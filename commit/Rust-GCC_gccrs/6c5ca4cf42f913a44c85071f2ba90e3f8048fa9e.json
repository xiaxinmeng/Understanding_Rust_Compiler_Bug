{"sha": "6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM1Y2E0Y2Y0MmY5MTNhNDRjODUwNzFmMmJhOTBlM2Y4MDQ4ZmE5ZQ==", "commit": {"author": {"name": "Pierre-Alexandre Bazin", "email": "bazin@adacore.com", "date": "2021-06-18T10:09:48Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-20T12:31:34Z"}, "message": "[Ada] SPARK proof of the Ada.Strings.Fixed library\n\ngcc/ada/\n\n\t* libgnat/a-strfix.adb (\"*\"): Added loop invariants and lemmas\n\tfor proof.\n\t(Delete): Added assertions for proof, and conditions to avoid\n\toverflow.\n\t(Head): Added loop invariant.\n\t(Insert): Same as Delete.\n\t(Move): Declared with SPARK_Mode Off.\n\t(Overwrite): Added assertions for proof, and conditions to avoid\n\toverflow.\n\t(Replace_Slice): Added assertions for proof, and conditions to\n\tavoid overflow.\n\t(Tail): Added loop invariant and avoided overflows.\n\t(Translate): Added loop invariants.\n\t(Trim): Ensured empty strings returned start at 1.\n\t* libgnat/a-strfix.ads (Index): Rewrote contract cases for\n\teasier proof.\n\t(Index_Non_Blank): Separated the null string case.\n\t(Count): Specified Mapping shouldn't be null.\n\t(Find_Token): Specified Source'First should be Positive when no\n\tFrom is given.\n\t(Translate): Specified Mapping shouldn't be null.\n\t(\"*\"): Rewrote postcondition for easier proof.\n\t* libgnat/a-strsea.adb (Belongs): Added postcondition.\n\t(Count): Rewrote loops and added loop invariants to avoid\n\toverflows.\n\t(Find_Token): Added loop invariants.\n\t(Index): Rewrote loops to avoid overflows and added loop\n\tinvariants for proof.\n\t(Index_Non_Blank): Added loop invariants.\n\t(Is_Identity): New function isolated without SPARK_Mode.\n\t* libgnat/a-strsea.ads: Fix starting comment as package is no\n\tlonger private.\n\t(Match): Declared ghost expression function Match.\n\t(Is_Identity): Described identity in the postcondition.\n\t(Index, Index_Non_Blank, Count, Find_Token): Added contract from\n\ta-strfix.ads.", "tree": {"sha": "53156b72c7516db8b164ead4e4f81e0f711e1ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53156b72c7516db8b164ead4e4f81e0f711e1ed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8582e5d07eabd78d7f73f3717993fe7b55dc7fc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8582e5d07eabd78d7f73f3717993fe7b55dc7fc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8582e5d07eabd78d7f73f3717993fe7b55dc7fc4"}], "stats": {"total": 1515, "additions": 1166, "deletions": 349}, "files": [{"sha": "00967c4bb9f0da6d94d6bf870cbf57073023bc2a", "filename": "gcc/ada/libgnat/a-strfix.adb", "status": "modified", "additions": 229, "deletions": 51, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strfix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strfix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strfix.adb?ref=6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "patch": "@@ -38,10 +38,17 @@\n --  bounds of function return results were also fixed, and use of & removed for\n --  efficiency reasons.\n \n+--  Ghost code, loop invariants and assertions in this unit are meant for\n+--  analysis only, not for run-time checking, as it would be too costly\n+--  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with Ada.Strings.Maps; use Ada.Strings.Maps;\n-with Ada.Strings.Search;\n \n-package body Ada.Strings.Fixed is\n+package body Ada.Strings.Fixed with SPARK_Mode is\n \n    ------------------------\n    -- Search Subprograms --\n@@ -146,9 +153,12 @@ package body Ada.Strings.Fixed is\n       Right : Character) return String\n    is\n    begin\n-      return Result : String (1 .. Left) do\n+      return Result : String (1 .. Left) with Relaxed_Initialization do\n          for J in Result'Range loop\n             Result (J) := Right;\n+            pragma Loop_Invariant\n+              (for all K in 1 .. J =>\n+                 Result (K)'Initialized and then Result (K) = Right);\n          end loop;\n       end return;\n    end \"*\";\n@@ -157,12 +167,82 @@ package body Ada.Strings.Fixed is\n      (Left  : Natural;\n       Right : String) return String\n    is\n-      Ptr    : Integer := 1;\n+      Ptr : Integer := 0;\n+\n+      --  Parts of the proof involving manipulations with the modulo operator\n+      --  are complicated for the prover and can't be done automatically in\n+      --  the global subprogram. That's why we isolate them in these two ghost\n+      --  lemmas.\n+\n+      procedure Lemma_Mod (K : Integer) with\n+        Ghost,\n+        Pre =>\n+          Right'Length /= 0\n+          and then Ptr mod Right'Length = 0\n+          and then Ptr in 0 .. Natural'Last - Right'Length\n+          and then K in Ptr .. Ptr + Right'Length - 1,\n+        Post => K mod Right'Length = K - Ptr;\n+      --  Lemma_Mod is applied to an index considered in Lemma_Split to prove\n+      --  that it has the right value modulo Right'Length.\n+\n+      procedure Lemma_Split (Result : String) with\n+        Ghost,\n+        Relaxed_Initialization => Result,\n+        Pre                    =>\n+          Right'Length /= 0\n+            and then Result'First = 1\n+            and then Result'Last >= 0\n+            and then Ptr mod Right'Length = 0\n+            and then Ptr in 0 .. Result'Last - Right'Length\n+            and then Result (Result'First .. Ptr + Right'Length)'Initialized\n+            and then Result (Ptr + 1 .. Ptr + Right'Length) = Right,\n+        Post                   =>\n+          (for all K in Ptr + 1 .. Ptr + Right'Length =>\n+            Result (K) = Right (Right'First + (K - 1) mod Right'Length));\n+      --  Lemma_Split is used after Result (Ptr + 1 .. Ptr + Right'Length) is\n+      --  updated to Right and concludes that the characters match for each\n+      --  index when taken modulo Right'Length, as the considered slice starts\n+      --  at index 1 modulo Right'Length.\n+\n+      ---------------\n+      -- Lemma_Mod --\n+      ---------------\n+\n+      procedure Lemma_Mod (K : Integer) is null;\n+\n+      -----------------\n+      -- Lemma_Split --\n+      -----------------\n+\n+      procedure Lemma_Split (Result : String) is\n+      begin\n+         for K in Ptr + 1 .. Ptr + Right'Length loop\n+            Lemma_Mod (K - 1);\n+            pragma Loop_Invariant\n+              (for all J in Ptr + 1 .. K =>\n+                 Result (J) = Right (Right'First + (J - 1) mod Right'Length));\n+         end loop;\n+      end Lemma_Split;\n+\n+   --  Start of processing for \"*\"\n+\n    begin\n-      return Result : String (1 .. Left * Right'Length) do\n+      if Right'Length = 0 then\n+         return \"\";\n+      end if;\n+\n+      return Result : String (1 .. Left * Right'Length)\n+        with Relaxed_Initialization\n+      do\n          for J in 1 .. Left loop\n-            Result (Ptr .. Ptr + Right'Length - 1) := Right;\n+            Result (Ptr + 1 .. Ptr + Right'Length) := Right;\n+            Lemma_Split (Result);\n             Ptr := Ptr + Right'Length;\n+            pragma Loop_Invariant (Ptr = J * Right'Length);\n+            pragma Loop_Invariant (Result (1 .. Ptr)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in 1 .. Ptr =>\n+                 Result (K) = Right (Right'First + (K - 1) mod Right'Length));\n          end loop;\n       end return;\n    end \"*\";\n@@ -176,7 +256,6 @@ package body Ada.Strings.Fixed is\n       From    : Positive;\n       Through : Natural) return String\n    is\n-      Front : Integer;\n    begin\n       if From > Through then\n          declare\n@@ -204,13 +283,22 @@ package body Ada.Strings.Fixed is\n          end if;\n \n       else\n-         Front := From - Source'First;\n-         return Result : String (1 .. Source'Length - (Through - From + 1)) do\n-            Result (1 .. Front) :=\n-              Source (Source'First .. From - 1);\n-            Result (Front + 1 .. Result'Last) :=\n-              Source (Through + 1 .. Source'Last);\n-         end return;\n+         declare\n+            Front : constant Integer := From - Source'First;\n+\n+         begin\n+            return Result : String (1 .. Source'Length - (Through - From + 1))\n+              with Relaxed_Initialization\n+            do\n+               Result (1 .. Front) :=\n+                 Source (Source'First .. From - 1);\n+\n+               if Through < Source'Last then\n+                  Result (Front + 1 .. Result'Last) :=\n+                    Source (Through + 1 .. Source'Last);\n+               end if;\n+            end return;\n+         end;\n       end if;\n    end Delete;\n \n@@ -219,8 +307,7 @@ package body Ada.Strings.Fixed is\n       From    : Positive;\n       Through : Natural;\n       Justify : Alignment := Left;\n-      Pad     : Character := Space)\n-   is\n+      Pad     : Character := Space) with SPARK_Mode => Off is\n    begin\n       Move (Source  => Delete (Source, From, Through),\n             Target  => Source,\n@@ -240,16 +327,19 @@ package body Ada.Strings.Fixed is\n       subtype Result_Type is String (1 .. Count);\n \n    begin\n-      if Count < Source'Length then\n+      if Count <= Source'Length then\n          return\n-           Result_Type (Source (Source'First .. Source'First + Count - 1));\n+           Result_Type (Source (Source'First .. Source'First + (Count - 1)));\n \n       else\n-         return Result : Result_Type do\n+         return Result : Result_Type with Relaxed_Initialization do\n             Result (1 .. Source'Length) := Source;\n \n             for J in Source'Length + 1 .. Count loop\n                Result (J) := Pad;\n+               pragma Loop_Invariant\n+                 (for all K in Source'Length + 1 .. J =>\n+                    Result (K)'Initialized and then Result (K) = Pad);\n             end loop;\n          end return;\n       end if;\n@@ -281,26 +371,39 @@ package body Ada.Strings.Fixed is\n       Front  : constant Integer := Before - Source'First;\n \n    begin\n-      if Before not in Source'First .. Source'Last + 1 then\n+      if Before - 1 not in Source'First - 1 .. Source'Last then\n          raise Index_Error;\n       end if;\n \n-      return Result : String (1 .. Source'Length + New_Item'Length) do\n+      return Result : String (1 .. Source'Length + New_Item'Length)\n+        with Relaxed_Initialization\n+      do\n          Result (1 .. Front) :=\n            Source (Source'First .. Before - 1);\n          Result (Front + 1 .. Front + New_Item'Length) :=\n            New_Item;\n-         Result (Front + New_Item'Length + 1 .. Result'Last) :=\n-           Source (Before .. Source'Last);\n+         pragma Assert\n+           (Result\n+              (Before - Source'First + 1\n+               .. Before - Source'First + New_Item'Length)\n+            = New_Item);\n+\n+         if Before <= Source'Last then\n+            Result (Front + New_Item'Length + 1 .. Result'Last) :=\n+              Source (Before .. Source'Last);\n+         end if;\n+\n+         pragma Assert\n+           (Result (1 .. Before - Source'First)\n+            = Source (Source'First .. Before - 1));\n       end return;\n    end Insert;\n \n    procedure Insert\n      (Source   : in out String;\n       Before   : Positive;\n       New_Item : String;\n-      Drop     : Truncation := Error)\n-   is\n+      Drop     : Truncation := Error) with SPARK_Mode => Off is\n    begin\n       Move (Source => Insert (Source, Before, New_Item),\n             Target => Source,\n@@ -316,7 +419,7 @@ package body Ada.Strings.Fixed is\n       Target  : out String;\n       Drop    : Truncation := Error;\n       Justify : Alignment  := Left;\n-      Pad     : Character  := Space)\n+      Pad     : Character  := Space) with SPARK_Mode => Off\n    is\n       Sfirst  : constant Integer := Source'First;\n       Slast   : constant Integer := Source'Last;\n@@ -423,7 +526,7 @@ package body Ada.Strings.Fixed is\n       Position : Positive;\n       New_Item : String) return String is\n    begin\n-      if Position not in Source'First .. Source'Last + 1 then\n+      if Position - 1 not in Source'First - 1 .. Source'Last then\n          raise Index_Error;\n       end if;\n \n@@ -434,11 +537,32 @@ package body Ada.Strings.Fixed is\n          Front         : constant Integer := Position - Source'First;\n \n       begin\n-         return Result : String (1 .. Result_Length) do\n+         return Result : String (1 .. Result_Length)\n+           with Relaxed_Initialization\n+         do\n             Result (1 .. Front) := Source (Source'First .. Position - 1);\n+            pragma Assert\n+              (Result (1 .. Position - Source'First)\n+               = Source (Source'First .. Position - 1));\n             Result (Front + 1 .. Front + New_Item'Length) := New_Item;\n-            Result (Front + New_Item'Length + 1 .. Result'Length) :=\n-              Source (Position + New_Item'Length .. Source'Last);\n+            pragma Assert\n+              (Result\n+                 (Position - Source'First + 1\n+                  .. Position - Source'First + New_Item'Length)\n+               = New_Item);\n+\n+            if Position <= Source'Last - New_Item'Length then\n+               Result (Front + New_Item'Length + 1 .. Result'Last) :=\n+                 Source (Position + New_Item'Length .. Source'Last);\n+            end if;\n+\n+            pragma Assert\n+              (if Position <= Source'Last - New_Item'Length\n+               then\n+                  Result\n+                 (Position - Source'First + New_Item'Length + 1\n+                  .. Result'Last)\n+               = Source (Position + New_Item'Length .. Source'Last));\n          end return;\n       end;\n    end Overwrite;\n@@ -447,8 +571,7 @@ package body Ada.Strings.Fixed is\n      (Source   : in out String;\n       Position : Positive;\n       New_Item : String;\n-      Drop     : Truncation := Right)\n-   is\n+      Drop     : Truncation := Right) with SPARK_Mode => Off is\n    begin\n       Move (Source => Overwrite (Source, Position, New_Item),\n             Target => Source,\n@@ -463,10 +586,9 @@ package body Ada.Strings.Fixed is\n      (Source : String;\n       Low    : Positive;\n       High   : Natural;\n-      By     : String) return String\n-   is\n+      By     : String) return String is\n    begin\n-      if Low > Source'Last + 1 or else High < Source'First - 1 then\n+      if Low - 1 > Source'Last or else High < Source'First - 1 then\n          raise Index_Error;\n       end if;\n \n@@ -484,11 +606,34 @@ package body Ada.Strings.Fixed is\n             --  Length of result\n \n          begin\n-            return Result : String (1 .. Result_Length) do\n+            return Result : String (1 .. Result_Length)\n+              with Relaxed_Initialization do\n                Result (1 .. Front_Len) := Source (Source'First .. Low - 1);\n+               pragma Assert\n+                 (Result (1 .. Integer'Max (0, Low - Source'First))\n+                  = Source (Source'First .. Low - 1));\n                Result (Front_Len + 1 .. Front_Len + By'Length) := By;\n-               Result (Front_Len + By'Length + 1 .. Result'Length) :=\n-                 Source (High + 1 .. Source'Last);\n+\n+               if High < Source'Last then\n+                  Result (Front_Len + By'Length + 1 .. Result'Last) :=\n+                    Source (High + 1 .. Source'Last);\n+               end if;\n+\n+               pragma Assert\n+                 (Result (1 .. Integer'Max (0, Low - Source'First))\n+                  = Source (Source'First .. Low - 1));\n+               pragma Assert\n+                 (Result\n+                    (Integer'Max (0, Low - Source'First) + 1\n+                     .. Integer'Max (0, Low - Source'First) + By'Length)\n+                  = By);\n+               pragma Assert\n+                 (if High < Source'Last\n+                  then\n+                     Result\n+                    (Integer'Max (0, Low - Source'First) + By'Length + 1\n+                     .. Result'Last)\n+                  = Source (High + 1 .. Source'Last));\n             end return;\n          end;\n       else\n@@ -503,8 +648,7 @@ package body Ada.Strings.Fixed is\n       By       : String;\n       Drop     : Truncation := Error;\n       Justify  : Alignment  := Left;\n-      Pad      : Character  := Space)\n-   is\n+      Pad      : Character  := Space) with SPARK_Mode => Off is\n    begin\n       Move (Replace_Slice (Source, Low, High, By), Source, Drop, Justify, Pad);\n    end Replace_Slice;\n@@ -521,18 +665,26 @@ package body Ada.Strings.Fixed is\n       subtype Result_Type is String (1 .. Count);\n \n    begin\n-      if Count < Source'Length then\n+      if Count = 0 then\n+         return \"\";\n+\n+      elsif Count < Source'Length then\n          return Result_Type (Source (Source'Last - Count + 1 .. Source'Last));\n \n       --  Pad on left\n \n       else\n-         return Result : Result_Type do\n+         return Result : Result_Type with Relaxed_Initialization do\n             for J in 1 .. Count - Source'Length loop\n                Result (J) := Pad;\n+               pragma Loop_Invariant\n+                 (for all K in 1 .. J =>\n+                    Result (K)'Initialized and then Result (K) = Pad);\n             end loop;\n \n-            Result (Count - Source'Length + 1 .. Count) := Source;\n+            if Source'Length /= 0 then\n+               Result (Count - Source'Length + 1 .. Count) := Source;\n+            end if;\n          end return;\n       end if;\n    end Tail;\n@@ -560,9 +712,18 @@ package body Ada.Strings.Fixed is\n       Mapping : Maps.Character_Mapping) return String\n    is\n    begin\n-      return Result : String (1 .. Source'Length) do\n+      return Result : String (1 .. Source'Length)\n+        with Relaxed_Initialization\n+      do\n          for J in Source'Range loop\n             Result (J - (Source'First - 1)) := Value (Mapping, Source (J));\n+            pragma Loop_Invariant\n+              (for all K in Source'First .. J =>\n+                 Result (K - (Source'First - 1))'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Source'First .. J =>\n+                 Result (K - (Source'First - 1)) =\n+                   Value (Mapping, Source (K)));\n          end loop;\n       end return;\n    end Translate;\n@@ -574,6 +735,9 @@ package body Ada.Strings.Fixed is\n    begin\n       for J in Source'Range loop\n          Source (J) := Value (Mapping, Source (J));\n+         pragma Loop_Invariant\n+           (for all K in Source'First .. J =>\n+              Source (K) = Value (Mapping, Source'Loop_Entry (K)));\n       end loop;\n    end Translate;\n \n@@ -583,9 +747,17 @@ package body Ada.Strings.Fixed is\n    is\n       pragma Unsuppress (Access_Check);\n    begin\n-      return Result : String (1 .. Source'Length) do\n+      return Result : String (1 .. Source'Length)\n+        with Relaxed_Initialization\n+      do\n          for J in Source'Range loop\n             Result (J - (Source'First - 1)) := Mapping.all (Source (J));\n+            pragma Loop_Invariant\n+              (for all K in Source'First .. J =>\n+                 Result (K - (Source'First - 1))'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Source'First .. J =>\n+                 Result (K - (Source'First - 1)) = Mapping (Source (K)));\n          end loop;\n       end return;\n    end Translate;\n@@ -598,6 +770,9 @@ package body Ada.Strings.Fixed is\n    begin\n       for J in Source'Range loop\n          Source (J) := Mapping.all (Source (J));\n+         pragma Loop_Invariant\n+           (for all K in Source'First .. J =>\n+              Source (K) = Mapping (Source'Loop_Entry (K)));\n       end loop;\n    end Translate;\n \n@@ -609,6 +784,9 @@ package body Ada.Strings.Fixed is\n      (Source : String;\n       Side   : Trim_End) return String\n    is\n+      Empty_String : constant String (1 .. 0) := \"\";\n+      --  Without declaring the empty string as a separate string starting\n+      --  at 1, SPARK provers have trouble proving the postcondition.\n    begin\n       case Side is\n          when Strings.Left =>\n@@ -618,7 +796,7 @@ package body Ada.Strings.Fixed is\n                --  All blanks case\n \n                if Low = 0 then\n-                  return \"\";\n+                  return Empty_String;\n                end if;\n \n                declare\n@@ -635,7 +813,7 @@ package body Ada.Strings.Fixed is\n                --  All blanks case\n \n                if High = 0 then\n-                  return \"\";\n+                  return Empty_String;\n                end if;\n \n                declare\n@@ -652,7 +830,7 @@ package body Ada.Strings.Fixed is\n                --  All blanks case\n \n                if Low = 0 then\n-                  return \"\";\n+                  return Empty_String;\n                end if;\n \n                declare\n@@ -695,8 +873,7 @@ package body Ada.Strings.Fixed is\n          return \"\";\n       end if;\n \n-      High :=\n-        Index (Source, Set => Right, Test  => Outside, Going => Backward);\n+      High := Index (Source, Set => Right, Test => Outside, Going => Backward);\n \n       --  Case where source comprises only characters in Right\n \n@@ -705,7 +882,8 @@ package body Ada.Strings.Fixed is\n       end if;\n \n       declare\n-         subtype Result_Type is String (1 .. High - Low + 1);\n+         Result_Length : constant Integer := High - Low + 1;\n+         subtype Result_Type is String (1 .. Result_Length);\n \n       begin\n          return Result_Type (Source (Low .. High));"}, {"sha": "1a5ee9473f239f60e3d6be2adf7f45d849b81def", "filename": "gcc/ada/libgnat/a-strfix.ads", "status": "modified", "additions": 197, "deletions": 179, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strfix.ads?ref=6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "patch": "@@ -13,14 +13,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Preconditions in this unit are meant for analysis only, not for run-time\n---  checking, so that the expected exceptions are raised. This is enforced by\n---  setting the corresponding assertion policy to Ignore.\n-\n-pragma Assertion_Policy (Pre => Ignore);\n-\n-with Ada.Strings.Maps;\n-\n --  The language-defined package Strings.Fixed provides string-handling\n --  subprograms for fixed-length strings; that is, for values of type\n --  Standard.String. Several of these subprograms are procedures that modify\n@@ -40,6 +32,20 @@ with Ada.Strings.Maps;\n --  these effects. Similar control is provided by the string transformation\n --  procedures.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n+with Ada.Strings.Maps; use type Ada.Strings.Maps.Character_Mapping_Function;\n+with Ada.Strings.Search;\n+\n package Ada.Strings.Fixed with SPARK_Mode is\n    pragma Preelaborate;\n \n@@ -108,56 +114,60 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    with\n-     Pre            =>\n-       Pattern'Length /= 0\n-         and then (if Source'Length /= 0 then From in Source'Range),\n+     Pre            => Pattern'Length > 0\n+       and then Mapping /= null\n+       and then (if Source'Length > 0 then From in Source'Range),\n \n      Post           => Index'Result in 0 | Source'Range,\n      Contract_Cases =>\n \n-        --  If no slice in the considered range of Source matches Pattern,\n-        --  then 0 is returned.\n+       --  If Source is the empty string, then 0 is returned\n \n-       ((for all J in Source'Range =>\n-           (if (if Going = Forward\n-                then J in From .. Source'Last - Pattern'Length + 1\n-                else J <= From - Pattern'Length + 1)\n-            then Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n-                 /= Pattern))\n+       (Source'Length = 0\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a valid index is returned\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n \n-        others\n+        Source'Length > 0\n+          and then\n+            (for some J in\n+              (if Going = Forward then From else Source'First)\n+               .. (if Going = Forward then Source'Last else From)\n+                - (Pattern'Length - 1) =>\n+              Ada.Strings.Search.Match (Source, Pattern, Mapping, J))\n         =>\n-\n           --  The result is in the considered range of Source\n \n-          (if Going = Forward\n-           then Index'Result in From .. Source'Last - Pattern'Length + 1\n-           else Index'Result in Source'First .. From - Pattern'Length + 1)\n+          Index'Result in\n+            (if Going = Forward then From else Source'First)\n+            .. (if Going = Forward then Source'Last else From)\n+             - (Pattern'Length - 1)\n \n             --  The slice beginning at the returned index matches Pattern\n \n             and then\n-              Translate (Source (Index'Result\n-                                 .. Index'Result - 1 + Pattern'Length),\n-                         Mapping)\n-              = Pattern\n+              Ada.Strings.Search.Match (Source, Pattern, Mapping, Index'Result)\n \n-            --  The result is the smallest or largest index which satisfies the\n-            --  matching, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  The result is the smallest or largest index which satisfies\n+            --  the matching, respectively when Going = Forward and Going =\n+            --  Backward.\n \n             and then\n               (for all J in Source'Range =>\n                  (if (if Going = Forward\n                       then J in From .. Index'Result - 1\n-                      else J - 1 in Index'Result .. From - Pattern'Length)\n-                  then Translate (Source (J .. J - 1 + Pattern'Length),\n-                                  Mapping)\n-                       /= Pattern))),\n+                      else J - 1 in Index'Result\n+                                    .. From - Pattern'Length)\n+                  then not (Ada.Strings.Search.Match\n+                              (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others\n+        =>\n+          Index'Result = 0),\n      Global         => null;\n    pragma Ada_05 (Index);\n \n@@ -168,56 +178,59 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    with\n-     Pre            =>\n-       Pattern'Length /= 0\n-         and then (if Source'Length /= 0 then From in Source'Range),\n+     Pre            => Pattern'Length > 0\n+       and then (if Source'Length > 0 then From in Source'Range),\n \n      Post           => Index'Result in 0 | Source'Range,\n      Contract_Cases =>\n \n-        --  If no slice in the considered range of Source matches Pattern,\n-        --  then 0 is returned.\n+       --  If Source is the empty string, then 0 is returned\n \n-       ((for all J in Source'Range =>\n-           (if (if Going = Forward\n-                then J in From .. Source'Last - Pattern'Length + 1\n-                else J <= From - Pattern'Length + 1)\n-            then Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n-                 /= Pattern))\n+       (Source'Length = 0\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a valid index is returned\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n \n-        others\n+        Source'Length > 0\n+          and then\n+            (for some J in\n+              (if Going = Forward then From else Source'First)\n+              .. (if Going = Forward then Source'Last else From)\n+               - (Pattern'Length - 1) =>\n+              Ada.Strings.Search.Match (Source, Pattern, Mapping, J))\n         =>\n-\n           --  The result is in the considered range of Source\n \n-          (if Going = Forward\n-           then Index'Result in From .. Source'Last - Pattern'Length + 1\n-           else Index'Result in Source'First .. From - Pattern'Length + 1)\n+          Index'Result in\n+            (if Going = Forward then From else Source'First)\n+            .. (if Going = Forward then Source'Last else From)\n+             - (Pattern'Length - 1)\n \n-            --  The slice beginning at the returned index matches Pattern\n+          --  The slice beginning at the returned index matches Pattern\n \n-            and then\n-              Translate (Source (Index'Result\n-                                 .. Index'Result - 1 + Pattern'Length),\n-                         Mapping)\n-              = Pattern\n+          and then\n+            Ada.Strings.Search.Match (Source, Pattern, Mapping, Index'Result)\n \n             --  The result is the smallest or largest index which satisfies the\n             --  matching, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  Going = Backward.\n \n             and then\n               (for all J in Source'Range =>\n                  (if (if Going = Forward\n                       then J in From .. Index'Result - 1\n-                      else J - 1 in Index'Result .. From - Pattern'Length)\n-                  then Translate (Source (J .. J - 1 + Pattern'Length),\n-                                  Mapping)\n-                       /= Pattern))),\n+                      else J - 1 in Index'Result\n+                                    .. From - Pattern'Length)\n+                  then not (Ada.Strings.Search.Match\n+                              (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others\n+        =>\n+          Index'Result = 0),\n      Global         => null;\n    pragma Ada_05 (Index);\n \n@@ -245,47 +258,48 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      Post           => Index'Result in 0 | Source'Range,\n      Contract_Cases =>\n \n-        --  If Source is empty, or if no slice of Source matches Pattern, then\n-        --  0 is returned.\n+       --  If Source is the empty string, then 0 is returned\n \n        (Source'Length = 0\n-          or else\n-            (for all J in Source'First .. Source'Last - Pattern'Length + 1 =>\n-               Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n-               /= Pattern)\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a valid index is returned\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n \n-        others\n+        Source'Length > 0\n+          and then\n+            (for some J in\n+              Source'First .. Source'Last - (Pattern'Length - 1) =>\n+                Ada.Strings.Search.Match (Source, Pattern, Mapping, J))\n         =>\n-\n           --  The result is in the considered range of Source\n \n-          Index'Result in Source'First .. Source'Last - Pattern'Length + 1\n+          Index'Result in Source'First .. Source'Last - (Pattern'Length - 1)\n \n             --  The slice beginning at the returned index matches Pattern\n \n             and then\n-              Translate (Source (Index'Result\n-                                 .. Index'Result - 1 + Pattern'Length),\n-                         Mapping)\n-              = Pattern\n+              Ada.Strings.Search.Match (Source, Pattern, Mapping, Index'Result)\n \n-            --  The result is the smallest or largest index which satisfies the\n-            --  matching, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  The result is the smallest or largest index which satisfies\n+            --  the matching, respectively when Going = Forward and Going =\n+            --  Backward.\n \n             and then\n               (for all J in Source'Range =>\n                  (if (if Going = Forward\n                       then J <= Index'Result - 1\n                       else J - 1 in Index'Result\n                                     .. Source'Last - Pattern'Length)\n-                  then Translate (Source (J .. J - 1 + Pattern'Length),\n-                                  Mapping)\n-                       /= Pattern))),\n+                  then not (Ada.Strings.Search.Match\n+                              (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others\n+        =>\n+          Index'Result = 0),\n      Global         => null;\n \n    function Index\n@@ -294,52 +308,53 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    with\n-     Pre            => Pattern'Length > 0,\n+     Pre            => Pattern'Length > 0 and then Mapping /= null,\n \n      Post           => Index'Result in 0 | Source'Range,\n      Contract_Cases =>\n \n-        --  If Source is empty, or if no slice of Source matches Pattern, then\n-        --  0 is returned.\n+       --  If Source is the empty string, then 0 is returned\n \n        (Source'Length = 0\n-          or else\n-            (for all J in Source'First .. Source'Last - Pattern'Length + 1 =>\n-               Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n-               /= Pattern)\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, a valid index is returned\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n \n-        others\n+        Source'Length > 0\n+          and then\n+            (for some J in\n+              Source'First .. Source'Last - (Pattern'Length - 1) =>\n+                Ada.Strings.Search.Match (Source, Pattern, Mapping, J))\n         =>\n-\n           --  The result is in the considered range of Source\n \n-          Index'Result in Source'First .. Source'Last - Pattern'Length + 1\n+          Index'Result in Source'First .. Source'Last - (Pattern'Length - 1)\n \n-            --  The slice beginning at the returned index matches Pattern\n+          --  The slice beginning at the returned index matches Pattern\n \n-            and then\n-              Translate (Source (Index'Result\n-                                 .. Index'Result - 1 + Pattern'Length),\n-                         Mapping)\n-              = Pattern\n+          and then\n+            Ada.Strings.Search.Match (Source, Pattern, Mapping, Index'Result)\n \n-            --  The result is the smallest or largest index which satisfies the\n-            --  matching, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  The result is the smallest or largest index which satisfies\n+            --  the matching, respectively when Going = Forward and Going =\n+            --  Backward.\n \n             and then\n               (for all J in Source'Range =>\n                  (if (if Going = Forward\n                       then J <= Index'Result - 1\n                       else J - 1 in Index'Result\n                                     .. Source'Last - Pattern'Length)\n-                  then Translate (Source (J .. J - 1 + Pattern'Length),\n-                                  Mapping)\n-                       /= Pattern))),\n+                  then not (Ada.Strings.Search.Match\n+                              (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others\n+        =>\n+          Index'Result = 0),\n      Global         => null;\n \n    --  If Going = Forward, returns:\n@@ -383,9 +398,9 @@ package Ada.Strings.Fixed with SPARK_Mode is\n               (Test = Inside)\n               = Ada.Strings.Maps.Is_In (Source (Index'Result), Set)\n \n-            --  The result is the smallest or largest index which satisfies the\n-            --  property, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  The result is the smallest or largest index which satisfies\n+            --  the property, respectively when Going = Forward and Going =\n+            --  Backward.\n \n             and then\n               (for all J in Source'Range =>\n@@ -402,22 +417,23 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Test    : Membership := Inside;\n       Going   : Direction := Forward) return Natural\n    with\n-     Pre            => (if Source'Length /= 0 then From in Source'Range),\n-\n+     Pre            => (if Source'Length > 0 then From in Source'Range),\n      Post           => Index'Result in 0 | Source'Range,\n      Contract_Cases =>\n \n-        --  If no character in the considered slice of Source satisfies the\n-        --  property Test on Set, then 0 is returned.\n+        --  If Source is the empty string, or no character of the considered\n+        --  slice of Source satisfies the property Test on Set, then 0 is\n+        --  returned.\n \n-       ((for all I in Source'Range =>\n-           (if I = From\n-                 or else (I > From) = (Going = Forward)\n-            then (Test = Inside) /= Ada.Strings.Maps.Is_In (Source (I), Set)))\n+        (Source'Length = 0\n+          or else\n+            (for all J in Source'Range =>\n+               (if J = From or else (J > From) = (Going = Forward) then\n+                  (Test = Inside) /= Ada.Strings.Maps.Is_In (Source (J), Set)))\n         =>\n           Index'Result = 0,\n \n-        --  Otherwise, an index in the range of Source is returned\n+        --  Otherwise, a index in the considered range of Source is returned\n \n         others\n         =>\n@@ -426,7 +442,8 @@ package Ada.Strings.Fixed with SPARK_Mode is\n \n           Index'Result in Source'Range\n             and then (Index'Result = From\n-                        or else (Index'Result > From) = (Going = Forward))\n+                       or else\n+                         (Index'Result > From) = (Going = Forward))\n \n             --  The character at the returned index satisfies the property\n             --  Test on Set.\n@@ -435,19 +452,18 @@ package Ada.Strings.Fixed with SPARK_Mode is\n               (Test = Inside)\n               = Ada.Strings.Maps.Is_In (Source (Index'Result), Set)\n \n-            --  The result is the smallest or largest index which satisfies the\n-            --  property, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  The result is the smallest or largest index which satisfies\n+            --  the property, respectively when Going = Forward and Going =\n+            --  Backward.\n \n             and then\n               (for all J in Source'Range =>\n                  (if J /= Index'Result\n-                       and then (J < Index'Result) = (Going = Forward)\n-                       and then (J = From\n-                                   or else (J > From) = (Going = Forward))\n-                  then\n-                    (Test = Inside)\n-                    /= Ada.Strings.Maps.Is_In (Source (J), Set)))),\n+                    and then (J < Index'Result) = (Going = Forward)\n+                    and then (J = From\n+                                or else (J > From) = (Going = Forward))\n+                  then (Test = Inside)\n+                       /= Ada.Strings.Maps.Is_In (Source (J), Set)))),\n      Global         => null;\n    pragma Ada_05 (Index);\n    --  Index searches for the first or last occurrence of any of a set of\n@@ -469,12 +485,14 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      Post           => Index_Non_Blank'Result in 0 | Source'Range,\n      Contract_Cases =>\n \n-        --  If all characters in the considered slice of Source are Space\n-        --  characters, then 0 is returned.\n+        --  If Source is the empty string, or all characters in the considered\n+        --  slice of Source are Space characters, then 0 is returned.\n \n-       ((for all J in Source'Range =>\n-           (if J = From or else (J > From) = (Going = Forward)\n-            then Source (J) = ' '))\n+        (Source'Length = 0\n+          or else\n+            (for all J in Source'Range =>\n+               (if J = From or else (J > From) = (Going = Forward) then\n+                  Source (J) = ' '))\n         =>\n           Index_Non_Blank'Result = 0,\n \n@@ -496,7 +514,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n \n             --  The result is the smallest or largest index which is not a\n             --  Space character, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  Going = Backward.\n \n             and then\n               (for all J in Source'Range =>\n@@ -535,8 +553,8 @@ package Ada.Strings.Fixed with SPARK_Mode is\n             and then Source (Index_Non_Blank'Result) /= ' '\n \n             --  The result is the smallest or largest index which is not a\n-            --  Space character, respectively when Going = Forward and\n-            --  Going = Backwards.\n+            --  Space character, respectively when Going = Forward and Going\n+            --  = Backward.\n \n             and then\n               (for all J in Source'Range =>\n@@ -560,7 +578,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Pattern : String;\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    with\n-     Pre    => Pattern'Length /= 0,\n+     Pre    => Pattern'Length /= 0 and then Mapping /= null,\n      Global => null;\n \n    --  Returns the maximum number of nonoverlapping slices of Source that match\n@@ -646,6 +664,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       First  : out Positive;\n       Last   : out Natural)\n    with\n+     Pre            => Source'First > 0,\n      Contract_Cases =>\n \n         --  If Source is the empty string, or if no character of Source\n@@ -701,6 +720,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      (Source  : String;\n       Mapping : Maps.Character_Mapping_Function) return String\n    with\n+     Pre    => Mapping /= null,\n      Post   =>\n \n        --  Lower bound of the returned string is 1\n@@ -751,10 +771,11 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      (Source  : in out String;\n       Mapping : Maps.Character_Mapping_Function)\n    with\n+     Pre    => Mapping /= null,\n      Post   =>\n \n-       --  Each character in Source after the call is the translation of\n-       --  the character at the same position before the call, through Mapping.\n+       --  Each character in Source after the call is the translation of the\n+       --  character at the same position before the call, through Mapping.\n \n        (for all J in Source'Range => Source (J) = Mapping (Source'Old (J))),\n      Global => null;\n@@ -765,8 +786,8 @@ package Ada.Strings.Fixed with SPARK_Mode is\n    with\n      Post   =>\n \n-       --  Each character in Source after the call is the translation of\n-       --  the character at the same position before the call, through Mapping.\n+       --  Each character in Source after the call is the translation of the\n+       --  character at the same position before the call, through Mapping.\n \n        (for all J in Source'Range =>\n           Source (J) = Ada.Strings.Maps.Value (Mapping, Source'Old (J))),\n@@ -778,32 +799,6 @@ package Ada.Strings.Fixed with SPARK_Mode is\n    -- String Transformation Subprograms --\n    ---------------------------------------\n \n-   procedure Replace_Slice\n-     (Source  : in out String;\n-      Low     : Positive;\n-      High    : Natural;\n-      By      : String;\n-      Drop    : Truncation := Error;\n-      Justify : Alignment  := Left;\n-      Pad     : Character  := Space)\n-   with\n-     Pre    =>\n-\n-       --  Incomplete contract\n-\n-       Low - 1 <= Source'Last\n-         and then High >= Source'First - 1,\n-     Global => null;\n-   --  If Low > Source'Last+1, or High < Source'First - 1, then Index_Error is\n-   --  propagated. Otherwise:\n-   --\n-   --  * If High >= Low, then the returned string comprises\n-   --    Source (Source'First .. Low - 1)\n-   --    & By & Source(High + 1 .. Source'Last), but with lower bound 1.\n-   --\n-   --  * If High < Low, then the returned string is\n-   --    Insert (Source, Before => Low, New_Item => By).\n-\n    function Replace_Slice\n      (Source : String;\n       Low    : Positive;\n@@ -834,19 +829,19 @@ package Ada.Strings.Fixed with SPARK_Mode is\n           --  Length of the returned string\n \n           Replace_Slice'Result'Length\n-          = Natural'Max (0, Low - Source'First)\n+          = Integer'Max (0, Low - Source'First)\n             + By'Length\n-            + Natural'Max (Source'Last - High, 0)\n+            + Integer'Max (Source'Last - High, 0)\n \n             --  Elements starting at Low are replaced by elements of By\n \n             and then\n-              Replace_Slice'Result (1 .. Natural'Max (0, Low - Source'First))\n+              Replace_Slice'Result (1 .. Integer'Max (0, Low - Source'First))\n               = Source (Source'First .. Low - 1)\n             and then\n               Replace_Slice'Result\n-                (Natural'Max (0, Low - Source'First) + 1\n-                 .. Natural'Max (0, Low - Source'First) + By'Length)\n+                (Integer'Max (0, Low - Source'First) + 1\n+                 .. Integer'Max (0, Low - Source'First) + By'Length)\n               = By\n \n             --  When there are remaining characters after the replaced slice,\n@@ -856,7 +851,7 @@ package Ada.Strings.Fixed with SPARK_Mode is\n               (if High < Source'Last\n                then\n                  Replace_Slice'Result\n-                   (Natural'Max (0, Low - Source'First) + By'Length + 1\n+                   (Integer'Max (0, Low - Source'First) + By'Length + 1\n                     .. Replace_Slice'Result'Last)\n                  = Source (High + 1 .. Source'Last)),\n \n@@ -890,6 +885,30 @@ package Ada.Strings.Fixed with SPARK_Mode is\n                    .. Replace_Slice'Result'Last)\n                 = Source (Low .. Source'Last))),\n      Global         => null;\n+   --  If Low > Source'Last + 1, or High < Source'First - 1, then Index_Error\n+   --  is propagated. Otherwise:\n+   --\n+   --  * If High >= Low, then the returned string comprises\n+   --    Source (Source'First .. Low - 1)\n+   --    & By & Source(High + 1 .. Source'Last), but with lower bound 1.\n+   --\n+   --  * If High < Low, then the returned string is\n+   --    Insert (Source, Before => Low, New_Item => By).\n+\n+   procedure Replace_Slice\n+     (Source  : in out String;\n+      Low     : Positive;\n+      High    : Natural;\n+      By      : String;\n+      Drop    : Truncation := Error;\n+      Justify : Alignment  := Left;\n+      Pad     : Character  := Space)\n+   with\n+     Pre    => Low - 1 <= Source'Last,\n+\n+   --  Incomplete contract\n+\n+     Global => null;\n    --  Equivalent to:\n    --\n    --    Move (Replace_Slice (Source, Low, High, By),\n@@ -929,15 +948,15 @@ package Ada.Strings.Fixed with SPARK_Mode is\n          --  are appended to the returned string.\n \n          and then\n-           (if Before - 1 < Source'Last\n+           (if Before <= Source'Last\n             then\n               Insert'Result\n                 (Before - Source'First + New_Item'Length + 1\n                  .. Insert'Result'Last)\n               = Source (Before .. Source'Last)),\n      Global => null;\n    --  Propagates Index_Error if Before is not in\n-   --  Source'First .. Source'Last+1; otherwise, returns\n+   --  Source'First .. Source'Last + 1; otherwise, returns\n    --  Source (Source'First .. Before - 1)\n    --  & New_Item & Source(Before..Source'Last), but with lower bound 1.\n \n@@ -1384,9 +1403,8 @@ package Ada.Strings.Fixed with SPARK_Mode is\n          --  Content of the string is Right concatenated with itself Left times\n \n          and then\n-           (for all J in 0 .. Left - 1 =>\n-              \"*\"'Result (J * Right'Length + 1 .. (J + 1) * Right'Length)\n-              = Right),\n+           (for all K in \"*\"'Result'Range =>\n+              \"*\"'Result (K) = Right (Right'First + (K - 1) mod Right'Length)),\n      Global => null;\n \n    --  These functions replicate a character or string a specified number of"}, {"sha": "243c92c869076f1cf28eb92550e94201778a9ecd", "filename": "gcc/ada/libgnat/a-strsea.adb", "status": "modified", "additions": 218, "deletions": 101, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strsea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strsea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strsea.adb?ref=6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "patch": "@@ -35,10 +35,18 @@\n --  case of identity mappings for Count and Index, and also Index_Non_Blank\n --  is specialized (rather than using the general Index routine).\n \n+--  Ghost code, loop invariants and assertions in this unit are meant for\n+--  analysis only, not for run-time checking, as it would be too costly\n+--  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n with Ada.Strings.Maps; use Ada.Strings.Maps;\n with System;           use System;\n \n-package body Ada.Strings.Search is\n+package body Ada.Strings.Search with SPARK_Mode is\n \n    -----------------------\n    -- Local Subprograms --\n@@ -61,13 +69,9 @@ package body Ada.Strings.Search is\n       Set     : Maps.Character_Set;\n       Test    : Membership) return Boolean\n    is\n-   begin\n-      if Test = Inside then\n-         return Is_In (Element, Set);\n-      else\n-         return not Is_In (Element, Set);\n-      end if;\n-   end Belongs;\n+      (if Test = Inside then\n+          Is_In (Element, Set)\n+      else not (Is_In (Element, Set)));\n \n    -----------\n    -- Count --\n@@ -81,47 +85,63 @@ package body Ada.Strings.Search is\n       PL1 : constant Integer := Pattern'Length - 1;\n       Num : Natural;\n       Ind : Natural;\n-      Cur : Natural;\n \n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n       end if;\n \n+      --  Isolating the null string case to ensure Source'First, Source'Last in\n+      --  Positive.\n+\n+      if Source = \"\" then\n+         return 0;\n+      end if;\n+\n       Num := 0;\n-      Ind := Source'First;\n+      Ind := Source'First - 1;\n \n       --  Unmapped case\n \n-      if Mapping'Address = Maps.Identity'Address then\n-         while Ind <= Source'Last - PL1 loop\n+      if Is_Identity (Mapping) then\n+         while Ind < Source'Last - PL1 loop\n+            Ind := Ind + 1;\n             if Pattern = Source (Ind .. Ind + PL1) then\n                Num := Num + 1;\n-               Ind := Ind + Pattern'Length;\n-            else\n-               Ind := Ind + 1;\n+               Ind := Ind + PL1;\n             end if;\n+\n+            pragma Loop_Invariant (Num <= Ind - (Source'First - 1));\n+            pragma Loop_Invariant (Ind >= Source'First);\n          end loop;\n \n       --  Mapped case\n \n       else\n-         while Ind <= Source'Last - PL1 loop\n-            Cur := Ind;\n+         while Ind < Source'Last - PL1 loop\n+            Ind := Ind + 1;\n             for K in Pattern'Range loop\n-               if Pattern (K) /= Value (Mapping, Source (Cur)) then\n-                  Ind := Ind + 1;\n+               if Pattern (K) /= Value (Mapping,\n+                 Source (Ind + (K - Pattern'First)))\n+               then\n+                  pragma Assert (not (Match (Source, Pattern, Mapping, Ind)));\n                   goto Cont;\n-               else\n-                  Cur := Cur + 1;\n                end if;\n+\n+               pragma Loop_Invariant\n+                 (for all J in Pattern'First .. K =>\n+                    Pattern (J) = Value (Mapping,\n+                      Source (Ind + (J - Pattern'First))));\n             end loop;\n \n+            pragma Assert (Match (Source, Pattern, Mapping, Ind));\n             Num := Num + 1;\n-            Ind := Ind + Pattern'Length;\n+            Ind := Ind + PL1;\n \n-         <<Cont>>\n+            <<Cont>>\n             null;\n+            pragma Loop_Invariant (Num <= Ind - (Source'First - 1));\n+            pragma Loop_Invariant (Ind >= Source'First);\n          end loop;\n       end if;\n \n@@ -138,37 +158,48 @@ package body Ada.Strings.Search is\n       PL1 : constant Integer := Pattern'Length - 1;\n       Num : Natural;\n       Ind : Natural;\n-      Cur : Natural;\n \n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n       end if;\n \n+      --  Isolating the null string case to ensure Source'First, Source'Last in\n+      --  Positive.\n+\n+      if Source = \"\" then\n+         return 0;\n+      end if;\n+\n       --  Check for null pointer in case checks are off\n \n       if Mapping = null then\n          raise Constraint_Error;\n       end if;\n \n       Num := 0;\n-      Ind := Source'First;\n-      while Ind <= Source'Last - PL1 loop\n-         Cur := Ind;\n+      Ind := Source'First - 1;\n+      while Ind < Source'Last - PL1 loop\n+         Ind := Ind + 1;\n          for K in Pattern'Range loop\n-            if Pattern (K) /= Mapping (Source (Cur)) then\n-               Ind := Ind + 1;\n+            if Pattern (K) /= Mapping (Source (Ind + (K - Pattern'First))) then\n+               pragma Assert (not (Match (Source, Pattern, Mapping, Ind)));\n                goto Cont;\n-            else\n-               Cur := Cur + 1;\n             end if;\n+\n+            pragma Loop_Invariant\n+              (for all J in Pattern'First .. K =>\n+                 Pattern (J) = Mapping (Source (Ind + (J - Pattern'First))));\n          end loop;\n \n+         pragma Assert (Match (Source, Pattern, Mapping, Ind));\n          Num := Num + 1;\n-         Ind := Ind + Pattern'Length;\n+         Ind := Ind + PL1;\n \n       <<Cont>>\n          null;\n+         pragma Loop_Invariant (Num <= Ind - (Source'First - 1));\n+         pragma Loop_Invariant (Ind >= Source'First);\n       end loop;\n \n       return Num;\n@@ -182,6 +213,7 @@ package body Ada.Strings.Search is\n \n    begin\n       for J in Source'Range loop\n+         pragma Loop_Invariant (N <= J - Source'First);\n          if Is_In (Source (J), Set) then\n             N := N + 1;\n          end if;\n@@ -217,19 +249,29 @@ package body Ada.Strings.Search is\n          if Belongs (Source (J), Set, Test) then\n             First := J;\n \n-            for K in J + 1 .. Source'Last loop\n-               if not Belongs (Source (K), Set, Test) then\n-                  Last := K - 1;\n-                  return;\n-               end if;\n-            end loop;\n+            if J < Source'Last then\n+               for K in J + 1 .. Source'Last loop\n+                  if not Belongs (Source (K), Set, Test) then\n+                     Last := K - 1;\n+                     return;\n+                  end if;\n+\n+                  pragma Loop_Invariant\n+                    (for all L in J .. K =>\n+                       Belongs (Source (L), Set, Test));\n+               end loop;\n+            end if;\n \n             --  Here if J indexes first char of token, and all chars after J\n             --  are in the token.\n \n             Last := Source'Last;\n             return;\n          end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Integer'Max (From, Source'First) .. J =>\n+                not (Belongs (Source (K), Set, Test)));\n       end loop;\n \n       --  Here if no token found\n@@ -250,19 +292,29 @@ package body Ada.Strings.Search is\n          if Belongs (Source (J), Set, Test) then\n             First := J;\n \n-            for K in J + 1 .. Source'Last loop\n-               if not Belongs (Source (K), Set, Test) then\n-                  Last := K - 1;\n-                  return;\n-               end if;\n-            end loop;\n+            if J < Source'Last then\n+               for K in J + 1 .. Source'Last loop\n+                  if not Belongs (Source (K), Set, Test) then\n+                     Last := K - 1;\n+                     return;\n+                  end if;\n+\n+                  pragma Loop_Invariant\n+                    (for all L in J .. K =>\n+                       Belongs (Source (L), Set, Test));\n+               end loop;\n+            end if;\n \n             --  Here if J indexes first char of token, and all chars after J\n             --  are in the token.\n \n             Last := Source'Last;\n             return;\n          end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Source'First .. J =>\n+              not (Belongs (Source (K), Set, Test)));\n       end loop;\n \n       --  Here if no token found\n@@ -292,53 +344,61 @@ package body Ada.Strings.Search is\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    is\n       PL1 : constant Integer := Pattern'Length - 1;\n-      Cur : Natural;\n-\n-      Ind : Integer;\n-      --  Index for start of match check. This can be negative if the pattern\n-      --  length is greater than the string length, which is why this variable\n-      --  is Integer instead of Natural. In this case, the search loops do not\n-      --  execute at all, so this Ind value is never used.\n \n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n       end if;\n \n+      --  If Pattern is longer than Source, it can't be found\n+\n+      if Pattern'Length > Source'Length then\n+         return 0;\n+      end if;\n+\n       --  Forwards case\n \n       if Going = Forward then\n-         Ind := Source'First;\n \n          --  Unmapped forward case\n \n-         if Mapping'Address = Maps.Identity'Address then\n-            for J in 1 .. Source'Length - PL1 loop\n+         if Is_Identity (Mapping) then\n+            for Ind in Source'First .. Source'Last - PL1 loop\n                if Pattern = Source (Ind .. Ind + PL1) then\n+                  pragma Assert (Match (Source, Pattern, Mapping, Ind));\n                   return Ind;\n-               else\n-                  Ind := Ind + 1;\n                end if;\n+\n+               pragma Loop_Invariant\n+                 (for all J in Source'First .. Ind =>\n+                    not (Match (Source, Pattern, Mapping, J)));\n             end loop;\n \n          --  Mapped forward case\n \n          else\n-            for J in 1 .. Source'Length - PL1 loop\n-               Cur := Ind;\n-\n+            for Ind in Source'First .. Source'Last - PL1 loop\n                for K in Pattern'Range loop\n-                  if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                  if Pattern (K) /= Value (Mapping,\n+                    Source (Ind + (K - Pattern'First)))\n+                  then\n                      goto Cont1;\n-                  else\n-                     Cur := Cur + 1;\n                   end if;\n+\n+                  pragma Loop_Invariant\n+                    (for all J in Pattern'First .. K =>\n+                       Pattern (J) = Value (Mapping,\n+                         Source (Ind + (J - Pattern'First))));\n                end loop;\n \n+               pragma Assert (Match (Source, Pattern, Mapping, Ind));\n                return Ind;\n \n-            <<Cont1>>\n-               Ind := Ind + 1;\n+               <<Cont1>>\n+               pragma Loop_Invariant\n+                 (for all J in Source'First .. Ind =>\n+                    not (Match (Source, Pattern, Mapping, J)));\n+               null;\n             end loop;\n          end if;\n \n@@ -347,35 +407,43 @@ package body Ada.Strings.Search is\n       else\n          --  Unmapped backward case\n \n-         Ind := Source'Last - PL1;\n-\n-         if Mapping'Address = Maps.Identity'Address then\n-            for J in reverse 1 .. Source'Length - PL1 loop\n+         if Is_Identity (Mapping) then\n+            for Ind in reverse Source'First .. Source'Last - PL1 loop\n                if Pattern = Source (Ind .. Ind + PL1) then\n+                  pragma Assert (Match (Source, Pattern, Mapping, Ind));\n                   return Ind;\n-               else\n-                  Ind := Ind - 1;\n                end if;\n+\n+               pragma Loop_Invariant\n+                 (for all J in Ind .. Source'Last - PL1 =>\n+                    not (Match (Source, Pattern, Mapping, J)));\n             end loop;\n \n          --  Mapped backward case\n \n          else\n-            for J in reverse 1 .. Source'Length - PL1 loop\n-               Cur := Ind;\n-\n+            for Ind in reverse Source'First .. Source'Last - PL1 loop\n                for K in Pattern'Range loop\n-                  if Pattern (K) /= Value (Mapping, Source (Cur)) then\n+                  if Pattern (K) /= Value (Mapping,\n+                    Source (Ind + (K - Pattern'First)))\n+                  then\n                      goto Cont2;\n-                  else\n-                     Cur := Cur + 1;\n                   end if;\n+\n+                  pragma Loop_Invariant\n+                    (for all J in Pattern'First .. K =>\n+                       Pattern (J) = Value (Mapping,\n+                         Source (Ind + (J - Pattern'First))));\n                end loop;\n \n+               pragma Assert (Match (Source, Pattern, Mapping, Ind));\n                return Ind;\n \n-            <<Cont2>>\n-               Ind := Ind - 1;\n+               <<Cont2>>\n+               pragma Loop_Invariant\n+                 (for all J in Ind .. Source'Last - PL1 =>\n+                    not (Match (Source, Pattern, Mapping, J)));\n+               null;\n             end loop;\n          end if;\n       end if;\n@@ -393,9 +461,6 @@ package body Ada.Strings.Search is\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    is\n       PL1 : constant Integer := Pattern'Length - 1;\n-      Ind : Natural;\n-      Cur : Natural;\n-\n    begin\n       if Pattern = \"\" then\n          raise Pattern_Error;\n@@ -416,43 +481,52 @@ package body Ada.Strings.Search is\n       --  Forwards case\n \n       if Going = Forward then\n-         Ind := Source'First;\n-         for J in 1 .. Source'Length - PL1 loop\n-            Cur := Ind;\n-\n+         for Ind in Source'First .. Source'Last - PL1 loop\n             for K in Pattern'Range loop\n-               if Pattern (K) /= Mapping.all (Source (Cur)) then\n+               if Pattern (K) /= Mapping.all\n+                 (Source (Ind + (K - Pattern'First)))\n+               then\n                   goto Cont1;\n-               else\n-                  Cur := Cur + 1;\n                end if;\n+\n+               pragma Loop_Invariant\n+                 (for all J in Pattern'First .. K =>\n+                   Pattern (J) = Mapping (Source (Ind + (J - Pattern'First))));\n             end loop;\n \n+            pragma Assert (Match (Source, Pattern, Mapping, Ind));\n             return Ind;\n \n-         <<Cont1>>\n-            Ind := Ind + 1;\n+            <<Cont1>>\n+            pragma Loop_Invariant\n+              (for all J in Source'First .. Ind =>\n+                 not (Match (Source, Pattern, Mapping, J)));\n+            null;\n          end loop;\n \n       --  Backwards case\n \n       else\n-         Ind := Source'Last - PL1;\n-         for J in reverse 1 .. Source'Length - PL1 loop\n-            Cur := Ind;\n-\n+         for Ind in reverse Source'First .. Source'Last - PL1 loop\n             for K in Pattern'Range loop\n-               if Pattern (K) /= Mapping.all (Source (Cur)) then\n+               if Pattern (K) /= Mapping.all\n+                 (Source (Ind + (K - Pattern'First)))\n+               then\n                   goto Cont2;\n-               else\n-                  Cur := Cur + 1;\n                end if;\n+\n+               pragma Loop_Invariant\n+                 (for all J in Pattern'First .. K =>\n+                   Pattern (J) = Mapping (Source (Ind + (J - Pattern'First))));\n             end loop;\n \n             return Ind;\n \n-         <<Cont2>>\n-            Ind := Ind - 1;\n+            <<Cont2>>\n+            pragma Loop_Invariant\n+              (for all J in Ind .. (Source'Last - PL1) =>\n+                not (Match (Source, Pattern, Mapping, J)));\n+            null;\n          end loop;\n       end if;\n \n@@ -476,6 +550,10 @@ package body Ada.Strings.Search is\n             if Belongs (Source (J), Set, Test) then\n                return J;\n             end if;\n+\n+            pragma Loop_Invariant\n+              (for all C of Source (Source'First .. J) =>\n+                   not (Belongs (C, Set, Test)));\n          end loop;\n \n       --  Backwards case\n@@ -485,6 +563,10 @@ package body Ada.Strings.Search is\n             if Belongs (Source (J), Set, Test) then\n                return J;\n             end if;\n+\n+            pragma Loop_Invariant\n+              (for all C of Source (J .. Source'Last) =>\n+                   not (Belongs (C, Set, Test)));\n          end loop;\n       end if;\n \n@@ -500,6 +582,8 @@ package body Ada.Strings.Search is\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    is\n+      Result : Natural;\n+      PL1    : constant Integer := Pattern'Length - 1;\n    begin\n \n       --  AI05-056: If source is empty result is always zero\n@@ -512,17 +596,29 @@ package body Ada.Strings.Search is\n             raise Index_Error;\n          end if;\n \n-         return\n+         Result :=\n            Index (Source (From .. Source'Last), Pattern, Forward, Mapping);\n+         pragma Assert\n+           (if (for some J in From .. Source'Last - PL1 =>\n+                 Match (Source, Pattern, Mapping, J))\n+            then Result in From .. Source'Last - PL1\n+            else Result = 0);\n \n       else\n          if From > Source'Last then\n             raise Index_Error;\n          end if;\n \n-         return\n+         Result :=\n            Index (Source (Source'First .. From), Pattern, Backward, Mapping);\n+         pragma Assert\n+           (if (for some J in Source'First .. From - PL1 =>\n+                  Match (Source, Pattern, Mapping, J))\n+            then Result in Source'First .. From - PL1\n+            else Result = 0);\n       end if;\n+\n+      return Result;\n    end Index;\n \n    function Index\n@@ -603,13 +699,19 @@ package body Ada.Strings.Search is\n             if Source (J) /= ' ' then\n                return J;\n             end if;\n+\n+            pragma Loop_Invariant\n+              (for all C of Source (Source'First .. J) => C = ' ');\n          end loop;\n \n       else -- Going = Backward\n          for J in reverse Source'Range loop\n             if Source (J) /= ' ' then\n                return J;\n             end if;\n+\n+            pragma Loop_Invariant\n+              (for all C of Source (J .. Source'Last) => C = ' ');\n          end loop;\n       end if;\n \n@@ -624,6 +726,13 @@ package body Ada.Strings.Search is\n       Going  : Direction := Forward) return Natural\n    is\n    begin\n+\n+      --  For equivalence with Index, if Source is empty the result is 0\n+\n+      if Source'Length = 0 then\n+         return 0;\n+      end if;\n+\n       if Going = Forward then\n          if From < Source'First then\n             raise Index_Error;\n@@ -642,4 +751,12 @@ package body Ada.Strings.Search is\n       end if;\n    end Index_Non_Blank;\n \n+   function Is_Identity\n+     (Mapping : Maps.Character_Mapping) return Boolean\n+   with SPARK_Mode => Off\n+   is\n+   begin\n+      return Mapping'Address = Maps.Identity'Address;\n+   end Is_Identity;\n+\n end Ada.Strings.Search;"}, {"sha": "4396747f7041b4b54966068861a139f59a34d1ab", "filename": "gcc/ada/libgnat/a-strsea.ads", "status": "modified", "additions": 522, "deletions": 18, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strsea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e/gcc%2Fada%2Flibgnat%2Fa-strsea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strsea.ads?ref=6c5ca4cf42f913a44c85071f2ba90e3f8048fa9e", "patch": "@@ -32,90 +32,594 @@\n --  This package contains the search functions from Ada.Strings.Fixed. They\n --  are separated out because they are shared by Ada.Strings.Bounded and\n --  Ada.Strings.Unbounded, and we don't want to drag in other irrelevant stuff\n---  from Ada.Strings.Fixed when using the other two packages. We make this a\n---  private package, since user programs should access these subprograms via\n---  one of the standard string packages.\n+--  from Ada.Strings.Fixed when using the other two packages. Although user\n+--  programs should access these subprograms via one of the standard string\n+--  packages, we do not make this a private package, since ghost function\n+--  Match is used in the contracts of the standard string packages.\n \n-with Ada.Strings.Maps;\n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced\n+--  by setting the corresponding assertion policy to Ignore. Postconditions,\n+--  contract cases and ghost code should not be executed at runtime as well,\n+--  in order not to slow down the execution of these functions.\n \n-private package Ada.Strings.Search is\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n+with Ada.Strings.Maps; use type Ada.Strings.Maps.Character_Mapping_Function;\n+\n+package Ada.Strings.Search with SPARK_Mode is\n    pragma Preelaborate;\n \n+   --  The ghost function Match tells whether the slice of Source starting at\n+   --  From and of length Pattern'Length matches with Pattern with respect to\n+   --  Mapping. Pattern should be non-empty and the considered slice should be\n+   --  fully included in Source'Range.\n+\n+   function Match\n+     (Source  : String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping_Function;\n+      From    : Integer) return Boolean\n+   is\n+      (for all K in Pattern'Range =>\n+         Pattern (K) = Mapping (Source (From + (K - Pattern'First))))\n+   with\n+     Ghost,\n+     Pre    => Mapping /= null\n+       and then Pattern'Length > 0\n+       and then Source'Length > 0\n+       and then From in Source'First .. Source'Last - (Pattern'Length - 1),\n+     Global => null;\n+\n+   function Match\n+     (Source  : String;\n+      Pattern : String;\n+      Mapping : Maps.Character_Mapping;\n+      From    : Integer) return Boolean\n+   is\n+      (for all K in Pattern'Range =>\n+         Pattern (K) =\n+           Ada.Strings.Maps.Value\n+             (Mapping, Source (From + (K - Pattern'First))))\n+   with\n+     Ghost,\n+     Pre    => Pattern'Length > 0\n+       and then Source'Length > 0\n+       and then From in Source'First .. Source'Last - (Pattern'Length - 1),\n+     Global => null;\n+\n+   function Is_Identity\n+     (Mapping : Maps.Character_Mapping) return Boolean\n+   with\n+     Post   => (if Is_Identity'Result then\n+                (for all K in Character =>\n+                   Ada.Strings.Maps.Value (Mapping, K) = K)),\n+     Global => null;\n+\n    function Index\n      (Source  : String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre            => Pattern'Length > 0,\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+       --  If Source is the empty string, then 0 is returned\n+\n+       (Source'Length = 0 => Index'Result = 0,\n+\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n+\n+        Source'Length > 0\n+          and then\n+            (for some J in\n+               Source'First .. Source'Last - (Pattern'Length - 1) =>\n+                 Match (Source, Pattern, Mapping, J))\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in Source'First .. Source'Last - (Pattern'Length - 1)\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then Match (Source, Pattern, Mapping, Index'Result)\n+\n+            --  The result is the smallest or largest index which satisfies\n+            --  the matching, respectively when Going = Forward and Going =\n+            --  Backward.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J <= Index'Result - 1\n+                      else J - 1 in Index'Result\n+                                    .. Source'Last - Pattern'Length)\n+                  then not (Match (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others => Index'Result = 0),\n+     Global         => null;\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre            => Pattern'Length > 0 and then Mapping /= null,\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+       --  If Source is the null string, then 0 is returned\n+\n+       (Source'Length = 0 => Index'Result = 0,\n+\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n+\n+        Source'Length > 0 and then\n+        (for some J in Source'First .. Source'Last - (Pattern'Length - 1) =>\n+             Match (Source, Pattern, Mapping, J))\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in Source'First .. Source'Last - (Pattern'Length - 1)\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then Match (Source, Pattern, Mapping, Index'Result)\n+\n+            --  The result is the smallest or largest index which satisfies\n+            --  the matching, respectively when Going = Forward and Going =\n+            --  Backward.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J <= Index'Result - 1\n+                      else J - 1 in Index'Result\n+                                    .. Source'Last - Pattern'Length)\n+                  then not (Match (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others => Index'Result = 0),\n+     Global         => null;\n \n    function Index\n      (Source : String;\n       Set    : Maps.Character_Set;\n       Test   : Membership := Inside;\n-      Going  : Direction  := Forward) return Natural;\n+      Going  : Direction  := Forward) return Natural\n+   with\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If no character of Source satisfies the property Test on Set, then\n+        --  0 is returned.\n+\n+       ((for all C of Source =>\n+           (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, a index in the range of Source is returned\n+\n+        others =>\n+\n+          --  The result is in the range of Source\n+\n+          Index'Result in Source'Range\n+\n+            --  The character at the returned index satisfies the property\n+            --  Test on Set\n+\n+            and then (Test = Inside)\n+              = Ada.Strings.Maps.Is_In (Source (Index'Result), Set)\n+\n+            --  The result is the smallest or largest index which satisfies\n+            --  the property, respectively when Going = Forward and Going =\n+            --  Backward.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index'Result\n+                       and then (J < Index'Result) = (Going = Forward)\n+                  then (Test = Inside)\n+                       /= Ada.Strings.Maps.Is_In (Source (J), Set)))),\n+     Global         => null;\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre            => Pattern'Length > 0\n+       and then (if Source'Length > 0 then From in Source'Range),\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+       --  If Source is the empty string, then 0 is returned\n+\n+       (Source'Length = 0 => Index'Result = 0,\n+\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n+\n+        Source'Length > 0\n+          and then\n+            (for some J in\n+              (if Going = Forward then From else Source'First)\n+              .. (if Going = Forward then Source'Last else From)\n+               - (Pattern'Length - 1) =>\n+              Match (Source, Pattern, Mapping, J))\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in\n+            (if Going = Forward then From else Source'First)\n+            .. (if Going = Forward then Source'Last else From)\n+              - (Pattern'Length - 1)\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then Match (Source, Pattern, Mapping, Index'Result)\n+\n+            --  The result is the smallest or largest index which satisfies\n+            --  the matching, respectively when Going = Forward and Going =\n+            --  Backward.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J in From .. Index'Result - 1\n+                      else J - 1 in Index'Result\n+                                    .. From - Pattern'Length)\n+                  then not (Match (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others => Index'Result = 0),\n+     Global         => null;\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n       From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre            => Pattern'Length > 0\n+       and then Mapping /= null\n+       and then (if Source'Length > 0 then From in Source'Range),\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+       --  If Source is the empty string, then 0 is returned\n+\n+       (Source'Length = 0 => Index'Result = 0,\n+\n+        --  If some slice of Source matches Pattern, then a valid index is\n+        --  returned.\n+\n+        Source'Length > 0\n+          and then\n+            (for some J in\n+              (if Going = Forward then From else Source'First)\n+              .. (if Going = Forward then Source'Last else From)\n+               - (Pattern'Length - 1) =>\n+              Match (Source, Pattern, Mapping, J))\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in\n+            (if Going = Forward then From else Source'First)\n+            .. (if Going = Forward then Source'Last else From)\n+              - (Pattern'Length - 1)\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then Match (Source, Pattern, Mapping, Index'Result)\n+\n+            --  The result is the smallest or largest index which satisfies\n+            --  the matching, respectively when Going = Forward and Going =\n+            --  Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J in From .. Index'Result - 1\n+                      else J - 1 in Index'Result\n+                                    .. From - Pattern'Length)\n+                  then not (Match (Source, Pattern, Mapping, J)))),\n+\n+        --  Otherwise, 0 is returned\n+\n+        others => Index'Result = 0),\n+     Global         => null;\n \n    function Index\n      (Source  : String;\n       Set     : Maps.Character_Set;\n       From    : Positive;\n       Test    : Membership := Inside;\n-      Going   : Direction := Forward) return Natural;\n+      Going   : Direction := Forward) return Natural\n+   with\n+     Pre            => (if Source'Length > 0 then From in Source'Range),\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If Source is the empty string, or no character of the considered\n+        --  slice of Source satisfies the property Test on Set, then 0 is\n+        --  returned.\n+\n+        (Source'Length = 0\n+          or else\n+            (for all J in Source'Range =>\n+               (if J = From or else (J > From) = (Going = Forward) then\n+                  (Test = Inside) /= Ada.Strings.Maps.Is_In (Source (J), Set)))\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, a index in the considered range of Source is returned\n+\n+        others =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in Source'Range\n+            and then (Index'Result = From\n+                       or else\n+                         (Index'Result > From) = (Going = Forward))\n+\n+            --  The character at the returned index satisfies the property\n+            --  Test on Set\n+\n+            and then\n+              (Test = Inside)\n+              = Ada.Strings.Maps.Is_In (Source (Index'Result), Set)\n+\n+            --  The result is the smallest or largest index which satisfies\n+            --  the property, respectively when Going = Forward and Going =\n+            --  Backward.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index'Result\n+                    and then (J < Index'Result) = (Going = Forward)\n+                    and then (J = From\n+                                or else (J > From) = (Going = Forward))\n+                  then (Test = Inside)\n+                       /= Ada.Strings.Maps.Is_In (Source (J), Set)))),\n+     Global         => null;\n \n    function Index_Non_Blank\n      (Source : String;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Post           => Index_Non_Blank'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If all characters of Source are Space characters, then 0 is\n+        --  returned.\n+\n+       ((for all C of Source => C = ' ') => Index_Non_Blank'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others                           =>\n+\n+          --  The result is in the range of Source\n+\n+          Index_Non_Blank'Result in Source'Range\n+\n+            --  The character at the returned index is not a Space character\n+\n+            and then Source (Index_Non_Blank'Result) /= ' '\n+\n+            --  The result is the smallest or largest index which is not a\n+            --  Space character, respectively when Going = Forward and\n+            --  Going = Backward.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index_Non_Blank'Result\n+                       and then (J < Index_Non_Blank'Result)\n+                              = (Going = Forward)\n+                  then Source (J) = ' '))),\n+     Global         => null;\n \n    function Index_Non_Blank\n      (Source : String;\n       From   : Positive;\n-      Going  : Direction := Forward) return Natural;\n+      Going  : Direction := Forward) return Natural\n+   with\n+     Pre            => (if Source'Length /= 0 then From in Source'Range),\n+     Post           => Index_Non_Blank'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If Source is the null string, or all characters in the considered\n+        --  slice of Source are Space characters, then 0 is returned.\n+\n+        (Source'Length = 0\n+          or else\n+            (for all J in Source'Range =>\n+               (if J = From or else (J > From) = (Going = Forward) then\n+                  Source (J) = ' '))\n+        =>\n+          Index_Non_Blank'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index_Non_Blank'Result in Source'Range\n+            and then (Index_Non_Blank'Result = From\n+                        or else (Index_Non_Blank'Result > From)\n+                                = (Going = Forward))\n+\n+            --  The character at the returned index is not a Space character\n+\n+            and then Source (Index_Non_Blank'Result) /= ' '\n+\n+            --  The result is the smallest or largest index which is not a\n+            --  Space character, respectively when Going = Forward and\n+            --  Going = Backward.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index_Non_Blank'Result\n+                       and then (J < Index_Non_Blank'Result)\n+                                = (Going = Forward)\n+                       and then (J = From or else (J > From)\n+                                = (Going = Forward))\n+                  then Source (J) = ' '))),\n+     Global         => null;\n \n    function Count\n      (Source  : String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n+   with\n+     Pre    => Pattern'Length > 0,\n+     Global => null;\n \n    function Count\n      (Source  : String;\n       Pattern : String;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural\n+   with\n+     Pre    => Pattern'Length > 0 and then Mapping /= null,\n+     Global => null;\n \n    function Count\n      (Source : String;\n-      Set    : Maps.Character_Set) return Natural;\n+      Set    : Maps.Character_Set) return Natural\n+   with\n+     Global => null;\n \n    procedure Find_Token\n      (Source : String;\n       Set    : Maps.Character_Set;\n       From   : Positive;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Pre            => (if Source'Length /= 0 then From in Source'Range),\n+     Contract_Cases =>\n+\n+        --  If Source is the empty string, or if no character of the considered\n+        --  slice of Source satisfies the property Test on Set, then First is\n+        --  set to From and Last is set to 0.\n+\n+       (Source'Length = 0\n+         or else\n+           (for all C of Source (From .. Source'Last) =>\n+              (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+        =>\n+          First = From and then Last = 0,\n+\n+        --  Otherwise, First and Last are set to valid indexes\n+\n+        others =>\n+\n+          --  First and Last are in the considered range of Source\n+\n+          First in From .. Source'Last\n+            and then Last in First .. Source'Last\n+\n+            --  No character between From and First satisfies the property Test\n+            --  on Set.\n+\n+            and then\n+              (for all C of Source (From .. First - 1) =>\n+                 (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  All characters between First and Last satisfy the property Test\n+            --  on Set.\n+\n+            and then\n+              (for all C of Source (First .. Last) =>\n+                 (Test = Inside) = Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  If Last is not Source'Last, then the character at position\n+            --  Last + 1 does not satify the property Test on Set.\n+\n+            and then\n+              (if Last < Source'Last\n+               then (Test = Inside)\n+                 /= Ada.Strings.Maps.Is_In (Source (Last + 1), Set))),\n+     Global         => null;\n \n    procedure Find_Token\n      (Source : String;\n       Set    : Maps.Character_Set;\n       Test   : Membership;\n       First  : out Positive;\n-      Last   : out Natural);\n+      Last   : out Natural)\n+   with\n+     Pre            => Source'First > 0,\n+     Contract_Cases =>\n+\n+        --  If Source is the empty string, or if no character of Source\n+        --  satisfies the property Test on Set, then First is set to From\n+        --  and Last is set to 0.\n+\n+       (Source'Length = 0\n+         or else\n+           (for all C of Source =>\n+              (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+        =>\n+          First = Source'First and then Last = 0,\n+\n+        --  Otherwise, First and Last are set to valid indexes\n+\n+        others =>\n+\n+          --  First and Last are in the considered range of Source\n+\n+          First in Source'Range\n+            and then Last in First .. Source'Last\n+\n+            --  No character before First satisfies the property Test on Set\n+\n+            and then\n+              (for all C of Source (Source'First .. First - 1) =>\n+                 (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  All characters between First and Last satisfy the property Test\n+            --  on Set.\n+\n+            and then\n+              (for all C of Source (First .. Last) =>\n+                 (Test = Inside) = Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  If Last is not Source'Last, then the character at position\n+            --  Last + 1 does not satify the property Test on Set.\n+\n+            and then\n+              (if Last < Source'Last\n+               then (Test = Inside)\n+                 /= Ada.Strings.Maps.Is_In (Source (Last + 1), Set))),\n+     Global => null;\n \n end Ada.Strings.Search;"}]}