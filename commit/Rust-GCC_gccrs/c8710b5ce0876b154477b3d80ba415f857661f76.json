{"sha": "c8710b5ce0876b154477b3d80ba415f857661f76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3MTBiNWNlMDg3NmIxNTQ0NzdiM2Q4MGJhNDE1Zjg1NzY2MWY3Ng==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2015-10-05T15:55:54Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2015-10-05T15:55:54Z"}, "message": "IPA-CP Alignment lattice cleanup\n\n2015-10-05  Martin Jambor  <mjambor@suse.cz>\n\t    Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-cp.c (ipcp_alignment_lattice): New type.\n\t(ipcp_param_lattices): Use the above to represent alignment.\n\t(ipcp_alignment_lattice::print): New function.\n\t(print_all_lattices): Use it to print alignment information.\n\t(ipcp_alignment_lattice::top_p): New function.\n\t(ipcp_alignment_lattice::bottom_p): Likewise.\n\t(ipcp_alignment_lattice::set_to_bottom): Likewise.\n\t(ipcp_alignment_lattice::meet_with_1): Likewise.\n\t(ipcp_alignment_lattice::meet_with): Two new overloaded functions.\n\t(set_all_contains_variable): Use set_to_bottom of alignment lattice.\n\t(initialize_node_lattices): Likewise.\n\t(propagate_alignment_accross_jump_function): Work with the new class\n\tfor alignment lattices.\n\t(propagate_constants_accross_call): Pass only the alignment lattice to\n\tpropagate_alignment_accross_jump_function.\n\t(ipcp_store_alignment_results): Work with the new class for alignment\n\tlattices.\n\ntestsuite/\n\t* gcc.dg/ipa/propalign-4.c: New test.\n\t* gcc.dg/ipa/propalign-5.c: Likewise.\n\n\nCo-Authored-By: Jan Hubicka <hubicka@ucw.cz>\n\nFrom-SVN: r228491", "tree": {"sha": "325ac823f7db9b09d43d88c0a824b2fcff9ebd90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/325ac823f7db9b09d43d88c0a824b2fcff9ebd90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8710b5ce0876b154477b3d80ba415f857661f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8710b5ce0876b154477b3d80ba415f857661f76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8710b5ce0876b154477b3d80ba415f857661f76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8710b5ce0876b154477b3d80ba415f857661f76/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85339618b6ba3edab19d8bd98eb19d8c5627c276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85339618b6ba3edab19d8bd98eb19d8c5627c276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85339618b6ba3edab19d8bd98eb19d8c5627c276"}], "stats": {"total": 311, "additions": 246, "deletions": 65}, "files": [{"sha": "d8abc2625491476804b7c1a2ef3f16a6b208f83d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8710b5ce0876b154477b3d80ba415f857661f76", "patch": "@@ -1,3 +1,24 @@\n+2015-10-05  Martin Jambor  <mjambor@suse.cz>\n+\t    Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-cp.c (ipcp_alignment_lattice): New type.\n+\t(ipcp_param_lattices): Use the above to represent alignment.\n+\t(ipcp_alignment_lattice::print): New function.\n+\t(print_all_lattices): Use it to print alignment information.\n+\t(ipcp_alignment_lattice::top_p): New function.\n+\t(ipcp_alignment_lattice::bottom_p): Likewise.\n+\t(ipcp_alignment_lattice::set_to_bottom): Likewise.\n+\t(ipcp_alignment_lattice::meet_with_1): Likewise.\n+\t(ipcp_alignment_lattice::meet_with): Two new overloaded functions.\n+\t(set_all_contains_variable): Use set_to_bottom of alignment lattice.\n+\t(initialize_node_lattices): Likewise.\n+\t(propagate_alignment_accross_jump_function): Work with the new class\n+\tfor alignment lattices.\n+\t(propagate_constants_accross_call): Pass only the alignment lattice to\n+\tpropagate_alignment_accross_jump_function.\n+\t(ipcp_store_alignment_results): Work with the new class for alignment\n+\tlattices.\n+\n 2015-10-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/67821"}, {"sha": "0d9fdee79b64919551454b2e90d0d13b677ca417", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 177, "deletions": 65, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c8710b5ce0876b154477b3d80ba415f857661f76", "patch": "@@ -241,6 +241,36 @@ class ipcp_agg_lattice : public ipcp_lattice<tree>\n   struct ipcp_agg_lattice *next;\n };\n \n+/* Lattice of pointer alignment.  Unlike the previous types of lattices, this\n+   one is only capable of holding one value.  */\n+\n+class ipcp_alignment_lattice\n+{\n+public:\n+  /* If bottom and top are both false, these two fields hold values as given by\n+     ptr_info_def and get_pointer_alignment_1.  */\n+  unsigned align;\n+  unsigned misalign;\n+\n+  inline bool bottom_p () const;\n+  inline bool top_p () const;\n+  inline bool set_to_bottom ();\n+  bool meet_with (unsigned new_align, unsigned new_misalign);\n+  bool meet_with (const ipcp_alignment_lattice &other, HOST_WIDE_INT offset);\n+  void print (FILE * f);\n+private:\n+  /* If set, this lattice is bottom and all other fields should be\n+     disregarded.  */\n+  bool bottom;\n+  /* If bottom and not_top are false, the lattice is TOP.  If not_top is true,\n+     the known alignment is stored in the fields align and misalign.  The field\n+     is negated so that memset to zero initializes the lattice to TOP\n+     state.  */\n+  bool not_top;\n+\n+  bool meet_with_1 (unsigned new_align, unsigned new_misalign);\n+};\n+\n /* Structure containing lattices for a parameter itself and for pieces of\n    aggregates that are passed in the parameter or by a reference in a parameter\n    plus some other useful flags.  */\n@@ -254,9 +284,8 @@ class ipcp_param_lattices\n   ipcp_lattice<ipa_polymorphic_call_context> ctxlat;\n   /* Lattices describing aggregate parts.  */\n   ipcp_agg_lattice *aggs;\n-  /* Alignment information.  Very basic one value lattice where !known means\n-     TOP and zero alignment bottom.  */\n-  ipa_alignment alignment;\n+  /* Lattice describing known alignment.  */\n+  ipcp_alignment_lattice alignment;\n   /* Number of aggregate lattices */\n   int aggs_count;\n   /* True if aggregate data were passed by reference (as opposed to by\n@@ -421,6 +450,19 @@ ipcp_lattice<valtype>::print (FILE * f, bool dump_sources, bool dump_benefits)\n     fprintf (f, \"\\n\");\n }\n \n+/* Print alignment lattice to F.  */\n+\n+void\n+ipcp_alignment_lattice::print (FILE * f)\n+{\n+  if (top_p ())\n+    fprintf (f, \"         Alignment unknown (TOP)\\n\");\n+  else if (bottom_p ())\n+    fprintf (f, \"         Alignment unusable (BOTTOM)\\n\");\n+  else\n+    fprintf (f, \"         Alignment %u, misalignment %u\\n\", align, misalign);\n+}\n+\n /* Print all ipcp_lattices of all functions to F.  */\n \n static void\n@@ -446,13 +488,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \t  plats->itself.print (f, dump_sources, dump_benefits);\n \t  fprintf (f, \"         ctxs: \");\n \t  plats->ctxlat.print (f, dump_sources, dump_benefits);\n-\t  if (plats->alignment.known && plats->alignment.align > 0)\n-\t    fprintf (f, \"         Alignment %u, misalignment %u\\n\",\n-\t\t     plats->alignment.align, plats->alignment.misalign);\n-\t  else if (plats->alignment.known)\n-\t    fprintf (f, \"         Alignment unusable\\n\");\n-\t  else\n-\t    fprintf (f, \"         Alignment unknown\\n\");\n+\t  plats->alignment.print (f);\n \t  if (plats->virt_call)\n \t    fprintf (f, \"        virt_call flag set\\n\");\n \n@@ -767,27 +803,111 @@ set_agg_lats_contain_variable (struct ipcp_param_lattices *plats)\n   return ret;\n }\n \n-/* Return true if alignment information in PLATS is known to be unusable.  */\n+/* Return true if alignment information in the lattice is yet unknown.  */\n \n-static inline bool\n-alignment_bottom_p (ipcp_param_lattices *plats)\n+bool\n+ipcp_alignment_lattice::top_p () const\n {\n-  return plats->alignment.known && (plats->alignment.align == 0);\n+  return !bottom && !not_top;\n }\n \n-/* Set alignment information in PLATS to unusable.  Return true if it\n-   previously was usable or unknown.  */\n+/* Return true if alignment information in the lattice is known to be\n+   unusable.  */\n \n-static inline bool\n-set_alignment_to_bottom (ipcp_param_lattices *plats)\n+bool\n+ipcp_alignment_lattice::bottom_p () const\n+{\n+  return bottom;\n+}\n+\n+/* Set alignment information in the lattice to bottom.  Return true if it\n+   previously was in a different state.  */\n+\n+bool\n+ipcp_alignment_lattice::set_to_bottom ()\n {\n-  if (alignment_bottom_p (plats))\n+  if (bottom_p ())\n     return false;\n-  plats->alignment.known = true;\n-  plats->alignment.align = 0;\n+  bottom = true;\n   return true;\n }\n \n+/* Meet the current value of the lattice with alignment described by NEW_ALIGN\n+   and NEW_MISALIGN, assuming that we know the current value is neither TOP nor\n+   BOTTOM.  Return true if the value of lattice has changed.  */\n+\n+bool\n+ipcp_alignment_lattice::meet_with_1 (unsigned new_align, unsigned new_misalign)\n+{\n+  gcc_checking_assert (new_align != 0);\n+  if (align == new_align && misalign == new_misalign)\n+    return false;\n+\n+  bool changed = false;\n+  if (align > new_align)\n+    {\n+      align = new_align;\n+      misalign = misalign % new_align;\n+      changed = true;\n+    }\n+  if (misalign != (new_misalign % align))\n+    {\n+      int diff = abs (misalign - (new_misalign % align));\n+      align = MIN (align, (unsigned) diff & -diff);\n+      if (align)\n+\tmisalign = misalign % align;\n+      else\n+\tset_to_bottom ();\n+      changed = true;\n+    }\n+  gcc_checking_assert (bottom_p () || align != 0);\n+  return changed;\n+}\n+\n+/* Meet the current value of the lattice with alignment described by NEW_ALIGN\n+   and NEW_MISALIGN.  Return true if the value of lattice has changed.  */\n+\n+bool\n+ipcp_alignment_lattice::meet_with (unsigned new_align, unsigned new_misalign)\n+{\n+  gcc_assert (new_align != 0);\n+  if (bottom_p ())\n+    return false;\n+  if (top_p ())\n+    {\n+      not_top = true;\n+      align = new_align;\n+      misalign = new_misalign;\n+      return true;\n+    }\n+  return meet_with_1 (new_align, new_misalign);\n+}\n+\n+/* Meet the current value of the lattice with OTHER, taking into account that\n+   OFFSET has been added to the pointer value.  Return true if the value of\n+   lattice has changed.  */\n+\n+bool\n+ipcp_alignment_lattice::meet_with (const ipcp_alignment_lattice &other,\n+\t\t\t\t   HOST_WIDE_INT offset)\n+{\n+  if (other.bottom_p ())\n+    return set_to_bottom ();\n+  if (bottom_p () || other.top_p ())\n+    return false;\n+\n+  unsigned adjusted_misalign = (other.misalign + offset) % other.align;\n+  if (top_p ())\n+    {\n+      not_top = true;\n+      align = other.align;\n+      misalign = adjusted_misalign;\n+      return true;\n+    }\n+\n+  return meet_with_1 (other.align, adjusted_misalign);\n+}\n+\n /* Mark bot aggregate and scalar lattices as containing an unknown variable,\n    return true is any of them has not been marked as such so far.  */\n \n@@ -798,7 +918,7 @@ set_all_contains_variable (struct ipcp_param_lattices *plats)\n   ret = plats->itself.set_contains_variable ();\n   ret |= plats->ctxlat.set_contains_variable ();\n   ret |= set_agg_lats_contain_variable (plats);\n-  ret |= set_alignment_to_bottom (plats);\n+  ret |= plats->alignment.set_to_bottom ();\n   return ret;\n }\n \n@@ -879,7 +999,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \t      plats->itself.set_to_bottom ();\n \t      plats->ctxlat.set_to_bottom ();\n \t      set_agg_lats_to_bottom (plats);\n-\t      set_alignment_to_bottom (plats);\n+\t      plats->alignment.set_to_bottom ();\n \t    }\n \t  else\n \t    set_all_contains_variable (plats);\n@@ -1448,22 +1568,17 @@ propagate_context_accross_jump_function (cgraph_edge *cs,\n    edge CS and update DEST_LAT accordingly.  */\n \n static bool\n-propagate_alignment_accross_jump_function (struct cgraph_edge *cs,\n-\t\t\t\t\t   struct ipa_jump_func *jfunc,\n-\t\t\t\t\t   struct ipcp_param_lattices *dest_lat)\n+propagate_alignment_accross_jump_function (cgraph_edge *cs,\n+\t\t\t\t\t   ipa_jump_func *jfunc,\n+\t\t\t\t\t   ipcp_alignment_lattice *dest_lat)\n {\n-  if (alignment_bottom_p (dest_lat))\n+  if (dest_lat->bottom_p ())\n     return false;\n \n-  ipa_alignment cur;\n-  cur.known = false;\n-  if (jfunc->alignment.known)\n-    cur = jfunc->alignment;\n-  else if (jfunc->type == IPA_JF_PASS_THROUGH\n+  if (jfunc->type == IPA_JF_PASS_THROUGH\n \t   || jfunc->type == IPA_JF_ANCESTOR)\n     {\n       struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-      struct ipcp_param_lattices *src_lats;\n       HOST_WIDE_INT offset = 0;\n       int src_idx;\n \n@@ -1474,44 +1589,32 @@ propagate_alignment_accross_jump_function (struct cgraph_edge *cs,\n \t    {\n \t      if (op != POINTER_PLUS_EXPR\n \t\t  && op != PLUS_EXPR)\n-\t\tgoto prop_fail;\n+\t\treturn dest_lat->set_to_bottom ();\n \t      tree operand = ipa_get_jf_pass_through_operand (jfunc);\n \t      if (!tree_fits_shwi_p (operand))\n-\t\tgoto prop_fail;\n+\t\treturn dest_lat->set_to_bottom ();\n \t      offset = tree_to_shwi (operand);\n \t    }\n \t  src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n \t}\n       else\n \t{\n \t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n-\t  offset = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;;\n+\t  offset = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;\n \t}\n \n+      struct ipcp_param_lattices *src_lats;\n       src_lats = ipa_get_parm_lattices (caller_info, src_idx);\n-      if (!src_lats->alignment.known\n-\t  || alignment_bottom_p (src_lats))\n-\tgoto prop_fail;\n-\n-      cur = src_lats->alignment;\n-      cur.misalign = (cur.misalign + offset) % cur.align;\n+      return dest_lat->meet_with (src_lats->alignment, offset);\n     }\n-\n-  if (cur.known)\n+  else\n     {\n-      if (!dest_lat->alignment.known)\n-\t{\n-\t  dest_lat->alignment = cur;\n-\t  return true;\n-\t}\n-      else if (dest_lat->alignment.align == cur.align\n-\t       && dest_lat->alignment.misalign == cur.misalign)\n-\treturn false;\n+      if (jfunc->alignment.known)\n+\treturn dest_lat->meet_with (jfunc->alignment.align,\n+\t\t\t\t    jfunc->alignment.misalign);\n+      else\n+\treturn dest_lat->set_to_bottom ();\n     }\n-\n- prop_fail:\n-  set_alignment_to_bottom (dest_lat);\n-  return true;\n }\n \n /* If DEST_PLATS already has aggregate items, check that aggs_by_ref matches\n@@ -1851,7 +1954,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n \t  ret |= propagate_context_accross_jump_function (cs, jump_func, i,\n \t\t\t\t\t\t\t  &dest_plats->ctxlat);\n \t  ret |= propagate_alignment_accross_jump_function (cs, jump_func,\n-\t\t\t\t\t\t\t    dest_plats);\n+\t\t\t\t\t\t\t &dest_plats->alignment);\n \t  ret |= propagate_aggs_accross_jump_function (cs, jump_func,\n \t\t\t\t\t\t       dest_plats);\n \t}\n@@ -4401,29 +4504,38 @@ ipcp_store_alignment_results (void)\n    for (unsigned i = 0; i < count ; i++)\n      {\n        ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-       if (plats->alignment.known\n-\t   && plats->alignment.align > 0)\n+       if (!plats->alignment.bottom_p ()\n+\t   && !plats->alignment.top_p ())\n \t {\n+\t   gcc_checking_assert (plats->alignment.align > 0);\n \t   found_useful_result = true;\n \t   break;\n \t }\n      }\n    if (!found_useful_result)\n      continue;\n \n-  ipcp_grow_transformations_if_necessary ();\n+   ipcp_grow_transformations_if_necessary ();\n    ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n    vec_safe_reserve_exact (ts->alignments, count);\n \n    for (unsigned i = 0; i < count ; i++)\n      {\n        ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+       ipa_alignment al;\n \n-       if (plats->alignment.align == 0)\n-\t plats->alignment.known = false;\n+       if (!plats->alignment.bottom_p ()\n+\t   && !plats->alignment.top_p ())\n+\t {\n+\t   al.known = true;\n+\t   al.align = plats->alignment.align;\n+\t   al.misalign = plats->alignment.misalign;\n+\t }\n+       else\n+\t al.known = false;\n \n-       ts->alignments->quick_push (plats->alignment);\n-       if (!dump_file || !plats->alignment.known)\n+       ts->alignments->quick_push (al);\n+       if (!dump_file || !al.known)\n \t continue;\n        if (!dumped_sth)\n \t {\n@@ -4432,7 +4544,7 @@ ipcp_store_alignment_results (void)\n \t   dumped_sth = true;\n \t }\n        fprintf (dump_file, \"  param %i: align: %u, misalign: %u\\n\",\n-\t\ti, plats->alignment.align, plats->alignment.misalign);\n+\t\ti, al.align, al.misalign);\n      }\n   }\n }"}, {"sha": "7e4d84f9e3e6d1bdbece7d73db9768c27ab77f00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c8710b5ce0876b154477b3d80ba415f857661f76", "patch": "@@ -1,3 +1,9 @@\n+2015-10-05  Martin Jambor  <mjambor@suse.cz>\n+\t    Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/ipa/propalign-4.c: New test.\n+\t* gcc.dg/ipa/propalign-5.c: Likewise.\n+\n 2015-10-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/67821"}, {"sha": "4b2b597752547602422549e25da2f3ecbd65baea", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-4.c?ref=c8710b5ce0876b154477b3d80ba415f857661f76", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-cp\"  } */\n+int n;\n+\n+static void\n+__attribute__ ((noinline))\n+test(void *a)\n+{\n+  __builtin_memset (a,0,n);\n+}\n+\n+static __attribute__ ((aligned(16))) int aa[10];\n+\n+int\n+main()\n+{\n+  test (&aa[1]);\n+  test (&aa[3]);\n+  return 0;\n+}\n+/* { dg-final { scan-ipa-dump \"Alignment 8, misalignment 4\"  \"cp\"  } } */"}, {"sha": "87021bc752679edcec14d57027efba93ab974980", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-5.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8710b5ce0876b154477b3d80ba415f857661f76/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-5.c?ref=c8710b5ce0876b154477b3d80ba415f857661f76", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-cp\"  } */\n+int n;\n+\n+static void\n+__attribute__ ((noinline))\n+test(void *a)\n+{\n+  __builtin_memset (a,0,n);\n+}\n+\n+int\n+main()\n+{\n+  int aa;\n+  short bb;\n+  test (&aa);\n+  test (&bb);\n+  return 0;\n+}\n+/* { dg-final { scan-ipa-dump \"Alignment 2\"  \"cp\"  } } */"}]}