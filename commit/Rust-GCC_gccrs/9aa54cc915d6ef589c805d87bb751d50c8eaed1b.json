{"sha": "9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFhNTRjYzkxNWQ2ZWY1ODljODA1ZDg3YmI3NTFkNTBjOGVhZWQxYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-05-13T15:17:34Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-05-13T15:17:34Z"}, "message": "gengtype: Support explicit pointers in template arguments\n\ngcc/\n2014-05-13  David Malcolm  <dmalcolm@redhat.com>\n\n\t* gengtype-parse.c (require3): Eliminate in favor of...\n\t(require4): New.\n\t(require_template_declaration): Update to support optional single *\n\ton a type.\n\n\t* gengtype.c (get_ultimate_base_class): Add a non-const overload.\n\t(create_user_defined_type): Handle a single level of explicit\n\tpointerness within template arguments.\n\t(struct write_types_data): Add field \"kind\".\n\t(filter_type_name): Handle \"*\" character.\n\t(write_user_func_for_structure_ptr): Require a write_types_data\n\trather than just a prefix string, so that we can look up the kind\n\tof the wtd and use it as an index into wrote_user_func_for_ptr,\n\tensuring that such functions are written at most once.  Support\n\tsubclasses by invoking the marking function of the ultimate base\n\tclass.\n\t(write_user_func_for_structure_body): Require a write_types_data\n\trather than just a prefix string, so that we can pass this to\n\twrite_user_func_for_structure_ptr.\n\t(write_func_for_structure): Likewise.\n\t(ggc_wtd): Add initializer of new \"kind\" field.\n\t(pch_wtd): Likewise.\n\n\t* gengtype.h (enum write_types_kinds): New.\n\t(struct type): Add field wrote_user_func_for_ptr to the \"s\"\n\tunion member.\n\nFrom-SVN: r210379", "tree": {"sha": "8bffdaf2d5d6487778cb3b5ae5abfe405d0963d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bffdaf2d5d6487778cb3b5ae5abfe405d0963d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c0f009c926cc78fb15f1c5cfa46071a4359c9e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0f009c926cc78fb15f1c5cfa46071a4359c9e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0f009c926cc78fb15f1c5cfa46071a4359c9e9"}], "stats": {"total": 142, "additions": 120, "deletions": 22}, "files": [{"sha": "a8a538b59408209cfed32eb8e92d82731004b113", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "patch": "@@ -1,3 +1,32 @@\n+2014-05-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gengtype-parse.c (require3): Eliminate in favor of...\n+\t(require4): New.\n+\t(require_template_declaration): Update to support optional single *\n+\ton a type.\n+\n+\t* gengtype.c (get_ultimate_base_class): Add a non-const overload.\n+\t(create_user_defined_type): Handle a single level of explicit\n+\tpointerness within template arguments.\n+\t(struct write_types_data): Add field \"kind\".\n+\t(filter_type_name): Handle \"*\" character.\n+\t(write_user_func_for_structure_ptr): Require a write_types_data\n+\trather than just a prefix string, so that we can look up the kind\n+\tof the wtd and use it as an index into wrote_user_func_for_ptr,\n+\tensuring that such functions are written at most once.  Support\n+\tsubclasses by invoking the marking function of the ultimate base\n+\tclass.\n+\t(write_user_func_for_structure_body): Require a write_types_data\n+\trather than just a prefix string, so that we can pass this to\n+\twrite_user_func_for_structure_ptr.\n+\t(write_func_for_structure): Likewise.\n+\t(ggc_wtd): Add initializer of new \"kind\" field.\n+\t(pch_wtd): Likewise.\n+\n+\t* gengtype.h (enum write_types_kinds): New.\n+\t(struct type): Add field wrote_user_func_for_ptr to the \"s\"\n+\tunion member.\n+\n 2014-05-13  Richard Sandiford  <r.sandiford@uk.ibm.com>\n \n \t* fold-const.c (optimize_bit_field_compare): Use wi:: operations"}, {"sha": "0f11cec7c413c5eb030434cd99f6c87c3dc31243", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "patch": "@@ -197,18 +197,19 @@ require2 (int t1, int t2)\n   return v;\n }\n \n-/* If the next token does not have one of the codes T1, T2 or T3, report a\n+/* If the next token does not have one of the codes T1, T2, T3 or T4, report a\n    parse error; otherwise return the token's value.  */\n static const char *\n-require3 (int t1, int t2, int t3)\n+require4 (int t1, int t2, int t3, int t4)\n {\n   int u = token ();\n   const char *v = advance ();\n-  if (u != t1 && u != t2 && u != t3)\n+  if (u != t1 && u != t2 && u != t3 && u != t4)\n     {\n-      parse_error (\"expected %s, %s or %s, have %s\",\n+      parse_error (\"expected %s, %s, %s or %s, have %s\",\n \t\t   print_token (t1, 0), print_token (t2, 0),\n-\t\t   print_token (t3, 0), print_token (u, v));\n+\t\t   print_token (t3, 0), print_token (t4, 0),\n+\t\t   print_token (u, v));\n       return 0;\n     }\n   return v;\n@@ -245,7 +246,9 @@ string_seq (void)\n \n /* The caller has detected a template declaration that starts\n    with TMPL_NAME.  Parse up to the closing '>'.  This recognizes\n-   simple template declarations of the form ID<ID1,ID2,...,IDn>.\n+   simple template declarations of the form ID<ID1,ID2,...,IDn>,\n+   potentially with a single level of indirection e.g.\n+     ID<ID1 *, ID2, ID3 *, ..., IDn>.\n    It does not try to parse anything more sophisticated than that.\n \n    Returns the template declaration string \"ID<ID1,ID2,...,IDn>\".  */\n@@ -254,6 +257,7 @@ static const char *\n require_template_declaration (const char *tmpl_name)\n {\n   char *str;\n+  int num_indirections = 0;\n \n   /* Recognize the opening '<'.  */\n   require ('<');\n@@ -294,9 +298,21 @@ require_template_declaration (const char *tmpl_name)\n \t  depth -= 1;\n \t  continue;\n \t}\n-      const char *id = require3 (SCALAR, ID, ',');\n+      const char *id = require4 (SCALAR, ID, '*', ',');\n       if (id == NULL)\n-\tid = \",\";\n+\t{\n+\t  if (T.code == '*')\n+\t    {\n+\t      id = \"*\";\n+\t      if (num_indirections++)\n+\t\tparse_error (\"only one level of indirection is supported\"\n+\t\t\t     \" in template arguments\");\n+\t    }\n+\t  else\n+\t    id = \",\";\n+\t}\n+      else\n+\tnum_indirections = 0;\n       str = concat (str, id, (char *) 0);\n     }\n   return str;"}, {"sha": "21da84b77d9958fbc54a3eaf23806c915ede0598", "filename": "gcc/gengtype.c", "status": "modified", "additions": 55, "deletions": 14, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "patch": "@@ -145,6 +145,14 @@ get_ultimate_base_class (const_type_p s)\n     s = s->u.s.base_class;\n   return s;\n }\n+\n+static type_p\n+get_ultimate_base_class (type_p s)\n+{\n+  while (s->u.s.base_class)\n+    s = s->u.s.base_class;\n+  return s;\n+}\n \f\n /* Input file handling. */\n \n@@ -589,16 +597,36 @@ create_user_defined_type (const char *type_name, struct fileloc *pos)\n       /* We only accept simple template declarations (see\n \t require_template_declaration), so we only need to parse a\n \t comma-separated list of strings, implicitly assumed to\n-\t be type names.  */\n+\t be type names, potentially with \"*\" characters.  */\n       char *arg = open_bracket + 1;\n       char *type_id = strtok (arg, \",>\");\n       pair_p fields = 0;\n       while (type_id)\n \t{\n \t  /* Create a new field for every type found inside the template\n \t     parameter list.  */\n-\t  const char *field_name = xstrdup (type_id);\n-\t  type_p arg_type = resolve_typedef (field_name, pos);\n+\n+\t  /* Support a single trailing \"*\" character.  */\n+\t  const char *star = strchr (type_id, '*');\n+\t  int is_ptr = (star != NULL);\n+\t  size_t offset_to_star = star - type_id;\n+\t  if (is_ptr)\n+\t    offset_to_star = star - type_id;\n+\n+\t  char *field_name = xstrdup (type_id);\n+\n+\t  type_p arg_type;\n+\t  if (is_ptr)\n+\t    {\n+\t      /* Strip off the first '*' character (and any subsequent text). */\n+\t      *(field_name + offset_to_star) = '\\0';\n+\n+\t      arg_type = find_structure (field_name, TYPE_STRUCT);\n+\t      arg_type = create_pointer (arg_type);\n+\t    }\n+\t  else\n+\t    arg_type = resolve_typedef (field_name, pos);\n+\n \t  fields = create_field_at (fields, arg_type, field_name, 0, pos);\n \t  type_id = strtok (0, \",>\");\n \t}\n@@ -2461,6 +2489,7 @@ struct write_types_data\n   const char *reorder_note_routine;\n   const char *comment;\n   int skip_hooks;\t\t/* skip hook generation if non zero */\n+  enum write_types_kinds kind;\n };\n \n static void output_escaped_param (struct walk_type_data *d,\n@@ -2537,7 +2566,8 @@ filter_type_name (const char *type_name)\n       size_t i;\n       char *s = xstrdup (type_name);\n       for (i = 0; i < strlen (s); i++)\n-\tif (s[i] == '<' || s[i] == '>' || s[i] == ':' || s[i] == ',')\n+\tif (s[i] == '<' || s[i] == '>' || s[i] == ':' || s[i] == ','\n+\t    || s[i] == '*')\n \t  s[i] = '_';\n       return s;\n     }\n@@ -3501,10 +3531,10 @@ write_marker_function_name (outf_p of, type_p s, const char *prefix)\n \n /* Write on OF a user-callable routine to act as an entry point for\n    the marking routine for S, generated by write_func_for_structure.\n-   PREFIX is the prefix to use to distinguish ggc and pch markers.  */\n+   WTD distinguishes between ggc and pch markers.  */\n \n static void\n-write_user_func_for_structure_ptr (outf_p of, type_p s, const char *prefix)\n+write_user_func_for_structure_ptr (outf_p of, type_p s, const write_types_data *wtd)\n {\n   /* Parameterized structures are not supported in user markers. There\n      is no way for the marker function to know which specific type\n@@ -3534,13 +3564,23 @@ write_user_func_for_structure_ptr (outf_p of, type_p s, const char *prefix)\n \tbreak;\n       }\n \n+  DBGPRINTF (\"write_user_func_for_structure_ptr: %s %s\", s->u.s.tag,\n+\t     wtd->prefix);\n+\n+  /* Only write the function once. */\n+  if (s->u.s.wrote_user_func_for_ptr[wtd->kind])\n+    return;\n+  s->u.s.wrote_user_func_for_ptr[wtd->kind] = true;\n+\n   oprintf (of, \"\\nvoid\\n\");\n-  oprintf (of, \"gt_%sx (\", prefix);\n+  oprintf (of, \"gt_%sx (\", wtd->prefix);\n   write_type_decl (of, s);\n   oprintf (of, \" *& x)\\n\");\n   oprintf (of, \"{\\n\");\n   oprintf (of, \"  if (x)\\n    \");\n-  write_marker_function_name (of, alias_of ? alias_of : s, prefix);\n+  write_marker_function_name (of,\n+\t\t\t      alias_of ? alias_of : get_ultimate_base_class (s),\n+\t\t\t      wtd->prefix);\n   oprintf (of, \" ((void *) x);\\n\");\n   oprintf (of, \"}\\n\");\n }\n@@ -3578,7 +3618,8 @@ write_user_func_for_structure_body (type_p s, const char *prefix,\n    which just marks the fields of T.  */\n \n static void\n-write_user_marking_functions (type_p s, const char *prefix,\n+write_user_marking_functions (type_p s,\n+\t\t\t      const write_types_data *w,\n \t\t\t      struct walk_type_data *d)\n {\n   gcc_assert (s->kind == TYPE_USER_STRUCT);\n@@ -3590,10 +3631,10 @@ write_user_marking_functions (type_p s, const char *prefix,\n \t{\n \t  type_p pointed_to_type = fld_type->u.p;\n \t  if (union_or_struct_p (pointed_to_type))\n-\t    write_user_func_for_structure_ptr (d->of, pointed_to_type, prefix);\n+\t    write_user_func_for_structure_ptr (d->of, pointed_to_type, w);\n \t}\n       else if (union_or_struct_p (fld_type))\n-\twrite_user_func_for_structure_body (fld_type, prefix, d);\n+\twrite_user_func_for_structure_body (fld_type, w->prefix, d);\n     }\n }\n \n@@ -3791,7 +3832,7 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n   oprintf (d.of, \"}\\n\");\n \n   if (orig_s->kind == TYPE_USER_STRUCT)\n-    write_user_marking_functions (orig_s, wtd->prefix, &d);\n+    write_user_marking_functions (orig_s, wtd, &d);\n }\n \n \n@@ -3969,14 +4010,14 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n static const struct write_types_data ggc_wtd = {\n   \"ggc_m\", NULL, \"ggc_mark\", \"ggc_test_and_set_mark\", NULL,\n   \"GC marker procedures.  \",\n-  FALSE\n+  FALSE, WTK_GGC\n };\n \n static const struct write_types_data pch_wtd = {\n   \"pch_n\", \"pch_p\", \"gt_pch_note_object\", \"gt_pch_note_object\",\n   \"gt_pch_note_reorder\",\n   \"PCH type-walking procedures.  \",\n-  TRUE\n+  TRUE, WTK_PCH\n };\n \n /* Write out the local pointer-walking routines.  */"}, {"sha": "6369001e038cd4a558212495fcedb6e744a3df0b", "filename": "gcc/gengtype.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aa54cc915d6ef589c805d87bb751d50c8eaed1b/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=9aa54cc915d6ef589c805d87bb751d50c8eaed1b", "patch": "@@ -127,7 +127,15 @@ extern type_p structures;\n extern type_p param_structs;\n extern pair_p variables;\n \n+/* An enum for distinguishing GGC vs PCH.  */\n \n+enum write_types_kinds\n+{\n+  WTK_GGC,\n+  WTK_PCH,\n+\n+  NUM_WTK\n+};\n \n /* Discrimating kind of types we can understand.  */\n \n@@ -302,6 +310,10 @@ struct type {\n       type_p first_subclass;\n       /* The next in that list.  */\n       type_p next_sibling_class;\n+\n+      /* Have we already written ggc/pch user func for ptr to this?\n+\t (in write_user_func_for_structure_ptr).  */\n+      bool wrote_user_func_for_ptr[NUM_WTK];\n     } s;\n \n     /* when TYPE_SCALAR: */"}]}