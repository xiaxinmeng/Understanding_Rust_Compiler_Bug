{"sha": "a82ad57075803763e50a2fc4411086132dce9c7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgyYWQ1NzA3NTgwMzc2M2U1MGEyZmM0NDExMDg2MTMyZGNlOWM3ZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-12T02:50:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-12T02:50:09Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1568", "tree": {"sha": "3fd85ae5e18ad0ea19b3707b18e257bc98868c66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fd85ae5e18ad0ea19b3707b18e257bc98868c66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a82ad57075803763e50a2fc4411086132dce9c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82ad57075803763e50a2fc4411086132dce9c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82ad57075803763e50a2fc4411086132dce9c7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82ad57075803763e50a2fc4411086132dce9c7d/comments", "author": null, "committer": null, "parents": [{"sha": "81feeecbd9f2fbf43327899667b1991bff10430c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81feeecbd9f2fbf43327899667b1991bff10430c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81feeecbd9f2fbf43327899667b1991bff10430c"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "d06baa068a9a4395849e1b33e6022b2d24e31919", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a82ad57075803763e50a2fc4411086132dce9c7d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a82ad57075803763e50a2fc4411086132dce9c7d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a82ad57075803763e50a2fc4411086132dce9c7d", "patch": "@@ -832,7 +832,7 @@ put_var_into_stack (decl)\n \n   /* If this is a variable-size object with a pseudo to address it,\n      put that pseudo into the stack, if the var is nonlocal.  */\n-  if (TREE_NONLOCAL (decl)\n+  if (DECL_NONLOCAL (decl)\n       && GET_CODE (reg) == MEM\n       && GET_CODE (XEXP (reg, 0)) == REG\n       && REGNO (XEXP (reg, 0)) > LAST_VIRTUAL_REGISTER)\n@@ -1892,7 +1892,7 @@ instantiate_decls (fndecl, valid_only)\n {\n   tree decl;\n \n-  if (TREE_INLINE (fndecl))\n+  if (DECL_INLINE (fndecl))\n     /* When compiling an inline function, the obstack used for\n        rtl allocation is the maybepermanent_obstack.  Calling\n        `resume_temporary_allocation' switches us back to that\n@@ -1917,7 +1917,7 @@ instantiate_decls (fndecl, valid_only)\n   /* Now process all variables defined in the function or its subblocks. */\n   instantiate_decls_1 (DECL_INITIAL (fndecl), valid_only);\n \n-  if (TREE_INLINE (fndecl))\n+  if (DECL_INLINE (fndecl))\n     {\n       /* Save all rtl allocated for this function by raising the\n \t high-water mark on the maybepermanent_obstack.  */\n@@ -2809,8 +2809,8 @@ assign_parms (fndecl, second_time)\n \t\t  !optimize\n #else /* It's not clear why the following was replaced.  */\n \t\t  /* Obsoleted by preceding line. */\n-\t\t  (obey_regdecls && ! TREE_REGDECL (parm)\n-\t\t   && ! TREE_INLINE (fndecl))\n+\t\t  (obey_regdecls && ! DECL_REGISTER (parm)\n+\t\t   && ! DECL_INLINE (fndecl))\n #endif\n \t\t  /* layout_decl may set this.  */\n \t\t  || TREE_ADDRESSABLE (parm)\n@@ -3264,7 +3264,7 @@ setjmp_protect (block)\n \t    NON_SAVING_SETJMP\n \t    ||\n #endif\n-\t    ! TREE_REGDECL (decl)))\n+\t    ! DECL_REGISTER (decl)))\n       put_var_into_stack (decl);\n   for (sub = BLOCK_SUBBLOCKS (block); sub; sub = TREE_CHAIN (sub))\n     setjmp_protect (sub);\n@@ -3289,7 +3289,7 @@ setjmp_protect_args ()\n \t    NON_SAVING_SETJMP\n \t    ||\n #endif\n-\t    ! TREE_REGDECL (decl)))\n+\t    ! DECL_REGISTER (decl)))\n       put_var_into_stack (decl);\n }\n \f\n@@ -3783,7 +3783,7 @@ expand_function_start (subr, parms_have_cleanups)\n \t  REG_FUNCTION_VALUE_P (DECL_RTL (DECL_RESULT (subr))) = 1;\n \t  /* Needed because we may need to move this to memory\n \t     in case it's a named return value whose address is taken.  */\n-\t  TREE_REGDECL (DECL_RESULT (subr)) = 1;\n+\t  DECL_REGISTER (DECL_RESULT (subr)) = 1;\n \t}\n     }\n "}]}