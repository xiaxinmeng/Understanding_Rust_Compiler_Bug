{"sha": "6a83e470e7d1687bbd83c776891122efe814c52f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE4M2U0NzBlN2QxNjg3YmJkODNjNzc2ODkxMTIyZWZlODE0YzUyZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.soma.redhat.com", "date": "2000-06-03T02:20:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-06-03T02:20:09Z"}, "message": "exception.cc (__cp_pop_exception): If we aren't popping or rethrowing, push down past any uncaught exceptions.\n\n        * exception.cc (__cp_pop_exception): If we aren't popping or\n        rethrowing, push down past any uncaught exceptions.\n        (__uncatch_exception): Rethrow the currently handled exception.\n        Move it to the top of the exception stack.\n\nFrom-SVN: r34375", "tree": {"sha": "caab236cb72cdba2203ea2f51ada560a2e434ed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caab236cb72cdba2203ea2f51ada560a2e434ed2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a83e470e7d1687bbd83c776891122efe814c52f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a83e470e7d1687bbd83c776891122efe814c52f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a83e470e7d1687bbd83c776891122efe814c52f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a83e470e7d1687bbd83c776891122efe814c52f/comments", "author": null, "committer": null, "parents": [{"sha": "de695d2c6db46e8272f3c1a04adc9b355a3059f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de695d2c6db46e8272f3c1a04adc9b355a3059f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de695d2c6db46e8272f3c1a04adc9b355a3059f7"}], "stats": {"total": 68, "additions": 59, "deletions": 9}, "files": [{"sha": "20e5058116743f8d1edc71f4e76a73b4f04b7727", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a83e470e7d1687bbd83c776891122efe814c52f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a83e470e7d1687bbd83c776891122efe814c52f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6a83e470e7d1687bbd83c776891122efe814c52f", "patch": "@@ -1,3 +1,10 @@\n+2000-06-02  Jason Merrill  <jason@casey.soma.redhat.com>\n+\n+\t* exception.cc (__cp_pop_exception): If we aren't popping or\n+\trethrowing, push down past any uncaught exceptions.\n+\t(__uncatch_exception): Rethrow the currently handled exception.\n+\tMove it to the top of the exception stack.\n+\n Fri Jun  2 19:38:57 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* cp-tree.h: Use struct tree_common instead of a char array."}, {"sha": "9263bfeaa01164ddd6fcaed9d54cc93ab4a65f57", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a83e470e7d1687bbd83c776891122efe814c52f/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a83e470e7d1687bbd83c776891122efe814c52f/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=6a83e470e7d1687bbd83c776891122efe814c52f", "patch": "@@ -247,17 +247,37 @@ __cp_push_exception (void *value, void *type, cleanup_fn cleanup)\n extern \"C\" void\n __cp_pop_exception (cp_eh_info *p)\n {\n-  cp_eh_info **q = __get_eh_info ();\n+  cp_eh_info **stack = __get_eh_info ();\n+  cp_eh_info **q = stack;\n \n   --p->handlers;\n \n-  /* Don't really pop if there are still active handlers for our exception,\n-     or if our exception is being rethrown (i.e. if the active exception is\n-     our exception and it is uncaught).  */\n-  if (p->handlers != 0\n-      || (p == *q && !p->caught))\n+  /* Do nothing if our exception is being rethrown (i.e. if the active\n+     exception is our exception and it is uncaught).  */\n+  if (p == *q && !p->caught)\n     return;\n \n+  /* Don't really pop if there are still active handlers for our exception;\n+     rather, push it down past any uncaught exceptions.  */\n+  if (p->handlers != 0)\n+    {\n+      if (p == *q && p->next && !p->next->caught)\n+\t{\n+\t  q = &(p->next);\n+\t  while (1)\n+\t    {\n+\t      if (*q == 0 || (*q)->caught)\n+\t\tbreak;\n+\n+\t      q = &((*q)->next);\n+\t    }\n+\t  *stack = p->next;\n+\t  p->next = *q;\n+\t  *q = p;\n+\t}\n+      return;\n+    }\n+\n   for (; *q; q = &((*q)->next))\n     if (*q == p)\n       break;\n@@ -277,12 +297,35 @@ __cp_pop_exception (cp_eh_info *p)\n   __eh_free (p);\n }\n \n+/* We're doing a rethrow.  Find the currently handled exception, mark it\n+   uncaught, and move it to the top of the EH stack.  */\n+\n extern \"C\" void\n __uncatch_exception (void)\n {\n-  cp_eh_info *p = CP_EH_INFO;\n-  if (p == 0)\n-    terminate ();\n+  cp_eh_info **stack = __get_eh_info ();\n+  cp_eh_info **q = stack;\n+  cp_eh_info *p;\n+\n+  while (1)\n+    {\n+      p = *q;\n+\n+      if (p == 0)\n+\tterminate ();\n+      if (p->caught)\n+\tbreak;\n+\n+      q = &(p->next);\n+    }\n+\n+  if (q != stack)\n+    {\n+      *q = p->next;\n+      p->next = *stack;\n+      *stack = p;\n+    }\n+\n   p->caught = false;\n }\n "}]}