{"sha": "548cfdc2cac1cf3844136a21a26379c737e0b086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ4Y2ZkYzJjYWMxY2YzODQ0MTM2YTIxYTI2Mzc5YzczN2UwYjA4Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-12-17T12:11:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-12-17T12:11:40Z"}, "message": "expmed.c (lowpart_bit_field_p): Fix comment.\n\n\t* expmed.c (lowpart_bit_field_p): Fix comment.\n\t(store_bit_field_using_insv): Fix formatting.\n\t(store_bit_field): Likewise.\n\t(store_fixed_bit_field): More declaration and remove return.\n\t(store_fixed_bit_field_1): Fix formatting.\n\t(extract_fixed_bit_field): Move declaration.\n\t(extract_fixed_bit_field_1): Simplify.\n\nFrom-SVN: r206044", "tree": {"sha": "c1d8c03d201912b33c62261fa56ad15abfe0994c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1d8c03d201912b33c62261fa56ad15abfe0994c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/548cfdc2cac1cf3844136a21a26379c737e0b086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548cfdc2cac1cf3844136a21a26379c737e0b086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/548cfdc2cac1cf3844136a21a26379c737e0b086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548cfdc2cac1cf3844136a21a26379c737e0b086/comments", "author": null, "committer": null, "parents": [{"sha": "61dd6a2e33c0811de2ade0363fc664221392b9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61dd6a2e33c0811de2ade0363fc664221392b9fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61dd6a2e33c0811de2ade0363fc664221392b9fc"}], "stats": {"total": 39, "additions": 21, "deletions": 18}, "files": [{"sha": "3bd3247eb37fcaa74bef60facbd952863c9a4d6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548cfdc2cac1cf3844136a21a26379c737e0b086/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548cfdc2cac1cf3844136a21a26379c737e0b086/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=548cfdc2cac1cf3844136a21a26379c737e0b086", "patch": "@@ -1,3 +1,13 @@\n+2013-12-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expmed.c (lowpart_bit_field_p): Fix comment.\n+\t(store_bit_field_using_insv): Fix formatting.\n+\t(store_bit_field): Likewise.\n+\t(store_fixed_bit_field): More declaration and remove return.\n+\t(store_fixed_bit_field_1): Fix formatting.\n+\t(extract_fixed_bit_field): Move declaration.\n+\t(extract_fixed_bit_field_1): Simplify.\n+\n 2013-12-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-utils.h (possible_polymorphic_call_targets): Determine context of"}, {"sha": "f672678a2d8f96a6a9f648d204f8a0fc19e8be34", "filename": "gcc/expmed.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548cfdc2cac1cf3844136a21a26379c737e0b086/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548cfdc2cac1cf3844136a21a26379c737e0b086/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=548cfdc2cac1cf3844136a21a26379c737e0b086", "patch": "@@ -422,7 +422,7 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n     return bitnum % BITS_PER_WORD == 0;\n }\n \n-/* Return true if -fstrict-volatile-bitfields applies an access of OP0\n+/* Return true if -fstrict-volatile-bitfields applies to an access of OP0\n    containing BITSIZE bits starting at BITNUM, with field mode FIELDMODE.\n    Return false if the access would touch memory outside the range\n    BITREGION_START to BITREGION_END for conformance to the C++ memory\n@@ -490,7 +490,8 @@ simple_mem_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n static bool\n store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n \t\t\t    unsigned HOST_WIDE_INT bitsize,\n-\t\t\t    unsigned HOST_WIDE_INT bitnum, rtx value)\n+\t\t\t    unsigned HOST_WIDE_INT bitnum,\n+\t\t\t    rtx value)\n {\n   struct expand_operand ops[4];\n   rtx value1;\n@@ -940,7 +941,6 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, fieldmode,\n \t\t\t\t  bitregion_start, bitregion_end))\n     {\n-\n       /* Storing any naturally aligned field can be done with a simple\n \t store.  For targets that support fast unaligned memory, any\n \t naturally sized, unit aligned field can be done directly.  */\n@@ -957,8 +957,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  /* Explicitly override the C/C++ memory model; ignore the\n \t     bit range so that we can do the access in the mode mandated\n \t     by -fstrict-volatile-bitfields instead.  */\n-\t  store_fixed_bit_field_1 (str_rtx, bitsize, bitnum,\n-\t\t\t\t   value);\n+\t  store_fixed_bit_field_1 (str_rtx, bitsize, bitnum, value);\n \t}\n \n       return;\n@@ -1002,8 +1001,6 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t       unsigned HOST_WIDE_INT bitregion_end,\n \t\t       rtx value)\n {\n-  enum machine_mode mode;\n-\n   /* There is a case not handled here:\n      a structure with a known alignment of just a halfword\n      and a field split across two aligned halfwords within the structure.\n@@ -1013,7 +1010,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \n   if (MEM_P (op0))\n     {\n-      mode = GET_MODE (op0);\n+      enum machine_mode mode = GET_MODE (op0);\n       if (GET_MODE_BITSIZE (mode) == 0\n \t  || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n \tmode = word_mode;\n@@ -1033,16 +1030,15 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     }\n \n   store_fixed_bit_field_1 (op0, bitsize, bitnum, value);\n-  return;\n }\n \n /* Helper function for store_fixed_bit_field, stores\n    the bit field always using the MODE of OP0.  */\n \n static void\n store_fixed_bit_field_1 (rtx op0, unsigned HOST_WIDE_INT bitsize,\n-\t\t         unsigned HOST_WIDE_INT bitnum,\n-\t\t         rtx value)\n+\t\t\t unsigned HOST_WIDE_INT bitnum,\n+\t\t\t rtx value)\n {\n   enum machine_mode mode;\n   rtx temp;\n@@ -1793,12 +1789,11 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t\t\t unsigned HOST_WIDE_INT bitnum, rtx target,\n \t\t\t int unsignedp)\n {\n-  enum machine_mode mode;\n-\n   if (MEM_P (op0))\n     {\n-      mode = get_best_mode (bitsize, bitnum, 0, 0,\n-\t\t\t    MEM_ALIGN (op0), word_mode, MEM_VOLATILE_P (op0));\n+      enum machine_mode mode\n+\t= get_best_mode (bitsize, bitnum, 0, 0, MEM_ALIGN (op0), word_mode,\n+\t\t\t MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t/* The only way this should occur is if the field spans word\n@@ -1821,9 +1816,7 @@ extract_fixed_bit_field_1 (enum machine_mode tmode, rtx op0,\n \t\t\t   unsigned HOST_WIDE_INT bitnum, rtx target,\n \t\t\t   int unsignedp)\n {\n-  enum machine_mode mode;\n-\n-  mode = GET_MODE (op0);\n+  enum machine_mode mode = GET_MODE (op0);\n   gcc_assert (SCALAR_INT_MODE_P (mode));\n \n   /* Note that bitsize + bitnum can be greater than GET_MODE_BITSIZE (mode)"}]}