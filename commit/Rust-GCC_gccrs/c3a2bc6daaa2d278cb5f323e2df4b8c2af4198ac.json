{"sha": "c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNhMmJjNmRhYWEyZDI3OGNiNWYzMjNlMmRmNGI4YzJhZjQxOThhYw==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-03-19T14:29:36Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-03-19T14:29:36Z"}, "message": "slp: remove unneeded permute calculation (PR99656)\n\nThe attach testcase ICEs because as you showed on the PR we have one child\nwhich is an internal with a PERM of EVENEVEN and one with TOP.\n\nThe problem is while we can conceptually merge the permute itself into EVENEVEN,\nmerging the lanes don't really make sense.\n\nThat said, we no longer even require the merged lanes as we create the permutes\nbased on the KIND directly.\n\nThis patch just removes all of that code.\n\nUnfortunately it still won't vectorize with the cost model enabled due to the\nblend that's created combining the load and the external\n\n\tnote: node 0x51f2ce8 (max_nunits=1, refcnt=1)\n\tnote: op: VEC_PERM_EXPR\n\tnote:       { }\n\tnote:       lane permutation { 0[0] 1[1] }\n\tnote:       children 0x51f23e0 0x51f2578\n\tnote: node 0x51f23e0 (max_nunits=2, refcnt=1)\n\tnote: op template: _16 = REALPART_EXPR <*t1_9(D)>;\n\tnote:       stmt 0 _16 = REALPART_EXPR <*t1_9(D)>;\n\tnote:       stmt 1 _16 = REALPART_EXPR <*t1_9(D)>;\n\tnote:       load permutation { 0 0 }\n\tnote: node (external) 0x51f2578 (max_nunits=1, refcnt=1)\n\tnote:       { _18, _18 }\n\nwhich costs the cost for the load-and-split and the cost of the external splat,\nand the one for blending them while in reality it's just a scalar load and\ninsert.\n\nThe compiler (with the cost model disabled) generates\n\n\tldr     q1, [x19]\n\tdup     v1.2d, v1.d[0]\n\tldr     d0, [x19, 8]\n\tfneg    d0, d0\n\tins     v1.d[1], v0.d[0]\n\nwhile really it should be\n\n\tldp     d1, d0, [x19]\n\tfneg    d0, d0\n\tins     v1.d[1], v0.d[0]\n\nbut that's for another time.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/99656\n\t* tree-vect-slp-patterns.c (linear_loads_p,\n\tcomplex_add_pattern::matches, is_eq_or_top,\n\tvect_validate_multiplication, complex_mul_pattern::matches,\n\tcomplex_fms_pattern::matches): Remove complex_perm_kinds_t.\n\t* tree-vectorizer.h: (complex_load_perm_t): Removed.\n\t(slp_tree_to_load_perm_map_t): Use complex_perm_kinds_t instead of\n\tcomplex_load_perm_t.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/99656\n\t* gfortran.dg/vect/pr99656.f90: New test.", "tree": {"sha": "4e45e808c1e9b8eac8fee0a55e2c273fb9d03a14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e45e808c1e9b8eac8fee0a55e2c273fb9d03a14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e2eabe1eed1e53d39923517122d3c7de2013ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2eabe1eed1e53d39923517122d3c7de2013ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e2eabe1eed1e53d39923517122d3c7de2013ad4"}], "stats": {"total": 94, "additions": 47, "deletions": 47}, "files": [{"sha": "59a28ee19e8f352d534e51558a7fce5c4d78100e", "filename": "gcc/testsuite/gfortran.dg/vect/pr99656.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr99656.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr99656.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr99656.f90?ref=c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile { target { aarch64*-*-* } } }\n+! { dg-require-effective-target le }\n+! { dg-additional-options \"-march=armv8.3-a -O1 -ftree-slp-vectorize\" }\n+\n+SUBROUTINE ZLAHQR2(H, LDH, H22, T1)\n+\n+      INTEGER            LDH\n+      COMPLEX*16         H(LDH, *)\n+\n+      INTEGER            NR\n+      COMPLEX*16         H22, SUM, T1, V2\n+\n+      COMPLEX*16         V( 3 )\n+\n+      EXTERNAL           ZLARFG\n+      INTRINSIC          DCONJG\n+\n+      V2 = H22\n+      CALL ZLARFG(T1)\n+      SUM = DCONJG(T1) * H(1, 1)\n+      H(1, 1) = SUM * V2\n+\n+      RETURN\n+END"}, {"sha": "85f2d03754d3ed87e4e34befdca417f2dd4ea21d", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac", "patch": "@@ -203,68 +203,49 @@ vect_merge_perms (complex_perm_kinds_t a, complex_perm_kinds_t b)\n /* Check to see if all loads rooted in ROOT are linear.  Linearity is\n    defined as having no gaps between values loaded.  */\n \n-static complex_load_perm_t\n+static complex_perm_kinds_t\n linear_loads_p (slp_tree_to_load_perm_map_t *perm_cache, slp_tree root)\n {\n   if (!root)\n-    return std::make_pair (PERM_UNKNOWN, vNULL);\n+    return PERM_UNKNOWN;\n \n   unsigned i;\n-  complex_load_perm_t *tmp;\n+  complex_perm_kinds_t *tmp;\n \n   if ((tmp = perm_cache->get (root)) != NULL)\n     return *tmp;\n \n-  complex_load_perm_t retval = std::make_pair (PERM_UNKNOWN, vNULL);\n+  complex_perm_kinds_t retval = PERM_UNKNOWN;\n   perm_cache->put (root, retval);\n \n   /* If it's a load node, then just read the load permute.  */\n   if (SLP_TREE_LOAD_PERMUTATION (root).exists ())\n     {\n-      retval.first = is_linear_load_p (SLP_TREE_LOAD_PERMUTATION (root));\n-      retval.second = SLP_TREE_LOAD_PERMUTATION (root);\n+      retval = is_linear_load_p (SLP_TREE_LOAD_PERMUTATION (root));\n       perm_cache->put (root, retval);\n       return retval;\n     }\n   else if (SLP_TREE_DEF_TYPE (root) != vect_internal_def)\n     {\n-      retval.first = PERM_TOP;\n+      retval = PERM_TOP;\n       perm_cache->put (root, retval);\n       return retval;\n     }\n \n-  auto_vec<load_permutation_t> all_loads;\n   complex_perm_kinds_t kind = PERM_TOP;\n \n   slp_tree child;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (root), i, child)\n     {\n-      complex_load_perm_t res = linear_loads_p (perm_cache, child);\n-      kind = vect_merge_perms (kind, res.first);\n+      complex_perm_kinds_t res = linear_loads_p (perm_cache, child);\n+      kind = vect_merge_perms (kind, res);\n       /* Unknown and Top are not valid on blends as they produce no permute.  */\n-      retval.first = kind;\n+      retval = kind;\n       if (kind == PERM_UNKNOWN || kind == PERM_TOP)\n \treturn retval;\n-      all_loads.safe_push (res.second);\n     }\n \n-  if (SLP_TREE_LANE_PERMUTATION (root).exists ())\n-    {\n-      lane_permutation_t perm = SLP_TREE_LANE_PERMUTATION (root);\n-      load_permutation_t nloads;\n-      nloads.create (SLP_TREE_LANES (root));\n-      nloads.quick_grow (SLP_TREE_LANES (root));\n-      for (i = 0; i < SLP_TREE_LANES (root); i++)\n-\tnloads[i] = all_loads[perm[i].first][perm[i].second];\n-\n-      retval.first = kind;\n-      retval.second = nloads;\n-    }\n-  else\n-    {\n-      retval.first = kind;\n-      retval.second = all_loads[0];\n-    }\n+  retval = kind;\n \n   perm_cache->put (root, retval);\n   return retval;\n@@ -704,11 +685,11 @@ complex_add_pattern::matches (complex_operation_t op,\n   vec<slp_tree> children = SLP_TREE_CHILDREN ((*ops)[0]);\n \n   /* First node must be unpermuted.  */\n-  if (linear_loads_p (perm_cache, children[0]).first != PERM_EVENODD)\n+  if (linear_loads_p (perm_cache, children[0]) != PERM_EVENODD)\n     return IFN_LAST;\n \n   /* Second node must be permuted.  */\n-  if (linear_loads_p (perm_cache, children[1]).first != PERM_ODDEVEN)\n+  if (linear_loads_p (perm_cache, children[1]) != PERM_ODDEVEN)\n     return IFN_LAST;\n \n   if (!vect_pattern_validate_optab (ifn, *node))\n@@ -795,9 +776,9 @@ vect_normalize_conj_loc (vec<slp_tree> args, bool *neg_first_p = NULL)\n /* Helper function to check if PERM is KIND or PERM_TOP.  */\n \n static inline bool\n-is_eq_or_top (complex_load_perm_t perm, complex_perm_kinds_t kind)\n+is_eq_or_top (complex_perm_kinds_t perm, complex_perm_kinds_t kind)\n {\n-  return perm.first == kind || perm.first == PERM_TOP;\n+  return perm == kind || perm == PERM_TOP;\n }\n \n /* Helper function that checks to see if LEFT_OP and RIGHT_OP are both MULT_EXPR\n@@ -828,7 +809,7 @@ vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n       /* Canonicalization for fms is not consistent. So have to test both\n \t variants to be sure.  This needs to be fixed in the mid-end so\n \t this part can be simpler.  */\n-      kind = linear_loads_p (perm_cache, right_op[0]).first;\n+      kind = linear_loads_p (perm_cache, right_op[0]);\n       if (!((is_eq_or_top (linear_loads_p (perm_cache, right_op[0]), PERM_ODDODD)\n \t   && is_eq_or_top (linear_loads_p (perm_cache, right_op[1]),\n \t\t\t     PERM_ODDEVEN))\n@@ -839,7 +820,7 @@ vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n     }\n   else\n     {\n-      if (linear_loads_p (perm_cache, right_op[1]).first != PERM_ODDODD\n+      if (linear_loads_p (perm_cache, right_op[1]) != PERM_ODDODD\n \t  && !is_eq_or_top (linear_loads_p (perm_cache, right_op[0]),\n \t\t\t    PERM_ODDEVEN))\n \treturn false;\n@@ -852,15 +833,15 @@ vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n   /* Check if the conjugate is on the second first or second operand.  The\n      order of the node with the conjugate value determines this, and the dup\n      node must be one of lane 0 of the same DR as the neg node.  */\n-  kind = linear_loads_p (perm_cache, left_op[index1]).first;\n+  kind = linear_loads_p (perm_cache, left_op[index1]);\n   if (kind == PERM_TOP)\n     {\n-      if (linear_loads_p (perm_cache, left_op[index2]).first == PERM_EVENODD)\n+      if (linear_loads_p (perm_cache, left_op[index2]) == PERM_EVENODD)\n \treturn true;\n     }\n   else if (kind == PERM_EVENODD)\n     {\n-      if ((kind = linear_loads_p (perm_cache, left_op[index2]).first) == PERM_EVENODD)\n+      if ((kind = linear_loads_p (perm_cache, left_op[index2])) == PERM_EVENODD)\n \treturn false;\n       return true;\n     }\n@@ -1003,7 +984,7 @@ complex_mul_pattern::matches (complex_operation_t op,\n   left_op.safe_splice (SLP_TREE_CHILDREN (muls[0]));\n   right_op.safe_splice (SLP_TREE_CHILDREN (muls[1]));\n \n-  if (linear_loads_p (perm_cache, left_op[1]).first == PERM_ODDEVEN)\n+  if (linear_loads_p (perm_cache, left_op[1]) == PERM_ODDEVEN)\n     return IFN_LAST;\n \n   bool neg_first = false;\n@@ -1035,7 +1016,7 @@ complex_mul_pattern::matches (complex_operation_t op,\n   ops->truncate (0);\n   ops->create (3);\n \n-  complex_perm_kinds_t kind = linear_loads_p (perm_cache, left_op[0]).first;\n+  complex_perm_kinds_t kind = linear_loads_p (perm_cache, left_op[0]);\n   if (kind == PERM_EVENODD)\n     {\n       ops->quick_push (left_op[1]);\n@@ -1356,7 +1337,7 @@ complex_fms_pattern::matches (complex_operation_t op,\n   ops->truncate (0);\n   ops->create (4);\n \n-  complex_perm_kinds_t kind = linear_loads_p (perm_cache, right_op[0]).first;\n+  complex_perm_kinds_t kind = linear_loads_p (perm_cache, right_op[0]);\n   if (kind == PERM_EVENODD)\n     {\n       ops->quick_push (child);"}, {"sha": "9861d9e88102138c0e2de8dfc34422ff65a0e9e0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c3a2bc6daaa2d278cb5f323e2df4b8c2af4198ac", "patch": "@@ -2059,13 +2059,8 @@ typedef enum _complex_perm_kinds {\n    PERM_TOP\n } complex_perm_kinds_t;\n \n-/* A pair with a load permute and a corresponding complex_perm_kind which gives\n-   information about the load it represents.  */\n-typedef std::pair<complex_perm_kinds_t, load_permutation_t>\n-  complex_load_perm_t;\n-\n /* Cache from nodes to the load permutation they represent.  */\n-typedef hash_map <slp_tree, complex_load_perm_t>\n+typedef hash_map <slp_tree, complex_perm_kinds_t>\n   slp_tree_to_load_perm_map_t;\n \n /* Vector pattern matcher base class.  All SLP pattern matchers must inherit"}]}