{"sha": "f2918c18ccd3400f81c8fd5143602bbc584c9640", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5MThjMThjY2QzNDAwZjgxYzhmZDUxNDM2MDJiYmM1ODRjOTY0MA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2014-06-17T23:20:30Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2014-06-17T23:20:30Z"}, "message": "tree-dfa.h (get_addr_base_and_unit_offset_1): Move from here.\n\n\n\t* tree-dfa.h (get_addr_base_and_unit_offset_1): Move from here.\n\t* tree-dfa.c (get_addr_base_and_unit_offset_1): To here.\n\nFrom-SVN: r211757", "tree": {"sha": "7a47841c50b6dcfc9851c43c1adcbdcabab19d58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a47841c50b6dcfc9851c43c1adcbdcabab19d58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2918c18ccd3400f81c8fd5143602bbc584c9640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2918c18ccd3400f81c8fd5143602bbc584c9640", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2918c18ccd3400f81c8fd5143602bbc584c9640", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2918c18ccd3400f81c8fd5143602bbc584c9640/comments", "author": null, "committer": null, "parents": [{"sha": "5a96dac608806ab37202bb7a4275a0f84755bde5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a96dac608806ab37202bb7a4275a0f84755bde5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a96dac608806ab37202bb7a4275a0f84755bde5"}], "stats": {"total": 289, "additions": 146, "deletions": 143}, "files": [{"sha": "ef2dbd017731ee3278bd1a7e03e038bdffc7cde8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2918c18ccd3400f81c8fd5143602bbc584c9640/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2918c18ccd3400f81c8fd5143602bbc584c9640/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2918c18ccd3400f81c8fd5143602bbc584c9640", "patch": "@@ -1,3 +1,8 @@\n+2014-06-17  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-dfa.h (get_addr_base_and_unit_offset_1): Move from here.\n+\t* tree-dfa.c (get_addr_base_and_unit_offset_1): To here.\n+\n 2014-06-17  Xinliang David Li  <davidxl@google.com>\n \n \t* tree-pretty-print.c (dump_function_header): Print cgraph uid."}, {"sha": "c55c9b9d5ca9a5f4f2e0c4b6fcd07cde79574899", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2918c18ccd3400f81c8fd5143602bbc584c9640/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2918c18ccd3400f81c8fd5143602bbc584c9640/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=f2918c18ccd3400f81c8fd5143602bbc584c9640", "patch": "@@ -661,6 +661,145 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   return exp;\n }\n \n+/* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n+   denotes the starting address of the memory access EXP.\n+   Returns NULL_TREE if the offset is not constant or any component\n+   is not BITS_PER_UNIT-aligned.\n+   VALUEIZE if non-NULL is used to valueize SSA names.  It should return\n+   its argument or a constant if the argument is known to be constant.  */\n+\n+tree\n+get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n+\t\t\t\t tree (*valueize) (tree))\n+{\n+  HOST_WIDE_INT byte_offset = 0;\n+\n+  /* Compute cumulative byte-offset for nested component-refs and array-refs,\n+     and find the ultimate containing object.  */\n+  while (1)\n+    {\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase BIT_FIELD_REF:\n+\t  {\n+\t    HOST_WIDE_INT this_off = TREE_INT_CST_LOW (TREE_OPERAND (exp, 2));\n+\t    if (this_off % BITS_PER_UNIT)\n+\t      return NULL_TREE;\n+\t    byte_offset += this_off / BITS_PER_UNIT;\n+\t  }\n+\t  break;\n+\n+\tcase COMPONENT_REF:\n+\t  {\n+\t    tree field = TREE_OPERAND (exp, 1);\n+\t    tree this_offset = component_ref_field_offset (exp);\n+\t    HOST_WIDE_INT hthis_offset;\n+\n+\t    if (!this_offset\n+\t\t|| TREE_CODE (this_offset) != INTEGER_CST\n+\t\t|| (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n+\t\t    % BITS_PER_UNIT))\n+\t      return NULL_TREE;\n+\n+\t    hthis_offset = TREE_INT_CST_LOW (this_offset);\n+\t    hthis_offset += (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n+\t\t\t     / BITS_PER_UNIT);\n+\t    byte_offset += hthis_offset;\n+\t  }\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  {\n+\t    tree index = TREE_OPERAND (exp, 1);\n+\t    tree low_bound, unit_size;\n+\n+\t    if (valueize\n+\t\t&& TREE_CODE (index) == SSA_NAME)\n+\t      index = (*valueize) (index);\n+\n+\t    /* If the resulting bit-offset is constant, track it.  */\n+\t    if (TREE_CODE (index) == INTEGER_CST\n+\t\t&& (low_bound = array_ref_low_bound (exp),\n+\t\t    TREE_CODE (low_bound) == INTEGER_CST)\n+\t\t&& (unit_size = array_ref_element_size (exp),\n+\t\t    TREE_CODE (unit_size) == INTEGER_CST))\n+\t      {\n+\t\toffset_int woffset\n+\t\t  = wi::sext (wi::to_offset (index) - wi::to_offset (low_bound),\n+\t\t\t      TYPE_PRECISION (TREE_TYPE (index)));\n+\t\twoffset *= wi::to_offset (unit_size);\n+\t\tbyte_offset += woffset.to_shwi ();\n+\t      }\n+\t    else\n+\t      return NULL_TREE;\n+\t  }\n+\t  break;\n+\n+\tcase REALPART_EXPR:\n+\t  break;\n+\n+\tcase IMAGPART_EXPR:\n+\t  byte_offset += TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (exp)));\n+\t  break;\n+\n+\tcase VIEW_CONVERT_EXPR:\n+\t  break;\n+\n+\tcase MEM_REF:\n+\t  {\n+\t    tree base = TREE_OPERAND (exp, 0);\n+\t    if (valueize\n+\t\t&& TREE_CODE (base) == SSA_NAME)\n+\t      base = (*valueize) (base);\n+\n+\t    /* Hand back the decl for MEM[&decl, off].  */\n+\t    if (TREE_CODE (base) == ADDR_EXPR)\n+\t      {\n+\t\tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n+\t\t  {\n+\t\t    offset_int off = mem_ref_offset (exp);\n+\t\t    byte_offset += off.to_short_addr ();\n+\t\t  }\n+\t\texp = TREE_OPERAND (base, 0);\n+\t      }\n+\t    goto done;\n+\t  }\n+\n+\tcase TARGET_MEM_REF:\n+\t  {\n+\t    tree base = TREE_OPERAND (exp, 0);\n+\t    if (valueize\n+\t\t&& TREE_CODE (base) == SSA_NAME)\n+\t      base = (*valueize) (base);\n+\n+\t    /* Hand back the decl for MEM[&decl, off].  */\n+\t    if (TREE_CODE (base) == ADDR_EXPR)\n+\t      {\n+\t\tif (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n+\t\t  return NULL_TREE;\n+\t\tif (!integer_zerop (TMR_OFFSET (exp)))\n+\t\t  {\n+\t\t    offset_int off = mem_ref_offset (exp);\n+\t\t    byte_offset += off.to_short_addr ();\n+\t\t  }\n+\t\texp = TREE_OPERAND (base, 0);\n+\t      }\n+\t    goto done;\n+\t  }\n+\n+\tdefault:\n+\t  goto done;\n+\t}\n+\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+done:\n+\n+  *poffset = byte_offset;\n+  return exp;\n+}\n+\n /* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n    denotes the starting address of the memory access EXP.\n    Returns NULL_TREE if the offset is not constant or any component"}, {"sha": "7dac0882f8ec6c820a6eb655e52652db6619ffb2", "filename": "gcc/tree-dfa.h", "status": "modified", "additions": 2, "deletions": 143, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2918c18ccd3400f81c8fd5143602bbc584c9640/gcc%2Ftree-dfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2918c18ccd3400f81c8fd5143602bbc584c9640/gcc%2Ftree-dfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.h?ref=f2918c18ccd3400f81c8fd5143602bbc584c9640", "patch": "@@ -31,152 +31,11 @@ extern void set_ssa_default_def (struct function *, tree, tree);\n extern tree get_or_create_ssa_default_def (struct function *, tree);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern tree get_addr_base_and_unit_offset_1 (tree, HOST_WIDE_INT *,\n+\t\t\t\t\t     tree (*) (tree));\n extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);\n extern bool stmt_references_abnormal_ssa_name (gimple);\n extern void dump_enumerated_decls (FILE *, int);\n \n-/* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n-   denotes the starting address of the memory access EXP.\n-   Returns NULL_TREE if the offset is not constant or any component\n-   is not BITS_PER_UNIT-aligned.\n-   VALUEIZE if non-NULL is used to valueize SSA names.  It should return\n-   its argument or a constant if the argument is known to be constant.  */\n-/* ??? This is a static inline here to avoid the overhead of the indirect calls\n-   to VALUEIZE.  But is this overhead really that significant?  And should we\n-   perhaps just rely on WHOPR to specialize the function?  */\n-\n-static inline tree\n-get_addr_base_and_unit_offset_1 (tree exp, HOST_WIDE_INT *poffset,\n-\t\t\t\t tree (*valueize) (tree))\n-{\n-  HOST_WIDE_INT byte_offset = 0;\n-\n-  /* Compute cumulative byte-offset for nested component-refs and array-refs,\n-     and find the ultimate containing object.  */\n-  while (1)\n-    {\n-      switch (TREE_CODE (exp))\n-\t{\n-\tcase BIT_FIELD_REF:\n-\t  {\n-\t    HOST_WIDE_INT this_off = TREE_INT_CST_LOW (TREE_OPERAND (exp, 2));\n-\t    if (this_off % BITS_PER_UNIT)\n-\t      return NULL_TREE;\n-\t    byte_offset += this_off / BITS_PER_UNIT;\n-\t  }\n-\t  break;\n-\n-\tcase COMPONENT_REF:\n-\t  {\n-\t    tree field = TREE_OPERAND (exp, 1);\n-\t    tree this_offset = component_ref_field_offset (exp);\n-\t    HOST_WIDE_INT hthis_offset;\n-\n-\t    if (!this_offset\n-\t\t|| TREE_CODE (this_offset) != INTEGER_CST\n-\t\t|| (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n-\t\t    % BITS_PER_UNIT))\n-\t      return NULL_TREE;\n-\n-\t    hthis_offset = TREE_INT_CST_LOW (this_offset);\n-\t    hthis_offset += (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n-\t\t\t     / BITS_PER_UNIT);\n-\t    byte_offset += hthis_offset;\n-\t  }\n-\t  break;\n-\n-\tcase ARRAY_REF:\n-\tcase ARRAY_RANGE_REF:\n-\t  {\n-\t    tree index = TREE_OPERAND (exp, 1);\n-\t    tree low_bound, unit_size;\n-\n-\t    if (valueize\n-\t\t&& TREE_CODE (index) == SSA_NAME)\n-\t      index = (*valueize) (index);\n-\n-\t    /* If the resulting bit-offset is constant, track it.  */\n-\t    if (TREE_CODE (index) == INTEGER_CST\n-\t\t&& (low_bound = array_ref_low_bound (exp),\n-\t\t    TREE_CODE (low_bound) == INTEGER_CST)\n-\t\t&& (unit_size = array_ref_element_size (exp),\n-\t\t    TREE_CODE (unit_size) == INTEGER_CST))\n-\t      {\n-\t\toffset_int woffset\n-\t\t  = wi::sext (wi::to_offset (index) - wi::to_offset (low_bound),\n-\t\t\t      TYPE_PRECISION (TREE_TYPE (index)));\n-\t\twoffset *= wi::to_offset (unit_size);\n-\t\tbyte_offset += woffset.to_shwi ();\n-\t      }\n-\t    else\n-\t      return NULL_TREE;\n-\t  }\n-\t  break;\n-\n-\tcase REALPART_EXPR:\n-\t  break;\n-\n-\tcase IMAGPART_EXPR:\n-\t  byte_offset += TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (exp)));\n-\t  break;\n-\n-\tcase VIEW_CONVERT_EXPR:\n-\t  break;\n-\n-\tcase MEM_REF:\n-\t  {\n-\t    tree base = TREE_OPERAND (exp, 0);\n-\t    if (valueize\n-\t\t&& TREE_CODE (base) == SSA_NAME)\n-\t      base = (*valueize) (base);\n-\n-\t    /* Hand back the decl for MEM[&decl, off].  */\n-\t    if (TREE_CODE (base) == ADDR_EXPR)\n-\t      {\n-\t\tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n-\t\t  {\n-\t\t    offset_int off = mem_ref_offset (exp);\n-\t\t    byte_offset += off.to_short_addr ();\n-\t\t  }\n-\t\texp = TREE_OPERAND (base, 0);\n-\t      }\n-\t    goto done;\n-\t  }\n-\n-\tcase TARGET_MEM_REF:\n-\t  {\n-\t    tree base = TREE_OPERAND (exp, 0);\n-\t    if (valueize\n-\t\t&& TREE_CODE (base) == SSA_NAME)\n-\t      base = (*valueize) (base);\n-\n-\t    /* Hand back the decl for MEM[&decl, off].  */\n-\t    if (TREE_CODE (base) == ADDR_EXPR)\n-\t      {\n-\t\tif (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n-\t\t  return NULL_TREE;\n-\t\tif (!integer_zerop (TMR_OFFSET (exp)))\n-\t\t  {\n-\t\t    offset_int off = mem_ref_offset (exp);\n-\t\t    byte_offset += off.to_short_addr ();\n-\t\t  }\n-\t\texp = TREE_OPERAND (base, 0);\n-\t      }\n-\t    goto done;\n-\t  }\n-\n-\tdefault:\n-\t  goto done;\n-\t}\n-\n-      exp = TREE_OPERAND (exp, 0);\n-    }\n-done:\n-\n-  *poffset = byte_offset;\n-  return exp;\n-}\n-\n-\n \n #endif /* GCC_TREE_DFA_H */"}]}