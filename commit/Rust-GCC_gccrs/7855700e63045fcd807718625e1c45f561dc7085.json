{"sha": "7855700e63045fcd807718625e1c45f561dc7085", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg1NTcwMGU2MzA0NWZjZDgwNzcxODYyNWUxYzQ1ZjU2MWRjNzA4NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-04T12:49:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-04T12:49:03Z"}, "message": "gimplify.c (gimplify_scan_omp_clauses): Don't sorry_at on lastprivate conditional on combined for simd.\n\n\t* gimplify.c (gimplify_scan_omp_clauses): Don't sorry_at on lastprivate\n\tconditional on combined for simd.\n\t* omp-low.c (struct omp_context): Add combined_into_simd_safelen0\n\tmember.\n\t(lower_rec_input_clauses): For gimple_omp_for_combined_into_p max_vf 1\n\tconstructs, don't remove lastprivate_conditional_map, but instead set\n\tctx->combined_into_simd_safelen0 and adjust hash_map, so that it points\n\tto parent construct temporaries.\n\t(lower_lastprivate_clauses): Handle ctx->combined_into_simd_safelen0\n\tlike !ctx->lastprivate_conditional_map.\n\t(lower_omp_1) <case GIMPLE_ASSIGN>: If up->combined_into_simd_safelen0,\n\tuse up->outer context instead of up.\n\t* omp-expand.c (expand_omp_for_generic): Perform cond_var bump even if\n\tgimple_omp_for_combined_p.\n\t(expand_omp_for_static_nochunk): Likewise.\n\t(expand_omp_for_static_chunk): Add forgotten cond_var bump that was\n\tprobably moved over into expand_omp_for_generic rather than being copied\n\tthere.\ngcc/cp/\n\t* cp-tree.h (CP_OMP_CLAUSE_INFO): Allow for any clauses up to _condvar_\n\tinstead of only up to linear.\ngcc/testsuite/\n\t* c-c++-common/gomp/lastprivate-conditional-2.c (foo): Don't expect\n\ta sorry_at on any of the clauses.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-7.c: New test.\n\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-8.c: New test.\n\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-9.c: New test.\n\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-10.c: New test.\n\nFrom-SVN: r271907", "tree": {"sha": "89b18afd8600dee3f74ec8eee9799a4697964396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89b18afd8600dee3f74ec8eee9799a4697964396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7855700e63045fcd807718625e1c45f561dc7085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7855700e63045fcd807718625e1c45f561dc7085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7855700e63045fcd807718625e1c45f561dc7085", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7855700e63045fcd807718625e1c45f561dc7085/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0697ecea7cc6f2a0813716fcf8d922f312f59dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0697ecea7cc6f2a0813716fcf8d922f312f59dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0697ecea7cc6f2a0813716fcf8d922f312f59dce"}], "stats": {"total": 440, "additions": 370, "deletions": 70}, "files": [{"sha": "3d1f36d6ce448b50ba7565c0d3daa897c75d55e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -1,3 +1,24 @@\n+2019-06-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (gimplify_scan_omp_clauses): Don't sorry_at on lastprivate\n+\tconditional on combined for simd.\n+\t* omp-low.c (struct omp_context): Add combined_into_simd_safelen0\n+\tmember.\n+\t(lower_rec_input_clauses): For gimple_omp_for_combined_into_p max_vf 1\n+\tconstructs, don't remove lastprivate_conditional_map, but instead set\n+\tctx->combined_into_simd_safelen0 and adjust hash_map, so that it points\n+\tto parent construct temporaries.\n+\t(lower_lastprivate_clauses): Handle ctx->combined_into_simd_safelen0\n+\tlike !ctx->lastprivate_conditional_map.\n+\t(lower_omp_1) <case GIMPLE_ASSIGN>: If up->combined_into_simd_safelen0,\n+\tuse up->outer context instead of up.\n+\t* omp-expand.c (expand_omp_for_generic): Perform cond_var bump even if\n+\tgimple_omp_for_combined_p.\n+\t(expand_omp_for_static_nochunk): Likewise.\n+\t(expand_omp_for_static_chunk): Add forgotten cond_var bump that was\n+\tprobably moved over into expand_omp_for_generic rather than being copied\n+\tthere.\n+\n 2019-06-04  Martin Liska  <mliska@suse.cz>\n \n \t* value-prof.c (dump_histogram_value): Fix typo."}, {"sha": "a3b18c76f5ea10946c6d4185e6d5529ddc287bbf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -1,3 +1,8 @@\n+2019-06-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (CP_OMP_CLAUSE_INFO): Allow for any clauses up to _condvar_\n+\tinstead of only up to linear.\n+\n 2019-06-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* parser.c (cp_parser_unqualified_id): Use build_min_nt_loc in"}, {"sha": "1f4e1e15554ad21f6fe01863274696a39a0814c4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -4924,7 +4924,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    See semantics.c for details.  */\n #define CP_OMP_CLAUSE_INFO(NODE) \\\n   TREE_TYPE (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_PRIVATE, \\\n-\t\t\t\t     OMP_CLAUSE_LINEAR))\n+\t\t\t\t     OMP_CLAUSE__CONDTEMP_))\n \n /* Nonzero if this transaction expression's body contains statements.  */\n #define TRANSACTION_EXPR_IS_STMT(NODE) \\"}, {"sha": "0f3e917bc2238ddb707b1ac152672f6f22a2c204", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -8145,31 +8145,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n \t    }\n \t  if (OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n-\t    {\n-\t      splay_tree_node n = NULL;\n-\t      if (code == OMP_SIMD\n-\t\t  && outer_ctx\n-\t\t  && outer_ctx->region_type == ORT_WORKSHARE)\n-\t\t{\n-\t\t  n = splay_tree_lookup (outer_ctx->variables,\n-\t\t\t\t\t (splay_tree_key) decl);\n-\t\t  if (n == NULL\n-\t\t      && outer_ctx->outer_context\n-\t\t      && (outer_ctx->outer_context->region_type\n-\t\t\t  == ORT_COMBINED_PARALLEL))\n-\t\t    n = splay_tree_lookup (outer_ctx->outer_context->variables,\n-\t\t\t\t\t   (splay_tree_key) decl);\n-\t\t}\n-\t      if (n && (n->value & GOVD_LASTPRIVATE_CONDITIONAL) != 0)\n-\t\t{\n-\t\t  sorry_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"%<conditional%> modifier on %<lastprivate%> \"\n-\t\t\t    \"clause not supported yet\");\n-\t\t  OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c) = 0;\n-\t\t}\n-\t      else\n-\t\tflags |= GOVD_LASTPRIVATE_CONDITIONAL;\n-\t    }\n+\t    flags |= GOVD_LASTPRIVATE_CONDITIONAL;\n \t  if (outer_ctx\n \t      && (outer_ctx->region_type == ORT_COMBINED_PARALLEL\n \t\t  || ((outer_ctx->region_type & ORT_COMBINED_TEAMS)"}, {"sha": "2eae8c02007b8f5c410f223cd2099a081e84deea", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -3257,6 +3257,25 @@ expand_omp_for_generic (struct omp_region *region,\n       vmain = gimple_omp_continue_control_use (cont_stmt);\n       vback = gimple_omp_continue_control_def (cont_stmt);\n \n+      if (cond_var)\n+\t{\n+\t  tree itype = TREE_TYPE (cond_var);\n+\t  tree t2;\n+\t  if ((fd->ordered && fd->collapse == 1)\n+\t       || bias\n+\t       || POINTER_TYPE_P (type)\n+\t       || TREE_CODE (fd->loop.n1) != INTEGER_CST\n+\t       || fd->loop.cond_code != LT_EXPR)\n+\t    t2 = build_int_cst (itype, 1);\n+\t  else\n+\t    t2 = fold_convert (itype, fd->loop.step);\n+\t  t2 = fold_build2 (PLUS_EXPR, itype, cond_var, t2);\n+\t  t2 = force_gimple_operand_gsi (&gsi, t2, false,\n+\t\t\t\t\t NULL_TREE, true, GSI_SAME_STMT);\n+\t  assign_stmt = gimple_build_assign (cond_var, t2);\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+\t}\n+\n       if (!gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n \t  if (POINTER_TYPE_P (type))\n@@ -3270,25 +3289,6 @@ expand_omp_for_generic (struct omp_region *region,\n \t  assign_stmt = gimple_build_assign (vback, t);\n \t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n-\t  if (cond_var)\n-\t    {\n-\t      tree itype = TREE_TYPE (cond_var);\n-\t      tree t2;\n-\t      if ((fd->ordered && fd->collapse == 1)\n-\t\t  || bias\n-\t\t  || POINTER_TYPE_P (type)\n-\t\t  || TREE_CODE (fd->loop.n1) != INTEGER_CST\n-\t\t  || fd->loop.cond_code != LT_EXPR)\n-\t\tt2 = build_int_cst (itype, 1);\n-\t      else\n-\t\tt2 = fold_convert (itype, fd->loop.step);\n-\t      t2 = fold_build2 (PLUS_EXPR, itype, cond_var, t2);\n-\t      t2 = force_gimple_operand_gsi (&gsi, t2, false,\n-\t\t\t\t\t     NULL_TREE, true, GSI_SAME_STMT);\n-\t      assign_stmt = gimple_build_assign (cond_var, t2);\n-\t      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n-\t    }\n-\n \t  if (fd->ordered && counts[fd->collapse - 1] == NULL_TREE)\n \t    {\n \t      tree tem;\n@@ -3962,6 +3962,23 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       vmain = gimple_omp_continue_control_use (cont_stmt);\n       vback = gimple_omp_continue_control_def (cont_stmt);\n \n+      if (cond_var)\n+\t{\n+\t  tree itype = TREE_TYPE (cond_var);\n+\t  tree t2;\n+\t  if (POINTER_TYPE_P (type)\n+\t      || TREE_CODE (n1) != INTEGER_CST\n+\t      || fd->loop.cond_code != LT_EXPR)\n+\t    t2 = build_int_cst (itype, 1);\n+\t  else\n+\t    t2 = fold_convert (itype, step);\n+\t  t2 = fold_build2 (PLUS_EXPR, itype, cond_var, t2);\n+\t  t2 = force_gimple_operand_gsi (&gsi, t2, false,\n+\t\t\t\t\t NULL_TREE, true, GSI_SAME_STMT);\n+\t  assign_stmt = gimple_build_assign (cond_var, t2);\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+\t}\n+\n       if (!gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n \t  if (POINTER_TYPE_P (type))\n@@ -3975,23 +3992,6 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t  assign_stmt = gimple_build_assign (vback, t);\n \t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n \n-\t  if (cond_var)\n-\t    {\n-\t      tree itype = TREE_TYPE (cond_var);\n-\t      tree t2;\n-\t      if (POINTER_TYPE_P (type)\n-\t\t  || TREE_CODE (n1) != INTEGER_CST\n-\t\t  || fd->loop.cond_code != LT_EXPR)\n-\t\tt2 = build_int_cst (itype, 1);\n-\t      else\n-\t\tt2 = fold_convert (itype, step);\n-\t      t2 = fold_build2 (PLUS_EXPR, itype, cond_var, t2);\n-\t      t2 = force_gimple_operand_gsi (&gsi, t2, false,\n-\t\t\t\t\t     NULL_TREE, true, GSI_SAME_STMT);\n-\t      assign_stmt = gimple_build_assign (cond_var, t2);\n-\t      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n-\t    }\n-\n \t  t = build2 (fd->loop.cond_code, boolean_type_node,\n \t\t      DECL_P (vback) && TREE_ADDRESSABLE (vback)\n \t\t      ? t : vback, e);\n@@ -4607,6 +4607,23 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       vmain = gimple_omp_continue_control_use (cont_stmt);\n       vback = gimple_omp_continue_control_def (cont_stmt);\n \n+      if (cond_var)\n+\t{\n+\t  tree itype = TREE_TYPE (cond_var);\n+\t  tree t2;\n+\t  if (POINTER_TYPE_P (type)\n+\t      || TREE_CODE (n1) != INTEGER_CST\n+\t      || fd->loop.cond_code != LT_EXPR)\n+\t    t2 = build_int_cst (itype, 1);\n+\t  else\n+\t    t2 = fold_convert (itype, step);\n+\t  t2 = fold_build2 (PLUS_EXPR, itype, cond_var, t2);\n+\t  t2 = force_gimple_operand_gsi (&gsi, t2, false,\n+\t\t\t\t\t NULL_TREE, true, GSI_SAME_STMT);\n+\t  assign_stmt = gimple_build_assign (cond_var, t2);\n+\t  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+\t}\n+\n       if (!gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n \t  if (POINTER_TYPE_P (type))"}, {"sha": "8fb68a19b0c2f6ae74f6ea4a41918a2bdd410f70", "filename": "gcc/omp-low.c", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -137,6 +137,10 @@ struct omp_context\n \n   /* True if this construct can be cancelled.  */\n   bool cancellable;\n+\n+  /* True if lower_omp_1 should look up lastprivate conditional in parent\n+     context.  */\n+  bool combined_into_simd_safelen0;\n };\n \n static splay_tree all_contexts;\n@@ -4816,6 +4820,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t\t      void_node);\n \t\t\t  gimple_seq tseq = NULL;\n \t\t\t  gimplify_and_add (x, &tseq);\n+\t\t\t  if (ctx->outer)\n+\t\t\t    lower_omp (&tseq, ctx->outer);\n \t\t\t  gimple_seq_add_seq (&llist[1], tseq);\n \t\t\t}\n \t\t      if (y)\n@@ -5278,11 +5284,31 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n       sctx.is_simt = false;\n       if (ctx->lastprivate_conditional_map)\n \t{\n-\t  /* When not vectorized, treat lastprivate(conditional:) like\n-\t     normal lastprivate, as there will be just one simd lane\n-\t     writing the privatized variable.  */\n-\t  delete ctx->lastprivate_conditional_map;\n-\t  ctx->lastprivate_conditional_map = NULL;\n+\t  if (gimple_omp_for_combined_into_p (ctx->stmt))\n+\t    {\n+\t      /* Signal to lower_omp_1 that it should use parent context.  */\n+\t      ctx->combined_into_simd_safelen0 = true;\n+\t      for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t    && OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c))\n+\t\t  {\n+\t\t    tree o = lookup_decl (OMP_CLAUSE_DECL (c), ctx);\n+\t\t    tree *v\n+\t\t      = ctx->lastprivate_conditional_map->get (o);\n+\t\t    tree po = lookup_decl (OMP_CLAUSE_DECL (c), ctx->outer);\n+\t\t    tree *pv\n+\t\t      = ctx->outer->lastprivate_conditional_map->get (po);\n+\t\t    *v = *pv;\n+\t\t  }\n+\t    }\n+\t  else\n+\t    {\n+\t      /* When not vectorized, treat lastprivate(conditional:) like\n+\t\t normal lastprivate, as there will be just one simd lane\n+\t\t writing the privatized variable.  */\n+\t      delete ctx->lastprivate_conditional_map;\n+\t      ctx->lastprivate_conditional_map = NULL;\n+\t    }\n \t}\n     }\n \n@@ -5652,7 +5678,8 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n \n       if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t  && OMP_CLAUSE_LASTPRIVATE_CONDITIONAL (c)\n-\t  && ctx->lastprivate_conditional_map)\n+\t  && ctx->lastprivate_conditional_map\n+\t  && !ctx->combined_into_simd_safelen0)\n \t{\n \t  gcc_assert (body_p);\n \t  if (simduid)\n@@ -10812,6 +10839,8 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    if (tree *v = up->lastprivate_conditional_map->get (lhs))\n \t      {\n \t\ttree clauses;\n+\t\tif (up->combined_into_simd_safelen0)\n+\t\t  up = up->outer;\n \t\tif (gimple_code (up->stmt) == GIMPLE_OMP_FOR)\n \t\t  clauses = gimple_omp_for_clauses (up->stmt);\n \t\telse"}, {"sha": "5978f7905f32e4ef804316b6862a429b8a6cf92b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -1,3 +1,8 @@\n+2019-06-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/lastprivate-conditional-2.c (foo): Don't expect\n+\ta sorry_at on any of the clauses.\n+\n 2019-06-04  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/90726"}, {"sha": "9330beb0ac0ea39c9b8ed9603e32a9fa4663a799", "filename": "gcc/testsuite/c-c++-common/gomp/lastprivate-conditional-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Flastprivate-conditional-2.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -13,15 +13,15 @@ foo (int *p)\n     if (p[i])\n       b = i;\n   #pragma omp parallel\n-  #pragma omp for simd lastprivate (conditional: c) /* { dg-message \"not supported yet\" } */\n+  #pragma omp for simd lastprivate (conditional: c)\n   for (i = 0; i < 32; i++)\n     if (p[i])\n       c = i;\n   #pragma omp parallel for lastprivate (conditional: d)\n   for (i = 0; i < 32; i++)\n     if (p[i])\n       d = i;\n-  #pragma omp parallel for simd lastprivate (conditional: e) /* { dg-message \"not supported yet\" } */\n+  #pragma omp parallel for simd lastprivate (conditional: e)\n   for (i = 0; i < 32; i++)\n     if (p[i])\n       e = i;"}, {"sha": "6371092c117e7929e120e50ab65700dad9724466", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -1,3 +1,10 @@\n+2019-06-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-7.c: New test.\n+\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-8.c: New test.\n+\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-9.c: New test.\n+\t* testsuite/libgomp.c-c++-common/lastprivate-conditional-10.c: New test.\n+\n 2019-05-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac: Call AX_COUNT_CPUS."}, {"sha": "2f7503903fd981e926a373a308aa66a4649281a0", "filename": "libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-10.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-10.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do run } */\n+\n+int v, x;\n+\n+__attribute__((noipa)) int\n+foo (int *a)\n+{\n+  #pragma omp parallel for simd lastprivate (conditional: x) schedule(simd: static) if (simd: 0)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i];\n+  return x;\n+}\n+\n+__attribute__((noipa)) int\n+bar (int *a, int *b)\n+{\n+  #pragma omp parallel\n+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16) simdlen (1)\n+  for (int i = 16; i < 128; ++i)\n+    {\n+      if (a[i])\n+\tx = a[i];\n+      if (b[i])\n+\tv = b[i] + 10;\n+    }\n+  return x;\n+}\n+\n+__attribute__((noipa)) int\n+baz (int *a)\n+{\n+  #pragma omp parallel for simd if (simd: 0) lastprivate (conditional: x) schedule(simd: dynamic, 16)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i] + 5;\n+  return x;\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], b[128], i;\n+  for (i = 0; i < 128; i++)\n+    {\n+      a[i] = ((i % 11) == 2) ? i + 10 : 0;\n+      asm volatile (\"\" : \"+g\" (i));\n+      b[i] = ((i % 13) == 5) ? i * 2 : 0;\n+    }\n+  if (foo (a) != 133)\n+    __builtin_abort ();\n+  if (bar (b, a) != 244 || v != 143)\n+    __builtin_abort ();\n+  if (baz (b) != 249)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "2d542d6d56c315d7a4be3076c031f1197fc644ab", "filename": "libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-7.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-7.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O2 -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { target avx_runtime } } } */\n+\n+int v, x;\n+\n+__attribute__((noipa)) void\n+foo (int *a)\n+{\n+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: static)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i];\n+}\n+\n+__attribute__((noipa)) void\n+bar (int *a, int *b)\n+{\n+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16)\n+  for (int i = 16; i < 128; ++i)\n+    {\n+      if (a[i])\n+\tx = a[i];\n+      if (b[i])\n+\tv = b[i] + 10;\n+    }\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a)\n+{\n+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: dynamic, 16)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i] + 5;\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], b[128], i;\n+  for (i = 0; i < 128; i++)\n+    {\n+      a[i] = ((i % 11) == 2) ? i + 10 : 0;\n+      asm volatile (\"\" : \"+g\" (i));\n+      b[i] = ((i % 13) == 5) ? i * 2 : 0;\n+    }\n+  #pragma omp parallel\n+  foo (a);\n+  if (x != 133)\n+    __builtin_abort ();\n+  x = -3;\n+  #pragma omp parallel\n+  bar (b, a);\n+  if (x != 244 || v != 143)\n+    __builtin_abort ();\n+  #pragma omp parallel\n+  baz (b);\n+  if (x != 249)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "b935a6c2dbfa343c4b0afb050b94e7813afc5640", "filename": "libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-8.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-8.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O2 -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { target avx_runtime } } } */\n+\n+int v, x;\n+\n+__attribute__((noipa)) int\n+foo (int *a)\n+{\n+  #pragma omp parallel for simd lastprivate (conditional: x) schedule(simd: static)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i];\n+  return x;\n+}\n+\n+__attribute__((noipa)) int\n+bar (int *a, int *b)\n+{\n+  #pragma omp parallel\n+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16)\n+  for (int i = 16; i < 128; ++i)\n+    {\n+      if (a[i])\n+\tx = a[i];\n+      if (b[i])\n+\tv = b[i] + 10;\n+    }\n+  return x;\n+}\n+\n+__attribute__((noipa)) int\n+baz (int *a)\n+{\n+  #pragma omp parallel for simd lastprivate (conditional: x) schedule(simd: dynamic, 16)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i] + 5;\n+  return x;\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], b[128], i;\n+  for (i = 0; i < 128; i++)\n+    {\n+      a[i] = ((i % 11) == 2) ? i + 10 : 0;\n+      asm volatile (\"\" : \"+g\" (i));\n+      b[i] = ((i % 13) == 5) ? i * 2 : 0;\n+    }\n+  if (foo (a) != 133)\n+    __builtin_abort ();\n+  if (bar (b, a) != 244 || v != 143)\n+    __builtin_abort ();\n+  if (baz (b) != 249)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "746b2a74c97ebdf3d50ca62db76e7f6d5bfbc04d", "filename": "libgomp/testsuite/libgomp.c-c++-common/lastprivate-conditional-9.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7855700e63045fcd807718625e1c45f561dc7085/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Flastprivate-conditional-9.c?ref=7855700e63045fcd807718625e1c45f561dc7085", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run } */\n+\n+int v, x;\n+\n+__attribute__((noipa)) void\n+foo (int *a)\n+{\n+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: static) if (simd: 0)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i];\n+}\n+\n+__attribute__((noipa)) void\n+bar (int *a, int *b)\n+{\n+  #pragma omp for simd lastprivate (conditional: x, v) schedule(static, 16) simdlen(1)\n+  for (int i = 16; i < 128; ++i)\n+    {\n+      if (a[i])\n+\tx = a[i];\n+      if (b[i])\n+\tv = b[i] + 10;\n+    }\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a)\n+{\n+  #pragma omp for simd lastprivate (conditional: x) schedule(simd: dynamic, 16) if (0)\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      x = a[i] + 5;\n+}\n+\n+int\n+main ()\n+{\n+  int a[128], b[128], i;\n+  for (i = 0; i < 128; i++)\n+    {\n+      a[i] = ((i % 11) == 2) ? i + 10 : 0;\n+      asm volatile (\"\" : \"+g\" (i));\n+      b[i] = ((i % 13) == 5) ? i * 2 : 0;\n+    }\n+  #pragma omp parallel\n+  foo (a);\n+  if (x != 133)\n+    __builtin_abort ();\n+  x = -3;\n+  #pragma omp parallel\n+  bar (b, a);\n+  if (x != 244 || v != 143)\n+    __builtin_abort ();\n+  #pragma omp parallel\n+  baz (b);\n+  if (x != 249)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}