{"sha": "997404de62431a850da6b05e228614a004549705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3NDA0ZGU2MjQzMWE4NTBkYTZiMDVlMjI4NjE0YTAwNDU0OTcwNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-01T14:13:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-01T14:13:44Z"}, "message": "expmed.c (store_bit_field, [...]): Use new named patterns\n\n\n\t* expmed.c (store_bit_field, extract_bit_field): Use new named patterns\n\t* expr.c (store_constructor): Use vec_init pattern.\n\t* genopinit.c (optabs): Initailize vec_set/vec_extract/vec_init.\n\t* optabs.h (optab_index): ADD OTI_vec_set/OTI_vec_extract/OTI_vec_init\n\t(vec_set_optab, vec_extract_optab, vec_init_optab): New.\n\t* i386.md (vec_setv2df, vec_extractv2df, vec_setv4sf, vec_extractv4sf):\n\tNew patterns.\n\t(sse2_unpc?pd): Fix pattern.\n\t(sse2_movlpd): Kill.\n\t(sse2_movsd): Deal with movlpd too.\n\t* i386.c (ix86_expand_builtin): Use sse2_movsd instead of sse2_movlpd.\n\t(ix86_expand_vector_init): New.\n\t* emmintrin.h (__mm_set_pd, __mm_set_ps): Use vector extensions.\n\t* md.texi (vec_set, vec_extract): Document\n\nFrom-SVN: r75304", "tree": {"sha": "366fcb1b6390ba0ac365092bc3e6aee1326879fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/366fcb1b6390ba0ac365092bc3e6aee1326879fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/997404de62431a850da6b05e228614a004549705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997404de62431a850da6b05e228614a004549705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997404de62431a850da6b05e228614a004549705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997404de62431a850da6b05e228614a004549705/comments", "author": null, "committer": null, "parents": [{"sha": "b684a3df8e33898816611f1cefbd0068ca22beca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b684a3df8e33898816611f1cefbd0068ca22beca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b684a3df8e33898816611f1cefbd0068ca22beca"}], "stats": {"total": 506, "additions": 455, "deletions": 51}, "files": [{"sha": "227149518a9a811d0384ae05cf6e700034ff8f00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -1,3 +1,20 @@\n+2004-01-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* expmed.c (store_bit_field, extract_bit_field): Use new named patterns\n+\t* expr.c (store_constructor): Use vec_init pattern.\n+\t* genopinit.c (optabs): Initailize vec_set/vec_extract/vec_init.\n+\t* optabs.h (optab_index): ADD OTI_vec_set/OTI_vec_extract/OTI_vec_init\n+\t(vec_set_optab, vec_extract_optab, vec_init_optab): New.\n+\t* i386.md (vec_setv2df, vec_extractv2df, vec_setv4sf, vec_extractv4sf):\n+\tNew patterns.\n+\t(sse2_unpc?pd): Fix pattern.\n+\t(sse2_movlpd): Kill.\n+\t(sse2_movsd): Deal with movlpd too.\n+\t* i386.c (ix86_expand_builtin): Use sse2_movsd instead of sse2_movlpd.\n+\t(ix86_expand_vector_init): New.\n+\t* emmintrin.h (__mm_set_pd, __mm_set_ps): Use vector extensions.\n+\t* md.texi (vec_set, vec_extract): Document\n+\n 2003-12-31  Jan Hubicka  <jh@suse.cz>\n \n \tPR opt/13473"}, {"sha": "a7dbc6785cb51a7136ea73420dd8993f890b8146", "filename": "gcc/config/i386/emmintrin.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Femmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Femmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Femmintrin.h?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -115,15 +115,7 @@ _mm_set_pd1 (double __F)\n static __inline __m128d\n _mm_set_pd (double __Z, double __Y)\n {\n-  union {\n-    double __a[2];\n-    __m128d __v;\n-  } __u;\n-\n-  __u.__a[0] = __Y;\n-  __u.__a[1] = __Z;\n-\n-  return __u.__v;\n+  return (__v2df) {__Y, __Z};\n }\n \n /* Create the vector [Y Z].  */"}, {"sha": "cc04a680d60a8371450eae2981e7546004ad4edb", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -217,6 +217,7 @@ extern int x86_field_alignment (tree, int);\n extern rtx ix86_tls_get_addr (void);\n extern bool ix86_must_pass_in_stack (enum machine_mode mode, tree);\n \n+extern void ix86_expand_vector_init (rtx, rtx);\n /* In winnt.c  */\n extern int i386_pe_dllexport_name_p (const char *);\n extern int i386_pe_dllimport_name_p (const char *);"}, {"sha": "0b904b173533604b263b8516f66bd41de7241fb1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 90, "deletions": 2, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -14075,7 +14075,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       icode = (fcode == IX86_BUILTIN_LOADHPS ? CODE_FOR_sse_movhps\n \t       : fcode == IX86_BUILTIN_LOADLPS ? CODE_FOR_sse_movlps\n \t       : fcode == IX86_BUILTIN_LOADHPD ? CODE_FOR_sse2_movhpd\n-\t       : CODE_FOR_sse2_movlpd);\n+\t       : CODE_FOR_sse2_movsd);\n       arg0 = TREE_VALUE (arglist);\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n@@ -14104,7 +14104,7 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       icode = (fcode == IX86_BUILTIN_STOREHPS ? CODE_FOR_sse_movhps\n \t       : fcode == IX86_BUILTIN_STORELPS ? CODE_FOR_sse_movlps\n \t       : fcode == IX86_BUILTIN_STOREHPD ? CODE_FOR_sse2_movhpd\n-\t       : CODE_FOR_sse2_movlpd);\n+\t       : CODE_FOR_sse2_movsd);\n       arg0 = TREE_VALUE (arglist);\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n@@ -15784,4 +15784,92 @@ ix86_must_pass_in_stack (enum machine_mode mode, tree type)\n    return (!TARGET_64BIT && type && mode == TImode);\n }\n \n+/* Initialize vector TARGET via VALS.  */\n+void\n+ix86_expand_vector_init (rtx target, rtx vals)\n+{\n+  enum machine_mode mode = GET_MODE (target);\n+  int elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+  int n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+  int i;\n+  \n+  for (i = n_elts - 1; i >= 0; i--)\n+    if (GET_CODE (XVECEXP (vals, 0, i)) != CONST_INT\n+\t&& GET_CODE (XVECEXP (vals, 0, i)) != CONST_DOUBLE)\n+      break;\n+\n+  /* Few special cases first...  \n+     ... constants are best loaded from constant pool.  */\n+  if (i < 0)\n+    {\n+      emit_move_insn (target, gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)));\n+      return;\n+    }\n+\n+  /* ... values where only first field is non-constant are best loaded\n+     from the pool and overwriten via move later.  */\n+  if (!i)\n+    {\n+      rtx op = simplify_gen_subreg (mode, XVECEXP (vals, 0, 0),\n+\t\t\t\t    GET_MODE_INNER (mode), 0);\n+\n+      op = force_reg (mode, op);\n+      XVECEXP (vals, 0, 0) = CONST0_RTX (GET_MODE_INNER (mode));\n+      emit_move_insn (target, gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)));\n+      switch (GET_MODE (target))\n+\t{\n+\t  case V2DFmode:\n+\t    emit_insn (gen_sse2_movsd (target, target, op));\n+\t    break;\n+\t  case V4SFmode:\n+\t    emit_insn (gen_sse_movss (target, target, op));\n+\t    break;\n+\t  default:\n+\t    break;\n+\t}\n+      return;\n+    }\n+\n+  /* And the busy sequence doing rotations.  */\n+  switch (GET_MODE (target))\n+    {\n+      case V2DFmode:\n+\t{\n+\t  rtx vecop0 =\n+\t    simplify_gen_subreg (V2DFmode, XVECEXP (vals, 0, 0), DFmode, 0);\n+\t  rtx vecop1 =\n+\t    simplify_gen_subreg (V2DFmode, XVECEXP (vals, 0, 1), DFmode, 0);\n+\n+\t  vecop0 = force_reg (V2DFmode, vecop0);\n+\t  vecop1 = force_reg (V2DFmode, vecop1);\n+\t  emit_insn (gen_sse2_unpcklpd (target, vecop0, vecop1));\n+\t}\n+\tbreak;\n+      case V4SFmode:\n+\t{\n+\t  rtx vecop0 =\n+\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 0), SFmode, 0);\n+\t  rtx vecop1 =\n+\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 1), SFmode, 0);\n+\t  rtx vecop2 =\n+\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 2), SFmode, 0);\n+\t  rtx vecop3 =\n+\t    simplify_gen_subreg (V4SFmode, XVECEXP (vals, 0, 3), SFmode, 0);\n+\t  rtx tmp1 = gen_reg_rtx (V4SFmode);\n+\t  rtx tmp2 = gen_reg_rtx (V4SFmode);\n+\n+\t  vecop0 = force_reg (V4SFmode, vecop0);\n+\t  vecop1 = force_reg (V4SFmode, vecop1);\n+\t  vecop2 = force_reg (V4SFmode, vecop2);\n+\t  vecop3 = force_reg (V4SFmode, vecop3);\n+\t  emit_insn (gen_sse_unpcklps (tmp1, vecop1, vecop3));\n+\t  emit_insn (gen_sse_unpcklps (tmp2, vecop0, vecop2));\n+\t  emit_insn (gen_sse_unpcklps (target, tmp2, tmp1));\n+\t}\n+\tbreak;\n+      default:\n+\tabort ();\n+    }\n+}\n+\n #include \"gt-i386.h\""}, {"sha": "a004c321b407be3eca820b6744a7141076d86098", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 177, "deletions": 21, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -4728,6 +4728,171 @@\n   \"TARGET_SSE2 && TARGET_SSE_MATH && TARGET_64BIT\"\n   \"x86_emit_floatuns (operands); DONE;\")\n \f\n+;; SSE extract/set expanders\n+\n+(define_expand \"vec_setv2df\"\n+  [(match_operand:V2DF 0 \"register_operand\" \"\")\n+   (match_operand:DF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  switch (INTVAL (operands[2]))\n+    {\n+    case 0:\n+      emit_insn (gen_sse2_movsd (operands[0], operands[0],\n+\t\t\t\t simplify_gen_subreg (V2DFmode, operands[1],\n+\t\t\t\t\t\t      DFmode, 0)));\n+      break;\n+    case 1:\n+      {\n+\trtx op1 = simplify_gen_subreg (V2DFmode, operands[1], DFmode, 0);\n+\n+\temit_insn (gen_sse2_unpcklpd (operands[0], operands[0], op1));\n+      }\n+      break;\n+    default:\n+      abort ();\n+    }\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv2df\"\n+  [(match_operand:DF 0 \"register_operand\" \"\")\n+   (match_operand:V2DF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  switch (INTVAL (operands[2]))\n+    {\n+    case 0:\n+      emit_move_insn (operands[0], gen_lowpart (DFmode, operands[1]));\n+      break;\n+    case 1:\n+      {\n+\trtx dest = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n+\n+\temit_insn (gen_sse2_unpckhpd (dest, operands[1], operands[1]));\n+      }\n+      break;\n+    default:\n+      abort ();\n+    }\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv2df\"\n+  [(match_operand:V2DF 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE2\"\n+{\n+  ix86_expand_vector_init (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_expand \"vec_setv4sf\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand:SF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  switch (INTVAL (operands[2]))\n+    {\n+    case 0:\n+      emit_insn (gen_sse_movss (operands[0], operands[0],\n+\t\t\t\tsimplify_gen_subreg (V4SFmode, operands[1],\n+\t\t\t\t\t\t     SFmode, 0)));\n+      break;\n+    case 1:\n+      {\n+\trtx op1 = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+\trtx tmp = gen_reg_rtx (V4SFmode);\n+ \n+        emit_move_insn (tmp, operands[0]);\n+\temit_insn (gen_sse_unpcklps (operands[0], operands[0], operands[0]));\n+\temit_insn (gen_sse_movss (operands[0], operands[0], op1));\n+        emit_insn (gen_sse_shufps (operands[0], operands[0], tmp,\n+                                   GEN_INT (1 + (0<<2) + (2<<4) + (3<<6))));\n+      }\n+    case 2:\n+      {\n+        rtx op1 = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+        rtx tmp = gen_reg_rtx (V4SFmode);\n+\n+        emit_move_insn (tmp, operands[0]);\n+        emit_insn (gen_sse_movss (tmp, tmp, op1));\n+        emit_insn (gen_sse_shufps (operands[0], operands[0], tmp,\n+                                   GEN_INT (0 + (1<<2) + (0<<4) + (3<<6))));\n+      }\n+      break;\n+    case 3:\n+      {\n+        rtx op1 = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+        rtx tmp = gen_reg_rtx (V4SFmode);\n+\n+        emit_move_insn (tmp, operands[0]);\n+        emit_insn (gen_sse_movss (tmp, tmp, op1));\n+        emit_insn (gen_sse_shufps (operands[0], operands[0], tmp,\n+                                   GEN_INT (0 + (1<<2) + (2<<4) + (0<<6))));\n+      }\n+      break;\n+    default:\n+      abort ();\n+    }\n+  DONE;\n+})\n+\n+(define_expand \"vec_extractv4sf\"\n+  [(match_operand:SF 0 \"register_operand\" \"\")\n+   (match_operand:V4SF 1 \"register_operand\" \"\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  switch (INTVAL (operands[2]))\n+    {\n+    case 0:\n+      emit_move_insn (operands[0], gen_lowpart (SFmode, operands[1]));\n+      break;\n+    case 1:\n+      {\n+\trtx op0 = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+\trtx tmp = gen_reg_rtx (V4SFmode);\n+ \n+        emit_move_insn (tmp, operands[1]);\n+        emit_insn (gen_sse_shufps (op0, tmp, tmp,\n+                                   GEN_INT (1)));\n+      }\n+    case 2:\n+      {\n+\trtx op0 = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+\trtx tmp = gen_reg_rtx (V4SFmode);\n+ \n+        emit_move_insn (tmp, operands[1]);\n+        emit_insn (gen_sse_unpckhps (op0, tmp, tmp));\n+      }\n+    case 3:\n+      {\n+\trtx op0 = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+\trtx tmp = gen_reg_rtx (V4SFmode);\n+ \n+        emit_move_insn (tmp, operands[1]);\n+        emit_insn (gen_sse_shufps (op0, tmp, tmp,\n+                                   GEN_INT (3)));\n+      }\n+    default:\n+      abort ();\n+    }\n+  DONE;\n+})\n+\n+(define_expand \"vec_initv4sf\"\n+  [(match_operand:V4SF 0 \"register_operand\" \"\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (operands[0], operands[1]);\n+  DONE;\n+})\n+\f\n ;; Add instructions\n \n ;; %%% splits for addsidi3\n@@ -22386,23 +22551,23 @@\n \t (vec_select:DF (match_operand:V2DF 1 \"register_operand\" \"0\")\n \t\t\t(parallel [(const_int 1)]))\n \t (vec_select:DF (match_operand:V2DF 2 \"register_operand\" \"x\")\n-\t\t\t(parallel [(const_int 0)]))))]\n+\t\t\t(parallel [(const_int 1)]))))]\n   \"TARGET_SSE2\"\n   \"unpckhpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"V2DF\")])\n \n (define_insn \"sse2_unpcklpd\"\n   [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n \t(vec_concat:V2DF\n \t (vec_select:DF (match_operand:V2DF 1 \"register_operand\" \"0\")\n \t\t\t(parallel [(const_int 0)]))\n \t (vec_select:DF (match_operand:V2DF 2 \"register_operand\" \"x\")\n-\t\t\t(parallel [(const_int 1)]))))]\n+\t\t\t(parallel [(const_int 0)]))))]\n   \"TARGET_SSE2\"\n   \"unpcklpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"V2DF\")])\n \n ;; MMX pack/unpack insns.\n \n@@ -22718,17 +22883,6 @@\n   [(set_attr \"type\" \"ssecvt\")\n    (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"sse2_movlpd\"\n-  [(set (match_operand:V2DF 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(vec_merge:V2DF\n-\t (match_operand:V2DF 1 \"nonimmediate_operand\" \"0,0\")\n-\t (match_operand:V2DF 2 \"nonimmediate_operand\" \"m,x\")\n-\t (const_int 1)))]\n-  \"TARGET_SSE2 && (GET_CODE (operands[1]) == MEM || GET_CODE (operands[2]) == MEM)\"\n-  \"movlpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n (define_expand \"sse2_loadsd\"\n   [(match_operand:V2DF 0 \"register_operand\" \"\")\n    (match_operand:DF 1 \"memory_operand\" \"\")]\n@@ -22751,15 +22905,17 @@\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"sse2_movsd\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:V2DF 0 \"nonimmediate_operand\" \"=x,x,m\")\n \t(vec_merge:V2DF\n-\t (match_operand:V2DF 1 \"register_operand\" \"0\")\n-\t (match_operand:V2DF 2 \"register_operand\" \"x\")\n+\t (match_operand:V2DF 1 \"nonimmediate_operand\" \"0,0,0\")\n+\t (match_operand:V2DF 2 \"nonimmediate_operand\" \"x,m,x\")\n \t (const_int 1)))]\n-  \"TARGET_SSE2\"\n-  \"movsd\\t{%2, %0|%0, %2}\"\n+  \"TARGET_SSE2 && ix86_binary_operator_ok (UNKNOWN, V2DFmode, operands)\"\n+  \"@movsd\\t{%2, %0|%0, %2}\n+    movlpd\\t{%2, %0|%0, %2}\n+    movlpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"DF\")])\n+   (set_attr \"mode\" \"DF,V2DF,V2DF\")])\n \n (define_insn \"sse2_storesd\"\n   [(set (match_operand:DF 0 \"memory_operand\" \"=m\")"}, {"sha": "dc54251eeab02440899cf5f8173b4918e642a8ae", "filename": "gcc/config/i386/xmmintrin.h", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -42,7 +42,6 @@ typedef int __m128 __attribute__ ((__mode__(__V4SF__)));\n \n /* Internal data types for implementing the intrinsics.  */\n typedef int __v4sf __attribute__ ((__mode__(__V4SF__)));\n-typedef int __v4si __attribute__ ((__mode__(__V4SI__)));\n \n /* Create a selector for use with the SHUFPS instruction.  */\n #define _MM_SHUFFLE(fp3,fp2,fp1,fp0) \\\n@@ -890,19 +889,9 @@ _mm_set_ps1 (float __F)\n \n /* Create the vector [Z Y X W].  */\n static __inline __m128\n-_mm_set_ps (float __Z, float __Y, float __X, float __W)\n+_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)\n {\n-  union {\n-    float __a[4];\n-    __m128 __v;\n-  } __u;\n-\n-  __u.__a[0] = __W;\n-  __u.__a[1] = __X;\n-  __u.__a[2] = __Y;\n-  __u.__a[3] = __Z;\n-\n-  return __u.__v;\n+  return (__v4sf) {__W, __X, __Y, __Z};\n }\n \n /* Create the vector [W X Y Z].  */"}, {"sha": "8ebfb4875529d5374d4cec7bec7089019fb63d9d", "filename": "gcc/expmed.c", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -313,6 +313,53 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   value = protect_from_queue (value, 0);\n \n+  /* Use vec_extract patterns for extracting parts of vectors whenever\n+     available.  */\n+  if (VECTOR_MODE_P (GET_MODE (op0))\n+      && GET_CODE (op0) != MEM\n+      && (vec_set_optab->handlers[(int)GET_MODE (op0)].insn_code\n+\t  != CODE_FOR_nothing)\n+      && fieldmode == GET_MODE_INNER (GET_MODE (op0))\n+      && bitsize == GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n+      && !(bitnum % GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n+    {\n+      enum machine_mode outermode = GET_MODE (op0);\n+      enum machine_mode innermode = GET_MODE_INNER (outermode);\n+      int icode = (int) vec_set_optab->handlers[(int) outermode].insn_code;\n+      int pos = bitnum / GET_MODE_BITSIZE (innermode);\n+      rtx rtxpos = GEN_INT (pos);\n+      rtx src = value;\n+      rtx dest = op0;\n+      rtx pat, seq;\n+      enum machine_mode mode0 = insn_data[icode].operand[0].mode;\n+      enum machine_mode mode1 = insn_data[icode].operand[1].mode;\n+      enum machine_mode mode2 = insn_data[icode].operand[2].mode;\n+\n+      start_sequence ();\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (src, mode1))\n+\tsrc = copy_to_mode_reg (mode1, src);\n+\n+      if (! (*insn_data[icode].operand[2].predicate) (rtxpos, mode2))\n+\trtxpos = copy_to_mode_reg (mode1, rtxpos);\n+\n+      /* We could handle this, but we should always be called with a pseudo\n+\t for our targets and all insns should take them as outputs.  */\n+      if (! (*insn_data[icode].operand[0].predicate) (dest, mode0)\n+\t  || ! (*insn_data[icode].operand[1].predicate) (src, mode1)\n+\t  || ! (*insn_data[icode].operand[2].predicate) (rtxpos, mode2))\n+\tabort ();\n+      pat = GEN_FCN (icode) (dest, src, rtxpos);\n+      seq = get_insns ();\n+      end_sequence ();\n+      if (pat)\n+\t{\n+\t  emit_insn (seq);\n+\t  emit_insn (pat);\n+\t  return dest;\n+\t}\n+    }\n+\n   if (flag_force_mem)\n     {\n       int old_generating_concat_p = generating_concat_p;\n@@ -1035,6 +1082,62 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       return op0;\n     }\n \n+  /* Use vec_extract patterns for extracting parts of vectors whenever\n+     available.  */\n+  if (VECTOR_MODE_P (GET_MODE (op0))\n+      && GET_CODE (op0) != MEM\n+      && (vec_extract_optab->handlers[(int)GET_MODE (op0)].insn_code\n+\t  != CODE_FOR_nothing)\n+      && ((bitsize + bitnum) / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))\n+\t  == bitsize / GET_MODE_BITSIZE (GET_MODE_INNER (GET_MODE (op0)))))\n+    {\n+      enum machine_mode outermode = GET_MODE (op0);\n+      enum machine_mode innermode = GET_MODE_INNER (outermode);\n+      int icode = (int) vec_extract_optab->handlers[(int) outermode].insn_code;\n+      int pos = bitnum / GET_MODE_BITSIZE (innermode);\n+      rtx rtxpos = GEN_INT (pos);\n+      rtx src = op0;\n+      rtx dest = NULL, pat, seq;\n+      enum machine_mode mode0 = insn_data[icode].operand[0].mode;\n+      enum machine_mode mode1 = insn_data[icode].operand[1].mode;\n+      enum machine_mode mode2 = insn_data[icode].operand[2].mode;\n+\n+      if (innermode == tmode || innermode == mode)\n+\tdest = target;\n+\n+      if (!dest)\n+\tdest = gen_reg_rtx (innermode);\n+\n+      start_sequence ();\n+\n+      if (! (*insn_data[icode].operand[0].predicate) (dest, mode0))\n+\tdest = copy_to_mode_reg (mode0, dest);\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (src, mode1))\n+\tsrc = copy_to_mode_reg (mode1, src);\n+\n+      if (! (*insn_data[icode].operand[2].predicate) (rtxpos, mode2))\n+\trtxpos = copy_to_mode_reg (mode1, rtxpos);\n+\n+      /* We could handle this, but we should always be called with a pseudo\n+\t for our targets and all insns should take them as outputs.  */\n+      if (! (*insn_data[icode].operand[0].predicate) (dest, mode0)\n+\t  || ! (*insn_data[icode].operand[1].predicate) (src, mode1)\n+\t  || ! (*insn_data[icode].operand[2].predicate) (rtxpos, mode2))\n+\tabort ();\n+      pat = GEN_FCN (icode) (dest, src, rtxpos);\n+      seq = get_insns ();\n+      end_sequence ();\n+      if (pat)\n+\t{\n+\t  emit_insn (seq);\n+\t  emit_insn (pat);\n+\t  return extract_bit_field (dest, bitsize,\n+\t\t\t\t    bitnum - pos * GET_MODE_BITSIZE (innermode),\n+\t\t\t\t    unsignedp, target, mode, tmode, total_size);\n+\t}\n+    }\n+\n   /* Make sure we are playing with integral modes.  Pun with subregs\n      if we aren't.  */\n   {"}, {"sha": "b0608fa57e1c3b2beef35e18b82757e2108283dd", "filename": "gcc/expr.c", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -4710,6 +4710,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n       int const_bounds_p;\n       HOST_WIDE_INT minelt = 0;\n       HOST_WIDE_INT maxelt = 0;\n+      int icode = 0;\n+      rtx *vector = NULL;\n+      int elt_size = 0;\n+      unsigned n_elts = 0;\n \n       /* Vectors are like arrays, but the domain is stored via an array\n \t type indirectly.  */\n@@ -4720,6 +4724,22 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t     it always will.  */\n \t  domain = TYPE_DEBUG_REPRESENTATION_TYPE (type);\n \t  domain = TYPE_DOMAIN (TREE_TYPE (TYPE_FIELDS (domain)));\n+\t  if (REG_P (target) && VECTOR_MODE_P (GET_MODE (target)))\n+\t    {\n+\t      enum machine_mode mode = GET_MODE (target);\n+\n+\t      icode = (int) vec_init_optab->handlers[mode].insn_code;\n+\t      if (icode != CODE_FOR_nothing)\n+\t\t{\n+\t\t  unsigned int i;\n+\n+\t\t  elt_size = GET_MODE_SIZE (GET_MODE_INNER (mode));\n+\t\t  n_elts = (GET_MODE_SIZE (mode) / elt_size);\n+\t\t  vector = alloca (n_elts);\n+\t\t  for (i = 0; i < n_elts; i++)\n+\t\t    vector [i] = CONST0_RTX (GET_MODE_INNER (mode));\n+\t\t}\n+\t    }\n \t}\n \n       const_bounds_p = (TYPE_MIN_VALUE (domain)\n@@ -4784,7 +4804,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    need_to_clear = 1;\n \t}\n \n-      if (need_to_clear && size > 0)\n+      if (need_to_clear && size > 0 && !vector)\n \t{\n \t  if (! cleared)\n \t    {\n@@ -4835,6 +4855,9 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      HOST_WIDE_INT lo, hi, count;\n \t      tree position;\n \n+\t      if (vector)\n+\t\tabort ();\n+\n \t      /* If the range is constant and \"small\", unroll the loop.  */\n \t      if (const_bounds_p\n \t\t  && host_integerp (lo_index, 0)\n@@ -4926,6 +4949,9 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    {\n \t      tree position;\n \n+\t      if (vector)\n+\t\tabort ();\n+\n \t      if (index == 0)\n \t\tindex = ssize_int (1);\n \n@@ -4943,6 +4969,16 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      xtarget = adjust_address (xtarget, mode, 0);\n \t      store_expr (value, xtarget, 0);\n \t    }\n+\t  else if (vector)\n+\t    {\n+\t      int pos;\n+\n+\t      if (index != 0)\n+\t\tpos = tree_low_cst (index, 0) - minelt;\n+\t      else\n+\t\tpos = i;\n+\t      vector[pos] = expand_expr (value, NULL_RTX, VOIDmode, 0);\n+\t    }\n \t  else\n \t    {\n \t      if (index != 0)\n@@ -4958,12 +4994,17 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t  target = copy_rtx (target);\n \t\t  MEM_KEEP_ALIAS_SET_P (target) = 1;\n \t\t}\n-\n-\t      store_constructor_field (target, bitsize, bitpos, mode, value,\n-\t\t\t\t       type, cleared, get_alias_set (elttype));\n-\n+\t      else\n+\t\tstore_constructor_field (target, bitsize, bitpos, mode, value,\n+\t\t\t\t\t type, cleared, get_alias_set (elttype));\n \t    }\n \t}\n+      if (vector)\n+\t{\n+\t  emit_insn (GEN_FCN (icode) (target,\n+\t\t\t\t      gen_rtx_PARALLEL (GET_MODE (target),\n+\t\t\t\t\t\t        gen_rtvec_v (n_elts, vector))));\n+\t}\n     }\n \n   /* Set constructor assignments.  */"}, {"sha": "8f309f43836d9919e85944abd56eb1a5e73d077b", "filename": "gcc/genopinit.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -152,7 +152,10 @@ static const char * const optabs[] =\n   \"movstr_optab[$A] = CODE_FOR_$(movstr$a$)\",\n   \"clrstr_optab[$A] = CODE_FOR_$(clrstr$a$)\",\n   \"cmpstr_optab[$A] = CODE_FOR_$(cmpstr$a$)\",\n-  \"cmpmem_optab[$A] = CODE_FOR_$(cmpmem$a$)\" };\n+  \"cmpmem_optab[$A] = CODE_FOR_$(cmpmem$a$)\",\n+  \"vec_set_optab->handlers[$A].insn_code = CODE_FOR_$(vec_set$a$)\",\n+  \"vec_extract_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract$a$)\",\n+  \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\" };\n \n static void gen_insn (rtx);\n "}, {"sha": "44d4b83ff8a9e955da0c29e4bc1bf51bd507df89", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -5271,6 +5271,9 @@ init_optabs (void)\n   cstore_optab = init_optab (UNKNOWN);\n   push_optab = init_optab (UNKNOWN);\n \n+  vec_extract_optab = init_optab (UNKNOWN);\n+  vec_set_optab = init_optab (UNKNOWN);\n+  vec_init_optab = init_optab (UNKNOWN);\n   /* Conversions.  */\n   sext_optab = init_convert_optab (SIGN_EXTEND);\n   zext_optab = init_convert_optab (ZERO_EXTEND);"}, {"sha": "a85ce3035cb38b964bd8691fcee87a460f1a19fb", "filename": "gcc/optabs.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997404de62431a850da6b05e228614a004549705/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997404de62431a850da6b05e228614a004549705/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=997404de62431a850da6b05e228614a004549705", "patch": "@@ -197,6 +197,13 @@ enum optab_index\n   /* Conditional add instruction.  */\n   OTI_addcc,\n \n+  /* Set specified field of vector operand.  */\n+  OTI_vec_set,\n+  /* Extract specified field of vector operand.  */\n+  OTI_vec_extract,\n+  /* Initialize vector operand.  */\n+  OTI_vec_init,\n+\n   OTI_MAX\n };\n \n@@ -281,6 +288,10 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define push_optab (optab_table[OTI_push])\n #define addcc_optab (optab_table[OTI_addcc])\n \n+#define vec_set_optab (optab_table[OTI_vec_set])\n+#define vec_extract_optab (optab_table[OTI_vec_extract])\n+#define vec_init_optab (optab_table[OTI_vec_init])\n+\n /* Conversion optabs have their own table and indexes.  */\n enum convert_optab_index\n {"}]}