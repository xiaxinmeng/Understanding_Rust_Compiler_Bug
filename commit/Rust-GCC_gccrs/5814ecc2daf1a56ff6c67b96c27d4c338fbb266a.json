{"sha": "5814ecc2daf1a56ff6c67b96c27d4c338fbb266a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxNGVjYzJkYWYxYTU2ZmY2YzY3Yjk2YzI3ZDRjMzM4ZmJiMjY2YQ==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-01-04T00:32:50Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-01-04T00:32:50Z"}, "message": "Date.java (parse): Fix a number of problems.\n\n\n\t* java/util/Date.java (parse):  Fix a number of problems.\n\t(skipParens):  Remove no-longer-needed method.\n\nFrom-SVN: r75381", "tree": {"sha": "d8c8e4116ea6138b8cc7f28f7918f2f5132a0fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c8e4116ea6138b8cc7f28f7918f2f5132a0fa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e237c8f52a6aa729366fc2eeb27257ee6c0cb160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e237c8f52a6aa729366fc2eeb27257ee6c0cb160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e237c8f52a6aa729366fc2eeb27257ee6c0cb160"}], "stats": {"total": 166, "additions": 79, "deletions": 87}, "files": [{"sha": "8ab7e9ba889fd17d633e2457e3e4488b8fbc3da4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5814ecc2daf1a56ff6c67b96c27d4c338fbb266a", "patch": "@@ -1,3 +1,8 @@\n+2004-01-03  Per Bothner  <per@bothner.com>\n+\n+\t* java/util/Date.java (parse):  Fix a number of problems.\n+\t(skipParens):  Remove no-longer-needed method.\n+\n 2003-12-31  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/protocol/http/Connection.java"}, {"sha": "c25b503dcde3ae3388c463ac791413eddf15ad12", "filename": "libjava/java/util/Date.java", "status": "modified", "additions": 74, "deletions": 87, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a/libjava%2Fjava%2Futil%2FDate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5814ecc2daf1a56ff6c67b96c27d4c338fbb266a/libjava%2Fjava%2Futil%2FDate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FDate.java?ref=5814ecc2daf1a56ff6c67b96c27d4c338fbb266a", "patch": "@@ -304,34 +304,6 @@ public String toGMTString()\n     return format.format(this);\n   }\n \n-  private static int skipParens(String string, int offset)\n-  {\n-    int len = string.length();\n-    int p = 0;\n-    int i;\n-\n-    for (i = offset; i < len; ++i)\n-      {\n-\tif (string.charAt(i) == '(')\n-\t  ++p;\n-\telse if (string.charAt(i) == ')')\n-\t  {\n-\t    --p;\n-\t    if (p == 0)\n-\t      return i + 1;\n-\t    // If we've encounted unbalanced parens, just return the\n-\t    // leftover one as an ordinary character.  It will be\n-\t    // caught later in parsing and cause an\n-\t    // IllegalArgumentException.\n-      \t    if (p < 0)\n-\t      return i;\n-\t  }\n-      }\n-\n-    // Not sure what to do if `p != 0' here.\n-    return i;\n-  }\n-\n   private static int parseTz(String tok, char sign)\n     throws IllegalArgumentException\n   {\n@@ -408,20 +380,25 @@ public static long parse(String string)\n \n     // Trim out any nested stuff in parentheses now to make parsing easier.\n     StringBuffer buf = new StringBuffer();\n-    int off = 0;\n-    int openParenOffset, tmpMonth;\n-    while ((openParenOffset = string.indexOf('(', off)) >= 0)\n+    int parenNesting = 0;\n+    int len = string.length();\n+    for (int i = 0;  i < len;  i++)\n       {\n-\t// Copy part of string leading up to open paren.\n-\tbuf.append(string.substring(off, openParenOffset));\n-\toff = skipParens(string, openParenOffset);\n+\tchar ch = string.charAt(i);\n+\tif (ch >= 'a' && ch <= 'z')\n+\t  ch -= 'a' - 'A';\n+\tif (ch == '(')\n+\t  parenNesting++;\n+\telse if (parenNesting == 0)\n+\t  buf.append(ch);\n+\telse if (ch == ')')\n+\t  parenNesting--;\n       }\n-    buf.append(string.substring(off));\n+    int tmpMonth;\n \n     // Make all chars upper case to simplify comparisons later.\n     // Also ignore commas; treat them as delimiters.\n-    StringTokenizer strtok =\n-      new StringTokenizer(buf.toString().toUpperCase(), \" \\t\\n\\r,\");\n+    StringTokenizer strtok = new StringTokenizer(buf.toString(), \" \\t\\n\\r,\");\n \n     while (strtok.hasMoreTokens())\n       {\n@@ -436,56 +413,59 @@ else if (firstch >= '0' && firstch <= '9')\n \t  {\n \t    while (tok != null && tok.length() > 0)\n \t      {\n-\t        // A colon or slash may be valid in the number.\n-\t        // Find the first of these before calling parseInt.\n-\t        int colon = tok.indexOf(':');\n-\t        int slash = tok.indexOf('/');\n-\t        int hyphen = tok.indexOf('-');\n-\t\t// We choose tok.length initially because it makes\n-\t\t// processing simpler.\n-\t        int punctOffset = tok.length();\n-\t\tif (colon >= 0)\n-\t\t  punctOffset = Math.min(punctOffset, colon);\n-\t        if (slash >= 0)\n-\t          punctOffset = Math.min(punctOffset, slash);\n-\t        if (hyphen >= 0)\n-\t          punctOffset = Math.min(punctOffset, hyphen);\n-\t\t// Following code relies on -1 being the exceptional\n-\t\t// case.\n-\t\tif (punctOffset == tok.length())\n-\t\t  punctOffset = -1;\n-\n-\t        int num;\n-\t        try\n-\t          {\n-\t\t    num = Integer.parseInt(punctOffset < 0 ? tok :\n-\t\t\t\t\t   tok.substring(0, punctOffset));\n-\t          }\n-\t        catch (NumberFormatException ex)\n-\t          {\n-\t\t    throw new IllegalArgumentException(tok);\n-\t          }\n-\n-\t\t// TBD: Spec says year can be followed by a slash.  That might\n-\t\t// make sense if using YY/MM/DD formats, but it would fail in\n-\t\t// that format for years <= 70.  Also, what about 1900?  That\n-\t\t// is interpreted as the year 3800; seems that the comparison\n-\t\t// should be num >= 1900 rather than just > 1900.\n-\t\t// What about a year of 62 - 70?  (61 or less could be a (leap)\n-\t\t// second).  70/MM/DD cause an exception but 71/MM/DD is ok\n-\t\t// even though there's no ambiguity in either case.\n-\t\t// For the parse method, the spec as written seems too loose.\n-\t\t// Until shown otherwise, we'll follow the spec as written.\n-\t        if (num > 70 && (punctOffset < 0 || punctOffset == slash))\n-\t\t  year = num > 1900 ? num - 1900 : num;\n-\t\telse if (punctOffset > 0 && punctOffset == colon)\n+\t\tint punctOffset = tok.length();\n+\t\tint num = 0;\n+\t\tint punct;\n+\t\tfor (int i = 0;  ;  i++)\n+\t\t  {\n+\t\t    if (i >= punctOffset)\n+\t\t      {\n+\t\t\tpunct = -1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tpunct = tok.charAt(i);\n+\t\t\tif (punct >= '0' && punct <= '9')\n+\t\t\t  {\n+\t\t\t    if (num > 999999999) // in case of overflow\n+\t\t\t      throw new IllegalArgumentException(tok);\n+\t\t\t    num = 10 * num + (punct - '0');\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    punctOffset = i;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      }\n+\t\t      \n+\t\t  }\n+\n+\t\tif (punct == ':')\n \t\t  {\n \t\t    if (hour < 0)\n \t\t      hour = num;\n \t\t    else\n \t\t      minute = num;\n \t\t  }\n-\t\telse if (punctOffset > 0 && punctOffset == slash)\n+\t        else if ((num >= 70\n+\t\t\t  && (punct == ' ' || punct == ','\n+\t\t\t      || punct == '/' || punct < 0))\n+\t\t\t || (num < 70 && day >= 0 && month >= 0 && year < 0))\n+\t\t  {\n+\t\t    if (num >= 100)\n+\t\t      year = num;\n+\t\t    else\n+\t\t      {\n+\t\t\tint curYear = 1900 + new Date().getYear();\n+\t\t\tint firstYear = curYear - 80;\n+\t\t\tyear = firstYear / 100 * 100 + num;\n+\t\t\tint yx = year;\n+\t\t\tif (year < firstYear)\n+\t\t\t  year += 100;\n+\t\t      }\n+\t\t  }\n+\t\telse if (punct == '/')\n \t\t  {\n \t\t    if (month < 0)\n \t\t      month = num - 1;\n@@ -502,7 +482,7 @@ else if (day < 0)\n \t\t  throw new IllegalArgumentException(tok);\n \n \t\t// Advance string if there's more to process in this token.\n-\t\tif (punctOffset < 0 || punctOffset + 1 >= tok.length())\n+\t\tif (punct < 0 || punctOffset + 1 >= tok.length())\n \t\t  tok = null;\n \t\telse\n \t\t  tok = tok.substring(punctOffset + 1);\n@@ -573,22 +553,29 @@ else if (tok.charAt(1) != 'S')\n \t  throw new IllegalArgumentException(tok);\n       }\n \n-    // Unspecified minutes and seconds should default to 0.\n+    // Unspecified hours, minutes, or seconds should default to 0.\n+    if (hour < 0)\n+      hour = 0;\n     if (minute < 0)\n       minute = 0;\n     if (second < 0)\n       second = 0;\n \n     // Throw exception if any other fields have not been recognized and set.\n-    if (year < 0 || month < 0 || day < 0 || hour < 0)\n+    if (year < 0 || month < 0 || day < 0)\n       throw new IllegalArgumentException(\"Missing field\");\n \n     // Return the time in either local time or relative to GMT as parsed.\n     // If no time-zone was specified, get the local one (in minutes) and\n     // convert to milliseconds before adding to the UTC.\n-    return UTC(year, month, day, hour, minute, second) + (localTimezone ?\n-\t\tnew Date(year, month, day).getTimezoneOffset() * 60 * 1000:\n-\t\t-timezone * 60 * 1000);\n+    GregorianCalendar cal\n+      = new GregorianCalendar(year, month, day, hour, minute, second);\n+    if (!localTimezone)\n+      {\n+\tcal.set(Calendar.ZONE_OFFSET, timezone * 60 * 1000);\n+\tcal.set(Calendar.DST_OFFSET, 0);\n+      }\n+    return cal.getTimeInMillis();\n   }\n \n   /**"}]}