{"sha": "9290558260c3d26ae55adb61a7225dde9e61fb79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI5MDU1ODI2MGMzZDI2YWU1NWFkYjYxYTcyMjVkZGU5ZTYxZmI3OQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-02-20T21:43:33Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-02-20T21:43:33Z"}, "message": "(unroll_loop): Add check for naive loop that ends with\nconditional branch that does not branch back to loop start.\n\nFrom-SVN: r13672", "tree": {"sha": "a91260ab5d148a7022550e1ab143c93a81bd3918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a91260ab5d148a7022550e1ab143c93a81bd3918"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9290558260c3d26ae55adb61a7225dde9e61fb79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9290558260c3d26ae55adb61a7225dde9e61fb79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9290558260c3d26ae55adb61a7225dde9e61fb79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9290558260c3d26ae55adb61a7225dde9e61fb79/comments", "author": null, "committer": null, "parents": [{"sha": "7657bf2fbfd58cc2b4926c32b0d0fe96ec186f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7657bf2fbfd58cc2b4926c32b0d0fe96ec186f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7657bf2fbfd58cc2b4926c32b0d0fe96ec186f57"}], "stats": {"total": 17, "additions": 17, "deletions": 0}, "files": [{"sha": "2ab6b2a16bcf6db73a0857caadf04651da8a6c6c", "filename": "gcc/unroll.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9290558260c3d26ae55adb61a7225dde9e61fb79/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9290558260c3d26ae55adb61a7225dde9e61fb79/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=9290558260c3d26ae55adb61a7225dde9e61fb79", "patch": "@@ -637,6 +637,23 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n       copy_end = last_loop_insn;\n     }\n \n+  if (unroll_type == UNROLL_NAIVE\n+      && GET_CODE (last_loop_insn) == JUMP_INSN\n+      && start_label != JUMP_LABEL (last_loop_insn))\n+    {\n+      /* ??? The loop ends with a conditional branch that does not branch back\n+\t to the loop start label.  In this case, we must emit an unconditional\n+\t branch to the loop exit after emitting the final branch.\n+\t copy_loop_body does not have support for this currently, so we\n+\t give up.  It doesn't seem worthwhile to unroll anyways since\n+\t unrolling would increase the number of branch instructions\n+\t executed.  */\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Unrolling failure: final conditional branch not to loop start\\n\");\n+      return;\n+    }\n+\n   /* Allocate a translation table for the labels and insn numbers.\n      They will be filled in as we copy the insns in the loop.  */\n "}]}