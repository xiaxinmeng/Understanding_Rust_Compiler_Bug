{"sha": "78bf6e2fc41516377353a272967b1c2d4f655e19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiZjZlMmZjNDE1MTYzNzczNTNhMjcyOTY3YjFjMmQ0ZjY1NWUxOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-04-13T21:10:31Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-04-13T21:10:31Z"}, "message": "fold-const.c (native_encode_expr): New function to encode the target representation of an INTEGER_CST...\n\n\n\t* fold-const.c (native_encode_expr): New function to encode\n\tthe target representation of an INTEGER_CST, REAL_CST, COMPLEX_CST\n\tor VECTOR_CST into a specified buffer.\n\t(native_encode_int): New function.\n\t(native_encode_real): New function.\n\t(native_encode_complex): New function.\n\t(native_encode_vector): New function.\n\t(native_interpret_expr): Inverse of native_encode_expr to convert\n\ta target representation into an INTEGER_CST, REAL_CST etc...\n\t(native_interpret_int): New function.\n\t(native_interpret_real): New function.\n\t(native_interpret_complex): New function.\n\t(native_interpret_vector): New function.\n\t(fold_view_convert_expr): New function to constant fold/evaluate\n\ta VIEW_CONVERT_EXPR of a suitable constant expression.\n\t(fold_unary) <VIEW_CONVERT_EXPR>: Call fold_view_convert_expr.\n\tChange call of build1 to fold_build1 when constructing a\n\tVIEW_CONVERT_EXPR.\n\n\t* gcc.target/i386/20050113-1.c: Tweak testcase to reflect that casts\n\tof integers to a vector types are now constant expressions in C.\n\t* gcc.dg/vect/vect-fold-1.c: New test case.\n\nFrom-SVN: r112927", "tree": {"sha": "be0b8aa4617e2c18a9c814b01cde5148cc91bc36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be0b8aa4617e2c18a9c814b01cde5148cc91bc36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78bf6e2fc41516377353a272967b1c2d4f655e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bf6e2fc41516377353a272967b1c2d4f655e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bf6e2fc41516377353a272967b1c2d4f655e19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bf6e2fc41516377353a272967b1c2d4f655e19/comments", "author": null, "committer": null, "parents": [{"sha": "eec69c4eca0201af80e1c40fe474fca89f890a82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eec69c4eca0201af80e1c40fe474fca89f890a82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eec69c4eca0201af80e1c40fe474fca89f890a82"}], "stats": {"total": 444, "additions": 441, "deletions": 3}, "files": [{"sha": "708551dd295ab70464e0b2c9a31921c8eca562ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78bf6e2fc41516377353a272967b1c2d4f655e19", "patch": "@@ -1,3 +1,24 @@\n+2006-04-13  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (native_encode_expr): New function to encode\n+\tthe target representation of an INTEGER_CST, REAL_CST, COMPLEX_CST\n+\tor VECTOR_CST into a specified buffer.\n+\t(native_encode_int): New function.\n+\t(native_encode_real): New function.\n+\t(native_encode_complex): New function.\n+\t(native_encode_vector): New function.\n+\t(native_interpret_expr): Inverse of native_encode_expr to convert\n+\ta target representation into an INTEGER_CST, REAL_CST etc...\n+\t(native_interpret_int): New function.\n+\t(native_interpret_real): New function.\n+\t(native_interpret_complex): New function.\n+\t(native_interpret_vector): New function.\n+\t(fold_view_convert_expr): New function to constant fold/evaluate\n+\ta VIEW_CONVERT_EXPR of a suitable constant expression.\n+\t(fold_unary) <VIEW_CONVERT_EXPR>: Call fold_view_convert_expr.\n+\tChange call of build1 to fold_build1 when constructing a\n+\tVIEW_CONVERT_EXPR.\n+\n 2006-04-13  Paolo Bonzini  <bonzini@gnu.org>\n \t    Ulrich Weigand  <uweigand@de.ibm.com>\n "}, {"sha": "8c88cd3af0965406343f703987170b3951e2c61c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 397, "deletions": 2, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=78bf6e2fc41516377353a272967b1c2d4f655e19", "patch": "@@ -134,6 +134,9 @@ static bool reorder_operands_p (tree, tree);\n static tree fold_negate_const (tree, tree);\n static tree fold_not_const (tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n+static int native_encode_expr (tree, unsigned char *, int);\n+static tree native_interpret_expr (tree, unsigned char *, int);\n+\n \n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n@@ -6756,6 +6759,398 @@ fold_plusminus_mult_expr (enum tree_code code, tree type, tree arg0, tree arg1)\n   return NULL_TREE;\n }\n \n+/* Subroutine of native_encode_expr.  Encode the INTEGER_CST\n+   specified by EXPR into the buffer PTR of length LEN bytes.\n+   Return the number of bytes placed in the buffer, or zero\n+   upon failure.  */\n+\n+static int\n+native_encode_int (tree expr, unsigned char *ptr, int len)\n+{\n+  tree type = TREE_TYPE (expr);\n+  int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  int byte, offset, word, words;\n+  unsigned char value;\n+\n+  if (total_bytes > len)\n+    return 0;\n+  words = total_bytes / UNITS_PER_WORD;\n+\n+  for (byte = 0; byte < total_bytes; byte++)\n+    {\n+      int bitpos = byte * BITS_PER_UNIT;\n+      if (bitpos < HOST_BITS_PER_WIDE_INT)\n+\tvalue = (unsigned char) (TREE_INT_CST_LOW (expr) >> bitpos);\n+      else\n+\tvalue = (unsigned char) (TREE_INT_CST_HIGH (expr)\n+\t\t\t\t >> (bitpos - HOST_BITS_PER_WIDE_INT));\n+\n+      if (total_bytes > UNITS_PER_WORD)\n+\t{\n+\t  word = byte / UNITS_PER_WORD;\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    word = (words - 1) - word;\n+\t  offset = word * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += (UNITS_PER_WORD - 1) - (byte % UNITS_PER_WORD);\n+\t  else\n+\t    offset += byte % UNITS_PER_WORD;\n+\t}\n+      else\n+\toffset = BYTES_BIG_ENDIAN ? (total_bytes - 1) - byte : byte;\n+      ptr[offset] = value;\n+    }\n+  return total_bytes;\n+}\n+\n+\n+/* Subroutine of native_encode_expr.  Encode the REAL_CST\n+   specified by EXPR into the buffer PTR of length LEN bytes.\n+   Return the number of bytes placed in the buffer, or zero\n+   upon failure.  */\n+\n+static int\n+native_encode_real (tree expr, unsigned char *ptr, int len)\n+{\n+  tree type = TREE_TYPE (expr);\n+  int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  int byte, offset, word, words;\n+  unsigned char value;\n+\n+  /* There are always 32 bits in each long, no matter the size of\n+     the hosts long.  We handle floating point representations with\n+     up to 192 bits.  */\n+  long tmp[6];\n+\n+  if (total_bytes > len)\n+    return 0;\n+  words = total_bytes / UNITS_PER_WORD;\n+\n+  real_to_target (tmp, TREE_REAL_CST_PTR (expr), TYPE_MODE (type));\n+\n+  for (byte = 0; byte < total_bytes; byte++)\n+    {\n+      int bitpos = byte * BITS_PER_UNIT;\n+      value = (unsigned char) (tmp[bitpos / 32] >> (bitpos & 31));\n+\n+      if (total_bytes > UNITS_PER_WORD)\n+\t{\n+\t  word = byte / UNITS_PER_WORD;\n+\t  if (FLOAT_WORDS_BIG_ENDIAN)\n+\t    word = (words - 1) - word;\n+\t  offset = word * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += (UNITS_PER_WORD - 1) - (byte % UNITS_PER_WORD);\n+\t  else\n+\t    offset += byte % UNITS_PER_WORD;\n+\t}\n+      else\n+\toffset = BYTES_BIG_ENDIAN ? (total_bytes - 1) - byte : byte;\n+      ptr[offset] = value;\n+    }\n+  return total_bytes;\n+}\n+\n+/* Subroutine of native_encode_expr.  Encode the COMPLEX_CST\n+   specified by EXPR into the buffer PTR of length LEN bytes.\n+   Return the number of bytes placed in the buffer, or zero\n+   upon failure.  */\n+\n+static int\n+native_encode_complex (tree expr, unsigned char *ptr, int len)\n+{\n+  int rsize, isize;\n+  tree part;\n+\n+  part = TREE_REALPART (expr);\n+  rsize = native_encode_expr (part, ptr, len);\n+  if (rsize == 0)\n+    return 0;\n+  part = TREE_IMAGPART (expr);\n+  isize = native_encode_expr (part, ptr+rsize, len-rsize);\n+  if (isize != rsize)\n+    return 0;\n+  return rsize + isize;\n+}\n+\n+\n+/* Subroutine of native_encode_expr.  Encode the VECTOR_CST\n+   specified by EXPR into the buffer PTR of length LEN bytes.\n+   Return the number of bytes placed in the buffer, or zero\n+   upon failure.  */\n+\n+static int\n+native_encode_vector (tree expr, unsigned char *ptr, int len)\n+{\n+  tree type = TREE_TYPE (expr);\n+  int i, size, offste, count;\n+  tree elem, elements;\n+\n+  size = 0;\n+  offset = 0;\n+  elements = TREE_VECTOR_CST_ELTS (expr);\n+  count = TYPE_VECTOR_SUBPARTS (TREE_TYPE (expr));\n+  for (i = 0; i < count; i++)\n+    {\n+      if (elements)\n+\t{\n+\t  elem = TREE_VALUE (elements);\n+\t  elements = TREE_CHAIN (elements);\n+\t}\n+      else\n+\telem = NULL_TREE;\n+\n+      if (elem)\n+\t{\n+\t  size = native_encode_expr (elem, ptr+offset, len-offset);\n+\t  if (size == 0)\n+\t    return 0;\n+\t}\n+      else if (size != 0)\n+\t{\n+\t  if (offset + size > len)\n+\t    return 0;\n+\t  memset (ptr+offset, 0, size);\n+\t}\n+      else\n+\treturn 0;\n+      offset += size;\n+    }\n+  return offset;\n+}\n+\n+\n+/* Subroutine of fold_view_convert_expr.  Encode the INTEGER_CST,\n+   REAL_CST, COMPLEX_CST or VECTOR_CST specified by EXPR into the\n+   buffer PTR of length LEN bytes.  Return the number of bytes\n+   placed in the buffer, or zero upon failure.  */\n+\n+static int\n+native_encode_expr (tree expr, unsigned char *ptr, int len)\n+{\n+  switch (TREE_CODE (expr))\n+    {\n+    case INTEGER_CST:\n+      return native_encode_int (expr, ptr, len);\n+\n+    case REAL_CST:\n+      return native_encode_real (expr, ptr, len);\n+\n+    case COMPLEX_CST:\n+      return native_encode_complex (expr, ptr, len);\n+\n+    case VECTOR_CST:\n+      return native_encode_vector (expr, ptr, len);\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+\n+/* Subroutine of native_interpret_expr.  Interpret the contents of\n+   the buffer PTR of length LEN as an INTEGER_CST of type TYPE.\n+   If the buffer cannot be interpreted, return NULL_TREE.  */\n+\n+static tree\n+native_interpret_int (tree type, unsigned char *ptr, int len)\n+{\n+  int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  int byte, offset, word, words;\n+  unsigned char value;\n+  unsigned int HOST_WIDE_INT lo = 0;\n+  HOST_WIDE_INT hi = 0;\n+\n+  if (total_bytes > len)\n+    return NULL_TREE;\n+  if (total_bytes * BITS_PER_UNIT > 2 * HOST_BITS_PER_WIDE_INT)\n+    return NULL_TREE;\n+  words = total_bytes / UNITS_PER_WORD;\n+\n+  for (byte = 0; byte < total_bytes; byte++)\n+    {\n+      int bitpos = byte * BITS_PER_UNIT;\n+      if (total_bytes > UNITS_PER_WORD)\n+\t{\n+\t  word = byte / UNITS_PER_WORD;\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    word = (words - 1) - word;\n+\t  offset = word * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += (UNITS_PER_WORD - 1) - (byte % UNITS_PER_WORD);\n+\t  else\n+\t    offset += byte % UNITS_PER_WORD;\n+\t}\n+      else\n+\toffset = BYTES_BIG_ENDIAN ? (total_bytes - 1) - byte : byte;\n+      value = ptr[offset];\n+\n+      if (bitpos < HOST_BITS_PER_WIDE_INT)\n+\tlo |= (unsigned HOST_WIDE_INT) value << bitpos;\n+      else\n+\thi |= (unsigned HOST_WIDE_INT) value\n+\t      << (bitpos - HOST_BITS_PER_WIDE_INT);\n+    }\n+\n+  return force_fit_type (build_int_cst_wide (type, lo, hi),\n+\t\t\t 0, false, false);\n+}\n+\n+\n+/* Subroutine of native_interpret_expr.  Interpret the contents of\n+   the buffer PTR of length LEN as a REAL_CST of type TYPE.\n+   If the buffer cannot be interpreted, return NULL_TREE.  */\n+\n+static tree\n+native_interpret_real (tree type, unsigned char *ptr, int len)\n+{\n+  int total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  int byte, offset, word, words;\n+  unsigned char value;\n+  /* There are always 32 bits in each long, no matter the size of\n+     the hosts long.  We handle floating point representations with\n+     up to 192 bits.  */\n+  REAL_VALUE_TYPE r;\n+  long tmp[6];\n+\n+  total_bytes = GET_MODE_SIZE (TYPE_MODE (type));\n+  if (total_bytes > len || total_bytes > 24)\n+    return NULL_TREE;\n+  words = total_bytes / UNITS_PER_WORD;\n+\n+  memset (tmp, 0, sizeof (tmp));\n+  for (byte = 0; byte < total_bytes; byte++)\n+    {\n+      int bitpos = byte * BITS_PER_UNIT;\n+      if (total_bytes > UNITS_PER_WORD)\n+\t{\n+\t  word = byte / UNITS_PER_WORD;\n+\t  if (FLOAT_WORDS_BIG_ENDIAN)\n+\t    word = (words - 1) - word;\n+\t  offset = word * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += (UNITS_PER_WORD - 1) - (byte % UNITS_PER_WORD);\n+\t  else\n+\t    offset += byte % UNITS_PER_WORD;\n+\t}\n+      else\n+\toffset = BYTES_BIG_ENDIAN ? (total_bytes - 1) - byte : byte;\n+      value = ptr[offset];\n+\n+      tmp[bitpos / 32] |= (unsigned long)value << (bitpos & 31);\n+    }\n+\n+  real_from_target (&r, tmp, mode);\n+  return build_real (type, r);\n+}\n+\n+\n+/* Subroutine of native_interpret_expr.  Interpret the contents of\n+   the buffer PTR of length LEN as a COMPLEX_CST of type TYPE.\n+   If the buffer cannot be interpreted, return NULL_TREE.  */\n+\n+static tree\n+native_interpret_complex (tree type, unsigned char *ptr, int len)\n+{\n+  tree etype, rpart, ipart;\n+  int size;\n+\n+  etype = TREE_TYPE (type);\n+  size = GET_MODE_SIZE (TYPE_MODE (etype));\n+  if (size * 2 > len)\n+    return NULL_TREE;\n+  rpart = native_interpret_expr (etype, ptr, size);\n+  if (!rpart)\n+    return NULL_TREE;\n+  ipart = native_interpret_expr (etype, ptr+size, size);\n+  if (!ipart)\n+    return NULL_TREE;\n+  return build_complex (type, rpart, ipart);\n+}\n+\n+\n+/* Subroutine of native_interpret_expr.  Interpret the contents of\n+   the buffer PTR of length LEN as a VECTOR_CST of type TYPE.\n+   If the buffer cannot be interpreted, return NULL_TREE.  */\n+\n+static tree\n+native_interpret_vector (tree type, unsigned char *ptr, int len)\n+{\n+  tree etype, elem, elements;\n+  int i, size, count;\n+\n+  etype = TREE_TYPE (type);\n+  size = GET_MODE_SIZE (TYPE_MODE (etype));\n+  count = TYPE_VECTOR_SUBPARTS (type);\n+  if (size * count > len)\n+    return NULL_TREE;\n+\n+  elements = NULL_TREE;\n+  for (i = count - 1; i >= 0; i--)\n+    {\n+      elem = native_interpret_expr (etype, ptr+(i*size), size);\n+      if (!elem)\n+\treturn NULL_TREE;\n+      elements = tree_cons (NULL_TREE, elem, elements);\n+    }\n+  return build_vector (type, elements);\n+}\n+\n+\n+/* Subroutine of fold_view_convert_expr.  Interpet the contents of\n+   the buffer PTR of length LEN as a constant of type TYPE.  For\n+   INTEGRAL_TYPE_P we return an INTEGER_CST, for SCALAR_FLOAT_TYPE_P\n+   we return a REAL_CST, etc...  If the buffer cannot be interpreted,\n+   return NULL_TREE.  */\n+\n+static tree\n+native_interpret_expr (tree type, unsigned char *ptr, int len)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+      return native_interpret_int (type, ptr, len);\n+\n+    case REAL_TYPE:\n+      return native_interpret_real (type, ptr, len);\n+\n+    case COMPLEX_TYPE:\n+      return native_interpret_complex (type, ptr, len);\n+\n+    case VECTOR_TYPE:\n+      return native_interpret_vector (type, ptr, len);\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+\n+/* Fold a VIEW_CONVERT_EXPR of a constant expression EXPR to type\n+   TYPE at compile-time.  If we're unable to perform the conversion\n+   return NULL_TREE.  */\n+\n+static tree\n+fold_view_convert_expr (tree type, tree expr)\n+{\n+  /* We support up to 512-bit values (for V8DFmode).  */\n+  unsigned char buffer[64];\n+  int len;\n+\n+  /* Check that the host and target are sane.  */\n+  if (CHAR_BIT != 8 || BITS_PER_UNIT != 8)\n+    return NULL_TREE;\n+\n+  len = native_encode_expr (expr, buffer, sizeof (buffer));\n+  if (len == 0)\n+    return NULL_TREE;\n+\n+  return native_interpret_expr (type, buffer, len);\n+}\n+\n+\n /* Fold a unary expression of code CODE and type TYPE with operand\n    OP0.  Return the folded expression if folding is successful.\n    Otherwise, return NULL_TREE.  */\n@@ -7095,8 +7490,8 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \n     case VIEW_CONVERT_EXPR:\n       if (TREE_CODE (op0) == VIEW_CONVERT_EXPR)\n-\treturn build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));\n-      return NULL_TREE;\n+\treturn fold_build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));\n+      return fold_view_convert_expr (type, op0);\n \n     case NEGATE_EXPR:\n       if (negate_expr_p (arg0))"}, {"sha": "185b3662969cf847ea5f3abb85cbd9d7407d552e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78bf6e2fc41516377353a272967b1c2d4f655e19", "patch": "@@ -1,3 +1,9 @@\n+2006-04-13  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.target/i386/20050113-1.c: Tweak testcase to reflect that casts\n+\tof integers to a vector types are now constant expressions in C.\n+\t* gcc.dg/vect/vect-fold-1.c: New test case.\n+\n 2006-04-13  Paolo Bonzini  <bonzini@gnu.org>\n \t    Ulrich Weigand  <uweigand@de.ibm.com>\n "}, {"sha": "88b68b7cf4a3911d1ea9fa0923cfae166e3277a6", "filename": "gcc/testsuite/gcc.dg/vect/vect-fold-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-fold-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-fold-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-fold-1.c?ref=78bf6e2fc41516377353a272967b1c2d4f655e19", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dom1\" } */\n+\n+typedef unsigned char v4qi __attribute__ ((vector_size (4)));\n+\n+v4qi c;\n+\n+void foo()\n+{\n+  v4qi a = { 1, 2, 3, 4 };\n+  v4qi b = { 5, 6, 7, 8 };\n+  c = a + b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"c = { 6, 8, 10, 12 }\" 1 \"dom1\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom1\" } } */"}, {"sha": "b1d3cecf41fa2acfd4c09d6d7282c87e8b960788", "filename": "gcc/testsuite/gcc.target/i386/20050113-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20050113-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bf6e2fc41516377353a272967b1c2d4f655e19/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20050113-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20050113-1.c?ref=78bf6e2fc41516377353a272967b1c2d4f655e19", "patch": "@@ -3,4 +3,4 @@\n /* { dg-options \"-mmmx\" } */\n \n typedef short int V __attribute__ ((vector_size (8)));\n-static V v = (V) 0x00FF00FF00FF00FFLL; /* { dg-error \"is not constant\" } */\n+static V v = (V) 0x00FF00FF00FF00FFLL;"}]}