{"sha": "c8a209ca246a80a556ae68d03f5c5165407d61cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhhMjA5Y2EyNDZhODBhNTU2YWU2OGQwM2Y1YzUxNjU0MDdkNjFjZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-06-18T15:22:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-06-18T15:22:19Z"}, "message": "cp-tree.h (COMPARE_RELAXED): Rename to ...\n\n\t* cp-tree.h (COMPARE_RELAXED): Rename to ...\n\t(COMPARE_DERIVED): ... here. Adjust comment.\n\t(resolve_typename_type_in_current_instantiation): Remove.\n\t(cp_tree_equal, comptypes): Return a bool.\n\t* cvt.c (convert_to_reference): Adjust comptypes call.\n\t* pt.c (template_args_equal, unify,): Adjust cp_tree_equal call.\n\t(resolve_typename_type_in_current_instantiation): Remove.\n\t* tree.c (cp_tree_equal): Return bool. Cope with TEMPLATE_DECLs and\n\tIDENTIFIER_NODEs. Abort if undeciderable. Adjust recursive\n\tcalls. Refactor code.\n\t* typeck.c (comp_array_types): Return bool. Lose callback.\n\tparameter. Adjust cp_tree_equal calls.\n\t(comptypes): Return bool. Adjust strict handling. Remove relaxed\n\tenumeration and java type handling. Deal with typename types here.\n\tAdjust recursive and cp_tree_equals calls. Adjust base and derived\n\tchecking.\n\t(comp_target_types): Remove unreachable code. Adjust\n\tsame_or_base_type_p calls.\n\t(ptr_reasonably_similar): Adjust base and derived check.\n\n\t* typeck.c (maybe_warn_about_returning_address_of_local): Remove\n\tunused calculation.\n\t(check_return_expr): Adjust error messages.\n\t* cp-tree.def (SCOPE_REF): Correct comment.\n\nFrom-SVN: r68155", "tree": {"sha": "9d291ec441061143be7bea21e3b8a7d198c6b984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d291ec441061143be7bea21e3b8a7d198c6b984"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8a209ca246a80a556ae68d03f5c5165407d61cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a209ca246a80a556ae68d03f5c5165407d61cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a209ca246a80a556ae68d03f5c5165407d61cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a209ca246a80a556ae68d03f5c5165407d61cf/comments", "author": null, "committer": null, "parents": [{"sha": "c76abc120c19129c7301b2622b718e18d1c2191f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c76abc120c19129c7301b2622b718e18d1c2191f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c76abc120c19129c7301b2622b718e18d1c2191f"}], "stats": {"total": 462, "additions": 215, "deletions": 247}, "files": [{"sha": "54a7d44a4f02d994e6ce032bd862988f394c3661", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c8a209ca246a80a556ae68d03f5c5165407d61cf", "patch": "@@ -1,3 +1,30 @@\n+2003-06-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (COMPARE_RELAXED): Rename to ...\n+\t(COMPARE_DERIVED): ... here. Adjust comment.\n+\t(resolve_typename_type_in_current_instantiation): Remove.\n+\t(cp_tree_equal, comptypes): Return a bool.\n+\t* cvt.c (convert_to_reference): Adjust comptypes call.\n+\t* pt.c (template_args_equal, unify,): Adjust cp_tree_equal call.\n+\t(resolve_typename_type_in_current_instantiation): Remove.\n+\t* tree.c (cp_tree_equal): Return bool. Cope with TEMPLATE_DECLs and\n+\tIDENTIFIER_NODEs. Abort if undeciderable. Adjust recursive\n+\tcalls. Refactor code.\n+\t* typeck.c (comp_array_types): Return bool. Lose callback.\n+\tparameter. Adjust cp_tree_equal calls.\n+\t(comptypes): Return bool. Adjust strict handling. Remove relaxed\n+\tenumeration and java type handling. Deal with typename types here.\n+\tAdjust recursive and cp_tree_equals calls. Adjust base and derived\n+\tchecking.\n+\t(comp_target_types): Remove unreachable code. Adjust\n+\tsame_or_base_type_p calls.\n+\t(ptr_reasonably_similar): Adjust base and derived check.\n+\t\n+\t* typeck.c (maybe_warn_about_returning_address_of_local): Remove\n+\tunused calculation.\n+\t(check_return_expr): Adjust error messages.\n+\t* cp-tree.def (SCOPE_REF): Correct comment.\n+\n 2003-06-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* mangle.c (mangle_conv_op_name_for_type): Correct sprintf format"}, {"sha": "7d657317031c77bed733805d745224a241d34c4c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=c8a209ca246a80a556ae68d03f5c5165407d61cf", "patch": "@@ -62,8 +62,7 @@ DEFTREECODE (DELETE_EXPR, \"dl_expr\", 'e', 2)\n DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", 'e', 2)\n \n /* Value is reference to particular overloaded class method.\n-   Operand 0 is the class name (an IDENTIFIER_NODE);\n-   operand 1 is the field (also an IDENTIFIER_NODE).\n+   Operand 0 is the class, operand 1 is the field\n    The COMPLEXITY field holds the class level (usually 0).  */\n DEFTREECODE (SCOPE_REF, \"scope_ref\", 'r', 2)\n "}, {"sha": "6c4ae0d2f713aecd378e2473f2b167ab165831ed", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c8a209ca246a80a556ae68d03f5c5165407d61cf", "patch": "@@ -3367,15 +3367,9 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define COMPARE_STRICT        0 /* Just check if the types are the\n \t\t\t\t   same.  */\n #define COMPARE_BASE          1 /* Check to see if the second type is\n-\t\t\t\t   derived from the first, or if both\n-\t\t\t\t   are pointers (or references) and\n-\t\t\t\t   the types pointed to by the second\n-\t\t\t\t   type is derived from the pointed to\n-\t\t\t\t   by the first.  */\n-#define COMPARE_RELAXED       2 /* Like COMPARE_DERIVED, but in\n-\t\t\t\t   reverse.  Also treat enumeration\n-\t\t\t\t   types as the same as integer types\n-\t\t\t\t   of the same width.  */\n+\t\t\t\t   derived from the first.  */\n+#define COMPARE_DERIVED       2 /* Like COMPARE_BASE, but in\n+\t\t\t\t   reverse.  */\n #define COMPARE_REDECLARATION 4 /* The comparsion is being done when\n \t\t\t\t   another declaration of an existing\n \t\t\t\t   entity is seen.  */\n@@ -3982,7 +3976,6 @@ extern bool dependent_template_p                (tree);\n extern bool type_dependent_expression_p         (tree);\n extern bool value_dependent_expression_p        (tree);\n extern tree resolve_typename_type               (tree, bool);\n-extern tree resolve_typename_type_in_current_instantiation (tree);\n extern tree template_for_substitution           (tree);\n \n /* in repo.c */\n@@ -4204,7 +4197,7 @@ extern tree error_type\t\t\t\t(tree);\n extern tree build_zc_wrapper\t\t\t(struct z_candidate *);\n extern int varargs_function_p\t\t\t(tree);\n extern int really_overloaded_fn\t\t\t(tree);\n-extern int cp_tree_equal\t\t\t(tree, tree);\n+extern bool cp_tree_equal\t\t\t(tree, tree);\n extern tree no_linkage_check\t\t\t(tree);\n extern void debug_binfo\t\t\t\t(tree);\n extern tree build_dummy_object\t\t\t(tree);\n@@ -4247,7 +4240,7 @@ extern int type_unknown_p\t\t\t(tree);\n extern tree commonparms\t\t\t\t(tree, tree);\n extern tree original_type\t\t\t(tree);\n extern int comp_except_specs\t\t\t(tree, tree, int);\n-extern int comptypes\t\t\t\t(tree, tree, int);\n+extern bool comptypes\t\t\t\t(tree, tree, int);\n extern int comp_target_types\t\t\t(tree, tree, int);\n extern int compparms\t\t\t\t(tree, tree);\n extern int comp_cv_qualification                (tree, tree);"}, {"sha": "2078a67b0160477bb12307f40dce2cf350c9d824", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c8a209ca246a80a556ae68d03f5c5165407d61cf", "patch": "@@ -507,10 +507,10 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n       /* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they\n          meant.  */\n       if (TREE_CODE (intype) == POINTER_TYPE\n-\t  && (comptypes (TREE_TYPE (intype), type, \n-\t\t\t COMPARE_BASE | COMPARE_RELAXED )))\n+\t  && (comptypes (TREE_TYPE (intype), type,\n+\t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n \twarning (\"casting `%T' to `%T' does not dereference pointer\",\n-\t\t    intype, reftype);\n+\t\t intype, reftype);\n \t  \n       rval = build_unary_op (ADDR_EXPR, expr, 0);\n       if (rval != error_mark_node)"}, {"sha": "742de91ad25ce67fc485cbfc407b16c7e99e912d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c8a209ca246a80a556ae68d03f5c5165407d61cf", "patch": "@@ -3811,7 +3811,7 @@ template_args_equal (ot, nt)\n   else if (TREE_CODE (ot) == TREE_VEC || TYPE_P (ot))\n     return 0;\n   else\n-    return (cp_tree_equal (ot, nt) > 0);\n+    return cp_tree_equal (ot, nt);\n }\n \n /* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n@@ -9638,22 +9638,14 @@ unify (tparms, targs, parm, arg, strict)\n \t  != template_decl_level (tparm))\n \t/* The PARM is not one we're trying to unify.  Just check\n \t   to see if it matches ARG.  */\n-\treturn (TREE_CODE (arg) == TREE_CODE (parm)\n-\t\t&& cp_tree_equal (parm, arg) > 0) ? 0 : 1;\n+\treturn !(TREE_CODE (arg) == TREE_CODE (parm)\n+\t\t && cp_tree_equal (parm, arg));\n \n       idx = TEMPLATE_PARM_IDX (parm);\n       targ = TREE_VEC_ELT (targs, idx);\n \n       if (targ)\n-\t{\n-\t  int i = (cp_tree_equal (targ, arg) > 0);\n-\t  if (i == 1)\n-\t    return 0;\n-\t  else if (i == 0)\n-\t    return 1;\n-\t  else\n-\t    abort ();\n-\t}\n+\treturn !cp_tree_equal (targ, arg);\n \n       /* [temp.deduct.type] If, in the declaration of a function template\n \t with a non-type template-parameter, the non-type\n@@ -11798,13 +11790,4 @@ resolve_typename_type (tree type, bool only_current_p)\n   return type;\n }\n \n-tree\n-resolve_typename_type_in_current_instantiation (tree type)\n-{\n-  tree t;\n-\n-  t = resolve_typename_type (type, /*only_current_p=*/true);\n-  return (t != error_mark_node) ? t : type;\n-}\n-\n #include \"gt-cp-pt.h\""}, {"sha": "385afcac4c9c68b0bd13e0c474d1df375ac9f309", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 83, "deletions": 79, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c8a209ca246a80a556ae68d03f5c5165407d61cf", "patch": "@@ -1552,38 +1552,35 @@ decl_namespace_context (tree decl)\n }\n \n /* Return truthvalue of whether T1 is the same tree structure as T2.\n-   Return 1 if they are the same.\n-   Return 0 if they are understandably different.\n-   Return -1 if either contains tree structure not understood by\n-   this function.  */\n+   Return 1 if they are the same. Return 0 if they are different.  */\n \n-int\n+bool\n cp_tree_equal (tree t1, tree t2)\n {\n   register enum tree_code code1, code2;\n-  int cmp;\n \n   if (t1 == t2)\n-    return 1;\n-  if (t1 == 0 || t2 == 0)\n-    return 0;\n-\n-  code1 = TREE_CODE (t1);\n-  code2 = TREE_CODE (t2);\n-\n-  if (code1 == NOP_EXPR || code1 == CONVERT_EXPR || code1 == NON_LVALUE_EXPR)\n-    {\n-      if (code2 == NOP_EXPR || code2 == CONVERT_EXPR || code2 == NON_LVALUE_EXPR)\n-\treturn cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n-      else\n-\treturn cp_tree_equal (TREE_OPERAND (t1, 0), t2);\n-    }\n-  else if (code2 == NOP_EXPR || code2 == CONVERT_EXPR\n-\t   || code2 == NON_LVALUE_EXPR)\n-    return cp_tree_equal (t1, TREE_OPERAND (t2, 0));\n-\n+    return true;\n+  if (!t1 || !t2)\n+    return false;\n+\n+  for (code1 = TREE_CODE (t1);\n+       code1 == NOP_EXPR || code1 == CONVERT_EXPR\n+\t || code1 == NON_LVALUE_EXPR;\n+       code1 = TREE_CODE (t1))\n+    t1 = TREE_OPERAND (t1, 0);\n+  for (code2 = TREE_CODE (t2);\n+       code2 == NOP_EXPR || code2 == CONVERT_EXPR\n+\t || code1 == NON_LVALUE_EXPR;\n+       code2 = TREE_CODE (t2))\n+    t2 = TREE_OPERAND (t2, 0);\n+\n+  /* They might have become equal now.  */\n+  if (t1 == t2)\n+    return true;\n+  \n   if (code1 != code2)\n-    return 0;\n+    return false;\n \n   switch (code1)\n     {\n@@ -1597,7 +1594,7 @@ cp_tree_equal (tree t1, tree t2)\n     case STRING_CST:\n       return TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)\n \t&& !memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n-\t\t  TREE_STRING_LENGTH (t1));\n+\t\t    TREE_STRING_LENGTH (t1));\n \n     case CONSTRUCTOR:\n       /* We need to do this when determining whether or not two\n@@ -1606,61 +1603,62 @@ cp_tree_equal (tree t1, tree t2)\n       if (!(same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n \t    /* The first operand is RTL.  */\n \t    && TREE_OPERAND (t1, 0) == TREE_OPERAND (t2, 0)))\n-\treturn 0;\n+\treturn false;\n       return cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n \n     case TREE_LIST:\n-      cmp = cp_tree_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n-      if (cmp <= 0)\n-\treturn cmp;\n-      cmp = cp_tree_equal (TREE_VALUE (t1), TREE_VALUE (t2));\n-      if (cmp <= 0)\n-\treturn cmp;\n+      if (!cp_tree_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2)))\n+\treturn false;\n+      if (!cp_tree_equal (TREE_VALUE (t1), TREE_VALUE (t2)))\n+\treturn false;\n       return cp_tree_equal (TREE_CHAIN (t1), TREE_CHAIN (t2));\n \n     case SAVE_EXPR:\n       return cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n \n     case CALL_EXPR:\n-      cmp = cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n-      if (cmp <= 0)\n-\treturn cmp;\n-      return simple_cst_list_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n-\n-    case TARGET_EXPR:\n-      /* Special case: if either target is an unallocated VAR_DECL,\n-\t it means that it's going to be unified with whatever the\n-\t TARGET_EXPR is really supposed to initialize, so treat it\n-\t as being equivalent to anything.  */\n-      if ((TREE_CODE (TREE_OPERAND (t1, 0)) == VAR_DECL\n-\t   && DECL_NAME (TREE_OPERAND (t1, 0)) == NULL_TREE\n-\t   && !DECL_RTL_SET_P (TREE_OPERAND (t1, 0)))\n-\t  || (TREE_CODE (TREE_OPERAND (t2, 0)) == VAR_DECL\n-\t      && DECL_NAME (TREE_OPERAND (t2, 0)) == NULL_TREE\n-\t      && !DECL_RTL_SET_P (TREE_OPERAND (t2, 0))))\n-\tcmp = 1;\n-      else\n-\tcmp = cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n-      if (cmp <= 0)\n-\treturn cmp;\n+      if (!cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0)))\n+\treturn false;\n       return cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n \n+    case TARGET_EXPR:\n+      {\n+\ttree o1 = TREE_OPERAND (t1, 0);\n+\ttree o2 = TREE_OPERAND (t2, 0);\n+\t\n+\t/* Special case: if either target is an unallocated VAR_DECL,\n+\t   it means that it's going to be unified with whatever the\n+\t   TARGET_EXPR is really supposed to initialize, so treat it\n+\t   as being equivalent to anything.  */\n+\tif (TREE_CODE (o1) == VAR_DECL && DECL_NAME (o1) == NULL_TREE\n+\t    && !DECL_RTL_SET_P (o1))\n+\t  /*Nop*/;\n+\telse if (TREE_CODE (o2) == VAR_DECL && DECL_NAME (o2) == NULL_TREE\n+\t\t && !DECL_RTL_SET_P (o2))\n+\t  /*Nop*/;\n+\telse if (!cp_tree_equal (o1, o2))\n+\t  return false;\n+      \n+\treturn cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+      }\n+      \n     case WITH_CLEANUP_EXPR:\n-      cmp = cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n-      if (cmp <= 0)\n-\treturn cmp;\n+      if (!cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0)))\n+\treturn false;\n       return cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t1, 1));\n \n     case COMPONENT_REF:\n-      if (TREE_OPERAND (t1, 1) == TREE_OPERAND (t2, 1))\n-\treturn cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n-      return 0;\n+      if (TREE_OPERAND (t1, 1) != TREE_OPERAND (t2, 1))\n+\treturn false;\n+      return cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n \n     case VAR_DECL:\n     case PARM_DECL:\n     case CONST_DECL:\n     case FUNCTION_DECL:\n-      return 0;\n+    case TEMPLATE_DECL:\n+    case IDENTIFIER_NODE:\n+      return false;\n \n     case TEMPLATE_PARM_INDEX:\n       return (TEMPLATE_PARM_IDX (t1) == TEMPLATE_PARM_IDX (t2)\n@@ -1670,17 +1668,25 @@ cp_tree_equal (tree t1, tree t2)\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (t1, 0)) != TREE_CODE (TREE_OPERAND (t2, 0)))\n-\treturn 0;\n-      if (TYPE_P (TREE_OPERAND (t1, 0)))\n-\treturn same_type_p (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n-      break;\n-\n+      {\n+\ttree o1 = TREE_OPERAND (t1, 0);\n+\ttree o2 = TREE_OPERAND (t2, 0);\n+\t\n+\tif (TREE_CODE (o1) != TREE_CODE (o2))\n+\t  return false;\n+\tif (TYPE_P (o1))\n+\t  return same_type_p (o1, o2);\n+\telse\n+\t  return cp_tree_equal (o1, o2);\n+      }\n+      \n     case PTRMEM_CST:\n       /* Two pointer-to-members are the same if they point to the same\n \t field or function in the same class.  */\n-      return (PTRMEM_CST_MEMBER (t1) == PTRMEM_CST_MEMBER (t2)\n-\t      && same_type_p (PTRMEM_CST_CLASS (t1), PTRMEM_CST_CLASS (t2)));\n+      if (PTRMEM_CST_MEMBER (t1) != PTRMEM_CST_MEMBER (t2))\n+\treturn false;\n+\n+      return same_type_p (PTRMEM_CST_CLASS (t1), PTRMEM_CST_CLASS (t2));\n \n     default:\n       break;\n@@ -1697,21 +1703,19 @@ cp_tree_equal (tree t1, tree t2)\n       {\n \tint i;\n \t\n-\tcmp = 1;\n \tfor (i = 0; i < TREE_CODE_LENGTH (code1); ++i)\n-\t  {\n-\t    cmp = cp_tree_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i));\n-\t    if (cmp <= 0)\n-\t      return cmp;\n-\t  }\n-\treturn cmp;\n+\t  if (!cp_tree_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i)))\n+\t    return false;\n+\t\n+\treturn true;\n       }\n     \n-      case 't':\n-\treturn same_type_p (t1, t2) ? 1 : 0;\n+    case 't':\n+      return same_type_p (t1, t2);\n     }\n \n-  return -1;\n+  my_friendly_assert (0, 20030617);\n+  return false;\n }\n \n /* Build a wrapper around a 'struct z_candidate' so we can use it as a"}, {"sha": "c94efcd37892012fef69c52def8e4909e500f786", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 92, "deletions": 130, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a209ca246a80a556ae68d03f5c5165407d61cf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c8a209ca246a80a556ae68d03f5c5165407d61cf", "patch": "@@ -54,8 +54,7 @@ static int comp_ptr_ttypes_real PARAMS ((tree, tree, int));\n static int comp_ptr_ttypes_const PARAMS ((tree, tree));\n static int comp_ptr_ttypes_reinterpret PARAMS ((tree, tree));\n static int comp_except_types PARAMS ((tree, tree, int));\n-static int comp_array_types PARAMS ((int (*) (tree, tree, int), tree,\n-\t\t\t\t   tree, int));\n+static bool comp_array_types PARAMS ((tree, tree, int));\n static tree common_base_type PARAMS ((tree, tree));\n static tree lookup_anon_field PARAMS ((tree, tree));\n static tree pointer_diff PARAMS ((tree, tree, tree));\n@@ -837,12 +836,10 @@ comp_except_specs (t1, t2, exact)\n   return !exact || base == NULL_TREE || length == list_length (t1);\n }\n \n-/* Compare the array types T1 and T2, using CMP as the type comparison\n-   function for the element types.  STRICT is as for comptypes.  */\n+/* Compare the array types T1 and T2.  STRICT is as for comptypes.  */\n \n-static int\n-comp_array_types (cmp, t1, t2, strict)\n-     register int (*cmp) PARAMS ((tree, tree, int));\n+static bool\n+comp_array_types (t1, t2, strict)\n      tree t1, t2;\n      int strict;\n {\n@@ -853,16 +850,15 @@ comp_array_types (cmp, t1, t2, strict)\n     return 1;\n \n   /* The type of the array elements must be the same.  */\n-  if (!(TREE_TYPE (t1) == TREE_TYPE (t2)\n-\t|| (*cmp) (TREE_TYPE (t1), TREE_TYPE (t2), \n-\t\t   strict & ~COMPARE_REDECLARATION)))\n-    return 0;\n+  if (!comptypes (TREE_TYPE (t1), TREE_TYPE (t2), \n+\t\t strict & ~COMPARE_REDECLARATION))\n+    return false;\n \n   d1 = TYPE_DOMAIN (t1);\n   d2 = TYPE_DOMAIN (t2);\n \n   if (d1 == d2)\n-    return 1;\n+    return true;\n \n   /* If one of the arrays is dimensionless, and the other has a\n      dimension, they are of different types.  However, it is valid to\n@@ -880,183 +876,153 @@ comp_array_types (cmp, t1, t2, strict)\n     return strict & COMPARE_REDECLARATION;\n \n   /* Check that the dimensions are the same.  */\n-  return (cp_tree_equal (TYPE_MIN_VALUE (d1),\n-\t\t\t TYPE_MIN_VALUE (d2))\n-\t  && cp_tree_equal (TYPE_MAX_VALUE (d1),\n-\t\t\t    TYPE_MAX_VALUE (d2)));\n+  return (cp_tree_equal (TYPE_MIN_VALUE (d1), TYPE_MIN_VALUE (d2))\n+\t  && cp_tree_equal (TYPE_MAX_VALUE (d1), TYPE_MAX_VALUE (d2)));\n }\n \n-/* Return 1 if T1 and T2 are compatible types for assignment or\n-   various other operations.  STRICT is a bitwise-or of the COMPARE_*\n-   flags.  */\n+/* Return true if T1 and T2 are related as allowed by STRICT.  STRICT\n+   is a bitwise-or of the COMPARE_* flags.  */\n \n-int\n+bool\n comptypes (t1, t2, strict)\n      tree t1;\n      tree t2;\n      int strict;\n {\n-  int attrval, val;\n   int orig_strict = strict;\n \n-  /* The special exemption for redeclaring array types without an\n-     array bound only applies at the top level:\n-\n-       extern int (*i)[];\n-       int (*i)[8];\n-\n-     is invalid, for example.  */\n-  strict &= ~COMPARE_REDECLARATION;\n-\n-  /* Suppress errors caused by previously reported errors */\n   if (t1 == t2)\n-    return 1;\n+    return true;\n+\n+  strict &= ~(COMPARE_REDECLARATION | COMPARE_BASE | COMPARE_DERIVED);\n \n   /* This should never happen.  */\n   my_friendly_assert (t1 != error_mark_node, 307);\n \n+  /* Suppress errors caused by previously reported errors */\n   if (t2 == error_mark_node)\n-    return 0;\n+    return false;\n+\n+  /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n+     current instantiation.  */\n+  if (TREE_CODE (t1) == TYPENAME_TYPE)\n+    {\n+      tree resolved = resolve_typename_type (t1, /*only_current_p=*/true);\n+\n+      if (resolved != error_mark_node)\n+\tt1 = resolved;\n+    }\n+  \n+  if (TREE_CODE (t2) == TYPENAME_TYPE)\n+    {\n+      tree resolved = resolve_typename_type (t2, /*only_current_p=*/true);\n+\n+      if (resolved != error_mark_node)\n+\tt2 = resolved;\n+    }\n \n-  /* If either type is the internal version of sizetype, return the\n+  /* If either type is the internal version of sizetype, use the\n      language version.  */\n   if (TREE_CODE (t1) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t1)\n-      && TYPE_DOMAIN (t1) != 0)\n+      && TYPE_DOMAIN (t1))\n     t1 = TYPE_DOMAIN (t1);\n \n   if (TREE_CODE (t2) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t2)\n-      && TYPE_DOMAIN (t2) != 0)\n+      && TYPE_DOMAIN (t2))\n     t2 = TYPE_DOMAIN (t2);\n \n-  if (strict & COMPARE_RELAXED)\n-    {\n-      /* Treat an enum type as the unsigned integer type of the same width.  */\n-\n-      if (TREE_CODE (t1) == ENUMERAL_TYPE)\n-\tt1 = c_common_type_for_size (TYPE_PRECISION (t1), 1);\n-      if (TREE_CODE (t2) == ENUMERAL_TYPE)\n-\tt2 = c_common_type_for_size (TYPE_PRECISION (t2), 1);\n-\n-      if (t1 == t2)\n-\treturn 1;\n-    }\n-\n   if (TYPE_PTRMEMFUNC_P (t1))\n     t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n   if (TYPE_PTRMEMFUNC_P (t2))\n     t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n \n-  /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n-     current instantiation.  */\n-  if (TREE_CODE (t1) == TYPENAME_TYPE)\n-    t1 = resolve_typename_type_in_current_instantiation (t1);\n-  if (TREE_CODE (t2) == TYPENAME_TYPE)\n-    t2 = resolve_typename_type_in_current_instantiation (t2);\n-\n   /* Different classes of types can't be compatible.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return 0;\n+    return false;\n \n   /* Qualifiers must match.  */\n   if (cp_type_quals (t1) != cp_type_quals (t2))\n-    return 0;\n-  if (strict == COMPARE_STRICT \n-      && TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n-    return 0;\n+    return false;\n+  if (TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n+    return false;\n \n   /* Allow for two different type nodes which have essentially the same\n      definition.  Note that we already checked for equality of the type\n      qualifiers (just above).  */\n \n   if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n-    return 1;\n+    return true;\n \n-  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n-  if (! (attrval = (*targetm.comp_type_attributes) (t1, t2)))\n-    return 0;\n-\n-  /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n-  val = 0;\n+  if (!(*targetm.comp_type_attributes) (t1, t2))\n+    return false;\n \n   switch (TREE_CODE (t1))\n     {\n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n \t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2))\n-\treturn 0;\n-      if (! comp_template_parms\n-\t      (DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t1)),\n-\t       DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t2))))\n-\treturn 0;\n+\treturn false;\n+      if (!comp_template_parms\n+\t  (DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t1)),\n+\t   DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t2))))\n+\treturn false;\n       if (TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM)\n-\treturn 1;\n+\treturn true;\n       /* Don't check inheritance.  */\n-      strict = COMPARE_STRICT;\n+      orig_strict = COMPARE_STRICT;\n       /* fall through */\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n       if (TYPE_TEMPLATE_INFO (t1) && TYPE_TEMPLATE_INFO (t2)\n \t  && (TYPE_TI_TEMPLATE (t1) == TYPE_TI_TEMPLATE (t2)\n-\t      || TREE_CODE (t1) == BOUND_TEMPLATE_TEMPLATE_PARM))\n-\tval = comp_template_args (TYPE_TI_ARGS (t1),\n-\t\t\t\t  TYPE_TI_ARGS (t2));\n-    look_hard:\n-      if ((strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n-\tval = 1;\n-      else if ((strict & COMPARE_RELAXED) && DERIVED_FROM_P (t2, t1))\n-\tval = 1;\n-      break;\n+\t      || TREE_CODE (t1) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+\t  && comp_template_args (TYPE_TI_ARGS (t1), TYPE_TI_ARGS (t2)))\n+\treturn true;\n+      \n+      if ((orig_strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n+\treturn true;\n+      else if ((orig_strict & COMPARE_DERIVED) && DERIVED_FROM_P (t2, t1))\n+\treturn true;\n+      \n+      return false;\n \n     case OFFSET_TYPE:\n-      val = (comptypes (build_pointer_type (TYPE_OFFSET_BASETYPE (t1)),\n-\t\t\tbuild_pointer_type (TYPE_OFFSET_BASETYPE (t2)), strict)\n-\t     && comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict));\n-      break;\n+      if (!comptypes (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2),\n+\t\t      orig_strict))\n+\treturn false;\n+      return comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict);\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      t1 = TREE_TYPE (t1);\n-      t2 = TREE_TYPE (t2);\n-      /* first, check whether the referred types match with the\n-         required level of strictness */\n-      val = comptypes (t1, t2, strict);\n-      if (val)\n-\tbreak;\n-      if (TREE_CODE (t1) == RECORD_TYPE \n-\t  && TREE_CODE (t2) == RECORD_TYPE)\n-\tgoto look_hard;\n-      break;\n+      return comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict);\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n-      val = ((TREE_TYPE (t1) == TREE_TYPE (t2)\n-\t      || comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict))\n-\t     && compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2)));\n-      break;\n+      if (!comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict))\n+\treturn false;\n+      return compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n \n     case ARRAY_TYPE:\n       /* Target types must match incl. qualifiers.  We use ORIG_STRICT\n \t here since this is the one place where\n \t COMPARE_REDECLARATION should be used.  */\n-      val = comp_array_types (comptypes, t1, t2, orig_strict);\n-      break;\n+      return comp_array_types (t1, t2, orig_strict & COMPARE_REDECLARATION);\n \n     case TEMPLATE_TYPE_PARM:\n-      return TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2)\n-\t&& TEMPLATE_TYPE_LEVEL (t1) == TEMPLATE_TYPE_LEVEL (t2);\n+      return (TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2)\n+\t      && TEMPLATE_TYPE_LEVEL (t1) == TEMPLATE_TYPE_LEVEL (t2));\n \n     case TYPENAME_TYPE:\n-      if (cp_tree_equal (TYPENAME_TYPE_FULLNAME (t1),\n-                         TYPENAME_TYPE_FULLNAME (t2)) < 1)\n-        return 0;\n+      if (!cp_tree_equal (TYPENAME_TYPE_FULLNAME (t1),\n+\t\t\t  TYPENAME_TYPE_FULLNAME (t2)))\n+        return false;\n       return same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n \n     case UNBOUND_CLASS_TEMPLATE:\n-      if (cp_tree_equal (TYPE_IDENTIFIER (t1),\n-                         TYPE_IDENTIFIER (t2)) < 1)\n-        return 0;\n+      if (!cp_tree_equal (TYPE_IDENTIFIER (t1), TYPE_IDENTIFIER (t2)))\n+        return false;\n       return same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n \n     case COMPLEX_TYPE:\n@@ -1065,7 +1031,7 @@ comptypes (t1, t2, strict)\n     default:\n       break;\n     }\n-  return attrval == 2 && val == 1 ? 2 : val;\n+  return false;\n }\n \n /* Subroutine of comp_target-types.  Make sure that the cv-quals change\n@@ -1166,9 +1132,8 @@ comp_target_types (ttl, ttr, nptrs)\n       return comp_cv_target_types (ttl, ttr, nptrs - 1);\n     }\n \n-  if (TREE_CODE (ttr) == ARRAY_TYPE)\n-    return comp_array_types (comp_target_types, ttl, ttr, COMPARE_STRICT);\n-  else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n+  my_friendly_assert (TREE_CODE (ttr) != ARRAY_TYPE, 20030617);\n+  if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n     {\n       tree argsl, argsr;\n       int saw_contra = 0;\n@@ -1263,11 +1228,9 @@ comp_target_types (ttl, ttr, nptrs)\n     {\n       if (nptrs < 0)\n \treturn 0;\n-      if (same_or_base_type_p (build_pointer_type (ttl), \n-\t\t\t       build_pointer_type (ttr)))\n+      if (same_or_base_type_p (ttl, ttr))\n \treturn 1;\n-      if (same_or_base_type_p (build_pointer_type (ttr), \n-\t\t\t       build_pointer_type (ttl)))\n+      if (same_or_base_type_p (ttr, ttl))\n \treturn -1;\n       return 0;\n     }\n@@ -1454,9 +1417,8 @@ comp_target_parms (parms1, parms2)\n     {\n       tree p1, p2;\n \n-      /* If one parmlist is shorter than the other,\n-\t they fail to match, unless STRICT is <= 0.  */\n-      if (t1 == 0 || t2 == 0)\n+      /* If one parmlist is shorter than the other, they fail to match.  */\n+      if (!t1 || !t2)\n \treturn 0;\n       p1 = TREE_VALUE (t1);\n       p2 = TREE_VALUE (t2);\n@@ -6313,8 +6275,6 @@ maybe_warn_about_returning_address_of_local (retval)\n       if (TREE_CODE (whats_returned) == AGGR_INIT_EXPR\n \t  || TREE_CODE (whats_returned) == TARGET_EXPR)\n \t{\n-\t  /* Get the target.  */\n-\t  whats_returned = TREE_OPERAND (whats_returned, 0);\n \t  warning (\"returning reference to temporary\");\n \t  return;\n \t}\n@@ -6402,7 +6362,8 @@ check_return_expr (retval)\n      that's supposed to return a value.  */\n   if (!retval && fn_returns_value_p)\n     {\n-      pedwarn (\"return-statement with no value, in function declared with a non-void return type\");\n+      pedwarn (\"return-statement with no value, in function returning `%D'\",\n+\t       valtype);\n       /* Clear this, so finish_function won't say that we reach the\n \t end of a non-void function (which we don't, we gave a\n \t return!).  */\n@@ -6418,7 +6379,8 @@ check_return_expr (retval)\n \t   its side-effects.  */\n \t  finish_expr_stmt (retval);\n       else\n-\tpedwarn (\"return-statement with a value, in function declared with a void return type\");\n+\tpedwarn (\"return-statement with a value, in function returning `%D'\",\n+\t\t retval);\n \n       current_function_returns_null = 1;\n \n@@ -6610,7 +6572,7 @@ ptr_reasonably_similar (to, from)\n       if (TREE_CODE (from) == OFFSET_TYPE\n \t  && comptypes (TYPE_OFFSET_BASETYPE (to),\n \t\t\tTYPE_OFFSET_BASETYPE (from), \n-\t\t\tCOMPARE_BASE | COMPARE_RELAXED))\n+\t\t\tCOMPARE_BASE | COMPARE_DERIVED))\n \tcontinue;\n \n       if (TREE_CODE (to) == INTEGER_TYPE\n@@ -6623,7 +6585,7 @@ ptr_reasonably_similar (to, from)\n       if (TREE_CODE (to) != POINTER_TYPE)\n \treturn comptypes\n \t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), \n-\t   COMPARE_BASE | COMPARE_RELAXED);\n+\t   COMPARE_BASE | COMPARE_DERIVED);\n     }\n }\n "}]}