{"sha": "6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYzNGQ2ZTA3OGZhZmE4Y2RjOTlhMmMzYjk4ZDVkODg4MmM2MjMwMw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-04-13T06:24:58Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-04-13T06:24:58Z"}, "message": "re PR fortran/26766 ([F2003] Recursive I/O still (again) broken)\n\n2006-04-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/26766\n\t* io/io.h: Add bit to identify associated unit as internal.\n\t* io/unit.c (get_external_unit): Renamed the find_unit_1 function to\n\treflect the external unit functionality vs internal unit.\n\t(get_internal_unit): New function to allocate and initialize an internal\n\tunit structure.\n\t(get_unit): Use get_internal_unit and get_external_unit.\n\t(is_internal_unit): Revised to use new bit added in io.h.\n\t* io/transfer.c (data_transfer_init): Fix line width.\n\t(st_read_done): Free memory allocated for internal unit.\n\t(st_write_done): Add test to only flush and truncate when not an\n\tinternal unit.  Free memory allocated for internal unit.\n\nFrom-SVN: r112914", "tree": {"sha": "c763d2334fb0ded7d39d7fef5c1d53dabe519ab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c763d2334fb0ded7d39d7fef5c1d53dabe519ab2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/comments", "author": null, "committer": null, "parents": [{"sha": "7b5d92b270ef6b7a55f4b337ee52777e53695807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b5d92b270ef6b7a55f4b337ee52777e53695807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b5d92b270ef6b7a55f4b337ee52777e53695807"}], "stats": {"total": 155, "additions": 106, "deletions": 49}, "files": [{"sha": "190d4a2768743e259923cdcbf44cb6fca899bf7b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "patch": "@@ -1,3 +1,18 @@\n+2006-04-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/26766\n+\t* io/io.h: Add bit to identify associated unit as internal.\n+\t* io/unit.c (get_external_unit): Renamed the find_unit_1 function to\n+\treflect the external unit functionality vs internal unit.\n+\t(get_internal_unit): New function to allocate and initialize an internal\n+\tunit structure.\n+\t(get_unit): Use get_internal_unit and get_external_unit.\n+\t(is_internal_unit): Revised to use new bit added in io.h.\n+\t* io/transfer.c (data_transfer_init): Fix line width.\n+\t(st_read_done): Free memory allocated for internal unit.\n+\t(st_write_done): Add test to only flush and truncate when not an\n+\tinternal unit.  Free memory allocated for internal unit.\n+\n 2006-04-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* io/io.h (st_parameter_dt): Revert 2005-12-10 change to"}, {"sha": "eed15ae36e832e76bf1a7c6dce40abf800630eb8", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "patch": "@@ -414,7 +414,10 @@ typedef struct st_parameter_dt\n           /* A namelist specific flag used to enable reading input from \n \t     line_buffer for logical reads.  */\n \t  unsigned line_buffer_enabled : 1;\n-\t  /* 18 unused bits.  */\n+\t  /* An internal unit specific flag used to identify that the associated\n+\t     unit is internal.  */\n+\t  unsigned unit_is_internal : 1;\n+\t  /* 17 unused bits.  */\n \n \t  char last_char;\n \t  char nml_delim;"}, {"sha": "11be456f7edbe1893086dc2c2467957692469fe0", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "patch": "@@ -1619,7 +1619,8 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n      it is always safe to truncate the file on the first write */\n   if (dtp->u.p.mode == WRITING\n       && dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n-      && dtp->u.p.current_unit->last_record == 0 && !is_preconnected(dtp->u.p.current_unit->s))\n+      && dtp->u.p.current_unit->last_record == 0 \n+      && !is_preconnected(dtp->u.p.current_unit->s))\n \tstruncate(dtp->u.p.current_unit->s);\n \n   /* Bugware for badly written mixed C-Fortran I/O.  */\n@@ -2317,6 +2318,8 @@ st_read_done (st_parameter_dt *dtp)\n     free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n+  if (is_internal_unit (dtp) && dtp->u.p.current_unit != NULL)\n+    free_mem (dtp->u.p.current_unit);\n   library_end ();\n }\n \n@@ -2353,10 +2356,12 @@ st_write_done (st_parameter_dt *dtp)\n \n       case NO_ENDFILE:\n \t/* Get rid of whatever is after this record.  */\n-\tflush (dtp->u.p.current_unit->s);\n-\tif (struncate (dtp->u.p.current_unit->s) == FAILURE)\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n-\n+        if (!is_internal_unit (dtp))\n+\t  {\n+\t    flush (dtp->u.p.current_unit->s);\n+\t    if (struncate (dtp->u.p.current_unit->s) == FAILURE)\n+\t      generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  }\n \tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \tbreak;\n       }\n@@ -2367,6 +2372,8 @@ st_write_done (st_parameter_dt *dtp)\n     free_mem (dtp->u.p.scratch);\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n+  if (is_internal_unit (dtp) && dtp->u.p.current_unit != NULL)\n+    free_mem (dtp->u.p.current_unit);\n   library_end ();\n }\n "}, {"sha": "81b128ee64034211bc82649573588aef56835a95", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 75, "deletions": 43, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f34d6e078fafa8cdc99a2c3b98d5d8882c62303/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=6f34d6e078fafa8cdc99a2c3b98d5d8882c62303", "patch": "@@ -75,7 +75,7 @@ Boston, MA 02110-1301, USA.  */\n \n \n #define CACHE_SIZE 3\n-static gfc_unit internal_unit, *unit_cache[CACHE_SIZE];\n+static gfc_unit *unit_cache[CACHE_SIZE];\n gfc_offset max_offset;\n gfc_unit *unit_root;\n #ifdef __GTHREAD_MUTEX_INIT\n@@ -260,12 +260,12 @@ delete_unit (gfc_unit * old)\n }\n \n \n-/* find_unit()-- Given an integer, return a pointer to the unit\n+/* get_external_unit()-- Given an integer, return a pointer to the unit\n  * structure.  Returns NULL if the unit does not exist,\n  * otherwise returns a locked unit. */\n \n static gfc_unit *\n-find_unit_1 (int n, int do_create)\n+get_external_unit (int n, int do_create)\n {\n   gfc_unit *p;\n   int c, created = 0;\n@@ -346,58 +346,99 @@ find_unit_1 (int n, int do_create)\n   return p;\n }\n \n+\n gfc_unit *\n find_unit (int n)\n {\n-  return find_unit_1 (n, 0);\n+  return get_external_unit (n, 0);\n }\n \n+\n gfc_unit *\n find_or_create_unit (int n)\n {\n-  return find_unit_1 (n, 1);\n+  return get_external_unit (n, 1);\n }\n \n-/* get_unit()-- Returns the unit structure associated with the integer\n- * unit or the internal file. */\n \n gfc_unit *\n-get_unit (st_parameter_dt *dtp, int do_create)\n+get_internal_unit (st_parameter_dt *dtp)\n {\n-  if ((dtp->common.flags & IOPARM_DT_HAS_INTERNAL_UNIT) != 0)\n+  gfc_unit * iunit;\n+\n+  /* Allocate memory for a unit structure.  */\n+\n+  iunit = get_mem (sizeof (gfc_unit));\n+  if (iunit == NULL)\n     {\n-      __gthread_mutex_lock (&internal_unit.lock);\n-      internal_unit.recl = dtp->internal_unit_len;\n-      if (is_array_io (dtp))\n-\t{\n-\t  internal_unit.rank = GFC_DESCRIPTOR_RANK (dtp->internal_unit_desc);\n-\t  internal_unit.ls = (array_loop_spec *)\n-\t    get_mem (internal_unit.rank * sizeof (array_loop_spec));\n-\t  dtp->internal_unit_len *=\n-\t    init_loop_spec (dtp->internal_unit_desc, internal_unit.ls);\n-\t}\n+      generate_error (&dtp->common, ERROR_INTERNAL_UNIT, NULL);\n+      return NULL;\n+    }\n \n-      internal_unit.s =\n-\topen_internal (dtp->internal_unit, dtp->internal_unit_len);\n-      internal_unit.bytes_left = internal_unit.recl;\n-      internal_unit.last_record=0;\n-      internal_unit.maxrec=0;\n-      internal_unit.current_record=0;\n+  memset (iunit, '\\0', sizeof (gfc_unit));\n \n-      /* Set flags for the internal unit */\n+  iunit->recl = dtp->internal_unit_len;\n \n-      internal_unit.flags.access = ACCESS_SEQUENTIAL;\n-      internal_unit.flags.action = ACTION_READWRITE;\n-      internal_unit.flags.form = FORM_FORMATTED;\n-      internal_unit.flags.delim = DELIM_NONE;\n-      internal_unit.flags.pad = PAD_YES;\n+  /* Set up the looping specification from the array descriptor, if any.  */\n \n-      return &internal_unit;\n+  if (is_array_io (dtp))\n+    {\n+      iunit->rank = GFC_DESCRIPTOR_RANK (dtp->internal_unit_desc);\n+      iunit->ls = (array_loop_spec *)\n+\tget_mem (iunit->rank * sizeof (array_loop_spec));\n+      dtp->internal_unit_len *=\n+\tinit_loop_spec (dtp->internal_unit_desc, iunit->ls);\n     }\n \n+  /* Set initial values for unit parameters.  */\n+\n+  iunit->s = open_internal (dtp->internal_unit, dtp->internal_unit_len);\n+  iunit->bytes_left = iunit->recl;\n+  iunit->last_record=0;\n+  iunit->maxrec=0;\n+  iunit->current_record=0;\n+  iunit->read_bad = 0;\n+\n+  /* Set flags for the internal unit.  */\n+\n+  iunit->flags.access = ACCESS_SEQUENTIAL;\n+  iunit->flags.action = ACTION_READWRITE;\n+  iunit->flags.form = FORM_FORMATTED;\n+  iunit->flags.pad = PAD_YES;\n+  iunit->flags.status = STATUS_UNSPECIFIED;\n+\n+  /* Initialize the data transfer parameters.  */\n+\n+  dtp->u.p.advance_status = ADVANCE_YES;\n+  dtp->u.p.blank_status = BLANK_UNSPECIFIED;\n+  dtp->u.p.seen_dollar = 0;\n+  dtp->u.p.skips = 0;\n+  dtp->u.p.pending_spaces = 0;\n+  dtp->u.p.max_pos = 0;\n+\n+  /* This flag tells us the unit is assigned to internal I/O.  */\n+  \n+  dtp->u.p.unit_is_internal = 1;\n+\n+  return iunit;\n+}\n+\n+\n+/* get_unit()-- Returns the unit structure associated with the integer\n+ * unit or the internal file. */\n+\n+gfc_unit *\n+get_unit (st_parameter_dt *dtp, int do_create)\n+{\n+\n+  if ((dtp->common.flags & IOPARM_DT_HAS_INTERNAL_UNIT) != 0)\n+    return get_internal_unit(dtp);\n+\n   /* Has to be an external unit */\n \n-  return find_unit_1 (dtp->common.unit, do_create);\n+  dtp->u.p.unit_is_internal = 0;\n+\n+  return get_external_unit (dtp->common.unit, do_create);\n }\n \n \n@@ -406,7 +447,7 @@ get_unit (st_parameter_dt *dtp, int do_create)\n int\n is_internal_unit (st_parameter_dt *dtp)\n {\n-  return dtp->u.p.current_unit == &internal_unit;\n+  return dtp->u.p.unit_is_internal;\n }\n \n \n@@ -432,15 +473,6 @@ init_units (void)\n   __GTHREAD_MUTEX_INIT_FUNCTION (&unit_lock);\n #endif\n \n-#ifdef __GTHREAD_MUTEX_INIT\n-  {\n-    __gthread_mutex_t tmp = __GTHREAD_MUTEX_INIT;\n-    internal_unit.lock = tmp;\n-  }\n-#else\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&internal_unit.lock);\n-#endif\n-\n   if (options.stdin_unit >= 0)\n     {\t\t\t\t/* STDIN */\n       u = insert_unit (options.stdin_unit);"}]}