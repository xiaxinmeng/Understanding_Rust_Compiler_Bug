{"sha": "43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNkOWFkMWRiZDI0ZjBkYmIxZWU4ZmJiODk3OGFjYzEwMTlhNjdmOA==", "commit": {"author": {"name": "Danny Smith", "email": "dannysmith@users.sourceforge.net", "date": "2005-10-12T20:54:50Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2005-10-12T20:54:50Z"}, "message": "re PR target/21275 (gcc 4.0.0 crash with mingw when using stdout in global var)\n\n\tPR middle-end/21275\n\tPR middle-end/21766\n\t* target.h (struct gcc_target): Add valid_dllimport_attribute_p\n\ttarget hook.\n\t(struct cxx): Add adjust_class_at_definition target hook.\n\t* target-def.h: (TARGET_VALID_DLLIMPORT_ATTRIBUTE_P): New define,\n\tdefaulting to hook_bool_tree_true. Add to TARGET_INITIALIZER\n\t(TARGET_CXX_ADJUST_CLASS_AT_DEFINITION): New define, defaulting to\n\thook_void_tree. Add to TARGET_CXX.\n\t* tree.h (struct decl_with_vis): Rename non_addr_const_p field to\n\tdllimport_flag.\n\t(DECL_NON_ADDR_CONSTANT_P): Replace with DECL_DLLIMPORT_P macro.\n\t* tree.c (merge_dllimport_decl_attributes): Check DECL_DLLIMPORT_P\n\tinstead of attribute. Check for dllexport override.  Warn if\n\tinconsistent dll linkage. Don't lose old dllimport if decl has\n\thad address referenced.   Tweak lookup of dllimport atribute.\n\t(handle_dll_attribute): Check targetm.valid_dllimport_attribute_p\n\tfor target specific rules.  Don't add dllimport attribute if\n\tDECL_DECLARED_INLINE_P.  Set DECL_DLLIMPORT_P when adding\n\tdllimport attribute.\n\t(staticp): Replace DECL_NON_ADDR_CONSTANT_P with DECL_DLLIMPORT_P.\n\t* varasm.c (initializer_constant_valid_p): Replace\n\tDECL_NON_ADDR_CONSTANT_P with DECL_DLLIMPORT_P\n\n\tPR target/21801\n\tPR target/23589\n\t* config.gcc (i[34567]86-*-cygwin*): Add winnt-cxx.o to\n\t'cxx_target_objs', winnt-stubs,o to 'extra_objs'.\n\t(i[34567]86-*-mingw32*): Likewise.\n\n\t* doc/tm.texi (TARGET_CXX_ADJUST_CLASS_AT_DEFINITION): Document.\n\t(TARGET_VALID_DLLIMPORT_ATTRIBUTE_P): Document.\n\n\t* config/i386/winnt.c (i386_pe_dllimport_p): Factor out\n\tC++-specific code. Change return value to bool.\n\t(i386_pe_dllimport_p): Likewise.\n\t(associated_type): Simplify and make language-independent\n\t(i386_pe_encode_section_info): Replace override of ambiguous\n\tdllimport symbol refs with a gcc_assert.\n\t(i386_pe_valid_dllimport_attribute_p): Define.\n\t* config/i386/winnt-cxx.c: New file. Define C++ versions of\n\ti386_pe_type_dllimport_p, i386_pe_type_dllexport_p,\n\ti386_pe_adjust_class_at_definition.\n\t* config/i386/winnt-stubs.c: New file. Define stub versions of\n\tlang-specific functions.\n\t* config/i386/i386-protos.h: Declare winnt-[cxx|stubs].c functions\n\ti386_pe_type_dllimport_p, i386_pe_type_dllexport_p,\n\ti386_pe_adjust_class_at_definition.\n\t(i386_pe_valid_dllimport_attribute_p): Declare.\n\t* config/i386/cygming.h (TARGET_VALID_DLLIMPORT_ATTRIBUTE_P): Define.\n\t(TARGET_CXX_ADJUST_CLASS_AT_DEFINITION): Define.\n\t* config/i386/t-cygming: Add rules for winnt-cxx.o, winnt-stubs.o.\n\n\tPR target/19704\n\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Replace test for\n\tdllimport attribute with test of DECL_DLLIMPORT_P.\n\n\ncp\n\tPR target/21801\n\tPR target/23589\n\t* class.c (finish_struct_1): Call\n\ttargetm.cxx.adjust_class_at_definition.\n\n\ntestsuite\n\t* gcc.dg/dll-2.c: Add tests for warnings.\n\t* gcc.dg/dll-3.c: Likewise.\n\t* gcc.dg/dll-4.c: Likewise.\n\n\t* g++.dg/ext/dllimport1.C: Adjust tests for warnings.\n\t* g++.dg/ext/dllimport2.C: Likewise.\n\t* g++.dg/ext/dllimport3.C: Likewise.\n\t* g++.dg/ext/dllimport7.C: Likewise.\n\t* g++.dg/ext/dllimport8.C: Likewise.\n\t* g++.dg/ext/dllimport9.C: Likewise.\n\nFrom-SVN: r105332", "tree": {"sha": "18c5c3123c37f3bfc1dcf357bb32d0289c2b8bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18c5c3123c37f3bfc1dcf357bb32d0289c2b8bb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/comments", "author": null, "committer": null, "parents": [{"sha": "bce71376125366159e33e872d5d34eff3112dd4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce71376125366159e33e872d5d34eff3112dd4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce71376125366159e33e872d5d34eff3112dd4b"}], "stats": {"total": 766, "additions": 542, "deletions": 224}, "files": [{"sha": "18c64b801c346c3fc8f27dab4341c975f8468432", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -1,3 +1,62 @@\n+2005-10-12  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+\tPR middle-end/21275\n+\tPR middle-end/21766\n+\t* target.h (struct gcc_target): Add valid_dllimport_attribute_p\n+\ttarget hook.\n+\t(struct cxx): Add adjust_class_at_definition target hook.\n+\t* target-def.h: (TARGET_VALID_DLLIMPORT_ATTRIBUTE_P): New define,\n+\tdefaulting to hook_bool_tree_true. Add to TARGET_INITIALIZER\n+\t(TARGET_CXX_ADJUST_CLASS_AT_DEFINITION): New define, defaulting to \n+\thook_void_tree. Add to TARGET_CXX.\n+\t* tree.h (struct decl_with_vis): Rename non_addr_const_p field to\n+\tdllimport_flag.\n+\t(DECL_NON_ADDR_CONSTANT_P): Replace with DECL_DLLIMPORT_P macro.\n+\t* tree.c (merge_dllimport_decl_attributes): Check DECL_DLLIMPORT_P\n+\tinstead of attribute. Check for dllexport override.  Warn if\n+\tinconsistent dll linkage. Don't lose old dllimport if decl has\n+\thad address referenced.   Tweak lookup of dllimport atribute.  \n+\t(handle_dll_attribute): Check targetm.valid_dllimport_attribute_p\n+\tfor target specific rules.  Don't add dllimport attribute if\n+\tDECL_DECLARED_INLINE_P.  Set DECL_DLLIMPORT_P when adding\n+\tdllimport attribute. \n+\t(staticp): Replace DECL_NON_ADDR_CONSTANT_P with DECL_DLLIMPORT_P.\n+\t* varasm.c (initializer_constant_valid_p): Replace\n+\tDECL_NON_ADDR_CONSTANT_P with DECL_DLLIMPORT_P\n+\n+\tPR target/21801\n+\tPR target/23589\n+\t* config.gcc (i[34567]86-*-cygwin*): Add winnt-cxx.o to \n+\t'cxx_target_objs', winnt-stubs,o to 'extra_objs'.\n+\t(i[34567]86-*-mingw32*): Likewise.\n+\n+\t* doc/tm.texi (TARGET_CXX_ADJUST_CLASS_AT_DEFINITION): Document.\n+\t(TARGET_VALID_DLLIMPORT_ATTRIBUTE_P): Document.\n+\t\t\t\n+\t* config/i386/winnt.c (i386_pe_dllimport_p): Factor out\n+\tC++-specific code. Change return value to bool. \n+\t(i386_pe_dllimport_p): Likewise.\n+\t(associated_type): Simplify and make language-independent\n+\t(i386_pe_encode_section_info): Replace override of ambiguous\n+\tdllimport symbol refs with a gcc_assert.\n+\t(i386_pe_valid_dllimport_attribute_p): Define.\n+\t* config/i386/winnt-cxx.c: New file. Define C++ versions of\n+\ti386_pe_type_dllimport_p, i386_pe_type_dllexport_p,\n+\ti386_pe_adjust_class_at_definition.\n+\t* config/i386/winnt-stubs.c: New file. Define stub versions of\n+\tlang-specific functions.\n+\t* config/i386/i386-protos.h: Declare winnt-[cxx|stubs].c functions\n+\ti386_pe_type_dllimport_p, i386_pe_type_dllexport_p, \n+\ti386_pe_adjust_class_at_definition.\n+\t(i386_pe_valid_dllimport_attribute_p): Declare. \n+\t* config/i386/cygming.h (TARGET_VALID_DLLIMPORT_ATTRIBUTE_P): Define.\n+\t(TARGET_CXX_ADJUST_CLASS_AT_DEFINITION): Define.\n+\t* config/i386/t-cygming: Add rules for winnt-cxx.o, winnt-stubs.o.\n+\n+\tPR target/19704\n+\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Replace test for\n+\tdllimport attribute with test of DECL_DLLIMPORT_P.\n+\n 2005-10-12  Adrian Straetling <straetling@de.ibm.com>\n \n \t* combine.c (make_extraction): Correct offset computation."}, {"sha": "21c6dab8cd98364f08c1c3c955844d49e118217e", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -1202,9 +1202,9 @@ i[34567]86-*-pe | i[34567]86-*-cygwin*)\n \ttmake_file=\"i386/t-cygwin i386/t-cygming\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \textra_options=\"${extra_options} i386/cygming.opt\"\n-\textra_objs=winnt.o\n+\textra_objs=\"winnt.o winnt-stubs.o\"\n \tc_target_objs=cygwin2.o\n-\tcxx_target_objs=cygwin2.o\n+\tcxx_target_objs=\"cygwin2.o winnt-cxx.o\"\n \textra_gcc_objs=cygwin1.o\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='posix'\n@@ -1216,7 +1216,8 @@ i[34567]86-*-mingw32*)\n \ttmake_file=\"i386/t-cygming i386/t-mingw32\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \textra_options=\"${extra_options} i386/cygming.opt\"\n-\textra_objs=winnt.o\n+\textra_objs=\"winnt.o winnt-stubs.o\"\n+\tcxx_target_objs=winnt-cxx.o\n \tcase ${enable_threads} in\n \t  \"\" | yes | win32) thread_file='win32' ;;\n \tesac"}, {"sha": "4005f1d8e637ef7916df6687eca6a23369830e45", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -410,6 +410,9 @@ extern int i386_pe_dllimport_name_p (const char *);\n #undef NO_PROFILE_COUNTERS\n #define NO_PROFILE_COUNTERS 1\n \n+#define TARGET_VALID_DLLIMPORT_ATTRIBUTE_P i386_pe_valid_dllimport_attribute_p\n+#define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION i386_pe_adjust_class_at_definition\n+\n #undef TREE\n \n #ifndef BUFSIZ"}, {"sha": "6c81d4d7e9f29332c2bd2530185c043033fe133c", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -244,6 +244,13 @@ extern void i386_pe_encode_section_info (tree, rtx, int);\n extern const char *i386_pe_strip_name_encoding (const char *);\n extern const char *i386_pe_strip_name_encoding_full (const char *);\n extern void i386_pe_output_labelref (FILE *, const char *);\n+extern bool i386_pe_valid_dllimport_attribute_p (tree);\n+\n+/* In winnt-cxx.c and winnt-stubs.c  */\n+extern void i386_pe_adjust_class_at_definition (tree);\n+extern bool i386_pe_type_dllimport_p (tree);\n+extern bool i386_pe_type_dllexport_p (tree);\n+\n extern rtx maybe_get_pool_constant (rtx);\n \n extern char internal_label_prefix[16];"}, {"sha": "7b3cf6a925568db75dcb32118262e354f73c02c0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -1982,7 +1982,7 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n \n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n   /* Dllimport'd functions are also called indirectly.  */\n-  if (decl && lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl))\n+  if (decl && DECL_DLLIMPORT_P (decl)\n       && ix86_function_regparm (TREE_TYPE (decl), NULL) >= 3)\n     return false;\n #endif"}, {"sha": "c001a8b0f618068e6ae4480d101a0494c0b8f7a6", "filename": "gcc/config/i386/t-cygming", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Ft-cygming", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Ft-cygming", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-cygming?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -16,4 +16,17 @@ winnt.o: $(srcdir)/config/i386/winnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t$(srcdir)/config/i386/winnt.c\n \n+winnt-cxx.o: $(srcdir)/config/i386/winnt-cxx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+  $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \\\n+  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t$(srcdir)/config/i386/winnt-cxx.c\n+\n+\n+winnt-stubs.o: $(srcdir)/config/i386/winnt-stubs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+  $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \\\n+  $(TM_P_H) toplev.h $(HASHTAB_H) $(GGC_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t$(srcdir)/config/i386/winnt-stubs.c\n+\n STMP_FIXINC=stmp-fixinc"}, {"sha": "5117bd7c7c6616572099cbe357832586ab73c9f5", "filename": "gcc/config/i386/winnt-cxx.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -0,0 +1,166 @@\n+/* Target support for C++ classes on Windows.\n+   Contributed by Danny Smith (dannysmith@users.sourceforge.net)\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"cp/cp-tree.h\" /* this is why we're a separate module */\n+#include \"flags.h\"\n+#include \"tm_p.h\"\n+#include \"toplev.h\"\n+#include \"hashtab.h\"\n+\n+bool\n+i386_pe_type_dllimport_p (tree decl)\n+{\n+   gcc_assert (TREE_CODE (decl) == VAR_DECL \n+               || TREE_CODE (decl) == FUNCTION_DECL);\n+\n+   if (TARGET_NOP_FUN_DLLIMPORT && TREE_CODE (decl) == FUNCTION_DECL)\n+     return false;\n+\n+   /* We ignore the dllimport attribute for inline member functions.\n+      This differs from MSVC behavior which treats it like GNUC\n+      'extern inline' extension.  Also ignore for template\n+      instantiations with linkonce semantics and artificial methods.  */\n+    if (TREE_CODE (decl) ==  FUNCTION_DECL\n+        && (DECL_DECLARED_INLINE_P (decl)\n+\t    || DECL_TEMPLATE_INSTANTIATION (decl)\n+\t    || DECL_ARTIFICIAL (decl)))\n+      return false;\n+\n+   /* Since we can't treat a pointer to a dllimport'd symbol as a\n+       constant address, we turn off the attribute on C++ virtual\n+       methods to allow creation of vtables using thunks.  */\n+    else if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n+\t     && DECL_VIRTUAL_P (decl))\n+      {\n+\t/* Even though we ignore the attribute from the start, warn if we later see\n+\t   an out-of class definition, as we do for other member functions in\n+\t   tree.c:merge_dllimport_decl_attributes.  If this is the key method, the\n+\t   definition may affect the import-export status of vtables, depending\n+           on how we handle MULTIPLE_SYMBOL_SPACES in cp/decl2.c.   */\n+\tif (DECL_INITIAL (decl))\n+\t  {\n+\t    warning (OPT_Wattributes, \"%q+D redeclared without dllimport attribute: \"\n+\t\t    \"previous dllimport ignored\", decl);\n+#ifdef PE_DLL_DEBUG\n+\t    if (decl == CLASSTYPE_KEY_METHOD (DECL_CONTEXT (decl)))            \n+\t      warning (OPT_Wattributes, \"key method %q+D of dllimport'd class defined\"\n+\t\t       decl);\n+#endif\n+\t  }\n+\treturn false;\n+      }\n+\n+      /* Don't mark defined functions as dllimport.  This code will only be\n+         reached if we see a non-inline function defined out-of-class.  */\n+    else if (TREE_CODE (decl) ==  FUNCTION_DECL\n+\t     && (DECL_INITIAL (decl)))\n+      return false;\n+\n+    /*  Don't allow definitions of static data members in dllimport class,\n+        If vtable data is marked as DECL_EXTERNAL, import it; otherwise just\n+        ignore the class attribute.  */\n+    else if (TREE_CODE (decl) == VAR_DECL\n+\t     && TREE_STATIC (decl) && TREE_PUBLIC (decl)\n+\t     && !DECL_EXTERNAL (decl))\n+      {\n+\tif (!DECL_VIRTUAL_P (decl))\n+\t     error (\"definition of static data member %q+D of \"\n+\t\t    \"dllimport'd class\", decl);\n+\treturn false;\n+      }\n+\n+    return true;\n+}\n+\n+\n+bool\n+i386_pe_type_dllexport_p (tree decl)\n+{\n+   gcc_assert (TREE_CODE (decl) == VAR_DECL \n+               || TREE_CODE (decl) == FUNCTION_DECL);\n+   /* Avoid exporting compiler-generated default dtors and copy ctors.\n+      The only artificial methods that need to be exported are virtual\n+      and non-virtual thunks.  */\n+   if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n+       && DECL_ARTIFICIAL (decl) && !DECL_THUNK_P (decl))\n+     return false;\n+   return true;\n+}\n+\n+static inline void maybe_add_dllimport (tree decl) \n+{\n+  if (i386_pe_type_dllimport_p (decl))\n+    DECL_DLLIMPORT_P (decl) = 1;   \n+}\n+\n+void\n+i386_pe_adjust_class_at_definition (tree t)\n+{\n+  tree member;\n+\n+  gcc_assert (CLASS_TYPE_P (t));\n+\n+ /* We only look at dllimport.  The only thing that dllexport does is\n+    add stuff to a '.drectiv' section at end-of-file, so no need to do\n+    anything for dllexport'd classes until we generate RTL. */  \n+  if (lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (t)) == NULL_TREE)\n+    return;\n+\n+  /* We don't actually add the attribute to the decl, just set the flag\n+     that signals that the address of this symbol is not a compile-time\n+     constant.   Any subsequent out-of-class declaration of members wil\n+     cause the DECL_DLLIMPORT_P flag to be unset.\n+     (See  tree.c: merge_dllimport_decl_attributes).\n+     That is just right since out-of class declarations can only be a\n+     definition.  We recheck the class members  at RTL generation to\n+     emit warnings if this has happened.  Definition of static data member\n+     of dllimport'd class always causes an error (as per MS compiler).\n+     */\n+\n+  /* Check static VAR_DECL's.  */\n+  for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n+    if (TREE_CODE (member) == VAR_DECL)     \n+      maybe_add_dllimport (member);\n+    \n+  /* Check FUNCTION_DECL's.  */\n+  for (member = TYPE_METHODS (t); member;  member = TREE_CHAIN (member))\n+    maybe_add_dllimport (member);\n+ \n+  /* Check vtables  */\n+  for (member = CLASSTYPE_VTABLES (t); member;  member = TREE_CHAIN (member))\n+    if (TREE_CODE (member) == VAR_DECL) \n+      maybe_add_dllimport (member);\n+\n+/* We leave typeinfo tables alone.  We can't mark TI objects as\n+     dllimport, since the address of a secondary VTT may be needed\n+     for static initialization of a primary VTT.  VTT's  of\n+     dllimport'd classes should always be link-once COMDAT.  */ \n+}"}, {"sha": "b373345de9cca6964a088048cd152e98d0558ce1", "filename": "gcc/config/i386/winnt-stubs.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fwinnt-stubs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fwinnt-stubs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt-stubs.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -0,0 +1,53 @@\n+/* Dummy subroutines for language-specific support on Windows.\n+   Contributed by Danny Smith (dannysmith@users.sourceforge.net)\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"tm_p.h\"\n+#include \"toplev.h\"\n+#include \"hashtab.h\"\n+\n+bool\n+i386_pe_type_dllimport_p (tree decl ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+\n+bool\n+i386_pe_type_dllexport_p (tree decl ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+\n+void\n+i386_pe_adjust_class_at_definition (tree t ATTRIBUTE_UNUSED)\n+{ }"}, {"sha": "f8a36ff1ba14b85a4d1970a5aeaffe706f8a5b1b", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 64, "deletions": 152, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -48,8 +48,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n static tree associated_type (tree);\n static tree gen_stdcall_or_fastcall_suffix (tree, bool);\n-static int i386_pe_dllexport_p (tree);\n-static int i386_pe_dllimport_p (tree);\n+static bool i386_pe_dllexport_p (tree);\n+static bool i386_pe_dllimport_p (tree);\n static void i386_pe_mark_dllexport (tree);\n static void i386_pe_mark_dllimport (tree);\n \n@@ -115,131 +115,63 @@ ix86_handle_selectany_attribute (tree *node, tree name,\n static tree\n associated_type (tree decl)\n {\n-  tree t = NULL_TREE;\n-\n-  /* In the C++ frontend, DECL_CONTEXT for a method doesn't actually refer\n-     to the containing class.  So we look at the 'this' arg.  */\n-  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-    {\n-      /* Artificial methods are not affected by the import/export status\n-\t of their class unless they are COMDAT.  Implicit copy ctor's and\n-\t dtor's are not affected by class status but virtual and\n-\t non-virtual thunks are.  */\n-      if (!DECL_ARTIFICIAL (decl) || DECL_COMDAT (decl))\n-\tt = TYPE_MAIN_VARIANT\n-\t  (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)))));\n-    }\n-  else if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n-    t = DECL_CONTEXT (decl);\n-\n-  return t;\n+  return  (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n+            ?  DECL_CONTEXT (decl) : NULL_TREE;\n }\n \n-/* Return nonzero if DECL is a dllexport'd object.  */\n \n-static int\n+/* Return true if DECL is a dllexport'd object.  */\n+\n+static bool\n i386_pe_dllexport_p (tree decl)\n {\n-  tree exp;\n-\n   if (TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != FUNCTION_DECL)\n-    return 0;\n-  exp = lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl));\n-  if (exp)\n-    return 1;\n-\n-  /* Class members get the dllexport status of their class.  */\n-  if (associated_type (decl))\n-    {\n-      exp = lookup_attribute (\"dllexport\",\n-\t\t\t      TYPE_ATTRIBUTES (associated_type (decl)));\n-      if (exp)\n-\treturn 1;\n-    }\n+       && TREE_CODE (decl) != FUNCTION_DECL)\n+    return false;\n \n-  return 0;\n-}\n+  if (lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl)))\n+    return true;\n+\n+  /* Also mark class members of exported classes with dllexport.  */\n+  if (associated_type (decl)\n+      && lookup_attribute (\"dllexport\",\n+\t\t\t    TYPE_ATTRIBUTES (associated_type (decl))))\n+    return i386_pe_type_dllexport_p (decl);\n \n-/* Return nonzero if DECL is a dllimport'd object.  */\n+  return false;\n+}\n \n-static int\n+static bool\n i386_pe_dllimport_p (tree decl)\n {\n-  tree imp;\n-  int context_imp = 0;\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && TARGET_NOP_FUN_DLLIMPORT)\n-    return 0;\n-\n   if (TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != FUNCTION_DECL)\n-    return 0;\n-\n-  imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n-\n-  /* Class members get the dllimport status of their class.  */\n-  if (!imp && associated_type (decl))\n-    {\n-      imp = lookup_attribute (\"dllimport\",\n-\t\t\t      TYPE_ATTRIBUTES (associated_type (decl)));\n-      if (imp)\n-\tcontext_imp = 1;\n-    }\n-\n-  if (imp)\n-    {\n-      /* Don't mark defined functions as dllimport.  If the definition\n-\t itself was marked with dllimport, than ix86_handle_dll_attribute\n-\t reports an error. This handles the case when the definition\n-\t overrides an earlier declaration.  */\n-      if (TREE_CODE (decl) ==  FUNCTION_DECL && DECL_INITIAL (decl)\n-\t  && !DECL_INLINE (decl))\n-\t{\n-\t   /* Don't warn about artificial methods.  */\n-\t  if (!DECL_ARTIFICIAL (decl))\n-\t    warning (0, \"function %q+D is defined after prior declaration \"\n-\t\t     \"as dllimport: attribute ignored\", decl);\n-\t  return 0;\n-\t}\n-\n-      /* We ignore the dllimport attribute for inline member functions.\n-\t This differs from MSVC behavior which treats it like GNUC\n-\t 'extern inline' extension.  */\n-      else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n-        {\n-\t  if (extra_warnings)\n-\t    warning (0, \"inline function %q+D is declared as dllimport: \"\n-\t\t     \"attribute ignored\", decl);\n-\t  return 0;\n-\t}\n-\n-      /*  Don't allow definitions of static data members in dllimport class,\n-\t  Just ignore attribute for vtable data.  */\n-      else if (TREE_CODE (decl) == VAR_DECL\n-\t       && TREE_STATIC (decl) && TREE_PUBLIC (decl)\n-\t       && !DECL_EXTERNAL (decl) && context_imp)\n-\t{\n-\t  if (!DECL_VIRTUAL_P (decl))\n-            error (\"definition of static data member %q+D of \"\n-\t\t   \"dllimport'd class\", decl);\n-\t  return 0;\n-\t}\n-\n-      /* Since we can't treat a pointer to a dllimport'd symbol as a\n-\t constant address, we turn off the attribute on C++ virtual\n-\t methods to allow creation of vtables using thunks.  Don't mark\n-\t artificial methods either (in associated_type, only COMDAT\n-\t artificial method get import status from class context).  */\n-      else if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n-\t       && (DECL_VIRTUAL_P (decl) || DECL_ARTIFICIAL (decl)))\n-\treturn 0;\n-\n-      return 1;\n-    }\n+       && TREE_CODE (decl) != FUNCTION_DECL)\n+    return false;\n+\n+  /* Lookup the attribute rather than rely on the DECL_DLLIMPORT_P flag.\n+     We may need to override an earlier decision.  */\n+  if (lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl)))\n+    return true;\n+\n+  /* The DECL_DLLIMPORT_P flag was set for decls in the class definition\n+     by  targetm.cxx.adjust_class_at_definition.  Check again to emit\n+     warnings if the class attribute has been overriden by an\n+     out-of-class definition.  */\n+  if (associated_type (decl)\n+      && lookup_attribute (\"dllimport\",\n+\t\t\t    TYPE_ATTRIBUTES (associated_type (decl))))\n+    return i386_pe_type_dllimport_p (decl);\n+\n+  return false;\n+}\n \n-  return 0;\n+/* Handle the -mno-fun-dllimport target switch.  */\n+bool\n+i386_pe_valid_dllimport_attribute_p (tree decl)\n+{\n+   if (TARGET_NOP_FUN_DLLIMPORT && TREE_CODE (decl) == FUNCTION_DECL)\n+     return false;\n+   return true;\n }\n \n /* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n@@ -283,7 +215,6 @@ i386_pe_mark_dllexport (tree decl)\n \t       decl);\n      /* Remove DLL_IMPORT_PREFIX.  */\n       oldname += strlen (DLL_IMPORT_PREFIX);\n-      DECL_NON_ADDR_CONST_P (decl) = 0;\n     }\n   else if (i386_pe_dllexport_name_p (oldname))\n     return;  /*  already done  */\n@@ -328,7 +259,9 @@ i386_pe_mark_dllimport (tree decl)\n     {\n       /* Already done, but do a sanity check to prevent assembler\n \t errors.  */\n-      gcc_assert (DECL_EXTERNAL (decl) && TREE_PUBLIC (decl));\n+      gcc_assert (DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)\n+\t\t  && DECL_DLLIMPORT_P (decl));\n+      return;\n     }\n \n   newname = alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);\n@@ -345,8 +278,7 @@ i386_pe_mark_dllimport (tree decl)\n   newrtl = gen_rtx_MEM (Pmode,symref);\n   XEXP (DECL_RTL (decl), 0) = newrtl;\n \n-  /* Can't treat a pointer to this as a constant address */\n-  DECL_NON_ADDR_CONST_P (decl) = 1;\n+  DECL_DLLIMPORT_P (decl) = 1;\n }\n \n /* Return string which is the former assembler name modified with a\n@@ -431,45 +363,25 @@ i386_pe_encode_section_info (tree decl, rtx rtl, int first)\n     }\n \n   /* Mark the decl so we can tell from the rtl whether the object is\n-     dllexport'd or dllimport'd.  This also handles dllexport/dllimport\n-     override semantics.  */\n+     dllexport'd or dllimport'd.  tree.c: merge_dllimport_decl_attributes\n+     handles dllexport/dllimport override semantics.  */\n \n   if (i386_pe_dllexport_p (decl))\n     i386_pe_mark_dllexport (decl);\n   else if (i386_pe_dllimport_p (decl))\n     i386_pe_mark_dllimport (decl);\n-  /* It might be that DECL has already been marked as dllimport, but a\n-     subsequent definition nullified that.  The attribute is gone but\n-     DECL_RTL still has (DLL_IMPORT_PREFIX) prefixed. We need to remove\n-     that. Ditto for the DECL_NON_ADDR_CONST_P flag.  */\n-  else if ((TREE_CODE (decl) == FUNCTION_DECL\n-\t    || TREE_CODE (decl) == VAR_DECL)\n-\t   && DECL_RTL (decl) != NULL_RTX\n-\t   && GET_CODE (DECL_RTL (decl)) == MEM\n-\t   && GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n-\t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n-\t   && i386_pe_dllimport_name_p (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n-    {\n-      const char *oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n-\n-      /* Remove DLL_IMPORT_PREFIX.  */\n-      tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n-      rtx symref = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-      SYMBOL_REF_DECL (symref) = decl;\n-      XEXP (DECL_RTL (decl), 0) = symref;\n-      DECL_NON_ADDR_CONST_P (decl) = 0;\n-\n-      /* We previously set TREE_PUBLIC and DECL_EXTERNAL.\n-\t We leave these alone for now.  */\n-\n-      if (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n-\twarning (0, \"%q+D defined locally after being \"\n-\t\t \"referenced with dllimport linkage\", decl);\n-      else\n-\twarning (OPT_Wattributes, \"%q+D redeclared without dllimport \"\n-\t\t \"attribute after being referenced with dllimport linkage\",\n-\t\t decl);\n-    }\n+  /* It might be that DECL has been declared as dllimport, but a\n+     subsequent definition nullified that.  Assert that\n+     tree.c: merge_dllimport_decl_attributes has removed the attribute\n+     before the RTL name was marked with the DLL_IMPORT_PREFIX.  */\n+  else\n+    gcc_assert (!((TREE_CODE (decl) == FUNCTION_DECL\n+\t    \t   || TREE_CODE (decl) == VAR_DECL)\n+\t\t  && rtl != NULL_RTX\n+\t\t  && GET_CODE (rtl) == MEM\n+\t\t  && GET_CODE (XEXP (rtl, 0)) == MEM\n+\t\t  && GET_CODE (XEXP (XEXP (rtl, 0), 0)) == SYMBOL_REF\n+\t\t  && i386_pe_dllimport_name_p (XSTR (XEXP (XEXP (rtl, 0), 0), 0))));\n }\n \n /* Strip only the leading encoding, leaving the stdcall suffix and fastcall"}, {"sha": "cb4ce856bfcb14c81fa3c78452164230a582901e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -1,3 +1,11 @@\n+2005-10-12  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+\tPR target/21801\n+\tPR target/23589\n+\t* class.c (finish_struct_1): Call\n+\ttargetm.cxx.adjust_class_at_definition.\n+\n+\n 2005-10-12  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/21592"}, {"sha": "dceeffe29c101e16715773725dd3dc755f8783c7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -5028,6 +5028,11 @@ finish_struct_1 (tree t)\n   if (warn_overloaded_virtual)\n     warn_hidden (t);\n \n+  /* Class layout, assignment of virtual table slots, etc., is now\n+     complete.  Give the back end a chance to tweak the visibility of\n+     the class or perform any other required target modifications.  */\n+  targetm.cxx.adjust_class_at_definition (t);\n+\n   maybe_suppress_debug_info (t);\n \n   dump_class_hierarchy (t);"}, {"sha": "46d24b6b7896dd030d099f7d0ec153747f6759ad", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -8478,6 +8478,12 @@ to perform initial processing of the @samp{dllimport} and\n @file{i386/i386.c}, for example.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_VALID_DLLIMPORT_ATTRIBUTE_P (tree @var{decl})\n+@var{decl} is a variable or function with @code{__attribute__((dllimport))}\n+specified. Use this hook if the target needs to add extra validation\n+checks to @code{handle_dll_attribute}.\n+@end deftypefn\n+\n @defmac TARGET_DECLSPEC\n Define this macro to a nonzero value if you want to treat\n @code{__declspec(X)} as equivalent to @code{__attribute((X))}.  By\n@@ -8657,6 +8663,12 @@ should be used to register static destructors when @option{-fuse-cxa-atexit}\n is in effect.  The default is to return false to use @code{__cxa_atexit}.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_CXX_ADJUST_CLASS_AT_DEFINITION (tree @var{type})\n+@var{type} is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that has just been\n+defined.  Use this hook to make adjustments to the class (eg, tweak\n+visibility or perform any other required target modifications).\n+@end deftypefn\n+\n @node Misc\n @section Miscellaneous Parameters\n @cindex parameters, miscellaneous"}, {"sha": "6dd121d952f6846e55db02c60499a410748ed953", "filename": "gcc/target-def.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -147,6 +147,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_INVALID_WITHIN_DOLOOP default_invalid_within_doloop\n #endif\n \n+#ifndef TARGET_VALID_DLLIMPORT_ATTRIBUTE_P\n+#define TARGET_VALID_DLLIMPORT_ATTRIBUTE_P hook_bool_tree_true\n+#endif\n+\n #ifndef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS false\n #endif\n@@ -516,6 +520,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_CXX_USE_AEABI_ATEXIT hook_bool_void_false\n #endif\n \n+#ifndef TARGET_CXX_ADJUST_CLASS_AT_DEFINITION\n+#define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION hook_void_tree\n+#endif\n+\n #define TARGET_CXX\t\t\t\t\\\n   {\t\t\t\t\t\t\\\n     TARGET_CXX_GUARD_TYPE,\t\t\t\\\n@@ -528,6 +536,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n     TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY,\t\\\n     TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT,        \\\n     TARGET_CXX_USE_AEABI_ATEXIT,\t\t\\\n+    TARGET_CXX_ADJUST_CLASS_AT_DEFINITION\t\\\n   }\n \n /* The whole shebang.  */\n@@ -593,6 +602,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_STACK_PROTECT_GUARD,\t\t\t\\\n   TARGET_STACK_PROTECT_FAIL,\t\t\t\\\n   TARGET_INVALID_WITHIN_DOLOOP,\t\t\t\\\n+  TARGET_VALID_DLLIMPORT_ATTRIBUTE_P,\t\t\\\n   TARGET_CALLS,\t\t\t\t\t\\\n   TARGET_INVALID_CONVERSION,\t\t\t\\\n   TARGET_INVALID_UNARY_OP,\t\t\t\\"}, {"sha": "cd850d1a4b5eb782d43e57b5c350c1028fffd980", "filename": "gcc/target.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -550,6 +550,11 @@ struct gcc_target\n   /* Returns NULL if target supports the insn within a doloop block,\n      otherwise it returns an error message.  */\n   const char * (*invalid_within_doloop) (rtx);\n+\n+  /* DECL is a variable or function with __attribute__((dllimport))\n+     specified.  Use this hook if the target needs to add extra validation\n+     checks to  handle_dll_attribute ().  */\n+  bool (* valid_dllimport_attribute_p) (tree decl);\n     \n   /* Functions relating to calls - argument passing, returns, etc.  */\n   struct calls {\n@@ -660,6 +665,11 @@ struct gcc_target\n     /* Returns true if __aeabi_atexit should be used to register static\n        destructors.  */\n     bool (*use_aeabi_atexit) (void);\n+    /* TYPE is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that\n+       has just been defined.  Use this hook to make adjustments to the\n+       class  (eg, tweak visibility or perform any other required\n+       target modifications).  */  \n+    void (*adjust_class_at_definition) (tree type);\n   } cxx;\n \n   /* True if unwinding tables should be generated by default.  */"}, {"sha": "18ed822c4f3d1175e7f39b2b2b3dba9b9c04c0b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -1,3 +1,16 @@\n+2005-10-12  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+\t* gcc.dg/dll-2.c: Add tests for warnings.\n+\t* gcc.dg/dll-3.c: Likewise.\n+\t* gcc.dg/dll-4.c: Likewise.\n+\n+\t* g++.dg/ext/dllimport1.C: Adjust tests for warnings.\n+\t* g++.dg/ext/dllimport2.C: Likewise.\n+\t* g++.dg/ext/dllimport3.C: Likewise.\n+\t* g++.dg/ext/dllimport7.C: Likewise.\n+\t* g++.dg/ext/dllimport8.C: Likewise.\n+\t* g++.dg/ext/dllimport9.C: Likewise.\n+\n 2005-10-10  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/24092"}, {"sha": "1fb69ed9f5c08b2274c316db761b500620bda875", "filename": "gcc/testsuite/g++.dg/ext/dllimport1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport1.C?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -5,13 +5,13 @@\n class __attribute__((dllimport)) Foo\n {\n  public:\n-  virtual void dummy_foo_func(void)\t// { dg-warning \"inline function\" }\n+  virtual void dummy_foo_func(void)\n     {}\n-  void Foo::dummy_foo_fun2();\n+  void dummy_foo_fun2();\n   virtual ~Foo();  //  avoid warning  \n };\n \n-void Foo::dummy_foo_fun2()\t//  { dg-warning \"defined\" }\n+void Foo::dummy_foo_fun2()\t//  { dg-warning \"redeclared without dllimport\" }\n {\n }\n "}, {"sha": "87a96d8ddee6fb1d5ad1cc8615073ab0062abed6", "filename": "gcc/testsuite/g++.dg/ext/dllimport2.C", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport2.C?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -1,27 +1,26 @@\n // { dg-do compile { target i?86-*-cygwin* i?86-*-mingw*} }\n-\n // PR c++/9738  Dllimport attribute is overriden by later definition/redeclaration\n \n void __attribute__((dllimport)) Bar(void);\n void __attribute__((dllimport)) Baz(void);\n __attribute__((dllimport)) int Biz;\n __attribute__((dllimport)) int Boz;\n \n+\n void Foo(void)\n   {\n     Bar();\n     Baz();\n     Biz++;\t \n     Boz++;\t \n   }\n- \n-void Bar(void)\t\t// { dg-warning \"defined\" }\n+\n+void Baz(void);\t\t// { dg-warning \"referenced with dll linkage\" }\n+void Bar(void)\t\t// { dg-warning \"referenced with dll linkage\" }\n   {\n   }\n-\n-void Baz(void);\t\t// { dg-warning \"redeclared\" }\n-extern int Biz;\t\t// { dg-warning \"redeclared\" }\n-int Boz;\t\t// { dg-warning \"defined\" }\n+extern int Biz;\t\t// { dg-warning \"referenced with dll linkage\" }\n+int Boz;\t\t// { dg-warning \"referenced with dll linkage\" }\n \n void foo()\n {"}, {"sha": "cd16dfa2505fe67628abf095f0b6e12a969d4656", "filename": "gcc/testsuite/g++.dg/ext/dllimport3.C", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport3.C?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -4,22 +4,21 @@\n // redefinition without attribute.\n  \n struct Foo\n- {\n-     int a;\n- };\n+{\n+  int a;\n+};\n \n  __attribute__((dllimport)) struct Foo f;\n \n- void Bar(void)\n- {\n-     void* dummy = &f;\n- }\n+void Bar(void)\n+{\n+  void* dummy  = (void*) &f;\n+}\n \n- struct Foo f;\t// { dg-warning \"defined\" }\n+struct Foo f;\t// { dg-warning \"referenced with dll linkage\" }\n \n-// Dllimport sets DECL_NON_ADDR_CONST_P to 1, so following\n+// Dllimport'd symbols do not have a constant address, so following\n // assignment would require static_initialization_and_destruction\n // if attribute is retained. \n \n- void* dummy = &f;\n- \n+void* dummy = &f;"}, {"sha": "9754ada962c2aa99cd598a4819c490ad159c8040", "filename": "gcc/testsuite/g++.dg/ext/dllimport7.C", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport7.C?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -18,8 +18,12 @@ class  __declspec(dllimport) Bar\n     static const Baz null_baz;\n };\n \n-const int Bar::three = 3;\t//  { dg-error \"definition of static data\" }\n-const Baz Bar::null_baz;\t//  { dg-error \"definition of static data\" }\n+const int Bar::three = 3;       //  { dg-warning \"redeclared without dllimport\" }\n+//  { dg-error \"definition of static data\" \"C++ specific error\" { target i?86-*-cygwin* i?86-*-mingw* } 21 }\n+\t\t\t\t\n+const Baz Bar::null_baz;\t//  { dg-warning \"redeclared without dllimport\" }\n+//  { dg-error \"definition of static data\" \"C++ specific error\" { target i?86-*-cygwin* i?86-*-mingw* }  24 }\n+\n \n \n int foo()"}, {"sha": "55326c5186683bdf6e93632bda3f1dc5781cbc99", "filename": "gcc/testsuite/g++.dg/ext/dllimport8.C", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport8.C?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -6,19 +6,19 @@\n // { dg-options { -Wall -W } }\n \n struct  __attribute__((dllimport)) Foo\n- {\n-    static int static_int;\n-    static void static_func1();\n-    static void static_func2();\n+{\n+  static int static_int;\n+  static void static_func1();\n+  static void static_func2();\n  };\n \n-void Foo::static_func1()\t//  { dg-warning \"defined\" }\n-  {\n-  }\n+void Foo::static_func1()\t//  { dg-warning \"redeclared without dllimport\" }\n+{\n+}\n \n-inline void Foo::static_func2()\t//  { dg-warning \"inline function\" }\n- {\n- }\n+inline void Foo::static_func2()\n+{\n+}\n \n void testfoo()\n { "}, {"sha": "8d60bb84d3a41abd9017476fdaa4af18c8029fd5", "filename": "gcc/testsuite/g++.dg/ext/dllimport9.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fdllimport9.C?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -6,11 +6,11 @@ inline __attribute__((dllimport)) void bar() { }\t// { dg-warning \"inline\" }\n \n struct __attribute__ ((dllimport)) Blah\t\n {\n-  void in_blah () { }\t\t\t\t// { dg-warning \"inline\" }\n+  void in_blah () { }  // Don't warn if member declared inline in class definition.\n   void out_blah ();\n };\n \n-inline void Blah::out_blah(){ }\t\t\t// { dg-warning \"inline\" }\n+inline void Blah::out_blah(){ }\t// Don't warn for inline override of external declaration\n \n void use_inlines()\n {"}, {"sha": "3b8b60eee41e0b05b9b08fb5e1adfaa62ceaab5e", "filename": "gcc/testsuite/gcc.dg/dll-2.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-2.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -11,13 +11,12 @@\n /* { dg-require-dll \"\" } */\n \n __declspec (dllimport) int foo1 ();\n-__declspec (dllexport) int foo1 ();\n-\n+__declspec (dllexport) int foo1 ();\t/* { dg-warning \"previous dllimport ignored\" } */\n __declspec (dllexport) int foo2 ();\n-__declspec (dllimport) int foo2 ();\n+__declspec (dllimport) int foo2 ();\t/* { dg-warning \"dllimport ignored\" } */\n \n __declspec (dllimport) int bar1;\n-__declspec (dllexport) int bar1;\n+__declspec (dllexport) int bar1;\t/* { dg-warning \"previous dllimport ignored\" } */\n \n __declspec (dllexport) int bar2;\n-__declspec (dllimport) int bar2;\n+__declspec (dllimport) int bar2;\t/* { dg-warning \"dllimport ignored\" } */"}, {"sha": "0a3f7df09881ed4a2fc557b147375946eaec0377", "filename": "gcc/testsuite/gcc.dg/dll-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-3.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -5,10 +5,10 @@\n /* { dg-do compile { target i?86-pc-mingw* } } */\n \n __declspec (dllimport) int foo1 ();\n-__declspec (dllexport) int foo1 ();\n+__declspec (dllexport) int foo1 ();\t/* { dg-warning \"previous dllimport ignored\" } */\n \n __declspec (dllexport) int foo2 ();\n-__declspec (dllimport) int foo2 ();\n+__declspec (dllimport) int foo2 ();\t/* { dg-warning \"dllimport ignored\" } */\n \n __declspec (dllexport) int foo1 () { return foo2 (); }\n __declspec (dllexport) int foo2 () { return foo1 (); }"}, {"sha": "9fcc8e9ad2c6cb5f13d154770177cae3b994f94e", "filename": "gcc/testsuite/gcc.dg/dll-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdll-4.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -3,10 +3,10 @@\n /* { dg-do compile { target i?86-pc-mingw* } } */\n \n __declspec (dllimport) int foo1;\n-int foo1;\n+int foo1;\t/* { dg-warning \"redeclared without dllimport\" } */\n \n __declspec (dllimport) int foo2;\n-int foo2 = 5;\n+int foo2 = 5;\t/* { dg-warning \"redeclared without dllimport\" } */\n \n int f () { return foo1 + foo2; }\n "}, {"sha": "946bf90044eaa05066f41c07a416c2ab5aea7520", "filename": "gcc/tree.c", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -1797,7 +1797,7 @@ staticp (tree arg)\n     case VAR_DECL:\n       return ((TREE_STATIC (arg) || DECL_EXTERNAL (arg))\n \t      && ! DECL_THREAD_LOCAL_P (arg)\n-\t      && ! DECL_NON_ADDR_CONST_P (arg)\n+\t      && ! DECL_DLLIMPORT_P (arg)\n \t      ? arg : NULL);\n \n     case CONST_DECL:\n@@ -3478,31 +3478,66 @@ tree\n merge_dllimport_decl_attributes (tree old, tree new)\n {\n   tree a;\n-  int delete_dllimport_p;\n-\n-  old = DECL_ATTRIBUTES (old);\n-  new = DECL_ATTRIBUTES (new);\n+  int delete_dllimport_p = 1;\n \n   /* What we need to do here is remove from `old' dllimport if it doesn't\n      appear in `new'.  dllimport behaves like extern: if a declaration is\n      marked dllimport and a definition appears later, then the object\n-     is not dllimport'd.  */\n-  if (lookup_attribute (\"dllimport\", old) != NULL_TREE\n-      && lookup_attribute (\"dllimport\", new) == NULL_TREE)\n-    delete_dllimport_p = 1;\n+     is not dllimport'd.  We also remove a `new' dllimport if the old list\n+     contains dllexport:  dllexport always overrides dllimport, regardless\n+     of the order of declaration.  */     \n+  if (!VAR_OR_FUNCTION_DECL_P (new))\n+    delete_dllimport_p = 0;\n+  else if (DECL_DLLIMPORT_P (new)\n+     \t   && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (old)))\n+    { \n+      DECL_DLLIMPORT_P (new) = 0;\n+      warning (OPT_Wattributes, \"%q+D already declared with dllexport attribute: \"\n+\t      \"dllimport ignored\", new);\n+    }\n+  else if (DECL_DLLIMPORT_P (old) && !DECL_DLLIMPORT_P (new))\n+    {\n+      /* Warn about overriding a symbol that has already been used. eg:\n+           extern int __attribute__ ((dllimport)) foo;\n+\t   int* bar () {return &foo;}\n+\t   int foo;\n+      */\n+      if (TREE_USED (old))\n+\t{\n+\t  warning (0, \"%q+D redeclared without dllimport attribute \"\n+\t\t   \"after being referenced with dll linkage\", new);\n+\t  /* If we have used a variable's address with dllimport linkage,\n+\t      keep the old DECL_DLLIMPORT_P flag: the ADDR_EXPR using the\n+\t      decl may already have had TREE_INVARIANT and TREE_CONSTANT\n+\t      computed.\n+\t      We still remove the attribute so that assembler code refers\n+\t      to '&foo rather than '_imp__foo'.  */\n+\t  if (TREE_CODE (old) == VAR_DECL && TREE_ADDRESSABLE (old))\n+\t    DECL_DLLIMPORT_P (new) = 1;\n+\t}\n+\n+      /* Let an inline definition silently override the external reference,\n+\t but otherwise warn about attribute inconsistency.  */ \n+      else if (TREE_CODE (new) == VAR_DECL\n+\t       || !DECL_DECLARED_INLINE_P (new))\n+\twarning (OPT_Wattributes, \"%q+D redeclared without dllimport attribute: \"\n+\t\t  \"previous dllimport ignored\", new);\n+    }\n   else\n     delete_dllimport_p = 0;\n \n-  a = merge_attributes (old, new);\n+  a = merge_attributes (DECL_ATTRIBUTES (old), DECL_ATTRIBUTES (new));\n \n-  if (delete_dllimport_p)\n+  if (delete_dllimport_p) \n     {\n       tree prev, t;\n-\n+      const size_t attr_len = strlen (\"dllimport\"); \n+     \n       /* Scan the list for dllimport and delete it.  */\n       for (prev = NULL_TREE, t = a; t; prev = t, t = TREE_CHAIN (t))\n \t{\n-\t  if (is_attribute_p (\"dllimport\", TREE_PURPOSE (t)))\n+\t  if (is_attribute_with_length_p (\"dllimport\", attr_len,\n+\t\t\t\t\t  TREE_PURPOSE (t)))\n \t    {\n \t      if (prev == NULL_TREE)\n \t\ta = TREE_CHAIN (a);\n@@ -3549,18 +3584,26 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n      any damage.  */\n   if (is_attribute_p (\"dllimport\", name))\n     {\n+      /* Honor any target-specific overides. */ \n+      if (!targetm.valid_dllimport_attribute_p (node))\n+\t*no_add_attrs = true;\n+\n+     else if (TREE_CODE (node) == FUNCTION_DECL\n+\t        && DECL_DECLARED_INLINE_P (node))\n+\t{\n+\t  warning (OPT_Wattributes, \"inline function %q+D declared as \"\n+\t\t  \" dllimport: attribute ignored\", node); \n+\t  *no_add_attrs = true;\n+\t}\n       /* Like MS, treat definition of dllimported variables and\n-\t non-inlined functions on declaration as syntax errors.  We\n-\t allow the attribute for function definitions if declared\n-\t inline.  */\n-      if (TREE_CODE (node) == FUNCTION_DECL  && DECL_INITIAL (node)\n-          && !DECL_DECLARED_INLINE_P (node))\n+\t non-inlined functions on declaration as syntax errors. */\n+     else if (TREE_CODE (node) == FUNCTION_DECL && DECL_INITIAL (node))\n \t{\n \t  error (\"function %q+D definition is marked dllimport\", node);\n \t  *no_add_attrs = true;\n \t}\n \n-      else if (TREE_CODE (node) == VAR_DECL)\n+     else if (TREE_CODE (node) == VAR_DECL)\n \t{\n \t  if (DECL_INITIAL (node))\n \t    {\n@@ -3577,6 +3620,9 @@ handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n \t  if (current_function_decl != NULL_TREE && !TREE_STATIC (node))\n \t    TREE_PUBLIC (node) = 1;\n \t}\n+\n+      if (*no_add_attrs == false)\n+        DECL_DLLIMPORT_P (node) = 1;\n     }\n \n   /*  Report error if symbol is not accessible at global scope.  */"}, {"sha": "144dbd87061be2c0ae55c3b005a140c7a5d4708a", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -2421,9 +2421,8 @@ struct tree_parm_decl GTY(())\n #define DECL_GIMPLE_FORMAL_TEMP_P(DECL) \\\n   DECL_WITH_VIS_CHECK (DECL)->decl_with_vis.gimple_formal_temp\n \n-/* Used to indicate that the pointer to this DECL cannot be treated as\n-   an address constant.  */\n-#define DECL_NON_ADDR_CONST_P(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.non_addr_const_p)\n+/* Used to indicate that the DECL is a dllimport.  */\n+#define DECL_DLLIMPORT_P(NODE) (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.dllimport_flag)\n \n /* DECL_BASED_ON_RESTRICT_P records whether a VAR_DECL is a temporary\n    based on a variable with a restrict qualified type.  If it is,\n@@ -2514,7 +2513,7 @@ struct tree_decl_with_vis GTY(())\n  unsigned common_flag:1; \n  unsigned in_text_section : 1;\n  unsigned gimple_formal_temp : 1;\n- unsigned non_addr_const_p : 1;\n+ unsigned dllimport_flag : 1; \n  unsigned based_on_restrict_p : 1;\n  /* Used by C++.  Might become a generic decl flag.  */\n  unsigned shadowed_for_var_p : 1;"}, {"sha": "1aee9839e2d3cbe0a55cdbfbc2ac5be8e62f2b0a", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=43d9ad1dbd24f0dbb1ee8fbb8978acc1019a67f8", "patch": "@@ -3643,7 +3643,7 @@ initializer_constant_valid_p (tree value, tree endtype)\n       if (value\n \t  && TREE_CODE (value) == FUNCTION_DECL\n \t  && ((decl_function_context (value) && !DECL_NO_STATIC_CHAIN (value))\n-\t      || DECL_NON_ADDR_CONST_P (value)))\n+\t      || DECL_DLLIMPORT_P (value)))\n \treturn NULL_TREE;\n       return value;\n "}]}