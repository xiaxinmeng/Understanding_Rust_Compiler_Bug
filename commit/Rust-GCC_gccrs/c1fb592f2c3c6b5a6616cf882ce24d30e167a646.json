{"sha": "c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFmYjU5MmYyYzNjNmI1YTY2MTZjZjg4MmNlMjRkMzBlMTY3YTY0Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-22T18:16:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-22T18:16:34Z"}, "message": "widening_mul: pattern recognize further forms of __builtin_add_overflow [PR95853]\n\nThe following patch recognizes some further forms of additions with overflow\nchecks as shown in the testcase, in particular where the unsigned addition is\nperformed in a wider mode just to catch overflow with a > narrower_utype_max\ncheck.\n\n2020-11-22  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/95853\n\t* tree-ssa-math-opts.c (uaddsub_overflow_check_p): Add maxval\n\targument, if non-NULL, instead look for r > maxval or r <= maxval\n\tcomparisons.\n\t(match_uaddsub_overflow): Pattern recognize even other forms of\n\t__builtin_add_overflow, in particular when addition is performed\n\tin a wider type and result compared to maximum of the narrower\n\ttype.\n\n\t* gcc.dg/pr95853.c: New test.", "tree": {"sha": "7539e06c8f43bcec10850ed0c4dbe2d01819b8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7539e06c8f43bcec10850ed0c4dbe2d01819b8aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fb592f2c3c6b5a6616cf882ce24d30e167a646/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdd2fb172940c5fc60e1d8195b30f7ebc0e754d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdd2fb172940c5fc60e1d8195b30f7ebc0e754d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdd2fb172940c5fc60e1d8195b30f7ebc0e754d0"}], "stats": {"total": 321, "additions": 307, "deletions": 14}, "files": [{"sha": "fdd3c30c45699ec0b43e34a0e4c80d289857d74d", "filename": "gcc/testsuite/gcc.dg/pr95853.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1fb592f2c3c6b5a6616cf882ce24d30e167a646/gcc%2Ftestsuite%2Fgcc.dg%2Fpr95853.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1fb592f2c3c6b5a6616cf882ce24d30e167a646/gcc%2Ftestsuite%2Fgcc.dg%2Fpr95853.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr95853.c?ref=c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "patch": "@@ -0,0 +1,59 @@\n+/* PR tree-optimization/95853 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-widening_mul\" } */\n+\n+#if __SIZEOF_INT128__\n+typedef __uint128_t W;\n+typedef unsigned long long T;\n+#else\n+typedef unsigned long long W;\n+typedef unsigned int T;\n+#endif\n+\n+struct S { int p; T r; };\n+\n+struct S\n+foo (T x, T y)\n+{\n+  W z = (W) x + y;\n+  return (struct S) { z > ~(T) 0, (T) z };\n+}\n+\n+struct S\n+bar (T x)\n+{\n+  W z = (W) x + 132;\n+  return (struct S) { z > ~(T) 0, (T) z };\n+}\n+\n+struct S\n+baz (T x, unsigned short y)\n+{\n+  W z = (W) x + y;\n+  return (struct S) { z > ~(T) 0, (T) z };\n+}\n+\n+struct S\n+qux (unsigned short x, T y)\n+{\n+  W z = (W) x + y;\n+  return (struct S) { z > ~(T) 0, (T) z };\n+}\n+\n+struct S\n+corge (T x, T y)\n+{\n+  T w = x + y;\n+  W z = (W) x + y;\n+  return (struct S) { z > ~(T) 0, w };\n+}\n+\n+struct S\n+garple (T x, T y)\n+{\n+  W z = (W) x + y;\n+  T w = x + y;\n+  return (struct S) { z > ~(T) 0, w };\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ADD_OVERFLOW\" 6 \"widening_mul\" { target { i?86-*-* x86_64-*-* } } } } */"}, {"sha": "4ade0b61679b98789224a4536d914edeef8b4dec", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 248, "deletions": 14, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1fb592f2c3c6b5a6616cf882ce24d30e167a646/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1fb592f2c3c6b5a6616cf882ce24d30e167a646/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=c1fb592f2c3c6b5a6616cf882ce24d30e167a646", "patch": "@@ -3457,7 +3457,7 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n    and 0 otherwise.  */\n \n static int\n-uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt)\n+uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt, tree maxval)\n {\n   enum tree_code ccode = ERROR_MARK;\n   tree crhs1 = NULL_TREE, crhs2 = NULL_TREE;\n@@ -3505,6 +3505,15 @@ uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt)\n     {\n     case GT_EXPR:\n     case LE_EXPR:\n+      if (maxval)\n+\t{\n+\t  /* r = a + b; r > maxval or r <= maxval  */\n+\t  if (crhs1 == lhs\n+\t      && TREE_CODE (crhs2) == INTEGER_CST\n+\t      && tree_int_cst_equal (crhs2, maxval))\n+\t    return ccode == GT_EXPR ? 1 : -1;\n+\t  break;\n+\t}\n       /* r = a - b; r > a or r <= a\n \t r = a + b; a > r or a <= r or b > r or b <= r.  */\n       if ((code == MINUS_EXPR && crhs1 == lhs && crhs2 == rhs1)\n@@ -3514,6 +3523,8 @@ uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt)\n       break;\n     case LT_EXPR:\n     case GE_EXPR:\n+      if (maxval)\n+\tbreak;\n       /* r = a - b; a < r or a >= r\n \t r = a + b; r < a or r >= a or r < b or r >= b.  */\n       if ((code == MINUS_EXPR && crhs1 == rhs1 && crhs2 == lhs)\n@@ -3535,7 +3546,21 @@ uaddsub_overflow_check_p (gimple *stmt, gimple *use_stmt)\n    x = REALPART_EXPR <_7>;\n    _8 = IMAGPART_EXPR <_7>;\n    if (_8)\n-   and similarly for addition.  */\n+   and similarly for addition.\n+\n+   Also recognize:\n+   yc = (type) y;\n+   zc = (type) z;\n+   x = yc + zc;\n+   if (x > max)\n+   where y and z have unsigned types with maximum max\n+   and there are other uses of x and all of those cast x\n+   back to that unsigned type and again replace it with\n+   _7 = ADD_OVERFLOW (y, z);\n+   _9 = REALPART_EXPR <_7>;\n+   _8 = IMAGPART_EXPR <_8>;\n+   if (_8)\n+   and replace (utype) x with _9.  */\n \n static bool\n match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n@@ -3548,14 +3573,16 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n   bool use_seen = false;\n   bool ovf_use_seen = false;\n   gimple *use_stmt;\n+  gimple *add_stmt = NULL;\n+  bool add_first = false;\n \n   gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR);\n   if (!INTEGRAL_TYPE_P (type)\n       || !TYPE_UNSIGNED (type)\n       || has_zero_uses (lhs)\n-      || has_single_use (lhs)\n-      || optab_handler (code == PLUS_EXPR ? uaddv4_optab : usubv4_optab,\n-\t\t\tTYPE_MODE (type)) == CODE_FOR_nothing)\n+      || (code == MINUS_EXPR\n+\t  && optab_handler (usubv4_optab,\n+\t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing))\n     return false;\n \n   FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n@@ -3564,29 +3591,213 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      if (uaddsub_overflow_check_p (stmt, use_stmt))\n+      if (uaddsub_overflow_check_p (stmt, use_stmt, NULL_TREE))\n \tovf_use_seen = true;\n       else\n \tuse_seen = true;\n       if (ovf_use_seen && use_seen)\n \tbreak;\n     }\n \n-  if (!ovf_use_seen || !use_seen)\n-    return false;\n-\n-  tree ctype = build_complex_type (type);\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n   tree rhs2 = gimple_assign_rhs2 (stmt);\n+  tree maxval = NULL_TREE;\n+  if (!ovf_use_seen\n+      || !use_seen\n+      || (code == PLUS_EXPR\n+\t  && optab_handler (uaddv4_optab,\n+\t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing))\n+    {\n+      if (code != PLUS_EXPR)\n+\treturn false;\n+      if (TREE_CODE (rhs1) != SSA_NAME\n+\t  || !gimple_assign_cast_p (SSA_NAME_DEF_STMT (rhs1)))\n+\treturn false;\n+      rhs1 = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (rhs1));\n+      tree type1 = TREE_TYPE (rhs1);\n+      if (!INTEGRAL_TYPE_P (type1)\n+\t  || !TYPE_UNSIGNED (type1)\n+\t  || TYPE_PRECISION (type1) >= TYPE_PRECISION (type)\n+\t  || (TYPE_PRECISION (type1)\n+\t      != GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (type1))))\n+\treturn false;\n+      if (TREE_CODE (rhs2) == INTEGER_CST)\n+\t{\n+\t  if (wi::ne_p (wi::rshift (wi::to_wide (rhs2),\n+\t  \t\t\t    TYPE_PRECISION (type1),\n+\t\t\t\t    UNSIGNED), 0))\n+\t    return false;\n+\t  rhs2 = fold_convert (type1, rhs2);\n+\t}\n+      else\n+\t{\n+\t  if (TREE_CODE (rhs2) != SSA_NAME\n+\t      || !gimple_assign_cast_p (SSA_NAME_DEF_STMT (rhs2)))\n+\t    return false;\n+\t  rhs2 = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (rhs2));\n+\t  tree type2 = TREE_TYPE (rhs2);\n+\t  if (!INTEGRAL_TYPE_P (type2)\n+\t      || !TYPE_UNSIGNED (type2)\n+\t      || TYPE_PRECISION (type2) >= TYPE_PRECISION (type)\n+\t      || (TYPE_PRECISION (type2)\n+\t\t  != GET_MODE_BITSIZE (SCALAR_INT_TYPE_MODE (type2))))\n+\t    return false;\n+\t}\n+      if (TYPE_PRECISION (type1) >= TYPE_PRECISION (TREE_TYPE (rhs2)))\n+\ttype = type1;\n+      else\n+\ttype = TREE_TYPE (rhs2);\n+\n+      if (TREE_CODE (type) != INTEGER_TYPE\n+\t  || optab_handler (uaddv4_optab,\n+\t\t\t    TYPE_MODE (type)) == CODE_FOR_nothing)\n+\treturn false;\n+\n+      maxval = wide_int_to_tree (type, wi::max_value (TYPE_PRECISION (type),\n+\t\t\t\t\t\t      UNSIGNED));\n+      ovf_use_seen = false;\n+      use_seen = false;\n+      basic_block use_bb = NULL;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n+\t{\n+\t  use_stmt = USE_STMT (use_p);\n+\t  if (is_gimple_debug (use_stmt))\n+\t    continue;\n+\n+\t  if (uaddsub_overflow_check_p (stmt, use_stmt, maxval))\n+\t    {\n+\t      ovf_use_seen = true;\n+\t      use_bb = gimple_bb (use_stmt);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!gimple_assign_cast_p (use_stmt)\n+\t\t  || gimple_assign_rhs_code (use_stmt) == VIEW_CONVERT_EXPR)\n+\t\treturn false;\n+\t      tree use_lhs = gimple_assign_lhs (use_stmt);\n+\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (use_lhs))\n+\t\t  || (TYPE_PRECISION (TREE_TYPE (use_lhs))\n+\t\t      > TYPE_PRECISION (type)))\n+\t\treturn false;\n+\t      use_seen = true;\n+\t    }\n+\t}\n+      if (!ovf_use_seen)\n+\treturn false;\n+      if (!useless_type_conversion_p (type, TREE_TYPE (rhs1)))\n+\t{\n+\t  if (!use_seen)\n+\t    return false;\n+\t  tree new_rhs1 = make_ssa_name (type);\n+\t  gimple *g = gimple_build_assign (new_rhs1, NOP_EXPR, rhs1);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  rhs1 = new_rhs1;\n+\t}\n+      else if (!useless_type_conversion_p (type, TREE_TYPE (rhs2)))\n+\t{\n+\t  if (!use_seen)\n+\t    return false;\n+\t  tree new_rhs2 = make_ssa_name (type);\n+\t  gimple *g = gimple_build_assign (new_rhs2, NOP_EXPR, rhs2);\n+\t  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\t  rhs2 = new_rhs2;\n+\t}\n+      else if (!use_seen)\n+\t{\n+\t  /* If there are no uses of the wider addition, check if\n+\t     forwprop has not created a narrower addition.\n+\t     Require it to be in the same bb as the overflow check.  */\n+\t  FOR_EACH_IMM_USE_FAST (use_p, iter, rhs1)\n+\t    {\n+\t      use_stmt = USE_STMT (use_p);\n+\t      if (is_gimple_debug (use_stmt))\n+\t\tcontinue;\n+\n+\t      if (use_stmt == stmt)\n+\t\tcontinue;\n+\n+\t      if (!is_gimple_assign (use_stmt)\n+\t\t  || gimple_bb (use_stmt) != use_bb\n+\t\t  || gimple_assign_rhs_code (use_stmt) != PLUS_EXPR)\n+\t\tcontinue;\n+\n+\t      if (gimple_assign_rhs1 (use_stmt) == rhs1)\n+\t\t{\n+\t\t  if (!operand_equal_p (gimple_assign_rhs2 (use_stmt),\n+\t\t\t\t\trhs2, 0))\n+\t\t    continue;\n+\t\t}\n+\t      else if (gimple_assign_rhs2 (use_stmt) == rhs1)\n+\t\t{\n+\t\t  if (gimple_assign_rhs1 (use_stmt) != rhs2)\n+\t\t    continue;\n+\t\t}\n+\t      else\n+\t\tcontinue;\n+\n+\t      add_stmt = use_stmt;\n+\t      break;\n+\t    }\n+\t  if (add_stmt == NULL)\n+\t    return false;\n+\n+\t  /* If stmt and add_stmt are in the same bb, we need to find out\n+\t     which one is earlier.  If they are in different bbs, we've\n+\t     checked add_stmt is in the same bb as one of the uses of the\n+\t     stmt lhs, so stmt needs to dominate add_stmt too.  */\n+\t  if (gimple_bb (stmt) == gimple_bb (add_stmt))\n+\t    {\n+\t      gimple_stmt_iterator gsif = *gsi;\n+\t      gimple_stmt_iterator gsib = *gsi;\n+\t      int i;\n+\t      /* Search both forward and backward from stmt and have a small\n+\t\t upper bound.  */\n+\t      for (i = 0; i < 128; i++)\n+\t\t{\n+\t\t  if (!gsi_end_p (gsib))\n+\t\t    {\n+\t\t      gsi_prev_nondebug (&gsib);\n+\t\t      if (gsi_stmt (gsib) == add_stmt)\n+\t\t\t{\n+\t\t\t  add_first = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (gsi_end_p (gsif))\n+\t\t    break;\n+\t\t  if (!gsi_end_p (gsif))\n+\t\t    {\n+\t\t      gsi_next_nondebug (&gsif);\n+\t\t      if (gsi_stmt (gsif) == add_stmt)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t      if (i == 128)\n+\t\treturn false;\n+\t      if (add_first)\n+\t\t*gsi = gsi_for_stmt (add_stmt);\n+\t    }\n+\t}\n+    }\n+\n+  tree ctype = build_complex_type (type);\n   gcall *g = gimple_build_call_internal (code == PLUS_EXPR\n \t\t\t\t\t ? IFN_ADD_OVERFLOW : IFN_SUB_OVERFLOW,\n \t\t\t\t\t 2, rhs1, rhs2);\n   tree ctmp = make_ssa_name (ctype);\n   gimple_call_set_lhs (g, ctmp);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n-  gassign *g2 = gimple_build_assign (lhs, REALPART_EXPR,\n+  tree new_lhs = maxval ? make_ssa_name (type) : lhs;\n+  gassign *g2 = gimple_build_assign (new_lhs, REALPART_EXPR,\n \t\t\t\t     build1 (REALPART_EXPR, type, ctmp));\n-  gsi_replace (gsi, g2, true);\n+  if (maxval)\n+    {\n+      gsi_insert_before (gsi, g2, GSI_SAME_STMT);\n+      if (add_first)\n+\t*gsi = gsi_for_stmt (stmt);\n+    }\n+  else\n+    gsi_replace (gsi, g2, true);\n   tree ovf = make_ssa_name (type);\n   g2 = gimple_build_assign (ovf, IMAGPART_EXPR,\n \t\t\t    build1 (IMAGPART_EXPR, type, ctmp));\n@@ -3597,9 +3808,20 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      int ovf_use = uaddsub_overflow_check_p (stmt, use_stmt);\n+      int ovf_use = uaddsub_overflow_check_p (stmt, use_stmt, maxval);\n       if (ovf_use == 0)\n-\tcontinue;\n+\t{\n+\t  if (maxval)\n+\t    {\n+\t      tree use_lhs = gimple_assign_lhs (use_stmt);\n+\t      gimple_assign_set_rhs1 (use_stmt, new_lhs);\n+\t      if (useless_type_conversion_p (TREE_TYPE (use_lhs),\n+\t\t\t\t\t     TREE_TYPE (new_lhs)))\n+\t\tgimple_assign_set_rhs_code (use_stmt, SSA_NAME);\n+\t      update_stmt (use_stmt);\n+\t    }\n+\t  continue;\n+\t}\n       if (gimple_code (use_stmt) == GIMPLE_COND)\n \t{\n \t  gcond *cond_stmt = as_a <gcond *> (use_stmt);\n@@ -3629,6 +3851,18 @@ match_uaddsub_overflow (gimple_stmt_iterator *gsi, gimple *stmt,\n \t}\n       update_stmt (use_stmt);\n     }\n+  if (maxval)\n+    {\n+      gimple_stmt_iterator gsi2 = gsi_for_stmt (stmt);\n+      gsi_remove (&gsi2, true);\n+      if (add_stmt)\n+\t{\n+\t  gimple *g = gimple_build_assign (gimple_assign_lhs (add_stmt),\n+\t\t\t\t\t   new_lhs);\n+\t  gsi2 = gsi_for_stmt (add_stmt);\n+\t  gsi_replace (&gsi2, g, true);\n+\t}\n+    }\n   return true;\n }\n "}]}