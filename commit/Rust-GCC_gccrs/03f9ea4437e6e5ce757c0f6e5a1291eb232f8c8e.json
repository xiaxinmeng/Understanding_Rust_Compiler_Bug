{"sha": "03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNmOWVhNDQzN2U2ZTVjZTc1N2MwZjZlNWExMjkxZWIyMzJmOGM4ZQ==", "commit": {"author": {"name": "Dhruv Matani", "email": "dhruvbird@gmx.net", "date": "2004-03-25T17:12:16Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-03-25T17:12:16Z"}, "message": "stl_list.h: Created a _List_impl class and made it derive from the allocator...\n\n\n2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* include/bits/stl_list.h: Created a _List_impl class and made it\n\tderive from the allocator, instead of the list deriving from the\n\tallocator class, which was not conformant. Changed all references\n\tfrom this->_M_node to this->_M_impl._M_node * bits/list.tcc: Same\n\tas above (changed all references to the concerned variables).\n\n2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* include/bits/stl_deque.h: Created a _Deque_impl class and made\n\tit derive from the allocator, instead of the deque deriving from\n\tthe allocator class, which was not conformant. Changed all\n\treferences to the _M_start, _M_finish, _M_map, and _M_map_size to\n\t_M_impl.*.\n\t(_Deque_base<_Tp,_Alloc>::~_Deque_base()): Added this->\n\tqualification in 2 places where it was missing.\n\t(_Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t)): Same as\n\tabove.\n\t* include/bits/deque.tcc: Same as above (changed all references to\n\tthe concerned variables).\n\n2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* include/bits/stl_vector.h: Created a _Vector_impl class and made\n\tit derive from the allocator, instead of the _Vector_base class,\n\tderiving from the allocator which was not conformant. Changed all\n\treferences to the _M_start, _M_finish, and _M_end_of_storage to\n\t_M_impl.*.\n\t* include/bits/vector.tcc: Same as above (changed all references\n\tto the concerned variables).\n\n2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* testsuite/23_containers/deque/cons/clear_allocator.cc: New.\n\t* testsuite/23_containers/list/cons/clear_allocator.cc: New.\n\t* testsuite/23_containers/vector/cons/clear_allocator.cc: New.\n\nFrom-SVN: r79957", "tree": {"sha": "4e905f4034e27bf84968849536241d115590f92d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e905f4034e27bf84968849536241d115590f92d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/comments", "author": null, "committer": null, "parents": [{"sha": "666c27b9fad383fe8d0a15006fb77f31ad16d854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666c27b9fad383fe8d0a15006fb77f31ad16d854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/666c27b9fad383fe8d0a15006fb77f31ad16d854"}], "stats": {"total": 1069, "additions": 697, "deletions": 372}, "files": [{"sha": "162c8473a59e22c7b7c668b5f6e5ca4cea598449", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -1,11 +1,50 @@\n+2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n+\n+\t* include/bits/stl_list.h: Created a _List_impl class and made it\n+\tderive from the allocator, instead of the list deriving from the\n+\tallocator class, which was not conformant. Changed all references\n+\tfrom this->_M_node to this->_M_impl._M_node * bits/list.tcc: Same\n+\tas above (changed all references to the concerned variables).\n+\n+2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n+\n+\t* include/bits/stl_deque.h: Created a _Deque_impl class and made\n+\tit derive from the allocator, instead of the deque deriving from\n+\tthe allocator class, which was not conformant. Changed all\n+\treferences to the _M_start, _M_finish, _M_map, and _M_map_size to\n+\t_M_impl.*.\n+\t(_Deque_base<_Tp,_Alloc>::~_Deque_base()): Added this->\n+\tqualification in 2 places where it was missing.\n+\t(_Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t)): Same as\n+\tabove.\n+\t* include/bits/deque.tcc: Same as above (changed all references to\n+\tthe concerned variables).\n+\n+2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n+\n+\t* include/bits/stl_vector.h: Created a _Vector_impl class and made\n+\tit derive from the allocator, instead of the _Vector_base class,\n+\tderiving from the allocator which was not conformant. Changed all\n+\treferences to the _M_start, _M_finish, and _M_end_of_storage to\n+\t_M_impl.*.\n+\t* include/bits/vector.tcc: Same as above (changed all references\n+\tto the concerned variables).\n+\n+2004-03-25  Dhruv Matani  <dhruvbird@gmx.net>\n+\n+\t* testsuite/23_containers/deque/cons/clear_allocator.cc: New.\n+\t* testsuite/23_containers/list/cons/clear_allocator.cc: New.\n+\t* testsuite/23_containers/vector/cons/clear_allocator.cc: New.\n+\t\n 2004-03-24  Dhruv Matani  <dhruvbird@gmx.net>\n \n-\t* ext/malloc_allocator.h: Fixed the construct function to call\n-\tglobal placement new instead of assignment. Added a check after\n-\tthe return from malloc to check whether returned pointer is NULL,\n-\tand if so, throw std::bad_alloc().\n-\t* ext/debug_allocator.h: Added a check in the deallocate function\n-\tto check whether the user has passed a NULL pointer or not.\n+\t* include/ext/malloc_allocator.h: Fixed the construct function to\n+\tcall global placement new instead of assignment. Added a check\n+\tafter the return from malloc to check whether returned pointer is\n+\tNULL, and if so, throw std::bad_alloc().\n+\t* include/ext/debug_allocator.h: Added a check in the deallocate\n+\tfunction to check whether the user has passed a NULL pointer or\n+\tnot.\n \t\n 2004-03-24  Benjamin Kosnik  <bkoz@redhat.com>\n "}, {"sha": "22fc573d9c0577070b440b482c9d51234a415070", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -72,13 +72,13 @@ namespace __gnu_norm\n       if (&__x != this)\n \t{\n \t  if (__len >= __x.size())\n-\t    erase(std::copy(__x.begin(), __x.end(), this->_M_start),\n-\t\t  this->_M_finish);\n+\t    erase(std::copy(__x.begin(), __x.end(), this->_M_impl._M_start),\n+\t\t  this->_M_impl._M_finish);\n \t  else\n \t    {\n \t      const_iterator __mid = __x.begin() + difference_type(__len);\n-\t      std::copy(__x.begin(), __mid, this->_M_start);\n-\t      insert(this->_M_finish, __mid, __x.end());\n+\t      std::copy(__x.begin(), __mid, this->_M_impl._M_start);\n+\t      insert(this->_M_impl._M_finish, __mid, __x.end());\n \t    }\n \t}\n       return *this;\n@@ -89,15 +89,15 @@ namespace __gnu_norm\n     deque<_Tp,_Alloc>::\n     insert(iterator position, const value_type& __x)\n     {\n-      if (position._M_cur == this->_M_start._M_cur)\n+      if (position._M_cur == this->_M_impl._M_start._M_cur)\n \t{\n \t  push_front(__x);\n-\t  return this->_M_start;\n+\t  return this->_M_impl._M_start;\n \t}\n-      else if (position._M_cur == this->_M_finish._M_cur)\n+      else if (position._M_cur == this->_M_impl._M_finish._M_cur)\n \t{\n \t  push_back(__x);\n-\t  iterator __tmp = this->_M_finish;\n+\t  iterator __tmp = this->_M_impl._M_finish;\n \t  --__tmp;\n \t  return __tmp;\n \t}\n@@ -112,52 +112,52 @@ namespace __gnu_norm\n     {\n       iterator __next = __position;\n       ++__next;\n-      size_type __index = __position - this->_M_start;\n+      size_type __index = __position - this->_M_impl._M_start;\n       if (__index < (size() >> 1))\n \t{\n-\t  std::copy_backward(this->_M_start, __position, __next);\n+\t  std::copy_backward(this->_M_impl._M_start, __position, __next);\n \t  pop_front();\n \t}\n       else\n \t{\n-\t  std::copy(__next, this->_M_finish, __position);\n+\t  std::copy(__next, this->_M_impl._M_finish, __position);\n \t  pop_back();\n \t}\n-      return this->_M_start + __index;\n+      return this->_M_impl._M_start + __index;\n     }\n \n   template <typename _Tp, typename _Alloc>\n     typename deque<_Tp,_Alloc>::iterator\n     deque<_Tp,_Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n-      if (__first == this->_M_start && __last == this->_M_finish)\n+      if (__first == this->_M_impl._M_start && __last == this->_M_impl._M_finish)\n \t{\n \t  clear();\n-\t  return this->_M_finish;\n+\t  return this->_M_impl._M_finish;\n \t}\n       else\n \t{\n \t  const difference_type __n = __last - __first;\n-\t  const difference_type __elems_before = __first - this->_M_start;\n+\t  const difference_type __elems_before = __first - this->_M_impl._M_start;\n \t  if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n \t    {\n-\t      std::copy_backward(this->_M_start, __first, __last);\n-\t      iterator __new_start = this->_M_start + __n;\n-\t      std::_Destroy(this->_M_start, __new_start);\n-\t      _M_destroy_nodes(this->_M_start._M_node, __new_start._M_node);\n-\t      this->_M_start = __new_start;\n+\t      std::copy_backward(this->_M_impl._M_start, __first, __last);\n+\t      iterator __new_start = this->_M_impl._M_start + __n;\n+\t      std::_Destroy(this->_M_impl._M_start, __new_start);\n+\t      _M_destroy_nodes(this->_M_impl._M_start._M_node, __new_start._M_node);\n+\t      this->_M_impl._M_start = __new_start;\n \t    }\n \t  else\n \t    {\n-\t      std::copy(__last, this->_M_finish, __first);\n-\t      iterator __new_finish = this->_M_finish - __n;\n-\t      std::_Destroy(__new_finish, this->_M_finish);\n+\t      std::copy(__last, this->_M_impl._M_finish, __first);\n+\t      iterator __new_finish = this->_M_impl._M_finish - __n;\n+\t      std::_Destroy(__new_finish, this->_M_impl._M_finish);\n \t      _M_destroy_nodes(__new_finish._M_node + 1,\n-\t\t\t       this->_M_finish._M_node + 1);\n-\t      this->_M_finish = __new_finish;\n+\t\t\t       this->_M_impl._M_finish._M_node + 1);\n+\t      this->_M_impl._M_finish = __new_finish;\n \t    }\n-\t  return this->_M_start + __elems_before;\n+\t  return this->_M_impl._M_start + __elems_before;\n \t}\n     }\n \n@@ -166,24 +166,24 @@ namespace __gnu_norm\n     deque<_Tp,_Alloc>::\n     clear()\n     {\n-      for (_Map_pointer __node = this->_M_start._M_node + 1;\n-           __node < this->_M_finish._M_node;\n+      for (_Map_pointer __node = this->_M_impl._M_start._M_node + 1;\n+           __node < this->_M_impl._M_finish._M_node;\n            ++__node)\n \t{\n \t  std::_Destroy(*__node, *__node + _S_buffer_size());\n \t  _M_deallocate_node(*__node);\n \t}\n \n-      if (this->_M_start._M_node != this->_M_finish._M_node)\n+      if (this->_M_impl._M_start._M_node != this->_M_impl._M_finish._M_node)\n \t{\n-\t  std::_Destroy(this->_M_start._M_cur, this->_M_start._M_last);\n-\t  std::_Destroy(this->_M_finish._M_first, this->_M_finish._M_cur);\n-\t  _M_deallocate_node(this->_M_finish._M_first);\n+\t  std::_Destroy(this->_M_impl._M_start._M_cur, this->_M_impl._M_start._M_last);\n+\t  std::_Destroy(this->_M_impl._M_finish._M_first, this->_M_impl._M_finish._M_cur);\n+\t  _M_deallocate_node(this->_M_impl._M_finish._M_first);\n \t}\n       else\n-        std::_Destroy(this->_M_start._M_cur, this->_M_finish._M_cur);\n+        std::_Destroy(this->_M_impl._M_start._M_cur, this->_M_impl._M_finish._M_cur);\n \n-      this->_M_finish = this->_M_start;\n+      this->_M_impl._M_finish = this->_M_impl._M_start;\n     }\n \n   template <typename _Tp, class _Alloc>\n@@ -207,31 +207,31 @@ namespace __gnu_norm\n     deque<_Tp,_Alloc>::\n     _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n     {\n-      if (__pos._M_cur == this->_M_start._M_cur)\n+      if (__pos._M_cur == this->_M_impl._M_start._M_cur)\n \t{\n \t  iterator __new_start = _M_reserve_elements_at_front(__n);\n \t  try\n \t    {\n-\t      std::uninitialized_fill(__new_start, this->_M_start, __x);\n-\t      this->_M_start = __new_start;\n+\t      std::uninitialized_fill(__new_start, this->_M_impl._M_start, __x);\n+\t      this->_M_impl._M_start = __new_start;\n \t    }\n \t  catch(...)\n \t    {\n-\t      _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t      _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);\n \t      __throw_exception_again;\n \t    }\n \t}\n-      else if (__pos._M_cur == this->_M_finish._M_cur)\n+      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)\n \t{\n \t  iterator __new_finish = _M_reserve_elements_at_back(__n);\n \t  try\n \t    {\n-\t      std::uninitialized_fill(this->_M_finish, __new_finish, __x);\n-\t      this->_M_finish = __new_finish;\n+\t      std::uninitialized_fill(this->_M_impl._M_finish, __new_finish, __x);\n+\t      this->_M_impl._M_finish = __new_finish;\n \t    }\n \t  catch(...)\n \t    {\n-\t      _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,\n \t\t\t       __new_finish._M_node + 1);\n \t      __throw_exception_again;\n \t    }\n@@ -248,17 +248,17 @@ namespace __gnu_norm\n       _Map_pointer __cur;\n       try\n         {\n-          for (__cur = this->_M_start._M_node;\n-\t       __cur < this->_M_finish._M_node;\n+          for (__cur = this->_M_impl._M_start._M_node;\n+\t       __cur < this->_M_impl._M_finish._M_node;\n \t       ++__cur)\n             std::uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n-          std::uninitialized_fill(this->_M_finish._M_first,\n-\t\t\t\t  this->_M_finish._M_cur,\n+          std::uninitialized_fill(this->_M_impl._M_finish._M_first,\n+\t\t\t\t  this->_M_impl._M_finish._M_cur,\n \t\t\t\t  __value);\n         }\n       catch(...)\n         {\n-          std::_Destroy(this->_M_start, iterator(*__cur, __cur));\n+          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur));\n           __throw_exception_again;\n         }\n     }\n@@ -296,92 +296,92 @@ namespace __gnu_norm\n         _Map_pointer __cur_node;\n         try\n           {\n-            for (__cur_node = this->_M_start._M_node;\n-                 __cur_node < this->_M_finish._M_node;\n+            for (__cur_node = this->_M_impl._M_start._M_node;\n+                 __cur_node < this->_M_impl._M_finish._M_node;\n                  ++__cur_node)\n             {\n               _ForwardIterator __mid = __first;\n               std::advance(__mid, _S_buffer_size());\n               std::uninitialized_copy(__first, __mid, *__cur_node);\n               __first = __mid;\n             }\n-            std::uninitialized_copy(__first, __last, this->_M_finish._M_first);\n+            std::uninitialized_copy(__first, __last, this->_M_impl._M_finish._M_first);\n           }\n         catch(...)\n           {\n-            std::_Destroy(this->_M_start, iterator(*__cur_node, __cur_node));\n+            std::_Destroy(this->_M_impl._M_start, iterator(*__cur_node, __cur_node));\n             __throw_exception_again;\n           }\n       }\n \n-  // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n+  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n     _M_push_back_aux(const value_type& __t)\n     {\n       value_type __t_copy = __t;\n       _M_reserve_map_at_back();\n-      *(this->_M_finish._M_node + 1) = this->_M_allocate_node();\n+      *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();\n       try\n         {\n-          std::_Construct(this->_M_finish._M_cur, __t_copy);\n-          this->_M_finish._M_set_node(this->_M_finish._M_node + 1);\n-          this->_M_finish._M_cur = this->_M_finish._M_first;\n+          std::_Construct(this->_M_impl._M_finish._M_cur, __t_copy);\n+          this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node + 1);\n+          this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;\n         }\n       catch(...)\n         {\n-          _M_deallocate_node(*(this->_M_finish._M_node + 1));\n+          _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));\n           __throw_exception_again;\n         }\n     }\n \n-  // Called only if _M_start._M_cur == _M_start._M_first.\n+  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_first.\n   template <typename _Tp, typename _Alloc>\n     void\n     deque<_Tp,_Alloc>::\n     _M_push_front_aux(const value_type& __t)\n     {\n       value_type __t_copy = __t;\n       _M_reserve_map_at_front();\n-      *(this->_M_start._M_node - 1) = this->_M_allocate_node();\n+      *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();\n       try\n         {\n-          this->_M_start._M_set_node(this->_M_start._M_node - 1);\n-          this->_M_start._M_cur = this->_M_start._M_last - 1;\n-          std::_Construct(this->_M_start._M_cur, __t_copy);\n+          this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node - 1);\n+          this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;\n+          std::_Construct(this->_M_impl._M_start._M_cur, __t_copy);\n         }\n       catch(...)\n         {\n-          ++this->_M_start;\n-          _M_deallocate_node(*(this->_M_start._M_node - 1));\n+          ++this->_M_impl._M_start;\n+          _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));\n           __throw_exception_again;\n         }\n     }\n \n-  // Called only if _M_finish._M_cur == _M_finish._M_first.\n+  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_first.\n   template <typename _Tp, typename _Alloc>\n     void deque<_Tp,_Alloc>::\n     _M_pop_back_aux()\n     {\n-      _M_deallocate_node(this->_M_finish._M_first);\n-      this->_M_finish._M_set_node(this->_M_finish._M_node - 1);\n-      this->_M_finish._M_cur = this->_M_finish._M_last - 1;\n-      std::_Destroy(this->_M_finish._M_cur);\n+      _M_deallocate_node(this->_M_impl._M_finish._M_first);\n+      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);\n+      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;\n+      std::_Destroy(this->_M_impl._M_finish._M_cur);\n     }\n \n-  // Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that\n+  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.  Note that\n   // if the deque has at least one element (a precondition for this member\n-  // function), and if _M_start._M_cur == _M_start._M_last, then the deque\n+  // function), and if _M_impl._M_start._M_cur == _M_impl._M_start._M_last, then the deque\n   // must have at least two nodes.\n   template <typename _Tp, typename _Alloc>\n     void deque<_Tp,_Alloc>::\n     _M_pop_front_aux()\n     {\n-      std::_Destroy(this->_M_start._M_cur);\n-      _M_deallocate_node(this->_M_start._M_first);\n-      this->_M_start._M_set_node(this->_M_start._M_node + 1);\n-      this->_M_start._M_cur = this->_M_start._M_first;\n+      std::_Destroy(this->_M_impl._M_start._M_cur);\n+      _M_deallocate_node(this->_M_impl._M_start._M_first);\n+      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);\n+      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;\n     }\n \n   template <typename _Tp, typename _Alloc>\n@@ -402,31 +402,31 @@ namespace __gnu_norm\n                           forward_iterator_tag)\n       {\n         size_type __n = std::distance(__first, __last);\n-        if (__pos._M_cur == this->_M_start._M_cur)\n+        if (__pos._M_cur == this->_M_impl._M_start._M_cur)\n \t  {\n \t    iterator __new_start = _M_reserve_elements_at_front(__n);\n \t    try\n \t      {\n \t\tstd::uninitialized_copy(__first, __last, __new_start);\n-\t\tthis->_M_start = __new_start;\n+\t\tthis->_M_impl._M_start = __new_start;\n \t      }\n \t    catch(...)\n \t      {\n-\t\t_M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t\t_M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);\n \t\t__throw_exception_again;\n \t      }\n \t  }\n-        else if (__pos._M_cur == this->_M_finish._M_cur)\n+        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)\n \t  {\n \t    iterator __new_finish = _M_reserve_elements_at_back(__n);\n \t    try\n \t      {\n-\t\tstd::uninitialized_copy(__first, __last, this->_M_finish);\n-\t\tthis->_M_finish = __new_finish;\n+\t\tstd::uninitialized_copy(__first, __last, this->_M_impl._M_finish);\n+\t\tthis->_M_impl._M_finish = __new_finish;\n \t      }\n \t    catch(...)\n \t      {\n-\t\t_M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t_M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,\n \t\t\t\t __new_finish._M_node + 1);\n \t\t__throw_exception_again;\n \t      }\n@@ -440,28 +440,28 @@ namespace __gnu_norm\n     deque<_Tp,_Alloc>::\n     _M_insert_aux(iterator __pos, const value_type& __x)\n     {\n-      difference_type __index = __pos - this->_M_start;\n+      difference_type __index = __pos - this->_M_impl._M_start;\n       value_type __x_copy = __x; // XXX copy\n       if (static_cast<size_type>(__index) < size() / 2)\n \t{\n \t  push_front(front());\n-\t  iterator __front1 = this->_M_start;\n+\t  iterator __front1 = this->_M_impl._M_start;\n \t  ++__front1;\n \t  iterator __front2 = __front1;\n \t  ++__front2;\n-\t  __pos = this->_M_start + __index;\n+\t  __pos = this->_M_impl._M_start + __index;\n \t  iterator __pos1 = __pos;\n \t  ++__pos1;\n \t  std::copy(__front2, __pos1, __front1);\n \t}\n       else\n \t{\n \t  push_back(back());\n-\t  iterator __back1 = this->_M_finish;\n+\t  iterator __back1 = this->_M_impl._M_finish;\n \t  --__back1;\n \t  iterator __back2 = __back1;\n \t  --__back2;\n-\t  __pos = this->_M_start + __index;\n+\t  __pos = this->_M_impl._M_start + __index;\n \t  std::copy_backward(__pos, __back2, __back1);\n \t}\n       *__pos = __x_copy;\n@@ -473,71 +473,71 @@ namespace __gnu_norm\n     deque<_Tp,_Alloc>::\n     _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)\n     {\n-      const difference_type __elems_before = __pos - this->_M_start;\n+      const difference_type __elems_before = __pos - this->_M_impl._M_start;\n       size_type __length = this->size();\n       value_type __x_copy = __x;\n       if (__elems_before < difference_type(__length / 2))\n \t{\n \t  iterator __new_start = _M_reserve_elements_at_front(__n);\n-\t  iterator __old_start = this->_M_start;\n-\t  __pos = this->_M_start + __elems_before;\n+\t  iterator __old_start = this->_M_impl._M_start;\n+\t  __pos = this->_M_impl._M_start + __elems_before;\n \t  try\n \t    {\n \t      if (__elems_before >= difference_type(__n))\n \t\t{\n-\t\t  iterator __start_n = this->_M_start + difference_type(__n);\n-\t\t  std::uninitialized_copy(this->_M_start, __start_n,\n+\t\t  iterator __start_n = this->_M_impl._M_start + difference_type(__n);\n+\t\t  std::uninitialized_copy(this->_M_impl._M_start, __start_n,\n \t\t\t\t\t  __new_start);\n-\t\t  this->_M_start = __new_start;\n+\t\t  this->_M_impl._M_start = __new_start;\n \t\t  std::copy(__start_n, __pos, __old_start);\n \t\t  fill(__pos - difference_type(__n), __pos, __x_copy);\n \t\t}\n \t      else\n \t\t{\n-\t\t  std::__uninitialized_copy_fill(this->_M_start, __pos,\n+\t\t  std::__uninitialized_copy_fill(this->_M_impl._M_start, __pos,\n \t\t\t\t\t\t __new_start,\n-\t\t\t\t\t\t this->_M_start, __x_copy);\n-\t\t  this->_M_start = __new_start;\n+\t\t\t\t\t\t this->_M_impl._M_start, __x_copy);\n+\t\t  this->_M_impl._M_start = __new_start;\n \t\t  std::fill(__old_start, __pos, __x_copy);\n \t\t}\n \t    }\n \t  catch(...)\n \t    {\n-\t      _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t      _M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);\n \t      __throw_exception_again;\n \t    }\n \t}\n       else\n \t{\n \t  iterator __new_finish = _M_reserve_elements_at_back(__n);\n-\t  iterator __old_finish = this->_M_finish;\n+\t  iterator __old_finish = this->_M_impl._M_finish;\n \t  const difference_type __elems_after =\n \t    difference_type(__length) - __elems_before;\n-\t  __pos = this->_M_finish - __elems_after;\n+\t  __pos = this->_M_impl._M_finish - __elems_after;\n \t  try\n \t    {\n \t      if (__elems_after > difference_type(__n))\n \t\t{\n-\t\t  iterator __finish_n = this->_M_finish - difference_type(__n);\n-\t\t  std::uninitialized_copy(__finish_n, this->_M_finish,\n-\t\t\t\t\t  this->_M_finish);\n-\t\t  this->_M_finish = __new_finish;\n+\t\t  iterator __finish_n = this->_M_impl._M_finish - difference_type(__n);\n+\t\t  std::uninitialized_copy(__finish_n, this->_M_impl._M_finish,\n+\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n \t\t  std::fill(__pos, __pos + difference_type(__n), __x_copy);\n \t\t}\n \t      else\n \t\t{\n-\t\t  std::__uninitialized_fill_copy(this->_M_finish,\n+\t\t  std::__uninitialized_fill_copy(this->_M_impl._M_finish,\n \t\t\t\t\t\t __pos + difference_type(__n),\n \t\t\t\t\t\t __x_copy, __pos,\n-\t\t\t\t\t\t this->_M_finish);\n-\t\t  this->_M_finish = __new_finish;\n+\t\t\t\t\t\t this->_M_impl._M_finish);\n+\t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::fill(__pos, __old_finish, __x_copy);\n \t\t}\n \t    }\n \t  catch(...)\n \t    {\n-\t      _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,\n \t\t\t       __new_finish._M_node + 1);\n \t      __throw_exception_again;\n \t    }\n@@ -552,56 +552,56 @@ namespace __gnu_norm\n                     _ForwardIterator __first, _ForwardIterator __last,\n                     size_type __n)\n       {\n-        const difference_type __elemsbefore = __pos - this->_M_start;\n+        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;\n         size_type __length = size();\n         if (static_cast<size_type>(__elemsbefore) < __length / 2)\n \t  {\n \t    iterator __new_start = _M_reserve_elements_at_front(__n);\n-\t    iterator __old_start = this->_M_start;\n-\t    __pos = this->_M_start + __elemsbefore;\n+\t    iterator __old_start = this->_M_impl._M_start;\n+\t    __pos = this->_M_impl._M_start + __elemsbefore;\n \t    try\n \t      {\n \t\tif (__elemsbefore >= difference_type(__n))\n \t\t  {\n-\t\t    iterator __start_n = this->_M_start + difference_type(__n);\n-\t\t    std::uninitialized_copy(this->_M_start, __start_n,\n+\t\t    iterator __start_n = this->_M_impl._M_start + difference_type(__n);\n+\t\t    std::uninitialized_copy(this->_M_impl._M_start, __start_n,\n \t\t\t\t\t    __new_start);\n-\t\t    this->_M_start = __new_start;\n+\t\t    this->_M_impl._M_start = __new_start;\n \t\t    std::copy(__start_n, __pos, __old_start);\n \t\t    std::copy(__first, __last, __pos - difference_type(__n));\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    _ForwardIterator __mid = __first;\n \t\t    std::advance(__mid, difference_type(__n) - __elemsbefore);\n-\t\t    std::__uninitialized_copy_copy(this->_M_start, __pos,\n+\t\t    std::__uninitialized_copy_copy(this->_M_impl._M_start, __pos,\n \t\t\t\t\t\t   __first, __mid, __new_start);\n-\t\t    this->_M_start = __new_start;\n+\t\t    this->_M_impl._M_start = __new_start;\n \t\t    std::copy(__mid, __last, __old_start);\n \t\t  }\n \t      }\n \t    catch(...)\n \t      {\n-\t\t_M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n+\t\t_M_destroy_nodes(__new_start._M_node, this->_M_impl._M_start._M_node);\n \t\t__throw_exception_again;\n \t      }\n \t  }\n         else\n         {\n           iterator __new_finish = _M_reserve_elements_at_back(__n);\n-          iterator __old_finish = this->_M_finish;\n+          iterator __old_finish = this->_M_impl._M_finish;\n           const difference_type __elemsafter =\n             difference_type(__length) - __elemsbefore;\n-          __pos = this->_M_finish - __elemsafter;\n+          __pos = this->_M_impl._M_finish - __elemsafter;\n           try\n             {\n               if (__elemsafter > difference_type(__n))\n \t\t{\n-\t\t  iterator __finish_n = this->_M_finish - difference_type(__n);\n+\t\t  iterator __finish_n = this->_M_impl._M_finish - difference_type(__n);\n \t\t  std::uninitialized_copy(__finish_n,\n-\t\t\t\t\t  this->_M_finish,\n-\t\t\t\t\t  this->_M_finish);\n-\t\t  this->_M_finish = __new_finish;\n+\t\t\t\t\t  this->_M_impl._M_finish,\n+\t\t\t\t\t  this->_M_impl._M_finish);\n+\t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy_backward(__pos, __finish_n, __old_finish);\n \t\t  std::copy(__first, __last, __pos);\n \t\t}\n@@ -610,15 +610,15 @@ namespace __gnu_norm\n \t\t  _ForwardIterator __mid = __first;\n \t\t  std::advance(__mid, __elemsafter);\n \t\t  std::__uninitialized_copy_copy(__mid, __last, __pos,\n-\t\t\t\t\t\t this->_M_finish,\n-\t\t\t\t\t\t this->_M_finish);\n-\t\t  this->_M_finish = __new_finish;\n+\t\t\t\t\t\t this->_M_impl._M_finish,\n+\t\t\t\t\t\t this->_M_impl._M_finish);\n+\t\t  this->_M_impl._M_finish = __new_finish;\n \t\t  std::copy(__first, __mid, __pos);\n \t\t}\n             }\n           catch(...)\n             {\n-              _M_destroy_nodes(this->_M_finish._M_node + 1,\n+              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,\n \t\t\t       __new_finish._M_node + 1);\n               __throw_exception_again;\n             }\n@@ -637,12 +637,12 @@ namespace __gnu_norm\n       try\n         {\n           for (__i = 1; __i <= __new_nodes; ++__i)\n-            *(this->_M_start._M_node - __i) = this->_M_allocate_node();\n+            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();\n         }\n       catch(...)\n         {\n           for (size_type __j = 1; __j < __i; ++__j)\n-            _M_deallocate_node(*(this->_M_start._M_node - __j));\n+            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));\n           __throw_exception_again;\n         }\n     }\n@@ -659,12 +659,12 @@ namespace __gnu_norm\n       try\n         {\n           for (__i = 1; __i <= __new_nodes; ++__i)\n-            *(this->_M_finish._M_node + __i) = this->_M_allocate_node();\n+            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();\n         }\n       catch(...)\n         {\n           for (size_type __j = 1; __j < __i; ++__j)\n-            _M_deallocate_node(*(this->_M_finish._M_node + __j));\n+            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));\n           __throw_exception_again;\n         }\n     }\n@@ -675,44 +675,44 @@ namespace __gnu_norm\n     _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)\n     {\n       size_type __old_num_nodes\n-\t= this->_M_finish._M_node - this->_M_start._M_node + 1;\n+\t= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;\n       size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n \n       _Map_pointer __new_nstart;\n-      if (this->_M_map_size > 2 * __new_num_nodes)\n+      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)\n \t{\n-\t  __new_nstart = this->_M_map + (this->_M_map_size\n+\t  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size\n \t\t\t\t\t - __new_num_nodes) / 2\n \t                 + (__add_at_front ? __nodes_to_add : 0);\n-\t  if (__new_nstart < this->_M_start._M_node)\n-\t    std::copy(this->_M_start._M_node,\n-\t\t    this->_M_finish._M_node + 1,\n+\t  if (__new_nstart < this->_M_impl._M_start._M_node)\n+\t    std::copy(this->_M_impl._M_start._M_node,\n+\t\t    this->_M_impl._M_finish._M_node + 1,\n \t\t    __new_nstart);\n \t  else\n-\t    std::copy_backward(this->_M_start._M_node,\n-\t\t\t       this->_M_finish._M_node + 1,\n+\t    std::copy_backward(this->_M_impl._M_start._M_node,\n+\t\t\t       this->_M_impl._M_finish._M_node + 1,\n \t\t\t       __new_nstart + __old_num_nodes);\n \t}\n       else\n \t{\n-\t  size_type __new_map_size = this->_M_map_size\n-\t                             + std::max(this->_M_map_size,\n+\t  size_type __new_map_size = this->_M_impl._M_map_size\n+\t                             + std::max(this->_M_impl._M_map_size,\n \t\t\t\t\t\t__nodes_to_add) + 2;\n \n \t  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);\n \t  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n \t                 + (__add_at_front ? __nodes_to_add : 0);\n-\t  std::copy(this->_M_start._M_node,\n-\t\t    this->_M_finish._M_node + 1,\n+\t  std::copy(this->_M_impl._M_start._M_node,\n+\t\t    this->_M_impl._M_finish._M_node + 1,\n \t\t    __new_nstart);\n-\t  _M_deallocate_map(this->_M_map, this->_M_map_size);\n+\t  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);\n \n-\t  this->_M_map = __new_map;\n-\t  this->_M_map_size = __new_map_size;\n+\t  this->_M_impl._M_map = __new_map;\n+\t  this->_M_impl._M_map_size = __new_map_size;\n \t}\n \n-      this->_M_start._M_set_node(__new_nstart);\n-      this->_M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n+      this->_M_impl._M_start._M_set_node(__new_nstart);\n+      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n     }\n } // namespace __gnu_norm\n "}, {"sha": "f712be2ab0b29a579d222012c4e70581ffd4a3a6", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -69,8 +69,8 @@ namespace __gnu_norm\n     _M_clear()\n     {\n       typedef _List_node<_Tp>  _Node;\n-      _Node* __cur = static_cast<_Node*>(this->_M_node._M_next);\n-      while (__cur != &this->_M_node)\n+      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);\n+      while (__cur != &this->_M_impl._M_node)\n       {\n         _Node* __tmp = __cur;\n         __cur = static_cast<_Node*>(__cur->_M_next);\n@@ -237,8 +237,8 @@ namespace __gnu_norm\n     sort()\n     {\n       // Do nothing if the list has length 0 or 1.\n-      if (this->_M_node._M_next != &this->_M_node\n-\t  && this->_M_node._M_next->_M_next != &this->_M_node)\n+      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node\n+\t  && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)\n       {\n         list __carry;\n         list __tmp[64];\n@@ -341,8 +341,8 @@ namespace __gnu_norm\n       sort(_StrictWeakOrdering __comp)\n       {\n \t// Do nothing if the list has length 0 or 1.\n-\tif (this->_M_node._M_next != &this->_M_node\n-\t    && this->_M_node._M_next->_M_next != &this->_M_node)\n+\tif (this->_M_impl._M_node._M_next != &this->_M_impl._M_node\n+\t    && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)\n \t  {\n \t    list __carry;\n \t    list __tmp[64];"}, {"sha": "5d237d5f3c157e0097cc582fc88d18ffd7a25464", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 82, "deletions": 72, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -351,39 +351,54 @@ namespace __gnu_norm\n   */\n   template<typename _Tp, typename _Alloc>\n     class _Deque_base\n-    : public _Alloc\n     {\n     public:\n       typedef _Alloc                  allocator_type;\n \n       allocator_type\n       get_allocator() const\n-      { return *static_cast<const _Alloc*>(this); }\n+      { return *static_cast<const _Alloc*>(&this->_M_impl); }\n \n       typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n       typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n \n       _Deque_base(const allocator_type& __a, size_t __num_elements)\n-      : _Alloc(__a), _M_start(), _M_finish()\n+\t: _M_impl(__a)\n       { _M_initialize_map(__num_elements); }\n \n       _Deque_base(const allocator_type& __a)\n-      : _Alloc(__a), _M_start(), _M_finish() { }\n+\t: _M_impl(__a)\n+      { }\n \n       ~_Deque_base();\n \n     protected:\n+      //This struct encapsulates the implementation of the std::deque\n+      //standard container and at the same time makes use of the EBO\n+      //for empty allocators.\n+      struct _Deque_impl\n+\t: public _Alloc {\n+\t_Tp** _M_map;\n+\tsize_t _M_map_size;\n+\titerator _M_start;\n+\titerator _M_finish;\n+\n+\t_Deque_impl(const _Alloc& __a)\n+\t  : _Alloc(__a), _M_map(0), _M_map_size(0), _M_start(), _M_finish()\n+\t{ }\n+      };\n+\n       typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;\n       _Map_alloc_type _M_get_map_allocator() const\n       { return _Map_alloc_type(this->get_allocator()); }\n \n       _Tp*\n       _M_allocate_node()\n-      { return _Alloc::allocate(__deque_buf_size(sizeof(_Tp))); }\n+      { return _M_impl._Alloc::allocate(__deque_buf_size(sizeof(_Tp))); }\n \n       void\n       _M_deallocate_node(_Tp* __p)\n-      { _Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }\n+      { _M_impl._Alloc::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }\n \n       _Tp**\n       _M_allocate_map(size_t __n)\n@@ -399,19 +414,16 @@ namespace __gnu_norm\n       void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n       enum { _S_initial_map_size = 8 };\n \n-      _Tp** _M_map;\n-      size_t _M_map_size;\n-      iterator _M_start;\n-      iterator _M_finish;\n+      _Deque_impl _M_impl;\n     };\n \n   template<typename _Tp, typename _Alloc>\n   _Deque_base<_Tp,_Alloc>::~_Deque_base()\n   {\n-    if (this->_M_map)\n+    if (this->_M_impl._M_map)\n     {\n-      _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);\n-      _M_deallocate_map(this->_M_map, this->_M_map_size);\n+      _M_destroy_nodes(this->_M_impl._M_start._M_node, this->_M_impl._M_finish._M_node + 1);\n+      _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);\n     }\n   }\n \n@@ -431,32 +443,32 @@ namespace __gnu_norm\n     {\n       size_t __num_nodes = __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;\n \n-      this->_M_map_size = std::max((size_t) _S_initial_map_size,\n+      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,\n \t\t\t\t   __num_nodes + 2);\n-      this->_M_map = _M_allocate_map(this->_M_map_size);\n+      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);\n \n       // For \"small\" maps (needing less than _M_map_size nodes), allocation\n       // starts in the middle elements and grows outwards.  So nstart may be\n       // the beginning of _M_map, but for small maps it may be as far in as\n       // _M_map+3.\n \n-      _Tp** __nstart = this->_M_map + (this->_M_map_size - __num_nodes) / 2;\n+      _Tp** __nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size - __num_nodes) / 2;\n       _Tp** __nfinish = __nstart + __num_nodes;\n \n       try\n \t{ _M_create_nodes(__nstart, __nfinish); }\n       catch(...)\n \t{\n-\t  _M_deallocate_map(this->_M_map, this->_M_map_size);\n-\t  this->_M_map = 0;\n-\t  this->_M_map_size = 0;\n+\t  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);\n+\t  this->_M_impl._M_map = 0;\n+\t  this->_M_impl._M_map_size = 0;\n \t  __throw_exception_again;\n \t}\n \n-      _M_start._M_set_node(__nstart);\n-      _M_finish._M_set_node(__nfinish - 1);\n-      _M_start._M_cur = _M_start._M_first;\n-      _M_finish._M_cur = _M_finish._M_first + __num_elements\n+      this->_M_impl._M_start._M_set_node(__nstart);\n+      this->_M_impl._M_finish._M_set_node(__nfinish - 1);\n+      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;\n+      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first + __num_elements\n \t                 % __deque_buf_size(sizeof(_Tp));\n     }\n \n@@ -608,12 +620,10 @@ namespace __gnu_norm\n \n       /** @if maint\n        *  A total of four data members accumulated down the heirarchy.\n+       *  May be accessed via _M_impl.*\n        *  @endif\n        */\n-      using _Base::_M_map;\n-      using _Base::_M_map_size;\n-      using _Base::_M_start;\n-      using _Base::_M_finish;\n+      using _Base::_M_impl;\n \n     public:\n       // [23.2.1.1] construct/copy/destroy\n@@ -658,7 +668,7 @@ namespace __gnu_norm\n        */\n       deque(const deque& __x)\n       : _Base(__x.get_allocator(), __x.size())\n-      { std::uninitialized_copy(__x.begin(), __x.end(), this->_M_start); }\n+      { std::uninitialized_copy(__x.begin(), __x.end(), this->_M_impl._M_start); }\n \n       /**\n        *  @brief  Builds a %deque from a range.\n@@ -690,7 +700,7 @@ namespace __gnu_norm\n        *  way.  Managing the pointer is the user's responsibilty.\n        */\n       ~deque()\n-      { std::_Destroy(this->_M_start, this->_M_finish); }\n+      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }\n \n       /**\n        *  @brief  %Deque assignment operator.\n@@ -748,39 +758,39 @@ namespace __gnu_norm\n        */\n       iterator\n       begin()\n-      { return this->_M_start; }\n+      { return this->_M_impl._M_start; }\n \n       /**\n        *  Returns a read-only (constant) iterator that points to the first\n        *  element in the %deque.  Iteration is done in ordinary element order.\n        */\n       const_iterator\n       begin() const\n-      { return this->_M_start; }\n+      { return this->_M_impl._M_start; }\n \n       /**\n        *  Returns a read/write iterator that points one past the last element in\n        *  the %deque.  Iteration is done in ordinary element order.\n        */\n       iterator\n       end()\n-      { return this->_M_finish; }\n+      { return this->_M_impl._M_finish; }\n \n       /**\n        *  Returns a read-only (constant) iterator that points one past the last\n        *  element in the %deque.  Iteration is done in ordinary element order.\n        */\n       const_iterator\n       end() const\n-      { return this->_M_finish; }\n+      { return this->_M_impl._M_finish; }\n \n       /**\n        *  Returns a read/write reverse iterator that points to the last element\n        *  in the %deque.  Iteration is done in reverse element order.\n        */\n       reverse_iterator\n       rbegin()\n-      { return reverse_iterator(this->_M_finish); }\n+      { return reverse_iterator(this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read-only (constant) reverse iterator that points to the\n@@ -789,15 +799,15 @@ namespace __gnu_norm\n        */\n       const_reverse_iterator\n       rbegin() const\n-      { return const_reverse_iterator(this->_M_finish); }\n+      { return const_reverse_iterator(this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read/write reverse iterator that points to one before the\n        *  first element in the %deque.  Iteration is done in reverse element\n        *  order.\n        */\n       reverse_iterator\n-      rend() { return reverse_iterator(this->_M_start); }\n+      rend() { return reverse_iterator(this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read-only (constant) reverse iterator that points to one\n@@ -806,13 +816,13 @@ namespace __gnu_norm\n        */\n       const_reverse_iterator\n       rend() const\n-      { return const_reverse_iterator(this->_M_start); }\n+      { return const_reverse_iterator(this->_M_impl._M_start); }\n \n       // [23.2.1.2] capacity\n       /**  Returns the number of elements in the %deque.  */\n       size_type\n       size() const\n-      { return this->_M_finish - this->_M_start; }\n+      { return this->_M_impl._M_finish - this->_M_impl._M_start; }\n \n       /**  Returns the size() of the largest possible %deque.  */\n       size_type\n@@ -834,9 +844,9 @@ namespace __gnu_norm\n       {\n \tconst size_type __len = size();\n \tif (__new_size < __len)\n-\t  erase(this->_M_start + __new_size, this->_M_finish);\n+\t  erase(this->_M_impl._M_start + __new_size, this->_M_impl._M_finish);\n \telse\n-\t  insert(this->_M_finish, __new_size - __len, __x);\n+\t  insert(this->_M_impl._M_finish, __new_size - __len, __x);\n       }\n \n       /**\n@@ -857,7 +867,7 @@ namespace __gnu_norm\n        */\n       bool\n       empty() const\n-      { return this->_M_finish == this->_M_start; }\n+      { return this->_M_impl._M_finish == this->_M_impl._M_start; }\n \n       // element access\n       /**\n@@ -871,7 +881,7 @@ namespace __gnu_norm\n        */\n       reference\n       operator[](size_type __n)\n-      { return this->_M_start[difference_type(__n)]; }\n+      { return this->_M_impl._M_start[difference_type(__n)]; }\n \n       /**\n        *  @brief  Subscript access to the data contained in the %deque.\n@@ -884,7 +894,7 @@ namespace __gnu_norm\n        */\n       const_reference\n       operator[](size_type __n) const\n-      { return this->_M_start[difference_type(__n)]; }\n+      { return this->_M_impl._M_start[difference_type(__n)]; }\n \n     protected:\n       /// @if maint Safety check used only from at().  @endif\n@@ -933,15 +943,15 @@ namespace __gnu_norm\n        */\n       reference\n       front()\n-      { return *this->_M_start; }\n+      { return *this->_M_impl._M_start; }\n \n       /**\n        *  Returns a read-only (constant) reference to the data at the first\n        *  element of the %deque.\n        */\n       const_reference\n       front() const\n-      { return *this->_M_start; }\n+      { return *this->_M_impl._M_start; }\n \n       /**\n        *  Returns a read/write reference to the data at the last element of the\n@@ -950,7 +960,7 @@ namespace __gnu_norm\n       reference\n       back()\n       {\n-\titerator __tmp = this->_M_finish;\n+\titerator __tmp = this->_M_impl._M_finish;\n \t--__tmp;\n \treturn *__tmp;\n       }\n@@ -962,7 +972,7 @@ namespace __gnu_norm\n       const_reference\n       back() const\n       {\n-\tconst_iterator __tmp = this->_M_finish;\n+\tconst_iterator __tmp = this->_M_impl._M_finish;\n \t--__tmp;\n \treturn *__tmp;\n       }\n@@ -979,10 +989,10 @@ namespace __gnu_norm\n       void\n       push_front(const value_type& __x)\n       {\n-\tif (this->_M_start._M_cur != this->_M_start._M_first)\n+\tif (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)\n \t  {\n-\t    std::_Construct(this->_M_start._M_cur - 1, __x);\n-\t    --this->_M_start._M_cur;\n+\t    std::_Construct(this->_M_impl._M_start._M_cur - 1, __x);\n+\t    --this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n \t  _M_push_front_aux(__x);\n@@ -999,10 +1009,10 @@ namespace __gnu_norm\n       void\n       push_back(const value_type& __x)\n       {\n-\tif (this->_M_finish._M_cur != this->_M_finish._M_last - 1)\n+\tif (this->_M_impl._M_finish._M_cur != this->_M_impl._M_finish._M_last - 1)\n \t  {\n-\t    std::_Construct(this->_M_finish._M_cur, __x);\n-\t    ++this->_M_finish._M_cur;\n+\t    std::_Construct(this->_M_impl._M_finish._M_cur, __x);\n+\t    ++this->_M_impl._M_finish._M_cur;\n \t  }\n \telse\n \t  _M_push_back_aux(__x);\n@@ -1019,10 +1029,10 @@ namespace __gnu_norm\n       void\n       pop_front()\n       {\n-\tif (this->_M_start._M_cur != this->_M_start._M_last - 1)\n+\tif (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_last - 1)\n \t  {\n-\t    std::_Destroy(this->_M_start._M_cur);\n-\t    ++this->_M_start._M_cur;\n+\t    std::_Destroy(this->_M_impl._M_start._M_cur);\n+\t    ++this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n \t  _M_pop_front_aux();\n@@ -1039,10 +1049,10 @@ namespace __gnu_norm\n       void\n       pop_back()\n       {\n-\tif (this->_M_finish._M_cur != this->_M_finish._M_first)\n+\tif (this->_M_impl._M_finish._M_cur != this->_M_impl._M_finish._M_first)\n \t  {\n-\t    --this->_M_finish._M_cur;\n-\t    std::_Destroy(this->_M_finish._M_cur);\n+\t    --this->_M_impl._M_finish._M_cur;\n+\t    std::_Destroy(this->_M_impl._M_finish._M_cur);\n \t  }\n \telse\n \t  _M_pop_back_aux();\n@@ -1140,10 +1150,10 @@ namespace __gnu_norm\n       void\n       swap(deque& __x)\n       {\n-\tstd::swap(this->_M_start, __x._M_start);\n-\tstd::swap(this->_M_finish, __x._M_finish);\n-\tstd::swap(this->_M_map, __x._M_map);\n-\tstd::swap(this->_M_map_size, __x._M_map_size);\n+\tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n+\tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n+\tstd::swap(this->_M_impl._M_map, __x._M_impl._M_map);\n+\tstd::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);\n       }\n \n       /**\n@@ -1362,21 +1372,21 @@ namespace __gnu_norm\n       iterator\n       _M_reserve_elements_at_front(size_type __n)\n       {\n-\tconst size_type __vacancies = this->_M_start._M_cur\n-\t                              - this->_M_start._M_first;\n+\tconst size_type __vacancies = this->_M_impl._M_start._M_cur\n+\t                              - this->_M_impl._M_start._M_first;\n \tif (__n > __vacancies)\n \t  _M_new_elements_at_front(__n - __vacancies);\n-\treturn this->_M_start - difference_type(__n);\n+\treturn this->_M_impl._M_start - difference_type(__n);\n       }\n \n       iterator\n       _M_reserve_elements_at_back(size_type __n)\n       {\n-\tconst size_type __vacancies = (this->_M_finish._M_last\n-\t\t\t\t       - this->_M_finish._M_cur) - 1;\n+\tconst size_type __vacancies = (this->_M_impl._M_finish._M_last\n+\t\t\t\t       - this->_M_impl._M_finish._M_cur) - 1;\n \tif (__n > __vacancies)\n \t  _M_new_elements_at_back(__n - __vacancies);\n-\treturn this->_M_finish + difference_type(__n);\n+\treturn this->_M_impl._M_finish + difference_type(__n);\n       }\n \n       void\n@@ -1400,15 +1410,15 @@ namespace __gnu_norm\n       void\n       _M_reserve_map_at_back (size_type __nodes_to_add = 1)\n       {\n-\tif (__nodes_to_add + 1 > this->_M_map_size\n-\t    - (this->_M_finish._M_node - this->_M_map))\n+\tif (__nodes_to_add + 1 > this->_M_impl._M_map_size\n+\t    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))\n \t  _M_reallocate_map(__nodes_to_add, false);\n       }\n \n       void\n       _M_reserve_map_at_front (size_type __nodes_to_add = 1)\n       {\n-\tif (__nodes_to_add > size_type(this->_M_start._M_node - this->_M_map))\n+\tif (__nodes_to_add > size_type(this->_M_impl._M_start._M_node - this->_M_impl._M_map))\n \t  _M_reallocate_map(__nodes_to_add, true);\n       }\n "}, {"sha": "c0d821116c753918e07074e342d74c5a83c6b375", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -275,7 +275,6 @@ namespace __gnu_norm\n   */\n   template<typename _Tp, typename _Alloc>\n     class _List_base\n-    : public _Alloc::template rebind<_List_node<_Tp> >::other\n     {\n     protected:\n       // NOTA BENE\n@@ -295,25 +294,33 @@ namespace __gnu_norm\n \n       _Node_Alloc_type;\n \n-      _List_node_base _M_node;\n+      struct _List_impl \n+\t: public _Node_Alloc_type {\n+\t_List_node_base _M_node;\n+\t_List_impl (const _Node_Alloc_type& __a)\n+\t  : _Node_Alloc_type(__a)\n+\t{ }\n+      };\n+\n+      _List_impl _M_impl;\n \n       _List_node<_Tp>*\n       _M_get_node()\n-      { return _Node_Alloc_type::allocate(1); }\n-\n+      { return _M_impl._Node_Alloc_type::allocate(1); }\n+      \n       void\n       _M_put_node(_List_node<_Tp>* __p)\n-      { _Node_Alloc_type::deallocate(__p, 1); }\n-\n+      { _M_impl._Node_Alloc_type::deallocate(__p, 1); }\n+      \n   public:\n       typedef _Alloc allocator_type;\n \n       allocator_type\n       get_allocator() const\n-      { return allocator_type(*static_cast<const _Node_Alloc_type*>(this)); }\n+      { return allocator_type(*static_cast<const _Node_Alloc_type*>(&this->_M_impl)); }\n \n       _List_base(const allocator_type& __a)\n-      : _Node_Alloc_type(__a)\n+\t: _M_impl(__a)\n       { _M_init(); }\n \n       // This is what actually destroys the list.\n@@ -326,8 +333,8 @@ namespace __gnu_norm\n       void\n       _M_init()\n       {\n-        this->_M_node._M_next = &this->_M_node;\n-        this->_M_node._M_prev = &this->_M_node;\n+        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;\n+        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;\n       }\n     };\n \n@@ -409,7 +416,7 @@ namespace __gnu_norm\n        *  will also be included, accumulated from the topmost parent.\n        *  @endif\n        */\n-      using _Base::_M_node;\n+      using _Base::_M_impl;\n       using _Base::_M_put_node;\n       using _Base::_M_get_node;\n \n@@ -588,7 +595,7 @@ namespace __gnu_norm\n        */\n       iterator\n       begin()\n-      { return this->_M_node._M_next; }\n+      { return this->_M_impl._M_node._M_next; }\n \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n@@ -597,15 +604,15 @@ namespace __gnu_norm\n        */\n       const_iterator\n       begin() const\n-      { return this->_M_node._M_next; }\n+      { return this->_M_impl._M_node._M_next; }\n \n       /**\n        *  Returns a read/write iterator that points one past the last\n        *  element in the %list.  Iteration is done in ordinary element\n        *  order.\n        */\n       iterator\n-      end() { return &this->_M_node; }\n+      end() { return &this->_M_impl._M_node; }\n \n       /**\n        *  Returns a read-only (constant) iterator that points one past\n@@ -614,7 +621,7 @@ namespace __gnu_norm\n        */\n       const_iterator\n       end() const\n-      { return &this->_M_node; }\n+      { return &this->_M_impl._M_node; }\n \n       /**\n        *  Returns a read/write reverse iterator that points to the last\n@@ -659,7 +666,7 @@ namespace __gnu_norm\n        */\n       bool\n       empty() const\n-      { return this->_M_node._M_next == &this->_M_node; }\n+      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }\n \n       /**  Returns the number of elements in the %list.  */\n       size_type\n@@ -788,7 +795,7 @@ namespace __gnu_norm\n        */\n       void\n       pop_back()\n-      { this->_M_erase(this->_M_node._M_prev); }\n+      { this->_M_erase(this->_M_impl._M_node._M_prev); }\n \n       /**\n        *  @brief  Inserts given value into %list before specified iterator.\n@@ -901,7 +908,7 @@ namespace __gnu_norm\n        */\n       void\n       swap(list& __x)\n-      { _List_node_base::swap(this->_M_node,__x._M_node); }\n+      { _List_node_base::swap(this->_M_impl._M_node,__x._M_impl._M_node); }\n \n       /**\n        *  Erases all the elements.  Note that this function only erases\n@@ -1064,7 +1071,7 @@ namespace __gnu_norm\n        */\n       void\n       reverse()\n-      { this->_M_node.reverse(); }\n+      { this->_M_impl._M_node.reverse(); }\n \n       /**\n        *  @brief  Sort the elements."}, {"sha": "10adb6368bed495c92751a89f7f66e7eea041f67", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 48, "deletions": 43, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -74,40 +74,47 @@ namespace __gnu_norm\n   */\n   template<typename _Tp, typename _Alloc>\n     struct _Vector_base\n-    : public _Alloc\n     {\n+      struct _Vector_impl \n+\t: public _Alloc {\n+\t_Tp*           _M_start;\n+\t_Tp*           _M_finish;\n+\t_Tp*           _M_end_of_storage;\n+\t_Vector_impl (_Alloc const& __a)\n+\t  : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)\n+\t{ }\n+      };\n+      \n     public:\n       typedef _Alloc allocator_type;\n \n       allocator_type\n-      get_allocator() const { return *static_cast<const _Alloc*>(this); }\n+      get_allocator() const { return *static_cast<const _Alloc*>(&this->_M_impl); }\n \n-      _Vector_base(const allocator_type& __a)\n-      : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0) { }\n+      _Vector_base(const allocator_type& __a) : _M_impl(__a)\n+      { }\n \n       _Vector_base(size_t __n, const allocator_type& __a)\n-      : _Alloc(__a)\n+\t: _M_impl(__a)\n       {\n-\tthis->_M_start = this->_M_allocate(__n);\n-\tthis->_M_finish = this->_M_start;\n-\tthis->_M_end_of_storage = this->_M_start + __n;\n+\tthis->_M_impl._M_start = this->_M_allocate(__n);\n+\tthis->_M_impl._M_finish = this->_M_impl._M_start;\n+\tthis->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n       }\n \n       ~_Vector_base()\n-      { _M_deallocate(this->_M_start,\n-\t\t      this->_M_end_of_storage - this->_M_start); }\n+      { _M_deallocate(this->_M_impl._M_start,\n+\t\t      this->_M_impl._M_end_of_storage - this->_M_impl._M_start); }\n \n     public:\n-      _Tp*           _M_start;\n-      _Tp*           _M_finish;\n-      _Tp*           _M_end_of_storage;\n+      _Vector_impl _M_impl;\n \n       _Tp*\n-      _M_allocate(size_t __n) { return _Alloc::allocate(__n); }\n+      _M_allocate(size_t __n) { return _M_impl.allocate(__n); }\n \n       void\n       _M_deallocate(_Tp* __p, size_t __n)\n-      { if (__p) _Alloc::deallocate(__p, __n); }\n+      { if (__p) _M_impl.deallocate(__p, __n); }\n     };\n \n \n@@ -162,9 +169,7 @@ namespace __gnu_norm\n        */\n       using _Base::_M_allocate;\n       using _Base::_M_deallocate;\n-      using _Base::_M_start;\n-      using _Base::_M_finish;\n-      using _Base::_M_end_of_storage;\n+      using _Base::_M_impl;\n \n     public:\n       // [23.2.4.1] construct/copy/destroy\n@@ -186,7 +191,7 @@ namespace __gnu_norm\n       vector(size_type __n, const value_type& __value,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__n, __a)\n-      { this->_M_finish = std::uninitialized_fill_n(this->_M_start,\n+      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,\n \t\t\t\t\t\t    __n, __value); }\n \n       /**\n@@ -199,7 +204,7 @@ namespace __gnu_norm\n       explicit\n       vector(size_type __n)\n       : _Base(__n, allocator_type())\n-      { this->_M_finish = std::uninitialized_fill_n(this->_M_start,\n+      { this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,\n \t\t\t\t\t\t    __n, value_type()); }\n \n       /**\n@@ -213,8 +218,8 @@ namespace __gnu_norm\n        */\n       vector(const vector& __x)\n       : _Base(__x.size(), __x.get_allocator())\n-      { this->_M_finish = std::uninitialized_copy(__x.begin(), __x.end(),\n-\t\t\t\t\t\t  this->_M_start);\n+      { this->_M_impl._M_finish = std::uninitialized_copy(__x.begin(), __x.end(),\n+\t\t\t\t\t\t  this->_M_impl._M_start);\n       }\n \n       /**\n@@ -248,7 +253,7 @@ namespace __gnu_norm\n        *  not touched in any way.  Managing the pointer is the user's\n        *  responsibilty.\n        */\n-      ~vector() { std::_Destroy(this->_M_start, this->_M_finish); }\n+      ~vector() { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish); }\n \n       /**\n        *  @brief  %Vector assignment operator.\n@@ -306,31 +311,31 @@ namespace __gnu_norm\n        *  element order.\n        */\n       iterator\n-      begin() { return iterator (this->_M_start); }\n+      begin() { return iterator (this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n        *  first element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       const_iterator\n-      begin() const { return const_iterator (this->_M_start); }\n+      begin() const { return const_iterator (this->_M_impl._M_start); }\n \n       /**\n        *  Returns a read/write iterator that points one past the last\n        *  element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       iterator\n-      end() { return iterator (this->_M_finish); }\n+      end() { return iterator (this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read-only (constant) iterator that points one past\n        *  the last element in the %vector.  Iteration is done in\n        *  ordinary element order.\n        */\n       const_iterator\n-      end() const { return const_iterator (this->_M_finish); }\n+      end() const { return const_iterator (this->_M_impl._M_finish); }\n \n       /**\n        *  Returns a read/write reverse iterator that points to the\n@@ -412,7 +417,7 @@ namespace __gnu_norm\n        */\n       size_type\n       capacity() const\n-      { return size_type(const_iterator(this->_M_end_of_storage) - begin()); }\n+      { return size_type(const_iterator(this->_M_impl._M_end_of_storage) - begin()); }\n \n       /**\n        *  Returns true if the %vector is empty.  (Thus begin() would\n@@ -550,10 +555,10 @@ namespace __gnu_norm\n       void\n       push_back(const value_type& __x)\n       {\n-\tif (this->_M_finish != this->_M_end_of_storage)\n+\tif (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n \t  {\n-\t    std::_Construct(this->_M_finish, __x);\n-\t    ++this->_M_finish;\n+\t    std::_Construct(this->_M_impl._M_finish, __x);\n+\t    ++this->_M_impl._M_finish;\n \t  }\n \telse\n \t  _M_insert_aux(end(), __x);\n@@ -571,8 +576,8 @@ namespace __gnu_norm\n       void\n       pop_back()\n       {\n-\t--this->_M_finish;\n-\tstd::_Destroy(this->_M_finish);\n+\t--this->_M_impl._M_finish;\n+\tstd::_Destroy(this->_M_impl._M_finish);\n       }\n \n       /**\n@@ -681,9 +686,9 @@ namespace __gnu_norm\n       void\n       swap(vector& __x)\n       {\n-\tstd::swap(this->_M_start, __x._M_start);\n-\tstd::swap(this->_M_finish, __x._M_finish);\n-\tstd::swap(this->_M_end_of_storage, __x._M_end_of_storage);\n+\tstd::swap(this->_M_impl._M_start, __x._M_impl._M_start);\n+\tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n+\tstd::swap(this->_M_impl._M_end_of_storage, __x._M_impl._M_end_of_storage);\n       }\n \n       /**\n@@ -728,9 +733,9 @@ namespace __gnu_norm\n         void\n         _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n         {\n-\t  this->_M_start = _M_allocate(__n);\n-\t  this->_M_end_of_storage = this->_M_start + __n;\n-\t  this->_M_finish = std::uninitialized_fill_n(this->_M_start,\n+\t  this->_M_impl._M_start = _M_allocate(__n);\n+\t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n+\t  this->_M_impl._M_finish = std::uninitialized_fill_n(this->_M_impl._M_start,\n \t\t\t\t\t\t      __n, __value);\n \t}\n \n@@ -762,10 +767,10 @@ namespace __gnu_norm\n \t\t\t    _ForwardIterator __last, forward_iterator_tag)\n         {\n \t  size_type __n = std::distance(__first, __last);\n-\t  this->_M_start = this->_M_allocate(__n);\n-\t  this->_M_end_of_storage = this->_M_start + __n;\n-\t  this->_M_finish = std::uninitialized_copy(__first, __last,\n-\t\t\t\t\t\t    this->_M_start);\n+\t  this->_M_impl._M_start = this->_M_allocate(__n);\n+\t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n+\t  this->_M_impl._M_finish = std::uninitialized_copy(__first, __last,\n+\t\t\t\t\t\t    this->_M_impl._M_start);\n \t}\n \n "}, {"sha": "dd459a53431bf3f91ffda833d3a0fbc0ff148a39", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -74,14 +74,14 @@ namespace __gnu_norm\n \t{\n \t  const size_type __old_size = size();\n \t  pointer __tmp = _M_allocate_and_copy(__n,\n-\t\t\t\t\t       this->_M_start,\n-\t\t\t\t\t       this->_M_finish);\n-\t  std::_Destroy(this->_M_start, this->_M_finish);\n-\t  _M_deallocate(this->_M_start,\n-\t\t\tthis->_M_end_of_storage - this->_M_start);\n-\t  this->_M_start = __tmp;\n-\t  this->_M_finish = __tmp + __old_size;\n-\t  this->_M_end_of_storage = this->_M_start + __n;\n+\t\t\t\t\t       this->_M_impl._M_start,\n+\t\t\t\t\t       this->_M_impl._M_finish);\n+\t  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t  _M_deallocate(this->_M_impl._M_start,\n+\t\t\tthis->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n+\t  this->_M_impl._M_start = __tmp;\n+\t  this->_M_impl._M_finish = __tmp + __old_size;\n+\t  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;\n \t}\n     }\n \n@@ -91,10 +91,10 @@ namespace __gnu_norm\n     insert(iterator __position, const value_type& __x)\n     {\n       size_type __n = __position - begin();\n-      if (this->_M_finish != this->_M_end_of_storage && __position == end())\n+      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage && __position == end())\n       {\n-        std::_Construct(this->_M_finish, __x);\n-        ++this->_M_finish;\n+        std::_Construct(this->_M_impl._M_finish, __x);\n+        ++this->_M_impl._M_finish;\n       }\n       else\n         _M_insert_aux(__position, __x);\n@@ -108,8 +108,8 @@ namespace __gnu_norm\n     {\n       if (__position + 1 != end())\n         std::copy(__position + 1, end(), __position);\n-      --this->_M_finish;\n-      std::_Destroy(this->_M_finish);\n+      --this->_M_impl._M_finish;\n+      std::_Destroy(this->_M_impl._M_finish);\n       return __position;\n     }\n \n@@ -120,7 +120,7 @@ namespace __gnu_norm\n     {\n       iterator __i(copy(__last, end(), __first));\n       std::_Destroy(__i, end());\n-      this->_M_finish = this->_M_finish - (__last - __first);\n+      this->_M_impl._M_finish = this->_M_impl._M_finish - (__last - __first);\n       return __first;\n     }\n \n@@ -135,11 +135,11 @@ namespace __gnu_norm\n         if (__xlen > capacity())\n         {\n           pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n-          std::_Destroy(this->_M_start, this->_M_finish);\n-          _M_deallocate(this->_M_start,\n-\t\t\tthis->_M_end_of_storage - this->_M_start);\n-          this->_M_start = __tmp;\n-          this->_M_end_of_storage = this->_M_start + __xlen;\n+          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+          _M_deallocate(this->_M_impl._M_start,\n+\t\t\tthis->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n+          this->_M_impl._M_start = __tmp;\n+          this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;\n         }\n         else if (size() >= __xlen)\n         {\n@@ -148,10 +148,10 @@ namespace __gnu_norm\n         }\n         else\n         {\n-          std::copy(__x.begin(), __x.begin() + size(), this->_M_start);\n-          std::uninitialized_copy(__x.begin() + size(), __x.end(), this->_M_finish);\n+          std::copy(__x.begin(), __x.begin() + size(), this->_M_impl._M_start);\n+          std::uninitialized_copy(__x.begin() + size(), __x.end(), this->_M_impl._M_finish);\n         }\n-        this->_M_finish = this->_M_start + __xlen;\n+        this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;\n       }\n       return *this;\n     }\n@@ -169,8 +169,8 @@ namespace __gnu_norm\n       else if (__n > size())\n       {\n         std::fill(begin(), end(), __val);\n-        this->_M_finish\n-\t  = std::uninitialized_fill_n(this->_M_finish, __n - size(), __val);\n+        this->_M_impl._M_finish\n+\t  = std::uninitialized_fill_n(this->_M_impl._M_finish, __n - size(), __val);\n       }\n       else\n         erase(fill_n(begin(), __n, __val), end());\n@@ -201,24 +201,24 @@ namespace __gnu_norm\n       if (__len > capacity())\n       {\n         pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n-        std::_Destroy(this->_M_start, this->_M_finish);\n-        _M_deallocate(this->_M_start,\n-\t\t      this->_M_end_of_storage - this->_M_start);\n-        this->_M_start = __tmp;\n-        this->_M_end_of_storage = this->_M_finish = this->_M_start + __len;\n+        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+        _M_deallocate(this->_M_impl._M_start,\n+\t\t      this->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n+        this->_M_impl._M_start = __tmp;\n+        this->_M_impl._M_end_of_storage = this->_M_impl._M_finish = this->_M_impl._M_start + __len;\n       }\n       else if (size() >= __len)\n       {\n-        iterator __new_finish(copy(__first, __last, this->_M_start));\n+        iterator __new_finish(copy(__first, __last, this->_M_impl._M_start));\n         std::_Destroy(__new_finish, end());\n-        this->_M_finish = __new_finish.base();\n+        this->_M_impl._M_finish = __new_finish.base();\n       }\n       else\n       {\n         _ForwardIterator __mid = __first;\n         std::advance(__mid, size());\n-        std::copy(__first, __mid, this->_M_start);\n-        this->_M_finish = std::uninitialized_copy(__mid, __last, this->_M_finish);\n+        std::copy(__first, __mid, this->_M_impl._M_start);\n+        this->_M_impl._M_finish = std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);\n       }\n     }\n \n@@ -227,14 +227,14 @@ namespace __gnu_norm\n     vector<_Tp,_Alloc>::\n     _M_insert_aux(iterator __position, const _Tp& __x)\n     {\n-      if (this->_M_finish != this->_M_end_of_storage)\n+      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)\n       {\n-        std::_Construct(this->_M_finish, *(this->_M_finish - 1));\n-        ++this->_M_finish;\n+        std::_Construct(this->_M_impl._M_finish, *(this->_M_impl._M_finish - 1));\n+        ++this->_M_impl._M_finish;\n         _Tp __x_copy = __x;\n         std::copy_backward(__position,\n-\t\t\t   iterator(this->_M_finish-2),\n-\t\t\t   iterator(this->_M_finish-1));\n+\t\t\t   iterator(this->_M_impl._M_finish-2),\n+\t\t\t   iterator(this->_M_impl._M_finish-1));\n         *__position = __x_copy;\n       }\n       else\n@@ -245,13 +245,13 @@ namespace __gnu_norm\n         iterator __new_finish(__new_start);\n         try\n           {\n-            __new_finish = std::uninitialized_copy(iterator(this->_M_start),\n+            __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),\n \t\t\t\t\t\t   __position,\n \t\t\t\t\t\t   __new_start);\n             std::_Construct(__new_finish.base(), __x);\n             ++__new_finish;\n             __new_finish = std::uninitialized_copy(__position,\n-\t\t\t\t\t\t   iterator(this->_M_finish),\n+\t\t\t\t\t\t   iterator(this->_M_impl._M_finish),\n \t\t\t\t\t\t   __new_finish);\n           }\n         catch(...)\n@@ -261,11 +261,11 @@ namespace __gnu_norm\n             __throw_exception_again;\n           }\n         std::_Destroy(begin(), end());\n-        _M_deallocate(this->_M_start,\n-\t\t      this->_M_end_of_storage - this->_M_start);\n-        this->_M_start = __new_start.base();\n-        this->_M_finish = __new_finish.base();\n-        this->_M_end_of_storage = __new_start.base() + __len;\n+        _M_deallocate(this->_M_impl._M_start,\n+\t\t      this->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n+        this->_M_impl._M_start = __new_start.base();\n+        this->_M_impl._M_finish = __new_finish.base();\n+        this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n       }\n     }\n \n@@ -276,28 +276,28 @@ namespace __gnu_norm\n     {\n       if (__n != 0)\n       {\n-        if (size_type(this->_M_end_of_storage - this->_M_finish) >= __n)\n+        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)\n \t  {\n            value_type __x_copy = __x;\n \t   const size_type __elems_after = end() - __position;\n-\t   iterator __old_finish(this->_M_finish);\n+\t   iterator __old_finish(this->_M_impl._M_finish);\n \t   if (__elems_after > __n)\n \t     {\n-\t       std::uninitialized_copy(this->_M_finish - __n,\n-\t\t\t\t       this->_M_finish,\n-\t\t\t\t       this->_M_finish);\n-\t       this->_M_finish += __n;\n+\t       std::uninitialized_copy(this->_M_impl._M_finish - __n,\n+\t\t\t\t       this->_M_impl._M_finish,\n+\t\t\t\t       this->_M_impl._M_finish);\n+\t       this->_M_impl._M_finish += __n;\n \t       std::copy_backward(__position, __old_finish - __n, __old_finish);\n \t       std::fill(__position, __position + __n, __x_copy);\n \t     }\n \t   else\n \t     {\n-\t       std::uninitialized_fill_n(this->_M_finish,\n+\t       std::uninitialized_fill_n(this->_M_impl._M_finish,\n \t\t\t\t\t __n - __elems_after,\n \t\t\t\t\t __x_copy);\n-\t       this->_M_finish += __n - __elems_after;\n-\t       std::uninitialized_copy(__position, __old_finish, this->_M_finish);\n-\t       this->_M_finish += __elems_after;\n+\t       this->_M_impl._M_finish += __n - __elems_after;\n+\t       std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);\n+\t       this->_M_impl._M_finish += __elems_after;\n \t       std::fill(__position, __old_finish, __x_copy);\n \t     }\n \t  }\n@@ -321,12 +321,12 @@ namespace __gnu_norm\n \t\t_M_deallocate(__new_start.base(),__len);\n \t\t__throw_exception_again;\n \t      }\n-\t    std::_Destroy(this->_M_start, this->_M_finish);\n-\t    _M_deallocate(this->_M_start,\n-\t\t\t  this->_M_end_of_storage - this->_M_start);\n-\t    this->_M_start = __new_start.base();\n-\t    this->_M_finish = __new_finish.base();\n-\t    this->_M_end_of_storage = __new_start.base() + __len;\n+\t    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+\t    _M_deallocate(this->_M_impl._M_start,\n+\t\t\t  this->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n+\t    this->_M_impl._M_start = __new_start.base();\n+\t    this->_M_impl._M_finish = __new_finish.base();\n+\t    this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n \t  }\n       }\n     }\n@@ -354,27 +354,27 @@ namespace __gnu_norm\n       if (__first != __last)\n       {\n         size_type __n = std::distance(__first, __last);\n-        if (size_type(this->_M_end_of_storage - this->_M_finish) >= __n)\n+        if (size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish) >= __n)\n         {\n           const size_type __elems_after = end() - __position;\n-          iterator __old_finish(this->_M_finish);\n+          iterator __old_finish(this->_M_impl._M_finish);\n           if (__elems_after > __n)\n           {\n-            std::uninitialized_copy(this->_M_finish - __n,\n-\t\t\t\t    this->_M_finish,\n-\t\t\t\t    this->_M_finish);\n-            this->_M_finish += __n;\n+            std::uninitialized_copy(this->_M_impl._M_finish - __n,\n+\t\t\t\t    this->_M_impl._M_finish,\n+\t\t\t\t    this->_M_impl._M_finish);\n+            this->_M_impl._M_finish += __n;\n             std::copy_backward(__position, __old_finish - __n, __old_finish);\n             std::copy(__first, __last, __position);\n           }\n           else\n           {\n             _ForwardIterator __mid = __first;\n             std::advance(__mid, __elems_after);\n-            std::uninitialized_copy(__mid, __last, this->_M_finish);\n-            this->_M_finish += __n - __elems_after;\n-            std::uninitialized_copy(__position, __old_finish, this->_M_finish);\n-            this->_M_finish += __elems_after;\n+            std::uninitialized_copy(__mid, __last, this->_M_impl._M_finish);\n+            this->_M_impl._M_finish += __n - __elems_after;\n+            std::uninitialized_copy(__position, __old_finish, this->_M_impl._M_finish);\n+            this->_M_impl._M_finish += __elems_after;\n             std::copy(__first, __mid, __position);\n           }\n         }\n@@ -386,12 +386,12 @@ namespace __gnu_norm\n           iterator __new_finish(__new_start);\n           try\n             {\n-              __new_finish = std::uninitialized_copy(iterator(this->_M_start),\n+              __new_finish = std::uninitialized_copy(iterator(this->_M_impl._M_start),\n \t\t\t\t\t\t     __position, __new_start);\n               __new_finish = std::uninitialized_copy(__first, __last,\n \t\t\t\t\t\t     __new_finish);\n               __new_finish = std::uninitialized_copy(__position,\n-\t\t\t\t\t\t     iterator(this->_M_finish),\n+\t\t\t\t\t\t     iterator(this->_M_impl._M_finish),\n \t\t\t\t\t\t     __new_finish);\n             }\n           catch(...)\n@@ -400,12 +400,12 @@ namespace __gnu_norm\n               _M_deallocate(__new_start.base(), __len);\n               __throw_exception_again;\n             }\n-          std::_Destroy(this->_M_start, this->_M_finish);\n-          _M_deallocate(this->_M_start,\n-\t\t\tthis->_M_end_of_storage - this->_M_start);\n-          this->_M_start = __new_start.base();\n-          this->_M_finish = __new_finish.base();\n-          this->_M_end_of_storage = __new_start.base() + __len;\n+          std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish);\n+          _M_deallocate(this->_M_impl._M_start,\n+\t\t\tthis->_M_impl._M_end_of_storage - this->_M_impl._M_start);\n+          this->_M_impl._M_start = __new_start.base();\n+          this->_M_impl._M_finish = __new_finish.base();\n+          this->_M_impl._M_end_of_storage = __new_start.base() + __len;\n         }\n       }\n     }"}, {"sha": "8103928a1e3e4441bbff39b283475f433e6fbcfc", "filename": "libstdc++-v3/testsuite/23_containers/deque/cons/clear_allocator.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcons%2Fclear_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcons%2Fclear_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fcons%2Fclear_allocator.cc?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <deque>\n+#include <ext/new_allocator.h>\n+\n+using namespace std;\n+using __gnu_cxx::new_allocator;\n+\n+template<typename T>\n+  class clear_alloc : public new_allocator<T> \n+  {\n+  public:\n+\n+    template <typename T1>\n+      struct rebind \n+      { typedef clear_alloc<T1> other; };\n+\n+    virtual void clear()\n+    { }\n+\n+    clear_alloc()\n+    { }\n+    \n+    clear_alloc(clear_alloc const& _wa)\n+    { }\n+    \n+    template<typename T1>\n+      clear_alloc(clear_alloc<T1> const& _wa)\n+      { }\n+\n+    virtual ~clear_alloc()\n+    { this->clear(); }\n+\n+    T* allocate(typename new_allocator<T>::size_type n, const void *hint = 0)\n+    {\n+      this->clear();\n+      return new_allocator<T>::allocate(n, hint);\n+    }\n+    \n+    void deallocate(T *ptr, typename new_allocator<T>::size_type n)\n+    {\n+      this->clear();\n+      new_allocator<T>::deallocate(ptr, n);\n+    }\n+  };\n+\n+template<typename Container>\n+  void Check_Container()\n+  {\n+    Container* pic = new Container;\n+    int x = 230;\n+    \n+    while (x--)\n+      {\n+\tpic->push_back(x);\n+      }\n+    \n+    pic->get_allocator();\n+    \n+    // The following has led to infinite recursions or cores.\n+    pic->clear();\n+\n+    delete pic;\n+  }\n+\n+\n+int main()\n+{\n+  Check_Container<std::deque<int, clear_alloc<int> > >();\n+  return 0;\n+}\n+"}, {"sha": "c74fc085ffba10f638cde2a54ddceec567929a89", "filename": "libstdc++-v3/testsuite/23_containers/list/cons/clear_allocator.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcons%2Fclear_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcons%2Fclear_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcons%2Fclear_allocator.cc?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <list>\n+#include <ext/new_allocator.h>\n+\n+using namespace std;\n+using __gnu_cxx::new_allocator;\n+\n+template<typename T>\n+  class clear_alloc : public new_allocator<T> \n+  {\n+  public:\n+\n+    template <typename T1>\n+      struct rebind \n+      { typedef clear_alloc<T1> other; };\n+\n+    virtual void clear()\n+    { }\n+\n+    clear_alloc()\n+    { }\n+    \n+    clear_alloc(clear_alloc const& _wa)\n+    { }\n+    \n+    template<typename T1>\n+      clear_alloc(clear_alloc<T1> const& _wa)\n+      { }\n+\n+    virtual ~clear_alloc()\n+    { this->clear(); }\n+\n+    T* allocate(typename new_allocator<T>::size_type n, const void *hint = 0)\n+    {\n+      this->clear();\n+      return new_allocator<T>::allocate(n, hint);\n+    }\n+    \n+    void deallocate(T *ptr, typename new_allocator<T>::size_type n)\n+    {\n+      this->clear();\n+      new_allocator<T>::deallocate(ptr, n);\n+    }\n+  };\n+\n+template<typename Container>\n+  void Check_Container()\n+  {\n+    Container* pic = new Container;\n+    int x = 230;\n+    \n+    while (x--)\n+      {\n+\tpic->push_back(x);\n+      }\n+    \n+    pic->get_allocator();\n+    \n+    // The following has led to infinite recursions or cores.\n+    pic->clear();\n+\n+    delete pic;\n+  }\n+\n+\n+int main()\n+{\n+  Check_Container<std::list<int, clear_alloc<int> > >();\n+  return 0;\n+}\n+"}, {"sha": "5cc878e6c59abe8fb04f9413f5a05fad74986191", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/clear_allocator.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fclear_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fclear_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fclear_allocator.cc?ref=03f9ea4437e6e5ce757c0f6e5a1291eb232f8c8e", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+ \n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <vector>\n+#include <ext/new_allocator.h>\n+\n+using namespace std;\n+using __gnu_cxx::new_allocator;\n+\n+template<typename T>\n+  class clear_alloc : public new_allocator<T> \n+  {\n+  public:\n+\n+    template <typename T1>\n+      struct rebind \n+      { typedef clear_alloc<T1> other; };\n+\n+    virtual void clear()\n+    { }\n+\n+    clear_alloc()\n+    { }\n+    \n+    clear_alloc(clear_alloc const& _wa)\n+    { }\n+    \n+    template<typename T1>\n+      clear_alloc(clear_alloc<T1> const& _wa)\n+      { }\n+\n+    virtual ~clear_alloc()\n+    { this->clear(); }\n+\n+    T* allocate(typename new_allocator<T>::size_type n, const void *hint = 0)\n+    {\n+      this->clear();\n+      return new_allocator<T>::allocate(n, hint);\n+    }\n+    \n+    void deallocate(T *ptr, typename new_allocator<T>::size_type n)\n+    {\n+      this->clear();\n+      new_allocator<T>::deallocate(ptr, n);\n+    }\n+  };\n+\n+template<typename Container>\n+  void Check_Container()\n+  {\n+    Container* pic = new Container;\n+    int x = 230;\n+    \n+    while (x--)\n+      {\n+\tpic->push_back(x);\n+      }\n+    \n+    pic->get_allocator();\n+    \n+    // The following has led to infinite recursions or cores.\n+    pic->clear();\n+\n+    delete pic;\n+  }\n+\n+\n+int main()\n+{\n+  Check_Container<std::vector<int, clear_alloc<int> > >();\n+  return 0;\n+}\n+"}]}