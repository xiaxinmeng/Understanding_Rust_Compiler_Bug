{"sha": "a6405f1438b2868418f94cc1673001ca2b50a65c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY0MDVmMTQzOGIyODY4NDE4Zjk0Y2MxNjczMDAxY2EyYjUwYTY1Yw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-11T10:25:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-11T10:25:01Z"}, "message": "Merge pull request #227 from SimplyTheOther/master\n\nChanges to AST structure in preparation for macro expansion and cleanup", "tree": {"sha": "915c10b77703d0ef8d074775ddea95eb0f728cab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/915c10b77703d0ef8d074775ddea95eb0f728cab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6405f1438b2868418f94cc1673001ca2b50a65c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgJQX9CRBK7hj4Ov3rIwAAdHIIAF1aiyp3cVS5gq44GW4Hw4bb\n+jwA6aR1ykCMvXTwSEoYQoFvMeJ9sfspuG9S+q2XFJfx+/FTyJlXoiTbLfTeRunm\nhQLvSo4vxX94sHPMNpKhDXg41nOM+cA5yP04rIyXroqtOZyI4aFrT9bv+y9NB40q\nk18+xV1gHYxFFf6UFdRijzEBPC+JgWMgEyfR07z/g1d80qQBzGXERVGGWv1FDpMj\nNSkkVaUCNEwzsSuf0GutQFlpwg6ykyCvgAbMPtjCTbWurmkDaNXAZQS4dBU4afe8\nAtjn1AidOGzhRAPdKdhAv+2m21eJBWXzlCE7VTtKQwFChMx1c+vSvJjQq/6E+EI=\n=Dd+Y\n-----END PGP SIGNATURE-----\n", "payload": "tree 915c10b77703d0ef8d074775ddea95eb0f728cab\nparent 0c7d0135663b6f0d94e0ffd931366ba2b32f8b2c\nparent 7d4ed9d38c7a636408a262f70aa69d2a34e2169d\nauthor Philip Herron <philip.herron@embecosm.com> 1613039101 +0000\ncommitter GitHub <noreply@github.com> 1613039101 +0000\n\nMerge pull request #227 from SimplyTheOther/master\n\nChanges to AST structure in preparation for macro expansion and cleanup"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6405f1438b2868418f94cc1673001ca2b50a65c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6405f1438b2868418f94cc1673001ca2b50a65c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6405f1438b2868418f94cc1673001ca2b50a65c/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c7d0135663b6f0d94e0ffd931366ba2b32f8b2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c7d0135663b6f0d94e0ffd931366ba2b32f8b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c7d0135663b6f0d94e0ffd931366ba2b32f8b2c"}, {"sha": "7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4ed9d38c7a636408a262f70aa69d2a34e2169d"}], "stats": {"total": 3496, "additions": 1571, "deletions": 1925}, "files": [{"sha": "2c196a07e03465201c83937d01f4e3606fcba09f", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 434, "deletions": 958, "changes": 1392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -109,38 +109,78 @@ frag_spec_to_str (MacroFragSpec frag_spec)\n     }\n }\n \n-std::string\n-Crate::as_string () const\n+enum AttrMode\n {\n-  fprintf (stderr, \"beginning crate recursive as-string\\n\");\n+  OUTER,\n+  INNER\n+};\n \n-  std::string str (\"Crate: \");\n-  // add utf8bom and shebang\n-  if (has_utf8bom)\n-    {\n-      str += \"\\n has utf8bom\";\n-    }\n-  if (has_shebang)\n+std::string\n+get_mode_dump_desc (AttrMode mode)\n+{\n+  switch (mode)\n     {\n-      str += \"\\n has shebang\";\n+    case OUTER:\n+      return \"outer attributes\";\n+    case INNER:\n+      return \"inner attributes\";\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n     }\n+}\n \n-  // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n+// Adds lines below adding attributes\n+std::string\n+append_attributes (std::vector<Attribute> attrs, AttrMode mode)\n+{\n+  indent_spaces (enter);\n+\n+  std::string str\n+    = \"\\n\" + indent_spaces (stay) + get_mode_dump_desc (mode) + \": \";\n+  // str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n+  if (attrs.empty ())\n     {\n       str += \"none\";\n     }\n   else\n     {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n+      /* note that this does not print them with outer or \"inner attribute\"\n+       * syntax - just prints the body */\n+      for (const auto &attr : attrs)\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n     }\n \n+  indent_spaces (out);\n+\n+  return str;\n+}\n+\n+// Removes the beginning and end quotes of a quoted string.\n+std::string\n+unquote_string (std::string input)\n+{\n+  rust_assert (input.front () == '\"');\n+  rust_assert (input.back () == '\"');\n+  return input.substr (1, input.length () - 2);\n+}\n+\n+std::string\n+Crate::as_string () const\n+{\n+  fprintf (stderr, \"beginning crate recursive as-string\\n\");\n+\n+  std::string str (\"Crate: \");\n+  // add utf8bom and shebang\n+  if (has_utf8bom)\n+    str += \"\\n has utf8bom\";\n+\n+  if (has_shebang)\n+    str += \"\\n has shebang\";\n+\n+  // inner attributes\n+  str += append_attributes (inner_attrs, INNER);\n+\n   // items\n   str += \"\\n items: \";\n   if (items.empty ())\n@@ -156,7 +196,7 @@ Crate::as_string () const\n \t    {\n \t      fprintf (stderr, \"something really terrible has gone wrong - \"\n \t\t\t       \"null pointer item in crate.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -236,7 +276,7 @@ DelimTokenTree::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"token tree in delim token tree.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += tree->as_string ();\n@@ -250,13 +290,17 @@ DelimTokenTree::as_string () const\n std::string\n Token::as_string () const\n {\n-  /* FIXME: only works when not identifier or literal or whatever, i.e. when\n-   * doesn't store string value */\n-  // return get_token_description(token_id);\n+  if (tok_ref->has_str ())\n+    {\n+      std::string str = tok_ref->get_str ();\n \n-  // maybe fixed - stores everything as string though, so storage-inefficient\n-  std::string quote = is_string_lit () ? \"\\\"\" : \"\";\n-  return quote + str + quote;\n+      std::string quote = is_string_lit () ? \"\\\"\" : \"\";\n+      return quote + str + quote;\n+    }\n+  else\n+    {\n+      return tok_ref->get_token_description ();\n+    }\n }\n \n std::string\n@@ -270,9 +314,7 @@ SimplePath::as_string () const\n {\n   std::string path;\n   if (has_opening_scope_resolution)\n-    {\n-      path = \"::\";\n-    }\n+    path = \"::\";\n \n   // crappy hack because doing proper for loop would be more code\n   bool first_time = true;\n@@ -336,30 +378,11 @@ VisItem::as_string () const\n     }\n \n   if (has_visibility ())\n-    {\n-      str = visibility.as_string () + \" \";\n-    }\n+    str += visibility.as_string () + \" \";\n \n   return str;\n }\n \n-// Creates a string that reflects the outer attributes stored.\n-/*std::string\n-Item::as_string () const\n-{\n-  std::string str;\n-\n-  if (!outer_attrs.empty ())\n-    {\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += attr.as_string () + \"\\n\";\n-\t}\n-    }\n-\n-  return str;\n-}*/\n-\n std::string\n Module::as_string () const\n {\n@@ -375,20 +398,7 @@ ModuleBodied::as_string () const\n   std::string str = Module::as_string ();\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // items\n   str += \"\\n items: \";\n@@ -405,7 +415,7 @@ ModuleBodied::as_string () const\n \t    {\n \t      fprintf (stderr, \"something really terrible has gone wrong - \"\n \t\t\t       \"null pointer item in crate.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -433,9 +443,7 @@ StaticItem::as_string () const\n   str += indent_spaces (stay) + \"static\";\n \n   if (has_mut)\n-    {\n-      str += \" mut\";\n-    }\n+    str += \" mut\";\n \n   str += \" \" + name;\n \n@@ -444,7 +452,7 @@ StaticItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer type in static item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n\" + indent_spaces (stay) + \"Type: \" + type->as_string ();\n \n@@ -453,7 +461,7 @@ StaticItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer expr in static item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n\" + indent_spaces (stay) + \"Expression: \" + expr->as_string ();\n \n@@ -468,9 +476,7 @@ ExternCrate::as_string () const\n   str += \"extern crate \" + referenced_crate;\n \n   if (has_as_clause ())\n-    {\n-      str += \" as \" + as_clause_name;\n-    }\n+    str += \" as \" + as_clause_name;\n \n   return str;\n }\n@@ -499,7 +505,7 @@ TupleStruct::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -515,20 +521,14 @@ TupleStruct::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t{\n-\t  str += \"\\n  \" + field.as_string ();\n-\t}\n+\tstr += \"\\n  \" + field.as_string ();\n     }\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   return str;\n }\n@@ -545,7 +545,7 @@ ConstantItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer type in const item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n  Type: \" + type->as_string ();\n \n@@ -554,7 +554,7 @@ ConstantItem::as_string () const\n     {\n       fprintf (stderr, \"something really terrible has gone wrong - null \"\n \t\t       \"pointer expr in const item.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += \"\\n  Expression: \" + const_expr->as_string ();\n \n@@ -585,7 +585,7 @@ InherentImpl::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in inherent impl.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -596,29 +596,12 @@ InherentImpl::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // inherent impl items\n   str += \"\\n Inherent impl items: \";\n@@ -629,9 +612,7 @@ InherentImpl::as_string () const\n   else\n     {\n       for (const auto &item : impl_items)\n-\t{\n-\t  str += \"\\n  \" + item->as_string ();\n-\t}\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -663,7 +644,7 @@ Method::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in method.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -725,7 +706,7 @@ StructStruct::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -734,13 +715,9 @@ StructStruct::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   // struct fields\n   str += \"\\n Struct fields: \";\n@@ -755,9 +732,7 @@ StructStruct::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t{\n-\t  str += \"\\n  \" + field.as_string ();\n-\t}\n+\tstr += \"\\n  \" + field.as_string ();\n     }\n \n   return str;\n@@ -775,7 +750,7 @@ UseDeclaration::as_string () const\n \tstderr,\n \t\"something really terrible has gone wrong - null pointer use tree in \"\n \t\"use declaration.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n \n   str += \"use \" + use_tree->as_string ();\n@@ -835,7 +810,7 @@ UseTreeList::as_string () const\n \t  fprintf (stderr,\n \t\t   \"something really terrible has gone wrong - null pointer \"\n \t\t   \"tree in use tree list.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       for (; i != e; i++)\n@@ -900,7 +875,7 @@ Enum::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -909,13 +884,9 @@ Enum::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   // items\n   str += \"\\n Items: \";\n@@ -934,7 +905,7 @@ Enum::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"enum item in enum.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -950,9 +921,7 @@ Trait::as_string () const\n   std::string str = VisItem::as_string ();\n \n   if (has_unsafe)\n-    {\n-      str += \"unsafe \";\n-    }\n+    str += \"unsafe \";\n \n   str += \"trait \" + name;\n \n@@ -973,7 +942,7 @@ Trait::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in trait.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -996,7 +965,7 @@ Trait::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"type param bound in trait.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + bound->as_string ();\n@@ -1005,13 +974,9 @@ Trait::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n \n   str += \"\\n Trait items: \";\n   if (!has_trait_items ())\n@@ -1029,7 +994,7 @@ Trait::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"trait item in trait.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + item->as_string ();\n@@ -1063,7 +1028,7 @@ Union::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in union.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -1072,13 +1037,9 @@ Union::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   // struct fields\n   str += \"\\n Struct fields (variants): \";\n@@ -1089,9 +1050,7 @@ Union::as_string () const\n   else\n     {\n       for (const auto &field : variants)\n-\t{\n-\t  str += \"\\n  \" + field.as_string ();\n-\t}\n+\tstr += \"\\n  \" + field.as_string ();\n     }\n \n   return str;\n@@ -1114,7 +1073,7 @@ Function::as_string () const\n \t    stderr,\n \t    \"something really terrible has gone wrong - null pointer return \"\n \t    \"type in function.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       str += return_type->as_string () + \" \";\n@@ -1139,7 +1098,7 @@ Function::as_string () const\n \t  fprintf (stderr,\n \t\t   \"something really terrible has gone wrong - null pointer \"\n \t\t   \"generic param in function item.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       for (; i != e; i++)\n@@ -1181,7 +1140,7 @@ Function::as_string () const\n \tstderr,\n \t\"something really terrible has gone wrong - null pointer function \"\n \t\"body in function.\");\n-      return \"nullptr_POINTER_MARK\";\n+      return \"NULL_POINTER_MARK\";\n     }\n   str += function_body->as_string () + \"\\n\";\n \n@@ -1212,22 +1171,12 @@ BlockExpr::as_string () const\n {\n   std::string istr = indent_spaces (enter);\n   std::string str = istr + \"BlockExpr:\\n\" + istr;\n+\n   // get outer attributes\n-  str += \"{\\n\" + indent_spaces (stay) + Expr::as_string ();\n+  str += append_attributes (outer_attrs, OUTER);\n \n   // inner attributes\n-  str += \"\\n\" + indent_spaces (stay) + \"inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // statements\n   str += \"\\n\" + indent_spaces (stay) + \"statements: \";\n@@ -1246,7 +1195,7 @@ BlockExpr::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"stmt in block expr.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n\" + indent_spaces (stay) + stmt->as_string ();\n@@ -1260,7 +1209,7 @@ BlockExpr::as_string () const\n   else\n     str += \"\\n\" + expr->as_string ();\n \n-  str += \"\\n\" + indent_spaces (out) + \"}\";\n+  str += \"\\n\" + indent_spaces (out);\n   return str;\n }\n \n@@ -1303,18 +1252,7 @@ TraitImpl::as_string () const\n     str += where_clause.as_string ();\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n trait impl items: \";\n   if (!has_impl_items ())\n@@ -1358,13 +1296,9 @@ TypeAlias::as_string () const\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n \n   str += \"\\n Type: \" + existing_type->as_string ();\n \n@@ -1374,46 +1308,11 @@ TypeAlias::as_string () const\n std::string\n MacroInvocationSemi::as_string () const\n {\n-  std::string str;\n-\n-  // get outer attrs\n-  if (!outer_attrs.empty ())\n-    {\n-      for (const auto &attr : outer_attrs)\n-\tstr += attr.as_string () + \"\\n\";\n-    }\n-\n-  str += \"\\n\" + path.as_string () + \"!\";\n-\n-  std::string tok_trees;\n-  if (token_trees.empty ())\n-    {\n-      tok_trees = \"none\";\n-    }\n-  else\n-    {\n-      auto i = token_trees.begin ();\n-      auto e = token_trees.end ();\n+  std::string str = \"MacroInvocationSemi: \";\n \n-      // DEBUG: null pointer check\n-      if (i == e)\n-\t{\n-\t  fprintf (stderr,\n-\t\t   \"something really terrible has gone wrong - null pointer \"\n-\t\t   \"token tree in macro invocation semi.\");\n-\t  return \"nullptr_POINTER_MARK\";\n-\t}\n+  str += append_attributes (outer_attrs, OUTER);\n \n-      std::string s;\n-      for (; i != e; i++)\n-\t{\n-\t  s += (*i)->as_string ();\n-\t  if (e != i + 1)\n-\t    s += \", \";\n-\t}\n-\n-      tok_trees += get_string_in_delims (s, delim_type);\n-    }\n+  str += \"\\n\" + invoc_data.as_string ();\n \n   return str;\n }\n@@ -1425,23 +1324,9 @@ ExternBlock::as_string () const\n \n   str += \"extern \";\n   if (has_abi ())\n-    {\n-      str += \"\\\"\" + abi + \"\\\" \";\n-    }\n+    str += \"\\\"\" + abi + \"\\\" \";\n \n-  // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n external items: \";\n   if (!has_extern_items ())\n@@ -1477,11 +1362,7 @@ MacroRulesDefinition::as_string () const\n   std::string str;\n \n   // get outer attrs\n-  if (!outer_attrs.empty ())\n-    {\n-      for (const auto &attr : outer_attrs)\n-\tstr += attr.as_string () + \"\\n\";\n-    }\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"macro_rules!\";\n \n@@ -1520,8 +1401,19 @@ MacroRulesDefinition::as_string () const\n std::string\n MacroInvocation::as_string () const\n {\n-  return \"MacroInvocation: \" + path.as_string () + \"!\"\n-\t + token_tree.as_string ();\n+  std::string str = \"MacroInvocation: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n+\n+  str += \"\\n \" + invoc_data.as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+MacroInvocData::as_string () const\n+{\n+  return path.as_string () + \"!\" + token_tree.as_string ();\n }\n \n std::string\n@@ -1569,7 +1461,11 @@ ClosureParam::as_string () const\n std::string\n ClosureExpr::as_string () const\n {\n-  std::string str (\"ClosureExpr:\\n Has move: \");\n+  std::string str = \"ClosureExpr:\";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n+\n+  str += \"\\n Has move: \";\n   if (has_move)\n     str += \"true\";\n   else\n@@ -1636,6 +1532,9 @@ QualifiedPathInExpression::as_string () const\n std::string\n BorrowExpr::as_string () const\n {\n+  /* TODO: find way to incorporate outer attrs - may have to represent in\n+   * different style (i.e. something more like BorrowExpr: \\n outer attrs) */\n+\n   std::string str (\"&\");\n \n   if (double_borrow)\n@@ -1652,6 +1551,9 @@ BorrowExpr::as_string () const\n std::string\n ReturnExpr::as_string () const\n {\n+  /* TODO: find way to incorporate outer attrs - may have to represent in\n+   * different style (i.e. something more like BorrowExpr: \\n outer attrs) */\n+\n   std::string str (\"return \");\n \n   if (has_returned_expr ())\n@@ -1665,19 +1567,11 @@ GroupedExpr::as_string () const\n {\n   std::string str (\"Grouped expr:\");\n \n+  // outer attrs\n+  str += append_attributes (outer_attrs, OUTER);\n+\n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n \n@@ -1693,6 +1587,7 @@ RangeToExpr::as_string () const\n std::string\n ContinueExpr::as_string () const\n {\n+  // TODO: rewrite format to allow outer attributes\n   std::string str (\"continue \");\n \n   if (has_label ())\n@@ -1704,6 +1599,7 @@ ContinueExpr::as_string () const\n std::string\n NegationExpr::as_string () const\n {\n+  // TODO: rewrite formula to allow outer attributes\n   std::string str;\n \n   switch (negation_type)\n@@ -1738,6 +1634,7 @@ RangeFullExpr::as_string () const\n std::string\n ArrayIndexExpr::as_string () const\n {\n+  // TODO: rewrite formula to allow outer attributes\n   return array_expr->as_string () + \"[\" + index_expr->as_string () + \"]\";\n }\n \n@@ -1768,7 +1665,8 @@ AsyncBlockExpr::as_string () const\n   std::string str = \"AsyncBlockExpr: \";\n \n   // get outer attributes\n-  str += \"\\n \" + Expr::as_string ();\n+  // str += \"\\n \" + Expr::as_string ();\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Has move: \";\n   str += has_move ? \"true\" : \"false\";\n@@ -1779,6 +1677,7 @@ AsyncBlockExpr::as_string () const\n std::string\n ComparisonExpr::as_string () const\n {\n+  // TODO: rewrite to better reflect non-literal expressions\n   std::string str (main_or_left_expr->as_string ());\n \n   switch (expr_type)\n@@ -1813,12 +1712,14 @@ ComparisonExpr::as_string () const\n std::string\n MethodCallExpr::as_string () const\n {\n-  std::string str (\"MethodCallExpr: \\n Object (receiver) expr: \");\n+  std::string str = \"MethodCallExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n+  str += \"\\n Object (receiver) expr: \\n\";\n   str += receiver->as_string ();\n \n   str += \"\\n Method path segment: \\n\";\n-\n   str += method_name.as_string ();\n \n   str += \"\\n Call params:\";\n@@ -1843,24 +1744,28 @@ MethodCallExpr::as_string () const\n std::string\n TupleIndexExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return tuple_expr->as_string () + \".\" + std::to_string (tuple_index);\n }\n \n std::string\n DereferenceExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return \"*\" + main_or_left_expr->as_string ();\n }\n \n std::string\n FieldAccessExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return receiver->as_string () + \".\" + field;\n }\n \n std::string\n LazyBooleanExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   std::string str (main_or_left_expr->as_string ());\n \n   switch (expr_type)\n@@ -1883,26 +1788,28 @@ LazyBooleanExpr::as_string () const\n std::string\n RangeFromToExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return from->as_string () + \"..\" + to->as_string ();\n }\n \n std::string\n RangeToInclExpr::as_string () const\n {\n+  // TODO: rewrite dump to better reflect non-literal exprs\n   return \"..=\" + to->as_string ();\n }\n \n std::string\n UnsafeBlockExpr::as_string () const\n {\n-  std::string istr = indent_spaces (enter);\n-  std::string str = istr + \"UnsafeBlockExpr:\";\n-  str += istr + \"{\";\n+  std::string str = \"UnsafeBlockExpr:\" + indent_spaces (enter);\n \n   // get outer attributes\n-  str += \"\\n\" + indent_spaces (stay) + Expr::as_string ();\n+  str += append_attributes (outer_attrs, OUTER);\n \n-  return str + \"\\n\" + indent_spaces (out) + \"}\\n\" + expr->as_string ();\n+  str += indent_spaces (stay) + expr->as_string () + \"\\n\" + indent_spaces (out);\n+\n+  return str;\n }\n \n std::string\n@@ -1918,7 +1825,9 @@ ClosureExprInner::as_string () const\n std::string\n IfExpr::as_string () const\n {\n-  std::string str (\"IfExpr: \");\n+  std::string str = \"IfExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Condition expr: \" + condition->as_string ();\n \n@@ -1960,7 +1869,9 @@ IfExprConseqIfLet::as_string () const\n std::string\n IfLetExpr::as_string () const\n {\n-  std::string str (\"IfLetExpr: \");\n+  std::string str = \"IfLetExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Condition match arm patterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2013,12 +1924,14 @@ IfLetExprConseqIfLet::as_string () const\n std::string\n RangeFromToInclExpr::as_string () const\n {\n+  // TODO: rewrite to allow dumps with non-literal exprs\n   return from->as_string () + \"..=\" + to->as_string ();\n }\n \n std::string\n ErrorPropagationExpr::as_string () const\n {\n+  // TODO: rewrite to allow dumps with non-literal exprs\n   return main_or_left_expr->as_string () + \"?\";\n }\n \n@@ -2145,8 +2058,11 @@ ArithmeticOrLogicalExpr::as_string () const\n std::string\n CallExpr::as_string () const\n {\n-  std::string str (\"CallExpr: \\n Function expr: \");\n+  std::string str = \"CallExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n+  str += \"\\n Function expr: \";\n   str += function->as_string ();\n \n   str += \"\\n Call params:\";\n@@ -2171,7 +2087,9 @@ CallExpr::as_string () const\n std::string\n WhileLoopExpr::as_string () const\n {\n-  std::string str (\"WhileLoopExpr: \");\n+  std::string str = \"WhileLoopExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n@@ -2189,7 +2107,9 @@ WhileLoopExpr::as_string () const\n std::string\n WhileLetLoopExpr::as_string () const\n {\n-  std::string str (\"WhileLetLoopExpr: \");\n+  std::string str = \"WhileLetLoopExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n@@ -2218,7 +2138,9 @@ WhileLetLoopExpr::as_string () const\n std::string\n LoopExpr::as_string () const\n {\n-  std::string str (\"LoopExpr: (infinite loop)\");\n+  std::string str = \"LoopExpr: (infinite loop)\";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n@@ -2234,21 +2156,12 @@ LoopExpr::as_string () const\n std::string\n ArrayExpr::as_string () const\n {\n-  std::string str (\"ArrayExpr:\");\n+  std::string str = \"ArrayExpr:\";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n Array elems: \";\n   if (!has_array_elems ())\n@@ -2262,12 +2175,14 @@ ArrayExpr::as_string () const\n std::string\n AwaitExpr::as_string () const\n {\n+  // TODO: rewrite dump to allow non-literal exprs\n   return awaited_expr->as_string () + \".await\";\n }\n \n std::string\n BreakExpr::as_string () const\n {\n+  // TODO: rewrite dump to allow outer attrs, non-literal exprs\n   std::string str (\"break \");\n \n   if (has_label ())\n@@ -2289,18 +2204,7 @@ std::string\n MatchArm::as_string () const\n {\n   // outer attributes\n-  std::string str = \"Outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n \" + attr.as_string ();\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\nPatterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2333,48 +2237,17 @@ MatchCase::as_string () const\n   return str;\n }\n \n-/*std::string\n-MatchCaseBlockExpr::as_string () const\n-{\n-  std::string str = MatchCase::as_string ();\n-\n-  str += \"\\n Block expr: \" + block_expr->as_string ();\n-\n-  return str;\n-}\n-\n-std::string\n-MatchCaseExpr::as_string () const\n-{\n-  std::string str = MatchCase::as_string ();\n-\n-  str += \"\\n Expr: \" + expr->as_string ();\n-\n-  return str;\n-}*/\n-\n std::string\n MatchExpr::as_string () const\n {\n   std::string str (\"MatchExpr:\");\n \n+  str += append_attributes (outer_attrs, OUTER);\n+\n   str += \"\\n Scrutinee expr: \" + branch_value->as_string ();\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   // match arms\n   str += \"\\n Match arms: \";\n@@ -2396,21 +2269,10 @@ TupleExpr::as_string () const\n {\n   std::string str (\"TupleExpr:\");\n \n+  str += append_attributes (outer_attrs, OUTER);\n+\n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n Tuple elements: \";\n   if (tuple_elems.empty ())\n@@ -2420,9 +2282,7 @@ TupleExpr::as_string () const\n   else\n     {\n       for (const auto &elem : tuple_elems)\n-\t{\n-\t  str += \"\\n  \" + elem->as_string ();\n-\t}\n+\tstr += \"\\n  \" + elem->as_string ();\n     }\n \n   return str;\n@@ -2436,13 +2296,9 @@ ExprStmtWithoutBlock::as_string () const\n   str += indent_spaces (stay);\n \n   if (expr == nullptr)\n-    {\n-      str += \"none (this shouldn't happen and is probably an error)\";\n-    }\n+    str += \"none (this shouldn't happen and is probably an error)\";\n   else\n-    {\n-      str += expr->as_string ();\n-    }\n+    str += expr->as_string ();\n   indent_spaces (out);\n \n   return str;\n@@ -2451,6 +2307,7 @@ ExprStmtWithoutBlock::as_string () const\n std::string\n FunctionParam::as_string () const\n {\n+  // TODO: rewrite dump to allow non-literal types\n   return param_name->as_string () + \" : \" + type->as_string ();\n }\n \n@@ -2475,17 +2332,13 @@ FunctionQualifiers::as_string () const\n     }\n \n   if (has_unsafe)\n-    {\n-      str += \"unsafe \";\n-    }\n+    str += \"unsafe \";\n \n   if (has_extern)\n     {\n       str += \"extern\";\n       if (extern_abi != \"\")\n-\t{\n-\t  str += \" \\\"\" + extern_abi + \"\\\"\";\n-\t}\n+\tstr += \" \\\"\" + extern_abi + \"\\\"\";\n     }\n \n   return str;\n@@ -2498,13 +2351,9 @@ TraitBound::as_string () const\n \n   str += \"\\n Has opening question mark: \";\n   if (opening_question_mark)\n-    {\n-      str += \"true\";\n-    }\n+    str += \"true\";\n   else\n-    {\n-      str += \"false\";\n-    }\n+    str += \"false\";\n \n   str += \"\\n For lifetimes: \";\n   if (!has_for_lifetimes ())\n@@ -2514,9 +2363,7 @@ TraitBound::as_string () const\n   else\n     {\n       for (const auto &lifetime : for_lifetimes)\n-\t{\n-\t  str += \"\\n  \" + lifetime.as_string ();\n-\t}\n+\tstr += \"\\n  \" + lifetime.as_string ();\n     }\n \n   str += \"\\n Type path: \" + type_path.as_string ();\n@@ -2555,9 +2402,7 @@ MacroMatcher::as_string () const\n   else\n     {\n       for (const auto &match : matches)\n-\t{\n-\t  str += \"\\n  \" + match->as_string ();\n-\t}\n+\tstr += \"\\n  \" + match->as_string ();\n     }\n \n   return str;\n@@ -2570,13 +2415,9 @@ LifetimeParam::as_string () const\n \n   str += \"\\n Outer attribute: \";\n   if (!has_outer_attribute ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += outer_attr.as_string ();\n-    }\n+    str += outer_attr.as_string ();\n \n   str += \"\\n Lifetime: \" + lifetime.as_string ();\n \n@@ -2588,9 +2429,7 @@ LifetimeParam::as_string () const\n   else\n     {\n       for (const auto &bound : lifetime_bounds)\n-\t{\n-\t  str += \"\\n  \" + bound.as_string ();\n-\t}\n+\tstr += \"\\n  \" + bound.as_string ();\n     }\n \n   return str;\n@@ -2605,12 +2444,12 @@ MacroMatchFragment::as_string () const\n std::string\n QualifiedPathInType::as_string () const\n {\n+  /* TODO: this may need adjusting if segments (e.g. with functions) can't be\n+   * literalised */\n   std::string str = path_type.as_string ();\n \n   for (const auto &segment : segments)\n-    {\n-      str += \"::\" + segment->as_string ();\n-    }\n+    str += \"::\" + segment->as_string ();\n \n   return str;\n }\n@@ -2628,20 +2467,14 @@ MacroMatchRepetition::as_string () const\n   else\n     {\n       for (const auto &match : matches)\n-\t{\n-\t  str += \"\\n  \" + match->as_string ();\n-\t}\n+\tstr += \"\\n  \" + match->as_string ();\n     }\n \n   str += \"\\n Sep: \";\n   if (!has_sep ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += sep->as_string ();\n-    }\n+    str += sep->as_string ();\n \n   str += \"\\n Op: \";\n   switch (op)\n@@ -2669,9 +2502,7 @@ std::string\n Lifetime::as_string () const\n {\n   if (is_error ())\n-    {\n-      return \"error lifetime\";\n-    }\n+    return \"error lifetime\";\n \n   switch (lifetime_type)\n     {\n@@ -2689,17 +2520,15 @@ Lifetime::as_string () const\n std::string\n TypePath::as_string () const\n {\n+  /* TODO: this may need to be rewritten if a segment (e.g. function) can't be\n+   * literalised */\n   std::string str;\n \n   if (has_opening_scope_resolution)\n-    {\n-      str = \"::\";\n-    }\n+    str = \"::\";\n \n   for (const auto &segment : segments)\n-    {\n-      str += segment->as_string () + \"::\";\n-    }\n+    str += segment->as_string () + \"::\";\n \n   // kinda hack - remove last 2 '::' characters\n   str.erase (str.length () - 2);\n@@ -2714,13 +2543,9 @@ TypeParam::as_string () const\n \n   str += \"\\n Outer attribute: \";\n   if (!has_outer_attribute ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += outer_attr.as_string ();\n-    }\n+    str += outer_attr.as_string ();\n \n   str += \"\\n Identifier: \" + type_representation;\n \n@@ -2732,20 +2557,14 @@ TypeParam::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t{\n-\t  str += \"\\n  \" + bound->as_string ();\n-\t}\n+\tstr += \"\\n  \" + bound->as_string ();\n     }\n \n   str += \"\\n Type: \";\n   if (!has_type ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += type->as_string ();\n-    }\n+    str += type->as_string ();\n \n   return str;\n }\n@@ -2754,9 +2573,7 @@ SimplePath\n PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n {\n   if (!has_segments ())\n-    {\n-      return SimplePath::create_empty ();\n-    }\n+    return SimplePath::create_empty ();\n \n   // create vector of reserved size (to minimise reallocations)\n   std::vector<SimplePathSegment> simple_segments;\n@@ -2767,9 +2584,7 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n       // return empty path if doesn't meet simple path segment requirements\n       if (segment.is_error () || segment.has_generic_args ()\n \t  || segment.as_string () == \"Self\")\n-\t{\n-\t  return SimplePath::create_empty ();\n-\t}\n+\treturn SimplePath::create_empty ();\n \n       // create segment and add to vector\n       std::string segment_str = segment.as_string ();\n@@ -2780,13 +2595,10 @@ PathPattern::convert_to_simple_path (bool with_opening_scope_resolution) const\n   // kind of a HACK to get locus depending on opening scope resolution\n   Location locus = Linemap::unknown_location ();\n   if (with_opening_scope_resolution)\n-    {\n-      locus = simple_segments[0].get_locus () - 2; // minus 2 chars for ::\n-    }\n+    locus = simple_segments[0].get_locus () - 2; // minus 2 chars for ::\n   else\n-    {\n-      locus = simple_segments[0].get_locus ();\n-    }\n+    locus = simple_segments[0].get_locus ();\n+  // FIXME: this hack probably doesn't actually work\n \n   return SimplePath (std::move (simple_segments), with_opening_scope_resolution,\n \t\t     locus);\n@@ -2796,9 +2608,7 @@ SimplePath\n TypePath::as_simple_path () const\n {\n   if (segments.empty ())\n-    {\n-      return SimplePath::create_empty ();\n-    }\n+    return SimplePath::create_empty ();\n \n   // create vector of reserved size (to minimise reallocations)\n   std::vector<SimplePathSegment> simple_segments;\n@@ -2809,9 +2619,7 @@ TypePath::as_simple_path () const\n       // return empty path if doesn't meet simple path segment requirements\n       if (segment == nullptr || segment->is_error ()\n \t  || !segment->is_ident_only () || segment->as_string () == \"Self\")\n-\t{\n-\t  return SimplePath::create_empty ();\n-\t}\n+\treturn SimplePath::create_empty ();\n \n       // create segment and add to vector\n       std::string segment_str = segment->as_string ();\n@@ -2826,11 +2634,10 @@ TypePath::as_simple_path () const\n std::string\n PathExprSegment::as_string () const\n {\n+  // TODO: rewrite dump to work with non-literalisable types\n   std::string ident_str = segment_name.as_string ();\n   if (has_generic_args ())\n-    {\n-      ident_str += \"::<\" + generic_args.as_string () + \">\";\n-    }\n+    ident_str += \"::<\" + generic_args.as_string () + \">\";\n \n   return ident_str;\n }\n@@ -2888,23 +2695,22 @@ GenericArgs::as_string () const\n std::string\n GenericArgsBinding::as_string () const\n {\n+  // TODO: rewrite to work with non-literalisable types\n   return identifier + \" = \" + type->as_string ();\n }\n \n std::string\n ForLoopExpr::as_string () const\n {\n-  std::string str (\"ForLoopExpr: \");\n+  std::string str = \"ForLoopExpr: \";\n+\n+  str += append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += loop_label.as_string ();\n-    }\n+    str += loop_label.as_string ();\n \n   str += \"\\n Pattern: \" + pattern->as_string ();\n \n@@ -2918,14 +2724,11 @@ ForLoopExpr::as_string () const\n std::string\n RangePattern::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable bounds\n   if (has_ellipsis_syntax)\n-    {\n-      return lower->as_string () + \"...\" + upper->as_string ();\n-    }\n+    return lower->as_string () + \"...\" + upper->as_string ();\n   else\n-    {\n-      return lower->as_string () + \"..=\" + upper->as_string ();\n-    }\n+    return lower->as_string () + \"..=\" + upper->as_string ();\n }\n \n std::string\n@@ -2934,9 +2737,7 @@ RangePatternBoundLiteral::as_string () const\n   std::string str;\n \n   if (has_minus)\n-    {\n-      str += \"-\";\n-    }\n+    str += \"-\";\n \n   str += literal.as_string ();\n \n@@ -2949,9 +2750,7 @@ SlicePattern::as_string () const\n   std::string str (\"SlicePattern: \");\n \n   for (const auto &pattern : items)\n-    {\n-      str += \"\\n \" + pattern->as_string ();\n-    }\n+    str += \"\\n \" + pattern->as_string ();\n \n   return str;\n }\n@@ -2962,9 +2761,7 @@ TuplePatternItemsMultiple::as_string () const\n   std::string str;\n \n   for (const auto &pattern : patterns)\n-    {\n-      str += \"\\n \" + pattern->as_string ();\n-    }\n+    str += \"\\n \" + pattern->as_string ();\n \n   return str;\n }\n@@ -2982,9 +2779,7 @@ TuplePatternItemsRanged::as_string () const\n   else\n     {\n       for (const auto &lower : lower_patterns)\n-\t{\n-\t  str += \"\\n  \" + lower->as_string ();\n-\t}\n+\tstr += \"\\n  \" + lower->as_string ();\n     }\n \n   str += \"\\n Upper patterns: \";\n@@ -2995,9 +2790,7 @@ TuplePatternItemsRanged::as_string () const\n   else\n     {\n       for (const auto &upper : upper_patterns)\n-\t{\n-\t  str += \"\\n  \" + upper->as_string ();\n-\t}\n+\tstr += \"\\n  \" + upper->as_string ();\n     }\n \n   return str;\n@@ -3013,20 +2806,7 @@ std::string\n StructPatternField::as_string () const\n {\n   // outer attributes\n-  std::string str (\"Outer attributes: \");\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   return str;\n }\n@@ -3039,14 +2819,10 @@ StructPatternFieldIdent::as_string () const\n   str += \"\\n\";\n \n   if (has_ref)\n-    {\n-      str += \"ref \";\n-    }\n+    str += \"ref \";\n \n   if (has_mut)\n-    {\n-      str += \"mut \";\n-    }\n+    str += \"mut \";\n \n   str += ident;\n \n@@ -3056,6 +2832,7 @@ StructPatternFieldIdent::as_string () const\n std::string\n StructPatternFieldTuplePat::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str = StructPatternField::as_string ();\n \n   str += \"\\n\";\n@@ -3068,6 +2845,7 @@ StructPatternFieldTuplePat::as_string () const\n std::string\n StructPatternFieldIdentPat::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str = StructPatternField::as_string ();\n \n   str += \"\\n\";\n@@ -3089,20 +2867,14 @@ StructPatternElements::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t{\n-\t  str += \"\\n   \" + field->as_string ();\n-\t}\n+\tstr += \"\\n   \" + field->as_string ();\n     }\n \n   str += \"\\n  Etc: \";\n   if (has_struct_pattern_etc)\n-    {\n-      str += \"true\";\n-    }\n+    str += \"true\";\n   else\n-    {\n-      str += \"false\";\n-    }\n+    str += \"false\";\n \n   return str;\n }\n@@ -3116,13 +2888,9 @@ StructPattern::as_string () const\n \n   str += \"\\n Struct pattern elems: \";\n   if (!has_struct_pattern_elems ())\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n   else\n-    {\n-      str += elems.as_string ();\n-    }\n+    str += elems.as_string ();\n \n   return str;\n }\n@@ -3133,27 +2901,22 @@ LiteralPattern::as_string () const\n   std::string str;\n \n   if (has_minus)\n-    {\n-      str += \"-\";\n-    }\n+    str += \"-\";\n \n   return str + lit.as_string ();\n }\n \n std::string\n ReferencePattern::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str (\"&\");\n \n   if (has_two_amps)\n-    {\n-      str += \"&\";\n-    }\n+    str += \"&\";\n \n   if (is_mut)\n-    {\n-      str += \"mut \";\n-    }\n+    str += \"mut \";\n \n   str += pattern->as_string ();\n \n@@ -3163,24 +2926,19 @@ ReferencePattern::as_string () const\n std::string\n IdentifierPattern::as_string () const\n {\n+  // TODO: maybe rewrite to work with non-linearisable patterns\n   std::string str;\n \n   if (is_ref)\n-    {\n-      str += \"ref \";\n-    }\n+    str += \"ref \";\n \n   if (is_mut)\n-    {\n-      str += \"mut \";\n-    }\n+    str += \"mut \";\n \n   str += variable_ident;\n \n   if (has_pattern_to_bind ())\n-    {\n-      str += \" @ \" + to_bind->as_string ();\n-    }\n+    str += \" @ \" + to_bind->as_string ();\n \n   return str;\n }\n@@ -3191,9 +2949,7 @@ TupleStructItemsNoRange::as_string () const\n   std::string str;\n \n   for (const auto &pattern : patterns)\n-    {\n-      str += \"\\n  \" + pattern->as_string ();\n-    }\n+    str += \"\\n  \" + pattern->as_string ();\n \n   return str;\n }\n@@ -3210,9 +2966,7 @@ TupleStructItemsRange::as_string () const\n   else\n     {\n       for (const auto &lower : lower_patterns)\n-\t{\n-\t  str += \"\\n   \" + lower->as_string ();\n-\t}\n+\tstr += \"\\n   \" + lower->as_string ();\n     }\n \n   str += \"\\n  Upper patterns: \";\n@@ -3223,9 +2977,7 @@ TupleStructItemsRange::as_string () const\n   else\n     {\n       for (const auto &upper : upper_patterns)\n-\t{\n-\t  str += \"\\n   \" + upper->as_string ();\n-\t}\n+\tstr += \"\\n   \" + upper->as_string ();\n     }\n \n   return str;\n@@ -3246,58 +2998,16 @@ TupleStructPattern::as_string () const\n std::string\n LetStmt::as_string () const\n {\n-  // outer attributes\n-  std::string str = \"Outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      indent_spaces (enter);\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-\t}\n-      indent_spaces (out);\n-    }\n+  // TODO: rewrite to work with non-linearisable types and exprs\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n\" + indent_spaces (stay) + \"let \" + variables_pattern->as_string ();\n \n   if (has_type ())\n-    {\n-      str += \" : \" + type->as_string ();\n-    }\n+    str += \" : \" + type->as_string ();\n \n   if (has_init_expr ())\n-    {\n-      str += \" = \" + init_expr->as_string ();\n-    }\n-\n-  return str;\n-}\n-\n-// Used to get outer attributes for expressions.\n-std::string\n-Expr::as_string () const\n-{\n-  // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+    str += \" = \" + init_expr->as_string ();\n \n   return str;\n }\n@@ -3306,10 +3016,7 @@ Expr::as_string () const\n TraitBound *\n TypePath::to_trait_bound (bool in_parens) const\n {\n-  // create clone FIXME is this required? or is copy constructor automatically\n-  // called?\n-  TypePath copy (*this);\n-  return new TraitBound (std::move (copy), copy.get_locus (), in_parens);\n+  return new TraitBound (TypePath (*this), get_locus (), in_parens);\n }\n \n std::string\n@@ -3321,6 +3028,7 @@ InferredType::as_string () const\n std::string\n TypeCastExpr::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs and types\n   return main_or_left_expr->as_string () + \" as \"\n \t + type_to_convert_to->as_string ();\n }\n@@ -3337,9 +3045,7 @@ ImplTraitType::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t{\n-\t  str += \"\\n  \" + bound->as_string ();\n-\t}\n+\tstr += \"\\n  \" + bound->as_string ();\n     }\n \n   return str;\n@@ -3348,17 +3054,14 @@ ImplTraitType::as_string () const\n std::string\n ReferenceType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"&\");\n \n-  if (has_lifetime ())\n-    {\n-      str += lifetime.as_string () + \" \";\n-    }\n+  if (has_lifetime ())\n+    str += lifetime.as_string () + \" \";\n \n   if (has_mut)\n-    {\n-      str += \"mut \";\n-    }\n+    str += \"mut \";\n \n   str += type->as_string ();\n \n@@ -3368,6 +3071,7 @@ ReferenceType::as_string () const\n std::string\n RawPointerType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"*\");\n \n   switch (pointer_type)\n@@ -3393,13 +3097,9 @@ TraitObjectType::as_string () const\n   std::string str (\"TraitObjectType: \\n Has dyn dispatch: \");\n \n   if (has_dyn)\n-    {\n-      str += \"true\";\n-    }\n+    str += \"true\";\n   else\n-    {\n-      str += \"false\";\n-    }\n+    str += \"false\";\n \n   str += \"\\n TypeParamBounds: \";\n   if (type_param_bounds.empty ())\n@@ -3409,9 +3109,7 @@ TraitObjectType::as_string () const\n   else\n     {\n       for (const auto &bound : type_param_bounds)\n-\t{\n-\t  str += \"\\n  \" + bound->as_string ();\n-\t}\n+\tstr += \"\\n  \" + bound->as_string ();\n     }\n \n   return str;\n@@ -3429,9 +3127,7 @@ BareFunctionType::as_string () const\n   else\n     {\n       for (const auto &for_lifetime : for_lifetimes)\n-\t{\n-\t  str += \"\\n  \" + for_lifetime.as_string ();\n-\t}\n+\tstr += \"\\n  \" + for_lifetime.as_string ();\n     }\n \n   str += \"\\n Qualifiers: \" + function_qualifiers.as_string ();\n@@ -3444,30 +3140,20 @@ BareFunctionType::as_string () const\n   else\n     {\n       for (const auto &param : params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n \n   str += \"\\n Is variadic: \";\n   if (is_variadic)\n-    {\n-      str += \"true\";\n-    }\n+    str += \"true\";\n   else\n-    {\n-      str += \"false\";\n-    }\n+    str += \"false\";\n \n   str += \"\\n Return type: \";\n   if (!has_return_type ())\n-    {\n-      str += \"none (void)\";\n-    }\n+    str += \"none (void)\";\n   else\n-    {\n-      str += return_type->as_string ();\n-    }\n+    str += return_type->as_string ();\n \n   return str;\n }\n@@ -3483,6 +3169,7 @@ ImplTraitTypeOneBound::as_string () const\n std::string\n TypePathSegmentGeneric::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   return TypePathSegment::as_string () + \"<\" + generic_args.as_string () + \">\";\n }\n \n@@ -3492,13 +3179,9 @@ TraitObjectTypeOneBound::as_string () const\n   std::string str (\"TraitObjectTypeOneBound: \\n Has dyn dispatch: \");\n \n   if (has_dyn)\n-    {\n-      str += \"true\";\n-    }\n+    str += \"true\";\n   else\n-    {\n-      str += \"false\";\n-    }\n+    str += \"false\";\n \n   str += \"\\n TraitBound: \" + trait_bound.as_string ();\n \n@@ -3508,6 +3191,7 @@ TraitObjectTypeOneBound::as_string () const\n std::string\n TypePathFunction::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"(\");\n \n   if (has_inputs ())\n@@ -3526,34 +3210,36 @@ TypePathFunction::as_string () const\n   str += \")\";\n \n   if (has_return_type ())\n-    {\n-      str += \" -> \" + return_type->as_string ();\n-    }\n+    str += \" -> \" + return_type->as_string ();\n \n   return str;\n }\n \n std::string\n TypePathSegmentFunction::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   return TypePathSegment::as_string () + function_path.as_string ();\n }\n \n std::string\n ArrayType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types and exprs\n   return \"[\" + elem_type->as_string () + \"; \" + size->as_string () + \"]\";\n }\n \n std::string\n SliceType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   return \"[\" + elem_type->as_string () + \"]\";\n }\n \n std::string\n TupleType::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable types\n   std::string str (\"(\");\n \n   if (!is_unit_type ())\n@@ -3577,7 +3263,7 @@ TupleType::as_string () const\n std::string\n StructExpr::as_string () const\n {\n-  std::string str = ExprWithoutBlock::as_string ();\n+  std::string str = append_attributes (outer_attrs, OUTER);\n   indent_spaces (enter);\n   str += \"\\n\" + indent_spaces (stay) + \"StructExpr:\";\n   indent_spaces (enter);\n@@ -3604,9 +3290,7 @@ StructExprTuple::as_string () const\n \n       // debug - null pointer check\n       if (*i == nullptr)\n-\t{\n-\t  return \"ERROR_MARK_STRING - nullptr struct expr tuple field\";\n-\t}\n+\treturn \"ERROR_MARK_STRING - nullptr struct expr tuple field\";\n \n       str += '(';\n       for (; i != e; i++)\n@@ -3621,18 +3305,7 @@ StructExprTuple::as_string () const\n   indent_spaces (enter);\n   indent_spaces (enter);\n   // inner attributes\n-  str += \"\\n\" + indent_spaces (stay) + \"inner attributes:\";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n   indent_spaces (out);\n   indent_spaces (out);\n \n@@ -3642,23 +3315,13 @@ StructExprTuple::as_string () const\n std::string\n StructExprStruct::as_string () const\n {\n+  // TODO: doesn't this require data from StructExpr?\n   std::string str (\"StructExprStruct (or subclass): \");\n \n   str += \"\\n Path: \" + get_struct_name ().as_string ();\n \n   // inner attributes\n-  str += \"\\n inner attributes: \";\n-  if (inner_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"inner attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : inner_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  str += append_attributes (inner_attrs, INNER);\n \n   return str;\n }\n@@ -3682,12 +3345,14 @@ StructExprFieldWithVal::as_string () const\n std::string\n StructExprFieldIdentifierValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return field_name + \" : \" + StructExprFieldWithVal::as_string ();\n }\n \n std::string\n StructExprFieldIndexValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return std::to_string (index) + \" : \" + StructExprFieldWithVal::as_string ();\n }\n \n@@ -3719,7 +3384,7 @@ StructExprStructFields::as_string () const\n std::string\n EnumExprStruct::as_string () const\n {\n-  std::string str (\"StructExprStruct (or subclass): \");\n+  std::string str (\"EnumExprStruct (or subclass): \");\n \n   str += \"\\n Path: \" + get_enum_variant_path ().as_string ();\n \n@@ -3747,31 +3412,22 @@ EnumExprFieldWithVal::as_string () const\n std::string\n EnumExprFieldIdentifierValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return field_name + \" : \" + EnumExprFieldWithVal::as_string ();\n }\n \n std::string\n EnumExprFieldIndexValue::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   return std::to_string (index) + \" : \" + EnumExprFieldWithVal::as_string ();\n }\n \n std::string\n EnumItem::as_string () const\n {\n   // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n\" + variant_name;\n \n@@ -3809,26 +3465,13 @@ EnumItemTuple::as_string () const\n std::string\n TupleField::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n+\n   // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   if (has_visibility ())\n-    {\n-      str += \"\\n\" + visibility.as_string ();\n-    }\n+    str += \"\\n\" + visibility.as_string ();\n \n   str += \" \" + field_type->as_string ();\n \n@@ -3866,26 +3509,12 @@ EnumItemStruct::as_string () const\n std::string\n StructField::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   if (has_visibility ())\n-    {\n-      str += \"\\n\" + visibility.as_string ();\n-    }\n+    str += \"\\n\" + visibility.as_string ();\n \n   str += \" \" + field_name + \" : \" + field_type->as_string ();\n \n@@ -3895,6 +3524,7 @@ StructField::as_string () const\n std::string\n EnumItemDiscriminant::as_string () const\n {\n+  // TODO: rewrite to work with non-linearisable exprs\n   std::string str = EnumItem::as_string ();\n \n   // add equal and expression\n@@ -3903,47 +3533,11 @@ EnumItemDiscriminant::as_string () const\n   return str;\n }\n \n-#if 0\n-std::string\n-ExternalItem::as_string () const\n-{\n-  // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n-    }\n-\n-  // start visibility on new line and with a space\n-  str += \"\\n\" + visibility.as_string () + \" \";\n-\n-  return str;\n-}\n-#endif\n-\n std::string\n ExternalStaticItem::as_string () const\n {\n   // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n@@ -3966,18 +3560,7 @@ std::string\n ExternalFunctionItem::as_string () const\n {\n   // outer attributes\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n  \" + attr.as_string ();\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   // start visibility on new line and with a space\n   str += \"\\n\" + visibility.as_string () + \" \";\n@@ -4004,7 +3587,7 @@ ExternalFunctionItem::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in external function item.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -4054,17 +3637,7 @@ ExternalFunctionItem::as_string () const\n std::string\n NamedFunctionParam::as_string () const\n {\n-  std::string str = \"outer attributes: \";\n-\n-  if (!has_outer_attrs ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &attr : outer_attrs)\n-\tstr += \"\\n \" + attr.as_string ();\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n\" + name;\n \n@@ -4073,50 +3646,18 @@ NamedFunctionParam::as_string () const\n   return str;\n }\n \n-/*std::string TraitItem::as_string() const {\n-    // outer attributes\n-    std::string str = \"outer attributes: \";\n-    if (outer_attrs.empty()) {\n-\tstr += \"none\";\n-    } else {\n-\t// note that this does not print them with \"outer attribute\" syntax -\n-just the body for (const auto& attr : outer_attrs) { str += \"\\n  \" +\n-attr.as_string();\n-\t}\n-    }\n-\n-    return str;\n-}*/\n-\n std::string\n TraitItemFunc::as_string () const\n {\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n\" + decl.as_string ();\n \n   str += \"\\n Definition (block expr): \";\n   if (has_definition ())\n-    {\n-      str += block_expr->as_string ();\n-    }\n+    str += block_expr->as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   return str;\n }\n@@ -4143,7 +3684,7 @@ TraitFunctionDecl::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in trait function decl.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -4154,9 +3695,7 @@ TraitFunctionDecl::as_string () const\n   if (has_params ())\n     {\n       for (const auto &param : function_params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n   else\n     {\n@@ -4165,56 +3704,31 @@ TraitFunctionDecl::as_string () const\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-    {\n-      str += return_type->as_string ();\n-    }\n+    str += return_type->as_string ();\n   else\n-    {\n-      str += \"none (void)\";\n-    }\n+    str += \"none (void)\";\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   return str;\n }\n \n std::string\n TraitItemMethod::as_string () const\n {\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\n\" + decl.as_string ();\n \n   str += \"\\n Definition (block expr): \";\n   if (has_definition ())\n-    {\n-      str += block_expr->as_string ();\n-    }\n+    str += block_expr->as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   return str;\n }\n@@ -4241,7 +3755,7 @@ TraitMethodDecl::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"generic param in trait function decl.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + param->as_string ();\n@@ -4254,9 +3768,7 @@ TraitMethodDecl::as_string () const\n   if (has_params ())\n     {\n       for (const auto &param : function_params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n   else\n     {\n@@ -4265,72 +3777,37 @@ TraitMethodDecl::as_string () const\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-    {\n-      str += return_type->as_string ();\n-    }\n+    str += return_type->as_string ();\n   else\n-    {\n-      str += \"none (void)\";\n-    }\n+    str += \"none (void)\";\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n+    str += where_clause.as_string ();\n   else\n-    {\n-      str += \"none\";\n-    }\n+    str += \"none\";\n \n   return str;\n }\n \n std::string\n TraitItemConst::as_string () const\n {\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  // TODO: rewrite to work with non-linearisable exprs\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\nconst \" + name + \" : \" + type->as_string ();\n \n   if (has_expression ())\n-    {\n-      str += \" = \" + expr->as_string ();\n-    }\n+    str += \" = \" + expr->as_string ();\n \n   return str;\n }\n \n std::string\n TraitItemType::as_string () const\n {\n-  std::string str = \"outer attributes: \";\n-  if (outer_attrs.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      /* note that this does not print them with \"outer attribute\" syntax -\n-       * just the body */\n-      for (const auto &attr : outer_attrs)\n-\t{\n-\t  str += \"\\n  \" + attr.as_string ();\n-\t}\n-    }\n+  std::string str = append_attributes (outer_attrs, OUTER);\n \n   str += \"\\ntype \" + name;\n \n@@ -4350,7 +3827,7 @@ TraitItemType::as_string () const\n \t\tstderr,\n \t\t\"something really terrible has gone wrong - null pointer \"\n \t\t\"type param bound in trait item type.\");\n-\t      return \"nullptr_POINTER_MARK\";\n+\t      return \"NULL_POINTER_MARK\";\n \t    }\n \n \t  str += \"\\n  \" + bound->as_string ();\n@@ -4363,6 +3840,7 @@ TraitItemType::as_string () const\n std::string\n SelfParam::as_string () const\n {\n+  // TODO: rewrite to allow non-linearisable types\n   if (is_error ())\n     {\n       return \"error\";\n@@ -4375,9 +3853,7 @@ SelfParam::as_string () const\n \t  std::string str;\n \n \t  if (is_mut)\n-\t    {\n-\t      str += \"mut \";\n-\t    }\n+\t    str += \"mut \";\n \n \t  str += \"self : \";\n \n@@ -4391,9 +3867,7 @@ SelfParam::as_string () const\n \t  std::string str = \"&\" + lifetime.as_string () + \" \";\n \n \t  if (is_mut)\n-\t    {\n-\t      str += \"mut \";\n-\t    }\n+\t    str += \"mut \";\n \n \t  str += \"self\";\n \n@@ -4405,9 +3879,7 @@ SelfParam::as_string () const\n \t  std::string str = \"&\";\n \n \t  if (is_mut)\n-\t    {\n-\t      str += \" mut \";\n-\t    }\n+\t    str += \" mut \";\n \n \t  str += \"self\";\n \n@@ -4419,9 +3891,7 @@ SelfParam::as_string () const\n \t  std::string str;\n \n \t  if (is_mut)\n-\t    {\n-\t      str += \"mut \";\n-\t    }\n+\t    str += \"mut \";\n \n \t  str += \"self\";\n \n@@ -4433,6 +3903,7 @@ SelfParam::as_string () const\n std::string\n ArrayElemsCopied::as_string () const\n {\n+  // TODO: rewrite to allow non-linearisable exprs\n   return elem_to_copy->as_string () + \"; \" + num_copies->as_string ();\n }\n \n@@ -4446,9 +3917,7 @@ LifetimeWhereClauseItem::as_string () const\n   str += \"\\nLifetime bounds: \";\n \n   for (const auto &bound : lifetime_bounds)\n-    {\n-      str += \"\\n \" + bound.as_string ();\n-    }\n+    str += \"\\n \" + bound.as_string ();\n \n   return str;\n }\n@@ -4465,9 +3934,7 @@ TypeBoundWhereClauseItem::as_string () const\n   else\n     {\n       for (const auto &for_lifetime : for_lifetimes)\n-\t{\n-\t  str += \"\\n \" + for_lifetime.as_string ();\n-\t}\n+\tstr += \"\\n \" + for_lifetime.as_string ();\n     }\n \n   str += \"\\nType: \" + bound_type->as_string ();\n@@ -4478,9 +3945,7 @@ TypeBoundWhereClauseItem::as_string () const\n     {\n       // debug null pointer check\n       if (bound == nullptr)\n-\t{\n-\t  return \"nullptr_POINTER_MARK - type param bounds\";\n-\t}\n+\treturn \"NULL_POINTER_MARK - type param bounds\";\n \n       str += \"\\n \" + bound->as_string ();\n     }\n@@ -4501,7 +3966,7 @@ ArrayElemsValues::as_string () const\n \t  fprintf (stderr,\n \t\t   \"something really terrible has gone wrong - null pointer \"\n \t\t   \"expr in array elems values.\");\n-\t  return \"nullptr_POINTER_MARK\";\n+\t  return \"NULL_POINTER_MARK\";\n \t}\n \n       str += \"\\n  \" + expr->as_string ();\n@@ -4513,6 +3978,7 @@ ArrayElemsValues::as_string () const\n std::string\n MaybeNamedParam::as_string () const\n {\n+  // TODO: rewrite to allow using non-linearisable types in dump\n   std::string str;\n \n   switch (param_kind)\n@@ -4621,8 +4087,8 @@ ModuleBodied::add_crate_name (std::vector<std::string> &names) const\n void\n Attribute::parse_attr_to_meta_item ()\n {\n-  // only parse if has attribute input\n-  if (!has_attr_input ())\n+  // only parse if has attribute input and not already parsed\n+  if (!has_attr_input () || is_parsed_to_meta_item ())\n     return;\n \n   std::unique_ptr<AttrInput> converted_input (\n@@ -4632,7 +4098,7 @@ Attribute::parse_attr_to_meta_item ()\n     attr_input = std::move (converted_input);\n }\n \n-AttrInput *\n+AttrInputMetaItemContainer *\n DelimTokenTree::parse_to_meta_item () const\n {\n   // must have token trees\n@@ -4709,8 +4175,11 @@ MacroParser::parse_meta_item_inner ()\n \n \t  skip_token (2);\n \n+\t  // remove the quotes from the string value\n+\t  std::string raw_value = unquote_string (std::move (value));\n+\n \t  return std::unique_ptr<MetaNameValueStr> (\n-\t    new MetaNameValueStr (std::move (ident), std::move (value)));\n+\t    new MetaNameValueStr (std::move (ident), std::move (raw_value)));\n \t}\n       else\n \t{\n@@ -4831,7 +4300,7 @@ MacroParser::parse_path_meta_item ()\n \t\t\t   \"failed to parse literal in attribute\");\n \t    return nullptr;\n \t  }\n-\tLiteralExpr expr (std::move (lit), locus);\n+\tLiteralExpr expr (std::move (lit), {}, locus);\n \t// stream_pos++;\n \t/* shouldn't be required anymore due to parsing literal actually\n \t * skipping the token */\n@@ -4886,9 +4355,8 @@ MacroParser::parse_meta_item_seq ()\n       meta_items.push_back (std::move (inner));\n \n       if (peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n+\tbreak;\n+\n       skip_token ();\n     }\n \n@@ -4911,9 +4379,10 @@ DelimTokenTree::to_token_stream () const\n   std::vector<std::unique_ptr<Token> > tokens;\n \n   // simulate presence of delimiters\n+  const_TokenPtr left_paren\n+    = Rust::Token::make (LEFT_PAREN, Linemap::unknown_location ());\n   tokens.push_back (\n-    std::unique_ptr<Token> (new Token (LEFT_PAREN, Linemap::unknown_location (),\n-\t\t\t\t       \"\", CORETYPE_UNKNOWN)));\n+    std::unique_ptr<Token> (new Token (std::move (left_paren))));\n \n   for (const auto &tree : token_trees)\n     {\n@@ -4923,9 +4392,10 @@ DelimTokenTree::to_token_stream () const\n \t\t     std::make_move_iterator (stream.end ()));\n     }\n \n-  tokens.push_back (std::unique_ptr<Token> (\n-    new Token (RIGHT_PAREN, Linemap::unknown_location (), \"\",\n-\t       CORETYPE_UNKNOWN)));\n+  const_TokenPtr right_paren\n+    = Rust::Token::make (RIGHT_PAREN, Linemap::unknown_location ());\n+  tokens.push_back (\n+    std::unique_ptr<Token> (new Token (std::move (right_paren))));\n \n   tokens.shrink_to_fit ();\n \n@@ -5049,7 +4519,7 @@ std::unique_ptr<MetaItemLitExpr>\n MacroParser::parse_meta_item_lit ()\n {\n   Location locus = peek_token ()->get_locus ();\n-  LiteralExpr lit_expr (parse_literal (), locus);\n+  LiteralExpr lit_expr (parse_literal (), {}, locus);\n   return std::unique_ptr<MetaItemLitExpr> (\n     new MetaItemLitExpr (std::move (lit_expr)));\n }\n@@ -5063,6 +4533,12 @@ AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n   if (items.empty ())\n     return false;\n \n+  // DEBUG\n+  fprintf (stderr,\n+\t   \"asked to check cfg of attrinputmetaitemcontainer - delegating to \"\n+\t   \"first item. container: '%s'\\n\",\n+\t   as_string ().c_str ());\n+\n   return items[0]->check_cfg_predicate (session);\n \n   /*for (const auto &inner_item : items)\n@@ -5075,8 +4551,7 @@ AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n }\n \n bool\n-MetaItemLitExpr::check_cfg_predicate (\n-  const Session &session ATTRIBUTE_UNUSED) const\n+MetaItemLitExpr::check_cfg_predicate (const Session &) const\n {\n   /* as far as I can tell, a literal expr can never be a valid cfg body, so\n    * false */\n@@ -5183,10 +4658,7 @@ bool\n MetaListPaths::check_path_exists_in_cfg (const Session &session,\n \t\t\t\t\t const SimplePath &path) const\n {\n-  auto it = session.options.target_data.features.find (path.as_string ());\n-  if (it != session.options.target_data.features.end ())\n-    return true;\n-  return false;\n+  return session.options.target_data.has_key (path.as_string ());\n }\n \n bool\n@@ -5240,10 +4712,7 @@ MetaItemSeq::check_cfg_predicate (const Session &session) const\n bool\n MetaWord::check_cfg_predicate (const Session &session) const\n {\n-  auto it = session.options.target_data.features.find (ident);\n-  if (it != session.options.target_data.features.end ())\n-    return true;\n-  return false;\n+  return session.options.target_data.has_key (ident);\n }\n \n bool\n@@ -5253,15 +4722,20 @@ MetaItemPath::check_cfg_predicate (const Session &session) const\n    * relating to SimplePath being identifier. Currently, it would return true\n    * if path as identifier existed, and if the path in string form existed\n    * (though this shouldn't occur). */\n-  auto it = session.options.target_data.features.find (path.as_string ());\n-  if (it != session.options.target_data.features.end ())\n-    return true;\n-  return false;\n+  return session.options.target_data.has_key (path.as_string ());\n }\n \n bool\n MetaNameValueStr::check_cfg_predicate (const Session &session) const\n {\n+  // DEBUG\n+  fprintf (stderr,\n+\t   \"checked key-value pair for cfg: '%s', '%s' - is%s in target data\\n\",\n+\t   ident.c_str (), str.c_str (),\n+\t   session.options.target_data.has_key_value_pair (ident, str)\n+\t     ? \"\"\n+\t     : \" not\");\n+\n   return session.options.target_data.has_key_value_pair (ident, str);\n }\n \n@@ -5287,7 +4761,7 @@ Attribute\n MetaNameValueStr::to_attribute () const\n {\n   LiteralExpr lit_expr (str, Literal::LitType::STRING,\n-\t\t\tPrimitiveCoreType::CORETYPE_UNKNOWN, Location ());\n+\t\t\tPrimitiveCoreType::CORETYPE_UNKNOWN, {}, Location ());\n   return Attribute (SimplePath::from_str (ident),\n \t\t    std::unique_ptr<AttrInputLiteral> (\n \t\t      new AttrInputLiteral (std::move (lit_expr))));\n@@ -5375,8 +4849,8 @@ AttrInputMetaItemContainer::separate_cfg_attrs () const\n       Attribute attr = (*it)->to_attribute ();\n       if (attr.is_empty ())\n \t{\n-\t  // TODO should this be an error that causes us to chuck out\n-\t  // everything?\n+\t  /* TODO should this be an error that causes us to chuck out\n+\t   * everything? */\n \t  continue;\n \t}\n       attrs.push_back (std::move (attr));\n@@ -5387,34 +4861,48 @@ AttrInputMetaItemContainer::separate_cfg_attrs () const\n }\n \n bool\n-Attribute::check_cfg_predicate (const Session &session)\n+Attribute::check_cfg_predicate (const Session &session) const\n {\n   /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n    * cfg_attr path */\n   if (!has_attr_input ()\n       || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\"))\n-    return false;\n+    {\n+      // DEBUG message\n+      fprintf (stderr,\n+\t       \"tried to check cfg predicate on attr that either has no input \"\n+\t       \"or invalid path. attr: '%s'\\n\",\n+\t       as_string ().c_str ());\n+\n+      return false;\n+    }\n \n-  // TODO: maybe replace with storing a \"has been parsed\" variable?\n-  parse_attr_to_meta_item ();\n-  // can't be const because of this anyway\n+  // assume that it has already been parsed\n+  if (!is_parsed_to_meta_item ())\n+    return false;\n \n   return attr_input->check_cfg_predicate (session);\n }\n \n std::vector<Attribute>\n-Attribute::separate_cfg_attrs ()\n+Attribute::separate_cfg_attrs () const\n {\n   if (!has_attr_input () || path.as_string () != \"cfg_attr\")\n     return {};\n \n-  // TODO: maybe replace with storing a \"has been parsed\" variable?\n-  parse_attr_to_meta_item ();\n-  // can't be const because of this anyway\n+  // assume that it has already been parsed\n+  if (!is_parsed_to_meta_item ())\n+    return {};\n \n   return attr_input->separate_cfg_attrs ();\n }\n \n+bool\n+Attribute::is_parsed_to_meta_item () const\n+{\n+  return has_attr_input () && attr_input->is_meta_item ();\n+}\n+\n /* Visitor implementations - these are short but inlining can't happen anyway\n  * due to virtual functions and I didn't want to make the ast header includes\n  * any longer than they already are. */\n@@ -5875,18 +5363,6 @@ IfLetExprConseqIfLet::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-/*void\n-MatchCaseBlockExpr::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n-void\n-MatchCaseExpr::accept_vis (ASTVisitor &vis)\n-{\n-  vis.visit (*this);\n-}*/\n-\n void\n MatchExpr::accept_vis (ASTVisitor &vis)\n {"}, {"sha": "b34525e8bb0d34e9cc2a34c1b9c8937c355b3f32", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 272, "deletions": 277, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -129,6 +129,7 @@ class Token : public TokenTree, public MacroMatch\n {\n   // A token is a kind of token tree (except delimiter tokens)\n   // A token is a kind of MacroMatch (except $ and delimiter tokens)\n+#if 0\n   // TODO: improve member variables - current ones are the same as lexer token\n   // Token kind.\n   TokenId token_id;\n@@ -138,6 +139,13 @@ class Token : public TokenTree, public MacroMatch\n   std::string str;\n   // Token type hint (if any).\n   PrimitiveCoreType type_hint;\n+#endif\n+\n+  const_TokenPtr tok_ref;\n+\n+  /* new idea: wrapper around const_TokenPtr used for heterogeneuous storage in\n+   * token trees. rather than convert back and forth when parsing macros, just \n+   * wrap it. */\n \n public:\n   // Unique pointer custom clone function\n@@ -146,15 +154,19 @@ class Token : public TokenTree, public MacroMatch\n     return std::unique_ptr<Token> (clone_token_impl ());\n   }\n \n+#if 0\n   /* constructor from general text - avoid using if lexer const_TokenPtr is\n    * available */\n   Token (TokenId token_id, Location locus, std::string str,\n \t PrimitiveCoreType type_hint)\n     : token_id (token_id), locus (locus), str (std::move (str)),\n       type_hint (type_hint)\n   {}\n+#endif\n+  // not doable with new implementation - will have to make a const_TokenPtr\n \n   // Constructor from lexer const_TokenPtr\n+#if 0\n   /* TODO: find workaround for std::string being nullptr - probably have to\n    * introduce new method in lexer Token, or maybe make conversion method\n    * there */\n@@ -188,10 +200,12 @@ class Token : public TokenTree, public MacroMatch\n \t\t lexer_token_ptr->get_token_description ());\n       }\n   }\n+#endif\n+  Token (const_TokenPtr lexer_tok_ptr) : tok_ref (std::move (lexer_tok_ptr)) {}\n \n   bool is_string_lit () const\n   {\n-    switch (token_id)\n+    switch (get_id ())\n       {\n       case STRING_LITERAL:\n       case BYTE_STRING_LITERAL:\n@@ -208,23 +222,29 @@ class Token : public TokenTree, public MacroMatch\n   // Return copy of itself but in token stream form.\n   std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n \n-  TokenId get_id () const { return token_id; }\n+  TokenId get_id () const { return tok_ref->get_id (); }\n \n-  Location get_locus () const { return locus; }\n+  Location get_locus () const { return tok_ref->get_locus (); }\n \n-  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+  PrimitiveCoreType get_type_hint () const { return tok_ref->get_type_hint (); }\n+\n+  // Get a new token pointer copy.\n+  const_TokenPtr get_tok_ptr () const { return tok_ref; }\n \n protected:\n   // No virtual for now as not polymorphic but can be in future\n   /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  Token *clone_token_tree_impl () const override { return clone_token_impl (); }\n+  Token *clone_token_tree_impl () const final override\n+  {\n+    return clone_token_impl ();\n+  }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  Token *clone_macro_match_impl () const override\n+  Token *clone_macro_match_impl () const final override\n   {\n     return clone_token_impl ();\n   }\n@@ -372,6 +392,13 @@ class SimplePath\n   }\n };\n \n+// path-to-string inverse comparison operator\n+inline bool\n+operator!= (const SimplePath &lhs, const std::string &rhs)\n+{\n+  return !(lhs == rhs);\n+}\n+\n // forward decl for Attribute\n class AttrInput;\n \n@@ -402,27 +429,9 @@ struct Attribute\n   // default destructor\n   ~Attribute () = default;\n \n-  // Copy constructor must deep copy attr_input as unique pointer\n-  /*Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n-  {\n-    // guard to protect from null pointer dereference\n-    if (other.attr_input != nullptr)\n-      attr_input = other.attr_input->clone_attr_input ();\n-  }*/\n   // no point in being defined inline as requires virtual call anyway\n   Attribute (const Attribute &other);\n \n-  // overload assignment operator to use custom clone method\n-  /*Attribute &operator= (Attribute const &other)\n-  {\n-    path = other.path;\n-    locus = other.locus;\n-    // guard to protect from null pointer dereference\n-    if (other.attr_input != nullptr)\n-      attr_input = other.attr_input->clone_attr_input ();\n-\n-    return *this;\n-  }*/\n   // no point in being defined inline as requires virtual call anyway\n   Attribute &operator= (const Attribute &other);\n \n@@ -499,7 +508,7 @@ struct Attribute\n \n   std::string as_string () const;\n \n-  // TODO: does this require visitor pattern as not polymorphic?\n+  // no visitor pattern as not currently polymorphic\n \n   const SimplePath &get_path () const { return path; }\n   SimplePath &get_path () { return path; }\n@@ -508,10 +517,15 @@ struct Attribute\n   void parse_attr_to_meta_item ();\n \n   /* Determines whether cfg predicate is true and item with attribute should not\n-   * be stripped. */\n-  bool check_cfg_predicate (const Session &session);\n+   * be stripped. Attribute body must already be parsed to meta item. */\n+  bool check_cfg_predicate (const Session &session) const;\n \n-  std::vector<Attribute> separate_cfg_attrs ();\n+  // Returns whether body has been parsed to meta item form or not.\n+  bool is_parsed_to_meta_item () const;\n+\n+  /* Returns any attributes generated from cfg_attr attributes. Attribute body\n+   * must already be parsed to meta item. */\n+  std::vector<Attribute> separate_cfg_attrs () const;\n \n protected:\n   // not virtual as currently no subclasses of Attribute, but could be in future\n@@ -544,99 +558,14 @@ class AttrInput\n \n   virtual std::vector<Attribute> separate_cfg_attrs () const { return {}; }\n \n+  // Returns whether attr input has been parsed to meta item syntax.\n+  virtual bool is_meta_item () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual AttrInput *clone_attr_input_impl () const = 0;\n };\n \n-// A token tree with delimiters\n-class DelimTokenTree : public TokenTree, public AttrInput\n-{\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree> > token_trees;\n-  Location locus;\n-\n-protected:\n-  DelimTokenTree *clone_delim_tok_tree_impl () const\n-  {\n-    return new DelimTokenTree (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_attr_input_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_token_tree_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-public:\n-  DelimTokenTree (DelimType delim_type,\n-\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n-\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n-\t\t  Location locus = Location ())\n-    : delim_type (delim_type), token_trees (std::move (token_trees)),\n-      locus (locus)\n-  {}\n-\n-  // Copy constructor with vector clone\n-  DelimTokenTree (DelimTokenTree const &other)\n-    : delim_type (other.delim_type), locus (other.locus)\n-  {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-  }\n-\n-  // overloaded assignment operator with vector clone\n-  DelimTokenTree &operator= (DelimTokenTree const &other)\n-  {\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n-\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  DelimTokenTree (DelimTokenTree &&other) = default;\n-  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n-\n-  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  bool check_cfg_predicate (const Session &) const override\n-  {\n-    // this should never be called - should be converted first\n-    return false;\n-  }\n-\n-  AttrInput *parse_to_meta_item () const override;\n-\n-  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n-\n-  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n-  {\n-    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n-  }\n-};\n-\n-/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n- * be defined */\n-class AttrInputLiteral;\n-\n // Forward decl - defined in rust-macro.h\n class MetaNameValueStr;\n \n@@ -689,7 +618,26 @@ class AttrInputMetaItemContainer : public AttrInput\n     : items (std::move (items))\n   {}\n \n-  // no destructor definition required\n+  // copy constructor with vector clone\n+  AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // copy assignment operator with vector clone\n+  AttrInputMetaItemContainer &\n+  operator= (const AttrInputMetaItemContainer &other)\n+  {\n+    AttrInput::operator= (other);\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n \n   // default move constructors\n   AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n@@ -712,9 +660,18 @@ class AttrInputMetaItemContainer : public AttrInput\n \n   std::vector<Attribute> separate_cfg_attrs () const override;\n \n+  bool is_meta_item () const override { return true; }\n+\n+  // TODO: this mutable getter seems dodgy\n+  std::vector<std::unique_ptr<MetaItemInner> > &get_items () { return items; }\n+  const std::vector<std::unique_ptr<MetaItemInner> > &get_items () const\n+  {\n+    return items;\n+  }\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n-  AttrInputMetaItemContainer *clone_attr_input_impl () const override\n+  AttrInputMetaItemContainer *clone_attr_input_impl () const final override\n   {\n     return clone_attr_input_meta_item_container_impl ();\n   }\n@@ -723,29 +680,99 @@ class AttrInputMetaItemContainer : public AttrInput\n   {\n     return new AttrInputMetaItemContainer (*this);\n   }\n+};\n \n-  // copy constructor with vector clone\n-  AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+protected:\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n   {\n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_meta_item_inner ());\n+    return new DelimTokenTree (*this);\n   }\n \n-  // copy assignment operator with vector clone\n-  AttrInputMetaItemContainer &\n-  operator= (const AttrInputMetaItemContainer &other)\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const final override\n   {\n-    AttrInput::operator= (other);\n+    return clone_delim_tok_tree_impl ();\n+  }\n \n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_meta_item_inner ());\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const final override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n \n     return *this;\n   }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &) const override\n+  {\n+    // this should never be called - should be converted first\n+    rust_assert (false);\n+    return false;\n+  }\n+\n+  AttrInputMetaItemContainer *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n+\n+  bool is_meta_item () const override { return false; }\n };\n \n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n // abstract base meta item class\n class MetaItem : public MetaItemInner\n {\n@@ -816,8 +843,6 @@ class Item : public Stmt\n     return std::unique_ptr<Item> (clone_item_impl ());\n   }\n \n-  std::string as_string () const = 0;\n-\n   /* Adds crate names to the vector passed by reference, if it can\n    * (polymorphism). TODO: remove, unused. */\n   virtual void\n@@ -840,14 +865,7 @@ class ExprWithoutBlock;\n // Base expression AST node - abstract\n class Expr\n {\n-  // TODO: move outer attribute data to derived classes?\n-  std::vector<Attribute> outer_attrs;\n-\n public:\n-  // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n-  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n-\n   // Unique pointer custom clone function\n   std::unique_ptr<Expr> clone_expr () const\n   {\n@@ -863,8 +881,7 @@ class Expr\n    * overrided in subclasses of ExprWithoutBlock */\n   virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n \n-  // TODO: make pure virtual if move out outer attributes to derived classes\n-  virtual std::string as_string () const;\n+  virtual std::string as_string () const = 0;\n \n   virtual ~Expr () {}\n \n@@ -886,20 +903,14 @@ class Expr\n \n protected:\n   // Constructor\n-  Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : outer_attrs (std::move (outer_attribs)),\n-      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n-  {}\n+  Expr () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n \n   // Clone function implementation as pure virtual method\n   virtual Expr *clone_expr_impl () const = 0;\n \n   // TODO: think of less hacky way to implement this kind of thing\n   // Sets outer attributes.\n-  void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)\n-  {\n-    outer_attrs = std::move (outer_attrs_to_set);\n-  }\n+  virtual void set_outer_attrs (std::vector<Attribute>) = 0;\n \n   NodeId node_id;\n };\n@@ -908,12 +919,6 @@ class Expr\n class ExprWithoutBlock : public Expr\n {\n protected:\n-  // Constructor\n-  ExprWithoutBlock (std::vector<Attribute> outer_attribs\n-\t\t    = std::vector<Attribute> ())\n-    : Expr (std::move (outer_attribs))\n-  {}\n-\n   // pure virtual clone implementation\n   virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n \n@@ -936,7 +941,7 @@ class ExprWithoutBlock : public Expr\n \n   /* downcasting hack from expr to use pratt parsing with\n    * parse_expr_without_block */\n-  ExprWithoutBlock *as_expr_without_block () const override\n+  ExprWithoutBlock *as_expr_without_block () const final override\n   {\n     return clone_expr_without_block_impl ();\n   }\n@@ -948,21 +953,21 @@ class ExprWithoutBlock : public Expr\n  */\n class IdentifierExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   Identifier ident;\n   Location locus;\n \n public:\n-  IdentifierExpr (Identifier ident, Location locus = Location (),\n-\t\t  std::vector<Attribute> outer_attrs\n-\t\t  = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attrs)), ident (std::move (ident)),\n+  IdentifierExpr (Identifier ident, std::vector<Attribute> outer_attrs,\n+\t\t  Location locus)\n+    : outer_attrs (std::move (outer_attrs)), ident (std::move (ident)),\n       locus (locus)\n   {}\n \n   std::string as_string () const override { return ident; }\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return locus; }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   Identifier get_ident () const { return ident; }\n \n@@ -978,9 +983,17 @@ class IdentifierExpr : public ExprWithoutBlock\n   void mark_for_strip () override { ident = {}; }\n   bool is_marked_for_strip () const override { return ident.empty (); }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n+\n protected:\n   // Clone method implementation\n-  IdentifierExpr *clone_expr_without_block_impl () const override\n+  IdentifierExpr *clone_expr_without_block_impl () const final override\n   {\n     return clone_identifier_expr_impl ();\n   }\n@@ -1205,15 +1218,8 @@ class GenericParam\n class LifetimeParam : public GenericParam\n {\n   Lifetime lifetime;\n-\n-  // bool has_lifetime_bounds;\n-  // LifetimeBounds lifetime_bounds;\n-  std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n-\n-  // bool has_outer_attribute;\n-  // std::unique_ptr<Attribute> outer_attr;\n+  std::vector<Lifetime> lifetime_bounds; \n   Attribute outer_attr;\n-\n   Location locus;\n \n public:\n@@ -1226,45 +1232,21 @@ class LifetimeParam : public GenericParam\n   // Creates an error state lifetime param.\n   static LifetimeParam create_error ()\n   {\n-    return LifetimeParam (Lifetime::error ());\n+    return LifetimeParam (Lifetime::error (), {}, Attribute::create_empty (), Location ());\n   }\n \n   // Returns whether the lifetime param is in an error state.\n   bool is_error () const { return lifetime.is_error (); }\n \n   // Constructor\n-  LifetimeParam (Lifetime lifetime, Location locus = Location (),\n-\t\t std::vector<Lifetime> lifetime_bounds\n-\t\t = std::vector<Lifetime> (),\n-\t\t Attribute outer_attr = Attribute::create_empty ())\n+  LifetimeParam (Lifetime lifetime, \n+\t\t std::vector<Lifetime> lifetime_bounds,\n+\t\t Attribute outer_attr, Location locus)\n     : lifetime (std::move (lifetime)),\n       lifetime_bounds (std::move (lifetime_bounds)),\n       outer_attr (std::move (outer_attr)), locus (locus)\n   {}\n \n-  // TODO: remove copy and assignment operator definitions - not required\n-\n-  // Copy constructor with clone\n-  LifetimeParam (LifetimeParam const &other)\n-    : lifetime (other.lifetime), lifetime_bounds (other.lifetime_bounds),\n-      outer_attr (other.outer_attr), locus (other.locus)\n-  {}\n-\n-  // Overloaded assignment operator to clone attribute\n-  LifetimeParam &operator= (LifetimeParam const &other)\n-  {\n-    lifetime = other.lifetime;\n-    lifetime_bounds = other.lifetime_bounds;\n-    outer_attr = other.outer_attr;\n-    locus = other.locus;\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  LifetimeParam (LifetimeParam &&other) = default;\n-  LifetimeParam &operator= (LifetimeParam &&other) = default;\n-\n   std::string as_string () const override;\n \n   void accept_vis (ASTVisitor &vis) override;\n@@ -1278,28 +1260,13 @@ class LifetimeParam : public GenericParam\n   }\n };\n \n-// A macro item AST node - potentially abstract base class\n+// A macro item AST node - abstract base class\n class MacroItem : public Item\n-{\n-  /*public:\n-  std::string as_string() const;*/\n-  // std::vector<Attribute> outer_attrs;\n-\n-protected:\n-  /*MacroItem (std::vector<Attribute> outer_attribs)\n-    : outer_attrs (std::move (outer_attribs))\n-  {}*/\n-};\n+{};\n \n // Item used in trait declarations - abstract base class\n class TraitItem\n {\n-  // bool has_outer_attrs;\n-  // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n-  // std::vector<Attribute> outer_attrs;\n-\n-  // NOTE: all children should have outer attributes\n-\n protected:\n   // Clone function implementation as pure virtual method\n   virtual TraitItem *clone_trait_item_impl () const = 0;\n@@ -1395,65 +1362,105 @@ class ExternalItem\n   virtual ExternalItem *clone_external_item_impl () const = 0;\n };\n \n-/* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n- * invocation) */\n-class MacroInvocationSemi : public MacroItem,\n-\t\t\t    public TraitItem,\n-\t\t\t    public InherentImplItem,\n-\t\t\t    public TraitImplItem,\n-\t\t\t    public ExternalItem\n+/* Data structure to store the data used in macro invocations and macro\n+ * invocations with semicolons. */\n+struct MacroInvocData\n {\n-  std::vector<Attribute> outer_attrs;\n+private:\n   SimplePath path;\n-  // all delim types except curly must have invocation end with a semicolon\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree> > token_trees;\n-  Location locus;\n+  DelimTokenTree token_tree;\n+\n+  // One way of parsing the macro. Probably not applicable for all macros.\n+  std::vector<std::unique_ptr<MetaItemInner> > parsed_items;\n+  bool parsed_to_meta_item = false;\n \n public:\n-  std::string as_string () const override;\n+  std::string as_string () const;\n \n-  MacroInvocationSemi (SimplePath macro_path, DelimType delim_type,\n-\t\t       std::vector<std::unique_ptr<TokenTree> > token_trees,\n-\t\t       std::vector<Attribute> outer_attribs, Location locus)\n-    : outer_attrs (std::move (outer_attribs)), path (std::move (macro_path)),\n-      delim_type (delim_type), token_trees (std::move (token_trees)),\n-      locus (locus)\n+  MacroInvocData (SimplePath path, DelimTokenTree token_tree)\n+    : path (std::move (path)), token_tree (std::move (token_tree))\n   {}\n \n   // Copy constructor with vector clone\n-  MacroInvocationSemi (MacroInvocationSemi const &other)\n-    : MacroItem (other), TraitItem (other), InherentImplItem (other),\n-      TraitImplItem (other), outer_attrs (other.outer_attrs), path (other.path),\n-      delim_type (other.delim_type), locus (other.locus)\n+  MacroInvocData (const MacroInvocData &other)\n+    : path (other.path), token_tree (other.token_tree),\n+      parsed_to_meta_item (other.parsed_to_meta_item)\n   {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n+    parsed_items.reserve (other.parsed_items.size ());\n+    for (const auto &e : other.parsed_items)\n+      parsed_items.push_back (e->clone_meta_item_inner ());\n   }\n \n-  // Overloaded assignment operator to vector clone\n-  MacroInvocationSemi &operator= (MacroInvocationSemi const &other)\n+  // Copy assignment operator with vector clone\n+  MacroInvocData &operator= (const MacroInvocData &other)\n   {\n-    MacroItem::operator= (other);\n-    TraitItem::operator= (other);\n-    InherentImplItem::operator= (other);\n-    TraitImplItem::operator= (other);\n-    outer_attrs = other.outer_attrs;\n     path = other.path;\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n+    token_tree = other.token_tree;\n+    parsed_to_meta_item = other.parsed_to_meta_item;\n \n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n+    parsed_items.reserve (other.parsed_items.size ());\n+    for (const auto &e : other.parsed_items)\n+      parsed_items.push_back (e->clone_meta_item_inner ());\n \n     return *this;\n   }\n \n   // Move constructors\n-  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n-  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n+  MacroInvocData (MacroInvocData &&other) = default;\n+  MacroInvocData &operator= (MacroInvocData &&other) = default;\n+\n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () { path = SimplePath::create_empty (); }\n+  bool is_marked_for_strip () const { return path.is_empty (); }\n+\n+  // Returns whether the macro has been parsed already.\n+  bool is_parsed () const { return parsed_to_meta_item; }\n+  // TODO: update on other ways of parsing it\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  DelimTokenTree &get_delim_tok_tree () { return token_tree; }\n+  const DelimTokenTree &get_delim_tok_tree () const { return token_tree; }\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  SimplePath &get_path () { return path; }\n+  const SimplePath &get_path () const { return path; }\n+\n+  void\n+  set_meta_item_output (std::vector<std::unique_ptr<MetaItemInner> > new_items)\n+  {\n+    parsed_items = std::move (new_items);\n+  }\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items ()\n+  {\n+    return parsed_items;\n+  }\n+  const std::vector<std::unique_ptr<MetaItemInner> > &get_meta_items () const\n+  {\n+    return parsed_items;\n+  }\n+};\n+\n+/* A macro invocation item (or statement) AST node (i.e. semi-coloned macro\n+ * invocation) */\n+class MacroInvocationSemi : public MacroItem,\n+\t\t\t    public TraitItem,\n+\t\t\t    public InherentImplItem,\n+\t\t\t    public TraitImplItem,\n+\t\t\t    public ExternalItem\n+{\n+  std::vector<Attribute> outer_attrs;\n+  MacroInvocData invoc_data;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroInvocationSemi (MacroInvocData invoc_data,\n+\t\t       std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      invoc_data (std::move (invoc_data)), locus (locus)\n+  {}\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1464,9 +1471,11 @@ class MacroInvocationSemi : public MacroItem,\n       clone_macro_invocation_semi_impl ());\n   }\n \n-  // Invalid if path is empty, so base stripping on that.\n-  void mark_for_strip () override { path = SimplePath::create_empty (); }\n-  bool is_marked_for_strip () const override { return path.is_empty (); }\n+  void mark_for_strip () override { invoc_data.mark_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return invoc_data.is_marked_for_strip ();\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n@@ -1484,35 +1493,35 @@ class MacroInvocationSemi : public MacroItem,\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocationSemi *clone_item_impl () const override\n+  MacroInvocationSemi *clone_item_impl () const final override\n   {\n     return clone_macro_invocation_semi_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocationSemi *clone_inherent_impl_item_impl () const override\n+  MacroInvocationSemi *clone_inherent_impl_item_impl () const final override\n   {\n     return clone_macro_invocation_semi_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocationSemi *clone_trait_impl_item_impl () const override\n+  MacroInvocationSemi *clone_trait_impl_item_impl () const final override\n   {\n     return clone_macro_invocation_semi_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocationSemi *clone_trait_item_impl () const override\n+  MacroInvocationSemi *clone_trait_item_impl () const final override\n   {\n     return clone_macro_invocation_semi_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocationSemi *clone_external_item_impl () const override\n+  MacroInvocationSemi *clone_external_item_impl () const final override\n   {\n     return clone_macro_invocation_semi_impl ();\n   }\n@@ -1593,20 +1602,6 @@ struct Crate\n // Base path expression AST node - abstract\n class PathExpr : public ExprWithoutBlock\n {\n-protected:\n-  PathExpr (std::vector<Attribute> outer_attribs)\n-    : ExprWithoutBlock (std::move (outer_attribs))\n-  {}\n-\n-public:\n-  // TODO: think of a better and less hacky way to allow this\n-\n-  /* Replaces the outer attributes of this path expression with the given outer\n-   * attributes. */\n-  void replace_outer_attrs (std::vector<Attribute> outer_attrs)\n-  {\n-    set_outer_attrs (std::move (outer_attrs));\n-  }\n };\n } // namespace AST\n } // namespace Rust"}, {"sha": "5366fac85808a6dc1122407d89a3678c5507768e", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 274, "deletions": 172, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -13,12 +13,7 @@ namespace AST {\n // AST node for an expression with an accompanying block - abstract\n class ExprWithBlock : public Expr\n {\n-  // TODO: should this mean that a BlockExpr should be a member variable?\n protected:\n-  ExprWithBlock (std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : Expr (std::move (outer_attrs))\n-  {}\n-\n   // pure virtual clone implementation\n   virtual ExprWithBlock *clone_expr_with_block_impl () const = 0;\n \n@@ -41,6 +36,7 @@ class ExprWithBlock : public Expr\n // Literals? Or literal base?\n class LiteralExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   Literal literal;\n   Location locus;\n \n@@ -50,15 +46,15 @@ class LiteralExpr : public ExprWithoutBlock\n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n \n   LiteralExpr (std::string value_as_string, Literal::LitType type,\n-\t       PrimitiveCoreType type_hint, Location locus,\n-\t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attrs)),\n+\t       PrimitiveCoreType type_hint,\n+\t       std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n       literal (std::move (value_as_string), type, type_hint), locus (locus)\n   {}\n \n-  LiteralExpr (Literal literal, Location locus,\n-\t       std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attrs)), literal (std::move (literal)),\n+  LiteralExpr (Literal literal,\n+\t       std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), literal (std::move (literal)),\n       locus (locus)\n   {}\n \n@@ -69,7 +65,7 @@ class LiteralExpr : public ExprWithoutBlock\n   }\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   Literal get_literal () const { return literal; }\n \n@@ -79,10 +75,15 @@ class LiteralExpr : public ExprWithoutBlock\n   void mark_for_strip () override { literal = Literal::create_error (); }\n   bool is_marked_for_strip () const override { return literal.is_error (); }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  LiteralExpr *clone_expr_without_block_impl () const override\n+  LiteralExpr *clone_expr_without_block_impl () const final override\n   {\n     return clone_literal_expr_impl ();\n   }\n@@ -121,6 +122,8 @@ class AttrInputLiteral : public AttrInput\n    * cfg */\n   bool check_cfg_predicate (const Session &) const override { return false; }\n \n+  bool is_meta_item () const override { return false; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -194,20 +197,21 @@ class OperatorExpr : public ExprWithoutBlock\n   Location locus;\n \n protected:\n-  /* Variable must be protected to allow derived classes to use it as a first\n-   * class citizen */\n+  /* Variables must be protected to allow derived classes to use them as first\n+   * class citizens */\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> main_or_left_expr;\n \n   // Constructor (only for initialisation of expr purposes)\n   OperatorExpr (std::unique_ptr<Expr> main_or_left_expr,\n \t\tstd::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)), locus (locus),\n+    : locus (locus), outer_attrs (std::move (outer_attribs)),\n       main_or_left_expr (std::move (main_or_left_expr))\n   {}\n \n   // Copy constructor (only for initialisation of expr purposes)\n   OperatorExpr (OperatorExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : locus (other.locus), outer_attrs (other.outer_attrs)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.main_or_left_expr != nullptr)\n@@ -219,7 +223,7 @@ class OperatorExpr : public ExprWithoutBlock\n   {\n     ExprWithoutBlock::operator= (other);\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.main_or_left_expr != nullptr)\n@@ -236,14 +240,19 @@ class OperatorExpr : public ExprWithoutBlock\n \n public:\n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   // Invalid if expr is null, so base stripping on that.\n   void mark_for_strip () override { main_or_left_expr = nullptr; }\n   bool is_marked_for_strip () const override\n   {\n     return main_or_left_expr == nullptr;\n   }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n /* Unary prefix & or &mut (or && and &&mut) borrow operator. Cannot be\n@@ -857,9 +866,9 @@ class CompoundAssignmentExpr : public OperatorExpr\n // Expression in parentheses (i.e. like literally just any 3 + (2 * 6))\n class GroupedExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n   std::unique_ptr<Expr> expr_in_parens;\n-\n   Location locus;\n \n public:\n@@ -868,17 +877,22 @@ class GroupedExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   GroupedExpr (std::unique_ptr<Expr> parenthesised_expr,\n \t       std::vector<Attribute> inner_attribs,\n \t       std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       expr_in_parens (std::move (parenthesised_expr)), locus (locus)\n   {}\n \n   // Copy constructor includes clone for expr_in_parens\n   GroupedExpr (GroupedExpr const &other)\n-    : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -892,7 +906,7 @@ class GroupedExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.expr_in_parens != nullptr)\n@@ -908,7 +922,7 @@ class GroupedExpr : public ExprWithoutBlock\n   GroupedExpr &operator= (GroupedExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1089,9 +1103,9 @@ class ArrayElemsCopied : public ArrayElems\n // Array definition-ish expression\n class ArrayExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n   std::unique_ptr<ArrayElems> internal_elements;\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -1103,21 +1117,26 @@ class ArrayExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   // Returns whether array expr has array elems or if it is just empty.\n   bool has_array_elems () const { return internal_elements != nullptr; }\n \n   // Constructor requires ArrayElems pointer\n   ArrayExpr (std::unique_ptr<ArrayElems> array_elems,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       internal_elements (std::move (array_elems)), locus (locus)\n   {}\n \n   // Copy constructor requires cloning ArrayElems for polymorphism to hold\n   ArrayExpr (ArrayExpr const &other)\n-    : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     if (other.has_array_elems ())\n@@ -1131,7 +1150,7 @@ class ArrayExpr : public ExprWithoutBlock\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     if (other.has_array_elems ())\n       internal_elements = other.internal_elements->clone_array_elems ();\n@@ -1146,7 +1165,7 @@ class ArrayExpr : public ExprWithoutBlock\n   ArrayExpr &operator= (ArrayExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1177,9 +1196,9 @@ class ArrayExpr : public ExprWithoutBlock\n  * implementation */\n class ArrayIndexExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> array_expr;\n   std::unique_ptr<Expr> index_expr;\n-\n   Location locus;\n \n public:\n@@ -1188,14 +1207,14 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   ArrayIndexExpr (std::unique_ptr<Expr> array_expr,\n \t\t  std::unique_ptr<Expr> array_index_expr,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       array_expr (std::move (array_expr)),\n       index_expr (std::move (array_index_expr)), locus (locus)\n   {}\n \n   // Copy constructor requires special cloning due to unique_ptr\n   ArrayIndexExpr (ArrayIndexExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.array_expr != nullptr)\n@@ -1208,7 +1227,7 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   ArrayIndexExpr &operator= (ArrayIndexExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -1229,7 +1248,7 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   ArrayIndexExpr &operator= (ArrayIndexExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1258,6 +1277,11 @@ class ArrayIndexExpr : public ExprWithoutBlock\n     return index_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1270,11 +1294,9 @@ class ArrayIndexExpr : public ExprWithoutBlock\n // AST representation of a tuple\n class TupleExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n-\n   std::vector<std::unique_ptr<Expr> > tuple_elems;\n-  // replaces (inlined version of) TupleElements\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -1286,17 +1308,22 @@ class TupleExpr : public ExprWithoutBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   TupleExpr (std::vector<std::unique_ptr<Expr> > tuple_elements,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       tuple_elems (std::move (tuple_elements)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   TupleExpr (TupleExpr const &other)\n-    : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     tuple_elems.reserve (other.tuple_elems.size ());\n@@ -1308,6 +1335,7 @@ class TupleExpr : public ExprWithoutBlock\n   TupleExpr &operator= (TupleExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n@@ -1327,7 +1355,7 @@ class TupleExpr : public ExprWithoutBlock\n    * comma, i.e. (0,) rather than (0) */\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1360,6 +1388,7 @@ class TupleExpr : public ExprWithoutBlock\n // AST representation of a tuple indexing expression\n class TupleIndexExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> tuple_expr;\n   // TupleIndex is a decimal int literal with no underscores or suffix\n   TupleIndex tuple_index;\n@@ -1375,13 +1404,13 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   TupleIndexExpr (std::unique_ptr<Expr> tuple_expr, TupleIndex index,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       tuple_expr (std::move (tuple_expr)), tuple_index (index), locus (locus)\n   {}\n \n   // Copy constructor requires a clone for tuple_expr\n   TupleIndexExpr (TupleIndexExpr const &other)\n-    : ExprWithoutBlock (other), tuple_index (other.tuple_index),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), tuple_index (other.tuple_index),\n       locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -1395,7 +1424,7 @@ class TupleIndexExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     tuple_index = other.tuple_index;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.tuple_expr != nullptr)\n@@ -1411,7 +1440,7 @@ class TupleIndexExpr : public ExprWithoutBlock\n   TupleIndexExpr &operator= (TupleIndexExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1426,6 +1455,11 @@ class TupleIndexExpr : public ExprWithoutBlock\n     return tuple_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1438,13 +1472,14 @@ class TupleIndexExpr : public ExprWithoutBlock\n // Base struct/tuple/union value creator AST node (abstract)\n class StructExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   PathInExpression struct_name;\n \n protected:\n   // Protected constructor to allow initialising struct_name\n   StructExpr (PathInExpression struct_path,\n \t      std::vector<Attribute> outer_attribs)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       struct_name (std::move (struct_path))\n   {}\n \n@@ -1460,6 +1495,11 @@ class StructExpr : public ExprWithoutBlock\n     struct_name = PathInExpression::create_error ();\n   }\n   bool is_marked_for_strip () const override { return struct_name.is_error (); }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n // Actual AST node of the struct creator (with no fields). Not abstract!\n@@ -1484,7 +1524,7 @@ class StructExprStruct : public StructExpr\n   {}\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1885,7 +1925,7 @@ class StructExprTuple : public StructExpr\n   StructExprTuple &operator= (StructExprTuple &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1922,7 +1962,7 @@ class StructExprUnit : public StructExpr\n   {}\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -1939,13 +1979,14 @@ class StructExprUnit : public StructExpr\n // Base AST node representing creation of an enum variant instance - abstract\n class EnumVariantExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   PathInExpression enum_variant_path;\n \n protected:\n   // Protected constructor for initialising enum_variant_path\n   EnumVariantExpr (PathInExpression path_to_enum_variant,\n \t\t   std::vector<Attribute> outer_attribs)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       enum_variant_path (std::move (path_to_enum_variant))\n   {}\n \n@@ -1965,6 +2006,11 @@ class EnumVariantExpr : public ExprWithoutBlock\n   {\n     return enum_variant_path.is_error ();\n   }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n /* Base AST node for a single enum expression field (in enum instance creation)\n@@ -2162,7 +2208,7 @@ class EnumExprStruct : public EnumVariantExpr\n   EnumExprStruct &operator= (EnumExprStruct &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -2186,7 +2232,6 @@ class EnumExprStruct : public EnumVariantExpr\n class EnumExprTuple : public EnumVariantExpr\n {\n   std::vector<std::unique_ptr<Expr> > values;\n-\n   Location locus;\n \n public:\n@@ -2227,7 +2272,7 @@ class EnumExprTuple : public EnumVariantExpr\n   EnumExprTuple &operator= (EnumExprTuple &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -2266,7 +2311,7 @@ class EnumExprFieldless : public EnumVariantExpr\n   {}\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -2285,10 +2330,9 @@ class Function;\n // Function call expression AST node\n class CallExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> function;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n-\n   Location locus;\n \n public:\n@@ -2299,14 +2343,14 @@ class CallExpr : public ExprWithoutBlock\n   CallExpr (std::unique_ptr<Expr> function_expr,\n \t    std::vector<std::unique_ptr<Expr> > function_params,\n \t    std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       function (std::move (function_expr)),\n       params (std::move (function_params)), locus (locus)\n   {}\n \n   // copy constructor requires clone\n   CallExpr (CallExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.function != nullptr)\n@@ -2322,7 +2366,7 @@ class CallExpr : public ExprWithoutBlock\n   {\n     ExprWithoutBlock::operator= (other);\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.function != nullptr)\n@@ -2345,7 +2389,7 @@ class CallExpr : public ExprWithoutBlock\n   bool has_params () const { return !params.empty (); }\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -2376,6 +2420,11 @@ class CallExpr : public ExprWithoutBlock\n     return function;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2388,11 +2437,10 @@ class CallExpr : public ExprWithoutBlock\n // Method call expression AST node\n class MethodCallExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> receiver;\n   PathExprSegment method_name;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n-\n   Location locus;\n \n public:\n@@ -2402,15 +2450,15 @@ class MethodCallExpr : public ExprWithoutBlock\n \t\t  PathExprSegment method_path,\n \t\t  std::vector<std::unique_ptr<Expr> > method_params,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       receiver (std::move (call_receiver)),\n       method_name (std::move (method_path)), params (std::move (method_params)),\n       locus (locus)\n   {}\n \n   // copy constructor required due to cloning\n   MethodCallExpr (MethodCallExpr const &other)\n-    : ExprWithoutBlock (other), method_name (other.method_name),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), method_name (other.method_name),\n       locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -2428,7 +2476,7 @@ class MethodCallExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     method_name = other.method_name;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2448,7 +2496,7 @@ class MethodCallExpr : public ExprWithoutBlock\n   MethodCallExpr &operator= (MethodCallExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -2482,6 +2530,11 @@ class MethodCallExpr : public ExprWithoutBlock\n   const PathExprSegment &get_method_name () const { return method_name; }\n   PathExprSegment &get_method_name () { return method_name; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2495,9 +2548,9 @@ class MethodCallExpr : public ExprWithoutBlock\n // Struct or union field access expression AST node\n class FieldAccessExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> receiver;\n   Identifier field;\n-\n   Location locus;\n \n public:\n@@ -2506,14 +2559,14 @@ class FieldAccessExpr : public ExprWithoutBlock\n   FieldAccessExpr (std::unique_ptr<Expr> field_access_receiver,\n \t\t   Identifier field_name, std::vector<Attribute> outer_attribs,\n \t\t   Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       receiver (std::move (field_access_receiver)),\n       field (std::move (field_name)), locus (locus)\n   {}\n \n   // Copy constructor required due to unique_ptr cloning\n   FieldAccessExpr (FieldAccessExpr const &other)\n-    : ExprWithoutBlock (other), field (other.field), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), field (other.field), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2526,7 +2579,7 @@ class FieldAccessExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     field = other.field;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n@@ -2542,7 +2595,7 @@ class FieldAccessExpr : public ExprWithoutBlock\n   FieldAccessExpr &operator= (FieldAccessExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -2559,6 +2612,11 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   Identifier get_field_name () const { return field; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2657,29 +2715,32 @@ struct ClosureParam\n // Base closure definition expression AST node - abstract\n class ClosureExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   bool has_move;\n   std::vector<ClosureParam> params; // may be empty\n-  /* also note a double pipe \"||\" can be used for empty params - does not need a\n-   * space */\n-\n   Location locus;\n \n protected:\n   ClosureExpr (std::vector<ClosureParam> closure_params, bool has_move,\n \t       std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attribs)), has_move (has_move),\n+    : outer_attrs (std::move (outer_attribs)), has_move (has_move),\n       params (std::move (closure_params)), locus (locus)\n   {}\n \n public:\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<ClosureParam> &get_params () const { return params; }\n   std::vector<ClosureParam> &get_params () { return params; }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n // Represents a non-type-specified closure expression AST node\n@@ -2758,13 +2819,10 @@ class ClosureExprInner : public ClosureExpr\n // A block AST node\n class BlockExpr : public ExprWithBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::vector<Attribute> inner_attrs;\n-\n-  // bool has_statements;\n   std::vector<std::unique_ptr<Stmt> > statements;\n-  // bool has_expr;\n-  std::unique_ptr<ExprWithoutBlock> expr; // inlined from Statements\n-\n+  std::unique_ptr<ExprWithoutBlock> expr; \n   Location locus;\n   bool marked_for_strip = false;\n \n@@ -2781,15 +2839,15 @@ class BlockExpr : public ExprWithBlock\n \t     std::unique_ptr<ExprWithoutBlock> block_expr,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       statements (std::move (block_statements)), expr (std::move (block_expr)),\n       locus (locus)\n   {}\n \n   // Copy constructor with clone\n   BlockExpr (BlockExpr const &other)\n-    : ExprWithBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n@@ -2808,7 +2866,7 @@ class BlockExpr : public ExprWithBlock\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to protect from null pointer dereference\n     if (other.expr != nullptr)\n@@ -2873,10 +2931,15 @@ class BlockExpr : public ExprWithBlock\n   // Removes the tail expression from the block.\n   void strip_tail_expr () { expr = nullptr; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  BlockExpr *clone_expr_with_block_impl () const override\n+  BlockExpr *clone_expr_with_block_impl () const final override\n   {\n     return clone_block_expr_impl ();\n   }\n@@ -2982,7 +3045,7 @@ class ClosureExprInnerTyped : public ClosureExpr\n // AST node representing continue expression within loops\n class ContinueExpr : public ExprWithoutBlock\n {\n-  // bool has_label;\n+  std::vector<Attribute> outer_attrs;\n   Lifetime label;\n   Location locus;\n \n@@ -2996,22 +3059,26 @@ class ContinueExpr : public ExprWithoutBlock\n   bool has_label () const { return !label.is_error (); }\n \n   // Constructor for a ContinueExpr with a label.\n-  ContinueExpr (Location locus, Lifetime label = Lifetime::error (),\n-\t\tstd::vector<Attribute> outer_attribs\n-\t\t= std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attribs)), label (std::move (label)),\n+  ContinueExpr (Lifetime label,\n+\t\tstd::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)), label (std::move (label)),\n       locus (locus)\n   {}\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n   // Can't think of any invalid invariants, so store boolean.\n   void mark_for_strip () override { marked_for_strip = true; }\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3025,12 +3092,9 @@ class ContinueExpr : public ExprWithoutBlock\n // AST node representing break expression within loops\n class BreakExpr : public ExprWithoutBlock\n {\n-  // bool has_label;\n+  std::vector<Attribute> outer_attrs;\n   Lifetime label;\n-\n-  // bool has_break_expr;\n   std::unique_ptr<Expr> break_expr;\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -3047,17 +3111,17 @@ class BreakExpr : public ExprWithoutBlock\n   bool has_break_expr () const { return break_expr != nullptr; }\n \n   // Constructor for a break expression\n-  BreakExpr (Location locus, Lifetime break_label = Lifetime::error (),\n-\t     std::unique_ptr<Expr> expr_in_break = nullptr,\n-\t     std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+  BreakExpr (Lifetime break_label,\n+\t     std::unique_ptr<Expr> expr_in_break,\n+\t     std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)),\n       label (std::move (break_label)), break_expr (std::move (expr_in_break)),\n       locus (locus)\n   {}\n \n   // Copy constructor defined to use clone for unique pointer\n   BreakExpr (BreakExpr const &other)\n-    : ExprWithoutBlock (other), label (other.label), locus (other.locus),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), label (other.label), locus (other.locus),\n       marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n@@ -3072,7 +3136,7 @@ class BreakExpr : public ExprWithoutBlock\n     label = other.label;\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to protect from null pointer dereference\n     if (other.break_expr != nullptr)\n@@ -3088,7 +3152,7 @@ class BreakExpr : public ExprWithoutBlock\n   BreakExpr &operator= (BreakExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -3099,10 +3163,15 @@ class BreakExpr : public ExprWithoutBlock\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_break_expr ()\n   {\n-    rust_assert (break_expr != nullptr);\n+    rust_assert (has_break_expr ());\n     return break_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  \n   Lifetime &get_label () { return label; }\n \n protected:\n@@ -3121,13 +3190,14 @@ class RangeExpr : public ExprWithoutBlock\n \n protected:\n   // outer attributes not allowed before range expressions\n-  RangeExpr (Location locus)\n-    : ExprWithoutBlock (std::vector<Attribute> ()), locus (locus)\n-  {}\n+  RangeExpr (Location locus) : locus (locus) {}\n \n public:\n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n+\n+  // should never be called - error if called\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { rust_assert (false); }\n };\n \n // Range from (inclusive) and to (exclusive) expression AST node object\n@@ -3515,8 +3585,8 @@ class RangeToInclExpr : public RangeExpr\n // Return expression AST node representation\n class ReturnExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> return_expr;\n-\n   Location locus;\n \n   // TODO: find another way to store this to save memory?\n@@ -3530,15 +3600,15 @@ class ReturnExpr : public ExprWithoutBlock\n   bool has_returned_expr () const { return return_expr != nullptr; }\n \n   // Constructor for ReturnExpr.\n-  ReturnExpr (Location locus, std::unique_ptr<Expr> returned_expr = nullptr,\n-\t      std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : ExprWithoutBlock (std::move (outer_attribs)),\n+  ReturnExpr (std::unique_ptr<Expr> returned_expr,\n+\t      std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)),\n       return_expr (std::move (returned_expr)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   ReturnExpr (ReturnExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus),\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus),\n       marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n@@ -3552,7 +3622,7 @@ class ReturnExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     locus = other.locus;\n     marked_for_strip = other.marked_for_strip;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to protect from null pointer dereference\n     if (other.return_expr != nullptr)\n@@ -3568,7 +3638,7 @@ class ReturnExpr : public ExprWithoutBlock\n   ReturnExpr &operator= (ReturnExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -3583,6 +3653,11 @@ class ReturnExpr : public ExprWithoutBlock\n     return return_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3598,6 +3673,7 @@ class MacroInvocation;\n // An unsafe block AST node\n class UnsafeBlockExpr : public ExprWithBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   // Or just have it extend BlockExpr\n   std::unique_ptr<BlockExpr> expr;\n   Location locus;\n@@ -3607,13 +3683,13 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   UnsafeBlockExpr (std::unique_ptr<BlockExpr> block_expr,\n \t\t   std::vector<Attribute> outer_attribs, Location locus)\n-    : ExprWithBlock (std::move (outer_attribs)), expr (std::move (block_expr)),\n+    : outer_attrs (std::move (outer_attribs)), expr (std::move (block_expr)),\n       locus (locus)\n   {}\n \n   // Copy constructor with clone\n   UnsafeBlockExpr (UnsafeBlockExpr const &other)\n-    : ExprWithBlock (other), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -3625,7 +3701,7 @@ class UnsafeBlockExpr : public ExprWithBlock\n   {\n     ExprWithBlock::operator= (other);\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -3641,7 +3717,7 @@ class UnsafeBlockExpr : public ExprWithBlock\n   UnsafeBlockExpr &operator= (UnsafeBlockExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -3656,6 +3732,11 @@ class UnsafeBlockExpr : public ExprWithBlock\n     return expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3700,9 +3781,8 @@ class BaseLoopExpr : public ExprWithBlock\n {\n protected:\n   // protected to allow subclasses better use of them\n-  // bool has_loop_label;\n+  std::vector<Attribute> outer_attrs;\n   LoopLabel loop_label;\n-\n   std::unique_ptr<BlockExpr> loop_block;\n \n private:\n@@ -3714,14 +3794,14 @@ class BaseLoopExpr : public ExprWithBlock\n \t\tLoopLabel loop_label = LoopLabel::error (),\n \t\tstd::vector<Attribute> outer_attribs\n \t\t= std::vector<Attribute> ())\n-    : ExprWithBlock (std::move (outer_attribs)),\n+    : outer_attrs (std::move (outer_attribs)),\n       loop_label (std::move (loop_label)), loop_block (std::move (loop_block)),\n       locus (locus)\n   {}\n \n   // Copy constructor for BaseLoopExpr with clone\n   BaseLoopExpr (BaseLoopExpr const &other)\n-    : ExprWithBlock (other), loop_label (other.loop_label), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), loop_label (other.loop_label), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.loop_block != nullptr)\n@@ -3734,7 +3814,7 @@ class BaseLoopExpr : public ExprWithBlock\n     ExprWithBlock::operator= (other);\n     loop_label = other.loop_label;\n     locus = other.locus;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.loop_block != nullptr)\n@@ -3755,7 +3835,7 @@ class BaseLoopExpr : public ExprWithBlock\n   LoopLabel &get_loop_label () { return loop_label; }\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   // Invalid if loop block is null, so base stripping on that.\n   void mark_for_strip () override { loop_block = nullptr; }\n@@ -3767,6 +3847,11 @@ class BaseLoopExpr : public ExprWithBlock\n     rust_assert (loop_block != nullptr);\n     return loop_block;\n   }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n };\n \n // 'Loop' expression (i.e. the infinite loop) AST node\n@@ -4010,24 +4095,23 @@ class IfLetExpr;\n // Base if expression with no \"else\" or \"if let\" AST node\n class IfExpr : public ExprWithBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> condition;\n   std::unique_ptr<BlockExpr> if_block;\n-\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n   IfExpr (std::unique_ptr<Expr> condition, std::unique_ptr<BlockExpr> if_block,\n-\t  Location locus)\n-    : ExprWithBlock (std::vector<Attribute> ()),\n-      condition (std::move (condition)), if_block (std::move (if_block)),\n+\t  std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), condition (std::move (condition)), if_block (std::move (if_block)),\n       locus (locus)\n   {}\n   // outer attributes are never allowed on IfExprs\n \n   // Copy constructor with clone\n-  IfExpr (IfExpr const &other) : ExprWithBlock (other), locus (other.locus)\n+  IfExpr (IfExpr const &other) : ExprWithBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.condition != nullptr)\n@@ -4040,6 +4124,7 @@ class IfExpr : public ExprWithBlock\n   IfExpr &operator= (IfExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -4070,7 +4155,7 @@ class IfExpr : public ExprWithBlock\n    * better approach? or does it not parse correctly and have downsides? */\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -4102,6 +4187,12 @@ class IfExpr : public ExprWithBlock\n     return if_block == nullptr && condition == nullptr;\n   }\n \n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n protected:\n   // Base clone function but still concrete as concrete base class\n   virtual IfExpr *clone_if_expr_impl () const { return new IfExpr (*this); }\n@@ -4124,8 +4215,8 @@ class IfExprConseqElse : public IfExpr\n \n   IfExprConseqElse (std::unique_ptr<Expr> condition,\n \t\t    std::unique_ptr<BlockExpr> if_block,\n-\t\t    std::unique_ptr<BlockExpr> else_block, Location locus)\n-    : IfExpr (std::move (condition), std::move (if_block), locus),\n+\t\t    std::unique_ptr<BlockExpr> else_block, std::vector<Attribute> outer_attrs, Location locus)\n+    : IfExpr (std::move (condition), std::move (if_block), std::move (outer_attrs), locus),\n       else_block (std::move (else_block))\n   {}\n   // again, outer attributes not allowed\n@@ -4180,8 +4271,8 @@ class IfExprConseqIf : public IfExpr\n \n   IfExprConseqIf (std::unique_ptr<Expr> condition,\n \t\t  std::unique_ptr<BlockExpr> if_block,\n-\t\t  std::unique_ptr<IfExpr> conseq_if_expr, Location locus)\n-    : IfExpr (std::move (condition), std::move (if_block), locus),\n+\t\t  std::unique_ptr<IfExpr> conseq_if_expr, std::vector<Attribute> outer_attrs, Location locus)\n+    : IfExpr (std::move (condition), std::move (if_block), std::move (outer_attrs), locus),\n       conseq_if_expr (std::move (conseq_if_expr))\n   {}\n   // outer attributes not allowed\n@@ -4232,7 +4323,7 @@ class IfExprConseqIf : public IfExpr\n // Basic \"if let\" expression AST node with no else\n class IfLetExpr : public ExprWithBlock\n {\n-  // MatchArmPatterns patterns;\n+  std::vector<Attribute> outer_attrs;\n   std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n   std::unique_ptr<Expr> value;\n   std::unique_ptr<BlockExpr> if_block;\n@@ -4242,17 +4333,16 @@ class IfLetExpr : public ExprWithBlock\n   std::string as_string () const override;\n \n   IfLetExpr (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n-\t     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n+\t     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block, std::vector<Attribute> outer_attrs,\n \t     Location locus)\n-    : ExprWithBlock (std::vector<Attribute> ()),\n-      match_arm_patterns (std::move (match_arm_patterns)),\n+    : match_arm_patterns (std::move (match_arm_patterns)),\n       value (std::move (value)), if_block (std::move (if_block)), locus (locus)\n   {}\n   // outer attributes not allowed on if let exprs either\n \n   // copy constructor with clone\n   IfLetExpr (IfLetExpr const &other)\n-    : ExprWithBlock (other), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.value != nullptr)\n@@ -4269,6 +4359,7 @@ class IfLetExpr : public ExprWithBlock\n   IfLetExpr &operator= (IfLetExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -4299,7 +4390,7 @@ class IfLetExpr : public ExprWithBlock\n   }\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -4338,6 +4429,12 @@ class IfLetExpr : public ExprWithBlock\n     return match_arm_patterns;\n   }\n \n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base (or rather this or any derived object) */\n@@ -4363,9 +4460,9 @@ class IfExprConseqIfLet : public IfExpr\n \n   IfExprConseqIfLet (std::unique_ptr<Expr> condition,\n \t\t     std::unique_ptr<BlockExpr> if_block,\n-\t\t     std::unique_ptr<IfLetExpr> conseq_if_let_expr,\n+\t\t     std::unique_ptr<IfLetExpr> conseq_if_let_expr, std::vector<Attribute> outer_attrs,\n \t\t     Location locus)\n-    : IfExpr (std::move (condition), std::move (if_block), locus),\n+    : IfExpr (std::move (condition), std::move (if_block), std::move (outer_attrs), locus),\n       if_let_expr (std::move (conseq_if_let_expr))\n   {}\n   // outer attributes not allowed\n@@ -4420,9 +4517,9 @@ class IfLetExprConseqElse : public IfLetExpr\n   IfLetExprConseqElse (\n     std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n-    std::unique_ptr<BlockExpr> else_block, Location locus)\n+    std::unique_ptr<BlockExpr> else_block, std::vector<Attribute> outer_attrs, Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n-\t\t std::move (if_block), locus),\n+\t\t std::move (if_block), std::move (outer_attrs), locus),\n       else_block (std::move (else_block))\n   {}\n   // outer attributes not allowed\n@@ -4479,9 +4576,9 @@ class IfLetExprConseqIf : public IfLetExpr\n   IfLetExprConseqIf (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t\t     std::unique_ptr<Expr> value,\n \t\t     std::unique_ptr<BlockExpr> if_block,\n-\t\t     std::unique_ptr<IfExpr> if_expr, Location locus)\n+\t\t     std::unique_ptr<IfExpr> if_expr, std::vector<Attribute> outer_attrs, Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n-\t\t std::move (if_block), locus),\n+\t\t std::move (if_block), std::move (outer_attrs), locus),\n       if_expr (std::move (if_expr))\n   {}\n   // again, outer attributes not allowed\n@@ -4537,9 +4634,9 @@ class IfLetExprConseqIfLet : public IfLetExpr\n   IfLetExprConseqIfLet (\n     std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n-    std::unique_ptr<IfLetExpr> if_let_expr, Location locus)\n+    std::unique_ptr<IfLetExpr> if_let_expr, std::vector<Attribute> outer_attrs, Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n-\t\t std::move (if_block), locus),\n+\t\t std::move (if_block), std::move (outer_attrs), locus),\n       if_let_expr (std::move (if_let_expr))\n   {}\n   // outer attributes not allowed\n@@ -4849,15 +4946,10 @@ class MatchCaseExpr : public MatchCase\n // Match expression AST node\n class MatchExpr : public ExprWithBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> branch_value;\n   std::vector<Attribute> inner_attrs;\n-\n-  // bool has_match_arms;\n-  // MatchArms match_arms;\n-  // std::vector<std::unique_ptr<MatchCase> > match_arms; // inlined from\n-  // MatchArms\n   std::vector<MatchCase> match_arms;\n-\n   Location locus;\n \n public:\n@@ -4867,28 +4959,23 @@ class MatchExpr : public ExprWithBlock\n   bool has_match_arms () const { return !match_arms.empty (); }\n \n   MatchExpr (std::unique_ptr<Expr> branch_value,\n-\t     // std::vector<std::unique_ptr<MatchCase> > match_arms,\n \t     std::vector<MatchCase> match_arms,\n \t     std::vector<Attribute> inner_attrs,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithBlock (std::move (outer_attrs)),\n+    : outer_attrs (std::move (outer_attrs)),\n       branch_value (std::move (branch_value)),\n       inner_attrs (std::move (inner_attrs)),\n       match_arms (std::move (match_arms)), locus (locus)\n   {}\n \n   // Copy constructor requires clone due to unique_ptr\n   MatchExpr (MatchExpr const &other)\n-    : ExprWithBlock (other), inner_attrs (other.inner_attrs),\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), inner_attrs (other.inner_attrs),\n       match_arms (other.match_arms), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.branch_value != nullptr)\n       branch_value = other.branch_value->clone_expr ();\n-\n-    /*match_arms.reserve (other.match_arms.size ());\n-    for (const auto &e : other.match_arms)\n-      match_arms.push_back (e->clone_match_case ());*/\n   }\n \n   // Overloaded assignment operator to clone due to unique_ptr\n@@ -4897,7 +4984,7 @@ class MatchExpr : public ExprWithBlock\n     ExprWithBlock::operator= (other);\n     inner_attrs = other.inner_attrs;\n     match_arms = other.match_arms;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -4906,10 +4993,6 @@ class MatchExpr : public ExprWithBlock\n     else\n       branch_value = nullptr;\n \n-    /*match_arms.reserve (other.match_arms.size ());\n-    for (const auto &e : other.match_arms)\n-      match_arms.push_back (e->clone_match_case ());*/\n-\n     return *this;\n   }\n \n@@ -4918,7 +5001,7 @@ class MatchExpr : public ExprWithBlock\n   MatchExpr &operator= (MatchExpr &&other) = default;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -4930,6 +5013,11 @@ class MatchExpr : public ExprWithBlock\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_scrutinee_expr ()\n   {\n@@ -4952,20 +5040,21 @@ class MatchExpr : public ExprWithBlock\n // Await expression AST node (pseudo-member variable access)\n class AwaitExpr : public ExprWithoutBlock\n {\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Expr> awaited_expr;\n   Location locus;\n \n public:\n   // TODO: ensure outer attributes are actually allowed\n   AwaitExpr (std::unique_ptr<Expr> awaited_expr,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attrs)),\n+    : outer_attrs (std::move (outer_attrs)),\n       awaited_expr (std::move (awaited_expr)), locus (locus)\n   {}\n \n   // copy constructor with clone\n   AwaitExpr (AwaitExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : ExprWithoutBlock (other), outer_attrs (other.outer_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.awaited_expr != nullptr)\n@@ -4976,6 +5065,7 @@ class AwaitExpr : public ExprWithoutBlock\n   AwaitExpr &operator= (AwaitExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference (only required if error state)\n@@ -4994,7 +5084,7 @@ class AwaitExpr : public ExprWithoutBlock\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -5009,6 +5099,11 @@ class AwaitExpr : public ExprWithoutBlock\n     return awaited_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -5022,20 +5117,21 @@ class AwaitExpr : public ExprWithoutBlock\n class AsyncBlockExpr : public ExprWithBlock\n {\n   // TODO: should this extend BlockExpr rather than be a composite of it?\n+  std::vector<Attribute> outer_attrs;\n   bool has_move;\n   std::unique_ptr<BlockExpr> block_expr;\n   Location locus;\n \n public:\n   AsyncBlockExpr (std::unique_ptr<BlockExpr> block_expr, bool has_move,\n \t\t  std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithBlock (std::move (outer_attrs)), has_move (has_move),\n+    : outer_attrs (std::move (outer_attrs)), has_move (has_move),\n       block_expr (std::move (block_expr)), locus (locus)\n   {}\n \n   // copy constructor with clone\n   AsyncBlockExpr (AsyncBlockExpr const &other)\n-    : ExprWithBlock (other), has_move (other.has_move), locus (other.locus)\n+    : ExprWithBlock (other), outer_attrs (other.outer_attrs), has_move (other.has_move), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.block_expr != nullptr)\n@@ -5046,6 +5142,7 @@ class AsyncBlockExpr : public ExprWithBlock\n   AsyncBlockExpr &operator= (AsyncBlockExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     has_move = other.has_move;\n     locus = other.locus;\n \n@@ -5065,7 +5162,7 @@ class AsyncBlockExpr : public ExprWithBlock\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -5080,6 +5177,11 @@ class AsyncBlockExpr : public ExprWithBlock\n     return block_expr;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "a6f5398218fa68a85967d7607af8ea59165ecc08", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -149,7 +149,7 @@ class TypeParam : public GenericParam\n   }\n \n protected:\n-  // Clone function implementation as (not pure) virtual method\n+  // Clone function implementation as virtual method\n   TypeParam *clone_generic_param_impl () const override\n   {\n     return new TypeParam (*this);\n@@ -891,17 +891,19 @@ class Method : public InherentImplItem, public TraitImplItem\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n-  Method *clone_inherent_impl_item_impl () const override\n+  Method *clone_inherent_impl_item_impl () const final override\n   {\n-    return new Method (*this);\n+    return clone_method_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n-  Method *clone_trait_impl_item_impl () const override\n+  Method *clone_trait_impl_item_impl () const final override\n   {\n-    return new Method (*this);\n+    return clone_method_impl ();\n   }\n+\n+  /*virtual*/ Method *clone_method_impl () const { return new Method (*this); }\n };\n \n // Item that supports visibility - abstract base class"}, {"sha": "51220e470033f4e74d65fac7e7c05435b3f48977", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 96, "deletions": 20, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -316,6 +316,12 @@ class MacroRulesDefinition : public MacroItem\n \n   Location locus;\n \n+  /* NOTE: in rustc, macro definitions are considered (and parsed as) a type\n+   * of macro, whereas here they are considered part of the language itself.\n+   * I am not aware of the implications of this decision. The rustc spec does\n+   * mention that using the same parser for macro definitions and invocations\n+   * is \"extremely self-referential and non-intuitive\". */\n+\n public:\n   std::string as_string () const override;\n \n@@ -354,49 +360,62 @@ class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n \t\t\tpublic ExprWithoutBlock\n {\n-  SimplePath path;\n-  DelimTokenTree token_tree;\n+  std::vector<Attribute> outer_attrs;\n+  MacroInvocData invoc_data;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  MacroInvocation (SimplePath path, DelimTokenTree token_tree,\n+  MacroInvocation (MacroInvocData invoc_data,\n \t\t   std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attrs)), path (std::move (path)),\n-      token_tree (std::move (token_tree)), locus (locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      invoc_data (std::move (invoc_data)), locus (locus)\n   {}\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if path is empty, so base stripping on that.\n-  void mark_for_strip () override { path = SimplePath::create_empty (); }\n-  bool is_marked_for_strip () const override { return path.is_empty (); }\n+  void mark_for_strip () override { invoc_data.mark_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return invoc_data.is_marked_for_strip ();\n+  }\n \n-  const SimplePath &get_path () const { return path; }\n-  SimplePath &get_path () { return path; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocation *clone_pattern_impl () const override\n+  MacroInvocation *clone_pattern_impl () const final override\n   {\n-    return new MacroInvocation (*this);\n+    return clone_macro_invocation_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocation *clone_expr_without_block_impl () const override\n+  MacroInvocation *clone_expr_without_block_impl () const final override\n   {\n-    return new MacroInvocation (*this);\n+    return clone_macro_invocation_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  MacroInvocation *clone_type_no_bounds_impl () const override\n+  MacroInvocation *clone_type_no_bounds_impl () const final override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  /*virtual*/ MacroInvocation *clone_macro_invocation_impl () const\n   {\n     return new MacroInvocation (*this);\n   }\n@@ -514,14 +533,18 @@ class MetaWord : public MetaItem\n class MetaNameValueStr : public MetaItem\n {\n   Identifier ident;\n+  // NOTE: str stored without quotes\n   std::string str;\n \n public:\n   MetaNameValueStr (Identifier ident, std::string str)\n     : ident (std::move (ident)), str (std::move (str))\n   {}\n \n-  std::string as_string () const override { return ident + \" = \" + str; }\n+  std::string as_string () const override\n+  {\n+    return ident + \" = \\\"\" + str + \"\\\"\";\n+  }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -602,17 +625,70 @@ class MetaListNameValueStr : public MetaItem\n   }\n };\n \n+/* Should be a tagged union to save space but implemented as struct due to\n+ * technical difficulties. TODO: fix\n+ * Basically, a single AST node used inside an AST fragment. */\n+struct SingleASTNode\n+{\n+  std::unique_ptr<Expr> expr;\n+  std::unique_ptr<Stmt> stmt;\n+  std::unique_ptr<Item> item;\n+  std::unique_ptr<Type> type;\n+  std::unique_ptr<Pattern> pattern;\n+  std::unique_ptr<TraitItem> trait_item;\n+  std::unique_ptr<InherentImplItem> inherent_impl_item;\n+  std::unique_ptr<TraitImplItem> trait_impl_item;\n+  std::unique_ptr<ExternalItem> external_item;\n+\n+  SingleASTNode (std::unique_ptr<Expr> expr) : expr (std::move (expr)) {}\n+  SingleASTNode (std::unique_ptr<Stmt> stmt) : stmt (std::move (stmt)) {}\n+  SingleASTNode (std::unique_ptr<Item> item) : item (std::move (item)) {}\n+  SingleASTNode (std::unique_ptr<Type> type) : type (std::move (type)) {}\n+  SingleASTNode (std::unique_ptr<Pattern> pattern)\n+    : pattern (std::move (pattern))\n+  {}\n+  SingleASTNode (std::unique_ptr<TraitItem> trait_item)\n+    : trait_item (std::move (trait_item))\n+  {}\n+  SingleASTNode (std::unique_ptr<InherentImplItem> inherent_impl_item)\n+    : inherent_impl_item (std::move (inherent_impl_item))\n+  {}\n+  SingleASTNode (std::unique_ptr<TraitImplItem> trait_impl_item)\n+    : trait_impl_item (std::move (trait_impl_item))\n+  {}\n+  SingleASTNode (std::unique_ptr<ExternalItem> external_item)\n+    : external_item (std::move (external_item))\n+  {}\n+};\n+\n+/* Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment. */\n+struct ASTFragment\n+{\n+private:\n+  /* basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create\n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance. */\n+\n+  std::vector<SingleASTNode> nodes;\n+\n+public:\n+  ASTFragment (std::vector<SingleASTNode> nodes) : nodes (std::move (nodes)) {}\n+};\n+\n // Object that parses macros from a token stream.\n /* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n  * attributes, I believe */\n struct MacroParser\n {\n private:\n+  // TODO: might as well rewrite to use lexer tokens\n   std::vector<std::unique_ptr<Token> > token_stream;\n-  /* probably have to make this mutable (mutable int stream_pos) otherwise const\n-   * has to be removed up to DelimTokenTree or further ok since this changing\n-   * would have an effect on the results of the methods run (i.e. not logically\n-   * const), the parsing methods shouldn't be const */\n   int stream_pos;\n \n public:"}, {"sha": "b30dffca6e6041e873f3e6001fd250e637f9ffe5", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -311,30 +311,28 @@ class PathPattern : public Pattern\n  * arguments) */\n class PathInExpression : public PathPattern, public PathExpr\n {\n+  std::vector<Attribute> outer_attrs;\n   bool has_opening_scope_resolution;\n   Location locus;\n-\n   NodeId _node_id;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor\n   PathInExpression (std::vector<PathExprSegment> path_segments,\n-\t\t    Location locus = Location (),\n-\t\t    bool has_opening_scope_resolution = false,\n-\t\t    std::vector<Attribute> outer_attrs\n-\t\t    = std::vector<Attribute> ())\n+\t\t    std::vector<Attribute> outer_attrs, Location locus,\n+\t\t    bool has_opening_scope_resolution = false)\n     : PathPattern (std::move (path_segments)),\n-      PathExpr (std::move (outer_attrs)),\n+      outer_attrs (std::move (outer_attrs)),\n       has_opening_scope_resolution (has_opening_scope_resolution),\n       locus (locus), _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Creates an error state path in expression.\n   static PathInExpression create_error ()\n   {\n-    return PathInExpression (std::vector<PathExprSegment> ());\n+    return PathInExpression ({}, {}, Location ());\n   }\n \n   // Returns whether path in expression is in an error state.\n@@ -353,28 +351,39 @@ class PathInExpression : public PathPattern, public PathExpr\n   }\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if path is empty (error state), so base stripping on that.\n   void mark_for_strip () override { remove_all_segments (); }\n   bool is_marked_for_strip () const override { return is_error (); }\n-  bool opening_scope_resolution () { return has_opening_scope_resolution; }\n+\n+  bool opening_scope_resolution () const { return has_opening_scope_resolution; }\n \n   NodeId get_node_id () const override { return _node_id; }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  PathInExpression *clone_pattern_impl () const override\n+  PathInExpression *clone_pattern_impl () const final override\n   {\n-    return new PathInExpression (*this);\n+    return clone_path_in_expression_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  PathInExpression *clone_expr_without_block_impl () const override\n+  PathInExpression *clone_expr_without_block_impl () const final override\n+  {\n+    return clone_path_in_expression_impl ();\n+  }\n+\n+  /*virtual*/ PathInExpression *clone_path_in_expression_impl () const\n   {\n     return new PathInExpression (*this);\n   }\n@@ -830,6 +839,7 @@ struct QualifiedPathType\n  * allows specifying trait functions) */\n class QualifiedPathInExpression : public PathPattern, public PathExpr\n {\n+  std::vector<Attribute> outer_attrs;\n   QualifiedPathType path_type;\n   Location locus;\n \n@@ -838,11 +848,10 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \n   QualifiedPathInExpression (QualifiedPathType qual_path_type,\n \t\t\t     std::vector<PathExprSegment> path_segments,\n-\t\t\t     Location locus = Location (),\n-\t\t\t     std::vector<Attribute> outer_attrs\n-\t\t\t     = std::vector<Attribute> ())\n+\t\t\t     std::vector<Attribute> outer_attrs,\n+           Location locus)\n     : PathPattern (std::move (path_segments)),\n-      PathExpr (std::move (outer_attrs)),\n+      outer_attrs (std::move (outer_attrs)),\n       path_type (std::move (qual_path_type)), locus (locus)\n   {}\n \n@@ -856,11 +865,11 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   static QualifiedPathInExpression create_error ()\n   {\n     return QualifiedPathInExpression (QualifiedPathType::create_error (),\n-\t\t\t\t      std::vector<PathExprSegment> ());\n+\t\t\t\t      {}, {}, Location ());\n   }\n \n   Location get_locus () const { return locus; }\n-  Location get_locus_slow () const override { return get_locus (); }\n+  Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n@@ -878,17 +887,27 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n     return path_type;\n   }\n \n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  QualifiedPathInExpression *clone_pattern_impl () const override\n+  QualifiedPathInExpression *clone_pattern_impl () const final override\n   {\n-    return new QualifiedPathInExpression (*this);\n+    return clone_qual_path_in_expression_impl ();\n   }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  QualifiedPathInExpression *clone_expr_without_block_impl () const override\n+  QualifiedPathInExpression *clone_expr_without_block_impl () const final override\n+  {\n+    return clone_qual_path_in_expression_impl ();\n+  }\n+\n+  /*virtual*/ QualifiedPathInExpression *clone_qual_path_in_expression_impl () const\n   {\n     return new QualifiedPathInExpression (*this);\n   }"}, {"sha": "b2a0bb5b0081dd2fbf122b42423e07739d564fb2", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 313, "deletions": 326, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -18,7 +18,6 @@\n \n #include \"rust-macro-expand.h\"\n #include \"rust-ast-full.h\"\n-// is full really required?\n #include \"rust-ast-visitor.h\"\n #include \"rust-diagnostics.h\"\n \n@@ -34,15 +33,15 @@ class AttrVisitor : public AST::ASTVisitor\n \n   void expand_struct_fields (std::vector<AST::StructField> &fields)\n   {\n-    for (int i = 0; i < fields.size ();)\n+    for (auto it = fields.begin (); it != fields.end ();)\n       {\n-\tauto &field = fields[i];\n+\tauto &field = *it;\n \n \tauto &field_attrs = field.get_outer_attrs ();\n \texpander.expand_cfg_attrs (field_attrs);\n-\tif (expander.fails_cfg (field_attrs))\n+\tif (expander.fails_cfg_with_expand (field_attrs))\n \t  {\n-\t    fields.erase (fields.begin () + i);\n+\t    it = fields.erase (it);\n \t    continue;\n \t  }\n \n@@ -54,21 +53,21 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t\t \"cannot strip type in this position\");\n \n \t// if nothing else happens, increment\n-\ti++;\n+\t++it;\n       }\n   }\n \n   void expand_tuple_fields (std::vector<AST::TupleField> &fields)\n   {\n-    for (int i = 0; i < fields.size ();)\n+    for (auto it = fields.begin (); it != fields.end ();)\n       {\n-\tauto &field = fields[i];\n+\tauto &field = *it;\n \n \tauto &field_attrs = field.get_outer_attrs ();\n \texpander.expand_cfg_attrs (field_attrs);\n-\tif (expander.fails_cfg (field_attrs))\n+\tif (expander.fails_cfg_with_expand (field_attrs))\n \t  {\n-\t    fields.erase (fields.begin () + i);\n+\t    it = fields.erase (it);\n \t    continue;\n \t  }\n \n@@ -80,21 +79,21 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t\t \"cannot strip type in this position\");\n \n \t// if nothing else happens, increment\n-\ti++;\n+\t++it;\n       }\n   }\n \n   void expand_function_params (std::vector<AST::FunctionParam> &params)\n   {\n-    for (int i = 0; i < params.size ();)\n+    for (auto it = params.begin (); it != params.end ();)\n       {\n-\tauto &param = params[i];\n+\tauto &param = *it;\n \n \tauto &param_attrs = param.get_outer_attrs ();\n \texpander.expand_cfg_attrs (param_attrs);\n-\tif (expander.fails_cfg (param_attrs))\n+\tif (expander.fails_cfg_with_expand (param_attrs))\n \t  {\n-\t    params.erase (params.begin () + i);\n+\t    it = params.erase (it);\n \t    continue;\n \t  }\n \n@@ -112,7 +111,7 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t\t \"cannot strip type in this position\");\n \n \t// increment\n-\ti++;\n+\t++it;\n       }\n   }\n \n@@ -160,15 +159,15 @@ class AttrVisitor : public AST::ASTVisitor\n \n   void expand_closure_params (std::vector<AST::ClosureParam> &params)\n   {\n-    for (int i = 0; i < params.size ();)\n+    for (auto it = params.begin (); it != params.end ();)\n       {\n-\tauto &param = params[i];\n+\tauto &param = *it;\n \n \tauto &param_attrs = param.get_outer_attrs ();\n \texpander.expand_cfg_attrs (param_attrs);\n-\tif (expander.fails_cfg (param_attrs))\n+\tif (expander.fails_cfg_with_expand (param_attrs))\n \t  {\n-\t    params.erase (params.begin () + i);\n+\t    it = params.erase (it);\n \t    continue;\n \t  }\n \n@@ -188,7 +187,7 @@ class AttrVisitor : public AST::ASTVisitor\n \t  }\n \n \t// increment if found nothing else so far\n-\ti++;\n+\t++it;\n       }\n   }\n \n@@ -202,8 +201,8 @@ class AttrVisitor : public AST::ASTVisitor\n \t  rust_error_at (type->get_locus_slow (),\n \t\t\t \"cannot strip type in this position\");\n       }\n-    // TODO: maybe check for invariants being violated - e.g. both type and\n-    // lifetime?\n+    /* TODO: maybe check for invariants being violated - e.g. both type and\n+     * lifetime? */\n   }\n \n   void expand_where_clause (AST::WhereClause &where_clause)\n@@ -264,6 +263,22 @@ class AttrVisitor : public AST::ASTVisitor\n       expand_where_clause (decl.get_where_clause ());\n   }\n \n+  template <typename T> void expand_pointer_allow_strip (T &values)\n+  {\n+    for (auto it = values.begin (); it != values.end ();)\n+      {\n+\tauto &value = *it;\n+\n+\t// mark for stripping if required\n+\tvalue->accept_vis (*this);\n+\n+\tif (value->is_marked_for_strip ())\n+\t  it = values.erase (it);\n+\telse\n+\t  ++it;\n+      }\n+  }\n+\n   void visit (AST::Token &) override\n   {\n     // shouldn't require?\n@@ -280,7 +295,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (ident_expr.get_outer_attrs ());\n-    if (expander.fails_cfg (ident_expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (ident_expr.get_outer_attrs ()))\n       {\n \tident_expr.mark_for_strip ();\n \treturn;\n@@ -298,7 +313,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n-    if (expander.fails_cfg (macro_invoc.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n       {\n \tmacro_invoc.mark_for_strip ();\n \treturn;\n@@ -315,7 +330,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (path.get_outer_attrs ());\n-    if (expander.fails_cfg (path.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (path.get_outer_attrs ()))\n       {\n \tpath.mark_for_strip ();\n \treturn;\n@@ -371,7 +386,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (path.get_outer_attrs ());\n-    if (expander.fails_cfg (path.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (path.get_outer_attrs ()))\n       {\n \tpath.mark_for_strip ();\n \treturn;\n@@ -398,7 +413,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -420,7 +435,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -440,7 +455,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -460,7 +475,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -480,7 +495,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -638,7 +653,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -647,7 +662,7 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says these are inner\n      * attributes, not outer attributes of inner expr */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -667,19 +682,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     /* apparently outer attributes are allowed in \"elements of array\n      * expressions\" according to spec */\n-    auto &values = elems.get_values ();\n-    for (int i = 0; i < values.size ();)\n-      {\n-\tauto &value = values[i];\n-\n-\t// mark for stripping if required\n-\tvalue->accept_vis (*this);\n-\n-\tif (value->is_marked_for_strip ())\n-\t  values.erase (values.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (elems.get_values ());\n   }\n   void visit (AST::ArrayElemsCopied &elems) override\n   {\n@@ -707,7 +710,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -716,7 +719,7 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says there are separate\n      * inner attributes, not just outer attributes of inner exprs */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -734,7 +737,7 @@ class AttrVisitor : public AST::ASTVisitor\n      * having expansion code anyway. TODO */\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -764,7 +767,7 @@ class AttrVisitor : public AST::ASTVisitor\n \n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -773,33 +776,21 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says these are inner\n      * attributes, not outer attributes of inner expr */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n       }\n \n     /* apparently outer attributes are allowed in \"elements of tuple\n      * expressions\" according to spec */\n-    auto &values = expr.get_tuple_elems ();\n-    for (int i = 0; i < values.size ();)\n-      {\n-\tauto &value = values[i];\n-\n-\t// mark for stripping if required\n-\tvalue->accept_vis (*this);\n-\n-\tif (value->is_marked_for_strip ())\n-\t  values.erase (values.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (expr.get_tuple_elems ());\n   }\n   void visit (AST::TupleIndexExpr &expr) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -819,7 +810,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -828,7 +819,7 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says these are inner\n      * attributes, not outer attributes of inner expr */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -871,7 +862,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -880,7 +871,7 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says these are inner\n      * attributes, not outer attributes of inner expr */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -919,7 +910,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -928,7 +919,7 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says these are inner\n      * attributes, not outer attributes of inner expr */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -955,7 +946,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -964,7 +955,7 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says these are inner\n      * attributes, not outer attributes of inner expr */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -979,25 +970,13 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* spec says outer attributes are specifically allowed for elements\n      * of tuple-style struct expressions, so full stripping possible */\n-    auto &values = expr.get_elems ();\n-    for (int i = 0; i < values.size ();)\n-      {\n-\tauto &value = values[i];\n-\n-\t// mark for stripping if required\n-\tvalue->accept_vis (*this);\n-\n-\tif (value->is_marked_for_strip ())\n-\t  values.erase (values.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (expr.get_elems ());\n   }\n   void visit (AST::StructExprUnit &expr) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1040,7 +1019,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1069,7 +1048,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1086,19 +1065,7 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* spec says outer attributes are specifically allowed for elements\n      * of tuple-style enum expressions, so full stripping possible */\n-    auto &values = expr.get_elems ();\n-    for (int i = 0; i < values.size ();)\n-      {\n-\tauto &value = values[i];\n-\n-\t// mark for stripping if required\n-\tvalue->accept_vis (*this);\n-\n-\tif (value->is_marked_for_strip ())\n-\t  values.erase (values.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (expr.get_elems ());\n   }\n   void visit (AST::EnumExprFieldless &expr) override\n   {\n@@ -1115,7 +1082,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1133,25 +1100,13 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* spec says outer attributes are specifically allowed for elements\n      * of call expressions, so full stripping possible */\n-    auto &params = expr.get_params ();\n-    for (int i = 0; i < params.size ();)\n-      {\n-\tauto &param = params[i];\n-\n-\t// mark for stripping if required\n-\tparam->accept_vis (*this);\n-\n-\tif (param->is_marked_for_strip ())\n-\t  params.erase (params.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (expr.get_params ());\n   }\n   void visit (AST::MethodCallExpr &expr) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1173,25 +1128,13 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* spec says outer attributes are specifically allowed for elements\n      * of method call expressions, so full stripping possible */\n-    auto &params = expr.get_params ();\n-    for (int i = 0; i < params.size ();)\n-      {\n-\tauto &param = params[i];\n-\n-\t// mark for stripping if required\n-\tparam->accept_vis (*this);\n-\n-\tif (param->is_marked_for_strip ())\n-\t  params.erase (params.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (expr.get_params ());\n   }\n   void visit (AST::FieldAccessExpr &expr) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1211,7 +1154,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1233,7 +1176,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1242,26 +1185,14 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip test based on inner attrs - spec says there are inner\n      * attributes, not just outer attributes of inner stmts */\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n       }\n \n     // strip all statements\n-    auto &stmts = expr.get_statements ();\n-    for (int i = 0; i < stmts.size ();)\n-      {\n-\tauto &stmt = stmts[i];\n-\n-\t// mark for stripping if required\n-\tstmt->accept_vis (*this);\n-\n-\tif (stmt->is_marked_for_strip ())\n-\t  stmts.erase (stmts.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (expr.get_statements ());\n \n     // strip tail expression if exists - can actually fully remove it\n     if (expr.has_tail_expr ())\n@@ -1278,7 +1209,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1307,7 +1238,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1317,7 +1248,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1440,7 +1371,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1470,7 +1401,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1488,7 +1419,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1506,7 +1437,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1532,7 +1463,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1566,13 +1497,13 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n       }\n \n-    // TODO: strip sub-patterns of pattern\n+    // strip sub-patterns of pattern\n     auto &pattern = expr.get_pattern ();\n     pattern->accept_vis (*this);\n     if (pattern->is_marked_for_strip ())\n@@ -1597,9 +1528,12 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n   void visit (AST::IfExpr &expr) override\n   {\n+    // rust playground test shows that IfExpr does support outer attrs, at least\n+    // when used as statement\n+\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1625,7 +1559,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1659,7 +1593,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1693,7 +1627,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1728,7 +1662,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1762,7 +1696,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1804,7 +1738,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1846,7 +1780,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1889,15 +1823,15 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n       }\n \n     // inner attr strip test\n     expander.expand_cfg_attrs (expr.get_inner_attrs ());\n-    if (expander.fails_cfg (expr.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_inner_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1913,17 +1847,17 @@ class AttrVisitor : public AST::ASTVisitor\n \n     // strip match cases\n     auto &match_cases = expr.get_match_cases ();\n-    for (int i = 0; i < match_cases.size ();)\n+    for (auto it = match_cases.begin (); it != match_cases.end ();)\n       {\n-\tauto &match_case = match_cases[i];\n+\tauto &match_case = *it;\n \n \t// strip match case based on outer attributes in match arm\n \tauto &match_arm = match_case.get_arm ();\n \texpander.expand_cfg_attrs (match_arm.get_outer_attrs ());\n-\tif (expander.fails_cfg (match_arm.get_outer_attrs ()))\n+\tif (expander.fails_cfg_with_expand (match_arm.get_outer_attrs ()))\n \t  {\n \t    // strip match case\n-\t    match_cases.erase (match_cases.begin () + i);\n+\t    it = match_cases.erase (it);\n \t    continue;\n \t  }\n \n@@ -1958,14 +1892,14 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t\t \"attributes not allowed\");\n \n \t// increment to next case if haven't continued\n-\ti++;\n+\t++it;\n       }\n   }\n   void visit (AST::AwaitExpr &expr) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -1984,7 +1918,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (expr.get_outer_attrs ());\n-    if (expander.fails_cfg (expr.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (expr.get_outer_attrs ()))\n       {\n \texpr.mark_for_strip ();\n \treturn;\n@@ -2041,7 +1975,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (method.get_outer_attrs ());\n-    if (expander.fails_cfg (method.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (method.get_outer_attrs ()))\n       {\n \tmethod.mark_for_strip ();\n \treturn;\n@@ -2086,40 +2020,28 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (module.get_outer_attrs ());\n-    if (expander.fails_cfg (module.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (module.get_outer_attrs ()))\n       {\n \tmodule.mark_for_strip ();\n \treturn;\n       }\n \n     // strip test based on inner attrs\n     expander.expand_cfg_attrs (module.get_inner_attrs ());\n-    if (expander.fails_cfg (module.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (module.get_inner_attrs ()))\n       {\n \tmodule.mark_for_strip ();\n \treturn;\n       }\n \n     // strip items if required\n-    auto &items = module.get_items ();\n-    for (int i = 0; i < items.size ();)\n-      {\n-\tauto &item = items[i];\n-\n-\t// mark for stripping if required\n-\titem->accept_vis (*this);\n-\n-\tif (item->is_marked_for_strip ())\n-\t  items.erase (items.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (module.get_items ());\n   }\n   void visit (AST::ModuleNoBody &module) override\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (module.get_outer_attrs ());\n-    if (expander.fails_cfg (module.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (module.get_outer_attrs ()))\n       {\n \tmodule.mark_for_strip ();\n \treturn;\n@@ -2129,7 +2051,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (crate.get_outer_attrs ());\n-    if (expander.fails_cfg (crate.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (crate.get_outer_attrs ()))\n       {\n \tcrate.mark_for_strip ();\n \treturn;\n@@ -2151,7 +2073,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (use_decl.get_outer_attrs ());\n-    if (expander.fails_cfg (use_decl.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (use_decl.get_outer_attrs ()))\n       {\n \tuse_decl.mark_for_strip ();\n \treturn;\n@@ -2161,7 +2083,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (function.get_outer_attrs ());\n-    if (expander.fails_cfg (function.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (function.get_outer_attrs ()))\n       {\n \tfunction.mark_for_strip ();\n \treturn;\n@@ -2201,7 +2123,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (type_alias.get_outer_attrs ());\n-    if (expander.fails_cfg (type_alias.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (type_alias.get_outer_attrs ()))\n       {\n \ttype_alias.mark_for_strip ();\n \treturn;\n@@ -2224,7 +2146,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (struct_item.get_outer_attrs ());\n-    if (expander.fails_cfg (struct_item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (struct_item.get_outer_attrs ()))\n       {\n \tstruct_item.mark_for_strip ();\n \treturn;\n@@ -2245,7 +2167,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (tuple_struct.get_outer_attrs ());\n-    if (expander.fails_cfg (tuple_struct.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (tuple_struct.get_outer_attrs ()))\n       {\n \ttuple_struct.mark_for_strip ();\n \treturn;\n@@ -2266,7 +2188,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2276,7 +2198,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2290,7 +2212,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2304,7 +2226,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2324,7 +2246,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (enum_item.get_outer_attrs ());\n-    if (expander.fails_cfg (enum_item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (enum_item.get_outer_attrs ()))\n       {\n \tenum_item.mark_for_strip ();\n \treturn;\n@@ -2339,25 +2261,13 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* strip enum fields if required - this is presumably\n      * allowed by spec */\n-    auto &variants = enum_item.get_variants ();\n-    for (int i = 0; i < variants.size ();)\n-      {\n-\tauto &variant = variants[i];\n-\n-\t// mark for stripping if required\n-\tvariant->accept_vis (*this);\n-\n-\tif (variant->is_marked_for_strip ())\n-\t  variants.erase (variants.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (enum_item.get_variants ());\n   }\n   void visit (AST::Union &union_item) override\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (union_item.get_outer_attrs ());\n-    if (expander.fails_cfg (union_item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (union_item.get_outer_attrs ()))\n       {\n \tunion_item.mark_for_strip ();\n \treturn;\n@@ -2378,7 +2288,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (const_item.get_outer_attrs ());\n-    if (expander.fails_cfg (const_item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (const_item.get_outer_attrs ()))\n       {\n \tconst_item.mark_for_strip ();\n \treturn;\n@@ -2405,7 +2315,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (static_item.get_outer_attrs ());\n-    if (expander.fails_cfg (static_item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (static_item.get_outer_attrs ()))\n       {\n \tstatic_item.mark_for_strip ();\n \treturn;\n@@ -2432,7 +2342,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2457,7 +2367,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2482,7 +2392,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2512,7 +2422,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2529,15 +2439,15 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (trait.get_outer_attrs ());\n-    if (expander.fails_cfg (trait.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (trait.get_outer_attrs ()))\n       {\n \ttrait.mark_for_strip ();\n \treturn;\n       }\n \n     // strip test based on inner attrs\n     expander.expand_cfg_attrs (trait.get_inner_attrs ());\n-    if (expander.fails_cfg (trait.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (trait.get_inner_attrs ()))\n       {\n \ttrait.mark_for_strip ();\n \treturn;\n@@ -2558,33 +2468,21 @@ class AttrVisitor : public AST::ASTVisitor\n       expand_where_clause (trait.get_where_clause ());\n \n     // strip trait items if required\n-    auto &trait_items = trait.get_trait_items ();\n-    for (int i = 0; i < trait_items.size ();)\n-      {\n-\tauto &item = trait_items[i];\n-\n-\t// mark for stripping if required\n-\titem->accept_vis (*this);\n-\n-\tif (item->is_marked_for_strip ())\n-\t  trait_items.erase (trait_items.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (trait.get_trait_items ());\n   }\n   void visit (AST::InherentImpl &impl) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (impl.get_outer_attrs ());\n-    if (expander.fails_cfg (impl.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (impl.get_outer_attrs ()))\n       {\n \timpl.mark_for_strip ();\n \treturn;\n       }\n \n     // strip test based on inner attrs\n     expander.expand_cfg_attrs (impl.get_inner_attrs ());\n-    if (expander.fails_cfg (impl.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (impl.get_inner_attrs ()))\n       {\n \timpl.mark_for_strip ();\n \treturn;\n@@ -2604,33 +2502,21 @@ class AttrVisitor : public AST::ASTVisitor\n       expand_where_clause (impl.get_where_clause ());\n \n     // strip inherent impl items if required\n-    auto &impl_items = impl.get_impl_items ();\n-    for (int i = 0; i < impl_items.size ();)\n-      {\n-\tauto &item = impl_items[i];\n-\n-\t// mark for stripping if required\n-\titem->accept_vis (*this);\n-\n-\tif (item->is_marked_for_strip ())\n-\t  impl_items.erase (impl_items.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (impl.get_impl_items ());\n   }\n   void visit (AST::TraitImpl &impl) override\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (impl.get_outer_attrs ());\n-    if (expander.fails_cfg (impl.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (impl.get_outer_attrs ()))\n       {\n \timpl.mark_for_strip ();\n \treturn;\n       }\n \n     // strip test based on inner attrs\n     expander.expand_cfg_attrs (impl.get_inner_attrs ());\n-    if (expander.fails_cfg (impl.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (impl.get_inner_attrs ()))\n       {\n \timpl.mark_for_strip ();\n \treturn;\n@@ -2656,25 +2542,13 @@ class AttrVisitor : public AST::ASTVisitor\n       expand_where_clause (impl.get_where_clause ());\n \n     // strip trait impl items if required\n-    auto &impl_items = impl.get_impl_items ();\n-    for (int i = 0; i < impl_items.size ();)\n-      {\n-\tauto &item = impl_items[i];\n-\n-\t// mark for stripping if required\n-\titem->accept_vis (*this);\n-\n-\tif (item->is_marked_for_strip ())\n-\t  impl_items.erase (impl_items.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (impl.get_impl_items ());\n   }\n   void visit (AST::ExternalStaticItem &item) override\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2690,7 +2564,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // strip test based on outer attrs\n     expander.expand_cfg_attrs (item.get_outer_attrs ());\n-    if (expander.fails_cfg (item.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (item.get_outer_attrs ()))\n       {\n \titem.mark_for_strip ();\n \treturn;\n@@ -2703,15 +2577,15 @@ class AttrVisitor : public AST::ASTVisitor\n     /* strip function parameters if required - this is specifically\n      * allowed by spec */\n     auto &params = item.get_function_params ();\n-    for (int i = 0; i < params.size ();)\n+    for (auto it = params.begin (); it != params.end ();)\n       {\n-\tauto &param = params[i];\n+\tauto &param = *it;\n \n \tauto &param_attrs = param.get_outer_attrs ();\n \texpander.expand_cfg_attrs (param_attrs);\n-\tif (expander.fails_cfg (param_attrs))\n+\tif (expander.fails_cfg_with_expand (param_attrs))\n \t  {\n-\t    params.erase (params.begin () + i);\n+\t    it = params.erase (it);\n \t    continue;\n \t  }\n \n@@ -2722,7 +2596,7 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t\t \"cannot strip type in this position\");\n \n \t// increment if nothing else happens\n-\ti++;\n+\t++it;\n       }\n     /* NOTE: these are extern function params, which may have different\n      * rules and restrictions to \"normal\" function params. So expansion\n@@ -2747,34 +2621,22 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (block.get_outer_attrs ());\n-    if (expander.fails_cfg (block.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (block.get_outer_attrs ()))\n       {\n \tblock.mark_for_strip ();\n \treturn;\n       }\n \n     // strip test based on inner attrs\n     expander.expand_cfg_attrs (block.get_inner_attrs ());\n-    if (expander.fails_cfg (block.get_inner_attrs ()))\n+    if (expander.fails_cfg_with_expand (block.get_inner_attrs ()))\n       {\n \tblock.mark_for_strip ();\n \treturn;\n       }\n \n     // strip external items if required\n-    auto &extern_items = block.get_extern_items ();\n-    for (int i = 0; i < extern_items.size ();)\n-      {\n-\tauto &item = extern_items[i];\n-\n-\t// mark for stripping if required\n-\titem->accept_vis (*this);\n-\n-\tif (item->is_marked_for_strip ())\n-\t  extern_items.erase (extern_items.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (block.get_extern_items ());\n   }\n \n   // I don't think it would be possible to strip macros without expansion\n@@ -2785,7 +2647,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (rules_def.get_outer_attrs ());\n-    if (expander.fails_cfg (rules_def.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (rules_def.get_outer_attrs ()))\n       {\n \trules_def.mark_for_strip ();\n \treturn;\n@@ -2797,7 +2659,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n-    if (expander.fails_cfg (macro_invoc.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))\n       {\n \tmacro_invoc.mark_for_strip ();\n \treturn;\n@@ -2872,7 +2734,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (field.get_outer_attrs ());\n-    if (expander.fails_cfg (field.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (field.get_outer_attrs ()))\n       {\n \tfield.mark_for_strip ();\n \treturn;\n@@ -2889,7 +2751,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (field.get_outer_attrs ());\n-    if (expander.fails_cfg (field.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (field.get_outer_attrs ()))\n       {\n \tfield.mark_for_strip ();\n \treturn;\n@@ -2906,7 +2768,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (field.get_outer_attrs ());\n-    if (expander.fails_cfg (field.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (field.get_outer_attrs ()))\n       {\n \tfield.mark_for_strip ();\n \treturn;\n@@ -2920,32 +2782,21 @@ class AttrVisitor : public AST::ASTVisitor\n     if (path.is_marked_for_strip ())\n       rust_error_at (path.get_locus (), \"cannot strip path in this position\");\n \n-    // TODO: apparently struct pattern fields can have outer attrs. so can they\n-    // be stripped?\n+    /* TODO: apparently struct pattern fields can have outer attrs. so can they\n+     * be stripped? */\n     if (!pattern.has_struct_pattern_elems ())\n       return;\n \n     auto &elems = pattern.get_struct_pattern_elems ();\n \n     // assuming you can strip struct pattern fields\n-    auto &fields = elems.get_struct_pattern_fields ();\n-    for (int i = 0; i < fields.size ();)\n-      {\n-\tauto &field = fields[i];\n-\n-\tfield->accept_vis (*this);\n-\n-\tif (field->is_marked_for_strip ())\n-\t  fields.erase (fields.begin () + i);\n-\telse\n-\t  i++;\n-      }\n+    expand_pointer_allow_strip (elems.get_struct_pattern_fields ());\n \n     // assuming you can strip the \"..\" part\n     if (elems.has_etc ())\n       {\n \texpander.expand_cfg_attrs (elems.get_etc_outer_attrs ());\n-\tif (expander.fails_cfg (elems.get_etc_outer_attrs ()))\n+\tif (expander.fails_cfg_with_expand (elems.get_etc_outer_attrs ()))\n \t  elems.strip_etc ();\n       }\n   }\n@@ -3068,7 +2919,7 @@ class AttrVisitor : public AST::ASTVisitor\n   {\n     // initial strip test based on outer attrs\n     expander.expand_cfg_attrs (stmt.get_outer_attrs ());\n-    if (expander.fails_cfg (stmt.get_outer_attrs ()))\n+    if (expander.fails_cfg_with_expand (stmt.get_outer_attrs ()))\n       {\n \tstmt.mark_for_strip ();\n \treturn;\n@@ -3250,15 +3101,15 @@ class AttrVisitor : public AST::ASTVisitor\n \n     // presumably function params can be stripped\n     auto &params = type.get_function_params ();\n-    for (int i = 0; i < params.size ();)\n+    for (auto it = params.begin (); it != params.end ();)\n       {\n-\tauto &param = params[i];\n+\tauto &param = *it;\n \n \tauto &param_attrs = param.get_outer_attrs ();\n \texpander.expand_cfg_attrs (param_attrs);\n-\tif (expander.fails_cfg (param_attrs))\n+\tif (expander.fails_cfg_with_expand (param_attrs))\n \t  {\n-\t    params.erase (params.begin () + i);\n+\t    it = params.erase (it);\n \t    continue;\n \t  }\n \n@@ -3269,7 +3120,7 @@ class AttrVisitor : public AST::ASTVisitor\n \t\t\t \"cannot strip type in this position\");\n \n \t// increment if nothing else happens\n-\ti++;\n+\t++it;\n       }\n \n     /* TODO: assuming that variadic nature cannot be stripped. If this\n@@ -3288,6 +3139,94 @@ class AttrVisitor : public AST::ASTVisitor\n   }\n };\n \n+void\n+MacroExpander::parse_macro_to_meta_item (AST::MacroInvocData &invoc)\n+{\n+  // only parse if not already parsed\n+  if (invoc.is_parsed ())\n+    return;\n+\n+  std::unique_ptr<AST::AttrInputMetaItemContainer> converted_input (\n+    invoc.get_delim_tok_tree ().parse_to_meta_item ());\n+\n+  if (converted_input == nullptr)\n+    {\n+      fprintf (stderr, \"DEBUG: failed to parse macro to meta item\\n\");\n+      // TODO: do something now? is this an actual error?\n+    }\n+  else\n+    {\n+      std::vector<std::unique_ptr<AST::MetaItemInner> > meta_items (\n+\tstd::move (converted_input->get_items ()));\n+      invoc.set_meta_item_output (std::move (meta_items));\n+    }\n+}\n+\n+AST::Literal\n+MacroExpander::expand_cfg_macro (AST::MacroInvocData &invoc)\n+{\n+  // only allow on cfg macros\n+  if (invoc.get_path () != \"cfg\")\n+    return AST::Literal::create_error ();\n+\n+  parse_macro_to_meta_item (invoc);\n+\n+  /* TODO: assuming that cfg! macros can only have one meta item inner, like cfg\n+   * attributes */\n+  if (invoc.get_meta_items ().size () != 1)\n+    return AST::Literal::create_error ();\n+\n+  bool result = invoc.get_meta_items ()[0]->check_cfg_predicate (session);\n+  if (result)\n+    return AST::Literal (\"true\", AST::Literal::BOOL, CORETYPE_BOOL);\n+  else\n+    return AST::Literal (\"false\", AST::Literal::BOOL, CORETYPE_BOOL);\n+}\n+\n+AST::ASTFragment\n+MacroExpander::expand_decl_macro (AST::MacroInvocData &invoc,\n+\t\t\t\t  AST::MacroRulesDefinition &rules_def)\n+{\n+  // ensure that both invocation and rules are in a valid state\n+  rust_assert (!invoc.is_marked_for_strip ());\n+  rust_assert (!rules_def.is_marked_for_strip ());\n+  rust_assert (rules_def.get_macro_rules ().size () > 0);\n+\n+  /* probably something here about parsing invoc and rules def token trees to\n+   * token stream. if not, how would parser handle the captures of exprs and\n+   * stuff? on the other hand, token trees may be kind of useful in rules def as\n+   * creating a point where recursion can occur (like having\n+   * \"compare_macro_match\" and then it calling itself when it finds delimiters)\n+   */\n+\n+  /* find matching rule to invoc token tree, based on macro rule's matcher. if\n+   * none exist, error.\n+   * - specifically, check each matcher in order. if one fails to match, move\n+   * onto next. */\n+  /* TODO: does doing this require parsing expressions and whatever in the\n+   * invoc? if so, might as well save the results if referenced using $ or\n+   * whatever. If not, do another pass saving them. Except this is probably\n+   * useless as different rules could have different starting points for exprs\n+   * or whatever. Decision trees could avoid this, but they have their own\n+   * issues. */\n+  /* TODO: will need to modify the parser so that it can essentially \"catch\"\n+   * errors - maybe \"try_parse_expr\" or whatever methods. */\n+  // this technically creates a back-tracking parser - this will be the\n+  // implementation style\n+\n+  /* then, after results are saved, generate the macro output from the\n+   * transcriber token tree. if i understand this correctly, the macro\n+   * invocation gets replaced by the transcriber tokens, except with\n+   * substitutions made (e.g. for $i variables) */\n+\n+  /* TODO: it is probably better to modify AST::Token to store a pointer to a\n+   * Lexer::Token (rather than being converted) - i.e. not so much have\n+   * AST::Token as a Token but rather a TokenContainer (as it is another type of\n+   * TokenTree). This will prevent re-conversion of Tokens between each type\n+   * all the time, while still allowing the heterogenous storage of token trees.\n+   */\n+}\n+\n void\n MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n {\n@@ -3309,7 +3248,7 @@ MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n \t  - derive or legacy derive - \"token-based\" vs \"AST-based\"\n \t  - else is unreachable\n       - derive container macro - unreachable*/\n-  \n+\n #if 0\n   // macro_rules macro test code\n   auto rule_def = find_rules_def(invoc->get_path());\n@@ -3331,27 +3270,74 @@ MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n }\n \n /* Determines whether any cfg predicate is false and hence item with attributes\n- * should be stripped.  */\n+ * should be stripped. Note that attributes must be expanded before calling. */\n bool\n-MacroExpander::fails_cfg (std::vector<AST::Attribute> &attrs)\n+MacroExpander::fails_cfg (const std::vector<AST::Attribute> &attrs) const\n {\n-  for (auto &attr : attrs)\n+  for (const auto &attr : attrs)\n     {\n       if (attr.get_path () == \"cfg\" && !attr.check_cfg_predicate (session))\n \treturn true;\n     }\n   return false;\n }\n \n+/* Determines whether any cfg predicate is false and hence item with attributes\n+ * should be stripped. Will expand attributes as well. */\n+bool\n+MacroExpander::fails_cfg_with_expand (std::vector<AST::Attribute> &attrs) const\n+{\n+  // TODO: maybe have something that strips cfg attributes that evaluate true?\n+  for (auto &attr : attrs)\n+    {\n+      if (attr.get_path () == \"cfg\")\n+\t{\n+\t  if (!attr.is_parsed_to_meta_item ())\n+\t    attr.parse_attr_to_meta_item ();\n+\n+\t  // DEBUG\n+\t  if (!attr.is_parsed_to_meta_item ())\n+\t    fprintf (stderr, \"failed to parse attr to meta item, right before \"\n+\t\t\t     \"cfg predicate check\\n\");\n+\t  else\n+\t    fprintf (stderr, \"attr has been successfully parsed to meta item, \"\n+\t\t\t     \"right before cfg predicate check\\n\");\n+\n+\t  if (!attr.check_cfg_predicate (session))\n+\t    {\n+\t      // DEBUG\n+\t      fprintf (\n+\t\tstderr,\n+\t\t\"cfg predicate failed for attribute: \\033[0;31m'%s'\\033[0m\\n\",\n+\t\tattr.as_string ().c_str ());\n+\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      // DEBUG\n+\t      fprintf (stderr,\n+\t\t       \"cfg predicate succeeded for attribute: \"\n+\t\t       \"\\033[0;31m'%s'\\033[0m\\n\",\n+\t\t       attr.as_string ().c_str ());\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n // Expands cfg_attr attributes.\n void\n MacroExpander::expand_cfg_attrs (std::vector<AST::Attribute> &attrs)\n {\n-  for (int i = 0; i < attrs.size ();)\n+  for (std::size_t i = 0; i < attrs.size ();)\n     {\n       auto &attr = attrs[i];\n       if (attr.get_path () == \"cfg_attr\")\n \t{\n+\t  if (!attr.is_parsed_to_meta_item ())\n+\t    attr.parse_attr_to_meta_item ();\n+\n \t  if (attr.check_cfg_predicate (session))\n \t    {\n \t      // split off cfg_attr\n@@ -3394,7 +3380,7 @@ MacroExpander::expand_crate ()\n   // expand crate cfg_attr attributes\n   expand_cfg_attrs (crate.inner_attrs);\n \n-  if (fails_cfg (crate.inner_attrs))\n+  if (fails_cfg_with_expand (crate.inner_attrs))\n     {\n       // basically, delete whole crate\n       crate.strip_crate ();\n@@ -3405,18 +3391,19 @@ MacroExpander::expand_crate ()\n   // expand attributes recursively and strip items if required\n   AttrVisitor attr_visitor (*this);\n   auto &items = crate.items;\n-  for (int i = 0; i < items.size ();)\n+  for (auto it = items.begin (); it != items.end ();)\n     {\n-      auto &item = items[i];\n+      auto &item = *it;\n \n       // mark for stripping if required\n       item->accept_vis (attr_visitor);\n \n       if (item->is_marked_for_strip ())\n-\titems.erase (items.begin () + i);\n+\tit = items.erase (it);\n       else\n-\ti++;\n+\t++it;\n     }\n+\n   // TODO: should recursive attribute and macro expansion be done in the same\n   // transversal? Or in separate ones like currently?\n "}, {"sha": "2e9b88bde27412ee7a6f0ec0c88e93ab83073a4d", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -20,6 +20,7 @@\n #define RUST_MACRO_EXPAND_H\n \n #include \"rust-ast.h\"\n+#include \"rust-macro.h\"\n \n // Provides objects and method prototypes for macro expansion\n \n@@ -34,9 +35,9 @@ struct ExpansionCfg\n {\n   // features?\n   unsigned int recursion_limit = 50; // TODO: determine default recursion limit\n-\t\t\t\t// trace macros?\n-\t\t\t\t// should test?\n-\t\t\t\t// more default stuff?\n+\t\t\t\t     // trace macros?\n+\t\t\t\t     // should test?\n+\t\t\t\t     // more default stuff?\n };\n \n // Object used to store shared data (between functions) for macro expansion.\n@@ -59,11 +60,18 @@ struct MacroExpander\n   // should this be public or private?\n   void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n+  // Expands a single declarative macro.\n+  AST::ASTFragment expand_decl_macro (AST::MacroInvocData &invoc,\n+\t\t\t\t      AST::MacroRulesDefinition &rules_def);\n+\n   void expand_cfg_attrs (std::vector<AST::Attribute> &attrs);\n-  bool fails_cfg (std::vector<AST::Attribute> &attr);\n+  bool fails_cfg (const std::vector<AST::Attribute> &attr) const;\n+  bool fails_cfg_with_expand (std::vector<AST::Attribute> &attrs) const;\n \n-  /* TODO: make it extend ASTVisitor so that individual items can be accessed\n-   * properly? */\n+  // Expand the data of a cfg! macro.\n+  void parse_macro_to_meta_item (AST::MacroInvocData &invoc);\n+  // Get the literal representation of a cfg! macro.\n+  AST::Literal expand_cfg_macro (AST::MacroInvocData &invoc);\n \n private:\n   AST::Crate &crate;"}, {"sha": "6070244959396240ef2b5aef875be545cc9a2ae8", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -317,13 +317,6 @@ class Token\n     return TokenPtr (new Token (IDENTIFIER, locus, str));\n   }\n \n-  // Makes and returns a new TokenPtr of type INT_LITERAL.\n-  /*static TokenPtr make_int (Location locus, const std::string &str)\n-  {\n-    //return TokenPtr (new Token (INT_LITERAL, locus, str));\n-    return std::make_shared<Token>(INT_LITERAL, locus, str);\n-  }*/\n-\n   // Makes and returns a new TokenPtr of type INT_LITERAL.\n   static TokenPtr make_int (Location locus, const std::string &str,\n \t\t\t    PrimitiveCoreType type_hint = CORETYPE_UNKNOWN)\n@@ -332,13 +325,6 @@ class Token\n     return TokenPtr (new Token (INT_LITERAL, locus, str, type_hint));\n   }\n \n-  // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n-  /*static TokenPtr make_float (Location locus, const std::string &str)\n-  {\n-    return TokenPtr (new Token (FLOAT_LITERAL, locus, str));\n-    return std::make_shared<Token>(FLOAT_LITERAL, locus, str);\n-  }*/\n-\n   // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n   static TokenPtr make_float (Location locus, const std::string &str,\n \t\t\t      PrimitiveCoreType type_hint = CORETYPE_UNKNOWN)"}, {"sha": "437a7b5f5afe7d94cb3e77cd696b6aaf969a4dbf", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 112, "deletions": 116, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -792,7 +792,7 @@ Parser<ManagedTokenSource>::parse_attr_input ()\n \n \t// create actual LiteralExpr\n \tAST::LiteralExpr lit_expr (t->get_str (), lit_type, t->get_type_hint (),\n-\t\t\t\t   t->get_locus ());\n+\t\t\t\t   {}, t->get_locus ());\n \n \tstd::unique_ptr<AST::AttrInputLiteral> attr_input_lit (\n \t  new AST::AttrInputLiteral (std::move (lit_expr)));\n@@ -974,8 +974,7 @@ Parser<ManagedTokenSource>::parse_token_tree ()\n     default:\n       // parse token itself as TokenTree\n       lexer.skip_token ();\n-      // TODO: fix that token constructor, possibly with c++11 features\n-      return std::unique_ptr<AST::Token> (new AST::Token (t));\n+      return std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n     }\n }\n \n@@ -1531,6 +1530,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t\t     t->get_token_description ());\n       return nullptr;\n     }\n+  Location tok_tree_locus = t->get_locus ();\n   lexer.skip_token ();\n \n   // parse actual token trees\n@@ -1556,6 +1556,10 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n       t = lexer.peek_token ();\n     }\n \n+  AST::DelimTokenTree delim_tok_tree (delim_type, std::move (token_trees),\n+\t\t\t\t      tok_tree_locus);\n+  AST::MacroInvocData invoc_data (std::move (path), std::move (delim_tok_tree));\n+\n   // parse end delimiters\n   t = lexer.peek_token ();\n   if (token_id_matches_delims (t->get_id (), delim_type))\n@@ -1570,8 +1574,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n \t      return std::unique_ptr<AST::MacroInvocationSemi> (\n-\t\tnew AST::MacroInvocationSemi (std::move (path), delim_type,\n-\t\t\t\t\t      std::move (token_trees),\n+\t\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t\t      std::move (outer_attrs),\n \t\t\t\t\t      macro_locus));\n \t    }\n@@ -1584,8 +1587,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t       lexer.peek_token ()->get_token_description ());\n \n       return std::unique_ptr<AST::MacroInvocationSemi> (\n-\tnew AST::MacroInvocationSemi (std::move (path), delim_type,\n-\t\t\t\t      std::move (token_trees),\n+\tnew AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t      std::move (outer_attrs), macro_locus));\n     }\n   else\n@@ -1633,8 +1635,8 @@ Parser<ManagedTokenSource>::parse_macro_invocation (\n   Location macro_locus = macro_path.get_locus ();\n \n   return std::unique_ptr<AST::MacroInvocation> (\n-    new AST::MacroInvocation (std::move (macro_path),\n-\t\t\t      std::move (delim_tok_tree),\n+    new AST::MacroInvocation (AST::MacroInvocData (std::move (macro_path),\n+\t\t\t\t\t\t   std::move (delim_tok_tree)),\n \t\t\t      std::move (outer_attrs), macro_locus));\n }\n \n@@ -1804,7 +1806,7 @@ Parser<ManagedTokenSource>::parse_macro_match ()\n     default:\n       // just the token\n       lexer.skip_token ();\n-      return std::unique_ptr<AST::Token> (new AST::Token (t));\n+      return std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n     }\n }\n \n@@ -1912,7 +1914,7 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n       break;\n     default:\n       // separator does exist\n-      separator = std::unique_ptr<AST::Token> (new AST::Token (t));\n+      separator = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n       lexer.skip_token ();\n       break;\n     }\n@@ -2664,9 +2666,9 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t}\n \n       std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime), locus,\n+\tnew AST::LifetimeParam (std::move (lifetime), \n \t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr)));\n+\t\t\t\tstd::move (outer_attr), locus));\n       generic_params.push_back (std::move (param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n@@ -2840,9 +2842,9 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n \t}\n \n       std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime), locus,\n+\tnew AST::LifetimeParam (std::move (lifetime),\n \t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr)));\n+\t\t\t\tstd::move (outer_attr), locus));\n       generic_params.push_back (std::move (param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n@@ -3165,9 +3167,9 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n       // TODO: have end token passed in?\n     }\n \n-  return AST::LifetimeParam (std::move (lifetime), lifetime_tok->get_locus (),\n+  return AST::LifetimeParam (std::move (lifetime), \n \t\t\t     std::move (lifetime_bounds),\n-\t\t\t     std::move (outer_attr));\n+\t\t\t     std::move (outer_attr), lifetime_tok->get_locus ());\n }\n \n // Parses type generic parameters. Will also consume any trailing comma.\n@@ -3692,13 +3694,11 @@ Parser<ManagedTokenSource>::parse_trait_bound ()\n       lexer.skip_token ();\n     }\n \n-  // parse for lifetimes, if it exists (although empty for lifetimes is ok to\n-  // handle this)\n+  /* parse for lifetimes, if it exists (although empty for lifetimes is ok to\n+   * handle this) */\n   std::vector<AST::LifetimeParam> for_lifetimes;\n   if (lexer.peek_token ()->get_id () == FOR)\n-    {\n       for_lifetimes = parse_for_lifetimes ();\n-    }\n \n   // handle TypePath\n   AST::TypePath type_path = parse_type_path ();\n@@ -6359,9 +6359,8 @@ Parser<ManagedTokenSource>::parse_path_in_expression ()\n \n   segments.shrink_to_fit ();\n \n-  return AST::PathInExpression (std::move (segments), locus,\n-\t\t\t\thas_opening_scope_resolution,\n-\t\t\t\tstd::vector<AST::Attribute> ());\n+  return AST::PathInExpression (std::move (segments), {}, locus,\n+\t\t\t\thas_opening_scope_resolution);\n }\n \n /* Parses a single path in expression path segment (including generic\n@@ -6474,8 +6473,7 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n \n   // FIXME: outer attr parsing\n   return AST::QualifiedPathInExpression (std::move (qual_path_type),\n-\t\t\t\t\t std::move (segments), locus,\n-\t\t\t\t\t std::vector<AST::Attribute> ());\n+\t\t\t\t\t std::move (segments), {}, locus);\n }\n \n // Parses the type syntactical construction at the start of a qualified path.\n@@ -7375,8 +7373,8 @@ Parser<ManagedTokenSource>::parse_literal_expr (\n   // create literal based on stuff in switch\n   return std::unique_ptr<AST::LiteralExpr> (\n     new AST::LiteralExpr (std::move (literal_value), std::move (type),\n-\t\t\t  t->get_type_hint (), t->get_locus (),\n-\t\t\t  std::move (outer_attrs)));\n+\t\t\t  t->get_type_hint (), std::move (outer_attrs),\n+\t\t\t  t->get_locus ()));\n }\n \n // Parses a return expression (including any expression to return).\n@@ -7406,8 +7404,8 @@ Parser<ManagedTokenSource>::parse_return_expr (\n     = parse_expr (std::vector<AST::Attribute> (), restrictions);\n \n   return std::unique_ptr<AST::ReturnExpr> (\n-    new AST::ReturnExpr (locus, std::move (returned_expr),\n-\t\t\t std::move (outer_attrs)));\n+    new AST::ReturnExpr (std::move (returned_expr), std::move (outer_attrs),\n+\t\t\t locus));\n }\n \n /* Parses a break expression (including any label to break to AND any return\n@@ -7445,8 +7443,8 @@ Parser<ManagedTokenSource>::parse_break_expr (\n     = parse_expr (std::vector<AST::Attribute> (), restrictions);\n \n   return std::unique_ptr<AST::BreakExpr> (\n-    new AST::BreakExpr (locus, std::move (label), std::move (return_expr),\n-\t\t\tstd::move (outer_attrs)));\n+    new AST::BreakExpr (std::move (label), std::move (return_expr),\n+\t\t\tstd::move (outer_attrs), locus));\n }\n \n // Parses a continue expression (including any label to continue from).\n@@ -7477,7 +7475,7 @@ Parser<ManagedTokenSource>::parse_continue_expr (\n     }\n \n   return std::unique_ptr<AST::ContinueExpr> (\n-    new AST::ContinueExpr (locus, std::move (label), std::move (outer_attrs)));\n+    new AST::ContinueExpr (std::move (label), std::move (outer_attrs), locus));\n }\n \n // Parses a loop label used in loop expressions.\n@@ -7511,7 +7509,7 @@ Parser<ManagedTokenSource>::parse_loop_label ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfExpr>\n Parser<ManagedTokenSource>::parse_if_expr (\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED, bool pratt_parse)\n+  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n {\n   // TODO: make having outer attributes an error?\n   Location locus = Linemap::unknown_location ();\n@@ -7543,8 +7541,7 @@ Parser<ManagedTokenSource>::parse_if_expr (\n    * parsed */\n   ParseRestrictions no_struct_expr;\n   no_struct_expr.can_be_struct_expr = false;\n-  std::unique_ptr<AST::Expr> condition\n-    = parse_expr (std::vector<AST::Attribute> (), no_struct_expr);\n+  std::unique_ptr<AST::Expr> condition = parse_expr ({}, no_struct_expr);\n   if (condition == nullptr)\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n@@ -7569,7 +7566,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n     {\n       // single selection - end of if expression\n       return std::unique_ptr<AST::IfExpr> (\n-\tnew AST::IfExpr (std::move (condition), std::move (if_body), locus));\n+\tnew AST::IfExpr (std::move (condition), std::move (if_body),\n+\t\t\t std::move (outer_attrs), locus));\n     }\n   else\n     {\n@@ -7598,7 +7596,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \t    return std::unique_ptr<AST::IfExprConseqElse> (\n \t      new AST::IfExprConseqElse (std::move (condition),\n \t\t\t\t\t std::move (if_body),\n-\t\t\t\t\t std::move (else_body), locus));\n+\t\t\t\t\t std::move (else_body),\n+\t\t\t\t\t std::move (outer_attrs), locus));\n \t  }\n \t  case IF: {\n \t    // multiple selection - else if or else if let\n@@ -7620,7 +7619,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \t\treturn std::unique_ptr<AST::IfExprConseqIfLet> (\n \t\t  new AST::IfExprConseqIfLet (std::move (condition),\n \t\t\t\t\t      std::move (if_body),\n-\t\t\t\t\t      std::move (if_let_expr), locus));\n+\t\t\t\t\t      std::move (if_let_expr),\n+\t\t\t\t\t      std::move (outer_attrs), locus));\n \t      }\n \t    else\n \t      {\n@@ -7638,7 +7638,8 @@ Parser<ManagedTokenSource>::parse_if_expr (\n \t\treturn std::unique_ptr<AST::IfExprConseqIf> (\n \t\t  new AST::IfExprConseqIf (std::move (condition),\n \t\t\t\t\t   std::move (if_body),\n-\t\t\t\t\t   std::move (if_expr), locus));\n+\t\t\t\t\t   std::move (if_expr),\n+\t\t\t\t\t   std::move (outer_attrs), locus));\n \t      }\n \t  }\n \tdefault:\n@@ -7658,7 +7659,7 @@ Parser<ManagedTokenSource>::parse_if_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfLetExpr>\n Parser<ManagedTokenSource>::parse_if_let_expr (\n-  std::vector<AST::Attribute> outer_attrs ATTRIBUTE_UNUSED, bool pratt_parse)\n+  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n {\n   // TODO: make having outer attributes an error?\n   Location locus = Linemap::unknown_location ();\n@@ -7708,8 +7709,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n   // parse expression (required) - HACK to prevent struct expr being parsed\n   ParseRestrictions no_struct_expr;\n   no_struct_expr.can_be_struct_expr = false;\n-  std::unique_ptr<AST::Expr> scrutinee_expr\n-    = parse_expr (std::vector<AST::Attribute> (), no_struct_expr);\n+  std::unique_ptr<AST::Expr> scrutinee_expr = parse_expr ({}, no_struct_expr);\n   if (scrutinee_expr == nullptr)\n     {\n       rust_error_at (\n@@ -7739,7 +7739,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n       return std::unique_ptr<AST::IfLetExpr> (\n \tnew AST::IfLetExpr (std::move (match_arm_patterns),\n \t\t\t    std::move (scrutinee_expr), std::move (if_let_body),\n-\t\t\t    locus));\n+\t\t\t    std::move (outer_attrs), locus));\n     }\n   else\n     {\n@@ -7769,7 +7769,8 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t      new AST::IfLetExprConseqElse (std::move (match_arm_patterns),\n \t\t\t\t\t    std::move (scrutinee_expr),\n \t\t\t\t\t    std::move (if_let_body),\n-\t\t\t\t\t    std::move (else_body), locus));\n+\t\t\t\t\t    std::move (else_body),\n+\t\t\t\t\t    std::move (outer_attrs), locus));\n \t  }\n \t  case IF: {\n \t    // multiple selection - else if or else if let\n@@ -7791,7 +7792,8 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t\treturn std::unique_ptr<AST::IfLetExprConseqIfLet> (\n \t\t  new AST::IfLetExprConseqIfLet (\n \t\t    std::move (match_arm_patterns), std::move (scrutinee_expr),\n-\t\t    std::move (if_let_body), std::move (if_let_expr), locus));\n+\t\t    std::move (if_let_body), std::move (if_let_expr),\n+\t\t    std::move (outer_attrs), locus));\n \t      }\n \t    else\n \t      {\n@@ -7810,7 +7812,8 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n \t\t  new AST::IfLetExprConseqIf (std::move (match_arm_patterns),\n \t\t\t\t\t      std::move (scrutinee_expr),\n \t\t\t\t\t      std::move (if_let_body),\n-\t\t\t\t\t      std::move (if_expr), locus));\n+\t\t\t\t\t      std::move (if_expr),\n+\t\t\t\t\t      std::move (outer_attrs), locus));\n \t      }\n \t  }\n \tdefault:\n@@ -8887,10 +8890,10 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      AST::DelimTokenTree tok_tree = parse_delim_token_tree ();\n \n \t      return std::unique_ptr<AST::MacroInvocation> (\n-\t\tnew AST::MacroInvocation (std::move (macro_path),\n-\t\t\t\t\t  std::move (tok_tree),\n-\t\t\t\t\t  std::vector<AST::Attribute> (),\n-\t\t\t\t\t  locus));\n+\t\tnew AST::MacroInvocation (\n+\t\t  AST::MacroInvocData (std::move (macro_path),\n+\t\t\t\t       std::move (tok_tree)),\n+\t\t  {}, locus));\n \t    }\n \t    case PLUS: {\n \t      // type param bounds\n@@ -9690,10 +9693,10 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \t      AST::DelimTokenTree tok_tree = parse_delim_token_tree ();\n \n \t      return std::unique_ptr<AST::MacroInvocation> (\n-\t\tnew AST::MacroInvocation (std::move (macro_path),\n-\t\t\t\t\t  std::move (tok_tree),\n-\t\t\t\t\t  std::vector<AST::Attribute> (),\n-\t\t\t\t\t  locus));\n+\t\tnew AST::MacroInvocation (\n+\t\t  AST::MacroInvocData (std::move (macro_path),\n+\t\t\t\t       std::move (tok_tree)),\n+\t\t  {}, locus));\n \t    }\n \t    case PLUS: {\n \t      // type param bounds - not allowed, here for error message\n@@ -11465,40 +11468,38 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t     * fixed up via HACKs in semantic analysis (by checking whether it\n \t     * is the last elem in the vector). */\n \n+\t    AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n+\t\t\t\t\t\ttok_tree_loc);\n+\t    AST::MacroInvocData invoc_data (std::move (macro_path),\n+\t\t\t\t\t    std::move (delim_tok_tree));\n+\n \t    if (lexer.peek_token ()->get_id () == SEMICOLON)\n \t      {\n \t\tlexer.skip_token ();\n \n \t\tstd::unique_ptr<AST::MacroInvocationSemi> stmt (\n-\t\t  new AST::MacroInvocationSemi (std::move (macro_path), type,\n-\t\t\t\t\t\tstd::move (token_trees),\n+\t\t  new AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t\t\tstd::move (outer_attrs),\n \t\t\t\t\t\tstmt_or_expr_loc));\n \t\treturn ExprOrStmt (std::move (stmt));\n \t      }\n \n \t    // otherwise, create macro invocation\n-\t    AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n-\t\t\t\t\t\ttok_tree_loc);\n-\n \t    std::unique_ptr<AST::MacroInvocation> expr (\n-\t      new AST::MacroInvocation (std::move (macro_path),\n-\t\t\t\t\tstd::move (delim_tok_tree),\n+\t      new AST::MacroInvocation (std::move (invoc_data),\n \t\t\t\t\tstd::move (outer_attrs),\n \t\t\t\t\tstmt_or_expr_loc));\n \t    return ExprOrStmt (std::move (expr));\n \t  }\n \telse\n \t  {\n \t    // tokens don't match opening delimiters, so produce error\n-\t    rust_error_at (t2->get_locus (),\n-\t\t\t   \"unexpected token %qs - expecting closing \"\n-\t\t\t   \"delimiter %qs (for a \"\n-\t\t\t   \"macro invocation)\",\n-\t\t\t   t2->get_token_description (),\n-\t\t\t   (type == AST::PARENS\n-\t\t\t      ? \")\"\n-\t\t\t      : (type == AST::SQUARE ? \"]\" : \"}\")));\n+\t    rust_error_at (\n+\t      t2->get_locus (),\n+\t      \"unexpected token %qs - expecting closing delimiter %qs (for a \"\n+\t      \"macro invocation)\",\n+\t      t2->get_token_description (),\n+\t      (type == AST::PARENS ? \")\" : (type == AST::SQUARE ? \"]\" : \"}\")));\n \t    return ExprOrStmt::create_error ();\n \t  }\n       }\n@@ -11535,7 +11536,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t    // lexer.skip_token();\n \n \t    // HACK: add outer attrs to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    expr = std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -11586,7 +11587,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t// lexer.skip_token();\n \n \t// HACK: replace outer attributes in path\n-\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\tpath.set_outer_attrs (std::move (outer_attrs));\n \tstd::unique_ptr<AST::PathInExpression> expr (\n \t  new AST::PathInExpression (std::move (path)));\n \n@@ -11765,25 +11766,25 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n        * HACKs in semantic analysis (by checking whether it is the last elem in\n        * the vector). */\n \n+      AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n+\t\t\t\t\t  tok_tree_loc);\n+      AST::MacroInvocData invoc_data (std::move (macro_path),\n+\t\t\t\t      std::move (delim_tok_tree));\n+\n       if (lexer.peek_token ()->get_id () == SEMICOLON)\n \t{\n \t  lexer.skip_token ();\n \n \t  std::unique_ptr<AST::MacroInvocationSemi> stmt (\n-\t    new AST::MacroInvocationSemi (std::move (macro_path), type,\n-\t\t\t\t\t  std::move (token_trees),\n+\t    new AST::MacroInvocationSemi (std::move (invoc_data),\n \t\t\t\t\t  std::move (outer_attrs),\n \t\t\t\t\t  macro_locus));\n \t  return ExprOrStmt (std::move (stmt));\n \t}\n \n       // otherwise, create macro invocation\n-      AST::DelimTokenTree delim_tok_tree (type, std::move (token_trees),\n-\t\t\t\t\t  tok_tree_loc);\n-\n       std::unique_ptr<AST::MacroInvocation> expr (\n-\tnew AST::MacroInvocation (std::move (macro_path),\n-\t\t\t\t  std::move (delim_tok_tree),\n+\tnew AST::MacroInvocation (std::move (invoc_data),\n \t\t\t\t  std::move (outer_attrs), macro_locus));\n       return ExprOrStmt (std::move (expr));\n     }\n@@ -12095,11 +12096,11 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t      /* HACK: may have to become permanent, but this is my\n \t\t       * current identifier expression */\n \t\t      return std::unique_ptr<AST::IdentifierExpr> (\n-\t\t\tnew AST::IdentifierExpr (tok->get_str (),\n+\t\t\tnew AST::IdentifierExpr (tok->get_str (), {},\n \t\t\t\t\t\t tok->get_locus ()));\n \t\t    }\n \t\t  // HACK: add outer attrs to path\n-\t\t  path.replace_outer_attrs (std::move (outer_attrs));\n+\t\t  path.set_outer_attrs (std::move (outer_attrs));\n \t\t  return std::unique_ptr<AST::PathInExpression> (\n \t\t    new AST::PathInExpression (std::move (path)));\n \t\t}\n@@ -12117,11 +12118,11 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t    /* HACK: may have to become permanent, but this is my\n \t\t     * current identifier expression */\n \t\t    return std::unique_ptr<AST::IdentifierExpr> (\n-\t\t      new AST::IdentifierExpr (tok->get_str (),\n+\t\t      new AST::IdentifierExpr (tok->get_str (), {},\n \t\t\t\t\t       tok->get_locus ()));\n \t\t  }\n \t\t// HACK: add outer attrs to path\n-\t\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\t\tpath.set_outer_attrs (std::move (outer_attrs));\n \t\treturn std::unique_ptr<AST::PathInExpression> (\n \t\t  new AST::PathInExpression (std::move (path)));\n \t      }\n@@ -12135,10 +12136,11 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t/* HACK: may have to become permanent, but this is my current\n \t\t * identifier expression */\n \t\treturn std::unique_ptr<AST::IdentifierExpr> (\n-\t\t  new AST::IdentifierExpr (tok->get_str (), tok->get_locus ()));\n+\t\t  new AST::IdentifierExpr (tok->get_str (), {},\n+\t\t\t\t\t   tok->get_locus ()));\n \t      }\n \t    // HACK: add outer attrs to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    return std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -12153,33 +12155,35 @@ Parser<ManagedTokenSource>::null_denotation (\n \t// HACK: add outer attrs to path\n \tAST::QualifiedPathInExpression path\n \t  = parse_qualified_path_in_expression (true);\n-\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\tpath.set_outer_attrs (std::move (outer_attrs));\n \treturn std::unique_ptr<AST::QualifiedPathInExpression> (\n \t  new AST::QualifiedPathInExpression (std::move (path)));\n       }\n+    // FIXME: for literal exprs, should outer attrs be passed in or just\n+    // ignored?\n     case INT_LITERAL:\n       // we should check the range, but ignore for now\n       // encode as int?\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::INT,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n     case FLOAT_LITERAL:\n       // encode as float?\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::FLOAT,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n     case STRING_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (tok->get_str (), AST::Literal::STRING,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n     case TRUE_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (\"true\", AST::Literal::BOOL, tok->get_type_hint (),\n-\t\t\t      tok->get_locus ()));\n+\t\t\t      {}, tok->get_locus ()));\n     case FALSE_LITERAL:\n       return std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (\"false\", AST::Literal::BOOL,\n-\t\t\t      tok->get_type_hint (), tok->get_locus ()));\n+\t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n       case LEFT_PAREN: { // have to parse whole expression if inside brackets\n \t/* recursively invoke parse_expression with lowest priority possible as\n \t * it it were a top-level expression. */\n@@ -12218,8 +12222,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_MINUS, std::vector<AST::Attribute> (),\n-\t\t\tentered_from_unary);\n+\t  = parse_expr (LBP_UNARY_MINUS, {}, entered_from_unary);\n \n \tif (expr == nullptr)\n \t  return nullptr;\n@@ -12243,8 +12246,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_EXCLAM, std::vector<AST::Attribute> (),\n-\t\t\tentered_from_unary);\n+\t  = parse_expr (LBP_UNARY_EXCLAM, {}, entered_from_unary);\n \n \tif (expr == nullptr)\n \t  return nullptr;\n@@ -12270,8 +12272,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tentered_from_unary.entered_from_unary = true;\n \tentered_from_unary.can_be_struct_expr = false;\n \tstd::unique_ptr<AST::Expr> expr\n-\t  = parse_expr (LBP_UNARY_ASTERISK, std::vector<AST::Attribute> (),\n-\t\t\tentered_from_unary);\n+\t  = parse_expr (LBP_UNARY_ASTERISK, {}, entered_from_unary);\n \t// FIXME: allow outer attributes on expression\n \treturn std::unique_ptr<AST::DereferenceExpr> (\n \t  new AST::DereferenceExpr (std::move (expr), std::move (outer_attrs),\n@@ -12291,15 +12292,12 @@ Parser<ManagedTokenSource>::null_denotation (\n \tif (lexer.peek_token ()->get_id () == MUT)\n \t  {\n \t    lexer.skip_token ();\n-\t    expr\n-\t      = parse_expr (LBP_UNARY_AMP_MUT, std::vector<AST::Attribute> (),\n-\t\t\t    entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP_MUT, {}, entered_from_unary);\n \t    is_mut_borrow = true;\n \t  }\n \telse\n \t  {\n-\t    expr = parse_expr (LBP_UNARY_AMP, std::vector<AST::Attribute> (),\n-\t\t\t       entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP, {}, entered_from_unary);\n \t  }\n \n \t// FIXME: allow outer attributes on expression\n@@ -12318,15 +12316,12 @@ Parser<ManagedTokenSource>::null_denotation (\n \tif (lexer.peek_token ()->get_id () == MUT)\n \t  {\n \t    lexer.skip_token ();\n-\t    expr\n-\t      = parse_expr (LBP_UNARY_AMP_MUT, std::vector<AST::Attribute> (),\n-\t\t\t    entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP_MUT, {}, entered_from_unary);\n \t    is_mut_borrow = true;\n \t  }\n \telse\n \t  {\n-\t    expr = parse_expr (LBP_UNARY_AMP, std::vector<AST::Attribute> (),\n-\t\t\t       entered_from_unary);\n+\t    expr = parse_expr (LBP_UNARY_AMP, {}, entered_from_unary);\n \t  }\n \n \t// FIXME: allow outer attributes on expression\n@@ -12364,7 +12359,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \tif (tok->get_id () == SELF && path.is_single_segment ())\n \t  {\n \t    // HACK: add outer attrs to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    return std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -12394,7 +12389,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t{\n \t\t  // assume path is returned\n \t\t  // HACK: add outer attributes to path\n-\t\t  path.replace_outer_attrs (std::move (outer_attrs));\n+\t\t  path.set_outer_attrs (std::move (outer_attrs));\n \t\t  return std::unique_ptr<AST::PathInExpression> (\n \t\t    new AST::PathInExpression (std::move (path)));\n \t\t}\n@@ -12407,7 +12402,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t      {\n \t\t// assume path is returned\n \t\t// HACK: add outer attributes to path\n-\t\tpath.replace_outer_attrs (std::move (outer_attrs));\n+\t\tpath.set_outer_attrs (std::move (outer_attrs));\n \t\treturn std::unique_ptr<AST::PathInExpression> (\n \t\t  new AST::PathInExpression (std::move (path)));\n \t      }\n@@ -12416,7 +12411,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t  default:\n \t    // assume path is returned\n \t    // HACK: add outer attributes to path\n-\t    path.replace_outer_attrs (std::move (outer_attrs));\n+\t    path.set_outer_attrs (std::move (outer_attrs));\n \t    return std::unique_ptr<AST::PathInExpression> (\n \t      new AST::PathInExpression (std::move (path)));\n \t  }\n@@ -14011,7 +14006,8 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n   Location macro_locus = converted_path.get_locus ();\n \n   return std::unique_ptr<AST::MacroInvocation> (\n-    new AST::MacroInvocation (std::move (converted_path), std::move (tok_tree),\n+    new AST::MacroInvocation (AST::MacroInvocData (std::move (converted_path),\n+\t\t\t\t\t\t   std::move (tok_tree)),\n \t\t\t      std::move (outer_attrs), macro_locus));\n }\n \n@@ -14178,9 +14174,8 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n       exprs.push_back (std::move (expr));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n+\tbreak;\n+\n       lexer.skip_token ();\n \n       t = lexer.peek_token ();\n@@ -14306,7 +14301,8 @@ Parser<ManagedTokenSource>::parse_path_in_expression_pratt (const_TokenPtr tok)\n     \"current token (just about to return path to null denotation): '%s'\\n\",\n     lexer.peek_token ()->get_token_description ());\n \n-  return AST::PathInExpression (std::move (segments), tok->get_locus (), false);\n+  return AST::PathInExpression (std::move (segments), {}, tok->get_locus (),\n+\t\t\t\tfalse);\n }\n \n // Parses a closure expression with pratt parsing (from null denotation)."}, {"sha": "4f7382a7e52d634f6ce87086372ad084ed4fa03a", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -360,7 +360,7 @@ ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n void\n ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n {\n-  AST::IdentifierExpr expr (field.get_field_name (), field.get_locus ());\n+  AST::IdentifierExpr expr (field.get_field_name (), {}, field.get_locus ());\n   expr.set_node_id (field.get_node_id ());\n \n   ResolveExpr::go (&expr, field.get_node_id ());"}, {"sha": "b8742fba58f1f9f96f242f178e8ca80b767dce70", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6405f1438b2868418f94cc1673001ca2b50a65c/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=a6405f1438b2868418f94cc1673001ca2b50a65c", "patch": "@@ -366,8 +366,11 @@ Session::enable_dump (std::string arg)\n {\n   if (arg.empty ())\n     {\n-      rust_error_at (Location (), \"dump option was not given a name. choose \"\n-\t\t\t\t  \"%<lex%>, %<parse%>, or %<target_options%>\");\n+      rust_error_at (\n+\tLocation (),\n+\t\"dump option was not given a name. choose %<lex%>, %<parse%>, \"\n+\t\"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n+\t\" %<target_options%>, %<hir%>, or %<all%>\");\n       return false;\n     }\n \n@@ -401,11 +404,6 @@ Session::enable_dump (std::string arg)\n     }\n   else if (arg == \"target_options\")\n     {\n-      // special case - dump all target options, and then quit compilation\n-      // nope, option handling called before init, so have to make this an\n-      // actual compile option\n-      // options.target_data.dump_target_options();\n-      // return false;\n       options.enable_dump_option (CompileOptions::TARGET_OPTION_DUMP);\n     }\n   else if (arg == \"hir\")\n@@ -416,8 +414,9 @@ Session::enable_dump (std::string arg)\n     {\n       rust_error_at (\n \tLocation (),\n-\t\"dump option %qs was unrecognised. choose %<lex%>, %<parse%>, or \"\n-\t\"%<target_options%>\",\n+\t\"dump option %qs was unrecognised. choose %<lex%>, %<parse%>, \"\n+\t\"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n+\t\" %<target_options%>, or %<hir%>\",\n \targ.c_str ());\n       return false;\n     }"}]}