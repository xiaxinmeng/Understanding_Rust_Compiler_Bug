{"sha": "3cc9a95d27f700508a686b8414dcffff9b4d75e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjOWE5NWQyN2Y3MDA1MDhhNjg2Yjg0MTRkY2ZmZmY5YjRkNzVlOQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-25T06:31:59Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-25T06:31:59Z"}, "message": "2003-06-25  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/ObjectInputStream.java\n\t(readClassDescriptor): New method.\n\t(readObject): Moved functionality to readClassDescriptor().\n\t* java/io/ObjectOutputStream.java\n\t(writeClassDescriptor): New method.\n\t(writeObject): Moved functionality to writeClassDescriptor().\n\nFrom-SVN: r68465", "tree": {"sha": "0604196de2a75326b3e65189f1592275cda74cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0604196de2a75326b3e65189f1592275cda74cb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cc9a95d27f700508a686b8414dcffff9b4d75e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc9a95d27f700508a686b8414dcffff9b4d75e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cc9a95d27f700508a686b8414dcffff9b4d75e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc9a95d27f700508a686b8414dcffff9b4d75e9/comments", "author": null, "committer": null, "parents": [{"sha": "55a5d1f7142fcb3e5cfad518b987c20d441e78cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a5d1f7142fcb3e5cfad518b987c20d441e78cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a5d1f7142fcb3e5cfad518b987c20d441e78cd"}], "stats": {"total": 174, "additions": 96, "deletions": 78}, "files": [{"sha": "3593202c58df316125f2ac7b58d9d0ec55a94908", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc9a95d27f700508a686b8414dcffff9b4d75e9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc9a95d27f700508a686b8414dcffff9b4d75e9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3cc9a95d27f700508a686b8414dcffff9b4d75e9", "patch": "@@ -1,3 +1,12 @@\n+2003-06-25  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(readClassDescriptor): New method.\n+\t(readObject): Moved functionality to readClassDescriptor().\n+\t* java/io/ObjectOutputStream.java\n+\t(writeClassDescriptor): New method.\n+\t(writeObject): Moved functionality to writeClassDescriptor().\n+\n 2003-06-25  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/swing/plaf/basic/BasicListUI.java,"}, {"sha": "ef79727c1e112d9e3db3f0f1ea154fb81f89d6ff", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc9a95d27f700508a686b8414dcffff9b4d75e9/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc9a95d27f700508a686b8414dcffff9b4d75e9/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=3cc9a95d27f700508a686b8414dcffff9b4d75e9", "patch": "@@ -219,44 +219,7 @@ public final Object readObject () throws ClassNotFoundException, IOException\n \n \t  case TC_CLASSDESC:\n \t    {\n-\t      dumpElement (\"CLASSDESC NAME=\");\n-\t      String name = this.realInputStream.readUTF ();\n-\t      dumpElement (name + \"; UID=\");\n-\t      long uid = this.realInputStream.readLong ();\n-\t      dumpElement (Long.toHexString(uid) + \"; FLAGS=\");\n-\t      byte flags = this.realInputStream.readByte ();\n-\t      dumpElement (Integer.toHexString(flags) + \"; FIELD COUNT=\");\n-\t      short field_count = this.realInputStream.readShort ();\n-\t      dumpElementln (Short.toString(field_count));\n-\t      ObjectStreamField[] fields = new ObjectStreamField[field_count];\n-\t      ObjectStreamClass osc = new ObjectStreamClass (name, uid,\n-\t\t\t\t\t\t\t     flags, fields);\n-\t      assignNewHandle (osc);\n-\t      \n-\t      for (int i=0; i < field_count; i++)\n-\t\t{\n-\t\t  dumpElement (\"  TYPE CODE=\");\n-\t\t  char type_code = (char)this.realInputStream.readByte ();\n-\t\t  dumpElement (type_code + \"; FIELD NAME=\");\n-\t\t  String field_name = this.realInputStream.readUTF ();\n-\t\t  dumpElementln (field_name);\n-\t\t  String class_name;\n-\t\t  \n-\t\t  if (type_code == 'L' || type_code == '[')\n-\t\t    class_name = (String)readObject ();\n-\t\t  else\n-\t\t    class_name = String.valueOf (type_code);\n-\t\t  \n-\t\t  // There're many cases you can't get java.lang.Class from\n-\t\t  // typename if your context class loader can't load it,\n-\t\t  // then use typename to construct the field\n-\t\t  fields[i] =\n-\t\t    new ObjectStreamField (field_name, class_name);\n-\t\t}\n-\t      \n-\t      boolean oldmode = setBlockDataMode (true);\n-\t      osc.setClass (resolveClass (osc));\n-\t      setBlockDataMode (oldmode);\n+\t      ObjectStreamClass osc = readClassDescriptor ();\n \t      \n \t      if (!is_consumed)\n \t\t{\n@@ -451,6 +414,51 @@ public final Object readObject () throws ClassNotFoundException, IOException\n     return ret_val;\n   }\n \n+  protected ObjectStreamClass readClassDescriptor ()\n+    throws ClassNotFoundException, IOException\n+  {\n+    dumpElement (\"CLASSDESC NAME=\");\n+    String name = this.realInputStream.readUTF ();\n+    dumpElement (name + \"; UID=\");\n+    long uid = this.realInputStream.readLong ();\n+    dumpElement (Long.toHexString(uid) + \"; FLAGS=\");\n+    byte flags = this.realInputStream.readByte ();\n+    dumpElement (Integer.toHexString(flags) + \"; FIELD COUNT=\");\n+    short field_count = this.realInputStream.readShort ();\n+    dumpElementln (Short.toString(field_count));\n+    ObjectStreamField[] fields = new ObjectStreamField[field_count];\n+    ObjectStreamClass osc = new ObjectStreamClass (name, uid,\n+                                                   flags, fields);\n+    assignNewHandle (osc);\n+\t      \n+    for (int i=0; i < field_count; i++)\n+      {\n+\tdumpElement (\"  TYPE CODE=\");\n+\tchar type_code = (char)this.realInputStream.readByte ();\n+\tdumpElement (type_code + \"; FIELD NAME=\");\n+\tString field_name = this.realInputStream.readUTF ();\n+\tdumpElementln (field_name);\n+\tString class_name;\n+\t\t  \n+\tif (type_code == 'L' || type_code == '[')\n+\t  class_name = (String)readObject ();\n+\telse\n+\t  class_name = String.valueOf (type_code);\n+\t\t  \n+\t// There're many cases you can't get java.lang.Class from\n+\t// typename if your context class loader can't load it,\n+\t// then use typename to construct the field\n+\tfields[i] =\n+\t  new ObjectStreamField (field_name, class_name);\n+      }\n+\t      \n+    boolean oldmode = setBlockDataMode (true);\n+    osc.setClass (resolveClass (osc));\n+    setBlockDataMode (oldmode);\n+\t      \n+    return osc;\n+  }\n+\n   /**\n    * Reads the current objects non-transient, non-static fields from\n    * the current class from the underlying output stream."}, {"sha": "da01b57ba8d5bf0dac49115ea6219deb6429b9cd", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc9a95d27f700508a686b8414dcffff9b4d75e9/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc9a95d27f700508a686b8414dcffff9b4d75e9/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=3cc9a95d27f700508a686b8414dcffff9b4d75e9", "patch": "@@ -224,46 +224,7 @@ public final void writeObject (Object obj) throws IOException\n \t      }\n \n \t    if (obj instanceof ObjectStreamClass)\n-\t      {\n-\t\tObjectStreamClass osc = (ObjectStreamClass)obj;\n-\t\trealOutput.writeByte (TC_CLASSDESC);\n-\t\trealOutput.writeUTF (osc.getName ());\n-\t\trealOutput.writeLong (osc.getSerialVersionUID ());\n-\t\tassignNewHandle (obj);\n-\n-\t\tint flags = osc.getFlags ();\n-\n-\t\tif (protocolVersion == PROTOCOL_VERSION_2\n-\t\t    && osc.isExternalizable ())\n-\t\t  flags |= SC_BLOCK_DATA;\n-\n-\t\trealOutput.writeByte (flags);\n-\n-\t\tObjectStreamField[] fields = osc.fields;\n-\t\trealOutput.writeShort (fields.length);\n-\n-\t\tObjectStreamField field;\n-\t\tfor (int i=0; i < fields.length; i++)\n-\t\t  {\n-\t\t    field = fields[i];\n-\t\t    realOutput.writeByte (field.getTypeCode ());\n-\t\t    realOutput.writeUTF (field.getName ());\n-\n-\t\t    if (! field.isPrimitive ())\n-\t\t      writeObject (field.getTypeString ());\n-\t\t  }\n-\n-\t\tboolean oldmode = setBlockDataMode (true);\n-\t\tannotateClass (osc.forClass ());\n-\t\tsetBlockDataMode (oldmode);\n-\t\trealOutput.writeByte (TC_ENDBLOCKDATA);\n-\n-\t\tif (osc.isSerializable ())\n-\t\t  writeObject (osc.getSuper ());\n-\t\telse\n-\t\t  writeObject (null);\n-\t\tbreak;\n-\t      }\n+\t      writeClassDescriptor ((ObjectStreamClass) obj);\n \n \t    if ((replacementEnabled || obj instanceof Serializable)\n \t\t&& ! replaceDone)\n@@ -406,6 +367,46 @@ public final void writeObject (Object obj) throws IOException\n       }\n   }\n \n+  protected void writeClassDescriptor (ObjectStreamClass osc) throws IOException\n+  {\n+    realOutput.writeByte (TC_CLASSDESC);\n+    realOutput.writeUTF (osc.getName ());\n+    realOutput.writeLong (osc.getSerialVersionUID ());\n+    assignNewHandle (osc);\n+\n+    int flags = osc.getFlags ();\n+\n+    if (protocolVersion == PROTOCOL_VERSION_2\n+\t&& osc.isExternalizable ())\n+      flags |= SC_BLOCK_DATA;\n+\n+    realOutput.writeByte (flags);\n+\n+    ObjectStreamField[] fields = osc.fields;\n+    realOutput.writeShort (fields.length);\n+\n+    ObjectStreamField field;\n+    for (int i=0; i < fields.length; i++)\n+      {\n+\tfield = fields[i];\n+\trealOutput.writeByte (field.getTypeCode ());\n+\trealOutput.writeUTF (field.getName ());\n+\n+\tif (! field.isPrimitive ())\n+\t  writeObject (field.getTypeString ());\n+      }\n+\n+    boolean oldmode = setBlockDataMode (true);\n+    annotateClass (osc.forClass ());\n+    setBlockDataMode (oldmode);\n+    realOutput.writeByte (TC_ENDBLOCKDATA);\n+\n+    if (osc.isSerializable ())\n+      writeObject (osc.getSuper ());\n+    else\n+      writeObject (null);\n+  }\n+  \n   /**\n      Writes the current objects non-transient, non-static fields from\n      the current class to the underlying output stream."}]}