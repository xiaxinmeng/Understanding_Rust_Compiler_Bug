{"sha": "671970a5621e18e7079b4ca113e56434c858db66", "node_id": "C_kwDOANBUbNoAKDY3MTk3MGE1NjIxZTE4ZTcwNzliNGNhMTEzZTU2NDM0Yzg1OGRiNjY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-06-10T13:39:13Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-06-10T14:24:29Z"}, "message": "libstdc++: Make std::lcm and std::gcd detect overflow [PR105844]\n\nWhen I fixed PR libstdc++/92978 I introduced a regression whereby\nstd::lcm(INT_MIN, 1) and std::lcm(50000, 49999) would no longer produce\nerrors during constant evaluation. Those calls are undefined, because\nthey violate the preconditions that |m| and the result can be\nrepresented in the return type (which is int in both those cases). The\nregression occurred because __absu<unsigned>(INT_MIN) is well-formed,\ndue to the explicit casts to unsigned in that new helper function, and\nthe out-of-range multiplication is well-formed, because unsigned\narithmetic wraps instead of overflowing.\n\nTo fix 92978 I made std::gcm and std::lcm calculate |m| and |n|\nimmediately, yielding a common unsigned type that was used to calculate\nthe result. That was partly correct, but there's no need to use an\nunsigned type. Doing so only suppresses the overflow errors so the\ncompiler can't detect them. This change replaces __absu with __abs_r\nthat returns the common type (not its corresponding unsigned type). This\nway we can detect overflow in __abs_r when required, while still\nsupporting the most-negative value when it can be represented in the\nresult type. To detect LCM results that are out of range of the result\ntype we still need explicit checks, because neither constant evaluation\nnor UBsan will complain about unsigned wrapping for cases such as\nstd::lcm(500000u, 499999u). We can detect those overflows efficiently by\nusing __builtin_mul_overflow and asserting.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/105844\n\t* include/experimental/numeric (experimental::gcd): Simplify\n\tassertions. Use __abs_r instead of __absu.\n\t(experimental::lcm): Likewise. Remove use of __detail::__lcm so\n\toverflow can be detected.\n\t* include/std/numeric (__detail::__absu): Rename to __abs_r and\n\tchange to allow signed result type, so overflow can be detected.\n\t(__detail::__lcm): Remove.\n\t(gcd): Simplify assertions. Use __abs_r instead of __absu.\n\t(lcm): Likewise. Remove use of __detail::__lcm so overflow can\n\tbe detected.\n\t* testsuite/26_numerics/gcd/gcd_neg.cc: Adjust dg-error lines.\n\t* testsuite/26_numerics/lcm/lcm_neg.cc: Likewise.\n\t* testsuite/26_numerics/gcd/105844.cc: New test.\n\t* testsuite/26_numerics/lcm/105844.cc: New test.", "tree": {"sha": "825abe925325c2097641498395ed2345a3620479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/825abe925325c2097641498395ed2345a3620479"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/671970a5621e18e7079b4ca113e56434c858db66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671970a5621e18e7079b4ca113e56434c858db66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671970a5621e18e7079b4ca113e56434c858db66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671970a5621e18e7079b4ca113e56434c858db66/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e65f2ed99024f23c56f7b6a961898bcaa882a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e65f2ed99024f23c56f7b6a961898bcaa882a92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e65f2ed99024f23c56f7b6a961898bcaa882a92"}], "stats": {"total": 184, "additions": 123, "deletions": 61}, "files": [{"sha": "426d9430dd6998ffb5a4edda49ed15af29ea6a58", "filename": "libstdc++-v3/include/experimental/numeric", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnumeric?ref=671970a5621e18e7079b4ca113e56434c858db66", "patch": "@@ -56,35 +56,41 @@ inline namespace fundamentals_v2\n     constexpr common_type_t<_Mn, _Nn>\n     gcd(_Mn __m, _Nn __n) noexcept\n     {\n-      static_assert(is_integral_v<_Mn>,\n-\t  \"std::experimental::gcd arguments must be integers\");\n-      static_assert(is_integral_v<_Nn>,\n-\t  \"std::experimental::gcd arguments must be integers\");\n-      static_assert(_Mn(2) != _Mn(1),\n-\t  \"std::experimental::gcd arguments must not be bool\");\n-      static_assert(_Nn(2) != _Nn(1),\n-\t  \"std::experimental::gcd arguments must not be bool\");\n-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n-      return std::__detail::__gcd(std::__detail::__absu<_Up>(__m),\n-\t\t\t\t  std::__detail::__absu<_Up>(__n));\n+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,\n+\t\t    \"std::experimental::gcd arguments must be integers\");\n+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,\n+\t\t    \"std::experimental::gcd arguments must not be bool\");\n+      namespace __detail = std::__detail;\n+      using _Ct = common_type_t<_Mn, _Nn>;\n+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);\n+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);\n+      return __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);\n     }\n \n   /// Least common multiple\n   template<typename _Mn, typename _Nn>\n     constexpr common_type_t<_Mn, _Nn>\n     lcm(_Mn __m, _Nn __n)\n     {\n-      static_assert(is_integral_v<_Mn>,\n+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,\n \t  \"std::experimental::lcm arguments must be integers\");\n-      static_assert(is_integral_v<_Nn>,\n-\t  \"std::experimental::lcm arguments must be integers\");\n-      static_assert(_Mn(2) != _Mn(1),\n-\t  \"std::experimental::lcm arguments must not be bool\");\n-      static_assert(_Nn(2) != _Nn(1),\n+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,\n \t  \"std::experimental::lcm arguments must not be bool\");\n-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n-      return std::__detail::__lcm(std::__detail::__absu<_Up>(__m),\n-\t\t\t\t  std::__detail::__absu<_Up>(__n));\n+      namespace __detail = std::__detail;\n+      using _Ct = common_type_t<_Mn, _Nn>;\n+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);\n+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);\n+      if (__m2 == 0 || __n2 == 0)\n+\treturn 0;\n+      _Ct __r = __m2 / __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);\n+\n+      if _GLIBCXX17_CONSTEXPR (is_signed_v<_Ct>)\n+\tif (__is_constant_evaluated())\n+\t  return __r * __n2; // constant evaluation can detect overflow here.\n+\n+      bool __overflow = __builtin_mul_overflow(__r, __n2, &__r);\n+      __glibcxx_assert(!__overflow);\n+      return __r;\n     }\n } // namespace fundamentals_v2\n } // namespace experimental"}, {"sha": "60a99d18ffd5c1a38d0a3a6e9d148ec70bbe4751", "filename": "libstdc++-v3/include/std/numeric", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=671970a5621e18e7079b4ca113e56434c858db66", "patch": "@@ -68,6 +68,7 @@\n #if __cplusplus >= 201402L\n # include <type_traits>\n # include <bit>\n+# include <ext/numeric_traits.h>\n #endif\n \n #if __cplusplus >= 201703L\n@@ -93,19 +94,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #if __cplusplus >= 201402L\n namespace __detail\n {\n-  // std::abs is not constexpr, doesn't support unsigned integers,\n-  // and std::abs(std::numeric_limits<T>::min()) is undefined.\n-  template<typename _Up, typename _Tp>\n-    constexpr _Up\n-    __absu(_Tp __val)\n+  // Like std::abs, but supports unsigned types and returns the specified type,\n+  // so |std::numeric_limits<_Tp>::min()| is OK if representable in _Res.\n+  template<typename _Res, typename _Tp>\n+    constexpr _Res\n+    __abs_r(_Tp __val)\n     {\n-      static_assert(is_unsigned<_Up>::value, \"result type must be unsigned\");\n-      static_assert(sizeof(_Up) >= sizeof(_Tp),\n+      static_assert(sizeof(_Res) >= sizeof(_Tp),\n \t  \"result type must be at least as wide as the input type\");\n-      return __val < 0 ? -(_Up)__val : (_Up)__val;\n+\n+      if (__val >= 0)\n+\treturn __val;\n+#ifdef _GLIBCXX_ASSERTIONS\n+      if (!__is_constant_evaluated()) // overflow already detected in constexpr\n+\t__glibcxx_assert(__val != __gnu_cxx::__int_traits<_Res>::__min);\n+#endif\n+      return -static_cast<_Res>(__val);\n     }\n \n-  template<typename _Up> void __absu(bool) = delete;\n+  template<typename> void __abs_r(bool) = delete;\n \n   // GCD implementation, using Stein's algorithm\n   template<typename _Tp>\n@@ -142,16 +149,6 @@ namespace __detail\n \t  __n >>= std::__countr_zero(__n);\n \t}\n     }\n-\n-  // LCM implementation\n-  template<typename _Tp>\n-    constexpr _Tp\n-    __lcm(_Tp __m, _Tp __n)\n-    {\n-      return (__m != 0 && __n != 0)\n-\t? (__m / __detail::__gcd(__m, __n)) * __n\n-\t: 0;\n-    }\n } // namespace __detail\n \n #if __cplusplus >= 201703L\n@@ -166,27 +163,39 @@ namespace __detail\n     constexpr common_type_t<_Mn, _Nn>\n     gcd(_Mn __m, _Nn __n) noexcept\n     {\n-      static_assert(is_integral_v<_Mn>, \"std::gcd arguments must be integers\");\n-      static_assert(is_integral_v<_Nn>, \"std::gcd arguments must be integers\");\n-      static_assert(_Mn(2) != _Mn(1), \"std::gcd arguments must not be bool\");\n-      static_assert(_Nn(2) != _Nn(1), \"std::gcd arguments must not be bool\");\n-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n-      return __detail::__gcd(__detail::__absu<_Up>(__m),\n-\t\t\t     __detail::__absu<_Up>(__n));\n+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,\n+\t\t    \"std::gcd arguments must be integers\");\n+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,\n+\t\t    \"std::gcd arguments must not be bool\");\n+      using _Ct = common_type_t<_Mn, _Nn>;\n+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);\n+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);\n+      return __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);\n     }\n \n   /// Least common multiple\n   template<typename _Mn, typename _Nn>\n     constexpr common_type_t<_Mn, _Nn>\n     lcm(_Mn __m, _Nn __n) noexcept\n     {\n-      static_assert(is_integral_v<_Mn>, \"std::lcm arguments must be integers\");\n-      static_assert(is_integral_v<_Nn>, \"std::lcm arguments must be integers\");\n-      static_assert(_Mn(2) == 2, \"std::lcm arguments must not be bool\");\n-      static_assert(_Nn(2) == 2, \"std::lcm arguments must not be bool\");\n-      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n-      return __detail::__lcm(__detail::__absu<_Up>(__m),\n-\t\t\t     __detail::__absu<_Up>(__n));\n+      static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,\n+\t\t    \"std::lcm arguments must be integers\");\n+      static_assert(_Mn(2) == 2 && _Nn(2) == 2,\n+\t\t    \"std::lcm arguments must not be bool\");\n+      using _Ct = common_type_t<_Mn, _Nn>;\n+      const _Ct __m2 = __detail::__abs_r<_Ct>(__m);\n+      const _Ct __n2 = __detail::__abs_r<_Ct>(__n);\n+      if (__m2 == 0 || __n2 == 0)\n+\treturn 0;\n+      _Ct __r = __m2 / __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);\n+\n+      if constexpr (is_signed_v<_Ct>)\n+\tif (__is_constant_evaluated())\n+\t  return __r * __n2; // constant evaluation can detect overflow here.\n+\n+      bool __overflow = __builtin_mul_overflow(__r, __n2, &__r);\n+      __glibcxx_assert(!__overflow);\n+      return __r;\n     }\n \n #endif // C++17"}, {"sha": "5b6fea7b5601df0e5e9b29d63bfbe5ad8819e193", "filename": "libstdc++-v3/testsuite/26_numerics/gcd/105844.cc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F105844.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F105844.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F105844.cc?ref=671970a5621e18e7079b4ca113e56434c858db66", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile { target c++17 } }\n+#include <numeric>\n+#include <climits>\n+\n+// PR libstdc++/105844\n+\n+// |INT_MIN| can be represented in common_type_t<int, unsigned> i.e. unsigned.\n+static_assert( std::gcd(INT_MIN, 2u) == 2 );\n+static_assert( std::gcd(2u, INT_MIN) == 2 );\n+\n+// |LLONG_MIN| can be represented in unsigned long long.\n+static_assert( std::gcd(LLONG_MIN, 2ull) == 2 );\n+static_assert( std::gcd(2ull, LLONG_MIN) == 2 );\n+\n+// But |INT_MIN| cannot be represented in common_type<int, int> i.e. int.\n+constexpr int a = std::gcd(INT_MIN, 1); // { dg-error \"overflow\" }\n+constexpr int b = std::gcd(1, INT_MIN); // { dg-error \"overflow\" }\n+\n+// And |LLONG_MIN| cannot be represented in long.\n+constexpr long long c = std::gcd(LLONG_MIN, 1); // { dg-error \"overflow\" }\n+constexpr long long d = std::gcd(1, LLONG_MIN); // { dg-error \"overflow\" }"}, {"sha": "e5d03a9a45388f77a41a2f7902565a37d27ea015", "filename": "libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc?ref=671970a5621e18e7079b4ca113e56434c858db66", "patch": "@@ -45,9 +45,11 @@ test01()\n   std::gcd<const int&, const int&>(0.1, 0.1);   // { dg-error \"from here\" }\n }\n \n-// { dg-error \"must be integers\" \"\" { target *-*-* } 169 }\n-// { dg-error \"must be integers\" \"\" { target *-*-* } 170 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 171 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 172 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 0 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 0 }\n+// These prunes could be removed if a fix for PR c++/96286 stops them.\n // { dg-prune-output \"deleted function\" }\n // { dg-prune-output \"incomplete type .*make_unsigned\" }\n+// { dg-prune-output \"does not have integral type\" }\n+// { dg-prune-output \"non-integral type\" }\n+// { dg-prune-output \"invalid specialization\" }"}, {"sha": "d0e032e03e0005c873a68f2c9d575b9af968e190", "filename": "libstdc++-v3/testsuite/26_numerics/lcm/105844.cc", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2F105844.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2F105844.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2F105844.cc?ref=671970a5621e18e7079b4ca113e56434c858db66", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile { target c++17 } }\n+#include <numeric>\n+#include <climits>\n+\n+// PR libstdc++/105844\n+\n+// |INT_MIN| can be represented in common_type_t<int, unsigned> i.e. unsigned.\n+static_assert( std::lcm(INT_MIN, 1u) == INT_MAX+1u );\n+static_assert( std::lcm(1u, INT_MIN) == INT_MAX+1u );\n+\n+// But |INT_MIN| cannot be represented in common_type<int, int> i.e. int.\n+constexpr int a = std::lcm(INT_MIN, 1); // { dg-error \"overflow\" }\n+constexpr int b = std::lcm(1, INT_MIN); // { dg-error \"overflow\" }\n+\n+// And the LCM of 50000 and 49999 cannot be represented in int.\n+constexpr int c = std::lcm(50000, 49999); // { dg-error \"overflow\" }\n+constexpr int d = std::lcm(49999, 50000); // { dg-error \"overflow\" }\n+\n+// Similarly for unsigned, but the diagnostic is a failed assertion instead.\n+constexpr int e = std::lcm(500000u, 499999); // { dg-error \"in 'constexpr'\" }\n+constexpr int f = std::lcm(499999u, 500000); // { dg-error \"in 'constexpr'\" }\n+// { dg-error \"unreachable\" \"\" { target *-*-* } 0 }"}, {"sha": "77cb974aab48fec3742083ca301eb314ad6a31ac", "filename": "libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/671970a5621e18e7079b4ca113e56434c858db66/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc?ref=671970a5621e18e7079b4ca113e56434c858db66", "patch": "@@ -45,9 +45,11 @@ test01()\n   std::lcm<const int&, const int&>(0.1, 0.1);   // { dg-error \"from here\" }\n }\n \n-// { dg-error \"must be integers\" \"\" { target *-*-* } 183 }\n-// { dg-error \"must be integers\" \"\" { target *-*-* } 184 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 185 }\n-// { dg-error \"must not be bool\" \"\" { target *-*-* } 186 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 0 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 0 }\n+// These prunes could be removed if a fix for PR c++/96286 stops them.\n // { dg-prune-output \"deleted function\" }\n // { dg-prune-output \"incomplete type .*make_unsigned\" }\n+// { dg-prune-output \"does not have integral type\" }\n+// { dg-prune-output \"non-integral type\" }\n+// { dg-prune-output \"invalid specialization\" }"}]}