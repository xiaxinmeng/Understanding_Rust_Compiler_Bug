{"sha": "45f8428faabad380efc9eedc2f763c7e380ef0e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmODQyOGZhYWJhZDM4MGVmYzllZWRjMmY3NjNjN2UzODBlZjBlMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-27T21:03:02Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-27T21:03:02Z"}, "message": "Initial revision\n\nFrom-SVN: r19439", "tree": {"sha": "1d790241a1918c499dc57c417fe19619598c5254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d790241a1918c499dc57c417fe19619598c5254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45f8428faabad380efc9eedc2f763c7e380ef0e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f8428faabad380efc9eedc2f763c7e380ef0e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f8428faabad380efc9eedc2f763c7e380ef0e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f8428faabad380efc9eedc2f763c7e380ef0e2/comments", "author": null, "committer": null, "parents": [{"sha": "fe7445b0dd947a2b46e67743f689f01e592aaf17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe7445b0dd947a2b46e67743f689f01e592aaf17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe7445b0dd947a2b46e67743f689f01e592aaf17"}], "stats": {"total": 105, "additions": 105, "deletions": 0}, "files": [{"sha": "3cd23d7d6ad91ed58bd3580c674c2c51182e0520", "filename": "gcc/intl/gettext.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f8428faabad380efc9eedc2f763c7e380ef0e2/gcc%2Fintl%2Fgettext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f8428faabad380efc9eedc2f763c7e380ef0e2/gcc%2Fintl%2Fgettext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Fgettext.h?ref=45f8428faabad380efc9eedc2f763c7e380ef0e2", "patch": "@@ -0,0 +1,105 @@\n+/* Internal header for GNU gettext internationalization functions.\n+   Copyright (C) 1995, 1997 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _GETTEXT_H\n+#define _GETTEXT_H 1\n+\n+#include <stdio.h>\n+\n+#if HAVE_LIMITS_H || _LIBC\n+# include <limits.h>\n+#endif\n+\n+/* @@ end of prolog @@ */\n+\n+/* The magic number of the GNU message catalog format.  */\n+#define _MAGIC 0x950412de\n+#define _MAGIC_SWAPPED 0xde120495\n+\n+/* Revision number of the currently used .mo (binary) file format.  */\n+#define MO_REVISION_NUMBER 0\n+\n+/* The following contortions are an attempt to use the C preprocessor\n+   to determine an unsigned integral type that is 32 bits wide.  An\n+   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but\n+   doing that would require that the configure script compile and *run*\n+   the resulting executable.  Locally running cross-compiled executables\n+   is usually not possible.  */\n+\n+#if __STDC__\n+# define UINT_MAX_32_BITS 4294967295U\n+#else\n+# define UINT_MAX_32_BITS 0xFFFFFFFF\n+#endif\n+\n+/* If UINT_MAX isn't defined, assume it's a 32-bit type.\n+   This should be valid for all systems GNU cares about because\n+   that doesn't include 16-bit systems, and only modern systems\n+   (that certainly have <limits.h>) have 64+-bit integral types.  */\n+\n+#ifndef UINT_MAX\n+# define UINT_MAX UINT_MAX_32_BITS\n+#endif\n+\n+#if UINT_MAX == UINT_MAX_32_BITS\n+typedef unsigned nls_uint32;\n+#else\n+# if USHRT_MAX == UINT_MAX_32_BITS\n+typedef unsigned short nls_uint32;\n+# else\n+#  if ULONG_MAX == UINT_MAX_32_BITS\n+typedef unsigned long nls_uint32;\n+#  else\n+  /* The following line is intended to throw an error.  Using #error is\n+     not portable enough.  */\n+  \"Cannot determine unsigned 32-bit data type.\"\n+#  endif\n+# endif\n+#endif\n+\n+\n+/* Header for binary .mo file format.  */\n+struct mo_file_header\n+{\n+  /* The magic number.  */\n+  nls_uint32 magic;\n+  /* The revision number of the file format.  */\n+  nls_uint32 revision;\n+  /* The number of strings pairs.  */\n+  nls_uint32 nstrings;\n+  /* Offset of table with start offsets of original strings.  */\n+  nls_uint32 orig_tab_offset;\n+  /* Offset of table with start offsets of translation strings.  */\n+  nls_uint32 trans_tab_offset;\n+  /* Size of hashing table.  */\n+  nls_uint32 hash_tab_size;\n+  /* Offset of first hashing entry.  */\n+  nls_uint32 hash_tab_offset;\n+};\n+\n+struct string_desc\n+{\n+  /* Length of addressed string.  */\n+  nls_uint32 length;\n+  /* Offset of string in file.  */\n+  nls_uint32 offset;\n+};\n+\n+/* @@ begin of epilog @@ */\n+\n+#endif\t/* gettext.h  */"}]}