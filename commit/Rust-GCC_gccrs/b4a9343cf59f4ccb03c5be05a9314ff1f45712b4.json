{"sha": "b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRhOTM0M2NmNTlmNGNjYjAzYzViZTA1YTkzMTRmZjFmNDU3MTJiNA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2011-06-14T14:29:58Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-06-14T14:29:58Z"}, "message": "re PR middle-end/45098 (Missed induction variable optimization)\n\n2011-06-14  Zdenek Dvorak  <ook@ucw.cz>\n\t    Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/45098\n\t* cfgloop.h (nb_iterations_upper_bound, nb_iterations_estimate):\n\tDocument changed semantics.\n\t(max_stmt_executions, max_stmt_executions_int): Declare.\n\t* tree-data-ref.c (estimated_loop_iterations)\n\t(estimated_loop_iterations_int): Move functions...\n\t* tree-ssa-loop-niter.c (estimated_loop_iterations)\n\t(estimated_loop_iterations_int): here.\n\t(record_estimate): Change nb_iterations_upper_bound and\n\tnb_iterations_estimate semantics.\n\t(max_stmt_executions, max_stmt_executions_int): New function.\n\t* tree-data-ref.c (estimated_loop_iterations_tree): Rename to ...\n\t(max_stmt_executions_tree): this.\n\t(analyze_miv_subscript): Use max_stmt_executions_tree instead of\n\testimated_loop_iterations_tree.\n\ttree-ssa-loop-ivopts.c (avg_loop_niter): Use\n\tmax_stmt_executions_int instead of estimated_loop_iterations_int.\n\t* predict.c (predict_loops): Idem.\n\t* tree-parloops.c (parallelize_loops): Idem.\n\t* tree-data-ref.c (analyze_siv_subscript_cst_affine)\n\t(compute_overlap_steps_for_affine_1_2, analyze_subscript_affine_affine)\n\t(init_omega_for_ddr_1): Idem.\n\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse)\n\t(loop_prefetch_arrays): Idem\n\t* graphite-sese-to-poly.c (build_loop_iteration_domains): Use\n\tmax_stmt_executions instead of estimated_loop_iterations.\n\t* tree-data-ref.c (estimated_loop_iterations_tree): Idem.\n\t* tree-vrp.c (adjust_range_with_scev): Use estimated_loop_iterations\n\tinstead of nb_iterations_upper_bound.\n\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r175022", "tree": {"sha": "988a19c68464433ba5e738e385eec5930b88c556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/988a19c68464433ba5e738e385eec5930b88c556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d2640c430fcce5cd42c60f361eb3f0ac1a048a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2640c430fcce5cd42c60f361eb3f0ac1a048a48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2640c430fcce5cd42c60f361eb3f0ac1a048a48"}], "stats": {"total": 301, "additions": 185, "deletions": 116}, "files": [{"sha": "80cd0a425d699183aa14206ce94ac406435e8b74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -1,3 +1,36 @@\n+2011-06-14  Zdenek Dvorak  <ook@ucw.cz>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/45098\n+\t* cfgloop.h (nb_iterations_upper_bound, nb_iterations_estimate):\n+\tDocument changed semantics.\n+\t(max_stmt_executions, max_stmt_executions_int): Declare.\n+\t* tree-data-ref.c (estimated_loop_iterations)\n+\t(estimated_loop_iterations_int): Move functions...\n+\t* tree-ssa-loop-niter.c (estimated_loop_iterations)\n+\t(estimated_loop_iterations_int): here.\n+\t(record_estimate): Change nb_iterations_upper_bound and\n+\tnb_iterations_estimate semantics.\n+\t(max_stmt_executions, max_stmt_executions_int): New function.\n+\t* tree-data-ref.c (estimated_loop_iterations_tree): Rename to ...\n+\t(max_stmt_executions_tree): this.\n+\t(analyze_miv_subscript): Use max_stmt_executions_tree instead of\n+\testimated_loop_iterations_tree.\n+\ttree-ssa-loop-ivopts.c (avg_loop_niter): Use\n+\tmax_stmt_executions_int instead of estimated_loop_iterations_int.\n+\t* predict.c (predict_loops): Idem.\n+\t* tree-parloops.c (parallelize_loops): Idem.\n+\t* tree-data-ref.c (analyze_siv_subscript_cst_affine)\n+\t(compute_overlap_steps_for_affine_1_2, analyze_subscript_affine_affine)\n+\t(init_omega_for_ddr_1): Idem.\n+\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse)\n+\t(loop_prefetch_arrays): Idem\n+\t* graphite-sese-to-poly.c (build_loop_iteration_domains): Use\n+\tmax_stmt_executions instead of estimated_loop_iterations.\n+\t* tree-data-ref.c (estimated_loop_iterations_tree): Idem.\n+\t* tree-vrp.c (adjust_range_with_scev): Use estimated_loop_iterations\n+\tinstead of nb_iterations_upper_bound.\n+\n 2011-06-13  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa.c (cgraph_address_taken_from_non_vtable_p): Check the ref type."}, {"sha": "510bc10bd4ad8cdcdc11ca2be2fb657508e42fc5", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -143,11 +143,13 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n      computes and caches the computed information in this field.  */\n   tree nb_iterations;\n \n-  /* An integer guaranteed to bound the number of iterations of the loop\n-     from above.  */\n+  /* An integer guaranteed to be greater or equal to nb_iterations.  Only\n+     valid if any_upper_bound is true.  */\n   double_int nb_iterations_upper_bound;\n \n-  /* An integer giving the expected number of iterations of the loop.  */\n+  /* An integer giving an estimate on nb_iterations.  Unlike\n+     nb_iterations_upper_bound, there is no guarantee that it is at least\n+     nb_iterations.  */\n   double_int nb_iterations_estimate;\n \n   bool any_upper_bound;\n@@ -278,7 +280,9 @@ extern rtx doloop_condition_get (rtx);\n \n void estimate_numbers_of_iterations_loop (struct loop *, bool);\n HOST_WIDE_INT estimated_loop_iterations_int (struct loop *, bool);\n+HOST_WIDE_INT max_stmt_executions_int (struct loop *, bool);\n bool estimated_loop_iterations (struct loop *, bool, double_int *);\n+bool max_stmt_executions (struct loop *, bool, double_int *);\n \n /* Loop manipulation.  */\n extern bool can_duplicate_loop_p (const struct loop *loop);"}, {"sha": "7e23c9d69def87308de4ce86579b3aef9eb88701", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -1092,7 +1092,7 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n       scan_tree_for_params (SCOP_REGION (scop), nb_iters, ub_expr, one);\n       mpz_clear (one);\n \n-      if (estimated_loop_iterations (loop, true, &nit))\n+      if (max_stmt_executions (loop, true, &nit))\n \tadd_upper_bounds_from_estimated_nit (scop, nit, dim, ub_expr);\n \n       /* loop_i <= expr_nb_iters */"}, {"sha": "f5e2449f63644473c61d7f3d2c7331d234bdeda5", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -994,7 +994,7 @@ predict_loops (void)\n \t     the loop, use it to predict this exit.  */\n \t  else if (n_exits == 1)\n \t    {\n-\t      nitercst = estimated_loop_iterations_int (loop, false);\n+\t      nitercst = max_stmt_executions_int (loop, false);\n \t      if (nitercst < 0)\n \t\tcontinue;\n \t      if (nitercst > max)"}, {"sha": "ebabf61c4dba4f57290ef8b3e3ec070117b72e75", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 17, "deletions": 69, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -1621,66 +1621,18 @@ analyze_ziv_subscript (tree chrec_a,\n     fprintf (dump_file, \")\\n\");\n }\n \n-/* Sets NIT to the estimated number of executions of the statements in\n-   LOOP.  If CONSERVATIVE is true, we must be sure that NIT is at least as\n-   large as the number of iterations.  If we have no reliable estimate,\n-   the function returns false, otherwise returns true.  */\n-\n-bool\n-estimated_loop_iterations (struct loop *loop, bool conservative,\n-\t\t\t   double_int *nit)\n-{\n-  estimate_numbers_of_iterations_loop (loop, true);\n-  if (conservative)\n-    {\n-      if (!loop->any_upper_bound)\n-\treturn false;\n-\n-      *nit = loop->nb_iterations_upper_bound;\n-    }\n-  else\n-    {\n-      if (!loop->any_estimate)\n-\treturn false;\n-\n-      *nit = loop->nb_iterations_estimate;\n-    }\n-\n-  return true;\n-}\n-\n-/* Similar to estimated_loop_iterations, but returns the estimate only\n-   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n-   on the number of iterations of LOOP could not be derived, returns -1.  */\n-\n-HOST_WIDE_INT\n-estimated_loop_iterations_int (struct loop *loop, bool conservative)\n-{\n-  double_int nit;\n-  HOST_WIDE_INT hwi_nit;\n-\n-  if (!estimated_loop_iterations (loop, conservative, &nit))\n-    return -1;\n-\n-  if (!double_int_fits_in_shwi_p (nit))\n-    return -1;\n-  hwi_nit = double_int_to_shwi (nit);\n-\n-  return hwi_nit < 0 ? -1 : hwi_nit;\n-}\n-\n-/* Similar to estimated_loop_iterations, but returns the estimate as a tree,\n+/* Similar to max_stmt_executions_int, but returns the bound as a tree,\n    and only if it fits to the int type.  If this is not the case, or the\n-   estimate on the number of iterations of LOOP could not be derived, returns\n+   bound  on the number of iterations of LOOP could not be derived, returns\n    chrec_dont_know.  */\n \n static tree\n-estimated_loop_iterations_tree (struct loop *loop, bool conservative)\n+max_stmt_executions_tree (struct loop *loop)\n {\n   double_int nit;\n   tree type;\n \n-  if (!estimated_loop_iterations (loop, conservative, &nit))\n+  if (!max_stmt_executions (loop, true, &nit))\n     return chrec_dont_know;\n \n   type = lang_hooks.types.type_for_size (INT_TYPE_SIZE, true);\n@@ -1763,7 +1715,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \n \t\t      /* Perform weak-zero siv test to see if overlap is\n \t\t\t outside the loop bounds.  */\n-\t\t      numiter = estimated_loop_iterations_int (loop, false);\n+\t\t      numiter = max_stmt_executions_int (loop, true);\n \n \t\t      if (numiter >= 0\n \t\t\t  && compare_tree_int (tmp, numiter) > 0)\n@@ -1841,7 +1793,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \n \t\t      /* Perform weak-zero siv test to see if overlap is\n \t\t\t outside the loop bounds.  */\n-\t\t      numiter = estimated_loop_iterations_int (loop, false);\n+\t\t      numiter = max_stmt_executions_int (loop, true);\n \n \t\t      if (numiter >= 0\n \t\t\t  && compare_tree_int (tmp, numiter) > 0)\n@@ -2022,10 +1974,9 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n   step_z = int_cst_value (CHREC_RIGHT (chrec_b));\n \n   niter_x =\n-    estimated_loop_iterations_int (get_chrec_loop (CHREC_LEFT (chrec_a)),\n-\t\t\t\t   false);\n-  niter_y = estimated_loop_iterations_int (get_chrec_loop (chrec_a), false);\n-  niter_z = estimated_loop_iterations_int (get_chrec_loop (chrec_b), false);\n+    max_stmt_executions_int (get_chrec_loop (CHREC_LEFT (chrec_a)), true);\n+  niter_y = max_stmt_executions_int (get_chrec_loop (chrec_a), true);\n+  niter_z = max_stmt_executions_int (get_chrec_loop (chrec_b), true);\n \n   if (niter_x < 0 || niter_y < 0 || niter_z < 0)\n     {\n@@ -2350,10 +2301,8 @@ analyze_subscript_affine_affine (tree chrec_a,\n \t  HOST_WIDE_INT niter, niter_a, niter_b;\n \t  affine_fn ova, ovb;\n \n-\t  niter_a = estimated_loop_iterations_int (get_chrec_loop (chrec_a),\n-\t\t\t\t\t\t   false);\n-\t  niter_b = estimated_loop_iterations_int (get_chrec_loop (chrec_b),\n-\t\t\t\t\t\t   false);\n+\t  niter_a = max_stmt_executions_int (get_chrec_loop (chrec_a), true);\n+\t  niter_b = max_stmt_executions_int (get_chrec_loop (chrec_b), true);\n \t  niter = MIN (niter_a, niter_b);\n \t  step_a = int_cst_value (CHREC_RIGHT (chrec_a));\n \t  step_b = int_cst_value (CHREC_RIGHT (chrec_b));\n@@ -2460,10 +2409,10 @@ analyze_subscript_affine_affine (tree chrec_a,\n \n \t  if (i1 > 0 && j1 > 0)\n \t    {\n-\t      HOST_WIDE_INT niter_a = estimated_loop_iterations_int\n-\t\t(get_chrec_loop (chrec_a), false);\n-\t      HOST_WIDE_INT niter_b = estimated_loop_iterations_int\n-\t\t(get_chrec_loop (chrec_b), false);\n+\t      HOST_WIDE_INT niter_a = max_stmt_executions_int\n+\t\t(get_chrec_loop (chrec_a), true);\n+\t      HOST_WIDE_INT niter_b = max_stmt_executions_int\n+\t\t(get_chrec_loop (chrec_b), true);\n \t      HOST_WIDE_INT niter = MIN (niter_a, niter_b);\n \n \t      /* (X0, Y0) is a solution of the Diophantine equation:\n@@ -2740,8 +2689,7 @@ analyze_miv_subscript (tree chrec_a,\n \t in the same order.  */\n       *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n       *overlaps_b = conflict_fn (1, affine_fn_cst (integer_zero_node));\n-      *last_conflicts = estimated_loop_iterations_tree\n-\t\t\t\t(get_chrec_loop (chrec_a), true);\n+      *last_conflicts = max_stmt_executions_tree (get_chrec_loop (chrec_a));\n       dependence_stats.num_miv_dependent++;\n     }\n \n@@ -3754,7 +3702,7 @@ init_omega_for_ddr_1 (struct data_reference *dra, struct data_reference *drb,\n   for (i = 0; i <= DDR_INNER_LOOP (ddr)\n \t && VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), i, loopi); i++)\n     {\n-      HOST_WIDE_INT nbi = estimated_loop_iterations_int (loopi, false);\n+      HOST_WIDE_INT nbi = max_stmt_executions_int (loopi, true);\n \n       /* 0 <= loop_x */\n       ineq = omega_add_zero_geq (pb, omega_black);"}, {"sha": "9d2ea1a05f6e970170213979b0918524463dd57a", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -2134,7 +2134,7 @@ parallelize_loops (void)\n \t  /* FIXME: the check for vector phi nodes could be removed.  */\n \t  || loop_has_vector_phi_nodes (loop))\n \tcontinue;\n-      estimated = estimated_loop_iterations_int (loop, false);\n+      estimated = max_stmt_executions_int (loop, false);\n       /* FIXME: Bypass this check as graphite doesn't update the\n       count and frequency correctly now.  */\n       if (!flag_loop_parallelize_all"}, {"sha": "3717639f0d2ca28dd70ae304649b9aa56be956f1", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -115,7 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n static inline HOST_WIDE_INT\n avg_loop_niter (struct loop *loop)\n {\n-  HOST_WIDE_INT niter = estimated_loop_iterations_int (loop, false);\n+  HOST_WIDE_INT niter = max_stmt_executions_int (loop, false);\n   if (niter == -1)\n     return AVG_LOOP_NITER (loop);\n "}, {"sha": "fa3ccc63f59202e1a7cd9954d12c0aa09e0987be", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 92, "deletions": 6, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -2568,18 +2568,17 @@ record_estimate (struct loop *loop, tree bound, double_int i_bound,\n     }\n \n   /* Update the number of iteration estimates according to the bound.\n-     If at_stmt is an exit, then every statement in the loop is\n-     executed at most BOUND + 1 times.  If it is not an exit, then\n-     some of the statements before it could be executed BOUND + 2\n-     times, if an exit of LOOP is before stmt.  */\n+     If at_stmt is an exit or dominates the single exit from the loop,\n+     then the loop latch is executed at most BOUND times, otherwise\n+     it can be executed BOUND + 1 times.  */\n   exit = single_exit (loop);\n   if (is_exit\n       || (exit != NULL\n \t  && dominated_by_p (CDI_DOMINATORS,\n \t\t\t     exit->src, gimple_bb (at_stmt))))\n-    delta = double_int_one;\n+    delta = double_int_zero;\n   else\n-    delta = double_int_two;\n+    delta = double_int_one;\n   i_bound = double_int_add (i_bound, delta);\n \n   /* If an overflow occurred, ignore the result.  */\n@@ -3042,6 +3041,93 @@ estimate_numbers_of_iterations_loop (struct loop *loop, bool use_undefined_p)\n     loop->nb_iterations_estimate = loop->nb_iterations_upper_bound;\n }\n \n+/* Sets NIT to the estimated number of executions of the latch of the\n+   LOOP.  If CONSERVATIVE is true, we must be sure that NIT is at least as\n+   large as the number of iterations.  If we have no reliable estimate,\n+   the function returns false, otherwise returns true.  */\n+\n+bool\n+estimated_loop_iterations (struct loop *loop, bool conservative,\n+\t\t\t   double_int *nit)\n+{\n+  estimate_numbers_of_iterations_loop (loop, true);\n+  if (conservative)\n+    {\n+      if (!loop->any_upper_bound)\n+\treturn false;\n+\n+      *nit = loop->nb_iterations_upper_bound;\n+    }\n+  else\n+    {\n+      if (!loop->any_estimate)\n+\treturn false;\n+\n+      *nit = loop->nb_iterations_estimate;\n+    }\n+\n+  return true;\n+}\n+\n+/* Similar to estimated_loop_iterations, but returns the estimate only\n+   if it fits to HOST_WIDE_INT.  If this is not the case, or the estimate\n+   on the number of iterations of LOOP could not be derived, returns -1.  */\n+\n+HOST_WIDE_INT\n+estimated_loop_iterations_int (struct loop *loop, bool conservative)\n+{\n+  double_int nit;\n+  HOST_WIDE_INT hwi_nit;\n+\n+  if (!estimated_loop_iterations (loop, conservative, &nit))\n+    return -1;\n+\n+  if (!double_int_fits_in_shwi_p (nit))\n+    return -1;\n+  hwi_nit = double_int_to_shwi (nit);\n+\n+  return hwi_nit < 0 ? -1 : hwi_nit;\n+}\n+\n+/* Returns an upper bound on the number of executions of statements\n+   in the LOOP.  For statements before the loop exit, this exceeds\n+   the number of execution of the latch by one.  */\n+\n+HOST_WIDE_INT\n+max_stmt_executions_int (struct loop *loop, bool conservative)\n+{\n+  HOST_WIDE_INT nit = estimated_loop_iterations_int (loop, conservative);\n+  HOST_WIDE_INT snit;\n+\n+  if (nit == -1)\n+    return -1;\n+\n+  snit = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) nit + 1);\n+\n+  /* If the computation overflows, return -1.  */\n+  return snit < 0 ? -1 : snit;\n+}\n+\n+/* Sets NIT to the estimated number of executions of the latch of the\n+   LOOP, plus one.  If CONSERVATIVE is true, we must be sure that NIT is at\n+   least as large as the number of iterations.  If we have no reliable\n+   estimate, the function returns false, otherwise returns true.  */\n+\n+bool\n+max_stmt_executions (struct loop *loop, bool conservative, double_int *nit)\n+{\n+  double_int nit_minus_one;\n+\n+  if (!estimated_loop_iterations (loop, conservative, nit))\n+    return false;\n+\n+  nit_minus_one = *nit;\n+\n+  *nit = double_int_add (*nit, double_int_one);\n+\n+  return double_int_ucmp (*nit, nit_minus_one) > 0;\n+}\n+\n /* Records estimates on numbers of iterations of loops.  */\n \n void"}, {"sha": "9d9d249d2c22777514e85d60d5b28b6eeb6ac041", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -1549,7 +1549,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n \tcontinue;\n \n       aloop = VEC_index (loop_p, vloops, i);\n-      vol = estimated_loop_iterations_int (aloop, false);\n+      vol = max_stmt_executions_int (aloop, false);\n       if (vol < 0)\n \tvol = expected_loop_iterations (aloop);\n       volume *= vol;\n@@ -1801,7 +1801,7 @@ loop_prefetch_arrays (struct loop *loop)\n     return false;\n \n   ahead = (PREFETCH_LATENCY + time - 1) / time;\n-  est_niter = estimated_loop_iterations_int (loop, false);\n+  est_niter = max_stmt_executions_int (loop, false);\n \n   /* Prefetching is not likely to be profitable if the trip count to ahead\n      ratio is too small.  */"}, {"sha": "0ca27eff6e6c1fdf1a18141d5d39b24a205f637b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "patch": "@@ -3403,44 +3403,42 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop,\n     tmax = TYPE_MAX_VALUE (type);\n \n   /* Try to use estimated number of iterations for the loop to constrain the\n-     final value in the evolution.\n-     We are interested in the number of executions of the latch, while\n-     nb_iterations_upper_bound includes the last execution of the exit test.  */\n+     final value in the evolution.  */\n   if (TREE_CODE (step) == INTEGER_CST\n-      && loop->any_upper_bound\n-      && !double_int_zero_p (loop->nb_iterations_upper_bound)\n       && is_gimple_val (init)\n       && (TREE_CODE (init) != SSA_NAME\n \t  || get_value_range (init)->type == VR_RANGE))\n     {\n-      value_range_t maxvr = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n-      double_int dtmp;\n-      bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (step));\n-      int overflow = 0;\n-\n-      dtmp = double_int_mul_with_sign (tree_to_double_int (step),\n-                                       double_int_sub (\n-                                           loop->nb_iterations_upper_bound,\n-                                           double_int_one),\n-                                       unsigned_p, &overflow);\n-      /* If the multiplication overflowed we can't do a meaningful\n-\t adjustment.  Likewise if the result doesn't fit in the type\n-\t of the induction variable.  For a signed type we have to\n-\t check whether the result has the expected signedness which\n-\t is that of the step as nb_iterations_upper_bound is unsigned.  */\n-      if (!overflow\n-\t  && double_int_fits_to_tree_p (TREE_TYPE (init), dtmp)\n-\t  && (unsigned_p\n-\t      || ((dtmp.high ^ TREE_INT_CST_HIGH (step)) >= 0)))\n-\t{\n-\t  tem = double_int_to_tree (TREE_TYPE (init), dtmp);\n-\t  extract_range_from_binary_expr (&maxvr, PLUS_EXPR,\n-\t\t\t\t\t  TREE_TYPE (init), init, tem);\n-\t  /* Likewise if the addition did.  */\n-\t  if (maxvr.type == VR_RANGE)\n+      double_int nit;\n+\n+      if (estimated_loop_iterations (loop, true, &nit))\n+\t{\n+\t  value_range_t maxvr = { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL };\n+\t  double_int dtmp;\n+\t  bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (step));\n+\t  int overflow = 0;\n+\n+\t  dtmp = double_int_mul_with_sign (tree_to_double_int (step), nit,\n+\t\t\t\t\t   unsigned_p, &overflow);\n+\t  /* If the multiplication overflowed we can't do a meaningful\n+\t     adjustment.  Likewise if the result doesn't fit in the type\n+\t     of the induction variable.  For a signed type we have to\n+\t     check whether the result has the expected signedness which\n+\t     is that of the step as number of iterations is unsigned.  */\n+\t  if (!overflow\n+\t      && double_int_fits_to_tree_p (TREE_TYPE (init), dtmp)\n+\t      && (unsigned_p\n+\t\t  || ((dtmp.high ^ TREE_INT_CST_HIGH (step)) >= 0)))\n \t    {\n-\t      tmin = maxvr.min;\n-\t      tmax = maxvr.max;\n+\t      tem = double_int_to_tree (TREE_TYPE (init), dtmp);\n+\t      extract_range_from_binary_expr (&maxvr, PLUS_EXPR,\n+\t\t\t\t\t      TREE_TYPE (init), init, tem);\n+\t      /* Likewise if the addition did.  */\n+\t      if (maxvr.type == VR_RANGE)\n+\t\t{\n+\t\t  tmin = maxvr.min;\n+\t\t  tmax = maxvr.max;\n+\t\t}\n \t    }\n \t}\n     }"}]}