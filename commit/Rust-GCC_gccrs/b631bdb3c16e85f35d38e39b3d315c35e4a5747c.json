{"sha": "b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYzMWJkYjNjMTZlODVmMzVkMzhlMzliM2QzMTVjMzVlNGE1NzQ3Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-07-25T00:29:17Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-07-25T00:29:17Z"}, "message": "PR tree-optimization/91183 - strlen of a strcpy result with a conditional source not folded\n\nPR tree-optimization/91183 - strlen of a strcpy result with a conditional source not folded\nPR tree-optimization/86688 - missing -Wstringop-overflow using a non-string local array in strnlen with excessive bound\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/91183\n\tPR tree-optimization/86688\n\t* builtins.c (compute_objsize): Handle MEM_REF.\n\t* tree-ssa-strlen.c (class ssa_name_limit_t): New.\n\t(get_min_string_length): Remove.\n\t(count_nonzero_bytes): New function.\n\t(handle_char_store): Rename...\n\t(handle_store): to this.  Handle multibyte stores via integer types.\n\t(strlen_check_and_optimize_stmt): Adjust conditional and the called\n\tfunction name.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/91183\n\tPR tree-optimization/86688\n\t* gcc.dg/Wstringop-overflow-14.c: New test.\n\t* gcc.dg/attr-nonstring-2.c: Remove xfails.\n\t* gcc.dg/strlenopt-70.c: New test.\n\t* gcc.dg/strlenopt-71.c: New test.\n\t* gcc.dg/strlenopt-72.c: New test.\n\t* gcc.dg/strlenopt-8.c: Remove xfails.\n\nFrom-SVN: r273783", "tree": {"sha": "946823534c8cde2d83143cbdcd1e5d6e8d8d7955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/946823534c8cde2d83143cbdcd1e5d6e8d8d7955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7214f11d4708a62868f4b0830ef65b87976d1826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7214f11d4708a62868f4b0830ef65b87976d1826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7214f11d4708a62868f4b0830ef65b87976d1826"}], "stats": {"total": 1135, "additions": 1035, "deletions": 100}, "files": [{"sha": "45221a4a7446226ba02c9f674d7783afa22165ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -14,6 +14,19 @@\n \t* config/msp430/msp430.h (ENDFILE_SPEC): Wrap uses of crtn*.o in\n \tif-exists.\n \n+2019-07-24  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91183\n+\tPR tree-optimization/86688\n+\t* builtins.c (compute_objsize): Handle MEM_REF.\n+\t* tree-ssa-strlen.c (class ssa_name_limit_t): New.\n+\t(get_min_string_length): Remove.\n+\t(count_nonzero_bytes): New function.\n+\t(handle_char_store): Rename...\n+\t(handle_store): to this.  Handle multibyte stores via integer types.\n+\t(strlen_check_and_optimize_stmt): Adjust conditional and the called\n+\tfunction name.\n+\n 2019-07-24  Martin Sebor  <msebor@redhat.com>\n \n \tPR driver/80545"}, {"sha": "695a9d191af4c4922351e3e59601a87b3fedda5c", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -3652,6 +3652,20 @@ compute_objsize (tree dest, int ostype)\n   if (!ostype)\n     return NULL_TREE;\n \n+  if (TREE_CODE (dest) == MEM_REF)\n+    {\n+      tree ref = TREE_OPERAND (dest, 0);\n+      tree off = TREE_OPERAND (dest, 1);\n+      if (tree size = compute_objsize (ref, ostype))\n+\t{\n+\t  if (tree_int_cst_lt (off, size))\n+\t    return fold_build2 (MINUS_EXPR, size_type_node, size, off);\n+\t  return integer_zero_node;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n   if (TREE_CODE (dest) != ADDR_EXPR)\n     return NULL_TREE;\n "}, {"sha": "532d1c195a3e8b796adbe5f62f8f68585580c401", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -1,3 +1,15 @@\n+2019-07-24  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91183\n+\tPR tree-optimization/86688\n+\t* gcc/testsuite/c-c++-common/ubsan/object-size-9.c: Disable warnings.\n+\t* gcc.dg/Wstringop-overflow-14.c: New test.\n+\t* gcc.dg/attr-nonstring-2.c: Remove xfails.\n+\t* gcc.dg/strlenopt-70.c: New test.\n+\t* gcc.dg/strlenopt-71.c: New test.\n+\t* gcc.dg/strlenopt-72.c: New test.\n+\t* gcc.dg/strlenopt-8.c: Remove xfails.\n+\n 2019-07-24  Martin Sebor  <msebor@redhat.com>\n \n \tPR driver/80545"}, {"sha": "bd2a53e643946d15b09df33dd5c98f98b44d16b2", "filename": "gcc/testsuite/c-c++-common/ubsan/object-size-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fobject-size-9.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } } */\n-/* { dg-options \"-fsanitize=undefined\" } */\n+/* { dg-options \"-Wno-stringop-overflow -fsanitize=undefined\" } */\n \n /* Test PARM_DECLs and RESULT_DECLs.  */\n "}, {"sha": "d23a248446bf9382c015a76cd8c48d7a29ec0847", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-14.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -0,0 +1,49 @@\n+/* Test to verify that past-the-end multibyte writes via lvalues of wider\n+   types than char are diagnosed.\n+   { dg-do compile }\n+   { dg-require-effective-target int32plus }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __INT16_TYPE__  int16_t;\n+typedef __INT32_TYPE__  int32_t;\n+typedef __INT64_TYPE__  int64_t;\n+typedef __SIZE_TYPE__   size_t;\n+\n+void* memcpy (void*, const void*, size_t);\n+char* strcpy (char*, const char*);\n+\n+char a4[4], a8[8], a16[16];\n+\n+const char s4[] = \"1234\";\n+const char t4[] = \"4321\";\n+\n+void test_memcpy_cond (int i)\n+{\n+  char *p = a4 + 1;\n+  const char *q = i ? s4 : t4;\n+  memcpy (p, q, 4);         // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+}\n+\n+\n+void test_int16 (void)\n+{\n+  char *p = a4 + 1;\n+  *(int16_t*)p = 0;\n+  *(int16_t*)(p + 2) = 0;   // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+}\n+\n+\n+void test_int32 (void)\n+{\n+  char *p = a8 + 3;\n+  *(int32_t*)p = 0;\n+  *(int32_t*)(p + 2) = 0;   // { dg-warning \"writing 4 bytes into a region of size 3\" }\n+}\n+\n+\n+void test_int64 (void)\n+{\n+  char *p = a16 + 5;\n+  *(int64_t*)p = 0;\n+  *(int64_t*)(p + 5) = 0;   // { dg-warning \"writing 8 bytes into a region of size 6\" }\n+}"}, {"sha": "ef2144d62075fdafbd5568a804e0c45844afa119", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -73,8 +73,8 @@ void test_strnlen_string_cst (void)\n   T (3, \"12\",  3, 1);\n   T (3, \"12\",  3, 9);\n   T (3, \"123\", 3, 1);\n-  T (3, \"123\", 3, 4);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" \"bug 86688\" { xfail *-*-* } } */\n-  T (3, \"123\", 3, 9);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 9\" \"bug 86688\" { xfail *-*-* } } */\n+  T (3, \"123\", 3, 4);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 4\" } */\n+  T (3, \"123\", 3, 9);               /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound 9\" } */\n \n   T (5, \"1\",   2, 1);\n   T (5, \"1\",   2, 2);\n@@ -110,6 +110,6 @@ void test_strnlen_string_range (void)\n {\n   T (3, \"1\",   2, UR (0, 1));\n   T (3, \"1\",   2, UR (3, 9));\n-  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[4, 5]\" \"bug 86688\" { xfail *-*-* } } */\n-  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[5, 9]\" \"bug 86688\" { xfail *-*-* } } */\n+  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[4, 5]\" } */\n+  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"argument 1 declared attribute .nonstring. is smaller than the specified bound \\\\\\[5, 9]\" } */\n }"}, {"sha": "2dc42d6e26e84368408f563a4345b3cb88783a15", "filename": "gcc/testsuite/gcc.dg/strlenopt-70.c", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-70.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -0,0 +1,293 @@\n+/* PR tree-optimization/91183 - strlen of a strcpy result with a conditional\n+   source not folded\n+   Test to verify that strlen can determine string lengths from wider stores\n+   than narrow characters.  This matters because on targets that can handle\n+   unaligned stores and where GCC lowers multi-character stores into smaller\n+   numbers of wider stores.\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" }  */\n+\n+#include \"strlenopt.h\"\n+\n+#define CHAR_BIT __CHAR_BIT__\n+\n+typedef __INT16_TYPE__  int16_t;\n+typedef __INT32_TYPE__  int32_t;\n+typedef __INT64_TYPE__  int64_t;\n+typedef __UINT64_TYPE__ uint64_t;\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macros to emit a call to function named\n+     call_failed_to_be_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\t\\\n+  if ((expr)) FAIL (not_eliminated); else (void)0\n+\n+/* Verify that 'strlen (A) EXPECT' is folded to true.  When non-null,\n+   the first sizeof (INIT) - 1 bytes of the INIT arrray are stored\n+   in A first, followed by *(TYPE*)A = ASSIGN.  */\n+#define T(init, type, off, assign, expect) do {\t\t\t\\\n+    char a[32];\t\t\t\t\t\t\t\\\n+    memcpy (a, init ? init : \"\", init ? sizeof init - 1 : 0);\t\\\n+    *(type*)(a + off) = assign;\t\t\t\t\t\\\n+    ELIM (!(strlen (a) expect));\t\t\t\t\\\n+  } while (0)\n+\n+/* Same as above but the assignment consisting of the two quadwords\n+   QW1 and QW2 to support int128_t.  */\n+#define T2(init, type, off, qw0, qw1, expect) do {\t\t\t\\\n+    char a[32];\t\t\t\t\t\t\t\t\\\n+    memcpy (a, init ? init : \"\", init ? sizeof init - 1: 0);\t\t\\\n+    type assign = ((type)qw0 << (sizeof (type) * CHAR_BIT / 2)) | (type)qw1; \\\n+    *(type*)(a + off) = assign;\t\t\t\t\t\t\\\n+    ELIM (!(strlen (a) expect));\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Same as T but works around the optimizer dropping the initializing\n+   store before the assignment and defeating the strlen optimization.  */\n+#define TX(init, type, off, assign, expect) do {\t\t\\\n+    char a[32];\t\t\t\t\t\t\t\\\n+    strcpy (a, init + 2);\t\t\t\t\t\\\n+    strcat (a, init + sizeof (init) - 3);\t\t\t\\\n+    *(type*)(a + off) = assign;\t\t\t\t\t\\\n+    ELIM (!(strlen (a) expect));\t\t\t\t\\\n+  } while (0)\n+\n+\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+#  define I16(s) ((s[0] << 8) + s[1])\n+#  define I32(s) ((s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3])\n+#  define I64(s)\t\t\t\t\t\t\\\n+  (((uint64_t)s[0] << 56)\t\t\t\t\t\\\n+   + ((uint64_t)s[1] << 48)\t\t\t\t\t\\\n+   + ((uint64_t)s[2] << 40)\t\t\t\t\t\\\n+   + ((uint64_t)s[3] << 32)\t\t\t\t\t\\\n+   + ((uint64_t)s[4] << 24)\t\t\t\t\t\\\n+   + ((uint64_t)s[5] << 16)\t\t\t\t\t\\\n+   + ((uint64_t)s[6] << 8)\t\t\t\t\t\\\n+   + s[7])\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+#  define I16(s) ((s[1] << 8) + s[0])\n+#  define I32(s) ((s[3] << 24) + (s[2] << 16) + (s[1] << 8) + s[0])\n+#  define I64(s)\t\t\t\t\t\t\\\n+  (((uint64_t)s[7] << 56)\t\t\t\t\t\\\n+   + ((uint64_t)s[6] << 48)\t\t\t\t\t\\\n+   + ((uint64_t)s[5] << 40)\t\t\t\t\t\\\n+   + ((uint64_t)s[4] << 32)\t\t\t\t\t\\\n+   + ((uint64_t)s[3] << 24)\t\t\t\t\t\\\n+   + ((uint64_t)s[2] << 16)\t\t\t\t\t\\\n+   + ((uint64_t)s[1] << 8)\t\t\t\t\t\\\n+   + s[0])\n+#endif\n+\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+\n+void store_16bit_be (void)\n+{\n+  T (\"xxx\", int16_t, 0, 0x0001, == 0);\n+  T (\"xxx\", int16_t, 0, 0x0010, == 0);\n+  T (\"xxx\", int16_t, 0, 0x0011, == 0);\n+  T (\"xxx\", int16_t, 0, 0x0100, == 1);\n+  T (\"xxx\", int16_t, 0, 0x1000, == 1);\n+  T (\"xxx\", int16_t, 0, 0x1100, == 1);\n+}\n+\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+\n+void store_16bit_le (int i)\n+{\n+  int16_t x0000 = I16 (\"\\0\\0\");\n+  int16_t x0001 = 0x0001;\n+  int16_t x0010 = 0x0010;\n+  int16_t x0011 = 0x0011;\n+  int16_t x0100 = 0x0100;\n+  int16_t x1000 = 0x1000;\n+  int16_t x1100 = 0x1100;\n+\n+  T (0,        int16_t, 0, x0000, == 0);\n+  T (\"x\",      int16_t, 0, x0000, == 0);\n+  T (\"xx\",     int16_t, 0, x0000, == 0);\n+  T (\"xxxx\",   int16_t, 0, x0000, == 0);\n+  T (0,        int16_t, 0, x0001, == 1);\n+  T (\"\\0\\0\\0\", int16_t, 0, x0001, == 1);\n+  T (0,        int16_t, 0, x0010, == 1);\n+  T (\"x\\0\\0\",  int16_t, 0, x0010, == 1);\n+  T (0,        int16_t, 0, x0011, == 1);\n+  T (\"xx\\0\",   int16_t, 0, x0011, == 1);\n+  T (0,        int16_t, 0, x0100, == 0);\n+  T (\"\\0\\0\\0\", int16_t, 0, x0100, == 0);\n+  T (0,        int16_t, 0, x1000, == 0);\n+  T (\"x\\0\\0\",  int16_t, 0, x1000, == 0);\n+  T (0,        int16_t, 0, x1100, == 0);\n+  T (\"xx\\0\",   int16_t, 0, x1100, == 0);\n+\n+  // FIXME: This fails because of the next test but succeeds on its own.\n+  // T (0,        int16_t, 0, i ? x0001 : x0010, == 1);\n+  T (\"xxx\",    int16_t, 0, i ? x0100 : x1100, == 0);\n+}\n+\n+#endif\n+\n+void store_32bit (volatile int i)\n+{\n+  T (0,      int32_t, 0, 0, == 0);\n+  T (\"x\",    int32_t, 0, 0, == 0);\n+  T (\"xx\",   int32_t, 0, 0, == 0);\n+  T (\"xxx\",  int32_t, 0, 0, == 0);\n+  T (\"xxxx\", int32_t, 0, 0, == 0);\n+\n+  T (\"\\0\",   int32_t, 1, 0, == 0);\n+  T (\"x\",    int32_t, 1, 0, == 1);\n+  T (\"xx\",   int32_t, 2, 0, == 2);\n+  T (\"xxx\",  int32_t, 3, 0, == 3);\n+\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\01\\0\\0\\0\"), == 1);\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\0\\01\\0\\0\"), == 0);\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\0\\0\\01\\0\"), == 0);\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\0\\0\\0\\01\"), == 0);\n+\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\1\\2\\0\\0\"), == 2);\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\0\\1\\2\\0\"), == 0);\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\0\\0\\1\\2\"), == 0);\n+\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\1\\2\\3\\0\"), == 3);\n+  T (\"xxx\",  int32_t, 0, I32 (\"\\0\\1\\2\\3\"), == 0);\n+\n+  int32_t x00332211 = I32 (\"123\\0\");\n+  int32_t x00002211 = I32 (\"12\\0\\0\");\n+  int32_t x00000011 = I32 (\"1\\0\\0\\0\");\n+\n+  T (\"xxxx\", int32_t, 0, i ? x00332211 : x00002211, <= 3);\n+  T (\"xxxx\", int32_t, 0, i ? x00332211 : x00002211, >= 2);\n+  T (\"xxxx\", int32_t, 0, i ? x00332211 : x00000011, <= 3);\n+  T (\"xxxx\", int32_t, 0, i ? x00332211 : x00000011, >= 1);\n+\n+  TX (\"abcde\",  int32_t, 0, i ? I32 (\"1234\") : I32 (\"1235\"), == 5);\n+  TX (\"abcde\",  int32_t, 1, i ? I32 (\"1234\") : I32 (\"1235\"), == 5);\n+\n+  TX (\"abcdef\", int32_t, 0, i ? I32 (\"1235\") : I32 (\"1234\"), == 6);\n+  TX (\"abcdef\", int32_t, 1, i ? I32 (\"1235\") : I32 (\"1234\"), == 6);\n+  TX (\"abcdef\", int32_t, 2, i ? I32 (\"1235\") : I32 (\"1234\"), == 6);\n+  TX (\"abcdef\", int32_t, 3, i ? I32 (\"124\\0\") : I32 (\"123\\0\"), == 6);\n+  TX (\"abcdef\", int32_t, 3, i ? I32 (\"12\\0\\0\") : I32 (\"13\\0\\0\"), == 5);\n+\n+  TX (\"abcdef\", int32_t, 3, i ? I32 (\"12\\0\\0\") : I32 (\"123\\0\"), >= 5);\n+  TX (\"abcdef\", int32_t, 3, i ? I32 (\"12\\0\\0\") : I32 (\"123\\0\"), < 7);\n+}\n+\n+void store_64bit (int i)\n+{\n+  T2 (\"xxxxxxx\", int64_t, 0,                0, I32 (\"\\1\\0\\0\\0\"), == 1);\n+  T2 (\"xxxxxxx\", int64_t, 0,                0, I32 (\"\\0\\1\\0\\0\"), == 0);\n+  T2 (\"xxxxxxx\", int64_t, 0,                0, I32 (\"\\0\\0\\1\\0\"), == 0);\n+  T2 (\"xxxxxxx\", int64_t, 0,                0, I32 (\"\\0\\00\\0\\1\"), == 0);\n+  T2 (\"xxxxxxx\", int64_t, 0, I32 (\"\\1\\0\\0\\0\"), 0, == 0);\n+  T2 (\"xxxxxxx\", int64_t, 0, I32 (\"\\0\\1\\0\\0\"), 0, == 0);\n+  T2 (\"xxxxxxx\", int64_t, 0, I32 (\"\\0\\0\\1\\0\"), 0, == 0);\n+  T2 (\"xxxxxxx\", int64_t, 0, I32 (\"\\0\\0\\0\\1\"), 0, == 0);\n+\n+  T2 (\"xxxxxxx\", int64_t, 0, 0, I32 (\"\\1\\2\\0\\0\"), == 2);\n+  T2 (\"xxxxxxx\", int64_t, 0, 0, I32 (\"\\0\\1\\2\\0\"), == 0);\n+  T2 (\"xxxxxxx\", int64_t, 0, 0, I32 (\"\\0\\0\\1\\2\"), == 0);\n+\n+  T2 (\"xxxxxxx\", int64_t, 0, 0, I32 (\"\\1\\2\\3\\0\"), == 3);\n+  T2 (\"xxxxxxx\", int64_t, 0, 0, I32 (\"\\0\\1\\2\\3\"), == 0);\n+\n+  T2 (\"xxxxxxx\", int64_t, 0, 0, I32 (\"\\1\\2\\3\\4\"), == 4);\n+  T2 (\"xxxxxxx\", int64_t, 0, I32 (\"\\5\\0\\0\\0\"), I32 (\"\\1\\2\\3\\4\"), == 5);\n+  T2 (\"xxxxxxx\", int64_t, 0, I32 (\"\\5\\6\\0\\0\"), I32 (\"\\1\\2\\3\\4\"), == 6);\n+  T2 (\"xxxxxxx\", int64_t, 0, I32 (\"\\5\\6\\7\\0\"), I32 (\"\\1\\2\\3\\4\"), == 7);\n+\n+  int64_t x7777777 = I64 (\"\\7\\7\\7\\7\\7\\7\\7\");\n+  int64_t x666666 = I64 (\"\\6\\6\\6\\6\\6\\6\\0\");\n+  int64_t x4444 = I64 (\"\\4\\4\\4\\4\\0\\0\\0\");\n+  int64_t x3333 = I64 (\"\\3\\3\\3\\3\\0\\0\\0\");\n+  int64_t x1 = I64 (\"\\1\\0\\0\\0\\0\\0\\0\");\n+\n+  T (\"x\\0xxxxxx\", int64_t, 0, i ? x7777777 : x666666, <= 7);\n+  T (\"xx\\0xxxxx\", int64_t, 0, i ? x7777777 : x666666, >= 6);\n+  T (\"xxx\\0xxxx\", int64_t, 0, i ? x666666 : x1, <= 6);\n+  T (\"xxxx\\0xxx\", int64_t, 0, i ? x666666 : x1, >= 1);\n+  T (\"xxxxxx\\0x\", int64_t, 0, i ? x4444 : x3333, == 4);\n+}\n+\n+#ifdef __uint128_t\n+\n+typedef __uint128_t     uint128_t;\n+\n+void store_128bit (void)\n+{\n+  uint64_t x1 = I64 (\"\\1\\0\\0\\0\\0\\0\\0\\0\");\n+  uint64_t x01 = I64 (\"\\0\\1\\0\\0\\0\\0\\0\\0\");\n+  uint64_t x001 = I64 (\"\\0\\0\\1\\0\\0\\0\\0\\0\");\n+  uint64_t x0001 = I64 (\"\\0\\0\\0\\1\\0\\0\\0\\0\");\n+  uint64_t x00001 = I64 (\"\\0\\0\\0\\0\\1\\0\\0\\0\");\n+  uint64_t x000001 = I64 (\"\\0\\0\\0\\0\\0\\1\\0\\0\");\n+  uint64_t x0000001 = I64 (\"\\0\\0\\0\\0\\0\\0\\1\\0\");\n+  uint64_t x00000001 = I64 (\"\\0\\0\\0\\0\\0\\0\\0\\1\");\n+\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0,        x1, == 1);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0,       x01, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0,      x001, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0,     x0001, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0,    x00001, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0,   x000001, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0,  x0000001, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0, x00000001, == 0);\n+\n+  T2 (\"xxxxxxx\", uint128_t, 0,        x1, 0, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0,       x01, 0, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0,      x001, 0, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0,     x0001, 0, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0,    x00001, 0, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0,   x000001, 0, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0,  x0000001, 0, == 0);\n+  T2 (\"xxxxxxx\", uint128_t, 0, x00000001, 0, == 0);\n+\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0, I64 (\"\\2\\1\\0\\0\\0\\0\\0\\0\"), == 2);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0, I64 (\"\\0\\2\\1\\0\\0\\0\\0\\0\"), == 0);\n+\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0, I64 (\"\\3\\2\\1\\0\\0\\0\\0\\0\"), == 3);\n+  T2 (\"xxxxxxx\", uint128_t, 0, 0, I64 (\"\\0\\3\\2\\1\\0\\0\\0\\0\"), == 0);\n+\n+  uint64_t x4321     = I64 (\"\\4\\3\\2\\1\\0\\0\\0\\0\");\n+  uint64_t x54321    = I64 (\"\\5\\4\\3\\2\\1\\0\\0\\0\");\n+  uint64_t x654321   = I64 (\"\\6\\5\\4\\3\\2\\1\\0\\0\");\n+  uint64_t x7654321  = I64 (\"\\7\\6\\5\\4\\3\\2\\1\\0\");\n+  uint64_t x87654321 = I64 (\"8\\7\\6\\5\\4\\3\\2\\1\");\n+  uint64_t x9        = I64 (\"9\\0\\0\\0\\0\\0\\0\\0\");\n+  uint64_t xa9       = I64 (\"a9\\0\\0\\0\\0\\0\\0\");\n+  uint64_t xba9      = I64 (\"ba9\\0\\0\\0\\0\\0\\0\");\n+  uint64_t xcba9     = I64 (\"cba9\\0\\0\\0\\0\\0\");\n+  uint64_t xdcba9    = I64 (\"dcba9\\0\\0\\0\\0\");\n+  uint64_t xedcba9   = I64 (\"edcba9\\0\\0\\0\\0\");\n+  uint64_t xfedcba9  = I64 (\"fedcba9\\0\\0\\0\");\n+\n+  T2 (0, uint128_t, 0,        0,     x4321, ==  4);\n+  T2 (0, uint128_t, 0,        0,    x54321, ==  5);\n+  T2 (0, uint128_t, 0,        0,   x654321, ==  6);\n+  T2 (0, uint128_t, 0,        0,  x7654321, ==  7);\n+  T2 (0, uint128_t, 0,        0, x87654321, ==  8);\n+  T2 (0, uint128_t, 0,       x9, x87654321, ==  9);\n+  T2 (0, uint128_t, 0,      xa9, x87654321, == 10);\n+  T2 (0, uint128_t, 0,     xba9, x87654321, == 11);\n+  T2 (0, uint128_t, 0,    xcba9, x87654321, == 12);\n+  T2 (0, uint128_t, 0,   xdcba9, x87654321, == 13);\n+  T2 (0, uint128_t, 0,  xedcba9, x87654321, == 14);\n+  T2 (0, uint128_t, 0, xfedcba9, x87654321, == 15);\n+}\n+\n+#endif   // __uint128_t\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"_not_eliminated_\" 0 \"optimized\" } } */"}, {"sha": "190551981420fbe7289a13e50491ace7add10702", "filename": "gcc/testsuite/gcc.dg/strlenopt-71.c", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-71.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-71.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-71.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -0,0 +1,212 @@\n+/* PR tree-optimization/91183 - strlen of a strcpy result with a conditional\n+   source not folded\n+   Runtime test to verify that multibyte stores are handled correctly.\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" }  */\n+\n+#include \"strlenopt.h\"\n+\n+#define CHAR_BIT __CHAR_BIT__\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+\n+#define NOIPA __attribute__ ((noclone, noinline, noipa))\n+\n+/* Prevent the optimizer from detemining invariants from prior tests.  */\n+NOIPA void terminate (void)\n+{\n+  __builtin_abort ();\n+}\n+\n+#define VERIFY(expr, str)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    const unsigned expect = strlen (str);\t\t\t\t\\\n+    const unsigned len = strlen (expr);\t\t\t\t\t\\\n+    if (len != expect)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__builtin_printf (\"line %i: strlen(%s) == %u failed: \"\t\t\\\n+\t\t\t  \"got %u with a = \\\"%.*s\\\"\\n\",\t\t\t\\\n+\t\t\t  __LINE__, #expr, expect, len,\t\t\t\\\n+\t\t\t  (int)sizeof a, a);\t\t\t\t\\\n+\tterminate ();\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (memcmp (a, str, expect + 1))\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__builtin_printf (\"line %i: expected string \\\"%s\\\", \"\t\t\\\n+\t\t\t  \"got a = \\\"%.*s\\\"\\n\",\t\t\t\t\\\n+\t\t\t  __LINE__, str, (int)sizeof a, a);\t\t\\\n+\tterminate ();\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+#  define I16(s) ((s[0] << 8) + s[1])\n+#  define I32(s) ((s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3])\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+#  define I16(s) ((s[1] << 8) + s[0])\n+#  define I32(s) ((s[3] << 24) + (s[2] << 16) + (s[1] << 8) + s[0])\n+#endif\n+\n+char a[32];\n+\n+NOIPA void\n+i16_1 (void)\n+{\n+  *(int16_t*)a = I16 (\"12\");\n+  *(int16_t*)(a + 2) = I16 (\"3\");\n+  VERIFY (a, \"123\");\n+\n+  *(int16_t*)(a + 1) = I16 (\"23\");\n+  VERIFY (a, \"123\");\n+\n+  *(int16_t*)(a) = I16 (\"12\");\n+  VERIFY (a, \"123\");\n+\n+  *(int16_t*)(a + 1) = I16 (\"2\");\n+  VERIFY (a, \"12\");\n+\n+  *(int16_t*)(a + 3) = I16 (\"45\");\n+  *(int16_t*)(a + 2) = I16 (\"34\");\n+  VERIFY (a, \"12345\");\n+}\n+\n+NOIPA void\n+i16_2 (void)\n+{\n+  strcpy (a, \"12\");\n+  strcat (a, \"34\");\n+\n+  *(int16_t*)a = I16 (\"12\");\n+  VERIFY (a, \"1234\");\n+\n+  *(int16_t*)(a + 1) = I16 (\"12\");\n+  VERIFY (a, \"1124\");\n+\n+  *(int16_t*)(a + 2) = I16 (\"12\");\n+  VERIFY (a, \"1112\");\n+\n+  *(int16_t*)(a + 3) = I16 (\"12\");\n+  VERIFY (a, \"11112\");\n+\n+  *(int16_t*)(a + 4) = I16 (\"12\");\n+  VERIFY (a, \"111112\");\n+}\n+\n+\n+NOIPA void\n+i32_1 (void)\n+{\n+  *(int32_t*)a = I32 (\"1234\");\n+  VERIFY (a, \"1234\");\n+\n+  *(int32_t*)(a + 1) = I32 (\"2345\");\n+  VERIFY (a, \"12345\");\n+}\n+\n+NOIPA void\n+i32_2 (void)\n+{\n+  strcpy (a, \"12\");\n+  strcat (a, \"34\");\n+\n+  *(int32_t*)a = I32 (\"1234\");\n+  VERIFY (a, \"1234\");\n+\n+  *(int32_t*)(a + 4) = I32 (\"567\");\n+  VERIFY (a, \"1234567\");\n+\n+  *(int32_t*)(a + 7) = I32 (\"89\\0\");\n+  VERIFY (a, \"123456789\");\n+\n+  *(int32_t*)(a + 3) = I32 (\"4567\");\n+  VERIFY (a, \"123456789\");\n+\n+  *(int32_t*)(a + 2) = I32 (\"3456\");\n+  VERIFY (a, \"123456789\");\n+\n+  *(int32_t*)(a + 1) = I32 (\"2345\");\n+  VERIFY (a, \"123456789\");\n+}\n+\n+\n+NOIPA void\n+i32_3 (void)\n+{\n+  strcpy (a, \"1234\");\n+  strcat (a, \"5678\");\n+\n+  *(int32_t*)a = I32 (\"1234\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)(a + 1) = I32 (\"234\");\n+  VERIFY (a, \"1234\");\n+\n+  *(int32_t*)(a + 2) = I32 (\"3456\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)(a + 3) = I32 (\"4567\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)(a + 4) = I32 (\"5678\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)(a + 5) = I32 (\"6789\");\n+  VERIFY (a, \"123456789\");\n+\n+  *(int32_t*)(a + 6) = I32 (\"789A\");\n+  VERIFY (a, \"123456789A\");\n+}\n+\n+volatile int vzero = 0;\n+\n+NOIPA void\n+i32_4 (void)\n+{\n+  strcpy (a, \"1234\");\n+  strcat (a, \"5678\");\n+\n+  *(int32_t*)a = vzero ? I32 (\"1\\0\\0\\0\") : I32 (\"1234\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)a = vzero ? I32 (\"12\\0\\0\") : I32 (\"1234\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)a = vzero ? I32 (\"123\\0\") : I32 (\"1234\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)a = vzero ? I32 (\"1234\") : I32 (\"1234\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)a = vzero ? I32 (\"1235\") : I32 (\"1234\");\n+  VERIFY (a, \"12345678\");\n+\n+  *(int32_t*)a = vzero ? I32 (\"1234\") : I32 (\"123\\0\");\n+  VERIFY (a, \"123\");\n+\n+  *(int32_t*)(a + 3) = vzero ? I32 (\"456\\0\") : I32 (\"4567\");\n+  VERIFY (a, \"12345678\");\n+}\n+\n+\n+int main ()\n+{\n+  memset (a, 0, sizeof a);\n+  i16_1 ();\n+\n+  memset (a, 0, sizeof a);\n+  i16_2 ();\n+\n+\n+  memset (a, 0, sizeof a);\n+  i32_1 ();\n+\n+  memset (a, 0, sizeof a);\n+  i32_2 ();\n+\n+  memset (a, 0, sizeof a);\n+  i32_3 ();\n+\n+  memset (a, 0, sizeof a);\n+  i32_4 ();\n+}"}, {"sha": "a06cc4f9cde1919f8ae87e4ea92da7435c55c769", "filename": "gcc/testsuite/gcc.dg/strlenopt-72.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-72.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-72.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-72.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -0,0 +1,64 @@\n+/* PR tree-optimization/91183 - strlen of a strcpy result with a conditional\n+   source not folded\n+   Test to verify that strlen can determine string lengths from wider stores\n+   than narrow characters.  This matters because on targets that can handle\n+   unaligned stores and where GCC lowers multi-character stores into smaller\n+   numbers of wider stores.\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" }  */\n+\n+#include \"strlenopt.h\"\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macros to emit a call to function named\n+     call_failed_to_be_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\t\\\n+  if ((expr)) FAIL (not_eliminated); else (void)0\n+\n+#undef T\n+#define T(N, ncpy, expect, assign) do {\t\t\t\t\\\n+    char a[N], b[N];\t\t\t\t\t\t\\\n+    assign;\t\t\t\t\t\t\t\\\n+    memcpy (b, a, ncpy);\t\t\t\t\t\\\n+    ELIM (!(expect == strlen (b)));\t\t\t\t\\\n+  } while (0)\n+\n+void test_copy (void)\n+{\n+  T (2, 1, 0, (a[0] = 0));\n+  T (2, 2, 0, (a[0] = 0, a[1] = 0));\n+  T (2, 2, 1, (a[0] = '1', a[1] = 0));\n+  T (4, 3, 2, (a[0] = '1', a[1] = '2', a[2] = 0));\n+  // Not handled due to pr83821:\n+  // T (4, 3, 1, (a[0] = '1', a[1] = 0, a[2] = '2'));\n+  T (4, 2, 1, (a[0] = '1', a[1] = 0,   a[2] = 0,   a[3] = 0));\n+  // Not handled due to pr83821:\n+  // T (4, 3, 1, (a[0] = '1', a[1] = 0,   a[2] = 0,   a[3] = 0));\n+  T (4, 4, 1, (a[0] = '1', a[1] = 0,   a[2] = 0,   a[3] = 0));\n+  T (4, 3, 2, (a[0] = '1', a[1] = '2', a[2] = 0,   a[3] = 0));\n+  T (4, 4, 2, (a[0] = '1', a[1] = '2', a[2] = 0,   a[3] = 0));\n+  T (4, 4, 3, (a[0] = '1', a[1] = '2', a[2] = '3', a[3] = 0));\n+  T (5, 4, 1, (a[0] = '1', a[1] = 0,   a[2] = 0,   a[3] = 0));\n+  T (5, 4, 2, (a[0] = '1', a[1] = '2', a[2] = 0,   a[3] = 0));\n+  T (5, 4, 3, (a[0] = '1', a[1] = '2', a[2] = '3', a[3] = 0));\n+  // Not handled:\n+  // T (5, 5, 1, (a[0] = '1', a[1] = 0,   a[2] = 0,   a[3] = 0,   a[4] = 0));\n+  // T (5, 5, 2, (a[0] = '1', a[1] = '2', a[2] = 0,   a[3] = 0,   a[4] = 0));\n+  // T (5, 5, 3, (a[0] = '1', a[1] = '2', a[2] = '3', a[3] = 0,   a[4] = 0));\n+  T (5, 5, 4, (a[0] = '1', a[1] = '2', a[2] = '3', a[3] = '4', a[4] = 0));\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"_not_eliminated_\" 0 \"optimized\" } } */"}, {"sha": "f43b809ed0288fdce5a1bce58363c4af854acbc1", "filename": "gcc/testsuite/gcc.dg/strlenopt-8.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-8.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -43,13 +43,7 @@ main ()\n   return 0;\n }\n \n-/* On non-strict-align targets we inline the memcpy that strcat is turned\n-   into and end up with a short typed load / store which strlenopt is not\n-   able to analyze.  */\n-\n-/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" { xfail non_strict_align } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" { target { non_strict_align } } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 4 \"strlen\" { target { ! non_strict_align } } } }  */\n+/* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */"}, {"sha": "4af47855e7ca9d4c997bf248000e225d9847d7d8", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 372, "deletions": 88, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b631bdb3c16e85f35d38e39b3d315c35e4a5747c/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=b631bdb3c16e85f35d38e39b3d315c35e4a5747c", "patch": "@@ -3328,78 +3328,287 @@ handle_pointer_plus (gimple_stmt_iterator *gsi)\n     }\n }\n \n-/* If RHS, either directly or indirectly, refers to a string of constant\n-   length, return the length.  Otherwise, if it refers to a character\n-   constant, return 1 if the constant is non-zero and 0 if it is nul.\n-   Otherwise, return a negative value.  */\n+/* Describes recursion limits used by count_nonzero_bytes.  */\n \n-static HOST_WIDE_INT\n-get_min_string_length (tree rhs, bool *full_string_p)\n+class ssa_name_limit_t\n {\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n+  bitmap visited;         /* Bitmap of visited SSA_NAMEs.  */\n+  unsigned ssa_def_max;   /* Longest chain of SSA_NAMEs to follow.  */\n+\n+  /* Not copyable or assignable.  */\n+  ssa_name_limit_t (ssa_name_limit_t&);\n+  void operator= (ssa_name_limit_t&);\n+\n+ public:\n+\n+  ssa_name_limit_t ()\n+    : visited (NULL),\n+    ssa_def_max (PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT)) { }\n+\n+  int next_ssa_name (tree);\n+\n+  ~ssa_name_limit_t ()\n     {\n-      if (tree_expr_nonzero_p (rhs))\n+      if (visited)\n+\tBITMAP_FREE (visited);\n+    }\n+};\n+\n+/* If the SSA_NAME has already been \"seen\" return a positive value.\n+   Otherwise add it to VISITED.  If the SSA_NAME limit has been\n+   reached, return a negative value.  Otherwise return zero.  */\n+\n+int ssa_name_limit_t::next_ssa_name (tree ssa_name)\n+{\n+  if (!visited)\n+    visited = BITMAP_ALLOC (NULL);\n+\n+  /* Return a positive value if SSA_NAME has already been visited.  */\n+  if (!bitmap_set_bit (visited, SSA_NAME_VERSION (ssa_name)))\n+    return 1;\n+\n+  /* Return a negative value to let caller avoid recursing beyond\n+     the specified limit.  */\n+  if (ssa_def_max == 0)\n+    return -1;\n+\n+  --ssa_def_max;\n+\n+  return 0;\n+}\n+\n+/* Determine the minimum and maximum number of leading non-zero bytes\n+   in the representation of EXP and set LENRANGE[0] and LENRANGE[1]\n+   to each.  Set LENRANGE[2] to the total number of bytes in\n+   the representation.  Set *NULTREM if the representation contains\n+   a zero byte, and set *ALLNUL if all the bytes are zero.  Avoid\n+   recursing deeper than the limits in SNLIM allow.  Return true\n+   on success and false otherwise.  */\n+\n+static bool\n+count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n+\t\t     bool *allnul, bool *allnonnul, ssa_name_limit_t &snlim)\n+{\n+  if (TREE_CODE (exp) == SSA_NAME)\n+    {\n+      /* Handle a single-character specially.  */\n+      tree type = TREE_TYPE (exp);\n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  && TYPE_MODE (type) == TYPE_MODE (char_type_node)\n+\t  && TYPE_PRECISION (type) == TYPE_PRECISION (char_type_node))\n \t{\n-\t  *full_string_p = false;\n-\t  return 1;\n+\t  /* Determine if the character EXP is known to be non-zero\n+\t     (even if its exact value is not known) and if so, recurse\n+\t     once to set the range, etc.  */\n+\t  if (tree_expr_nonzero_p (exp))\n+\t    return count_nonzero_bytes (build_int_cst (type, 1), lenrange,\n+\t\t\t\t\tnulterm, allnul, allnonnul, snlim);\n+\t  /* Don't know whether EXP is or isn't nonzero.  */\n+\t  return false;\n \t}\n \n-      *full_string_p = true;\n-      return 0;\n+      gimple *stmt = SSA_NAME_DEF_STMT (exp);\n+      if (gimple_code (stmt) != GIMPLE_PHI)\n+\treturn false;\n+\n+      /* Avoid processing an SSA_NAME that has already been visited\n+\t or if an SSA_NAME limit has been reached.  Indicate success\n+\t if the former and failure if the latter.  */\n+      if (int res = snlim.next_ssa_name (exp))\n+\treturn res > 0;\n+\n+      /* Determine the minimum and maximum from the PHI arguments.  */\n+      unsigned int n = gimple_phi_num_args (stmt);\n+      for (unsigned i = 0; i != n; i++)\n+\t{\n+\t  tree def = gimple_phi_arg_def (stmt, i);\n+\t  if (!count_nonzero_bytes (def, lenrange, nulterm, allnul, allnonnul,\n+\t\t\t\t    snlim))\n+\t    return false;\n+\t}\n+\n+      return true;\n     }\n \n-  if (TREE_CODE (rhs) == MEM_REF\n-      && integer_zerop (TREE_OPERAND (rhs, 1)))\n+  /* Offset from the beginning of the representation bytes, a pointer\n+     to the representation, and the number of bytes of the representation\n+     to consider (may be less than the object size for MEM_REF).  */\n+  unsigned HOST_WIDE_INT offset = 0;\n+  const char *prep = NULL;\n+  unsigned nbytes = 0;\n+\n+  if (TREE_CODE (exp) == MEM_REF)\n     {\n-      rhs = TREE_OPERAND (rhs, 0);\n-      if (TREE_CODE (rhs) == ADDR_EXPR)\n-\t{\n-\t  tree rhs_addr = rhs;\n+      /* If the MEM_REF operand is the address of an object such as\n+\t a string or integer, extract it and the offset into it.  */\n+      tree arg = TREE_OPERAND (exp, 0);\n+      if (TREE_CODE (arg) != ADDR_EXPR)\n+\treturn false;\n+\n+      tree off = TREE_OPERAND (exp, 1);\n+      if (TREE_CODE (off) != INTEGER_CST\n+\t  || !tree_fits_uhwi_p (off))\n+\treturn false;\n \n-\t  rhs = TREE_OPERAND (rhs, 0);\n-\t  if (TREE_CODE (rhs) != STRING_CST)\n+      offset = tree_to_uhwi (off);\n+      if (INT_MAX < offset)\n+\treturn false;\n+\n+      /* The size of the MEM_REF access determines the number of bytes.  */\n+      tree type = TREE_TYPE (exp);\n+      if (tree typesize = TYPE_SIZE_UNIT (type))\n+\tnbytes = tree_to_uhwi (typesize);\n+\n+      if (offset == 0 && TREE_CODE (exp) != STRING_CST)\n+\t{\n+\t  int idx = get_stridx (arg);\n+\t  if (idx > 0)\n \t    {\n-\t      int idx = get_stridx (rhs_addr);\n-\t      if (idx > 0)\n+\t      strinfo *si = get_strinfo (idx);\n+\t      if (si && tree_fits_shwi_p (si->nonzero_chars))\n \t\t{\n-\t\t  strinfo *si = get_strinfo (idx);\n-\t\t  if (si\n-\t\t      && tree_fits_shwi_p (si->nonzero_chars))\n-\t\t    {\n-\t\t      *full_string_p = si->full_string_p;\n-\t\t      return tree_to_shwi (si->nonzero_chars);\n-\t\t    }\n+\t\t  unsigned len = tree_to_shwi (si->nonzero_chars);\n+\t\t  if (len < lenrange[0])\n+\t\t    lenrange[0] = len;\n+\t\t  if (lenrange[1] < len)\n+\t\t    lenrange[1] = len;\n+\n+\t\t  if (!si->full_string_p)\n+\t\t    *nulterm = false;\n+\n+\t\t  /* Since only the length of the string are known and\n+\t\t     its contents, clear ALLNUL and ALLNONNUL purely on\n+\t\t     the basis of the length.  */\n+\t\t  if (len)\n+\t\t    *allnul = false;\n+\t\t  else\n+\t\t    *allnonnul = false;\n+\t\t  return true;\n \t\t}\n \t    }\n \t}\n+\n+      /* Proceed to extract the object representation below.  */\n+      exp = TREE_OPERAND (arg, 0);\n     }\n \n-  if (TREE_CODE (rhs) == VAR_DECL\n-      && TREE_READONLY (rhs))\n-    rhs = DECL_INITIAL (rhs);\n+  if (TREE_CODE (exp) == VAR_DECL && TREE_READONLY (exp))\n+    {\n+      exp = DECL_INITIAL (exp);\n+      if (!exp)\n+\treturn false;\n+    }\n \n-  if (rhs && TREE_CODE (rhs) == STRING_CST)\n+  if (TREE_CODE (exp) == STRING_CST)\n     {\n-      HOST_WIDE_INT len = strlen (TREE_STRING_POINTER (rhs));\n-      *full_string_p = len < TREE_STRING_LENGTH (rhs);\n-      return len;\n+      /* Set PREP and NBYTES to the string representation.  */\n+      gcc_assert (offset <= INT_MAX);\n+\n+      if (!nbytes)\n+\t{\n+\t  /* Unless NBYTES has already been determined above from\n+\t     MEM_REF, set it here.  It includes all internal nuls,\n+\t     including the terminating one if the string has one.  */\n+\t  nbytes = TREE_STRING_LENGTH (exp);\n+\t  if (nbytes <= offset)\n+\t    return false;\n+\t}\n+\n+      prep = TREE_STRING_POINTER (exp) + offset;\n     }\n \n-  return -1;\n+  unsigned char buf[256];\n+  if (!prep)\n+    {\n+      /* Try to extract the representation of the constant object.  */\n+      nbytes = native_encode_expr (exp, buf, sizeof buf, -1);\n+      if (!nbytes)\n+\treturn false;\n+\n+      prep = reinterpret_cast <char *>(buf);\n+    }\n+\n+  /* Compute the number of leading nonzero bytes in the representation\n+     and update the minimum and maximum.  */\n+  unsigned n = strnlen (prep, nbytes);\n+\n+  if (n < lenrange[0])\n+    lenrange[0] = n;\n+  if (lenrange[1] < n)\n+    lenrange[1] = n;\n+\n+  /* Set the size of the representation.  */\n+  if (lenrange[2] < nbytes)\n+    lenrange[2] = nbytes;\n+\n+  /* Clear NULTERM if none of the bytes is zero.  */\n+  if (n == nbytes)\n+    *nulterm = false;\n+\n+  if (n)\n+    {\n+      /* When the initial number of non-zero bytes N is non-zero, reset\n+       *ALLNUL; if N is less than that the size of the representation\n+       also clear *ALLNONNUL.  */\n+      *allnul = false;\n+      if (n < nbytes)\n+\t*allnonnul = false;\n+    }\n+  else if (*allnul || *allnonnul)\n+    {\n+      *allnonnul = false;\n+\n+      if (*allnul)\n+\t{\n+\t  /* When either ALLNUL is set and N is zero, also determine\n+\t     whether all subsequent bytes after the first one (which\n+\t     is nul) are zero or nonzero and clear ALLNUL if not.  */\n+\t  for (const char *p = prep; p != prep + nbytes; ++p)\n+\t    if (*p)\n+\t      {\n+\t\t*allnul = false;\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Same as above except with an implicit SSA_NAME limit.  */\n+\n+static bool\n+count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n+\t\t     bool *allnul, bool *allnonnul)\n+{\n+  /* Set to optimistic values so the caller doesn't have to worry about\n+     initializing these and to what.  On success, the function will clear\n+     these if it determines their values are different but being recursive\n+     it never sets either to true.  On failure, their values are\n+     unspecified.  */\n+  *nulterm = true;\n+  *allnul = true;\n+  *allnonnul = true;\n+\n+  ssa_name_limit_t snlim;\n+  return count_nonzero_bytes (exp, lenrange, nulterm, allnul, allnonnul, snlim);\n }\n \n-/* Handle a single or multiple character store either by single\n-   character assignment or by multi-character assignment from\n-   MEM_REF.  */\n+/* Handle a single or multibyte store other than by a built-in function,\n+   either via a single character assignment or by multi-byte assignment\n+   either via MEM_REF or via a type other than char (such as in\n+   '*(int*)a = 12345').  Return true when handled.  */\n \n static bool\n-handle_char_store (gimple_stmt_iterator *gsi)\n+handle_store (gimple_stmt_iterator *gsi)\n {\n   int idx = -1;\n   strinfo *si = NULL;\n   gimple *stmt = gsi_stmt (*gsi);\n   tree ssaname = NULL_TREE, lhs = gimple_assign_lhs (stmt);\n   tree rhs = gimple_assign_rhs1 (stmt);\n+\n+  /* The offset of the first byte in LHS modified by the the store.  */\n   unsigned HOST_WIDE_INT offset = 0;\n \n   if (TREE_CODE (lhs) == MEM_REF\n@@ -3428,23 +3637,77 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \tsi = get_strinfo (idx);\n     }\n \n+  /* Minimum and maximum leading non-zero bytes and the size of the store.  */\n+  unsigned lenrange[] = { UINT_MAX, 0, 0 };\n+\n+  /* Set to the minimum length of the string being assigned if known.  */\n+  unsigned HOST_WIDE_INT rhs_minlen;\n+\n   /* STORING_NONZERO_P is true iff not all stored characters are zero.\n+     STORING_ALL_NONZERO_P is true if all stored characters are zero.\n      STORING_ALL_ZEROS_P is true iff all stored characters are zero.\n      Both are false when it's impossible to determine which is true.  */\n   bool storing_nonzero_p;\n-  bool storing_all_zeros_p = initializer_zerop (rhs, &storing_nonzero_p);\n-  if (!storing_nonzero_p)\n-    storing_nonzero_p = tree_expr_nonzero_p (rhs);\n-  bool full_string_p = storing_all_zeros_p;\n+  bool storing_all_nonzero_p;\n+  bool storing_all_zeros_p;\n+  /* FULL_STRING_P is set when the stored sequence of characters form\n+     a nul-terminated string.  */\n+  bool full_string_p;\n \n-  /* Set to the length of the string being assigned if known.  */\n-  HOST_WIDE_INT rhslen;\n+  const bool ranges_valid\n+    = count_nonzero_bytes (rhs, lenrange, &full_string_p,\n+\t\t\t   &storing_all_zeros_p, &storing_all_nonzero_p);\n+  if (ranges_valid)\n+    {\n+      rhs_minlen = lenrange[0];\n+      storing_nonzero_p = lenrange[1] > 0;\n+\n+      if (tree dstsize = compute_objsize (lhs, 1))\n+\tif (compare_tree_int (dstsize, lenrange[2]) < 0)\n+\t  warning_n (gimple_location (stmt), OPT_Wstringop_overflow_,\n+\t\t     lenrange[2],\n+\t\t     \"%Gwriting %u byte into a region of size %E\",\n+\t\t     \"%Gwriting %u bytes into a region of size %E\",\n+\t\t     stmt, lenrange[2], dstsize);\n+    }\n+  else\n+    {\n+      rhs_minlen = HOST_WIDE_INT_M1U;\n+      full_string_p = false;\n+      storing_nonzero_p = false;\n+      storing_all_zeros_p = false;\n+      storing_all_nonzero_p = false;\n+    }\n \n   if (si != NULL)\n     {\n-      int cmp = compare_nonzero_chars (si, offset);\n-      gcc_assert (offset == 0 || cmp >= 0);\n-      if (storing_all_zeros_p && cmp == 0 && si->full_string_p)\n+      /* The corresponding element is set to 1 if the first and last\n+\t element, respectively, of the sequence of characters being\n+\t written over the string described by SI ends before\n+\t the terminating nul (if it has one), to zero if the nul is\n+\t being overwritten but not beyond, or negative otherwise.  */\n+      int store_before_nul[2];\n+      if (ranges_valid)\n+\t{\n+\t  /* The offset of the last stored byte.  */\n+\t  unsigned HOST_WIDE_INT endoff = offset + lenrange[2] - 1;\n+\t  store_before_nul[0] = compare_nonzero_chars (si, offset);\n+\t  if (endoff == offset)\n+\t    store_before_nul[1] = store_before_nul[0];\n+\t  else\n+\t    store_before_nul[1] = compare_nonzero_chars (si, endoff);\n+\t}\n+      else\n+\t{\n+\t  store_before_nul[0] = compare_nonzero_chars (si, offset);\n+\t  store_before_nul[1] = store_before_nul[0];\n+\t  gcc_assert (offset == 0 || store_before_nul[0] >= 0);\n+\t}\n+\n+      if (storing_all_zeros_p\n+\t  && store_before_nul[0] == 0\n+\t  && store_before_nul[1] == 0\n+\t  && si->full_string_p)\n \t{\n \t  /* When overwriting a '\\0' with a '\\0', the store can be removed\n \t     if we know it has been stored in the current function.  */\n@@ -3463,16 +3726,21 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t    }\n \t}\n \n-      if (cmp > 0\n+      if (store_before_nul[1] > 0\n \t  && storing_nonzero_p\n+\t  && lenrange[0] == lenrange[1]\n+\t  && lenrange[0] == lenrange[2]\n \t  && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE)\n \t{\n-\t  /* Handle a single non-nul character store.\n+\t  /* Handle a store of one or more non-nul characters that ends\n+\t     before the terminating nul of the destination and so does\n+\t     not affect its length\n \t     If si->nonzero_chars > OFFSET, we aren't overwriting '\\0',\n-\t     and if we aren't storing '\\0', we know that the length of the\n-\t     string and any other zero terminated string in memory remains\n-\t     the same.  In that case we move to the next gimple statement and\n-\t     return to signal the caller that it shouldn't invalidate anything.\n+\t     and if we aren't storing '\\0', we know that the length of\n+\t     the string and any other zero terminated string in memory\n+\t     remains the same.  In that case we move to the next gimple\n+\t     statement and return to signal the caller that it shouldn't\n+\t     invalidate anything.\n \n \t     This is benefical for cases like:\n \n@@ -3493,7 +3761,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \n       if (storing_all_zeros_p\n \t  || storing_nonzero_p\n-\t  || (offset != 0 && cmp > 0))\n+\t  || (offset != 0 && store_before_nul[1] > 0))\n \t{\n \t  /* When STORING_NONZERO_P, we know that the string will start\n \t     with at least OFFSET + 1 nonzero characters.  If storing\n@@ -3506,22 +3774,15 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t     OFFSET characters long.\n \n \t     Otherwise, we're storing an unknown value at offset OFFSET,\n-\t     so need to clip the nonzero_chars to OFFSET.  */\n-\t  bool full_string_p = storing_all_zeros_p;\n-\t  HOST_WIDE_INT len = 1;\n-\t  if (storing_nonzero_p)\n-\t    {\n-\t      /* Try to get the minimum length of the string (or\n-\t\t individual character) being stored.  If it fails,\n-\t\t STORING_NONZERO_P guarantees it's at least 1.  */\n-\t      len = get_min_string_length (rhs, &full_string_p);\n-\t      if (len < 0)\n-\t\tlen = 1;\n-\t    }\n-\n+\t     so need to clip the nonzero_chars to OFFSET.\n+\t     Use the minimum length of the string (or individual character)\n+\t     being stored if it's known.  Otherwise, STORING_NONZERO_P\n+\t     guarantees it's at least 1.  */\n+\t  HOST_WIDE_INT len\n+\t    = storing_nonzero_p && ranges_valid ? lenrange[0] : 1;\n \t  location_t loc = gimple_location (stmt);\n \t  tree oldlen = si->nonzero_chars;\n-\t  if (cmp == 0 && si->full_string_p)\n+\t  if (store_before_nul[1] == 0 && si->full_string_p)\n \t    /* We're overwriting the nul terminator with a nonzero or\n \t       unknown character.  If the previous stmt was a memcpy,\n \t       its length may be decreased.  */\n@@ -3567,8 +3828,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t  HOST_WIDE_INT slen = (storing_all_zeros_p\n \t\t\t\t? 0\n \t\t\t\t: (storing_nonzero_p\n-\t\t\t\t   ? get_min_string_length (rhs, &full_string_p)\n-\t\t\t\t   : -1));\n+\t\t\t\t   && ranges_valid ? lenrange[0] : -1));\n \t  tree len = (slen <= 0\n \t\t      ? size_zero_node\n \t\t      : build_int_cst (size_type_node, slen));\n@@ -3583,18 +3843,18 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t}\n     }\n   else if (idx == 0\n-\t   && (rhslen = get_min_string_length (rhs, &full_string_p)) >= 0\n+\t   && rhs_minlen < HOST_WIDE_INT_M1U\n \t   && ssaname == NULL_TREE\n \t   && TREE_CODE (TREE_TYPE (lhs)) == ARRAY_TYPE)\n     {\n       HOST_WIDE_INT a = int_size_in_bytes (TREE_TYPE (lhs));\n-      if (a > 0 && (unsigned HOST_WIDE_INT) a > (unsigned HOST_WIDE_INT) rhslen)\n+      if (a > 0 && (unsigned HOST_WIDE_INT) a > rhs_minlen)\n \t{\n \t  int idx = new_addr_stridx (lhs);\n \t  if (idx != 0)\n \t    {\n \t      si = new_strinfo (build_fold_addr_expr (lhs), idx,\n-\t\t\t\tbuild_int_cst (size_type_node, rhslen),\n+\t\t\t\tbuild_int_cst (size_type_node, rhs_minlen),\n \t\t\t\tfull_string_p);\n \t      set_strinfo (idx, si);\n \t      si->dont_invalidate = true;\n@@ -3707,6 +3967,16 @@ fold_strstr_to_strncmp (tree rhs1, tree rhs2, gimple *stmt)\n     }\n }\n \n+/* Return true if TYPE corresponds to a narrow character type.  */\n+\n+static bool\n+is_char_type (tree type)\n+{\n+  return (TREE_CODE (type) == INTEGER_TYPE\n+\t  && TYPE_MODE (type) == TYPE_MODE (char_type_node)\n+\t  && TYPE_PRECISION (type) == TYPE_PRECISION (char_type_node));\n+}\n+\n /* Attempt to check for validity of the performed access a single statement\n    at *GSI using string length knowledge, and to optimize it.\n    If the given basic block needs clean-up of EH, CLEANUP_EH is set to\n@@ -3907,18 +4177,32 @@ strlen_check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n \t  }\n       }\n     else if (TREE_CODE (lhs) != SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n-\t{\n-\t  tree type = TREE_TYPE (lhs);\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    type = TREE_TYPE (type);\n-\t  if (TREE_CODE (type) == INTEGER_TYPE\n-\t      && TYPE_MODE (type) == TYPE_MODE (char_type_node)\n-\t      && TYPE_PRECISION (type) == TYPE_PRECISION (char_type_node))\n-\t    {\n-\t      if (! handle_char_store (gsi))\n-\t\treturn false;\n-\t    }\n-\t}\n+      {\n+\ttree type = TREE_TYPE (lhs);\n+\tif (TREE_CODE (type) == ARRAY_TYPE)\n+\t  type = TREE_TYPE (type);\n+\n+\tbool is_char_store = is_char_type (type);\n+\tif (!is_char_store && TREE_CODE (lhs) == MEM_REF)\n+\t  {\n+\t    /* To consider stores into char objects via integer types\n+\t       other than char but not those to non-character objects,\n+\t       determine the type of the destination rather than just\n+\t       the type of the access.  */\n+\t    tree ref = TREE_OPERAND (lhs, 0);\n+\t    type = TREE_TYPE (ref);\n+\t    if (TREE_CODE (type) == POINTER_TYPE)\n+\t      type = TREE_TYPE (type);\n+\t    if (TREE_CODE (type) == ARRAY_TYPE)\n+\t      type = TREE_TYPE (type);\n+\t    if (is_char_type (type))\n+\t      is_char_store = true;\n+\t  }\n+\n+\t/* Handle a single or multibyte assignment.  */\n+\tif (is_char_store && !handle_store (gsi))\n+\t  return false;\n+      }\n     }\n   else if (gcond *cond = dyn_cast<gcond *> (stmt))\n     {"}]}