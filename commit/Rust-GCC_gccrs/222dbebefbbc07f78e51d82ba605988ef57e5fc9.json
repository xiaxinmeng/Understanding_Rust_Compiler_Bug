{"sha": "222dbebefbbc07f78e51d82ba605988ef57e5fc9", "node_id": "C_kwDOANBUbNoAKDIyMmRiZWJlZmJiYzA3Zjc4ZTUxZDgyYmE2MDU5ODhlZjU3ZTVmYzk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-01T05:29:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-01T05:29:36Z"}, "message": "objc: Fix handling of break stmt inside of switch inside of ObjC foreach [PR103639]\n\nThe r11-3302-g3696a50beeb73f changes broke the following ObjC testcase.\nin_statement is either 0 (not in a looping statement), various IN_* flags\nfor various kinds of looping statements (or OpenMP structured blocks) or\nthose flags ored with IN_SWITCH_STMT when a switch appears inside of those\ncontexts.  This is because break binds to switch in that last case, but\ncontinue binds to the looping construct in that case.\nThe c_finish_bc_stmt function performs diagnostics on incorrect\nbreak/continue uses and then checks if in_statement & IN_OBJC_FOREACH\nand in that case jumps to the label provided by the caller, otherwise\nemits a BREAK_STMT or CONTINUE_STMT.  This is incorrect if we have\nObjC foreach with switch nested in it and break inside of that,\nin_statement in that case is IN_OBJC_FOREACH | IN_SWITCH_STMT and\nis_break is true.  We want to handle it like other breaks inside of\nswitch, i.e. emit a BREAK_STMT.\n\nThe following patch fixes that.\n\n2022-01-01  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR objc/103639\n\t* c-typeck.c (c_finish_bc_stmt): For break inside of switch inside of\n\tObjC foreach, emit normal BREAK_STMT rather than goto to label.\n\n2022-01-01  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR objc/103639\n\t* objc.dg/pr103639.m: New test.", "tree": {"sha": "159f0a56261525b5a56294d61294caa2529feba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/159f0a56261525b5a56294d61294caa2529feba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/222dbebefbbc07f78e51d82ba605988ef57e5fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/222dbebefbbc07f78e51d82ba605988ef57e5fc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/222dbebefbbc07f78e51d82ba605988ef57e5fc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/222dbebefbbc07f78e51d82ba605988ef57e5fc9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f17d2677bc2cbbc9021c81584000a2db1699d14e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17d2677bc2cbbc9021c81584000a2db1699d14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f17d2677bc2cbbc9021c81584000a2db1699d14e"}], "stats": {"total": 104, "additions": 103, "deletions": 1}, "files": [{"sha": "71724be6abc16c99f643719a1744a632028fad4f", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/222dbebefbbc07f78e51d82ba605988ef57e5fc9/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/222dbebefbbc07f78e51d82ba605988ef57e5fc9/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=222dbebefbbc07f78e51d82ba605988ef57e5fc9", "patch": "@@ -11257,7 +11257,8 @@ c_finish_bc_stmt (location_t loc, tree label, bool is_break)\n \n   if (skip)\n     return NULL_TREE;\n-  else if (in_statement & IN_OBJC_FOREACH)\n+  else if ((in_statement & IN_OBJC_FOREACH)\n+\t   && !(is_break && (in_statement & IN_SWITCH_STMT)))\n     {\n       /* The foreach expander produces low-level code using gotos instead\n \t of a structured loop construct.  */"}, {"sha": "c46e0d42c178d1f119cb193d3a2c44b49e327066", "filename": "gcc/testsuite/objc.dg/pr103639.m", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/222dbebefbbc07f78e51d82ba605988ef57e5fc9/gcc%2Ftestsuite%2Fobjc.dg%2Fpr103639.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/222dbebefbbc07f78e51d82ba605988ef57e5fc9/gcc%2Ftestsuite%2Fobjc.dg%2Fpr103639.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fpr103639.m?ref=222dbebefbbc07f78e51d82ba605988ef57e5fc9", "patch": "@@ -0,0 +1,101 @@\n+/* PR objc/103639 */\n+/* { dg-do run } */\n+/* { dg-skip-if \"No NeXT fast enum. pre-Darwin9\" { *-*-darwin[5-8]* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-additional-sources \"../objc-obj-c++-shared/nsconstantstring-class-impl.m\" } */\n+/* { dg-additional-options \"-mno-constant-cfstrings\" { target *-*-darwin* } } */\n+/* { dg-additional-options \"-Wno-objc-root-class\" } */\n+\n+#import \"../objc-obj-c++-shared/TestsuiteObject.m\"\n+#ifndef __NEXT_RUNTIME__\n+#include <objc/NXConstStr.h>\n+#else\n+#include \"../objc-obj-c++-shared/nsconstantstring-class.h\"\n+#endif\n+\n+extern int printf (const char *, ...);\n+#include <stdlib.h>\n+\n+/* A mini-array implementation that can be used to test fast\n+    enumeration.  You create the array with some objects; you can\n+    mutate the array, and you can fast-enumerate it.\n+ */\n+@interface MyArray : TestsuiteObject\n+{\n+  unsigned int length;\n+  id *objects;\n+  unsigned long mutated;\n+}\n+- (id) initWithLength: (unsigned int)l  objects: (id *)o;\n+- (void) mutate;\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState *)state\n+                                     objects:(id *)stackbuf \n+                                       count:(unsigned long)len;\n+@end\n+\n+@implementation MyArray : TestsuiteObject\n+- (id) initWithLength: (unsigned int)l\n+\t      objects: (id *)o\n+{\n+  length = l;\n+  objects = o;\n+  mutated = 0;\n+  return self;\n+}\n+- (void) mutate\n+{\n+  mutated = 1;\n+}\n+- (unsigned long)countByEnumeratingWithState: (struct __objcFastEnumerationState*)state \n+\t\t  \t\t     objects: (id*)stackbuf\n+\t\t\t \t       count: (unsigned long)len\n+{\n+  unsigned long i, batch_size;\n+\n+  /* We keep how many objects we served in the state->state counter.  So the next batch\n+     will contain up to length - state->state objects.  */\n+  batch_size = length - state->state;\n+\n+  /* Make obvious adjustments.  */\n+  if (batch_size < 0)\n+    batch_size = 0;\n+\n+  if (batch_size > len)\n+    batch_size = len;\n+\n+  /* Copy the objects.  */\n+  for (i = 0; i < batch_size; i++)\n+    stackbuf[i] = objects[i];\n+\n+  state->state += batch_size;\n+  state->itemsPtr = stackbuf;\n+  state->mutationsPtr = &mutated;\n+\n+  return batch_size;\n+}\n+@end\n+\n+int check = 0;\n+\n+int\n+main()\n+{\n+  id *objects = malloc (sizeof (id) * 2);\n+  objects[0] = @\"a\";\n+  objects[1] = @\"b\";\n+\n+  MyArray *array = [[MyArray alloc] initWithLength: 2 objects: objects];\n+\n+  int someVar = 0;\n+  for (id object in array) {\n+    switch (someVar) {\n+      case 0:\n+\tbreak;\n+    }\n+    ++check;\n+  }\n+\n+  if (check != 2)\n+    abort ();\n+  return 0;\n+}"}]}