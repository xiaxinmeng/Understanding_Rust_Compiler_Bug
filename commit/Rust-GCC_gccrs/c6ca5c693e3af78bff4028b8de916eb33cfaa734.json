{"sha": "c6ca5c693e3af78bff4028b8de916eb33cfaa734", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZjYTVjNjkzZTNhZjc4YmZmNDAyOGI4ZGU5MTZlYjMzY2ZhYTczNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-01-12T22:42:08Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-01-12T22:42:08Z"}, "message": "Reverted\n\nFrom-SVN: r38965", "tree": {"sha": "bb0b4f30b570a302df8cfcf5553542edb8fae0e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb0b4f30b570a302df8cfcf5553542edb8fae0e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6ca5c693e3af78bff4028b8de916eb33cfaa734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ca5c693e3af78bff4028b8de916eb33cfaa734", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6ca5c693e3af78bff4028b8de916eb33cfaa734", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ca5c693e3af78bff4028b8de916eb33cfaa734/comments", "author": null, "committer": null, "parents": [{"sha": "f474c6f8f92594e09a56c03cdd609d161e690bdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f474c6f8f92594e09a56c03cdd609d161e690bdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f474c6f8f92594e09a56c03cdd609d161e690bdd"}], "stats": {"total": 56, "additions": 1, "deletions": 55}, "files": [{"sha": "008b22cae3ed878f527089db5a160d4ab271dbd8", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6ca5c693e3af78bff4028b8de916eb33cfaa734/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6ca5c693e3af78bff4028b8de916eb33cfaa734/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=c6ca5c693e3af78bff4028b8de916eb33cfaa734", "patch": "@@ -1,6 +1,6 @@\n /* Move registers around to reduce number of move instructions needed.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1505,17 +1505,6 @@ find_matches (insn, matchp)\n   int op_no;\n   int any_matches = 0;\n \n-  if (GET_CODE (insn) == CALL_INSN\n-      && CALL_INSN_FUNCTION_USAGE (insn))\n-    {\n-      rtx usage;\n-\n-      for (usage = CALL_INSN_FUNCTION_USAGE (insn);\n-\t   usage;\n-\t   usage = XEXP (usage, 1))\n-\tfind_related (&XEXP (usage, 0), insn, luid, call_tally);\n-    }\n-\n   extract_insn (insn);\n   if (! constrain_operands (0))\n     return 0;\n@@ -1582,45 +1571,6 @@ find_matches (insn, matchp)\n   return any_matches;\n }\n \n-/* Try to replace all occurrences of DST_REG with SRC in LOC, that is\n-   assumed to be in INSN.  */\n-\n-static void\n-replace_in_call_usage (loc, dst_reg, src, insn)\n-     rtx *loc;\n-     int dst_reg;\n-     rtx src;\n-     rtx insn;\n-{\n-  rtx x = *loc;\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i, j;\n-\n-  if (! x)\n-    return;\n-  \n-  code = GET_CODE (x);\n-  if (code == REG)\n-    {\n-      if (REGNO (x) != dst_reg)\n-\treturn;\n-\t\n-      validate_change (insn, loc, src, 1);\n-\n-      return;\n-    }\n-  \n-  /* Process each of our operands recursively.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n-    if (*fmt == 'e')\n-      replace_in_call_usage (&XEXP (x, i), dst_reg, src, insn);\n-    else if (*fmt == 'E')\n-      for (j = 0; j < XVECLEN (x, i); j++)\n-\treplace_in_call_usage (& XVECEXP (x, i, j), dst_reg, src, insn);\n-}\n-\n /* Try to replace output operand DST in SET, with input operand SRC.  SET is\n    the only set in INSN.  INSN has just been recognized and constrained.\n    SRC is operand number OPERAND_NUMBER in INSN.\n@@ -1693,10 +1643,6 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \n   for (length = s_length = 0, p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n     {\n-      if (GET_CODE (p) == CALL_INSN)\n-\treplace_in_call_usage (& CALL_INSN_FUNCTION_USAGE (p),\n-\t\t\t       REGNO (dst), src, p);\n-\t  \n       /* ??? We can't scan past the end of a basic block without updating\n \t the register lifetime info (REG_DEAD/basic_block_live_at_start).  */\n       if (perhaps_ends_bb_p (p))"}]}