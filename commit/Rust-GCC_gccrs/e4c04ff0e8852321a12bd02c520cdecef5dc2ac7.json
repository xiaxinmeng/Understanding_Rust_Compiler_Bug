{"sha": "e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRjMDRmZjBlODg1MjMyMWExMmJkMDJjNTIwY2RlY2VmNWRjMmFjNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-11-12T09:21:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-11-12T09:21:45Z"}, "message": "re PR c++/57734 (Returning template alias to enum class fails with \"invalid declarator\")\n\n/cp\n2013-11-12  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/57734\n\t* pt.c (lookup_template_class_1): Handle alias template declarations\n\tof enumeration types.\n\n/testsuite\n2013-11-12  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/57734\n\t* g++.dg/cpp0x/alias-decl-enum-1.C: New.\n\nFrom-SVN: r204697", "tree": {"sha": "ac6149fb379cf7becabcda2af17d30fd50cfe1fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac6149fb379cf7becabcda2af17d30fd50cfe1fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/comments", "author": null, "committer": null, "parents": [{"sha": "801a661c44fdc05f6ad1edc3143386be4c7853b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801a661c44fdc05f6ad1edc3143386be4c7853b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801a661c44fdc05f6ad1edc3143386be4c7853b5"}], "stats": {"total": 109, "additions": 84, "deletions": 25}, "files": [{"sha": "fc70bbdc8cb99cb8777d0aade93344d0e298f56f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "patch": "@@ -1,3 +1,9 @@\n+2013-11-12  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/57734\n+\t* pt.c (lookup_template_class_1): Handle alias template declarations\n+\tof enumeration types.\n+\n 2013-11-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* cvt.c (cp_convert_to_pointer): Call build_ptrmemfunc before"}, {"sha": "d066c26dd88208ceb83e00554d4054172b78bdd4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "patch": "@@ -7458,30 +7458,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \tcontext = global_namespace;\n \n       /* Create the type.  */\n-      if (TREE_CODE (template_type) == ENUMERAL_TYPE)\n-\t{\n-\t  if (!is_dependent_type)\n-\t    {\n-\t      set_current_access_from_decl (TYPE_NAME (template_type));\n-\t      t = start_enum (TYPE_IDENTIFIER (template_type), NULL_TREE,\n-\t\t\t      tsubst (ENUM_UNDERLYING_TYPE (template_type),\n-\t\t\t\t      arglist, complain, in_decl),\n-\t\t\t      SCOPED_ENUM_P (template_type), NULL);\n-\t    }\n-\t  else\n-            {\n-              /* We don't want to call start_enum for this type, since\n-                 the values for the enumeration constants may involve\n-                 template parameters.  And, no one should be interested\n-                 in the enumeration constants for such a type.  */\n-              t = cxx_make_type (ENUMERAL_TYPE);\n-              SET_SCOPED_ENUM_P (t, SCOPED_ENUM_P (template_type));\n-            }\n-          SET_OPAQUE_ENUM_P (t, OPAQUE_ENUM_P (template_type));\n-\t  ENUM_FIXED_UNDERLYING_TYPE_P (t)\n-\t    = ENUM_FIXED_UNDERLYING_TYPE_P (template_type);\n-\t}\n-      else if (DECL_ALIAS_TEMPLATE_P (gen_tmpl))\n+      if (DECL_ALIAS_TEMPLATE_P (gen_tmpl))\n \t{\n \t  /* The user referred to a specialization of an alias\n \t    template represented by GEN_TMPL.\n@@ -7505,6 +7482,29 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t  if (t == error_mark_node)\n \t    return t;\n \t}\n+      else if (TREE_CODE (template_type) == ENUMERAL_TYPE)\n+\t{\n+\t  if (!is_dependent_type)\n+\t    {\n+\t      set_current_access_from_decl (TYPE_NAME (template_type));\n+\t      t = start_enum (TYPE_IDENTIFIER (template_type), NULL_TREE,\n+\t\t\t      tsubst (ENUM_UNDERLYING_TYPE (template_type),\n+\t\t\t\t      arglist, complain, in_decl),\n+\t\t\t      SCOPED_ENUM_P (template_type), NULL);\n+\t    }\n+\t  else\n+            {\n+              /* We don't want to call start_enum for this type, since\n+                 the values for the enumeration constants may involve\n+                 template parameters.  And, no one should be interested\n+                 in the enumeration constants for such a type.  */\n+              t = cxx_make_type (ENUMERAL_TYPE);\n+              SET_SCOPED_ENUM_P (t, SCOPED_ENUM_P (template_type));\n+            }\n+          SET_OPAQUE_ENUM_P (t, OPAQUE_ENUM_P (template_type));\n+\t  ENUM_FIXED_UNDERLYING_TYPE_P (t)\n+\t    = ENUM_FIXED_UNDERLYING_TYPE_P (template_type);\n+\t}\n       else if (CLASS_TYPE_P (template_type))\n \t{\n \t  t = make_class_type (TREE_CODE (template_type));\n@@ -7661,7 +7661,8 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t= tree_cons (arglist, t,\n \t\t     DECL_TEMPLATE_INSTANTIATIONS (templ));\n \n-      if (TREE_CODE (template_type) == ENUMERAL_TYPE && !is_dependent_type)\n+      if (TREE_CODE (template_type) == ENUMERAL_TYPE && !is_dependent_type\n+\t  && !DECL_ALIAS_TEMPLATE_P (gen_tmpl))\n \t/* Now that the type has been registered on the instantiations\n \t   list, we set up the enumerators.  Because the enumeration\n \t   constants may involve the enumeration type itself, we make"}, {"sha": "07106bc31a7ba3a376409d323ed36382b86af0d6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "patch": "@@ -1,3 +1,8 @@\n+2013-11-12  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/57734\n+\t* g++.dg/cpp0x/alias-decl-enum-1.C: New.\n+\n 2013-11-11  Martin Liska\t<marxin.liska@gmail.com>\n \n \t* gcc.dg/time-profiler-1.c: New test."}, {"sha": "260a193a0836ff539c05104ed3df41ad0051b6a0", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-enum-1.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-enum-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c04ff0e8852321a12bd02c520cdecef5dc2ac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-enum-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-enum-1.C?ref=e4c04ff0e8852321a12bd02c520cdecef5dc2ac7", "patch": "@@ -0,0 +1,47 @@\n+// PR c++/57734\n+// { dg-do compile { target c++11 } }\n+\n+template<typename T, typename U>\n+struct same_type { static const bool value = false; };\n+\n+template<typename T>\n+struct same_type<T, T> { static const bool value = true; };\n+\n+enum e { zero };\n+enum class eclass { one };\n+\n+template<typename T>\n+using enum_alias = e;\n+\n+template<typename T>\n+using eclass_alias = eclass;\n+\n+typedef enum_alias<void> etest0;\n+typedef enum_alias<void> etest0;\n+typedef enum_alias<int>  etest0;\n+typedef enum_alias<int>  etest1;\n+\n+static_assert (same_type<etest0, etest1>::value, \"\");\n+\n+typedef eclass_alias<void> ectest0;\n+typedef eclass_alias<void> ectest0;\n+typedef eclass_alias<int>  ectest0;\n+typedef eclass_alias<int>  ectest1;\n+\n+static_assert (same_type<ectest0, ectest1>::value, \"\");\n+\n+template<typename T>\n+enum_alias<T> efoo(T f) { return enum_alias<T>::zero; }\n+\n+template<typename T>\n+constexpr enum_alias<T> cefoo(T f) { return enum_alias<T>::zero; }\n+\n+static_assert ( cefoo(1) == e::zero, \"\");\n+\n+template<typename T>\n+eclass_alias<T> ecfoo(T f) { return eclass_alias<T>::one; }\n+\n+template<typename T>\n+constexpr eclass_alias<T> cecfoo(T f) { return eclass_alias<T>::one; }\n+\n+static_assert ( cecfoo(1) == eclass::one, \"\");"}]}