{"sha": "be5af15f2de92c69a358b5dd8525cdef671439a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU1YWYxNWYyZGU5MmM2OWEzNThiNWRkODUyNWNkZWY2NzE0MzlhOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-10-10T11:41:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-10-10T11:41:55Z"}, "message": "modulo-sched.c (undo_replace_buff_elem): Delete.\n\ngcc/\n\t* modulo-sched.c (undo_replace_buff_elem): Delete.\n\t(generate_reg_moves): Don't build and return an undo list.\n\t(free_undo_replace_buff): Delete.\n\t(sms_schedule): Adjust call to generate_reg_moves.\n\tDon't call free_undo_replace_buff.\n\nFrom-SVN: r179741", "tree": {"sha": "93a2ba740a84027eb382a89ead71717b5aeb6f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a2ba740a84027eb382a89ead71717b5aeb6f6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be5af15f2de92c69a358b5dd8525cdef671439a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be5af15f2de92c69a358b5dd8525cdef671439a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be5af15f2de92c69a358b5dd8525cdef671439a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be5af15f2de92c69a358b5dd8525cdef671439a9/comments", "author": null, "committer": null, "parents": [{"sha": "8a0180e7e70205660b5655c1b6cd03d7e204ca06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0180e7e70205660b5655c1b6cd03d7e204ca06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a0180e7e70205660b5655c1b6cd03d7e204ca06"}], "stats": {"total": 59, "additions": 10, "deletions": 49}, "files": [{"sha": "ecccc88443b75c165718e4fad4dccf3569cc2eb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5af15f2de92c69a358b5dd8525cdef671439a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5af15f2de92c69a358b5dd8525cdef671439a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be5af15f2de92c69a358b5dd8525cdef671439a9", "patch": "@@ -1,3 +1,11 @@\n+2011-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* modulo-sched.c (undo_replace_buff_elem): Delete.\n+\t(generate_reg_moves): Don't build and return an undo list.\n+\t(free_undo_replace_buff): Delete.\n+\t(sms_schedule): Adjust call to generate_reg_moves.\n+\tDon't call free_undo_replace_buff.\n+\n 2011-10-10  Matthias Klose <doko@ubuntu.com>\n \n \t* common/config/m32c: Remove empty directory."}, {"sha": "cc4726850e0663f1b2a22de999f9ea762ce70fc4", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 49, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be5af15f2de92c69a358b5dd8525cdef671439a9/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be5af15f2de92c69a358b5dd8525cdef671439a9/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=be5af15f2de92c69a358b5dd8525cdef671439a9", "patch": "@@ -165,17 +165,6 @@ struct partial_schedule\n   int stage_count;  /* The stage count of the partial schedule.  */\n };\n \n-/* We use this to record all the register replacements we do in\n-   the kernel so we can undo SMS if it is not profitable.  */\n-struct undo_replace_buff_elem\n-{\n-  rtx insn;\n-  rtx orig_reg;\n-  rtx new_reg;\n-  struct undo_replace_buff_elem *next;\n-};\n-\n-\n \n static partial_schedule_ptr create_partial_schedule (int ii, ddg_ptr, int history);\n static void free_partial_schedule (partial_schedule_ptr);\n@@ -460,13 +449,12 @@ print_node_sched_params (FILE *file, int num_nodes, ddg_ptr g)\n    nreg_moves = ----------------------------------- + 1 - {   dependence.\n                             ii                          { 1 if not.\n */\n-static struct undo_replace_buff_elem *\n+static void\n generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n {\n   ddg_ptr g = ps->g;\n   int ii = ps->ii;\n   int i;\n-  struct undo_replace_buff_elem *reg_move_replaces = NULL;\n \n   for (i = 0; i < g->num_nodes; i++)\n     {\n@@ -562,22 +550,6 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n \n \t  EXECUTE_IF_SET_IN_SBITMAP (uses_of_defs[i_reg_move], 0, i_use, sbi)\n \t    {\n-\t      struct undo_replace_buff_elem *rep;\n-\n-\t      rep = (struct undo_replace_buff_elem *)\n-\t\t    xcalloc (1, sizeof (struct undo_replace_buff_elem));\n-\t      rep->insn = g->nodes[i_use].insn;\n-\t      rep->orig_reg = old_reg;\n-\t      rep->new_reg = new_reg;\n-\n-\t      if (! reg_move_replaces)\n-\t\treg_move_replaces = rep;\n-\t      else\n-\t\t{\n-\t\t  rep->next = reg_move_replaces;\n-\t\t  reg_move_replaces = rep;\n-\t\t}\n-\n \t      replace_rtx (g->nodes[i_use].insn, old_reg, new_reg);\n \t      if (rescan)\n \t\tdf_insn_rescan (g->nodes[i_use].insn);\n@@ -587,21 +559,6 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n \t}\n       sbitmap_vector_free (uses_of_defs);\n     }\n-  return reg_move_replaces;\n-}\n-\n-/* Free memory allocated for the undo buffer.  */\n-static void\n-free_undo_replace_buff (struct undo_replace_buff_elem *reg_move_replaces)\n-{\n-\n-  while (reg_move_replaces)\n-    {\n-      struct undo_replace_buff_elem *rep = reg_move_replaces;\n-\n-      reg_move_replaces = reg_move_replaces->next;\n-      free (rep);\n-    }\n }\n \n /* Update the sched_params (time, row and stage) for node U using the II,\n@@ -1480,8 +1437,6 @@ sms_schedule (void)\n \t}\n       else\n \t{\n-\t  struct undo_replace_buff_elem *reg_move_replaces;\n-\n           if (!opt_sc_p)\n             {\n \t      /* Rotate the partial schedule to have the branch in row ii-1.  */\n@@ -1531,13 +1486,11 @@ sms_schedule (void)\n \t  /* The life-info is not valid any more.  */\n \t  df_set_bb_dirty (g->bb);\n \n-\t  reg_move_replaces = generate_reg_moves (ps, true);\n+\t  generate_reg_moves (ps, true);\n \t  if (dump_file)\n \t    print_node_sched_params (dump_file, g->num_nodes, g);\n \t  /* Generate prolog and epilog.  */\n           generate_prolog_epilog (ps, loop, count_reg, count_init);\n-\n-\t  free_undo_replace_buff (reg_move_replaces);\n \t}\n \n       free_partial_schedule (ps);"}]}