{"sha": "bbe04bade0cc3b17e62c2af3d89b899367e7d2d1", "node_id": "C_kwDOANBUbNoAKGJiZTA0YmFkZTBjYzNiMTdlNjJjMmFmM2Q4OWI4OTkzNjdlN2QyZDE", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-12-22T01:16:24Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-12-22T01:16:24Z"}, "message": "Update znver4 costs\n\nUpdate cost of znver4 mostly based on data measued by Agner Fog.\nCompared to previous generations x87 became bit slower which is probably not\nbig deal (and we have minimal benchmarking coverage for it).  One interesting\nimprovement is reducation of FMA cost.  I also updated costs of AVX256\nloads/stores  based on latencies (not throughput which is twice of avx256).\nOverall AVX512 vectorization seems to improve noticeably some of TSVC\nbenchmarks but since internally 512 vectors are split to 256 vectors it is\nsomewhat risky and does not win in SPEC scores (mostly by regressing benchmarks\nwith loop that have small trip count like x264 and exchange), so for now I am\ngoing to set AVX256_OPTIMAL tune but I am still playing with it.  We improved\nsince ZNVER1 on choosing vectorization size and also have vectorized\nprologues/epilogues so it may be possible to make avx512 small win overall.\n\n2022-12-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* config/i386/x86-tune-costs.h (znver4_cost): Upate costs of FP and SSE\n\tmoves, division multiplication, gathers, L2 cache size, and more\n\tcomplex FP instrutions.", "tree": {"sha": "b51f81927c88afeafd58c432bc618ec4c3b4257b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b51f81927c88afeafd58c432bc618ec4c3b4257b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbe04bade0cc3b17e62c2af3d89b899367e7d2d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe04bade0cc3b17e62c2af3d89b899367e7d2d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe04bade0cc3b17e62c2af3d89b899367e7d2d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe04bade0cc3b17e62c2af3d89b899367e7d2d1/comments", "author": null, "committer": null, "parents": [{"sha": "de282a2012049ea7d1236f8cb6f946385057c20f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de282a2012049ea7d1236f8cb6f946385057c20f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de282a2012049ea7d1236f8cb6f946385057c20f"}], "stats": {"total": 61, "additions": 31, "deletions": 30}, "files": [{"sha": "18ad3cc296bf482ae3e1ae79f19bb26cc3385e73", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe04bade0cc3b17e62c2af3d89b899367e7d2d1/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe04bade0cc3b17e62c2af3d89b899367e7d2d1/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=bbe04bade0cc3b17e62c2af3d89b899367e7d2d1", "patch": "@@ -1867,9 +1867,9 @@ struct processor_costs znver4_cost = {\n   {8, 8, 8},\t\t\t\t/* cost of storing integer\n \t\t\t\t\t   registers.  */\n   2,\t\t\t\t\t/* cost of reg,reg fld/fst.  */\n-  {6, 6, 16},\t\t\t\t/* cost of loading fp registers\n+  {14, 14, 17},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode.  */\n-  {8, 8, 16},\t\t\t\t/* cost of storing fp registers\n+  {12, 12, 16},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode.  */\n   2,\t\t\t\t\t/* cost of moving MMX register.  */\n   {6, 6},\t\t\t\t/* cost of loading MMX registers\n@@ -1878,13 +1878,13 @@ struct processor_costs znver4_cost = {\n \t\t\t\t\t   in SImode and DImode.  */\n   2, 2, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM\n \t\t\t\t\t   register.  */\n-  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n+  {6, 6, 10, 10, 12},\t\t\t/* cost of loading SSE registers\n \t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n-  {8, 8, 8, 8, 16},\t\t\t/* cost of storing SSE registers\n+  {8, 8, 8, 12, 12},\t\t\t/* cost of storing SSE registers\n \t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n-  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE\n+  6, 8,\t\t\t\t\t/* SSE->integer and integer->SSE\n \t\t\t\t\t   moves.  */\n-  8, 8,\t\t\t\t/* mask->integer and integer->mask moves */\n+  8, 8,\t\t\t\t\t/* mask->integer and integer->mask moves */\n   {6, 6, 6},\t\t\t\t/* cost of loading mask register\n \t\t\t\t\t   in QImode, HImode, SImode.  */\n   {8, 8, 8},\t\t\t\t/* cost if storing mask register\n@@ -1894,6 +1894,7 @@ struct processor_costs znver4_cost = {\n   },\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction.  */\n+  /* TODO: Lea with 3 components has cost 2.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs.  */\n   COSTS_N_INSNS (1),\t\t\t/* constant shift costs.  */\n@@ -1904,11 +1905,11 @@ struct processor_costs znver4_cost = {\n    COSTS_N_INSNS (3)},\t\t\t/*\t\t\tother.  */\n   0,\t\t\t\t\t/* cost of multiply per each bit\n \t\t\t\t\t   set.  */\n-  {COSTS_N_INSNS (9),\t\t\t/* cost of a divide/mod for QI.  */\n-   COSTS_N_INSNS (10),\t\t\t/* \t\t\t    HI.  */\n-   COSTS_N_INSNS (12),\t\t\t/*\t\t\t    SI.  */\n-   COSTS_N_INSNS (17),\t\t\t/*\t\t\t    DI.  */\n-   COSTS_N_INSNS (17)},\t\t\t/*\t\t\t    other.  */\n+  {COSTS_N_INSNS (12),\t\t\t/* cost of a divide/mod for QI.  */\n+   COSTS_N_INSNS (13),\t\t\t/* \t\t\t    HI.  */\n+   COSTS_N_INSNS (13),\t\t\t/*\t\t\t    SI.  */\n+   COSTS_N_INSNS (18),\t\t\t/*\t\t\t    DI.  */\n+   COSTS_N_INSNS (18)},\t\t\t/*\t\t\t    other.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movsx.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx.  */\n   8,\t\t\t\t\t/* \"large\" insn.  */\n@@ -1919,22 +1920,22 @@ struct processor_costs znver4_cost = {\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {8, 8, 8},\t\t\t\t/* cost of storing integer\n \t\t\t\t\t   registers.  */\n-  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n+  {6, 6, 10, 10, 12},\t\t\t/* cost of loading SSE registers\n \t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n-  {8, 8, 8, 8, 16},\t\t\t/* cost of storing SSE register\n+  {8, 8, 8, 12, 12},\t\t\t/* cost of storing SSE register\n \t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n-  {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned loads.  */\n-  {8, 8, 8, 8, 16},\t\t\t/* cost of unaligned stores.  */\n-  2, 2, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM\n+  {6, 6, 6, 6, 6},\t\t\t/* cost of unaligned loads.  */\n+  {8, 8, 8, 8, 8},\t\t\t/* cost of unaligned stores.  */\n+  2, 2, 2,\t\t\t\t/* cost of moving XMM,YMM,ZMM\n \t\t\t\t\t   register.  */\n   6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n-  /* VGATHERDPD is 15 uops and throughput is 4, VGATHERDPS is 23 uops,\n-     throughput 9.  Approx 7 uops do not depend on vector size and every load\n-     is 4 uops.  */\n-  14, 8,\t\t\t\t/* Gather load static, per_elt.  */\n-  14, 10,\t\t\t\t/* Gather store static, per_elt.  */\n+  /* VGATHERDPD is 17 uops and throughput is 4, VGATHERDPS is 24 uops,\n+     throughput 5.  Approx 7 uops do not depend on vector size and every load\n+     is 5 uops.  */\n+  14, 10,\t\t\t\t/* Gather load static, per_elt.  */\n+  14, 20,\t\t\t\t/* Gather store static, per_elt.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n-  512,\t\t\t\t\t/* size of l2 cache.  */\n+  1024,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block.  */\n   /* New AMD processors never drop prefetches; if they cannot be performed\n      immediately, they are queued.  We set number of simultaneous prefetches\n@@ -1943,26 +1944,26 @@ struct processor_costs znver4_cost = {\n      time).  */\n   100,\t\t\t\t\t/* number of parallel prefetches.  */\n   3,\t\t\t\t\t/* Branch cost.  */\n-  COSTS_N_INSNS (5),\t\t\t/* cost of FADD and FSUB insns.  */\n-  COSTS_N_INSNS (5),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (7),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (7),\t\t\t/* cost of FMUL instruction.  */\n   /* Latency of fdiv is 8-15.  */\n   COSTS_N_INSNS (15),\t\t\t/* cost of FDIV instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   /* Latency of fsqrt is 4-10.  */\n-  COSTS_N_INSNS (10),\t\t\t/* cost of FSQRT instruction.  */\n+  COSTS_N_INSNS (25),\t\t\t/* cost of FSQRT instruction.  */\n \n   COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of MULSS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of MULSD instruction.  */\n-  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SS instruction.  */\n-  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SD instruction.  */\n-  COSTS_N_INSNS (10),\t\t\t/* cost of DIVSS instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (4),\t\t\t/* cost of FMA SD instruction.  */\n+  COSTS_N_INSNS (13),\t\t\t/* cost of DIVSS instruction.  */\n   /* 9-13.  */\n   COSTS_N_INSNS (13),\t\t\t/* cost of DIVSD instruction.  */\n-  COSTS_N_INSNS (10),\t\t\t/* cost of SQRTSS instruction.  */\n-  COSTS_N_INSNS (15),\t\t\t/* cost of SQRTSD instruction.  */\n+  COSTS_N_INSNS (15),\t\t\t/* cost of SQRTSS instruction.  */\n+  COSTS_N_INSNS (21),\t\t\t/* cost of SQRTSD instruction.  */\n   /* Zen can execute 4 integer operations per cycle.  FP operations\n      take 3 cycles and it can execute 2 integer additions and 2\n      multiplications thus reassociation may make sense up to with of 6."}]}