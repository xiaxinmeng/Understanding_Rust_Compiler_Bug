{"sha": "160061ac10f9143d9698daac5f7e46b5a615825c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYwMDYxYWMxMGY5MTQzZDk2OThkYWFjNWY3ZTQ2YjVhNjE1ODI1Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-22T14:45:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-22T14:45:54Z"}, "message": "libstdc++: Introduce new headers for C++20 ranges components\n\nThis introduces two new headers:\n\n<bits/ranges_base.h> defines the minimal components needed\nfor using C++20 ranges (customization point objects such as\nstd::ranges::begin, concepts such as std::ranges::range, etc.)\n\n<bits/ranges_util.h> includes <bits/ranges_base.h> and additionally\ndefines subrange, which is needed by <bits/ranges_algo.h>.\n\nMost of the content of <bits/ranges_base.h> was previously defined in\n<bits/range_access.h>, but a few pieces were only defined in <ranges>.\nThis meant the entire <ranges> header was needed in <algorithm> and\n<memory>, even though they don't use all the range adaptors.\n\nBy moving the ranges components out of <bits/range_access.h> that file\nis left defining just the contents of [iterator.range] i.e. std::begin,\nstd::end, std::size etc. and not C++20 ranges components.\n\nFor consistency with other C++20 ranges headers, <bits/range_cmp.h> is\nrenamed to <bits/ranges_cmp.h>.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new headers and adjust for renamed\n\theader.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/iterator_concepts.h: Adjust for renamed header.\n\t* include/bits/range_access.h (ranges::*): Move to new\n\t<bits/ranges_base.h> header.\n\t* include/bits/ranges_algobase.h: Include new <bits/ranges_base.h>\n\theader instead of <ranges>.\n\t* include/bits/ranges_algo.h: Include new <bits/ranges_util.h>\n\theader.\n\t* include/bits/range_cmp.h: Moved to...\n\t* include/bits/ranges_cmp.h: ...here.\n\t* include/bits/ranges_base.h: New header.\n\t* include/bits/ranges_util.h: New header.\n\t* include/experimental/string_view: Include new\n\t<bits/ranges_base.h> header.\n\t* include/std/functional: Adjust for renamed header.\n\t* include/std/ranges (ranges::view_base, ranges::enable_view)\n\t(ranges::dangling, ranges::borrowed_iterator_t): Move to new\n\t<bits/ranges_base.h> header.\n\t(ranges::view_interface, ranges::subrange)\n\t(ranges::borrowed_subrange_t): Move to new <bits/ranges_util.h>\n\theader.\n\t* include/std/span: Include new <bits/ranges_base.h> header.\n\t* include/std/string_view: Likewise.\n\t* testsuite/24_iterators/back_insert_iterator/pr93884.cc: Add\n\tmissing <ranges> header.\n\t* testsuite/24_iterators/front_insert_iterator/pr93884.cc:\n\tLikewise.", "tree": {"sha": "1374ca7bb120f47da781098591af719e76019d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1374ca7bb120f47da781098591af719e76019d44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/160061ac10f9143d9698daac5f7e46b5a615825c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160061ac10f9143d9698daac5f7e46b5a615825c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/160061ac10f9143d9698daac5f7e46b5a615825c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160061ac10f9143d9698daac5f7e46b5a615825c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7df1534c136e2556ca10d3a60d2b2cc77544dbc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df1534c136e2556ca10d3a60d2b2cc77544dbc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df1534c136e2556ca10d3a60d2b2cc77544dbc8"}], "stats": {"total": 2578, "additions": 1341, "deletions": 1237}, "files": [{"sha": "28d273924ee0fa321ef58ea9379f7574a20ca20b", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -158,10 +158,12 @@ bits_headers = \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n-\t${bits_srcdir}/range_cmp.h \\\n \t${bits_srcdir}/ranges_algobase.h \\\n \t${bits_srcdir}/ranges_algo.h \\\n+\t${bits_srcdir}/ranges_base.h \\\n+\t${bits_srcdir}/ranges_cmp.h \\\n \t${bits_srcdir}/ranges_uninitialized.h \\\n+\t${bits_srcdir}/ranges_util.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\"}, {"sha": "2dfd8d2cb36a7e3cb0b33c76597529945c46eeed", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -504,10 +504,12 @@ bits_headers = \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n-\t${bits_srcdir}/range_cmp.h \\\n \t${bits_srcdir}/ranges_algobase.h \\\n \t${bits_srcdir}/ranges_algo.h \\\n+\t${bits_srcdir}/ranges_base.h \\\n+\t${bits_srcdir}/ranges_cmp.h \\\n \t${bits_srcdir}/ranges_uninitialized.h \\\n+\t${bits_srcdir}/ranges_util.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\"}, {"sha": "8ff4f8667dd11471cd180dea58b4762345a5673c", "filename": "libstdc++-v3/include/bits/iterator_concepts.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -34,7 +34,7 @@\n \n #include <concepts>\n #include <bits/ptr_traits.h>\t// to_address\n-#include <bits/range_cmp.h>\t// identity, ranges::less\n+#include <bits/ranges_cmp.h>\t// identity, ranges::less\n \n #if __cpp_lib_concepts\n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "c8d8185172d772e2dbb0e959957b732ec9515b7e", "filename": "libstdc++-v3/include/bits/range_access.h", "status": "modified", "additions": 4, "deletions": 823, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -1,4 +1,4 @@\n-// <range_access.h> -*- C++ -*-\n+// Range access functions for containers -*- C++ -*-\n \n // Copyright (C) 2010-2020 Free Software Foundation, Inc.\n //\n@@ -34,11 +34,7 @@\n \n #if __cplusplus >= 201103L\n #include <initializer_list>\n-#include <bits/iterator_concepts.h>\n-#include <ext/numeric_traits.h>\n-#if __cplusplus > 201703L\n-#include <bits/max_size_type.h>\n-#endif\n+#include <type_traits>\t    // common_type_t, make_signed_t\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -322,8 +318,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     data(initializer_list<_Tp> __il) noexcept\n     { return __il.begin(); }\n \n-#endif // C++17\n-\n #if __cplusplus > 201703L\n #define __cpp_lib_ssize 201902L\n   template<typename _Container>\n@@ -340,824 +334,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     constexpr ptrdiff_t\n     ssize(const _Tp (&)[_Num]) noexcept\n     { return _Num; }\n-\n-#ifdef __cpp_lib_concepts\n-namespace ranges\n-{\n-  template<typename>\n-    inline constexpr bool disable_sized_range = false;\n-\n-  template<typename _Tp>\n-    inline constexpr bool enable_borrowed_range = false;\n-\n-  template<typename _Tp>\n-    extern const bool enable_view;\n-\n-  namespace __detail\n-  {\n-    constexpr __max_size_type\n-    __to_unsigned_like(__max_size_type __t) noexcept\n-    { return __t; }\n-\n-    constexpr __max_size_type\n-    __to_unsigned_like(__max_diff_type __t) noexcept\n-    { return __max_size_type(__t); }\n-\n-    template<integral _Tp>\n-      constexpr auto\n-      __to_unsigned_like(_Tp __t) noexcept\n-      { return static_cast<make_unsigned_t<_Tp>>(__t); }\n-\n-#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__\n-    constexpr unsigned __int128\n-    __to_unsigned_like(__int128 __t) noexcept\n-    { return __t; }\n-\n-    constexpr unsigned __int128\n-    __to_unsigned_like(unsigned __int128 __t) noexcept\n-    { return __t; }\n-#endif\n-\n-    template<typename _Tp>\n-      using __make_unsigned_like_t\n-\t= decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));\n-\n-    // Part of the constraints of ranges::borrowed_range\n-    template<typename _Tp>\n-      concept __maybe_borrowed_range\n-\t= is_lvalue_reference_v<_Tp>\n-\t  || enable_borrowed_range<remove_cvref_t<_Tp>>;\n-\n-  } // namespace __detail\n-\n-  namespace __cust_access\n-  {\n-    using std::ranges::__detail::__maybe_borrowed_range;\n-    using std::__detail::__class_or_enum;\n-    using std::__detail::__decay_copy;\n-    using std::__detail::__member_begin;\n-    using std::__detail::__adl_begin;\n-\n-    struct _Begin\n-    {\n-    private:\n-      template<typename _Tp>\n-\tstatic constexpr bool\n-\t_S_noexcept()\n-\t{\n-\t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n-\t    return true;\n-\t  else if constexpr (__member_begin<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp&>().begin()));\n-\t  else\n-\t    return noexcept(__decay_copy(begin(std::declval<_Tp&>())));\n-\t}\n-\n-    public:\n-      template<__maybe_borrowed_range _Tp>\n-\trequires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>\n-\t  || __adl_begin<_Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n-\t{\n-\t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n-\t    {\n-\t      static_assert(is_lvalue_reference_v<_Tp>);\n-\t      using _Up = remove_all_extents_t<remove_reference_t<_Tp>>;\n-\t      static_assert(sizeof(_Up) != 0, \"not array of incomplete type\");\n-\t      return __t + 0;\n-\t    }\n-\t  else if constexpr (__member_begin<_Tp>)\n-\t    return __t.begin();\n-\t  else\n-\t    return begin(__t);\n-\t}\n-    };\n-\n-    template<typename _Tp>\n-      concept __member_end = requires(_Tp& __t)\n-\t{\n-\t  { __decay_copy(__t.end()) }\n-\t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n-\t};\n-\n-    void end(auto&) = delete;\n-    void end(const auto&) = delete;\n-\n-    template<typename _Tp>\n-      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>\n-\t&& requires(_Tp& __t)\n-\t{\n-\t  { __decay_copy(end(__t)) }\n-\t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n-\t};\n-\n-    struct _End\n-    {\n-    private:\n-      template<typename _Tp>\n-\tstatic constexpr bool\n-\t_S_noexcept()\n-\t{\n-\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n-\t    return true;\n-\t  else if constexpr (__member_end<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp&>().end()));\n-\t  else\n-\t    return noexcept(__decay_copy(end(std::declval<_Tp&>())));\n-\t}\n-\n-    public:\n-      template<__maybe_borrowed_range _Tp>\n-\trequires is_bounded_array_v<remove_reference_t<_Tp>> || __member_end<_Tp>\n-\t|| __adl_end<_Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n-\t{\n-\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n-\t    {\n-\t      static_assert(is_lvalue_reference_v<_Tp>);\n-\t      return __t + extent_v<remove_reference_t<_Tp>>;\n-\t    }\n-\t  else if constexpr (__member_end<_Tp>)\n-\t    return __t.end();\n-\t  else\n-\t    return end(__t);\n-\t}\n-    };\n-\n-    template<typename _Tp>\n-      constexpr decltype(auto)\n-      __as_const(_Tp&& __t) noexcept\n-      {\n-\tif constexpr (is_lvalue_reference_v<_Tp>)\n-\t  return static_cast<const remove_reference_t<_Tp>&>(__t);\n-\telse\n-\t  return static_cast<const _Tp&&>(__t);\n-      }\n-\n-    struct _CBegin\n-    {\n-      template<typename _Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_Begin{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _Begin{}(__cust_access::__as_const((_Tp&&)__e)); }\n-\t{\n-\t  return _Begin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-    struct _CEnd\n-    {\n-      template<typename _Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_End{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _End{}(__cust_access::__as_const((_Tp&&)__e)); }\n-\t{\n-\t  return _End{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-    template<typename _Tp>\n-      concept __member_rbegin = requires(_Tp& __t)\n-\t{\n-\t  { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;\n-\t};\n-\n-    void rbegin(auto&) = delete;\n-    void rbegin(const auto&) = delete;\n-\n-    template<typename _Tp>\n-      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>\n-\t&& requires(_Tp& __t)\n-\t{\n-\t  { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;\n-\t};\n-\n-    template<typename _Tp>\n-      concept __reversable = requires(_Tp& __t)\n-\t{\n-\t  { _Begin{}(__t) } -> bidirectional_iterator;\n-\t  { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;\n-\t};\n-\n-    struct _RBegin\n-    {\n-    private:\n-      template<typename _Tp>\n-\tstatic constexpr bool\n-\t_S_noexcept()\n-\t{\n-\t  if constexpr (__member_rbegin<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));\n-\t  else if constexpr (__adl_rbegin<_Tp>)\n-\t    return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));\n-\t  else\n-\t    {\n-\t      if constexpr (noexcept(_End{}(std::declval<_Tp&>())))\n-\t\t{\n-\t\t  using _It = decltype(_End{}(std::declval<_Tp&>()));\n-\t\t  // std::reverse_iterator copy-initializes its member.\n-\t\t  return is_nothrow_copy_constructible_v<_It>;\n-\t\t}\n-\t      else\n-\t\treturn false;\n-\t    }\n-\t}\n-\n-    public:\n-      template<__maybe_borrowed_range _Tp>\n-\trequires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __t) const\n-\tnoexcept(_S_noexcept<_Tp>())\n-\t{\n-\t  if constexpr (__member_rbegin<_Tp>)\n-\t    return __t.rbegin();\n-\t  else if constexpr (__adl_rbegin<_Tp>)\n-\t    return rbegin(__t);\n-\t  else\n-\t    return std::make_reverse_iterator(_End{}(__t));\n-\t}\n-    };\n-\n-    template<typename _Tp>\n-      concept __member_rend = requires(_Tp& __t)\n-\t{\n-\t  { __decay_copy(__t.rend()) }\n-\t    -> sentinel_for<decltype(_RBegin{}(__t))>;\n-\t};\n-\n-    void rend(auto&) = delete;\n-    void rend(const auto&) = delete;\n-\n-    template<typename _Tp>\n-      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>\n-\t&& requires(_Tp& __t)\n-\t{\n-\t  { __decay_copy(rend(__t)) }\n-\t    -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;\n-\t};\n-\n-    struct _REnd\n-    {\n-    private:\n-      template<typename _Tp>\n-\tstatic constexpr bool\n-\t_S_noexcept()\n-\t{\n-\t  if constexpr (__member_rend<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp&>().rend()));\n-\t  else if constexpr (__adl_rend<_Tp>)\n-\t    return noexcept(__decay_copy(rend(std::declval<_Tp&>())));\n-\t  else\n-\t    {\n-\t      if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))\n-\t\t{\n-\t\t  using _It = decltype(_Begin{}(std::declval<_Tp&>()));\n-\t\t  // std::reverse_iterator copy-initializes its member.\n-\t\t  return is_nothrow_copy_constructible_v<_It>;\n-\t\t}\n-\t      else\n-\t\treturn false;\n-\t    }\n-\t}\n-\n-    public:\n-      template<__maybe_borrowed_range _Tp>\n-\trequires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __t) const\n-\tnoexcept(_S_noexcept<_Tp>())\n-\t{\n-\t  if constexpr (__member_rend<_Tp>)\n-\t    return __t.rend();\n-\t  else if constexpr (__adl_rend<_Tp>)\n-\t    return rend(__t);\n-\t  else\n-\t    return std::make_reverse_iterator(_Begin{}(__t));\n-\t}\n-    };\n-\n-    struct _CRBegin\n-    {\n-      template<typename _Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_RBegin{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _RBegin{}(__cust_access::__as_const((_Tp&&)__e)); }\n-\t{\n-\t  return _RBegin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-    struct _CREnd\n-    {\n-      template<typename _Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_REnd{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _REnd{}(__cust_access::__as_const((_Tp&&)__e)); }\n-\t{\n-\t  return _REnd{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-    template<typename _Tp>\n-      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n-\t{\n-\t  { __decay_copy(std::forward<_Tp>(__t).size()) }\n-\t    -> __detail::__is_integer_like;\n-\t};\n-\n-    void size(auto&) = delete;\n-    void size(const auto&) = delete;\n-\n-    template<typename _Tp>\n-      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>\n-\t&& !disable_sized_range<remove_cvref_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n-\t{\n-\t  { __decay_copy(size(std::forward<_Tp>(__t))) }\n-\t    -> __detail::__is_integer_like;\n-\t};\n-\n-    template<typename _Tp>\n-      concept __sentinel_size = requires(_Tp&& __t)\n-\t{\n-\t  { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;\n-\n-\t  { _End{}(std::forward<_Tp>(__t)) }\n-\t    -> sized_sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n-\t};\n-\n-    struct _Size\n-    {\n-    private:\n-      template<typename _Tp>\n-\tstatic constexpr bool\n-\t_S_noexcept()\n-\t{\n-\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n-\t    return true;\n-\t  else if constexpr (__member_size<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().size()));\n-\t  else if constexpr (__adl_size<_Tp>)\n-\t    return noexcept(__decay_copy(size(std::declval<_Tp>())));\n-\t  else if constexpr (__sentinel_size<_Tp>)\n-\t    return noexcept(_End{}(std::declval<_Tp>())\n-\t\t\t    - _Begin{}(std::declval<_Tp>()));\n-\t}\n-\n-    public:\n-      template<typename _Tp>\n-\trequires is_bounded_array_v<remove_reference_t<_Tp>>\n-\t  || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n-\t{\n-\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n-\t    {\n-\t      return extent_v<remove_reference_t<_Tp>>;\n-\t    }\n-\t  else if constexpr (__member_size<_Tp>)\n-\t    return std::forward<_Tp>(__e).size();\n-\t  else if constexpr (__adl_size<_Tp>)\n-\t    return size(std::forward<_Tp>(__e));\n-\t  else if constexpr (__sentinel_size<_Tp>)\n-\t    return __detail::__to_unsigned_like(\n-\t\t_End{}(std::forward<_Tp>(__e))\n-\t\t- _Begin{}(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-    struct _SSize\n-    {\n-      template<typename _Tp>\n-\trequires requires (_Tp&& __e)\n-\t  {\n-\t    _Begin{}(std::forward<_Tp>(__e));\n-\t    _Size{}(std::forward<_Tp>(__e));\n-\t  }\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_Size{}(std::forward<_Tp>(__e))))\n-\t{\n-\t  using __iter_type = decltype(_Begin{}(std::forward<_Tp>(__e)));\n-\t  using __diff_type = iter_difference_t<__iter_type>;\n-\t  using __gnu_cxx::__int_traits;\n-\t  auto __size = _Size{}(std::forward<_Tp>(__e));\n-\t  if constexpr (integral<__diff_type>)\n-\t    {\n-\t      if constexpr (__int_traits<__diff_type>::__digits\n-\t\t\t    < __int_traits<ptrdiff_t>::__digits)\n-\t\treturn static_cast<ptrdiff_t>(__size);\n-\t    }\n-\t  return static_cast<__diff_type>(__size);\n-\t}\n-    };\n-\n-    template<typename _Tp>\n-      concept __member_empty = requires(_Tp&& __t)\n-\t{ bool(std::forward<_Tp>(__t).empty()); };\n-\n-    template<typename _Tp>\n-      concept __size0_empty = requires(_Tp&& __t)\n-\t{ _Size{}(std::forward<_Tp>(__t)) == 0; };\n-\n-    template<typename _Tp>\n-      concept __eq_iter_empty = requires(_Tp&& __t)\n-\t{\n-\t  { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;\n-\t  bool(_Begin{}(std::forward<_Tp>(__t))\n-\t      == _End{}(std::forward<_Tp>(__t)));\n-\t};\n-\n-    struct _Empty\n-    {\n-    private:\n-      template<typename _Tp>\n-\tstatic constexpr bool\n-\t_S_noexcept()\n-\t{\n-\t  if constexpr (__member_empty<_Tp>)\n-\t    return noexcept(std::declval<_Tp>().empty());\n-\t  else if constexpr (__size0_empty<_Tp>)\n-\t    return noexcept(_Size{}(std::declval<_Tp>()) == 0);\n-\t  else\n-\t    return noexcept(bool(_Begin{}(std::declval<_Tp>())\n-\t\t== _End{}(std::declval<_Tp>())));\n-\t}\n-\n-    public:\n-      template<typename _Tp>\n-\trequires __member_empty<_Tp> || __size0_empty<_Tp>\n-\t|| __eq_iter_empty<_Tp>\n-\tconstexpr bool\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n-\t{\n-\t  if constexpr (__member_empty<_Tp>)\n-\t    return bool(std::forward<_Tp>(__e).empty());\n-\t  else if constexpr (__size0_empty<_Tp>)\n-\t    return _Size{}(std::forward<_Tp>(__e)) == 0;\n-\t  else\n-\t    return bool(_Begin{}(std::forward<_Tp>(__e))\n-\t\t== _End{}(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-    template<typename _Tp>\n-      concept __pointer_to_object = is_pointer_v<_Tp>\n-\t\t\t\t    && is_object_v<remove_pointer_t<_Tp>>;\n-\n-    template<typename _Tp>\n-      concept __member_data = is_lvalue_reference_v<_Tp>\n-\t&& requires(_Tp __t) { { __t.data() } -> __pointer_to_object; };\n-\n-    template<typename _Tp>\n-      concept __begin_data = requires(_Tp&& __t)\n-\t{ { _Begin{}(std::forward<_Tp>(__t)) } -> contiguous_iterator; };\n-\n-    struct _Data\n-    {\n-    private:\n-      template<typename _Tp>\n-\tstatic constexpr bool\n-\t_S_noexcept()\n-\t{\n-\t  if constexpr (__member_data<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().data()));\n-\t  else\n-\t    return noexcept(_Begin{}(std::declval<_Tp>()));\n-\t}\n-\n-    public:\n-      template<__maybe_borrowed_range _Tp>\n-\trequires __member_data<_Tp> || __begin_data<_Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n-\t{\n-\t  if constexpr (__member_data<_Tp>)\n-\t    return __e.data();\n-\t  else\n-\t    return std::to_address(_Begin{}(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-    struct _CData\n-    {\n-      template<typename _Tp>\n-\tconstexpr auto\n-\toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_Data{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _Data{}(__cust_access::__as_const((_Tp&&)__e)); }\n-\t{\n-\t  return _Data{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n-\t}\n-    };\n-\n-  } // namespace __cust_access\n-\n-  inline namespace __cust\n-  {\n-    inline constexpr __cust_access::_Begin begin{};\n-    inline constexpr __cust_access::_End end{};\n-    inline constexpr __cust_access::_CBegin cbegin{};\n-    inline constexpr __cust_access::_CEnd cend{};\n-    inline constexpr __cust_access::_RBegin rbegin{};\n-    inline constexpr __cust_access::_REnd rend{};\n-    inline constexpr __cust_access::_CRBegin crbegin{};\n-    inline constexpr __cust_access::_CREnd crend{};\n-    inline constexpr __cust_access::_Size size{};\n-    inline constexpr __cust_access::_SSize ssize{};\n-    inline constexpr __cust_access::_Empty empty{};\n-    inline constexpr __cust_access::_Data data{};\n-    inline constexpr __cust_access::_CData cdata{};\n-  }\n-\n-  /// [range.range] The range concept.\n-  template<typename _Tp>\n-    concept range = requires(_Tp& __t)\n-      {\n-\tranges::begin(__t);\n-\tranges::end(__t);\n-      };\n-\n-  /// [range.range] The borrowed_range concept.\n-  template<typename _Tp>\n-    concept borrowed_range\n-      = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;\n-\n-  template<typename _Tp>\n-    using iterator_t = std::__detail::__range_iter_t<_Tp>;\n-\n-  template<range _Range>\n-    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));\n-\n-  template<range _Range>\n-    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n-\n-  template<range _Range>\n-    using range_value_t = iter_value_t<iterator_t<_Range>>;\n-\n-  template<range _Range>\n-    using range_reference_t = iter_reference_t<iterator_t<_Range>>;\n-\n-  template<range _Range>\n-    using range_rvalue_reference_t\n-      = iter_rvalue_reference_t<iterator_t<_Range>>;\n-\n-  /// [range.sized] The sized_range concept.\n-  template<typename _Tp>\n-    concept sized_range = range<_Tp>\n-      && requires(_Tp& __t) { ranges::size(__t); };\n-\n-  template<sized_range _Range>\n-    using range_size_t = decltype(ranges::size(std::declval<_Range&>()));\n-\n-  // [range.refinements]\n-\n-  /// A range for which ranges::begin returns an output iterator.\n-  template<typename _Range, typename _Tp>\n-    concept output_range\n-      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;\n-\n-  /// A range for which ranges::begin returns an input iterator.\n-  template<typename _Tp>\n-    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;\n-\n-  /// A range for which ranges::begin returns a forward iterator.\n-  template<typename _Tp>\n-    concept forward_range\n-      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;\n-\n-  /// A range for which ranges::begin returns a bidirectional iterator.\n-  template<typename _Tp>\n-    concept bidirectional_range\n-      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;\n-\n-  /// A range for which ranges::begin returns a random access iterator.\n-  template<typename _Tp>\n-    concept random_access_range\n-      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;\n-\n-  /// A range for which ranges::begin returns a contiguous iterator.\n-  template<typename _Tp>\n-    concept contiguous_range\n-      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>\n-      && requires(_Tp& __t)\n-      {\n-\t{ ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;\n-      };\n-\n-  /// A range for which ranges::begin and ranges::end return the same type.\n-  template<typename _Tp>\n-    concept common_range\n-      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n-\n-  // [range.iter.ops] range iterator operations\n-\n-  template<input_or_output_iterator _It>\n-    constexpr void\n-    advance(_It& __it, iter_difference_t<_It> __n)\n-    {\n-      if constexpr (random_access_iterator<_It>)\n-\t__it += __n;\n-      else if constexpr (bidirectional_iterator<_It>)\n-\t{\n-\t  if (__n > 0)\n-\t    {\n-\t      do\n-\t\t{\n-\t\t  ++__it;\n-\t\t}\n-\t      while (--__n);\n-\t    }\n-\t  else if (__n < 0)\n-\t    {\n-\t      do\n-\t\t{\n-\t\t  --__it;\n-\t\t}\n-\t      while (++__n);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  // cannot decrement a non-bidirectional iterator\n-\t  __glibcxx_assert(__n >= 0);\n-\t  while (__n-- > 0)\n-\t    ++__it;\n-\t}\n-    }\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n-    constexpr void\n-    advance(_It& __it, _Sent __bound)\n-    {\n-      if constexpr (assignable_from<_It&, _Sent>)\n-\t__it = std::move(__bound);\n-      else if constexpr (sized_sentinel_for<_Sent, _It>)\n-\tranges::advance(__it, __bound - __it);\n-      else\n-\t{\n-\t  while (__it != __bound)\n-\t    ++__it;\n-\t}\n-    }\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n-    constexpr iter_difference_t<_It>\n-    advance(_It& __it, iter_difference_t<_It> __n, _Sent __bound)\n-    {\n-      if constexpr (sized_sentinel_for<_Sent, _It>)\n-\t{\n-\t  const auto __diff = __bound - __it;\n-#ifdef __cpp_lib_is_constant_evaluated\n-\t  if (std::is_constant_evaluated()\n-\t      && !(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0)))\n-\t    throw \"inconsistent directions for distance and bound\";\n-#endif\n-\t  // n and bound must not lead in opposite directions:\n-\t  __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));\n-\t  const auto __absdiff = __diff < 0 ? -__diff : __diff;\n-\t  const auto __absn = __n < 0 ? -__n : __n;;\n-\t  if (__absn >= __absdiff)\n-\t    {\n-\t      ranges::advance(__it, __bound);\n-\t      return __n - __diff;\n-\t    }\n-\t  else\n-\t    {\n-\t      ranges::advance(__it, __n);\n-\t      return 0;\n-\t    }\n-\t}\n-      else if (__it == __bound || __n == 0)\n-\treturn iter_difference_t<_It>(0);\n-      else if (__n > 0)\n-\t{\n-\t  iter_difference_t<_It> __m = 0;\n-\t  do\n-\t    {\n-\t      ++__it;\n-\t      ++__m;\n-\t    }\n-\t  while (__m != __n && __it != __bound);\n-\t  return __n - __m;\n-\t}\n-      else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)\n-\t{\n-\t  iter_difference_t<_It> __m = 0;\n-\t  do\n-\t    {\n-\t      --__it;\n-\t      --__m;\n-\t    }\n-\t  while (__m != __n && __it != __bound);\n-\t  return __n - __m;\n-\t}\n-      else\n-\t{\n-\t  // cannot decrement a non-bidirectional iterator\n-\t  __glibcxx_assert(__n >= 0);\n-\t  return __n;\n-\t}\n-    }\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n-    constexpr iter_difference_t<_It>\n-    distance(_It __first, _Sent __last)\n-    {\n-      if constexpr (sized_sentinel_for<_Sent, _It>)\n-\treturn __last - __first;\n-      else\n-\t{\n-\t  iter_difference_t<_It> __n = 0;\n-\t  while (__first != __last)\n-\t    {\n-\t      ++__first;\n-\t      ++__n;\n-\t    }\n-\t  return __n;\n-\t}\n-    }\n-\n-  template<range _Range>\n-    constexpr range_difference_t<_Range>\n-    distance(_Range&& __r)\n-    {\n-      if constexpr (sized_range<_Range>)\n-\treturn static_cast<range_difference_t<_Range>>(ranges::size(__r));\n-      else\n-\treturn ranges::distance(ranges::begin(__r), ranges::end(__r));\n-    }\n-\n-  template<input_or_output_iterator _It>\n-    constexpr _It\n-    next(_It __x)\n-    {\n-      ++__x;\n-      return __x;\n-    }\n-\n-  template<input_or_output_iterator _It>\n-    constexpr _It\n-    next(_It __x, iter_difference_t<_It> __n)\n-    {\n-      ranges::advance(__x, __n);\n-      return __x;\n-    }\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n-    constexpr _It\n-    next(_It __x, _Sent __bound)\n-    {\n-      ranges::advance(__x, __bound);\n-      return __x;\n-    }\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n-    constexpr _It\n-    next(_It __x, iter_difference_t<_It> __n, _Sent __bound)\n-    {\n-      ranges::advance(__x, __n, __bound);\n-      return __x;\n-    }\n-\n-  template<bidirectional_iterator _It>\n-    constexpr _It\n-    prev(_It __x)\n-    {\n-      --__x;\n-      return __x;\n-    }\n-\n-  template<bidirectional_iterator _It>\n-    constexpr _It\n-    prev(_It __x, iter_difference_t<_It> __n)\n-    {\n-      ranges::advance(__x, -__n);\n-      return __x;\n-    }\n-\n-  template<bidirectional_iterator _It>\n-    constexpr _It\n-    prev(_It __x, iter_difference_t<_It> __n, _It __bound)\n-    {\n-      ranges::advance(__x, -__n, __bound);\n-      return __x;\n-    }\n-\n-} // namespace ranges\n-#endif // library concepts\n #endif // C++20\n+\n+#endif // C++17\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n \n #endif // C++11\n-\n #endif // _GLIBCXX_RANGE_ACCESS_H"}, {"sha": "61673e38fa69153675f386eef14b4dfd550637ab", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -33,6 +33,7 @@\n #if __cplusplus > 201703L\n \n #include <bits/ranges_algobase.h>\n+#include <bits/ranges_util.h>\n #include <bits/uniform_int_dist.h> // concept uniform_random_bit_generator\n \n #if __cpp_lib_concepts"}, {"sha": "eb8573972fa4377598bad9818f9ff79bcbcf3e8a", "filename": "libstdc++-v3/include/bits/ranges_algobase.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -34,9 +34,8 @@\n \n #include <compare>\n #include <iterator>\n-// #include <bits/range_concepts.h>\n-#include <ranges>\n-#include <bits/invoke.h>\n+#include <bits/ranges_base.h> // ranges::begin, ranges::range etc.\n+#include <bits/invoke.h>      // __invoke\n #include <bits/cpp_type_traits.h> // __is_byte\n \n #if __cpp_lib_concepts"}, {"sha": "681b24e5ccef9ae86e98ee29348b8f6610cd05a6", "filename": "libstdc++-v3/include/bits/ranges_base.h", "status": "added", "additions": 887, "deletions": 0, "changes": 887, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_base.h?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -0,0 +1,887 @@\n+// Core concepts and definitions for <ranges> -*- C++ -*-\n+\n+// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/ranges_base.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{ranges}\n+ */\n+\n+#ifndef _GLIBCXX_RANGES_BASE_H\n+#define _GLIBCXX_RANGES_BASE_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L\n+#include <bits/iterator_concepts.h>\n+#include <ext/numeric_traits.h>\n+#include <bits/max_size_type.h>\n+\n+#ifdef __cpp_lib_concepts\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace ranges\n+{\n+  template<typename>\n+    inline constexpr bool disable_sized_range = false;\n+\n+  template<typename _Tp>\n+    inline constexpr bool enable_borrowed_range = false;\n+\n+  namespace __detail\n+  {\n+    constexpr __max_size_type\n+    __to_unsigned_like(__max_size_type __t) noexcept\n+    { return __t; }\n+\n+    constexpr __max_size_type\n+    __to_unsigned_like(__max_diff_type __t) noexcept\n+    { return __max_size_type(__t); }\n+\n+    template<integral _Tp>\n+      constexpr auto\n+      __to_unsigned_like(_Tp __t) noexcept\n+      { return static_cast<make_unsigned_t<_Tp>>(__t); }\n+\n+#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__\n+    constexpr unsigned __int128\n+    __to_unsigned_like(__int128 __t) noexcept\n+    { return __t; }\n+\n+    constexpr unsigned __int128\n+    __to_unsigned_like(unsigned __int128 __t) noexcept\n+    { return __t; }\n+#endif\n+\n+    template<typename _Tp>\n+      using __make_unsigned_like_t\n+\t= decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));\n+\n+    // Part of the constraints of ranges::borrowed_range\n+    template<typename _Tp>\n+      concept __maybe_borrowed_range\n+\t= is_lvalue_reference_v<_Tp>\n+\t  || enable_borrowed_range<remove_cvref_t<_Tp>>;\n+\n+  } // namespace __detail\n+\n+  namespace __cust_access\n+  {\n+    using std::ranges::__detail::__maybe_borrowed_range;\n+    using std::__detail::__class_or_enum;\n+    using std::__detail::__decay_copy;\n+    using std::__detail::__member_begin;\n+    using std::__detail::__adl_begin;\n+\n+    struct _Begin\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n+\t    return true;\n+\t  else if constexpr (__member_begin<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().begin()));\n+\t  else\n+\t    return noexcept(__decay_copy(begin(std::declval<_Tp&>())));\n+\t}\n+\n+    public:\n+      template<__maybe_borrowed_range _Tp>\n+\trequires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>\n+\t  || __adl_begin<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n+\t    {\n+\t      static_assert(is_lvalue_reference_v<_Tp>);\n+\t      using _Up = remove_all_extents_t<remove_reference_t<_Tp>>;\n+\t      static_assert(sizeof(_Up) != 0, \"not array of incomplete type\");\n+\t      return __t + 0;\n+\t    }\n+\t  else if constexpr (__member_begin<_Tp>)\n+\t    return __t.begin();\n+\t  else\n+\t    return begin(__t);\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_end = requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(__t.end()) }\n+\t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n+\t};\n+\n+    void end(auto&) = delete;\n+    void end(const auto&) = delete;\n+\n+    template<typename _Tp>\n+      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(end(__t)) }\n+\t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n+\t};\n+\n+    struct _End\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n+\t    return true;\n+\t  else if constexpr (__member_end<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().end()));\n+\t  else\n+\t    return noexcept(__decay_copy(end(std::declval<_Tp&>())));\n+\t}\n+\n+    public:\n+      template<__maybe_borrowed_range _Tp>\n+\trequires is_bounded_array_v<remove_reference_t<_Tp>> || __member_end<_Tp>\n+\t|| __adl_end<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n+\t    {\n+\t      static_assert(is_lvalue_reference_v<_Tp>);\n+\t      return __t + extent_v<remove_reference_t<_Tp>>;\n+\t    }\n+\t  else if constexpr (__member_end<_Tp>)\n+\t    return __t.end();\n+\t  else\n+\t    return end(__t);\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      constexpr decltype(auto)\n+      __as_const(_Tp&& __t) noexcept\n+      {\n+\tif constexpr (is_lvalue_reference_v<_Tp>)\n+\t  return static_cast<const remove_reference_t<_Tp>&>(__t);\n+\telse\n+\t  return static_cast<const _Tp&&>(__t);\n+      }\n+\n+    struct _CBegin\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_Begin{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _Begin{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _Begin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _CEnd\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_End{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _End{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _End{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_rbegin = requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;\n+\t};\n+\n+    void rbegin(auto&) = delete;\n+    void rbegin(const auto&) = delete;\n+\n+    template<typename _Tp>\n+      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;\n+\t};\n+\n+    template<typename _Tp>\n+      concept __reversable = requires(_Tp& __t)\n+\t{\n+\t  { _Begin{}(__t) } -> bidirectional_iterator;\n+\t  { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;\n+\t};\n+\n+    struct _RBegin\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_rbegin<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));\n+\t  else if constexpr (__adl_rbegin<_Tp>)\n+\t    return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));\n+\t  else\n+\t    {\n+\t      if constexpr (noexcept(_End{}(std::declval<_Tp&>())))\n+\t\t{\n+\t\t  using _It = decltype(_End{}(std::declval<_Tp&>()));\n+\t\t  // std::reverse_iterator copy-initializes its member.\n+\t\t  return is_nothrow_copy_constructible_v<_It>;\n+\t\t}\n+\t      else\n+\t\treturn false;\n+\t    }\n+\t}\n+\n+    public:\n+      template<__maybe_borrowed_range _Tp>\n+\trequires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __t) const\n+\tnoexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_rbegin<_Tp>)\n+\t    return __t.rbegin();\n+\t  else if constexpr (__adl_rbegin<_Tp>)\n+\t    return rbegin(__t);\n+\t  else\n+\t    return std::make_reverse_iterator(_End{}(__t));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_rend = requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(__t.rend()) }\n+\t    -> sentinel_for<decltype(_RBegin{}(__t))>;\n+\t};\n+\n+    void rend(auto&) = delete;\n+    void rend(const auto&) = delete;\n+\n+    template<typename _Tp>\n+      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& requires(_Tp& __t)\n+\t{\n+\t  { __decay_copy(rend(__t)) }\n+\t    -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;\n+\t};\n+\n+    struct _REnd\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_rend<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().rend()));\n+\t  else if constexpr (__adl_rend<_Tp>)\n+\t    return noexcept(__decay_copy(rend(std::declval<_Tp&>())));\n+\t  else\n+\t    {\n+\t      if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))\n+\t\t{\n+\t\t  using _It = decltype(_Begin{}(std::declval<_Tp&>()));\n+\t\t  // std::reverse_iterator copy-initializes its member.\n+\t\t  return is_nothrow_copy_constructible_v<_It>;\n+\t\t}\n+\t      else\n+\t\treturn false;\n+\t    }\n+\t}\n+\n+    public:\n+      template<__maybe_borrowed_range _Tp>\n+\trequires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __t) const\n+\tnoexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_rend<_Tp>)\n+\t    return __t.rend();\n+\t  else if constexpr (__adl_rend<_Tp>)\n+\t    return rend(__t);\n+\t  else\n+\t    return std::make_reverse_iterator(_Begin{}(__t));\n+\t}\n+    };\n+\n+    struct _CRBegin\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_RBegin{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _RBegin{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _RBegin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _CREnd\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_REnd{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _REnd{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _REnd{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>\n+\t&& requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(std::forward<_Tp>(__t).size()) }\n+\t    -> __detail::__is_integer_like;\n+\t};\n+\n+    void size(auto&) = delete;\n+    void size(const auto&) = delete;\n+\n+    template<typename _Tp>\n+      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>\n+\t&& !disable_sized_range<remove_cvref_t<_Tp>>\n+\t&& requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(size(std::forward<_Tp>(__t))) }\n+\t    -> __detail::__is_integer_like;\n+\t};\n+\n+    template<typename _Tp>\n+      concept __sentinel_size = requires(_Tp&& __t)\n+\t{\n+\t  { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;\n+\n+\t  { _End{}(std::forward<_Tp>(__t)) }\n+\t    -> sized_sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n+\t};\n+\n+    struct _Size\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n+\t    return true;\n+\t  else if constexpr (__member_size<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().size()));\n+\t  else if constexpr (__adl_size<_Tp>)\n+\t    return noexcept(__decay_copy(size(std::declval<_Tp>())));\n+\t  else if constexpr (__sentinel_size<_Tp>)\n+\t    return noexcept(_End{}(std::declval<_Tp>())\n+\t\t\t    - _Begin{}(std::declval<_Tp>()));\n+\t}\n+\n+    public:\n+      template<typename _Tp>\n+\trequires is_bounded_array_v<remove_reference_t<_Tp>>\n+\t  || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n+\t    {\n+\t      return extent_v<remove_reference_t<_Tp>>;\n+\t    }\n+\t  else if constexpr (__member_size<_Tp>)\n+\t    return std::forward<_Tp>(__e).size();\n+\t  else if constexpr (__adl_size<_Tp>)\n+\t    return size(std::forward<_Tp>(__e));\n+\t  else if constexpr (__sentinel_size<_Tp>)\n+\t    return __detail::__to_unsigned_like(\n+\t\t_End{}(std::forward<_Tp>(__e))\n+\t\t- _Begin{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _SSize\n+    {\n+      template<typename _Tp>\n+\trequires requires (_Tp&& __e)\n+\t  {\n+\t    _Begin{}(std::forward<_Tp>(__e));\n+\t    _Size{}(std::forward<_Tp>(__e));\n+\t  }\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_Size{}(std::forward<_Tp>(__e))))\n+\t{\n+\t  using __iter_type = decltype(_Begin{}(std::forward<_Tp>(__e)));\n+\t  using __diff_type = iter_difference_t<__iter_type>;\n+\t  using __gnu_cxx::__int_traits;\n+\t  auto __size = _Size{}(std::forward<_Tp>(__e));\n+\t  if constexpr (integral<__diff_type>)\n+\t    {\n+\t      if constexpr (__int_traits<__diff_type>::__digits\n+\t\t\t    < __int_traits<ptrdiff_t>::__digits)\n+\t\treturn static_cast<ptrdiff_t>(__size);\n+\t    }\n+\t  return static_cast<__diff_type>(__size);\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_empty = requires(_Tp&& __t)\n+\t{ bool(std::forward<_Tp>(__t).empty()); };\n+\n+    template<typename _Tp>\n+      concept __size0_empty = requires(_Tp&& __t)\n+\t{ _Size{}(std::forward<_Tp>(__t)) == 0; };\n+\n+    template<typename _Tp>\n+      concept __eq_iter_empty = requires(_Tp&& __t)\n+\t{\n+\t  { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;\n+\t  bool(_Begin{}(std::forward<_Tp>(__t))\n+\t      == _End{}(std::forward<_Tp>(__t)));\n+\t};\n+\n+    struct _Empty\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_empty<_Tp>)\n+\t    return noexcept(std::declval<_Tp>().empty());\n+\t  else if constexpr (__size0_empty<_Tp>)\n+\t    return noexcept(_Size{}(std::declval<_Tp>()) == 0);\n+\t  else\n+\t    return noexcept(bool(_Begin{}(std::declval<_Tp>())\n+\t\t== _End{}(std::declval<_Tp>())));\n+\t}\n+\n+    public:\n+      template<typename _Tp>\n+\trequires __member_empty<_Tp> || __size0_empty<_Tp>\n+\t|| __eq_iter_empty<_Tp>\n+\tconstexpr bool\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_empty<_Tp>)\n+\t    return bool(std::forward<_Tp>(__e).empty());\n+\t  else if constexpr (__size0_empty<_Tp>)\n+\t    return _Size{}(std::forward<_Tp>(__e)) == 0;\n+\t  else\n+\t    return bool(_Begin{}(std::forward<_Tp>(__e))\n+\t\t== _End{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __pointer_to_object = is_pointer_v<_Tp>\n+\t\t\t\t    && is_object_v<remove_pointer_t<_Tp>>;\n+\n+    template<typename _Tp>\n+      concept __member_data = is_lvalue_reference_v<_Tp>\n+\t&& requires(_Tp __t) { { __t.data() } -> __pointer_to_object; };\n+\n+    template<typename _Tp>\n+      concept __begin_data = requires(_Tp&& __t)\n+\t{ { _Begin{}(std::forward<_Tp>(__t)) } -> contiguous_iterator; };\n+\n+    struct _Data\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_data<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().data()));\n+\t  else\n+\t    return noexcept(_Begin{}(std::declval<_Tp>()));\n+\t}\n+\n+    public:\n+      template<__maybe_borrowed_range _Tp>\n+\trequires __member_data<_Tp> || __begin_data<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_data<_Tp>)\n+\t    return __e.data();\n+\t  else\n+\t    return std::to_address(_Begin{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _CData\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_Data{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _Data{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _Data{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+  } // namespace __cust_access\n+\n+  inline namespace __cust\n+  {\n+    inline constexpr __cust_access::_Begin begin{};\n+    inline constexpr __cust_access::_End end{};\n+    inline constexpr __cust_access::_CBegin cbegin{};\n+    inline constexpr __cust_access::_CEnd cend{};\n+    inline constexpr __cust_access::_RBegin rbegin{};\n+    inline constexpr __cust_access::_REnd rend{};\n+    inline constexpr __cust_access::_CRBegin crbegin{};\n+    inline constexpr __cust_access::_CREnd crend{};\n+    inline constexpr __cust_access::_Size size{};\n+    inline constexpr __cust_access::_SSize ssize{};\n+    inline constexpr __cust_access::_Empty empty{};\n+    inline constexpr __cust_access::_Data data{};\n+    inline constexpr __cust_access::_CData cdata{};\n+  }\n+\n+  /// [range.range] The range concept.\n+  template<typename _Tp>\n+    concept range = requires(_Tp& __t)\n+      {\n+\tranges::begin(__t);\n+\tranges::end(__t);\n+      };\n+\n+  /// [range.range] The borrowed_range concept.\n+  template<typename _Tp>\n+    concept borrowed_range\n+      = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;\n+\n+  template<typename _Tp>\n+    using iterator_t = std::__detail::__range_iter_t<_Tp>;\n+\n+  template<range _Range>\n+    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));\n+\n+  template<range _Range>\n+    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n+\n+  template<range _Range>\n+    using range_value_t = iter_value_t<iterator_t<_Range>>;\n+\n+  template<range _Range>\n+    using range_reference_t = iter_reference_t<iterator_t<_Range>>;\n+\n+  template<range _Range>\n+    using range_rvalue_reference_t\n+      = iter_rvalue_reference_t<iterator_t<_Range>>;\n+\n+  /// [range.sized] The sized_range concept.\n+  template<typename _Tp>\n+    concept sized_range = range<_Tp>\n+      && requires(_Tp& __t) { ranges::size(__t); };\n+\n+  template<sized_range _Range>\n+    using range_size_t = decltype(ranges::size(std::declval<_Range&>()));\n+\n+  /// [range.view] The ranges::view_base type.\n+  struct view_base { };\n+\n+  /// [range.view] The ranges::enable_view boolean.\n+  template<typename _Tp>\n+    inline constexpr bool enable_view = derived_from<_Tp, view_base>;\n+\n+  /// [range.view] The ranges::view concept.\n+  template<typename _Tp>\n+    concept view\n+      = range<_Tp> && movable<_Tp> && default_initializable<_Tp>\n+\t&& enable_view<_Tp>;\n+\n+  // [range.refinements]\n+\n+  /// A range for which ranges::begin returns an output iterator.\n+  template<typename _Range, typename _Tp>\n+    concept output_range\n+      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;\n+\n+  /// A range for which ranges::begin returns an input iterator.\n+  template<typename _Tp>\n+    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;\n+\n+  /// A range for which ranges::begin returns a forward iterator.\n+  template<typename _Tp>\n+    concept forward_range\n+      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;\n+\n+  /// A range for which ranges::begin returns a bidirectional iterator.\n+  template<typename _Tp>\n+    concept bidirectional_range\n+      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;\n+\n+  /// A range for which ranges::begin returns a random access iterator.\n+  template<typename _Tp>\n+    concept random_access_range\n+      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;\n+\n+  /// A range for which ranges::begin returns a contiguous iterator.\n+  template<typename _Tp>\n+    concept contiguous_range\n+      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>\n+      && requires(_Tp& __t)\n+      {\n+\t{ ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;\n+      };\n+\n+  /// A range for which ranges::begin and ranges::end return the same type.\n+  template<typename _Tp>\n+    concept common_range\n+      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n+\n+  /// A range which can be safely converted to a view.\n+  template<typename _Tp>\n+    concept viewable_range = range<_Tp>\n+      && (borrowed_range<_Tp> || view<remove_cvref_t<_Tp>>);\n+\n+  // [range.iter.ops] range iterator operations\n+\n+  template<input_or_output_iterator _It>\n+    constexpr void\n+    advance(_It& __it, iter_difference_t<_It> __n)\n+    {\n+      if constexpr (random_access_iterator<_It>)\n+\t__it += __n;\n+      else if constexpr (bidirectional_iterator<_It>)\n+\t{\n+\t  if (__n > 0)\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  ++__it;\n+\t\t}\n+\t      while (--__n);\n+\t    }\n+\t  else if (__n < 0)\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  --__it;\n+\t\t}\n+\t      while (++__n);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  // cannot decrement a non-bidirectional iterator\n+\t  __glibcxx_assert(__n >= 0);\n+\t  while (__n-- > 0)\n+\t    ++__it;\n+\t}\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr void\n+    advance(_It& __it, _Sent __bound)\n+    {\n+      if constexpr (assignable_from<_It&, _Sent>)\n+\t__it = std::move(__bound);\n+      else if constexpr (sized_sentinel_for<_Sent, _It>)\n+\tranges::advance(__it, __bound - __it);\n+      else\n+\t{\n+\t  while (__it != __bound)\n+\t    ++__it;\n+\t}\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr iter_difference_t<_It>\n+    advance(_It& __it, iter_difference_t<_It> __n, _Sent __bound)\n+    {\n+      if constexpr (sized_sentinel_for<_Sent, _It>)\n+\t{\n+\t  const auto __diff = __bound - __it;\n+#ifdef __cpp_lib_is_constant_evaluated\n+\t  if (std::is_constant_evaluated()\n+\t      && !(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0)))\n+\t    throw \"inconsistent directions for distance and bound\";\n+#endif\n+\t  // n and bound must not lead in opposite directions:\n+\t  __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));\n+\t  const auto __absdiff = __diff < 0 ? -__diff : __diff;\n+\t  const auto __absn = __n < 0 ? -__n : __n;;\n+\t  if (__absn >= __absdiff)\n+\t    {\n+\t      ranges::advance(__it, __bound);\n+\t      return __n - __diff;\n+\t    }\n+\t  else\n+\t    {\n+\t      ranges::advance(__it, __n);\n+\t      return 0;\n+\t    }\n+\t}\n+      else if (__it == __bound || __n == 0)\n+\treturn iter_difference_t<_It>(0);\n+      else if (__n > 0)\n+\t{\n+\t  iter_difference_t<_It> __m = 0;\n+\t  do\n+\t    {\n+\t      ++__it;\n+\t      ++__m;\n+\t    }\n+\t  while (__m != __n && __it != __bound);\n+\t  return __n - __m;\n+\t}\n+      else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)\n+\t{\n+\t  iter_difference_t<_It> __m = 0;\n+\t  do\n+\t    {\n+\t      --__it;\n+\t      --__m;\n+\t    }\n+\t  while (__m != __n && __it != __bound);\n+\t  return __n - __m;\n+\t}\n+      else\n+\t{\n+\t  // cannot decrement a non-bidirectional iterator\n+\t  __glibcxx_assert(__n >= 0);\n+\t  return __n;\n+\t}\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr iter_difference_t<_It>\n+    distance(_It __first, _Sent __last)\n+    {\n+      if constexpr (sized_sentinel_for<_Sent, _It>)\n+\treturn __last - __first;\n+      else\n+\t{\n+\t  iter_difference_t<_It> __n = 0;\n+\t  while (__first != __last)\n+\t    {\n+\t      ++__first;\n+\t      ++__n;\n+\t    }\n+\t  return __n;\n+\t}\n+    }\n+\n+  template<range _Range>\n+    constexpr range_difference_t<_Range>\n+    distance(_Range&& __r)\n+    {\n+      if constexpr (sized_range<_Range>)\n+\treturn static_cast<range_difference_t<_Range>>(ranges::size(__r));\n+      else\n+\treturn ranges::distance(ranges::begin(__r), ranges::end(__r));\n+    }\n+\n+  template<input_or_output_iterator _It>\n+    constexpr _It\n+    next(_It __x)\n+    {\n+      ++__x;\n+      return __x;\n+    }\n+\n+  template<input_or_output_iterator _It>\n+    constexpr _It\n+    next(_It __x, iter_difference_t<_It> __n)\n+    {\n+      ranges::advance(__x, __n);\n+      return __x;\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr _It\n+    next(_It __x, _Sent __bound)\n+    {\n+      ranges::advance(__x, __bound);\n+      return __x;\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr _It\n+    next(_It __x, iter_difference_t<_It> __n, _Sent __bound)\n+    {\n+      ranges::advance(__x, __n, __bound);\n+      return __x;\n+    }\n+\n+  template<bidirectional_iterator _It>\n+    constexpr _It\n+    prev(_It __x)\n+    {\n+      --__x;\n+      return __x;\n+    }\n+\n+  template<bidirectional_iterator _It>\n+    constexpr _It\n+    prev(_It __x, iter_difference_t<_It> __n)\n+    {\n+      ranges::advance(__x, -__n);\n+      return __x;\n+    }\n+\n+  template<bidirectional_iterator _It>\n+    constexpr _It\n+    prev(_It __x, iter_difference_t<_It> __n, _It __bound)\n+    {\n+      ranges::advance(__x, -__n, __bound);\n+      return __x;\n+    }\n+\n+  /// Type returned by algorithms instead of a dangling iterator or subrange.\n+  struct dangling\n+  {\n+    constexpr dangling() noexcept = default;\n+    template<typename... _Args>\n+      constexpr dangling(_Args&&...) noexcept { }\n+  };\n+\n+  template<range _Range>\n+    using borrowed_iterator_t = conditional_t<borrowed_range<_Range>,\n+\t\t\t\t\t     iterator_t<_Range>,\n+\t\t\t\t\t     dangling>;\n+\n+} // namespace ranges\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // library concepts\n+#endif // C++20\n+#endif // _GLIBCXX_RANGES_BASE_H"}, {"sha": "a48f950f5abded5c47bf7bea60ea7227fda192dd", "filename": "libstdc++-v3/include/bits/ranges_cmp.h", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_cmp.h?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -22,13 +22,13 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n-/** @file bits/range_cmp.h\n+/** @file bits/ranges_cmp.h\n  *  This is an internal header file, included by other library headers.\n  *  Do not attempt to use it directly. @headername{functional}\n  */\n \n-#ifndef _RANGE_CMP_H\n-#define _RANGE_CMP_H 1\n+#ifndef _RANGES_CMP_H\n+#define _RANGES_CMP_H 1\n \n #if __cplusplus > 201703L\n # include <bits/move.h>\n@@ -192,4 +192,4 @@ namespace ranges\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n #endif // C++20\n-#endif // _RANGE_CMP_H\n+#endif // _RANGES_CMP_H", "previous_filename": "libstdc++-v3/include/bits/range_cmp.h"}, {"sha": "694ae7963995c7b84562bce37fb852801816d5aa", "filename": "libstdc++-v3/include/bits/ranges_util.h", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_util.h?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -0,0 +1,417 @@\n+// Utilities for representing and manipulating ranges -*- C++ -*-\n+\n+// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/ranges_util.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{ranges}\n+ */\n+\n+#ifndef _RANGES_UTIL_H\n+#define _RANGES_UTIL_H 1\n+\n+#if __cplusplus > 201703L\n+# include <bits/ranges_base.h>\n+\n+#ifdef __cpp_lib_ranges\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace ranges\n+{\n+  // C++20 24.5 [range.utility] Range utilities\n+\n+  namespace __detail\n+  {\n+    template<typename _Range>\n+      concept __simple_view = view<_Range> && range<const _Range>\n+\t&& same_as<iterator_t<_Range>, iterator_t<const _Range>>\n+\t&& same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;\n+\n+    template<typename _It>\n+      concept __has_arrow = input_iterator<_It>\n+\t&& (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });\n+\n+    template<typename _Tp, typename _Up>\n+      concept __not_same_as\n+\t= !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;\n+  } // namespace __detail\n+\n+  /// The ranges::view_interface class template\n+  template<typename _Derived>\n+    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>\n+    class view_interface : public view_base\n+    {\n+    private:\n+      constexpr _Derived& _M_derived() noexcept\n+      {\n+\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n+\tstatic_assert(view<_Derived>);\n+\treturn static_cast<_Derived&>(*this);\n+      }\n+\n+      constexpr const _Derived& _M_derived() const noexcept\n+      {\n+\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n+\tstatic_assert(view<_Derived>);\n+\treturn static_cast<const _Derived&>(*this);\n+      }\n+\n+    public:\n+      constexpr bool\n+      empty() requires forward_range<_Derived>\n+      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n+\n+      constexpr bool\n+      empty() const requires forward_range<const _Derived>\n+      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n+\n+      constexpr explicit\n+      operator bool() requires requires { ranges::empty(_M_derived()); }\n+      { return !ranges::empty(_M_derived()); }\n+\n+      constexpr explicit\n+      operator bool() const requires requires { ranges::empty(_M_derived()); }\n+      { return !ranges::empty(_M_derived()); }\n+\n+      constexpr auto\n+      data() requires contiguous_iterator<iterator_t<_Derived>>\n+      { return to_address(ranges::begin(_M_derived())); }\n+\n+      constexpr auto\n+      data() const\n+      requires range<const _Derived>\n+\t&& contiguous_iterator<iterator_t<const _Derived>>\n+      { return to_address(ranges::begin(_M_derived())); }\n+\n+      constexpr auto\n+      size()\n+      requires forward_range<_Derived>\n+\t&& sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>\n+      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n+\n+      constexpr auto\n+      size() const\n+      requires forward_range<const _Derived>\n+\t&& sized_sentinel_for<sentinel_t<const _Derived>,\n+\t\t\t      iterator_t<const _Derived>>\n+      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n+\n+      constexpr decltype(auto)\n+      front() requires forward_range<_Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::begin(_M_derived());\n+      }\n+\n+      constexpr decltype(auto)\n+      front() const requires forward_range<const _Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::begin(_M_derived());\n+      }\n+\n+      constexpr decltype(auto)\n+      back()\n+      requires bidirectional_range<_Derived> && common_range<_Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::prev(ranges::end(_M_derived()));\n+      }\n+\n+      constexpr decltype(auto)\n+      back() const\n+      requires bidirectional_range<const _Derived>\n+\t&& common_range<const _Derived>\n+      {\n+\t__glibcxx_assert(!empty());\n+\treturn *ranges::prev(ranges::end(_M_derived()));\n+      }\n+\n+      template<random_access_range _Range = _Derived>\n+\tconstexpr decltype(auto)\n+\toperator[](range_difference_t<_Range> __n)\n+\t{ return ranges::begin(_M_derived())[__n]; }\n+\n+      template<random_access_range _Range = const _Derived>\n+\tconstexpr decltype(auto)\n+\toperator[](range_difference_t<_Range> __n) const\n+\t{ return ranges::begin(_M_derived())[__n]; }\n+    };\n+\n+  namespace __detail\n+  {\n+    template<class _From, class _To>\n+      concept __convertible_to_non_slicing = convertible_to<_From, _To>\n+\t&& !(is_pointer_v<decay_t<_From>> && is_pointer_v<decay_t<_To>>\n+\t    && __not_same_as<remove_pointer_t<decay_t<_From>>,\n+\t\t\t     remove_pointer_t<decay_t<_To>>>);\n+\n+    template<typename _Tp>\n+      concept __pair_like\n+\t= !is_reference_v<_Tp> && requires(_Tp __t)\n+\t{\n+\t  typename tuple_size<_Tp>::type;\n+\t  requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;\n+\t  typename tuple_element_t<0, remove_const_t<_Tp>>;\n+\t  typename tuple_element_t<1, remove_const_t<_Tp>>;\n+\t  { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;\n+\t  { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;\n+\t};\n+\n+    template<typename _Tp, typename _Up, typename _Vp>\n+      concept __pair_like_convertible_from\n+\t= !range<_Tp> && __pair_like<_Tp>\n+\t&& constructible_from<_Tp, _Up, _Vp>\n+\t&& __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>>\n+\t&& convertible_to<_Vp, tuple_element_t<1, _Tp>>;\n+\n+    template<typename _Tp>\n+      concept __iterator_sentinel_pair\n+\t= !range<_Tp> && __pair_like<_Tp>\n+\t&& sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;\n+\n+  } // namespace __detail\n+\n+  enum class subrange_kind : bool { unsized, sized };\n+\n+  /// The ranges::subrange class template\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,\n+\t   subrange_kind _Kind = sized_sentinel_for<_Sent, _It>\n+\t     ? subrange_kind::sized : subrange_kind::unsized>\n+    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)\n+    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>\n+    {\n+    private:\n+      // XXX: gcc complains when using constexpr here\n+      static const bool _S_store_size\n+\t= _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;\n+\n+      _It _M_begin = _It();\n+      _Sent _M_end = _Sent();\n+\n+      template<typename, bool = _S_store_size>\n+\tstruct _Size\n+\t{ };\n+\n+      template<typename _Tp>\n+\tstruct _Size<_Tp, true>\n+\t{ __detail::__make_unsigned_like_t<_Tp> _M_size; };\n+\n+      [[no_unique_address]] _Size<iter_difference_t<_It>> _M_size = {};\n+\n+    public:\n+      subrange() = default;\n+\n+      constexpr\n+      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s)\n+\trequires (!_S_store_size)\n+      : _M_begin(std::move(__i)), _M_end(__s)\n+      { }\n+\n+      constexpr\n+      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s,\n+\t       __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+      : _M_begin(std::move(__i)), _M_end(__s)\n+      {\n+\tusing __detail::__to_unsigned_like;\n+\t__glibcxx_assert(__n == __to_unsigned_like(ranges::distance(__i, __s)));\n+\tif constexpr (_S_store_size)\n+\t  _M_size._M_size = __n;\n+      }\n+\n+      template<__detail::__not_same_as<subrange> _Rng>\n+\trequires borrowed_range<_Rng>\n+\t  && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>\n+\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n+\tconstexpr\n+\tsubrange(_Rng&& __r) requires _S_store_size && sized_range<_Rng>\n+\t: subrange{__r, ranges::size(__r)}\n+\t{ }\n+\n+      template<__detail::__not_same_as<subrange> _Rng>\n+\trequires borrowed_range<_Rng>\n+\t  && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>\n+\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n+\tconstexpr\n+\tsubrange(_Rng&& __r) requires (!_S_store_size)\n+\t: subrange{ranges::begin(__r), ranges::end(__r)}\n+\t{ }\n+\n+      template<borrowed_range _Rng>\n+\trequires __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>\n+\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n+\tconstexpr\n+\tsubrange(_Rng&& __r,\n+\t\t __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n+\trequires (_Kind == subrange_kind::sized)\n+\t: subrange{ranges::begin(__r), ranges::end(__r), __n}\n+\t{ }\n+\n+      template<__detail::__not_same_as<subrange> _PairLike>\n+\trequires __detail::__pair_like_convertible_from<_PairLike, const _It&,\n+\t\t\t\t\t\t\tconst _Sent&>\n+      constexpr\n+      operator _PairLike() const\n+      { return _PairLike(_M_begin, _M_end); }\n+\n+      constexpr _It\n+      begin() const requires copyable<_It>\n+      { return _M_begin; }\n+\n+      [[nodiscard]] constexpr _It\n+      begin() requires (!copyable<_It>)\n+      { return std::move(_M_begin); }\n+\n+      constexpr _Sent end() const { return _M_end; }\n+\n+      constexpr bool empty() const { return _M_begin == _M_end; }\n+\n+      constexpr __detail::__make_unsigned_like_t<iter_difference_t<_It>>\n+      size() const requires (_Kind == subrange_kind::sized)\n+      {\n+\tif constexpr (_S_store_size)\n+\t  return _M_size._M_size;\n+\telse\n+\t  return __detail::__to_unsigned_like(_M_end - _M_begin);\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      next(iter_difference_t<_It> __n = 1) const &\n+\trequires forward_iterator<_It>\n+      {\n+\tauto __tmp = *this;\n+\t__tmp.advance(__n);\n+\treturn __tmp;\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      next(iter_difference_t<_It> __n = 1) &&\n+      {\n+\tadvance(__n);\n+\treturn std::move(*this);\n+      }\n+\n+      [[nodiscard]] constexpr subrange\n+      prev(iter_difference_t<_It> __n = 1) const\n+\trequires bidirectional_iterator<_It>\n+      {\n+\tauto __tmp = *this;\n+\t__tmp.advance(-__n);\n+\treturn __tmp;\n+      }\n+\n+      constexpr subrange&\n+      advance(iter_difference_t<_It> __n)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 3433. subrange::advance(n) has UB when n < 0\n+\tif constexpr (bidirectional_iterator<_It>)\n+\t  if (__n < 0)\n+\t    {\n+\t      ranges::advance(_M_begin, __n);\n+\t      if constexpr (_S_store_size)\n+\t\t_M_size._M_size += __detail::__to_unsigned_like(-__n);\n+\t      return *this;\n+\t    }\n+\n+\t__glibcxx_assert(__n >= 0);\n+\tauto __d = __n - ranges::advance(_M_begin, __n, _M_end);\n+\tif constexpr (_S_store_size)\n+\t  _M_size._M_size -= __detail::__to_unsigned_like(__d);\n+\treturn *this;\n+      }\n+    };\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    subrange(_It, _Sent) -> subrange<_It, _Sent>;\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    subrange(_It, _Sent,\n+\t     __detail::__make_unsigned_like_t<iter_difference_t<_It>>)\n+      -> subrange<_It, _Sent, subrange_kind::sized>;\n+\n+  template<__detail::__iterator_sentinel_pair _Pr>\n+    subrange(_Pr)\n+      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;\n+\n+  template<__detail::__iterator_sentinel_pair _Pr>\n+    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<\n+\t\t\t\t\t\t     tuple_element_t<0, _Pr>>>)\n+      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,\n+\t\t  subrange_kind::sized>;\n+\n+  template<borrowed_range _Rng>\n+    subrange(_Rng&&)\n+      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,\n+\t\t (sized_range<_Rng>\n+\t\t  || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)\n+\t\t ? subrange_kind::sized : subrange_kind::unsized>;\n+\n+  template<borrowed_range _Rng>\n+    subrange(_Rng&&,\n+\t     __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)\n+      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;\n+\n+  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>\n+    requires (_Num < 2)\n+    constexpr auto\n+    get(const subrange<_It, _Sent, _Kind>& __r)\n+    {\n+      if constexpr (_Num == 0)\n+\treturn __r.begin();\n+      else\n+\treturn __r.end();\n+    }\n+\n+  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>\n+    requires (_Num < 2)\n+    constexpr auto\n+    get(subrange<_It, _Sent, _Kind>&& __r)\n+    {\n+      if constexpr (_Num == 0)\n+\treturn __r.begin();\n+      else\n+\treturn __r.end();\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent,\n+\t   subrange_kind _Kind>\n+    inline constexpr bool\n+      enable_borrowed_range<subrange<_It, _Sent, _Kind>> = true;\n+\n+  template<range _Range>\n+    using borrowed_subrange_t = conditional_t<borrowed_range<_Range>,\n+\t\t\t\t\t      subrange<iterator_t<_Range>>,\n+\t\t\t\t\t      dangling>;\n+\n+} // namespace ranges\n+\n+  using ranges::get;\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // library concepts\n+#endif // C++20\n+#endif // _RANGES_UTIL_H"}, {"sha": "1d6399acbed70e333929b034283ffbdc714a8ad0", "filename": "libstdc++-v3/include/experimental/string_view", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fstring_view", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fstring_view", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fstring_view?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -40,6 +40,7 @@\n \n #include <string>\n #include <limits>\n+#include <bits/ranges_base.h> // enable_borrowed_range, enable_view\n #include <experimental/bits/lfts_config.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "9bad692f2ad477a9af339aa448695523efd2a1f1", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -65,7 +65,7 @@\n # include <bits/stl_algo.h>\n #endif\n #if __cplusplus > 201703L\n-# include <bits/range_cmp.h>\n+# include <bits/ranges_cmp.h>\n # include <compare>\n #endif\n "}, {"sha": "e7fa44936120c863c50709e1103494908d5912b1", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 13, "deletions": 402, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -38,12 +38,13 @@\n \n #if __cpp_lib_concepts\n \n-#include <bits/refwrap.h>\n #include <compare>\n #include <initializer_list>\n #include <iterator>\n #include <optional>\n #include <tuple>\n+#include <bits/ranges_util.h>\n+#include <bits/refwrap.h>\n \n /**\n  * @defgroup ranges Ranges\n@@ -56,410 +57,18 @@ namespace std _GLIBCXX_VISIBILITY(default)\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n namespace ranges\n {\n-  // [range.range] The range concept.\n-  // [range.sized] The sized_range concept.\n-  // Defined in <bits/range_access.h>\n-\n-  // [range.refinements]\n-  // Defined in <bits/range_access.h>\n-\n-  struct view_base { };\n-\n-  template<typename _Tp>\n-    inline constexpr bool enable_view = derived_from<_Tp, view_base>;\n-\n-  template<typename _Tp>\n-    concept view\n-      = range<_Tp> && movable<_Tp> && default_initializable<_Tp>\n-\t&& enable_view<_Tp>;\n-\n-  /// A range which can be safely converted to a view.\n-  template<typename _Tp>\n-    concept viewable_range = range<_Tp>\n-      && (borrowed_range<_Tp> || view<remove_cvref_t<_Tp>>);\n-\n-  namespace __detail\n-  {\n-    template<typename _Range>\n-      concept __simple_view = view<_Range> && range<const _Range>\n-\t&& same_as<iterator_t<_Range>, iterator_t<const _Range>>\n-\t&& same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;\n-\n-    template<typename _It>\n-      concept __has_arrow = input_iterator<_It>\n-\t&& (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });\n-\n-    template<typename _Tp, typename _Up>\n-      concept __not_same_as\n-\t= !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;\n-  } // namespace __detail\n-\n-  template<typename _Derived>\n-    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>\n-    class view_interface : public view_base\n-    {\n-    private:\n-      constexpr _Derived& _M_derived() noexcept\n-      {\n-\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n-\tstatic_assert(view<_Derived>);\n-\treturn static_cast<_Derived&>(*this);\n-      }\n-\n-      constexpr const _Derived& _M_derived() const noexcept\n-      {\n-\tstatic_assert(derived_from<_Derived, view_interface<_Derived>>);\n-\tstatic_assert(view<_Derived>);\n-\treturn static_cast<const _Derived&>(*this);\n-      }\n-\n-    public:\n-      constexpr bool\n-      empty() requires forward_range<_Derived>\n-      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n-\n-      constexpr bool\n-      empty() const requires forward_range<const _Derived>\n-      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }\n-\n-      constexpr explicit\n-      operator bool() requires requires { ranges::empty(_M_derived()); }\n-      { return !ranges::empty(_M_derived()); }\n-\n-      constexpr explicit\n-      operator bool() const requires requires { ranges::empty(_M_derived()); }\n-      { return !ranges::empty(_M_derived()); }\n-\n-      constexpr auto\n-      data() requires contiguous_iterator<iterator_t<_Derived>>\n-      { return to_address(ranges::begin(_M_derived())); }\n-\n-      constexpr auto\n-      data() const\n-      requires range<const _Derived>\n-\t&& contiguous_iterator<iterator_t<const _Derived>>\n-      { return to_address(ranges::begin(_M_derived())); }\n-\n-      constexpr auto\n-      size()\n-      requires forward_range<_Derived>\n-\t&& sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>\n-      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n-\n-      constexpr auto\n-      size() const\n-      requires forward_range<const _Derived>\n-\t&& sized_sentinel_for<sentinel_t<const _Derived>,\n-\t\t\t      iterator_t<const _Derived>>\n-      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }\n-\n-      constexpr decltype(auto)\n-      front() requires forward_range<_Derived>\n-      {\n-\t__glibcxx_assert(!empty());\n-\treturn *ranges::begin(_M_derived());\n-      }\n-\n-      constexpr decltype(auto)\n-      front() const requires forward_range<const _Derived>\n-      {\n-\t__glibcxx_assert(!empty());\n-\treturn *ranges::begin(_M_derived());\n-      }\n-\n-      constexpr decltype(auto)\n-      back()\n-      requires bidirectional_range<_Derived> && common_range<_Derived>\n-      {\n-\t__glibcxx_assert(!empty());\n-\treturn *ranges::prev(ranges::end(_M_derived()));\n-      }\n-\n-      constexpr decltype(auto)\n-      back() const\n-      requires bidirectional_range<const _Derived>\n-\t&& common_range<const _Derived>\n-      {\n-\t__glibcxx_assert(!empty());\n-\treturn *ranges::prev(ranges::end(_M_derived()));\n-      }\n-\n-      template<random_access_range _Range = _Derived>\n-\tconstexpr decltype(auto)\n-\toperator[](range_difference_t<_Range> __n)\n-\t{ return ranges::begin(_M_derived())[__n]; }\n-\n-      template<random_access_range _Range = const _Derived>\n-\tconstexpr decltype(auto)\n-\toperator[](range_difference_t<_Range> __n) const\n-\t{ return ranges::begin(_M_derived())[__n]; }\n-    };\n-\n-  namespace __detail\n-  {\n-    template<class _From, class _To>\n-      concept __convertible_to_non_slicing = convertible_to<_From, _To>\n-\t&& !(is_pointer_v<decay_t<_From>> && is_pointer_v<decay_t<_To>>\n-\t    && __not_same_as<remove_pointer_t<decay_t<_From>>,\n-\t\t\t     remove_pointer_t<decay_t<_To>>>);\n-\n-    template<typename _Tp>\n-      concept __pair_like\n-\t= !is_reference_v<_Tp> && requires(_Tp __t)\n-\t{\n-\t  typename tuple_size<_Tp>::type;\n-\t  requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;\n-\t  typename tuple_element_t<0, remove_const_t<_Tp>>;\n-\t  typename tuple_element_t<1, remove_const_t<_Tp>>;\n-\t  { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;\n-\t  { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;\n-\t};\n-\n-    template<typename _Tp, typename _Up, typename _Vp>\n-      concept __pair_like_convertible_from\n-\t= !range<_Tp> && __pair_like<_Tp>\n-\t&& constructible_from<_Tp, _Up, _Vp>\n-\t&& __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>>\n-\t&& convertible_to<_Vp, tuple_element_t<1, _Tp>>;\n-\n-    template<typename _Tp>\n-      concept __iterator_sentinel_pair\n-\t= !range<_Tp> && __pair_like<_Tp>\n-\t&& sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;\n-\n-  } // namespace __detail\n-\n-  enum class subrange_kind : bool { unsized, sized };\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,\n-\t   subrange_kind _Kind = sized_sentinel_for<_Sent, _It>\n-\t     ? subrange_kind::sized : subrange_kind::unsized>\n-    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)\n-    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>\n-    {\n-    private:\n-      // XXX: gcc complains when using constexpr here\n-      static const bool _S_store_size\n-\t= _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;\n-\n-      _It _M_begin = _It();\n-      _Sent _M_end = _Sent();\n-\n-      template<typename, bool = _S_store_size>\n-\tstruct _Size\n-\t{ };\n-\n-      template<typename _Tp>\n-\tstruct _Size<_Tp, true>\n-\t{ __detail::__make_unsigned_like_t<_Tp> _M_size; };\n-\n-      [[no_unique_address]] _Size<iter_difference_t<_It>> _M_size = {};\n-\n-    public:\n-      subrange() = default;\n-\n-      constexpr\n-      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s)\n-\trequires (!_S_store_size)\n-      : _M_begin(std::move(__i)), _M_end(__s)\n-      { }\n-\n-      constexpr\n-      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s,\n-\t       __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n-\trequires (_Kind == subrange_kind::sized)\n-      : _M_begin(std::move(__i)), _M_end(__s)\n-      {\n-\tusing __detail::__to_unsigned_like;\n-\t__glibcxx_assert(__n == __to_unsigned_like(ranges::distance(__i, __s)));\n-\tif constexpr (_S_store_size)\n-\t  _M_size._M_size = __n;\n-      }\n-\n-      template<__detail::__not_same_as<subrange> _Rng>\n-\trequires borrowed_range<_Rng>\n-\t  && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>\n-\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n-\tconstexpr\n-\tsubrange(_Rng&& __r) requires _S_store_size && sized_range<_Rng>\n-\t: subrange{__r, ranges::size(__r)}\n-\t{ }\n-\n-      template<__detail::__not_same_as<subrange> _Rng>\n-\trequires borrowed_range<_Rng>\n-\t  && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>\n-\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n-\tconstexpr\n-\tsubrange(_Rng&& __r) requires (!_S_store_size)\n-\t: subrange{ranges::begin(__r), ranges::end(__r)}\n-\t{ }\n-\n-      template<borrowed_range _Rng>\n-\trequires __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>\n-\t  && convertible_to<sentinel_t<_Rng>, _Sent>\n-\tconstexpr\n-\tsubrange(_Rng&& __r,\n-\t\t __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)\n-\trequires (_Kind == subrange_kind::sized)\n-\t: subrange{ranges::begin(__r), ranges::end(__r), __n}\n-\t{ }\n-\n-      template<__detail::__not_same_as<subrange> _PairLike>\n-\trequires __detail::__pair_like_convertible_from<_PairLike, const _It&,\n-\t\t\t\t\t\t\tconst _Sent&>\n-      constexpr\n-      operator _PairLike() const\n-      { return _PairLike(_M_begin, _M_end); }\n-\n-      constexpr _It\n-      begin() const requires copyable<_It>\n-      { return _M_begin; }\n-\n-      [[nodiscard]] constexpr _It\n-      begin() requires (!copyable<_It>)\n-      { return std::move(_M_begin); }\n-\n-      constexpr _Sent end() const { return _M_end; }\n-\n-      constexpr bool empty() const { return _M_begin == _M_end; }\n-\n-      constexpr __detail::__make_unsigned_like_t<iter_difference_t<_It>>\n-      size() const requires (_Kind == subrange_kind::sized)\n-      {\n-\tif constexpr (_S_store_size)\n-\t  return _M_size._M_size;\n-\telse\n-\t  return __detail::__to_unsigned_like(_M_end - _M_begin);\n-      }\n-\n-      [[nodiscard]] constexpr subrange\n-      next(iter_difference_t<_It> __n = 1) const &\n-\trequires forward_iterator<_It>\n-      {\n-\tauto __tmp = *this;\n-\t__tmp.advance(__n);\n-\treturn __tmp;\n-      }\n-\n-      [[nodiscard]] constexpr subrange\n-      next(iter_difference_t<_It> __n = 1) &&\n-      {\n-\tadvance(__n);\n-\treturn std::move(*this);\n-      }\n-\n-      [[nodiscard]] constexpr subrange\n-      prev(iter_difference_t<_It> __n = 1) const\n-\trequires bidirectional_iterator<_It>\n-      {\n-\tauto __tmp = *this;\n-\t__tmp.advance(-__n);\n-\treturn __tmp;\n-      }\n-\n-      constexpr subrange&\n-      advance(iter_difference_t<_It> __n)\n-      {\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 3433. subrange::advance(n) has UB when n < 0\n-\tif constexpr (bidirectional_iterator<_It>)\n-\t  if (__n < 0)\n-\t    {\n-\t      ranges::advance(_M_begin, __n);\n-\t      if constexpr (_S_store_size)\n-\t\t_M_size._M_size += __detail::__to_unsigned_like(-__n);\n-\t      return *this;\n-\t    }\n-\n-\t__glibcxx_assert(__n >= 0);\n-\tauto __d = __n - ranges::advance(_M_begin, __n, _M_end);\n-\tif constexpr (_S_store_size)\n-\t  _M_size._M_size -= __detail::__to_unsigned_like(__d);\n-\treturn *this;\n-      }\n-    };\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n-    subrange(_It, _Sent) -> subrange<_It, _Sent>;\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n-    subrange(_It, _Sent,\n-\t     __detail::__make_unsigned_like_t<iter_difference_t<_It>>)\n-      -> subrange<_It, _Sent, subrange_kind::sized>;\n-\n-  template<__detail::__iterator_sentinel_pair _Pr>\n-    subrange(_Pr)\n-      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;\n-\n-  template<__detail::__iterator_sentinel_pair _Pr>\n-    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<\n-\t\t\t\t\t\t     tuple_element_t<0, _Pr>>>)\n-      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,\n-\t\t  subrange_kind::sized>;\n-\n-  template<borrowed_range _Rng>\n-    subrange(_Rng&&)\n-      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,\n-\t\t (sized_range<_Rng>\n-\t\t  || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)\n-\t\t ? subrange_kind::sized : subrange_kind::unsized>;\n-\n-  template<borrowed_range _Rng>\n-    subrange(_Rng&&,\n-\t     __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)\n-      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;\n-\n-  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>\n-    requires (_Num < 2)\n-    constexpr auto\n-    get(const subrange<_It, _Sent, _Kind>& __r)\n-    {\n-      if constexpr (_Num == 0)\n-\treturn __r.begin();\n-      else\n-\treturn __r.end();\n-    }\n-\n-  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>\n-    requires (_Num < 2)\n-    constexpr auto\n-    get(subrange<_It, _Sent, _Kind>&& __r)\n-    {\n-      if constexpr (_Num == 0)\n-\treturn __r.begin();\n-      else\n-\treturn __r.end();\n-    }\n-\n-  template<input_or_output_iterator _It, sentinel_for<_It> _Sent,\n-\t   subrange_kind _Kind>\n-    inline constexpr bool\n-      enable_borrowed_range<subrange<_It, _Sent, _Kind>> = true;\n-\n-} // namespace ranges\n-\n-  using ranges::get;\n-\n-namespace ranges\n-{\n-  /// Type returned by algorithms instead of a dangling iterator or subrange.\n-  struct dangling\n-  {\n-    constexpr dangling() noexcept = default;\n-    template<typename... _Args>\n-      constexpr dangling(_Args&&...) noexcept { }\n-  };\n+  // [range.access] customization point objects\n+  // [range.req] range and view concepts\n+  // [range.dangling] dangling iterator handling\n+  // Defined in <bits/ranges_base.h>\n \n-  template<range _Range>\n-    using borrowed_iterator_t = conditional_t<borrowed_range<_Range>,\n-\t\t\t\t\t      iterator_t<_Range>,\n-\t\t\t\t\t      dangling>;\n+  // [view.interface] View interface\n+  // [range.subrange] Sub-ranges\n+  // Defined in <bits/ranges_util.h>\n \n-  template<range _Range>\n-    using borrowed_subrange_t = conditional_t<borrowed_range<_Range>,\n-\t\t\t\t\t      subrange<iterator_t<_Range>>,\n-\t\t\t\t\t      dangling>;\n+  // C++20 24.6 [range.factories] Range factories\n \n+  /// A view that contains no elements.\n   template<typename _Tp> requires is_object_v<_Tp>\n     class empty_view\n     : public view_interface<empty_view<_Tp>>\n@@ -1038,6 +647,8 @@ namespace views\n     istream_view(basic_istream<_CharT, _Traits>& __s)\n     { return basic_istream_view<_Val, _CharT, _Traits>{__s}; }\n \n+  // C++20 24.7 [range.adaptors] Range adaptors\n+\n namespace __detail\n {\n   struct _Empty { };"}, {"sha": "fb349403c9ee0297afd1e35a6d0eefc340c3c1c8", "filename": "libstdc++-v3/include/std/span", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -41,7 +41,7 @@\n #include <type_traits>\n #include <array>\n #include <bits/stl_iterator.h>\n-#include <bits/range_access.h>\n+#include <bits/ranges_base.h>\n \n #if __cpp_lib_concepts\n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "32c51b2bbd4c4438d0f10fa21ac1af732815364e", "filename": "libstdc++-v3/include/std/string_view", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring_view?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -41,6 +41,7 @@\n #include <bits/char_traits.h>\n #include <bits/functional_hash.h>\n #include <bits/range_access.h>\n+#include <bits/ranges_base.h>\n #include <bits/ostream_insert.h>\n #include <ext/numeric_traits.h>\n "}, {"sha": "b620be8cb982cda4598faa5e2eee39b87dd39211", "filename": "libstdc++-v3/testsuite/24_iterators/back_insert_iterator/pr93884.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fback_insert_iterator%2Fpr93884.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fback_insert_iterator%2Fpr93884.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fback_insert_iterator%2Fpr93884.cc?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -21,6 +21,7 @@\n #include <iterator>\n #include <algorithm>\n #include <vector>\n+#include <ranges>\n #include <testsuite_hooks.h>\n \n namespace ranges = std::ranges;"}, {"sha": "0f6e9f57ebfca7781ca0d1ab3238a397c9066e13", "filename": "libstdc++-v3/testsuite/24_iterators/front_insert_iterator/pr93884.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Ffront_insert_iterator%2Fpr93884.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160061ac10f9143d9698daac5f7e46b5a615825c/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Ffront_insert_iterator%2Fpr93884.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Ffront_insert_iterator%2Fpr93884.cc?ref=160061ac10f9143d9698daac5f7e46b5a615825c", "patch": "@@ -21,6 +21,7 @@\n #include <iterator>\n #include <algorithm>\n #include <deque>\n+#include <ranges>\n #include <testsuite_hooks.h>\n \n namespace ranges = std::ranges;"}]}