{"sha": "c0f136cd17132ceeb25dadb4c97f474d37924cbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBmMTM2Y2QxNzEzMmNlZWIyNWRhZGI0Yzk3ZjQ3NGQzNzkyNGNiZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T10:02:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T10:02:10Z"}, "message": "[multiple changes]\n\n2010-10-22  Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-locale.adb: Minor code clean up.\n\n2010-10-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb: Minor code reorganization and factoring.\n\nFrom-SVN: r165813", "tree": {"sha": "cb33e8d504c2e2ff8124c3a56f4d2156460a7ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb33e8d504c2e2ff8124c3a56f4d2156460a7ca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0f136cd17132ceeb25dadb4c97f474d37924cbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0f136cd17132ceeb25dadb4c97f474d37924cbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0f136cd17132ceeb25dadb4c97f474d37924cbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0f136cd17132ceeb25dadb4c97f474d37924cbd/comments", "author": null, "committer": null, "parents": [{"sha": "c56a9ba447f72fccf12291589aec165cb99a65d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56a9ba447f72fccf12291589aec165cb99a65d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56a9ba447f72fccf12291589aec165cb99a65d2"}], "stats": {"total": 152, "additions": 81, "deletions": 71}, "files": [{"sha": "5e656f9f3f0af3666d1e7c2768a66d1614ce47d2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0f136cd17132ceeb25dadb4c97f474d37924cbd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0f136cd17132ceeb25dadb4c97f474d37924cbd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c0f136cd17132ceeb25dadb4c97f474d37924cbd", "patch": "@@ -1,3 +1,11 @@\n+2010-10-22  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-locale.adb: Minor code clean up.\n+\n+2010-10-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb: Minor code reorganization and factoring.\n+\n 2010-10-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_ch5.adb, sem_ch5.adb, sinfo.ads, snames.ads-tmpl, par-ch5.adb:"}, {"sha": "d56970c86e95b734f7a05ffeda270c58bbf7eb90", "filename": "gcc/ada/a-locale.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0f136cd17132ceeb25dadb4c97f474d37924cbd/gcc%2Fada%2Fa-locale.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0f136cd17132ceeb25dadb4c97f474d37924cbd/gcc%2Fada%2Fa-locale.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-locale.adb?ref=c0f136cd17132ceeb25dadb4c97f474d37924cbd", "patch": "@@ -45,7 +45,7 @@ package body Ada.Locales is\n       pragma Import (C, C_Get_Language_Code);\n       F : Lower_4;\n    begin\n-      C_Get_Language_Code (F (1)'Address);\n+      C_Get_Language_Code (F'Address);\n       return Language_Code (F (1 .. 3));\n    end Language;\n \n@@ -58,7 +58,7 @@ package body Ada.Locales is\n       pragma Import (C, C_Get_Country_Code);\n       F : Upper_4;\n    begin\n-      C_Get_Country_Code (F (1)'Address);\n+      C_Get_Country_Code (F'Address);\n       return Country_Code (F (1 .. 2));\n    end Country;\n "}, {"sha": "4450a1efc05b8dc341b498c40f7643a444b183e5", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 71, "deletions": 69, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0f136cd17132ceeb25dadb4c97f474d37924cbd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0f136cd17132ceeb25dadb4c97f474d37924cbd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c0f136cd17132ceeb25dadb4c97f474d37924cbd", "patch": "@@ -4398,17 +4398,23 @@ package body Exp_Ch4 is\n \n       procedure Substitute_Valid_Check is\n       begin\n-         Rewrite (N,\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => Relocate_Node (Lop),\n-             Attribute_Name => Name_Valid));\n+         --  Don't do this for type with predicates, since we don't care in\n+         --  this case if it gets optimized away, the critical test is the\n+         --  call to the predicate function\n \n-         Analyze_And_Resolve (N, Restyp);\n+         if not Has_Predicates (Ltyp) then\n+            Rewrite (N,\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => Relocate_Node (Lop),\n+                Attribute_Name => Name_Valid));\n \n-         Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n-         Error_Msg_N -- CODEFIX\n-           (\"\\?use ''Valid attribute instead\", N);\n-         return;\n+            Analyze_And_Resolve (N, Restyp);\n+\n+            Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n+            Error_Msg_N -- CODEFIX\n+              (\"\\?use ''Valid attribute instead\", N);\n+            return;\n+         end if;\n       end Substitute_Valid_Check;\n \n    --  Start of processing for Expand_N_In\n@@ -4682,7 +4688,10 @@ package body Exp_Ch4 is\n             --  type if they come from the original type definition. Also this\n             --  way we get all the processing above for an explicit range.\n \n-            elsif Is_Scalar_Type (Typ) then\n+            --  Don't do this for a type with predicates, since we would lose\n+            --  the predicate from this rewriting (test goes to base type).\n+\n+            elsif Is_Scalar_Type (Typ) and then not Has_Predicates (Typ) then\n                Rewrite (Rop,\n                  Make_Range (Loc,\n                    Low_Bound =>\n@@ -7426,79 +7435,72 @@ package body Exp_Ch4 is\n    -- Expand_N_Quantified_Expression --\n    ------------------------------------\n \n-   procedure Expand_N_Quantified_Expression (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      Cond     : constant Node_Id    := Condition (N);\n+   --  We expand:\n \n-      Actions  : List_Id;\n-      Decl     : Node_Id;\n-      I_Scheme : Node_Id;\n-      Test     : Node_Id;\n-      Tnn      : Entity_Id;\n+   --    for all X in range => Cond\n \n-      --  We expand:\n+   --  into:\n \n-      --      for all X in range => Cond\n+   --        T := True;\n+   --        for X in range loop\n+   --           if not Cond then\n+   --              T := False;\n+   --              exit;\n+   --           end if;\n+   --        end loop;\n \n-      --  into:\n+   --  Conversely, an existentially quantified expression:\n \n-      --        R := True;\n-      --        for all X in range loop\n-      --           if not Cond then\n-      --              R := False;\n-      --              exit;\n-      --           end if;\n-      --        end loop;\n+   --    for some X in range => Cond\n \n-      --  Conversely, an existentially quantified expression becomes:\n+   --  becomes:\n \n-      --        R := False;\n-      --        for all X in range loop\n-      --           if Cond then\n-      --              R := True;\n-      --              exit;\n-      --           end if;\n-      --        end loop;\n+   --        T := False;\n+   --        for X in range loop\n+   --           if Cond then\n+   --              T := True;\n+   --              exit;\n+   --           end if;\n+   --        end loop;\n \n-      --  In both cases, the iteration may be over a container, in which\n-      --  case it is given by an iterator specification, not a loop.\n+   --  In both cases, the iteration may be over a container in which case it is\n+   --  given by an iterator specification, not a loop parameter specification.\n+\n+   procedure Expand_N_Quantified_Expression (N : Node_Id) is\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Is_Universal : constant Boolean := All_Present (N);\n+      Actions      : constant List_Id := New_List;\n+      Tnn          : constant Entity_Id := Make_Temporary (Loc, 'T', N);\n+      Cond         : Node_Id;\n+      Decl         : Node_Id;\n+      I_Scheme     : Node_Id;\n+      Test         : Node_Id;\n \n    begin\n-      Actions := New_List;\n-      Tnn := Make_Temporary (Loc, 'T');\n       Decl :=\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Tnn,\n-          Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc));\n-\n+          Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n+          Expression          =>\n+            New_Occurrence_Of (Boolean_Literals (Is_Universal), Loc));\n       Append_To (Actions, Decl);\n \n-      if All_Present (N) then\n-         Set_Expression (Decl, New_Occurrence_Of (Standard_True, Loc));\n+      Cond := Relocate_Node (Condition (N));\n \n-         Test :=\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-                Make_Op_Not (Loc, Relocate_Node (Cond)),\n-             Then_Statements => New_List (\n-               Make_Assignment_Statement (Loc,\n-                 Name       => New_Occurrence_Of (Tnn, Loc),\n-                 Expression => New_Occurrence_Of (Standard_False, Loc)),\n-               Make_Exit_Statement (Loc)));\n-\n-      else\n-         Set_Expression (Decl, New_Occurrence_Of (Standard_False, Loc));\n-\n-         Test :=\n-           Make_If_Statement (Loc,\n-             Condition       => Relocate_Node (Cond),\n-             Then_Statements => New_List (\n-               Make_Assignment_Statement (Loc,\n-                 Name       => New_Occurrence_Of (Tnn, Loc),\n-                 Expression => New_Occurrence_Of (Standard_True, Loc)),\n-               Make_Exit_Statement (Loc)));\n+      if Is_Universal then\n+         Cond := Make_Op_Not (Loc, Cond);\n       end if;\n \n+      Test :=\n+        Make_Implicit_If_Statement (N,\n+          Condition       => Cond,\n+          Then_Statements => New_List (\n+            Make_Assignment_Statement (Loc,\n+              Name       => New_Occurrence_Of (Tnn, Loc),\n+              Expression =>\n+                New_Occurrence_Of (Boolean_Literals (not Is_Universal), Loc)),\n+            Make_Exit_Statement (Loc)));\n+\n       if Present (Loop_Parameter_Specification (N)) then\n          I_Scheme :=\n            Make_Iteration_Scheme (Loc,\n@@ -7513,11 +7515,11 @@ package body Exp_Ch4 is\n       Append_To (Actions,\n         Make_Loop_Statement (Loc,\n           Iteration_Scheme => I_Scheme,\n-              Statements                   => New_List (Test),\n-              End_Label                    => Empty));\n+          Statements       => New_List (Test),\n+          End_Label        => Empty));\n \n-      --  The components of the scheme have already been analyzed, and the\n-      --  loop index declaration has been processed.\n+      --  The components of the scheme have already been analyzed, and the loop\n+      --  parameter declaration has been processed.\n \n       Set_Analyzed (Iteration_Scheme (Last (Actions)));\n "}]}