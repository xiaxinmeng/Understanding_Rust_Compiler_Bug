{"sha": "94b8a37fa16f7638cc1965718f4ec71719506743", "node_id": "C_kwDOANBUbNoAKDk0YjhhMzdmYTE2Zjc2MzhjYzE5NjU3MThmNGVjNzE3MTk1MDY3NDM", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-12T10:13:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-12T11:27:12Z"}, "message": "tree-optimization/105562 - avoid uninit diagnostic with better FRE\n\nWe can avoid some uninit diagnostics by making FRE disambiguate\nagainst CLOBBERs since any aliasing there would invoke undefined\nbehavior for a read we are looking up.\n\n2022-05-12  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/105562\n\t* tree-ssa-sccvn.cc (vn_reference_lookup_3): Disambiguate\n\tagainst all CLOBBER defs if there's not an obvious must-alias\n\tand we are not doing redundant store elimination.\n\t(vn_walk_cb_data::redundant_store_removal_p): New field.\n\t(vn_reference_lookup_pieces): Initialize it.\n\t(vn_reference_lookup): Add argument to specify if we are\n\tdoing redundant store removal.\n\t(eliminate_dom_walker::eliminate_stmt): Specify we do.\n\t* tree-ssa-sccvn.h (vn_reference_lookup): Adjust.\n\n\t* g++.dg/warn/uninit-pr105562.C: New testcase.", "tree": {"sha": "2c4655d41dda9a3ca708025e0cd240b3ea7b7739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c4655d41dda9a3ca708025e0cd240b3ea7b7739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94b8a37fa16f7638cc1965718f4ec71719506743", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94b8a37fa16f7638cc1965718f4ec71719506743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94b8a37fa16f7638cc1965718f4ec71719506743", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94b8a37fa16f7638cc1965718f4ec71719506743/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78c8b0b980341f28de96da518a38bf85bbd24d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c8b0b980341f28de96da518a38bf85bbd24d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78c8b0b980341f28de96da518a38bf85bbd24d98"}], "stats": {"total": 49, "additions": 40, "deletions": 9}, "files": [{"sha": "ec3a5503c8043103345f1db0eb92ed3ad944e1d6", "filename": "gcc/testsuite/g++.dg/warn/uninit-pr105562.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94b8a37fa16f7638cc1965718f4ec71719506743/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funinit-pr105562.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94b8a37fa16f7638cc1965718f4ec71719506743/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funinit-pr105562.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funinit-pr105562.C?ref=94b8a37fa16f7638cc1965718f4ec71719506743", "patch": "@@ -0,0 +1,10 @@\n+// { dg-require-effective-target c++11 }\n+// { dg-options \"-O -Wall -fno-strict-aliasing\" }\n+\n+#include <regex>\n+\n+int main()\n+{\n+  std::regex a(\".\");\n+  std::regex b(std::move(a));\n+}"}, {"sha": "f1bc372f81a31da4d8393b2bc618fb1f51e86d22", "filename": "gcc/tree-ssa-sccvn.cc", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94b8a37fa16f7638cc1965718f4ec71719506743/gcc%2Ftree-ssa-sccvn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94b8a37fa16f7638cc1965718f4ec71719506743/gcc%2Ftree-ssa-sccvn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.cc?ref=94b8a37fa16f7638cc1965718f4ec71719506743", "patch": "@@ -1799,11 +1799,13 @@ struct pd_data\n struct vn_walk_cb_data\n {\n   vn_walk_cb_data (vn_reference_t vr_, tree orig_ref_, tree *last_vuse_ptr_,\n-\t\t   vn_lookup_kind vn_walk_kind_, bool tbaa_p_, tree mask_)\n+\t\t   vn_lookup_kind vn_walk_kind_, bool tbaa_p_, tree mask_,\n+\t\t   bool redundant_store_removal_p_)\n     : vr (vr_), last_vuse_ptr (last_vuse_ptr_), last_vuse (NULL_TREE),\n       mask (mask_), masked_result (NULL_TREE), vn_walk_kind (vn_walk_kind_),\n-      tbaa_p (tbaa_p_), saved_operands (vNULL), first_set (-2),\n-      first_base_set (-2), known_ranges (NULL)\n+      tbaa_p (tbaa_p_), redundant_store_removal_p (redundant_store_removal_p_),\n+      saved_operands (vNULL), first_set (-2), first_base_set (-2),\n+      known_ranges (NULL)\n   {\n     if (!last_vuse_ptr)\n       last_vuse_ptr = &last_vuse;\n@@ -1862,6 +1864,7 @@ struct vn_walk_cb_data\n   tree masked_result;\n   vn_lookup_kind vn_walk_kind;\n   bool tbaa_p;\n+  bool redundant_store_removal_p;\n   vec<vn_reference_op_s> saved_operands;\n \n   /* The VDEFs of partial defs we come along.  */\n@@ -2620,6 +2623,19 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n \t  return NULL;\n \t}\n \n+      /* When the def is a CLOBBER we can optimistically disambiguate\n+\t against it since any overlap it would be undefined behavior.\n+\t Avoid this for obvious must aliases to save compile-time though.\n+\t We also may not do this when the query is used for redundant\n+\t store removal.  */\n+      if (!data->redundant_store_removal_p\n+\t  && gimple_clobber_p (def_stmt)\n+\t  && !operand_equal_p (ao_ref_base (&lhs_ref), base, OEP_ADDRESS_OF))\n+\t{\n+\t  *disambiguate_only = TR_DISAMBIGUATE;\n+\t  return NULL;\n+\t}\n+\n       /* Besides valueizing the LHS we can also use access-path based\n          disambiguation on the original non-valueized ref.  */\n       if (!ref->ref\n@@ -3604,7 +3620,8 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set,\n     {\n       ao_ref r;\n       unsigned limit = param_sccvn_max_alias_queries_per_access;\n-      vn_walk_cb_data data (&vr1, NULL_TREE, NULL, kind, true, NULL_TREE);\n+      vn_walk_cb_data data (&vr1, NULL_TREE, NULL, kind, true, NULL_TREE,\n+\t\t\t    false);\n       vec<vn_reference_op_s> ops_for_ref;\n       if (!valueized_p)\n \tops_for_ref = vr1.operands;\n@@ -3649,12 +3666,14 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set,\n    MASK is either NULL_TREE, or can be an INTEGER_CST if the result of the\n    load is bitwise anded with MASK and so we are only interested in a subset\n    of the bits and can ignore if the other bits are uninitialized or\n-   not initialized with constants.  */\n+   not initialized with constants.  When doing redundant store removal\n+   the caller has to set REDUNDANT_STORE_REMOVAL_P.  */\n \n tree\n vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n \t\t     vn_reference_t *vnresult, bool tbaa_p,\n-\t\t     tree *last_vuse_ptr, tree mask)\n+\t\t     tree *last_vuse_ptr, tree mask,\n+\t\t     bool redundant_store_removal_p)\n {\n   vec<vn_reference_op_s> operands;\n   struct vn_reference_s vr1;\n@@ -3732,7 +3751,8 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n \t\t\t\t\t     vr1.type, ops_for_ref))\n \tao_ref_init (&r, op);\n       vn_walk_cb_data data (&vr1, r.ref ? NULL_TREE : op,\n-\t\t\t    last_vuse_ptr, kind, tbaa_p, mask);\n+\t\t\t    last_vuse_ptr, kind, tbaa_p, mask,\n+\t\t\t    redundant_store_removal_p);\n \n       wvnresult\n \t= ((vn_reference_t)\n@@ -6592,7 +6612,8 @@ eliminate_dom_walker::eliminate_stmt (basic_block b, gimple_stmt_iterator *gsi)\n       tree val = NULL_TREE;\n       if (lookup_lhs)\n \tval = vn_reference_lookup (lookup_lhs, gimple_vuse (stmt),\n-\t\t\t\t   VN_WALKREWRITE, &vnresult, false);\n+\t\t\t\t   VN_WALKREWRITE, &vnresult, false,\n+\t\t\t\t   NULL, NULL_TREE, true);\n       if (TREE_CODE (rhs) == SSA_NAME)\n \trhs = VN_INFO (rhs)->valnum;\n       if (val"}, {"sha": "a1b1e6bdd1edc14179f14e247811b639b22ebe70", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94b8a37fa16f7638cc1965718f4ec71719506743/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94b8a37fa16f7638cc1965718f4ec71719506743/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=94b8a37fa16f7638cc1965718f4ec71719506743", "patch": "@@ -265,7 +265,7 @@ tree vn_reference_lookup_pieces (tree, alias_set_type, alias_set_type, tree,\n \t\t\t\t vec<vn_reference_op_s> ,\n \t\t\t\t vn_reference_t *, vn_lookup_kind);\n tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool,\n-\t\t\t  tree * = NULL, tree = NULL_TREE);\n+\t\t\t  tree * = NULL, tree = NULL_TREE, bool = false);\n void vn_reference_lookup_call (gcall *, vn_reference_t *, vn_reference_t);\n vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, alias_set_type,\n \t\t\t\t\t   tree, vec<vn_reference_op_s>,"}]}