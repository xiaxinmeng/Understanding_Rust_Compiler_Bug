{"sha": "dbc957f103982bd3d8cb973beb26439d4e99ad8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJjOTU3ZjEwMzk4MmJkM2Q4Y2I5NzNiZWIyNjQzOWQ0ZTk5YWQ4Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-07-19T04:27:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-07-19T04:27:16Z"}, "message": "class.c (type_requires_array_cookie): New function.\n\n\t* class.c (type_requires_array_cookie): New function.\n\t(check_methods): Don't try to figure out whether the type needs a\n\tcookie here.\n\t(check_bases_and_members): Set TYPE_VEC_NEW_USES_COOKIE here.\n\t* cp-tree.h (TYPE_VEC_DELETE_TAKES_SIZE): Remove.\n\t(TYPE_VEC_NEW_USES_COOKIE): Reimplement.\n\t* pt.c (instantiate_class_template): Don't set\n\tTYPE_VEC_DELETE_TAKES_SIZE.\n\t* NEWS: Document ABI changes from GCC 3.0.\n\nFrom-SVN: r44142", "tree": {"sha": "55d1f67ed10772a2950b1029d8cfb2d9fe75bb8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55d1f67ed10772a2950b1029d8cfb2d9fe75bb8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbc957f103982bd3d8cb973beb26439d4e99ad8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc957f103982bd3d8cb973beb26439d4e99ad8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbc957f103982bd3d8cb973beb26439d4e99ad8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc957f103982bd3d8cb973beb26439d4e99ad8c/comments", "author": null, "committer": null, "parents": [{"sha": "8458e9540166e45e4e9501cf2ae5a9aeb49b1468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8458e9540166e45e4e9501cf2ae5a9aeb49b1468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8458e9540166e45e4e9501cf2ae5a9aeb49b1468"}], "stats": {"total": 162, "additions": 119, "deletions": 43}, "files": [{"sha": "6825721315bf096b3dede15c791b1aca61678931", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dbc957f103982bd3d8cb973beb26439d4e99ad8c", "patch": "@@ -1,3 +1,15 @@\n+2001-07-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (type_requires_array_cookie): New function.\n+\t(check_methods): Don't try to figure out whether the type needs a\n+\tcookie here.\n+\t(check_bases_and_members): Set TYPE_VEC_NEW_USES_COOKIE here.\n+\t* cp-tree.h (TYPE_VEC_DELETE_TAKES_SIZE): Remove.\n+\t(TYPE_VEC_NEW_USES_COOKIE): Reimplement.\n+\t* pt.c (instantiate_class_template): Don't set\n+\tTYPE_VEC_DELETE_TAKES_SIZE.\n+\t* NEWS: Document ABI changes from GCC 3.0.\n+\t\n 2001-07-18  Xavier Delacour <xavier@fmaudio.net>,\n             Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n "}, {"sha": "69b6fb46ff725068d9eeba3772d3afa5f05214ab", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=dbc957f103982bd3d8cb973beb26439d4e99ad8c", "patch": "@@ -1,5 +1,41 @@\n *** Changes in GCC 3.1:\n \n+* The C++ ABI has been changed to correctly handle this code:\n+\t\n+    struct A {\n+      void operator delete[] (void *, size_t);\n+    };\n+\n+    struct B : public A { \n+    };\n+\n+    new B[10];\n+\n+  The amount of storage allocated for the array will be greater than\n+  it was in 3.0, in order to store the number of elements in the\n+  array, so that the correct size can be passed to `operator delete[]'\n+  when the array is deleted.  Previously, the value passed to \n+  `operator delete[]' was unpredictable.\n+\n+  This change will only affect code that declares a two-argument\n+  `operator delete[]' with a second parameter of type `size_t'\n+  in a base class, and does not override that definition in a \n+  derived class.\n+\n+* The C++ ABI has been changed so that:\n+\n+    struct A { \n+      void operator delete[] (void *, size_t);\n+      void operator delete[] (void *);\n+    };\n+\n+  does not cause unncessary storage to be allocated when an array of\n+  `A' objects is allocated.\n+\n+  This change will only affect code that declares both of these\n+  forms of `operator delete[]', and declared the two-argument form\n+  before the one-argument form.\n+\n *** Changes in GCC 3.0:\n \n * Support for guiding declarations has been removed."}, {"sha": "c3aa297236b513fc63e33a032807cba87cc9ff8d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 59, "deletions": 27, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dbc957f103982bd3d8cb973beb26439d4e99ad8c", "patch": "@@ -218,6 +218,7 @@ static int layout_conflict_p PARAMS ((tree, tree, splay_tree, int));\n static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n \t\t\t\t\t\t    splay_tree_key k2));\n static void warn_about_ambiguous_direct_bases PARAMS ((tree));\n+static bool type_requires_array_cookie PARAMS ((tree));\n \n /* Macros for dfs walking during vtt construction. See\n    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n@@ -4210,7 +4211,6 @@ check_methods (t)\n      tree t;\n {\n   tree x;\n-  int seen_one_arg_array_delete_p = 0;\n \n   for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n@@ -4234,32 +4234,6 @@ check_methods (t)\n \t    CLASSTYPE_PURE_VIRTUALS (t)\n \t      = tree_cons (NULL_TREE, x, CLASSTYPE_PURE_VIRTUALS (t));\n \t}\n-\n-      if (DECL_ARRAY_DELETE_OPERATOR_P (x))\n-\t{\n-\t  tree second_parm;\n-\n-\t  /* When dynamically allocating an array of this type, we\n-\t     need a \"cookie\" to record how many elements we allocated,\n-\t     even if the array elements have no non-trivial\n-\t     destructor, if the usual array deallocation function\n-\t     takes a second argument of type size_t.  The standard (in\n-\t     [class.free]) requires that the second argument be set\n-\t     correctly.  */\n-\t  second_parm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (x)));\n-\t  /* Under the new ABI, we choose only those function that are\n-\t     explicitly declared as `operator delete[] (void *,\n-\t     size_t)'.  */\n-\t  if (!seen_one_arg_array_delete_p\n-\t      && second_parm\n-\t      && TREE_CHAIN (second_parm) == void_list_node\n-\t      && same_type_p (TREE_VALUE (second_parm), sizetype))\n-\t    TYPE_VEC_DELETE_TAKES_SIZE (t) = 1;\n-\t  /* If there's no second parameter, then this is the usual\n-\t     deallocation function.  */\n-\t  else if (second_parm == void_list_node)\n-\t    seen_one_arg_array_delete_p = 1;\n-\t}\n     }\n }\n \n@@ -4556,6 +4530,59 @@ remove_zero_width_bit_fields (t)\n     }\n }\n \n+/* Returns TRUE iff we need a cookie when dynamically allocating an\n+   array whose elements have the indicated class TYPE.  */\n+\n+static bool\n+type_requires_array_cookie (type)\n+     tree type;\n+{\n+  tree fns;\n+  bool has_two_argument_delete_p;\n+\n+  my_friendly_assert (CLASS_TYPE_P (type), 20010712);\n+\n+  /* If there's a non-trivial destructor, we need a cookie.  In order\n+     to iterate through the array calling the destructor for each\n+     element, we'll have to know how many elements there are.  */\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+    return true;\n+\n+  /* If the usual deallocation function is a two-argument whose second\n+     argument is of type `size_t', then we have to pass the size of\n+     the array to the deallocation function, so we will need to store\n+     a cookie.  */\n+  fns = lookup_fnfields (TYPE_BINFO (type), \n+\t\t\t ansi_opname (VEC_DELETE_EXPR),\n+\t\t\t /*protect=*/0);\n+  /* If there are no `operator []' members, or the lookup is\n+     ambiguous, then we don't need a cookie.  */\n+  if (!fns || fns == error_mark_node)\n+    return false;\n+  /* Loop through all of the functions.  */\n+  for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n+    {\n+      tree fn;\n+      tree second_parm;\n+\n+      /* Select the current function.  */\n+      fn = OVL_CURRENT (fns);\n+      /* See if this function is a one-argument delete function.  If\n+\t it is, then it will be the usual deallocation function.  */\n+      second_parm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn)));\n+      if (second_parm == void_list_node)\n+\treturn false;\n+      /* Otherwise, if we have a two-argument function and the second\n+\t argument is `size_t', it will be the usual deallocation\n+\t function -- unless there is one-argument function, too.  */\n+      if (TREE_CHAIN (second_parm) == void_list_node\n+\t  && same_type_p (TREE_VALUE (second_parm), sizetype))\n+\thas_two_argument_delete_p = true;\n+    }\n+\n+  return has_two_argument_delete_p;\n+}\n+\n /* Check the validity of the bases and members declared in T.  Add any\n    implicitly-generated functions (like copy-constructors and\n    assignment operators).  Compute various flag bits (like\n@@ -4641,6 +4668,11 @@ check_bases_and_members (t, empty_p)\n \n   /* Build and sort the CLASSTYPE_METHOD_VEC.  */\n   finish_struct_methods (t);\n+\n+  /* Figure out whether or not we will need a cookie when dynamically\n+     allocating an array of this type.  */\n+  TYPE_LANG_SPECIFIC (t)->vec_new_uses_cookie\n+    = type_requires_array_cookie (t);\n }\n \n /* If T needs a pointer to its virtual function table, set TYPE_VFIELD"}, {"sha": "b32bd0cb88172c208a569991256263b2d0ac955e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dbc957f103982bd3d8cb973beb26439d4e99ad8c", "patch": "@@ -1291,7 +1291,7 @@ struct lang_type\n   unsigned needs_virtual_reinit : 1;\n \n   unsigned marks: 6;\n-  unsigned vec_delete_takes_size : 1;\n+  unsigned vec_new_uses_cookie : 1;\n   unsigned declared_class : 1;\n \n   unsigned being_defined : 1;\n@@ -1353,19 +1353,11 @@ struct lang_type\n #define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->gets_delete)\n #define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n \n-/* Nonzero for _CLASSTYPE means that operator vec delete is defined and\n-   takes the optional size_t argument.  */\n-#define TYPE_VEC_DELETE_TAKES_SIZE(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->vec_delete_takes_size)\n-\n /* Nonzero if `new NODE[x]' should cause the allocation of extra\n-   storage to indicate how many array elements are in use.  The old\n-   ABI had a bug in that we always allocate the extra storage if NODE\n-   has a two-argument array operator delete.  */\n-#define TYPE_VEC_NEW_USES_COOKIE(NODE)\t\t\\\n-  (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (NODE)\t\\\n-   || (TYPE_LANG_SPECIFIC (NODE)\t\t\\\n-       && TYPE_VEC_DELETE_TAKES_SIZE (NODE)))\n+   storage to indicate how many array elements are in use.  */\n+#define TYPE_VEC_NEW_USES_COOKIE(NODE)\t\t\t\\\n+  (CLASS_TYPE_P (NODE)\t\t\t\t\t\\\n+   && TYPE_LANG_SPECIFIC (NODE)->vec_new_uses_cookie)\n \n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */"}, {"sha": "d09ce8f70ca02bc2030fd3c1d142b03e94d7aa5e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dbc957f103982bd3d8cb973beb26439d4e99ad8c", "patch": "@@ -4988,7 +4988,6 @@ instantiate_class_template (type)\n   TYPE_HAS_NEW_OPERATOR (type) = TYPE_HAS_NEW_OPERATOR (pattern);\n   TYPE_HAS_ARRAY_NEW_OPERATOR (type) = TYPE_HAS_ARRAY_NEW_OPERATOR (pattern);\n   TYPE_GETS_DELETE (type) = TYPE_GETS_DELETE (pattern);\n-  TYPE_VEC_DELETE_TAKES_SIZE (type) = TYPE_VEC_DELETE_TAKES_SIZE (pattern);\n   TYPE_HAS_ASSIGN_REF (type) = TYPE_HAS_ASSIGN_REF (pattern);\n   TYPE_HAS_CONST_ASSIGN_REF (type) = TYPE_HAS_CONST_ASSIGN_REF (pattern);\n   TYPE_HAS_ABSTRACT_ASSIGN_REF (type) = TYPE_HAS_ABSTRACT_ASSIGN_REF (pattern);"}, {"sha": "5f296ebeef1b6120958c25a221271a791659911a", "filename": "gcc/testsuite/g++.old-deja/g++.abi/arraynew.C", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Farraynew.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc957f103982bd3d8cb973beb26439d4e99ad8c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Farraynew.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Farraynew.C?ref=dbc957f103982bd3d8cb973beb26439d4e99ad8c", "patch": "@@ -82,6 +82,9 @@ struct Z2 { ~Z2 () {}; long double d; };\n struct W1 { void operator delete[] (void *, size_t) {}; };\n struct W2 { void operator delete[] (void *) {}; \n             void operator delete[] (void *, size_t) {}; };\n+struct W3 { void operator delete[] (void *, size_t) {}; \n+            void operator delete[] (void *) {}; };\n+struct W4 : public W1 {};\n \n struct V { void *operator new[] (size_t s, void *p) \n              { return p; }\n@@ -108,11 +111,13 @@ int main ()\n   // There should be a cookie when using the two-argument array delete\n   // operator.\n   check_cookie<W1> (9);\n+  check_cookie<W4> (10);\n   // But not when the one-argument version is also available.\n-  check_no_cookie<W2> (10);\n+  check_no_cookie<W2> (11);\n+  check_no_cookie<W3> (12);\n \n   // There should be a cookie when using a non-global placement new.\n-  check_placement_cookie<V> (11);\n+  check_placement_cookie<V> (13);\n }\n \n #else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */"}]}