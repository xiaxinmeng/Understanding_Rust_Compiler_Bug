{"sha": "c2fe93f7ba3e77c489dc06d48a3082efefa6eac1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJmZTkzZjdiYTNlNzdjNDg5ZGMwNmQ0OGEzMDgyZWZlZmE2ZWFjMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-07-30T21:14:52Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-07-30T21:14:52Z"}, "message": "re PR libstdc++/32908 (Miss lexicographical_compare random access override)\n\n2007-07-30  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/32908\n\t* include/bits/stl_algobase.h (struct __lc_rai): New.\n\t(lexicographical_compare(_II1, _II1, _II2, _II2),\n\tlexicographical_compare(_II1, _II1, _II2, _II2, _Compare)): Use it.\n\t* testsuite/performance/25_algorithms/lexicographical_compare.cc: New.\n\nFrom-SVN: r127073", "tree": {"sha": "4969a654005cdf40d89695213d7a0208bd12bb13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4969a654005cdf40d89695213d7a0208bd12bb13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1/comments", "author": null, "committer": null, "parents": [{"sha": "f1ad2eefc99971867c92e0ff222dd52d33410099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ad2eefc99971867c92e0ff222dd52d33410099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ad2eefc99971867c92e0ff222dd52d33410099"}], "stats": {"total": 154, "additions": 133, "deletions": 21}, "files": [{"sha": "8af41ef6f1f32989c4c6cdee9454f87439737a16", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c2fe93f7ba3e77c489dc06d48a3082efefa6eac1", "patch": "@@ -1,3 +1,11 @@\n+2007-07-30  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/32908\n+\t* include/bits/stl_algobase.h (struct __lc_rai): New.\n+\t(lexicographical_compare(_II1, _II1, _II2, _II2),\n+\tlexicographical_compare(_II1, _II1, _II2, _II2, _Compare)): Use it.\n+\t* testsuite/performance/25_algorithms/lexicographical_compare.cc: New.\n+\n 2007-07-27  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/32907"}, {"sha": "4146b21df5b654fff86533625cdbd6ecd6d90b50", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=c2fe93f7ba3e77c489dc06d48a3082efefa6eac1", "patch": "@@ -778,6 +778,43 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return true;\n     }\n \n+\n+  template<typename, typename>\n+    struct __lc_rai\n+    {\n+      template<typename _II1, typename _II2>\n+        static _II1\n+        __newlast1(_II1, _II1 __last1, _II2, _II2)\n+        { return __last1; }\n+\n+      template<typename _II>\n+        static bool\n+        __cnd2(_II __first, _II __last)\n+        { return __first != __last; }\n+    };\n+\n+  template<>\n+    struct __lc_rai<random_access_iterator_tag,\n+\t\t    random_access_iterator_tag>\n+    {\n+      template<typename _RAI1, typename _RAI2>\n+        static _RAI1\n+        __newlast1(_RAI1 __first1, _RAI1 __last1,\n+\t\t   _RAI2 __first2, _RAI2 __last2)\n+        {\n+\t  const typename iterator_traits<_RAI1>::difference_type\n+\t    __diff1 = __last1 - __first1;\n+\t  const typename iterator_traits<_RAI2>::difference_type\n+\t    __diff2 = __last2 - __first2;\n+\t  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;\n+\t}\n+\n+      template<typename _RAI>\n+        static bool\n+        __cnd2(_RAI, _RAI)\n+        { return true; }\n+    };\n+\n   /**\n    *  @brief Performs \"dictionary\" comparison on ranges.\n    *  @param  first1  An input iterator.\n@@ -792,24 +829,30 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,\n    *  then this is an inline call to @c memcmp.\n   */\n-  template<typename _InputIterator1, typename _InputIterator2>\n+  template<typename _II1, typename _II2>\n     bool\n-    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n-\t\t\t    _InputIterator2 __first2, _InputIterator2 __last2)\n+    lexicographical_compare(_II1 __first1, _II1 __last1,\n+\t\t\t    _II2 __first2, _II2 __last2)\n     {\n+      typedef typename iterator_traits<_II1>::iterator_category _Category1;\n+      typedef typename iterator_traits<_II2>::iterator_category _Category2;\n+\n       // concept requirements\n-      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n-      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n-      __glibcxx_function_requires(_LessThanOpConcept<\n-\t    typename iterator_traits<_InputIterator1>::value_type,\n-\t    typename iterator_traits<_InputIterator2>::value_type>)\n-      __glibcxx_function_requires(_LessThanOpConcept<\n-\t    typename iterator_traits<_InputIterator2>::value_type,\n-\t    typename iterator_traits<_InputIterator1>::value_type>)\n+      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_II2>::value_type _ValueType2;\n+      __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n+      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)\n+      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      for (; __first1 != __last1 && __first2 != __last2;\n+      __last1 = __lc_rai<_Category1, _Category2>::__newlast1(__first1,\n+\t\t\t\t\t\t\t     __last1,\n+\t\t\t\t\t\t\t     __first2,\n+\t\t\t\t\t\t\t     __last2);\n+      for (; __first1 != __last1\n+\t     && __lc_rai<_Category1, _Category2>::__cnd2(__first2, __last2);\n \t   ++__first1, ++__first2)\n \t{\n \t  if (*__first1 < *__first2)\n@@ -829,23 +872,29 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  @param  comp  A @link s20_3_3_comparisons comparison functor@endlink.\n    *  @return   A boolean true or false.\n    *\n-   *  The same as the four-parameter @c lexigraphical_compare, but uses the\n+   *  The same as the four-parameter @c lexicographical_compare, but uses the\n    *  comp parameter instead of @c <.\n   */\n-  template<typename _InputIterator1, typename _InputIterator2,\n-\t   typename _Compare>\n+  template<typename _II1, typename _II2, typename _Compare>\n     bool\n-    lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n-\t\t\t    _InputIterator2 __first2, _InputIterator2 __last2,\n-\t\t\t    _Compare __comp)\n+    lexicographical_compare(_II1 __first1, _II1 __last1,\n+\t\t\t    _II2 __first2, _II2 __last2, _Compare __comp)\n     {\n+      typedef typename iterator_traits<_II1>::iterator_category _Category1;\n+      typedef typename iterator_traits<_II2>::iterator_category _Category2;\n+\n       // concept requirements\n-      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n-      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      for (; __first1 != __last1 && __first2 != __last2;\n+      __last1 = __lc_rai<_Category1, _Category2>::__newlast1(__first1,\n+\t\t\t\t\t\t\t     __last1,\n+\t\t\t\t\t\t\t     __first2,\n+\t\t\t\t\t\t\t     __last2);\n+      for (; __first1 != __last1\n+\t     && __lc_rai<_Category1, _Category2>::__cnd2(__first2, __last2);\n \t   ++__first1, ++__first2)\n \t{\n \t  if (__comp(*__first1, *__first2))"}, {"sha": "b983881c4b4b478b5d6a09279f992a84c42fd5ec", "filename": "libstdc++-v3/testsuite/performance/25_algorithms/lexicographical_compare.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Flexicographical_compare.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2fe93f7ba3e77c489dc06d48a3082efefa6eac1/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Flexicographical_compare.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Flexicographical_compare.cc?ref=c2fe93f7ba3e77c489dc06d48a3082efefa6eac1", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <vector>\n+#include <testsuite_performance.h>\n+\n+// libstdc++/32908\n+int main()\n+{\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  int cnt = 0;\n+  std::vector<int> a(10000), b(10000);\n+\n+  start_counters(time, resource);\n+  for (int i = 0; i < 100000; ++i)\n+    {\n+      if (a < b)\n+\t++cnt;\n+      if (a > b)\n+\t++cnt;\n+    }\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"\", time, resource);\n+  clear_counters(time, resource);\n+\n+  return cnt;\n+}"}]}