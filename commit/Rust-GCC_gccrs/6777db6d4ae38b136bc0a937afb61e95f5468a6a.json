{"sha": "6777db6d4ae38b136bc0a937afb61e95f5468a6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc3N2RiNmQ0YWUzOGIxMzZiYzBhOTM3YWZiNjFlOTVmNTQ2OGE2YQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-27T05:49:33Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-27T05:49:33Z"}, "message": "cpplib.h: \"~=\" is not a single pp-token.\n\n2000-04-26  Neil Booth  <NeilB@earthling.net>\n\n\t* cpplib.h: \"~=\" is not a single pp-token.\n\t* cpplex.c: Correct commentary.\n\nFrom-SVN: r33463", "tree": {"sha": "7b5ab3deec58ecdc4da392d9db01abcef6b534cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b5ab3deec58ecdc4da392d9db01abcef6b534cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6777db6d4ae38b136bc0a937afb61e95f5468a6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6777db6d4ae38b136bc0a937afb61e95f5468a6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6777db6d4ae38b136bc0a937afb61e95f5468a6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6777db6d4ae38b136bc0a937afb61e95f5468a6a/comments", "author": null, "committer": null, "parents": [{"sha": "b4593d17c03d7a32bb761b5d22a4fa0285548216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4593d17c03d7a32bb761b5d22a4fa0285548216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4593d17c03d7a32bb761b5d22a4fa0285548216"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "7931e3c38e77b40914018601823c04214a894c5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6777db6d4ae38b136bc0a937afb61e95f5468a6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6777db6d4ae38b136bc0a937afb61e95f5468a6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6777db6d4ae38b136bc0a937afb61e95f5468a6a", "patch": "@@ -1,3 +1,8 @@\n+2000-04-26  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpplib.h: \"~=\" is not a single pp-token.\n+\t* cpplex.c: Correct commentary.\n+\n 2000-04-26  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (mark_set_1): New arguments code and flags; update all"}, {"sha": "11a88e1b47a1f4561ceb810e9e379a1c716f2143", "filename": "gcc/cpplex.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6777db6d4ae38b136bc0a937afb61e95f5468a6a/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6777db6d4ae38b136bc0a937afb61e95f5468a6a/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=6777db6d4ae38b136bc0a937afb61e95f5468a6a", "patch": "@@ -2056,24 +2056,24 @@ _cpp_init_input_buffer (pfile)\n  that replaced trigraphs and deleted esacped newlines, and a second\n  pass that tokenized the result of the first pass.  Tokenisation was\n  performed by peeking at the next character in the input stream.  For\n- example, if the input stream contained \"~=\", the handler for the ~\n+ example, if the input stream contained \"!=\", the handler for the !\n  character would peek at the next character, and if it were a '='\n- would skip over it, and return a \"~=\" token, otherwise it would\n- return just the \"~\" token.\n+ would skip over it, and return a \"!=\" token, otherwise it would\n+ return just the \"!\" token.\n \n  To implement a single-pass lexer, this peeking ahead is unworkable.\n  An arbitrary number of escaped newlines, and trigraphs (in particular\n- ??/ which translates to the escape \\), could separate the '~' and '='\n- in the input stream, yet the next token is still a \"~=\".\n+ ??/ which translates to the escape \\), could separate the '!' and '='\n+ in the input stream, yet the next token is still a \"!=\".\n \n  Suppose instead that we lex by one logical line at a time, producing\n- a token list or stack for each logical line, and when seeing the '~'\n- push a CPP_COMPLEMENT token on the list.  Then if the '~' is part of\n- a longer token (\"~=\") we know we must see the remainder of the token\n- by the time we reach the end of the logical line.  Thus we can have\n- the '=' handler look at the previous token (at the end of the list /\n- top of the stack) and see if it is a \"~\" token, and if so, instead of\n- pushing a \"=\" token revise the existing token to be a \"~=\" token.\n+ a token list or stack for each logical line, and when seeing the '!'\n+ push a CPP_NOT token on the list.  Then if the '!' is part of a\n+ longer token (\"!=\") we know we must see the remainder of the token by\n+ the time we reach the end of the logical line.  Thus we can have the\n+ '=' handler look at the previous token (at the end of the list / top\n+ of the stack) and see if it is a \"!\" token, and if so, instead of\n+ pushing a \"=\" token revise the existing token to be a \"!=\" token.\n \n  This works in the presence of escaped newlines, because the '\\' would\n  have been pushed on the top of the stack as a CPP_BACKSLASH.  The\n@@ -2091,7 +2091,7 @@ _cpp_init_input_buffer (pfile)\n  To the preprocessor, whitespace is only significant to the point of\n  knowing whether whitespace precedes a particular token.  For example,\n  the '=' handler needs to know whether there was whitespace between it\n- and a \"~\" token on the top of the stack, to make the token conversion\n+ and a \"!\" token on the top of the stack, to make the token conversion\n  decision correctly.  So each token has a PREV_WHITESPACE flag to\n  indicate this - the standard permits consecutive whitespace to be\n  regarded as a single space.  The compiler front ends are not"}, {"sha": "8233804911d2584a8a08112b80388dd23600e911", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6777db6d4ae38b136bc0a937afb61e95f5468a6a/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6777db6d4ae38b136bc0a937afb61e95f5468a6a/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=6777db6d4ae38b136bc0a937afb61e95f5468a6a", "patch": "@@ -61,10 +61,10 @@ typedef struct cpp_name cpp_name;\n   T(CPP_AND,\t\t\"&\")\t/* bit ops */\t\\\n   T(CPP_OR,\t\t\"|\")\t\t\t\\\n   T(CPP_XOR,\t\t\"^\")\t\t\t\\\n-  T(CPP_COMPL,\t\t\"~\")\t\t\t\\\n   T(CPP_RSHIFT,\t\t\">>\")\t\t\t\\\n   T(CPP_LSHIFT,\t\t\"<<\")\t\t\t\\\n \\\n+  T(CPP_COMPL,\t\t\"~\")\t\t\t\\\n   T(CPP_AND_AND,\t\"&&\")\t/* logical */\t\\\n   T(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n   T(CPP_QUERY,\t\t\"?\")\t\t\t\\\n@@ -85,7 +85,6 @@ typedef struct cpp_name cpp_name;\n   T(CPP_AND_EQ,\t\t\"&=\")\t/* bit ops */\t\\\n   T(CPP_OR_EQ,\t\t\"|=\")\t\t\t\\\n   T(CPP_XOR_EQ,\t\t\"^=\")\t\t\t\\\n-  T(CPP_COMPL_EQ,\t\"~=\")\t\t\t\\\n   T(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n   T(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n   /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */\t\\"}]}