{"sha": "db0d1bae4a36e255bdf676e5030294c27e4b6c86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIwZDFiYWU0YTM2ZTI1NWJkZjY3NmU1MDMwMjk0YzI3ZTRiNmM4Ng==", "commit": {"author": {"name": "Liu Hao", "email": "lh_mouse@126.com", "date": "2017-10-11T13:34:44Z"}, "committer": {"name": "Jonathan Yong", "email": "jyong@gcc.gnu.org", "date": "2017-10-11T13:34:44Z"}, "message": "pretty-print.c [_WIN32] (colorize_init): Remove.\n\n2017-10-11  Liu Hao  <lh_mouse@126.com>\n\n\t* pretty-print.c [_WIN32] (colorize_init): Remove.  Use\n\tthe generic version below instead.\n\t(should_colorize): Recognize Windows consoles as terminals\n\tfor MinGW targets.\n\t* pretty-print.c [__MINGW32__] (write_all): New function.\n\t[__MINGW32__] (find_esc_head): Likewise.\n\t[__MINGW32__] (find_esc_terminator): Likewise.\n\t[__MINGW32__] (eat_esc_sequence): Likewise.\n\t[__MINGW32__] (mingw_ansi_fputs): New function that handles\n\tANSI escape codes.\n\t(pp_write_text_to_stream): Use mingw_ansi_fputs instead of fputs\n\tfor MinGW targets.\n\nFrom-SVN: r253645", "tree": {"sha": "026c4bf2491704e6d768ff840a022533a7d45e3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/026c4bf2491704e6d768ff840a022533a7d45e3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db0d1bae4a36e255bdf676e5030294c27e4b6c86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db0d1bae4a36e255bdf676e5030294c27e4b6c86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db0d1bae4a36e255bdf676e5030294c27e4b6c86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db0d1bae4a36e255bdf676e5030294c27e4b6c86/comments", "author": {"login": "lhmouse", "id": 5071344, "node_id": "MDQ6VXNlcjUwNzEzNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5071344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lhmouse", "html_url": "https://github.com/lhmouse", "followers_url": "https://api.github.com/users/lhmouse/followers", "following_url": "https://api.github.com/users/lhmouse/following{/other_user}", "gists_url": "https://api.github.com/users/lhmouse/gists{/gist_id}", "starred_url": "https://api.github.com/users/lhmouse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lhmouse/subscriptions", "organizations_url": "https://api.github.com/users/lhmouse/orgs", "repos_url": "https://api.github.com/users/lhmouse/repos", "events_url": "https://api.github.com/users/lhmouse/events{/privacy}", "received_events_url": "https://api.github.com/users/lhmouse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85866209d4b1819c1a99071c980a42f4db35d104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85866209d4b1819c1a99071c980a42f4db35d104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85866209d4b1819c1a99071c980a42f4db35d104"}], "stats": {"total": 707, "additions": 697, "deletions": 10}, "files": [{"sha": "3d888e3b64529d9d0feef2daaf10e7c42a0fd377", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0d1bae4a36e255bdf676e5030294c27e4b6c86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0d1bae4a36e255bdf676e5030294c27e4b6c86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db0d1bae4a36e255bdf676e5030294c27e4b6c86", "patch": "@@ -1,3 +1,18 @@\n+2017-10-11  Liu Hao  <lh_mouse@126.com>\n+\n+\t* pretty-print.c [_WIN32] (colorize_init): Remove.  Use\n+\tthe generic version below instead.\n+\t(should_colorize): Recognize Windows consoles as terminals\n+\tfor MinGW targets.\n+\t* pretty-print.c [__MINGW32__] (write_all): New function.\n+\t[__MINGW32__] (find_esc_head): Likewise.\n+\t[__MINGW32__] (find_esc_terminator): Likewise.\n+\t[__MINGW32__] (eat_esc_sequence): Likewise.\n+\t[__MINGW32__] (mingw_ansi_fputs): New function that handles\n+\tANSI escape codes.\n+\t(pp_write_text_to_stream): Use mingw_ansi_fputs instead of fputs\n+\tfor MinGW targets.\n+\n 2017-10-11  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-niter.c (infer_loop_bounds_from_pointer_arith):"}, {"sha": "b8cf6f2c04556594f97b2b377864fd42d01c1935", "filename": "gcc/diagnostic-color.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0d1bae4a36e255bdf676e5030294c27e4b6c86/gcc%2Fdiagnostic-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0d1bae4a36e255bdf676e5030294c27e4b6c86/gcc%2Fdiagnostic-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.c?ref=db0d1bae4a36e255bdf676e5030294c27e4b6c86", "patch": "@@ -20,6 +20,10 @@\n #include \"system.h\"\n #include \"diagnostic-color.h\"\n \n+#ifdef __MINGW32__\n+#  include <windows.h>\n+#endif\n+\n /* Select Graphic Rendition (SGR, \"\\33[...m\") strings.  */\n /* Also Erase in Line (EL) to Right (\"\\33[K\") by default.  */\n /*    Why have EL to Right after SGR?\n@@ -275,23 +279,28 @@ parse_gcc_colors (void)\n       return true;\n }\n \n-#if defined(_WIN32)\n-bool\n-colorize_init (diagnostic_color_rule_t)\n-{\n-  return false;\n-}\n-#else\n-\n /* Return true if we should use color when in auto mode, false otherwise. */\n static bool\n should_colorize (void)\n {\n+#ifdef __MINGW32__\n+  /* For consistency reasons, one should check the handle returned by\n+     _get_osfhandle(_fileno(stderr)) because the function\n+     pp_write_text_to_stream() in pretty-print.c calls fputs() on\n+     that stream.  However, the code below for non-Windows doesn't seem\n+     to care about it either...  */\n+  HANDLE h;\n+  DWORD m;\n+\n+  h = GetStdHandle (STD_ERROR_HANDLE);\n+  return (h != INVALID_HANDLE_VALUE) && (h != NULL)\n+\t  && GetConsoleMode (h, &m);\n+#else\n   char const *t = getenv (\"TERM\");\n   return t && strcmp (t, \"dumb\") != 0 && isatty (STDERR_FILENO);\n+#endif\n }\n \n-\n bool\n colorize_init (diagnostic_color_rule_t rule)\n {\n@@ -310,4 +319,3 @@ colorize_init (diagnostic_color_rule_t rule)\n       gcc_unreachable ();\n     }\n }\n-#endif"}, {"sha": "e66d898a645ee3e412c8fbc742b40252492fd145", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 664, "deletions": 0, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db0d1bae4a36e255bdf676e5030294c27e4b6c86/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db0d1bae4a36e255bdf676e5030294c27e4b6c86/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=db0d1bae4a36e255bdf676e5030294c27e4b6c86", "patch": "@@ -30,6 +30,666 @@ along with GCC; see the file COPYING3.  If not see\n #include <iconv.h>\n #endif\n \n+#ifdef __MINGW32__\n+\n+/* Replacement for fputs() that handles ANSI escape codes on Windows NT.\n+   Contributed by: Liu Hao (lh_mouse at 126 dot com)\n+\n+   XXX: This file is compiled into libcommon.a that will be self-contained.\n+\tIt looks like that these functions can be put nowhere else.  */\n+\n+#include <io.h>\n+#define WIN32_LEAN_AND_MEAN 1\n+#include <windows.h>\n+\n+/* Write all bytes in [s,s+n) into the specified stream.\n+   Errors are ignored.  */\n+static void\n+write_all (HANDLE h, const char *s, size_t n)\n+{\n+  size_t rem = n;\n+  DWORD step;\n+\n+  while (rem != 0)\n+    {\n+      if (rem <= UINT_MAX)\n+\tstep = rem;\n+      else\n+\tstep = UINT_MAX;\n+      if (!WriteFile (h, s + n - rem, step, &step, NULL))\n+\tbreak;\n+      rem -= step;\n+    }\n+}\n+\n+/* Find the beginning of an escape sequence.\n+   There are two cases:\n+   1. If the sequence begins with an ESC character (0x1B) and a second\n+      character X in [0x40,0x5F], returns X and stores a pointer to\n+      the third character into *head.\n+   2. If the sequence begins with a character X in [0x80,0x9F], returns\n+      (X-0x40) and stores a pointer to the second character into *head.\n+   Stores the number of ESC character(s) in *prefix_len.\n+   Returns 0 if no such sequence can be found.  */\n+static int\n+find_esc_head (int *prefix_len, const char **head, const char *str)\n+{\n+  int c;\n+  const char *r = str;\n+  int escaped = 0;\n+\n+  for (;;)\n+    {\n+      c = (unsigned char) *r;\n+      if (c == 0)\n+\t{\n+\t  /* Not found.  */\n+\t  return 0;\n+\t}\n+      if (escaped && 0x40 <= c && c <= 0x5F)\n+\t{\n+\t  /* Found (case 1).  */\n+\t  *prefix_len = 2;\n+\t  *head = r + 1;\n+\t  return c;\n+\t}\n+      if (0x80 <= c && c <= 0x9F)\n+\t{\n+\t  /* Found (case 2).  */\n+\t  *prefix_len = 1;\n+\t  *head = r + 1;\n+\t  return c - 0x40;\n+\t}\n+      ++r;\n+      escaped = c == 0x1B;\n+    }\n+}\n+\n+/* Find the terminator of an escape sequence.\n+   str should be the value stored in *head by a previous successful\n+   call to find_esc_head().\n+   Returns 0 if no such sequence can be found.  */\n+static int\n+find_esc_terminator (const char **term, const char *str)\n+{\n+  int c;\n+  const char *r = str;\n+\n+  for (;;)\n+    {\n+      c = (unsigned char) *r;\n+      if (c == 0)\n+\t{\n+\t  /* Not found.  */\n+\t  return 0;\n+\t}\n+      if (0x40 <= c && c <= 0x7E)\n+\t{\n+\t  /* Found.  */\n+\t  *term = r;\n+\t  return c;\n+\t}\n+      ++r;\n+    }\n+}\n+\n+/* Handle a sequence of codes.  Sequences that are invalid, reserved,\n+   unrecognized or unimplemented are ignored silently.\n+   There isn't much we can do because of lameness of Windows consoles.  */\n+static void\n+eat_esc_sequence (HANDLE h, int esc_code,\n+\t\t  const char *esc_head, const char *esc_term)\n+{\n+  /* Numbers in an escape sequence cannot be negative, because\n+     a minus sign in the middle of it would have terminated it.  */\n+  long n1, n2;\n+  char *eptr, *delim;\n+  CONSOLE_SCREEN_BUFFER_INFO sb;\n+  COORD cr;\n+  /* ED and EL parameters.  */\n+  DWORD cnt, step;\n+  long rows;\n+  /* SGR parameters.  */\n+  WORD attrib_add, attrib_rm;\n+  const char *param;\n+\n+  switch (MAKEWORD (esc_code, *esc_term))\n+    {\n+    /* ESC [ n1 'A'\n+\t Move the cursor up by n1 characters.  */\n+    case MAKEWORD ('[', 'A'):\n+      if (esc_head == esc_term)\n+\tn1 = 1;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  /* Stop at the topmost boundary.  */\n+\t  if (cr.Y > n1)\n+\t    cr.Y -= n1;\n+\t  else\n+\t    cr.Y = 0;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'B'\n+\t Move the cursor down by n1 characters.  */\n+    case MAKEWORD ('[', 'B'):\n+      if (esc_head == esc_term)\n+\tn1 = 1;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  /* Stop at the bottommost boundary.  */\n+\t  if (sb.dwSize.Y - cr.Y > n1)\n+\t    cr.Y += n1;\n+\t  else\n+\t    cr.Y = sb.dwSize.Y;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'C'\n+\t Move the cursor right by n1 characters.  */\n+    case MAKEWORD ('[', 'C'):\n+      if (esc_head == esc_term)\n+\tn1 = 1;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  /* Stop at the rightmost boundary.  */\n+\t  if (sb.dwSize.X - cr.X > n1)\n+\t    cr.X += n1;\n+\t  else\n+\t    cr.X = sb.dwSize.X;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'D'\n+\t Move the cursor left by n1 characters.  */\n+    case MAKEWORD ('[', 'D'):\n+      if (esc_head == esc_term)\n+\tn1 = 1;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  /* Stop at the leftmost boundary.  */\n+\t  if (cr.X > n1)\n+\t    cr.X -= n1;\n+\t  else\n+\t    cr.X = 0;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'E'\n+\t Move the cursor to the beginning of the n1-th line downwards.  */\n+    case MAKEWORD ('[', 'E'):\n+      if (esc_head == esc_term)\n+\tn1 = 1;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  cr.X = 0;\n+\t  /* Stop at the bottommost boundary.  */\n+\t  if (sb.dwSize.Y - cr.Y > n1)\n+\t    cr.Y += n1;\n+\t  else\n+\t    cr.Y = sb.dwSize.Y;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'F'\n+\t Move the cursor to the beginning of the n1-th line upwards.  */\n+    case MAKEWORD ('[', 'F'):\n+      if (esc_head == esc_term)\n+\tn1 = 1;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  cr.X = 0;\n+\t  /* Stop at the topmost boundary.  */\n+\t  if (cr.Y > n1)\n+\t    cr.Y -= n1;\n+\t  else\n+\t    cr.Y = 0;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'G'\n+\t Move the cursor to the (1-based) n1-th column.  */\n+    case MAKEWORD ('[', 'G'):\n+      if (esc_head == esc_term)\n+\tn1 = 1;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  n1 -= 1;\n+\t  /* Stop at the leftmost or rightmost boundary.  */\n+\t  if (n1 < 0)\n+\t    cr.X = 0;\n+\t  else if (n1 > sb.dwSize.X)\n+\t    cr.X = sb.dwSize.X;\n+\t  else\n+\t    cr.X = n1;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 ';' n2 'H'\n+       ESC [ n1 ';' n2 'f'\n+\t Move the cursor to the (1-based) n1-th row and\n+\t (also 1-based) n2-th column.  */\n+    case MAKEWORD ('[', 'H'):\n+    case MAKEWORD ('[', 'f'):\n+      if (esc_head == esc_term)\n+\t{\n+\t  /* Both parameters are omitted and set to 1 by default.  */\n+\t  n1 = 1;\n+\t  n2 = 1;\n+\t}\n+      else if (!(delim = (char *) memchr (esc_head, ';',\n+\t\t\t\t\t  esc_term - esc_head)))\n+\t{\n+\t  /* Only the first parameter is given.  The second one is\n+\t     set to 1 by default.  */\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t  n2 = 1;\n+\t}\n+      else\n+\t{\n+\t  /* Both parameters are given.  The first one shall be\n+\t     terminated by the semicolon.  */\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != delim)\n+\t    break;\n+\t  n2 = strtol (delim + 1, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  cr = sb.dwCursorPosition;\n+\t  n1 -= 1;\n+\t  n2 -= 1;\n+\t  /* The cursor position shall be relative to the view coord of\n+\t     the console window, which is usually smaller than the actual\n+\t     buffer.  FWIW, the 'appropriate' solution will be shrinking\n+\t     the buffer to match the size of the console window,\n+\t     destroying scrollback in the process.  */\n+\t  n1 += sb.srWindow.Top;\n+\t  n2 += sb.srWindow.Left;\n+\t  /* Stop at the topmost or bottommost boundary.  */\n+\t  if (n1 < 0)\n+\t    cr.Y = 0;\n+\t  else if (n1 > sb.dwSize.Y)\n+\t    cr.Y = sb.dwSize.Y;\n+\t  else\n+\t    cr.Y = n1;\n+\t  /* Stop at the leftmost or rightmost boundary.  */\n+\t  if (n2 < 0)\n+\t    cr.X = 0;\n+\t  else if (n2 > sb.dwSize.X)\n+\t    cr.X = sb.dwSize.X;\n+\t  else\n+\t    cr.X = n2;\n+\t  SetConsoleCursorPosition (h, cr);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'J'\n+\t Erase display.  */\n+    case MAKEWORD ('[', 'J'):\n+      if (esc_head == esc_term)\n+\t/* This is one of the very few codes whose parameters have\n+\t   a default value of zero.  */\n+\tn1 = 0;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  /* The cursor is not necessarily in the console window, which\n+\t     makes the behavior of this code harder to define.  */\n+\t  switch (n1)\n+\t    {\n+\t    case 0:\n+\t      /* If the cursor is in or above the window, erase from\n+\t\t it to the bottom of the window; otherwise, do nothing.  */\n+\t      cr = sb.dwCursorPosition;\n+\t      cnt = sb.dwSize.X - sb.dwCursorPosition.X;\n+\t      rows = sb.srWindow.Bottom - sb.dwCursorPosition.Y;\n+\t      break;\n+\t    case 1:\n+\t      /* If the cursor is in or under the window, erase from\n+\t\t it to the top of the window; otherwise, do nothing.  */\n+\t      cr.X = 0;\n+\t      cr.Y = sb.srWindow.Top;\n+\t      cnt = sb.dwCursorPosition.X + 1;\n+\t      rows = sb.dwCursorPosition.Y - sb.srWindow.Top;\n+\t      break;\n+\t    case 2:\n+\t      /* Erase the entire window.  */\n+\t      cr.X = sb.srWindow.Left;\n+\t      cr.Y = sb.srWindow.Top;\n+\t      cnt = 0;\n+\t      rows = sb.srWindow.Bottom - sb.srWindow.Top + 1;\n+\t      break;\n+\t    default:\n+\t      /* Erase the entire buffer.  */\n+\t      cr.X = 0;\n+\t      cr.Y = 0;\n+\t      cnt = 0;\n+\t      rows = sb.dwSize.Y;\n+\t      break;\n+\t    }\n+\t  if (rows < 0)\n+\t    break;\n+\t  cnt += rows * sb.dwSize.X;\n+\t  FillConsoleOutputCharacterW (h, L' ', cnt, cr, &step);\n+\t  FillConsoleOutputAttribute (h, sb.wAttributes, cnt, cr, &step);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 'K'\n+\t Erase line.  */\n+    case MAKEWORD ('[', 'K'):\n+      if (esc_head == esc_term)\n+\t/* This is one of the very few codes whose parameters have\n+\t   a default value of zero.  */\n+\tn1 = 0;\n+      else\n+\t{\n+\t  n1 = strtol (esc_head, &eptr, 10);\n+\t  if (eptr != esc_term)\n+\t    break;\n+\t}\n+\n+      if (GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  switch (n1)\n+\t    {\n+\t    case 0:\n+\t      /* Erase from the cursor to the end.  */\n+\t      cr = sb.dwCursorPosition;\n+\t      cnt = sb.dwSize.X - sb.dwCursorPosition.X;\n+\t      break;\n+\t    case 1:\n+\t      /* Erase from the cursor to the beginning.  */\n+\t      cr = sb.dwCursorPosition;\n+\t      cr.X = 0;\n+\t      cnt = sb.dwCursorPosition.X + 1;\n+\t      break;\n+\t    default:\n+\t      /* Erase the entire line.  */\n+\t      cr = sb.dwCursorPosition;\n+\t      cr.X = 0;\n+\t      cnt = sb.dwSize.X;\n+\t      break;\n+\t    }\n+\t  FillConsoleOutputCharacterW (h, L' ', cnt, cr, &step);\n+\t  FillConsoleOutputAttribute (h, sb.wAttributes, cnt, cr, &step);\n+\t}\n+      break;\n+\n+    /* ESC [ n1 ';' n2 'm'\n+\t Set SGR parameters.  Zero or more parameters will follow.  */\n+    case MAKEWORD ('[', 'm'):\n+      attrib_add = 0;\n+      attrib_rm = 0;\n+      if (esc_head == esc_term)\n+\t{\n+\t  /* When no parameter is given, reset the console.  */\n+\t  attrib_add |= (FOREGROUND_RED | FOREGROUND_GREEN\n+\t\t\t | FOREGROUND_BLUE);\n+\t  attrib_rm = -1; /* Removes everything.  */\n+\t  goto sgr_set_it;\n+\t}\n+      param = esc_head;\n+      do\n+\t{\n+\t  /* Parse a parameter.  */\n+\t  n1 = strtol (param, &eptr, 10);\n+\t  if (*eptr != ';' && eptr != esc_term)\n+\t    goto sgr_set_it;\n+\n+\t  switch (n1)\n+\t    {\n+\t    case 0:\n+\t      /* Reset.  */\n+\t      attrib_add |= (FOREGROUND_RED | FOREGROUND_GREEN\n+\t\t\t     | FOREGROUND_BLUE);\n+\t      attrib_rm = -1; /* Removes everything.  */\n+\t      break;\n+\t    case 1:\n+\t      /* Bold.  */\n+\t      attrib_add |= FOREGROUND_INTENSITY;\n+\t      break;\n+\t    case 4:\n+\t      /* Underline.  */\n+\t      attrib_add |= COMMON_LVB_UNDERSCORE;\n+\t      break;\n+\t    case 5:\n+\t      /* Blink.  */\n+\t      /* XXX: It is not BLINKING at all! */\n+\t      attrib_add |= BACKGROUND_INTENSITY;\n+\t      break;\n+\t    case 7:\n+\t      /* Reverse.  */\n+\t      attrib_add |= COMMON_LVB_REVERSE_VIDEO;\n+\t      break;\n+\t    case 22:\n+\t      /* No bold.  */\n+\t      attrib_add &= ~FOREGROUND_INTENSITY;\n+\t      attrib_rm |= FOREGROUND_INTENSITY;\n+\t      break;\n+\t    case 24:\n+\t      /* No underline.  */\n+\t      attrib_add &= ~COMMON_LVB_UNDERSCORE;\n+\t      attrib_rm |= COMMON_LVB_UNDERSCORE;\n+\t      break;\n+\t    case 25:\n+\t      /* No blink.  */\n+\t      /* XXX: It is not BLINKING at all! */\n+\t      attrib_add &= ~BACKGROUND_INTENSITY;\n+\t      attrib_rm |= BACKGROUND_INTENSITY;\n+\t      break;\n+\t    case 27:\n+\t      /* No reverse.  */\n+\t      attrib_add &= ~COMMON_LVB_REVERSE_VIDEO;\n+\t      attrib_rm |= COMMON_LVB_REVERSE_VIDEO;\n+\t      break;\n+\t    case 30:\n+\t    case 31:\n+\t    case 32:\n+\t    case 33:\n+\t    case 34:\n+\t    case 35:\n+\t    case 36:\n+\t    case 37:\n+\t      /* Foreground color.  */\n+\t      attrib_add &= ~(FOREGROUND_RED | FOREGROUND_GREEN\n+\t\t\t      | FOREGROUND_BLUE);\n+\t      n1 -= 30;\n+\t      if (n1 & 1)\n+\t\tattrib_add |= FOREGROUND_RED;\n+\t      if (n1 & 2)\n+\t\tattrib_add |= FOREGROUND_GREEN;\n+\t      if (n1 & 4)\n+\t\tattrib_add |= FOREGROUND_BLUE;\n+\t      attrib_rm |= (FOREGROUND_RED | FOREGROUND_GREEN\n+\t\t\t    | FOREGROUND_BLUE);\n+\t      break;\n+\t    case 38:\n+\t      /* Reserved for extended foreground color.\n+\t\t Don't know how to handle parameters remaining.\n+\t\t Bail out.  */\n+\t      goto sgr_set_it;\n+\t    case 39:\n+\t      /* Reset foreground color.  */\n+\t      /* Set to grey.  */\n+\t      attrib_add |= (FOREGROUND_RED | FOREGROUND_GREEN\n+\t\t\t     | FOREGROUND_BLUE);\n+\t      attrib_rm |= (FOREGROUND_RED | FOREGROUND_GREEN\n+\t\t\t    | FOREGROUND_BLUE);\n+\t      break;\n+\t    case 40:\n+\t    case 41:\n+\t    case 42:\n+\t    case 43:\n+\t    case 44:\n+\t    case 45:\n+\t    case 46:\n+\t    case 47:\n+\t      /* Background color.  */\n+\t      attrib_add &= ~(BACKGROUND_RED | BACKGROUND_GREEN\n+\t\t\t      | BACKGROUND_BLUE);\n+\t      n1 -= 40;\n+\t      if (n1 & 1)\n+\t\tattrib_add |= BACKGROUND_RED;\n+\t      if (n1 & 2)\n+\t\tattrib_add |= BACKGROUND_GREEN;\n+\t      if (n1 & 4)\n+\t\tattrib_add |= BACKGROUND_BLUE;\n+\t      attrib_rm |= (BACKGROUND_RED | BACKGROUND_GREEN\n+\t\t\t    | BACKGROUND_BLUE);\n+\t      break;\n+\t    case 48:\n+\t      /* Reserved for extended background color.\n+\t\t Don't know how to handle parameters remaining.\n+\t\t Bail out.  */\n+\t      goto sgr_set_it;\n+\t    case 49:\n+\t      /* Reset background color.  */\n+\t      /* Set to black.  */\n+\t      attrib_add &= ~(BACKGROUND_RED | BACKGROUND_GREEN\n+\t\t\t      | BACKGROUND_BLUE);\n+\t      attrib_rm |= (BACKGROUND_RED | BACKGROUND_GREEN\n+\t\t\t    | BACKGROUND_BLUE);\n+\t      break;\n+\t    }\n+\n+\t  /* Prepare the next parameter.  */\n+\t  param = eptr + 1;\n+\t}\n+      while (param != esc_term);\n+\n+sgr_set_it:\n+      /* 0xFFFF removes everything.  If it is not the case,\n+\t care must be taken to preserve old attributes.  */\n+      if (attrib_rm != 0xFFFF && GetConsoleScreenBufferInfo (h, &sb))\n+\t{\n+\t  attrib_add |= sb.wAttributes & ~attrib_rm;\n+\t}\n+      SetConsoleTextAttribute (h, attrib_add);\n+      break;\n+    }\n+}\n+\n+int\n+mingw_ansi_fputs (const char *str, FILE *fp)\n+{\n+  const char *read = str;\n+  HANDLE h;\n+  DWORD mode;\n+  int esc_code, prefix_len;\n+  const char *esc_head, *esc_term;\n+\n+  h = (HANDLE) _get_osfhandle (_fileno (fp));\n+  if (h == INVALID_HANDLE_VALUE)\n+    return EOF;\n+\n+  /* Don't mess up stdio functions with Windows APIs.  */\n+  fflush (fp);\n+\n+  if (GetConsoleMode (h, &mode))\n+    /* If it is a console, translate ANSI escape codes as needed.  */\n+    for (;;)\n+      {\n+\tif ((esc_code = find_esc_head (&prefix_len, &esc_head, read)) == 0)\n+\t  {\n+\t    /* Write all remaining characters, then exit.  */\n+\t    write_all (h, read, strlen (read));\n+\t    break;\n+\t  }\n+\tif (find_esc_terminator (&esc_term, esc_head) == 0)\n+\t  /* Ignore incomplete escape sequences at the moment.\n+\t     FIXME: The escape state shall be cached for further calls\n+\t\t    to this function.  */\n+\t  break;\n+\twrite_all (h, read, esc_head - prefix_len - read);\n+\teat_esc_sequence (h, esc_code, esc_head, esc_term);\n+\tread = esc_term + 1;\n+      }\n+  else\n+    /* If it is not a console, write everything as-is.  */\n+    write_all (h, read, strlen (read));\n+\n+  _close ((intptr_t) h);\n+  return 1;\n+}\n+\n+#endif /* __MINGW32__ */\n+\n static void pp_quoted_string (pretty_printer *, const char *, size_t = -1);\n \n /* Overwrite the given location/range within this text_info's rich_location.\n@@ -140,7 +800,11 @@ void\n pp_write_text_to_stream (pretty_printer *pp)\n {\n   const char *text = pp_formatted_text (pp);\n+#ifdef __MINGW32__\n+  mingw_ansi_fputs (text, pp_buffer (pp)->stream);\n+#else\n   fputs (text, pp_buffer (pp)->stream);\n+#endif\n   pp_clear_output_area (pp);\n }\n "}]}