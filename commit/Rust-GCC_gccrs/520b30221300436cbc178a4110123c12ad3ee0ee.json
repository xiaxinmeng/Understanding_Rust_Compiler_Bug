{"sha": "520b30221300436cbc178a4110123c12ad3ee0ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwYjMwMjIxMzAwNDM2Y2JjMTc4YTQxMTAxMjNjMTJhZDNlZTBlZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-01-09T10:45:18Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-01-09T10:45:18Z"}, "message": "IPA ICF: compare_operand is split to multiple functions.\n\n\t* ipa-icf-gimple.c (func_checker::compare_ssa_name): Enhance SSA\n\tname comparison.\n\t(func_checker::compare_memory_operand): New function.\n\t(func_checker::compare_operand): Split case to newly\n\tadded functions.\n\t(func_checker::compare_cst_or_decl): New function.\n\t(func_checker::compare_gimple_call): Identify\n\tmemory operands.\n\t(func_checker::compare_gimple_assign): Likewise.\n\t* ipa-icf-gimple.h: New function.\n\nFrom-SVN: r219379", "tree": {"sha": "796989ae907b8f48345b88fac0d7067a42ea2c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/796989ae907b8f48345b88fac0d7067a42ea2c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520b30221300436cbc178a4110123c12ad3ee0ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520b30221300436cbc178a4110123c12ad3ee0ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520b30221300436cbc178a4110123c12ad3ee0ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520b30221300436cbc178a4110123c12ad3ee0ee/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce9401b43fd971f49db251a56f5a32c68de803a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce9401b43fd971f49db251a56f5a32c68de803a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce9401b43fd971f49db251a56f5a32c68de803a2"}], "stats": {"total": 269, "additions": 159, "deletions": 110}, "files": [{"sha": "ffea916db29ab77270615ab1d93a0c52ba70911c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520b30221300436cbc178a4110123c12ad3ee0ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520b30221300436cbc178a4110123c12ad3ee0ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=520b30221300436cbc178a4110123c12ad3ee0ee", "patch": "@@ -1,3 +1,16 @@\n+2015-01-09  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf-gimple.c (func_checker::compare_ssa_name): Enhance SSA\n+\tname comparison.\n+\t(func_checker::compare_memory_operand): New function.\n+\t(func_checker::compare_operand): Split case to newly\n+\tadded functions.\n+\t(func_checker::compare_cst_or_decl): New function.\n+\t(func_checker::compare_gimple_call): Identify\n+\tmemory operands.\n+\t(func_checker::compare_gimple_assign): Likewise.\n+\t* ipa-icf-gimple.h: New function.\n+\n 2015-01-09  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/64503"}, {"sha": "9cb7bc33808517f75d169143ad276423dc09f39f", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 138, "deletions": 109, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520b30221300436cbc178a4110123c12ad3ee0ee/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520b30221300436cbc178a4110123c12ad3ee0ee/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=520b30221300436cbc178a4110123c12ad3ee0ee", "patch": "@@ -110,6 +110,9 @@ func_checker::~func_checker ()\n bool\n func_checker::compare_ssa_name (tree t1, tree t2)\n {\n+  gcc_assert (TREE_CODE (t1) == SSA_NAME);\n+  gcc_assert (TREE_CODE (t2) == SSA_NAME);\n+\n   unsigned i1 = SSA_NAME_VERSION (t1);\n   unsigned i2 = SSA_NAME_VERSION (t2);\n \n@@ -123,6 +126,20 @@ func_checker::compare_ssa_name (tree t1, tree t2)\n   else if (m_target_ssa_names[i2] != (int) i1)\n     return false;\n \n+  if (SSA_NAME_IS_DEFAULT_DEF (t1))\n+    {\n+      tree b1 = SSA_NAME_VAR (t1);\n+      tree b2 = SSA_NAME_VAR (t2);\n+\n+      if (b1 == NULL && b2 == NULL)\n+\treturn true;\n+\n+      if (b1 == NULL || b2 == NULL || TREE_CODE (b1) != TREE_CODE (b2))\n+\treturn return_false ();\n+\n+      return compare_cst_or_decl (b1, b2);\n+    }\n+\n   return true;\n }\n \n@@ -178,9 +195,10 @@ func_checker::compare_decl (tree t1, tree t2)\n }\n \n /* Return true if types are compatible from perspective of ICF.  */\n-bool func_checker::compatible_types_p (tree t1, tree t2,\n-\t\t\t\t       bool compare_polymorphic,\n-\t\t\t\t       bool first_argument)\n+bool\n+func_checker::compatible_types_p (tree t1, tree t2,\n+\t\t\t\t  bool compare_polymorphic,\n+\t\t\t\t  bool first_argument)\n {\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return return_false_with_msg (\"different tree types\");\n@@ -214,15 +232,112 @@ bool func_checker::compatible_types_p (tree t1, tree t2,\n   return true;\n }\n \n-/* Function responsible for comparison of handled components T1 and T2.\n+/* Function compare for equality given memory operands T1 and T2.  */\n+\n+bool\n+func_checker::compare_memory_operand (tree t1, tree t2)\n+{\n+  if (!t1 && !t2)\n+    return true;\n+  else if (!t1 || !t2)\n+    return false;\n+\n+  ao_ref r1, r2;\n+  ao_ref_init (&r1, t1);\n+  ao_ref_init (&r2, t2);\n+\n+  tree b1 = ao_ref_base (&r1);\n+  tree b2 = ao_ref_base (&r2);\n+\n+  bool source_is_memop = DECL_P (b1) || INDIRECT_REF_P (b1)\n+\t\t\t || TREE_CODE (b1) == MEM_REF\n+\t\t\t || TREE_CODE (b1) == TARGET_MEM_REF;\n+\n+  bool target_is_memop = DECL_P (b2) || INDIRECT_REF_P (b2)\n+\t\t\t || TREE_CODE (b2) == MEM_REF\n+\t\t\t || TREE_CODE (b2) == TARGET_MEM_REF;\n+\n+  /* Compare alias sets for memory operands.  */\n+  if (source_is_memop && target_is_memop)\n+    {\n+      if (TREE_THIS_VOLATILE (b1) != TREE_THIS_VOLATILE (b2))\n+\treturn return_false_with_msg (\"different operand volatility\");\n+\n+      if (ao_ref_alias_set (&r1) != ao_ref_alias_set (&r2)\n+\t  || ao_ref_base_alias_set (&r1) != ao_ref_base_alias_set (&r2))\n+\treturn return_false_with_msg (\"ao alias sets are different\");\n+    }\n+\n+  return compare_operand (t1, t2);\n+}\n+\n+/* Function compare for equality given trees T1 and T2 which\n+   can be either a constant or a declaration type.  */\n+\n+bool\n+func_checker::compare_cst_or_decl (tree t1, tree t2)\n+{\n+  bool ret;\n+\n+  switch (TREE_CODE (t1))\n+    {\n+    case INTEGER_CST:\n+    case COMPLEX_CST:\n+    case VECTOR_CST:\n+    case STRING_CST:\n+    case REAL_CST:\n+      {\n+\tret = compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t      && operand_equal_p (t1, t2, OEP_ONLY_CONST);\n+\treturn return_with_debug (ret);\n+      }\n+    case FUNCTION_DECL:\n+      {\n+\tret = compare_function_decl (t1, t2);\n+\treturn return_with_debug (ret);\n+      }\n+    case VAR_DECL:\n+      return return_with_debug (compare_variable_decl (t1, t2));\n+    case FIELD_DECL:\n+      {\n+\ttree offset1 = DECL_FIELD_OFFSET (t1);\n+\ttree offset2 = DECL_FIELD_OFFSET (t2);\n+\n+\ttree bit_offset1 = DECL_FIELD_BIT_OFFSET (t1);\n+\ttree bit_offset2 = DECL_FIELD_BIT_OFFSET (t2);\n+\n+\tret = compare_operand (offset1, offset2)\n+\t      && compare_operand (bit_offset1, bit_offset2);\n+\n+\treturn return_with_debug (ret);\n+      }\n+    case LABEL_DECL:\n+      {\n+\tint *bb1 = m_label_bb_map.get (t1);\n+\tint *bb2 = m_label_bb_map.get (t2);\n+\n+\treturn return_with_debug (*bb1 == *bb2);\n+      }\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case CONST_DECL:\n+      {\n+\tret = compare_decl (t1, t2);\n+\treturn return_with_debug (ret);\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Function responsible for comparison of various operands T1 and T2.\n    If these components, from functions FUNC1 and FUNC2, are equal, true\n    is returned.  */\n \n bool\n func_checker::compare_operand (tree t1, tree t2)\n {\n-  tree base1, base2, x1, x2, y1, y2, z1, z2;\n-  HOST_WIDE_INT offset1 = 0, offset2 = 0;\n+  tree x1, x2, y1, y2, z1, z2;\n   bool ret;\n \n   if (!t1 && !t2)\n@@ -233,24 +348,9 @@ func_checker::compare_operand (tree t1, tree t2)\n   tree tt1 = TREE_TYPE (t1);\n   tree tt2 = TREE_TYPE (t2);\n \n-  if (TREE_THIS_VOLATILE (t1) != TREE_THIS_VOLATILE (t2))\n-    return return_false_with_msg (\"different operand volatility\");\n-\n   if (!func_checker::compatible_types_p (tt1, tt2))\n     return false;\n \n-  base1 = get_addr_base_and_unit_offset (t1, &offset1);\n-  base2 = get_addr_base_and_unit_offset (t2, &offset2);\n-\n-  if (base1 && base2)\n-    {\n-      if (offset1 != offset2)\n-\treturn return_false_with_msg (\"base offsets are different\");\n-\n-      t1 = base1;\n-      t2 = base2;\n-    }\n-\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n     return return_false ();\n \n@@ -273,6 +373,7 @@ func_checker::compare_operand (tree t1, tree t2)\n       }\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n+      /* First argument is the array, second is the index.  */\n       x1 = TREE_OPERAND (t1, 0);\n       x2 = TREE_OPERAND (t2, 0);\n       y1 = TREE_OPERAND (t1, 1);\n@@ -284,6 +385,7 @@ func_checker::compare_operand (tree t1, tree t2)\n       if (!compare_operand (array_ref_element_size (t1),\n \t\t\t    array_ref_element_size (t2)))\n \treturn return_false_with_msg (\"\");\n+\n       if (!compare_operand (x1, x2))\n \treturn return_false_with_msg (\"\");\n       return compare_operand (y1, y2);\n@@ -308,16 +410,6 @@ func_checker::compare_operand (tree t1, tree t2)\n \tif (!compare_operand (x1, x2))\n \t  return return_false_with_msg (\"\");\n \n-\tif (get_alias_set (TREE_TYPE (y1)) != get_alias_set (TREE_TYPE (y2)))\n-\t  return return_false_with_msg (\"alias set for MEM_REF offsets are different\");\n-\n-\tao_ref r1, r2;\n-\tao_ref_init (&r1, t1);\n-\tao_ref_init (&r2, t2);\n-\tif (ao_ref_alias_set (&r1) != ao_ref_alias_set (&r2)\n-\t    || ao_ref_base_alias_set (&r1) != ao_ref_base_alias_set (&r2))\n-\t  return return_false_with_msg (\"ao alias sets are different\");\n-\n \t/* Type of the offset on MEM_REF does not matter.  */\n \treturn wi::to_offset  (y1) == wi::to_offset  (y2);\n       }\n@@ -329,7 +421,7 @@ func_checker::compare_operand (tree t1, tree t2)\n \ty2 = TREE_OPERAND (t2, 1);\n \n \tret = compare_operand (x1, x2)\n-\t      && compare_operand (y1, y2);\n+\t      && compare_cst_or_decl (y1, y2);\n \n \treturn return_with_debug (ret);\n       }\n@@ -343,9 +435,9 @@ func_checker::compare_operand (tree t1, tree t2)\n \tz1 = TREE_OPERAND (t1, 2);\n \tz2 = TREE_OPERAND (t2, 2);\n \n-\tret = compare_operand (x1, x2)\n-\t      && compare_operand (y1, y2)\n-\t      && compare_operand (z1, z2);\n+\tret = compare_ssa_name (x1, x2)\n+\t      && compare_ssa_name (y1, y2)\n+\t      && compare_cst_or_decl (z1, z2);\n \n \treturn return_with_debug (ret);\n       }\n@@ -357,89 +449,26 @@ func_checker::compare_operand (tree t1, tree t2)\n \tret = compare_operand (x1, x2);\n \treturn return_with_debug (ret);\n       }\n-    case SSA_NAME:\n-      {\n-\tret = compare_ssa_name (t1, t2);\n-\n-\tif (!ret)\n-\t  return return_with_debug (ret);\n-\n-\tif (SSA_NAME_IS_DEFAULT_DEF (t1))\n-\t  {\n-\t    tree b1 = SSA_NAME_VAR (t1);\n-\t    tree b2 = SSA_NAME_VAR (t2);\n-\n-\t    if (b1 == NULL && b2 == NULL)\n-\t      return true;\n-\n-\t    if (b1 == NULL || b2 == NULL || TREE_CODE (b1) != TREE_CODE (b2))\n-\t      return return_false ();\n-\n-\t    switch (TREE_CODE (b1))\n-\t      {\n-\t      case VAR_DECL:\n-\t\treturn return_with_debug (compare_variable_decl (t1, t2));\n-\t      case PARM_DECL:\n-\t      case RESULT_DECL:\n-\t\tret = compare_decl (b1, b2);\n-\t\treturn return_with_debug (ret);\n-\t      default:\n-\t\treturn return_false_with_msg (\"Unknown TREE code reached\");\n-\t      }\n-\t  }\n-\telse\n-\t  return true;\n-      }\n-    case INTEGER_CST:\n+    case BIT_FIELD_REF:\n       {\n-\tret = compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t      && wi::to_offset  (t1) == wi::to_offset  (t2);\n-\n+\tret = compare_decl (t1, t2);\n \treturn return_with_debug (ret);\n       }\n+    case SSA_NAME:\n+\treturn compare_ssa_name (t1, t2);\n+    case INTEGER_CST:\n     case COMPLEX_CST:\n     case VECTOR_CST:\n     case STRING_CST:\n     case REAL_CST:\n-      {\n-\tret = operand_equal_p (t1, t2, OEP_ONLY_CONST);\n-\treturn return_with_debug (ret);\n-      }\n     case FUNCTION_DECL:\n-      {\n-\tret = compare_function_decl (t1, t2);\n-\treturn return_with_debug (ret);\n-      }\n     case VAR_DECL:\n-      return return_with_debug (compare_variable_decl (t1, t2));\n     case FIELD_DECL:\n-      {\n-\ttree offset1 = DECL_FIELD_OFFSET (t1);\n-\ttree offset2 = DECL_FIELD_OFFSET (t2);\n-\n-\ttree bit_offset1 = DECL_FIELD_BIT_OFFSET (t1);\n-\ttree bit_offset2 = DECL_FIELD_BIT_OFFSET (t2);\n-\n-\tret = compare_operand (offset1, offset2)\n-\t      && compare_operand (bit_offset1, bit_offset2);\n-\n-\treturn return_with_debug (ret);\n-      }\n     case LABEL_DECL:\n-      {\n-\tint *bb1 = m_label_bb_map.get (t1);\n-\tint *bb2 = m_label_bb_map.get (t2);\n-\n-\treturn return_with_debug (*bb1 == *bb2);\n-      }\n     case PARM_DECL:\n     case RESULT_DECL:\n     case CONST_DECL:\n-    case BIT_FIELD_REF:\n-      {\n-\tret = compare_decl (t1, t2);\n-\treturn return_with_debug (ret);\n-      }\n+      return compare_cst_or_decl (t1, t2);\n     default:\n       return return_false_with_msg (\"Unknown TREE code reached\");\n     }\n@@ -706,15 +735,15 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n       t1 = gimple_call_arg (s1, i);\n       t2 = gimple_call_arg (s2, i);\n \n-      if (!compare_operand (t1, t2))\n-\treturn false;\n+      if (!compare_memory_operand (t1, t2))\n+\treturn return_false_with_msg (\"memory operands are different\");\n     }\n \n   /* Return value checking.  */\n   t1 = gimple_get_lhs (s1);\n   t2 = gimple_get_lhs (s2);\n \n-  return compare_operand (t1, t2);\n+  return compare_memory_operand (t1, t2);\n }\n \n \n@@ -745,8 +774,8 @@ func_checker::compare_gimple_assign (gimple s1, gimple s2)\n       arg1 = gimple_op (s1, i);\n       arg2 = gimple_op (s2, i);\n \n-      if (!compare_operand (arg1, arg2))\n-\treturn false;\n+      if (!compare_memory_operand (arg1, arg2))\n+\treturn return_false_with_msg (\"memory operands are different\");\n     }\n \n "}, {"sha": "a52f8c33c9ac98a38a34297fa9bc2f849c457274", "filename": "gcc/ipa-icf-gimple.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520b30221300436cbc178a4110123c12ad3ee0ee/gcc%2Fipa-icf-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520b30221300436cbc178a4110123c12ad3ee0ee/gcc%2Fipa-icf-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.h?ref=520b30221300436cbc178a4110123c12ad3ee0ee", "patch": "@@ -203,7 +203,14 @@ class func_checker\n   /* Verifies that tree labels T1 and T2 correspond.  */\n   bool compare_tree_ssa_label (tree t1, tree t2);\n \n-  /* Function responsible for comparison of handled components T1 and T2.\n+  /* Function compare for equality given memory operands T1 and T2.  */\n+  bool compare_memory_operand (tree t1, tree t2);\n+\n+  /* Function compare for equality given trees T1 and T2 which\n+     can be either a constant or a declaration type.  */\n+  bool compare_cst_or_decl (tree t1, tree t2);\n+\n+  /* Function responsible for comparison of various operands T1 and T2.\n      If these components, from functions FUNC1 and FUNC2, are equal, true\n      is returned.  */\n   bool compare_operand (tree t1, tree t2);"}]}