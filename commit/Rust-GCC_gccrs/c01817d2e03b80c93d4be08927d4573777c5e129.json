{"sha": "c01817d2e03b80c93d4be08927d4573777c5e129", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxODE3ZDJlMDNiODBjOTNkNGJlMDg5MjdkNDU3Mzc3N2M1ZTEyOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T13:41:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T13:41:24Z"}, "message": "[multiple changes]\n\n2011-08-30  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Add_Internal_Interface_Entities): If serious errors have\n\tbeen reported and a subprogram covering an interface primitive is not\n\tfound then skip generating the internal entity. Done to avoid crashing\n\tthe frontend.\n\t(Check_Abstract_Overriding): Change text of error of wrong formal of\n\tprotected subprogram or entry. Done for consistency to emit exactly the\n\tsame error reported by Check_Synchronized_Overriding. In addition, the\n\terror is restricted to protected types (bug found working on AI05-0090)\n\n2011-08-30  Yannick Moy  <moy@adacore.com>\n\n\t* exp_aggr.adb, exp_ch11.adb, exp_prag.adb: Remove early exit during\n\texpansion in Alfa mode.\n\t* exp_ch6.adb, exp_ch6.ads (Expand_Actuals): Make subprogram public.\n\t* exp_light.adb, exp_light.ads: New package defining light expansion.\n\t* expander.adb (Expand): Call light expansion in Alfa mode\n\t* exp_ch6_light.adb, exp_ch6_light.ads: Light expansion of chapter 6\n\tconstructs.\n\t* exp_ch7_light.adb, exp_ch7_light.ads: Light expansion of chapter 7\n\tconstructs.\n\t* exp_attr_light.adb, exp_attr_light.ads: Light expansion of attributes\n\t* gnat1drv.adb (Adjust_Global_Switches): Comment\n\n2011-08-30  Yannick Moy  <moy@adacore.com>\n\n\t* lib-xref-alfa.adb: Minor refactoring.\n\n2011-08-30  Yannick Moy  <moy@adacore.com>\n\n\t* exp_ch9.adb (Expand_Entry_Barrier): Do not perform expansion in Alfa\n\tmode.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Do not perform\n\texpansion in Alfa mode.\n\t* sem_ch9.adb (Analyze_Entry_Body): Do not perform expansion in Alfa\n\tmode.\n\n2011-08-30  Robert Dewar  <dewar@adacore.com>\n\n\t* debug_a.adb: Update comment.\n\nFrom-SVN: r178304", "tree": {"sha": "1880ea83ac066801135cc69321359f40a3523cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1880ea83ac066801135cc69321359f40a3523cb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01817d2e03b80c93d4be08927d4573777c5e129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01817d2e03b80c93d4be08927d4573777c5e129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01817d2e03b80c93d4be08927d4573777c5e129", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01817d2e03b80c93d4be08927d4573777c5e129/comments", "author": null, "committer": null, "parents": [{"sha": "996c8821a235a2313d3574d0815044847f7b5c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996c8821a235a2313d3574d0815044847f7b5c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996c8821a235a2313d3574d0815044847f7b5c14"}], "stats": {"total": 1104, "additions": 832, "deletions": 272}, "files": [{"sha": "ae4edc39f926dbbc40c0f4f5030b0416a0e491d0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -1,3 +1,45 @@\n+2011-08-30  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Add_Internal_Interface_Entities): If serious errors have\n+\tbeen reported and a subprogram covering an interface primitive is not\n+\tfound then skip generating the internal entity. Done to avoid crashing\n+\tthe frontend.\n+\t(Check_Abstract_Overriding): Change text of error of wrong formal of\n+\tprotected subprogram or entry. Done for consistency to emit exactly the\n+\tsame error reported by Check_Synchronized_Overriding. In addition, the\n+\terror is restricted to protected types (bug found working on AI05-0090)\n+\n+2011-08-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_aggr.adb, exp_ch11.adb, exp_prag.adb: Remove early exit during\n+\texpansion in Alfa mode.\n+\t* exp_ch6.adb, exp_ch6.ads (Expand_Actuals): Make subprogram public.\n+\t* exp_light.adb, exp_light.ads: New package defining light expansion.\n+\t* expander.adb (Expand): Call light expansion in Alfa mode\n+\t* exp_ch6_light.adb, exp_ch6_light.ads: Light expansion of chapter 6\n+\tconstructs.\n+\t* exp_ch7_light.adb, exp_ch7_light.ads: Light expansion of chapter 7\n+\tconstructs.\n+\t* exp_attr_light.adb, exp_attr_light.ads: Light expansion of attributes\n+\t* gnat1drv.adb (Adjust_Global_Switches): Comment\n+\n+2011-08-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-xref-alfa.adb: Minor refactoring.\n+\n+2011-08-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_ch9.adb (Expand_Entry_Barrier): Do not perform expansion in Alfa\n+\tmode.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Do not perform\n+\texpansion in Alfa mode.\n+\t* sem_ch9.adb (Analyze_Entry_Body): Do not perform expansion in Alfa\n+\tmode.\n+\n+2011-08-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug_a.adb: Update comment.\n+\n 2011-08-30  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch5.adb, sem_ch3.adb, sem_ch5.adb, einfo.adb, checks.adb,"}, {"sha": "43455b910d9d5a89bb816cbab2a7f1e80630d70c", "filename": "gcc/ada/debug_a.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fdebug_a.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fdebug_a.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug_a.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,6 +75,8 @@ package body Debug_A is\n \n       --  Now push the new element\n \n+      --  Why is this done unconditionally???\n+\n       Debug_A_Depth := Debug_A_Depth + 1;\n \n       if Debug_A_Depth <= Max_Node_Ids then\n@@ -101,6 +103,8 @@ package body Debug_A is\n       --  We look down the stack to find something with a decent Sloc. (If\n       --  we find nothing, just leave it unchanged which is not so terrible)\n \n+      --  This seems nasty overhead for the normal case ???\n+\n       for J in reverse 1 .. Integer'Min (Max_Node_Ids, Debug_A_Depth) loop\n          if Sloc (Node_Ids (J)) > No_Location then\n             Current_Error_Node := Node_Ids (J);"}, {"sha": "a54ebe8b297dfce475701bc0b6693256ad0b02ff", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -4664,12 +4664,6 @@ package body Exp_Aggr is\n          Check_Same_Aggr_Bounds (N, 1);\n       end if;\n \n-      --  In formal verification mode, leave the aggregate non-expanded\n-\n-      if ALFA_Mode then\n-         return;\n-      end if;\n-\n       --  STEP 2\n \n       --  Here we test for is packed array aggregate that we can handle at"}, {"sha": "9c63c9928680a9323c98cfd07aed3fce2bbbb61c", "filename": "gcc/ada/exp_attr_light.adb", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_attr_light.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_attr_light.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr_light.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,49 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       E X P _ A T T R _ L I G H T                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--              Copyright (C) 2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Exp_Attr; use Exp_Attr;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+\n+package body Exp_Attr_Light is\n+\n+   ----------------------------------------\n+   -- Expand_Light_N_Attribute_Reference --\n+   ----------------------------------------\n+\n+   procedure Expand_Light_N_Attribute_Reference (N : Node_Id) is\n+      Id : constant Attribute_Id := Get_Attribute_Id (Attribute_Name (N));\n+   begin\n+      case Id is\n+         when Attribute_Old  |\n+            Attribute_Result =>\n+            Expand_N_Attribute_Reference (N);\n+\n+         when others =>\n+            null;\n+      end case;\n+   end Expand_Light_N_Attribute_Reference;\n+\n+end Exp_Attr_Light;"}, {"sha": "3b2bf7df09919c37268eb5167ae80b4911e0b198", "filename": "gcc/ada/exp_attr_light.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_attr_light.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_attr_light.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr_light.ads?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,35 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       E X P _ A T T R _ L I G H T                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--              Copyright (C) 2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Light expand routines for attribute references\n+\n+with Types; use Types;\n+\n+package Exp_Attr_Light is\n+\n+   procedure Expand_Light_N_Attribute_Reference (N : Node_Id);\n+   --  Expand attributes 'Old and 'Result only\n+\n+end Exp_Attr_Light;"}, {"sha": "dca021f92375d1c03b5bf94d09c4afd91298275c", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -1673,7 +1673,6 @@ package body Exp_Ch11 is\n \n          if VM_Target = No_VM\n            and then not CodePeer_Mode\n-           and then not ALFA_Mode\n            and then Exception_Mechanism = Back_End_Exceptions\n          then\n             return;"}, {"sha": "6780f6e8998161d6d650f13e252121b6804e1120", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -156,36 +156,6 @@ package body Exp_Ch6 is\n    --  the values are not changed for the call, we know immediately that\n    --  we have an infinite recursion.\n \n-   procedure Expand_Actuals (N : Node_Id; Subp : Entity_Id);\n-   --  For each actual of an in-out or out parameter which is a numeric\n-   --  (view) conversion of the form T (A), where A denotes a variable,\n-   --  we insert the declaration:\n-   --\n-   --    Temp : T[ := T (A)];\n-   --\n-   --  prior to the call. Then we replace the actual with a reference to Temp,\n-   --  and append the assignment:\n-   --\n-   --    A := TypeA (Temp);\n-   --\n-   --  after the call. Here TypeA is the actual type of variable A. For out\n-   --  parameters, the initial declaration has no expression. If A is not an\n-   --  entity name, we generate instead:\n-   --\n-   --    Var  : TypeA renames A;\n-   --    Temp : T := Var;       --  omitting expression for out parameter.\n-   --    ...\n-   --    Var := TypeA (Temp);\n-   --\n-   --  For other in-out parameters, we emit the required constraint checks\n-   --  before and/or after the call.\n-   --\n-   --  For all parameter modes, actuals that denote components and slices of\n-   --  packed arrays are expanded into suitable temporaries.\n-   --\n-   --  For non-scalar objects that are possibly unaligned, add call by copy\n-   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n-\n    procedure Expand_Ctrl_Function_Call (N : Node_Id);\n    --  N is a function call which returns a controlled object. Transform the\n    --  call into a temporary which retrieves the returned object from the"}, {"sha": "95a10ec9deddd64102d5a4efa0fb84fbad35ca01", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -37,6 +37,36 @@ package Exp_Ch6 is\n    procedure Expand_N_Subprogram_Body_Stub      (N : Node_Id);\n    procedure Expand_N_Subprogram_Declaration    (N : Node_Id);\n \n+   procedure Expand_Actuals (N : Node_Id; Subp : Entity_Id);\n+   --  For each actual of an in-out or out parameter which is a numeric\n+   --  (view) conversion of the form T (A), where A denotes a variable,\n+   --  we insert the declaration:\n+   --\n+   --    Temp : T[ := T (A)];\n+   --\n+   --  prior to the call. Then we replace the actual with a reference to Temp,\n+   --  and append the assignment:\n+   --\n+   --    A := TypeA (Temp);\n+   --\n+   --  after the call. Here TypeA is the actual type of variable A. For out\n+   --  parameters, the initial declaration has no expression. If A is not an\n+   --  entity name, we generate instead:\n+   --\n+   --    Var  : TypeA renames A;\n+   --    Temp : T := Var;       --  omitting expression for out parameter.\n+   --    ...\n+   --    Var := TypeA (Temp);\n+   --\n+   --  For other in-out parameters, we emit the required constraint checks\n+   --  before and/or after the call.\n+   --\n+   --  For all parameter modes, actuals that denote components and slices of\n+   --  packed arrays are expanded into suitable temporaries.\n+   --\n+   --  For non-scalar objects that are possibly unaligned, add call by copy\n+   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n+\n    procedure Expand_Call (N : Node_Id);\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call."}, {"sha": "e07057c41f599f1bee6fdcde9b5b49feccb59656", "filename": "gcc/ada/exp_ch6_light.adb", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6_light.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6_light.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6_light.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,193 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         E X P _ C H 6 _ L I G H T                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--              Copyright (C) 2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Exp_Ch6;  use Exp_Ch6;\n+with Exp_Dbug; use Exp_Dbug;\n+with Rtsfind;  use Rtsfind;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Res;  use Sem_Res;\n+with Sinfo;    use Sinfo;\n+with Stand;    use Stand;\n+with Tbuild;   use Tbuild;\n+\n+package body Exp_Ch6_Light is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Expand_Simple_Function_Return (N : Node_Id);\n+   --  Expand simple return from function\n+\n+   -----------------------\n+   -- Expand_Light_Call --\n+   -----------------------\n+\n+   procedure Expand_Light_Call (N : Node_Id) is\n+      Call_Node   : constant Node_Id := N;\n+      Parent_Subp : Entity_Id;\n+      Subp        : Entity_Id;\n+\n+   begin\n+      --  Ignore if previous error\n+\n+      if Nkind (Call_Node) in N_Has_Etype\n+        and then Etype (Call_Node) = Any_Type\n+      then\n+         return;\n+      end if;\n+\n+      --  Call using access to subprogram with explicit dereference\n+\n+      if Nkind (Name (Call_Node)) = N_Explicit_Dereference then\n+         Subp        := Etype (Name (Call_Node));\n+         Parent_Subp := Empty;\n+\n+      --  Case of call to simple entry, where the Name is a selected component\n+      --  whose prefix is the task, and whose selector name is the entry name\n+\n+      elsif Nkind (Name (Call_Node)) = N_Selected_Component then\n+         Subp        := Entity (Selector_Name (Name (Call_Node)));\n+         Parent_Subp := Empty;\n+\n+      --  Case of call to member of entry family, where Name is an indexed\n+      --  component, with the prefix being a selected component giving the\n+      --  task and entry family name, and the index being the entry index.\n+\n+      elsif Nkind (Name (Call_Node)) = N_Indexed_Component then\n+         Subp        := Entity (Selector_Name (Prefix (Name (Call_Node))));\n+         Parent_Subp := Empty;\n+\n+      --  Normal case\n+\n+      else\n+         Subp        := Entity (Name (Call_Node));\n+         Parent_Subp := Alias (Subp);\n+      end if;\n+\n+      --  Various expansion activities for actuals are carried out\n+\n+      Expand_Actuals (N, Subp);\n+\n+      --  If the subprogram is a renaming, replace it in the call with the name\n+      --  of the actual subprogram being called.\n+\n+      if Present (Parent_Subp) then\n+         Parent_Subp := Ultimate_Alias (Parent_Subp);\n+\n+         --  The below setting of Entity is suspect, see F109-018 discussion???\n+\n+         Set_Entity (Name (Call_Node), Parent_Subp);\n+      end if;\n+\n+   end Expand_Light_Call;\n+\n+   --------------------------------------------\n+   -- Expand_Light_N_Simple_Return_Statement --\n+   --------------------------------------------\n+\n+   procedure Expand_Light_N_Simple_Return_Statement (N : Node_Id) is\n+   begin\n+      --  Defend against previous errors (i.e. the return statement calls a\n+      --  function that is not available in configurable runtime).\n+\n+      if Present (Expression (N))\n+        and then Nkind (Expression (N)) = N_Empty\n+      then\n+         return;\n+      end if;\n+\n+      --  Distinguish the function and non-function cases:\n+\n+      case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n+\n+         when E_Function          |\n+              E_Generic_Function  =>\n+            Expand_Simple_Function_Return (N);\n+\n+         when E_Procedure         |\n+              E_Generic_Procedure |\n+              E_Entry             |\n+              E_Entry_Family      |\n+              E_Return_Statement =>\n+            --  Expand_Non_Function_Return (N);\n+            null;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+   exception\n+      when RE_Not_Available =>\n+         return;\n+   end Expand_Light_N_Simple_Return_Statement;\n+\n+   ------------------------------------\n+   -- Expand_Light_N_Subprogram_Body --\n+   ------------------------------------\n+\n+   procedure Expand_Light_N_Subprogram_Body (N : Node_Id) is\n+   begin\n+      Qualify_Entity_Names (N);\n+   end Expand_Light_N_Subprogram_Body;\n+\n+   -----------------------------------\n+   -- Expand_Simple_Function_Return --\n+   -----------------------------------\n+\n+   procedure Expand_Simple_Function_Return (N : Node_Id) is\n+      Scope_Id : constant Entity_Id :=\n+                   Return_Applies_To (Return_Statement_Entity (N));\n+      --  The function we are returning from\n+\n+      R_Type : constant Entity_Id := Etype (Scope_Id);\n+      --  The result type of the function\n+\n+      Exp : constant Node_Id := Expression (N);\n+      pragma Assert (Present (Exp));\n+\n+      Exptyp : constant Entity_Id := Etype (Exp);\n+      --  The type of the expression (not necessarily the same as R_Type)\n+\n+   begin\n+      --  Check the result expression of a scalar function against the subtype\n+      --  of the function by inserting a conversion. This conversion must\n+      --  eventually be performed for other classes of types, but for now it's\n+      --  only done for scalars.\n+      --  ???\n+\n+      if Is_Scalar_Type (Exptyp) then\n+         Rewrite (Exp, Convert_To (R_Type, Exp));\n+\n+         --  The expression is resolved to ensure that the conversion gets\n+         --  expanded to generate a possible constraint check.\n+\n+         Analyze_And_Resolve (Exp, R_Type);\n+      end if;\n+   end Expand_Simple_Function_Return;\n+\n+end Exp_Ch6_Light;"}, {"sha": "0cdec5cf5a8ddbd6655226631a7ae02578880584", "filename": "gcc/ada/exp_ch6_light.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6_light.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch6_light.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6_light.ads?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,44 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         E X P _ C H 6 _ L I G H T                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--              Copyright (C) 2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Light expand routines for chapter 6 constructs\n+\n+with Types; use Types;\n+\n+package Exp_Ch6_Light is\n+\n+   procedure Expand_Light_Call (N : Node_Id);\n+   --  This procedure contains common processing for function and procedure\n+   --  calls:\n+   --  * expansion of actuals to introduce necessary temporaries\n+   --  * replacement of renaming by subprogram renamed\n+\n+   procedure Expand_Light_N_Simple_Return_Statement (N : Node_Id);\n+   --  Insert conversion on function return if necessary\n+\n+   procedure Expand_Light_N_Subprogram_Body (N : Node_Id);\n+   --  Fully qualify names of enclosed entities\n+\n+end Exp_Ch6_Light;"}, {"sha": "f4e6a871e21fd1bb3ba022d704997a0e704fa95d", "filename": "gcc/ada/exp_ch7_light.adb", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch7_light.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch7_light.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7_light.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,35 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         E X P _ C H 7 _ L I G H T                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--              Copyright (C) 2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Exp_Dbug; use Exp_Dbug;\n+\n+package body Exp_Ch7_Light is\n+\n+   procedure Expand_Light_N_Package_Declaration (N : Node_Id) is\n+   begin\n+      Qualify_Entity_Names (N);\n+   end Expand_Light_N_Package_Declaration;\n+\n+end Exp_Ch7_Light;"}, {"sha": "87ab34be1013d25898e97aa227e4b27cf363979a", "filename": "gcc/ada/exp_ch7_light.ads", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch7_light.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch7_light.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7_light.ads?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,35 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                         E X P _ C H 7 _ L I G H T                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--              Copyright (C) 2011, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Light expand routines for chapter 7 constructs\n+\n+with Types; use Types;\n+\n+package Exp_Ch7_Light is\n+\n+   procedure Expand_Light_N_Package_Declaration (N : Node_Id);\n+   --  Fully qualify names of enclosed entities\n+\n+end Exp_Ch7_Light;"}, {"sha": "2e11a27899548367ad7121f4781480837393a9c4", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -5206,7 +5206,9 @@ package body Exp_Ch9 is\n       --  barrier just as a protected function, and discard the protected\n       --  version of it because it is never called.\n \n-      if Expander_Active then\n+      if Expander_Active\n+        and then not ALFA_Mode\n+      then\n          B_F := Build_Barrier_Function (N, Ent, Prot);\n          Func := Barrier_Function (Ent);\n          Set_Corresponding_Spec (B_F, Func);\n@@ -5245,6 +5247,7 @@ package body Exp_Ch9 is\n          --  within the function.\n \n          if Expander_Active\n+           and then not ALFA_Mode\n            and then Scope (Entity (Cond)) /= Func\n          then\n             Set_Declarations (B_F, Empty_List);"}, {"sha": "47aa2e64e9c3ef909f3282c6674309e64e977950", "filename": "gcc/ada/exp_light.adb", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_light.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_light.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_light.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,64 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            E X P _ L I G H T                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;          use Atree;\n+with Exp_Attr_Light; use Exp_Attr_Light;\n+with Exp_Ch6_Light;  use Exp_Ch6_Light;\n+with Exp_Ch7_Light;  use Exp_Ch7_Light;\n+with Sinfo;          use Sinfo;\n+\n+package body Exp_Light is\n+\n+   ------------------\n+   -- Expand_Light --\n+   ------------------\n+\n+   procedure Expand_Light (N : Node_Id) is\n+   begin\n+      case Nkind (N) is\n+\n+         when N_Package_Declaration =>\n+            Expand_Light_N_Package_Declaration (N);\n+\n+         when N_Simple_Return_Statement =>\n+            Expand_Light_N_Simple_Return_Statement (N);\n+\n+         when N_Subprogram_Body =>\n+            Expand_Light_N_Subprogram_Body (N);\n+\n+         when N_Function_Call            |\n+              N_Procedure_Call_Statement =>\n+            Expand_Light_Call (N);\n+\n+         when N_Attribute_Reference =>\n+            Expand_Light_N_Attribute_Reference (N);\n+\n+         when others =>\n+            null;\n+\n+      end case;\n+   end Expand_Light;\n+\n+end Exp_Light;"}, {"sha": "26804596f23558e649765e939a7ccd5642b4eed6", "filename": "gcc/ada/exp_light.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_light.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_light.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_light.ads?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -0,0 +1,52 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            E X P _ L I G H T                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements a light expansion which is used in formal\n+--  verification mode. Instead of a complete expansion of nodes for code\n+--  generation, this light expansion targets generation of intermediate code\n+--  for formal verification.\n+\n+--  Expand_Light is called directly by Expander.Expand.\n+\n+--  Light expansion has three main objectives:\n+\n+--    1. Perform limited expansion to explicit some Ada rules and constructs\n+--       (translate 'Old and 'Result, replace renamings by renamed, insert\n+--        conversions, expand actuals in calls to introduce temporaries)\n+\n+--    2. Facilitate treatment for the formal verification back-end (fully\n+--       qualify names)\n+\n+--    3. Avoid the introduction of low-level code that is difficult to analyze\n+--       formally, as typically done in the full expansion for high-level\n+--       constructs (tasking, dispatching)\n+\n+with Types; use Types;\n+\n+package Exp_Light is\n+\n+   procedure Expand_Light (N : Node_Id);\n+\n+end Exp_Light;"}, {"sha": "22e9bb04691e6e2b558756e6965e0d5023ed5890", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -321,15 +321,6 @@ package body Exp_Prag is\n       --  be an explicit conditional in the source, not an implicit if, so we\n       --  do not call Make_Implicit_If_Statement.\n \n-      --  In formal verification mode, we keep the pragma check in the code,\n-      --  and its enclosed expression is not expanded. This requires that no\n-      --  transient scope is introduced for pragma check in this mode in\n-      --  Exp_Ch7.Establish_Transient_Scope.\n-\n-      if ALFA_Mode then\n-         return;\n-      end if;\n-\n       --  Case where we generate a direct raise\n \n       if ((Debug_Flag_Dot_G"}, {"sha": "59045e73a77bffa37bb510fe43de595ad48213e8", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 219, "deletions": 212, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -39,6 +39,7 @@ with Exp_Ch9;   use Exp_Ch9;\n with Exp_Ch11;  use Exp_Ch11;\n with Exp_Ch12;  use Exp_Ch12;\n with Exp_Ch13;  use Exp_Ch13;\n+with Exp_Light; use Exp_Light;\n with Exp_Prag;  use Exp_Prag;\n with Opt;       use Opt;\n with Rtsfind;   use Rtsfind;\n@@ -131,325 +132,331 @@ package body Expander is\n          --  routines.\n \n          begin\n-            case Nkind (N) is\n+            if ALFA_Mode then\n+               Expand_Light (N);\n \n-               when N_Abort_Statement =>\n-                  Expand_N_Abort_Statement (N);\n+            else\n+               case Nkind (N) is\n \n-               when N_Accept_Statement =>\n-                  Expand_N_Accept_Statement (N);\n+                  when N_Abort_Statement =>\n+                     Expand_N_Abort_Statement (N);\n \n-               when N_Aggregate =>\n-                  Expand_N_Aggregate (N);\n+                  when N_Accept_Statement =>\n+                     Expand_N_Accept_Statement (N);\n \n-               when N_Allocator =>\n-                  Expand_N_Allocator (N);\n+                  when N_Aggregate =>\n+                     Expand_N_Aggregate (N);\n \n-               when N_And_Then =>\n-                  Expand_N_And_Then (N);\n+                  when N_Allocator =>\n+                     Expand_N_Allocator (N);\n \n-               when N_Assignment_Statement =>\n-                  Expand_N_Assignment_Statement (N);\n+                  when N_And_Then =>\n+                     Expand_N_And_Then (N);\n \n-               when N_Asynchronous_Select =>\n-                  Expand_N_Asynchronous_Select (N);\n+                  when N_Assignment_Statement =>\n+                     Expand_N_Assignment_Statement (N);\n \n-               when N_Attribute_Definition_Clause =>\n-                  Expand_N_Attribute_Definition_Clause (N);\n+                  when N_Asynchronous_Select =>\n+                     Expand_N_Asynchronous_Select (N);\n \n-               when N_Attribute_Reference =>\n-                  Expand_N_Attribute_Reference (N);\n+                  when N_Attribute_Definition_Clause =>\n+                     Expand_N_Attribute_Definition_Clause (N);\n \n-               when N_Block_Statement =>\n-                  Expand_N_Block_Statement (N);\n+                  when N_Attribute_Reference =>\n+                     Expand_N_Attribute_Reference (N);\n \n-               when N_Case_Expression =>\n-                  Expand_N_Case_Expression (N);\n+                  when N_Block_Statement =>\n+                     Expand_N_Block_Statement (N);\n \n-               when N_Case_Statement =>\n-                  Expand_N_Case_Statement (N);\n+                  when N_Case_Expression =>\n+                     Expand_N_Case_Expression (N);\n \n-               when N_Conditional_Entry_Call =>\n-                  Expand_N_Conditional_Entry_Call (N);\n+                  when N_Case_Statement =>\n+                     Expand_N_Case_Statement (N);\n \n-               when N_Conditional_Expression =>\n-                  Expand_N_Conditional_Expression (N);\n+                  when N_Conditional_Entry_Call =>\n+                     Expand_N_Conditional_Entry_Call (N);\n \n-               when N_Delay_Relative_Statement =>\n-                  Expand_N_Delay_Relative_Statement (N);\n+                  when N_Conditional_Expression =>\n+                     Expand_N_Conditional_Expression (N);\n \n-               when N_Delay_Until_Statement =>\n-                  Expand_N_Delay_Until_Statement (N);\n+                  when N_Delay_Relative_Statement =>\n+                     Expand_N_Delay_Relative_Statement (N);\n \n-               when N_Entry_Body =>\n-                  Expand_N_Entry_Body (N);\n+                  when N_Delay_Until_Statement =>\n+                     Expand_N_Delay_Until_Statement (N);\n \n-               when N_Entry_Call_Statement =>\n-                  Expand_N_Entry_Call_Statement (N);\n+                  when N_Entry_Body =>\n+                     Expand_N_Entry_Body (N);\n \n-               when N_Entry_Declaration =>\n-                  Expand_N_Entry_Declaration (N);\n+                  when N_Entry_Call_Statement =>\n+                     Expand_N_Entry_Call_Statement (N);\n \n-               when N_Exception_Declaration =>\n-                  Expand_N_Exception_Declaration (N);\n+                  when N_Entry_Declaration =>\n+                     Expand_N_Entry_Declaration (N);\n \n-               when N_Exception_Renaming_Declaration =>\n-                  Expand_N_Exception_Renaming_Declaration (N);\n+                  when N_Exception_Declaration =>\n+                     Expand_N_Exception_Declaration (N);\n \n-               when N_Exit_Statement =>\n-                  Expand_N_Exit_Statement (N);\n+                  when N_Exception_Renaming_Declaration =>\n+                     Expand_N_Exception_Renaming_Declaration (N);\n \n-               when N_Expanded_Name =>\n-                  Expand_N_Expanded_Name (N);\n+                  when N_Exit_Statement =>\n+                     Expand_N_Exit_Statement (N);\n \n-               when N_Explicit_Dereference =>\n-                  Expand_N_Explicit_Dereference (N);\n+                  when N_Expanded_Name =>\n+                     Expand_N_Expanded_Name (N);\n \n-               when N_Expression_With_Actions =>\n-                  Expand_N_Expression_With_Actions (N);\n+                  when N_Explicit_Dereference =>\n+                     Expand_N_Explicit_Dereference (N);\n \n-               when N_Extended_Return_Statement =>\n-                  Expand_N_Extended_Return_Statement (N);\n+                  when N_Expression_With_Actions =>\n+                     Expand_N_Expression_With_Actions (N);\n \n-               when N_Extension_Aggregate =>\n-                  Expand_N_Extension_Aggregate (N);\n+                  when N_Extended_Return_Statement =>\n+                     Expand_N_Extended_Return_Statement (N);\n \n-               when N_Free_Statement =>\n-                  Expand_N_Free_Statement (N);\n+                  when N_Extension_Aggregate =>\n+                     Expand_N_Extension_Aggregate (N);\n \n-               when N_Freeze_Entity =>\n-                  Expand_N_Freeze_Entity (N);\n+                  when N_Free_Statement =>\n+                     Expand_N_Free_Statement (N);\n \n-               when N_Full_Type_Declaration =>\n-                  Expand_N_Full_Type_Declaration (N);\n+                  when N_Freeze_Entity =>\n+                     Expand_N_Freeze_Entity (N);\n \n-               when N_Function_Call =>\n-                  Expand_N_Function_Call (N);\n+                  when N_Full_Type_Declaration =>\n+                     Expand_N_Full_Type_Declaration (N);\n \n-               when N_Generic_Instantiation =>\n-                  Expand_N_Generic_Instantiation (N);\n+                  when N_Function_Call =>\n+                     Expand_N_Function_Call (N);\n \n-               when N_Goto_Statement =>\n-                  Expand_N_Goto_Statement (N);\n+                  when N_Generic_Instantiation =>\n+                     Expand_N_Generic_Instantiation (N);\n \n-               when N_Handled_Sequence_Of_Statements =>\n-                  Expand_N_Handled_Sequence_Of_Statements (N);\n+                  when N_Goto_Statement =>\n+                     Expand_N_Goto_Statement (N);\n \n-               when N_Identifier =>\n-                  Expand_N_Identifier (N);\n+                  when N_Handled_Sequence_Of_Statements =>\n+                     Expand_N_Handled_Sequence_Of_Statements (N);\n \n-               when N_Indexed_Component =>\n-                  Expand_N_Indexed_Component (N);\n+                  when N_Identifier =>\n+                     Expand_N_Identifier (N);\n \n-               when N_If_Statement =>\n-                  Expand_N_If_Statement (N);\n+                  when N_Indexed_Component =>\n+                     Expand_N_Indexed_Component (N);\n \n-               when N_In =>\n-                  Expand_N_In (N);\n+                  when N_If_Statement =>\n+                     Expand_N_If_Statement (N);\n \n-               when N_Loop_Statement =>\n-                  Expand_N_Loop_Statement (N);\n+                  when N_In =>\n+                     Expand_N_In (N);\n \n-               when N_Not_In =>\n-                  Expand_N_Not_In (N);\n+                  when N_Loop_Statement =>\n+                     Expand_N_Loop_Statement (N);\n \n-               when N_Null =>\n-                  Expand_N_Null (N);\n+                  when N_Not_In =>\n+                     Expand_N_Not_In (N);\n \n-               when N_Object_Declaration =>\n-                  Expand_N_Object_Declaration (N);\n+                  when N_Null =>\n+                     Expand_N_Null (N);\n \n-               when N_Object_Renaming_Declaration =>\n-                  Expand_N_Object_Renaming_Declaration (N);\n+                  when N_Object_Declaration =>\n+                     Expand_N_Object_Declaration (N);\n \n-               when N_Op_Add =>\n-                  Expand_N_Op_Add (N);\n+                  when N_Object_Renaming_Declaration =>\n+                     Expand_N_Object_Renaming_Declaration (N);\n \n-               when N_Op_Abs =>\n-                  Expand_N_Op_Abs (N);\n+                  when N_Op_Add =>\n+                     Expand_N_Op_Add (N);\n \n-               when N_Op_And =>\n-                  Expand_N_Op_And (N);\n+                  when N_Op_Abs =>\n+                     Expand_N_Op_Abs (N);\n \n-               when N_Op_Concat =>\n-                  Expand_N_Op_Concat (N);\n+                  when N_Op_And =>\n+                     Expand_N_Op_And (N);\n \n-               when N_Op_Divide =>\n-                  Expand_N_Op_Divide (N);\n+                  when N_Op_Concat =>\n+                     Expand_N_Op_Concat (N);\n \n-               when N_Op_Eq =>\n-                  Expand_N_Op_Eq (N);\n+                  when N_Op_Divide =>\n+                     Expand_N_Op_Divide (N);\n \n-               when N_Op_Expon =>\n-                  Expand_N_Op_Expon (N);\n+                  when N_Op_Eq =>\n+                     Expand_N_Op_Eq (N);\n \n-               when N_Op_Ge =>\n-                  Expand_N_Op_Ge (N);\n+                  when N_Op_Expon =>\n+                     Expand_N_Op_Expon (N);\n \n-               when N_Op_Gt =>\n-                  Expand_N_Op_Gt (N);\n+                  when N_Op_Ge =>\n+                     Expand_N_Op_Ge (N);\n \n-               when N_Op_Le =>\n-                  Expand_N_Op_Le (N);\n+                  when N_Op_Gt =>\n+                     Expand_N_Op_Gt (N);\n \n-               when N_Op_Lt =>\n-                  Expand_N_Op_Lt (N);\n+                  when N_Op_Le =>\n+                     Expand_N_Op_Le (N);\n \n-               when N_Op_Minus =>\n-                  Expand_N_Op_Minus (N);\n+                  when N_Op_Lt =>\n+                     Expand_N_Op_Lt (N);\n \n-               when N_Op_Mod =>\n-                  Expand_N_Op_Mod (N);\n+                  when N_Op_Minus =>\n+                     Expand_N_Op_Minus (N);\n \n-               when N_Op_Multiply =>\n-                  Expand_N_Op_Multiply (N);\n+                  when N_Op_Mod =>\n+                     Expand_N_Op_Mod (N);\n \n-               when N_Op_Ne =>\n-                  Expand_N_Op_Ne (N);\n+                  when N_Op_Multiply =>\n+                     Expand_N_Op_Multiply (N);\n \n-               when N_Op_Not =>\n-                  Expand_N_Op_Not (N);\n+                  when N_Op_Ne =>\n+                     Expand_N_Op_Ne (N);\n \n-               when N_Op_Or =>\n-                  Expand_N_Op_Or (N);\n+                  when N_Op_Not =>\n+                     Expand_N_Op_Not (N);\n \n-               when N_Op_Plus =>\n-                  Expand_N_Op_Plus (N);\n+                  when N_Op_Or =>\n+                     Expand_N_Op_Or (N);\n \n-               when N_Op_Rem =>\n-                  Expand_N_Op_Rem (N);\n+                  when N_Op_Plus =>\n+                     Expand_N_Op_Plus (N);\n \n-               when N_Op_Rotate_Left =>\n-                  Expand_N_Op_Rotate_Left (N);\n+                  when N_Op_Rem =>\n+                     Expand_N_Op_Rem (N);\n \n-               when N_Op_Rotate_Right =>\n-                  Expand_N_Op_Rotate_Right (N);\n+                  when N_Op_Rotate_Left =>\n+                     Expand_N_Op_Rotate_Left (N);\n \n-               when N_Op_Shift_Left =>\n-                  Expand_N_Op_Shift_Left (N);\n+                  when N_Op_Rotate_Right =>\n+                     Expand_N_Op_Rotate_Right (N);\n \n-               when N_Op_Shift_Right =>\n-                  Expand_N_Op_Shift_Right (N);\n+                  when N_Op_Shift_Left =>\n+                     Expand_N_Op_Shift_Left (N);\n \n-               when N_Op_Shift_Right_Arithmetic =>\n-                  Expand_N_Op_Shift_Right_Arithmetic (N);\n+                  when N_Op_Shift_Right =>\n+                     Expand_N_Op_Shift_Right (N);\n \n-               when N_Op_Subtract =>\n-                  Expand_N_Op_Subtract (N);\n+                  when N_Op_Shift_Right_Arithmetic =>\n+                     Expand_N_Op_Shift_Right_Arithmetic (N);\n \n-               when N_Op_Xor =>\n-                  Expand_N_Op_Xor (N);\n+                  when N_Op_Subtract =>\n+                     Expand_N_Op_Subtract (N);\n \n-               when N_Or_Else =>\n-                  Expand_N_Or_Else (N);\n+                  when N_Op_Xor =>\n+                     Expand_N_Op_Xor (N);\n \n-               when N_Package_Body =>\n-                  Expand_N_Package_Body (N);\n+                  when N_Or_Else =>\n+                     Expand_N_Or_Else (N);\n \n-               when N_Package_Declaration =>\n-                  Expand_N_Package_Declaration (N);\n+                  when N_Package_Body =>\n+                     Expand_N_Package_Body (N);\n \n-               when N_Package_Renaming_Declaration =>\n-                  Expand_N_Package_Renaming_Declaration (N);\n+                  when N_Package_Declaration =>\n+                     Expand_N_Package_Declaration (N);\n \n-               when N_Subprogram_Renaming_Declaration =>\n-                  Expand_N_Subprogram_Renaming_Declaration (N);\n+                  when N_Package_Renaming_Declaration =>\n+                     Expand_N_Package_Renaming_Declaration (N);\n \n-               when N_Pragma =>\n-                  Expand_N_Pragma (N);\n+                  when N_Subprogram_Renaming_Declaration =>\n+                     Expand_N_Subprogram_Renaming_Declaration (N);\n \n-               when N_Procedure_Call_Statement =>\n-                  Expand_N_Procedure_Call_Statement (N);\n+                  when N_Pragma =>\n+                     Expand_N_Pragma (N);\n \n-               when N_Protected_Type_Declaration =>\n-                  Expand_N_Protected_Type_Declaration (N);\n+                  when N_Procedure_Call_Statement =>\n+                     Expand_N_Procedure_Call_Statement (N);\n \n-               when N_Protected_Body =>\n-                  Expand_N_Protected_Body (N);\n+                  when N_Protected_Type_Declaration =>\n+                     Expand_N_Protected_Type_Declaration (N);\n \n-               when N_Qualified_Expression =>\n-                  Expand_N_Qualified_Expression (N);\n+                  when N_Protected_Body =>\n+                     Expand_N_Protected_Body (N);\n \n-               when N_Quantified_Expression  =>\n-                  Expand_N_Quantified_Expression (N);\n+                  when N_Qualified_Expression =>\n+                     Expand_N_Qualified_Expression (N);\n \n-               when N_Raise_Statement =>\n-                  Expand_N_Raise_Statement (N);\n+                  when N_Quantified_Expression  =>\n+                     Expand_N_Quantified_Expression (N);\n \n-               when N_Raise_Constraint_Error =>\n-                  Expand_N_Raise_Constraint_Error (N);\n+                  when N_Raise_Statement =>\n+                     Expand_N_Raise_Statement (N);\n \n-               when N_Raise_Program_Error =>\n-                  Expand_N_Raise_Program_Error (N);\n+                  when N_Raise_Constraint_Error =>\n+                     Expand_N_Raise_Constraint_Error (N);\n \n-               when N_Raise_Storage_Error =>\n-                  Expand_N_Raise_Storage_Error (N);\n+                  when N_Raise_Program_Error =>\n+                     Expand_N_Raise_Program_Error (N);\n \n-               when N_Real_Literal =>\n-                  Expand_N_Real_Literal (N);\n+                  when N_Raise_Storage_Error =>\n+                     Expand_N_Raise_Storage_Error (N);\n \n-               when N_Record_Representation_Clause =>\n-                  Expand_N_Record_Representation_Clause (N);\n+                  when N_Real_Literal =>\n+                     Expand_N_Real_Literal (N);\n \n-               when N_Requeue_Statement =>\n-                  Expand_N_Requeue_Statement (N);\n+                  when N_Record_Representation_Clause =>\n+                     Expand_N_Record_Representation_Clause (N);\n \n-               when N_Simple_Return_Statement =>\n-                  Expand_N_Simple_Return_Statement (N);\n+                  when N_Requeue_Statement =>\n+                     Expand_N_Requeue_Statement (N);\n \n-               when N_Selected_Component =>\n-                  Expand_N_Selected_Component (N);\n+                  when N_Simple_Return_Statement =>\n+                     Expand_N_Simple_Return_Statement (N);\n \n-               when N_Selective_Accept =>\n-                  Expand_N_Selective_Accept (N);\n+                  when N_Selected_Component =>\n+                     Expand_N_Selected_Component (N);\n \n-               when N_Single_Task_Declaration =>\n-                  Expand_N_Single_Task_Declaration (N);\n+                  when N_Selective_Accept =>\n+                     Expand_N_Selective_Accept (N);\n \n-               when N_Slice =>\n-                  Expand_N_Slice (N);\n+                  when N_Single_Task_Declaration =>\n+                     Expand_N_Single_Task_Declaration (N);\n \n-               when N_Subtype_Indication =>\n-                  Expand_N_Subtype_Indication (N);\n+                  when N_Slice =>\n+                     Expand_N_Slice (N);\n \n-               when N_Subprogram_Body =>\n-                  Expand_N_Subprogram_Body (N);\n+                  when N_Subtype_Indication =>\n+                     Expand_N_Subtype_Indication (N);\n \n-               when N_Subprogram_Body_Stub =>\n-                  Expand_N_Subprogram_Body_Stub (N);\n+                  when N_Subprogram_Body =>\n+                     Expand_N_Subprogram_Body (N);\n \n-               when N_Subprogram_Declaration =>\n-                  Expand_N_Subprogram_Declaration (N);\n+                  when N_Subprogram_Body_Stub =>\n+                     Expand_N_Subprogram_Body_Stub (N);\n \n-               when N_Subprogram_Info =>\n-                  Expand_N_Subprogram_Info (N);\n+                  when N_Subprogram_Declaration =>\n+                     Expand_N_Subprogram_Declaration (N);\n \n-               when N_Task_Body =>\n-                  Expand_N_Task_Body (N);\n+                  when N_Subprogram_Info =>\n+                     Expand_N_Subprogram_Info (N);\n \n-               when N_Task_Type_Declaration =>\n-                  Expand_N_Task_Type_Declaration (N);\n+                  when N_Task_Body =>\n+                     Expand_N_Task_Body (N);\n \n-               when N_Timed_Entry_Call =>\n-                  Expand_N_Timed_Entry_Call (N);\n+                  when N_Task_Type_Declaration =>\n+                     Expand_N_Task_Type_Declaration (N);\n \n-               when N_Type_Conversion =>\n-                  Expand_N_Type_Conversion (N);\n+                  when N_Timed_Entry_Call =>\n+                     Expand_N_Timed_Entry_Call (N);\n \n-               when N_Unchecked_Expression =>\n-                  Expand_N_Unchecked_Expression (N);\n+                  when N_Type_Conversion =>\n+                     Expand_N_Type_Conversion (N);\n \n-               when N_Unchecked_Type_Conversion =>\n-                  Expand_N_Unchecked_Type_Conversion (N);\n+                  when N_Unchecked_Expression =>\n+                     Expand_N_Unchecked_Expression (N);\n \n-               when N_Variant_Part =>\n-                  Expand_N_Variant_Part (N);\n+                  when N_Unchecked_Type_Conversion =>\n+                     Expand_N_Unchecked_Type_Conversion (N);\n \n-               --  For all other node kinds, no expansion activity is required\n+                  when N_Variant_Part =>\n+                     Expand_N_Variant_Part (N);\n \n-               when others => null;\n+                  --  For all other node kinds, no expansion activity is\n+                  --  required.\n \n-            end case;\n+                  when others => null;\n+\n+               end case;\n+            end if;\n \n          exception\n             when RE_Not_Available =>"}, {"sha": "b538f4bc82e4490cf25781cdd642b3baf8b03ff5", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -435,8 +435,9 @@ procedure Gnat1drv is\n \n          Polling_Required := False;\n \n-         --  Set operating mode to Generate_Code to benefit from full front-end\n-         --  expansion (e.g. default arguments).\n+         --  Set operating mode to Generate_Code, but full front-end expansion\n+         --  is not desirable in ALFA mode, so a light expansion is performed\n+         --  instead.\n \n          Operating_Mode := Generate_Code;\n "}, {"sha": "66c161379be51931146e2faad8829a19b101c5d9", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -158,7 +158,7 @@ package body ALFA is\n      Table_Name           => \"Drefs\");\n    --  Table of cross-references for reads and writes through explicit\n    --  dereferences, that are output as reads/writes to the special variable\n-   --  \"HEAP\". These references are added to the regular references when\n+   --  \"Heap\". These references are added to the regular references when\n    --  computing ALFA cross-references.\n \n    -----------------------\n@@ -543,7 +543,7 @@ package body ALFA is\n       end loop;\n \n       --  Add dereferences to the set of regular references, by creating a\n-      --  special \"HEAP\" variable for these special references.\n+      --  special \"Heap\" variable for these special references.\n \n       Name_Len := Name_Of_Heap_Variable'Length;\n       Name_Buffer (1 .. Name_Len) := Name_Of_Heap_Variable;\n@@ -559,8 +559,10 @@ package body ALFA is\n       Set_Has_Fully_Qualified_Name (Heap);\n \n       for J in Drefs.First .. Drefs.Last loop\n-         Xrefs.Increment_Last;\n-         Xrefs.Table (Xrefs.Last)     := Drefs.Table (J);\n+         Xrefs.Append (Drefs.Table (J));\n+\n+         --  Set entity at this point with newly created \"Heap\" variable\n+\n          Xrefs.Table (Xrefs.Last).Ent := Heap;\n \n          Nrefs         := Nrefs + 1;\n@@ -1047,15 +1049,15 @@ package body ALFA is\n \n          Ref_Scope := Enclosing_Subprogram_Or_Package (N);\n \n-         --  Entity is filled later on with the special \"HEAP\" variable\n+         --  Entity is filled later on with the special \"Heap\" variable\n \n          Drefs.Table (Indx).Ent := Empty;\n \n          Drefs.Table (Indx).Def := No_Location;\n          Drefs.Table (Indx).Loc := Ref;\n          Drefs.Table (Indx).Typ := Typ;\n \n-         --  It is as if the special \"HEAP\" was defined in every scope where it\n+         --  It is as if the special \"Heap\" was defined in every scope where it\n          --  is referenced.\n \n          Drefs.Table (Indx).Eun := Get_Source_Unit (Ref);"}, {"sha": "2d1951f855f70ab38590d193d8a9394e11507e9b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -1609,6 +1609,10 @@ package body Sem_Ch3 is\n                    (Tagged_Type => Tagged_Type,\n                     Iface_Prim  => Iface_Prim);\n \n+               if No (Prim) and then Serious_Errors_Detected > 0 then\n+                  goto Continue;\n+               end if;\n+\n                pragma Assert (Present (Prim));\n \n                --  Ada 2012 (AI05-0197): If the name of the covering primitive\n@@ -1669,6 +1673,7 @@ package body Sem_Ch3 is\n                Set_Has_Delayed_Freeze (New_Subp);\n             end if;\n \n+            <<Continue>>\n             Next_Elmt (Elmt);\n          end loop;\n \n@@ -9163,13 +9168,16 @@ package body Sem_Ch3 is\n                   if Ekind (First_Formal (Subp)) = E_In_Parameter\n                     and then Ekind (Subp) /= E_Function\n                   then\n-                     if not Is_Predefined_Dispatching_Operation (Subp) then\n+                     if not Is_Predefined_Dispatching_Operation (Subp)\n+                       and then Is_Protected_Type\n+                                  (Corresponding_Concurrent_Type (T))\n+                     then\n                         Error_Msg_NE\n                           (\"first formal of & must be of mode `OUT`, \" &\n                            \"`IN OUT` or access-to-variable\", T, Subp);\n                         Error_Msg_N\n-                          (\"\\to be overridden by protected procedure or \" &\n-                           \"entry (RM 9.4(11.9/2))\", T);\n+                          (\"\\in order to be overridden by protected procedure \"\n+                           & \"or entry (RM 9.4(11.9/2))\", T);\n                      end if;\n \n                   --  Some other kind of overriding failure\n@@ -17437,7 +17445,7 @@ package body Sem_Ch3 is\n \n             --  Ada 2005 (AI-251): The partial view shall be a descendant of\n             --  an interface type if and only if the full type is descendant\n-            --  of the interface type (AARM 7.3 (7.3/2).\n+            --  of the interface type (AARM 7.3 (7.3/2)).\n \n             Iface := Find_Hidden_Interface (Priv_T_Ifaces, Full_T_Ifaces);\n "}, {"sha": "07c625d17a1df2d57035e40f0155f89dbaf8e188", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -2700,6 +2700,7 @@ package body Sem_Ch6 is\n       --  references entities which were created during regular expansion.\n \n       if Expander_Active\n+        and then not ALFA_Mode\n         and then Comes_From_Source (N)\n         and then Present (Prot_Typ)\n         and then Present (Spec_Id)"}, {"sha": "f5530a9349b2d83bb951a3e3321510112d2f95cb", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01817d2e03b80c93d4be08927d4573777c5e129/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=c01817d2e03b80c93d4be08927d4573777c5e129", "patch": "@@ -728,6 +728,7 @@ package body Sem_Ch9 is\n       --  entry family index (if applicable).\n \n       if Expander_Active\n+        and then not ALFA_Mode\n         and then Is_Protected_Type (P_Type)\n       then\n          Install_Private_Data_Declarations"}]}