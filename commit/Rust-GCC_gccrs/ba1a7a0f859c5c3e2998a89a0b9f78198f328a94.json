{"sha": "ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmExYTdhMGY4NTljNWMzZTI5OThhODlhMGI5Zjc4MTk4ZjMyOGE5NA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-07-20T07:01:48Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-07-20T07:01:48Z"}, "message": "Add selftests for fibonacci_heap\n\n\t* Makefile.in: Include fibonacci_heap.c\n\t* fibonacci_heap.c: New file.\n\t* fibonacci_heap.h (fibonacci_heap::insert): Use insert_node.\n\t(fibonacci_heap::union_with): Fix deletion of the second heap.\n\t* selftest-run-tests.c (selftest::run_tests): Incorporate\n\tfibonacci heap tests.\n\t* selftest.h: Declare fibonacci_heap_c_tests.\n\nFrom-SVN: r238509", "tree": {"sha": "6f8272b27e014a60a465f02ef3c0745201f328c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f8272b27e014a60a465f02ef3c0745201f328c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dcbdb17aebb7fac8b3e455774728c044dd711e37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbdb17aebb7fac8b3e455774728c044dd711e37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcbdb17aebb7fac8b3e455774728c044dd711e37"}], "stats": {"total": 340, "additions": 331, "deletions": 9}, "files": [{"sha": "c6a3d6b62ca16e8a6a353b3b70dd2b02396a507c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "patch": "@@ -1,3 +1,13 @@\n+2016-07-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: Include fibonacci_heap.c\n+\t* fibonacci_heap.c: New file.\n+\t* fibonacci_heap.h (fibonacci_heap::insert): Use insert_node.\n+\t(fibonacci_heap::union_with): Fix deletion of the second heap.\n+\t* selftest-run-tests.c (selftest::run_tests): Incorporate\n+\tfibonacci heap tests.\n+\t* selftest.h: Declare fibonacci_heap_c_tests.\n+\n 2016-07-20  Martin Liska  <mliska@suse.cz>\n \n \t* selftest-run-tests.c (selftest::run_tests): New function."}, {"sha": "bfa467c38acd2cd2633d6d81e4f8582197fe540a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "patch": "@@ -1259,6 +1259,7 @@ OBJS = \\\n \texplow.o \\\n \texpmed.o \\\n \texpr.o \\\n+\tfibonacci_heap.o \\\n \tfinal.o \\\n \tfixed-value.o \\\n \tfold-const.o \\"}, {"sha": "afc858139742c1375c59abf4cf1775fea21200fb", "filename": "gcc/fibonacci_heap.c", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Ffibonacci_heap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Ffibonacci_heap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffibonacci_heap.c?ref=ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "patch": "@@ -0,0 +1,290 @@\n+/* Fibonacci heap for GNU compiler.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+   Contributed by Martin Liska <mliska@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests.  */\n+\n+/* Verify that operations with empty heap work.  */\n+\n+typedef fibonacci_node <int, int> int_heap_node_t;\n+typedef fibonacci_heap <int, int> int_heap_t;\n+\n+static void\n+test_empty_heap ()\n+{\n+  int_heap_t *h1 = new int_heap_t (INT_MIN);\n+\n+  ASSERT_TRUE (h1->empty ());\n+  ASSERT_EQ (0, h1->nodes ());\n+  ASSERT_EQ (NULL, h1->min ());\n+\n+  int_heap_t *h2 = new int_heap_t (INT_MIN);\n+\n+  int_heap_t *r = h1->union_with (h2);\n+  ASSERT_TRUE (r->empty ());\n+  ASSERT_EQ (0, r->nodes ());\n+  ASSERT_EQ (NULL, r->min ());\n+\n+  delete r;\n+}\n+\n+#define TEST_HEAP_N 100\n+#define TEST_CALCULATE_VALUE(i)  ((3 * i) + 10000)\n+\n+/* Verify heap basic operations.  */\n+\n+static void\n+test_basic_heap_operations ()\n+{\n+  int values[TEST_HEAP_N];\n+  int_heap_t *h1 = new int_heap_t (INT_MIN);\n+\n+  for (unsigned i = 0; i < TEST_HEAP_N; i++)\n+    {\n+      values[i] = TEST_CALCULATE_VALUE (i);\n+      ASSERT_EQ (i, h1->nodes ());\n+      h1->insert (i, &values[i]);\n+      ASSERT_EQ (0, h1->min_key ());\n+      ASSERT_EQ (values[0], *h1->min ());\n+    }\n+\n+  for (unsigned i = 0; i < TEST_HEAP_N; i++)\n+    {\n+      ASSERT_EQ (TEST_HEAP_N - i, h1->nodes ());\n+      ASSERT_EQ ((int)i, h1->min_key ());\n+      ASSERT_EQ (values[i], *h1->min ());\n+\n+      h1->extract_min ();\n+    }\n+\n+  ASSERT_TRUE (h1->empty ());\n+\n+  delete h1;\n+}\n+\n+/* Builds a simple heap with values in interval 0..TEST_HEAP_N-1, where values\n+   of each key is equal to 3 * key + 10000.  BUFFER is used as a storage\n+   of values and NODES points to inserted nodes.  */\n+\n+static int_heap_t *\n+build_simple_heap (int *buffer, int_heap_node_t **nodes)\n+{\n+  int_heap_t *h = new int_heap_t (INT_MIN);\n+\n+  for (unsigned i = 0; i < TEST_HEAP_N; i++)\n+    {\n+      buffer[i] = TEST_CALCULATE_VALUE (i);\n+      nodes[i] = h->insert (i, &buffer[i]);\n+    }\n+\n+  return h;\n+}\n+\n+/* Verify that fibonacci_heap::replace_key works.  */\n+\n+static void\n+test_replace_key ()\n+{\n+  int values[TEST_HEAP_N];\n+  int_heap_node_t *nodes[TEST_HEAP_N];\n+\n+  int_heap_t *heap = build_simple_heap (values, nodes);\n+\n+  int N = 10;\n+  for (unsigned i = 0; i < (unsigned)N; i++)\n+    heap->replace_key (nodes[i], 100 * 1000 + i);\n+\n+  ASSERT_EQ (TEST_HEAP_N, heap->nodes ());\n+  ASSERT_EQ (N, heap->min_key ());\n+  ASSERT_EQ (TEST_CALCULATE_VALUE (N), *heap->min ());\n+\n+  for (int i = 0; i < TEST_HEAP_N - 1; i++)\n+    heap->extract_min ();\n+\n+  ASSERT_EQ (1, heap->nodes ());\n+  ASSERT_EQ (100 * 1000 + N - 1, heap->min_key ());\n+\n+  delete heap;\n+}\n+\n+/* Verify that heap can handle duplicate keys.  */\n+\n+static void\n+test_duplicate_keys ()\n+{\n+  int values[3 * TEST_HEAP_N];\n+  int_heap_t *heap = new int_heap_t (INT_MIN);\n+\n+  for (unsigned i = 0; i < 3 * TEST_HEAP_N; i++)\n+    {\n+      values[i] = TEST_CALCULATE_VALUE (i);\n+      heap->insert (i / 3, &values[i]);\n+    }\n+\n+  ASSERT_EQ (3 * TEST_HEAP_N, heap->nodes ());\n+  ASSERT_EQ (0, heap->min_key ());\n+  ASSERT_EQ (TEST_CALCULATE_VALUE (0), *heap->min ());\n+\n+  for (unsigned i = 0; i < 9; i++)\n+    heap->extract_min ();\n+\n+  for (unsigned i = 0; i < 3; i++)\n+    {\n+      ASSERT_EQ (3, heap->min_key ());\n+      heap->extract_min ();\n+    }\n+\n+  delete heap;\n+}\n+\n+/* Verify that heap can handle union.  */\n+\n+static void\n+test_union ()\n+{\n+  int value = 777;\n+\n+  int_heap_t *heap1 = new int_heap_t (INT_MIN);\n+  for (unsigned i = 0; i < 2 * TEST_HEAP_N; i++)\n+    heap1->insert (i, &value);\n+\n+  int_heap_t *heap2 = new int_heap_t (INT_MIN);\n+  for (unsigned i = 2 * TEST_HEAP_N; i < 3 * TEST_HEAP_N; i++)\n+    heap2->insert (i, &value);\n+\n+  int_heap_t *union_heap = heap1->union_with (heap2);\n+\n+  for (int i = 0; i < 3 * TEST_HEAP_N; i++)\n+    {\n+      ASSERT_EQ (i, union_heap->min_key ());\n+      union_heap->extract_min ();\n+    }\n+\n+  delete union_heap;\n+}\n+\n+/* Verify that heap can handle union with a heap having exactly the same\n+   keys.  */\n+\n+static void\n+test_union_of_equal_heaps ()\n+{\n+  int value = 777;\n+\n+  int_heap_t *heap1 = new int_heap_t (INT_MIN);\n+  for (unsigned i = 0; i < TEST_HEAP_N; i++)\n+    heap1->insert (i, &value);\n+\n+  int_heap_t *heap2 = new int_heap_t (INT_MIN);\n+  for (unsigned i = 0; i < TEST_HEAP_N; i++)\n+    heap2->insert (i, &value);\n+\n+  int_heap_t *union_heap = heap1->union_with (heap2);\n+\n+  for (int i = 0; i < TEST_HEAP_N; i++)\n+    for (int j = 0; j < 2; j++)\n+    {\n+      ASSERT_EQ (i, union_heap->min_key ());\n+      union_heap->extract_min ();\n+    }\n+\n+  delete union_heap;\n+}\n+\n+/* Dummy struct for testing.  */\n+\n+struct heap_key\n+{\n+  heap_key (int k): key (k)\n+  {\n+  }\n+\n+  int key;\n+\n+  bool operator< (const heap_key &other) const\n+  {\n+    return key > other.key;\n+  }\n+\n+  bool operator== (const heap_key &other) const\n+  {\n+    return key == other.key;\n+  }\n+\n+  bool operator> (const heap_key &other) const\n+  {\n+    return !(*this == other || *this < other);\n+  }\n+};\n+\n+typedef fibonacci_heap<heap_key, int> class_fibonacci_heap_t;\n+\n+/* Verify that heap can handle a struct as key type.  */\n+\n+static void\n+test_struct_key ()\n+{\n+  int value = 123456;\n+  class_fibonacci_heap_t *heap = new class_fibonacci_heap_t (INT_MIN);\n+\n+  heap->insert (heap_key (1), &value);\n+  heap->insert (heap_key (10), &value);\n+  heap->insert (heap_key (100), &value);\n+  heap->insert (heap_key (1000), &value);\n+\n+  ASSERT_EQ (1000, heap->min_key ().key);\n+  ASSERT_EQ (4, heap->nodes ());\n+  heap->extract_min ();\n+  heap->extract_min ();\n+  ASSERT_EQ (10, heap->min_key ().key);\n+  heap->extract_min ();\n+  ASSERT_EQ (&value, heap->min ());\n+  heap->extract_min ();\n+  ASSERT_TRUE (heap->empty ());\n+\n+  delete heap;\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+fibonacci_heap_c_tests ()\n+{\n+  test_empty_heap ();\n+  test_basic_heap_operations ();\n+  test_replace_key ();\n+  test_duplicate_keys ();\n+  test_union ();\n+  test_union_of_equal_heaps ();\n+  test_struct_key ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "1345027f27848ece2a6ae4f28f7b10e84a5279d5", "filename": "gcc/fibonacci_heap.h", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Ffibonacci_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Ffibonacci_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffibonacci_heap.h?ref=ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "patch": "@@ -1,4 +1,4 @@\n-/* Vector API for GNU compiler.\n+/* Fibonacci heap for GNU compiler.\n    Copyright (C) 1998-2016 Free Software Foundation, Inc.\n    Contributed by Daniel Berlin (dan@cgsoftware.com).\n    Re-implemented in C++ by Martin Liska <mliska@suse.cz>\n@@ -61,8 +61,8 @@ class fibonacci_node\n   }\n \n   /* Constructor for a node with given KEY.  */\n-  fibonacci_node (K key): m_parent (NULL), m_child (NULL), m_left (this),\n-    m_right (this), m_key (key),\n+  fibonacci_node (K key, V *data = NULL): m_parent (NULL), m_child (NULL),\n+    m_left (this), m_right (this), m_key (key), m_data (data),\n     m_degree (0), m_mark (0)\n   {\n   }\n@@ -230,6 +230,9 @@ class fibonacci_heap\n   /* Insert new NODE given by KEY and DATA associated with the key.  */\n   fibonacci_node_t *insert (fibonacci_node_t *node, K key, V *data);\n \n+  /* Insert new NODE that has already filled key and value.  */\n+  fibonacci_node_t *insert_node (fibonacci_node_t *node);\n+\n   /* Insert it into the root list.  */\n   void insert_root (fibonacci_node_t *node);\n \n@@ -330,12 +333,12 @@ fibonacci_node<K,V>*\n fibonacci_heap<K,V>::insert (K key, V *data)\n {\n   /* Create the new node.  */\n-  fibonacci_node<K,V> *node = new fibonacci_node_t ();\n+  fibonacci_node<K,V> *node = new fibonacci_node_t (key, data);\n \n-  return insert (node, key, data);\n+  return insert_node (node);\n }\n \n-/* Insert new NODE given by KEY and DATA associated with the key.  */\n+/* Insert new NODE given by DATA associated with the key.  */\n \n template<class K, class V>\n fibonacci_node<K,V>*\n@@ -345,6 +348,15 @@ fibonacci_heap<K,V>::insert (fibonacci_node_t *node, K key, V *data)\n   node->m_data = data;\n   node->m_key = key;\n \n+  return insert_node (node);\n+}\n+\n+/* Insert new NODE that has already filled key and value.  */\n+\n+template<class K, class V>\n+fibonacci_node<K,V>*\n+fibonacci_heap<K,V>::insert_node (fibonacci_node_t *node)\n+{\n   /* Insert it into the root list.  */\n   insert_root (node);\n \n@@ -359,6 +371,7 @@ fibonacci_heap<K,V>::insert (fibonacci_node_t *node, K key, V *data)\n }\n \n /* For given NODE, set new KEY and DATA value.  */\n+\n template<class K, class V>\n V*\n fibonacci_heap<K,V>::replace_key_data (fibonacci_node<K,V> *node, K key,\n@@ -406,7 +419,9 @@ fibonacci_heap<K,V>::replace_key_data (fibonacci_node<K,V> *node, K key,\n   return odata;\n }\n \n-/* Extract minimum node in the heap.  */\n+/* Extract minimum node in the heap.  Delete fibonacci node if RELEASE\n+   is true.  */\n+\n template<class K, class V>\n V*\n fibonacci_heap<K,V>::extract_min (bool release)\n@@ -449,7 +464,7 @@ fibonacci_heap<K,V>::delete_node (fibonacci_node<K,V> *node, bool release)\n   return ret;\n }\n \n-/* Union the heap with HEAPB.  */\n+/* Union the heap with HEAPB.  One of the heaps is going to be deleted.  */\n \n template<class K, class V>\n fibonacci_heap<K,V>*\n@@ -478,10 +493,13 @@ fibonacci_heap<K,V>::union_with (fibonacci_heap<K,V> *heapb)\n   heapa->m_nodes += heapb->m_nodes;\n \n   /* And set the new minimum, if it's changed.  */\n-  if (heapb->min->compare (heapa->min) < 0)\n+  if (heapb->m_min->compare (heapa->m_min) < 0)\n     heapa->m_min = heapb->m_min;\n \n+  /* Set m_min to NULL to not to delete live fibonacci nodes.  */\n+  heapb->m_min = NULL;\n   delete (heapb);\n+\n   return heapa;\n }\n \n@@ -544,6 +562,7 @@ fibonacci_heap<K,V>::cascading_cut (fibonacci_node<K,V> *y)\n }\n \n /* Extract minimum node from the heap.  */\n+\n template<class K, class V>\n fibonacci_node<K,V>*\n fibonacci_heap<K,V>::extract_minimum_node ()"}, {"sha": "85e101d42c3e0d97fe67eafdbfe5a5115e9e6dab", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "patch": "@@ -50,6 +50,7 @@ selftest::run_tests ()\n   wide_int_cc_tests ();\n   ggc_tests_c_tests ();\n   sreal_c_tests ();\n+  fibonacci_heap_c_tests ();\n \n   /* Mid-level data structures.  */\n   input_c_tests ();"}, {"sha": "0bee4764890d960d6d7b89fc62ec32104360b3ce", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1a7a0f859c5c3e2998a89a0b9f78198f328a94/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=ba1a7a0f859c5c3e2998a89a0b9f78198f328a94", "patch": "@@ -76,6 +76,7 @@ extern void diagnostic_c_tests ();\n extern void diagnostic_show_locus_c_tests ();\n extern void et_forest_c_tests ();\n extern void fold_const_c_tests ();\n+extern void fibonacci_heap_c_tests ();\n extern void function_tests_c_tests ();\n extern void gimple_c_tests ();\n extern void ggc_tests_c_tests ();"}]}