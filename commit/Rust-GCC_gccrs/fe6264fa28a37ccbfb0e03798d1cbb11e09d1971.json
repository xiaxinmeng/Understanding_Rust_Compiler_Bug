{"sha": "fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "node_id": "C_kwDOANBUbNoAKGZlNjI2NGZhMjhhMzdjY2JmYjBlMDM3OThkMWNiYjExZTA5ZDE5NzE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-24T11:08:58Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:07Z"}, "message": "gccrs: These are wrappers ported from reusing gccgo\n\nThe wrappers over linemap and location will eventually disappear here but\nserved as a useful starting point for us. We have wrappers over the\ndiagnostics system which we might be able to get rid of as well.\n\n\tgcc/rust/\n\t* rust-diagnostics.cc: New.\n\t* rust-diagnostics.h: New.\n\t* rust-gcc-diagnostics.cc: New.\n\t* rust-linemap.cc: New.\n\t* rust-linemap.h: New.\n\t* rust-location.h: New.\n\t* rust-system.h: New.", "tree": {"sha": "d93f66bbc9f58c59dcd51ecc61cc50e155007bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d93f66bbc9f58c59dcd51ecc61cc50e155007bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5"}], "stats": {"total": 1065, "additions": 1065, "deletions": 0}, "files": [{"sha": "c2d3e4ee8bef0a8b86206ff8c8dc8312cd227b49", "filename": "gcc/rust/rust-diagnostics.cc", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.cc?ref=fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "patch": "@@ -0,0 +1,244 @@\n+// rust-diagnostics.cc -- GCC implementation of rust diagnostics interface.\n+// Copyright (C) 2016-2022 Free Software Foundation, Inc.\n+// Contributed by Than McIntosh, Google.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+\n+static std::string\n+mformat_value ()\n+{\n+  return std::string (xstrerror (errno));\n+}\n+\n+// Rewrite a format string to expand any extensions not\n+// supported by sprintf(). See comments in rust-diagnostics.h\n+// for list of supported format specifiers.\n+\n+static std::string\n+expand_format (const char *fmt)\n+{\n+  std::stringstream ss;\n+  for (const char *c = fmt; *c; ++c)\n+    {\n+      if (*c != '%')\n+\t{\n+\t  ss << *c;\n+\t  continue;\n+\t}\n+      c++;\n+      switch (*c)\n+\t{\n+\t  case '\\0': {\n+\t    // malformed format string\n+\t    rust_unreachable ();\n+\t  }\n+\t  case '%': {\n+\t    ss << \"%\";\n+\t    break;\n+\t  }\n+\t  case 'm': {\n+\t    ss << mformat_value ();\n+\t    break;\n+\t  }\n+\t  case '<': {\n+\t    ss << rust_open_quote ();\n+\t    break;\n+\t  }\n+\t  case '>': {\n+\t    ss << rust_close_quote ();\n+\t    break;\n+\t  }\n+\t  case 'q': {\n+\t    ss << rust_open_quote ();\n+\t    c++;\n+\t    if (*c == 'm')\n+\t      {\n+\t\tss << mformat_value ();\n+\t      }\n+\t    else\n+\t      {\n+\t\tss << \"%\" << *c;\n+\t      }\n+\t    ss << rust_close_quote ();\n+\t    break;\n+\t  }\n+\t  default: {\n+\t    ss << \"%\" << *c;\n+\t  }\n+\t}\n+    }\n+  return ss.str ();\n+}\n+\n+// Expand message format specifiers, using a combination of\n+// expand_format above to handle extensions (ex: %m, %q) and vasprintf()\n+// to handle regular printf-style formatting. A pragma is being used here to\n+// suppress this warning:\n+//\n+//   warning: function \u2018std::__cxx11::string expand_message(const char*,\n+//   __va_list_tag*)\u2019 might be a candidate for \u2018gnu_printf\u2019 format attribute\n+//   [-Wsuggest-attribute=format]\n+//\n+// What appears to be happening here is that the checker is deciding that\n+// because of the call to vasprintf() (which has attribute gnu_printf), the\n+// calling function must need to have attribute gnu_printf as well, even\n+// though there is already an attribute declaration for it.\n+\n+static std::string\n+expand_message (const char *fmt, va_list ap) RUST_ATTRIBUTE_GCC_DIAG (1, 0);\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wsuggest-attribute=format\"\n+\n+static std::string\n+expand_message (const char *fmt, va_list ap)\n+{\n+  char *mbuf = 0;\n+  std::string expanded_fmt = expand_format (fmt);\n+  int nwr = vasprintf (&mbuf, expanded_fmt.c_str (), ap);\n+  if (nwr == -1)\n+    {\n+      // memory allocation failed\n+      rust_be_error_at (Linemap::unknown_location (),\n+\t\t\t\"memory allocation failed in vasprintf\");\n+      rust_assert (0);\n+    }\n+  std::string rval = std::string (mbuf);\n+  free (mbuf);\n+  return rval;\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+static const char *cached_open_quote = NULL;\n+static const char *cached_close_quote = NULL;\n+\n+const char *\n+rust_open_quote ()\n+{\n+  if (cached_open_quote == NULL)\n+    rust_be_get_quotechars (&cached_open_quote, &cached_close_quote);\n+  return cached_open_quote;\n+}\n+\n+const char *\n+rust_close_quote ()\n+{\n+  if (cached_close_quote == NULL)\n+    rust_be_get_quotechars (&cached_open_quote, &cached_close_quote);\n+  return cached_close_quote;\n+}\n+\n+void\n+rust_internal_error_at (const Location location, const char *fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  rust_be_internal_error_at (location, expand_message (fmt, ap));\n+  va_end (ap);\n+}\n+\n+void\n+rust_error_at (const Location location, const char *fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  rust_be_error_at (location, expand_message (fmt, ap));\n+  va_end (ap);\n+}\n+\n+void\n+rust_warning_at (const Location location, int opt, const char *fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  rust_be_warning_at (location, opt, expand_message (fmt, ap));\n+  va_end (ap);\n+}\n+\n+void\n+rust_fatal_error (const Location location, const char *fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  rust_be_fatal_error (location, expand_message (fmt, ap));\n+  va_end (ap);\n+}\n+\n+void\n+rust_inform (const Location location, const char *fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  rust_be_inform (location, expand_message (fmt, ap));\n+  va_end (ap);\n+}\n+\n+// Rich Locations\n+void\n+rust_error_at (const RichLocation &location, const char *fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  rust_be_error_at (location, expand_message (fmt, ap));\n+  va_end (ap);\n+}\n+\n+void\n+rust_debug_loc (const Location location, const char *fmt, ...)\n+{\n+  if (!rust_be_debug_p ())\n+    return;\n+\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  char *mbuf = NULL;\n+  int nwr = vasprintf (&mbuf, fmt, ap);\n+  va_end (ap);\n+  if (nwr == -1)\n+    {\n+      rust_be_error_at (Linemap::unknown_location (),\n+\t\t\t\"memory allocation failed in vasprintf\");\n+      rust_assert (0);\n+    }\n+  std::string rval = std::string (mbuf);\n+  free (mbuf);\n+  rust_be_inform (location, rval);\n+}\n+\n+namespace Rust {\n+Error::Error (const Location location, const char *fmt, ...) : locus (location)\n+{\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  message = expand_message (fmt, ap);\n+  va_end (ap);\n+\n+  message.shrink_to_fit ();\n+}\n+} // namespace Rust"}, {"sha": "93bd1b3237b0958e68899c6a26a09cb4c9c0c203", "filename": "gcc/rust/rust-diagnostics.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.h?ref=fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "patch": "@@ -0,0 +1,154 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// rust-diagnostics.h -- interface to diagnostic reporting   -*- C++ -*-\n+\n+#ifndef RUST_DIAGNOSTICS_H\n+#define RUST_DIAGNOSTICS_H\n+\n+#include \"rust-linemap.h\"\n+\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)\n+#define RUST_ATTRIBUTE_GCC_DIAG(m, n)                                          \\\n+  __attribute__ ((__format__ (__gcc_tdiag__, m, n)))                           \\\n+    __attribute__ ((__nonnull__ (m)))\n+#else\n+#define RUST_ATTRIBUTE_GCC_DIAG(m, n)\n+#endif\n+\n+// These declarations define the interface through which the frontend\n+// reports errors and warnings. These functions accept printf-like\n+// format specifiers (e.g. %d, %f, %s, etc), with the following additional\n+// extensions:\n+//\n+//  1.  'q' qualifier may be applied to a specifier to add quoting, e.g.\n+//      %qd produces a quoted decimal output, %qs a quoted string output.\n+//      [This extension is supported only with single-character format\n+//      specifiers].\n+//\n+//  2.  %m specifier outputs value of \"strerror(errno)\" at time of call.\n+//\n+//  3.  %< outputs an opening quote, %> a closing quote.\n+//\n+// All other format specifiers are as defined by 'sprintf'. The final resulting\n+// message is then sent to the back end via rust_be_error_at/rust_be_warning_at.\n+\n+// clang-format off\n+// simple location\n+extern void\n+rust_internal_error_at (const Location, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3)\n+  RUST_ATTRIBUTE_NORETURN;\n+extern void\n+rust_error_at (const Location, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n+extern void\n+rust_warning_at (const Location, int opt, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (3, 4);\n+extern void\n+rust_fatal_error (const Location, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3)\n+  RUST_ATTRIBUTE_NORETURN;\n+extern void\n+rust_inform (const Location, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n+\n+// rich locations\n+extern void\n+rust_error_at (const RichLocation &, const char *fmt, ...)\n+  RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n+// clang-format on\n+\n+// These interfaces provide a way for the front end to ask for\n+// the open/close quote characters it should use when formatting\n+// diagnostics (warnings, errors).\n+extern const char *\n+rust_open_quote ();\n+extern const char *\n+rust_close_quote ();\n+\n+// These interfaces are used by utilities above to pass warnings and\n+// errors (once format specifiers have been expanded) to the back end,\n+// and to determine quoting style. Avoid calling these routines directly;\n+// instead use the equivalent routines above. The back end is required to\n+// implement these routines.\n+\n+// clang-format off\n+extern void\n+rust_be_internal_error_at (const Location, const std::string &errmsg)\n+  RUST_ATTRIBUTE_NORETURN;\n+extern void\n+rust_be_error_at (const Location, const std::string &errmsg);\n+extern void\n+rust_be_error_at (const RichLocation &, const std::string &errmsg);\n+extern void\n+rust_be_warning_at (const Location, int opt, const std::string &warningmsg);\n+extern void\n+rust_be_fatal_error (const Location, const std::string &errmsg)\n+  RUST_ATTRIBUTE_NORETURN;\n+extern void\n+rust_be_inform (const Location, const std::string &infomsg);\n+extern void\n+rust_be_get_quotechars (const char **open_quote, const char **close_quote);\n+extern bool\n+rust_be_debug_p (void);\n+// clang-format on\n+\n+namespace Rust {\n+/* A structure used to represent an error. Useful for enabling\n+ * errors to be ignored, e.g. if backtracking. */\n+struct Error\n+{\n+  Location locus;\n+  std::string message;\n+  // TODO: store more stuff? e.g. node id?\n+\n+  Error (Location locus, std::string message)\n+    : locus (locus), message (std::move (message))\n+  {\n+    message.shrink_to_fit ();\n+  }\n+\n+  // TODO: the attribute part might be incorrect\n+  Error (Location locus, const char *fmt,\n+\t ...) /*RUST_ATTRIBUTE_GCC_DIAG (2, 3)*/ RUST_ATTRIBUTE_GCC_DIAG (3, 4);\n+\n+  // Irreversibly emits the error as an error.\n+  void emit_error () const { rust_error_at (locus, \"%s\", message.c_str ()); }\n+\n+  // Irreversibly emits the error as a fatal error.\n+  void emit_fatal_error () const\n+  {\n+    rust_fatal_error (locus, \"%s\", message.c_str ());\n+  }\n+};\n+} // namespace Rust\n+\n+// rust_debug uses normal printf formatting, not GCC diagnostic formatting.\n+#define rust_debug(...) rust_debug_loc (Location (), __VA_ARGS__)\n+\n+// rust_sorry_at wraps GCC diagnostic \"sorry_at\" to accept \"Location\" instead of\n+// \"location_t\"\n+#define rust_sorry_at(location, ...)                                           \\\n+  sorry_at (location.gcc_location (), __VA_ARGS__)\n+\n+void\n+rust_debug_loc (const Location location, const char *fmt,\n+\t\t...) ATTRIBUTE_PRINTF_2;\n+\n+#endif // !defined(RUST_DIAGNOSTICS_H)"}, {"sha": "db07372dfb5e68de226267ce22709b478fd67f9e", "filename": "gcc/rust/rust-gcc-diagnostics.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-gcc-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-gcc-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc-diagnostics.cc?ref=fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// rust-gcc-diagnostics.cc -- GCC implementation of rust diagnostics interface.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+\n+#include \"options.h\"\n+\n+void\n+rust_be_internal_error_at (const Location location, const std::string &errmsg)\n+{\n+  std::string loc_str = Linemap::location_to_string (location);\n+  if (loc_str.empty ())\n+    internal_error (\"%s\", errmsg.c_str ());\n+  else\n+    internal_error (\"at %s, %s\", loc_str.c_str (), errmsg.c_str ());\n+}\n+\n+void\n+rust_be_error_at (const Location location, const std::string &errmsg)\n+{\n+  location_t gcc_loc = location.gcc_location ();\n+  error_at (gcc_loc, \"%s\", errmsg.c_str ());\n+}\n+\n+void\n+rust_be_warning_at (const Location location, int opt,\n+\t\t    const std::string &warningmsg)\n+{\n+  location_t gcc_loc = location.gcc_location ();\n+  warning_at (gcc_loc, opt, \"%s\", warningmsg.c_str ());\n+}\n+\n+void\n+rust_be_fatal_error (const Location location, const std::string &fatalmsg)\n+{\n+  location_t gcc_loc = location.gcc_location ();\n+  fatal_error (gcc_loc, \"%s\", fatalmsg.c_str ());\n+}\n+\n+void\n+rust_be_inform (const Location location, const std::string &infomsg)\n+{\n+  location_t gcc_loc = location.gcc_location ();\n+  inform (gcc_loc, \"%s\", infomsg.c_str ());\n+}\n+\n+void\n+rust_be_error_at (const RichLocation &location, const std::string &errmsg)\n+{\n+  /* TODO: 'error_at' would like a non-'const' 'rich_location *'.  */\n+  rich_location &gcc_loc = const_cast<rich_location &> (location.get ());\n+  error_at (&gcc_loc, \"%s\", errmsg.c_str ());\n+}\n+\n+void\n+rust_be_get_quotechars (const char **open_qu, const char **close_qu)\n+{\n+  *open_qu = open_quote;\n+  *close_qu = close_quote;\n+}\n+\n+bool\n+rust_be_debug_p (void)\n+{\n+  return !!flag_rust_debug;\n+}"}, {"sha": "b32a965a4aaa6718977d077621602a2cfe3b2f6a", "filename": "gcc/rust/rust-linemap.cc", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.cc?ref=fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "patch": "@@ -0,0 +1,229 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// rust-linemap.cc -- GCC implementation of Linemap.\n+\n+#include \"rust-linemap.h\"\n+\n+// This class implements the Linemap interface defined by the\n+// frontend.\n+\n+class Gcc_linemap : public Linemap\n+{\n+public:\n+  Gcc_linemap () : Linemap (), in_file_ (false) {}\n+\n+  void start_file (const char *file_name, unsigned int line_begin);\n+\n+  void start_line (unsigned int line_number, unsigned int line_size);\n+\n+  Location get_location (unsigned int column);\n+\n+  void stop ();\n+\n+  std::string to_string (Location);\n+\n+  std::string location_file (Location);\n+\n+  int location_line (Location);\n+\n+  int location_column (Location);\n+\n+protected:\n+  Location get_predeclared_location ();\n+\n+  Location get_unknown_location ();\n+\n+  bool is_predeclared (Location);\n+\n+  bool is_unknown (Location);\n+\n+private:\n+  // Whether we are currently reading a file.\n+  bool in_file_;\n+};\n+\n+Linemap *Linemap::instance_ = NULL;\n+\n+// Start getting locations from a new file.\n+\n+void\n+Gcc_linemap::start_file (const char *file_name, unsigned line_begin)\n+{\n+  if (this->in_file_)\n+    linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n+  linemap_add (line_table, LC_ENTER, 0, file_name, line_begin);\n+  this->in_file_ = true;\n+}\n+\n+// Stringify a location\n+\n+std::string\n+Gcc_linemap::to_string (Location location)\n+{\n+  const line_map_ordinary *lmo;\n+  location_t resolved_location;\n+\n+  // Screen out unknown and predeclared locations; produce output\n+  // only for simple file:line locations.\n+  resolved_location\n+    = linemap_resolve_location (line_table, location.gcc_location (),\n+\t\t\t\tLRK_SPELLING_LOCATION, &lmo);\n+  if (lmo == NULL || resolved_location < RESERVED_LOCATION_COUNT)\n+    return \"\";\n+  const char *path = LINEMAP_FILE (lmo);\n+  if (!path)\n+    return \"\";\n+\n+  // Strip the source file down to the base file, to reduce clutter.\n+  std::stringstream ss;\n+  ss << lbasename (path) << \":\" << SOURCE_LINE (lmo, location.gcc_location ())\n+     << \":\" << SOURCE_COLUMN (lmo, location.gcc_location ());\n+  return ss.str ();\n+}\n+\n+// Return the file name for a given location.\n+\n+std::string\n+Gcc_linemap::location_file (Location loc)\n+{\n+  return LOCATION_FILE (loc.gcc_location ());\n+}\n+\n+// Return the line number for a given location.\n+\n+int\n+Gcc_linemap::location_line (Location loc)\n+{\n+  return LOCATION_LINE (loc.gcc_location ());\n+}\n+\n+// Return the column number for a given location.\n+int\n+Gcc_linemap::location_column (Location loc)\n+{\n+  return LOCATION_COLUMN (loc.gcc_location ());\n+}\n+\n+// Stop getting locations.\n+\n+void\n+Gcc_linemap::stop ()\n+{\n+  linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n+  this->in_file_ = false;\n+}\n+\n+// Start a new line.\n+\n+void\n+Gcc_linemap::start_line (unsigned lineno, unsigned linesize)\n+{\n+  linemap_line_start (line_table, lineno, linesize);\n+}\n+\n+// Get a location.\n+\n+Location\n+Gcc_linemap::get_location (unsigned column)\n+{\n+  return Location (linemap_position_for_column (line_table, column));\n+}\n+\n+// Get the unknown location.\n+\n+Location\n+Gcc_linemap::get_unknown_location ()\n+{\n+  return Location (UNKNOWN_LOCATION);\n+}\n+\n+// Get the predeclared location.\n+\n+Location\n+Gcc_linemap::get_predeclared_location ()\n+{\n+  return Location (BUILTINS_LOCATION);\n+}\n+\n+// Return whether a location is the predeclared location.\n+\n+bool\n+Gcc_linemap::is_predeclared (Location loc)\n+{\n+  return loc.gcc_location () == BUILTINS_LOCATION;\n+}\n+\n+// Return whether a location is the unknown location.\n+\n+bool\n+Gcc_linemap::is_unknown (Location loc)\n+{\n+  return loc.gcc_location () == UNKNOWN_LOCATION;\n+}\n+\n+// Return the Linemap to use for the gcc backend.\n+\n+Linemap *\n+rust_get_linemap ()\n+{\n+  return new Gcc_linemap;\n+}\n+\n+RichLocation::RichLocation (Location root)\n+  : gcc_rich_loc (line_table, root.gcc_location ())\n+{\n+  /*rich_location (line_maps *set, location_t loc,\n+\t\t const range_label *label = NULL);*/\n+}\n+\n+RichLocation::~RichLocation () {}\n+\n+void\n+RichLocation::add_range (Location loc)\n+{\n+  gcc_rich_loc.add_range (loc.gcc_location ());\n+}\n+\n+void\n+RichLocation::add_fixit_insert_before (const std::string &new_parent)\n+{\n+  gcc_rich_loc.add_fixit_insert_before (new_parent.c_str ());\n+}\n+\n+void\n+RichLocation::add_fixit_insert_before (Location where,\n+\t\t\t\t       const std::string &new_parent)\n+{\n+  gcc_rich_loc.add_fixit_insert_before (where.gcc_location (),\n+\t\t\t\t\tnew_parent.c_str ());\n+}\n+\n+void\n+RichLocation::add_fixit_insert_after (const std::string &new_parent)\n+{\n+  gcc_rich_loc.add_fixit_insert_after (new_parent.c_str ());\n+}\n+\n+void\n+RichLocation::add_fixit_insert_after (Location where,\n+\t\t\t\t      const std::string &new_parent)\n+{\n+  gcc_rich_loc.add_fixit_insert_after (where.gcc_location (),\n+\t\t\t\t       new_parent.c_str ());\n+}"}, {"sha": "0ba95f87575de21885db2ef76dc2cd593112296a", "filename": "gcc/rust/rust-linemap.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-linemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-linemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.h?ref=fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "patch": "@@ -0,0 +1,163 @@\n+// rust-linemap.h -- interface to location tracking   -*- C++ -*-\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the '../go/gofrontend/LICENSE' file.\n+\n+#ifndef RUST_LINEMAP_H\n+#define RUST_LINEMAP_H\n+\n+#include \"rust-system.h\"\n+\n+// The backend must define a type named Location which holds\n+// information about a location in a source file.  The only thing the\n+// frontend does with instances of Location is pass them back to the\n+// backend interface.  The Location type must be assignable, and it\n+// must be comparable: i.e., it must support operator= and operator<.\n+// The type is normally passed by value rather than by reference, and\n+// it should support that efficiently.  The type should be defined in\n+// \"rust-location.h\".\n+#include \"rust-location.h\"\n+\n+// The Linemap class is a pure abstract interface, plus some static\n+// convenience functions.  The backend must implement the interface.\n+\n+/* TODO: probably better to replace linemap implementation as pure abstract\n+ * interface with some sort of compile-time switch (macros or maybe templates if\n+ * doable without too much extra annoyance) as to the definition of the methods\n+ * or whatever. This is to improve performance, as virtual function calls would\n+ * otherwise have to be made in tight loops like in the lexer. */\n+\n+class Linemap\n+{\n+public:\n+  Linemap ()\n+  {\n+    // Only one instance of Linemap is allowed to exist.\n+    rust_assert (Linemap::instance_ == NULL);\n+    Linemap::instance_ = this;\n+  }\n+\n+  virtual ~Linemap () { Linemap::instance_ = NULL; }\n+\n+  // Subsequent Location values will come from the file named\n+  // FILE_NAME, starting at LINE_BEGIN.  Normally LINE_BEGIN will be\n+  // 0, but it will be non-zero if the Rust source has a //line comment.\n+  virtual void start_file (const char *file_name, unsigned int line_begin) = 0;\n+\n+  // Subsequent Location values will come from the line LINE_NUMBER,\n+  // in the current file.  LINE_SIZE is the size of the line in bytes.\n+  // This will normally be called for every line in a source file.\n+  virtual void start_line (unsigned int line_number, unsigned int line_size)\n+    = 0;\n+\n+  // Get a Location representing column position COLUMN on the current\n+  // line in the current file.\n+  virtual Location get_location (unsigned int column) = 0;\n+\n+  // Stop generating Location values.  This will be called after all\n+  // input files have been read, in case any cleanup is required.\n+  virtual void stop () = 0;\n+\n+  // Produce a human-readable description of a Location, e.g.\n+  // \"foo.rust:10\". Returns an empty string for predeclared, builtin or\n+  // unknown locations.\n+  virtual std::string to_string (Location) = 0;\n+\n+  // Return the file name for a given location.\n+  virtual std::string location_file (Location) = 0;\n+\n+  // Return the line number for a given location.\n+  virtual int location_line (Location) = 0;\n+\n+  // Return the column number for a given location.\n+  virtual int location_column (Location) = 0;\n+\n+protected:\n+  // Return a special Location used for predeclared identifiers.  This\n+  // Location should be different from that for any actual source\n+  // file.  This location will be used for various different types,\n+  // functions, and objects created by the frontend.\n+  virtual Location get_predeclared_location () = 0;\n+\n+  // Return a special Location which indicates that no actual location\n+  // is known.  This is used for undefined objects and for errors.\n+  virtual Location get_unknown_location () = 0;\n+\n+  // Return whether the argument is the Location returned by\n+  // get_predeclared_location.\n+  virtual bool is_predeclared (Location) = 0;\n+\n+  // Return whether the argument is the Location returned by\n+  // get_unknown_location.\n+  virtual bool is_unknown (Location) = 0;\n+\n+  // The single existing instance of Linemap.\n+  static Linemap *instance_;\n+\n+public:\n+  // Following are convenience static functions, which allow us to\n+  // access some virtual functions without explicitly passing around\n+  // an instance of Linemap.\n+\n+  // Return the special Location used for predeclared identifiers.\n+  static Location predeclared_location ()\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->get_predeclared_location ();\n+  }\n+\n+  // Return the special Location used when no location is known.\n+  static Location unknown_location ()\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->get_unknown_location ();\n+  }\n+\n+  // Return whether the argument is the special location used for\n+  // predeclared identifiers.\n+  static bool is_predeclared_location (Location loc)\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->is_predeclared (loc);\n+  }\n+\n+  // Return whether the argument is the special location used when no\n+  // location is known.\n+  static bool is_unknown_location (Location loc)\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->is_unknown (loc);\n+  }\n+\n+  // Produce a human-readable description of a Location.\n+  static std::string location_to_string (Location loc)\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->to_string (loc);\n+  }\n+\n+  // Return the file name of a location.\n+  static std::string location_to_file (Location loc)\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->location_file (loc);\n+  }\n+\n+  // Return line number of a location.\n+  static int location_to_line (Location loc)\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->location_line (loc);\n+  }\n+\n+  static int location_to_column (Location loc)\n+  {\n+    rust_assert (Linemap::instance_ != NULL);\n+    return Linemap::instance_->location_column (loc);\n+  }\n+};\n+\n+#endif // !defined(RUST_LINEMAP_H)"}, {"sha": "1bb875fe6a41823fdce5e0bdeb5a62e24564be15", "filename": "gcc/rust/rust-location.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-location.h?ref=fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "patch": "@@ -0,0 +1,105 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// rust-location.h -- GCC specific Location declaration.   -*- C++ -*-\n+\n+#ifndef RUST_LOCATION_H\n+#define RUST_LOCATION_H\n+\n+#include \"rust-system.h\"\n+\n+// A location in an input source file.\n+\n+class Location\n+{\n+public:\n+  Location () : gcc_loc_ (UNKNOWN_LOCATION) {}\n+\n+  explicit Location (location_t loc) : gcc_loc_ (loc) {}\n+\n+  location_t gcc_location () const { return gcc_loc_; }\n+\n+  Location operator+= (location_t rhs)\n+  {\n+    gcc_loc_ += rhs;\n+    return *this;\n+  }\n+\n+  Location operator-= (location_t rhs)\n+  {\n+    gcc_loc_ -= rhs;\n+    return *this;\n+  }\n+\n+  bool operator== (location_t rhs) { return rhs == gcc_loc_; }\n+\n+private:\n+  location_t gcc_loc_;\n+};\n+\n+// The Rust frontend requires the ability to compare Locations.\n+\n+inline bool\n+operator< (Location loca, Location locb)\n+{\n+  return loca.gcc_location () < locb.gcc_location ();\n+}\n+\n+inline bool\n+operator== (Location loca, Location locb)\n+{\n+  return loca.gcc_location () == locb.gcc_location ();\n+}\n+\n+inline Location\n+operator+ (Location lhs, location_t rhs)\n+{\n+  lhs += rhs;\n+  return lhs;\n+}\n+\n+inline Location\n+operator- (Location lhs, location_t rhs)\n+{\n+  lhs -= rhs;\n+  return lhs;\n+}\n+\n+class RichLocation\n+{\n+public:\n+  RichLocation (Location root);\n+  ~RichLocation ();\n+\n+  void add_range (Location loc);\n+\n+  void add_fixit_insert_before (const std::string &new_parent);\n+\n+  void add_fixit_insert_before (Location where, const std::string &new_parent);\n+\n+  void add_fixit_insert_after (const std::string &new_parent);\n+\n+  void add_fixit_insert_after (Location where, const std::string &new_parent);\n+\n+  const rich_location &get () const { return gcc_rich_loc; }\n+\n+private:\n+  rich_location gcc_rich_loc;\n+};\n+\n+#endif // !defined(RUST_LOCATION_H)"}, {"sha": "3a600237966314b6dc761887ed1f1176bcdadce1", "filename": "gcc/rust/rust-system.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6264fa28a37ccbfb0e03798d1cbb11e09d1971/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=fe6264fa28a37ccbfb0e03798d1cbb11e09d1971", "patch": "@@ -0,0 +1,86 @@\n+// rust-system.h -- Rust frontend inclusion of gcc header files   -*- C++ -*-\n+// Copyright (C) 2009-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_SYSTEM_H\n+#define RUST_SYSTEM_H\n+\n+#define INCLUDE_ALGORITHM\n+#include \"config.h\"\n+\n+/* Define this so that inttypes.h defines the PRI?64 macros even\n+   when compiling with a C++ compiler.  Define it here so in the\n+   event inttypes.h gets pulled in by another header it is already\n+   defined.  */\n+#define __STDC_FORMAT_MACROS\n+\n+// These must be included before the #poison declarations in system.h.\n+\n+#include <string>\n+#include <list>\n+#include <map>\n+#include <set>\n+#include <vector>\n+#include <sstream>\n+#include <string>\n+#include <deque>\n+#include <functional>\n+#include <memory>\n+#include <utility>\n+#include <fstream>\n+\n+// Rust frontend requires C++11 minimum, so will have unordered_map and set\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+/* We don't really need iostream, but some versions of gmp.h include\n+ * it when compiled with C++, which means that we need to include it\n+ * before the macro magic of safe-ctype.h, which is included by\n+ * system.h. */\n+#include <iostream>\n+\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"coretypes.h\"\n+\n+#include \"diagnostic-core.h\" /* For error_at and friends.  */\n+#include \"intl.h\"\t     /* For _().  */\n+\n+#define RUST_ATTRIBUTE_NORETURN ATTRIBUTE_NORETURN\n+\n+// File separator to use based on whether or not the OS we're working with is\n+// DOS-based\n+#if defined(HAVE_DOS_BASED_FILE_SYSTEM)\n+constexpr static const char *file_separator = \"\\\\\";\n+#else\n+constexpr static const char *file_separator = \"/\";\n+#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n+\n+// When using gcc, rust_assert is just gcc_assert.\n+#define rust_assert(EXPR) gcc_assert (EXPR)\n+\n+// When using gcc, rust_unreachable is just gcc_unreachable.\n+#define rust_unreachable() gcc_unreachable ()\n+\n+extern void\n+rust_preserve_from_gc (tree t);\n+\n+extern const char *\n+rust_localize_identifier (const char *ident);\n+\n+#endif // !defined(RUST_SYSTEM_H)"}]}