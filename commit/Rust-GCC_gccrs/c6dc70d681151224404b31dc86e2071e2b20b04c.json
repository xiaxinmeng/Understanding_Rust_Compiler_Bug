{"sha": "c6dc70d681151224404b31dc86e2071e2b20b04c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZkYzcwZDY4MTE1MTIyNDQwNGIzMWRjODZlMjA3MWUyYjIwYjA0Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-08T22:26:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-08T22:26:25Z"}, "message": "(BYTE_LOAD_EXTEND, LOAD_EXTEND): New macros.\n\n(subst, simplify_and_const_int, nonzero_bits, num_sign_bit_copies): Use them.\n(subst, case SET): Make a SIGN_EXTEND instead of paradoxical SUBREG if\nBYTE_LOADS_SIGN_EXTEND; previously only made ZERO_EXTEND.\n\nFrom-SVN: r3160", "tree": {"sha": "6f2fef91cf83dbb3a0db6db6cd9d66ccb5cd27cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f2fef91cf83dbb3a0db6db6cd9d66ccb5cd27cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6dc70d681151224404b31dc86e2071e2b20b04c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6dc70d681151224404b31dc86e2071e2b20b04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6dc70d681151224404b31dc86e2071e2b20b04c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6dc70d681151224404b31dc86e2071e2b20b04c/comments", "author": null, "committer": null, "parents": [{"sha": "f093e272e4161153eed536094f29516f13463904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f093e272e4161153eed536094f29516f13463904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f093e272e4161153eed536094f29516f13463904"}], "stats": {"total": 31, "additions": 23, "deletions": 8}, "files": [{"sha": "ef7bc4186e255157a5044dc0c8b03e863293bea4", "filename": "gcc/combine.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6dc70d681151224404b31dc86e2071e2b20b04c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6dc70d681151224404b31dc86e2071e2b20b04c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c6dc70d681151224404b31dc86e2071e2b20b04c", "patch": "@@ -92,6 +92,20 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    Use gen_lowpart_for_combine instead.  See comments there.  */\n #define gen_lowpart dont_use_gen_lowpart_you_dummy\n \n+/* If byte loads either zero- or sign- extend, define BYTE_LOADS_EXTEND\n+   for cases when we don't care which is true.  Define LOAD_EXTEND to\n+   be ZERO_EXTEND or SIGN_EXTEND, depending on which was defined.  */\n+\n+#ifdef BYTE_LOADS_ZERO_EXTEND\n+#define BYTE_LOADS_EXTEND\n+#define LOAD_EXTEND ZERO_EXTEND\n+#endif\n+\n+#ifdef BYTE_LOAD_SIGN_EXTEND\n+#define BYTE_LOADS_EXTEND\n+#define LOAD_EXTEND SIGN_EXTEND\n+#endif\n+\n /* Number of attempts to combine instructions in this function.  */\n \n static int combine_attempts;\n@@ -3822,8 +3836,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t We can always do this if M1 is narrower than M2 because that\n \t means that we only care about the low bits of the result.\n \n-\t However, on most machines (those with BYTE_LOADS_ZERO_EXTEND\n-\t and BYTES_LOADS_SIGN_EXTEND not defined), we cannot perform a\n+\t However, on most machines (those with neither BYTE_LOADS_ZERO_EXTEND\n+\t nor BYTES_LOADS_SIGN_EXTEND defined), we cannot perform a\n \t narrower operation that requested since the high-order bits will\n \t be undefined.  On machine where BYTE_LOADS_*_EXTEND is defined,\n \t however, this transformation is safe as long as M1 and M2 have\n@@ -3836,7 +3850,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t       / UNITS_PER_WORD)\n \t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x))))\n \t\t   + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n-#if ! defined(BYTE_LOADS_ZERO_EXTEND) && ! defined (BYTE_LOADS_SIGN_EXTEND)\n+#ifndef BYTE_LOADS_EXTEND\n \t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n \t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n #endif\n@@ -3850,18 +3864,19 @@ subst (x, from, to, in_dest, unique_copy)\n \t  SUBST (SET_SRC (x), SUBREG_REG (SET_SRC (x)));\n \t}\n \n-#ifdef BYTE_LOADS_ZERO_EXTEND\n+#ifdef BYTE_LOADS_EXTEND\n       /* If we have (set FOO (subreg:M (mem:N BAR) 0)) with\n \t M wider than N, this would require a paradoxical subreg.\n \t Replace the subreg with a zero_extend to avoid the reload that\n \t would otherwise be required. */\n+\n       if (GET_CODE (SET_SRC (x)) == SUBREG\n \t  && subreg_lowpart_p (SET_SRC (x))\n \t  && SUBREG_WORD (SET_SRC (x)) == 0\n \t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n \t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n \t  && GET_CODE (SUBREG_REG (SET_SRC (x))) == MEM)\n-\tSUBST (SET_SRC (x), gen_rtx_combine (ZERO_EXTEND,\n+\tSUBST (SET_SRC (x), gen_rtx_combine (LOAD_EXTEND,\n \t\t\t\t\t     GET_MODE (SET_SRC (x)),\n \t\t\t\t\t     XEXP (SET_SRC (x), 0)));\n #endif\n@@ -5675,7 +5690,7 @@ simplify_and_const_int (x, mode, varop, constop)\n \t\t constant masks to zero all the bits the mode doesn't have.  */\n \t      && ((GET_MODE_SIZE (GET_MODE (varop))\n \t\t   < GET_MODE_SIZE (GET_MODE (SUBREG_REG (varop))))\n-#if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n+#ifdef BYTE_LOADS_EXTEND\n \t\t  || (0 == (constop\n \t\t\t    & GET_MODE_MASK (GET_MODE (varop))\n \t\t\t    & ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (varop)))))\n@@ -6144,7 +6159,7 @@ nonzero_bits (x, mode)\n \t      <= HOST_BITS_PER_WIDE_INT))\n \t{\n \t  nonzero &= nonzero_bits (SUBREG_REG (x), mode);\n-#if ! defined(BYTE_LOADS_ZERO_EXTEND) && ! defined(BYTE_LOADS_SIGN_EXTEND)\n+#ifndef BYTE_LOADS_EXTEND\n \t  /* On many CISC machines, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n \t     not known to be zero.  */\n@@ -6290,7 +6305,7 @@ num_sign_bit_copies (x, mode)\n \t\t\t     - bitwidth)));\n \t}\n \n-#if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n+#ifdef BYTE_LOADS_EXTEND\n       /* For paradoxical SUBREGs, just look inside since, on machines with\n \t one of these defined, we assume that operations are actually \n \t performed on the full register.  Note that we are passing MODE"}]}