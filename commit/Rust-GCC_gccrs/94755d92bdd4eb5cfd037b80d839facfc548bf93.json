{"sha": "94755d92bdd4eb5cfd037b80d839facfc548bf93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3NTVkOTJiZGQ0ZWI1Y2ZkMDM3YjgwZDgzOWZhY2ZjNTQ4YmY5Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-23T20:48:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-23T20:48:38Z"}, "message": "integrate.h (copy_decl_for_inlining): New declaration.\n\n1999-11-23  Mark Mitchell  <mark@codesourcery.com>\n\n\t* integrate.h (copy_decl_for_inlining): New declaration.\n\t* integrate.c (copy_and_set_decl_abstract_origin): Remove.\n\t(copy_decl_for_inlining): New function.\n\t(integrate_parm_decls): Use it.\n\t(integrate_decl_tree): Likewise.\n\nFrom-SVN: r30644", "tree": {"sha": "fd26fb2c910650dc8f518a2e4cf6cb9d30da6028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd26fb2c910650dc8f518a2e4cf6cb9d30da6028"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94755d92bdd4eb5cfd037b80d839facfc548bf93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94755d92bdd4eb5cfd037b80d839facfc548bf93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94755d92bdd4eb5cfd037b80d839facfc548bf93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94755d92bdd4eb5cfd037b80d839facfc548bf93/comments", "author": null, "committer": null, "parents": [{"sha": "76ee804272089646a4c554ddf6be4471fb589b62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76ee804272089646a4c554ddf6be4471fb589b62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76ee804272089646a4c554ddf6be4471fb589b62"}], "stats": {"total": 109, "additions": 63, "deletions": 46}, "files": [{"sha": "f03893ac2ae53205a28459a4fbe35c76d87826e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94755d92bdd4eb5cfd037b80d839facfc548bf93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94755d92bdd4eb5cfd037b80d839facfc548bf93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94755d92bdd4eb5cfd037b80d839facfc548bf93", "patch": "@@ -1,3 +1,11 @@\n+1999-11-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* integrate.h (copy_decl_for_inlining): New declaration.\n+\t* integrate.c (copy_and_set_decl_abstract_origin): Remove.\n+\t(copy_decl_for_inlining): New function.\n+\t(integrate_parm_decls): Use it.\n+\t(integrate_decl_tree): Likewise.\n+\n 1999-11-23  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* config/mips/mips.h (ISA_HAS_FP4,ISA_HAS_CONDMOVE,ISA_HAS_8CC): Split "}, {"sha": "5acc2d1481ff380b311e27a159775730a3d475c2", "filename": "gcc/integrate.c", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94755d92bdd4eb5cfd037b80d839facfc548bf93/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94755d92bdd4eb5cfd037b80d839facfc548bf93/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=94755d92bdd4eb5cfd037b80d839facfc548bf93", "patch": "@@ -76,7 +76,6 @@ static void set_block_abstract_flags\tPROTO((tree, int));\n static void process_reg_param\t\tPROTO((struct inline_remap *, rtx,\n \t\t\t\t\t       rtx));\n void set_decl_abstract_flags\t\tPROTO((tree, int));\n-static tree copy_and_set_decl_abstract_origin PROTO((tree));\n static rtx expand_inline_function_eh_labelmap PROTO((rtx));\n static void mark_stores                 PROTO((rtx, rtx, void *));\n \n@@ -296,23 +295,56 @@ initialize_for_inline (fndecl)\n   return arg_vector;\n }\n \n-/* Copy NODE (as with copy_node).  NODE must be a DECL.  Set the\n-   DECL_ABSTRACT_ORIGIN for the new accordinly.  */\n+/* Copy NODE (which must be a DECL, but not a PARM_DECL).  The DECL\n+   originally was in the FROM_FN, but now it will be in the \n+   TO_FN.  */\n \n-static tree\n-copy_and_set_decl_abstract_origin (node)\n-     tree node;\n+tree\n+copy_decl_for_inlining (decl, from_fn, to_fn)\n+     tree decl;\n+     tree from_fn;\n+     tree to_fn;\n {\n-  tree copy = copy_node (node);\n-  if (DECL_ABSTRACT_ORIGIN (copy) != NULL_TREE)\n-    /* That means that NODE already had a DECL_ABSTRACT_ORIGIN.  (This\n-       situation occurs if we inline a function which itself made\n-       calls to inline functions.)  Since DECL_ABSTRACT_ORIGIN is the\n-       most distant ancestor, we don't have to do anything here.  */\n+  tree copy;\n+\n+  /* Copy the declaration.  */\n+  if (TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == RESULT_DECL)\n+    /* For a parameter, we must make an equivalent VAR_DECL, not a\n+       new PARM_DECL.  */\n+    copy = build_decl (VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n+  else\n+    {\n+      copy = copy_node (decl);\n+      if (DECL_LANG_SPECIFIC (copy))\n+\tcopy_lang_decl (copy);\n+    }\n+\n+  /* Set the DECL_ABSTRACT_ORIGIN so the debugging routines know what\n+     declaration inspired this copy.  */\n+  DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (decl);\n+\n+  /* The new variable/label has no RTL, yet.  */\n+  DECL_RTL (copy) = NULL_RTX;\n+\n+  /* These args would always appear unused, if not for this.  */\n+  TREE_USED (copy) = 1;\n+\n+  /* Set the context for the new declaration.  */\n+  if (!DECL_CONTEXT (decl))\n+    /* Globals stay global.  */\n+\t;\n+  else if (DECL_CONTEXT (decl) != from_fn)\n+    /* Things that weren't in the scope of the function we're inlining\n+       from aren't in the scope we're inlining too, either.  */\n+    ;\n+  else if (TREE_STATIC (decl))\n+    /* Function-scoped static variables should say in the original\n+       function.  */\n     ;\n   else\n-    /* The most distant ancestor must be NODE.  */\n-    DECL_ABSTRACT_ORIGIN (copy) = node;\n+    /* Ordinary automatic local variables are now in the scope of the\n+       new function.  */\n+    DECL_CONTEXT (copy) = to_fn;\n \n   return copy;\n }\n@@ -1384,20 +1416,14 @@ integrate_parm_decls (args, map, arg_vector)\n \n   for (tail = args, i = 0; tail; tail = TREE_CHAIN (tail), i++)\n     {\n-      register tree decl = build_decl (VAR_DECL, DECL_NAME (tail),\n-\t\t\t\t       TREE_TYPE (tail));\n+      tree decl = copy_decl_for_inlining (tail, map->fndecl,\n+\t\t\t\t\t  current_function_decl);\n       rtx new_decl_rtl\n \t= copy_rtx_and_substitute (RTVEC_ELT (arg_vector, i), map, 1);\n \n-      DECL_ARG_TYPE (decl) = DECL_ARG_TYPE (tail);\n       /* We really should be setting DECL_INCOMING_RTL to something reasonable\n \t here, but that's going to require some more work.  */\n       /* DECL_INCOMING_RTL (decl) = ?; */\n-      /* These args would always appear unused, if not for this.  */\n-      TREE_USED (decl) = 1;\n-      /* Prevent warning for shadowing with these.  */\n-      DECL_ABSTRACT_ORIGIN (decl) = DECL_ORIGIN (tail);\n-      DECL_CONTEXT (decl) = current_function_decl;\n       /* Fully instantiate the address with the equivalent form so that the\n \t debugging information contains the actual register, instead of the\n \t virtual register.   Do this by not passing an insn to\n@@ -1433,7 +1459,7 @@ integrate_decl_tree (let, map)\n \n       push_obstacks_nochange ();\n       saveable_allocation ();\n-      d = copy_and_set_decl_abstract_origin (t);\n+      d = copy_decl_for_inlining (t, map->fndecl, current_function_decl);\n       pop_obstacks ();\n \n       if (DECL_RTL (t) != 0)\n@@ -1447,29 +1473,6 @@ integrate_decl_tree (let, map)\n \t  subst_constants (&DECL_RTL (d), NULL_RTX, map, 1);\n \t  apply_change_group ();\n \t}\n-      /* These args would always appear unused, if not for this.  */\n-      TREE_USED (d) = 1;\n-\n-      if (DECL_LANG_SPECIFIC (d))\n-\tcopy_lang_decl (d);\n-\n-      /* Set the context for the new declaration.  */\n-      if (!DECL_CONTEXT (t))\n-\t/* Globals stay global.  */\n-\t;\n-      else if (DECL_CONTEXT (t) != map->fndecl)\n-\t/* Things that weren't in the scope of the function we're\n-\t   inlining from aren't in the scope we're inlining too,\n-\t   either.  */\n-\t;\n-      else if (TREE_STATIC (t))\n-\t/* Function-scoped static variables should say in the original\n-\t   function.  */\n-\t;\n-      else\n-\t/* Ordinary automatic local variables are now in the scope of\n-\t   the new function.  */\n-\tDECL_CONTEXT (d) = current_function_decl;\n \n       /* Add this declaration to the list of variables in the new\n \t block.  */"}, {"sha": "88bcd53960b2040edc0b82a284b6d54e58f30f3f", "filename": "gcc/integrate.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94755d92bdd4eb5cfd037b80d839facfc548bf93/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94755d92bdd4eb5cfd037b80d839facfc548bf93/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=94755d92bdd4eb5cfd037b80d839facfc548bf93", "patch": "@@ -116,6 +116,12 @@ struct inline_remap\n    labels, and frame-pointer offsets as necessary.  */\n extern rtx copy_rtx_and_substitute PROTO((rtx, struct inline_remap *, int));\n \n+/* Copy a declaration when one function is substituted inline into\n+   another.  */\n+extern union tree_node *copy_decl_for_inlining PROTO((union tree_node *,\n+\t\t\t\t\t\t      union tree_node *,\n+\t\t\t\t\t\t      union tree_node *));\n+\n extern void try_constants PROTO((rtx, struct inline_remap *));\n \n /* Return the label indicated.  */"}]}