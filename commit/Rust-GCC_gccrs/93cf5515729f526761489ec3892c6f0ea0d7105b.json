{"sha": "93cf5515729f526761489ec3892c6f0ea0d7105b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjZjU1MTU3MjlmNTI2NzYxNDg5ZWMzODkyYzZmMGVhMGQ3MTA1Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-08-14T12:04:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-08-14T12:04:05Z"}, "message": "re PR rtl-optimization/91154 (456.hmmer regression on Haswell caused by r272922)\n\n2019-08-14  Richard Biener  <rguenther@suse.de>\n        Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\n\tPR target/91154\n\t* config/i386/i386-features.h (scalar_chain::scalar_chain): Add\n\tmode arguments.\n\t(scalar_chain::smode): New member.\n\t(scalar_chain::vmode): Likewise.\n\t(dimode_scalar_chain): Rename to...\n\t(general_scalar_chain): ... this.\n\t(general_scalar_chain::general_scalar_chain): Take mode arguments.\n\t(timode_scalar_chain::timode_scalar_chain): Initialize scalar_chain\n\tbase with TImode and V1TImode.\n\t* config/i386/i386-features.c (scalar_chain::scalar_chain): Adjust.\n\t(general_scalar_chain::vector_const_cost): Adjust for SImode\n\tchains.\n\t(general_scalar_chain::compute_convert_gain): Likewise.  Add\n\t{S,U}{MIN,MAX} support.\n\t(general_scalar_chain::replace_with_subreg): Use vmode/smode.\n\t(general_scalar_chain::make_vector_copies): Likewise.  Handle\n\tnon-DImode chains appropriately.\n\t(general_scalar_chain::convert_reg): Likewise.\n\t(general_scalar_chain::convert_op): Likewise.\n\t(general_scalar_chain::convert_insn): Likewise.  Add\n\tfatal_insn_not_found if the result is not recognized.\n\t(convertible_comparison_p): Pass in the scalar mode and use that.\n\t(general_scalar_to_vector_candidate_p): Likewise.  Rename from\n\tdimode_scalar_to_vector_candidate_p.  Add {S,U}{MIN,MAX} support.\n\t(scalar_to_vector_candidate_p): Remove by inlining into single\n\tcaller.\n\t(general_remove_non_convertible_regs): Rename from\n\tdimode_remove_non_convertible_regs.\n\t(remove_non_convertible_regs): Remove by inlining into single caller.\n\t(convert_scalars_to_vector): Handle SImode and DImode chains\n\tin addition to TImode chains.\n\t* config/i386/i386.md (<maxmin><MAXMIN_IMODE>3): New expander.\n\t(*<maxmin><MAXMIN_IMODE>3_1): New insn-and-split.\n\t(*<maxmin>di3_doubleword): Likewise.\n\n\t* gcc.target/i386/pr91154.c: New testcase.\n\t* gcc.target/i386/minmax-3.c: Likewise.\n\t* gcc.target/i386/minmax-4.c: Likewise.\n\t* gcc.target/i386/minmax-5.c: Likewise.\n\t* gcc.target/i386/minmax-6.c: Likewise.\n\t* gcc.target/i386/minmax-1.c: Add -mno-stv.\n\t* gcc.target/i386/minmax-2.c: Likewise.\n\nCo-Authored-By: Uros Bizjak <ubizjak@gmail.com>\n\nFrom-SVN: r274481", "tree": {"sha": "4776032dfeba22334b1afe3a5c6ae1558ef7d899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4776032dfeba22334b1afe3a5c6ae1558ef7d899"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93cf5515729f526761489ec3892c6f0ea0d7105b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cf5515729f526761489ec3892c6f0ea0d7105b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93cf5515729f526761489ec3892c6f0ea0d7105b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cf5515729f526761489ec3892c6f0ea0d7105b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b187f36ec16d43d0227805955d8fae51af26970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b187f36ec16d43d0227805955d8fae51af26970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b187f36ec16d43d0227805955d8fae51af26970"}], "stats": {"total": 706, "additions": 523, "deletions": 183}, "files": [{"sha": "d745e1dfd74f1d2417490e97489c212c8f782857", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -1,3 +1,42 @@\n+2019-08-14  Richard Biener  <rguenther@suse.de>\n+\tUro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/91154\n+\t* config/i386/i386-features.h (scalar_chain::scalar_chain): Add\n+\tmode arguments.\n+\t(scalar_chain::smode): New member.\n+\t(scalar_chain::vmode): Likewise.\n+\t(dimode_scalar_chain): Rename to...\n+\t(general_scalar_chain): ... this.\n+\t(general_scalar_chain::general_scalar_chain): Take mode arguments.\n+\t(timode_scalar_chain::timode_scalar_chain): Initialize scalar_chain\n+\tbase with TImode and V1TImode.\n+\t* config/i386/i386-features.c (scalar_chain::scalar_chain): Adjust.\n+\t(general_scalar_chain::vector_const_cost): Adjust for SImode\n+\tchains.\n+\t(general_scalar_chain::compute_convert_gain): Likewise.  Add\n+\t{S,U}{MIN,MAX} support.\n+\t(general_scalar_chain::replace_with_subreg): Use vmode/smode.\n+\t(general_scalar_chain::make_vector_copies): Likewise.  Handle\n+\tnon-DImode chains appropriately.\n+\t(general_scalar_chain::convert_reg): Likewise.\n+\t(general_scalar_chain::convert_op): Likewise.\n+\t(general_scalar_chain::convert_insn): Likewise.  Add\n+\tfatal_insn_not_found if the result is not recognized.\n+\t(convertible_comparison_p): Pass in the scalar mode and use that.\n+\t(general_scalar_to_vector_candidate_p): Likewise.  Rename from\n+\tdimode_scalar_to_vector_candidate_p.  Add {S,U}{MIN,MAX} support.\n+\t(scalar_to_vector_candidate_p): Remove by inlining into single\n+\tcaller.\n+\t(general_remove_non_convertible_regs): Rename from\n+\tdimode_remove_non_convertible_regs.\n+\t(remove_non_convertible_regs): Remove by inlining into single caller.\n+\t(convert_scalars_to_vector): Handle SImode and DImode chains\n+\tin addition to TImode chains.\n+\t* config/i386/i386.md (<maxmin><MAXMIN_IMODE>3): New expander.\n+\t(*<maxmin><MAXMIN_IMODE>3_1): New insn-and-split.\n+\t(*<maxmin>di3_doubleword): Likewise.\n+\n 2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n "}, {"sha": "688400757a69b21cb9d6de56cc9237d015a2613e", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 269, "deletions": 179, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -276,8 +276,11 @@ unsigned scalar_chain::max_id = 0;\n \n /* Initialize new chain.  */\n \n-scalar_chain::scalar_chain ()\n+scalar_chain::scalar_chain (enum machine_mode smode_, enum machine_mode vmode_)\n {\n+  smode = smode_;\n+  vmode = vmode_;\n+\n   chain_id = ++max_id;\n \n    if (dump_file)\n@@ -319,7 +322,7 @@ scalar_chain::add_to_queue (unsigned insn_uid)\n    conversion.  */\n \n void\n-dimode_scalar_chain::mark_dual_mode_def (df_ref def)\n+general_scalar_chain::mark_dual_mode_def (df_ref def)\n {\n   gcc_assert (DF_REF_REG_DEF_P (def));\n \n@@ -409,6 +412,9 @@ scalar_chain::add_insn (bitmap candidates, unsigned int insn_uid)\n       && !HARD_REGISTER_P (SET_DEST (def_set)))\n     bitmap_set_bit (defs, REGNO (SET_DEST (def_set)));\n \n+  /* ???  The following is quadratic since analyze_register_chain\n+     iterates over all refs to look for dual-mode regs.  Instead this\n+     should be done separately for all regs mentioned in the chain once.  */\n   df_ref ref;\n   df_ref def;\n   for (ref = DF_INSN_UID_DEFS (insn_uid); ref; ref = DF_REF_NEXT_LOC (ref))\n@@ -469,19 +475,21 @@ scalar_chain::build (bitmap candidates, unsigned insn_uid)\n    instead of using a scalar one.  */\n \n int\n-dimode_scalar_chain::vector_const_cost (rtx exp)\n+general_scalar_chain::vector_const_cost (rtx exp)\n {\n   gcc_assert (CONST_INT_P (exp));\n \n-  if (standard_sse_constant_p (exp, V2DImode))\n-    return COSTS_N_INSNS (1);\n-  return ix86_cost->sse_load[1];\n+  if (standard_sse_constant_p (exp, vmode))\n+    return ix86_cost->sse_op;\n+  /* We have separate costs for SImode and DImode, use SImode costs\n+     for smaller modes.  */\n+  return ix86_cost->sse_load[smode == DImode ? 1 : 0];\n }\n \n /* Compute a gain for chain conversion.  */\n \n int\n-dimode_scalar_chain::compute_convert_gain ()\n+general_scalar_chain::compute_convert_gain ()\n {\n   bitmap_iterator bi;\n   unsigned insn_uid;\n@@ -491,6 +499,13 @@ dimode_scalar_chain::compute_convert_gain ()\n   if (dump_file)\n     fprintf (dump_file, \"Computing gain for chain #%d...\\n\", chain_id);\n \n+  /* SSE costs distinguish between SImode and DImode loads/stores, for\n+     int costs factor in the number of GPRs involved.  When supporting\n+     smaller modes than SImode the int load/store costs need to be\n+     adjusted as well.  */\n+  unsigned sse_cost_idx = smode == DImode ? 1 : 0;\n+  unsigned m = smode == DImode ? (TARGET_64BIT ? 1 : 2) : 1;\n+\n   EXECUTE_IF_SET_IN_BITMAP (insns, 0, insn_uid, bi)\n     {\n       rtx_insn *insn = DF_INSN_UID_GET (insn_uid)->insn;\n@@ -500,18 +515,19 @@ dimode_scalar_chain::compute_convert_gain ()\n       int igain = 0;\n \n       if (REG_P (src) && REG_P (dst))\n-\tigain += 2 - ix86_cost->xmm_move;\n+\tigain += 2 * m - ix86_cost->xmm_move;\n       else if (REG_P (src) && MEM_P (dst))\n-\tigain += 2 * ix86_cost->int_store[2] - ix86_cost->sse_store[1];\n+\tigain\n+\t  += m * ix86_cost->int_store[2] - ix86_cost->sse_store[sse_cost_idx];\n       else if (MEM_P (src) && REG_P (dst))\n-\tigain += 2 * ix86_cost->int_load[2] - ix86_cost->sse_load[1];\n+\tigain += m * ix86_cost->int_load[2] - ix86_cost->sse_load[sse_cost_idx];\n       else if (GET_CODE (src) == ASHIFT\n \t       || GET_CODE (src) == ASHIFTRT\n \t       || GET_CODE (src) == LSHIFTRT)\n \t{\n     \t  if (CONST_INT_P (XEXP (src, 0)))\n \t    igain -= vector_const_cost (XEXP (src, 0));\n-\t  igain += 2 * ix86_cost->shift_const - ix86_cost->sse_op;\n+\t  igain += m * ix86_cost->shift_const - ix86_cost->sse_op;\n \t  if (INTVAL (XEXP (src, 1)) >= 32)\n \t    igain -= COSTS_N_INSNS (1);\n \t}\n@@ -521,11 +537,11 @@ dimode_scalar_chain::compute_convert_gain ()\n \t       || GET_CODE (src) == XOR\n \t       || GET_CODE (src) == AND)\n \t{\n-\t  igain += 2 * ix86_cost->add - ix86_cost->sse_op;\n+\t  igain += m * ix86_cost->add - ix86_cost->sse_op;\n \t  /* Additional gain for andnot for targets without BMI.  */\n \t  if (GET_CODE (XEXP (src, 0)) == NOT\n \t      && !TARGET_BMI)\n-\t    igain += 2 * ix86_cost->add;\n+\t    igain += m * ix86_cost->add;\n \n \t  if (CONST_INT_P (XEXP (src, 0)))\n \t    igain -= vector_const_cost (XEXP (src, 0));\n@@ -534,17 +550,30 @@ dimode_scalar_chain::compute_convert_gain ()\n \t}\n       else if (GET_CODE (src) == NEG\n \t       || GET_CODE (src) == NOT)\n-\tigain += 2 * ix86_cost->add - ix86_cost->sse_op - COSTS_N_INSNS (1);\n+\tigain += m * ix86_cost->add - ix86_cost->sse_op - COSTS_N_INSNS (1);\n+      else if (GET_CODE (src) == SMAX\n+\t       || GET_CODE (src) == SMIN\n+\t       || GET_CODE (src) == UMAX\n+\t       || GET_CODE (src) == UMIN)\n+\t{\n+\t  /* We do not have any conditional move cost, estimate it as a\n+\t     reg-reg move.  Comparisons are costed as adds.  */\n+\t  igain += m * (COSTS_N_INSNS (2) + ix86_cost->add);\n+\t  /* Integer SSE ops are all costed the same.  */\n+\t  igain -= ix86_cost->sse_op;\n+\t}\n       else if (GET_CODE (src) == COMPARE)\n \t{\n \t  /* Assume comparison cost is the same.  */\n \t}\n       else if (CONST_INT_P (src))\n \t{\n \t  if (REG_P (dst))\n-\t    igain += 2 * COSTS_N_INSNS (1);\n+\t    /* DImode can be immediate for TARGET_64BIT and SImode always.  */\n+\t    igain += m * COSTS_N_INSNS (1);\n \t  else if (MEM_P (dst))\n-\t    igain += 2 * ix86_cost->int_store[2] - ix86_cost->sse_store[1];\n+\t    igain += (m * ix86_cost->int_store[2]\n+\t\t     - ix86_cost->sse_store[sse_cost_idx]);\n \t  igain -= vector_const_cost (src);\n \t}\n       else\n@@ -561,6 +590,7 @@ dimode_scalar_chain::compute_convert_gain ()\n   if (dump_file)\n     fprintf (dump_file, \"  Instruction conversion gain: %d\\n\", gain);\n \n+  /* ???  What about integer to SSE?  */\n   EXECUTE_IF_SET_IN_BITMAP (defs_conv, 0, insn_uid, bi)\n     cost += DF_REG_DEF_COUNT (insn_uid) * ix86_cost->sse_to_integer;\n \n@@ -578,10 +608,10 @@ dimode_scalar_chain::compute_convert_gain ()\n /* Replace REG in X with a V2DI subreg of NEW_REG.  */\n \n rtx\n-dimode_scalar_chain::replace_with_subreg (rtx x, rtx reg, rtx new_reg)\n+general_scalar_chain::replace_with_subreg (rtx x, rtx reg, rtx new_reg)\n {\n   if (x == reg)\n-    return gen_rtx_SUBREG (V2DImode, new_reg, 0);\n+    return gen_rtx_SUBREG (vmode, new_reg, 0);\n \n   const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n   int i, j;\n@@ -601,7 +631,7 @@ dimode_scalar_chain::replace_with_subreg (rtx x, rtx reg, rtx new_reg)\n /* Replace REG in INSN with a V2DI subreg of NEW_REG.  */\n \n void\n-dimode_scalar_chain::replace_with_subreg_in_insn (rtx_insn *insn,\n+general_scalar_chain::replace_with_subreg_in_insn (rtx_insn *insn,\n \t\t\t\t\t\t  rtx reg, rtx new_reg)\n {\n   replace_with_subreg (single_set (insn), reg, new_reg);\n@@ -632,10 +662,10 @@ scalar_chain::emit_conversion_insns (rtx insns, rtx_insn *after)\n    and replace its uses in a chain.  */\n \n void\n-dimode_scalar_chain::make_vector_copies (unsigned regno)\n+general_scalar_chain::make_vector_copies (unsigned regno)\n {\n   rtx reg = regno_reg_rtx[regno];\n-  rtx vreg = gen_reg_rtx (DImode);\n+  rtx vreg = gen_reg_rtx (smode);\n   df_ref ref;\n \n   for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n@@ -644,37 +674,59 @@ dimode_scalar_chain::make_vector_copies (unsigned regno)\n \tstart_sequence ();\n \tif (!TARGET_INTER_UNIT_MOVES_TO_VEC)\n \t  {\n-\t    rtx tmp = assign_386_stack_local (DImode, SLOT_STV_TEMP);\n-\t    emit_move_insn (adjust_address (tmp, SImode, 0),\n-\t\t\t    gen_rtx_SUBREG (SImode, reg, 0));\n-\t    emit_move_insn (adjust_address (tmp, SImode, 4),\n-\t\t\t    gen_rtx_SUBREG (SImode, reg, 4));\n-\t    emit_move_insn (vreg, tmp);\n+\t    rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n+\t    if (smode == DImode && !TARGET_64BIT)\n+\t      {\n+\t\temit_move_insn (adjust_address (tmp, SImode, 0),\n+\t\t\t\tgen_rtx_SUBREG (SImode, reg, 0));\n+\t\temit_move_insn (adjust_address (tmp, SImode, 4),\n+\t\t\t\tgen_rtx_SUBREG (SImode, reg, 4));\n+\t      }\n+\t    else\n+\t      emit_move_insn (tmp, reg);\n+\t    emit_insn (gen_rtx_SET\n+\t\t        (gen_rtx_SUBREG (vmode, vreg, 0),\n+\t\t\t gen_rtx_VEC_MERGE (vmode,\n+\t\t\t\t\t    gen_rtx_VEC_DUPLICATE (vmode,\n+\t\t\t\t\t\t\t\t   tmp),\n+\t\t\t\t\t    CONST0_RTX (vmode),\n+\t\t\t\t\t    GEN_INT (HOST_WIDE_INT_1U))));\n \t  }\n-\telse if (TARGET_SSE4_1)\n+\telse if (!TARGET_64BIT && smode == DImode)\n \t  {\n-\t    emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\tCONST0_RTX (V4SImode),\n-\t\t\t\t\tgen_rtx_SUBREG (SImode, reg, 0)));\n-\t    emit_insn (gen_sse4_1_pinsrd (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t  gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 4),\n-\t\t\t\t\t  GEN_INT (2)));\n+\t    if (TARGET_SSE4_1)\n+\t      {\n+\t\temit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t    CONST0_RTX (V4SImode),\n+\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 0)));\n+\t\temit_insn (gen_sse4_1_pinsrd (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t      gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t      gen_rtx_SUBREG (SImode, reg, 4),\n+\t\t\t\t\t      GEN_INT (2)));\n+\t      }\n+\t    else\n+\t      {\n+\t\trtx tmp = gen_reg_rtx (DImode);\n+\t\temit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t    CONST0_RTX (V4SImode),\n+\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 0)));\n+\t\temit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, tmp, 0),\n+\t\t\t\t\t    CONST0_RTX (V4SImode),\n+\t\t\t\t\t    gen_rtx_SUBREG (SImode, reg, 4)));\n+\t\temit_insn (gen_vec_interleave_lowv4si\n+\t\t\t   (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t    gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t    gen_rtx_SUBREG (V4SImode, tmp, 0)));\n+\t      }\n \t  }\n \telse\n-\t  {\n-\t    rtx tmp = gen_reg_rtx (DImode);\n-\t    emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\t\t\tCONST0_RTX (V4SImode),\n-\t\t\t\t\tgen_rtx_SUBREG (SImode, reg, 0)));\n-\t    emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, tmp, 0),\n-\t\t\t\t\tCONST0_RTX (V4SImode),\n-\t\t\t\t\tgen_rtx_SUBREG (SImode, reg, 4)));\n-\t    emit_insn (gen_vec_interleave_lowv4si\n-\t\t       (gen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\tgen_rtx_SUBREG (V4SImode, vreg, 0),\n-\t\t\tgen_rtx_SUBREG (V4SImode, tmp, 0)));\n-\t  }\n+\t  emit_insn (gen_rtx_SET\n+\t\t       (gen_rtx_SUBREG (vmode, vreg, 0),\n+\t\t\tgen_rtx_VEC_MERGE (vmode,\n+\t\t\t\t\t   gen_rtx_VEC_DUPLICATE (vmode,\n+\t\t\t\t\t\t\t\t  reg),\n+\t\t\t\t\t   CONST0_RTX (vmode),\n+\t\t\t\t\t   GEN_INT (HOST_WIDE_INT_1U))));\n \trtx_insn *seq = get_insns ();\n \tend_sequence ();\n \trtx_insn *insn = DF_REF_INSN (ref);\n@@ -703,7 +755,7 @@ dimode_scalar_chain::make_vector_copies (unsigned regno)\n    in case register is used in not convertible insn.  */\n \n void\n-dimode_scalar_chain::convert_reg (unsigned regno)\n+general_scalar_chain::convert_reg (unsigned regno)\n {\n   bool scalar_copy = bitmap_bit_p (defs_conv, regno);\n   rtx reg = regno_reg_rtx[regno];\n@@ -715,7 +767,7 @@ dimode_scalar_chain::convert_reg (unsigned regno)\n   bitmap_copy (conv, insns);\n \n   if (scalar_copy)\n-    scopy = gen_reg_rtx (DImode);\n+    scopy = gen_reg_rtx (smode);\n \n   for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n     {\n@@ -735,40 +787,55 @@ dimode_scalar_chain::convert_reg (unsigned regno)\n \t  start_sequence ();\n \t  if (!TARGET_INTER_UNIT_MOVES_FROM_VEC)\n \t    {\n-\t      rtx tmp = assign_386_stack_local (DImode, SLOT_STV_TEMP);\n+\t      rtx tmp = assign_386_stack_local (smode, SLOT_STV_TEMP);\n \t      emit_move_insn (tmp, reg);\n-\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n-\t\t\t      adjust_address (tmp, SImode, 0));\n-\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n-\t\t\t      adjust_address (tmp, SImode, 4));\n+\t      if (!TARGET_64BIT && smode == DImode)\n+\t\t{\n+\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n+\t\t\t\t  adjust_address (tmp, SImode, 0));\n+\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n+\t\t\t\t  adjust_address (tmp, SImode, 4));\n+\t\t}\n+\t      else\n+\t\temit_move_insn (scopy, tmp);\n \t    }\n-\t  else if (TARGET_SSE4_1)\n+\t  else if (!TARGET_64BIT && smode == DImode)\n \t    {\n-\t      rtx tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, const0_rtx));\n-\t      emit_insn\n-\t\t(gen_rtx_SET\n-\t\t (gen_rtx_SUBREG (SImode, scopy, 0),\n-\t\t  gen_rtx_VEC_SELECT (SImode,\n-\t\t\t\t      gen_rtx_SUBREG (V4SImode, reg, 0), tmp)));\n-\n-\t      tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, const1_rtx));\n-\t      emit_insn\n-\t\t(gen_rtx_SET\n-\t\t (gen_rtx_SUBREG (SImode, scopy, 4),\n-\t\t  gen_rtx_VEC_SELECT (SImode,\n-\t\t\t\t      gen_rtx_SUBREG (V4SImode, reg, 0), tmp)));\n+\t      if (TARGET_SSE4_1)\n+\t\t{\n+\t\t  rtx tmp = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\t      gen_rtvec (1, const0_rtx));\n+\t\t  emit_insn\n+\t\t    (gen_rtx_SET\n+\t\t       (gen_rtx_SUBREG (SImode, scopy, 0),\n+\t\t\tgen_rtx_VEC_SELECT (SImode,\n+\t\t\t\t\t    gen_rtx_SUBREG (V4SImode, reg, 0),\n+\t\t\t\t\t    tmp)));\n+\n+\t\t  tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, const1_rtx));\n+\t\t  emit_insn\n+\t\t    (gen_rtx_SET\n+\t\t       (gen_rtx_SUBREG (SImode, scopy, 4),\n+\t\t\tgen_rtx_VEC_SELECT (SImode,\n+\t\t\t\t\t    gen_rtx_SUBREG (V4SImode, reg, 0),\n+\t\t\t\t\t    tmp)));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx vcopy = gen_reg_rtx (V2DImode);\n+\t\t  emit_move_insn (vcopy, gen_rtx_SUBREG (V2DImode, reg, 0));\n+\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n+\t\t\t\t  gen_rtx_SUBREG (SImode, vcopy, 0));\n+\t\t  emit_move_insn (vcopy,\n+\t\t\t\t  gen_rtx_LSHIFTRT (V2DImode,\n+\t\t\t\t\t\t    vcopy, GEN_INT (32)));\n+\t\t  emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n+\t\t\t\t  gen_rtx_SUBREG (SImode, vcopy, 0));\n+\t\t}\n \t    }\n \t  else\n-\t    {\n-\t      rtx vcopy = gen_reg_rtx (V2DImode);\n-\t      emit_move_insn (vcopy, gen_rtx_SUBREG (V2DImode, reg, 0));\n-\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n-\t\t\t      gen_rtx_SUBREG (SImode, vcopy, 0));\n-\t      emit_move_insn (vcopy,\n-\t\t\t      gen_rtx_LSHIFTRT (V2DImode, vcopy, GEN_INT (32)));\n-\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n-\t\t\t      gen_rtx_SUBREG (SImode, vcopy, 0));\n-\t    }\n+\t    emit_move_insn (scopy, reg);\n+\n \t  rtx_insn *seq = get_insns ();\n \t  end_sequence ();\n \t  emit_conversion_insns (seq, insn);\n@@ -817,21 +884,21 @@ dimode_scalar_chain::convert_reg (unsigned regno)\n    registers conversion.  */\n \n void\n-dimode_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n+general_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n {\n   *op = copy_rtx_if_shared (*op);\n \n   if (GET_CODE (*op) == NOT)\n     {\n       convert_op (&XEXP (*op, 0), insn);\n-      PUT_MODE (*op, V2DImode);\n+      PUT_MODE (*op, vmode);\n     }\n   else if (MEM_P (*op))\n     {\n-      rtx tmp = gen_reg_rtx (DImode);\n+      rtx tmp = gen_reg_rtx (GET_MODE (*op));\n \n       emit_insn_before (gen_move_insn (tmp, *op), insn);\n-      *op = gen_rtx_SUBREG (V2DImode, tmp, 0);\n+      *op = gen_rtx_SUBREG (vmode, tmp, 0);\n \n       if (dump_file)\n \tfprintf (dump_file, \"  Preloading operand for insn %d into r%d\\n\",\n@@ -849,24 +916,30 @@ dimode_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n \t    gcc_assert (!DF_REF_CHAIN (ref));\n \t    break;\n \t  }\n-      *op = gen_rtx_SUBREG (V2DImode, *op, 0);\n+      *op = gen_rtx_SUBREG (vmode, *op, 0);\n     }\n   else if (CONST_INT_P (*op))\n     {\n       rtx vec_cst;\n-      rtx tmp = gen_rtx_SUBREG (V2DImode, gen_reg_rtx (DImode), 0);\n+      rtx tmp = gen_rtx_SUBREG (vmode, gen_reg_rtx (smode), 0);\n \n       /* Prefer all ones vector in case of -1.  */\n       if (constm1_operand (*op, GET_MODE (*op)))\n-\tvec_cst = CONSTM1_RTX (V2DImode);\n+\tvec_cst = CONSTM1_RTX (vmode);\n       else\n-\tvec_cst = gen_rtx_CONST_VECTOR (V2DImode,\n-\t\t\t\t\tgen_rtvec (2, *op, const0_rtx));\n+\t{\n+\t  unsigned n = GET_MODE_NUNITS (vmode);\n+\t  rtx *v = XALLOCAVEC (rtx, n);\n+\t  v[0] = *op;\n+\t  for (unsigned i = 1; i < n; ++i)\n+\t    v[i] = const0_rtx;\n+\t  vec_cst = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (n, v));\n+\t}\n \n-      if (!standard_sse_constant_p (vec_cst, V2DImode))\n+      if (!standard_sse_constant_p (vec_cst, vmode))\n \t{\n \t  start_sequence ();\n-\t  vec_cst = validize_mem (force_const_mem (V2DImode, vec_cst));\n+\t  vec_cst = validize_mem (force_const_mem (vmode, vec_cst));\n \t  rtx_insn *seq = get_insns ();\n \t  end_sequence ();\n \t  emit_insn_before (seq, insn);\n@@ -878,14 +951,14 @@ dimode_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n   else\n     {\n       gcc_assert (SUBREG_P (*op));\n-      gcc_assert (GET_MODE (*op) == V2DImode);\n+      gcc_assert (GET_MODE (*op) == vmode);\n     }\n }\n \n /* Convert INSN to vector mode.  */\n \n void\n-dimode_scalar_chain::convert_insn (rtx_insn *insn)\n+general_scalar_chain::convert_insn (rtx_insn *insn)\n {\n   rtx def_set = single_set (insn);\n   rtx src = SET_SRC (def_set);\n@@ -896,9 +969,9 @@ dimode_scalar_chain::convert_insn (rtx_insn *insn)\n     {\n       /* There are no scalar integer instructions and therefore\n \t temporary register usage is required.  */\n-      rtx tmp = gen_reg_rtx (DImode);\n+      rtx tmp = gen_reg_rtx (smode);\n       emit_conversion_insns (gen_move_insn (dst, tmp), insn);\n-      dst = gen_rtx_SUBREG (V2DImode, tmp, 0);\n+      dst = gen_rtx_SUBREG (vmode, tmp, 0);\n     }\n \n   switch (GET_CODE (src))\n@@ -907,33 +980,37 @@ dimode_scalar_chain::convert_insn (rtx_insn *insn)\n     case ASHIFTRT:\n     case LSHIFTRT:\n       convert_op (&XEXP (src, 0), insn);\n-      PUT_MODE (src, V2DImode);\n+      PUT_MODE (src, vmode);\n       break;\n \n     case PLUS:\n     case MINUS:\n     case IOR:\n     case XOR:\n     case AND:\n+    case SMAX:\n+    case SMIN:\n+    case UMAX:\n+    case UMIN:\n       convert_op (&XEXP (src, 0), insn);\n       convert_op (&XEXP (src, 1), insn);\n-      PUT_MODE (src, V2DImode);\n+      PUT_MODE (src, vmode);\n       break;\n \n     case NEG:\n       src = XEXP (src, 0);\n       convert_op (&src, insn);\n-      subreg = gen_reg_rtx (V2DImode);\n-      emit_insn_before (gen_move_insn (subreg, CONST0_RTX (V2DImode)), insn);\n-      src = gen_rtx_MINUS (V2DImode, subreg, src);\n+      subreg = gen_reg_rtx (vmode);\n+      emit_insn_before (gen_move_insn (subreg, CONST0_RTX (vmode)), insn);\n+      src = gen_rtx_MINUS (vmode, subreg, src);\n       break;\n \n     case NOT:\n       src = XEXP (src, 0);\n       convert_op (&src, insn);\n-      subreg = gen_reg_rtx (V2DImode);\n-      emit_insn_before (gen_move_insn (subreg, CONSTM1_RTX (V2DImode)), insn);\n-      src = gen_rtx_XOR (V2DImode, src, subreg);\n+      subreg = gen_reg_rtx (vmode);\n+      emit_insn_before (gen_move_insn (subreg, CONSTM1_RTX (vmode)), insn);\n+      src = gen_rtx_XOR (vmode, src, subreg);\n       break;\n \n     case MEM:\n@@ -947,17 +1024,17 @@ dimode_scalar_chain::convert_insn (rtx_insn *insn)\n       break;\n \n     case SUBREG:\n-      gcc_assert (GET_MODE (src) == V2DImode);\n+      gcc_assert (GET_MODE (src) == vmode);\n       break;\n \n     case COMPARE:\n       src = SUBREG_REG (XEXP (XEXP (src, 0), 0));\n \n-      gcc_assert ((REG_P (src) && GET_MODE (src) == DImode)\n-\t\t  || (SUBREG_P (src) && GET_MODE (src) == V2DImode));\n+      gcc_assert ((REG_P (src) && GET_MODE (src) == GET_MODE_INNER (vmode))\n+\t\t  || (SUBREG_P (src) && GET_MODE (src) == vmode));\n \n       if (REG_P (src))\n-\tsubreg = gen_rtx_SUBREG (V2DImode, src, 0);\n+\tsubreg = gen_rtx_SUBREG (vmode, src, 0);\n       else\n \tsubreg = copy_rtx_if_shared (src);\n       emit_insn_before (gen_vec_interleave_lowv2di (copy_rtx_if_shared (subreg),\n@@ -985,7 +1062,9 @@ dimode_scalar_chain::convert_insn (rtx_insn *insn)\n   PATTERN (insn) = def_set;\n \n   INSN_CODE (insn) = -1;\n-  recog_memoized (insn);\n+  int patt = recog_memoized (insn);\n+  if  (patt == -1)\n+    fatal_insn_not_found (insn);\n   df_insn_rescan (insn);\n }\n \n@@ -1124,7 +1203,7 @@ timode_scalar_chain::convert_insn (rtx_insn *insn)\n }\n \n void\n-dimode_scalar_chain::convert_registers ()\n+general_scalar_chain::convert_registers ()\n {\n   bitmap_iterator bi;\n   unsigned id;\n@@ -1194,7 +1273,7 @@ has_non_address_hard_reg (rtx_insn *insn)\n \t\t     (const_int 0 [0])))  */\n \n static bool\n-convertible_comparison_p (rtx_insn *insn)\n+convertible_comparison_p (rtx_insn *insn, enum machine_mode mode)\n {\n   if (!TARGET_SSE4_1)\n     return false;\n@@ -1227,20 +1306,20 @@ convertible_comparison_p (rtx_insn *insn)\n \n   if (!SUBREG_P (op1)\n       || !SUBREG_P (op2)\n-      || GET_MODE (op1) != SImode\n-      || GET_MODE (op2) != SImode\n+      || GET_MODE (op1) != mode\n+      || GET_MODE (op2) != mode\n       || ((SUBREG_BYTE (op1) != 0\n-\t   || SUBREG_BYTE (op2) != GET_MODE_SIZE (SImode))\n+\t   || SUBREG_BYTE (op2) != GET_MODE_SIZE (mode))\n \t  && (SUBREG_BYTE (op2) != 0\n-\t      || SUBREG_BYTE (op1) != GET_MODE_SIZE (SImode))))\n+\t      || SUBREG_BYTE (op1) != GET_MODE_SIZE (mode))))\n     return false;\n \n   op1 = SUBREG_REG (op1);\n   op2 = SUBREG_REG (op2);\n \n   if (op1 != op2\n       || !REG_P (op1)\n-      || GET_MODE (op1) != DImode)\n+      || GET_MODE (op1) != GET_MODE_WIDER_MODE (mode).else_blk ())\n     return false;\n \n   return true;\n@@ -1249,7 +1328,7 @@ convertible_comparison_p (rtx_insn *insn)\n /* The DImode version of scalar_to_vector_candidate_p.  */\n \n static bool\n-dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n+general_scalar_to_vector_candidate_p (rtx_insn *insn, enum machine_mode mode)\n {\n   rtx def_set = single_set (insn);\n \n@@ -1263,12 +1342,12 @@ dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n   rtx dst = SET_DEST (def_set);\n \n   if (GET_CODE (src) == COMPARE)\n-    return convertible_comparison_p (insn);\n+    return convertible_comparison_p (insn, mode);\n \n   /* We are interested in DImode promotion only.  */\n-  if ((GET_MODE (src) != DImode\n+  if ((GET_MODE (src) != mode\n        && !CONST_INT_P (src))\n-      || GET_MODE (dst) != DImode)\n+      || GET_MODE (dst) != mode)\n     return false;\n \n   if (!REG_P (dst) && !MEM_P (dst))\n@@ -1288,6 +1367,15 @@ dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n \treturn false;\n       break;\n \n+    case SMAX:\n+    case SMIN:\n+    case UMAX:\n+    case UMIN:\n+      if ((mode == DImode && !TARGET_AVX512VL)\n+\t  || (mode == SImode && !TARGET_SSE4_1))\n+\treturn false;\n+      /* Fallthru.  */\n+\n     case PLUS:\n     case MINUS:\n     case IOR:\n@@ -1298,7 +1386,7 @@ dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n \t  && !CONST_INT_P (XEXP (src, 1)))\n \treturn false;\n \n-      if (GET_MODE (XEXP (src, 1)) != DImode\n+      if (GET_MODE (XEXP (src, 1)) != mode\n \t  && !CONST_INT_P (XEXP (src, 1)))\n \treturn false;\n       break;\n@@ -1327,7 +1415,7 @@ dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n \t  || !REG_P (XEXP (XEXP (src, 0), 0))))\n       return false;\n \n-  if (GET_MODE (XEXP (src, 0)) != DImode\n+  if (GET_MODE (XEXP (src, 0)) != mode\n       && !CONST_INT_P (XEXP (src, 0)))\n     return false;\n \n@@ -1391,22 +1479,16 @@ timode_scalar_to_vector_candidate_p (rtx_insn *insn)\n   return false;\n }\n \n-/* Return 1 if INSN may be converted into vector\n-   instruction.  */\n-\n-static bool\n-scalar_to_vector_candidate_p (rtx_insn *insn)\n-{\n-  if (TARGET_64BIT)\n-    return timode_scalar_to_vector_candidate_p (insn);\n-  else\n-    return dimode_scalar_to_vector_candidate_p (insn);\n-}\n+/* For a given bitmap of insn UIDs scans all instruction and\n+   remove insn from CANDIDATES in case it has both convertible\n+   and not convertible definitions.\n \n-/* The DImode version of remove_non_convertible_regs.  */\n+   All insns in a bitmap are conversion candidates according to\n+   scalar_to_vector_candidate_p.  Currently it implies all insns\n+   are single_set.  */\n \n static void\n-dimode_remove_non_convertible_regs (bitmap candidates)\n+general_remove_non_convertible_regs (bitmap candidates)\n {\n   bitmap_iterator bi;\n   unsigned id;\n@@ -1561,35 +1643,21 @@ timode_remove_non_convertible_regs (bitmap candidates)\n   BITMAP_FREE (regs);\n }\n \n-/* For a given bitmap of insn UIDs scans all instruction and\n-   remove insn from CANDIDATES in case it has both convertible\n-   and not convertible definitions.\n-\n-   All insns in a bitmap are conversion candidates according to\n-   scalar_to_vector_candidate_p.  Currently it implies all insns\n-   are single_set.  */\n-\n-static void\n-remove_non_convertible_regs (bitmap candidates)\n-{\n-  if (TARGET_64BIT)\n-    timode_remove_non_convertible_regs (candidates);\n-  else\n-    dimode_remove_non_convertible_regs (candidates);\n-}\n-\n /* Main STV pass function.  Find and convert scalar\n    instructions into vector mode when profitable.  */\n \n static unsigned int\n convert_scalars_to_vector ()\n {\n   basic_block bb;\n-  bitmap candidates;\n   int converted_insns = 0;\n \n   bitmap_obstack_initialize (NULL);\n-  candidates = BITMAP_ALLOC (NULL);\n+  const machine_mode cand_mode[3] = { SImode, DImode, TImode };\n+  const machine_mode cand_vmode[3] = { V4SImode, V2DImode, V1TImode };\n+  bitmap_head candidates[3];  /* { SImode, DImode, TImode } */\n+  for (unsigned i = 0; i < 3; ++i)\n+    bitmap_initialize (&candidates[i], &bitmap_default_obstack);\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n@@ -1605,51 +1673,73 @@ convert_scalars_to_vector ()\n     {\n       rtx_insn *insn;\n       FOR_BB_INSNS (bb, insn)\n-\tif (scalar_to_vector_candidate_p (insn))\n+\tif (TARGET_64BIT\n+\t    && timode_scalar_to_vector_candidate_p (insn))\n \t  {\n \t    if (dump_file)\n-\t      fprintf (dump_file, \"  insn %d is marked as a candidate\\n\",\n+\t      fprintf (dump_file, \"  insn %d is marked as a TImode candidate\\n\",\n \t\t       INSN_UID (insn));\n \n-\t    bitmap_set_bit (candidates, INSN_UID (insn));\n+\t    bitmap_set_bit (&candidates[2], INSN_UID (insn));\n+\t  }\n+\telse\n+\t  {\n+\t    /* Check {SI,DI}mode.  */\n+\t    for (unsigned i = 0; i <= 1; ++i)\n+\t      if (general_scalar_to_vector_candidate_p (insn, cand_mode[i]))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"  insn %d is marked as a %s candidate\\n\",\n+\t\t\t     INSN_UID (insn), i == 0 ? \"SImode\" : \"DImode\");\n+\n+\t\t  bitmap_set_bit (&candidates[i], INSN_UID (insn));\n+\t\t  break;\n+\t\t}\n \t  }\n     }\n \n-  remove_non_convertible_regs (candidates);\n+  if (TARGET_64BIT)\n+    timode_remove_non_convertible_regs (&candidates[2]);\n+  for (unsigned i = 0; i <= 1; ++i)\n+    general_remove_non_convertible_regs (&candidates[i]);\n \n-  if (bitmap_empty_p (candidates))\n-    if (dump_file)\n+  for (unsigned i = 0; i <= 2; ++i)\n+    if (!bitmap_empty_p (&candidates[i]))\n+      break;\n+    else if (i == 2 && dump_file)\n       fprintf (dump_file, \"There are no candidates for optimization.\\n\");\n \n-  while (!bitmap_empty_p (candidates))\n-    {\n-      unsigned uid = bitmap_first_set_bit (candidates);\n-      scalar_chain *chain;\n+  for (unsigned i = 0; i <= 2; ++i)\n+    while (!bitmap_empty_p (&candidates[i]))\n+      {\n+\tunsigned uid = bitmap_first_set_bit (&candidates[i]);\n+\tscalar_chain *chain;\n \n-      if (TARGET_64BIT)\n-\tchain = new timode_scalar_chain;\n-      else\n-\tchain = new dimode_scalar_chain;\n+\tif (cand_mode[i] == TImode)\n+\t  chain = new timode_scalar_chain;\n+\telse\n+\t  chain = new general_scalar_chain (cand_mode[i], cand_vmode[i]);\n \n-      /* Find instructions chain we want to convert to vector mode.\n-\t Check all uses and definitions to estimate all required\n-\t conversions.  */\n-      chain->build (candidates, uid);\n+\t/* Find instructions chain we want to convert to vector mode.\n+\t   Check all uses and definitions to estimate all required\n+\t   conversions.  */\n+\tchain->build (&candidates[i], uid);\n \n-      if (chain->compute_convert_gain () > 0)\n-\tconverted_insns += chain->convert ();\n-      else\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Chain #%d conversion is not profitable\\n\",\n-\t\t   chain->chain_id);\n+\tif (chain->compute_convert_gain () > 0)\n+\t  converted_insns += chain->convert ();\n+\telse\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Chain #%d conversion is not profitable\\n\",\n+\t\t     chain->chain_id);\n \n-      delete chain;\n-    }\n+\tdelete chain;\n+      }\n \n   if (dump_file)\n     fprintf (dump_file, \"Total insns converted: %d\\n\", converted_insns);\n \n-  BITMAP_FREE (candidates);\n+  for (unsigned i = 0; i <= 2; ++i)\n+    bitmap_release (&candidates[i]);\n   bitmap_obstack_release (NULL);\n   df_process_deferred_rescans ();\n "}, {"sha": "c85ac45e3472bf80b3a0ed93b5263db6504da02d", "filename": "gcc/config/i386/i386-features.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Fconfig%2Fi386%2Fi386-features.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Fconfig%2Fi386%2Fi386-features.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.h?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -127,11 +127,16 @@ namespace {\n class scalar_chain\n {\n  public:\n-  scalar_chain ();\n+  scalar_chain (enum machine_mode, enum machine_mode);\n   virtual ~scalar_chain ();\n \n   static unsigned max_id;\n \n+  /* Scalar mode.  */\n+  enum machine_mode smode;\n+  /* Vector mode.  */\n+  enum machine_mode vmode;\n+\n   /* ID of a chain.  */\n   unsigned int chain_id;\n   /* A queue of instructions to be included into a chain.  */\n@@ -159,9 +164,11 @@ class scalar_chain\n   virtual void convert_registers () = 0;\n };\n \n-class dimode_scalar_chain : public scalar_chain\n+class general_scalar_chain : public scalar_chain\n {\n  public:\n+  general_scalar_chain (enum machine_mode smode_, enum machine_mode vmode_)\n+    : scalar_chain (smode_, vmode_) {}\n   int compute_convert_gain ();\n  private:\n   void mark_dual_mode_def (df_ref def);\n@@ -178,6 +185,8 @@ class dimode_scalar_chain : public scalar_chain\n class timode_scalar_chain : public scalar_chain\n {\n  public:\n+  timode_scalar_chain () : scalar_chain (TImode, V1TImode) {}\n+\n   /* Convert from TImode to V1TImode is always faster.  */\n   int compute_convert_gain () { return 1; }\n "}, {"sha": "9951d46d8b2c6b33110e7563975aa1aacf5579bd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -17719,6 +17719,110 @@\n    (match_operand:SWI 3 \"const_int_operand\")]\n   \"\"\n   \"if (ix86_expand_int_addcc (operands)) DONE; else FAIL;\")\n+\n+;; min/max patterns\n+\n+(define_mode_iterator MAXMIN_IMODE\n+  [(SI \"TARGET_SSE4_1\") (DI \"TARGET_AVX512VL\")])\n+(define_code_attr maxmin_rel\n+  [(smax \"GE\") (smin \"LE\") (umax \"GEU\") (umin \"LEU\")])\n+\n+(define_expand \"<code><mode>3\"\n+  [(parallel\n+    [(set (match_operand:MAXMIN_IMODE 0 \"register_operand\")\n+\t  (maxmin:MAXMIN_IMODE\n+\t    (match_operand:MAXMIN_IMODE 1 \"register_operand\")\n+\t    (match_operand:MAXMIN_IMODE 2 \"nonimmediate_operand\")))\n+     (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_STV\")\n+\n+(define_insn_and_split \"*<code><mode>3_1\"\n+  [(set (match_operand:MAXMIN_IMODE 0 \"register_operand\")\n+\t(maxmin:MAXMIN_IMODE\n+\t  (match_operand:MAXMIN_IMODE 1 \"register_operand\")\n+\t  (match_operand:MAXMIN_IMODE 2 \"nonimmediate_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"(TARGET_64BIT || <MODE>mode != DImode) && TARGET_STV\n+   && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(if_then_else:MAXMIN_IMODE (match_dup 3)\n+\t  (match_dup 1)\n+\t  (match_dup 2)))]\n+{\n+  machine_mode mode = <MODE>mode;\n+\n+  if (!register_operand (operands[2], mode))\n+    operands[2] = force_reg (mode, operands[2]);\n+\n+  enum rtx_code code = <maxmin_rel>;\n+  machine_mode cmpmode = SELECT_CC_MODE (code, operands[1], operands[2]);\n+  rtx flags = gen_rtx_REG (cmpmode, FLAGS_REG);\n+\n+  rtx tmp = gen_rtx_COMPARE (cmpmode, operands[1], operands[2]);\n+  emit_insn (gen_rtx_SET (flags, tmp));\n+\n+  operands[3] = gen_rtx_fmt_ee (code, VOIDmode, flags, const0_rtx);\n+})\n+\n+(define_insn_and_split \"*<code>di3_doubleword\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(maxmin:DI (match_operand:DI 1 \"register_operand\")\n+\t\t   (match_operand:DI 2 \"nonimmediate_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && TARGET_STV && TARGET_AVX512VL\n+   && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(if_then_else:SI (match_dup 6)\n+\t  (match_dup 1)\n+\t  (match_dup 2)))\n+   (set (match_dup 3)\n+\t(if_then_else:SI (match_dup 6)\n+\t  (match_dup 4)\n+\t  (match_dup 5)))]\n+{\n+  if (!register_operand (operands[2], DImode))\n+    operands[2] = force_reg (DImode, operands[2]);\n+\n+  split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\n+\n+  rtx cmplo[2] = { operands[1], operands[2] };\n+  rtx cmphi[2] = { operands[4], operands[5] };\n+\n+  enum rtx_code code = <maxmin_rel>;\n+\n+  switch (code)\n+    {\n+    case LE: case LEU:\n+      std::swap (cmplo[0], cmplo[1]);\n+      std::swap (cmphi[0], cmphi[1]);\n+      code = swap_condition (code);\n+      /* FALLTHRU */\n+\n+    case GE: case GEU:\n+      {\n+\tbool uns = (code == GEU);\n+\trtx (*sbb_insn) (machine_mode, rtx, rtx, rtx)\n+\t  = uns ? gen_sub3_carry_ccc : gen_sub3_carry_ccgz;\n+\n+\temit_insn (gen_cmp_1 (SImode, cmplo[0], cmplo[1]));\n+\n+\trtx tmp = gen_rtx_SCRATCH (SImode);\n+\temit_insn (sbb_insn (SImode, tmp, cmphi[0], cmphi[1]));\n+\n+\trtx flags = gen_rtx_REG (uns ? CCCmode : CCGZmode, FLAGS_REG);\n+\toperands[6] = gen_rtx_fmt_ee (code, VOIDmode, flags, const0_rtx);\n+\n+\tbreak;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n \f\n ;; Misc patterns (?)\n "}, {"sha": "afe27ee58bb4a5f861da535748c5c8380a4ee9cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -1,3 +1,14 @@\n+2019-08-14  Richard Biener  <rguenther@suse.de>\n+\n+\tPR target/91154\n+\t* gcc.target/i386/pr91154.c: New testcase.\n+\t* gcc.target/i386/minmax-3.c: Likewise.\n+\t* gcc.target/i386/minmax-4.c: Likewise.\n+\t* gcc.target/i386/minmax-5.c: Likewise.\n+\t* gcc.target/i386/minmax-6.c: Likewise.\n+\t* gcc.target/i386/minmax-1.c: Add -mno-stv.\n+\t* gcc.target/i386/minmax-2.c: Likewise.\n+\n 2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n "}, {"sha": "0ec35b1c5a108485bff64062a1b8fb4595f5e20d", "filename": "gcc/testsuite/gcc.target/i386/minmax-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-1.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -march=opteron\" } */\n+/* { dg-options \"-O2 -march=opteron -mno-stv\" } */\n /* { dg-final { scan-assembler \"test\" } } */\n /* { dg-final { scan-assembler-not \"cmp\" } } */\n #define max(a,b) (((a) > (b))? (a) : (b))"}, {"sha": "af9baeaaf7cf11d72dc29f036d563e9ce188d1d0", "filename": "gcc/testsuite/gcc.target/i386/minmax-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-2.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2\" } */\n+/* { dg-options \"-O2 -mno-stv\" } */\n /* { dg-final { scan-assembler \"test\" } } */\n /* { dg-final { scan-assembler-not \"cmp\" } } */\n #define max(a,b) (((a) > (b))? (a) : (b))"}, {"sha": "ec7b3180e2b6c4e296deb61a56c1e996330d7435", "filename": "gcc/testsuite/gcc.target/i386/minmax-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-3.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mstv\" } */\n+\n+#define max(a,b) (((a) > (b))? (a) : (b))\n+#define min(a,b) (((a) < (b))? (a) : (b))\n+\n+int ssi[1024];\n+unsigned int usi[1024];\n+long long sdi[1024];\n+unsigned long long udi[1024];\n+\n+#define CHECK(FN, VARIANT) \\\n+void \\\n+FN ## VARIANT (void) \\\n+{ \\\n+  for (int i = 1; i < 1024; ++i) \\\n+    VARIANT[i] = FN(VARIANT[i-1], VARIANT[i]); \\\n+}\n+\n+CHECK(max, ssi);\n+CHECK(min, ssi);\n+CHECK(max, usi);\n+CHECK(min, usi);\n+CHECK(max, sdi);\n+CHECK(min, sdi);\n+CHECK(max, udi);\n+CHECK(min, udi);"}, {"sha": "9d8ed182b612e13aa1c9a57b9560d610ec021266", "filename": "gcc/testsuite/gcc.target/i386/minmax-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-4.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mstv -msse4.1\" } */\n+\n+#include \"minmax-3.c\"\n+\n+/* { dg-final { scan-assembler-times \"pmaxsd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pmaxud\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pminsd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"pminud\" 1 } } */"}, {"sha": "1971dbd4eb82aec782a210d6f7bfb0179b611451", "filename": "gcc/testsuite/gcc.target/i386/minmax-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-5.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mstv -mavx512vl\" } */\n+\n+#include \"minmax-3.c\"\n+\n+/* { dg-final { scan-assembler-times \"vpmaxsd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpmaxud\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpminsd\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpminud\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpmaxsq\" 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"vpmaxuq\" 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"vpminsq\" 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"vpminuq\" 1 { target lp64 } } } */"}, {"sha": "b3af8c4d8ae2dcf7820ec9129f0f069c86e89f4e", "filename": "gcc/testsuite/gcc.target/i386/minmax-6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-6.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=haswell\" } */\n+\n+unsigned short\n+UMVLine16Y_11 (short unsigned int * Pic, int y, int width)\n+{\n+  if (y != width)\n+    {\n+      y = y < 0 ? 0 : y;\n+      return Pic[y * width];\n+    }\n+  return Pic[y];\n+} \n+\n+/* We do not want the RA to spill %esi for it's dual-use but using\n+   pmaxsd is OK.  */\n+/* { dg-final { scan-assembler-not \"rsp\" { target { ! { ia32 } } } } } */\n+/* { dg-final { scan-assembler \"pmaxsd\" } } */"}, {"sha": "69f2e21bccc30d523212a1553af11d0632d9b251", "filename": "gcc/testsuite/gcc.target/i386/pr91154.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91154.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cf5515729f526761489ec3892c6f0ea0d7105b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91154.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr91154.c?ref=93cf5515729f526761489ec3892c6f0ea0d7105b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse4.1 -mstv\" } */\n+\n+void foo (int *dc, int *mc, int *tpdd, int *tpmd, int M)\n+{\n+  int sc;\n+  int k;\n+  for (k = 1; k <= M; k++)\n+    {\n+      dc[k] = dc[k-1] + tpdd[k-1];\n+      if ((sc = mc[k-1] + tpmd[k-1]) > dc[k]) dc[k] = sc;\n+      if (dc[k] < -987654321) dc[k] = -987654321;\n+    }\n+}\n+\n+/* We want to convert the loop to SSE since SSE pmaxsd is faster than\n+   compare + conditional move.  */\n+/* { dg-final { scan-assembler-not \"cmov\" } } */\n+/* { dg-final { scan-assembler-times \"pmaxsd\" 2 } } */\n+/* { dg-final { scan-assembler-times \"paddd\" 2 } } */"}]}