{"sha": "b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhkODVmNTY5YTZkZDQ0Y2I5NTYxYzk1ZTVmNjI4YmQ2Y2Q1MzFhNQ==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2020-10-07T23:27:45Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2021-02-26T03:27:14Z"}, "message": "Optimize pcrel access of globals\n\nThis patch implements a RTL pass that looks for pc-relative loads of the\naddress of an external variable using the PCREL_GOT relocation and a\nsingle load or store that uses that external address.\n\nProduced by a cast of thousands:\n * Michael Meissner\n * Peter Bergner\n * Bill Schmidt\n * Alan Modra\n * Segher Boessenkool\n * Aaron Sawdey\n\ngcc/ChangeLog:\n\n\t* config.gcc: Add rs6000-pcrel-opt.o.\n\t* config/rs6000/rs6000-pcrel-opt.c: New file.\n\t* config/rs6000/pcrel-opt.md: New file.\n\t* config/rs6000/predicates.md: Add d_form_memory predicate.\n\t* config/rs6000/rs6000-cpus.def: Add OPTION_MASK_PCREL_OPT.\n\t* config/rs6000/rs6000-passes.def: Add pass_pcrel_opt.\n\t* config/rs6000/rs6000-protos.h: Add reg_to_non_prefixed(),\n\tpcrel_opt_valid_mem_p(), output_pcrel_opt_reloc(),\n\tand make_pass_pcrel_opt().\n\t* config/rs6000/rs6000.c (reg_to_non_prefixed): Make global.\n\t(rs6000_option_override_internal): Add pcrel-opt.\n\t(rs6000_delegitimize_address): Support pcrel-opt.\n\t(rs6000_opt_masks): Add pcrel-opt.\n\t(pcrel_opt_valid_mem_p): New function.\n\t(reg_to_non_prefixed): Make global.\n\t(rs6000_asm_output_opcode): Reset prepend_p_to_next_insn.\n\t(output_pcrel_opt_reloc): New function.\n\t* config/rs6000/rs6000.md (loads_extern_addr): New attr.\n\t(pcrel_extern_addr): Set loads_extern_addr.\n\tAdd include for pcrel-opt.md.\n\t* config/rs6000/rs6000.opt: Add -mpcrel-opt.\n\t* config/rs6000/t-rs6000: Add rules for pcrel-opt.c and\n\tpcrel-opt.md.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/powerpc/pcrel-opt-inc-di.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-ld-df.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-ld-di.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-ld-hi.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-ld-qi.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-ld-sf.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-ld-si.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-ld-vector.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-st-df.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-st-di.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-st-hi.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-st-qi.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-st-sf.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-st-si.c: New test.\n\t* gcc.target/powerpc/pcrel-opt-st-vector.c: New test.", "tree": {"sha": "328c0460daf20e0f73d88fc7e96cf2b6099b527b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/328c0460daf20e0f73d88fc7e96cf2b6099b527b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9967bbfceddce755b18bdbecc6d0c56e994a05cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9967bbfceddce755b18bdbecc6d0c56e994a05cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9967bbfceddce755b18bdbecc6d0c56e994a05cc"}], "stats": {"total": 2051, "additions": 2042, "deletions": 9}, "files": [{"sha": "c8853009e55d412e5e36154a248880d80d54edf5", "filename": "gcc/config.gcc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -509,7 +509,8 @@ or1k*-*-*)\n \t;;\n powerpc*-*-*)\n \tcpu_type=rs6000\n-\textra_objs=\"rs6000-string.o rs6000-p8swap.o rs6000-logue.o rs6000-call.o\"\n+\textra_objs=\"rs6000-string.o rs6000-p8swap.o rs6000-logue.o\"\n+\textra_objs=\"${extra_objs} rs6000-call.o rs6000-pcrel-opt.o\"\n \textra_headers=\"ppc-asm.h altivec.h htmintrin.h htmxlintrin.h\"\n \textra_headers=\"${extra_headers} bmi2intrin.h bmiintrin.h\"\n \textra_headers=\"${extra_headers} xmmintrin.h mm_malloc.h emmintrin.h\"\n@@ -524,6 +525,7 @@ powerpc*-*-*)\n \tesac\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\"\n \ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/rs6000/rs6000-logue.c \\$(srcdir)/config/rs6000/rs6000-call.c\"\n+\ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/rs6000/rs6000-pcrel-opt.c\"\n \t;;\n pru-*-*)\n \tcpu_type=pru\n@@ -535,8 +537,10 @@ riscv*)\n \t;;\n rs6000*-*-*)\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\"\n-\textra_objs=\"rs6000-string.o rs6000-p8swap.o rs6000-logue.o rs6000-call.o\"\n+\textra_objs=\"rs6000-string.o rs6000-p8swap.o rs6000-logue.o\"\n+\textra_objs=\"${extra_objs} rs6000-call.o rs6000-pcrel-opt.o\"\n \ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/rs6000/rs6000-logue.c \\$(srcdir)/config/rs6000/rs6000-call.c\"\n+\ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/rs6000/rs6000-pcrel-opt.c\"\n \t;;\n sparc*-*-*)\n \tcpu_type=sparc"}, {"sha": "9706a3977c58be6aed62e7bf3c71afc00eb273c1", "filename": "gcc/config/rs6000/pcrel-opt.md", "status": "added", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Fpcrel-opt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Fpcrel-opt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpcrel-opt.md?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,401 @@\n+;; Machine description for the PCREL_OPT optimization.\n+;; Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+;; Contributed by Michael Meissner (meissner@linux.ibm.com)\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Support for the PCREL_OPT optimization.  PCREL_OPT looks for instances where\n+;; an external variable is used only once, either for reading or for writing.\n+;;\n+;; If we are optimizing a single read, normally the code would look like:\n+;;\n+;;\t(set (reg:DI <ptr>)\n+;;\t     (symbol_ref:DI \"<extern_addr>\"))\t# <data> is currently dead\n+;;\n+;;\t\t...\t# insns do not need to be adjacent\n+;;\n+;;\t(set (reg:SI <data>)\n+;;\t     (mem:SI (reg:DI <xxx>)))\t\t# <ptr> dies with this insn\n+;;\n+;; We transform this into:\n+;;\n+;;\t(parallel [(set (reg:DI <ptr>)\n+;;\t\t\t(unspec:SI [(symbol_ref:DI <extern_addr>)\n+;;\t\t\t\t    (const_int <marker>)]\n+;;\t\t\t\t   UNSPEC_PCREL_OPT_LD_ADDR))\n+;;\t\t   (set (reg:DI <data>)\n+;;\t\t\t(unspec:DI [(const_int 0)]\n+;;\t\t\t\t   UNSPEC_PCREL_OPT_LD_DATA))])\n+;;\n+;;\t...\n+;;\n+;;\t(parallel [(set (reg:SI <data>)\n+;;\t\t   (unspec:SI [(mem:SI (reg:DI <ptr>))\n+;;\t\t\t       (reg:DI <data>)\n+;;\t\t\t       (const_int <marker>)]\n+;;\t\t\t      UNSPEC_PCREL_OPT_LD_RELOC))\n+;;\t\t   (clobber (reg:DI <ptr>))])\n+;;\n+;; The marker is an integer constant that links the load of the external\n+;; address to the load of the actual variable.\n+;;\n+;; In the first insn, we set both the address of the external variable, and\n+;; mark that the variable being loaded both are created in that insn, and are\n+;; consumed in the second insn.\t It doesn't matter what mode the register that\n+;; we will ultimately do the load into, so we use DImode.  We just need to mark\n+;; that both registers may be set in the first insn, and will be used in the\n+;; second insn.\n+;;\n+;; Since we use UNSPEC's and link both the the register holding the external\n+;; address and the value being loaded, it should prevent other passes from\n+;; modifying it.\n+;;\n+;; If the register being loaded is the same as the base register, we use an\n+;; alternate form of the insns.\n+;;\n+;;\t(set (reg:DI <data_ptr>)\n+;;\t     (unspec:DI [(symbol_ref:DI <extern_addr>)\n+;;\t\t\t (const_int <marker>)]\n+;;\t\t\tUNSPEC_PCREL_OPT_LD_SAME_REG))\n+;;\n+;;\t...\n+;;\n+;;\t(parallel [(set (reg:SI <data>)\n+;;\t\t   (unspec:SI [(mem:SI (reg:DI <ptr>))\n+;;\t\t\t       (reg:DI <data>)\n+;;\t\t\t       (const_int <marker>)]\n+;;\t\t\t      UNSPEC_PCREL_OPT_LD_RELOC))\n+;;\t\t   (clobber (reg:DI <ptr>))])\n+\n+(define_c_enum \"unspec\"\n+  [UNSPEC_PCREL_OPT_LD_ADDR\n+   UNSPEC_PCREL_OPT_LD_DATA\n+   UNSPEC_PCREL_OPT_LD_SAME_REG\n+   UNSPEC_PCREL_OPT_LD_RELOC\n+   UNSPEC_PCREL_OPT_ST_ADDR\n+   UNSPEC_PCREL_OPT_ST_RELOC])\n+\n+;; Modes that are supported for PCREL_OPT\n+(define_mode_iterator PCRELOPT [QI HI SI DI TI SF DF KF\n+\t\t\t  V1TI V2DI V4SI V8HI V16QI V2DF V4SF\n+\t\t\t  (TF \"TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD\")])\n+\n+;; Vector modes for PCREL_OPT\n+(define_mode_iterator PCRELOPT_VECT [TI KF V1TI V2DI V4SI V8HI V16QI V2DF V4SF\n+\t\t\t       (TF \"TARGET_FLOAT128_TYPE && TARGET_IEEEQUAD\")])\n+\n+;; Insn for loading the external address, where the register being loaded is not\n+;; the same as the register being loaded with the data.\n+(define_insn \"pcrel_opt_ld_addr\"\n+  [(set (match_operand:DI 0 \"base_reg_operand\" \"=&b,&b\")\n+\t(unspec:DI [(match_operand:DI 1 \"pcrel_external_address\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n,n\")]\n+\t\t   UNSPEC_PCREL_OPT_LD_ADDR))\n+   (set (match_operand:DI 3 \"gpc_reg_operand\" \"=r,wa\")\n+\t(unspec:DI [(const_int 0)]\n+\t\t   UNSPEC_PCREL_OPT_LD_DATA))]\n+  \"TARGET_PCREL_OPT\n+   && reg_or_subregno (operands[0]) != reg_or_subregno (operands[3])\"\n+  \"ld %0,%a1\\n.Lpcrel%2:\"\n+  [(set_attr \"prefixed\" \"yes\")\n+   (set_attr \"type\" \"load\")\n+   (set_attr \"loads_external_address\" \"yes\")])\n+\n+;; Alternate form of loading up the external address that is the same register\n+;; as the final load.\n+(define_insn \"pcrel_opt_ld_addr_same_reg\"\n+  [(set (match_operand:DI 0 \"base_reg_operand\" \"=b\")\n+\t(unspec:DI [(match_operand:DI 1 \"pcrel_external_address\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n\")]\n+\t\t   UNSPEC_PCREL_OPT_LD_SAME_REG))]\n+  \"TARGET_PCREL_OPT\"\n+  \"ld %0,%a1\\n.Lpcrel%2:\"\n+  [(set_attr \"prefixed\" \"yes\")\n+   (set_attr \"type\" \"load\")\n+   (set_attr \"loads_external_address\" \"yes\")])\n+\n+;; PCREL_OPT modes that are optimized for loading or storing GPRs.\n+(define_mode_iterator PCRELOPT_GPR [QI HI SI DI SF DF])\n+\n+(define_mode_attr PCRELOPT_GPR_LD [(QI \"lbz\")\n+\t\t\t     (HI \"lhz\")\n+\t\t\t     (SI \"lwz\")\n+\t\t\t     (SF \"lwz\")\n+\t\t\t     (DI \"ld\")\n+\t\t\t     (DF \"ld\")])\n+\n+;; PCREL_OPT load operation of GPRs.  Operand 4 (the register used to hold the\n+;; address of the external symbol) is SCRATCH if the same register is used for\n+;; the normal load.\n+(define_insn \"*pcrel_opt_ld<mode>_gpr\"\n+  [(parallel [(set (match_operand:PCRELOPT_GPR 0 \"int_reg_operand\" \"+r\")\n+\t\t   (unspec:PCRELOPT_GPR [\n+\t\t     (match_operand:PCRELOPT_GPR 1 \"d_form_memory\" \"m\")\n+\t\t     (match_operand:DI 2 \"int_reg_operand\" \"0\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t    UNSPEC_PCREL_OPT_LD_RELOC))\n+\t      (clobber (match_scratch:DI 4 \"=bX\"))])]\n+  \"TARGET_PCREL_OPT\n+   && (GET_CODE (operands[4]) == SCRATCH\n+       || reg_mentioned_p (operands[4], operands[1]))\"\n+{\n+  output_pcrel_opt_reloc (operands[3]);\n+  return \"<PCRELOPT_GPR_LD> %0,%1\";\n+}\n+  [(set_attr \"type\" \"load\")])\n+\n+;; PCREL_OPT load with sign/zero extension\n+(define_insn \"*pcrel_opt_ldsi_<u><mode>_gpr\"\n+  [(set (match_operand:EXTSI 0 \"int_reg_operand\" \"+r\")\n+\t(any_extend:EXTSI\n+\t (unspec:SI [(match_operand:SI 1 \"d_form_memory\" \"m\")\n+\t\t     (match_operand:DI 2 \"int_reg_operand\" \"0\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_PCREL_OPT_LD_RELOC)))\n+   (clobber (match_scratch:DI 4 \"=bX\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[3]);\n+  return \"lw<az> %0,%1\";\n+}\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*pcrel_opt_ldhi_<u><mode>_gpr\"\n+  [(set (match_operand:EXTHI 0 \"int_reg_operand\" \"+r\")\n+\t(any_extend:EXTHI\n+\t (unspec:HI [(match_operand:HI 1 \"d_form_memory\" \"m\")\n+\t\t     (match_operand:DI 2 \"int_reg_operand\" \"0\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_PCREL_OPT_LD_RELOC)))\n+   (clobber (match_scratch:DI 4 \"=bX\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[3]);\n+  return \"lh<az> %0,%1\";\n+}\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*pcrel_opt_ldqi_u<mode>_gpr\"\n+  [(set (match_operand:EXTQI 0 \"int_reg_operand\" \"+r\")\n+\t(zero_extend:EXTQI\n+\t (unspec:QI [(match_operand:QI 1 \"d_form_memory\" \"m\")\n+\t\t     (match_operand:DI 2 \"int_reg_operand\" \"0\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_PCREL_OPT_LD_RELOC)))\n+   (clobber (match_scratch:DI 4 \"=bX\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[3]);\n+  return \"lbz %0,%1\";\n+}\n+  [(set_attr \"type\" \"load\")])\n+\n+;; Scalar types that can be optimized by loading them into floating point\n+;; or Altivec registers.\n+(define_mode_iterator PCRELOPT_FP [DI DF SF])\n+\n+;; Load instructions to load up scalar floating point or 64-bit integer values\n+;; into floating point registers or Altivec registers.\n+(define_mode_attr PCRELOPT_FPR_LD [(DI \"lfd\") (DF \"lfd\") (SF \"lfs\")])\n+(define_mode_attr PCRELOPT_VMX_LD [(DI \"lxsd\") (DF \"lxsd\") (SF \"lxssp\")])\n+\n+;; PCREL_OPT load operation of scalar DF/DI/SF into vector registers.\n+(define_insn \"*pcrel_opt_ld<mode>_vsx\"\n+  [(set (match_operand:PCRELOPT_FP 0 \"vsx_register_operand\" \"+d,v\")\n+\t(unspec:PCRELOPT_FP [(match_operand:PCRELOPT_FP 1 \"d_form_memory\" \"m,m\")\n+\t\t       (match_operand:DI 2 \"vsx_register_operand\" \"0,0\")\n+\t\t       (match_operand 3 \"const_int_operand\" \"n,n\")]\n+\t\t       UNSPEC_PCREL_OPT_LD_RELOC))\n+   (clobber (match_operand:DI 4 \"base_reg_operand\" \"=b,b\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[3]);\n+  return which_alternative ? \"<PCRELOPT_VMX_LD> %0,%1\"\n+\t\t\t : \"<PCRELOPT_FPR_LD> %0,%1\";\n+}\n+  [(set_attr \"type\" \"fpload\")])\n+\n+;; PCREL_OPT optimization extending SFmode to DFmode via a load.\n+(define_insn \"*pcrel_opt_ldsf_df\"\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"+d,v\")\n+\t(float_extend:DF\n+\t (unspec:SF [(match_operand:SF 1 \"d_form_memory\" \"m,m\")\n+\t\t     (match_operand:DI 2 \"vsx_register_operand\" \"0,0\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"n,n\")]\n+\t\t    UNSPEC_PCREL_OPT_LD_RELOC)))\n+   (clobber (match_operand:DI 4 \"base_reg_operand\" \"=b,b\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[3]);\n+  return which_alternative ? \"lxssp %0,%1\" : \"lfs %0,%1\";\n+}\n+  [(set_attr \"type\" \"fpload\")])\n+\n+;; PCREL_OPT load operation of vector/float128 types into vector registers.\n+(define_insn \"*pcrel_opt_ld<mode>\"\n+  [(set (match_operand:PCRELOPT_VECT 0 \"vsx_register_operand\" \"+wa\")\n+\t(unspec:PCRELOPT_VECT [(match_operand:PCRELOPT_VECT 1 \"d_form_memory\" \"m\")\n+\t\t\t (match_operand:DI 2 \"vsx_register_operand\" \"0\")\n+\t\t\t (match_operand 3 \"const_int_operand\" \"n\")]\n+\t\t\tUNSPEC_PCREL_OPT_LD_RELOC))\n+   (clobber (match_operand:DI 4 \"base_reg_operand\" \"=b\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[3]);\n+  return \"lxv %x0,%1\";\n+}\n+  [(set_attr \"type\" \"vecload\")])\n+\n+\f\n+;; PCREL_OPT optimization for stores.  We need to put the label after the PLD\n+;; instruction, because the assembler might insert a NOP before the PLD for\n+;; alignment.\n+;;\n+;; If we are optimizing a single write, normally the code would look like:\n+;;\n+;;\t(set (reg:DI <ptr>)\n+;;\t     (symbol_ref:DI \"<extern_addr>\"))\t# <data> must be live here\n+;;\n+;;\t    ...\t\t     # insns do not need to be adjacent\n+;;\n+;;\t(set (mem:SI (reg:DI <xxx>))\n+;;\t     (reg:SI <data>))\t\t\t# <ptr> dies with this insn\n+;;\n+;; We optimize this to be:\n+;;\n+;;\t(parallel [(set (reg:DI <ptr>)\n+;;\t\t\t(unspec:DI [(symbol_ref:DI \"<extern_addr>\")\n+;;\t\t\t\t    (const_int <marker>)]\n+;;\t\t\t\t   UNSPEC_PCREL_OPT_ST_ADDR))\n+;;\t\t   (use (reg:<MODE> <data>))])\n+;;\n+;;\t    ...\t\t     # insns do not need to be adjacent\n+;;\n+;;\t(parallel [(set (mem:<MODE> (reg:DI <ptr>))\n+;;\t\t\t(unspec:<MODE> [(reg:<MODE> <data>)\n+;;\t\t\t\t\t(const_int <marker>)]\n+;;\t\t\t\t       UNSPEC_PCREL_OPT_ST_RELOC))\n+;;\t\t   (clobber (reg:DI <ptr>))])\n+\n+(define_insn \"*pcrel_opt_st_addr<mode>\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=b\")\n+\t(unspec:DI [(match_operand:DI 1 \"pcrel_external_address\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n\")]\n+\t\tUNSPEC_PCREL_OPT_ST_ADDR))\n+   (use (match_operand:PCRELOPT 3 \"gpc_reg_operand\" \"rwa\"))]\n+  \"TARGET_PCREL_OPT\"\n+  \"ld %0,%a1\\n.Lpcrel%2:\"\n+  [(set_attr \"prefixed\" \"yes\")\n+   (set_attr \"type\" \"load\")\n+   (set_attr \"loads_external_address\" \"yes\")])\n+\n+;; PCREL_OPT stores.\n+(define_insn \"*pcrel_opt_st<mode>\"\n+  [(set (match_operand:QHSI 0 \"d_form_memory\" \"=m\")\n+\t(unspec:QHSI [(match_operand:QHSI 1 \"gpc_reg_operand\" \"r\")\n+\t\t      (match_operand 2 \"const_int_operand\" \"n\")]\n+\t\t     UNSPEC_PCREL_OPT_ST_RELOC))\n+   (clobber (match_operand:DI 3 \"base_reg_operand\" \"=b\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[2]);\n+  return \"st<wd> %1,%0\";\n+}\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*pcrel_opt_stdi\"\n+  [(set (match_operand:DI 0 \"d_form_memory\" \"=m,m,m\")\n+\t(unspec:DI [(match_operand:DI 1 \"gpc_reg_operand\" \"r,d,v\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n,n,n\")]\n+\t\t   UNSPEC_PCREL_OPT_ST_RELOC))\n+   (clobber (match_operand:DI 3 \"base_reg_operand\" \"=b,b,b\"))]\n+  \"TARGET_PCREL_OPT && TARGET_POWERPC64\"\n+{\n+  output_pcrel_opt_reloc (operands[2]);\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"std %1,%0\";\n+    case 1:\n+      return \"stfd %1,%0\";\n+    case 2:\n+      return \"stxsd %1,%0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"store,fpstore,fpstore\")])\n+\n+(define_insn \"*pcrel_opt_stsf\"\n+  [(set (match_operand:SF 0 \"d_form_memory\" \"=m,m,m\")\n+\t(unspec:SF [(match_operand:SF 1 \"gpc_reg_operand\" \"d,v,r\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n,n,n\")]\n+\t\t   UNSPEC_PCREL_OPT_ST_RELOC))\n+   (clobber (match_operand:DI 3 \"base_reg_operand\" \"=b,b,b\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[2]);\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"stfs %1,%0\";\n+    case 1:\n+      return \"stxssp %1,%0\";\n+    case 2:\n+      return \"stw %1,%0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"fpstore,fpstore,store\")])\n+\n+(define_insn \"*pcrel_opt_stdf\"\n+  [(set (match_operand:DF 0 \"d_form_memory\" \"=m,m,m\")\n+\t(unspec:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d,v,r\")\n+\t\t    (match_operand 2 \"const_int_operand\" \"n,n,n\")]\n+\t\t   UNSPEC_PCREL_OPT_ST_RELOC))\n+   (clobber (match_operand:DI 3 \"base_reg_operand\" \"=b,b,b\"))]\n+  \"TARGET_PCREL_OPT\n+   && (TARGET_POWERPC64 || vsx_register_operand (operands[1], DFmode))\"\n+{\n+  output_pcrel_opt_reloc (operands[2]);\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"stfd %1,%0\";\n+    case 1:\n+      return \"stxsd %1,%0\";\n+    case 2:\n+      return \"std %1,%0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"fpstore,fpstore,store\")])\n+\n+(define_insn \"*pcrel_opt_st<mode>\"\n+  [(set (match_operand:PCRELOPT_VECT 0 \"d_form_memory\" \"=m\")\n+\t(unspec:PCRELOPT_VECT [(match_operand:PCRELOPT_VECT 1 \"gpc_reg_operand\" \"wa\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")]\n+\t\t    UNSPEC_PCREL_OPT_ST_RELOC))\n+   (clobber (match_operand:DI 3 \"base_reg_operand\" \"=b\"))]\n+  \"TARGET_PCREL_OPT\"\n+{\n+  output_pcrel_opt_reloc (operands[2]);\n+  return \"stxv %x1,%0\";\n+}\n+  [(set_attr \"type\" \"vecstore\")])"}, {"sha": "bd6ef1e56a51f55aa9bf70866416df68ad4ac7dd", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -1904,3 +1904,24 @@\n {\n   return address_is_prefixed (XEXP (op, 0), mode, NON_PREFIXED_DEFAULT);\n })\n+\n+;; Return true if the operand is a valid memory operand with a D-form\n+;; address that could be merged with the load of a PC-relative external address\n+;; with the PCREL_OPT optimization.  We don't check here whether or not the\n+;; offset needs to be used in a DS-FORM (bottom 2 bits 0) or DQ-FORM (bottom 4\n+;; bits 0) instruction.\n+(define_predicate \"d_form_memory\"\n+  (match_code \"mem\")\n+{\n+  if (!memory_operand (op, mode))\n+    return false;\n+\n+  rtx addr = XEXP (op, 0);\n+\n+  if (REG_P (addr))\n+    return true;\n+  if (SUBREG_P (addr) && REG_P (SUBREG_REG (addr)))\n+    return true;\n+\n+  return !indexed_address (addr, mode);\n+})"}, {"sha": "cbbb42c1b3a151b81de30358b1303393f5c10e34", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -77,6 +77,7 @@\n /* Flags that need to be turned off if -mno-power10.  */\n #define OTHER_POWER10_MASKS\t(OPTION_MASK_MMA\t\t\t\\\n \t\t\t\t | OPTION_MASK_PCREL\t\t\t\\\n+\t\t\t\t | OPTION_MASK_PCREL_OPT\t\t\\\n \t\t\t\t | OPTION_MASK_PREFIXED)\n \n #define ISA_3_1_MASKS_SERVER\t(ISA_3_0_MASKS_SERVER\t\t\t\\\n@@ -147,6 +148,7 @@\n \t\t\t\t | OPTION_MASK_P9_MISC\t\t\t\\\n \t\t\t\t | OPTION_MASK_P9_VECTOR\t\t\\\n \t\t\t\t | OPTION_MASK_PCREL\t\t\t\\\n+\t\t\t\t | OPTION_MASK_PCREL_OPT\t\t\\\n \t\t\t\t | OPTION_MASK_POPCNTB\t\t\t\\\n \t\t\t\t | OPTION_MASK_POPCNTD\t\t\t\\\n \t\t\t\t | OPTION_MASK_POWERPC64\t\t\\"}, {"sha": "c8e46ba6abe0d9bc4d84cbf06223a1306ce525b3", "filename": "gcc/config/rs6000/rs6000-passes.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-passes.def?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -24,4 +24,12 @@ along with GCC; see the file COPYING3.  If not see\n    REPLACE_PASS (PASS, INSTANCE, TGT_PASS)\n  */\n \n+  /* Pass to add the appropriate vector swaps on power8 little endian systems.\n+     The power8 does not have instructions that automaticaly do the byte swaps\n+     for loads and stores.  */\n   INSERT_PASS_BEFORE (pass_cse, 1, pass_analyze_swaps);\n+\n+  /* Pass to do the PCREL_OPT optimization that combines the load of an\n+     external symbol's address along with a single load or store using that\n+     address as a base register.  */\n+  INSERT_PASS_BEFORE (pass_sched2, 1, pass_pcrel_opt);"}, {"sha": "32275aa981e203d0c8f634557bf8f6fa5076c785", "filename": "gcc/config/rs6000/rs6000-pcrel-opt.c", "status": "added", "additions": 910, "deletions": 0, "changes": 910, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-pcrel-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-pcrel-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-pcrel-opt.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,910 @@\n+/* Subroutines used support the pc-relative linker optimization.\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file implements a RTL pass that looks for pc-relative loads of the\n+   address of an external variable using the PCREL_GOT relocation and a single\n+   load that uses that external address.  If that is found we create the\n+   PCREL_OPT relocation to possibly convert:\n+\n+\tpld addr_reg,var@pcrel@got\n+\n+\t<possibly other insns that do not use 'addr_reg' or 'data_reg'>\n+\n+\tlwz data_reg,0(addr_reg)\n+\n+   into:\n+\n+\tplwz data_reg,var@pcrel\n+\n+\t<possibly other insns that do not use 'addr_reg' or 'data_reg'>\n+\n+\tnop\n+\n+   Of course it would be nice to be able to put the plwz in this example in\n+   place of the lwz but the linker cannot easily replace a 4-byte instruction\n+   with an 8-byte one.\n+\n+   If the variable is not defined in the main program or the code using it is\n+   not in the main program, the linker puts the address in the .got section and\n+   generates:\n+\n+\t\t.section .got\n+\t.Lvar_got:\n+\t\t.dword var\n+\n+   At the point where it is referenced, we have:\n+\n+\t\t.section .text\n+\t\tpld addr_reg,.Lvar_got@pcrel\n+\n+\t\t<possibly other insns that do not use 'addr_reg' or 'data_reg'>\n+\n+\t\tlwz data_reg,0(addr_reg)\n+\n+   We look for a single usage in the basic block where this external\n+   address is loaded, and convert it to a PCREL_OPT relocation so the\n+   linker can convert it to a single plwz in this case.  Multiple uses\n+   or references in another basic block will force us to not use the\n+   PCREL_OPT relocation.\n+\n+   We also optimize stores to the address of an external variable using the\n+   PCREL_GOT relocation and a single store that uses that external address.  If\n+   that is found we create the PCREL_OPT relocation to possibly convert:\n+\n+\tpld addr_reg,var@pcrel@got\n+\n+\t<possibly other insns that do not use 'addr_reg' or 'data_reg'>\n+\n+\tstw data_reg,0(addr_reg)\n+\n+   into:\n+\n+\tpstw data_reg,var@pcrel\n+\n+\t<possibly other insns that do not use 'addr_reg' or 'data_reg'>\n+\n+\tnop\n+\n+   If the variable is not defined in the main program or the code using it is\n+   not in the main program, the linker puts the address in the .got section and\n+   generates:\n+\n+\t\t.section .got\n+\t.Lvar_got:\n+\t\t.dword var\n+\n+   And at our point of reference we have:\n+\n+\t\t.section .text\n+\t\tpld addr_reg,.Lvar_got@pcrel\n+\n+\t\t<possibly other insns that do not use 'addr_reg' or 'data_reg'>\n+\n+\t\tstw data_reg,0(addr_reg)\n+\n+   We only look for a single usage in the basic block where the external\n+   address is loaded.  Multiple uses or references in another basic block will\n+   force us to not use the PCREL_OPT relocation.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"memmodel.h\"\n+#include \"expmed.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"ira.h\"\n+#include \"print-tree.h\"\n+#include \"varasm.h\"\n+#include \"explow.h\"\n+#include \"expr.h\"\n+#include \"output.h\"\n+#include \"tree-pass.h\"\n+#include \"rtx-vector-builder.h\"\n+#include \"print-rtl.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+\n+/* Various counters.  */\n+static struct {\n+  unsigned long extern_addrs;\n+  unsigned long loads;\n+  unsigned long adjacent_loads;\n+  unsigned long failed_loads;\n+  unsigned long stores;\n+  unsigned long adjacent_stores;\n+  unsigned long failed_stores;\n+} counters;\n+\n+/* Unique integer that is appended to .Lpcrel to make a pcrel_opt label. */\n+static unsigned int pcrel_opt_next_num;\n+\n+\f\n+/* Optimize a PC-relative load address to be used in a load. Before it calls\n+   this function, pcrel_opt_address () uses DF to make sure that it is safe\n+   to do the PCREL_OPT optimization on these insns.\n+\n+   Convert insns of the form:\n+\n+\t(set (reg:DI addr)\n+\t     (symbol_ref:DI \"ext_symbol\"))\n+\n+\t...\n+\n+\t(set (reg:<MODE> value)\n+\t     (mem:<MODE> (reg:DI addr)))\n+\n+   into:\n+\n+\t(parallel [(set (reg:DI addr)\n+\t\t\t(unspec:<MODE> [(symbol_ref:DI \"ext_symbol\")\n+\t\t\t\t\t(const_int label_num)]\n+\t\t\t\t       UNSPEC_PCREL_OPT_LD_ADDR))\n+\t\t   (set (reg:DI data)\n+\t\t\t(unspec:DI [(const_int 0)]\n+\t\t\t\t   UNSPEC_PCREL_OPT_LD_DATA))])\n+\n+\t...\n+\n+\t(parallel [(set (reg:<MODE>)\n+\t\t\t(unspec:<MODE> [(mem:<MODE> (reg:DI addr))\n+\t\t\t\t\t(reg:DI data)\n+\t\t\t\t\t(const_int label_num)]\n+\t\t\t\t       UNSPEC_PCREL_OPT_LD_RELOC))\n+\t\t   (clobber (reg:DI addr))])\n+\n+   Because PCREL_OPT will move the actual location of the load from the second\n+   insn to the first, we need to have the register for the load data be live\n+   starting at the first insn.\n+\n+   If the destination register for the data being loaded is the same register\n+   used to hold the extern address, we generate this insn instead:\n+\n+\t(set (reg:DI data)\n+\t     (unspec:DI [(symbol_ref:DI \"ext_symbol\")\n+\t\t\t (const_int label_num)]\n+\t\t\tUNSPEC_PCREL_OPT_LD_SAME_REG))\n+\n+   In the first insn, we set both the address of the external variable, and mark\n+   that the variable being loaded both are created in that insn, and are\n+   consumed in the second insn.  The mode used in the first insn for the data\n+   register that will be loaded in the second insn doesn't matter in the end so\n+   we use DImode.  We just need to mark that both registers may be set in the\n+   first insn, and will be used in the second insn.\n+\n+   The UNSPEC_PCREL_OPT_LD_ADDR insn will generate the load address plus\n+   a definition of a label (.Lpcrel<n>), while the UNSPEC_PCREL_OPT_LD_RELOC\n+   insn will generate the .reloc to tell the linker to tie the load address and\n+   load using that address together.\n+\n+\tpld b,ext_symbol@got@pcrel\n+   .Lpcrel1:\n+\n+\t...\n+\n+\t.reloc .Lpcrel1-8,R_PPC64_PCREL_OPT,.-(.Lpcrel1-8)\n+\tlwz r,0(b)\n+\n+   If ext_symbol is defined in another object file in the main program and we\n+   are linking the main program, the linker will convert the above instructions\n+   to:\n+\n+\tplwz r,ext_symbol@got@pcrel\n+\n+\t...\n+\n+\tnop\n+\n+   ADDR_INSN is the insn that is loading the address.\n+   LOAD_INSN is the insn that uses the address to load the actual data.  */\n+\n+static void\n+pcrel_opt_load (rtx_insn *addr_insn, rtx_insn *load_insn)\n+{\n+  rtx addr_set = PATTERN (addr_insn);\n+  gcc_assert (GET_CODE (addr_set) == SET);\n+\n+  rtx addr_reg = SET_DEST (addr_set);\n+  gcc_assert (base_reg_operand (addr_reg, Pmode));\n+\n+  rtx addr_symbol = SET_SRC (addr_set);\n+  gcc_assert (pcrel_external_address (addr_symbol, Pmode));\n+\n+  rtx load_set = PATTERN (load_insn);\n+  gcc_assert (GET_CODE (load_set) == SET);\n+\n+  /* Make sure there are no references to the register being loaded\n+     between the two insns.  */\n+  rtx reg = SET_DEST (load_set);\n+  if (reg_used_between_p (reg, addr_insn, load_insn)\n+      || reg_set_between_p (reg, addr_insn, load_insn))\n+    return;\n+\n+  rtx mem = SET_SRC (load_set);\n+  machine_mode reg_mode = GET_MODE (reg);\n+  machine_mode mem_mode = GET_MODE (mem);\n+  rtx mem_inner = mem;\n+  unsigned int reg_regno = reg_or_subregno (reg);\n+\n+  /* Handle the fact that LWA is a DS format instruction, but LWZ is a D format\n+     instruction.  If the mem load is a signed SImode (i.e. LWA would be used)\n+     we set mem_mode to DImode so that pcrel_opt_valid_mem_p() will check that\n+     the address will work for a DS-form instruction. If it won't work, we skip\n+     the optimization.  The float loads are all indexed so there are no problems\n+     there.  */\n+\n+  if (GET_CODE (mem) == SIGN_EXTEND && GET_MODE (XEXP (mem, 0)) == SImode)\n+    {\n+      if (!INT_REGNO_P (reg_regno))\n+\treturn;\n+\n+      mem_inner = XEXP (mem, 0);\n+      mem_mode = DImode;\n+    }\n+\n+  else if (GET_CODE (mem) == SIGN_EXTEND\n+\t   || GET_CODE (mem) == ZERO_EXTEND\n+\t   || GET_CODE (mem) == FLOAT_EXTEND)\n+    {\n+      mem_inner = XEXP (mem, 0);\n+      mem_mode = GET_MODE (mem_inner);\n+    }\n+\n+  if (!MEM_P (mem_inner))\n+    return;\n+\n+  /* Can we do PCREL_OPT for this reference?  */\n+  if (!pcrel_opt_valid_mem_p (reg, mem_mode, mem_inner))\n+    return;\n+\n+  /* Allocate a new PC-relative label, and update the load external address\n+     insn.\n+\n+     If the register being loaded is different from the address register, we\n+     need to indicate both registers are set at the load of the address.\n+\n+\t(parallel [(set (reg load)\n+\t\t\t(unspec [(symbol_ref addr_symbol)\n+\t\t\t\t (const_int label_num)]\n+\t\t\t\tUNSPEC_PCREL_OPT_LD_ADDR))\n+\t\t   (set (reg addr)\n+\t\t\t(unspec [(const_int 0)]\n+\t\t\t\tUNSPEC_PCREL_OPT_LD_DATA))])\n+\n+     If the register being loaded is the same as the address register, we use\n+     an alternate form:\n+\n+\t(set (reg load)\n+\t     (unspec [(symbol_ref addr_symbol)\n+\t\t      (const_int label_num)]\n+\t\t     UNSPEC_PCREL_OPT_LD_SAME_REG))  */\n+  unsigned int addr_regno = reg_or_subregno (addr_reg);\n+  rtx label_num = GEN_INT (++pcrel_opt_next_num);\n+  rtx reg_di = gen_rtx_REG (DImode, reg_regno);\n+  rtx addr_pattern;\n+\n+  /* Create the load address, either using the pattern with an explicit clobber\n+     if the address register is not the same as the register being loaded, or\n+     using the pattern that requires the address register to be the address\n+     loaded.  */\n+  if (addr_regno != reg_regno)\n+    addr_pattern = gen_pcrel_opt_ld_addr (addr_reg, addr_symbol, label_num,\n+\t\t\t\t\t  reg_di);\n+  else\n+    addr_pattern = gen_pcrel_opt_ld_addr_same_reg (addr_reg, addr_symbol,\n+\t\t\t\t\t\t   label_num);\n+\n+  validate_change (addr_insn, &PATTERN (addr_insn), addr_pattern, false);\n+\n+  /* Update the load insn.  If the mem had a sign/zero/float extend, add that\n+     also after doing the UNSPEC.  Add an explicit clobber of the external\n+     address register just to make it clear that the address register dies.\n+\n+\t(parallel [(set (reg:<MODE> data)\n+\t\t\t(unspec:<MODE> [(mem (addr_reg)\n+\t\t\t\t\t(reg:DI data)\n+\t\t\t\t\t(const_int label_num)]\n+\t\t\t\t       UNSPEC_PCREL_OPT_LD_RELOC))\n+\t\t   (clobber (reg:DI addr_reg))])  */\n+  rtvec v_load = gen_rtvec (3, mem_inner, reg_di, label_num);\n+  rtx new_load = gen_rtx_UNSPEC (GET_MODE (mem_inner), v_load,\n+\t\t\t\t UNSPEC_PCREL_OPT_LD_RELOC);\n+\n+  if (GET_CODE (mem) != GET_CODE (mem_inner))\n+    new_load = gen_rtx_fmt_e (GET_CODE (mem), reg_mode, new_load);\n+\n+  rtx new_load_set = gen_rtx_SET (reg, new_load);\n+  rtx load_clobber = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t      (addr_regno == reg_regno\n+\t\t\t\t       ? gen_rtx_SCRATCH (Pmode)\n+\t\t\t\t       : addr_reg));\n+  rtx new_load_pattern\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, new_load_set, load_clobber));\n+\n+  validate_change (load_insn, &PATTERN (load_insn), new_load_pattern, false);\n+\n+  /* Attempt to apply the changes:  */\n+  if (!apply_change_group ())\n+    {\n+      /* PCREL_OPT load optimization did not succeed.  */\n+      counters.failed_loads++;\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"PCREL_OPT load failed (addr insn = %d, use insn = %d).\\n\",\n+\t\t INSN_UID (addr_insn),\n+\t\t INSN_UID (load_insn));\n+      return;\n+    }\n+\n+  /* PCREL_OPT load optimization succeeded.  */\n+  counters.loads++;\n+  if (next_nonnote_insn (addr_insn) == load_insn)\n+    counters.adjacent_loads++;\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"PCREL_OPT load (addr insn = %d, use insn = %d).\\n\",\n+\t     INSN_UID (addr_insn),\n+\t     INSN_UID (load_insn));\n+\n+  /* Because we have set DF_DEFER_INSN_RESCAN, we have to explicitly do it\n+     after we have made changes to the insns.  */\n+  df_analyze ();\n+\n+}\n+\f\n+/* Optimize a PC-relative load address to be used in a store. Before calling\n+   this function, pcrel_opt_address () uses DF to make sure it is safe to do\n+   the PCREL_OPT optimization.\n+\n+   Convert insns of the form:\n+\n+\t(set (reg:DI addr)\n+\t     (symbol_ref:DI \"ext_symbol\"))\n+\n+\t...\n+\n+\t(set (mem:<MODE> (reg:DI addr))\n+\t     (reg:<MODE> value))\n+\n+   into:\n+\n+\t(parallel [(set (reg:DI addr)\n+\t\t\t(unspec:DI [(symbol_ref:DI \"ext_symbol\")\n+\t\t\t\t    (const_int label_num)]\n+\t\t\t\t  UNSPEC_PCREL_OPT_ST_ADDR))\n+\t\t  (use (reg:<MODE> value))])\n+\n+\t...\n+\n+\t(parallel [(set (mem:<MODE> (reg:DI addr))\n+\t\t\t(unspec:<MODE> [(reg:<MODE>)\n+\t\t\t\t\t(const_int label_num)]\n+\t\t\t\t       UNSPEC_PCREL_OPT_ST_RELOC))\n+\t\t   (clobber (reg:DI addr))])\n+\n+   The UNSPEC_PCREL_OPT_ST_ADDR insn will generate the load address plus a\n+   definition of a label (.Lpcrel<n>), while the UNSPEC_PCREL_OPT_ST_RELOC insn\n+   will generate the .reloc to tell the linker to tie the load address and load\n+   using that address together.\n+\n+\tpld b,ext_symbol@got@pcrel\n+   .Lpcrel1:\n+\n+\t...\n+\n+\t.reloc .Lpcrel1-8,R_PPC64_PCREL_OPT,.-(.Lpcrel1-8)\n+\tstw r,0(b)\n+\n+   If ext_symbol is defined in another object file in the main program and we\n+   are linking the main program, the linker will convert the above instructions\n+   to:\n+\n+\tpstwz r,ext_symbol@got@pcrel\n+\n+\t...\n+\n+\tnop  */\n+\n+static void\n+pcrel_opt_store (rtx_insn *addr_insn,\t\t/* insn loading address.  */\n+\t\t rtx_insn *store_insn)\t\t/* insn using address.  */\n+{\n+  rtx addr_old_set = PATTERN (addr_insn);\n+  gcc_assert (GET_CODE (addr_old_set) == SET);\n+\n+  rtx addr_reg = SET_DEST (addr_old_set);\n+  gcc_assert (base_reg_operand (addr_reg, Pmode));\n+\n+  rtx addr_symbol = SET_SRC (addr_old_set);\n+  gcc_assert (pcrel_external_address (addr_symbol, Pmode));\n+\n+  rtx store_set = PATTERN (store_insn);\n+  gcc_assert (GET_CODE (store_set) == SET);\n+\n+  rtx mem = SET_DEST (store_set);\n+  if (!MEM_P (mem))\n+    return;\n+\n+  machine_mode mem_mode = GET_MODE (mem);\n+  rtx reg = SET_SRC (store_set);\n+\n+  /* Don't allow storing the address of the external variable.  */\n+  if (reg_or_subregno (reg) == reg_or_subregno (addr_reg))\n+    return;\n+\n+  /* Can we do PCREL_OPT for this reference?  */\n+  if (!pcrel_opt_valid_mem_p (reg, mem_mode, mem))\n+    return;\n+\n+  /* Allocate a new PC-relative label, and update the load address insn.\n+\n+\t(parallel [(set (reg addr)\n+\t\t       (unspec [(symbol_ref symbol)\n+\t\t\t\t (const_int label_num)]\n+\t\t\t\tUNSPEC_PCREL_OPT_ST_ADDR))\n+\t\t  (use (reg store))])\n+  */\n+  rtx label_num = GEN_INT (++pcrel_opt_next_num);\n+  rtvec v_addr = gen_rtvec (2, addr_symbol, label_num);\n+  rtx addr_unspec = gen_rtx_UNSPEC (Pmode, v_addr,\n+\t\t\t\t   UNSPEC_PCREL_OPT_ST_ADDR);\n+  rtx addr_new_set = gen_rtx_SET (addr_reg, addr_unspec);\n+  rtx addr_use = gen_rtx_USE (VOIDmode, reg);\n+  rtx addr_new_pattern\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, addr_new_set, addr_use));\n+\n+  validate_change (addr_insn, &PATTERN (addr_insn), addr_new_pattern, false);\n+\n+  /* Update the store insn.  Add an explicit clobber of the external address\n+     register just to be sure there are no additional uses of the address\n+     register.\n+\n+\t(parallel [(set (mem (addr_reg)\n+\t\t\t(unspec:<MODE> [(reg)\n+\t\t\t\t\t(const_int label_num)]\n+\t\t\t\t       UNSPEC_PCREL_OPT_ST_RELOC))\n+\t\t  (clobber (reg:DI addr_reg))])  */\n+  rtvec v_store = gen_rtvec (2, reg, label_num);\n+  rtx new_store = gen_rtx_UNSPEC (mem_mode, v_store,\n+\t\t\t\t  UNSPEC_PCREL_OPT_ST_RELOC);\n+\n+  rtx new_store_set = gen_rtx_SET (mem, new_store);\n+  rtx store_clobber = gen_rtx_CLOBBER (VOIDmode, addr_reg);\n+  rtx new_store_pattern\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, new_store_set, store_clobber));\n+\n+  validate_change (store_insn, &PATTERN (store_insn), new_store_pattern, false);\n+\n+  /* Attempt to apply the changes:  */\n+  if (!apply_change_group ())\n+    {\n+      /* PCREL_OPT store failed.  */\n+      counters.failed_stores++;\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"PCREL_OPT store failed (addr insn = %d, use insn = %d).\\n\",\n+\t\t INSN_UID (addr_insn),\n+\t\t INSN_UID (store_insn));\n+      return;\n+    }\n+\n+  /* PCREL_OPT store succeeded.  */\n+  counters.stores++;\n+  if (next_nonnote_insn (addr_insn) == store_insn)\n+    counters.adjacent_stores++;\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"PCREL_OPT store (addr insn = %d, use insn = %d).\\n\",\n+\t     INSN_UID (addr_insn),\n+\t     INSN_UID (store_insn));\n+\n+  /* Because we have set DF_DEFER_INSN_RESCAN, we have to explicitly do it\n+     after we have made changes to the insns.  */\n+  df_analyze();\n+\n+}\n+\n+/* Return the register used as the base register of MEM, if the instruction has\n+   a pc-relative form.  We look for BSWAP to rule out LFIWAX/LFIWZX/STFIWX, and\n+   ROTATE/VEC_SELECT are RTX_EXTRA not RTX_UNARY which rules out lxvd2x. This\n+   excludes instructions that do not have a pc-relative form.  */\n+\n+static rtx\n+get_mem_base_reg (rtx mem)\n+{\n+  const char * fmt;\n+\n+  while (!MEM_P (mem))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (mem)) != RTX_UNARY\n+\t  || GET_CODE (mem) == BSWAP)\n+\treturn NULL_RTX;\n+      fmt = GET_RTX_FORMAT (GET_CODE (mem));\n+      if (fmt[0] != 'e')\n+\treturn NULL_RTX;\n+      mem = XEXP (mem, 0);\n+      if (mem == NULL_RTX )\n+\treturn NULL_RTX;\n+    }\n+\n+  if (!MEM_SIZE_KNOWN_P (mem))\n+    return NULL_RTX;\n+\n+  rtx addr_rtx = (XEXP (mem, 0));\n+  if (GET_CODE (addr_rtx) == PRE_MODIFY)\n+    addr_rtx = XEXP (addr_rtx, 1);\n+\n+  while (GET_CODE (addr_rtx) == PLUS\n+\t && CONST_INT_P (XEXP (addr_rtx, 1)))\n+    addr_rtx = XEXP (addr_rtx, 0);\n+\n+  if (!REG_P (addr_rtx))\n+    return NULL_RTX;\n+\n+  return addr_rtx;\n+}\n+\n+/* Check whether INSN contains a reference to REGNO that will inhibit the\n+   PCREL_OPT optimization.  If TYPE is a load or store instruction, return true\n+   if there is a definition of REGNO.  If TYPE is a load instruction, then\n+   return true of there is a use of REGNO.  */\n+\n+static bool\n+insn_references_regno_p (rtx_insn *insn, unsigned int regno,\n+\t\t       enum attr_type type)\n+{\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  df_ref ref;\n+\n+  /* Return true if there is a definition of REGNO.  */\n+  for (ref = DF_INSN_INFO_DEFS (insn_info); ref; ref = DF_REF_NEXT_LOC (ref))\n+    if (DF_REF_REGNO (ref) == regno)\n+      return true;\n+\n+  /* If type is a load, return true if there is a use of REGNO.  */\n+  if (type == TYPE_LOAD\n+      || type == TYPE_FPLOAD\n+      || type == TYPE_VECLOAD)\n+    for (ref = DF_INSN_INFO_USES (insn_info); ref; ref = DF_REF_NEXT_LOC (ref))\n+      if (DF_REF_REGNO (ref) == regno)\n+\treturn true;\n+\n+  return false;\n+}\n+\n+/* Given an insn that loads up a base register with the address of an\n+   external symbol, see if we can optimize it with the PCREL_OPT\n+   optimization.\n+\n+   DF is used to make sure that there is exactly one definition and one\n+   non-debug use of the address register defined by the insn. The use insn must\n+   be a non-prefix insn, and must also be in the same basic block as the address\n+   insn.\n+\n+   ADDR_INSN is the insn that loads the external symbol address.  */\n+\n+static void\n+pcrel_opt_address (rtx_insn *addr_insn)\n+{\n+  counters.extern_addrs++;\n+\n+  /* Do some basic validation.  */\n+  rtx addr_set = PATTERN (addr_insn);\n+  if (GET_CODE (addr_set) != SET)\n+    return;\n+\n+  rtx addr_reg = SET_DEST (addr_set);\n+  rtx addr_symbol = SET_SRC (addr_set);\n+\n+  if (!base_reg_operand (addr_reg, Pmode)\n+      || !pcrel_external_address (addr_symbol, Pmode))\n+    return;\n+\n+  /* The address register must have exactly one definition.  */\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (addr_insn);\n+  if (!insn_info)\n+    return;\n+\n+  df_ref def = df_single_def (insn_info);\n+  if (!def)\n+    return;\n+\n+  /* Make sure there is at least one use.  */\n+  df_link *chain = DF_REF_CHAIN (def);\n+  if (!chain || !chain->ref)\n+    return;\n+\n+  /* Get the insn of the possible load or store.  */\n+  rtx_insn *use_insn = DF_REF_INSN (chain->ref);\n+\n+  /* Ensure there are no other uses.  */\n+  for (chain = chain->next; chain; chain = chain->next)\n+    if (chain->ref && DF_REF_INSN_INFO (chain->ref))\n+      {\n+\tgcc_assert (DF_REF_INSN (chain->ref));\n+\tif (NONDEBUG_INSN_P (DF_REF_INSN (chain->ref)))\n+\t  return;\n+      }\n+\n+  /* The use instruction must be a single non-prefixed instruction.  */\n+  if (get_attr_length (use_insn) != 4)\n+    return;\n+\n+  /* The address and the memory operation must be in the same basic block.  */\n+  if (BLOCK_FOR_INSN (use_insn) != BLOCK_FOR_INSN (addr_insn))\n+    return;\n+\n+  /* If this isn't a simple SET, skip doing the optimization.  */\n+  if (GET_CODE (PATTERN (use_insn)) != SET)\n+    return;\n+\n+  enum attr_type use_insn_type = get_attr_type (use_insn);\n+  unsigned int use_regno;\n+\n+  /* Make sure the use_insn is using addr_reg as its base register\n+     for the load or store, and determine the regno for the register\n+     used in the use_insn.  */\n+  rtx use_dest, use_src;\n+  switch (use_insn_type)\n+    {\n+    case TYPE_LOAD:\n+    case TYPE_FPLOAD:\n+    case TYPE_VECLOAD:\n+      /* Make sure our address register is the same register used in the\n+\t base address of the load.  */\n+      if (addr_reg != get_mem_base_reg (SET_SRC (PATTERN (use_insn))))\n+\treturn;\n+      /* Make sure we are setting a register before we look at REGNO.  */\n+      use_dest = SET_DEST (PATTERN (use_insn));\n+      if (!register_operand (use_dest, GET_MODE (use_dest)))\n+\treturn;\n+      use_regno = REGNO (use_dest);\n+      break;\n+    case TYPE_STORE:\n+    case TYPE_FPSTORE:\n+    case TYPE_VECSTORE:\n+      /* Make sure our address register is the same register used in the\n+\t base address of the store.  */\n+      if (addr_reg != get_mem_base_reg (SET_DEST (PATTERN (use_insn))))\n+\treturn;\n+      /* Make sure this is a register before we look at REGNO.  */\n+      use_src = SET_SRC (PATTERN (use_insn));\n+      if (!register_operand (use_src, GET_MODE (use_src)))\n+\treturn;\n+      use_regno = REGNO (use_src);\n+      break;\n+    default:\n+      /* We can only optimize loads and stores.  Ignore everything else.  */\n+      return;\n+    }\n+\n+  rtx_insn *insn;\n+  for (insn = NEXT_INSN (addr_insn);\n+       insn != use_insn;\n+       insn = NEXT_INSN (insn))\n+    {\n+      /* If we see a call, do not do the PCREL_OPT optimization.  */\n+      if (CALL_P (insn))\n+\treturn;\n+\n+      /* Skip debug insns.  */\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      /* See if it is a load or store.  */\n+      if (GET_CODE (PATTERN (insn)) != USE\n+\t  && GET_CODE (PATTERN (insn)) != CLOBBER)\n+\t{\n+\t  switch (get_attr_type (insn))\n+\t    {\n+\t    case TYPE_LOAD:\n+\t      /* While load of the external address is a 'load' for scheduling\n+\t\t purposes, it should be safe to allow loading other external\n+\t\t addresses between the load of the external address we are\n+\t\t currently looking at and the load or store using that\n+\t\t address.  */\n+\t      if (get_attr_loads_external_address (insn)\n+\t\t  == LOADS_EXTERNAL_ADDRESS_YES)\n+\t\tbreak;\n+\t      /* fall through */\n+\n+\t    case TYPE_FPLOAD:\n+\t    case TYPE_VECLOAD:\n+\t      /* Don't do the PCREL_OPT store optimization if there is a load\n+\t\t operation.  For example, the load might be trying to load the\n+\t\t value being stored in between getting the address and doing\n+\t\t the store.  */\n+\t      if (use_insn_type == TYPE_STORE\n+\t\t  || use_insn_type == TYPE_FPSTORE\n+\t\t  || use_insn_type == TYPE_VECSTORE)\n+\t\treturn;\n+\t      break;\n+\n+\t    case TYPE_STORE:\n+\t    case TYPE_FPSTORE:\n+\t    case TYPE_VECSTORE:\n+\t      /* Don't do the PCREL_OPT load optimization if there is a store\n+\t\t operation.  Perhaps the store might be to the global variable\n+\t\t through a pointer.  */\n+\t      return;\n+\n+\t    case TYPE_LOAD_L:\n+\t    case TYPE_STORE_C:\n+\t    case TYPE_HTM:\n+\t    case TYPE_HTMSIMPLE:\n+\t      /* Don't do the optimization through atomic operations.  */\n+\t      return;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* Check for invalid references of the non-address register that is\n+\t used in the load or store instruction.  */\n+      if (insn_references_regno_p (insn, use_regno, use_insn_type))\n+\treturn;\n+    }\n+\n+  /* Is this a load or a store?  */\n+  switch (use_insn_type)\n+    {\n+    case TYPE_LOAD:\n+    case TYPE_FPLOAD:\n+    case TYPE_VECLOAD:\n+      pcrel_opt_load (addr_insn, use_insn);\n+      break;\n+\n+    case TYPE_STORE:\n+    case TYPE_FPSTORE:\n+    case TYPE_VECSTORE:\n+      pcrel_opt_store (addr_insn, use_insn);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Optimize pcrel external variable references.  */\n+\n+static unsigned int\n+pcrel_opt_pass (function *fun)\n+{\n+  basic_block bb;\n+  rtx_insn *insn, *curr_insn = 0;\n+\n+  memset (&counters, 0, sizeof (counters));\n+\n+  /* Dataflow analysis for use-def chains.  However we have to specify both UD\n+   and DU as otherwise when we make changes to insns for the PCREL_OPT there\n+   will be dangling references.  */\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n+  df_chain_add_problem (DF_DU_CHAIN + DF_UD_CHAIN);\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n+  /* Set the defer flag as our pattern of operation will be to modify two insns,\n+     then call df_analyze ().  */\n+  df_set_flags (DF_DEFER_INSN_RESCAN | DF_LR_RUN_DCE);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n+\n+  /* Look at each basic block to see if there is a load of an external\n+     variable's external address, and a single load/store using that external\n+     address.  */\n+  FOR_ALL_BB_FN (bb, fun)\n+    {\n+      FOR_BB_INSNS_SAFE (bb, insn, curr_insn)\n+\t{\n+\t  if (NONJUMP_INSN_P (insn)\n+\t      && single_set (insn)\n+\t      && get_attr_loads_external_address (insn)\n+\t      == LOADS_EXTERNAL_ADDRESS_YES)\n+\t    pcrel_opt_address (insn);\n+\t}\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"\\n# of loads of an address of an external symbol = %lu\\n\",\n+\t       counters.extern_addrs);\n+\n+      fprintf (dump_file, \"# of PCREL_OPT loads = %lu (adjacent %lu)\\n\",\n+\t       counters.loads, counters.adjacent_loads);\n+\n+      if (counters.failed_loads)\n+\tfprintf (dump_file, \"# of failed PCREL_OPT loads = %lu\\n\",\n+\t\t counters.failed_loads);\n+\n+      fprintf (dump_file, \"# of PCREL_OPT stores = %lu (adjacent %lu)\\n\",\n+\t       counters.stores, counters.adjacent_stores);\n+\n+      if (counters.failed_stores)\n+\tfprintf (dump_file, \"# of failed PCREL_OPT stores = %lu\\n\",\n+\t\t counters.failed_stores);\n+\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  df_remove_problem (df_chain);\n+  df_process_deferred_rescans ();\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS | DF_LR_RUN_DCE);\n+  df_analyze ();\n+  return 0;\n+}\n+\f\n+/* Optimize pc-relative references for the new PCREL_OPT pass.  */\n+const pass_data pass_data_pcrel_opt =\n+{\n+  RTL_PASS,\t\t\t/* type.  */\n+  \"pcrel_opt\",\t\t\t/* name.  */\n+  OPTGROUP_NONE,\t\t/* optinfo_flags.  */\n+  TV_NONE,\t\t\t/* tv_id.  */\n+  0,\t\t\t\t/* properties_required.  */\n+  0,\t\t\t\t/* properties_provided.  */\n+  0,\t\t\t\t/* properties_destroyed.  */\n+  0,\t\t\t\t/* todo_flags_start.  */\n+  TODO_df_finish,\t\t/* todo_flags_finish.  */\n+};\n+\n+/* Pass data structures.  */\n+class pcrel_opt : public rtl_opt_pass\n+{\n+public:\n+  pcrel_opt (gcc::context *ctxt)\n+  : rtl_opt_pass (pass_data_pcrel_opt, ctxt)\n+  {}\n+\n+  ~pcrel_opt (void)\n+  {}\n+\n+  /* opt_pass methods:  */\n+  virtual bool gate (function *)\n+  {\n+    return (TARGET_PCREL && TARGET_PCREL_OPT && optimize);\n+  }\n+\n+  virtual unsigned int execute (function *fun)\n+  {\n+    return pcrel_opt_pass (fun);\n+  }\n+\n+  opt_pass *clone ()\n+  {\n+    return new pcrel_opt (m_ctxt);\n+  }\n+};\n+\n+rtl_opt_pass *\n+make_pass_pcrel_opt (gcc::context *ctxt)\n+{\n+  return new pcrel_opt (ctxt);\n+}"}, {"sha": "203660b0a789713c9d0e9a5e7e91bc2a06263627", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -193,10 +193,13 @@ extern enum insn_form address_to_insn_form (rtx, machine_mode,\n \t\t\t\t\t    enum non_prefixed_form);\n extern bool address_is_non_pfx_d_or_x (rtx addr, machine_mode mode,\n \t\t\t\t       enum non_prefixed_form non_prefix_format);\n+extern bool pcrel_opt_valid_mem_p (rtx, machine_mode, rtx);\n+enum non_prefixed_form reg_to_non_prefixed (rtx reg, machine_mode mode);\n extern bool prefixed_load_p (rtx_insn *);\n extern bool prefixed_store_p (rtx_insn *);\n extern bool prefixed_paddi_p (rtx_insn *);\n extern void rs6000_asm_output_opcode (FILE *);\n+extern void output_pcrel_opt_reloc (rtx);\n extern void rs6000_final_prescan_insn (rtx_insn *, rtx [], int);\n extern int rs6000_adjust_insn_length (rtx_insn *, int);\n \n@@ -309,6 +312,7 @@ namespace gcc { class context; }\n class rtl_opt_pass;\n \n extern rtl_opt_pass *make_pass_analyze_swaps (gcc::context *);\n+extern rtl_opt_pass *make_pass_pcrel_opt (gcc::context *);\n extern bool rs6000_sum_of_two_registers_p (const_rtx expr);\n extern bool rs6000_quadword_masked_address_p (const_rtx exp);\n extern rtx rs6000_gen_lvx (enum machine_mode, rtx, rtx);"}, {"sha": "71a54ed6f730d521386f623d2efec677b40e6bfa", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 106, "deletions": 5, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -1173,7 +1173,6 @@ static bool rs6000_secondary_reload_move (enum rs6000_reg_type,\n \t\t\t\t\t  machine_mode,\n \t\t\t\t\t  secondary_reload_info *,\n \t\t\t\t\t  bool);\n-static enum non_prefixed_form reg_to_non_prefixed (rtx reg, machine_mode mode);\n rtl_opt_pass *make_pass_analyze_swaps (gcc::context*);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n@@ -4452,6 +4451,9 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_MMA;\n     }\n \n+  if (!TARGET_PCREL && TARGET_PCREL_OPT)\n+    rs6000_isa_flags &= ~OPTION_MASK_PCREL_OPT;\n+\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"after subtarget\", rs6000_isa_flags);\n \n@@ -8985,8 +8987,57 @@ rs6000_delegitimize_address (rtx orig_x)\n {\n   rtx x, y, offset;\n \n-  if (GET_CODE (orig_x) == UNSPEC && XINT (orig_x, 1) == UNSPEC_FUSION_GPR)\n-    orig_x = XVECEXP (orig_x, 0, 0);\n+  /* UNSPEC_FUSION_GPR is created by the peephole2 for power8 fusion.  It\n+     encodes loading up the high part of the address of a TOC reference along\n+     with a load of a GPR using the same base register used for the load.  We\n+     return the original SYMBOL_REF.\n+\n+\t(set (reg:INT1 <reg>\n+\t     (unspec:INT1 [<combined-address>] UNSPEC_FUSION_GPR)))\n+\n+     UNSPEC_PCREL_OPT_LD_ADDR is used by the power10 PCREL_OPT pass.  These\n+     UNSPECs include the external SYMBOL_REF along with the value being loaded.\n+     We return the original SYMBOL_REF.\n+\n+\t(parallel [(set (reg:DI <base-reg>)\n+\t\t\t(unspec:DI [(symbol_ref <symbol>)\n+\t\t\t\t    (const_int <marker>)]\n+\t\t\t\t   UNSPEC_PCREL_OPT_LD_ADDR))\n+\t\t   (set (reg:DI <load-reg>)\n+\t\t\t(unspec:DI [(const_int 0)]\n+\t\t\t\t   UNSPEC_PCREL_OPT_LD_DATA))])\n+\n+     UNSPEC_PCREL_OPT_LD_SAME_REG is an alternative that is used if the\n+     GPR being loaded is the same as the GPR used to hold the external address.\n+\n+\t(set (reg:DI <base-reg>)\n+\t     (unspec:DI [(symbol_ref <symbol>)\n+\t\t\t (const_int <marker>)]\n+\t\t\tUNSPEC_PCREL_OPT_LD_SAME_REG))\n+\n+     UNSPEC_PCREL_OPT_ST_ADDR is used by the power10 PCREL_OPT pass.  This\n+     UNSPEC include the external SYMBOL_REF along with the value being loaded.\n+     We return the original SYMBOL_REF.\n+\n+\t(parallel [(set (reg:DI <base-reg>)\n+\t\t\t(unspec:DI [(symbol_ref <symbol>)\n+\t\t\t\t    (const_int <marker>)]\n+\t\t\t\t   UNSPEC_PCREL_OPT_ST_ADDR))\n+\t\t   (use (reg <store-reg>))])  */\n+\n+  if (GET_CODE (orig_x) == UNSPEC)\n+    switch (XINT (orig_x, 1))\n+      {\n+      case UNSPEC_FUSION_GPR:\n+      case UNSPEC_PCREL_OPT_LD_ADDR:\n+      case UNSPEC_PCREL_OPT_LD_SAME_REG:\n+      case UNSPEC_PCREL_OPT_ST_ADDR:\n+\torig_x = XVECEXP (orig_x, 0, 0);\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n \n   orig_x = delegitimize_mem_from_attrs (orig_x);\n \n@@ -23788,6 +23839,7 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"mulhw\",\t\t\tOPTION_MASK_MULHW,\t\tfalse, true  },\n   { \"multiple\",\t\t\tOPTION_MASK_MULTIPLE,\t\tfalse, true  },\n   { \"pcrel\",\t\t\tOPTION_MASK_PCREL,\t\tfalse, true  },\n+  { \"pcrel-opt\",\t\tOPTION_MASK_PCREL_OPT,\t\tfalse, true  },\n   { \"popcntb\",\t\t\tOPTION_MASK_POPCNTB,\t\tfalse, true  },\n   { \"popcntd\",\t\t\tOPTION_MASK_POPCNTD,\t\tfalse, true  },\n   { \"power8-fusion\",\t\tOPTION_MASK_P8_FUSION,\t\tfalse, true  },\n@@ -25932,6 +25984,32 @@ address_is_non_pfx_d_or_x (rtx addr, machine_mode mode,\n   return false;\n }\n \n+/* Return true if an REG with a given MODE is loaded from or stored into a MEM\n+   location uses a non-prefixed D/DS/DQ-form address.  This is used to validate\n+   the load or store with the PCREL_OPT optimization to make sure it is an\n+   instruction that can be optimized.\n+\n+   We need to specify the MODE separately from the REG to allow for loads that\n+   include zero/sign/float extension.  */\n+\n+bool\n+pcrel_opt_valid_mem_p (rtx reg, machine_mode mode, rtx mem)\n+{\n+  /* If the instruction is indexed only like LFIWAX/LXSIWAX we cannot do the\n+     PCREL_OPT optimization.  */\n+  enum non_prefixed_form non_prefixed = reg_to_non_prefixed (reg, mode);\n+  if (non_prefixed == NON_PREFIXED_X)\n+    return false;\n+\n+  /* Check if this is a non-prefixed D/DS/DQ-form instruction.  */\n+  rtx addr = XEXP (mem, 0);\n+  enum insn_form iform = address_to_insn_form (addr, mode, non_prefixed);\n+  return (iform == INSN_FORM_BASE_REG\n+\t  || iform == INSN_FORM_D\n+\t  || iform == INSN_FORM_DS\n+\t  || iform == INSN_FORM_DQ);\n+}\n+\n /* Helper function to see if we're potentially looking at lfs/stfs.\n    - PARALLEL containing a SET and a CLOBBER\n    - stfs:\n@@ -25990,7 +26068,7 @@ is_lfs_stfs_insn (rtx_insn *insn)\n /* Helper function to take a REG and a MODE and turn it into the non-prefixed\n    instruction format (D/DS/DQ) used for offset memory.  */\n \n-static enum non_prefixed_form\n+enum non_prefixed_form\n reg_to_non_prefixed (rtx reg, machine_mode mode)\n {\n   /* If it isn't a register, use the defaults.  */\n@@ -26213,11 +26291,34 @@ void\n rs6000_asm_output_opcode (FILE *stream)\n {\n   if (prepend_p_to_next_insn)\n-    fprintf (stream, \"p\");\n+    {\n+      fprintf (stream, \"p\");\n+\n+      /* Reset the flag in the case where there are separate insn lines in the\n+\t sequence, so the 'p' is only emitted for the first line.  This shows up\n+\t when we are doing the PCREL_OPT optimization, in that the label created\n+\t with %r<n> would have a leading 'p' printed.  */\n+      prepend_p_to_next_insn = false;\n+    }\n \n   return;\n }\n \n+/* Emit the relocation to tie the next instruction to a previous instruction\n+   that loads up an external address.  This is used to do the PCREL_OPT\n+   optimization.  Note, the label is generated after the PLD of the got\n+   pc-relative address to allow for the assembler to insert NOPs before the PLD\n+   instruction.  The operand is a constant integer that is the label\n+   number.  */\n+\n+void\n+output_pcrel_opt_reloc (rtx label_num)\n+{\n+  rtx operands[1] = { label_num };\n+  output_asm_insn (\".reloc .Lpcrel%0-8,R_PPC64_PCREL_OPT,.-(.Lpcrel%0-8)\",\n+\t\t   operands);\n+}\n+\n /* Adjust the length of an INSN.  LENGTH is the currently-computed length and\n    should be adjusted to reflect any required changes.  This macro is used when\n    there is some systematic length adjustment required that would be difficult"}, {"sha": "5ae65fb9f96468e3461c757ed65a2ad0298444c1", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -292,6 +292,10 @@\n \n \t(const_string \"no\")))\n \n+;; Whether an insn loads an external address for the PCREL_OPT optimizaton.\n+(define_attr \"loads_external_address\" \"no,yes\"\n+  (const_string \"no\"))\n+\n ;; Return the number of real hardware instructions in a combined insn.  If it\n ;; is 0, just use the length / 4.\n (define_attr \"num_insns\" \"\" (const_int 0))\n@@ -10261,7 +10265,8 @@\n   \"TARGET_PCREL\"\n   \"ld %0,%a1\"\n   [(set_attr \"prefixed\" \"yes\")\n-   (set_attr \"type\" \"load\")])\n+   (set_attr \"type\" \"load\")\n+   (set_attr \"loads_external_address\" \"yes\")])\n \n ;; TOC register handling.\n \n@@ -14946,3 +14951,4 @@\n (include \"crypto.md\")\n (include \"htm.md\")\n (include \"fusion.md\")\n+(include \"pcrel-opt.md\")"}, {"sha": "0dbdf7536735379ec30c63f6f68ff5e259e832b5", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -609,6 +609,10 @@ mpcrel\n Target Mask(PCREL) Var(rs6000_isa_flags)\n Generate (do not generate) pc-relative memory addressing.\n \n+mpcrel-opt\n+Target Undocumented Mask(PCREL_OPT) Var(rs6000_isa_flags)\n+Generate (do not generate) pc-relative memory optimizations for externals.\n+\n mmma\n Target Mask(MMA) Var(rs6000_isa_flags)\n Generate (do not generate) MMA instructions."}, {"sha": "44f7ffb35fec119618a34b9f7e9e87bd3d4ed817", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -23,6 +23,10 @@ TM_H += $(srcdir)/config/rs6000/rs6000-cpus.def\n TM_H += $(srcdir)/config/rs6000/rs6000-modes.h\n PASSES_EXTRA += $(srcdir)/config/rs6000/rs6000-passes.def\n \n+rs6000-pcrel-opt.o: $(srcdir)/config/rs6000/rs6000-pcrel-opt.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n rs6000-c.o: $(srcdir)/config/rs6000/rs6000-c.c\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n@@ -90,4 +94,5 @@ MD_INCLUDES = $(srcdir)/config/rs6000/rs64.md \\\n \t$(srcdir)/config/rs6000/crypto.md \\\n \t$(srcdir)/config/rs6000/htm.md \\\n \t$(srcdir)/config/rs6000/dfp.md \\\n-\t$(srcdir)/config/rs6000/fusion.md\n+\t$(srcdir)/config/rs6000/fusion.md \\\n+\t$(srcdir)/config/rs6000/pcrel-opt.md"}, {"sha": "c82041c9dc67b4cc024d2d6b9b24e302421efb59", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-inc-di.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-inc-di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-inc-di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-inc-di.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tunsigned int\n+\n+/* Test whether using an external variable twice (doing an increment) prevents\n+   the PCREL_OPT optimization.  */\n+extern TYPE ext;\n+\n+void\n+inc (void)\n+{\n+  ext++;\t\t/* No PCREL_OPT (uses address twice).  */\n+}\n+\n+/* { dg-final { scan-assembler-not \"R_PPC64_PCREL_OPT\" } } */"}, {"sha": "d35862fcb6e05e0aa82a4fe3dd7df9817646e8e7", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-ld-df.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-df.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tdouble\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for\n+   double.  */\n+extern TYPE ext[];\n+\n+TYPE\n+get (void)\n+{\n+  return ext[0];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get2 (void)\n+{\n+  return ext[2];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get_large (void)\n+{\n+  return ext[LARGE];\t\t/* No PCREL_OPT (load is  prefixed).  */\n+}\n+\n+TYPE\n+get_variable (unsigned long n)\n+{\n+  return ext[n];\t\t/* No PCREL_OPT (load is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "7e1ff99f20e8a89517af1a3999185738b541b16e", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-ld-di.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-di.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tlong long\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for long\n+   long.  */\n+extern TYPE ext[];\n+\n+TYPE\n+get (void)\n+{\n+  return ext[0];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get2 (void)\n+{\n+  return ext[2];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get_large (void)\n+{\n+  return ext[LARGE];\t\t/* No PCREL_OPT (load is  prefixed).  */\n+}\n+\n+TYPE\n+get_variable (unsigned long n)\n+{\n+  return ext[n];\t\t/* No PCREL_OPT (load is indexed).  */\n+}\n+\n+double\n+get_double (void)\n+{\n+  return (double) ext[0];\t/* PCREL_OPT relocation.  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  3 } } */"}, {"sha": "4143aeb73718db820d0d49e4d6c71f6c6409d85e", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-ld-hi.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-hi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-hi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-hi.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tunsigned short\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for unsigned\n+   short.  */\n+extern TYPE ext[];\n+\n+TYPE\n+get (void)\n+{\n+  return ext[0];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get2 (void)\n+{\n+  return ext[2];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get_large (void)\n+{\n+  return ext[LARGE];\t\t/* No PCREL_OPT (load is  prefixed).  */\n+}\n+\n+TYPE\n+get_variable (unsigned long n)\n+{\n+  return ext[n];\t\t/* No PCREL_OPT (load is indexed).  */\n+}\n+\n+double\n+get_double (void)\n+{\n+  return (double) ext[0];\t/* No PCREL_OPT (LXSIHZX is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "30d3236f95c4f026dea93cd1b7d046b808b3d2cd", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-ld-qi.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-qi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-qi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-qi.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tunsigned char\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for unsigned\n+   char.  */\n+extern TYPE ext[];\n+\n+TYPE\n+get (void)\n+{\n+  return ext[0];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get2 (void)\n+{\n+  return ext[2];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get_large (void)\n+{\n+  return ext[LARGE];\t\t/* No PCREL_OPT (load is  prefixed).  */\n+}\n+\n+TYPE\n+get_variable (unsigned long n)\n+{\n+  return ext[n];\t\t/* No PCREL_OPT (load is indexed).  */\n+}\n+\n+double\n+get_double (void)\n+{\n+  return (double) ext[0];\t/* No PCREL_OPT (LXSIBZX is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "9d1e2a1956f458bdf7f2bc88537314509e32b67f", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-ld-sf.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-sf.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tfloat\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for\n+   float.  */\n+extern TYPE ext[];\n+\n+TYPE\n+get (void)\n+{\n+  return ext[0];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get2 (void)\n+{\n+  return ext[2];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get_large (void)\n+{\n+  return ext[LARGE];\t\t/* No PCREL_OPT (load is  prefixed).  */\n+}\n+\n+TYPE\n+get_variable (unsigned long n)\n+{\n+  return ext[n];\t\t/* No PCREL_OPT (load is indexed).  */\n+}\n+\n+double\n+get_double (void)\n+{\n+  return (double) ext[0];\t/* PCREL_OPT relocation.  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  3 } } */"}, {"sha": "17be6fa17789506afe5af541dd548dae49d07c52", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-ld-si.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-si.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tint\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for int.  */\n+extern TYPE ext[];\n+\n+TYPE\n+get (void)\n+{\n+  return ext[0];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get2 (void)\n+{\n+  return ext[2];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get_large (void)\n+{\n+  return ext[LARGE];\t\t/* No PCREL_OPT (load is  prefixed).  */\n+}\n+\n+TYPE\n+get_variable (unsigned long n)\n+{\n+  return ext[n];\t\t/* No PCREL_OPT (load is indexed).  */\n+}\n+\n+double\n+get_double (void)\n+{\n+  return (double) ext[0];\t/* No PCREL_OPT (LFIWAX is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "8c12aea5acdc34c0224a889b7f8113246df828ed", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-ld-vector.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-ld-vector.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tvector double\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for\n+   vector double.  */\n+extern TYPE ext[];\n+\n+TYPE\n+get (void)\n+{\n+  return ext[0];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get2 (void)\n+{\n+  return ext[2];\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+TYPE\n+get_large (void)\n+{\n+  return ext[LARGE];\t\t/* No PCREL_OPT (load is  prefixed).  */\n+}\n+\n+TYPE\n+get_variable (unsigned long n)\n+{\n+  return ext[n];\t\t/* No PCREL_OPT (load is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "d795d35d8de8f566cac6a0903e04edd18a709e36", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-st-df.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-df.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tdouble\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for\n+   double.  */\n+extern TYPE ext[];\n+\n+void\n+store (TYPE a)\n+{\n+  ext[0] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store2 (TYPE a)\n+{\n+  ext[2] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store_large (TYPE a)\n+{\n+  ext[LARGE] = a;\t\t/* No PCREL_OPT (store is prefixed).  */\n+}\n+\n+void\n+store_variable (TYPE a, unsigned long n)\n+{\n+  ext[n] = a;\t\t\t/* No PCREL_OPT (store is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "bf57de4b88628736076de09d1d71cf01bcee4534", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-st-di.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-di.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tlong long\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for long\n+   long.  */\n+extern TYPE ext[];\n+\n+void\n+store (TYPE a)\n+{\n+  ext[0] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store2 (TYPE a)\n+{\n+  ext[2] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store_large (TYPE a)\n+{\n+  ext[LARGE] = a;\t\t/* No PCREL_OPT (store is prefixed).  */\n+}\n+\n+void\n+store_variable (TYPE a, unsigned long n)\n+{\n+  ext[n] = a;\t\t\t/* No PCREL_OPT (store is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "8822e767dfe5596e35bf6cf54e5183d3f00c4226", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-st-hi.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-hi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-hi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-hi.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tunsigned short\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for unsigned\n+   short.  */\n+extern TYPE ext[];\n+\n+void\n+store (TYPE a)\n+{\n+  ext[0] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store2 (TYPE a)\n+{\n+  ext[2] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store_large (TYPE a)\n+{\n+  ext[LARGE] = a;\t\t/* No PCREL_OPT (store is prefixed).  */\n+}\n+\n+void\n+store_variable (TYPE a, unsigned long n)\n+{\n+  ext[n] = a;\t\t\t/* No PCREL_OPT (store is indexed).  */\n+}\n+\n+void\n+store_double (double a)\n+{\n+  ext[0] = (TYPE) a;\t\t/* No PCREL_OPT (STXIHZX is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "2f756833717b8da4144abfe40f91e6d4a2505031", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-st-qi.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-qi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-qi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-qi.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tunsigned char\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for unsigned\n+   char.  */\n+extern TYPE ext[];\n+\n+void\n+store (TYPE a)\n+{\n+  ext[0] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store2 (TYPE a)\n+{\n+  ext[2] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store_large (TYPE a)\n+{\n+  ext[LARGE] = a;\t\t/* No PCREL_OPT (store is prefixed).  */\n+}\n+\n+void\n+store_variable (TYPE a, unsigned long n)\n+{\n+  ext[n] = a;\t\t\t/* No PCREL_OPT (store is indexed).  */\n+}\n+\n+void\n+store_double (double a)\n+{\n+  ext[0] = (TYPE) a;\t\t/* No PCREL_OPT (STXIBZX is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "3dd88aad8568afbe7a08c671e138bdd65a7dc611", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-st-sf.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-sf.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tfloat\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for\n+   float.  */\n+extern TYPE ext[];\n+\n+void\n+store (TYPE a)\n+{\n+  ext[0] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store2 (TYPE a)\n+{\n+  ext[2] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store_large (TYPE a)\n+{\n+  ext[LARGE] = a;\t\t/* No PCREL_OPT (store is prefixed).  */\n+}\n+\n+void\n+store_variable (TYPE a, unsigned long n)\n+{\n+  ext[n] = a;\t\t\t/* No PCREL_OPT (store is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "78dc8120efebac175a6647f515309eb7fc4bb899", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-st-si.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-si.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tint\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for int.  */\n+extern TYPE ext[];\n+\n+void\n+store (TYPE a)\n+{\n+  ext[0] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store2 (TYPE a)\n+{\n+  ext[2] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store_large (TYPE a)\n+{\n+  ext[LARGE] = a;\t\t/* No PCREL_OPT (store is prefixed).  */\n+}\n+\n+void\n+store_variable (TYPE a, unsigned long n)\n+{\n+  ext[n] = a;\t\t\t/* No PCREL_OPT (store is indexed).  */\n+}\n+\n+void\n+store_double (double a)\n+{\n+  ext[0] = (TYPE) a;\t\t/* No PCREL_OPT (STFIWX is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}, {"sha": "2c602eb3103f81651117e08e1ad127b575e7cf09", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-opt-st-vector.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8d85f569a6dd44cb9561c95e5f628bd6cd531a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-opt-st-vector.c?ref=b8d85f569a6dd44cb9561c95e5f628bd6cd531a5", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_pcrel } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power10\" } */\n+\n+#define TYPE\tvector double\n+#define LARGE\t0x20000\n+\n+/* Test whether we get the right number of PCREL_OPT optimizations for\n+   vector double.  */\n+extern TYPE ext[];\n+\n+void\n+store (TYPE a)\n+{\n+  ext[0] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store2 (TYPE a)\n+{\n+  ext[2] = a;\t\t\t/* PCREL_OPT relocation.  */\n+}\n+\n+void\n+store_large (TYPE a)\n+{\n+  ext[LARGE] = a;\t\t/* No PCREL_OPT (store is prefixed).  */\n+}\n+\n+void\n+store_variable (TYPE a, unsigned long n)\n+{\n+  ext[n] = a;\t\t\t/* No PCREL_OPT (store is indexed).  */\n+}\n+\n+/* { dg-final { scan-assembler-times \"R_PPC64_PCREL_OPT\"  2 } } */"}]}