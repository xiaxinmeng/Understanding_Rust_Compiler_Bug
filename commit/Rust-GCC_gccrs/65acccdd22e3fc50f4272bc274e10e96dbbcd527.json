{"sha": "65acccdd22e3fc50f4272bc274e10e96dbbcd527", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVhY2NjZGQyMmUzZmM1MGY0MjcyYmMyNzRlMTBlOTZkYmJjZDUyNw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-02-23T20:55:21Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-02-23T20:55:21Z"}, "message": "emit-rtl.c (immed_double_const): Cleanup.\n\n\t* emit-rtl.c (immed_double_const): Cleanup.\n\nFrom-SVN: r111396", "tree": {"sha": "4644db9aaf9652a8ad6c838fd26cc5277918467b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4644db9aaf9652a8ad6c838fd26cc5277918467b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65acccdd22e3fc50f4272bc274e10e96dbbcd527", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65acccdd22e3fc50f4272bc274e10e96dbbcd527", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65acccdd22e3fc50f4272bc274e10e96dbbcd527", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65acccdd22e3fc50f4272bc274e10e96dbbcd527/comments", "author": null, "committer": null, "parents": [{"sha": "cbb5e20166ec05d529f819e12e0727ca6ff1749a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb5e20166ec05d529f819e12e0727ca6ff1749a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb5e20166ec05d529f819e12e0727ca6ff1749a"}], "stats": {"total": 68, "additions": 18, "deletions": 50}, "files": [{"sha": "9b05db88771b9650eec6b65934bc101d448fd984", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65acccdd22e3fc50f4272bc274e10e96dbbcd527/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65acccdd22e3fc50f4272bc274e10e96dbbcd527/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65acccdd22e3fc50f4272bc274e10e96dbbcd527", "patch": "@@ -1,3 +1,7 @@\n+2006-02-23  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* emit-rtl.c (immed_double_const): Cleanup.\n+\n 2006-02-23  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \tFix PR tree-optimization/26376"}, {"sha": "7dfdd3a0163cef7f9bd93ae66ebb2697139f3b6f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65acccdd22e3fc50f4272bc274e10e96dbbcd527/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65acccdd22e3fc50f4272bc274e10e96dbbcd527/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=65acccdd22e3fc50f4272bc274e10e96dbbcd527", "patch": "@@ -444,64 +444,28 @@ immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, enum machine_mode mode)\n   rtx value;\n   unsigned int i;\n \n+  /* There are the following cases (note that there are no modes with\n+     HOST_BITS_PER_WIDE_INT < GET_MODE_BITSIZE (mode) < 2 * HOST_BITS_PER_WIDE_INT):\n+\n+     1) If GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT, then we use\n+\tgen_int_mode.\n+     2) GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT, but the value of\n+\tthe integer fits into HOST_WIDE_INT anyway (i.e., i1 consists only\n+\tfrom copies of the sign bit, and sign of i0 and i1 are the same),  then \n+\twe return a CONST_INT for i0.\n+     3) Otherwise, we create a CONST_DOUBLE for i0 and i1.  */\n   if (mode != VOIDmode)\n     {\n-      int width;\n-      \n       gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n \t\t  || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT\n \t\t  /* We can get a 0 for an error mark.  */\n \t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n \t\t  || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT);\n \n-      /* We clear out all bits that don't belong in MODE, unless they and\n-\t our sign bit are all one.  So we get either a reasonable negative\n-\t value or a reasonable unsigned value for this mode.  */\n-      width = GET_MODE_BITSIZE (mode);\n-      if (width < HOST_BITS_PER_WIDE_INT\n-\t  && ((i0 & ((HOST_WIDE_INT) (-1) << (width - 1)))\n-\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n-\ti0 &= ((HOST_WIDE_INT) 1 << width) - 1, i1 = 0;\n-      else if (width == HOST_BITS_PER_WIDE_INT\n-\t       && ! (i1 == ~0 && i0 < 0))\n-\ti1 = 0;\n-      else\n-\t/* We should be able to represent this value as a constant.  */\n-\tgcc_assert (width <= 2 * HOST_BITS_PER_WIDE_INT);\n-\n-      /* If this would be an entire word for the target, but is not for\n-\t the host, then sign-extend on the host so that the number will\n-\t look the same way on the host that it would on the target.\n-\n-\t For example, when building a 64 bit alpha hosted 32 bit sparc\n-\t targeted compiler, then we want the 32 bit unsigned value -1 to be\n-\t represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-\t The latter confuses the sparc backend.  */\n-\n-      if (width < HOST_BITS_PER_WIDE_INT\n-\t  && (i0 & ((HOST_WIDE_INT) 1 << (width - 1))))\n-\ti0 |= ((HOST_WIDE_INT) (-1) << width);\n-\n-      /* If MODE fits within HOST_BITS_PER_WIDE_INT, always use a\n-\t CONST_INT.\n-\n-\t ??? Strictly speaking, this is wrong if we create a CONST_INT for\n-\t a large unsigned constant with the size of MODE being\n-\t HOST_BITS_PER_WIDE_INT and later try to interpret that constant\n-\t in a wider mode.  In that case we will mis-interpret it as a\n-\t negative number.\n-\n-\t Unfortunately, the only alternative is to make a CONST_DOUBLE for\n-\t any constant in any mode if it is an unsigned constant larger\n-\t than the maximum signed integer in an int on the host.  However,\n-\t doing this will break everyone that always expects to see a\n-\t CONST_INT for SImode and smaller.\n-\n-\t We have always been making CONST_INTs in this case, so nothing\n-\t new is being broken.  */\n-\n-      if (width <= HOST_BITS_PER_WIDE_INT)\n-\ti1 = (i0 < 0) ? ~(HOST_WIDE_INT) 0 : 0;\n+      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\treturn gen_int_mode (i0, mode);\n+\n+      gcc_assert (GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT);\n     }\n \n   /* If this integer fits in one word, return a CONST_INT.  */"}]}