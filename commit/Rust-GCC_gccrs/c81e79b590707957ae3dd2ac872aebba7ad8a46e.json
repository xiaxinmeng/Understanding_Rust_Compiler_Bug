{"sha": "c81e79b590707957ae3dd2ac872aebba7ad8a46e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgxZTc5YjU5MDcwNzk1N2FlM2RkMmFjODcyYWViYmE3YWQ4YTQ2ZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-05-06T18:39:08Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-05-06T18:39:08Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-05-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * trans-array.c (gfc_walk_variable_expr): Continue walking\n        for scalar coarrays.\n        * trans-intrinsic.c (convert_element_to_coarray_ref): New\n        * function.\n        (trans_this_image, trans_image_index, conv_intrinsic_cobound): Use it.\n        (trans_this_image): Fix algorithm.\n        * trans-types.c (gfc_get_element_type,\n        * gfc_get_array_descriptor_base,\n        gfc_sym_type): Handle scalar coarrays.\n\n2011-05-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray/this_image_2.f90: New.\n\nFrom-SVN: r173506", "tree": {"sha": "20a46afa6ab4803eb0299a3388a1c8a1bad7d820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20a46afa6ab4803eb0299a3388a1c8a1bad7d820"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c81e79b590707957ae3dd2ac872aebba7ad8a46e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81e79b590707957ae3dd2ac872aebba7ad8a46e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c81e79b590707957ae3dd2ac872aebba7ad8a46e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81e79b590707957ae3dd2ac872aebba7ad8a46e/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc9ae24cbea172e0810524ec506339b918e944ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9ae24cbea172e0810524ec506339b918e944ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9ae24cbea172e0810524ec506339b918e944ae"}], "stats": {"total": 190, "additions": 179, "deletions": 11}, "files": [{"sha": "e80bfd34a8fe4ffbf92f0b5eb279f2d01f943f84", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c81e79b590707957ae3dd2ac872aebba7ad8a46e", "patch": "@@ -1,3 +1,14 @@\n+2011-05-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* trans-array.c (gfc_walk_variable_expr): Continue walking\n+\tfor scalar coarrays.\n+\t* trans-intrinsic.c (convert_element_to_coarray_ref): New function.\n+\t(trans_this_image, trans_image_index, conv_intrinsic_cobound): Use it.\n+\t(trans_this_image): Fix algorithm.\n+\t* trans-types.c (gfc_get_element_type, gfc_get_array_descriptor_base,\n+\tgfc_sym_type): Handle scalar coarrays.\n+\n 2011-05-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/48858"}, {"sha": "1a4ab3912e5bafb64c84bbb8a72d55553fd9d7e9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c81e79b590707957ae3dd2ac872aebba7ad8a46e", "patch": "@@ -7443,7 +7443,7 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \n       ar = &ref->u.ar;\n \n-      if (ar->as->rank == 0)\n+      if (ar->as->rank == 0 && ref->next != NULL)\n \t{\n \t  /* Scalar coarray.  */\n \t  continue;"}, {"sha": "345b45082f9c4899bfcd85598d379ce0696231bb", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c81e79b590707957ae3dd2ac872aebba7ad8a46e", "patch": "@@ -921,6 +921,24 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n }\n \n \n+/* Convert the last ref of a scalar coarray from an AR_ELEMENT to an\n+   AR_FULL, suitable for the scalarizer.  */\n+\n+static void\n+convert_element_to_coarray_ref (gfc_expr *expr)\n+{\n+  gfc_ref *ref;\n+\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->next == NULL\n+\t&& ref->u.ar.codimen)\n+      {\n+\tref->u.ar.type = AR_FULL;\n+\tbreak;\n+      }\n+}\n+\n+\n static void\n trans_this_image (gfc_se * se, gfc_expr *expr)\n {\n@@ -951,6 +969,8 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \n   /* Obtain the descriptor of the COARRAY.  */\n   gfc_init_se (&argse, NULL);\n+  if (expr->value.function.actual->expr->rank == 0)\n+    convert_element_to_coarray_ref (expr->value.function.actual->expr);\n   ss = gfc_walk_expr (expr->value.function.actual->expr);\n   gcc_assert (ss != gfc_ss_terminator);\n   ss->data.info.codimen = corank;\n@@ -970,7 +990,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n       dim_arg = se->loop->loopvar[0];\n       dim_arg = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t gfc_array_index_type, dim_arg,\n-\t\t\t\t gfc_rank_cst[rank]);\n+\t\t\t\t build_int_cst (TREE_TYPE (dim_arg), 1));\n       gfc_advance_se_ss_chain (se);\n     }\n   else\n@@ -1016,7 +1036,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \n      m = this_images() - 1\n      i = rank\n-     min_var = min (corank - 2, dim_arg)\n+     min_var = min (rank + corank - 2, rank + dim_arg - 1)\n      for (;;)\n        {\n \t extent = gfc_extent(i)\n@@ -1042,10 +1062,13 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \t\t       build_int_cst (type, 1));\n   gfc_add_modify (&se->pre, m, tmp);\n \n-  /* min_var = min (rank+corank-2, dim_arg).  */\n+  /* min_var = min (rank + corank-2, rank + dim_arg - 1).  */\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t fold_convert (integer_type_node, dim_arg),\n+\t\t\t build_int_cst (integer_type_node, rank - 1));\n   tmp = fold_build2_loc (input_location, MIN_EXPR, integer_type_node,\n \t\t\t build_int_cst (integer_type_node, rank + corank - 2),\n-\t\t\t fold_convert (integer_type_node, dim_arg));\n+\t\t\t tmp);\n   gfc_add_modify (&se->pre, min_var, tmp);\n \n   /* i = rank.  */\n@@ -1102,9 +1125,9 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \t\t\t  build_int_cst (TREE_TYPE (dim_arg), corank));\n \n   lbound = gfc_conv_descriptor_lbound_get (desc,\n-\t\t\tfold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t gfc_array_index_type, dim_arg,\n-\t\t\t\t\t gfc_rank_cst[rank - 1]));\n+\t\tfold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, dim_arg,\n+\t\t\t\t build_int_cst (TREE_TYPE (dim_arg), rank-1)));\n   lbound = fold_convert (type, lbound);\n \n   tmp = fold_build2_loc (input_location, MINUS_EXPR, type, ml,\n@@ -1133,6 +1156,8 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n \n   /* Obtain the descriptor of the COARRAY.  */\n   gfc_init_se (&argse, NULL);\n+  if (expr->value.function.actual->expr->rank == 0)\n+    convert_element_to_coarray_ref (expr->value.function.actual->expr);\n   ss = gfc_walk_expr (expr->value.function.actual->expr);\n   gcc_assert (ss != gfc_ss_terminator);\n   ss->data.info.codimen = corank;\n@@ -1457,6 +1482,8 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n   gcc_assert (arg->expr->expr_type == EXPR_VARIABLE);\n   corank = gfc_get_corank (arg->expr);\n \n+  if (expr->value.function.actual->expr->rank == 0)\n+    convert_element_to_coarray_ref (expr->value.function.actual->expr);\n   ss = gfc_walk_expr (arg->expr);\n   gcc_assert (ss != gfc_ss_terminator);\n   ss->data.info.codimen = corank;"}, {"sha": "22a2c5b760fa0d9b56afd086b825c8bddda18c13", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c81e79b590707957ae3dd2ac872aebba7ad8a46e", "patch": "@@ -1205,7 +1205,7 @@ gfc_get_element_type (tree type)\n int\n gfc_is_nodesc_array (gfc_symbol * sym)\n {\n-  gcc_assert (sym->attr.dimension);\n+  gcc_assert (sym->attr.dimension || sym->attr.codimension);\n \n   /* We only want local arrays.  */\n   if (sym->attr.pointer || sym->attr.allocatable)\n@@ -1598,7 +1598,7 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n   char name[16 + 2*GFC_RANK_DIGITS + 1 + 1];\n   int idx = 2 * (codimen + dimen - 1) + restricted;\n \n-  gcc_assert (dimen >= 1 && codimen + dimen <= GFC_MAX_DIMENSIONS);\n+  gcc_assert (codimen + dimen >= 1 && codimen + dimen <= GFC_MAX_DIMENSIONS);\n   if (gfc_array_descriptor_base[idx])\n     return gfc_array_descriptor_base[idx];\n \n@@ -1996,7 +1996,7 @@ gfc_sym_type (gfc_symbol * sym)\n   if (!restricted)\n     type = gfc_nonrestricted_type (type);\n \n-  if (sym->attr.dimension)\n+  if (sym->attr.dimension || sym->attr.codimension)\n     {\n       if (gfc_is_nodesc_array (sym))\n         {"}, {"sha": "fc2d5b106f7845fa98ffcbd409938023ed43a157", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c81e79b590707957ae3dd2ac872aebba7ad8a46e", "patch": "@@ -1,3 +1,8 @@\n+2011-05-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray/this_image_2.f90: New.\n+\n 2011-05-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/48858"}, {"sha": "d5a5eef8de1ee66d50eca3177b6348a26458f20a", "filename": "gcc/testsuite/gfortran.dg/coarray/this_image_2.f90", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fthis_image_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81e79b590707957ae3dd2ac872aebba7ad8a46e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fthis_image_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fthis_image_2.f90?ref=c81e79b590707957ae3dd2ac872aebba7ad8a46e", "patch": "@@ -0,0 +1,125 @@\n+! { dg-do run }\n+!\n+! PR fortran/18918\n+!\n+! Version for scalar coarrays\n+!\n+! this_image(coarray) run test,\n+! expecially for num_images > 1\n+!\n+! Tested are values up to num_images == 8,\n+! higher values are OK, but not tested for\n+!\n+implicit none\n+integer :: a[2:2, 3:4, 7:*]\n+integer :: i\n+\n+if (this_image(A, dim=1) /= 2) call abort()\n+i = 1\n+if (this_image(A, dim=i) /= 2) call abort()\n+\n+select case (this_image())\n+  case (1)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 7) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 7) call abort()\n+    if (any (this_image(A) /= [2,3,7])) call abort()\n+\n+  case (2)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 7) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 7) call abort()\n+    if (any (this_image(A) /= [2,4,7])) call abort()\n+\n+  case (3)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 8) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 8) call abort()\n+    if (any (this_image(A) /= [2,3,8])) call abort()\n+\n+  case (4)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 8) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 8) call abort()\n+    if (any (this_image(A) /= [2,4,8])) call abort()\n+\n+  case (5)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 9) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 9) call abort()\n+    if (any (this_image(A) /= [2,3,9])) call abort()\n+\n+  case (6)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 9) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 9) call abort()\n+    if (any (this_image(A) /= [2,4,9])) call abort()\n+\n+  case (7)\n+    if (this_image(A, dim=2) /= 3) call abort()\n+    if (this_image(A, dim=3) /= 10) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 3) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 10) call abort()\n+    if (any (this_image(A) /= [2,3,10])) call abort()\n+\n+  case (8)\n+    if (this_image(A, dim=2) /= 4) call abort()\n+    if (this_image(A, dim=3) /= 10) call abort()\n+    i = 2\n+    if (this_image(A, dim=i) /= 4) call abort()\n+    i = 3\n+    if (this_image(A, dim=i) /= 10) call abort()\n+    if (any (this_image(A) /= [2,4,10])) call abort()\n+end select\n+\n+contains\n+\n+subroutine test_image_index\n+implicit none\n+integer :: index1, index2, index3\n+logical :: one\n+\n+integer, save :: d(2)[-1:3, *]\n+integer, save :: e(2)[-1:-1, 3:*]\n+\n+one = num_images() == 1\n+\n+index1 = image_index(d, [-1, 1] )\n+index2 = image_index(d, [0, 1] )\n+\n+if (one .and. (index1 /= 1 .or. index2 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 1 .or. index2 /= 2)) &\n+  call abort()\n+\n+index1 = image_index(e, [-1, 3] )\n+index2 = image_index(e, [-1, 4] )\n+\n+if (one .and. (index1 /= 1 .or. index2 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 1 .or. index2 /= 2)) &\n+  call abort()\n+\n+end subroutine test_image_index\n+\n+end"}]}