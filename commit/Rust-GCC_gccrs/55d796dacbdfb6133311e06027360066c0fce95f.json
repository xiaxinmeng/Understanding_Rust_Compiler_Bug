{"sha": "55d796dacbdfb6133311e06027360066c0fce95f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVkNzk2ZGFjYmRmYjYxMzMzMTFlMDYwMjczNjAwNjZjMGZjZTk1Zg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-16T17:52:19Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-16T17:52:19Z"}, "message": "recog.c (validate_change_1, [...]): Avoid C++ keywords.\n\n\t* recog.c (validate_change_1, validate_change,\n\tvalidate_unshare_change, validate_replace_rtx_1, struct\n\tfunny_match, constrain_operands, peephole2_optimize): Avoid C++\n\tkeywords.\n\t* reload.c (push_secondary_reload, secondary_reload_class,\n\tscratch_reload_class, find_valid_class, find_reusable_reload,\n\tpush_reload, find_dummy_reload, find_reloads_address_1,\n\tfind_reloads_address_part, find_equiv_reg): Likewise.\n\t* reload1.c (spill_failure, eliminate_regs_1, allocate_reload_reg,\n\tchoose_reload_regs): Likewise.\n\t* rtlanal.c (replace_rtx, nonzero_bits1, num_sign_bit_copies1):\n\tLikewise.\n\t* rtlhooks.c (gen_lowpart_if_possible): Likewise.\n\t* sched-ebb.c (add_deps_for_risky_insns): Likewise.\n\t* sched-rgn.c (concat_INSN_LIST): Likewise.\n\t* stor-layout.c (mode_for_size, mode_for_size_tree,\n\tsmallest_mode_for_size): Likewise.\n\nFrom-SVN: r137894", "tree": {"sha": "6ea7145a64bd6e7855ef17deb8174471e33ab630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ea7145a64bd6e7855ef17deb8174471e33ab630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55d796dacbdfb6133311e06027360066c0fce95f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d796dacbdfb6133311e06027360066c0fce95f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d796dacbdfb6133311e06027360066c0fce95f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d796dacbdfb6133311e06027360066c0fce95f/comments", "author": null, "committer": null, "parents": [{"sha": "d858f359363662cf2555f4d9c259d80aaecae031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d858f359363662cf2555f4d9c259d80aaecae031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d858f359363662cf2555f4d9c259d80aaecae031"}], "stats": {"total": 408, "additions": 214, "deletions": 194}, "files": [{"sha": "43e62ff705753f215da18d4ea5ed904dcb57a221", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -1,3 +1,23 @@\n+2008-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* recog.c (validate_change_1, validate_change,\n+\tvalidate_unshare_change, validate_replace_rtx_1, struct\n+\tfunny_match, constrain_operands, peephole2_optimize): Avoid C++\n+\tkeywords.\n+\t* reload.c (push_secondary_reload, secondary_reload_class,\n+\tscratch_reload_class, find_valid_class, find_reusable_reload,\n+\tpush_reload, find_dummy_reload, find_reloads_address_1,\n+\tfind_reloads_address_part, find_equiv_reg): Likewise.\n+\t* reload1.c (spill_failure, eliminate_regs_1, allocate_reload_reg,\n+\tchoose_reload_regs): Likewise.\n+\t* rtlanal.c (replace_rtx, nonzero_bits1, num_sign_bit_copies1):\n+\tLikewise.\n+\t* rtlhooks.c (gen_lowpart_if_possible): Likewise.\n+\t* sched-ebb.c (add_deps_for_risky_insns): Likewise.\n+\t* sched-rgn.c (concat_INSN_LIST): Likewise.\n+\t* stor-layout.c (mode_for_size, mode_for_size_tree,\n+\tsmallest_mode_for_size): Likewise.\n+\n 2008-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cfg.c (dump_reg_info): Avoid C++ keywords."}, {"sha": "599d529231aabc5db3d2ff73a3c679d3b63172de", "filename": "gcc/recog.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -183,7 +183,7 @@ static int changes_allocated;\n static int num_changes = 0;\n \n /* Validate a proposed change to OBJECT.  LOC is the location in the rtl\n-   at which NEW will be placed.  If OBJECT is zero, no validation is done,\n+   at which NEW_RTX will be placed.  If OBJECT is zero, no validation is done,\n    the change is simply made.\n \n    Two types of objects are supported:  If OBJECT is a MEM, memory_address_p\n@@ -201,16 +201,16 @@ static int num_changes = 0;\n    Otherwise, perform the change and return 1.  */\n \n static bool\n-validate_change_1 (rtx object, rtx *loc, rtx new, bool in_group, bool unshare)\n+validate_change_1 (rtx object, rtx *loc, rtx new_rtx, bool in_group, bool unshare)\n {\n   rtx old = *loc;\n \n-  if (old == new || rtx_equal_p (old, new))\n+  if (old == new_rtx || rtx_equal_p (old, new_rtx))\n     return 1;\n \n   gcc_assert (in_group != 0 || num_changes == 0);\n \n-  *loc = new;\n+  *loc = new_rtx;\n \n   /* Save the information describing this change.  */\n   if (num_changes >= changes_allocated)\n@@ -253,18 +253,18 @@ validate_change_1 (rtx object, rtx *loc, rtx new, bool in_group, bool unshare)\n    UNSHARE to false.  */\n \n bool\n-validate_change (rtx object, rtx *loc, rtx new, bool in_group)\n+validate_change (rtx object, rtx *loc, rtx new_rtx, bool in_group)\n {\n-  return validate_change_1 (object, loc, new, in_group, false);\n+  return validate_change_1 (object, loc, new_rtx, in_group, false);\n }\n \n /* Wrapper for validate_change_1 without the UNSHARE argument defaulting\n    UNSHARE to true.  */\n \n bool\n-validate_unshare_change (rtx object, rtx *loc, rtx new, bool in_group)\n+validate_unshare_change (rtx object, rtx *loc, rtx new_rtx, bool in_group)\n {\n-  return validate_change_1 (object, loc, new, in_group, true);\n+  return validate_change_1 (object, loc, new_rtx, in_group, true);\n }\n \n \n@@ -525,7 +525,7 @@ validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object)\n   enum rtx_code code;\n   enum machine_mode op0_mode = VOIDmode;\n   int prev_changes = num_changes;\n-  rtx new;\n+  rtx new_rtx;\n \n   if (!x)\n     return;\n@@ -633,25 +633,25 @@ validate_replace_rtx_1 (rtx *loc, rtx from, rtx to, rtx object)\n     case SIGN_EXTEND:\n       if (GET_MODE (XEXP (x, 0)) == VOIDmode)\n \t{\n-\t  new = simplify_gen_unary (code, GET_MODE (x), XEXP (x, 0),\n+\t  new_rtx = simplify_gen_unary (code, GET_MODE (x), XEXP (x, 0),\n \t\t\t\t    op0_mode);\n \t  /* If any of the above failed, substitute in something that\n \t     we know won't be recognized.  */\n-\t  if (!new)\n-\t    new = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n-\t  validate_change (object, loc, new, 1);\n+\t  if (!new_rtx)\n+\t    new_rtx = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n+\t  validate_change (object, loc, new_rtx, 1);\n \t}\n       break;\n     case SUBREG:\n       /* All subregs possible to simplify should be simplified.  */\n-      new = simplify_subreg (GET_MODE (x), SUBREG_REG (x), op0_mode,\n+      new_rtx = simplify_subreg (GET_MODE (x), SUBREG_REG (x), op0_mode,\n \t\t\t     SUBREG_BYTE (x));\n \n       /* Subregs of VOIDmode operands are incorrect.  */\n-      if (!new && GET_MODE (SUBREG_REG (x)) == VOIDmode)\n-\tnew = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n-      if (new)\n-\tvalidate_change (object, loc, new, 1);\n+      if (!new_rtx && GET_MODE (SUBREG_REG (x)) == VOIDmode)\n+\tnew_rtx = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n+      if (new_rtx)\n+\tvalidate_change (object, loc, new_rtx, 1);\n       break;\n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n@@ -2200,7 +2200,7 @@ preprocess_constraints (void)\n \n struct funny_match\n {\n-  int this, other;\n+  int this_op, other;\n };\n \n int\n@@ -2350,7 +2350,7 @@ constrain_operands (int strict)\n \t\t     output op is the one that will be printed.  */\n \t\t  if (val == 2 && strict > 0)\n \t\t    {\n-\t\t      funny_match[funny_match_index].this = opno;\n+\t\t      funny_match[funny_match_index].this_op = opno;\n \t\t      funny_match[funny_match_index++].other = match;\n \t\t    }\n \t\t}\n@@ -2583,7 +2583,7 @@ constrain_operands (int strict)\n \t      while (--funny_match_index >= 0)\n \t\t{\n \t\t  recog_data.operand[funny_match[funny_match_index].other]\n-\t\t    = recog_data.operand[funny_match[funny_match_index].this];\n+\t\t    = recog_data.operand[funny_match[funny_match_index].this_op];\n \t\t}\n \n \t      return 1;\n@@ -2987,7 +2987,7 @@ peephole2_optimize (void)\n \t  prev = PREV_INSN (insn);\n \t  if (INSN_P (insn))\n \t    {\n-\t      rtx try, before_try, x;\n+\t      rtx attempt, before_try, x;\n \t      int match_len;\n \t      rtx note;\n \t      bool was_call = false;\n@@ -3008,13 +3008,13 @@ peephole2_optimize (void)\n \t\t     substitution would lose the\n \t\t     REG_FRAME_RELATED_EXPR that is attached.  */\n \t\t  peep2_current_count = 0;\n-\t\t  try = NULL;\n+\t\t  attempt = NULL;\n \t\t}\n \t      else\n \t\t/* Match the peephole.  */\n-\t\ttry = peephole2_insns (PATTERN (insn), insn, &match_len);\n+\t\tattempt = peephole2_insns (PATTERN (insn), insn, &match_len);\n \n-\t      if (try != NULL)\n+\t      if (attempt != NULL)\n \t\t{\n \t\t  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n \t\t     in SEQ and copy our CALL_INSN_FUNCTION_USAGE and other\n@@ -3032,7 +3032,7 @@ peephole2_optimize (void)\n \t\t\tcontinue;\n \t\t      was_call = true;\n \n-\t\t      new_insn = try;\n+\t\t      new_insn = attempt;\n \t\t      while (new_insn != NULL_RTX)\n \t\t\t{\n \t\t\t  if (CALL_P (new_insn))\n@@ -3080,7 +3080,7 @@ peephole2_optimize (void)\n \t\t\t\t\tREG_EH_REGION, NULL_RTX);\n \n \t\t  /* Replace the old sequence with the new.  */\n-\t\t  try = emit_insn_after_setloc (try, peep2_insn_data[i].insn,\n+\t\t  attempt = emit_insn_after_setloc (attempt, peep2_insn_data[i].insn,\n \t\t\t\t\t        INSN_LOCATOR (peep2_insn_data[i].insn));\n \t\t  before_try = PREV_INSN (insn);\n \t\t  delete_insn_chain (insn, peep2_insn_data[i].insn, false);\n@@ -3095,7 +3095,7 @@ peephole2_optimize (void)\n \t\t\tif (eh_edge->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n \t\t\t  break;\n \n-\t\t      for (x = try ; x != before_try ; x = PREV_INSN (x))\n+\t\t      for (x = attempt ; x != before_try ; x = PREV_INSN (x))\n \t\t\tif (CALL_P (x)\n \t\t\t    || (flag_non_call_exceptions\n \t\t\t\t&& may_trap_p (PATTERN (x))\n@@ -3145,7 +3145,7 @@ peephole2_optimize (void)\n \t\t  bitmap_copy (live, peep2_insn_data[i].live_before);\n \n \t\t  /* Update life information for the new sequence.  */\n-\t\t  x = try;\n+\t\t  x = attempt;\n \t\t  do\n \t\t    {\n \t\t      if (INSN_P (x))\n@@ -3169,7 +3169,7 @@ peephole2_optimize (void)\n \n \t\t  /* If we generated a jump instruction, it won't have\n \t\t     JUMP_LABEL set.  Recompute after we're done.  */\n-\t\t  for (x = try; x != before_try; x = PREV_INSN (x))\n+\t\t  for (x = attempt; x != before_try; x = PREV_INSN (x))\n \t\t    if (JUMP_P (x))\n \t\t      {\n \t\t        do_rebuild_jump_labels = true;"}, {"sha": "7c7d736f14c2b953c7608fa6b2c21eecbf4faef7", "filename": "gcc/reload.c", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -319,7 +319,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t\t       enum machine_mode reload_mode, enum reload_type type,\n \t\t       enum insn_code *picode, secondary_reload_info *prev_sri)\n {\n-  enum reg_class class = NO_REGS;\n+  enum reg_class rclass = NO_REGS;\n   enum reg_class scratch_class;\n   enum machine_mode mode = reload_mode;\n   enum insn_code icode = CODE_FOR_nothing;\n@@ -362,15 +362,15 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n   sri.icode = CODE_FOR_nothing;\n   sri.prev_sri = prev_sri;\n-  class = targetm.secondary_reload (in_p, x, reload_class, reload_mode, &sri);\n+  rclass = targetm.secondary_reload (in_p, x, reload_class, reload_mode, &sri);\n   icode = sri.icode;\n \n   /* If we don't need any secondary registers, done.  */\n-  if (class == NO_REGS && icode == CODE_FOR_nothing)\n+  if (rclass == NO_REGS && icode == CODE_FOR_nothing)\n     return -1;\n \n-  if (class != NO_REGS)\n-    t_reload = push_secondary_reload (in_p, x, opnum, optional, class,\n+  if (rclass != NO_REGS)\n+    t_reload = push_secondary_reload (in_p, x, opnum, optional, rclass,\n \t\t\t\t      reload_mode, type, &t_icode, &sri);\n \n   /* If we will be using an insn, the secondary reload is for a\n@@ -392,7 +392,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t an icode to reload from an intermediate tertiary reload register.\n \t We should probably have a new field in struct reload to tag a\n \t chain of scratch operand reloads onto.   */\n-      gcc_assert (class == NO_REGS);\n+      gcc_assert (rclass == NO_REGS);\n \n       scratch_constraint = insn_data[(int) icode].operand[2].constraint;\n       gcc_assert (*scratch_constraint == '=');\n@@ -404,7 +404,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t\t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) letter,\n \t\t\t\t\t\t   scratch_constraint));\n \n-      class = scratch_class;\n+      rclass = scratch_class;\n       mode = insn_data[(int) icode].operand[2].mode;\n     }\n \n@@ -422,21 +422,21 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n      Allow this when a reload_in/out pattern is being used.  I.e. assume\n      that the generated code handles this case.  */\n \n-  gcc_assert (!in_p || class != reload_class || icode != CODE_FOR_nothing\n+  gcc_assert (!in_p || rclass != reload_class || icode != CODE_FOR_nothing\n \t      || t_icode != CODE_FOR_nothing);\n \n   /* See if we can reuse an existing secondary reload.  */\n   for (s_reload = 0; s_reload < n_reloads; s_reload++)\n     if (rld[s_reload].secondary_p\n-\t&& (reg_class_subset_p (class, rld[s_reload].class)\n-\t    || reg_class_subset_p (rld[s_reload].class, class))\n+\t&& (reg_class_subset_p (rclass, rld[s_reload].class)\n+\t    || reg_class_subset_p (rld[s_reload].class, rclass))\n \t&& ((in_p && rld[s_reload].inmode == mode)\n \t    || (! in_p && rld[s_reload].outmode == mode))\n \t&& ((in_p && rld[s_reload].secondary_in_reload == t_reload)\n \t    || (! in_p && rld[s_reload].secondary_out_reload == t_reload))\n \t&& ((in_p && rld[s_reload].secondary_in_icode == t_icode)\n \t    || (! in_p && rld[s_reload].secondary_out_icode == t_icode))\n-\t&& (SMALL_REGISTER_CLASS_P (class) || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (rclass) || SMALL_REGISTER_CLASSES)\n \t&& MERGABLE_RELOADS (secondary_type, rld[s_reload].when_needed,\n \t\t\t     opnum, rld[s_reload].opnum))\n       {\n@@ -445,8 +445,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \tif (! in_p)\n \t  rld[s_reload].outmode = mode;\n \n-\tif (reg_class_subset_p (class, rld[s_reload].class))\n-\t  rld[s_reload].class = class;\n+\tif (reg_class_subset_p (rclass, rld[s_reload].class))\n+\t  rld[s_reload].class = rclass;\n \n \trld[s_reload].opnum = MIN (rld[s_reload].opnum, opnum);\n \trld[s_reload].optional &= optional;\n@@ -467,7 +467,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t way reloads are output.  */\n \n       if (in_p && icode == CODE_FOR_nothing\n-\t  && SECONDARY_MEMORY_NEEDED (class, reload_class, mode))\n+\t  && SECONDARY_MEMORY_NEEDED (rclass, reload_class, mode))\n \t{\n \t  get_secondary_mem (x, reload_mode, opnum, type);\n \n@@ -479,7 +479,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n       /* We need to make a new secondary reload for this register class.  */\n       rld[s_reload].in = rld[s_reload].out = 0;\n-      rld[s_reload].class = class;\n+      rld[s_reload].class = rclass;\n \n       rld[s_reload].inmode = in_p ? mode : VOIDmode;\n       rld[s_reload].outmode = ! in_p ? mode : VOIDmode;\n@@ -503,7 +503,7 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \n #ifdef SECONDARY_MEMORY_NEEDED\n       if (! in_p && icode == CODE_FOR_nothing\n-\t  && SECONDARY_MEMORY_NEEDED (reload_class, class, mode))\n+\t  && SECONDARY_MEMORY_NEEDED (reload_class, rclass, mode))\n \tget_secondary_mem (x, mode, opnum, type);\n #endif\n     }\n@@ -516,21 +516,21 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n    register and a scratch register is needed, we return the class of the\n    intermediate register.  */\n enum reg_class\n-secondary_reload_class (bool in_p, enum reg_class class,\n+secondary_reload_class (bool in_p, enum reg_class rclass,\n \t\t\tenum machine_mode mode, rtx x)\n {\n   enum insn_code icode;\n   secondary_reload_info sri;\n \n   sri.icode = CODE_FOR_nothing;\n   sri.prev_sri = NULL;\n-  class = targetm.secondary_reload (in_p, x, class, mode, &sri);\n+  rclass = targetm.secondary_reload (in_p, x, rclass, mode, &sri);\n   icode = sri.icode;\n \n   /* If there are no secondary reloads at all, we return NO_REGS.\n      If an intermediate register is needed, we return its class.  */\n-  if (icode == CODE_FOR_nothing || class != NO_REGS)\n-    return class;\n+  if (icode == CODE_FOR_nothing || rclass != NO_REGS)\n+    return rclass;\n \n   /* No intermediate register is needed, but we have a special reload\n      pattern, which we assume for now needs a scratch register.  */\n@@ -547,7 +547,7 @@ scratch_reload_class (enum insn_code icode)\n {\n   const char *scratch_constraint;\n   char scratch_letter;\n-  enum reg_class class;\n+  enum reg_class rclass;\n \n   gcc_assert (insn_data[(int) icode].n_operands == 3);\n   scratch_constraint = insn_data[(int) icode].operand[2].constraint;\n@@ -558,10 +558,10 @@ scratch_reload_class (enum insn_code icode)\n   scratch_letter = *scratch_constraint;\n   if (scratch_letter == 'r')\n     return GENERAL_REGS;\n-  class = REG_CLASS_FROM_CONSTRAINT ((unsigned char) scratch_letter,\n+  rclass = REG_CLASS_FROM_CONSTRAINT ((unsigned char) scratch_letter,\n \t\t\t\t     scratch_constraint);\n-  gcc_assert (class != NO_REGS);\n-  return class;\n+  gcc_assert (rclass != NO_REGS);\n+  return rclass;\n }\n \f\n #ifdef SECONDARY_MEMORY_NEEDED\n@@ -660,40 +660,40 @@ find_valid_class (enum machine_mode outer ATTRIBUTE_UNUSED,\n \t\t  unsigned int dest_regno ATTRIBUTE_UNUSED)\n {\n   int best_cost = -1;\n-  int class;\n+  int rclass;\n   int regno;\n   enum reg_class best_class = NO_REGS;\n   enum reg_class dest_class ATTRIBUTE_UNUSED = REGNO_REG_CLASS (dest_regno);\n   unsigned int best_size = 0;\n   int cost;\n \n-  for (class = 1; class < N_REG_CLASSES; class++)\n+  for (rclass = 1; rclass < N_REG_CLASSES; rclass++)\n     {\n       int bad = 0;\n       int good = 0;\n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER - n && ! bad; regno++)\n-\tif (TEST_HARD_REG_BIT (reg_class_contents[class], regno))\n+\tif (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno))\n \t  {\n \t    if (HARD_REGNO_MODE_OK (regno, inner))\n \t      {\n \t\tgood = 1;\n-\t\tif (! TEST_HARD_REG_BIT (reg_class_contents[class], regno + n)\n+\t\tif (! TEST_HARD_REG_BIT (reg_class_contents[rclass], regno + n)\n \t\t    || ! HARD_REGNO_MODE_OK (regno + n, outer))\n \t\t  bad = 1;\n \t      }\n \t  }\n \n       if (bad || !good)\n \tcontinue;\n-      cost = REGISTER_MOVE_COST (outer, class, dest_class);\n+      cost = REGISTER_MOVE_COST (outer, rclass, dest_class);\n \n-      if ((reg_class_size[class] > best_size\n+      if ((reg_class_size[rclass] > best_size\n \t   && (best_cost < 0 || best_cost >= cost))\n \t  || best_cost > cost)\n \t{\n-\t  best_class = class;\n-\t  best_size = reg_class_size[class];\n-\t  best_cost = REGISTER_MOVE_COST (outer, class, dest_class);\n+\t  best_class = rclass;\n+\t  best_size = reg_class_size[rclass];\n+\t  best_cost = REGISTER_MOVE_COST (outer, rclass, dest_class);\n \t}\n     }\n \n@@ -704,14 +704,14 @@ find_valid_class (enum machine_mode outer ATTRIBUTE_UNUSED,\n \f\n /* Return the number of a previously made reload that can be combined with\n    a new one, or n_reloads if none of the existing reloads can be used.\n-   OUT, CLASS, TYPE and OPNUM are the same arguments as passed to\n+   OUT, RCLASS, TYPE and OPNUM are the same arguments as passed to\n    push_reload, they determine the kind of the new reload that we try to\n    combine.  P_IN points to the corresponding value of IN, which can be\n    modified by this function.\n    DONT_SHARE is nonzero if we can't share any input-only reload for IN.  */\n \n static int\n-find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n+find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n \t\t      enum reload_type type, int opnum, int dont_share)\n {\n   rtx in = *p_in;\n@@ -732,18 +732,18 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n      than we otherwise would.  */\n \n   for (i = 0; i < n_reloads; i++)\n-    if ((reg_class_subset_p (class, rld[i].class)\n-\t || reg_class_subset_p (rld[i].class, class))\n+    if ((reg_class_subset_p (rclass, rld[i].class)\n+\t || reg_class_subset_p (rld[i].class, rclass))\n \t/* If the existing reload has a register, it must fit our class.  */\n \t&& (rld[i].reg_rtx == 0\n-\t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t    || TEST_HARD_REG_BIT (reg_class_contents[(int) rclass],\n \t\t\t\t  true_regnum (rld[i].reg_rtx)))\n \t&& ((in != 0 && MATCHES (rld[i].in, in) && ! dont_share\n \t     && (out == 0 || rld[i].out == 0 || MATCHES (rld[i].out, out)))\n \t    || (out != 0 && MATCHES (rld[i].out, out)\n \t\t&& (in == 0 || rld[i].in == 0 || MATCHES (rld[i].in, in))))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (SMALL_REGISTER_CLASS_P (class) || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (rclass) || SMALL_REGISTER_CLASSES)\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed, opnum, rld[i].opnum))\n       return i;\n \n@@ -753,12 +753,12 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n      the preincrementation as happening before any ref in this insn\n      to that register.  */\n   for (i = 0; i < n_reloads; i++)\n-    if ((reg_class_subset_p (class, rld[i].class)\n-\t || reg_class_subset_p (rld[i].class, class))\n+    if ((reg_class_subset_p (rclass, rld[i].class)\n+\t || reg_class_subset_p (rld[i].class, rclass))\n \t/* If the existing reload has a register, it must fit our\n \t   class.  */\n \t&& (rld[i].reg_rtx == 0\n-\t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t    || TEST_HARD_REG_BIT (reg_class_contents[(int) rclass],\n \t\t\t\t  true_regnum (rld[i].reg_rtx)))\n \t&& out == 0 && rld[i].out == 0 && rld[i].in != 0\n \t&& ((REG_P (in)\n@@ -768,7 +768,7 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class class,\n \t\t&& GET_RTX_CLASS (GET_CODE (in)) == RTX_AUTOINC\n \t\t&& MATCHES (XEXP (in, 0), rld[i].in)))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (SMALL_REGISTER_CLASS_P (class) || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (rclass) || SMALL_REGISTER_CLASSES)\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed,\n \t\t\t     opnum, rld[i].opnum))\n       {\n@@ -878,7 +878,7 @@ can_reload_into (rtx in, int regno, enum machine_mode mode)\n    If IN and OUT are both nonzero, it means the same register must be used\n    to reload both IN and OUT.\n \n-   CLASS is a register class required for the reloaded data.\n+   RCLASS is a register class required for the reloaded data.\n    INMODE is the machine mode that the instruction requires\n    for the reg that replaces IN and OUTMODE is likewise for OUT.\n \n@@ -904,7 +904,7 @@ can_reload_into (rtx in, int regno, enum machine_mode mode)\n \n int\n push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n-\t     enum reg_class class, enum machine_mode inmode,\n+\t     enum reg_class rclass, enum machine_mode inmode,\n \t     enum machine_mode outmode, int strict_low, int optional,\n \t     int opnum, enum reload_type type)\n {\n@@ -1003,7 +1003,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   if (in != 0 && GET_CODE (in) == SUBREG\n       && (subreg_lowpart_p (in) || strict_low)\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (in)), inmode, class)\n+      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (in)), inmode, rclass)\n #endif\n       && (CONSTANT_P (SUBREG_REG (in))\n \t  || GET_CODE (SUBREG_REG (in)) == PLUS\n@@ -1043,8 +1043,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (in))]\n \t\t\t\t\t\t[GET_MODE (SUBREG_REG (in))]))\n \t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (in), inmode)))\n-\t  || (secondary_reload_class (1, class, inmode, in) != NO_REGS\n-\t      && (secondary_reload_class (1, class, GET_MODE (SUBREG_REG (in)),\n+\t  || (secondary_reload_class (1, rclass, inmode, in) != NO_REGS\n+\t      && (secondary_reload_class (1, rclass, GET_MODE (SUBREG_REG (in)),\n \t\t\t\t\t  SUBREG_REG (in))\n \t\t  == NO_REGS))\n #ifdef CANNOT_CHANGE_MODE_CLASS\n@@ -1079,7 +1079,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n   if (in != 0 && reload_inner_reg_of_subreg (in, inmode, 0))\n     {\n-      enum reg_class in_class = class;\n+      enum reg_class in_class = rclass;\n \n       if (REG_P (SUBREG_REG (in)))\n \tin_class\n@@ -1109,7 +1109,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   if (out != 0 && GET_CODE (out) == SUBREG\n       && (subreg_lowpart_p (out) || strict_low)\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (out)), outmode, class)\n+      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SUBREG_REG (out)), outmode, rclass)\n #endif\n       && (CONSTANT_P (SUBREG_REG (out))\n \t  || strict_low\n@@ -1136,8 +1136,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (out))]\n \t\t\t\t\t\t[GET_MODE (SUBREG_REG (out))]))\n \t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (out), outmode)))\n-\t  || (secondary_reload_class (0, class, outmode, out) != NO_REGS\n-\t      && (secondary_reload_class (0, class, GET_MODE (SUBREG_REG (out)),\n+\t  || (secondary_reload_class (0, rclass, outmode, out) != NO_REGS\n+\t      && (secondary_reload_class (0, rclass, GET_MODE (SUBREG_REG (out)),\n \t\t\t\t\t  SUBREG_REG (out))\n \t\t  == NO_REGS))\n #ifdef CANNOT_CHANGE_MODE_CLASS\n@@ -1211,10 +1211,10 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   /* Narrow down the class of register wanted if that is\n      desirable on this machine for efficiency.  */\n   {\n-    enum reg_class preferred_class = class;\n+    enum reg_class preferred_class = rclass;\n \n     if (in != 0)\n-      preferred_class = PREFERRED_RELOAD_CLASS (in, class);\n+      preferred_class = PREFERRED_RELOAD_CLASS (in, rclass);\n \n   /* Output reloads may need analogous treatment, different in detail.  */\n #ifdef PREFERRED_OUTPUT_RELOAD_CLASS\n@@ -1225,7 +1225,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n     /* Discard what the target said if we cannot do it.  */\n     if (preferred_class != NO_REGS\n \t|| (optional && type == RELOAD_FOR_OUTPUT))\n-      class = preferred_class;\n+      rclass = preferred_class;\n   }\n \n   /* Make sure we use a class that can handle the actual pseudo\n@@ -1234,14 +1234,14 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      can handle SImode, QImode needs a smaller class.  */\n #ifdef LIMIT_RELOAD_CLASS\n   if (in_subreg_loc)\n-    class = LIMIT_RELOAD_CLASS (inmode, class);\n+    rclass = LIMIT_RELOAD_CLASS (inmode, rclass);\n   else if (in != 0 && GET_CODE (in) == SUBREG)\n-    class = LIMIT_RELOAD_CLASS (GET_MODE (SUBREG_REG (in)), class);\n+    rclass = LIMIT_RELOAD_CLASS (GET_MODE (SUBREG_REG (in)), rclass);\n \n   if (out_subreg_loc)\n-    class = LIMIT_RELOAD_CLASS (outmode, class);\n+    rclass = LIMIT_RELOAD_CLASS (outmode, rclass);\n   if (out != 0 && GET_CODE (out) == SUBREG)\n-    class = LIMIT_RELOAD_CLASS (GET_MODE (SUBREG_REG (out)), class);\n+    rclass = LIMIT_RELOAD_CLASS (GET_MODE (SUBREG_REG (out)), rclass);\n #endif\n \n   /* Verify that this class is at least possible for the mode that\n@@ -1265,7 +1265,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t}\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (HARD_REGNO_MODE_OK (i, mode)\n-\t    && in_hard_reg_set_p (reg_class_contents[(int) class], mode, i))\n+\t    && in_hard_reg_set_p (reg_class_contents[(int) rclass], mode, i))\n \t  break;\n       if (i == FIRST_PSEUDO_REGISTER)\n \t{\n@@ -1290,10 +1290,10 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   /* Optional output reloads are always OK even if we have no register class,\n      since the function of these reloads is only to have spill_reg_store etc.\n      set, so that the storing insn can be deleted later.  */\n-  gcc_assert (class != NO_REGS\n+  gcc_assert (rclass != NO_REGS\n \t      || (optional != 0 && type == RELOAD_FOR_OUTPUT));\n \n-  i = find_reusable_reload (&in, out, class, type, opnum, dont_share);\n+  i = find_reusable_reload (&in, out, rclass, type, opnum, dont_share);\n \n   if (i == n_reloads)\n     {\n@@ -1303,11 +1303,11 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n       if (in != 0)\n \tsecondary_in_reload\n-\t  = push_secondary_reload (1, in, opnum, optional, class, inmode, type,\n+\t  = push_secondary_reload (1, in, opnum, optional, rclass, inmode, type,\n \t\t\t\t   &secondary_in_icode, NULL);\n       if (out != 0 && GET_CODE (out) != SCRATCH)\n \tsecondary_out_reload\n-\t  = push_secondary_reload (0, out, opnum, optional, class, outmode,\n+\t  = push_secondary_reload (0, out, opnum, optional, rclass, outmode,\n \t\t\t\t   type, &secondary_out_icode, NULL);\n \n       /* We found no existing reload suitable for re-use.\n@@ -1320,14 +1320,14 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t      || (GET_CODE (in) == SUBREG && REG_P (SUBREG_REG (in))))\n \t  && reg_or_subregno (in) < FIRST_PSEUDO_REGISTER\n \t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (reg_or_subregno (in)),\n-\t\t\t\t      class, inmode))\n+\t\t\t\t      rclass, inmode))\n \tget_secondary_mem (in, inmode, opnum, type);\n #endif\n \n       i = n_reloads;\n       rld[i].in = in;\n       rld[i].out = out;\n-      rld[i].class = class;\n+      rld[i].class = rclass;\n       rld[i].inmode = inmode;\n       rld[i].outmode = outmode;\n       rld[i].reg_rtx = 0;\n@@ -1351,7 +1351,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n           && (REG_P (out)\n \t      || (GET_CODE (out) == SUBREG && REG_P (SUBREG_REG (out))))\n \t  && reg_or_subregno (out) < FIRST_PSEUDO_REGISTER\n-\t  && SECONDARY_MEMORY_NEEDED (class,\n+\t  && SECONDARY_MEMORY_NEEDED (rclass,\n \t\t\t\t      REGNO_REG_CLASS (reg_or_subregno (out)),\n \t\t\t\t      outmode))\n \tget_secondary_mem (out, outmode, opnum, type);\n@@ -1411,8 +1411,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  rld[i].out = out;\n \t  rld[i].out_reg = outloc ? *outloc : 0;\n \t}\n-      if (reg_class_subset_p (class, rld[i].class))\n-\trld[i].class = class;\n+      if (reg_class_subset_p (rclass, rld[i].class))\n+\trld[i].class = rclass;\n       rld[i].optional &= optional;\n       if (MERGE_TO_OTHER (type, rld[i].when_needed,\n \t\t\t  opnum, rld[i].opnum))\n@@ -1561,7 +1561,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \n \t    for (offs = 0; offs < nregs; offs++)\n \t      if (fixed_regs[regno + offs]\n-\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) rclass],\n \t\t\t\t\t  regno + offs))\n \t\tbreak;\n \n@@ -1867,7 +1867,7 @@ combine_reloads (void)\n    If so, return the register rtx that proves acceptable.\n \n    INLOC and OUTLOC are locations where IN and OUT appear in the insn.\n-   CLASS is the register class required for the reload.\n+   RCLASS is the register class required for the reload.\n \n    If FOR_REAL is >= 0, it is the number of the reload,\n    and in some cases when it can be discovered that OUT doesn't need\n@@ -1884,7 +1884,7 @@ combine_reloads (void)\n static rtx\n find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t\t   enum machine_mode inmode, enum machine_mode outmode,\n-\t\t   enum reg_class class, int for_real, int earlyclobber)\n+\t\t   enum reg_class rclass, int for_real, int earlyclobber)\n {\n   rtx in = real_in;\n   rtx out = real_out;\n@@ -1927,9 +1927,9 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n   /* Narrow down the reg class, the same way push_reload will;\n      otherwise we might find a dummy now, but push_reload won't.  */\n   {\n-    enum reg_class preferred_class = PREFERRED_RELOAD_CLASS (in, class);\n+    enum reg_class preferred_class = PREFERRED_RELOAD_CLASS (in, rclass);\n     if (preferred_class != NO_REGS)\n-      class = preferred_class;\n+      rclass = preferred_class;\n   }\n \n   /* See if OUT will do.  */\n@@ -1960,7 +1960,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t  unsigned int i;\n \n \t  for (i = 0; i < nwords; i++)\n-\t    if (! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t    if (! TEST_HARD_REG_BIT (reg_class_contents[(int) rclass],\n \t\t\t\t     regno + i))\n \t      break;\n \n@@ -2028,7 +2028,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t  unsigned int i;\n \n \t  for (i = 0; i < nwords; i++)\n-\t    if (! TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t    if (! TEST_HARD_REG_BIT (reg_class_contents[(int) rclass],\n \t\t\t\t     regno + i))\n \t      break;\n \n@@ -5916,14 +5916,14 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t     is larger than the class size, then reload the whole SUBREG.  */\n \t  else\n \t    {\n-\t      enum reg_class class = context_reg_class;\n-\t      if ((unsigned) CLASS_MAX_NREGS (class, GET_MODE (SUBREG_REG (x)))\n-\t\t  > reg_class_size[class])\n+\t      enum reg_class rclass = context_reg_class;\n+\t      if ((unsigned) CLASS_MAX_NREGS (rclass, GET_MODE (SUBREG_REG (x)))\n+\t\t  > reg_class_size[rclass])\n \t\t{\n \t\t  x = find_reloads_subreg_address (x, 0, opnum, \n \t\t\t\t\t\t   ADDR_TYPE (type),\n \t\t\t\t\t\t   ind_levels, insn);\n-\t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0, class,\n+\t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0, rclass,\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n \t\t}\n@@ -5954,7 +5954,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n }\n \f\n /* X, which is found at *LOC, is a part of an address that needs to be\n-   reloaded into a register of class CLASS.  If X is a constant, or if\n+   reloaded into a register of class RCLASS.  If X is a constant, or if\n    X is a PLUS that contains a constant, check that the constant is a\n    legitimate operand and that we are supposed to be able to load\n    it into the register.\n@@ -5969,13 +5969,13 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n    supports.  */\n \n static void\n-find_reloads_address_part (rtx x, rtx *loc, enum reg_class class,\n+find_reloads_address_part (rtx x, rtx *loc, enum reg_class rclass,\n \t\t\t   enum machine_mode mode, int opnum,\n \t\t\t   enum reload_type type, int ind_levels)\n {\n   if (CONSTANT_P (x)\n       && (! LEGITIMATE_CONSTANT_P (x)\n-\t  || PREFERRED_RELOAD_CLASS (x, class) == NO_REGS))\n+\t  || PREFERRED_RELOAD_CLASS (x, rclass) == NO_REGS))\n     {\n       x = force_const_mem (mode, x);\n       find_reloads_address (mode, &x, XEXP (x, 0), &XEXP (x, 0),\n@@ -5985,7 +5985,7 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class class,\n   else if (GET_CODE (x) == PLUS\n \t   && CONSTANT_P (XEXP (x, 1))\n \t   && (! LEGITIMATE_CONSTANT_P (XEXP (x, 1))\n-\t       || PREFERRED_RELOAD_CLASS (XEXP (x, 1), class) == NO_REGS))\n+\t       || PREFERRED_RELOAD_CLASS (XEXP (x, 1), rclass) == NO_REGS))\n     {\n       rtx tem;\n \n@@ -5995,7 +5995,7 @@ find_reloads_address_part (rtx x, rtx *loc, enum reg_class class,\n \t\t\t    opnum, type, ind_levels, 0);\n     }\n \n-  push_reload (x, NULL_RTX, loc, (rtx*) 0, class,\n+  push_reload (x, NULL_RTX, loc, (rtx*) 0, rclass,\n \t       mode, VOIDmode, 0, 0, opnum, type);\n }\n \f\n@@ -6600,7 +6600,7 @@ refers_to_mem_for_reload_p (rtx x)\n \f\n /* Check the insns before INSN to see if there is a suitable register\n    containing the same value as GOAL.\n-   If OTHER is -1, look for a register in class CLASS.\n+   If OTHER is -1, look for a register in class RCLASS.\n    Otherwise, just see if register number OTHER shares GOAL's value.\n \n    Return an rtx for the register found, or zero if none is found.\n@@ -6626,7 +6626,7 @@ refers_to_mem_for_reload_p (rtx x)\n    as if it were a constant except that sp is required to be unchanging.  */\n \n rtx\n-find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n+find_equiv_reg (rtx goal, rtx insn, enum reg_class rclass, int other,\n \t\tshort *reload_reg_p, int goalreg, enum machine_mode mode)\n {\n   rtx p = insn;\n@@ -6772,7 +6772,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t}\n \t      else if ((unsigned) valueno >= FIRST_PSEUDO_REGISTER)\n \t\tcontinue;\n-\t      else if (!in_hard_reg_set_p (reg_class_contents[(int) class],\n+\t      else if (!in_hard_reg_set_p (reg_class_contents[(int) rclass],\n \t\t\t\t\t  mode, valueno))\n \t\tcontinue;\n \t      value = valtry;"}, {"sha": "ad58228c791f6b8eb3e8798455eb2a39565e7922", "filename": "gcc/reload1.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -1976,16 +1976,16 @@ delete_caller_save_insns (void)\n    INSN should be one of the insns which needed this particular spill reg.  */\n \n static void\n-spill_failure (rtx insn, enum reg_class class)\n+spill_failure (rtx insn, enum reg_class rclass)\n {\n   if (asm_noperands (PATTERN (insn)) >= 0)\n     error_for_asm (insn, \"can't find a register in class %qs while \"\n \t\t   \"reloading %<asm%>\",\n-\t\t   reg_class_names[class]);\n+\t\t   reg_class_names[rclass]);\n   else\n     {\n       error (\"unable to find a register to spill in class %qs\",\n-\t     reg_class_names[class]);\n+\t     reg_class_names[rclass]);\n \n       if (dump_file)\n \t{\n@@ -2394,7 +2394,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n   int regno;\n-  rtx new;\n+  rtx new_rtx;\n   int i, j;\n   const char *fmt;\n   int copied = 0;\n@@ -2523,15 +2523,15 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t     && reg_equiv_constant[REGNO (new0)] != 0)\n \t      new0 = reg_equiv_constant[REGNO (new0)];\n \n-\t    new = form_sum (new0, new1);\n+\t    new_rtx = form_sum (new0, new1);\n \n \t    /* As above, if we are not inside a MEM we do not want to\n \t       turn a PLUS into something else.  We might try to do so here\n \t       for an addition of 0 if we aren't optimizing.  */\n-\t    if (! mem_mode && GET_CODE (new) != PLUS)\n-\t      return gen_rtx_PLUS (GET_MODE (x), new, const0_rtx);\n+\t    if (! mem_mode && GET_CODE (new_rtx) != PLUS)\n+\t      return gen_rtx_PLUS (GET_MODE (x), new_rtx, const0_rtx);\n \t    else\n-\t      return new;\n+\t      return new_rtx;\n \t  }\n       }\n       return x;\n@@ -2588,8 +2588,8 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n       /* If we have something in XEXP (x, 0), the usual case, eliminate it.  */\n       if (XEXP (x, 0))\n \t{\n-\t  new = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true);\n-\t  if (new != XEXP (x, 0))\n+\t  new_rtx = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, true);\n+\t  if (new_rtx != XEXP (x, 0))\n \t    {\n \t      /* If this is a REG_DEAD note, it is not valid anymore.\n \t\t Using the eliminated version could result in creating a\n@@ -2599,7 +2599,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t\t? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true)\n \t\t\t: NULL_RTX);\n \n-\t      x = gen_rtx_EXPR_LIST (REG_NOTE_KIND (x), new, XEXP (x, 1));\n+\t      x = gen_rtx_EXPR_LIST (REG_NOTE_KIND (x), new_rtx, XEXP (x, 1));\n \t    }\n \t}\n \n@@ -2611,10 +2611,10 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true);\n-\t  if (new != XEXP (x, 1))\n+\t  new_rtx = eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true);\n+\t  if (new_rtx != XEXP (x, 1))\n \t    return\n-\t      gen_rtx_fmt_ee (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new);\n+\t      gen_rtx_fmt_ee (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new_rtx);\n \t}\n       return x;\n \n@@ -2636,13 +2636,13 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n       if (GET_CODE (XEXP (x, 1)) == PLUS\n \t  && XEXP (XEXP (x, 1), 0) == XEXP (x, 0))\n \t{\n-\t  rtx new = eliminate_regs_1 (XEXP (XEXP (x, 1), 1), mem_mode,\n+\t  rtx new_rtx = eliminate_regs_1 (XEXP (XEXP (x, 1), 1), mem_mode,\n \t\t\t\t      insn, true);\n \n-\t  if (new != XEXP (XEXP (x, 1), 1))\n+\t  if (new_rtx != XEXP (XEXP (x, 1), 1))\n \t    return gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (x, 0),\n \t\t\t\t   gen_rtx_PLUS (GET_MODE (x),\n-\t\t\t\t\t\t XEXP (x, 0), new));\n+\t\t\t\t\t\t XEXP (x, 0), new_rtx));\n \t}\n       return x;\n \n@@ -2660,9 +2660,9 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n     case POPCOUNT:\n     case PARITY:\n     case BSWAP:\n-      new = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false);\n-      if (new != XEXP (x, 0))\n-\treturn gen_rtx_fmt_e (code, GET_MODE (x), new);\n+      new_rtx = eliminate_regs_1 (XEXP (x, 0), mem_mode, insn, false);\n+      if (new_rtx != XEXP (x, 0))\n+\treturn gen_rtx_fmt_e (code, GET_MODE (x), new_rtx);\n       return x;\n \n     case SUBREG:\n@@ -2678,17 +2678,17 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t  && reg_equiv_memory_loc != 0\n \t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n \t{\n-\t  new = SUBREG_REG (x);\n+\t  new_rtx = SUBREG_REG (x);\n \t}\n       else\n-\tnew = eliminate_regs_1 (SUBREG_REG (x), mem_mode, insn, false);\n+\tnew_rtx = eliminate_regs_1 (SUBREG_REG (x), mem_mode, insn, false);\n \n-      if (new != SUBREG_REG (x))\n+      if (new_rtx != SUBREG_REG (x))\n \t{\n \t  int x_size = GET_MODE_SIZE (GET_MODE (x));\n-\t  int new_size = GET_MODE_SIZE (GET_MODE (new));\n+\t  int new_size = GET_MODE_SIZE (GET_MODE (new_rtx));\n \n-\t  if (MEM_P (new)\n+\t  if (MEM_P (new_rtx)\n \t      && ((x_size < new_size\n #ifdef WORD_REGISTER_OPERATIONS\n \t\t   /* On these machines, combine can create rtl of the form\n@@ -2704,9 +2704,9 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t   )\n \t\t  || x_size == new_size)\n \t      )\n-\t    return adjust_address_nv (new, GET_MODE (x), SUBREG_BYTE (x));\n+\t    return adjust_address_nv (new_rtx, GET_MODE (x), SUBREG_BYTE (x));\n \t  else\n-\t    return gen_rtx_SUBREG (GET_MODE (x), new, SUBREG_BYTE (x));\n+\t    return gen_rtx_SUBREG (GET_MODE (x), new_rtx, SUBREG_BYTE (x));\n \t}\n \n       return x;\n@@ -2722,9 +2722,9 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \n     case USE:\n       /* Handle insn_list USE that a call to a pure function may generate.  */\n-      new = eliminate_regs_1 (XEXP (x, 0), 0, insn, false);\n-      if (new != XEXP (x, 0))\n-\treturn gen_rtx_USE (GET_MODE (x), new);\n+      new_rtx = eliminate_regs_1 (XEXP (x, 0), 0, insn, false);\n+      if (new_rtx != XEXP (x, 0))\n+\treturn gen_rtx_USE (GET_MODE (x), new_rtx);\n       return x;\n \n     case CLOBBER:\n@@ -2743,21 +2743,21 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new = eliminate_regs_1 (XEXP (x, i), mem_mode, insn, false);\n-\t  if (new != XEXP (x, i) && ! copied)\n+\t  new_rtx = eliminate_regs_1 (XEXP (x, i), mem_mode, insn, false);\n+\t  if (new_rtx != XEXP (x, i) && ! copied)\n \t    {\n \t      x = shallow_copy_rtx (x);\n \t      copied = 1;\n \t    }\n-\t  XEXP (x, i) = new;\n+\t  XEXP (x, i) = new_rtx;\n \t}\n       else if (*fmt == 'E')\n \t{\n \t  int copied_vec = 0;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      new = eliminate_regs_1 (XVECEXP (x, i, j), mem_mode, insn, false);\n-\t      if (new != XVECEXP (x, i, j) && ! copied_vec)\n+\t      new_rtx = eliminate_regs_1 (XVECEXP (x, i, j), mem_mode, insn, false);\n+\t      if (new_rtx != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n \t\t  rtvec new_v = gen_rtvec_v (XVECLEN (x, i),\n \t\t\t\t\t     XVEC (x, i)->elem);\n@@ -2769,7 +2769,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t\t  XVEC (x, i) = new_v;\n \t\t  copied_vec = 1;\n \t\t}\n-\t      XVECEXP (x, i, j) = new;\n+\t      XVECEXP (x, i, j) = new_rtx;\n \t    }\n \t}\n     }\n@@ -5474,7 +5474,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \n       for (count = 0; count < n_spills; count++)\n \t{\n-\t  int class = (int) rld[r].class;\n+\t  int rclass = (int) rld[r].class;\n \t  int regnum;\n \n \t  i++;\n@@ -5491,7 +5491,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t\t   && free_for_value_p (regnum, rld[r].mode, rld[r].opnum,\n \t\t\t\t\trld[r].when_needed, rld[r].in,\n \t\t\t\t\trld[r].out, r, 1)))\n-\t      && TEST_HARD_REG_BIT (reg_class_contents[class], regnum)\n+\t      && TEST_HARD_REG_BIT (reg_class_contents[rclass], regnum)\n \t      && HARD_REGNO_MODE_OK (regnum, rld[r].mode)\n \t      /* Look first for regs to share, then for unshared.  But\n \t\t don't share regs used for inherited reloads; they are\n@@ -5521,7 +5521,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t      while (nr > 1)\n \t\t{\n \t\t  int regno = regnum + nr - 1;\n-\t\t  if (!(TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n+\t\t  if (!(TEST_HARD_REG_BIT (reg_class_contents[rclass], regno)\n \t\t\t&& spill_reg_order[regno] >= 0\n \t\t\t&& reload_reg_free_p (regno, rld[r].opnum,\n \t\t\t\t\t      rld[r].when_needed)))\n@@ -5793,7 +5793,7 @@ choose_reload_regs (struct insn_chain *chain)\n #endif\n \t\t  )\n \t\t{\n-\t\t  enum reg_class class = rld[r].class, last_class;\n+\t\t  enum reg_class rclass = rld[r].class, last_class;\n \t\t  rtx last_reg = reg_last_reload_reg[regno];\n \t\t  enum machine_mode need_mode;\n \n@@ -5814,18 +5814,18 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t      && reg_reloaded_contents[i] == regno\n \t\t      && TEST_HARD_REG_BIT (reg_reloaded_valid, i)\n \t\t      && HARD_REGNO_MODE_OK (i, rld[r].mode)\n-\t\t      && (TEST_HARD_REG_BIT (reg_class_contents[(int) class], i)\n+\t\t      && (TEST_HARD_REG_BIT (reg_class_contents[(int) rclass], i)\n \t\t\t  /* Even if we can't use this register as a reload\n \t\t\t     register, we might use it for reload_override_in,\n \t\t\t     if copying it to the desired class is cheap\n \t\t\t     enough.  */\n-\t\t\t  || ((REGISTER_MOVE_COST (mode, last_class, class)\n-\t\t\t       < MEMORY_MOVE_COST (mode, class, 1))\n-\t\t\t      && (secondary_reload_class (1, class, mode,\n+\t\t\t  || ((REGISTER_MOVE_COST (mode, last_class, rclass)\n+\t\t\t       < MEMORY_MOVE_COST (mode, rclass, 1))\n+\t\t\t      && (secondary_reload_class (1, rclass, mode,\n \t\t\t\t\t\t\t  last_reg)\n \t\t\t\t  == NO_REGS)\n #ifdef SECONDARY_MEMORY_NEEDED\n-\t\t\t      && ! SECONDARY_MEMORY_NEEDED (last_class, class,\n+\t\t\t      && ! SECONDARY_MEMORY_NEEDED (last_class, rclass,\n \t\t\t\t\t\t\t    mode)\n #endif\n \t\t\t      ))"}, {"sha": "fb4a5df7dc859cb08f036d82e43ad883448f1621", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -2470,32 +2470,32 @@ replace_rtx (rtx x, rtx from, rtx to)\n \n   if (GET_CODE (x) == SUBREG)\n     {\n-      rtx new = replace_rtx (SUBREG_REG (x), from, to);\n+      rtx new_rtx = replace_rtx (SUBREG_REG (x), from, to);\n \n-      if (GET_CODE (new) == CONST_INT)\n+      if (GET_CODE (new_rtx) == CONST_INT)\n \t{\n-\t  x = simplify_subreg (GET_MODE (x), new,\n+\t  x = simplify_subreg (GET_MODE (x), new_rtx,\n \t\t\t       GET_MODE (SUBREG_REG (x)),\n \t\t\t       SUBREG_BYTE (x));\n \t  gcc_assert (x);\n \t}\n       else\n-\tSUBREG_REG (x) = new;\n+\tSUBREG_REG (x) = new_rtx;\n \n       return x;\n     }\n   else if (GET_CODE (x) == ZERO_EXTEND)\n     {\n-      rtx new = replace_rtx (XEXP (x, 0), from, to);\n+      rtx new_rtx = replace_rtx (XEXP (x, 0), from, to);\n \n-      if (GET_CODE (new) == CONST_INT)\n+      if (GET_CODE (new_rtx) == CONST_INT)\n \t{\n \t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n-\t\t\t\t\tnew, GET_MODE (XEXP (x, 0)));\n+\t\t\t\t\tnew_rtx, GET_MODE (XEXP (x, 0)));\n \t  gcc_assert (x);\n \t}\n       else\n-\tXEXP (x, 0) = new;\n+\tXEXP (x, 0) = new_rtx;\n \n       return x;\n     }\n@@ -3692,12 +3692,12 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \n       {\n \tunsigned HOST_WIDE_INT nonzero_for_hook = nonzero;\n-\trtx new = rtl_hooks.reg_nonzero_bits (x, mode, known_x,\n+\trtx new_rtx = rtl_hooks.reg_nonzero_bits (x, mode, known_x,\n \t\t\t\t\t      known_mode, known_ret,\n \t\t\t\t\t      &nonzero_for_hook);\n \n-\tif (new)\n-\t  nonzero_for_hook &= cached_nonzero_bits (new, mode, known_x,\n+\tif (new_rtx)\n+\t  nonzero_for_hook &= cached_nonzero_bits (new_rtx, mode, known_x,\n \t\t\t\t\t\t   known_mode, known_ret);\n \n \treturn nonzero_for_hook;\n@@ -4177,12 +4177,12 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \n       {\n \tunsigned int copies_for_hook = 1, copies = 1;\n-\trtx new = rtl_hooks.reg_num_sign_bit_copies (x, mode, known_x,\n+\trtx new_rtx = rtl_hooks.reg_num_sign_bit_copies (x, mode, known_x,\n \t\t\t\t\t\t     known_mode, known_ret,\n \t\t\t\t\t\t     &copies_for_hook);\n \n-\tif (new)\n-\t  copies = cached_num_sign_bit_copies (new, mode, known_x,\n+\tif (new_rtx)\n+\t  copies = cached_num_sign_bit_copies (new_rtx, mode, known_x,\n \t\t\t\t\t       known_mode, known_ret);\n \n \tif (copies > 1 || copies_for_hook > 1)"}, {"sha": "25fbc094830a0dd10156686ba58f01411b8352fe", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -141,7 +141,7 @@ gen_lowpart_if_possible (enum machine_mode mode, rtx x)\n     {\n       /* This is the only other case we handle.  */\n       int offset = 0;\n-      rtx new;\n+      rtx new_rtx;\n \n       if (WORDS_BIG_ENDIAN)\n \toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n@@ -152,11 +152,11 @@ gen_lowpart_if_possible (enum machine_mode mode, rtx x)\n \toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n \t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n \n-      new = adjust_address_nv (x, mode, offset);\n-      if (! memory_address_p (mode, XEXP (new, 0)))\n+      new_rtx = adjust_address_nv (x, mode, offset);\n+      if (! memory_address_p (mode, XEXP (new_rtx, 0)))\n \treturn 0;\n \n-      return new;\n+      return new_rtx;\n     }\n   else if (mode != GET_MODE (x) && GET_MODE (x) != VOIDmode\n \t   && validate_subreg (mode, GET_MODE (x), x,"}, {"sha": "25b97c395d1d5ad2f63f0c983791f7c551453e2b", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -357,7 +357,7 @@ static void\n add_deps_for_risky_insns (rtx head, rtx tail)\n {\n   rtx insn, prev;\n-  int class;\n+  int classification;\n   rtx last_jump = NULL_RTX;\n   rtx next_tail = NEXT_INSN (tail);\n   basic_block last_block = NULL, bb;\n@@ -372,9 +372,9 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n       }\n     else if (INSN_P (insn) && last_jump != NULL_RTX)\n       {\n-\tclass = haifa_classify_insn (insn);\n+\tclassification = haifa_classify_insn (insn);\n \tprev = last_jump;\n-\tswitch (class)\n+\tswitch (classification)\n \t  {\n \t  case PFREE_CANDIDATE:\n \t    if (flag_schedule_speculative_load)"}, {"sha": "28f528302ff42897f29394fdd4cc1517e3fefa4c", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -2388,10 +2388,10 @@ static struct deps *bb_deps;\n static rtx\n concat_INSN_LIST (rtx copy, rtx old)\n {\n-  rtx new = old;\n+  rtx new_rtx = old;\n   for (; copy ; copy = XEXP (copy, 1))\n-    new = alloc_INSN_LIST (XEXP (copy, 0), new);\n-  return new;\n+    new_rtx = alloc_INSN_LIST (XEXP (copy, 0), new_rtx);\n+  return new_rtx;\n }\n \n static void"}, {"sha": "17654611e1acf1475d09df167b2003406e52c1a5", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d796dacbdfb6133311e06027360066c0fce95f/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=55d796dacbdfb6133311e06027360066c0fce95f", "patch": "@@ -163,20 +163,20 @@ variable_size (tree size)\n #endif\n \n /* Return the machine mode to use for a nonscalar of SIZE bits.  The\n-   mode must be in class CLASS, and have exactly that many value bits;\n+   mode must be in class MCLASS, and have exactly that many value bits;\n    it may have padding as well.  If LIMIT is nonzero, modes of wider\n    than MAX_FIXED_MODE_SIZE will not be used.  */\n \n enum machine_mode\n-mode_for_size (unsigned int size, enum mode_class class, int limit)\n+mode_for_size (unsigned int size, enum mode_class mclass, int limit)\n {\n   enum machine_mode mode;\n \n   if (limit && size > MAX_FIXED_MODE_SIZE)\n     return BLKmode;\n \n   /* Get the first mode which has this size, in the specified class.  */\n-  for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n+  for (mode = GET_CLASS_NARROWEST_MODE (mclass); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     if (GET_MODE_PRECISION (mode) == size)\n       return mode;\n@@ -187,7 +187,7 @@ mode_for_size (unsigned int size, enum mode_class class, int limit)\n /* Similar, except passed a tree node.  */\n \n enum machine_mode\n-mode_for_size_tree (const_tree size, enum mode_class class, int limit)\n+mode_for_size_tree (const_tree size, enum mode_class mclass, int limit)\n {\n   unsigned HOST_WIDE_INT uhwi;\n   unsigned int ui;\n@@ -198,20 +198,20 @@ mode_for_size_tree (const_tree size, enum mode_class class, int limit)\n   ui = uhwi;\n   if (uhwi != ui)\n     return BLKmode;\n-  return mode_for_size (ui, class, limit);\n+  return mode_for_size (ui, mclass, limit);\n }\n \n /* Similar, but never return BLKmode; return the narrowest mode that\n    contains at least the requested number of value bits.  */\n \n enum machine_mode\n-smallest_mode_for_size (unsigned int size, enum mode_class class)\n+smallest_mode_for_size (unsigned int size, enum mode_class mclass)\n {\n   enum machine_mode mode;\n \n   /* Get the first mode which has at least this size, in the\n      specified class.  */\n-  for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n+  for (mode = GET_CLASS_NARROWEST_MODE (mclass); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     if (GET_MODE_PRECISION (mode) >= size)\n       return mode;"}]}