{"sha": "41f927f4a668aeb167a673f916cc5cbfb978a560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFmOTI3ZjRhNjY4YWViMTY3YTY3M2Y5MTZjYzVjYmZiOTc4YTU2MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-11-01T11:18:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-11-01T11:18:06Z"}, "message": "[ABI PATCH] static anonymous unions of function scope\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-10/msg02076.html\n\t* cp-tree.h (struct lang_function): Delete x_local_names field.\n\t(struct lang_decl_base): Rename u2sel to spare.\n\t(struct lang_decl_min): Remove lang_decl_u2 union.  Keep access\n\tfield.\n\t(LANG_DECL_U2_CHECK): Delete.\n\t(DECL_DISCRIMINATOR_P): Require function scope.\n\t(DECL_DISCRIMINATOR): Adjust.\n\t(DECL_DISCRIMINATOR_SET_P): Delete.\n\t(DECL_CAPTURED_VARIABLE, DECL_ACCESS, THUnK_VIRTUAL_OFFSET): Adjust.\n\t(local_classes): Don't declare.\n\t(determine_local_discriminator): Declare.\n\t* decl.c (push_local_name): Delete.\n\t(local_entities, determina_local_discrminator): New.\n\t(duplicate_decls): Copy DECL_ACCESS. Fix formatting.\n\t(cp_finish_decl): Use determine_local_discriminator.\n\t(save_function_data): Drop x_local_names.\n\t(finish_function): Drop local_names.\n\t* decl2.c (finish_anon_union): Use determine_local_disciminator.\n\t* mangle.c (write_unnamed_type_name): Use\n\tdiscriminator_for_local_entity.\n\t(local_class_index): Delete.\n\t(discriminator_for_local_entity): Reimplement.\n\t(write_local_name): Adjust discriminator code.\n\t* name-lookup.c (do_pushtag): Call determine_local_discrimiator.\n\t* semantics.c (finish_omp_threadprivate): Drop DECL_DISCRIMINATOR\n\thandling.\n\t* class.c (local_classes): Delete.\n\t(init_class_processing): Don't init it.\n\n\t* g++.dg/abi/anon5.C: New.\n\nFrom-SVN: r265714", "tree": {"sha": "9677b9701960270615e3bd8fae450f03f8400509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9677b9701960270615e3bd8fae450f03f8400509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41f927f4a668aeb167a673f916cc5cbfb978a560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f927f4a668aeb167a673f916cc5cbfb978a560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f927f4a668aeb167a673f916cc5cbfb978a560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f927f4a668aeb167a673f916cc5cbfb978a560/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5de9d93189dd367bd3d2e1430d3aefdccab5cb72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de9d93189dd367bd3d2e1430d3aefdccab5cb72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de9d93189dd367bd3d2e1430d3aefdccab5cb72"}], "stats": {"total": 284, "additions": 145, "deletions": 139}, "files": [{"sha": "b567d6565eb1ac80b52d80b82f458756a7141a51", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -1,3 +1,34 @@\n+2018-11-01  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (struct lang_function): Delete x_local_names field.\n+\t(struct lang_decl_base): Rename u2sel to spare.\n+\t(struct lang_decl_min): Remove lang_decl_u2 union.  Keep access\n+\tfield.\n+\t(LANG_DECL_U2_CHECK): Delete.\n+\t(DECL_DISCRIMINATOR_P): Require function scope.\n+\t(DECL_DISCRIMINATOR): Adjust.\n+\t(DECL_DISCRIMINATOR_SET_P): Delete.\n+\t(DECL_CAPTURED_VARIABLE, DECL_ACCESS, THUnK_VIRTUAL_OFFSET): Adjust.\n+\t(local_classes): Don't declare.\n+\t(determine_local_discriminator): Declare.\n+\t* decl.c (push_local_name): Delete.\n+\t(local_entities, determina_local_discrminator): New.\n+\t(duplicate_decls): Copy DECL_ACCESS. Fix formatting.\n+\t(cp_finish_decl): Use determine_local_discriminator.\n+\t(save_function_data): Drop x_local_names.\n+\t(finish_function): Drop local_names.\n+\t* decl2.c (finish_anon_union): Use determine_local_disciminator.\n+\t* mangle.c (write_unnamed_type_name): Use\n+\tdiscriminator_for_local_entity.\n+\t(local_class_index): Delete.\n+\t(discriminator_for_local_entity): Reimplement.\n+\t(write_local_name): Adjust discriminator code.\n+\t* name-lookup.c (do_pushtag): Call determine_local_discrimiator.\n+\t* semantics.c (finish_omp_threadprivate): Drop DECL_DISCRIMINATOR\n+\thandling.\n+\t* class.c (local_classes): Delete.\n+\t(init_class_processing): Don't init it.\n+\n 2018-11-01  Martin Liska  <mliska@suse.cz>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "0b50f67157882f036f0fd741a99843ff241e74cb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -111,10 +111,6 @@ static class_stack_node_t current_class_stack;\n /* The size of the largest empty class seen in this translation unit.  */\n static GTY (()) tree sizeof_biggest_empty_class;\n \n-/* An array of all local classes present in this translation unit, in\n-   declaration order.  */\n-vec<tree, va_gc> *local_classes;\n-\n static tree get_vfield_name (tree);\n static void finish_struct_anon (tree);\n static tree get_vtable_name (tree);\n@@ -7431,7 +7427,6 @@ init_class_processing (void)\n   current_class_stack_size = 10;\n   current_class_stack\n     = XNEWVEC (struct class_stack_node, current_class_stack_size);\n-  vec_alloc (local_classes, 8);\n   sizeof_biggest_empty_class = size_zero_node;\n \n   ridpointers[(int) RID_PUBLIC] = access_public_node;"}, {"sha": "6d49744b8301d53c2453010c3309351f5873155d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -1793,7 +1793,7 @@ struct GTY(()) language_function {\n   hash_table<named_label_hash> *x_named_labels;\n \n   cp_binding_level *bindings;\n-  vec<tree, va_gc> *x_local_names;\n+\n   /* Tracking possibly infinite loops.  This is a vec<tree> only because\n      vec<bool> doesn't work with gtype.  */\n   vec<tree, va_gc> *infinite_loops;\n@@ -2527,7 +2527,7 @@ struct GTY(()) lang_decl_base {\n   unsigned friend_or_tls : 1;\t\t   /* var, fn, type or template */\n   unsigned unknown_bound_p : 1;\t\t   /* var */\n   unsigned odr_used : 1;\t\t   /* var or fn */\n-  unsigned u2sel : 1;\n+  unsigned spare : 1;\n   unsigned concept_p : 1;                  /* applies to vars and functions */\n   unsigned var_declared_inline_p : 1;\t   /* var */\n   unsigned dependent_init_p : 1;\t   /* var */\n@@ -2555,17 +2555,12 @@ struct GTY(()) lang_decl_min {\n      DECL_TEMPLATE_INFO.  */\n   tree template_info;\n \n-  union lang_decl_u2 {\n-    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n-       THUNK_VIRTUAL_OFFSET.\n-       In a VAR_DECL for which DECL_HAS_VALUE_EXPR_P holds,\n-       this is DECL_CAPTURED_VARIABLE.\n-       Otherwise this is DECL_ACCESS.  */\n-    tree GTY ((tag (\"0\"))) access;\n-\n-    /* For TREE_STATIC VAR_DECL in function, this is DECL_DISCRIMINATOR.  */\n-    int GTY ((tag (\"1\"))) discriminator;\n-  } GTY ((desc (\"%0.u.base.u2sel\"))) u2;\n+  /* In a DECL_THUNK_P FUNCTION_DECL, this is THUNK_VIRTUAL_OFFSET.\n+     In a lambda-capture proxy VAR_DECL, this is DECL_CAPTURED_VARIABLE.\n+     In a function-scope TREE_STATIC VAR_DECL or IMPLICIT_TYPEDEF_P TYPE_DECL,\n+     this is DECL_DISCRIMINATOR.\n+     Otherwise, in a class-scope DECL, this is DECL_ACCESS.   */\n+  tree access;\n };\n \n /* Additional DECL_LANG_SPECIFIC information for functions.  */\n@@ -2721,12 +2716,6 @@ struct GTY(()) lang_decl {\n     lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n   &lt->u.decomp; })\n \n-#define LANG_DECL_U2_CHECK(NODE, TF) __extension__\t\t\\\n-({  struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n-    if (!LANG_DECL_HAS_MIN (NODE) || lt->u.base.u2sel != TF)\t\\\n-      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n-    &lt->u.min.u2; })\n-\n #else\n \n #define LANG_DECL_MIN_CHECK(NODE) \\\n@@ -2744,9 +2733,6 @@ struct GTY(()) lang_decl {\n #define LANG_DECL_DECOMP_CHECK(NODE) \\\n   (&DECL_LANG_SPECIFIC (NODE)->u.decomp)\n \n-#define LANG_DECL_U2_CHECK(NODE, TF) \\\n-  (&DECL_LANG_SPECIFIC (NODE)->u.min.u2)\n-\n #endif /* ENABLE_TREE_CHECKING */\n \n /* For a FUNCTION_DECL or a VAR_DECL, the language linkage for the\n@@ -2854,15 +2840,13 @@ struct GTY(()) lang_decl {\n \t CLONE = DECL_CHAIN (CLONE))\n \n /* Nonzero if NODE has DECL_DISCRIMINATOR and not DECL_ACCESS.  */\n-#define DECL_DISCRIMINATOR_P(NODE)\t\\\n-  (VAR_P (NODE) && DECL_FUNCTION_SCOPE_P (NODE))\n+#define DECL_DISCRIMINATOR_P(NODE)\t\t\t\t\\\n+  (((TREE_CODE (NODE) == VAR_DECL && TREE_STATIC (NODE))\t\\\n+    || DECL_IMPLICIT_TYPEDEF_P (NODE))\t\t\t\t\\\n+   && DECL_FUNCTION_SCOPE_P (NODE))\n \n /* Discriminator for name mangling.  */\n-#define DECL_DISCRIMINATOR(NODE) (LANG_DECL_U2_CHECK (NODE, 1)->discriminator)\n-\n-/* True iff DECL_DISCRIMINATOR is set for a DECL_DISCRIMINATOR_P decl.  */\n-#define DECL_DISCRIMINATOR_SET_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE) && DECL_LANG_SPECIFIC (NODE)->u.base.u2sel == 1)\n+#define DECL_DISCRIMINATOR(NODE) (LANG_DECL_MIN_CHECK (NODE)->access)\n \n /* The index of a user-declared parameter in its function, starting at 1.\n    All artificial parameters will have index 0.  */\n@@ -3334,7 +3318,7 @@ struct GTY(()) lang_decl {\n \n /* For a lambda capture proxy, its captured variable.  */\n #define DECL_CAPTURED_VARIABLE(NODE) \\\n-  (LANG_DECL_U2_CHECK (NODE, 0)->access)\n+  (LANG_DECL_MIN_CHECK (NODE)->access)\n \n /* For a VAR_DECL, indicates that the variable is actually a\n    non-static data member of anonymous union that has been promoted to\n@@ -4509,7 +4493,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    For example, if a member that would normally be public in a\n    derived class is made protected, then the derived class and the\n    protected_access_node will appear in the DECL_ACCESS for the node.  */\n-#define DECL_ACCESS(NODE) (LANG_DECL_U2_CHECK (NODE, 0)->access)\n+#define DECL_ACCESS(NODE) (LANG_DECL_MIN_CHECK (NODE)->access)\n \n /* Nonzero if the FUNCTION_DECL is a global constructor.  */\n #define DECL_GLOBAL_CTOR_P(NODE) \\\n@@ -4846,7 +4830,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    binfos.)  */\n \n #define THUNK_VIRTUAL_OFFSET(DECL) \\\n-  (LANG_DECL_U2_CHECK (FUNCTION_DECL_CHECK (DECL), 0)->access)\n+  (LANG_DECL_MIN_CHECK (FUNCTION_DECL_CHECK (DECL))->access)\n \n /* A thunk which is equivalent to another thunk.  */\n #define THUNK_ALIAS(DECL) \\\n@@ -5240,10 +5224,6 @@ struct local_specialization_stack\n \n extern int current_class_depth;\n \n-/* An array of all local classes present in this translation unit, in\n-   declaration order.  */\n-extern GTY(()) vec<tree, va_gc> *local_classes;\n-\n /* in decl.c */\n \n /* An array of static vars & fns.  */\n@@ -6303,6 +6283,7 @@ extern void pop_switch\t\t\t\t(void);\n extern void note_break_stmt\t\t\t(void);\n extern bool note_iteration_stmt_body_start\t(void);\n extern void note_iteration_stmt_body_end\t(bool);\n+extern void determine_local_discriminator\t(tree);\n extern tree make_lambda_name\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree, bool = true);\n extern bool maybe_version_functions\t\t(tree, tree, bool);"}, {"sha": "23fcf6b04715a234615dd7c9f397fbc2e9839d40", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 55, "deletions": 41, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -66,7 +66,6 @@ static const char *redeclaration_error_message (tree, tree);\n \n static int decl_jump_unsafe (tree);\n static void require_complete_types_for_parms (tree);\n-static void push_local_name (tree);\n static tree grok_reference_init (tree, tree, tree, int);\n static tree grokvardecl (tree, tree, tree, const cp_decl_specifier_seq *,\n \t\t\t int, int, int, bool, int, tree);\n@@ -138,8 +137,6 @@ static void expand_static_init (tree, tree);\n \n tree cp_global_trees[CPTI_MAX];\n \n-#define local_names cp_function_chain->x_local_names\n-\n /* A list of objects which have constructors or destructors\n    which reside in the global scope.  The decl is stored in\n    the TREE_VALUE slot and the initializer is stored\n@@ -871,40 +868,57 @@ create_implicit_typedef (tree name, tree type)\n   return decl;\n }\n \n-/* Remember a local name for name-mangling purposes.  */\n+/* Function-scope local entities that need discriminators.  Each entry\n+   is a {decl,name} pair.  VAR_DECLs for anon unions get their name\n+   smashed, so we cannot rely on DECL_NAME.  */\n \n-static void\n-push_local_name (tree decl)\n-{\n-  size_t i, nelts;\n-  tree t, name;\n+static GTY((deletable)) vec<tree, va_gc> *local_entities;\n \n-  timevar_start (TV_NAME_LOOKUP);\n+/* Determine the mangling discriminator of local DECL.  There are\n+   generally very few of these in any particular function.  */\n \n-  name = DECL_NAME (decl);\n+void\n+determine_local_discriminator (tree decl)\n+{\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  retrofit_lang_decl (decl);\n+  tree ctx = DECL_CONTEXT (decl);\n+  tree name = (TREE_CODE (decl) == TYPE_DECL\n+\t       && TYPE_UNNAMED_P (TREE_TYPE (decl))\n+\t       ? NULL_TREE : DECL_NAME (decl));\n+  size_t nelts = vec_safe_length (local_entities);\n+  for (size_t i = 0; i < nelts; i += 2)\n+    {\n+      tree *pair = &(*local_entities)[i];\n+      tree d = pair[0];\n+      tree n = pair[1];\n+      gcc_checking_assert (d != decl);\n+      if (name == n\n+\t  && TREE_CODE (decl) == TREE_CODE (d)\n+\t  && ctx == DECL_CONTEXT (d))\n+\t{\n+\t  tree disc = integer_one_node;\n+\t  if (DECL_DISCRIMINATOR (d))\n+\t    disc = build_int_cst (TREE_TYPE (disc),\n+\t\t\t\t  TREE_INT_CST_LOW (DECL_DISCRIMINATOR (d)) + 1);\n+\t  DECL_DISCRIMINATOR (decl) = disc;\n+\t  /* Replace the saved decl.  */\n+\t  pair[0] = decl;\n+\t  decl = NULL_TREE;\n+\t  break;\n+\t}\n+    }\n \n-  nelts = vec_safe_length (local_names);\n-  for (i = 0; i < nelts; i++)\n+  if (decl)\n     {\n-      t = (*local_names)[i];\n-      if (DECL_NAME (t) == name)\n-\t{\n-\t  retrofit_lang_decl (decl);\n-\t  DECL_LANG_SPECIFIC (decl)->u.base.u2sel = 1;\n-\t  if (DECL_DISCRIMINATOR_SET_P (t))\n-\t    DECL_DISCRIMINATOR (decl) = DECL_DISCRIMINATOR (t) + 1;\n-\t  else\n-\t    DECL_DISCRIMINATOR (decl) = 1;\n-\n-\t  (*local_names)[i] = decl;\n-\t  timevar_stop (TV_NAME_LOOKUP);\n-\t  return;\n-\t}\n+      vec_safe_reserve (local_entities, 2);\n+      local_entities->quick_push (decl);\n+      local_entities->quick_push (name);\n     }\n \n-  vec_safe_push (local_names, decl);\n-  timevar_stop (TV_NAME_LOOKUP);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n+\n \f\n /* Subroutine of duplicate_decls: return truthvalue of whether\n    or not types of these decls match.\n@@ -2360,8 +2374,7 @@ next_arg:;\n \n       if (LANG_DECL_HAS_MIN (newdecl))\n \t{\n-\t  DECL_LANG_SPECIFIC (newdecl)->u.min.u2 =\n-\t    DECL_LANG_SPECIFIC (olddecl)->u.min.u2;\n+\t  DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);\n \t  if (DECL_TEMPLATE_INFO (newdecl))\n \t    {\n \t      new_template_info = DECL_TEMPLATE_INFO (newdecl);\n@@ -2397,15 +2410,15 @@ next_arg:;\n \n       /* Merge parameter attributes. */\n       tree oldarg, newarg;\n-      for (oldarg = DECL_ARGUMENTS(olddecl), \n-               newarg = DECL_ARGUMENTS(newdecl);\n+      for (oldarg = DECL_ARGUMENTS(olddecl),  newarg = DECL_ARGUMENTS(newdecl);\n            oldarg && newarg;\n-           oldarg = DECL_CHAIN(oldarg), newarg = DECL_CHAIN(newarg)) {\n+           oldarg = DECL_CHAIN(oldarg), newarg = DECL_CHAIN(newarg))\n+\t{\n           DECL_ATTRIBUTES (newarg)\n-              = (*targetm.merge_decl_attributes) (oldarg, newarg);\n+\t    = (*targetm.merge_decl_attributes) (oldarg, newarg);\n           DECL_ATTRIBUTES (oldarg) = DECL_ATTRIBUTES (newarg);\n-      }\n-      \n+\t}\n+\n       if (DECL_TEMPLATE_INSTANTIATION (olddecl)\n \t  && !DECL_TEMPLATE_INSTANTIATION (newdecl))\n \t{\n@@ -7135,7 +7148,11 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  && TREE_STATIC (decl)\n \t  && !DECL_ARTIFICIAL (decl))\n \t{\n-\t  push_local_name (decl);\n+\t  /* The variable holding an anonymous union will have had its\n+\t     discriminator set in finish_anon_union, after which it's\n+\t     NAME will have been cleared.  */\n+\t  if (DECL_NAME (decl))\n+\t    determine_local_discriminator (decl);\n \t  /* Normally has_forced_label_in_static is set during GIMPLE\n \t     lowering, but [cd]tors are never actually compiled directly.\n \t     We need to set this early so we can deal with the label\n@@ -15620,7 +15637,6 @@ save_function_data (tree decl)\n   /* Clear out the bits we don't need.  */\n   f->base.x_stmt_tree.x_cur_stmt_list = NULL;\n   f->bindings = NULL;\n-  f->x_local_names = NULL;\n   f->base.local_typedefs = NULL;\n }\n \n@@ -16125,8 +16141,6 @@ finish_function (bool inline_p)\n       f->extern_decl_map = NULL;\n       f->infinite_loops = NULL;\n     }\n-  /* Clear out the bits we don't need.  */\n-  local_names = NULL;\n \n   /* We're leaving the context of this function, so zap cfun.  It's still in\n      DECL_STRUCT_FUNCTION, and we'll restore it in tree_rest_of_compilation.  */"}, {"sha": "a163558af54710b148e49818a4c8feeaf05e86ae", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -1666,7 +1666,11 @@ finish_anon_union (tree anon_union_decl)\n       DECL_NAME (anon_union_decl) = DECL_NAME (main_decl);\n       maybe_commonize_var (anon_union_decl);\n       if (TREE_STATIC (anon_union_decl) || DECL_EXTERNAL (anon_union_decl))\n-\tmangle_decl (anon_union_decl);\n+\t{\n+\t  if (DECL_DISCRIMINATOR_P (anon_union_decl))\n+\t    determine_local_discriminator (anon_union_decl);\n+\t  mangle_decl (anon_union_decl);\n+\t}\n       DECL_NAME (anon_union_decl) = NULL_TREE;\n     }\n "}, {"sha": "690d0bbdbd3bf9172adf06af80cf539d8d6dc707", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 17, "deletions": 47, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -233,7 +233,6 @@ static void write_discriminator (const int);\n static void write_local_name (tree, const tree, const tree);\n static void dump_substitution_candidates (void);\n static tree mangle_decl_string (const tree);\n-static int local_class_index (tree);\n static void maybe_check_abi_tags (tree, tree = NULL_TREE, int = 10);\n static bool equal_abi_tags (tree, tree);\n \n@@ -1642,7 +1641,7 @@ write_unnamed_type_name (const tree type)\n   MANGLE_TRACE_TREE (\"unnamed-type-name\", type);\n \n   if (TYPE_FUNCTION_SCOPE_P (type))\n-    discriminator = local_class_index (type);\n+    discriminator = discriminator_for_local_entity (TYPE_NAME (type));\n   else if (TYPE_CLASS_SCOPE_P (type))\n     discriminator = nested_anon_class_index (type);\n   else\n@@ -1913,58 +1912,25 @@ write_special_name_destructor (const tree dtor)\n     }\n }\n \n-/* Scan the vector of local classes and return how many others with the\n-   same name (or same no name) and context precede ENTITY.  */\n-\n-static int\n-local_class_index (tree entity)\n-{\n-  int ix, discriminator = 0;\n-  tree name = (TYPE_UNNAMED_P (entity) ? NULL_TREE\n-\t       : TYPE_IDENTIFIER (entity));\n-  tree ctx = TYPE_CONTEXT (entity);\n-  for (ix = 0; ; ix++)\n-    {\n-      tree type = (*local_classes)[ix];\n-      if (type == entity)\n-\treturn discriminator;\n-      if (TYPE_CONTEXT (type) == ctx\n-\t  && (name ? TYPE_IDENTIFIER (type) == name\n-\t      : TYPE_UNNAMED_P (type)))\n-\t++discriminator;\n-    }\n-  gcc_unreachable ();\n-}\n-\n /* Return the discriminator for ENTITY appearing inside\n-   FUNCTION.  The discriminator is the lexical ordinal of VAR among\n-   entities with the same name in the same FUNCTION.  */\n+   FUNCTION.  The discriminator is the lexical ordinal of VAR or TYPE among\n+   entities with the same name and kind in the same FUNCTION.  */\n \n static int\n discriminator_for_local_entity (tree entity)\n {\n-  if (DECL_DISCRIMINATOR_P (entity))\n+  if (!DECL_LANG_SPECIFIC (entity))\n     {\n-      if (DECL_DISCRIMINATOR_SET_P (entity))\n-\treturn DECL_DISCRIMINATOR (entity);\n-      else\n-\t/* The first entity with a particular name doesn't get\n-\t   DECL_DISCRIMINATOR set up.  */\n-\treturn 0;\n-    }\n-  else if (TREE_CODE (entity) == TYPE_DECL)\n-    {\n-      /* Scan the list of local classes.  */\n-      entity = TREE_TYPE (entity);\n-\n-      /* Lambdas and unnamed types have their own discriminators.  */\n-      if (LAMBDA_TYPE_P (entity) || TYPE_UNNAMED_P (entity))\n-\treturn 0;\n-\n-      return local_class_index (entity);\n+      /* Some decls, like __FUNCTION__, don't need a discriminator.  */\n+      gcc_checking_assert (DECL_ARTIFICIAL (entity));\n+      return 0;\n     }\n+  else if (tree disc = DECL_DISCRIMINATOR (entity))\n+    return TREE_INT_CST_LOW (disc);\n   else\n-    gcc_unreachable ();\n+    /* The first entity with a particular name doesn't get\n+       DECL_DISCRIMINATOR set up.  */\n+    return 0;\n }\n \n /* Return the discriminator for STRING, a string literal used inside\n@@ -2062,7 +2028,11 @@ write_local_name (tree function, const tree local_entity,\n \t from <local-name>, so it doesn't try to process the enclosing\n \t function scope again.  */\n       write_name (entity, /*ignore_local_scope=*/1);\n-      write_discriminator (discriminator_for_local_entity (local_entity));\n+      if (DECL_DISCRIMINATOR_P (local_entity)\n+\t  && !(TREE_CODE (local_entity) == TYPE_DECL\n+\t       && (LAMBDA_TYPE_P (TREE_TYPE (local_entity))\n+\t\t   || TYPE_UNNAMED_P (TREE_TYPE (local_entity)))))\n+\twrite_discriminator (discriminator_for_local_entity (local_entity));\n     }\n }\n "}, {"sha": "ad562ba219e41b4e70a031b67dc015c989608266", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -6879,7 +6879,7 @@ do_pushtag (tree name, tree type, tag_scope scope)\n \t    }\n \t  /* Lambdas use LAMBDA_EXPR_DISCRIMINATOR instead.  */\n \t  else if (!LAMBDA_TYPE_P (type))\n-\t    vec_safe_push (local_classes, type);\n+\t    determine_local_discriminator (TYPE_NAME (type));\n \t}\n     }\n "}, {"sha": "0d9673db1c5691be4d854a2d29f71e2b4786f69a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -7566,14 +7566,7 @@ finish_omp_threadprivate (tree vars)\n \t{\n \t  /* Allocate a LANG_SPECIFIC structure for V, if needed.  */\n \t  if (DECL_LANG_SPECIFIC (v) == NULL)\n-\t    {\n-\t      retrofit_lang_decl (v);\n-\n-\t      /* Make sure that DECL_DISCRIMINATOR_P continues to be true\n-\t\t after the allocation of the lang_decl structure.  */\n-\t      if (DECL_DISCRIMINATOR_P (v))\n-\t\tDECL_LANG_SPECIFIC (v)->u.base.u2sel = 1;\n-\t    }\n+\t    retrofit_lang_decl (v);\n \n \t  if (! CP_DECL_THREAD_LOCAL_P (v))\n \t    {"}, {"sha": "13e1a1c351920e86f27c3f2ea4b4faf9bcd3f6f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -1,3 +1,7 @@\n+2018-11-01  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/abi/anon5.C: New.\n+\n 2018-11-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR d/87824"}, {"sha": "4e724d40128f9428330a3fb9f66079cd10be415b", "filename": "gcc/testsuite/g++.dg/abi/anon5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f927f4a668aeb167a673f916cc5cbfb978a560/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fanon5.C?ref=41f927f4a668aeb167a673f916cc5cbfb978a560", "patch": "@@ -0,0 +1,14 @@\n+// anon-union decls may need a discriminator\n+\n+void f ()\n+{\n+  { static int bob; }\n+  { static union {int bob;};}\n+  { static int bob; }\n+  { static union {int bob;}; }\n+}\n+\n+// { dg-final { scan-assembler {_ZZ1fvE3bob[^_]} } }\n+// { dg-final { scan-assembler {_ZZ1fvE3bob_0} } }\n+// { dg-final { scan-assembler {_ZZ1fvE3bob_1} } }\n+// { dg-final { scan-assembler {_ZZ1fvE3bob_2} } }"}]}