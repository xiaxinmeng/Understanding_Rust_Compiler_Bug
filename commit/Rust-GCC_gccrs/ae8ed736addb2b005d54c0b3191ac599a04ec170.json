{"sha": "ae8ed736addb2b005d54c0b3191ac599a04ec170", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU4ZWQ3MzZhZGRiMmIwMDVkNTRjMGIzMTkxYWM1OTlhMDRlYzE3MA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-05-13T19:52:42Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-05-18T20:26:06Z"}, "message": "c++: Implement DR 1512, Pointer comparison vs qual convs [PR87699]\n\nThis patch resolves DR 1512 (and, by turn, DR 583).  This entails:\n\n1) Relational pointer comparisons against null pointer constants have\n   been made ill-formed:\n\n   void f(char *p) {\n      if (p > 0)\n\t// ...\n   }\n\n   was always invalid in C but was -- accidentally -- allowed in C++.\n\n2) This was ill-formed:\n\n   bool foo(int** x, const int** y) {\n     return x < y;\n   }\n\n   because 'int**' couldn't be converted to 'const int**'.  This was\n   fixed by re-defining a generic composite pointer type.  The composite\n   type of these two pointers will be 'const int *const *', to which\n   both pointers can be converted.\n\n3) The overload descriptions for built-in operators were adjusted,\n   because objects of type std::nullptr_t cannot be used with relational\n   operators any more.\n\nI fixed 1) by adjusting cp_build_binary_op; we already had a warning\nfor it so made it a hard error now.\n\nThen 2) required tweaking composite_pointer_type_r.  [expr.type] defines\nthe composite pointer type by using the \"cv-combined type.\"  We didn't\nimplement the [conv.qual]/3.3 part; previously the composite type of\n'int**' and 'const int**' was 'const int**', so this didn't compile:\n\n    void f(const int **p, int **q) {\n      true ? p : q;\n    }\n\nI wrote a more extensive test for this which uses decltype and some\ntemplate magic to check the composite type, see composite-ptr-type.C.\nWe still don't handle everything that [expr.type] requires us to,\nbut it's pretty close.\n\nAnd finally 3) was handled in add_builtin_candidate.  Turned out we\nweren't creating built-in operator candidates when the type was\nstd::nullptr_t at all.  We should, for == and !=.  Tested in builtin4.C.\nIn passing, I'm fixing some of the comments too.\n\n\tDR 1512\n\tPR c++/87699\n\t* call.c (add_builtin_candidate) <case EQ_EXPR>: Create candidate\n\toperator functions when type is std::nullptr_t for ==/!=.\n\t* typeck.c (composite_pointer_type_r): Add bool a * parameter.  Use it\n\tto maybe add \"const\" to the pointer type.\n\t(composite_pointer_type): Update the call to composite_pointer_type_r.\n\t(cp_build_binary_op): Turn two warning_at into error_at.  Print the\n\ttypes.\n\n\t* g++.dg/cpp0x/constexpr-array-ptr10.C: Change dg-warning to dg-error\n\tand adjust the expected messages in dg-error.\n\t* g++.dg/expr/composite-ptr-type.C: New test.\n\t* g++.dg/expr/ptr-comp1.C: New test.\n\t* g++.dg/expr/ptr-comp2.C: New test.\n\t* g++.dg/expr/ptr-comp3.C: New test.\n\t* g++.dg/overload/builtin4.C: New test.\n\t* g++.dg/warn/Wextra-3.C: Change dg-warning to dg-error.", "tree": {"sha": "3dce991ddf0a96e1a585b86ca63233d79f4296d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dce991ddf0a96e1a585b86ca63233d79f4296d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae8ed736addb2b005d54c0b3191ac599a04ec170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae8ed736addb2b005d54c0b3191ac599a04ec170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae8ed736addb2b005d54c0b3191ac599a04ec170", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae8ed736addb2b005d54c0b3191ac599a04ec170/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "295790712f1168d9d540c240446b167592b77aca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/295790712f1168d9d540c240446b167592b77aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/295790712f1168d9d540c240446b167592b77aca"}], "stats": {"total": 374, "additions": 287, "deletions": 87}, "files": [{"sha": "52422cef10f732d3079b50a6b0fb18a2e8ea27e1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -1,3 +1,15 @@\n+2020-05-18  Marek Polacek  <polacek@redhat.com>\n+\n+\tDR 1512\n+\tPR c++/87699\n+\t* call.c (add_builtin_candidate) <case EQ_EXPR>: Create candidate\n+\toperator functions when type is std::nullptr_t for ==/!=.\n+\t* typeck.c (composite_pointer_type_r): Add a bool * parameter.  Use it\n+\tto maybe add \"const\" to the pointer type.\n+\t(composite_pointer_type): Update the call to composite_pointer_type_r.\n+\t(cp_build_binary_op): Turn two warning_at into error_at.  Print the\n+\ttypes.\n+\n 2020-05-18  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (build_over_call): Remove unnecessary"}, {"sha": "264f4a126e6f167426a2b028d4fe9abcb01c8477", "filename": "gcc/cp/call.c", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -2713,8 +2713,9 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \n \t     T&      operator*(T*);\n \n-   8 For every function type T, there exist candidate operator functions of\n-     the form\n+\n+   8 For every function type T that does not have cv-qualifiers or\n+     a ref-qualifier, there exist candidate operator functions of the form\n \t     T&      operator*(T*);  */\n \n     case INDIRECT_REF:\n@@ -2727,8 +2728,8 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n /* 9 For every type T, there exist candidate operator functions of the form\n \t     T*      operator+(T*);\n \n-   10For  every  promoted arithmetic type T, there exist candidate operator\n-     functions of the form\n+   10 For every floating-point or promoted integral type T, there exist\n+      candidate operator functions of the form\n \t     T       operator+(T);\n \t     T       operator-(T);  */\n \n@@ -2741,19 +2742,19 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \tbreak;\n       return;\n \n-/* 11For every promoted integral type T,  there  exist  candidate  operator\n-     functions of the form\n+/* 11 For every promoted integral type T,  there  exist  candidate  operator\n+      functions of the form\n \t     T       operator~(T);  */\n \n     case BIT_NOT_EXPR:\n       if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type1))\n \tbreak;\n       return;\n \n-/* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1\n-     is the same type as C2 or is a derived class of C2, T  is  a  complete\n-     object type or a function type, and CV1 and CV2 are cv-qualifier-seqs,\n-     there exist candidate operator functions of the form\n+/* 12 For every quintuple (C1, C2, T, CV1, CV2), where C2 is a class type, C1\n+     is the same type as C2 or is a derived class of C2, and T is an object\n+     type or a function type there exist candidate operator functions of the\n+     form\n \t     CV12 T& operator->*(CV1 C1*, CV2 T C2::*);\n      where CV12 is the union of CV1 and CV2.  */\n \n@@ -2770,8 +2771,9 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t}\n       return;\n \n-/* 13For every pair of promoted arithmetic types L and R, there exist  can-\n-     didate operator functions of the form\n+/* 13 For every pair of types L and R, where each of L and R is a floating-point\n+      or promoted integral type, there exist candidate operator functions of the\n+      form\n \t     LR      operator*(L, R);\n \t     LR      operator/(L, R);\n \t     LR      operator+(L, R);\n@@ -2782,34 +2784,33 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t     bool    operator>=(L, R);\n \t     bool    operator==(L, R);\n \t     bool    operator!=(L, R);\n-     where  LR  is  the  result of the usual arithmetic conversions between\n-     types L and R.\n+      where  LR  is  the  result of the usual arithmetic conversions between\n+      types L and R.\n \n-     For every integral type T there exists a candidate operator function of\n-     the form\n+   14 For every integral type T there exists a candidate operator function of\n+      the form\n \n        std::strong_ordering operator<=>(T, T);\n \n-     For every pair of floating-point types L and R, there exists a candidate\n-     operator function of the form\n+   15 For every pair of floating-point types L and R, there exists a candidate\n+      operator function of the form\n \n        std::partial_ordering operator<=>(L, R);\n \n-   14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-\n-     unqualified  complete  object  type and I is a promoted integral type,\n-     there exist candidate operator functions of the form\n-\t     T*      operator+(T*, I);\n-\t     T&      operator[](T*, I);\n-\t     T*      operator-(T*, I);\n-\t     T*      operator+(I, T*);\n-\t     T&      operator[](I, T*);\n+   16 For every cv-qualified or cv-unqualified object type T there exist\n+      candidate operator functions of the form\n+\t     T*      operator+(T*, std::ptrdiff_t);\n+\t     T&      operator[](T*, std::ptrdiff_t);\n+\t     T*      operator-(T*, std::ptrdiff_t);\n+\t     T*      operator+(std::ptrdiff_t, T*);\n+\t     T&      operator[](std::ptrdiff_t, T*);\n \n-   15For every T, where T is a pointer to complete object type, there exist\n-     candidate operator functions of the form112)\n-\t     ptrdiff_t operator-(T, T);\n+   17 For every T, where T is a pointer to object type, there exist candidate\n+      operator functions of the form\n+\t     std::ptrdiff_t operator-(T, T);\n \n-   16For every pointer or enumeration type T, there exist candidate operator\n-     functions of the form\n+   18 For every T, where T is an enumeration type or a pointer type, there\n+      exist candidate operator functions of the form\n \t     bool    operator<(T, T);\n \t     bool    operator>(T, T);\n \t     bool    operator<=(T, T);\n@@ -2818,13 +2819,12 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t     bool    operator!=(T, T);\n \t     R       operator<=>(T, T);\n \n-     where R is the result type specified in [expr.spaceship].\n+      where R is the result type specified in [expr.spaceship].\n \n-   17For every pointer to member type T,  there  exist  candidate  operator\n-     functions of the form\n+   19 For every T, where T is a pointer-to-member type or std::nullptr_t,\n+      there exist candidate operator functions of the form\n \t     bool    operator==(T, T);\n-\t     bool    operator!=(T, T);\n-\t     std::strong_equality operator<=>(T, T);  */\n+\t     bool    operator!=(T, T);  */\n \n     case MINUS_EXPR:\n       if (TYPE_PTROB_P (type1) && TYPE_PTROB_P (type2))\n@@ -2852,6 +2852,8 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n       if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n \t  || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2)))\n \tbreak;\n+      if (NULLPTR_TYPE_P (type1) && NULLPTR_TYPE_P (type2))\n+\tbreak;\n       if (TYPE_PTRMEM_P (type1) && null_ptr_cst_p (args[1]))\n \t{\n \t  type2 = type1;"}, {"sha": "768c62281f486ee2b34e3e2ce252056cb88434f5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -478,11 +478,12 @@ composite_pointer_error (const op_location_t &location,\n }\n \n /* Subroutine of composite_pointer_type to implement the recursive\n-   case.  See that function for documentation of the parameters.  */\n+   case.  See that function for documentation of the parameters.  And ADD_CONST\n+   is used to track adding \"const\" where needed.  */\n \n static tree\n composite_pointer_type_r (const op_location_t &location,\n-\t\t\t  tree t1, tree t2, \n+\t\t\t  tree t1, tree t2, bool *add_const,\n \t\t\t  composite_pointer_operation operation,\n \t\t\t  tsubst_flags_t complain)\n {\n@@ -503,20 +504,17 @@ composite_pointer_type_r (const op_location_t &location,\n       pointee2 = TYPE_PTRMEM_POINTED_TO_TYPE (t2);\n     }\n \n-  /* [expr.rel]\n+  /* [expr.type]\n \n-     Otherwise, the composite pointer type is a pointer type\n-     similar (_conv.qual_) to the type of one of the operands,\n-     with a cv-qualification signature (_conv.qual_) that is the\n-     union of the cv-qualification signatures of the operand\n-     types.  */\n+     If T1 and T2 are similar types, the result is the cv-combined type of\n+     T1 and T2.  */\n   if (same_type_ignoring_top_level_qualifiers_p (pointee1, pointee2))\n     result_type = pointee1;\n   else if ((TYPE_PTR_P (pointee1) && TYPE_PTR_P (pointee2))\n \t   || (TYPE_PTRMEM_P (pointee1) && TYPE_PTRMEM_P (pointee2)))\n     {\n       result_type = composite_pointer_type_r (location, pointee1, pointee2,\n-\t\t\t\t\t      operation, complain);\n+\t\t\t\t\t      add_const, operation, complain);\n       if (result_type == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -529,9 +527,18 @@ composite_pointer_type_r (const op_location_t &location,\n \treturn error_mark_node;\n       result_type = void_type_node;\n     }\n+  const int q1 = cp_type_quals (pointee1);\n+  const int q2 = cp_type_quals (pointee2);\n+  const int quals = q1 | q2;\n   result_type = cp_build_qualified_type (result_type,\n-\t\t\t\t\t (cp_type_quals (pointee1)\n-\t\t\t\t\t  | cp_type_quals (pointee2)));\n+\t\t\t\t\t (quals | (*add_const\n+\t\t\t\t\t\t   ? TYPE_QUAL_CONST\n+\t\t\t\t\t\t   : TYPE_UNQUALIFIED)));\n+  /* The cv-combined type can add \"const\" as per [conv.qual]/3.3 (except for\n+     the TLQ).  The reason is that both T1 and T2 can then be converted to the\n+     cv-combined type of T1 and T2.  */\n+  if (quals != q1 || quals != q2)\n+    *add_const = true;\n   /* If the original types were pointers to members, so is the\n      result.  */\n   if (TYPE_PTRMEM_P (t1))\n@@ -556,7 +563,7 @@ composite_pointer_type_r (const op_location_t &location,\n   return build_type_attribute_variant (result_type, attributes);\n }\n \n-/* Return the composite pointer type (see [expr.rel]) for T1 and T2.\n+/* Return the composite pointer type (see [expr.type]) for T1 and T2.\n    ARG1 and ARG2 are the values with those types.  The OPERATION is to\n    describe the operation between the pointer types,\n    in case an error occurs.\n@@ -573,7 +580,7 @@ composite_pointer_type (const op_location_t &location,\n   tree class1;\n   tree class2;\n \n-  /* [expr.rel]\n+  /* [expr.type]\n \n      If one operand is a null pointer constant, the composite pointer\n      type is the type of the other operand.  */\n@@ -584,10 +591,10 @@ composite_pointer_type (const op_location_t &location,\n \n   /* We have:\n \n-       [expr.rel]\n+       [expr.type]\n \n-       If one of the operands has type \"pointer to cv1 void*\", then\n-       the other has type \"pointer to cv2T\", and the composite pointer\n+       If one of the operands has type \"pointer to cv1 void\", then\n+       the other has type \"pointer to cv2 T\", and the composite pointer\n        type is \"pointer to cv12 void\", where cv12 is the union of cv1\n        and cv2.\n \n@@ -719,7 +726,9 @@ composite_pointer_type (const op_location_t &location,\n         }\n     }\n \n-  return composite_pointer_type_r (location, t1, t2, operation, complain);\n+  bool add_const = false;\n+  return composite_pointer_type_r (location, t1, t2, &add_const, operation,\n+\t\t\t\t   complain);\n }\n \n /* Return the merged type of two types.\n@@ -5316,17 +5325,19 @@ cp_build_binary_op (const op_location_t &location,\n \t\t\t\t\t      CPO_COMPARISON, complain);\n       else if (code0 == POINTER_TYPE && null_ptr_cst_p (orig_op1))\n \t{\n-\t  result_type = type0;\n-\t  if (extra_warnings && (complain & tf_warning))\n-\t    warning_at (location, OPT_Wextra,\n-\t\t\t\"ordered comparison of pointer with integer zero\");\n+\t  /* Core Issue 1512 made this ill-formed.  */\n+\t  if (complain & tf_error)\n+\t    error_at (location, \"ordered comparison of pointer with \"\n+\t\t      \"integer zero (%qT and %qT)\", type0, type1);\n+\t  return error_mark_node;\n \t}\n       else if (code1 == POINTER_TYPE && null_ptr_cst_p (orig_op0))\n \t{\n-\t  result_type = type1;\n-\t  if (extra_warnings && (complain & tf_warning))\n-\t    warning_at (location, OPT_Wextra,\n-\t\t\t\"ordered comparison of pointer with integer zero\");\n+\t  /* Core Issue 1512 made this ill-formed.  */\n+\t  if (complain & tf_error)\n+\t    error_at (location, \"ordered comparison of pointer with \"\n+\t\t      \"integer zero (%qT and %qT)\", type0, type1);\n+\t  return error_mark_node;\n \t}\n       else if (null_ptr_cst_p (orig_op0) && null_ptr_cst_p (orig_op1))\n \t/* One of the operands must be of nullptr_t type.  */"}, {"sha": "facaf4436655d3b7758b67ef6edf1089a3ac077f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -1,3 +1,16 @@\n+2020-05-18  Marek Polacek  <polacek@redhat.com>\n+\n+\tDR 1512\n+\tPR c++/87699\n+\t* g++.dg/cpp0x/constexpr-array-ptr10.C: Change dg-warning to dg-error\n+\tand adjust the expected messages in dg-error.\n+\t* g++.dg/expr/composite-ptr-type.C: New test.\n+\t* g++.dg/expr/ptr-comp1.C: New test.\n+\t* g++.dg/expr/ptr-comp2.C: New test.\n+\t* g++.dg/expr/ptr-comp3.C: New test.\n+\t* g++.dg/overload/builtin4.C: New test.\n+\t* g++.dg/warn/Wextra-3.C: Change dg-warning to dg-error.\n+\n 2020-05-18  Marek Polacek  <polacek@redhat.com>\n \n \t* g++.dg/overload/builtin5.C: New test."}, {"sha": "5224bb142349f8aa4b58971389fd2b2129a06e5e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array-ptr10.C", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array-ptr10.C?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -19,18 +19,18 @@ constexpr int *p0 = &i;\n constexpr bool b0  = p0;        // { dg-warning \"address of .A::i.\" }\n constexpr bool b1  = p0 == 0;   // { dg-warning \"address of .A::i.\" }\n constexpr bool b2  = p0 != 0;   // { dg-warning \"address of .A::i.\" }\n-constexpr bool b3  = p0 <  0;   // { dg-warning \"25:ordered comparison\" }\n-constexpr bool b4  = p0 <= 0;   // { dg-warning \"25:ordered comparison\" }\n-constexpr bool b5  = p0 >  0;   // { dg-warning \"25:ordered comparison\" }\n-constexpr bool b6  = p0 >= 0;   // { dg-warning \"25:ordered comparison\" }\n+constexpr bool b3  = p0 <  0;   // { dg-error \"25:ordered comparison\" }\n+constexpr bool b4  = p0 <= 0;   // { dg-error \"25:ordered comparison\" }\n+constexpr bool b5  = p0 >  0;   // { dg-error \"25:ordered comparison\" }\n+constexpr bool b6  = p0 >= 0;   // { dg-error \"25:ordered comparison\" }\n \n constexpr bool b7  = !p0;       // { dg-warning \"address of .A::i.\" }\n constexpr bool b8  = 0 == p0;   // { dg-warning \"address of .A::i.\" }\n constexpr bool b9  = 0 != p0;   // { dg-warning \"address of .A::i.\" }\n-constexpr bool b10 = 0 <  p0;   // { dg-warning \"24:ordered comparison\" }\n-constexpr bool b11 = 0 <= p0;   // { dg-warning \"24:ordered comparison\" }\n-constexpr bool b12 = 0 >  p0;   // { dg-warning \"24:ordered comparison\" }\n-constexpr bool b13 = 0 >= p0;   // { dg-warning \"24:ordered comparison\" }\n+constexpr bool b10 = 0 <  p0;   // { dg-error \"24:ordered comparison\" }\n+constexpr bool b11 = 0 <= p0;   // { dg-error \"24:ordered comparison\" }\n+constexpr bool b12 = 0 >  p0;   // { dg-error \"24:ordered comparison\" }\n+constexpr bool b13 = 0 >= p0;   // { dg-error \"24:ordered comparison\" }\n \n }\n \n@@ -60,20 +60,19 @@ constexpr int *p0 = &i;\n constexpr bool b0  = p0;        // { dg-error \"not a constant expression\" }\n constexpr bool b1  = p0 == 0;   // { dg-error \"not a constant expression\" }\n constexpr bool b2  = p0 != 0;   // { dg-error \"not a constant expression\" }\n-constexpr bool b4  = p0 <= 0;   // { dg-error \"not a constant expression\" }\n-constexpr bool b5  = p0 >  0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b4  = p0 <= 0;   // { dg-error \"ordered comparison\" }\n+constexpr bool b5  = p0 >  0;   // { dg-error \"ordered comparison\" }\n \n constexpr bool b7  = !p0;       // { dg-error \"not a constant expression\" }\n constexpr bool b8  = 0 == p0;   // { dg-error \"not a constant expression\" }\n constexpr bool b9  = 0 != p0;   // { dg-error \"not a constant expression\" }\n-constexpr bool b10 = 0 <  p0;   // { dg-error \"not a constant expression\" }\n-constexpr bool b13 = 0 >= p0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b10 = 0 <  p0;   // { dg-error \"ordered comparison\" }\n+constexpr bool b13 = 0 >= p0;   // { dg-error \"ordered comparison\" }\n \n-// The following are accepted as constant expressions due to bug c++/70196.\n-constexpr bool b3  = p0 <  0;\n-constexpr bool b6  = p0 >= 0;\n-constexpr bool b11 = 0 <= p0;\n-constexpr bool b12 = 0 >  p0;\n+constexpr bool b3  = p0 <  0; // { dg-error \"ordered comparison\" }\n+constexpr bool b6  = p0 >= 0; // { dg-error \"ordered comparison\" }\n+constexpr bool b11 = 0 <= p0; // { dg-error \"ordered comparison\" }\n+constexpr bool b12 = 0 >  p0; // { dg-error \"ordered comparison\" }\n \n #pragma GCC diagnostic pop\n \n@@ -92,14 +91,14 @@ constexpr int *p1 = &i + 1;\n constexpr bool b0  = p1;        // { dg-error \"not a constant expression\" }\n constexpr bool b1  = p1 == 0;   // { dg-error \"not a constant expression\" }\n constexpr bool b2  = p1 != 0;   // { dg-error \"not a constant expression\" }\n-constexpr bool b4  = p1 <= 0;   // { dg-error \"not a constant expression\" }\n-constexpr bool b5  = p1 >  0;   // { dg-error \"not a constant expression\" }\n+constexpr bool b4  = p1 <= 0;   // { dg-error \"ordered comparison\" }\n+constexpr bool b5  = p1 >  0;   // { dg-error \"ordered comparison\" }\n \n constexpr bool b7  = !p1;       // { dg-error \"not a constant expression\" }\n constexpr bool b8  = 0 == p1;   // { dg-error \"not a constant expression\" }\n constexpr bool b9  = 0 != p1;   // { dg-error \"not a constant expression\" }\n-constexpr bool b10 = 0 <  p1;   // { dg-error \"not a constant expression\" }\n-constexpr bool b13 = 0 >= p1;   // { dg-error \"not a constant expression\" }\n+constexpr bool b10 = 0 <  p1;   // { dg-error \"ordered comparison\" }\n+constexpr bool b13 = 0 >= p1;   // { dg-error \"ordered comparison\" }\n \n // The following are accepted as constant expressions due to bug c++/70196.\n // constexpr bool b3  = p1 <  0;"}, {"sha": "a7c301d7cb0f7e340e25217bf989a294b82abd87", "filename": "gcc/testsuite/g++.dg/expr/composite-ptr-type.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcomposite-ptr-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcomposite-ptr-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcomposite-ptr-type.C?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -0,0 +1,72 @@\n+// DR 1512\n+// Test the composite pointer type of two operands.\n+// { dg-do compile { target c++11 } }\n+\n+using nullptr_t = decltype(nullptr);\n+\n+template <class T, class U> struct same;\n+template <class T> struct same<T,T> { };\n+\n+template<typename T>\n+T fn ()\n+{\n+}\n+\n+// Check that the composite pointer type of T and U is RES.\n+template<typename T, typename U, typename RES>\n+void test ()\n+{\n+  same<decltype(true ? fn<T>() : fn<U>()), RES> s;\n+}\n+\n+struct A { };\n+struct B : A { };\n+\n+// Test [expr.type]/3.\n+void\n+foo ()\n+{\n+  // if both p1 and p2 are null pointer constants -> std::nullptr_\u00adt.\n+  test<nullptr_t, nullptr_t, nullptr_t>();\n+\n+  // if either p1 or p2 is a null pointer constant -> T2 or T1.\n+  test<nullptr_t, const char **, const char **>();\n+  test<const char **, nullptr_t, const char **>();\n+\n+  // if T1 or T2 is 'pointer to cv1 void' and the other type is 'pointer\n+  // to cv2 T', where T is an object type or void -> 'pointer to cv12 void',\n+  // where cv12 is the union of cv1 and cv2.\n+  test<const int *, volatile void *, const volatile void *>();\n+  test<const void *, volatile int *, const volatile void *>();\n+\n+  test<int *, const int *, const int *>();\n+  // Make sure that we propagate 'const' here as per [conv.qual]/3.3.\n+  test<int **, const int **, const int *const *>();\n+  test<int *volatile *, const int **, const int *const volatile *>();\n+  test<int **, volatile int **, volatile int *const *>();\n+\n+  // if T1 is 'pointer to cv1 C1' and T2 is 'pointer to cv2 C2', where C1 is\n+  // reference-related to C2 or C2 is reference-related to C1 -> the cv-combined\n+  // type of T1 and T2 or the cv-combined type of T2 and T1, respectively.\n+  test<const A*, volatile B*, const volatile A *>();\n+  test<const B*, volatile A*, const volatile A *>();\n+\n+  test<const int *A::*, volatile int *A::*, const volatile int *const A::*>();\n+  // FIXME: This doesn't work if they're reference-related but not same.\n+  //test<const int *A::*, volatile int *B::*, const volatile int *const B::*>();\n+  //test<const int *B::*, volatile int *A::*, const volatile int *const B::*>();\n+\n+  // if T1 or T2 is 'pointer to noexcept function' and the other type is\n+  // 'pointer to function', where the function types are otherwise the same\n+  // -> 'pointer to function'.\n+  test<int (*)() noexcept, int (*)(), int (*)()>();\n+  test<int (*)(), int (*)() noexcept, int (*)()>();\n+\n+  // if T1 or T2 is 'pointer to member of C1 of type function', the other type\n+  // is 'pointer to member of C2 of type noexcept function', and C1 is\n+  // reference-related to C2 or C2 is reference-related to C1, where the\n+  // function types are otherwise the same -> 'pointer to member of C2 of type\n+  // function' or 'pointer to member of C1 of type function', respectively.\n+  test<int (A::*)() noexcept, int (A::*)(), int (A::*)()>();\n+  test<int (A::*)(), int (A::*)() noexcept, int (A::*)()>();\n+}"}, {"sha": "f2434cbc87e0b6bd5dca5f3a57c85862eddd75ce", "filename": "gcc/testsuite/g++.dg/expr/ptr-comp1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp1.C?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -0,0 +1,32 @@\n+// DR 1512\n+// PR c++/87699\n+// { dg-do compile { target c++11 } }\n+\n+/* Relational comparisons between null pointer constants and pointers are now\n+   ill-formed.  */\n+\n+void\n+f (char *p)\n+{\n+  if (p > 0) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (p >= 0) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (p < 0) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (p <= 0) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (p > nullptr) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (p >= nullptr) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (p < nullptr) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (p <= nullptr) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+}\n+\n+void\n+f2 (char *p)\n+{\n+  if (0 > p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (0 >= p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (0 < p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (0 <= p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (nullptr > p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (nullptr >= p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (nullptr < p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+  if (nullptr <= p) { } // { dg-error \"ordered comparison of pointer with integer zero\" }\n+}"}, {"sha": "da5b09af8adc045f2548e8fa5c4599c3b7f7cc86", "filename": "gcc/testsuite/g++.dg/expr/ptr-comp2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp2.C?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -0,0 +1,14 @@\n+// DR 1512\n+// PR c++/87699\n+// { dg-do compile { target c++11 } }\n+\n+template<class T, decltype((((T*) 0) < nullptr), true) = false> // { dg-error \"ordered comparison\" }\n+bool test(T*)\n+{\n+  return true;\n+}\n+\n+int main()\n+{\n+  test((int*)(nullptr)); // { dg-error \"no matching function\" }\n+}"}, {"sha": "e1bc3c56d4d5ee9bf9ac58b1b520a81bc26cdda5", "filename": "gcc/testsuite/g++.dg/expr/ptr-comp3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fptr-comp3.C?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -0,0 +1,15 @@\n+// DR 1512\n+// PR c++/87699\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wall -Wextra -pedantic-errors\" }\n+\n+/* Comparisons between pointer types with different cv-quals are now OK.  */\n+\n+void\n+f (int **p1, const int **p2)\n+{\n+   if (p1 == p2) { }\n+   if (p1 != p2) { }\n+   if (p2 == p1) { }\n+   if (p2 != p1) { }\n+}"}, {"sha": "567bb933fde565aa6acf623332aa451594d64612", "filename": "gcc/testsuite/g++.dg/overload/builtin4.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin4.C?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -0,0 +1,31 @@\n+// DR 1512\n+// PR c++/87699\n+// { dg-do compile { target c++11 } }\n+\n+using nullptr_t = decltype(nullptr);\n+\n+template<typename T>\n+struct S { operator T(); };\n+\n+void\n+fn ()\n+{\n+  S<nullptr_t> s;\n+  // Make sure we create a builtin operator overload candidate for == and !=.\n+  if (s == s) { }\n+  if (s != s) { }\n+\n+  // But not for these.\n+  if (s > s) { }    // { dg-error \"no match for\" }\n+  if (s < s) { }    // { dg-error \"no match for\" }\n+  if (s <= s) { }   // { dg-error \"no match for\" }\n+  if (s >= s) { }   // { dg-error \"no match for\" }\n+\n+  S<int *> r;\n+  if (s == r) { }   // { dg-error \"no match for\" }\n+  if (s != r) { }   // { dg-error \"no match for\" }\n+  if (s > r) { }    // { dg-error \"no match for\" }\n+  if (s < r) { }    // { dg-error \"no match for\" }\n+  if (s >= r) { }   // { dg-error \"no match for\" }\n+  if (s <= r) { }   // { dg-error \"no match for\" }\n+}"}, {"sha": "1b596b3f3e24a82f06eb1862e204568a0e9972d6", "filename": "gcc/testsuite/g++.dg/warn/Wextra-3.C", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8ed736addb2b005d54c0b3191ac599a04ec170/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-3.C?ref=ae8ed736addb2b005d54c0b3191ac599a04ec170", "patch": "@@ -1,9 +1,8 @@\n // PR c++/45278\n-// { dg-options \"-Wextra\" } \n \n extern void* p;\n \n-int f1() { return ( p <  0 ? 1 : 0 ); } // { dg-warning \"23:ordered comparison\" }\n-int f2() { return ( p <= 0 ? 1 : 0 ); } // { dg-warning \"23:ordered comparison\" }\n-int f3() { return ( p >  0 ? 1 : 0 ); } // { dg-warning \"23:ordered comparison\" }\n-int f4() { return ( p >= 0 ? 1 : 0 ); } // { dg-warning \"23:ordered comparison\" }\n+int f1() { return ( p <  0 ? 1 : 0 ); } // { dg-error \"23:ordered comparison\" }\n+int f2() { return ( p <= 0 ? 1 : 0 ); } // { dg-error \"23:ordered comparison\" }\n+int f3() { return ( p >  0 ? 1 : 0 ); } // { dg-error \"23:ordered comparison\" }\n+int f4() { return ( p >= 0 ? 1 : 0 ); } // { dg-error \"23:ordered comparison\" }"}]}