{"sha": "dd81163fe8ff6611261475f97c08f8ef688dd4d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ4MTE2M2ZlOGZmNjYxMTI2MTQ3NWY5N2MwOGY4ZWY2ODhkZDRkMQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-09-26T09:18:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-09-26T09:18:09Z"}, "message": "[Ada] Minor reformattings\n\n2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* contracts.adb, exp_unst.adb, exp_util.adb, gnat1drv.adb,\n\topt.ads, par-prag.adb, sem_ch3.adb, sem_ch5.adb, sem_prag.adb,\n\tsinfo.ads, snames.ads-tmpl: Minor reformatting.\n\nFrom-SVN: r264621", "tree": {"sha": "329676d6b87fd68d45791685a77b519aad197fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/329676d6b87fd68d45791685a77b519aad197fc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd81163fe8ff6611261475f97c08f8ef688dd4d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd81163fe8ff6611261475f97c08f8ef688dd4d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd81163fe8ff6611261475f97c08f8ef688dd4d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd81163fe8ff6611261475f97c08f8ef688dd4d1/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8bc3bcb5fee9140c876d89ae2bf298914c01077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8bc3bcb5fee9140c876d89ae2bf298914c01077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8bc3bcb5fee9140c876d89ae2bf298914c01077"}], "stats": {"total": 520, "additions": 318, "deletions": 202}, "files": [{"sha": "ba3c363367e7075333dc4421e1de0c0e4846ead5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -1,3 +1,9 @@\n+2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* contracts.adb, exp_unst.adb, exp_util.adb, gnat1drv.adb,\n+\topt.ads, par-prag.adb, sem_ch3.adb, sem_ch5.adb, sem_prag.adb,\n+\tsinfo.ads, snames.ads-tmpl: Minor reformatting.\n+\n 2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Add unit GNAT.Sets to the list of"}, {"sha": "760c06b1114f51158ce4fab34eccdb9af0df32f1", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -2858,13 +2858,11 @@ package body Contracts is\n          -------------------------------\n \n          procedure Process_Preconditions_For (Subp_Id : Entity_Id) is\n-            Items : constant Node_Id := Contract (Subp_Id);\n-\n-            Bod       : constant Node_Id := Unit_Declaration_Node (Body_Id);\n+            Items     : constant Node_Id := Contract (Subp_Id);\n+            Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n             Decl      : Node_Id;\n             Freeze_T  : Boolean;\n             Prag      : Node_Id;\n-            Subp_Decl : Node_Id;\n \n          begin\n             --  Process the contract. If the body is an expression function\n@@ -2873,12 +2871,13 @@ package body Contracts is\n             --  its completion by an expression function appear in distinct\n             --  declarative lists of the same unit (visible and private).\n \n-            Freeze_T := Was_Expression_Function (Bod)\n-                          and then Sloc (Body_Id) /= Sloc (Subp_Id)\n-                          and then In_Same_Source_Unit (Body_Id, Subp_Id)\n-                          and then List_Containing (Bod) /=\n-                            List_Containing (Unit_Declaration_Node (Subp_Id))\n-                          and then not In_Instance;\n+            Freeze_T :=\n+              Was_Expression_Function (Body_Decl)\n+                and then Sloc (Body_Id) /= Sloc (Subp_Id)\n+                and then In_Same_Source_Unit (Body_Id, Subp_Id)\n+                and then List_Containing (Body_Decl) /=\n+                         List_Containing (Subp_Decl)\n+                and then not In_Instance;\n \n             if Present (Items) then\n                Prag := Pre_Post_Conditions (Items);\n@@ -2887,10 +2886,13 @@ package body Contracts is\n                     and then Is_Checked (Prag)\n                   then\n                      if Freeze_T\n-                        and then Present (Corresponding_Aspect (Prag))\n+                       and then Present (Corresponding_Aspect (Prag))\n                      then\n-                        Freeze_Expr_Types (Subp_Id, Standard_Boolean,\n-                          Expression (Corresponding_Aspect (Prag)), Bod);\n+                        Freeze_Expr_Types\n+                          (Def_Id => Subp_Id,\n+                           Typ    => Standard_Boolean,\n+                           Expr   => Expression (Corresponding_Aspect (Prag)),\n+                           N      => Body_Decl);\n                      end if;\n \n                      Prepend_To_Decls_Or_Save (Prag);\n@@ -2905,8 +2907,6 @@ package body Contracts is\n             --  it must be taken into account. The pragma appears after the\n             --  stub.\n \n-            Subp_Decl := Unit_Declaration_Node (Subp_Id);\n-\n             if Nkind (Subp_Decl) = N_Subprogram_Body_Stub then\n \n                --  Inspect the declarations following the body stub"}, {"sha": "de4ea1a26ce27f0d3e6cfe43a0c7c95c9340abe8", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -260,8 +260,8 @@ package body Exp_Unst is\n          E := Ultimate_Alias (E);\n \n          --  The body of a protected operation has a different name and\n-         --  has been scanned at this point, and thus has an entry in\n-         --  the subprogram table.\n+         --  has been scanned at this point, and thus has an entry in the\n+         --  subprogram table.\n \n          if E = Sub and then Convention (E) = Convention_Protected then\n             E := Protected_Body_Subprogram (E);\n@@ -541,19 +541,17 @@ package body Exp_Unst is\n                      if Nkind (N) = N_Attribute_Reference then\n                         declare\n                            Attr : constant Attribute_Id :=\n-                             Get_Attribute_Id (Attribute_Name (N));\n+                                    Get_Attribute_Id (Attribute_Name (N));\n+                           DT   : Boolean := False;\n+\n                         begin\n                            if (Attr = Attribute_First\n                                  or else Attr = Attribute_Last\n                                  or else Attr = Attribute_Length)\n                              and then Is_Constrained (Etype (Prefix (N)))\n                            then\n-                              declare\n-                                 DT : Boolean := False;\n-                              begin\n-                                 Check_Static_Type\n-                                   (Etype (Prefix (N)), Empty, DT);\n-                              end;\n+                              Check_Static_Type\n+                                (Etype (Prefix (N)), Empty, DT);\n                            end if;\n                         end;\n                      end if;\n@@ -2022,21 +2020,23 @@ package body Exp_Unst is\n                                  --  N_Loop_Parameter_Specification or to\n                                  --  an N_Iterator_Specification.\n \n-                                 if Nkind_In (Ins, N_Iterator_Specification,\n-                                              N_Loop_Parameter_Specification)\n+                                 if Nkind_In\n+                                      (Ins, N_Iterator_Specification,\n+                                            N_Loop_Parameter_Specification)\n                                  then\n-                                    --  Quantified expression are rewrittne\n-                                    --  as loops during expansion.\n+                                    --  Quantified expression are rewritten as\n+                                    --  loops during expansion.\n \n                                     if Nkind (Parent (Ins)) =\n-                                      N_Quantified_Expression\n+                                         N_Quantified_Expression\n                                     then\n                                        null;\n \n                                     else\n                                        Ins :=\n                                          First\n-                                         (Statements (Parent (Parent (Ins))));\n+                                           (Statements\n+                                             (Parent (Parent (Ins))));\n                                        Insert_Before (Ins, Asn);\n                                     end if;\n "}, {"sha": "ec681af91dbabf8f8e3618be54573c8dbb555e32", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -9151,10 +9151,10 @@ package body Exp_Util is\n                  Aliased_Present    => False,\n                  Subtype_Indication => New_Occurrence_Of (Constr_Root, Loc))));\n \n-         Set_Reverse_Storage_Order (Equiv_Type,\n-           Reverse_Storage_Order (Base_Type (Root_Utyp)));\n-         Set_Reverse_Bit_Order (Equiv_Type,\n-           Reverse_Bit_Order (Base_Type (Root_Utyp)));\n+         Set_Reverse_Storage_Order\n+           (Equiv_Type, Reverse_Storage_Order (Base_Type (Root_Utyp)));\n+         Set_Reverse_Bit_Order\n+           (Equiv_Type, Reverse_Bit_Order (Base_Type (Root_Utyp)));\n       end if;\n \n       Append_To (Comp_List,"}, {"sha": "eab2fda1a00de9eb1a8ed5015e1a477f3754b11a", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -161,7 +161,7 @@ procedure Gnat1drv is\n          Modify_Tree_For_C := True;\n       end if;\n \n-      --  -gnatd_A disables generation of ALI files.\n+      --  -gnatd_A disables generation of ALI files\n \n       if Debug_Flag_Underscore_AA then\n          Disable_ALI_File := True;"}, {"sha": "26143030da1b1d9b52576c919fab7fab00a59866", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -1216,6 +1216,11 @@ package Opt is\n    --  cannot be simultaneous compilations with the object files in the same\n    --  object directory, if project files are used.\n \n+   OpenAcc_Enabled : Boolean := False;\n+   --  GNAT\n+   --  Indicates whether OpenAcc pragmas should be taken into account. Set to\n+   --  True by the use of -fopenacc.\n+\n    type Operating_Mode_Type is (Check_Syntax, Check_Semantics, Generate_Code);\n    pragma Ordered (Operating_Mode_Type);\n    Operating_Mode : Operating_Mode_Type := Generate_Code;\n@@ -2335,21 +2340,11 @@ package Opt is\n \n    --    The only special comment sequence allowed is --!\n \n-   -------------\n-   -- OpenAcc --\n-   -------------\n-\n-   OpenAcc_Enabled : Boolean := False;\n-   --  GNAT\n-   --  Indicates whether OpenAcc pragmas should be taken into account.\n-   --  Set True by use of -fopenacc.\n-\n    --------------------------\n    -- Private Declarations --\n    --------------------------\n \n private\n-\n    --  The following type is used to save and restore settings of switches in\n    --  Opt that represent the configuration (i.e. result of config pragmas).\n "}, {"sha": "a8b399711e51550339620577b7a788f3842b69db", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -1295,11 +1295,15 @@ begin\n       -- All Other Pragmas --\n       -----------------------\n \n-      --  For all other pragmas, checking and processing is handled\n-      --  entirely in Sem_Prag, and no further checking is done by Par.\n+      --  For all other pragmas, checking and processing is handled entirely in\n+      --  Sem_Prag, and no further checking is done by Par.\n \n       when Pragma_Abort_Defer\n          | Pragma_Abstract_State\n+         | Pragma_Acc_Data\n+         | Pragma_Acc_Kernels\n+         | Pragma_Acc_Loop\n+         | Pragma_Acc_Parallel\n          | Pragma_Async_Readers\n          | Pragma_Async_Writers\n          | Pragma_Assertion_Policy\n@@ -1516,10 +1520,6 @@ begin\n          | Pragma_Warning_As_Error\n          | Pragma_Weak_External\n          | Pragma_Validity_Checks\n-         | Pragma_Acc_Data\n-         | Pragma_Acc_Kernels\n-         | Pragma_Acc_Loop\n-         | Pragma_Acc_Parallel\n       =>\n          null;\n "}, {"sha": "32797d88f9e06ae9671bd771dc47c727efe476c7", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -1919,8 +1919,8 @@ package body Sem_Ch3 is\n          if Is_Limited_Record (Typ) then\n             return True;\n \n-         --  If the root type is limited (and not a limited interface)\n-         --  so is the current type\n+         --  If the root type is limited (and not a limited interface) so is\n+         --  the current type.\n \n          elsif Is_Limited_Record (R)\n            and then (not Is_Interface (R) or else not Is_Limited_Interface (R))\n@@ -1931,8 +1931,8 @@ package body Sem_Ch3 is\n          --  limited record parent that is not an interface.\n \n          elsif R /= P\n-            and then Is_Limited_Record (P)\n-            and then not Is_Interface (P)\n+           and then Is_Limited_Record (P)\n+           and then not Is_Interface (P)\n          then\n             return True;\n "}, {"sha": "95b56601d810dd32dc4086c9193997acb7d48f30", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -2210,8 +2210,7 @@ package body Sem_Ch5 is\n       if Nkind (Iter_Name) = N_Function_Call\n         and then Is_Entity_Name (Name (Iter_Name))\n         and then Full_Analysis\n-        and then (In_Assertion_Expr = 0\n-                   or else Assertions_Enabled)\n+        and then (In_Assertion_Expr = 0 or else Assertions_Enabled)\n       then\n          Freeze_Before (N, Entity (Name (Iter_Name)));\n       end if;"}, {"sha": "bc914119afa97ee582d1f93e9bd77aa8da36e3c0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 253, "deletions": 139, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -3686,10 +3686,10 @@ package body Sem_Prag is\n       -----------------------\n \n       function Acc_First (N : Node_Id) return Node_Id;\n-      --  Helper function to iterate over arguments given to OpenAcc pragmas.\n+      --  Helper function to iterate over arguments given to OpenAcc pragmas\n \n       function Acc_Next (N : Node_Id) return Node_Id;\n-      --  Helper function to iterate over arguments given to OpenAcc pragmas.\n+      --  Helper function to iterate over arguments given to OpenAcc pragmas\n \n       procedure Acquire_Warning_Match_String (Arg : Node_Id);\n       --  Used by pragma Warnings (Off, string), and Warn_As_Error (string) to\n@@ -4241,14 +4241,14 @@ package body Sem_Prag is\n       --  profile.\n \n       procedure Validate_Acc_Condition_Clause (Clause : Node_Id);\n-      --  Make sure the argument of a given Acc_If clause is a boolean.\n+      --  Make sure the argument of a given Acc_If clause is a Boolean\n \n       procedure Validate_Acc_Data_Clause (Clause : Node_Id);\n       --  Make sure the argument of an OpenAcc data clause (e.g. Copy, Copyin,\n       --  Copyout...) is an identifier or an aggregate of identifiers.\n \n       procedure Validate_Acc_Int_Expr_Clause (Clause : Node_Id);\n-      --  Make sure the argument of an OpenAcc clause is an Integer expression.\n+      --  Make sure the argument of an OpenAcc clause is an Integer expression\n \n       procedure Validate_Acc_Int_Expr_List_Clause (Clause : Node_Id);\n       --  Make sure the argument of an OpenAcc clause is an Integer expression\n@@ -4266,8 +4266,8 @@ package body Sem_Prag is\n       procedure Validate_Acc_Loop_Vector (Clause : Node_Id);\n       --  When this procedure is called in a construct offloaded by an\n       --  Acc_Kernels pragma, makes sure that a Vector_Length clause does\n-      --  not exist on said pragma.\n-      --  In all cases, make sure the argument is an integer expression.\n+      --  not exist on said pragma. In all cases, make sure the argument\n+      --  is an Integer expression.\n \n       procedure Validate_Acc_Loop_Worker (Clause : Node_Id);\n       --  When this procedure is called in a construct offloaded by an\n@@ -4297,10 +4297,12 @@ package body Sem_Prag is\n          if Nkind (N) = N_Aggregate then\n             if Present (Expressions (N)) then\n                return First (Expressions (N));\n+\n             elsif Present (Component_Associations (N)) then\n                return Expression (First (Component_Associations (N)));\n             end if;\n          end if;\n+\n          return N;\n       end Acc_First;\n \n@@ -4312,8 +4314,10 @@ package body Sem_Prag is\n       begin\n          if Nkind (Parent (N)) = N_Component_Association then\n             return Expression (Next (Parent (N)));\n+\n          elsif Nkind (Parent (N)) = N_Aggregate then\n             return Next (N);\n+\n          else\n             return Empty;\n          end if;\n@@ -11174,8 +11178,9 @@ package body Sem_Prag is\n       procedure Validate_Acc_Condition_Clause (Clause : Node_Id) is\n       begin\n          Analyze_And_Resolve (Clause);\n+\n          if not Is_Boolean_Type (Etype (Clause)) then\n-            Error_Pragma (\"Expected a boolean\");\n+            Error_Pragma (\"expected a boolean\");\n          end if;\n       end Validate_Acc_Condition_Clause;\n \n@@ -11185,13 +11190,16 @@ package body Sem_Prag is\n \n       procedure Validate_Acc_Data_Clause (Clause : Node_Id) is\n          Expr : Node_Id;\n+\n       begin\n          Expr := Acc_First (Clause);\n          while Present (Expr) loop\n             if Nkind (Expr) /= N_Identifier then\n-               Error_Pragma (\"Expected an Identifer\");\n+               Error_Pragma (\"expected an identifer\");\n             end if;\n+\n             Analyze_And_Resolve (Expr);\n+\n             Expr := Acc_Next (Expr);\n          end loop;\n       end Validate_Acc_Data_Clause;\n@@ -11203,8 +11211,9 @@ package body Sem_Prag is\n       procedure Validate_Acc_Int_Expr_Clause (Clause : Node_Id) is\n       begin\n          Analyze_And_Resolve (Clause);\n+\n          if not Is_Integer_Type (Etype (Clause)) then\n-            Error_Pragma_Arg (\"Expected an integer\", Clause);\n+            Error_Pragma_Arg (\"expected an integer\", Clause);\n          end if;\n       end Validate_Acc_Int_Expr_Clause;\n \n@@ -11214,13 +11223,16 @@ package body Sem_Prag is\n \n       procedure Validate_Acc_Int_Expr_List_Clause (Clause : Node_Id) is\n          Expr : Node_Id;\n+\n       begin\n          Expr := Acc_First (Clause);\n          while Present (Expr) loop\n             Analyze_And_Resolve (Expr);\n+\n             if not Is_Integer_Type (Etype (Expr)) then\n-               Error_Pragma (\"Expected an Integer\");\n+               Error_Pragma (\"expected an integer\");\n             end if;\n+\n             Expr := Acc_Next (Expr);\n          end loop;\n       end Validate_Acc_Int_Expr_List_Clause;\n@@ -11230,41 +11242,45 @@ package body Sem_Prag is\n       --------------------------------\n \n       procedure Validate_Acc_Loop_Collapse (Clause : Node_Id) is\n-         Count : Uint;\n-         Parent_Loop : Node_Id;\n-         Current_Statement : Node_Id;\n+         Count    : Uint;\n+         Par_Loop : Node_Id;\n+         Stmt     : Node_Id;\n+\n       begin\n-         --  Make sure the argument is a positive integer.\n+         --  Make sure the argument is a positive integer\n+\n          Analyze_And_Resolve (Clause);\n+\n          Count := Static_Integer (Clause);\n          if Count = No_Uint or else Count < 1 then\n-            Error_Pragma_Arg (\"Expected a positive integer\", Clause);\n+            Error_Pragma_Arg (\"expected a positive integer\", Clause);\n          end if;\n \n          --  Then, make sure we have at least Count-1 tightly-nested loops\n          --  (i.e. loops with no statements in between).\n \n-         Parent_Loop := Parent (Parent (Parent (Clause)));\n-         Current_Statement := First (Statements (Parent_Loop));\n+         Par_Loop := Parent (Parent (Parent (Clause)));\n+         Stmt     := First (Statements (Par_Loop));\n+\n          --  Skip first pragmas in the parent loop\n-         while Present (Current_Statement)\n-            and then Nkind (Current_Statement) = N_Pragma loop\n-            Current_Statement := Next (Current_Statement);\n+\n+         while Present (Stmt) and then Nkind (Stmt) = N_Pragma loop\n+            Next (Stmt);\n          end loop;\n \n-         if not Present (Next (Current_Statement)) then\n-            While_Loop :\n-            while Nkind (Current_Statement) = N_Loop_Statement\n-               and Count > 1 loop\n-               Current_Statement := First (Statements (Current_Statement));\n-               exit While_Loop when Present (Next (Current_Statement));\n+         if not Present (Next (Stmt)) then\n+            while Nkind (Stmt) = N_Loop_Statement and Count > 1 loop\n+               Stmt := First (Statements (Stmt));\n+               exit when Present (Next (Stmt));\n+\n                Count := Count - 1;\n-            end loop While_Loop;\n+            end loop;\n          end if;\n \n          if Count > 1 then\n-            Error_Pragma_Arg (\"Collapse argument too high or loops not \" &\n-            \"tightly nested.\", Clause);\n+            Error_Pragma_Arg\n+              (\"Collapse argument too high or loops not tightly nested\",\n+               Clause);\n          end if;\n       end Validate_Acc_Loop_Collapse;\n \n@@ -11300,83 +11316,119 @@ package body Sem_Prag is\n       ---------------------------------\n \n       procedure Validate_Acc_Name_Reduction (Clause : Node_Id) is\n+\n          --  ??? On top of the following operations, the OpenAcc spec adds the\n          --  \"bitwise and\", \"bitwise or\" and modulo for C and \".eqv\" and\n          --  \".neqv\" for Fortran. Can we, should we and how do we support them\n          --  in Ada?\n-         type Reduction_Op is (Add_Op, Mul_Op, Max_Op,\n-            Min_Op, And_Op, Or_Op);\n+\n+         type Reduction_Op is (Add_Op, Mul_Op, Max_Op, Min_Op, And_Op, Or_Op);\n+\n          function To_Reduction_Op (Op : String) return Reduction_Op;\n+         --  Convert operator Op described by a String into its corresponding\n+         --  enumeration value.\n+\n+         ---------------------\n+         -- To_Reduction_Op --\n+         ---------------------\n+\n          function To_Reduction_Op (Op : String) return Reduction_Op is\n          begin\n             if Op = \"+\" then\n                return Add_Op;\n+\n             elsif Op = \"*\" then\n                return Mul_Op;\n+\n             elsif Op = \"max\" then\n                return Max_Op;\n+\n             elsif Op = \"min\" then\n                return Min_Op;\n+\n             elsif Op = \"and\" then\n                return And_Op;\n+\n             elsif Op = \"or\" then\n                return Or_Op;\n+\n             else\n-               Error_Pragma (\"Unsuported reduction operation\");\n+               Error_Pragma (\"unsuported reduction operation\");\n             end if;\n          end To_Reduction_Op;\n-         Expr : Node_Id;\n-         Reduc_Op : Node_Id;\n+\n+         --  Local variables\n+\n+         Seen : constant Elist_Id := New_Elmt_List;\n+\n+         Expr      : Node_Id;\n+         Reduc_Op  : Node_Id;\n          Reduc_Var : Node_Id;\n-         Seen_Entities : Elist_Id;\n+\n+      --  Start of processing for Validate_Acc_Name_Reduction\n+\n       begin\n-         --  Reduction operations look like this:\n-         --  (\"+\" => (a, b), \"*\" => c)\n-         Seen_Entities := New_Elmt_List;\n+         --  Reduction operations appear in the following form:\n+         --    (\"+\" => (a, b), \"*\" => c)\n+\n          Expr := First (Component_Associations (Clause));\n          while Present (Expr) loop\n             Reduc_Op := First (Choices (Expr));\n             String_To_Name_Buffer (Strval (Reduc_Op));\n-            case To_Reduction_Op (Name_Buffer (1 .. Name_Len)) is\n \n-               when Add_Op | Mul_Op | Max_Op | Min_Op =>\n+            case To_Reduction_Op (Name_Buffer (1 .. Name_Len)) is\n+               when Add_Op\n+                  | Mul_Op\n+                  | Max_Op\n+                  | Min_Op\n+               =>\n                   Reduc_Var := Acc_First (Expression (Expr));\n                   while Present (Reduc_Var) loop\n                      Analyze_And_Resolve (Reduc_Var);\n-                     if Contains (Seen_Entities, Entity (Reduc_Var)) then\n-                        Error_Pragma (\"Variable used in multiple reductions\");\n+\n+                     if Contains (Seen, Entity (Reduc_Var)) then\n+                        Error_Pragma (\"variable used in multiple reductions\");\n+\n                      else\n-                        if (Nkind (Reduc_Var) /= N_Identifier)\n-                           or not Is_Numeric_Type (Etype (Reduc_Var))\n+                        if Nkind (Reduc_Var) /= N_Identifier\n+                          or not Is_Numeric_Type (Etype (Reduc_Var))\n                         then\n                            Error_Pragma\n-                              (\"Expected an identifier for a Numeric\");\n+                             (\"expected an identifier for a Numeric\");\n                         end if;\n-                        Append_Elmt (Entity (Reduc_Var), Seen_Entities);\n+\n+                        Append_Elmt (Entity (Reduc_Var), Seen);\n                      end if;\n+\n                      Reduc_Var := Acc_Next (Reduc_Var);\n                   end loop;\n \n-               when And_Op | Or_Op =>\n+               when And_Op\n+                  | Or_Op\n+               =>\n                   Reduc_Var := Acc_First (Expression (Expr));\n                   while Present (Reduc_Var) loop\n                      Analyze_And_Resolve (Reduc_Var);\n-                     if Contains (Seen_Entities, Entity (Reduc_Var)) then\n-                        Error_Pragma (\"Variable used in multiple \" &\n-                        \"reductions\");\n+\n+                     if Contains (Seen, Entity (Reduc_Var)) then\n+                        Error_Pragma (\"variable used in multiple reductions\");\n+\n                      else\n-                        if Nkind (Reduc_Var) /= N_Identifier or not\n-                           Is_Boolean_Type (Etype (Reduc_Var))\n+                        if Nkind (Reduc_Var) /= N_Identifier\n+                          or not Is_Boolean_Type (Etype (Reduc_Var))\n                         then\n-                           Error_Pragma (\"Expected a variable of type \" &\n-                           \"Boolean\");\n+                           Error_Pragma\n+                             (\"expected a variable of type boolean\");\n                         end if;\n-                        Append_Elmt (Entity (Reduc_Var), Seen_Entities);\n+\n+                        Append_Elmt (Entity (Reduc_Var), Seen);\n                      end if;\n+\n                      Reduc_Var := Acc_Next (Reduc_Var);\n                   end loop;\n             end case;\n-            Expr := Next (Expr);\n+\n+            Next (Expr);\n          end loop;\n       end Validate_Acc_Name_Reduction;\n \n@@ -11385,26 +11437,38 @@ package body Sem_Prag is\n       -----------------------------------\n \n       procedure Validate_Acc_Size_Expressions (Clause : Node_Id) is\n-\n-         --  A size expr is either an integer expression or \"*\"\n          function Validate_Size_Expr (Expr : Node_Id) return Boolean;\n+         --  A size expr is either an integer expression or \"*\"\n+\n+         ------------------------\n+         -- Validate_Size_Expr --\n+         ------------------------\n+\n          function Validate_Size_Expr (Expr : Node_Id) return Boolean is\n          begin\n             if Nkind (Expr) = N_Operator_Symbol then\n                return Get_String_Char (Strval (Expr), 1) = Get_Char_Code ('*');\n             end if;\n+\n             Analyze_And_Resolve (Expr);\n+\n             return Is_Integer_Type (Etype (Expr));\n          end Validate_Size_Expr;\n \n+         --  Local variables\n+\n          Expr : Node_Id;\n+\n+      --  Start of processing for Validate_Acc_Size_Expressions\n+\n       begin\n          Expr := Acc_First (Clause);\n          while Present (Expr) loop\n             if not Validate_Size_Expr (Expr) then\n-               Error_Pragma (\"Size expressions should be either integers \" &\n-               \"or '*'\");\n+               Error_Pragma\n+                 (\"Size expressions should be either integers or '*'\");\n             end if;\n+\n             Expr := Acc_Next (Expr);\n          end loop;\n       end Validate_Acc_Size_Expressions;\n@@ -12357,8 +12421,8 @@ package body Sem_Prag is\n          --------------\n \n          when Pragma_Acc_Data => Acc_Data : declare\n-            Clause_Names : constant Name_List := (\n-               Name_Attach,\n+            Clause_Names : constant Name_List :=\n+              (Name_Attach,\n                Name_Copy,\n                Name_Copy_In,\n                Name_Copy_Out,\n@@ -12367,55 +12431,63 @@ package body Sem_Prag is\n                Name_Detach,\n                Name_Device_Ptr,\n                Name_No_Create,\n-               Name_Present\n-               );\n+               Name_Present);\n+\n+            Clause  : Node_Id;\n             Clauses : Args_List (Clause_Names'Range);\n-            Clause : Node_Id;\n \n          begin\n             if not OpenAcc_Enabled then\n                return;\n             end if;\n+\n             GNAT_Pragma;\n-            if Nkind (Parent (N)) /= N_Loop_Statement\n-            then\n-               Error_Pragma (\"Acc_Data pragma should be placed in loop or \"\n-               & \"block statements.\");\n+\n+            if Nkind (Parent (N)) /= N_Loop_Statement then\n+               Error_Pragma\n+                 (\"Acc_Data pragma should be placed in loop or block \"\n+                  & \"statements\");\n             end if;\n+\n             Gather_Associations (Clause_Names, Clauses);\n+\n             for Id in Clause_Names'First .. Clause_Names'Last loop\n                Clause := Clauses (Id);\n+\n                if Present (Clause) then\n                   case Clause_Names (Id) is\n                      when Name_Copy\n                         | Name_Copy_In\n                         | Name_Copy_Out\n                         | Name_Create\n                         | Name_Device_Ptr\n-                        | Name_Present =>\n+                        | Name_Present\n+                     =>\n                         Validate_Acc_Data_Clause (Clause);\n+\n                      when Name_Attach\n                         | Name_Detach\n                         | Name_Delete\n-                        | Name_No_Create =>\n-                        Error_Pragma (\"Unsupported pragma clause.\");\n-                     when others => raise Program_Error;\n+                        | Name_No_Create\n+                      =>\n+                        Error_Pragma (\"unsupported pragma clause\");\n+\n+                     when others =>\n+                        raise Program_Error;\n                   end case;\n                end if;\n             end loop;\n \n             Set_Is_OpenAcc_Environment (Parent (N));\n-\n          end Acc_Data;\n \n          --------------\n          -- Acc_Loop --\n          --------------\n \n          when Pragma_Acc_Loop => Acc_Loop : declare\n-\n-            Clause_Names : constant Name_List := (\n-               Name_Auto,\n+            Clause_Names : constant Name_List :=\n+              (Name_Auto,\n                Name_Collapse,\n                Name_Gang,\n                Name_Independent,\n@@ -12424,64 +12496,90 @@ package body Sem_Prag is\n                Name_Seq,\n                Name_Tile,\n                Name_Vector,\n-               Name_Worker\n-            );\n+               Name_Worker);\n+\n+            Clause  : Node_Id;\n             Clauses : Args_List (Clause_Names'Range);\n-            Clause : Node_Id;\n-            Parent_Node : Node_Id;\n+            Par     : Node_Id;\n \n          begin\n             if not OpenAcc_Enabled then\n                return;\n             end if;\n+\n             GNAT_Pragma;\n \n             --  Make sure the pragma is in an openacc construct\n+\n             Check_Loop_Pragma_Placement;\n-            Parent_Node := Parent (N);\n-            while Present (Parent_Node) and then\n-               (Nkind (Parent_Node) /= N_Loop_Statement or else\n-                not Is_OpenAcc_Environment (Parent_Node)) loop\n-               Parent_Node := Parent (Parent_Node);\n+\n+            Par := Parent (N);\n+            while Present (Par)\n+              and then (Nkind (Par) /= N_Loop_Statement\n+                         or else not Is_OpenAcc_Environment (Par))\n+            loop\n+               Par := Parent (Par);\n             end loop;\n-            if not Is_OpenAcc_Environment (Parent_Node) then\n-               Error_Pragma (\"Acc_Loop directive must be associated with an \" &\n-               \"OpenAcc construct region\");\n+\n+            if not Is_OpenAcc_Environment (Par) then\n+               Error_Pragma\n+                 (\"Acc_Loop directive must be associated with an OpenAcc \"\n+                  & \"construct region\");\n             end if;\n \n             Gather_Associations (Clause_Names, Clauses);\n+\n             for Id in Clause_Names'First .. Clause_Names'Last loop\n                Clause := Clauses (Id);\n+\n                if Present (Clause) then\n                   case Clause_Names (Id) is\n-                     when Name_Auto | Name_Independent | Name_Seq => null;\n+                     when Name_Auto\n+                        | Name_Independent\n+                        | Name_Seq\n+                     =>\n+                        null;\n+\n                      when Name_Collapse =>\n                         Validate_Acc_Loop_Collapse (Clause);\n-                     when Name_Gang => Validate_Acc_Loop_Gang (Clause);\n+\n+                     when Name_Gang =>\n+                        Validate_Acc_Loop_Gang (Clause);\n+\n                      when Name_Acc_Private =>\n                         Validate_Acc_Data_Clause (Clause);\n+\n                      when Name_Reduction =>\n                         Validate_Acc_Name_Reduction (Clause);\n-                     when Name_Tile => Validate_Acc_Size_Expressions (Clause);\n-                     when Name_Vector => Validate_Acc_Loop_Vector (Clause);\n-                     when Name_Worker => Validate_Acc_Loop_Worker (Clause);\n-                     when others => raise Program_Error;\n+\n+                     when Name_Tile =>\n+                        Validate_Acc_Size_Expressions (Clause);\n+\n+                     when Name_Vector =>\n+                        Validate_Acc_Loop_Vector (Clause);\n+\n+                     when Name_Worker =>\n+                        Validate_Acc_Loop_Worker (Clause);\n+\n+                     when others =>\n+                        raise Program_Error;\n                   end case;\n                end if;\n             end loop;\n+\n             Set_Is_OpenAcc_Loop (Parent (N));\n          end Acc_Loop;\n \n          ----------------------------------\n          -- Acc_Parallel and Acc_Kernels --\n          ----------------------------------\n \n-         when Pragma_Acc_Parallel | Pragma_Acc_Kernels =>\n-            Acc_Kernels_Or_Parallel :\n-         declare\n-\n-            Clause_Names : constant Name_List := (\n-               Name_Acc_If,\n+         when Pragma_Acc_Parallel\n+            | Pragma_Acc_Kernels\n+         =>\n+         Acc_Kernels_Or_Parallel : declare\n+            Clause_Names : constant Name_List :=\n+              (Name_Acc_If,\n                Name_Async,\n                Name_Copy,\n                Name_Copy_In,\n@@ -12495,111 +12593,127 @@ package body Sem_Prag is\n                Name_Present,\n                Name_Vector_Length,\n                Name_Wait,\n+\n                --  Parallel only\n+\n                Name_Acc_Private,\n                Name_First_Private,\n                Name_Reduction,\n+\n                --  Kernels only\n+\n                Name_Attach,\n-               Name_No_Create\n-               );\n+               Name_No_Create);\n+\n+            Clause  : Node_Id;\n             Clauses : Args_List (Clause_Names'Range);\n-            Clause : Node_Id;\n \n          begin\n             if not OpenAcc_Enabled then\n                return;\n             end if;\n+\n             GNAT_Pragma;\n             Check_Loop_Pragma_Placement;\n \n             if Nkind (Parent (N)) /= N_Loop_Statement then\n-               Error_Pragma (\"Pragma should be placed in loop or block \"\n-               & \"statements.\");\n+               Error_Pragma\n+                 (\"pragma should be placed in loop or block statements\");\n             end if;\n \n             Gather_Associations (Clause_Names, Clauses);\n+\n             for Id in Clause_Names'First .. Clause_Names'Last loop\n                Clause := Clauses (Id);\n+\n                if Present (Clause) then\n                   if Chars (Parent (Clause)) = No_Name then\n-                     Error_Pragma (\"All arguments should be associations\");\n+                     Error_Pragma (\"all arguments should be associations\");\n                   else\n                      case Clause_Names (Id) is\n-                           --  Note: According to the OpenAcc Standard v2.6,\n-                           --  Async's argument should be optional. Because\n-                           --  this complicates parsing the clause, the\n-                           --  argument is made mandatory. The standard defines\n-                           --  two negative values, acc_async_noval and\n-                           --  acc_async_sync. When given acc_async_noval as\n-                           --  value, the clause should behave as if no\n-                           --  argument was given. According to the standard,\n-                           --  acc_async_noval is defined in header files for C\n-                           --  and Fortran, thus this value should probably be\n-                           --  defined in the OpenAcc Ada library once it is\n-                           --  implemented.\n+\n+                        --  Note: According to the OpenAcc Standard v2.6,\n+                        --  Async's argument should be optional. Because this\n+                        --  complicates parsing the clause, the argument is\n+                        --  made mandatory. The standard defines two negative\n+                        --  values, acc_async_noval and acc_async_sync. When\n+                        --  given acc_async_noval as value, the clause should\n+                        --  behave as if no argument was given. According to\n+                        --  the standard, acc_async_noval is defined in header\n+                        --  files for C and Fortran, thus this value should\n+                        --  probably be defined in the OpenAcc Ada library once\n+                        --  it is implemented.\n+\n                         when Name_Async\n                            | Name_Num_Gangs\n                            | Name_Num_Workers\n-                           | Name_Vector_Length =>\n+                           | Name_Vector_Length\n+                        =>\n                            Validate_Acc_Int_Expr_Clause (Clause);\n \n                         when Name_Acc_If =>\n                            Validate_Acc_Condition_Clause (Clause);\n \n-                           --  Unsupported by GCC\n+                        --  Unsupported by GCC\n+\n                         when Name_Attach\n-                           | Name_No_Create =>\n-                           Error_Pragma (\"Unsupported clause.\");\n+                           | Name_No_Create\n+                        =>\n+                           Error_Pragma (\"unsupported clause\");\n \n-                        when Name_First_Private\n-                           | Name_Acc_Private =>\n+                        when Name_Acc_Private\n+                           | Name_First_Private\n+                        =>\n                            if Prag_Id /= Pragma_Acc_Parallel then\n-                              Error_Pragma (\"Argument is only available for\" &\n-                              \" 'Parallel' construct.\");\n+                              Error_Pragma\n+                                (\"argument is only available for 'Parallel' \"\n+                                 & \"construct\");\n                            else\n                               Validate_Acc_Data_Clause (Clause);\n                            end if;\n \n                         when Name_Copy\n                            | Name_Copy_In\n                            | Name_Copy_Out\n-                           | Name_Present\n                            | Name_Create\n-                           | Name_Device_Ptr =>\n+                           | Name_Device_Ptr\n+                           | Name_Present\n+                        =>\n                            Validate_Acc_Data_Clause (Clause);\n \n                         when Name_Reduction =>\n                            if Prag_Id /= Pragma_Acc_Parallel then\n-                              Error_Pragma (\"Argument is only available for\" &\n-                              \" 'Parallel' construct.\");\n+                              Error_Pragma\n+                                (\"argument is only available for 'Parallel' \"\n+                                 & \"construct\");\n                            else\n                               Validate_Acc_Name_Reduction (Clause);\n                            end if;\n \n                         when Name_Default =>\n                            if Chars (Clause) /= Name_None then\n-                              Error_Pragma (\"Expected None\");\n+                              Error_Pragma (\"expected none\");\n                            end if;\n \n                         when Name_Device_Type =>\n-                           Error_Pragma (\"Unsupported pragma clause\");\n+                           Error_Pragma (\"unsupported pragma clause\");\n+\n+                        --  Similar to Name_Async, Name_Wait's arguments should\n+                        --  be optional. However, this can be simulated using\n+                        --  acc_async_noval, hence, we do not bother making the\n+                        --  argument optional for now.\n \n-                           --  Same as for Name_Async, Name_Wait's arguments\n-                           --  should be optional. However, this can be\n-                           --  simulated using acc_async_noval, hence, we do\n-                           --  not bother making the argument optional for now.\n                         when Name_Wait =>\n                            Validate_Acc_Int_Expr_List_Clause (Clause);\n \n-                        when others => raise Program_Error;\n+                        when others =>\n+                           raise Program_Error;\n                      end case;\n                   end if;\n                end if;\n             end loop;\n \n             Set_Is_OpenAcc_Environment (Parent (N));\n-\n          end Acc_Kernels_Or_Parallel;\n \n          ------------"}, {"sha": "fcf99a8132b3254c7b51b0cc16244a8fe5ab9af8", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -5134,11 +5134,11 @@ package Sinfo is\n       --  Iteration_Scheme (Node2) (set to Empty if no iteration scheme)\n       --  Statements (List3)\n       --  End_Label (Node4)\n+      --  Is_OpenAcc_Environment (Flag13-Sem)\n+      --  Is_OpenAcc_Loop (Flag14-Sem)\n       --  Has_Created_Identifier (Flag15)\n       --  Is_Null_Loop (Flag16)\n       --  Suppress_Loop_Warnings (Flag17)\n-      --  Is_OpenAcc_Environment (Flag13-Sem)\n-      --  Is_OpenAcc_Loop (Flag14-Sem)\n \n       --  Note: the parser fills in the Identifier field if there is an\n       --  explicit loop identifier. Otherwise the parser leaves this field"}, {"sha": "21cc0f41182864646d7f2504d2c9353f6e11ff86", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd81163fe8ff6611261475f97c08f8ef688dd4d1/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=dd81163fe8ff6611261475f97c08f8ef688dd4d1", "patch": "@@ -864,8 +864,8 @@ package Snames is\n    Name_Warn                           : constant Name_Id := N + $;\n    Name_Working_Storage                : constant Name_Id := N + $;\n \n-   --  OpenAcc-specific clause names\n-   --  Parallel, Kernels, Data\n+   --  OpenAcc-specific clause names for Parallel, Kernels, Data\n+\n    Name_Acc_If                         : constant Name_Id := N + $;\n    Name_Acc_Private                    : constant Name_Id := N + $;\n    Name_Attach                         : constant Name_Id := N + $;\n@@ -884,13 +884,15 @@ package Snames is\n    Name_Reduction                      : constant Name_Id := N + $;\n    Name_Vector_Length                  : constant Name_Id := N + $;\n    Name_Wait                           : constant Name_Id := N + $;\n+\n    --  Loop\n+\n+   Name_Auto                           : constant Name_Id := N + $;\n    Name_Collapse                       : constant Name_Id := N + $;\n    Name_Gang                           : constant Name_Id := N + $;\n-   Name_Worker                         : constant Name_Id := N + $;\n    Name_Seq                            : constant Name_Id := N + $;\n-   Name_Auto                           : constant Name_Id := N + $;\n    Name_Tile                           : constant Name_Id := N + $;\n+   Name_Worker                         : constant Name_Id := N + $;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These"}]}