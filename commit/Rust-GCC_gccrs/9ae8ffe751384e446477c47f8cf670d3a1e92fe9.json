{"sha": "9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFlOGZmZTc1MTM4NGU0NDY0NzdjNDdmOGNmNjcwZDNhMWU5MmZlOQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-08-11T20:07:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-11T20:07:24Z"}, "message": "* Integrate alias analysis changes from jfc@mit.edu\n        * Makefile.in (OBJS): Add alias.o\n        (alias.o): Add dependencies.\n        * alias.c: New file.\n        * sched.c: Remove alias analysis code.  It lives in alias.c now.\n        (reg_last_uses_size): Declare.\n        (sched_analyze_2): Add new arguments to true_dependence.\n        (sched_analyze_insn): Use reg_last_uses_size instead of max_reg.\n        (schedule_block): Initialize reg_last_uses_size.\n        (schedule_insns): Always call init_alias_analysis.\n        * calls.c (expand_call): Note calls to malloc, calloc, and realloc;\n        mark return value from such functions as a pointer and keep track of\n        them for alias analysis.  If a return value from a function is a\n        pointer, mark it as such.\n        * combine.c (distribute_notes): Handle REG_NOALIAS.\n        * cse.c (struct write_data): Delete.  No longer needed.\n        (invalidate): Don't call set_nonvarying_address_components anymore.\n        Use true_dependence to decide if an entry should be removed from\n        the hash table.\n        (invalidate_memory): Remove WRITES argument, simplify appropriately.\n        Fix all callers.\n        (note_mem_written): Similarly for WRITE_PTR argument.\n        (invalidate_from_clobbers): Similarly for W argument.\n        (invalidate_for_call): Remove memory elements from the hash table.\n        (refers_to_mem_p, cse_rtx_addr_varies_p): Deleted.\n        (cse_rtx_varies_p): New function.  Derived from old\n        cse_rtx_addr_varies_p.\n        (cse_insn): Remove WRITES_MEMORY and INIT variables and all references.\n        Don't call note_mem_written anymore.  Stack pushes invalidate the stack\n        pointer if PUSH_ROUNDING is defined.  No longer need to call\n        cse_rtx_addr_varies_p to decide if a MEM should be invalidated.\n        (skipped_writes_memory): Remove variable.\n        (invalidate_skipped_set): Simplify and wewrite to use invalidate_memory.\n        (invalidate_skipped_block): Simplify for new alias analysis code.\n        (cse_set_around_loop): Likewise.\n        (cse_main): Call init_alias_analysis.\n        * flags.h (flag_alias_check, flag_argument_noalias): Declare.\n        * toplev.c (flag_alias_check, flag_argument_noalias): Define.\n        (f_options): Add new alias checking arguments.\n        (main): Set flag_alias_check when optimizing.\n        * local_alloc (validate_equiv_mem_from_store): Add new arguments\n        to true_dependence.\n        (memref_referenced_p): Likewise.\n        * loop.c (NUM_STORES): Increase to 30.\n        (prescan_loop): Only non-constant calls set unknown_address_altered.\n        (invariant_p): Add new arguments to true_dependence.\n        (record_giv): Initialize unrolled and shared fields.\n        (emit_iv_add_mult): Call record_base_value as needed.\n        * loop.h (struct induction): Add unrolled and shared fields.\n        * unroll.c  (unroll_loop): Call record_base_value as needed.\n        (copy_loop_body): Likewise.\n        (final_biv_value): Likewise.\n        (final_giv_value): Likewise.\n        (find_splittable_regs): Likewise.  Only create one new pseudo\n        if we have multiple address GIVs that were combined with the same\n        dst_reg GIV.  Note when a new register is created due to unrolling.\n        * rtl.c (reg_note_name): Add REG_NOALIAS.\n        * rtl.h (enum reg_note): Similarly.\n        (rtx_varies_p, may_trap_p, side_effects_p): Declare.\n        (volatile_refs_p, volatile_insn_p, remove_note): Likewise.\n        (note_stores, refers_to_regno_p, reg_overlap_mentioned_p): Likewise.\n        (true_dependence, read_dependence, anti_dependence): Likewise.\n        (output_dependence, init_alias_analysis, end_alias_analysis): Likewise.\n        (mark_user_reg, mark_reg_pointer): Likewise.\njfc's alias analysis code.\n\nFrom-SVN: r14768", "tree": {"sha": "070833bf20a821eb8d3cb38069e95b6e7b7b9bc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/070833bf20a821eb8d3cb38069e95b6e7b7b9bc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/comments", "author": null, "committer": null, "parents": [{"sha": "5fa39bfeb7285e06d0cd52c1da94fe93a67703d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0"}], "stats": {"total": 2274, "additions": 1371, "deletions": 903}, "files": [{"sha": "cdf71eb59d878576e7e2d397c1a4409874ae0d31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -1,6 +1,72 @@\n Mon Aug 11 10:04:49 1997  Jeffrey A Law  (law@cygnus.com)\n \n-\t* Integrate reload bugfix from Wilson which enables the PA port\n+\t* Integrate alias analysis changes from jfc@mit.edu\n+\t* Makefile.in (OBJS): Add alias.o\n+\t(alias.o): Add dependencies.\n+\t* alias.c: New file.\n+\t* sched.c: Remove alias analysis code.  It lives in alias.c now.\n+\t(reg_last_uses_size): Declare.\n+\t(sched_analyze_2): Add new arguments to true_dependence.\n+\t(sched_analyze_insn): Use reg_last_uses_size instead of max_reg.\n+\t(schedule_block): Initialize reg_last_uses_size.\n+\t(schedule_insns): Always call init_alias_analysis.\n+\t* calls.c (expand_call): Note calls to malloc, calloc, and realloc;\n+\tmark return value from such functions as a pointer and keep track of\n+\tthem for alias analysis.  If a return value from a function is a\n+\tpointer, mark it as such.\n+\t* combine.c (distribute_notes): Handle REG_NOALIAS.\n+\t* cse.c (struct write_data): Delete.  No longer needed.\n+\t(invalidate): Don't call set_nonvarying_address_components anymore.\n+\tUse true_dependence to decide if an entry should be removed from\n+\tthe hash table.\n+\t(invalidate_memory): Remove WRITES argument, simplify appropriately.\n+\tFix all callers.\n+\t(note_mem_written): Similarly for WRITE_PTR argument.\n+\t(invalidate_from_clobbers): Similarly for W argument.\n+\t(invalidate_for_call): Remove memory elements from the hash table.\n+\t(refers_to_mem_p, cse_rtx_addr_varies_p): Deleted.\n+\t(cse_rtx_varies_p): New function.  Derived from old\n+\tcse_rtx_addr_varies_p.\n+\t(cse_insn): Remove WRITES_MEMORY and INIT variables and all references.\n+\tDon't call note_mem_written anymore.  Stack pushes invalidate the stack\n+\tpointer if PUSH_ROUNDING is defined.  No longer need to call\n+\tcse_rtx_addr_varies_p to decide if a MEM should be invalidated.\n+\t(skipped_writes_memory): Remove variable.\n+\t(invalidate_skipped_set): Simplify and wewrite to use invalidate_memory.\n+\t(invalidate_skipped_block): Simplify for new alias analysis code.\n+\t(cse_set_around_loop): Likewise.\n+\t(cse_main): Call init_alias_analysis.\n+\t* flags.h (flag_alias_check, flag_argument_noalias): Declare.\n+\t* toplev.c (flag_alias_check, flag_argument_noalias): Define.\n+\t(f_options): Add new alias checking arguments.\n+\t(main): Set flag_alias_check when optimizing.\n+\t* local_alloc (validate_equiv_mem_from_store): Add new arguments\n+\tto true_dependence.\n+\t(memref_referenced_p): Likewise.\n+\t* loop.c (NUM_STORES): Increase to 30.\n+\t(prescan_loop): Only non-constant calls set unknown_address_altered.\n+\t(invariant_p): Add new arguments to true_dependence.\n+\t(record_giv): Initialize unrolled and shared fields.\n+\t(emit_iv_add_mult): Call record_base_value as needed.\n+\t* loop.h (struct induction): Add unrolled and shared fields.\n+\t* unroll.c  (unroll_loop): Call record_base_value as needed.\n+\t(copy_loop_body): Likewise.\n+\t(final_biv_value): Likewise.\n+\t(final_giv_value): Likewise.\n+\t(find_splittable_regs): Likewise.  Only create one new pseudo\n+\tif we have multiple address GIVs that were combined with the same\n+\tdst_reg GIV.  Note when a new register is created due to unrolling.\n+\t* rtl.c (reg_note_name): Add REG_NOALIAS.\n+\t* rtl.h (enum reg_note): Similarly.\n+\t(rtx_varies_p, may_trap_p, side_effects_p): Declare.\n+\t(volatile_refs_p, volatile_insn_p, remove_note): Likewise.\n+\t(note_stores, refers_to_regno_p, reg_overlap_mentioned_p): Likewise.\n+\t(true_dependence, read_dependence, anti_dependence): Likewise.\n+\t(output_dependence, init_alias_analysis, end_alias_analysis): Likewise.\n+\t(mark_user_reg, mark_reg_pointer): Likewise.\n+\n+\n+\t* Integrate reload bugfix from Wilon which enables the PA port\n \tto bootstrap again.\n \t* reload1.c (reload): Sum needs for both OPADDR_ADDR and and\n \tOPERAND_ADDRESS when computing how many registers an insn needs."}, {"sha": "7d7e6daa684166548115caf345104d11f483df08", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -554,7 +554,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o \\\n  integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o \\\n  regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n- insn-peep.o reorg.o sched.o final.o recog.o reg-stack.o \\\n+ insn-peep.o reorg.o alias.o sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o convert.o $(EXTRA_OBJS)\n \n@@ -1321,6 +1321,8 @@ caller-save.o : caller-save.c $(CONFIG_H) $(RTL_H) flags.h \\\n reorg.o : reorg.c $(CONFIG_H) $(RTL_H) conditions.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) regs.h insn-config.h insn-attr.h insn-flags.h recog.h \\\n    flags.h output.h\n+alias.o : alias.c $(CONFIG_H) $(RTL_H) flags.h hard-reg-set.h regs.h \\\n+   insn-codes.h\n sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) $(RTL_H) $(BASIC_BLOCK_H) regs.h hard-reg-set.h \\\n    flags.h insn-config.h insn-attr.h\n final.o : final.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h regs.h \\"}, {"sha": "75c784084b2af9fa05f2b447f2350ae426fab4d0", "filename": "gcc/alias.c", "status": "added", "additions": 1015, "deletions": 0, "changes": 1015, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -0,0 +1,1015 @@\n+/* Alias analysis for GNU C\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Contributed by John Carr (jfc@mit.edu).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+\n+static rtx canon_rtx\t\t\tPROTO((rtx));\n+static int rtx_equal_for_memref_p\tPROTO((rtx, rtx));\n+static rtx find_symbolic_term\t\tPROTO((rtx));\n+static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n+\t\t\t\t\t       HOST_WIDE_INT));\n+\n+/* Set up all info needed to perform alias analysis on memory references.  */\n+\n+#define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n+\n+/* reg_base_value[N] gives an address to which register N is related.\n+   If all sets after the first add or subtract to the current value\n+   or otherwise modify it so it does not point to a different top level\n+   object, reg_base_value[N] is equal to the address part of the source\n+   of the first set.  The value will be a SYMBOL_REF, a LABEL_REF, or\n+   (address (reg)) to indicate that the address is derived from an\n+   argument or fixed register.  */\n+rtx *reg_base_value;\n+unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n+#define REG_BASE_VALUE(X) \\\n+\t(REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n+\n+/* Vector indexed by N giving the initial (unchanging) value known\n+   for pseudo-register N.  */\n+rtx *reg_known_value;\n+\n+/* Indicates number of valid entries in reg_known_value.  */\n+static int reg_known_value_size;\n+\n+/* Vector recording for each reg_known_value whether it is due to a\n+   REG_EQUIV note.  Future passes (viz., reload) may replace the\n+   pseudo with the equivalent expression and so we account for the\n+   dependences that would be introduced if that happens. */\n+/* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in\n+   assign_parms mention the arg pointer, and there are explicit insns in the\n+   RTL that modify the arg pointer.  Thus we must ensure that such insns don't\n+   get scheduled across each other because that would invalidate the REG_EQUIV\n+   notes.  One could argue that the REG_EQUIV notes are wrong, but solving\n+   the problem in the scheduler will likely give better code, so we do it\n+   here.  */\n+char *reg_known_equiv_p;\n+\n+/* Inside SRC, the source of a SET, find a base address.  */\n+\n+/* When copying arguments into pseudo-registers, record the (ADDRESS)\n+   expression for the argument directly so that even if the argument\n+   register is changed later (e.g. for a function call) the original\n+   value is noted.  */\n+static int copying_arguments;\n+\n+static rtx\n+find_base_value (src)\n+     register rtx src;\n+{\n+  switch (GET_CODE (src))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return src;\n+\n+    case REG:\n+      if (copying_arguments && REGNO (src) < FIRST_PSEUDO_REGISTER)\n+\treturn reg_base_value[REGNO (src)];\n+      return src;\n+\n+    case MEM:\n+      /* Check for an argument passed in memory.  Only record in the\n+\t copying-arguments block; it is too hard to track changes\n+\t otherwise.  */\n+      if (copying_arguments\n+\t  && (XEXP (src, 0) == arg_pointer_rtx\n+\t      || (GET_CODE (XEXP (src, 0)) == PLUS\n+\t\t  && XEXP (XEXP (src, 0), 0) == arg_pointer_rtx)))\n+\treturn gen_rtx (ADDRESS, VOIDmode, src);\n+      return 0;\n+\n+    case CONST:\n+      src = XEXP (src, 0);\n+      if (GET_CODE (src) != PLUS && GET_CODE (src) != MINUS)\n+\tbreak;\n+      /* fall through */\n+    case PLUS:\n+    case MINUS:\n+      /* Guess which operand to set the register equivalent to.  */\n+      /* If the first operand is a symbol or the second operand is\n+\t an integer, the first operand is the base address.  */\n+      if (GET_CODE (XEXP (src, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (src, 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\treturn XEXP (src, 0);\n+      /* If an operand is a register marked as a pointer, it is the base.  */\n+      if (GET_CODE (XEXP (src, 0)) == REG\n+\t  && REGNO_POINTER_FLAG (REGNO (XEXP (src, 0))))\n+\tsrc = XEXP (src, 0);\n+      else if (GET_CODE (XEXP (src, 1)) == REG\n+\t  && REGNO_POINTER_FLAG (REGNO (XEXP (src, 1))))\n+\tsrc = XEXP (src, 1);\n+      else\n+\treturn 0;\n+      if (copying_arguments && REGNO (src) < FIRST_PSEUDO_REGISTER)\n+\treturn reg_base_value[REGNO (src)];\n+      return src;\n+\n+    case AND:\n+      /* If the second operand is constant set the base\n+\t address to the first operand. */\n+      if (GET_CODE (XEXP (src, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (src, 0)) == REG)\n+\t{\n+\t  src = XEXP (src, 0);\n+\t  if (copying_arguments && REGNO (src) < FIRST_PSEUDO_REGISTER)\n+\t    return reg_base_value[REGNO (src)];\n+\t  return src;\n+\t}\n+      return 0;\n+\n+    case HIGH:\n+      return XEXP (src, 0);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Called from init_alias_analysis indirectly through note_stores.  */\n+\n+/* while scanning insns to find base values, reg_seen[N] is nonzero if\n+   register N has been set in this function.  */\n+static char *reg_seen;\n+\n+static\n+void record_set (dest, set)\n+     rtx dest, set;\n+{\n+  register int regno;\n+  rtx src;\n+\n+  if (GET_CODE (dest) != REG)\n+    return;\n+\n+  regno = REGNO (dest);\n+\n+  if (set)\n+    {\n+      /* A CLOBBER wipes out any old value but does not prevent a previously\n+\t unset register from acquiring a base address (i.e. reg_seen is not\n+\t set).  */\n+      if (GET_CODE (set) == CLOBBER)\n+\t{\n+\t  reg_base_value[regno] = 0;\n+\t  return;\n+\t}\n+      src = SET_SRC (set);\n+    }\n+  else\n+    {\n+      static int unique_id;\n+      if (reg_seen[regno])\n+\t{\n+\t  reg_base_value[regno] = 0;\n+\t  return;\n+\t}\n+      reg_seen[regno] = 1;\n+      reg_base_value[regno] = gen_rtx (ADDRESS, Pmode,\n+\t\t\t\t       GEN_INT (unique_id++));\n+      return;\n+    }\n+\n+  /* This is not the first set.  If the new value is not related to the\n+     old value, forget the base value. Note that the following code is\n+     not detected:\n+     extern int x, y;  int *p = &x; p += (&y-&x);\n+     ANSI C does not allow computing the difference of addresses\n+     of distinct top level objects.  */\n+  if (reg_base_value[regno])\n+    switch (GET_CODE (src))\n+      {\n+      case PLUS:\n+      case MINUS:\n+\tif (XEXP (src, 0) != dest && XEXP (src, 1) != dest)\n+\t  reg_base_value[regno] = 0;\n+\tbreak;\n+      case AND:\n+\tif (XEXP (src, 0) != dest || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\t  reg_base_value[regno] = 0;\n+\tbreak;\n+      case LO_SUM:\n+\tif (XEXP (src, 0) != dest)\n+\t  reg_base_value[regno] = 0;\n+\tbreak;\n+      default:\n+\treg_base_value[regno] = 0;\n+\tbreak;\n+      }\n+  /* If this is the first set of a register, record the value.  */\n+  else if ((regno >= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])\n+\t   && ! reg_seen[regno] && reg_base_value[regno] == 0)\n+    reg_base_value[regno] = find_base_value (src);\n+\n+  reg_seen[regno] = 1;\n+}\n+\n+/* Called from loop optimization when a new pseudo-register is created.  */\n+void\n+record_base_value (regno, val)\n+     int regno;\n+     rtx val;\n+{\n+  if (!flag_alias_check || regno >= reg_base_value_size)\n+    return;\n+  if (GET_CODE (val) == REG)\n+    {\n+      if (REGNO (val) < reg_base_value_size)\n+\treg_base_value[regno] = reg_base_value[REGNO (val)];\n+      return;\n+    }\n+  reg_base_value[regno] = find_base_value (val);\n+}\n+\n+static rtx\n+canon_rtx (x)\n+     rtx x;\n+{\n+  /* Recursively look for equivalences.  */\n+  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+      && REGNO (x) < reg_known_value_size)\n+    return reg_known_value[REGNO (x)] == x\n+      ? x : canon_rtx (reg_known_value[REGNO (x)]);\n+  else if (GET_CODE (x) == PLUS)\n+    {\n+      rtx x0 = canon_rtx (XEXP (x, 0));\n+      rtx x1 = canon_rtx (XEXP (x, 1));\n+\n+      if (x0 != XEXP (x, 0) || x1 != XEXP (x, 1))\n+\t{\n+\t  /* We can tolerate LO_SUMs being offset here; these\n+\t     rtl are used for nothing other than comparisons.  */\n+\t  if (GET_CODE (x0) == CONST_INT)\n+\t    return plus_constant_for_output (x1, INTVAL (x0));\n+\t  else if (GET_CODE (x1) == CONST_INT)\n+\t    return plus_constant_for_output (x0, INTVAL (x1));\n+\t  return gen_rtx (PLUS, GET_MODE (x), x0, x1);\n+\t}\n+    }\n+  /* This gives us much better alias analysis when called from\n+     the loop optimizer.   Note we want to leave the original\n+     MEM alone, but need to return the canonicalized MEM with\n+     all the flags with their original values.  */\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      rtx addr = canon_rtx (XEXP (x, 0));\n+      if (addr != XEXP (x, 0))\n+\t{\n+\t  rtx new = gen_rtx (MEM, GET_MODE (x), addr);\n+\t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n+\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n+\t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n+\t  x = new;\n+\t}\n+    }\n+  return x;\n+}\n+\n+/* Return 1 if X and Y are identical-looking rtx's.\n+\n+   We use the data in reg_known_value above to see if two registers with\n+   different numbers are, in fact, equivalent.  */\n+\n+static int\n+rtx_equal_for_memref_p (x, y)\n+     rtx x, y;\n+{\n+  register int i;\n+  register int j;\n+  register enum rtx_code code;\n+  register char *fmt;\n+\n+  if (x == 0 && y == 0)\n+    return 1;\n+  if (x == 0 || y == 0)\n+    return 0;\n+  x = canon_rtx (x);\n+  y = canon_rtx (y);\n+\n+  if (x == y)\n+    return 1;\n+\n+  code = GET_CODE (x);\n+  /* Rtx's of different codes cannot be equal.  */\n+  if (code != GET_CODE (y))\n+    return 0;\n+\n+  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.\n+     (REG:SI x) and (REG:HI x) are NOT equivalent.  */\n+\n+  if (GET_MODE (x) != GET_MODE (y))\n+    return 0;\n+\n+  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */\n+\n+  if (code == REG)\n+    return REGNO (x) == REGNO (y);\n+  if (code == LABEL_REF)\n+    return XEXP (x, 0) == XEXP (y, 0);\n+  if (code == SYMBOL_REF)\n+    return XSTR (x, 0) == XSTR (y, 0);\n+\n+  /* For commutative operations, the RTX match if the operand match in any\n+     order.  Also handle the simple binary and unary cases without a loop.  */\n+  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c')\n+    return ((rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 0))\n+\t     && rtx_equal_for_memref_p (XEXP (x, 1), XEXP (y, 1)))\n+\t    || (rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 1))\n+\t\t&& rtx_equal_for_memref_p (XEXP (x, 1), XEXP (y, 0))));\n+  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == '2')\n+    return (rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 0))\n+\t    && rtx_equal_for_memref_p (XEXP (x, 1), XEXP (y, 1)));\n+  else if (GET_RTX_CLASS (code) == '1')\n+    return rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 0));\n+\n+  /* Compare the elements.  If any pair of corresponding elements\n+     fail to match, return 0 for the whole things.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (rtx_equal_for_memref_p (XVECEXP (x, i, j), XVECEXP (y, i, j)) == 0)\n+\t      return 0;\n+\t  break;\n+\n+\tcase 'e':\n+\t  if (rtx_equal_for_memref_p (XEXP (x, i), XEXP (y, i)) == 0)\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\n+\tcase '0':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* Given an rtx X, find a SYMBOL_REF or LABEL_REF within\n+   X and return it, or return 0 if none found.  */\n+\n+static rtx\n+find_symbolic_term (x)\n+     rtx x;\n+{\n+  register int i;\n+  register enum rtx_code code;\n+  register char *fmt;\n+\n+  code = GET_CODE (x);\n+  if (code == SYMBOL_REF || code == LABEL_REF)\n+    return x;\n+  if (GET_RTX_CLASS (code) == 'o')\n+    return 0;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      rtx t;\n+\n+      if (fmt[i] == 'e')\n+\t{\n+\t  t = find_symbolic_term (XEXP (x, i));\n+\t  if (t != 0)\n+\t    return t;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tbreak;\n+    }\n+  return 0;\n+}\n+\n+static rtx\n+find_base_term (x)\n+     register rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      return REG_BASE_VALUE (x);\n+\n+    case HIGH:\n+      return find_base_term (XEXP (x, 0));\n+\n+    case CONST:\n+      x = XEXP (x, 0);\n+      if (GET_CODE (x) != PLUS && GET_CODE (x) != MINUS)\n+\treturn 0;\n+      /* fall through */\n+    case LO_SUM:\n+    case PLUS:\n+    case MINUS:\n+      {\n+\trtx tmp = find_base_term (XEXP (x, 0));\n+\tif (tmp)\n+\t  return tmp;\n+\treturn find_base_term (XEXP (x, 1));\n+      }\n+\n+    case AND:\n+      if (GET_CODE (XEXP (x, 0)) == REG && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\treturn REG_BASE_VALUE (XEXP (x, 0));\n+      return 0;\n+\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return x;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 0 if the addresses X and Y are known to point to different\n+   objects, 1 if they might be pointers to the same object.  */\n+\n+static int\n+base_alias_check (x, y)\n+     rtx x, y;\n+{\n+  rtx x_base = find_base_term (x);\n+  rtx y_base = find_base_term (y);\n+\n+  /* If either base address is unknown or the base addresses are equal,\n+     nothing is known about aliasing.  */\n+\n+  if (x_base == 0 || y_base == 0 || rtx_equal_p (x_base, y_base))\n+    return 1;\n+\n+  /* The base addresses of the read and write are different\n+     expressions.  If they are both symbols there is no\n+     conflict.  */\n+  if (GET_CODE (x_base) != ADDRESS && GET_CODE (y_base) != ADDRESS)\n+    return 0;\n+\n+  /* If one address is a stack reference there can be no alias:\n+     stack references using different base registers do not alias,\n+     a stack reference can not alias a parameter, and a stack reference\n+     can not alias a global.  */\n+  if ((GET_CODE (x_base) == ADDRESS && GET_MODE (x_base) == Pmode)\n+      || (GET_CODE (y_base) == ADDRESS && GET_MODE (y_base) == Pmode))\n+    return 0;\n+\n+  if (! flag_argument_noalias)\n+    return 1;\n+\n+  if (flag_argument_noalias > 1)\n+    return 0;\n+\n+  /* Weak noalias assertion (arguments are distinct, but may match globals). */\n+  return ! (GET_MODE (x_base) == VOIDmode && GET_MODE (y_base) == VOIDmode);\n+}\n+\n+/* Return nonzero if X and Y (memory addresses) could reference the\n+   same location in memory.  C is an offset accumulator.  When\n+   C is nonzero, we are testing aliases between X and Y + C.\n+   XSIZE is the size in bytes of the X reference,\n+   similarly YSIZE is the size in bytes for Y.\n+\n+   If XSIZE or YSIZE is zero, we do not know the amount of memory being\n+   referenced (the reference was BLKmode), so make the most pessimistic\n+   assumptions.\n+\n+   We recognize the following cases of non-conflicting memory:\n+\n+\t(1) addresses involving the frame pointer cannot conflict\n+\t    with addresses involving static variables.\n+\t(2) static variables with different addresses cannot conflict.\n+\n+   Nice to notice that varying addresses cannot conflict with fp if no\n+   local variables had their addresses taken, but that's too hard now.  */\n+\n+\n+static int\n+memrefs_conflict_p (xsize, x, ysize, y, c)\n+     register rtx x, y;\n+     int xsize, ysize;\n+     HOST_WIDE_INT c;\n+{\n+  if (GET_CODE (x) == HIGH)\n+    x = XEXP (x, 0);\n+  else if (GET_CODE (x) == LO_SUM)\n+    x = XEXP (x, 1);\n+  else\n+    x = canon_rtx (x);\n+  if (GET_CODE (y) == HIGH)\n+    y = XEXP (y, 0);\n+  else if (GET_CODE (y) == LO_SUM)\n+    y = XEXP (y, 1);\n+  else\n+    y = canon_rtx (y);\n+\n+  if (rtx_equal_for_memref_p (x, y))\n+    {\n+      if (xsize == 0 || ysize == 0)\n+\treturn 1;\n+      if (c >= 0 && xsize > c)\n+\treturn 1;\n+      if (c < 0 && ysize+c > 0)\n+\treturn 1;\n+      return 0;\n+    }\n+\n+  if (y == frame_pointer_rtx || y == hard_frame_pointer_rtx\n+      || y == stack_pointer_rtx)\n+    {\n+      rtx t = y;\n+      int tsize = ysize;\n+      y = x; ysize = xsize;\n+      x = t; xsize = tsize;\n+    }\n+\n+  if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n+      || x == stack_pointer_rtx)\n+    {\n+      rtx y1;\n+\n+      if (CONSTANT_P (y))\n+\treturn 0;\n+\n+      if (GET_CODE (y) == PLUS\n+\t  && canon_rtx (XEXP (y, 0)) == x\n+\t  && (y1 = canon_rtx (XEXP (y, 1)))\n+\t  && GET_CODE (y1) == CONST_INT)\n+\t{\n+\t  c += INTVAL (y1);\n+\t  return (xsize == 0 || ysize == 0\n+\t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n+\t}\n+\n+      if (GET_CODE (y) == PLUS\n+\t  && (y1 = canon_rtx (XEXP (y, 0)))\n+\t  && CONSTANT_P (y1))\n+\treturn 0;\n+\n+      return 1;\n+    }\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      /* The fact that X is canonicalized means that this\n+\t PLUS rtx is canonicalized.  */\n+      rtx x0 = XEXP (x, 0);\n+      rtx x1 = XEXP (x, 1);\n+\n+      if (GET_CODE (y) == PLUS)\n+\t{\n+\t  /* The fact that Y is canonicalized means that this\n+\t     PLUS rtx is canonicalized.  */\n+\t  rtx y0 = XEXP (y, 0);\n+\t  rtx y1 = XEXP (y, 1);\n+\n+\t  if (rtx_equal_for_memref_p (x1, y1))\n+\t    return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n+\t  if (rtx_equal_for_memref_p (x0, y0))\n+\t    return memrefs_conflict_p (xsize, x1, ysize, y1, c);\n+\t  if (GET_CODE (x1) == CONST_INT)\n+\t    if (GET_CODE (y1) == CONST_INT)\n+\t      return memrefs_conflict_p (xsize, x0, ysize, y0,\n+\t\t\t\t\t c - INTVAL (x1) + INTVAL (y1));\n+\t    else\n+\t      return memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n+\t  else if (GET_CODE (y1) == CONST_INT)\n+\t    return memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n+\n+\t  /* Handle case where we cannot understand iteration operators,\n+\t     but we notice that the base addresses are distinct objects.  */\n+\t  /* ??? Is this still necessary? */\n+\t  x = find_symbolic_term (x);\n+\t  if (x == 0)\n+\t    return 1;\n+\t  y = find_symbolic_term (y);\n+\t  if (y == 0)\n+\t    return 1;\n+\t  return rtx_equal_for_memref_p (x, y);\n+\t}\n+      else if (GET_CODE (x1) == CONST_INT)\n+\treturn memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n+    }\n+  else if (GET_CODE (y) == PLUS)\n+    {\n+      /* The fact that Y is canonicalized means that this\n+\t PLUS rtx is canonicalized.  */\n+      rtx y0 = XEXP (y, 0);\n+      rtx y1 = XEXP (y, 1);\n+\n+      if (GET_CODE (y1) == CONST_INT)\n+\treturn memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n+      else\n+\treturn 1;\n+    }\n+\n+  if (GET_CODE (x) == GET_CODE (y))\n+    switch (GET_CODE (x))\n+      {\n+      case MULT:\n+\t{\n+\t  /* Handle cases where we expect the second operands to be the\n+\t     same, and check only whether the first operand would conflict\n+\t     or not.  */\n+\t  rtx x0, y0;\n+\t  rtx x1 = canon_rtx (XEXP (x, 1));\n+\t  rtx y1 = canon_rtx (XEXP (y, 1));\n+\t  if (! rtx_equal_for_memref_p (x1, y1))\n+\t    return 1;\n+\t  x0 = canon_rtx (XEXP (x, 0));\n+\t  y0 = canon_rtx (XEXP (y, 0));\n+\t  if (rtx_equal_for_memref_p (x0, y0))\n+\t    return (xsize == 0 || ysize == 0\n+\t\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n+\n+\t  /* Can't properly adjust our sizes.  */\n+\t  if (GET_CODE (x1) != CONST_INT)\n+\t    return 1;\n+\t  xsize /= INTVAL (x1);\n+\t  ysize /= INTVAL (x1);\n+\t  c /= INTVAL (x1);\n+\t  return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n+\t}\n+      }\n+\n+  /* Treat an access through an AND (e.g. a subword access on an Alpha)\n+     as an access with indeterminate size.  */\n+  if (GET_CODE (x) == AND && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return memrefs_conflict_p (0, XEXP (x, 0), ysize, y, c);\n+  if (GET_CODE (y) == AND && GET_CODE (XEXP (y, 1)) == CONST_INT)\n+    return memrefs_conflict_p (xsize, x, 0, XEXP (y, 0), c);\n+\n+  if (CONSTANT_P (x))\n+    {\n+      if (GET_CODE (x) == CONST_INT && GET_CODE (y) == CONST_INT)\n+\t{\n+\t  c += (INTVAL (y) - INTVAL (x));\n+\t  return (xsize == 0 || ysize == 0\n+\t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n+\t}\n+\n+      if (GET_CODE (x) == CONST)\n+\t{\n+\t  if (GET_CODE (y) == CONST)\n+\t    return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)),\n+\t\t\t\t       ysize, canon_rtx (XEXP (y, 0)), c);\n+\t  else\n+\t    return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)),\n+\t\t\t\t       ysize, y, c);\n+\t}\n+      if (GET_CODE (y) == CONST)\n+\treturn memrefs_conflict_p (xsize, x, ysize,\n+\t\t\t\t   canon_rtx (XEXP (y, 0)), c);\n+\n+      if (CONSTANT_P (y))\n+\treturn (rtx_equal_for_memref_p (x, y)\n+\t\t&& (xsize == 0 || ysize == 0\n+\t\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0)));\n+\n+      return 1;\n+    }\n+  return 1;\n+}\n+\n+/* Functions to compute memory dependencies.\n+\n+   Since we process the insns in execution order, we can build tables\n+   to keep track of what registers are fixed (and not aliased), what registers\n+   are varying in known ways, and what registers are varying in unknown\n+   ways.\n+\n+   If both memory references are volatile, then there must always be a\n+   dependence between the two references, since their order can not be\n+   changed.  A volatile and non-volatile reference can be interchanged\n+   though. \n+\n+   A MEM_IN_STRUCT reference at a non-QImode varying address can never\n+   conflict with a non-MEM_IN_STRUCT reference at a fixed address.   We must\n+   allow QImode aliasing because the ANSI C standard allows character\n+   pointers to alias anything.  We are assuming that characters are\n+   always QImode here.  */\n+\n+/* Read dependence: X is read after read in MEM takes place.  There can\n+   only be a dependence here if both reads are volatile.  */\n+\n+int\n+read_dependence (mem, x)\n+     rtx mem;\n+     rtx x;\n+{\n+  return MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem);\n+}\n+\n+/* True dependence: X is read after store in MEM takes place.  */\n+\n+int\n+true_dependence (mem, mem_mode, x, varies)\n+     rtx mem;\n+     enum machine_mode mem_mode;\n+     rtx x;\n+     int (*varies)();\n+{\n+  rtx x_addr, mem_addr;\n+\n+  if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n+    return 1;\n+\n+  x_addr = XEXP (x, 0);\n+  mem_addr = XEXP (mem, 0);\n+\n+  if (flag_alias_check && ! base_alias_check (x_addr, mem_addr))\n+    return 0;\n+\n+  /* If X is an unchanging read, then it can't possibly conflict with any\n+     non-unchanging store.  It may conflict with an unchanging write though,\n+     because there may be a single store to this address to initialize it.\n+     Just fall through to the code below to resolve the case where we have\n+     both an unchanging read and an unchanging write.  This won't handle all\n+     cases optimally, but the possible performance loss should be\n+     negligible.  */\n+  if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n+    return 0;\n+\n+  x_addr = canon_rtx (x_addr);\n+  mem_addr = canon_rtx (mem_addr);\n+  if (mem_mode == VOIDmode)\n+    mem_mode = GET_MODE (mem);\n+\n+  if (! memrefs_conflict_p (mem_mode, mem_addr, SIZE_FOR_MODE (x), x_addr, 0))\n+    return 0;\n+\n+  /* If both references are struct references, or both are not, nothing\n+     is known about aliasing.\n+\n+     If either reference is QImode or BLKmode, ANSI C permits aliasing.\n+\n+     If both addresses are constant, or both are not, nothing is known\n+     about aliasing.  */\n+  if (MEM_IN_STRUCT_P (x) == MEM_IN_STRUCT_P (mem)\n+      || mem_mode == QImode || mem_mode == BLKmode\n+      || GET_MODE (x) == QImode || GET_MODE (mem) == BLKmode\n+      || varies (x_addr) == varies (mem_addr))\n+    return 1;\n+\n+  /* One memory reference is to a constant address, one is not.\n+     One is to a structure, the other is not.\n+\n+     If either memory reference is a variable structure the other is a\n+     fixed scalar and there is no aliasing.  */\n+  if ((MEM_IN_STRUCT_P (mem) && varies (mem_addr))\n+      || (MEM_IN_STRUCT_P (x) && varies (x)))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Anti dependence: X is written after read in MEM takes place.  */\n+\n+int\n+anti_dependence (mem, x)\n+     rtx mem;\n+     rtx x;\n+{\n+  if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n+    return 1;\n+\n+  if (flag_alias_check && ! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n+    return 0;\n+\n+  /* If MEM is an unchanging read, then it can't possibly conflict with\n+     the store to X, because there is at most one store to MEM, and it must\n+     have occurred somewhere before MEM.  */\n+  x = canon_rtx (x);\n+  mem = canon_rtx (mem);\n+  if (RTX_UNCHANGING_P (mem))\n+    return 0;\n+\n+  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n+\t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n+\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n+\t\t&& GET_MODE (mem) != QImode\n+\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n+\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n+\t\t&& GET_MODE (x) != QImode\n+\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n+}\n+\n+/* Output dependence: X is written after store in MEM takes place.  */\n+\n+int\n+output_dependence (mem, x)\n+     register rtx mem;\n+     register rtx x;\n+{\n+  if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n+    return 1;\n+\n+  if (flag_alias_check && !base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n+    return 0;\n+\n+  x = canon_rtx (x);\n+  mem = canon_rtx (mem);\n+  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n+\t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n+\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n+\t\t&& GET_MODE (mem) != QImode\n+\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n+\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n+\t\t&& GET_MODE (x) != QImode\n+\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n+}\n+\n+void\n+init_alias_analysis ()\n+{\n+  int maxreg = max_reg_num ();\n+  int changed;\n+  register int i;\n+  register rtx insn;\n+  rtx note;\n+  rtx set;\n+\n+  reg_known_value_size = maxreg;\n+\n+  reg_known_value\n+    = (rtx *) oballoc ((maxreg - FIRST_PSEUDO_REGISTER) * sizeof (rtx))\n+    - FIRST_PSEUDO_REGISTER;\n+  reg_known_equiv_p =\n+    oballoc (maxreg - FIRST_PSEUDO_REGISTER) - FIRST_PSEUDO_REGISTER;\n+  bzero ((char *) (reg_known_value + FIRST_PSEUDO_REGISTER),\n+\t (maxreg-FIRST_PSEUDO_REGISTER) * sizeof (rtx));\n+  bzero (reg_known_equiv_p + FIRST_PSEUDO_REGISTER,\n+\t (maxreg - FIRST_PSEUDO_REGISTER) * sizeof (char));\n+\n+  if (flag_alias_check)\n+    {\n+      /* Overallocate reg_base_value to allow some growth during loop\n+\t optimization.  Loop unrolling can create a large number of\n+\t registers.  */\n+      reg_base_value_size = maxreg * 2;\n+      reg_base_value = (rtx *)oballoc (reg_base_value_size * sizeof (rtx));\n+      reg_seen = (char *)alloca (reg_base_value_size);\n+      bzero (reg_base_value, reg_base_value_size * sizeof (rtx));\n+      bzero (reg_seen, reg_base_value_size);\n+\n+      /* Mark all hard registers which may contain an address.\n+\t The stack, frame and argument pointers may contain an address.\n+\t An argument register which can hold a Pmode value may contain\n+\t an address even if it is not in BASE_REGS.\n+\n+\t The address expression is VOIDmode for an argument and\n+\t Pmode for other registers.  */\n+#ifndef OUTGOING_REGNO\n+#define OUTGOING_REGNO(N) N\n+#endif\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t/* Check whether this register can hold an incoming pointer\n+\t   argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n+\t   numbers, so translate if necessary due to register windows. */\n+\tif (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i)) && HARD_REGNO_MODE_OK (i, Pmode))\n+\t  reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n+\t\t\t\t       gen_rtx (REG, Pmode, i));\n+\n+      reg_base_value[STACK_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, stack_pointer_rtx);\n+      reg_base_value[ARG_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n+      reg_base_value[FRAME_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n+      reg_base_value[HARD_FRAME_POINTER_REGNUM]\n+\t= gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n+    }\n+\n+  copying_arguments = 1;\n+  /* Fill in the entries with known constant values.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (flag_alias_check && GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  /* If this insn has a noalias note, process it,  Otherwise,\n+\t     scan for sets.  A simple set will have no side effects\n+\t     which could change the base value of any other register. */\n+\t  rtx noalias_note;\n+\t  if (GET_CODE (PATTERN (insn)) == SET\n+\t      && (noalias_note = find_reg_note (insn, REG_NOALIAS, NULL_RTX)))\n+\t      record_set (SET_DEST (PATTERN (insn)), 0);\n+\t  else\n+\t    note_stores (PATTERN (insn), record_set);\n+\t}\n+      else if (GET_CODE (insn) == NOTE\n+\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\tcopying_arguments = 0;\n+\n+      if ((set = single_set (insn)) != 0\n+\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t  && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n+\t       && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n+\t      || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n+\t  && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n+\t{\n+\t  int regno = REGNO (SET_DEST (set));\n+\t  reg_known_value[regno] = XEXP (note, 0);\n+\t  reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t}\n+    }\n+\n+  /* Fill in the remaining entries.  */\n+  for (i = FIRST_PSEUDO_REGISTER; i < maxreg; i++)\n+    if (reg_known_value[i] == 0)\n+      reg_known_value[i] = regno_reg_rtx[i];\n+\n+  if (! flag_alias_check)\n+    return;\n+\n+  /* Simplify the reg_base_value array so that no register refers to\n+     another register, except to special registers indirectly through\n+     ADDRESS expressions.\n+\n+     In theory this loop can take as long as O(registers^2), but unless\n+     there are very long dependency chains it will run in close to linear\n+     time.  */\n+  do\n+    {\n+      changed = 0;\n+      for (i = FIRST_PSEUDO_REGISTER; i < reg_base_value_size; i++)\n+\t{\n+\t  rtx base = reg_base_value[i];\n+\t  if (base && GET_CODE (base) == REG)\n+\t    {\n+\t      int base_regno = REGNO (base);\n+\t      if (base_regno == i)\t\t/* register set from itself */\n+\t\treg_base_value[i] = 0;\n+\t      else\n+\t\treg_base_value[i] = reg_base_value[base_regno];\n+\t      changed = 1;\n+\t    }\n+\t}\n+    }\n+  while (changed);\n+\n+  reg_seen = 0;\n+}\n+\n+void\n+end_alias_analysis ()\n+{\n+  reg_known_value = 0;\n+  reg_base_value = 0;\n+  reg_base_value_size = 0;\n+}"}, {"sha": "2f5c1c2cf68f88ba08a29c495392389b3d11c1ac", "filename": "gcc/calls.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -563,6 +563,8 @@ expand_call (exp, target, ignore)\n \n   /* Nonzero if it is plausible that this is a call to alloca.  */\n   int may_be_alloca;\n+  /* Nonzero if this is a call to malloc or a related function. */\n+  int is_malloc;\n   /* Nonzero if this is a call to setjmp or a related function.  */\n   int returns_twice;\n   /* Nonzero if this is a call to `longjmp'.  */\n@@ -841,6 +843,7 @@ expand_call (exp, target, ignore)\n \n   returns_twice = 0;\n   is_longjmp = 0;\n+  is_malloc = 0;\n \n   if (name != 0 && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 15)\n     {\n@@ -880,6 +883,12 @@ expand_call (exp, target, ignore)\n       else if (tname[0] == 'l' && tname[1] == 'o'\n \t       && ! strcmp (tname, \"longjmp\"))\n \tis_longjmp = 1;\n+      /* Only recognize malloc when alias analysis is enabled.  */\n+      else if (flag_alias_check\n+\t       && ((tname[0] == 'm' && ! strcmp(tname + 1, \"alloc\"))\n+\t\t   || (tname[0] == 'c' && ! strcmp(tname + 1, \"alloc\"))\n+\t\t   || (tname[0] == 'r' && ! strcmp(tname + 1, \"ealloc\"))))\n+\tis_malloc = 1;\n     }\n \n   if (may_be_alloca)\n@@ -1366,7 +1375,7 @@ expand_call (exp, target, ignore)\n \n   /* Now we are about to start emitting insns that can be deleted\n      if a libcall is deleted.  */\n-  if (is_const)\n+  if (is_const || is_malloc)\n     start_sequence ();\n \n   /* If we have no actual push instructions, or shouldn't use them,\n@@ -1948,6 +1957,13 @@ expand_call (exp, target, ignore)\n       rtx temp = gen_reg_rtx (GET_MODE (valreg));\n       rtx insns;\n \n+      /* Mark the return value as a pointer if needed.  */\n+      if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n+\t{\n+\t  tree pointed_to = TREE_TYPE (TREE_TYPE (exp));\n+\t  mark_reg_pointer (temp, TYPE_ALIGN (pointed_to) / BITS_PER_UNIT);\n+\t}\n+\n       /* Construct an \"equal form\" for the value which mentions all the\n \t arguments in order as well as the function name.  */\n #ifdef PUSH_ARGS_REVERSED\n@@ -1974,6 +1990,29 @@ expand_call (exp, target, ignore)\n       end_sequence ();\n       emit_insns (insns);\n     }\n+  else if (is_malloc)\n+    {\n+      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n+      rtx last, insns;\n+\n+      /* The return value from a malloc-like function is a pointer. */\n+      if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n+\tmark_reg_pointer (temp, BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n+\n+      emit_move_insn (temp, valreg);\n+\n+      /* The return value from a malloc-like function can not alias\n+\t anything else.  */\n+      last = get_last_insn ();\n+      REG_NOTES (last) = \n+\tgen_rtx (EXPR_LIST, REG_NOALIAS, temp, REG_NOTES (last));\n+\n+      /* Write out the sequence.  */\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_insns (insns);\n+      valreg = temp;\n+    }\n \n   /* For calls to `setjmp', etc., inform flow.c it should complain\n      if nonvolatile values are live.  */"}, {"sha": "7ce64e45b715b6ddf0545c4815069ca2d1baed98", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -11058,6 +11058,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \tcase REG_EQUAL:\n \tcase REG_EQUIV:\n \tcase REG_NONNEG:\n+\tcase REG_NOALIAS:\n \t  /* These notes say something about results of an insn.  We can\n \t     only support them if they used to be on I3 in which case they\n \t     remain on I3.  Otherwise they are ignored."}, {"sha": "096a630aeb4a85343ac9946e3d53028627641db7", "filename": "gcc/cse.c", "status": "modified", "additions": 131, "deletions": 299, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -519,27 +519,6 @@ static struct table_elt *last_jump_equiv_class;\n \n static int constant_pool_entries_cost;\n \n-/* Bits describing what kind of values in memory must be invalidated\n-   for a particular instruction.  If all three bits are zero,\n-   no memory refs need to be invalidated.  Each bit is more powerful\n-   than the preceding ones, and if a bit is set then the preceding\n-   bits are also set.\n-\n-   Here is how the bits are set:\n-   Pushing onto the stack invalidates only the stack pointer,\n-   writing at a fixed address invalidates only variable addresses,\n-   writing in a structure element at variable address\n-     invalidates all but scalar variables,\n-   and writing in anything else at variable address invalidates everything.  */\n-\n-struct write_data\n-{\n-  int sp : 1;\t\t\t/* Invalidate stack pointer.  */\n-  int var : 1;\t\t\t/* Invalidate variable addresses.  */\n-  int nonscalar : 1;\t\t/* Invalidate all but scalar variables.  */\n-  int all : 1;\t\t\t/* Invalidate all memory refs.  */\n-};\n-\n /* Define maximum length of a branch path.  */\n \n #define PATHLENGTH\t10\n@@ -626,9 +605,10 @@ static struct table_elt *insert PROTO((rtx, struct table_elt *, unsigned,\n static void merge_equiv_classes PROTO((struct table_elt *,\n \t\t\t\t       struct table_elt *));\n static void invalidate\t\tPROTO((rtx, enum machine_mode));\n+static int cse_rtx_varies_p\tPROTO((rtx));\n static void remove_invalid_refs\tPROTO((int));\n static void rehash_using_reg\tPROTO((rtx));\n-static void invalidate_memory\tPROTO((struct write_data *));\n+static void invalidate_memory\tPROTO((void));\n static void invalidate_for_call\tPROTO((void));\n static rtx use_related_value\tPROTO((rtx, struct table_elt *));\n static unsigned canon_hash\tPROTO((rtx, enum machine_mode));\n@@ -638,9 +618,6 @@ static void set_nonvarying_address_components PROTO((rtx, int, rtx *,\n \t\t\t\t\t\t     HOST_WIDE_INT *,\n \t\t\t\t\t\t     HOST_WIDE_INT *));\n static int refers_to_p\t\tPROTO((rtx, rtx));\n-static int refers_to_mem_p\tPROTO((rtx, rtx, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT));\n-static int cse_rtx_addr_varies_p PROTO((rtx));\n static rtx canon_reg\t\tPROTO((rtx, rtx));\n static void find_best_addr\tPROTO((rtx, rtx *));\n static enum rtx_code find_comparison_args PROTO((enum rtx_code, rtx *, rtx *,\n@@ -656,8 +633,8 @@ static void record_jump_equiv\tPROTO((rtx, int));\n static void record_jump_cond\tPROTO((enum rtx_code, enum machine_mode,\n \t\t\t\t       rtx, rtx, int));\n static void cse_insn\t\tPROTO((rtx, int));\n-static void note_mem_written\tPROTO((rtx, struct write_data *));\n-static void invalidate_from_clobbers PROTO((struct write_data *, rtx));\n+static int note_mem_written\tPROTO((rtx));\n+static void invalidate_from_clobbers PROTO((rtx));\n static rtx cse_process_notes\tPROTO((rtx, rtx));\n static void cse_around_loop\tPROTO((rtx));\n static void invalidate_skipped_set PROTO((rtx, rtx));\n@@ -1534,8 +1511,6 @@ invalidate (x, full_mode)\n {\n   register int i;\n   register struct table_elt *p;\n-  rtx base;\n-  HOST_WIDE_INT start, end;\n \n   /* If X is a register, dependencies on its contents\n      are recorded through the qty number mechanism.\n@@ -1627,16 +1602,17 @@ invalidate (x, full_mode)\n   if (full_mode == VOIDmode)\n     full_mode = GET_MODE (x);\n \n-  set_nonvarying_address_components (XEXP (x, 0), GET_MODE_SIZE (full_mode),\n-\t\t\t\t     &base, &start, &end);\n-\n   for (i = 0; i < NBUCKETS; i++)\n     {\n       register struct table_elt *next;\n       for (p = table[i]; p; p = next)\n \t{\n \t  next = p->next_same_hash;\n-\t  if (refers_to_mem_p (p->exp, base, start, end))\n+\t  /* Invalidate ASM_OPERANDS which reference memory (this is easier\n+\t     than checking all the aliases).  */\n+\t  if (p->in_memory\n+\t      && (GET_CODE (p->exp) != MEM\n+\t\t  || true_dependence (x, full_mode, p->exp, cse_rtx_varies_p)))\n \t    remove_from_table (p, i);\n \t}\n     }\n@@ -1717,30 +1693,6 @@ rehash_using_reg (x)\n       }\n }\n \f\n-/* Remove from the hash table all expressions that reference memory,\n-   or some of them as specified by *WRITES.  */\n-\n-static void\n-invalidate_memory (writes)\n-     struct write_data *writes;\n-{\n-  register int i;\n-  register struct table_elt *p, *next;\n-  int all = writes->all;\n-  int nonscalar = writes->nonscalar;\n-\n-  for (i = 0; i < NBUCKETS; i++)\n-    for (p = table[i]; p; p = next)\n-      {\n-\tnext = p->next_same_hash;\n-\tif (p->in_memory\n-\t    && (all\n-\t\t|| (nonscalar && p->in_struct)\n-\t\t|| cse_rtx_addr_varies_p (p->exp)))\n-\t  remove_from_table (p, i);\n-      }\n-}\n-\f\n /* Remove from the hash table any expression that is a call-clobbered\n    register.  Also update their TICK values.  */\n \n@@ -1778,6 +1730,12 @@ invalidate_for_call ()\n \t{\n \t  next = p->next_same_hash;\n \n+\t  if (p->in_memory)\n+\t    {\n+\t      remove_from_table (p, hash);\n+\t      continue;\n+\t    }\n+\n \t  if (GET_CODE (p->exp) != REG\n \t      || REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n \t    continue;\n@@ -2418,127 +2376,52 @@ set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n   *pend = end;\n }\n \n-/* Return 1 iff any subexpression of X refers to memory\n-   at an address of BASE plus some offset\n-   such that any of the bytes' offsets fall between START (inclusive)\n-   and END (exclusive).\n-\n-   The value is undefined if X is a varying address (as determined by\n-   cse_rtx_addr_varies_p).  This function is not used in such cases.\n-\n-   When used in the cse pass, `qty_const' is nonzero, and it is used\n-   to treat an address that is a register with a known constant value\n-   as if it were that constant value.\n-   In the loop pass, `qty_const' is zero, so this is not done.  */\n-\n-static int\n-refers_to_mem_p (x, base, start, end)\n-     rtx x, base;\n-     HOST_WIDE_INT start, end;\n-{\n-  register HOST_WIDE_INT i;\n-  register enum rtx_code code;\n-  register char *fmt;\n-\n- repeat:\n-  if (x == 0)\n-    return 0;\n-\n-  code = GET_CODE (x);\n-  if (code == MEM)\n-    {\n-      register rtx addr = XEXP (x, 0);\t/* Get the address.  */\n-      rtx mybase;\n-      HOST_WIDE_INT mystart, myend;\n-\n-      set_nonvarying_address_components (addr, GET_MODE_SIZE (GET_MODE (x)),\n-\t\t\t\t\t &mybase, &mystart, &myend);\n-\n-\n-      /* refers_to_mem_p is never called with varying addresses. \n-\t If the base addresses are not equal, there is no chance\n-\t of the memory addresses conflicting.  */\n-      if (! rtx_equal_p (mybase, base))\n-\treturn 0;\n-\n-      return myend > start && mystart < end;\n-    }\n-\n-  /* X does not match, so try its subexpressions.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    if (fmt[i] == 'e')\n-      {\n-\tif (i == 0)\n-\t  {\n-\t    x = XEXP (x, 0);\n-\t    goto repeat;\n-\t  }\n-\telse\n-\t  if (refers_to_mem_p (XEXP (x, i), base, start, end))\n-\t    return 1;\n-      }\n-    else if (fmt[i] == 'E')\n-      {\n-\tint j;\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (refers_to_mem_p (XVECEXP (x, i, j), base, start, end))\n-\t    return 1;\n-      }\n-\n-  return 0;\n-}\n-\n-/* Nonzero if X refers to memory at a varying address;\n-   except that a register which has at the moment a known constant value\n-   isn't considered variable.  */\n+/* Return 1 if X has a value that can vary even between two\n+   executions of the program.  0 means X can be compared reliably\n+   against certain constants or near-constants.  */\n \n static int\n-cse_rtx_addr_varies_p (x)\n-     rtx x;\n+cse_rtx_varies_p (x)\n+     register rtx x;\n {\n   /* We need not check for X and the equivalence class being of the same\n      mode because if X is equivalent to a constant in some mode, it\n      doesn't vary in any mode.  */\n \n-  if (GET_CODE (x) == MEM\n-      && GET_CODE (XEXP (x, 0)) == REG\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n-      && GET_MODE (XEXP (x, 0)) == qty_mode[reg_qty[REGNO (XEXP (x, 0))]]\n-      && qty_const[reg_qty[REGNO (XEXP (x, 0))]] != 0)\n+  if (GET_CODE (x) == REG\n+      && REGNO_QTY_VALID_P (REGNO (x))\n+      && GET_MODE (x) == qty_mode[reg_qty[REGNO (x)]]\n+      && qty_const[reg_qty[REGNO (x)]] != 0)\n     return 0;\n \n-  if (GET_CODE (x) == MEM\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (XEXP (x, 0), 0)))\n-      && (GET_MODE (XEXP (XEXP (x, 0), 0))\n-\t  == qty_mode[reg_qty[REGNO (XEXP (XEXP (x, 0), 0))]])\n-      && qty_const[reg_qty[REGNO (XEXP (XEXP (x, 0), 0))]])\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n+      && (GET_MODE (XEXP (x, 0))\n+\t  == qty_mode[reg_qty[REGNO (XEXP (x, 0))]])\n+      && qty_const[reg_qty[REGNO (XEXP (x, 0))]])\n     return 0;\n \n   /* This can happen as the result of virtual register instantiation, if\n      the initial constant is too large to be a valid address.  This gives\n      us a three instruction sequence, load large offset into a register,\n      load fp minus a constant into a register, then a MEM which is the\n      sum of the two `constant' registers.  */\n-  if (GET_CODE (x) == MEM\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == REG\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (XEXP (x, 0), 0)))\n-      && (GET_MODE (XEXP (XEXP (x, 0), 0))\n-\t  == qty_mode[reg_qty[REGNO (XEXP (XEXP (x, 0), 0))]])\n-      && qty_const[reg_qty[REGNO (XEXP (XEXP (x, 0), 0))]]\n-      && REGNO_QTY_VALID_P (REGNO (XEXP (XEXP (x, 0), 1)))\n-      && (GET_MODE (XEXP (XEXP (x, 0), 1))\n-\t  == qty_mode[reg_qty[REGNO (XEXP (XEXP (x, 0), 1))]])\n-      && qty_const[reg_qty[REGNO (XEXP (XEXP (x, 0), 1))]])\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && GET_CODE (XEXP (x, 1)) == REG\n+      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 0)))\n+      && (GET_MODE (XEXP (x, 0))\n+\t  == qty_mode[reg_qty[REGNO (XEXP (x, 0))]])\n+      && qty_const[reg_qty[REGNO (XEXP (x, 0))]]\n+      && REGNO_QTY_VALID_P (REGNO (XEXP (x, 1)))\n+      && (GET_MODE (XEXP (x, 1))\n+\t  == qty_mode[reg_qty[REGNO (XEXP (x, 1))]])\n+      && qty_const[reg_qty[REGNO (XEXP (x, 1))]])\n     return 0;\n \n-  return rtx_addr_varies_p (x);\n+  return rtx_varies_p (x);\n }\n \f\n /* Canonicalize an expression:\n@@ -6161,8 +6044,6 @@ cse_insn (insn, in_libcall_block)\n   /* Records what this insn does to set CC0.  */\n   rtx this_insn_cc0 = 0;\n   enum machine_mode this_insn_cc0_mode;\n-  struct write_data writes_memory;\n-  static struct write_data init = {0, 0, 0, 0};\n \n   rtx src_eqv = 0;\n   struct table_elt *src_eqv_elt = 0;\n@@ -6174,7 +6055,6 @@ cse_insn (insn, in_libcall_block)\n   struct set *sets;\n \n   this_insn = insn;\n-  writes_memory = init;\n \n   /* Find all the SETs and CLOBBERs in this instruction.\n      Record all the SETs in the array `set' and count them.\n@@ -6276,15 +6156,11 @@ cse_insn (insn, in_libcall_block)\n \t    }\n \t  else if (GET_CODE (y) == CLOBBER)\n \t    {\n-\t      /* If we clobber memory, take note of that,\n-\t\t and canon the address.\n+\t      /* If we clobber memory, canon the address.\n \t\t This does nothing when a register is clobbered\n \t\t because we have already invalidated the reg.  */\n \t      if (GET_CODE (XEXP (y, 0)) == MEM)\n-\t\t{\n-\t\t  canon_reg (XEXP (y, 0), NULL_RTX);\n-\t\t  note_mem_written (XEXP (y, 0), &writes_memory);\n-\t\t}\n+\t\tcanon_reg (XEXP (y, 0), NULL_RTX);\n \t    }\n \t  else if (GET_CODE (y) == USE\n \t\t   && ! (GET_CODE (XEXP (y, 0)) == REG\n@@ -6303,10 +6179,7 @@ cse_insn (insn, in_libcall_block)\n   else if (GET_CODE (x) == CLOBBER)\n     {\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n-\t{\n-\t  canon_reg (XEXP (x, 0), NULL_RTX);\n-\t  note_mem_written (XEXP (x, 0), &writes_memory);\n-\t}\n+\tcanon_reg (XEXP (x, 0), NULL_RTX);\n     }\n \n   /* Canonicalize a USE of a pseudo register or memory location.  */\n@@ -6964,7 +6837,8 @@ cse_insn (insn, in_libcall_block)\n \t\t   && (src_folded == 0\n \t\t       || (GET_CODE (src_folded) != MEM\n \t\t\t   && ! src_folded_force_flag))\n-\t\t   && GET_MODE_CLASS (mode) != MODE_CC)\n+\t\t   && GET_MODE_CLASS (mode) != MODE_CC\n+\t\t   && mode != VOIDmode)\n \t    {\n \t      src_folded_force_flag = 1;\n \t      src_folded = trial;\n@@ -7087,13 +6961,15 @@ cse_insn (insn, in_libcall_block)\n \n       if (GET_CODE (dest) == MEM)\n \t{\n+#ifdef PUSH_ROUNDING\n+\t  /* Stack pushes invalidate the stack pointer.  */\n+\t  rtx addr = XEXP (dest, 0);\n+\t  if ((GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n+\t       || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n+\t      && XEXP (addr, 0) == stack_pointer_rtx)\n+\t    invalidate (stack_pointer_rtx, Pmode);\n+#endif\n \t  dest = fold_rtx (dest, insn);\n-\n-\t  /* Decide whether we invalidate everything in memory,\n-\t     or just things at non-fixed places.\n-\t     Writing a large aggregate must invalidate everything\n-\t     because we don't know how long it is.  */\n-\t  note_mem_written (dest, &writes_memory);\n \t}\n \n       /* Compute the hash code of the destination now,\n@@ -7338,17 +7214,15 @@ cse_insn (insn, in_libcall_block)\n \t so that the destination goes into that class.  */\n       sets[i].src_elt = src_eqv_elt;\n \n-  invalidate_from_clobbers (&writes_memory, x);\n+  invalidate_from_clobbers (x);\n \n   /* Some registers are invalidated by subroutine calls.  Memory is \n      invalidated by non-constant calls.  */\n \n   if (GET_CODE (insn) == CALL_INSN)\n     {\n-      static struct write_data everything = {0, 1, 1, 1};\n-\n       if (! CONST_CALL_P (insn))\n-\tinvalidate_memory (&everything);\n+\tinvalidate_memory ();\n       invalidate_for_call ();\n     }\n \n@@ -7369,8 +7243,7 @@ cse_insn (insn, in_libcall_block)\n \t   Needed for memory if this is a nonvarying address, unless\n \t   we have just done an invalidate_memory that covers even those.  */\n \tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n-\t    || (GET_CODE (dest) == MEM && ! writes_memory.all\n-\t\t&& ! cse_rtx_addr_varies_p (dest)))\n+\t    || GET_CODE (dest) == MEM)\n \t  invalidate (dest, VOIDmode);\n \telse if (GET_CODE (dest) == STRICT_LOW_PART\n \t\t || GET_CODE (dest) == ZERO_EXTRACT)\n@@ -7638,95 +7511,68 @@ cse_insn (insn, in_libcall_block)\n   prev_insn = insn;\n }\n \f\n-/* Store 1 in *WRITES_PTR for those categories of memory ref\n-   that must be invalidated when the expression WRITTEN is stored in.\n-   If WRITTEN is null, say everything must be invalidated.  */\n-\n+/* Remove from the ahsh table all expressions that reference memory.  */\n static void\n-note_mem_written (written, writes_ptr)\n-     rtx written;\n-     struct write_data *writes_ptr;\n+invalidate_memory ()\n {\n-  static struct write_data everything = {0, 1, 1, 1};\n+  register int i;\n+  register struct table_elt *p, *next;\n \n-  if (written == 0)\n-    *writes_ptr = everything;\n-  else if (GET_CODE (written) == MEM)\n+  for (i = 0; i < NBUCKETS; i++)\n+    for (p = table[i]; p; p = next)\n+      {\n+\tnext = p->next_same_hash;\n+\tif (p->in_memory)\n+\t  remove_from_table (p, i);\n+      }\n+}\n+\n+/* XXX ??? The name of this function bears little resemblance to\n+   what this function actually does.  FIXME.  */\n+static int\n+note_mem_written (addr)\n+     register rtx addr;\n+{\n+  /* Pushing or popping the stack invalidates just the stack pointer.  */\n+  if ((GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n+       || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n+      && GET_CODE (XEXP (addr, 0)) == REG\n+      && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n     {\n-      /* Pushing or popping the stack invalidates just the stack pointer.  */\n-      rtx addr = XEXP (written, 0);\n-      if ((GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == PRE_INC\n-\t   || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n-\t  && GET_CODE (XEXP (addr, 0)) == REG\n-\t  && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n-\t{\n-\t  writes_ptr->sp = 1;\n-\t  return;\n-\t}\n-      else if (GET_MODE (written) == BLKmode)\n-\t*writes_ptr = everything;\n-      else if (cse_rtx_addr_varies_p (written))\n-\t{\n-\t  /* A varying address that is a sum indicates an array element,\n-\t     and that's just as good as a structure element\n-\t     in implying that we need not invalidate scalar variables.\n-\t     However, we must allow QImode aliasing of scalars, because the\n-\t     ANSI C standard allows character pointers to alias anything.\n-\t     We must also allow AND addresses, because they may generate\n-\t     accesses outside the object being referenced.  This is used to\n-\t     generate aligned addresses from unaligned addresses, for instance,\n-\t     the alpha storeqi_unaligned pattern.  */\n-\t  if (! ((MEM_IN_STRUCT_P (written)\n-\t\t  || GET_CODE (XEXP (written, 0)) == PLUS)\n-\t\t && GET_MODE (written) != QImode\n-\t\t && GET_CODE (XEXP (written, 0)) != AND))\n-\t    writes_ptr->all = 1;\n-\t  writes_ptr->nonscalar = 1;\n-\t}\n-      writes_ptr->var = 1;\n+      if (reg_tick[STACK_POINTER_REGNUM] >= 0)\n+\treg_tick[STACK_POINTER_REGNUM]++;\n+\n+      /* This should be *very* rare.  */\n+      if (TEST_HARD_REG_BIT (hard_regs_in_table, STACK_POINTER_REGNUM))\n+\tinvalidate (stack_pointer_rtx, VOIDmode);\n+      return 1;\n     }\n+  return 0;\n }\n \n /* Perform invalidation on the basis of everything about an insn\n    except for invalidating the actual places that are SET in it.\n    This includes the places CLOBBERed, and anything that might\n    alias with something that is SET or CLOBBERed.\n \n-   W points to the writes_memory for this insn, a struct write_data\n-   saying which kinds of memory references must be invalidated.\n    X is the pattern of the insn.  */\n \n static void\n-invalidate_from_clobbers (w, x)\n-     struct write_data *w;\n+invalidate_from_clobbers (x)\n      rtx x;\n {\n-  /* If W->var is not set, W specifies no action.\n-     If W->all is set, this step gets all memory refs\n-     so they can be ignored in the rest of this function.  */\n-  if (w->var)\n-    invalidate_memory (w);\n-\n-  if (w->sp)\n-    {\n-      if (reg_tick[STACK_POINTER_REGNUM] >= 0)\n-\treg_tick[STACK_POINTER_REGNUM]++;\n-\n-      /* This should be *very* rare.  */\n-      if (TEST_HARD_REG_BIT (hard_regs_in_table, STACK_POINTER_REGNUM))\n-\tinvalidate (stack_pointer_rtx, VOIDmode);\n-    }\n-\n   if (GET_CODE (x) == CLOBBER)\n     {\n       rtx ref = XEXP (x, 0);\n-\n-      if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n-\t  || (GET_CODE (ref) == MEM && ! w->all))\n-\tinvalidate (ref, VOIDmode);\n-      else if (GET_CODE (ref) == STRICT_LOW_PART\n-\t       || GET_CODE (ref) == ZERO_EXTRACT)\n-\tinvalidate (XEXP (ref, 0), GET_MODE (ref));\n+      if (ref)\n+\t{\n+\t  if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n+\t      || GET_CODE (ref) == MEM)\n+\t    invalidate (ref, VOIDmode);\n+\t  else if (GET_CODE (ref) == STRICT_LOW_PART\n+\t\t   || GET_CODE (ref) == ZERO_EXTRACT)\n+\t    invalidate (XEXP (ref, 0), GET_MODE (ref));\n+\t}\n     }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n@@ -7737,15 +7583,12 @@ invalidate_from_clobbers (w, x)\n \t  if (GET_CODE (y) == CLOBBER)\n \t    {\n \t      rtx ref = XEXP (y, 0);\n-\t      if (ref)\n-\t\t{\n-\t\t  if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n-\t\t      || (GET_CODE (ref) == MEM && !w->all))\n-\t\t    invalidate (ref, VOIDmode);\n-\t\t  else if (GET_CODE (ref) == STRICT_LOW_PART\n-\t\t\t   || GET_CODE (ref) == ZERO_EXTRACT)\n-\t\t    invalidate (XEXP (ref, 0), GET_MODE (ref));\n-\t\t}\n+\t      if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n+\t\t  || GET_CODE (ref) == MEM)\n+\t\tinvalidate (ref, VOIDmode);\n+\t      else if (GET_CODE (ref) == STRICT_LOW_PART\n+\t\t       || GET_CODE (ref) == ZERO_EXTRACT)\n+\t\tinvalidate (XEXP (ref, 0), GET_MODE (ref));\n \t    }\n \t}\n     }\n@@ -7907,10 +7750,6 @@ cse_around_loop (loop_start)\n     }\n }\n \f\n-/* Variable used for communications between the next two routines.  */\n-\n-static struct write_data skipped_writes_memory;\n-\n /* Process one SET of an insn that was skipped.  We ignore CLOBBERs\n    since they are done elsewhere.  This function is called via note_stores.  */\n \n@@ -7919,14 +7758,21 @@ invalidate_skipped_set (dest, set)\n      rtx set;\n      rtx dest;\n {\n-  if (GET_CODE (dest) == MEM)\n-    note_mem_written (dest, &skipped_writes_memory);\n-\n-  /* There are times when an address can appear varying and be a PLUS\n-     during this scan when it would be a fixed address were we to know\n-     the proper equivalences.  So promote \"nonscalar\" to be \"all\".  */\n-  if (skipped_writes_memory.nonscalar)\n-    skipped_writes_memory.all = 1;\n+  enum rtx_code code = GET_CODE (dest);\n+\n+  if (code == MEM\n+      && ! note_mem_written (dest)\t/* If this is not a stack push ... */\n+      /* There are times when an address can appear varying and be a PLUS\n+\t during this scan when it would be a fixed address were we to know\n+\t the proper equivalences.  So invalidate all memory if there is\n+\t a BLKmode or nonscalar memory reference or a reference to a\n+\t variable address.  */\n+      && (MEM_IN_STRUCT_P (dest) || GET_MODE (dest) == BLKmode\n+\t  || cse_rtx_varies_p (XEXP (dest, 0))))\n+    {\n+      invalidate_memory ();\n+      return;\n+    }\n \n   if (GET_CODE (set) == CLOBBER\n #ifdef HAVE_cc0\n@@ -7935,12 +7781,10 @@ invalidate_skipped_set (dest, set)\n       || dest == pc_rtx)\n     return;\n \n-  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n-      || (! skipped_writes_memory.all && ! cse_rtx_addr_varies_p (dest)))\n-    invalidate (dest, VOIDmode);\n-  else if (GET_CODE (dest) == STRICT_LOW_PART\n-\t   || GET_CODE (dest) == ZERO_EXTRACT)\n+  if (code == STRICT_LOW_PART || code == ZERO_EXTRACT)\n     invalidate (XEXP (dest, 0), GET_MODE (dest));\n+  else if (code == REG || code == SUBREG || code == MEM)\n+    invalidate (dest, VOIDmode);\n }\n \n /* Invalidate all insns from START up to the end of the function or the\n@@ -7952,25 +7796,21 @@ invalidate_skipped_block (start)\n      rtx start;\n {\n   rtx insn;\n-  static struct write_data init = {0, 0, 0, 0};\n-  static struct write_data everything = {0, 1, 1, 1};\n \n   for (insn = start; insn && GET_CODE (insn) != CODE_LABEL;\n        insn = NEXT_INSN (insn))\n     {\n       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n \tcontinue;\n \n-      skipped_writes_memory = init;\n-\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n+\t  if (! CONST_CALL_P (insn))\n+\t    invalidate_memory ();\n \t  invalidate_for_call ();\n-\t  skipped_writes_memory = everything;\n \t}\n \n       note_stores (PATTERN (insn), invalidate_skipped_set);\n-      invalidate_from_clobbers (&skipped_writes_memory, PATTERN (insn));\n     }\n }\n \f\n@@ -8020,10 +7860,6 @@ cse_set_around_loop (x, insn, loop_start)\n      rtx loop_start;\n {\n   struct table_elt *src_elt;\n-  static struct write_data init = {0, 0, 0, 0};\n-  struct write_data writes_memory;\n-\n-  writes_memory = init;\n \n   /* If this is a SET, see if we can replace SET_SRC, but ignore SETs that\n      are setting PC or CC0 or whose SET_SRC is already a register.  */\n@@ -8083,16 +7919,11 @@ cse_set_around_loop (x, insn, loop_start)\n     }\n \n   /* Now invalidate anything modified by X.  */\n-  note_mem_written (SET_DEST (x), &writes_memory);\n-\n-  if (writes_memory.var)\n-    invalidate_memory (&writes_memory);\n+  note_mem_written (SET_DEST (x));\n \n-  /* See comment on similar code in cse_insn for explanation of these\n-     tests.  */\n+  /* See comment on similar code in cse_insn for explanation of these tests.  */\n   if (GET_CODE (SET_DEST (x)) == REG || GET_CODE (SET_DEST (x)) == SUBREG\n-      || (GET_CODE (SET_DEST (x)) == MEM && ! writes_memory.all\n-\t  && ! cse_rtx_addr_varies_p (SET_DEST (x))))\n+      || GET_CODE (SET_DEST (x)) == MEM)\n     invalidate (SET_DEST (x), VOIDmode);\n   else if (GET_CODE (SET_DEST (x)) == STRICT_LOW_PART\n \t   || GET_CODE (SET_DEST (x)) == ZERO_EXTRACT)\n@@ -8342,6 +8173,7 @@ cse_main (f, nregs, after_loop, file)\n   val.path_size = 0;\n \n   init_recog ();\n+  init_alias_analysis ();\n \n   max_reg = nregs;\n "}, {"sha": "b5c6d75446b33395cd0ee2a81d0f48af13d72b19", "filename": "gcc/flags.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -370,6 +370,19 @@ extern int flag_gnu_linker;\n /* Tag all structures with __attribute__(packed) */\n extern int flag_pack_struct;\n \n+/* 1 if alias checking is enabled: symbols do not alias each other\n+   and parameters do not alias the current stack frame.  */\n+extern int flag_alias_check;\n+\n+/* This flag is only tested if alias checking is enabled.\n+   0 if pointer arguments may alias each other.  True in C.\n+   1 if pointer arguments may not alias each other but may alias\n+   global variables.\n+   2 if pointer arguments may not alias each other and may not\n+   alias global variables.  True in Fortran.\n+   The value is ignored if flag_alias_check is 0.  */\n+extern int flag_argument_noalias;\n+\n /* Emit code to check for stack overflow; also may cause large objects\n    to be allocated dynamically.  */\n extern int flag_stack_check;"}, {"sha": "44661695b129923a3f45f3658e45ab9dae7e2c6a", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -543,7 +543,7 @@ validate_equiv_mem_from_store (dest, set)\n   if ((GET_CODE (dest) == REG\n        && reg_overlap_mentioned_p (dest, equiv_mem))\n       || (GET_CODE (dest) == MEM\n-\t  && true_dependence (dest, equiv_mem)))\n+\t  && true_dependence (dest, VOIDmode, equiv_mem, rtx_varies_p)))\n     equiv_mem_modified = 1;\n }\n \n@@ -632,7 +632,7 @@ memref_referenced_p (memref, x)\n \t\t\t\t      reg_equiv_replacement[REGNO (x)]));\n \n     case MEM:\n-      if (true_dependence (memref, x))\n+      if (true_dependence (memref, VOIDmode, x, rtx_varies_p))\n \treturn 1;\n       break;\n "}, {"sha": "b54e677b9288c4d5adfca88739a05dabad80f049", "filename": "gcc/loop.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -111,8 +111,7 @@ int *loop_number_exit_count;\n \n unsigned HOST_WIDE_INT loop_n_iterations;\n \n-/* Nonzero if there is a subroutine call in the current loop.\n-   (unknown_address_altered is also nonzero in this case.)  */\n+/* Nonzero if there is a subroutine call in the current loop.  */\n \n static int loop_has_call;\n \n@@ -160,7 +159,7 @@ static char *moved_once;\n /* Array of MEMs that are stored in this loop. If there are too many to fit\n    here, we just turn on unknown_address_altered.  */\n \n-#define NUM_STORES 20\n+#define NUM_STORES 30\n static rtx loop_store_mems[NUM_STORES];\n \n /* Index of first available slot in above array.  */\n@@ -2199,7 +2198,8 @@ prescan_loop (start, end)\n \t}\n       else if (GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  unknown_address_altered = 1;\n+\t  if (! CONST_CALL_P (insn))\n+\t    unknown_address_altered = 1;\n \t  loop_has_call = 1;\n \t}\n       else\n@@ -2795,7 +2795,7 @@ invariant_p (x)\n \n       /* See if there is any dependence between a store and this load.  */\n       for (i = loop_store_mems_idx - 1; i >= 0; i--)\n-\tif (true_dependence (loop_store_mems[i], x))\n+\tif (true_dependence (loop_store_mems[i], VOIDmode, x, rtx_varies_p))\n \t  return 0;\n \n       /* It's not invalidated by a store in memory\n@@ -4523,6 +4523,8 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->final_value = 0;\n   v->same_insn = 0;\n   v->auto_inc_opt = 0;\n+  v->unrolled = 0;\n+  v->shared = 0;\n \n   /* The v->always_computable field is used in update_giv_derive, to\n      determine whether a giv can be used to derive another giv.  For a\n@@ -5771,6 +5773,8 @@ emit_iv_add_mult (b, m, a, reg, insert_before)\n   end_sequence ();\n \n   emit_insn_before (seq, insert_before);\n+\n+  record_base_value (REGNO (reg), b);\n }\n \f\n /* Test whether A * B can be computed without"}, {"sha": "3536fa1e20dc4252c46df5a4d655cc8cb6848dfa", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -92,6 +92,9 @@ struct induction\n \t\t\t\t   would probably lose. */\n   unsigned auto_inc_opt : 1;\t/* 1 if this giv had its increment output next\n \t\t\t\t   to it to try to form an auto-inc address. */\n+  unsigned unrolled : 1;\t/* 1 if new register has been allocated in\n+\t\t\t\t   unrolled loop.  */\n+  unsigned shared : 1;\n   int lifetime;\t\t\t/* Length of life of this giv */\n   int times_used;\t\t/* # times this giv is used. */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be"}, {"sha": "1f2c9dde0ff061d5fe9a6044cecb323e34796515", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -181,7 +181,7 @@ char *reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n \t\t\t  \"REG_NONNEG\", \"REG_NO_CONFLICT\", \"REG_UNUSED\",\n \t\t\t  \"REG_CC_SETTER\", \"REG_CC_USER\", \"REG_LABEL\",\n \t\t\t  \"REG_DEP_ANTI\", \"REG_DEP_OUTPUT\", \"REG_BR_PROB\",\n-\t\t\t  \"REG_EXEC_COUNT\" };\n+\t\t\t  \"REG_EXEC_COUNT\", \"REG_NOALIAS\" };\n \n /* Allocate an rtx vector of N elements.\n    Store the length, and initialize all elements to zero.  */"}, {"sha": "de9386df210af78e5cbbe298a641f8e745cf487a", "filename": "gcc/rtl.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -317,7 +317,7 @@ enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n \t\tREG_NONNEG = 8, REG_NO_CONFLICT = 9, REG_UNUSED = 10,\n \t\tREG_CC_SETTER = 11, REG_CC_USER = 12, REG_LABEL = 13,\n \t\tREG_DEP_ANTI = 14, REG_DEP_OUTPUT = 15, REG_BR_PROB = 16,\n-\t\tREG_EXEC_COUNT = 17 };\n+\t\tREG_EXEC_COUNT = 17, REG_NOALIAS = 18 };\n /* The base value for branch probability notes.  */\n #define REG_BR_PROB_BASE  10000\n \n@@ -803,6 +803,16 @@ extern rtx gen_ble\t\t\tPROTO((rtx));\n extern rtx eliminate_constant_term\tPROTO((rtx, rtx *));\n extern rtx expand_complex_abs\t\tPROTO((enum machine_mode, rtx, rtx, int));\n extern enum machine_mode choose_hard_reg_mode PROTO((int, int));\n+extern int rtx_varies_p\t\tPROTO((rtx));\n+extern int may_trap_p\t\tPROTO((rtx));\n+extern int side_effects_p\tPROTO((rtx));\n+extern int volatile_refs_p\tPROTO((rtx));\n+extern int volatile_insn_p\tPROTO((rtx));\n+extern void remove_note\t\tPROTO((rtx, rtx));\n+extern void note_stores\t\tPROTO((rtx, void (*)()));\n+extern int refers_to_regno_p\tPROTO((int, int, rtx, rtx *));\n+extern int reg_overlap_mentioned_p PROTO((rtx, rtx));\n+\n \n /* Maximum number of parallel sets and clobbers in any insn in this fn.\n    Always at least 3, since the combiner could put that many togetherm\n@@ -959,3 +969,12 @@ extern char *regno_pointer_align;\n    know what `enum tree_code' means.  */\n \n extern int rtx_to_tree_code\tPROTO((enum rtx_code));\n+\n+extern int true_dependence\tPROTO((rtx, enum machine_mode, rtx, int (*)()));\n+extern int read_dependence\tPROTO((rtx, rtx));\n+extern int anti_dependence\tPROTO((rtx, rtx));\n+extern int output_dependence\tPROTO((rtx, rtx));\n+extern void init_alias_analysis\tPROTO((void));\n+extern void end_alias_analysis\tPROTO((void));\n+extern void mark_user_reg\tPROTO((rtx));\n+extern void mark_reg_pointer\tPROTO((rtx, int));"}, {"sha": "cdaaf79cf38e6fb4386d2dde6c8cd6159ec00a65", "filename": "gcc/sched.c", "status": "modified", "additions": 11, "deletions": 575, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -127,6 +127,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"insn-attr.h\"\n \n+extern char *reg_known_equiv_p;\n+extern rtx *reg_known_value;\n+\n #ifdef INSN_SCHEDULING\n /* Arrays set up by scheduling for the same respective purposes as\n    similar-named arrays set up by flow analysis.  We work with these\n@@ -143,6 +146,7 @@ static int *sched_reg_live_length;\n    such insn.  Needed for new registers which may be introduced\n    by splitting insns.  */\n static rtx *reg_last_uses;\n+static int reg_last_uses_size;\n static rtx *reg_last_sets;\n static regset reg_pending_sets;\n static int reg_pending_sets_all;\n@@ -295,11 +299,6 @@ struct sometimes\n };\n \n /* Forward declarations.  */\n-static rtx canon_rtx\t\t\tPROTO((rtx));\n-static int rtx_equal_for_memref_p\tPROTO((rtx, rtx));\n-static rtx find_symbolic_term\t\tPROTO((rtx));\n-static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n-\t\t\t\t\t       HOST_WIDE_INT));\n static void add_dependence\t\tPROTO((rtx, rtx, enum reg_note));\n static void remove_dependence\t\tPROTO((rtx, rtx));\n static rtx find_insn_list\t\tPROTO((rtx, rtx));\n@@ -349,567 +348,6 @@ void schedule_insns\tPROTO((FILE *));\n \f\n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n-/* Vector indexed by N giving the initial (unchanging) value known\n-   for pseudo-register N.  */\n-static rtx *reg_known_value;\n-\n-/* Vector recording for each reg_known_value whether it is due to a\n-   REG_EQUIV note.  Future passes (viz., reload) may replace the\n-   pseudo with the equivalent expression and so we account for the\n-   dependences that would be introduced if that happens.  */\n-/* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in\n-   assign_parms mention the arg pointer, and there are explicit insns in the\n-   RTL that modify the arg pointer.  Thus we must ensure that such insns don't\n-   get scheduled across each other because that would invalidate the REG_EQUIV\n-   notes.  One could argue that the REG_EQUIV notes are wrong, but solving\n-   the problem in the scheduler will likely give better code, so we do it\n-   here.  */\n-static char *reg_known_equiv_p;\n-\n-/* Indicates number of valid entries in reg_known_value.  */\n-static int reg_known_value_size;\n-\n-static rtx\n-canon_rtx (x)\n-     rtx x;\n-{\n-  /* Recursively look for equivalences.  */\n-  if (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER\n-      && REGNO (x) <= reg_known_value_size)\n-    return reg_known_value[REGNO (x)] == x\n-      ? x : canon_rtx (reg_known_value[REGNO (x)]);\n-  else if (GET_CODE (x) == PLUS)\n-    {\n-      rtx x0 = canon_rtx (XEXP (x, 0));\n-      rtx x1 = canon_rtx (XEXP (x, 1));\n-\n-      if (x0 != XEXP (x, 0) || x1 != XEXP (x, 1))\n-\t{\n-\t  /* We can tolerate LO_SUMs being offset here; these\n-\t     rtl are used for nothing other than comparisons.  */\n-\t  if (GET_CODE (x0) == CONST_INT)\n-\t    return plus_constant_for_output (x1, INTVAL (x0));\n-\t  else if (GET_CODE (x1) == CONST_INT)\n-\t    return plus_constant_for_output (x0, INTVAL (x1));\n-\t  return gen_rtx (PLUS, GET_MODE (x), x0, x1);\n-\t}\n-    }\n-  /* This gives us much better alias analysis when called from\n-     the loop optimizer.   Note we want to leave the original\n-     MEM alone, but need to return the canonicalized MEM with\n-     all the flags with their original values.  */\n-  else if (GET_CODE (x) == MEM)\n-    {\n-      rtx copy = copy_rtx (x);\n-      XEXP (copy, 0) = canon_rtx (XEXP (copy, 0));\n-      x = copy;\n-    }\n-  return x;\n-}\n-\n-/* Set up all info needed to perform alias analysis on memory references.  */\n-\n-void\n-init_alias_analysis ()\n-{\n-  int maxreg = max_reg_num ();\n-  rtx insn;\n-  rtx note;\n-  rtx set;\n-\n-  reg_known_value_size = maxreg;\n-\n-  reg_known_value\n-    = (rtx *) oballoc ((maxreg-FIRST_PSEUDO_REGISTER) * sizeof (rtx))\n-      - FIRST_PSEUDO_REGISTER;\n-  bzero ((char *) (reg_known_value + FIRST_PSEUDO_REGISTER),\n-\t (maxreg-FIRST_PSEUDO_REGISTER) * sizeof (rtx));\n-\n-  reg_known_equiv_p\n-    = (char *) oballoc ((maxreg -FIRST_PSEUDO_REGISTER) * sizeof (char))\n-      - FIRST_PSEUDO_REGISTER;\n-  bzero (reg_known_equiv_p + FIRST_PSEUDO_REGISTER,\n-\t (maxreg - FIRST_PSEUDO_REGISTER) * sizeof (char));\n-\n-  /* Fill in the entries with known constant values.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if ((set = single_set (insn)) != 0\n-\t&& GET_CODE (SET_DEST (set)) == REG\n-\t&& REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n-\t&& (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n-\t     && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n-\t    || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n-\t&& GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n-      {\n-\tint regno = REGNO (SET_DEST (set));\n-\treg_known_value[regno] = XEXP (note, 0);\n-\treg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n-      }\n-\n-  /* Fill in the remaining entries.  */\n-  while (--maxreg >= FIRST_PSEUDO_REGISTER)\n-    if (reg_known_value[maxreg] == 0)\n-      reg_known_value[maxreg] = regno_reg_rtx[maxreg];\n-}\n-\n-/* Return 1 if X and Y are identical-looking rtx's.\n-\n-   We use the data in reg_known_value above to see if two registers with\n-   different numbers are, in fact, equivalent.  */\n-\n-static int\n-rtx_equal_for_memref_p (x, y)\n-     rtx x, y;\n-{\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register char *fmt;\n-\n-  if (x == 0 && y == 0)\n-    return 1;\n-  if (x == 0 || y == 0)\n-    return 0;\n-  x = canon_rtx (x);\n-  y = canon_rtx (y);\n-\n-  if (x == y)\n-    return 1;\n-\n-  code = GET_CODE (x);\n-  /* Rtx's of different codes cannot be equal.  */\n-  if (code != GET_CODE (y))\n-    return 0;\n-\n-  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.\n-     (REG:SI x) and (REG:HI x) are NOT equivalent.  */\n-\n-  if (GET_MODE (x) != GET_MODE (y))\n-    return 0;\n-\n-  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */\n-\n-  if (code == REG)\n-    return REGNO (x) == REGNO (y);\n-  if (code == LABEL_REF)\n-    return XEXP (x, 0) == XEXP (y, 0);\n-  if (code == SYMBOL_REF)\n-    return XSTR (x, 0) == XSTR (y, 0);\n-\n-  /* For commutative operations, the RTX match if the operand match in any\n-     order.  Also handle the simple binary and unary cases without a loop.  */\n-  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c')\n-    return ((rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 0))\n-\t     && rtx_equal_for_memref_p (XEXP (x, 1), XEXP (y, 1)))\n-\t    || (rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 1))\n-\t\t&& rtx_equal_for_memref_p (XEXP (x, 1), XEXP (y, 0))));\n-  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == '2')\n-    return (rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 0))\n-\t    && rtx_equal_for_memref_p (XEXP (x, 1), XEXP (y, 1)));\n-  else if (GET_RTX_CLASS (code) == '1')\n-    return rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 0));\n-\n-  /* Compare the elements.  If any pair of corresponding elements\n-     fail to match, return 0 for the whole things.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      switch (fmt[i])\n-\t{\n-\tcase 'w':\n-\t  if (XWINT (x, i) != XWINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'n':\n-\tcase 'i':\n-\t  if (XINT (x, i) != XINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'V':\n-\tcase 'E':\n-\t  /* Two vectors must have the same length.  */\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return 0;\n-\n-\t  /* And the corresponding elements must match.  */\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (rtx_equal_for_memref_p (XVECEXP (x, i, j), XVECEXP (y, i, j)) == 0)\n-\t      return 0;\n-\t  break;\n-\n-\tcase 'e':\n-\t  if (rtx_equal_for_memref_p (XEXP (x, i), XEXP (y, i)) == 0)\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'S':\n-\tcase 's':\n-\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'u':\n-\t  /* These are just backpointers, so they don't matter.  */\n-\t  break;\n-\n-\tcase '0':\n-\t  break;\n-\n-\t  /* It is believed that rtx's at this level will never\n-\t     contain anything but integers and other rtx's,\n-\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  return 1;\n-}\n-\n-/* Given an rtx X, find a SYMBOL_REF or LABEL_REF within\n-   X and return it, or return 0 if none found.  */\n-\n-static rtx\n-find_symbolic_term (x)\n-     rtx x;\n-{\n-  register int i;\n-  register enum rtx_code code;\n-  register char *fmt;\n-\n-  code = GET_CODE (x);\n-  if (code == SYMBOL_REF || code == LABEL_REF)\n-    return x;\n-  if (GET_RTX_CLASS (code) == 'o')\n-    return 0;\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      rtx t;\n-\n-      if (fmt[i] == 'e')\n-\t{\n-\t  t = find_symbolic_term (XEXP (x, i));\n-\t  if (t != 0)\n-\t    return t;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tbreak;\n-    }\n-  return 0;\n-}\n-\n-/* Return nonzero if X and Y (memory addresses) could reference the\n-   same location in memory.  C is an offset accumulator.  When\n-   C is nonzero, we are testing aliases between X and Y + C.\n-   XSIZE is the size in bytes of the X reference,\n-   similarly YSIZE is the size in bytes for Y.\n-\n-   If XSIZE or YSIZE is zero, we do not know the amount of memory being\n-   referenced (the reference was BLKmode), so make the most pessimistic\n-   assumptions.\n-\n-   We recognize the following cases of non-conflicting memory:\n-\n-\t(1) addresses involving the frame pointer cannot conflict\n-\t    with addresses involving static variables.\n-\t(2) static variables with different addresses cannot conflict.\n-\n-   Nice to notice that varying addresses cannot conflict with fp if no\n-   local variables had their addresses taken, but that's too hard now.  */\n-\n-/* ??? In Fortran, references to a array parameter can never conflict with\n-   another array parameter.  */\n-\n-static int\n-memrefs_conflict_p (xsize, x, ysize, y, c)\n-     rtx x, y;\n-     int xsize, ysize;\n-     HOST_WIDE_INT c;\n-{\n-  if (GET_CODE (x) == HIGH)\n-    x = XEXP (x, 0);\n-  else if (GET_CODE (x) == LO_SUM)\n-    x = XEXP (x, 1);\n-  else\n-    x = canon_rtx (x);\n-  if (GET_CODE (y) == HIGH)\n-    y = XEXP (y, 0);\n-  else if (GET_CODE (y) == LO_SUM)\n-    y = XEXP (y, 1);\n-  else\n-    y = canon_rtx (y);\n-\n-  if (rtx_equal_for_memref_p (x, y))\n-    return (xsize == 0 || ysize == 0\n-\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n-\n-  if (y == frame_pointer_rtx || y == hard_frame_pointer_rtx\n-      || y == stack_pointer_rtx)\n-    {\n-      rtx t = y;\n-      int tsize = ysize;\n-      y = x; ysize = xsize;\n-      x = t; xsize = tsize;\n-    }\n-\n-  if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n-      || x == stack_pointer_rtx)\n-    {\n-      rtx y1;\n-\n-      if (CONSTANT_P (y))\n-\treturn 0;\n-\n-      if (GET_CODE (y) == PLUS\n-\t  && canon_rtx (XEXP (y, 0)) == x\n-\t  && (y1 = canon_rtx (XEXP (y, 1)))\n-\t  && GET_CODE (y1) == CONST_INT)\n-\t{\n-\t  c += INTVAL (y1);\n-\t  return (xsize == 0 || ysize == 0\n-\t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n-\t}\n-\n-      if (GET_CODE (y) == PLUS\n-\t  && (y1 = canon_rtx (XEXP (y, 0)))\n-\t  && CONSTANT_P (y1))\n-\treturn 0;\n-\n-      return 1;\n-    }\n-\n-  if (GET_CODE (x) == PLUS)\n-    {\n-      /* The fact that X is canonicalized means that this\n-\t PLUS rtx is canonicalized.  */\n-      rtx x0 = XEXP (x, 0);\n-      rtx x1 = XEXP (x, 1);\n-\n-      if (GET_CODE (y) == PLUS)\n-\t{\n-\t  /* The fact that Y is canonicalized means that this\n-\t     PLUS rtx is canonicalized.  */\n-\t  rtx y0 = XEXP (y, 0);\n-\t  rtx y1 = XEXP (y, 1);\n-\n-\t  if (rtx_equal_for_memref_p (x1, y1))\n-\t    return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n-\t  if (rtx_equal_for_memref_p (x0, y0))\n-\t    return memrefs_conflict_p (xsize, x1, ysize, y1, c);\n-\t  if (GET_CODE (x1) == CONST_INT)\n-\t    if (GET_CODE (y1) == CONST_INT)\n-\t      return memrefs_conflict_p (xsize, x0, ysize, y0,\n-\t\t\t\t\t c - INTVAL (x1) + INTVAL (y1));\n-\t    else\n-\t      return memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n-\t  else if (GET_CODE (y1) == CONST_INT)\n-\t    return memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n-\n-\t  /* Handle case where we cannot understand iteration operators,\n-\t     but we notice that the base addresses are distinct objects.  */\n-\t  x = find_symbolic_term (x);\n-\t  if (x == 0)\n-\t    return 1;\n-\t  y = find_symbolic_term (y);\n-\t  if (y == 0)\n-\t    return 1;\n-\t  return rtx_equal_for_memref_p (x, y);\n-\t}\n-      else if (GET_CODE (x1) == CONST_INT)\n-\treturn memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n-    }\n-  else if (GET_CODE (y) == PLUS)\n-    {\n-      /* The fact that Y is canonicalized means that this\n-\t PLUS rtx is canonicalized.  */\n-      rtx y0 = XEXP (y, 0);\n-      rtx y1 = XEXP (y, 1);\n-\n-      if (GET_CODE (y1) == CONST_INT)\n-\treturn memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n-      else\n-\treturn 1;\n-    }\n-\n-  if (GET_CODE (x) == GET_CODE (y))\n-    switch (GET_CODE (x))\n-      {\n-      case MULT:\n-\t{\n-\t  /* Handle cases where we expect the second operands to be the\n-\t     same, and check only whether the first operand would conflict\n-\t     or not.  */\n-\t  rtx x0, y0;\n-\t  rtx x1 = canon_rtx (XEXP (x, 1));\n-\t  rtx y1 = canon_rtx (XEXP (y, 1));\n-\t  if (! rtx_equal_for_memref_p (x1, y1))\n-\t    return 1;\n-\t  x0 = canon_rtx (XEXP (x, 0));\n-\t  y0 = canon_rtx (XEXP (y, 0));\n-\t  if (rtx_equal_for_memref_p (x0, y0))\n-\t    return (xsize == 0 || ysize == 0\n-\t\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n-\n-\t  /* Can't properly adjust our sizes.  */\n-\t  if (GET_CODE (x1) != CONST_INT)\n-\t    return 1;\n-\t  xsize /= INTVAL (x1);\n-\t  ysize /= INTVAL (x1);\n-\t  c /= INTVAL (x1);\n-\t  return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n-\t}\n-      }\n-\n-  if (CONSTANT_P (x))\n-    {\n-      if (GET_CODE (x) == CONST_INT && GET_CODE (y) == CONST_INT)\n-\t{\n-\t  c += (INTVAL (y) - INTVAL (x));\n-\t  return (xsize == 0 || ysize == 0\n-\t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n-\t}\n-\n-      if (GET_CODE (x) == CONST)\n-\t{\n-\t  if (GET_CODE (y) == CONST)\n-\t    return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)),\n-\t\t\t\t       ysize, canon_rtx (XEXP (y, 0)), c);\n-\t  else\n-\t    return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)),\n-\t\t\t\t       ysize, y, c);\n-\t}\n-      if (GET_CODE (y) == CONST)\n-\treturn memrefs_conflict_p (xsize, x, ysize,\n-\t\t\t\t   canon_rtx (XEXP (y, 0)), c);\n-\n-      if (CONSTANT_P (y))\n-\treturn (rtx_equal_for_memref_p (x, y)\n-\t\t&& (xsize == 0 || ysize == 0\n-\t\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0)));\n-\n-      return 1;\n-    }\n-  return 1;\n-}\n-\n-/* Functions to compute memory dependencies.\n-\n-   Since we process the insns in execution order, we can build tables\n-   to keep track of what registers are fixed (and not aliased), what registers\n-   are varying in known ways, and what registers are varying in unknown\n-   ways.\n-\n-   If both memory references are volatile, then there must always be a\n-   dependence between the two references, since their order can not be\n-   changed.  A volatile and non-volatile reference can be interchanged\n-   though. \n-\n-   A MEM_IN_STRUCT reference at a non-QImode non-AND varying address can never\n-   conflict with a non-MEM_IN_STRUCT reference at a fixed address.   We must\n-   allow QImode aliasing because the ANSI C standard allows character\n-   pointers to alias anything.  We are assuming that characters are\n-   always QImode here.  We also must allow AND addresses, because they may\n-   generate accesses outside the object being referenced.  This is used to\n-   generate aligned addresses from unaligned addresses, for instance, the\n-   alpha storeqi_unaligned pattern.  */\n-\n-/* Read dependence: X is read after read in MEM takes place.  There can\n-   only be a dependence here if both reads are volatile.  */\n-\n-int\n-read_dependence (mem, x)\n-     rtx mem;\n-     rtx x;\n-{\n-  return MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem);\n-}\n-\n-/* True dependence: X is read after store in MEM takes place.  */\n-\n-int\n-true_dependence (mem, x)\n-     rtx mem;\n-     rtx x;\n-{\n-  /* If X is an unchanging read, then it can't possibly conflict with any\n-     non-unchanging store.  It may conflict with an unchanging write though,\n-     because there may be a single store to this address to initialize it.\n-     Just fall through to the code below to resolve the case where we have\n-     both an unchanging read and an unchanging write.  This won't handle all\n-     cases optimally, but the possible performance loss should be\n-     negligible.  */\n-  x = canon_rtx (x);\n-  mem = canon_rtx (mem);\n-  if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n-    return 0;\n-\n-  return ((MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n-\t  || (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n-\t\t\t\t  SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n-\t      && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n-\t\t    && GET_MODE (mem) != QImode\n-\t\t    && GET_CODE (XEXP (mem, 0)) != AND\n-\t\t    && ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n-\t      && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n-\t\t    && GET_MODE (x) != QImode\n-\t\t    && GET_CODE (XEXP (x, 0)) != AND\n-\t\t    && ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem))));\n-}\n-\n-/* Anti dependence: X is written after read in MEM takes place.  */\n-\n-int\n-anti_dependence (mem, x)\n-     rtx mem;\n-     rtx x;\n-{\n-  /* If MEM is an unchanging read, then it can't possibly conflict with\n-     the store to X, because there is at most one store to MEM, and it must\n-     have occurred somewhere before MEM.  */\n-  x = canon_rtx (x);\n-  mem = canon_rtx (mem);\n-  if (RTX_UNCHANGING_P (mem))\n-    return 0;\n-\n-  return ((MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n-\t  || (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n-\t\t\t\t  SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n-\t      && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n-\t\t    && GET_MODE (mem) != QImode\n-\t\t    && GET_CODE (XEXP (mem, 0)) != AND\n-\t\t    && ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n-\t      && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n-\t\t    && GET_MODE (x) != QImode\n-\t\t    && GET_CODE (XEXP (x, 0)) != AND\n-\t\t    && ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem))));\n-}\n-\n-/* Output dependence: X is written after store in MEM takes place.  */\n-\n-int\n-output_dependence (mem, x)\n-     rtx mem;\n-     rtx x;\n-{\n-  x = canon_rtx (x);\n-  mem = canon_rtx (mem);\n-  return ((MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n-\t  || (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n-\t\t\t\t  SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n-\t      && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n-\t\t    && GET_MODE (mem) != QImode\n-\t\t    && GET_CODE (XEXP (mem, 0)) != AND\n-\t\t    && ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n-\t      && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n-\t\t    && GET_MODE (x) != QImode\n-\t\t    && GET_CODE (XEXP (x, 0)) != AND\n-\t\t    && ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem))));\n-}\n-\f\n /* Helper functions for instruction scheduling.  */\n \n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n@@ -1948,7 +1386,8 @@ sched_analyze_2 (x, insn)\n \t  {\n \t    /* If a dependency already exists, don't create a new one.  */\n \t    if (! find_insn_list (XEXP (pending, 0), LOG_LINKS (insn)))\n-\t      if (true_dependence (XEXP (pending_mem, 0), x))\n+\t      if (true_dependence (XEXP (pending_mem, 0), VOIDmode,\n+\t\t\t\t   x, rtx_varies_p))\n \t\tadd_dependence (insn, XEXP (pending, 0), 0);\n \n \t    pending = XEXP (pending, 1);\n@@ -2047,7 +1486,7 @@ sched_analyze_insn (x, insn, loop_notes)\n {\n   register RTX_CODE code = GET_CODE (x);\n   rtx link;\n-  int maxreg = max_reg_num ();\n+  int maxreg = reg_last_uses_size;\n   int i;\n \n   if (code == SET || code == CLOBBER)\n@@ -2084,7 +1523,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \n   if (loop_notes)\n     {\n-      int max_reg = max_reg_num ();\n+      int max_reg = reg_last_uses_size;\n       rtx link;\n \n       for (i = 0; i < max_reg; i++)\n@@ -2222,8 +1661,7 @@ sched_analyze (head, tail)\n \t  if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == NOTE\n \t      && NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_SETJMP)\n \t    {\n-\t      int max_reg = max_reg_num ();\n-\t      for (i = 0; i < max_reg; i++)\n+\t      for (i = 0; i < reg_last_uses_size; i++)\n \t\t{\n \t\t  for (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n@@ -3198,7 +2636,7 @@ schedule_block (b, file)\n     fprintf (file, \";;\\t -- basic block number %d from %d to %d --\\n\",\n \t     b, INSN_UID (basic_block_head[b]), INSN_UID (basic_block_end[b]));\n \n-  i = max_reg_num ();\n+  reg_last_uses_size = i = max_reg_num ();\n   reg_last_uses = (rtx *) alloca (i * sizeof (rtx));\n   bzero ((char *) reg_last_uses, i * sizeof (rtx));\n   reg_last_sets = (rtx *) alloca (i * sizeof (rtx));\n@@ -4819,17 +4257,15 @@ schedule_insns (dump_file)\n       bb_live_regs = ALLOCA_REG_SET ();\n       bzero ((char *) sched_reg_n_calls_crossed, max_regno * sizeof (int));\n       bzero ((char *) sched_reg_live_length, max_regno * sizeof (int));\n-      init_alias_analysis ();\n     }\n   else\n     {\n       sched_reg_n_calls_crossed = 0;\n       sched_reg_live_length = 0;\n       bb_dead_regs = 0;\n       bb_live_regs = 0;\n-      if (! flag_schedule_insns)\n-\tinit_alias_analysis ();\n     }\n+  init_alias_analysis ();\n \n   if (write_symbols != NO_DEBUG)\n     {"}, {"sha": "43be973bcbe9568e5d7219d5bfec4b84661086e3", "filename": "gcc/toplev.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -616,6 +616,17 @@ int flag_check_memory_usage = 0;\n    -fcheck-memory-usage.  */\n int flag_prefix_function_name = 0;\n \n+/* 1 if alias checking is on (by default, when -O).  */\n+int flag_alias_check = 0;\n+\n+/* 0 if pointer arguments may alias each other.  True in C.\n+   1 if pointer arguments may not alias each other but may alias\n+   global variables.\n+   2 if pointer arguments may not alias each other and may not\n+   alias global variables.  True in Fortran.\n+   This defaults to 0 for C.  */\n+int flag_argument_noalias = 0;\n+\n /* Table of language-independent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -672,6 +683,10 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"pack-struct\", &flag_pack_struct, 1},\n   {\"stack-check\", &flag_stack_check, 1},\n   {\"bytecode\", &output_bytecode, 1},\n+  {\"alias-check\", &flag_alias_check, 1},\n+  {\"argument-alias\", &flag_argument_noalias, 0},\n+  {\"argument-noalias\", &flag_argument_noalias, 1},\n+  {\"argument-noalias-global\", &flag_argument_noalias, 2},\n   {\"check-memory-usage\", &flag_check_memory_usage, 1},\n   {\"prefix-function-name\", &flag_prefix_function_name, 1}\n };\n@@ -3672,6 +3687,7 @@ main (argc, argv, envp)\n #ifdef CAN_DEBUG_WITHOUT_FP\n       flag_omit_frame_pointer = 1;\n #endif\n+      flag_alias_check = 1;\n     }\n \n   if (optimize >= 2)"}, {"sha": "46339988ede28838c67b3be78a3283a8272c0e23", "filename": "gcc/unroll.c", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8ffe751384e446477c47f8cf670d3a1e92fe9/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=9ae8ffe751384e446477c47f8cf670d3a1e92fe9", "patch": "@@ -1046,8 +1046,11 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n \t      for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; j++)\n \t\tif (local_regno[j])\n-\t\t  map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n-\n+\t\t  {\n+\t\t    map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n+\t\t    record_base_value (REGNO (map->reg_map[j]),\n+\t\t\t\t       regno_reg_rtx[j]);\n+\t\t  }\n \t      /* The last copy needs the compare/branch insns at the end,\n \t\t so reset copy_end here if the loop ends with a conditional\n \t\t branch.  */\n@@ -1191,7 +1194,11 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n       for (j = FIRST_PSEUDO_REGISTER; j < max_reg_before_loop; j++)\n \tif (local_regno[j])\n-\t  map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n+\t  {\n+\t    map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n+\t    record_base_value (REGNO (map->reg_map[j]),\n+\t\t\t       regno_reg_rtx[j]);\n+\t  }\n \n       /* If loop starts with a branch to the test, then fix it so that\n \t it points to the test of the first unrolled copy of the loop.  */\n@@ -1691,7 +1698,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t\t/* Check for shared address givs, and avoid\n \t\t\t   incrementing the shared pseudo reg more than\n \t\t\t   once.  */\n-\t\t\tif (! tv->same_insn)\n+\t\t\tif (! tv->same_insn && ! tv->shared)\n \t\t\t  {\n \t\t\t    /* tv->dest_reg may actually be a (PLUS (REG)\n \t\t\t       (CONST)) here, so we must call plus_constant\n@@ -1817,6 +1824,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t      tem = gen_reg_rtx (GET_MODE (giv_src_reg));\n \t\t      giv_dest_reg = tem;\n \t\t      map->reg_map[regno] = tem;\n+\t\t      record_base_value (REGNO (tem), giv_src_reg);\n \t\t    }\n \t\t  else\n \t\t    map->reg_map[regno] = giv_src_reg;\n@@ -2505,7 +2513,8 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t\t      || ! invariant_p (bl->initial_value)))\n \t\t{\n \t\t  rtx tem = gen_reg_rtx (bl->biv->mode);\n-\t\t  \n+\n+\t\t  record_base_value (REGNO (tem), bl->biv->add_val);\n \t\t  emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n \t\t\t\t    loop_start);\n \n@@ -2562,6 +2571,8 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t\t this insn will always be executed, no matter how the loop\n \t\t exits.  */\n \t      rtx tem = gen_reg_rtx (bl->biv->mode);\n+\t      record_base_value (REGNO (tem), bl->biv->add_val);\n+\n \t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n \t\t\t\tloop_start);\n \t      emit_insn_before (gen_move_insn (bl->biv->src_reg,\n@@ -2737,6 +2748,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t    {\n \t      rtx tem = gen_reg_rtx (bl->biv->mode);\n \n+\t      record_base_value (REGNO (tem), bl->biv->add_val);\n \t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n \t\t\t\tloop_start);\n \t      biv_initial_value = tem;\n@@ -2778,6 +2790,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t      || GET_CODE (XEXP (value, 1)) != CONST_INT))\n \t\t{\n \t\t  rtx tem = gen_reg_rtx (v->mode);\n+\t\t  record_base_value (REGNO (tem), v->add_val);\n \t\t  emit_iv_add_mult (bl->initial_value, v->mult_val,\n \t\t\t\t    v->add_val, tem, loop_start);\n \t\t  value = tem;\n@@ -2796,16 +2809,9 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t what we want for split addr regs. We always create a new\n \t\t register for the split addr giv, just to be safe.  */\n \n-\t      /* ??? If there are multiple address givs which have been\n-\t\t combined with the same dest_reg giv, then we may only need\n-\t\t one new register for them.  Pulling out constants below will\n-\t\t catch some of the common cases of this.  Currently, I leave\n-\t\t the work of simplifying multiple address givs to the\n-\t\t following cse pass.  */\n-\t      \n-\t      /* As a special case, if we have multiple identical address givs\n-\t\t within a single instruction, then we do use a single pseudo\n-\t\t reg for both.  This is necessary in case one is a match_dup\n+\t      /* If we have multiple identical address givs within a\n+\t\t single instruction, then use a single pseudo reg for\n+\t\t both.  This is necessary in case one is a match_dup\n \t\t of the other.  */\n \n \t      v->const_adjust = 0;\n@@ -2818,12 +2824,26 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t\t     \"Sharing address givs in insn %d\\n\",\n \t\t\t     INSN_UID (v->insn));\n \t\t}\n+\t      /* If multiple address GIVs have been combined with the\n+\t\t same dest_reg GIV, do not create a new register for\n+\t\t each.  */\n+\t      else if (unroll_type != UNROLL_COMPLETELY\n+\t\t       && v->giv_type == DEST_ADDR\n+\t\t       && v->same && v->same->giv_type == DEST_ADDR\n+\t\t       && v->same->unrolled)\n+\t\t{\n+\t\t  v->dest_reg = v->same->dest_reg;\n+\t\t  v->shared = 1;\n+\t\t}\n \t      else if (unroll_type != UNROLL_COMPLETELY)\n \t\t{\n \t\t  /* If not completely unrolling the loop, then create a new\n \t\t     register to hold the split value of the DEST_ADDR giv.\n \t\t     Emit insn to initialize its value before loop start.  */\n-\t\t  tem = gen_reg_rtx (v->mode);\n+\n+\t\t  rtx tem = gen_reg_rtx (v->mode);\n+\t\t  record_base_value (REGNO (tem), v->add_val);\n+\t\t  v->unrolled = 1;\n \n \t\t  /* If the address giv has a constant in its new_reg value,\n \t\t     then this constant can be pulled out and put in value,\n@@ -2834,7 +2854,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t    {\n \t\t      v->dest_reg\n \t\t\t= plus_constant (tem, INTVAL (XEXP (v->new_reg,1)));\n-\t\t      \n+\n \t\t      /* Only succeed if this will give valid addresses.\n \t\t\t Try to validate both the first and the last\n \t\t\t address resulting from loop unrolling, if\n@@ -3130,6 +3150,7 @@ final_biv_value (bl, loop_start, loop_end)\n \t     case it is needed later.  */\n \n \t  tem = gen_reg_rtx (bl->biv->mode);\n+\t  record_base_value (REGNO (tem), bl->biv->add_val);\n \t  /* Make sure loop_end is not the last insn.  */\n \t  if (NEXT_INSN (loop_end) == 0)\n \t    emit_note_after (NOTE_INSN_DELETED, loop_end);\n@@ -3228,6 +3249,7 @@ final_giv_value (v, loop_start, loop_end)\n \n \t  /* Put the final biv value in tem.  */\n \t  tem = gen_reg_rtx (bl->biv->mode);\n+\t  record_base_value (REGNO (tem), bl->biv->add_val);\n \t  emit_iv_add_mult (increment, GEN_INT (loop_n_iterations),\n \t\t\t    bl->initial_value, tem, insert_before);\n "}]}