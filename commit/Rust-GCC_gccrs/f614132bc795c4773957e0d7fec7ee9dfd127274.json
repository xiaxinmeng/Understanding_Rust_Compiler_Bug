{"sha": "f614132bc795c4773957e0d7fec7ee9dfd127274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYxNDEzMmJjNzk1YzQ3NzM5NTdlMGQ3ZmVjN2VlOWRmZDEyNzI3NA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-27T04:37:47Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-27T04:37:47Z"}, "message": "In gcc/: 2010-10-27 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * c-parser.c (c_parser_objc_at_property): Renamed to\n        c_parser_objc_at_property_declaration.  Updated calls to\n        objc_add_property_variable, now objc_add_property_declaration.\n        Code rewritten to be much more robust in recovering from syntax\n        errors.  Added comments.\n        (c_parser_objc_property_attrlist): Removed.\n        (c_parser_external_declaration): Updated calls to\n        c_parser_objc_at_property, now\n        c_parser_objc_at_property_declaration.\n        (c_parser_objc_methodprotolist): Same change.\n\nIn gcc/c-family/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * c-common.h (objc_add_property_variable): Renamed to\n        objc_add_property_declaration.  Added location argument.\n        * stub-objc.c (objc_add_property_variable): Same change.\n\nIn gcc/cp/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * parser.c (cp_parser_objc_property_decl): Renamed to\n        cp_parser_objc_struct_declaration.  Return the parsed trees\n        instead of calling objc_add_property_variable directly.  Detect\n        missing or invalid declspecs.  Implemented attributes.  Do not eat\n        the ';' at the end.  Exit loop whenever a non-comma is parsed, not\n        just EOF.\n        (cp_parser_objc_at_property): Renamed to\n        cp_parser_objc_at_property_declaration.  Updated calls to\n        objc_add_property_variable, now objc_add_property_declaration, and\n        to cp_parser_objc_property_decl, now\n        cp_parser_objc_struct_declaration.  Rewritten all code to be more\n        robust in dealing with syntax errors, and almost identical to the\n        one in c_parser_objc_at_property_declaration.\n        (cp_parser_objc_property_attrlist): Removed.\n        (cp_parser_objc_method_prototype_list): Updated call to\n        cp_parser_objc_at_property.\n        (cp_parser_objc_method_definition_list): Same change.\n        (cp_parser_objc_class_ivars): Detect a number of invalid\n        declarations of instance variables and produce errors when they\n        are found.\n\nIn gcc/objc/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (objc_add_property_variable): Renamed to\n        objc_add_property_declaration.  Added location argument.  Updated\n        warnings and errors to use it.  Use error, not fatal_error, if a\n        property declaration is found outside an interface or\n        implementation context.\n\nIn gcc/testsuite/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/at-property-1.m: New.\n        * objc.dg/property/at-property-2.m: New.\n        * objc.dg/property/at-property-3.m: New.\n        * objc.dg/ivar-invalid-type-1.m: New.\n        * obj-c++.dg/property/at-property-1.mm: New.\n        * obj-c++.dg/property/at-property-2.mm: New.\n        * obj-c++.dg/property/at-property-3.mm: New.\n        * obj-c++.dg/ivar-invalid-type-1.mm: New.\n        * objc.dg/property/property-neg-6.m: Updated testcase for updates\n        in error reporting.\n\nFrom-SVN: r165996", "tree": {"sha": "6ea8370f843d34af7151be0a948bae894059845f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ea8370f843d34af7151be0a948bae894059845f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f614132bc795c4773957e0d7fec7ee9dfd127274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f614132bc795c4773957e0d7fec7ee9dfd127274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f614132bc795c4773957e0d7fec7ee9dfd127274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f614132bc795c4773957e0d7fec7ee9dfd127274/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e1484c9ee7d218f9e07f13916cbeb0ada3164c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e1484c9ee7d218f9e07f13916cbeb0ada3164c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e1484c9ee7d218f9e07f13916cbeb0ada3164c2"}], "stats": {"total": 851, "additions": 627, "deletions": 224}, "files": [{"sha": "22fb34a4c2750f7b6c63096ca47cd09a9d9f7319", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -1,3 +1,16 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-parser.c (c_parser_objc_at_property): Renamed to\n+\tc_parser_objc_at_property_declaration.  Updated calls to\n+\tobjc_add_property_variable, now objc_add_property_declaration.\n+\tCode rewritten to be much more robust in recovering from syntax\n+\terrors.  Added comments.\n+\t(c_parser_objc_property_attrlist): Removed.\n+\t(c_parser_external_declaration): Updated calls to\n+\tc_parser_objc_at_property, now\n+\tc_parser_objc_at_property_declaration.\n+\t(c_parser_objc_methodprotolist): Same change.\n+\t\n 2010-10-26  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.md (split_stack_return): Put back"}, {"sha": "d742912f8ab9f4e585db6252596f95ed6fd36ed9", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -1,3 +1,9 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-common.h (objc_add_property_variable): Renamed to\n+\tobjc_add_property_declaration.  Added location argument.\n+\t* stub-objc.c (objc_add_property_variable): Same change.\n+\t\n 2010-10-23  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c-common.h (objc_maybe_printable_name): New."}, {"sha": "55637659946b4065b04e1b39b7057817b23c7593", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -1043,7 +1043,7 @@ extern void objc_finish_foreach_loop (location_t, tree, tree, tree, tree, tree);\n extern void objc_set_property_attr \n   (location_t, objc_property_attribute_kind, tree);\n extern bool  objc_method_decl (enum tree_code);\n-extern void objc_add_property_variable (tree);\n+extern void objc_add_property_declaration (location_t, tree);\n extern tree objc_build_getter_call (tree, tree);\n extern tree objc_build_setter_call (tree, tree);\n extern void objc_add_synthesize_declaration (location_t, tree);"}, {"sha": "fb92c7fc0bbe1f3fb6aafe6a82493a3681a9a0d6", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -331,7 +331,7 @@ objc_set_property_attr (location_t ARG_UNUSED (loc),\n }\n \n void\n-objc_add_property_variable (tree ARG_UNUSED (prop))\n+objc_add_property_declaration (location_t ARG_UNUSED (loc), tree ARG_UNUSED (prop))\n {\n }\n "}, {"sha": "c885c8a961048ac1a6b06ab4d1372609d9418a25", "filename": "gcc/c-parser.c", "status": "modified", "additions": 159, "deletions": 113, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -1081,7 +1081,7 @@ static tree c_parser_objc_selector_arg (c_parser *);\n static tree c_parser_objc_receiver (c_parser *);\n static tree c_parser_objc_message_args (c_parser *);\n static tree c_parser_objc_keywordexpr (c_parser *);\n-static void c_parser_objc_at_property (c_parser *) ;\n+static void c_parser_objc_at_property_declaration (c_parser *);\n static void c_parser_objc_at_synthesize_declaration (c_parser *);\n static void c_parser_objc_at_dynamic_declaration (c_parser *);\n static bool c_parser_objc_diagnose_bad_element_prefix\n@@ -1185,7 +1185,7 @@ c_parser_external_declaration (c_parser *parser)\n \t  break;\n \tcase RID_AT_PROPERTY:\n \t  gcc_assert (c_dialect_objc ());\n-\t  c_parser_objc_at_property (parser);\n+\t  c_parser_objc_at_property_declaration (parser);\n \t  break;\n \tcase RID_AT_SYNTHESIZE:\n \t  gcc_assert (c_dialect_objc ());\n@@ -6997,7 +6997,7 @@ c_parser_objc_methodprotolist (c_parser *parser)\n \t  if (c_parser_next_token_is_keyword (parser, RID_AT_END))\n \t    return;\n \t  else if (c_parser_next_token_is_keyword (parser, RID_AT_PROPERTY))\n-\t    c_parser_objc_at_property (parser);\n+\t    c_parser_objc_at_property_declaration (parser);\n \t  else if (c_parser_next_token_is_keyword (parser, RID_AT_OPTIONAL))\n \t    {\n \t      objc_set_method_opt (true);\n@@ -7574,132 +7574,178 @@ c_parser_objc_diagnose_bad_element_prefix (c_parser *parser,\n   return false;\n }\n \n-/* ObjC @property. */\n+/* Parse an Objective-C @property declaration.  The syntax is:\n \n-/* Parse a comma-separated list of property attributes.  */\n+   objc-property-declaration:\n+     '@property' objc-property-attributes[opt] struct-declaration ;\n \n+   objc-property-attributes:\n+    '(' objc-property-attribute-list ')'\n+\n+   objc-property-attribute-list:\n+     objc-property-attribute\n+     objc-property-attribute-list, objc-property-attribute\n+\n+   objc-property-attribute\n+     'getter' = identifier\n+     'setter' = identifier\n+     'readonly'\n+     'readwrite'\n+     'assign'\n+     'retain'\n+     'copy'\n+     'nonatomic'\n+\n+  For example:\n+    @property NSString *name;\n+    @property (readonly) id object;\n+    @property (retain, nonatomic, getter=getTheName) id name;\n+    @property int a, b, c;\n+\n+  PS: This function is identical to cp_parser_objc_at_propery_declaration\n+  for C++.  Keep them in sync.\n+\n+  WORK IN PROGRESS: At the moment, the list of attributes that are\n+  parsed is different from the above list.  It will be updated to use\n+  the above list at the same time as @synthesize is implemented.  */\n static void\n-c_parser_objc_property_attrlist (c_parser *parser)\n+c_parser_objc_at_property_declaration (c_parser *parser)\n {\n-  bool err = false;\n-  /* Initialize to an empty list.  */\n-  objc_set_property_attr (c_parser_peek_token (parser)->location,\n-\t\t\t  OBJC_PATTR_INIT, NULL_TREE);\n+  tree properties;\n+  location_t loc;\n+  loc = c_parser_peek_token (parser)->location;\n+  gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_PROPERTY));\n \n-  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n-    return;\n+  c_parser_consume_token (parser);  /* Eat '@property'.  */\n \n-  /* Eat the '(' */\n-  c_parser_consume_token (parser);\n-  \n-  /* Property attribute keywords are valid now.  */\n-  parser->objc_property_attr_context = true;\n-  while (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN)\n-\t && c_parser_next_token_is_not (parser, CPP_EOF)\n-\t && !err)\n+  /* Initialize attributes to an empty list.  */\n+  objc_set_property_attr (loc, OBJC_PATTR_INIT, NULL_TREE);\n+\n+  /* Parse the optional attribute list...  */\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n-      enum rid keywd;\n-      location_t loc;\n-      if (c_parser_peek_token (parser)->type != CPP_KEYWORD)\n-\t{\n-\t  c_parser_error (parser, \"expected a property attribute\");\n-\t  c_parser_consume_token (parser);\n-\t  err = true;\n-\t  break;\n-\t}\n-      keywd = c_parser_peek_token (parser)->keyword;\n-      /* Initially, make diagnostics point to the attribute.  */\n-      loc = c_parser_peek_token (parser)->location;\n-      switch (keywd)\n+      /* Eat the '(' */\n+      c_parser_consume_token (parser);\n+      \n+      /* Property attribute keywords are valid now.  */\n+      parser->objc_property_attr_context = true;\n+\n+      while (true)\n \t{\n-\t  tree ident;\n-\t  objc_property_attribute_kind pkind;\n-\t  case RID_READONLY:\n-\t    objc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n+\t  bool syntax_error = false;\n+\t  c_token *token = c_parser_peek_token (parser);\n+\t  enum rid keyword;\n+\n+\t  if (token->type != CPP_KEYWORD)\n+\t    {\n+\t      if (token->type == CPP_CLOSE_PAREN)\n+\t\tc_parser_error (parser, \"expected identifier\");\n+\t      else\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  c_parser_error (parser, \"unknown property attribute\");\n+\t\t}\n+\t      break;\n+\t    }\n+\t  keyword = token->keyword;\n+\t  switch (keyword)\n+\t    {\n+\t      tree ident;\n+\t      objc_property_attribute_kind pkind;\n+\t    case RID_READONLY:\n+\t      c_parser_consume_token (parser);\n+\t      objc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n+\t      break;\n+\t    case RID_GETTER:\n+\t    case RID_SETTER:\n+\t    case RID_IVAR:\n+\t      c_parser_consume_token (parser);\n+\t      if (c_parser_next_token_is_not (parser, CPP_EQ))\n+\t\t{\n+\t\t  c_parser_error (parser,\n+\t\t\t\t  \"getter/setter/ivar attribute must be followed by %<=%>\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      c_parser_consume_token (parser); /* eat the = */\n+\t      if (c_parser_next_token_is_not (parser, CPP_NAME))\n+\t\t{\n+\t\t  c_parser_error (parser, \"expected identifier\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      ident = c_parser_peek_token (parser)->value;\n+\t      c_parser_consume_token (parser);\n+\t      if (keyword == RID_SETTER)\n+\t\t{\n+\t\t  pkind = OBJC_PATTR_SETTER;\n+\t\t  /* Eat the identifier, and look for the following : */\n+\t\t  if (c_parser_next_token_is_not (parser, CPP_COLON))\n+\t\t    {\n+\t\t      c_parser_error (parser,\n+\t\t\t\t      \"setter name must be followed by %<:%>\");\n+\t\t      syntax_error = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  c_parser_consume_token (parser);\n+\t\t}\n+\t      else if (keyword == RID_GETTER)\n+\t\tpkind = OBJC_PATTR_GETTER;\n+\t      else\n+\t\tpkind = OBJC_PATTR_IVAR;\n+\t      objc_set_property_attr (loc, pkind, ident);\n+\t      break;\n+\t    case RID_COPIES:\n+\t      c_parser_consume_token (parser);\n+\t      objc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n+\t      break;\n+\t    default:\n+\t      if (token->type == CPP_CLOSE_PAREN)\n+\t\tc_parser_error (parser, \"expected identifier\");\n+\t      else\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  c_parser_error (parser, \"unknown property attribute\");\n+\t\t}\n+\t      syntax_error = true;\n+\t      break;\n+\t    }\n+\n+\t  if (syntax_error)\n \t    break;\n-\t  case RID_GETTER:\n-\t  case RID_SETTER:\n-\t  case RID_IVAR:\n+\t  \n+\t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    c_parser_consume_token (parser);\n-\t    if (c_parser_next_token_is_not (parser, CPP_EQ))\n-\t      {\n-\t\tc_parser_error (parser, \n-\t\t  \"getter/setter/ivar attribute must be followed by %<=%>\");\n-\t\terr = true;\n-\t\tbreak;\n-\t      }\n-\t    c_parser_consume_token (parser); /* eat the = */\n-\t    if (c_parser_next_token_is_not (parser, CPP_NAME))\n-\t      {\n-\t\tc_parser_error (parser, \"expected an identifier\");\n-\t\terr = true;\n-\t\tbreak;\n-\t      }\n-\t    ident = c_parser_peek_token (parser)->value;\n-\t    if (keywd == RID_SETTER)\n-\t      {\n-\t\tpkind = OBJC_PATTR_SETTER;\n-\t\t/* Eat the identifier, and look for the following : */\n-\t\tc_parser_consume_token (parser);\n-\t\tif (c_parser_next_token_is_not (parser, CPP_COLON))\n-\t\t  {\n-\t\t    c_parser_error (parser,\n-\t\t\t\t\"setter name must be followed by %<:%>\");\n-\t\t    err = true;\n-\t\t  }\n-\t      }\n-\t    else if (keywd == RID_GETTER)\n-\t      pkind = OBJC_PATTR_GETTER;\n-\t    else\n-\t      pkind = OBJC_PATTR_IVAR;\n-\t    \n-\t    objc_set_property_attr (loc, pkind, ident);\n-\t    break;\n-\t  case RID_COPIES:\n-\t    objc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n-\t    break;\n-\t  default:\n-\t    c_parser_error (parser, \"unknown property attribute\");\n-\t    err = true;\n+\t  else\n \t    break;\n \t}\n-      /* Eat the attribute,identifier or colon that's been used.  */\n-      c_parser_consume_token (parser);\n-      if (err)\n-        break;\n-\n-      if (c_parser_next_token_is (parser, CPP_COMMA))\n-\tc_parser_consume_token (parser);\n-      else if (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n-\twarning_at (c_parser_peek_token (parser)->location, 0, \n-\t\t    \"property attributes should be separated by a %<,%>\");\n-    }  \n-  parser->objc_property_attr_context = false;\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n-}\n-\n-/* Parse property attributes and then the definition.  */\n-\n-static void\n-c_parser_objc_at_property (c_parser *parser)\n-{\n-  tree props;\n-  /* We should only arrive here with the property keyword.  */\n-  c_parser_require_keyword (parser, RID_AT_PROPERTY, \"expected %<@property%>\");\n-\n-  /* Process the optional attribute list...  */\n-  c_parser_objc_property_attrlist (parser) ;\n-  /* ... and the property var decls.  */\n-  props = c_parser_struct_declaration (parser);\n+      parser->objc_property_attr_context = false;\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+    }\n+  /* ... and the property declaration(s).  */\n+  properties = c_parser_struct_declaration (parser);\n \n-  /* Comma-separated properties are chained together in\n-     reverse order; add them one by one.  */\n-  props = nreverse (props);\n+  if (properties == error_mark_node)\n+    {\n+      c_parser_skip_until_found (parser, CPP_SEMICOLON, NULL);\n+      parser->error = false;\n+      return;\n+    }\n \n-  for (; props; props = TREE_CHAIN (props))\n-    objc_add_property_variable (copy_node (props));\n+  if (properties == NULL_TREE)\n+    c_parser_error (parser, \"expected identifier\");\n+  else\n+    {\n+      /* Comma-separated properties are chained together in\n+\t reverse order; add them one by one.  */\n+      properties = nreverse (properties);\n+      \n+      for (; properties; properties = TREE_CHAIN (properties))\n+\tobjc_add_property_declaration (loc, copy_node (properties));\n+    }\n \n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+  parser->error = false;\n }\n \n /* Parse an Objective-C @synthesize declaration.  The syntax is:"}, {"sha": "582e5c871e0f4f05dc243917ad99bd1eed518f09", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -1,3 +1,26 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* parser.c (cp_parser_objc_property_decl): Renamed to\n+\tcp_parser_objc_struct_declaration.  Return the parsed trees\n+\tinstead of calling objc_add_property_variable directly.  Detect\n+\tmissing or invalid declspecs.  Implemented attributes.  Do not eat\n+\tthe ';' at the end.  Exit loop whenever a non-comma is parsed, not\n+\tjust EOF.\n+\t(cp_parser_objc_at_property): Renamed to\n+\tcp_parser_objc_at_property_declaration.  Updated calls to\n+\tobjc_add_property_variable, now objc_add_property_declaration, and\n+\tto cp_parser_objc_property_decl, now\n+\tcp_parser_objc_struct_declaration.  Rewritten all code to be more\n+\trobust in dealing with syntax errors, and almost identical to the\n+\tone in c_parser_objc_at_property_declaration.\n+\t(cp_parser_objc_property_attrlist): Removed.\n+\t(cp_parser_objc_method_prototype_list): Updated call to\n+\tcp_parser_objc_at_property.\n+\t(cp_parser_objc_method_definition_list): Same change.\n+\t(cp_parser_objc_class_ivars): Detect a number of invalid\n+\tdeclarations of instance variables and produce errors when they\n+\tare found.\n+\t\n 2010-10-26  Jason Merrill  <jason@redhat.com>\n \n \t* tree.c (build_vec_init_expr): Split out from..."}, {"sha": "95be6d324b9084cfdc843c598b94a7da2de0509b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 252, "deletions": 97, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -2098,13 +2098,13 @@ static tree cp_parser_objc_statement\n   (cp_parser *);\n static bool cp_parser_objc_valid_prefix_attributes\n   (cp_parser *, tree *);\n-static void cp_parser_objc_at_property \n+static void cp_parser_objc_at_property_declaration \n   (cp_parser *) ;\n static void cp_parser_objc_at_synthesize_declaration \n   (cp_parser *) ;\n static void cp_parser_objc_at_dynamic_declaration\n   (cp_parser *) ;\n-static void cp_parser_objc_property_decl \n+static tree cp_parser_objc_struct_declaration\n   (cp_parser *) ;\n \n /* Utility Routines */\n@@ -21930,7 +21930,7 @@ cp_parser_objc_method_prototype_list (cp_parser* parser)\n \t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n \t}\n       else if (token->keyword == RID_AT_PROPERTY)\n-\tcp_parser_objc_at_property (parser);\n+\tcp_parser_objc_at_property_declaration (parser);\n       else if (token->keyword == RID_ATTRIBUTE \n       \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n \twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n@@ -21997,8 +21997,10 @@ cp_parser_objc_method_definition_list (cp_parser* parser)\n \t      objc_finish_method_definition (meth);\n \t    }\n \t}\n+      /* The following case will be removed once @synthesize is\n+\t completely implemented.  */\n       else if (token->keyword == RID_AT_PROPERTY)\n-\tcp_parser_objc_at_property (parser);\n+\tcp_parser_objc_at_property_declaration (parser);\n       else if (token->keyword == RID_AT_SYNTHESIZE)\n \tcp_parser_objc_at_synthesize_declaration (parser);\n       else if (token->keyword == RID_AT_DYNAMIC)\n@@ -22051,6 +22053,28 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t    &declspecs,\n \t\t\t\t    &decl_class_or_enum_p);\n+\n+      /* auto, register, static, extern, mutable.  */\n+      if (declspecs.storage_class != sc_none)\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\t  \n+\t  declspecs.storage_class = sc_none;\n+\t}\n+\n+      /* __thread.  */\n+      if (declspecs.specs[(int) ds_thread])\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\n+\t  declspecs.specs[(int) ds_thread] = 0;\n+\t}\n+      \n+      /* typedef.  */\n+      if (declspecs.specs[(int) ds_typedef])\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\n+\t  declspecs.specs[(int) ds_typedef] = 0;\n+\t}\n+\n       prefix_attributes = declspecs.attributes;\n       declspecs.attributes = NULL_TREE;\n \n@@ -22496,144 +22520,275 @@ cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)\n   return false;  \n }\n \n-/* This routine parses the propery declarations. */\n+/* This routine is a minimal replacement for\n+   c_parser_struct_declaration () used when parsing the list of\n+   types/names or ObjC++ properties.  For example, when parsing the\n+   code\n \n-static void\n-cp_parser_objc_property_decl (cp_parser *parser)\n+   @property (readonly) int a, b, c;\n+\n+   this function is responsible for parsing \"int a, int b, int c\" and\n+   returning the declarations as CHAIN of DECLs.\n+\n+   TODO: Share this code with cp_parser_objc_class_ivars.  It's very\n+   similar parsing.  */\n+static tree\n+cp_parser_objc_struct_declaration (cp_parser *parser)\n {\n-  int declares_class_or_enum;\n+  tree decls = NULL_TREE;\n   cp_decl_specifier_seq declspecs;\n+  int decl_class_or_enum_p;\n+  tree prefix_attributes;\n \n   cp_parser_decl_specifier_seq (parser,\n-                                CP_PARSER_FLAGS_NONE,\n-                                &declspecs,\n-                                &declares_class_or_enum);\n+\t\t\t\tCP_PARSER_FLAGS_NONE,\n+\t\t\t\t&declspecs,\n+\t\t\t\t&decl_class_or_enum_p);\n+\n+  if (declspecs.type == error_mark_node)\n+    return error_mark_node;\n+\n+  /* auto, register, static, extern, mutable.  */\n+  if (declspecs.storage_class != sc_none)\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.storage_class = sc_none;\n+    }\n+  \n+  /* __thread.  */\n+  if (declspecs.specs[(int) ds_thread])\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.specs[(int) ds_thread] = 0;\n+    }\n+  \n+  /* typedef.  */\n+  if (declspecs.specs[(int) ds_typedef])\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.specs[(int) ds_typedef] = 0;\n+    }\n+\n+  prefix_attributes = declspecs.attributes;\n+  declspecs.attributes = NULL_TREE;\n+\n   /* Keep going until we hit the `;' at the end of the declaration. */\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     {\n-      tree property;\n+      tree attributes, first_attribute, decl;\n+      cp_declarator *declarator;\n       cp_token *token;\n-      cp_declarator *declarator\n-\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\tNULL, NULL, false);\n-      property = grokdeclarator (declarator, &declspecs, NORMAL,0, NULL);\n-      /* Recover from any kind of error in property declaration. */\n-      if (property == error_mark_node || property == NULL_TREE)\n-\treturn;\n \n-      /* Add to property list. */\n-      objc_add_property_variable (copy_node (property));\n+      /* Parse the declarator.  */\n+      declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t NULL, NULL, false);\n+\n+      /* Look for attributes that apply to the ivar.  */\n+      attributes = cp_parser_attributes_opt (parser);\n+      /* Remember which attributes are prefix attributes and\n+\t which are not.  */\n+      first_attribute = attributes;\n+      /* Combine the attributes.  */\n+      attributes = chainon (prefix_attributes, attributes);\n+      \n+      decl = grokfield (declarator, &declspecs,\n+\t\t\tNULL_TREE, /*init_const_expr_p=*/false,\n+\t\t\tNULL_TREE, attributes);\n+\n+      if (decl == error_mark_node || decl == NULL_TREE)\n+\treturn error_mark_node;\n+      \n+      /* Reset PREFIX_ATTRIBUTES.  */\n+      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\tattributes = TREE_CHAIN (attributes);\n+      if (attributes)\n+\tTREE_CHAIN (attributes) = NULL_TREE;\n+\n+      DECL_CHAIN (decl) = decls;\n+      decls = decl;\n+\n       token = cp_lexer_peek_token (parser->lexer);\n       if (token->type == CPP_COMMA)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n \t  continue;\n \t}\n-      else if (token->type == CPP_EOF)\n+      else\n \tbreak;\n     }\n-  /* Eat ';' if present, or issue an error.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+  return decls;\n }\n \n-/* ObjC @property. */\n-/* Parse a comma-separated list of property attributes.  \n-   The lexer does not recognize */\n+/* Parse an Objective-C @property declaration.  The syntax is:\n+\n+   objc-property-declaration:\n+     '@property' objc-property-attributes[opt] struct-declaration ;\n+\n+   objc-property-attributes:\n+    '(' objc-property-attribute-list ')'\n+\n+   objc-property-attribute-list:\n+     objc-property-attribute\n+     objc-property-attribute-list, objc-property-attribute\n+\n+   objc-property-attribute\n+     'getter' = identifier\n+     'setter' = identifier\n+     'readonly'\n+     'readwrite'\n+     'assign'\n+     'retain'\n+     'copy'\n+     'nonatomic'\n+\n+  For example:\n+    @property NSString *name;\n+    @property (readonly) id object;\n+    @property (retain, nonatomic, getter=getTheName) id name;\n+    @property int a, b, c;\n+\n+   PS: This function is identical to\n+   c_parser_objc_at_property_declaration for C.  Keep them in sync.\n \n+   WORK IN PROGRESS: At the moment, the list of attributes that are\n+   parsed is different from the above list.  It will be updated to use\n+   the above list at the same time as @synthesize is implemented.  */\n static void \n-cp_parser_objc_property_attrlist (cp_parser *parser)\n+cp_parser_objc_at_property_declaration (cp_parser *parser)\n {\n-  cp_token *token;\n-  /* Initialize to an empty list.  */\n-  objc_set_property_attr (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t\t  OBJC_PATTR_INIT, NULL_TREE);\n+  tree properties;\n+  location_t loc;\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n \n-  /* The list is optional.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n-    return;\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@property'.  */\n \n-  /* Eat the '('.  */\n-  cp_lexer_consume_token (parser->lexer);\n+  /* Initialize attributes to an empty list.  */\n+  objc_set_property_attr (loc, OBJC_PATTR_INIT, NULL_TREE);\n \n-  token = cp_lexer_peek_token (parser->lexer);\n-  while (token->type != CPP_CLOSE_PAREN && token->type != CPP_EOF)\n-    {\n-      location_t loc = token->location;\n-      tree node = cp_parser_identifier (parser);\n-      if (node == ridpointers [(int) RID_READONLY])\n-\tobjc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n-      else if (node == ridpointers [(int) RID_GETTER]\n-\t       || node == ridpointers [(int) RID_SETTER]\n-\t       || node == ridpointers [(int) RID_IVAR])\n+  /* Parse the optional attribute list...  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      /* Eat the '('.  */\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      while (true)\n \t{\n-\t  /* Do the getter/setter/ivar attribute. */\n-\t  token = cp_lexer_consume_token (parser->lexer);\n-\t  if (token->type == CPP_EQ)\n+\t  bool syntax_error = false;\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      \t  enum rid keyword;\n+\n+\t  if (token->type != CPP_NAME)\n \t    {\n-\t      tree attr_ident = cp_parser_identifier (parser);\n+\t      cp_parser_error (parser, \"expected identifier\");\n+\t      break;\n+\t    }\n+\t  keyword = C_RID_CODE (token->u.value);\n+\t  switch (keyword)\n+\t    {\n+\t      tree ident;\n \t      objc_property_attribute_kind pkind;\n-\t      if (node == ridpointers [(int) RID_GETTER])\n-\t\tpkind = OBJC_PATTR_GETTER;\n-\t      else if (node == ridpointers [(int) RID_SETTER])\n+\t    case RID_READONLY:\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      objc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n+\t      break;\n+\t    case RID_GETTER:\n+\t    case RID_SETTER:\n+\t    case RID_IVAR:\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n+\t\t{\n+\t\t  cp_parser_error (parser,\n+\t\t\t\t   \"getter/setter/ivar attribute must be followed by %<=%>\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      cp_lexer_consume_token (parser->lexer); /* eat the = */\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+\t\t{\n+\t\t  cp_parser_error (parser, \"expected identifier\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      ident = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      if (keyword == RID_SETTER)\n \t\t{\n \t\t  pkind = OBJC_PATTR_SETTER;\n-\t\t  /* Consume the ':' which must always follow the setter name. */\n-\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n-\t\t    cp_lexer_consume_token (parser->lexer); \n-\t\t  else\n+\t\t  /* Eat the identifier, and look for the following : */\n+\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n \t\t    {\n-\t\t      error_at (token->location,\n-\t\t\t\t\"setter name must be followed by %<:%>\");\n+\t\t      cp_parser_error (parser,\n+\t\t\t\t      \"setter name must be followed by %<:%>\");\n+\t\t      syntax_error = true;\n \t\t      break;\n \t\t    }\n+\t\t  cp_lexer_consume_token (parser->lexer);\n \t\t}\n-\t      else \n+\t      else if (keyword == RID_GETTER)\n+\t\tpkind = OBJC_PATTR_GETTER;\n+\t      else\n \t\tpkind = OBJC_PATTR_IVAR;\n-\t      objc_set_property_attr (loc, pkind, attr_ident);\t  \n-\t    }\n-\t  else\n-\t    {\n-\t      error_at (token->location,\n-\t      \t\"getter/setter/ivar attribute must be followed by %<=%>\");\n+\t      objc_set_property_attr (loc, pkind, ident);\n+\t      break;\n+\t    case RID_COPIES:\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      objc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n+\t      break;\n+\t    default:\n+\t      if (token->type == CPP_CLOSE_PAREN)\n+\t\tcp_parser_error (parser, \"expected identifier\");\n+\t      else\n+\t\t{\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  cp_parser_error (parser, \"unknown property attribute\");\n+\t\t}\n+\t      syntax_error = true;\n \t      break;\n \t    }\n+\n+\t  if (syntax_error)\n+\t    break;\n+\t  \n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  else\n+\t    break;\n \t}\n-      else if (node == ridpointers [(int) RID_COPIES])\n-\tobjc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n-      else\n+\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \t{\n-\t  error_at (token->location,\"unknown property attribute\");\n-\t  break;\n+\t  cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t /*recovering=*/true,\n+\t\t\t\t\t\t /*or_comma=*/false,\n+\t\t\t\t\t\t /*consume_paren=*/true);\n \t}\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\tcp_lexer_consume_token (parser->lexer);\n-      else if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-\twarning_at (token->location, 0, \n-\t\t    \"property attributes should be separated by a %<,%>\");\n-      token = cp_lexer_peek_token (parser->lexer);\t  \n     }\n \n-  if (token->type != CPP_CLOSE_PAREN)\n-    error_at (token->location,\n-\t      \"syntax error in @property's attribute declaration\");\n-  else\n-    /* Consume ')' */\n-    cp_lexer_consume_token (parser->lexer);\n-}\n-\n-/* This function parses a @property declaration inside an objective class\n-   or its implementation. */\n+  /* ... and the property declaration(s).  */\n+  properties = cp_parser_objc_struct_declaration (parser);\n \n-static void \n-cp_parser_objc_at_property (cp_parser *parser)\n-{\n-  /* Consume @property */\n-  cp_lexer_consume_token (parser->lexer);\n+  if (properties == error_mark_node)\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      /* If the next token is now a `;', consume it.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\tcp_lexer_consume_token (parser->lexer);\n+      return;\n+    }\n \n-  /* Parse optional attributes list...  */\n-  cp_parser_objc_property_attrlist (parser);\n-  /* ... and the property declaration(s).  */\n-  cp_parser_objc_property_decl (parser);\n+  if (properties == NULL_TREE)\n+    cp_parser_error (parser, \"expected identifier\");\n+  else\n+    {\n+      /* Comma-separated properties are chained together in\n+\t reverse order; add them one by one.  */\n+      properties = nreverse (properties);\n+      \n+      for (; properties; properties = TREE_CHAIN (properties))\n+\tobjc_add_property_declaration (loc, copy_node (properties));\n+    }\n+  \n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n }\n \n /* Parse an Objective-C++ @synthesize declaration.  The syntax is:"}, {"sha": "de29539c57584b00dc9a39678e7ddb96124a08e2", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -1,3 +1,11 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_add_property_variable): Renamed to\n+\tobjc_add_property_declaration.  Added location argument.  Updated\n+\twarnings and errors to use it.  Use error, not fatal_error, if a\n+\tproperty declaration is found outside an interface or\n+\timplementation context.\n+\t\n 2010-10-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_keyword_decl): Updated comments.  Do not"}, {"sha": "efdf17f709ef59ae13e987fc268555a80a570100", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -871,7 +871,7 @@ objc_set_property_attr (location_t loc, objc_property_attribute_kind attr,\n */\n \n void\n-objc_add_property_variable (tree decl)\n+objc_add_property_declaration (location_t location, tree decl)\n {\n   tree property_decl;\n   tree x;\n@@ -882,7 +882,7 @@ objc_add_property_variable (tree decl)\n       interface = lookup_interface (CLASS_NAME (objc_implementation_context));\n       if (!interface)\n \t{\n-\t  error (\"no class property can be implemented without an interface\");\n+\t  error_at (location, \"no class property can be implemented without an interface\");\n \t  return;\n \t}\n       if (TREE_CODE (objc_implementation_context) == CATEGORY_IMPLEMENTATION_TYPE)\n@@ -891,14 +891,14 @@ objc_add_property_variable (tree decl)\n \t\t\t\t     CLASS_SUPER_NAME (objc_implementation_context));\t\n \t  if (!interface)\n \t    {\n-\t      error (\"no category property can be implemented without an interface\");\n+\t      error_at (location, \"no category property can be implemented without an interface\");\n \t      return;\n \t    }\n         }\n     }\n   else if (!objc_interface_context)\n     {\n-      fatal_error (\"property declaration not in @interface or @implementation context\");\n+      error_at (location, \"property declaration not in @interface or @implementation context\");\n       return;\n     }\n \n@@ -923,13 +923,13 @@ objc_add_property_variable (tree decl)\n       /* Issue error if property and an ivar name match. */\n       if (TREE_CODE (objc_interface_context) == CLASS_INTERFACE_TYPE\n \t  && is_ivar (CLASS_IVARS (objc_interface_context), DECL_NAME (decl)))\n-\terror (\"property %qD may not have the same name as an ivar in the class\", decl);\n+\terror_at (location, \"property %qD may not have the same name as an ivar in the class\", decl);\n       /* must check for duplicate property declarations. */\n       for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n \t{\n \t  if (PROPERTY_NAME (x) == DECL_NAME (decl))\n \t    {\n-\t      error (\"duplicate property declaration %qD\", decl);\n+\t      error_at (location, \"duplicate property declaration %qD\", decl);\n \t      return;\n \t    }\n \t}\n@@ -945,26 +945,26 @@ objc_add_property_variable (tree decl)\n \t  break;\n       if (!x)\n \t{\n-\t  error (\"no declaration of property %qD found in the interface\", decl);\n+\t  error_at (location, \"no declaration of property %qD found in the interface\", decl);\n \t  return;\n \t}\n       /* readonlys must also match. */\n       if (PROPERTY_READONLY (x) != PROPERTY_READONLY (property_decl))\n \t{\n-\t  error (\"property %qD %<readonly%> attribute conflicts with its\" \n-\t\t \" interface version\", decl);\n+\t  error_at (location, \"property %qD %<readonly%> attribute conflicts with its\" \n+\t\t    \" interface version\", decl);\n \t}\n       /* copies must also match. */\n       if (PROPERTY_COPIES (x) != PROPERTY_COPIES (property_decl))\n \t{\n-\t  error (\"property %qD %<copies%> attribute conflicts with its\" \n-\t\t \" interface version\", decl);\n+\t  error_at (location, \"property %qD %<copies%> attribute conflicts with its\" \n+\t\t    \" interface version\", decl);\n \t}\n       /* Cannot have readonly and setter attribute for the same property. */\n       if (PROPERTY_READONLY (property_decl) == boolean_true_node &&\n \t  PROPERTY_SETTER_NAME (property_decl))\n \t{\n-\t  warning (0, \"a %<readonly%> property cannot have a setter (ignored)\");\n+\t  warning_at (location, 0, \"a %<readonly%> property cannot have a setter (ignored)\");\n \t  PROPERTY_SETTER_NAME (property_decl) = NULL_TREE;\n \t}\n       /* Add the property to the list of properties for current implementation. */"}, {"sha": "2a824880995137d38835cb03fe68c4b8c0ca1c9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -1,3 +1,16 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/at-property-1.m: New.\t\n+\t* objc.dg/property/at-property-2.m: New.\n+\t* objc.dg/property/at-property-3.m: New.\n+\t* objc.dg/ivar-invalid-type-1.m: New.\n+\t* obj-c++.dg/property/at-property-1.mm: New.\n+\t* obj-c++.dg/property/at-property-2.mm: New.\n+\t* obj-c++.dg/property/at-property-3.mm: New.\t\n+\t* obj-c++.dg/ivar-invalid-type-1.mm: New.\n+\t* objc.dg/property/property-neg-6.m: Updated testcase for updates\n+\tin error reporting.\n+\n 2010-10-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/46010"}, {"sha": "bd2094ade076321472e56c0d7baf91b1fd8b9e85", "filename": "gcc/testsuite/obj-c++.dg/ivar-invalid-type-1.mm", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fivar-invalid-type-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fivar-invalid-type-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fivar-invalid-type-1.mm?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@interface MySubClass\n+{\n+  volatile int a;  /* This is allowed */\n+  extern int b;    /* { dg-error \"invalid type\" } */\n+  static int c;    /* { dg-error \"invalid type\" } */\n+  inline int d;    /* { dg-error \"declared as an .inline.\" } */\n+  typedef int e;   /* { dg-error \"invalid type\" } */\n+  __thread int f;  /* dg-error \"invalid type\" */ /* FIXME: The compiler generates this message, but the testsuite does not match it.  */\n+}\n+@end"}, {"sha": "c3be5d81c2e6224c243406894764b1c74e1d8a9e", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-1.mm", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-1.mm?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property;                      /* { dg-error \"expected identifier\" } */\n+@property int;                  /* { dg-error \"expected identifier\" } */\n+@property int a;\n+@property int b, c;\n+@property () int d;             /* { dg-error \"expected identifier\" } */\n+@property (readonly) int e;\n+@property (readonly,) int f;    /* { dg-error \"expected identifier\" } */\n+@property (xxx) int g;          /* { dg-error \"unknown property attribute\" } */\n+@property (readonly,xxx) int h; /* { dg-error \"unknown property attribute\" } */\n+/* FIXME - there is a problem with the testuite in running the following test.  The compiler\n+   generates the messages, but the testsuite still complains.  */\n+/*@property ( int i;*/          /* dg-error \"unknown property attribute\" */\n+                                /* dg-error \"expected ... \"       \"\" { target *-*-* } 18 */\n+                                /* dg-error \"expected identfier \" \"\" { target *-*-* } 18 */\n+@end"}, {"sha": "7442251377afd701bfb77a82e49dbfc7567fd6ed", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-2.mm", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-2.mm?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property id name __attribute__((deprecated));\n+@property id table __attribute__((xxx));        /* { dg-warning \".xxx. attribute directive ignored\" } */\n+@property void function (void);                 /* { dg-error \"can.t make .function. into a method\" } */\n+@property typedef int j;                        /* { dg-error \"invalid type for property\" } */\n+@end"}, {"sha": "adf4dd0366bf0cf671b97c30dd4030d9b5cedb03", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-3.mm", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-3.mm?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property volatile int a;  /* This is allowed */\n+@property extern int b;    /* { dg-error \"invalid type\" } */\n+@property static int c;    /* { dg-error \"invalid type\" } */\n+@property inline int d;    /* { dg-error \"declared as an .inline.\" } */\n+@property typedef int e;   /* { dg-error \"invalid type\" } */\n+@property __thread int f;  /* { dg-error \"invalid type\" } */\n+@end"}, {"sha": "3e7785db86f84413188f71321b52ec93bcaf343e", "filename": "gcc/testsuite/objc.dg/ivar-invalid-type-1.m", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fivar-invalid-type-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fivar-invalid-type-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fivar-invalid-type-1.m?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@end\n+\n+@interface MySubClass\n+{\n+  volatile int a;  /* This is allowed */\n+  extern int b;    /* { dg-error \"expected\" } */\n+  static int c;    /* { dg-error \"expected\" } */\n+  inline int d;    /* { dg-error \"expected\" } */\n+  typedef int e;   /* { dg-error \"expected\" } */\n+  __thread int f;  /* { dg-error \"expected\" } */\n+}\n+@end"}, {"sha": "4ff269d0f5ab06e8143f967a8f5f19d70a730ceb", "filename": "gcc/testsuite/objc.dg/property/at-property-1.m", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-1.m?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property;                      /* { dg-error \"expected\" } */\n+@property int;                  /* { dg-error \"expected identifier\" } */\n+                                /* { dg-warning \"declaration does not declare anything\" \"\" { target *-*-* } 10 } */\n+@property int a;\n+@property int b, c;\n+@property () int d;             /* { dg-error \"expected identifier\" } */\n+@property (readonly) int e;\n+@property (readonly,) int f;    /* { dg-error \"expected identifier\" } */\n+@property (xxx) int g;          /* { dg-error \"unknown property attribute\" } */\n+@property (readonly,xxx) int h; /* { dg-error \"unknown property attribute\" } */\n+@property ( int i;              /* { dg-error \"unknown property attribute\" } */\n+/* Because the last syntax error opens a '(' and never closes it, we get to the end of input.  */\n+@end                            /* { dg-error \"expected ..end. at end of input\" } */"}, {"sha": "23bd4850310754ce785964eb14ca0dd14ca08bfe", "filename": "gcc/testsuite/objc.dg/property/at-property-2.m", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-2.m?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property id name __attribute__((deprecated));\n+@property id table __attribute__((xxx));        /* { dg-warning \".xxx. attribute directive ignored\" } */\n+@property void function (void);                 /* { dg-error \"declared as a function\" } */\n+@property typedef int j;                        /* { dg-error \"expected\" } */\n+@end"}, {"sha": "70b522cbabf1e41816f7b44a748cbe8a7381e0ae", "filename": "gcc/testsuite/objc.dg/property/at-property-3.m", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-3.m?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property volatile int a;  /* This is allowed */\n+@property extern int b;    /* { dg-error \"expected\" } */\n+@property static int c;    /* { dg-error \"expected\" } */\n+@property inline int d;    /* { dg-error \"expected\" } */\n+@property typedef int e;   /* { dg-error \"expected\" } */\n+@property __thread int f;  /* { dg-error \"expected\" } */\n+@end"}, {"sha": "7059a56f0944ad11d7d69d88b77fc18d8728a2f2", "filename": "gcc/testsuite/objc.dg/property/property-neg-6.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f614132bc795c4773957e0d7fec7ee9dfd127274/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-6.m?ref=f614132bc795c4773957e0d7fec7ee9dfd127274", "patch": "@@ -6,3 +6,4 @@ @interface Bar\n   int iVar;\n }\n @property int FooBar /* { dg-error \"expected ':', ',', ';', '\\}' or '__attribute__' at end of input\" } */\n+/* { dg-error \"expected ..end. at end of input\" \"\" { target *-*-* } 8 } */"}]}