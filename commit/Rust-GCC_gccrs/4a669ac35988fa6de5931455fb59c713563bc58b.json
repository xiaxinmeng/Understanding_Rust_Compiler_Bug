{"sha": "4a669ac35988fa6de5931455fb59c713563bc58b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE2NjlhYzM1OTg4ZmE2ZGU1OTMxNDU1ZmI1OWM3MTM1NjNiYzU4Yg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-07-07T08:49:04Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-07-07T08:49:04Z"}, "message": "tree-vrp.c (vrp_int_const_binop): Change overflow type to overflow_type.\n\n\t* tree-vrp.c (vrp_int_const_binop): Change overflow type to\n\toverflow_type.\n\t(combine_bound): Use wide-int overflow calculation instead of\n\trolling our own.\n\t* calls.c (maybe_warn_alloc_args_overflow): Change overflow type to\n\toverflow_type.\n\t* fold-const.c (int_const_binop_2): Same.\n\t(extract_muldiv_1): Same.\n\t(fold_div_compare): Same.\n\t(fold_abs_const): Same.\n\t* match.pd: Same.\n\t* poly-int.h (add): Same.\n\t(sub): Same.\n\t(neg): Same.\n\t(mul): Same.\n\t* predict.c (predict_iv_comparison): Same.\n\t* profile-count.c (slow_safe_scale_64bit): Same.\n\t* simplify-rtx.c (simplify_const_binary_operation): Same.\n\t* tree-chrec.c (tree_fold_binomial): Same.\n\t* tree-data-ref.c (split_constant_offset_1): Same.\n\t* tree-if-conv.c (idx_within_array_bound): Same.\n\t* tree-scalar-evolution.c (iv_can_overflow_p): Same.\n\t* tree-ssa-phiopt.c (minmax_replacement): Same.\n\t* tree-vect-loop.c (is_nonwrapping_integer_induction): Same.\n\t* tree-vect-stmts.c (vect_truncate_gather_scatter_offset): Same.\n\t* vr-values.c (vr_values::adjust_range_with_scev): Same.\n\t* wide-int.cc (wi::add_large): Same.\n\t(wi::mul_internal): Same.\n\t(wi::sub_large): Same.\n\t(wi::divmod_internal): Same.\n\t* wide-int.h: Change overflow type to overflow_type for neg, add,\n\tmul, smul, umul, div_trunc, div_floor, div_ceil, div_round,\n\tmod_trunc, mod_ceil, mod_round, add_large, sub_large,\n\tmul_internal, divmod_internal.\n\t(overflow_type): New enum.\n\t(accumulate_overflow): New.\n\ncp/\n\t* decl.c (build_enumerator): Change overflow type to overflow_type.\n\t* init.c (build_new_1): Same.\n\nFrom-SVN: r262494", "tree": {"sha": "9d2011edd9c0f88e911bf1ca42ef0a447245abf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d2011edd9c0f88e911bf1ca42ef0a447245abf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a669ac35988fa6de5931455fb59c713563bc58b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a669ac35988fa6de5931455fb59c713563bc58b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a669ac35988fa6de5931455fb59c713563bc58b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a669ac35988fa6de5931455fb59c713563bc58b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "962b3564e98b2634a2d001eceb946d8f15f9bfae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/962b3564e98b2634a2d001eceb946d8f15f9bfae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/962b3564e98b2634a2d001eceb946d8f15f9bfae"}], "stats": {"total": 500, "additions": 308, "deletions": 192}, "files": [{"sha": "986b54f61105818196608ff59523f702446a9250", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -1,3 +1,42 @@\n+2018-07-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.c (vrp_int_const_binop): Change overflow type to\n+\toverflow_type.\n+\t(combine_bound): Use wide-int overflow calculation instead of\n+\trolling our own.\n+\t* calls.c (maybe_warn_alloc_args_overflow): Change overflow type to\n+\toverflow_type.\n+\t* fold-const.c (int_const_binop_2): Same.\n+\t(extract_muldiv_1): Same.\n+\t(fold_div_compare): Same.\n+\t(fold_abs_const): Same.\n+\t* match.pd: Same.\n+\t* poly-int.h (add): Same.\n+\t(sub): Same.\n+\t(neg): Same.\n+\t(mul): Same.\n+\t* predict.c (predict_iv_comparison): Same.\n+\t* profile-count.c (slow_safe_scale_64bit): Same.\n+\t* simplify-rtx.c (simplify_const_binary_operation): Same.\n+\t* tree-chrec.c (tree_fold_binomial): Same.\n+\t* tree-data-ref.c (split_constant_offset_1): Same.\n+\t* tree-if-conv.c (idx_within_array_bound): Same.\n+\t* tree-scalar-evolution.c (iv_can_overflow_p): Same.\n+\t* tree-ssa-phiopt.c (minmax_replacement): Same.\n+\t* tree-vect-loop.c (is_nonwrapping_integer_induction): Same.\n+\t* tree-vect-stmts.c (vect_truncate_gather_scatter_offset): Same.\n+\t* vr-values.c (vr_values::adjust_range_with_scev): Same.\n+\t* wide-int.cc (wi::add_large): Same.\n+\t(wi::mul_internal): Same.\n+\t(wi::sub_large): Same.\n+\t(wi::divmod_internal): Same.\n+\t* wide-int.h: Change overflow type to overflow_type for neg, add,\n+\tmul, smul, umul, div_trunc, div_floor, div_ceil, div_round,\n+\tmod_trunc, mod_ceil, mod_round, add_large, sub_large,\n+\tmul_internal, divmod_internal.\n+\t(overflow_type): New enum.\n+\t(accumulate_overflow): New.\n+\n 2018-07-06  Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n \n \t* tree-ssa-phiopt.c (cond_removal_in_popcount_pattern): New."}, {"sha": "2a08822d310f4b7e448949b69ece562f42364a1b", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -1517,7 +1517,7 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n       wide_int x = wi::to_wide (argrange[0][0], szprec);\n       wide_int y = wi::to_wide (argrange[1][0], szprec);\n \n-      bool vflow;\n+      wi::overflow_type vflow;\n       wide_int prod = wi::umul (x, y, &vflow);\n \n       if (vflow)"}, {"sha": "9fb2b48f64ca0e299b5f29d4c8d888a9ec815768", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -1,3 +1,8 @@\n+2018-07-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* decl.c (build_enumerator): Change overflow type to overflow_type.\n+\t* init.c (build_new_1): Same.\n+\n 2018-07-05  Nathan Sidwell  <nathan@acm.org>\n \n \t* cp/decl.c (decls_match): Check SYSTEM_IMPLICIT_EXTERN_C not"}, {"sha": "c879e8f8f3f5d7fe6054baf363e6c10f82061e15", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -14628,7 +14628,6 @@ build_enumerator (tree name, tree value, tree enumtype, tree attributes,\n \t  if (TYPE_VALUES (enumtype))\n \t    {\n \t      tree prev_value;\n-\t      bool overflowed;\n \n \t      /* C++03 7.2/4: If no initializer is specified for the first\n \t\t enumerator, the type is an unspecified integral\n@@ -14642,6 +14641,7 @@ build_enumerator (tree name, tree value, tree enumtype, tree attributes,\n \t\tvalue = error_mark_node;\n \t      else\n \t\t{\n+\t\t  wi::overflow_type overflowed;\n \t\t  tree type = TREE_TYPE (prev_value);\n \t\t  signop sgn = TYPE_SIGN (type);\n \t\t  widest_int wi = wi::add (wi::to_widest (prev_value), 1, sgn,\n@@ -14668,7 +14668,7 @@ incremented enumerator value is too large for %<unsigned long%>\") : G_(\"\\\n incremented enumerator value is too large for %<long%>\"));\n \t\t\t}\n \t\t      if (type == NULL_TREE)\n-\t\t\toverflowed = true;\n+\t\t        overflowed = wi::OVF_UNKNOWN;\n \t\t      else\n \t\t\tvalue = wide_int_to_tree (type, wi);\n \t\t    }"}, {"sha": "94f8fdd7bd98891faa3bb9d0eb6eca8ea4825128", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -2943,7 +2943,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n       tree inner_nelts_cst = maybe_constant_value (inner_nelts);\n       if (TREE_CODE (inner_nelts_cst) == INTEGER_CST)\n \t{\n-\t  bool overflow;\n+\t  wi::overflow_type overflow;\n \t  offset_int result = wi::mul (wi::to_offset (inner_nelts_cst),\n \t\t\t\t       inner_nelts_count, SIGNED, &overflow);\n \t  if (overflow)\n@@ -3072,7 +3072,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t maximum object size and is safe even if we choose not to use\n \t a cookie after all.  */\n       max_size -= wi::to_offset (cookie_size);\n-      bool overflow;\n+      wi::overflow_type overflow;\n       inner_size = wi::mul (wi::to_offset (size), inner_nelts_count, SIGNED,\n \t\t\t    &overflow);\n       if (overflow || wi::gtu_p (inner_size, max_size))"}, {"sha": "5b94c700c81f1b3f19cf217a12af22d867523948", "filename": "gcc/fold-const.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -976,7 +976,7 @@ int_const_binop_2 (enum tree_code code, const_tree parg1, const_tree parg2,\n   tree t;\n   tree type = TREE_TYPE (parg1);\n   signop sign = TYPE_SIGN (type);\n-  bool overflow = false;\n+  wi::overflow_type overflow = wi::OVF_NONE;\n \n   wi::tree_to_wide_ref arg1 = wi::to_wide (parg1);\n   wide_int arg2 = wi::to_wide (parg2, TYPE_PRECISION (type));\n@@ -1133,7 +1133,7 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n   if (poly_int_tree_p (arg1) && poly_int_tree_p (arg2))\n     {\n       poly_wide_int res;\n-      bool overflow;\n+      wi::overflow_type overflow;\n       tree type = TREE_TYPE (arg1);\n       signop sign = TYPE_SIGN (type);\n       switch (code)\n@@ -6486,14 +6486,14 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n       if (tcode == code)\n \t{\n \t  bool overflow_p = false;\n-\t  bool overflow_mul_p;\n+\t  wi::overflow_type overflow_mul;\n \t  signop sign = TYPE_SIGN (ctype);\n \t  unsigned prec = TYPE_PRECISION (ctype);\n \t  wide_int mul = wi::mul (wi::to_wide (op1, prec),\n \t\t\t\t  wi::to_wide (c, prec),\n-\t\t\t\t  sign, &overflow_mul_p);\n+\t\t\t\t  sign, &overflow_mul);\n \t  overflow_p = TREE_OVERFLOW (c) | TREE_OVERFLOW (op1);\n-\t  if (overflow_mul_p\n+\t  if (overflow_mul\n \t      && ((sign == UNSIGNED && tcode != MULT_EXPR) || sign == SIGNED))\n \t    overflow_p = true;\n \t  if (!overflow_p)\n@@ -6705,7 +6705,7 @@ fold_div_compare (enum tree_code code, tree c1, tree c2, tree *lo,\n {\n   tree prod, tmp, type = TREE_TYPE (c1);\n   signop sign = TYPE_SIGN (type);\n-  bool overflow;\n+  wi::overflow_type overflow;\n \n   /* We have to do this the hard way to detect unsigned overflow.\n      prod = int_const_binop (MULT_EXPR, c1, c2);  */\n@@ -8396,7 +8396,7 @@ pointer_may_wrap_p (tree base, tree offset, poly_int64 bitpos)\n   else\n     wi_offset = wi::to_poly_wide (offset);\n \n-  bool overflow;\n+  wi::overflow_type overflow;\n   poly_wide_int units = wi::shwi (bits_to_bytes_round_down (bitpos),\n \t\t\t\t  precision);\n   poly_wide_int total = wi::add (wi_offset, units, UNSIGNED, &overflow);\n@@ -13820,7 +13820,7 @@ fold_negate_const (tree arg0, tree type)\n     default:\n       if (poly_int_tree_p (arg0))\n \t{\n-\t  bool overflow;\n+\t  wi::overflow_type overflow;\n \t  poly_wide_int res = wi::neg (wi::to_poly_wide (arg0), &overflow);\n \t  t = force_fit_type (type, res, 1,\n \t\t\t      (overflow && ! TYPE_UNSIGNED (type))\n@@ -13851,7 +13851,7 @@ fold_abs_const (tree arg0, tree type)\n         /* If the value is unsigned or non-negative, then the absolute value\n \t   is the same as the ordinary value.  */\n \twide_int val = wi::to_wide (arg0);\n-\tbool overflow = false;\n+\twi::overflow_type overflow = wi::OVF_NONE;\n \tif (!wi::neg_p (val, TYPE_SIGN (TREE_TYPE (arg0))))\n \t  ;\n "}, {"sha": "4d0a28dcddf365ad5c399c6a66de372ca159a577", "filename": "gcc/match.pd", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -307,11 +307,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (simplify\n   (div (div @0 INTEGER_CST@1) INTEGER_CST@2)\n   (with {\n-    bool overflow_p;\n+    wi::overflow_type overflow;\n     wide_int mul = wi::mul (wi::to_wide (@1), wi::to_wide (@2),\n-\t\t\t    TYPE_SIGN (type), &overflow_p);\n+\t\t\t    TYPE_SIGN (type), &overflow);\n    }\n-   (if (!overflow_p)\n+   (if (!overflow)\n     (div @0 { wide_int_to_tree (type, mul); })\n     (if (TYPE_UNSIGNED (type)\n \t || mul != wi::min_value (TYPE_PRECISION (type), SIGNED))\n@@ -322,13 +322,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (simplify\n  (mult (mult @0 INTEGER_CST@1) INTEGER_CST@2)\n  (with {\n-   bool overflow_p;\n+   wi::overflow_type overflow;\n    wide_int mul = wi::mul (wi::to_wide (@1), wi::to_wide (@2),\n-\t\t\t   TYPE_SIGN (type), &overflow_p);\n+\t\t\t   TYPE_SIGN (type), &overflow);\n   }\n   /* Skip folding on overflow: the only special case is @1 * @2 == -INT_MIN,\n      otherwise undefined overflow implies that @0 must be zero.  */\n-  (if (!overflow_p || TYPE_OVERFLOW_WRAPS (type))\n+  (if (!overflow || TYPE_OVERFLOW_WRAPS (type))\n    (mult @0 { wide_int_to_tree (type, mul); }))))\n \n /* Optimize A / A to 1.0 if we don't care about\n@@ -2861,7 +2861,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t     && (cmp == LT_EXPR || cmp == GE_EXPR)))\n      (with\n       {\n-\tbool overflow = false;\n+\twi::overflow_type overflow = wi::OVF_NONE;\n \tenum tree_code code, cmp_code = cmp;\n \twide_int real_c1;\n \twide_int c1 = wi::to_wide (@1);\n@@ -3421,7 +3421,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     (if (TREE_CODE (@1) == INTEGER_CST)\n      (with\n       {\n-\tbool ovf;\n+\twi::overflow_type ovf;\n \twide_int prod = wi::mul (wi::to_wide (@2), wi::to_wide (@1),\n \t\t\t\t TYPE_SIGN (TREE_TYPE (@1)), &ovf);\n       }\n@@ -3434,7 +3434,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (if (wi::gt_p (wi::to_wide (@1), 0, TYPE_SIGN (TREE_TYPE (@1))))\n    (with\n     {\n-      bool ovf;\n+      wi::overflow_type ovf;\n       wide_int prod = wi::mul (wi::to_wide (@2), wi::to_wide (@1),\n \t\t\t       TYPE_SIGN (TREE_TYPE (@1)), &ovf);\n     }"}, {"sha": "c2cd2c2a5c769cbde5a2fa31b3f4f57b022ef2be", "filename": "gcc/poly-int.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -917,17 +917,17 @@ add (const Ca &a, const poly_int_pod<N, Cb> &b)\n template<unsigned int N, typename Ca, typename Cb>\n inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n add (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b,\n-     signop sgn, bool *overflow)\n+     signop sgn, wi::overflow_type *overflow)\n {\n   typedef WI_BINARY_RESULT (Ca, Cb) C;\n   poly_int<N, C> r;\n   POLY_SET_COEFF (C, r, 0, wi::add (a.coeffs[0], b.coeffs[0], sgn, overflow));\n   for (unsigned int i = 1; i < N; i++)\n     {\n-      bool suboverflow;\n+      wi::overflow_type suboverflow;\n       POLY_SET_COEFF (C, r, i, wi::add (a.coeffs[i], b.coeffs[i], sgn,\n \t\t\t\t\t&suboverflow));\n-      *overflow |= suboverflow;\n+      wi::accumulate_overflow (*overflow, suboverflow);\n     }\n   return r;\n }\n@@ -1016,17 +1016,17 @@ sub (const Ca &a, const poly_int_pod<N, Cb> &b)\n template<unsigned int N, typename Ca, typename Cb>\n inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n sub (const poly_int_pod<N, Ca> &a, const poly_int_pod<N, Cb> &b,\n-     signop sgn, bool *overflow)\n+     signop sgn, wi::overflow_type *overflow)\n {\n   typedef WI_BINARY_RESULT (Ca, Cb) C;\n   poly_int<N, C> r;\n   POLY_SET_COEFF (C, r, 0, wi::sub (a.coeffs[0], b.coeffs[0], sgn, overflow));\n   for (unsigned int i = 1; i < N; i++)\n     {\n-      bool suboverflow;\n+      wi::overflow_type suboverflow;\n       POLY_SET_COEFF (C, r, i, wi::sub (a.coeffs[i], b.coeffs[i], sgn,\n \t\t\t\t\t&suboverflow));\n-      *overflow |= suboverflow;\n+      wi::accumulate_overflow (*overflow, suboverflow);\n     }\n   return r;\n }\n@@ -1060,16 +1060,16 @@ neg (const poly_int_pod<N, Ca> &a)\n \n template<unsigned int N, typename Ca>\n inline poly_int<N, WI_UNARY_RESULT (Ca)>\n-neg (const poly_int_pod<N, Ca> &a, bool *overflow)\n+neg (const poly_int_pod<N, Ca> &a, wi::overflow_type *overflow)\n {\n   typedef WI_UNARY_RESULT (Ca) C;\n   poly_int<N, C> r;\n   POLY_SET_COEFF (C, r, 0, wi::neg (a.coeffs[0], overflow));\n   for (unsigned int i = 1; i < N; i++)\n     {\n-      bool suboverflow;\n+      wi::overflow_type suboverflow;\n       POLY_SET_COEFF (C, r, i, wi::neg (a.coeffs[i], &suboverflow));\n-      *overflow |= suboverflow;\n+      wi::accumulate_overflow (*overflow, suboverflow);\n     }\n   return r;\n }\n@@ -1136,16 +1136,16 @@ mul (const Ca &a, const poly_int_pod<N, Cb> &b)\n template<unsigned int N, typename Ca, typename Cb>\n inline poly_int<N, WI_BINARY_RESULT (Ca, Cb)>\n mul (const poly_int_pod<N, Ca> &a, const Cb &b,\n-     signop sgn, bool *overflow)\n+     signop sgn, wi::overflow_type *overflow)\n {\n   typedef WI_BINARY_RESULT (Ca, Cb) C;\n   poly_int<N, C> r;\n   POLY_SET_COEFF (C, r, 0, wi::mul (a.coeffs[0], b, sgn, overflow));\n   for (unsigned int i = 1; i < N; i++)\n     {\n-      bool suboverflow;\n+      wi::overflow_type suboverflow;\n       POLY_SET_COEFF (C, r, i, wi::mul (a.coeffs[i], b, sgn, &suboverflow));\n-      *overflow |= suboverflow;\n+      wi::accumulate_overflow (*overflow, suboverflow);\n     }\n   return r;\n }"}, {"sha": "65e088fb8df6d8aca9df89cb11aa20ab3d935d37", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -1629,7 +1629,8 @@ predict_iv_comparison (struct loop *loop, basic_block bb,\n       && tree_fits_shwi_p (compare_base))\n     {\n       int probability;\n-      bool overflow, overall_overflow = false;\n+      wi::overflow_type overflow;\n+      bool overall_overflow = false;\n       widest_int compare_count, tem;\n \n       /* (loop_bound - base) / compare_step */"}, {"sha": "213462ca406931c3cfcfaf5b28f9a283db5d7e48", "filename": "gcc/profile-count.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -210,7 +210,7 @@ bool\n slow_safe_scale_64bit (uint64_t a, uint64_t b, uint64_t c, uint64_t *res)\n {\n   FIXED_WIDE_INT (128) tmp = a;\n-  bool overflow;\n+  wi::overflow_type overflow;\n   tmp = wi::udiv_floor (wi::umul (tmp, b, &overflow) + (c / 2), c);\n   gcc_checking_assert (!overflow);\n   if (wi::fits_uhwi_p (tmp))"}, {"sha": "a9f2586d895ae79120503b1e9c3744167adcd735", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -4226,7 +4226,7 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n       && CONST_SCALAR_INT_P (op1))\n     {\n       wide_int result;\n-      bool overflow;\n+      wi::overflow_type overflow;\n       rtx_mode_t pop0 = rtx_mode_t (op0, int_mode);\n       rtx_mode_t pop1 = rtx_mode_t (op1, int_mode);\n "}, {"sha": "0b89acd91cd93bb2d7ea7ce28e99f9938b8058d3", "filename": "gcc/testsuite/gcc.dg/plugin/poly-int-tests.h", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fpoly-int-tests.h?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -4087,7 +4087,7 @@ test_wide_int_add ()\n   typedef poly_int<N, wide_int> T;\n   typedef poly_helper<T> ph;\n \n-  bool overflow;\n+  wi::overflow_type overflow;\n   ASSERT_KNOWN_EQ (wi::add (ph::make (wi::uhwi (15, 4),\n \t\t\t\t      wi::uhwi (4, 4),\n \t\t\t\t      wi::uhwi (2, 4)),\n@@ -4098,7 +4098,7 @@ test_wide_int_add ()\n \t\t   ph::make (wi::uhwi (0, 4),\n \t\t\t     wi::uhwi (4, 4),\n \t\t\t     wi::uhwi (2, 4)));\n-  ASSERT_TRUE (overflow);\n+  ASSERT_TRUE ((bool)overflow);\n   ASSERT_KNOWN_EQ (wi::add (ph::make (wi::uhwi (30, 5),\n \t\t\t\t      wi::uhwi (6, 5),\n \t\t\t\t      wi::uhwi (11, 5)),\n@@ -4109,7 +4109,7 @@ test_wide_int_add ()\n \t\t   ph::make (wi::uhwi (31, 5),\n \t\t\t     wi::uhwi (0, 5),\n \t\t\t     wi::uhwi (30, 5)));\n-  ASSERT_EQ (overflow, N >= 2);\n+  ASSERT_EQ ((bool)overflow, N >= 2);\n   ASSERT_KNOWN_EQ (wi::add (ph::make (wi::uhwi (1, 6),\n \t\t\t\t      wi::uhwi (63, 6),\n \t\t\t\t      wi::uhwi (50, 6)),\n@@ -4120,7 +4120,7 @@ test_wide_int_add ()\n \t\t   ph::make (wi::uhwi (62, 6),\n \t\t\t     wi::uhwi (63, 6),\n \t\t\t     wi::uhwi (36, 6)));\n-  ASSERT_EQ (overflow, N == 3);\n+  ASSERT_EQ ((bool)overflow, N == 3);\n \n   ASSERT_KNOWN_EQ (wi::add (ph::make (wi::shwi (7, 4),\n \t\t\t\t      wi::shwi (7, 4),\n@@ -4132,7 +4132,7 @@ test_wide_int_add ()\n \t\t   ph::make (wi::shwi (-8, 4),\n \t\t\t     wi::shwi (7, 4),\n \t\t\t     wi::shwi (-8, 4)));\n-  ASSERT_TRUE (overflow);\n+  ASSERT_TRUE ((bool)overflow);\n   ASSERT_KNOWN_EQ (wi::add (ph::make (wi::shwi (-1, 5),\n \t\t\t\t      wi::shwi (6, 5),\n \t\t\t\t      wi::shwi (11, 5)),\n@@ -4143,7 +4143,7 @@ test_wide_int_add ()\n \t\t   ph::make (wi::shwi (14, 5),\n \t\t\t     wi::shwi (-15, 5),\n \t\t\t     wi::shwi (-4, 5)));\n-  ASSERT_EQ (overflow, N >= 2);\n+  ASSERT_EQ ((bool)overflow, N >= 2);\n   ASSERT_KNOWN_EQ (wi::add (ph::make (wi::shwi (4, 6),\n \t\t\t\t      wi::shwi (0, 6),\n \t\t\t\t      wi::shwi (-1, 6)),\n@@ -4154,7 +4154,7 @@ test_wide_int_add ()\n \t\t   ph::make (wi::shwi (-28, 6),\n \t\t\t     wi::shwi (-32, 6),\n \t\t\t     wi::shwi (31, 6)));\n-  ASSERT_EQ (overflow, N == 3);\n+  ASSERT_EQ ((bool)overflow, N == 3);\n }\n \n /* Test wi::sub for poly_int<N, wide_int>.  */\n@@ -4166,7 +4166,7 @@ test_wide_int_sub ()\n   typedef poly_int<N, wide_int> T;\n   typedef poly_helper<T> ph;\n \n-  bool overflow;\n+  wi::overflow_type overflow;\n   ASSERT_KNOWN_EQ (wi::sub (ph::make (wi::uhwi (0, 4),\n \t\t\t\t      wi::uhwi (4, 4),\n \t\t\t\t      wi::uhwi (2, 4)),\n@@ -4177,7 +4177,7 @@ test_wide_int_sub ()\n \t\t   ph::make (wi::uhwi (15, 4),\n \t\t\t     wi::uhwi (4, 4),\n \t\t\t     wi::uhwi (2, 4)));\n-  ASSERT_TRUE (overflow);\n+  ASSERT_TRUE ((bool)overflow);\n   ASSERT_KNOWN_EQ (wi::sub (ph::make (wi::uhwi (30, 5),\n \t\t\t\t      wi::uhwi (29, 5),\n \t\t\t\t      wi::uhwi (11, 5)),\n@@ -4188,7 +4188,7 @@ test_wide_int_sub ()\n \t\t   ph::make (wi::uhwi (29, 5),\n \t\t\t     wi::uhwi (30, 5),\n \t\t\t     wi::uhwi (2, 5)));\n-  ASSERT_EQ (overflow, N >= 2);\n+  ASSERT_EQ ((bool)overflow, N >= 2);\n   ASSERT_KNOWN_EQ (wi::sub (ph::make (wi::uhwi (0, 6),\n \t\t\t\t      wi::uhwi (63, 6),\n \t\t\t\t      wi::uhwi (0, 6)),\n@@ -4199,7 +4199,7 @@ test_wide_int_sub ()\n \t\t   ph::make (wi::uhwi (0, 6),\n \t\t\t     wi::uhwi (63, 6),\n \t\t\t     wi::uhwi (12, 6)));\n-  ASSERT_EQ (overflow, N == 3);\n+  ASSERT_EQ ((bool)overflow, N == 3);\n \n   ASSERT_KNOWN_EQ (wi::sub (ph::make (wi::shwi (-8, 4),\n \t\t\t\t      wi::shwi (5, 4),\n@@ -4211,7 +4211,7 @@ test_wide_int_sub ()\n \t\t   ph::make (wi::shwi (7, 4),\n \t\t\t     wi::shwi (5, 4),\n \t\t\t     wi::shwi (-7, 4)));\n-  ASSERT_TRUE (overflow);\n+  ASSERT_TRUE ((bool)overflow);\n   ASSERT_KNOWN_EQ (wi::sub (ph::make (wi::shwi (-1, 5),\n \t\t\t\t      wi::shwi (-7, 5),\n \t\t\t\t      wi::shwi (0, 5)),\n@@ -4222,7 +4222,7 @@ test_wide_int_sub ()\n \t\t   ph::make (wi::shwi (-16, 5),\n \t\t\t     wi::shwi (14, 5),\n \t\t\t     wi::shwi (15, 5)));\n-  ASSERT_EQ (overflow, N >= 2);\n+  ASSERT_EQ ((bool)overflow, N >= 2);\n   ASSERT_KNOWN_EQ (wi::sub (ph::make (wi::shwi (-32, 6),\n \t\t\t\t      wi::shwi (-1, 6),\n \t\t\t\t      wi::shwi (0, 6)),\n@@ -4233,7 +4233,7 @@ test_wide_int_sub ()\n \t\t   ph::make (wi::shwi (0, 6),\n \t\t\t     wi::shwi (31, 6),\n \t\t\t     wi::shwi (-32, 6)));\n-  ASSERT_EQ (overflow, N == 3);\n+  ASSERT_EQ ((bool)overflow, N == 3);\n }\n \n /* Test wi::mul for poly_int<N, wide_int>.  */\n@@ -4245,31 +4245,31 @@ test_wide_int_mul ()\n   typedef poly_int<N, wide_int> T;\n   typedef poly_helper<T> ph;\n \n-  bool overflow;\n+  wi::overflow_type overflow;\n   ASSERT_KNOWN_EQ (wi::mul (ph::make (wi::uhwi (4, 4),\n \t\t\t\t      wi::uhwi (3, 4),\n \t\t\t\t      wi::uhwi (2, 4)), 4,\n \t\t\t    UNSIGNED, &overflow),\n \t\t   ph::make (wi::uhwi (0, 4),\n \t\t\t     wi::uhwi (12, 4),\n \t\t\t     wi::uhwi (8, 4)));\n-  ASSERT_TRUE (overflow);\n+  ASSERT_TRUE ((bool)overflow);\n   ASSERT_KNOWN_EQ (wi::mul (ph::make (wi::uhwi (15, 5),\n \t\t\t\t      wi::uhwi (31, 5),\n \t\t\t\t      wi::uhwi (7, 5)), 2,\n \t\t\t    UNSIGNED, &overflow),\n \t\t   ph::make (wi::uhwi (30, 5),\n \t\t\t     wi::uhwi (30, 5),\n \t\t\t     wi::uhwi (14, 5)));\n-  ASSERT_EQ (overflow, N >= 2);\n+  ASSERT_EQ ((bool)overflow, N >= 2);\n   ASSERT_KNOWN_EQ (wi::mul (ph::make (wi::uhwi (1, 6),\n \t\t\t\t      wi::uhwi (0, 6),\n \t\t\t\t      wi::uhwi (2, 6)), 63,\n \t\t\t    UNSIGNED, &overflow),\n \t\t   ph::make (wi::uhwi (63, 6),\n \t\t\t     wi::uhwi (0, 6),\n \t\t\t     wi::uhwi (62, 6)));\n-  ASSERT_EQ (overflow, N == 3);\n+  ASSERT_EQ ((bool)overflow, N == 3);\n \n   ASSERT_KNOWN_EQ (wi::mul (ph::make (wi::shwi (-1, 4),\n \t\t\t\t      wi::shwi (1, 4),\n@@ -4278,23 +4278,23 @@ test_wide_int_mul ()\n \t\t   ph::make (wi::shwi (-8, 4),\n \t\t\t     wi::shwi (-8, 4),\n \t\t\t     wi::shwi (0, 4)));\n-  ASSERT_TRUE (overflow);\n+  ASSERT_TRUE ((bool)overflow);\n   ASSERT_KNOWN_EQ (wi::mul (ph::make (wi::shwi (2, 5),\n \t\t\t\t      wi::shwi (-3, 5),\n \t\t\t\t      wi::shwi (1, 5)), 6,\n \t\t\t    SIGNED, &overflow),\n \t\t   ph::make (wi::shwi (12, 5),\n \t\t\t     wi::shwi (14, 5),\n \t\t\t     wi::shwi (6, 5)));\n-  ASSERT_EQ (overflow, N >= 2);\n+  ASSERT_EQ ((bool)overflow, N >= 2);\n   ASSERT_KNOWN_EQ (wi::mul (ph::make (wi::shwi (5, 6),\n \t\t\t\t      wi::shwi (-6, 6),\n \t\t\t\t      wi::shwi (7, 6)), -5,\n \t\t\t    SIGNED, &overflow),\n \t\t   ph::make (wi::shwi (-25, 6),\n \t\t\t     wi::shwi (30, 6),\n \t\t\t     wi::shwi (29, 6)));\n-  ASSERT_EQ (overflow, N == 3);\n+  ASSERT_EQ ((bool)overflow, N == 3);\n }\n \n /* Test wi::neg for poly_int<N, wide_int>.  */\n@@ -4306,28 +4306,28 @@ test_wide_int_neg ()\n   typedef poly_int<N, wide_int> T;\n   typedef poly_helper<T> ph;\n \n-  bool overflow;\n+  wi::overflow_type overflow;\n   ASSERT_KNOWN_EQ (wi::neg (ph::make (wi::shwi (-8, 4),\n \t\t\t\t      wi::shwi (7, 4),\n \t\t\t\t      wi::shwi (-7, 4)), &overflow),\n \t\t   ph::make (wi::shwi (-8, 4),\n \t\t\t     wi::shwi (-7, 4),\n \t\t\t     wi::shwi (7, 4)));\n-  ASSERT_TRUE (overflow);\n+  ASSERT_TRUE ((bool)overflow);\n   ASSERT_KNOWN_EQ (wi::neg (ph::make (wi::shwi (-15, 5),\n \t\t\t\t      wi::shwi (-16, 5),\n \t\t\t\t      wi::shwi (15, 5)), &overflow),\n \t\t   ph::make (wi::shwi (15, 5),\n \t\t\t     wi::shwi (-16, 5),\n \t\t\t     wi::shwi (-15, 5)));\n-  ASSERT_EQ (overflow, N >= 2);\n+  ASSERT_EQ ((bool)overflow, N >= 2);\n   ASSERT_KNOWN_EQ (wi::neg (ph::make (wi::shwi (-28, 6),\n \t\t\t\t      wi::shwi (30, 6),\n \t\t\t\t      wi::shwi (-32, 6)), &overflow),\n \t\t   ph::make (wi::shwi (28, 6),\n \t\t\t     wi::shwi (-30, 6),\n \t\t\t     wi::shwi (-32, 6)));\n-  ASSERT_EQ (overflow, N == 3);\n+  ASSERT_EQ ((bool)overflow, N == 3);\n }\n \n /* Test poly_int<N, C> for things that only make sense when C is an"}, {"sha": "fa8c2ee2a20b4b4c37d58cb29ee3f4ac2da63e65", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -524,7 +524,7 @@ chrec_fold_multiply (tree type,\n static tree\n tree_fold_binomial (tree type, tree n, unsigned int k)\n {\n-  bool overflow;\n+  wi::overflow_type overflow;\n   unsigned int i;\n \n   /* Handle the most frequent cases.  */"}, {"sha": "a8c6872a2350f86f57079cba2e2e58b92b386ac8", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -734,12 +734,12 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\t   is known to be [A + TMP_OFF, B + TMP_OFF], with all\n \t\t   operations done in ITYPE.  The addition must overflow\n \t\t   at both ends of the range or at neither.  */\n-\t\tbool overflow[2];\n+\t\twi::overflow_type overflow[2];\n \t\tunsigned int prec = TYPE_PRECISION (itype);\n \t\twide_int woff = wi::to_wide (tmp_off, prec);\n \t\twide_int op0_min = wi::add (var_min, woff, sgn, &overflow[0]);\n \t\twi::add (var_max, woff, sgn, &overflow[1]);\n-\t\tif (overflow[0] != overflow[1])\n+\t\tif ((overflow[0] != wi::OVF_NONE) != (overflow[1] != wi::OVF_NONE))\n \t\t  return false;\n \n \t\t/* Calculate (ssizetype) OP0 - (ssizetype) TMP_VAR.  */"}, {"sha": "e9eaa11786a80aa2accac9c9eef3fda1b2b7a39b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -743,7 +743,7 @@ hash_memrefs_baserefs_and_store_DRs_read_written_info (data_reference_p a)\n static bool\n idx_within_array_bound (tree ref, tree *idx, void *dta)\n {\n-  bool overflow;\n+  wi::overflow_type overflow;\n   widest_int niter, valid_niter, delta, wi_step;\n   tree ev, init, step;\n   tree low, high;"}, {"sha": "69122f2652f400e8fabdb969e71d8ad651a0a6f3", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -3185,7 +3185,7 @@ iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n \t\t       && wi::le_p (base_max, type_max, sgn));\n \n   /* Account the possible increment in the last ieration.  */\n-  bool overflow = false;\n+  wi::overflow_type overflow = wi::OVF_NONE;\n   nit = wi::add (nit, 1, SIGNED, &overflow);\n   if (overflow)\n     return true;\n@@ -3202,7 +3202,7 @@ iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n      the type.  */\n   if (sgn == UNSIGNED || !wi::neg_p (step_max))\n     {\n-      bool overflow = false;\n+      wi::overflow_type overflow = wi::OVF_NONE;\n       if (wi::gtu_p (wi::mul (step_max, nit2, UNSIGNED, &overflow),\n \t\t     type_max - base_max)\n \t  || overflow)\n@@ -3211,7 +3211,8 @@ iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n   /* If step can be negative, check that nit*(-step) <= base_min-type_min.  */\n   if (sgn == SIGNED && wi::neg_p (step_min))\n     {\n-      bool overflow = false, overflow2 = false;\n+      wi::overflow_type overflow, overflow2;\n+      overflow = overflow2 = wi::OVF_NONE;\n       if (wi::gtu_p (wi::mul (wi::neg (step_min, &overflow2),\n \t\t     nit2, UNSIGNED, &overflow),\n \t\t     base_min - type_min)\n@@ -3315,7 +3316,7 @@ simple_iv_with_niters (struct loop *wrto_loop, struct loop *use_loop,\n   enum tree_code code;\n   tree type, ev, base, e;\n   wide_int extreme;\n-  bool folded_casts, overflow;\n+  bool folded_casts;\n \n   iv->base = NULL_TREE;\n   iv->step = NULL_TREE;\n@@ -3424,7 +3425,7 @@ simple_iv_with_niters (struct loop *wrto_loop, struct loop *use_loop,\n       code = GT_EXPR;\n       extreme = wi::max_value (type);\n     }\n-  overflow = false;\n+  wi::overflow_type overflow = wi::OVF_NONE;\n   extreme = wi::sub (extreme, wi::to_wide (iv->step),\n \t\t     TYPE_SIGN (type), &overflow);\n   if (overflow)"}, {"sha": "656f8401c586b2e6f8d3ebbe4106ae2e3b937f45", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -1230,7 +1230,7 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t{\n \t  if (cmp == LT_EXPR)\n \t    {\n-\t      bool overflow;\n+\t      wi::overflow_type overflow;\n \t      wide_int alt = wi::sub (wi::to_wide (larger), 1,\n \t\t\t\t      TYPE_SIGN (TREE_TYPE (larger)),\n \t\t\t\t      &overflow);\n@@ -1239,7 +1239,7 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t    }\n \t  else\n \t    {\n-\t      bool overflow;\n+\t      wi::overflow_type overflow;\n \t      wide_int alt = wi::add (wi::to_wide (larger), 1,\n \t\t\t\t      TYPE_SIGN (TREE_TYPE (larger)),\n \t\t\t\t      &overflow);\n@@ -1256,9 +1256,9 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t Likewise larger >= CST is equivalent to larger > CST-1.  */\n       if (TREE_CODE (smaller) == INTEGER_CST)\n \t{\n+\t  wi::overflow_type overflow;\n \t  if (cmp == GT_EXPR)\n \t    {\n-\t      bool overflow;\n \t      wide_int alt = wi::add (wi::to_wide (smaller), 1,\n \t\t\t\t      TYPE_SIGN (TREE_TYPE (smaller)),\n \t\t\t\t      &overflow);\n@@ -1267,7 +1267,6 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t    }\n \t  else\n \t    {\n-\t      bool overflow;\n \t      wide_int alt = wi::sub (wi::to_wide (smaller), 1,\n \t\t\t\t      TYPE_SIGN (TREE_TYPE (smaller)),\n \t\t\t\t      &overflow);"}, {"sha": "9b7147cddf5ee00aea48fc065775981bf5861156", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -6051,7 +6051,7 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n   tree step = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo);\n   tree lhs_type = TREE_TYPE (gimple_phi_result (stmt));\n   widest_int ni, max_loop_value, lhs_max;\n-  bool overflow = false;\n+  wi::overflow_type overflow = wi::OVF_NONE;\n \n   /* Make sure the loop is integer based.  */\n   if (TREE_CODE (base) != INTEGER_CST"}, {"sha": "73b81e1c2dd1b68cc9469d8d55f64dba5d030837", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -2029,7 +2029,7 @@ vect_truncate_gather_scatter_offset (gimple *stmt, loop_vec_info loop_vinfo,\n \n   /* Try scales of 1 and the element size.  */\n   int scales[] = { 1, vect_get_scalar_dr_size (dr) };\n-  bool overflow_p = false;\n+  wi::overflow_type overflow = wi::OVF_NONE;\n   for (int i = 0; i < 2; ++i)\n     {\n       int scale = scales[i];\n@@ -2039,13 +2039,13 @@ vect_truncate_gather_scatter_offset (gimple *stmt, loop_vec_info loop_vinfo,\n \n       /* See whether we can calculate (COUNT - 1) * STEP / SCALE\n \t in OFFSET_BITS bits.  */\n-      widest_int range = wi::mul (count, factor, SIGNED, &overflow_p);\n-      if (overflow_p)\n+      widest_int range = wi::mul (count, factor, SIGNED, &overflow);\n+      if (overflow)\n \tcontinue;\n       signop sign = range >= 0 ? UNSIGNED : SIGNED;\n       if (wi::min_precision (range, sign) > element_bits)\n \t{\n-\t  overflow_p = true;\n+\t  overflow = wi::OVF_UNKNOWN;\n \t  continue;\n \t}\n \n@@ -2071,7 +2071,7 @@ vect_truncate_gather_scatter_offset (gimple *stmt, loop_vec_info loop_vinfo,\n       return true;\n     }\n \n-  if (overflow_p && dump_enabled_p ())\n+  if (overflow && dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"truncating gather/scatter offset to %d bits\"\n \t\t     \" might change its value.\\n\", element_bits);"}, {"sha": "a7453abba7ffcd692f9dfea9f87282c4d3a7fb6e", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 18, "deletions": 42, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -968,7 +968,7 @@ value_range_constant_singleton (value_range *vr)\n static bool\n vrp_int_const_binop (enum tree_code code, tree val1, tree val2, wide_int *res)\n {\n-  bool overflow = false;\n+  wi::overflow_type overflow = wi::OVF_NONE;\n   signop sign = TYPE_SIGN (TREE_TYPE (val1));\n \n   switch (code)\n@@ -1326,7 +1326,7 @@ adjust_symbolic_bound (tree &bound, enum tree_code code, tree type,\n    if over/underflow occurred.  */\n \n static void\n-combine_bound (enum tree_code code, wide_int &wi, int &ovf,\n+combine_bound (enum tree_code code, wide_int &wi, wi::overflow_type &ovf,\n \t       tree type, tree op0, tree op1)\n {\n   bool minus_p = (code == MINUS_EXPR);\n@@ -1337,41 +1337,16 @@ combine_bound (enum tree_code code, wide_int &wi, int &ovf,\n   if (op0 && op1)\n     {\n       if (minus_p)\n-\t{\n-\t  wi = wi::to_wide (op0) - wi::to_wide (op1);\n-\n-\t  /* Check for overflow.  */\n-\t  if (wi::cmp (0, wi::to_wide (op1), sgn)\n-\t      != wi::cmp (wi, wi::to_wide (op0), sgn))\n-\t    ovf = wi::cmp (wi::to_wide (op0),\n-\t\t\t   wi::to_wide (op1), sgn);\n-\t}\n+\twi = wi::sub (wi::to_wide (op0), wi::to_wide (op1), sgn, &ovf);\n       else\n-\t{\n-\t  wi = wi::to_wide (op0) + wi::to_wide (op1);\n-\n-\t  /* Check for overflow.  */\n-\t  if (wi::cmp (wi::to_wide (op1), 0, sgn)\n-\t      != wi::cmp (wi, wi::to_wide (op0), sgn))\n-\t    ovf = wi::cmp (wi::to_wide (op0), wi, sgn);\n-\t}\n+\twi = wi::add (wi::to_wide (op0), wi::to_wide (op1), sgn, &ovf);\n     }\n   else if (op0)\n     wi = wi::to_wide (op0);\n   else if (op1)\n     {\n       if (minus_p)\n-\t{\n-\t  wi = -wi::to_wide (op1);\n-\n-\t  /* Check for overflow.  */\n-\t  if (sgn == SIGNED\n-\t      && wi::neg_p (wi::to_wide (op1))\n-\t      && wi::neg_p (wi))\n-\t    ovf = 1;\n-\t  else if (sgn == UNSIGNED && wi::to_wide (op1) != 0)\n-\t    ovf = -1;\n-\t}\n+\twi = wi::neg (wi::to_wide (op1), &ovf);\n       else\n \twi = wi::to_wide (op1);\n     }\n@@ -1392,7 +1367,8 @@ static void\n set_value_range_with_overflow (value_range &vr,\n \t\t\t       tree type,\n \t\t\t       const wide_int &wmin, const wide_int &wmax,\n-\t\t\t       int min_ovf, int max_ovf)\n+\t\t\t       wi::overflow_type min_ovf,\n+\t\t\t       wi::overflow_type max_ovf)\n {\n   const signop sgn = TYPE_SIGN (type);\n   const unsigned int prec = TYPE_PRECISION (type);\n@@ -1404,15 +1380,15 @@ set_value_range_with_overflow (value_range &vr,\n \t range kind and bounds appropriately.  */\n       wide_int tmin = wide_int::from (wmin, prec, sgn);\n       wide_int tmax = wide_int::from (wmax, prec, sgn);\n-      if (min_ovf == max_ovf)\n+      if ((min_ovf != wi::OVF_NONE) == (max_ovf != wi::OVF_NONE))\n \t{\n \t  /* No overflow or both overflow or underflow.  The\n \t     range kind stays VR_RANGE.  */\n \t  vr.min = wide_int_to_tree (type, tmin);\n \t  vr.max = wide_int_to_tree (type, tmax);\n \t}\n-      else if ((min_ovf == -1 && max_ovf == 0)\n-\t       || (max_ovf == 1 && min_ovf == 0))\n+      else if ((min_ovf == wi::OVF_UNDERFLOW && max_ovf == wi::OVF_NONE)\n+\t       || (max_ovf == wi::OVF_OVERFLOW && min_ovf == wi::OVF_NONE))\n \t{\n \t  /* Min underflow or max overflow.  The range kind\n \t     changes to VR_ANTI_RANGE.  */\n@@ -1449,16 +1425,16 @@ set_value_range_with_overflow (value_range &vr,\n \t value.  */\n       wide_int type_min = wi::min_value (prec, sgn);\n       wide_int type_max = wi::max_value (prec, sgn);\n-      if (min_ovf == -1)\n+      if (min_ovf == wi::OVF_UNDERFLOW)\n \tvr.min = wide_int_to_tree (type, type_min);\n-      else if (min_ovf == 1)\n+      else if (min_ovf == wi::OVF_OVERFLOW)\n \tvr.min = wide_int_to_tree (type, type_max);\n       else\n \tvr.min = wide_int_to_tree (type, wmin);\n \n-      if (max_ovf == -1)\n+      if (max_ovf == wi::OVF_UNDERFLOW)\n \tvr.max = wide_int_to_tree (type, type_min);\n-      else if (max_ovf == 1)\n+      else if (max_ovf == wi::OVF_OVERFLOW)\n \tvr.max = wide_int_to_tree (type, type_max);\n       else\n \tvr.max = wide_int_to_tree (type, wmax);\n@@ -1688,17 +1664,17 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t  && neg_max_op0 == (minus_p ? neg_max_op1 : !neg_max_op1))))\n \t{\n \t  wide_int wmin, wmax;\n-\t  int min_ovf = 0;\n-\t  int max_ovf = 0;\n+\t  wi::overflow_type min_ovf = wi::OVF_NONE;\n+\t  wi::overflow_type max_ovf = wi::OVF_NONE;\n \n \t  /* Build the bounds.  */\n \t  combine_bound (code, wmin, min_ovf, expr_type, min_op0, min_op1);\n \t  combine_bound (code, wmax, max_ovf, expr_type, max_op0, max_op1);\n \n \t  /* If we have overflow for the constant part and the resulting\n \t     range will be symbolic, drop to VR_VARYING.  */\n-\t  if ((min_ovf && sym_min_op0 != sym_min_op1)\n-\t      || (max_ovf && sym_max_op0 != sym_max_op1))\n+\t  if (((bool)min_ovf && sym_min_op0 != sym_min_op1)\n+\t      || ((bool)max_ovf && sym_max_op0 != sym_max_op1))\n \t    {\n \t      set_value_range_to_varying (vr);\n \t      return;"}, {"sha": "32f64e047af5eae1febe66d4a5f1fff206c3f57f", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -1810,7 +1810,7 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t{\n \t  value_range maxvr = VR_INITIALIZER;\n \t  signop sgn = TYPE_SIGN (TREE_TYPE (step));\n-\t  bool overflow;\n+\t  wi::overflow_type overflow;\n \n \t  widest_int wtmp = wi::mul (wi::to_widest (step), nit, sgn,\n \t\t\t\t     &overflow);"}, {"sha": "d9e353c3eac07c086bd8e07ed4303b0f6fd9a11f", "filename": "gcc/wide-int.cc", "status": "modified", "additions": 53, "deletions": 26, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fwide-int.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fwide-int.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.cc?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -1128,7 +1128,7 @@ unsigned int\n wi::add_large (HOST_WIDE_INT *val, const HOST_WIDE_INT *op0,\n \t       unsigned int op0len, const HOST_WIDE_INT *op1,\n \t       unsigned int op1len, unsigned int prec,\n-\t       signop sgn, bool *overflow)\n+\t       signop sgn, wi::overflow_type *overflow)\n {\n   unsigned HOST_WIDE_INT o0 = 0;\n   unsigned HOST_WIDE_INT o1 = 0;\n@@ -1158,25 +1158,36 @@ wi::add_large (HOST_WIDE_INT *val, const HOST_WIDE_INT *op0,\n       val[len] = mask0 + mask1 + carry;\n       len++;\n       if (overflow)\n-\t*overflow = (sgn == UNSIGNED && carry);\n+\t*overflow\n+\t  = (sgn == UNSIGNED && carry) ? wi::OVF_OVERFLOW : wi::OVF_NONE;\n     }\n   else if (overflow)\n     {\n       unsigned int shift = -prec % HOST_BITS_PER_WIDE_INT;\n       if (sgn == SIGNED)\n \t{\n \t  unsigned HOST_WIDE_INT x = (val[len - 1] ^ o0) & (val[len - 1] ^ o1);\n-\t  *overflow = (HOST_WIDE_INT) (x << shift) < 0;\n+\t  if ((HOST_WIDE_INT) (x << shift) < 0)\n+\t    {\n+\t      if (o0 > (unsigned HOST_WIDE_INT) val[len - 1])\n+\t\t*overflow = wi::OVF_UNDERFLOW;\n+\t      else if (o0 < (unsigned HOST_WIDE_INT) val[len - 1])\n+\t\t*overflow = wi::OVF_OVERFLOW;\n+\t      else\n+\t\t*overflow = wi::OVF_NONE;\n+\t    }\n+\t  else\n+\t    *overflow = wi::OVF_NONE;\n \t}\n       else\n \t{\n \t  /* Put the MSB of X and O0 and in the top of the HWI.  */\n \t  x <<= shift;\n \t  o0 <<= shift;\n \t  if (old_carry)\n-\t    *overflow = (x <= o0);\n+\t    *overflow = (x <= o0) ? wi::OVF_OVERFLOW : wi::OVF_NONE;\n \t  else\n-\t    *overflow = (x < o0);\n+\t    *overflow = (x < o0) ? wi::OVF_OVERFLOW : wi::OVF_NONE;\n \t}\n     }\n \n@@ -1264,12 +1275,14 @@ wi_pack (HOST_WIDE_INT *result,\n    made to see if it overflows.  Unfortunately there is no better way\n    to check for overflow than to do this.  If OVERFLOW is nonnull,\n    record in *OVERFLOW whether the result overflowed.  SGN controls\n-   the signedness and is used to check overflow or if HIGH is set.  */\n+   the signedness and is used to check overflow or if HIGH is set.\n+\n+   NOTE: Overflow type for signed overflow is not yet implemented.  */\n unsigned int\n wi::mul_internal (HOST_WIDE_INT *val, const HOST_WIDE_INT *op1val,\n \t\t  unsigned int op1len, const HOST_WIDE_INT *op2val,\n \t\t  unsigned int op2len, unsigned int prec, signop sgn,\n-\t\t  bool *overflow, bool high)\n+\t\t  wi::overflow_type *overflow, bool high)\n {\n   unsigned HOST_WIDE_INT o0, o1, k, t;\n   unsigned int i;\n@@ -1294,7 +1307,7 @@ wi::mul_internal (HOST_WIDE_INT *val, const HOST_WIDE_INT *op1val,\n      just make sure that we never attempt to set it.  */\n   bool needs_overflow = (overflow != 0);\n   if (needs_overflow)\n-    *overflow = false;\n+    *overflow = wi::OVF_NONE;\n \n   wide_int_ref op1 = wi::storage_ref (op1val, op1len, prec);\n   wide_int_ref op2 = wi::storage_ref (op2val, op2len, prec);\n@@ -1337,7 +1350,8 @@ wi::mul_internal (HOST_WIDE_INT *val, const HOST_WIDE_INT *op1val,\n \t  unsigned HOST_WIDE_INT upper;\n \t  umul_ppmm (upper, val[0], op1.ulow (), op2.ulow ());\n \t  if (needs_overflow)\n-\t    *overflow = (upper != 0);\n+\t    /* Unsigned overflow can only be +OVERFLOW.  */\n+\t    *overflow = (upper != 0) ? wi::OVF_OVERFLOW : wi::OVF_NONE;\n \t  if (high)\n \t    val[0] = upper;\n \t  return 1;\n@@ -1394,12 +1408,14 @@ wi::mul_internal (HOST_WIDE_INT *val, const HOST_WIDE_INT *op1val,\n \t  if (sgn == SIGNED)\n \t    {\n \t      if ((HOST_WIDE_INT) r != sext_hwi (r, prec))\n-\t\t*overflow = true;\n+\t\t/* FIXME: Signed overflow type is not implemented yet.  */\n+\t\t*overflow = OVF_UNKNOWN;\n \t    }\n \t  else\n \t    {\n \t      if ((r >> prec) != 0)\n-\t\t*overflow = true;\n+\t\t/* Unsigned overflow can only be +OVERFLOW.  */\n+\t\t*overflow = OVF_OVERFLOW;\n \t    }\n \t}\n       val[0] = high ? r >> prec : r;\n@@ -1474,7 +1490,8 @@ wi::mul_internal (HOST_WIDE_INT *val, const HOST_WIDE_INT *op1val,\n \n       for (i = half_blocks_needed; i < half_blocks_needed * 2; i++)\n \tif (((HOST_WIDE_INT)(r[i] & mask)) != top)\n-\t  *overflow = true;\n+\t  /* FIXME: Signed overflow type is not implemented yet.  */\n+\t  *overflow = (sgn == UNSIGNED) ? wi::OVF_OVERFLOW : wi::OVF_UNKNOWN;\n     }\n \n   int r_offset = high ? half_blocks_needed : 0;\n@@ -1518,7 +1535,7 @@ unsigned int\n wi::sub_large (HOST_WIDE_INT *val, const HOST_WIDE_INT *op0,\n \t       unsigned int op0len, const HOST_WIDE_INT *op1,\n \t       unsigned int op1len, unsigned int prec,\n-\t       signop sgn, bool *overflow)\n+\t       signop sgn, wi::overflow_type *overflow)\n {\n   unsigned HOST_WIDE_INT o0 = 0;\n   unsigned HOST_WIDE_INT o1 = 0;\n@@ -1552,25 +1569,35 @@ wi::sub_large (HOST_WIDE_INT *val, const HOST_WIDE_INT *op0,\n       val[len] = mask0 - mask1 - borrow;\n       len++;\n       if (overflow)\n-\t*overflow = (sgn == UNSIGNED && borrow);\n+\t*overflow = (sgn == UNSIGNED && borrow) ? OVF_UNDERFLOW : OVF_NONE;\n     }\n   else if (overflow)\n     {\n       unsigned int shift = -prec % HOST_BITS_PER_WIDE_INT;\n       if (sgn == SIGNED)\n \t{\n \t  unsigned HOST_WIDE_INT x = (o0 ^ o1) & (val[len - 1] ^ o0);\n-\t  *overflow = (HOST_WIDE_INT) (x << shift) < 0;\n+\t  if ((HOST_WIDE_INT) (x << shift) < 0)\n+\t    {\n+\t      if (o0 > o1)\n+\t\t*overflow = OVF_UNDERFLOW;\n+\t      else if (o0 < o1)\n+\t\t*overflow = OVF_OVERFLOW;\n+\t      else\n+\t\t*overflow = OVF_NONE;\n+\t    }\n+\t  else\n+\t    *overflow = OVF_NONE;\n \t}\n       else\n \t{\n \t  /* Put the MSB of X and O0 and in the top of the HWI.  */\n \t  x <<= shift;\n \t  o0 <<= shift;\n \t  if (old_borrow)\n-\t    *overflow = (x >= o0);\n+\t    *overflow = (x >= o0) ? OVF_UNDERFLOW : OVF_NONE;\n \t  else\n-\t    *overflow = (x > o0);\n+\t    *overflow = (x > o0) ? OVF_UNDERFLOW : OVF_NONE;\n \t}\n     }\n \n@@ -1706,7 +1733,7 @@ wi::divmod_internal (HOST_WIDE_INT *quotient, unsigned int *remainder_len,\n \t\t     unsigned int dividend_len, unsigned int dividend_prec,\n \t\t     const HOST_WIDE_INT *divisor_val, unsigned int divisor_len,\n \t\t     unsigned int divisor_prec, signop sgn,\n-\t\t     bool *oflow)\n+\t\t     wi::overflow_type *oflow)\n {\n   unsigned int dividend_blocks_needed = 2 * BLOCKS_NEEDED (dividend_prec);\n   unsigned int divisor_blocks_needed = 2 * BLOCKS_NEEDED (divisor_prec);\n@@ -1750,16 +1777,16 @@ wi::divmod_internal (HOST_WIDE_INT *quotient, unsigned int *remainder_len,\n \t  *remainder_len = 1;\n \t  remainder[0] = 0;\n \t}\n-      if (oflow != 0)\n-\t*oflow = true;\n+      if (oflow)\n+\t*oflow = OVF_OVERFLOW;\n       if (quotient)\n \tfor (unsigned int i = 0; i < dividend_len; ++i)\n \t  quotient[i] = dividend_val[i];\n       return dividend_len;\n     }\n \n   if (oflow)\n-    *oflow = false;\n+    *oflow = OVF_NONE;\n \n   /* Do it on the host if you can.  */\n   if (sgn == SIGNED\n@@ -2421,30 +2448,30 @@ test_overflow ()\n       {\n \tint prec = precs[i];\n \tint offset = offsets[j];\n-\tbool overflow;\n+\twi::overflow_type overflow;\n \twide_int sum, diff;\n \n \tsum = wi::add (wi::max_value (prec, UNSIGNED) - offset, 1,\n \t\t       UNSIGNED, &overflow);\n \tASSERT_EQ (sum, -offset);\n-\tASSERT_EQ (overflow, offset == 0);\n+\tASSERT_EQ (overflow != wi::OVF_NONE, offset == 0);\n \n \tsum = wi::add (1, wi::max_value (prec, UNSIGNED) - offset,\n \t\t       UNSIGNED, &overflow);\n \tASSERT_EQ (sum, -offset);\n-\tASSERT_EQ (overflow, offset == 0);\n+\tASSERT_EQ (overflow != wi::OVF_NONE, offset == 0);\n \n \tdiff = wi::sub (wi::max_value (prec, UNSIGNED) - offset,\n \t\t\twi::max_value (prec, UNSIGNED),\n \t\t\tUNSIGNED, &overflow);\n \tASSERT_EQ (diff, -offset);\n-\tASSERT_EQ (overflow, offset != 0);\n+\tASSERT_EQ (overflow != wi::OVF_NONE, offset != 0);\n \n \tdiff = wi::sub (wi::max_value (prec, UNSIGNED) - offset,\n \t\t\twi::max_value (prec, UNSIGNED) - 1,\n \t\t\tUNSIGNED, &overflow);\n \tASSERT_EQ (diff, 1 - offset);\n-\tASSERT_EQ (overflow, offset > 1);\n+\tASSERT_EQ (overflow != wi::OVF_NONE, offset > 1);\n     }\n }\n "}, {"sha": "cb5f9abffe23cc83209ab8c20e38dee346c36f0b", "filename": "gcc/wide-int.h", "status": "modified", "additions": 109, "deletions": 41, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a669ac35988fa6de5931455fb59c713563bc58b/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=4a669ac35988fa6de5931455fb59c713563bc58b", "patch": "@@ -344,6 +344,23 @@ typedef generic_wide_int <wide_int_ref_storage <false> > wide_int_ref;\n \n namespace wi\n {\n+  /* Operations that calculate overflow do so even for\n+     TYPE_OVERFLOW_WRAPS types.  For example, adding 1 to +MAX_INT in\n+     an unsigned int is 0 and does not overflow in C/C++, but wi::add\n+     will set the overflow argument in case it's needed for further\n+     analysis.\n+\n+     For operations that require overflow, these are the different\n+     types of overflow.  */\n+  enum overflow_type {\n+    OVF_NONE = 0,\n+    OVF_UNDERFLOW = -1,\n+    OVF_OVERFLOW = 1,\n+    /* There was an overflow, but we are unsure whether it was an\n+       overflow or an underflow.  */\n+    OVF_UNKNOWN = 2\n+  };\n+\n   /* Classifies an integer based on its precision.  */\n   enum precision_type {\n     /* The integer has both a precision and defined signedness.  This allows\n@@ -522,7 +539,7 @@ namespace wi\n \n   UNARY_FUNCTION bit_not (const T &);\n   UNARY_FUNCTION neg (const T &);\n-  UNARY_FUNCTION neg (const T &, bool *);\n+  UNARY_FUNCTION neg (const T &, overflow_type *);\n   UNARY_FUNCTION abs (const T &);\n   UNARY_FUNCTION ext (const T &, unsigned int, signop);\n   UNARY_FUNCTION sext (const T &, unsigned int);\n@@ -542,33 +559,41 @@ namespace wi\n   BINARY_FUNCTION bit_or_not (const T1 &, const T2 &);\n   BINARY_FUNCTION bit_xor (const T1 &, const T2 &);\n   BINARY_FUNCTION add (const T1 &, const T2 &);\n-  BINARY_FUNCTION add (const T1 &, const T2 &, signop, bool *);\n+  BINARY_FUNCTION add (const T1 &, const T2 &, signop, overflow_type *);\n   BINARY_FUNCTION sub (const T1 &, const T2 &);\n-  BINARY_FUNCTION sub (const T1 &, const T2 &, signop, bool *);\n+  BINARY_FUNCTION sub (const T1 &, const T2 &, signop, overflow_type *);\n   BINARY_FUNCTION mul (const T1 &, const T2 &);\n-  BINARY_FUNCTION mul (const T1 &, const T2 &, signop, bool *);\n-  BINARY_FUNCTION smul (const T1 &, const T2 &, bool *);\n-  BINARY_FUNCTION umul (const T1 &, const T2 &, bool *);\n+  BINARY_FUNCTION mul (const T1 &, const T2 &, signop, overflow_type *);\n+  BINARY_FUNCTION smul (const T1 &, const T2 &, overflow_type *);\n+  BINARY_FUNCTION umul (const T1 &, const T2 &, overflow_type *);\n   BINARY_FUNCTION mul_high (const T1 &, const T2 &, signop);\n-  BINARY_FUNCTION div_trunc (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION div_trunc (const T1 &, const T2 &, signop,\n+\t\t\t     overflow_type * = 0);\n   BINARY_FUNCTION sdiv_trunc (const T1 &, const T2 &);\n   BINARY_FUNCTION udiv_trunc (const T1 &, const T2 &);\n-  BINARY_FUNCTION div_floor (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION div_floor (const T1 &, const T2 &, signop,\n+\t\t\t     overflow_type * = 0);\n   BINARY_FUNCTION udiv_floor (const T1 &, const T2 &);\n   BINARY_FUNCTION sdiv_floor (const T1 &, const T2 &);\n-  BINARY_FUNCTION div_ceil (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION div_ceil (const T1 &, const T2 &, signop,\n+\t\t\t    overflow_type * = 0);\n   BINARY_FUNCTION udiv_ceil (const T1 &, const T2 &);\n-  BINARY_FUNCTION div_round (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION div_round (const T1 &, const T2 &, signop,\n+\t\t\t     overflow_type * = 0);\n   BINARY_FUNCTION divmod_trunc (const T1 &, const T2 &, signop,\n \t\t\t\tWI_BINARY_RESULT (T1, T2) *);\n   BINARY_FUNCTION gcd (const T1 &, const T2 &, signop = UNSIGNED);\n-  BINARY_FUNCTION mod_trunc (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION mod_trunc (const T1 &, const T2 &, signop,\n+\t\t\t     overflow_type * = 0);\n   BINARY_FUNCTION smod_trunc (const T1 &, const T2 &);\n   BINARY_FUNCTION umod_trunc (const T1 &, const T2 &);\n-  BINARY_FUNCTION mod_floor (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION mod_floor (const T1 &, const T2 &, signop,\n+\t\t\t     overflow_type * = 0);\n   BINARY_FUNCTION umod_floor (const T1 &, const T2 &);\n-  BINARY_FUNCTION mod_ceil (const T1 &, const T2 &, signop, bool * = 0);\n-  BINARY_FUNCTION mod_round (const T1 &, const T2 &, signop, bool * = 0);\n+  BINARY_FUNCTION mod_ceil (const T1 &, const T2 &, signop,\n+\t\t\t    overflow_type * = 0);\n+  BINARY_FUNCTION mod_round (const T1 &, const T2 &, signop,\n+\t\t\t     overflow_type * = 0);\n \n   template <typename T1, typename T2>\n   bool multiple_of_p (const T1 &, const T2 &, signop);\n@@ -606,6 +631,8 @@ namespace wi\n \n   template <typename T>\n   unsigned int min_precision (const T &, signop);\n+\n+  static inline void accumulate_overflow (overflow_type &, overflow_type);\n }\n \n namespace wi\n@@ -1700,20 +1727,20 @@ namespace wi\n \t\t\t  const HOST_WIDE_INT *, unsigned int, unsigned int);\n   unsigned int add_large (HOST_WIDE_INT *, const HOST_WIDE_INT *, unsigned int,\n \t\t\t  const HOST_WIDE_INT *, unsigned int, unsigned int,\n-\t\t\t  signop, bool *);\n+\t\t\t  signop, overflow_type *);\n   unsigned int sub_large (HOST_WIDE_INT *, const HOST_WIDE_INT *, unsigned int,\n \t\t\t  const HOST_WIDE_INT *, unsigned int, unsigned int,\n-\t\t\t  signop, bool *);\n+\t\t\t  signop, overflow_type *);\n   unsigned int mul_internal (HOST_WIDE_INT *, const HOST_WIDE_INT *,\n \t\t\t     unsigned int, const HOST_WIDE_INT *,\n-\t\t\t     unsigned int, unsigned int, signop, bool *,\n-\t\t\t     bool);\n+\t\t\t     unsigned int, unsigned int, signop,\n+\t\t\t     overflow_type *, bool);\n   unsigned int divmod_internal (HOST_WIDE_INT *, unsigned int *,\n \t\t\t\tHOST_WIDE_INT *, const HOST_WIDE_INT *,\n \t\t\t\tunsigned int, unsigned int,\n \t\t\t\tconst HOST_WIDE_INT *,\n \t\t\t\tunsigned int, unsigned int,\n-\t\t\t\tsignop, bool *);\n+\t\t\t\tsignop, overflow_type *);\n }\n \n /* Return the number of bits that integer X can hold.  */\n@@ -2102,12 +2129,13 @@ wi::neg (const T &x)\n   return sub (0, x);\n }\n \n-/* Return -x.  Indicate in *OVERFLOW if X is the minimum signed value.  */\n+/* Return -x.  Indicate in *OVERFLOW if performing the negation would\n+   cause an overflow.  */\n template <typename T>\n inline WI_UNARY_RESULT (T)\n-wi::neg (const T &x, bool *overflow)\n+wi::neg (const T &x, overflow_type *overflow)\n {\n-  *overflow = only_sign_bit_p (x);\n+  *overflow = only_sign_bit_p (x) ? OVF_OVERFLOW : OVF_NONE;\n   return sub (0, x);\n }\n \n@@ -2407,7 +2435,7 @@ wi::add (const T1 &x, const T2 &y)\n    and indicate in *OVERFLOW whether the operation overflowed.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::add (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::add (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);\n   unsigned int precision = get_precision (result);\n@@ -2419,11 +2447,24 @@ wi::add (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n       unsigned HOST_WIDE_INT yl = yi.ulow ();\n       unsigned HOST_WIDE_INT resultl = xl + yl;\n       if (sgn == SIGNED)\n-\t*overflow = (((resultl ^ xl) & (resultl ^ yl))\n-\t\t     >> (precision - 1)) & 1;\n+\t{\n+\t  if ((((resultl ^ xl) & (resultl ^ yl))\n+\t       >> (precision - 1)) & 1)\n+\t    {\n+\t      if (xl > resultl)\n+\t\t*overflow = OVF_UNDERFLOW;\n+\t      else if (xl < resultl)\n+\t\t*overflow = OVF_OVERFLOW;\n+\t      else\n+\t\t*overflow = OVF_NONE;\n+\t    }\n+\t  else\n+\t    *overflow = OVF_NONE;\n+\t}\n       else\n \t*overflow = ((resultl << (HOST_BITS_PER_WIDE_INT - precision))\n-\t\t     < (xl << (HOST_BITS_PER_WIDE_INT - precision)));\n+\t\t     < (xl << (HOST_BITS_PER_WIDE_INT - precision)))\n+\t  ? OVF_OVERFLOW : OVF_NONE;\n       val[0] = resultl;\n       result.set_len (1);\n     }\n@@ -2480,7 +2521,7 @@ wi::sub (const T1 &x, const T2 &y)\n    and indicate in *OVERFLOW whether the operation overflowed.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::sub (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::sub (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);\n   unsigned int precision = get_precision (result);\n@@ -2492,10 +2533,23 @@ wi::sub (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n       unsigned HOST_WIDE_INT yl = yi.ulow ();\n       unsigned HOST_WIDE_INT resultl = xl - yl;\n       if (sgn == SIGNED)\n-\t*overflow = (((xl ^ yl) & (resultl ^ xl)) >> (precision - 1)) & 1;\n+\t{\n+\t  if ((((xl ^ yl) & (resultl ^ xl)) >> (precision - 1)) & 1)\n+\t    {\n+\t      if (xl > yl)\n+\t\t*overflow = OVF_UNDERFLOW;\n+\t      else if (xl < yl)\n+\t\t*overflow = OVF_OVERFLOW;\n+\t      else\n+\t\t*overflow = OVF_NONE;\n+\t    }\n+\t  else\n+\t    *overflow = OVF_NONE;\n+\t}\n       else\n \t*overflow = ((resultl << (HOST_BITS_PER_WIDE_INT - precision))\n-\t\t     > (xl << (HOST_BITS_PER_WIDE_INT - precision)));\n+\t\t     > (xl << (HOST_BITS_PER_WIDE_INT - precision)))\n+\t  ? OVF_UNDERFLOW : OVF_NONE;\n       val[0] = resultl;\n       result.set_len (1);\n     }\n@@ -2530,7 +2584,7 @@ wi::mul (const T1 &x, const T2 &y)\n    and indicate in *OVERFLOW whether the operation overflowed.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::mul (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::mul (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (result, val, T1, x, T2, y);\n   unsigned int precision = get_precision (result);\n@@ -2546,16 +2600,16 @@ wi::mul (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n    *OVERFLOW whether the operation overflowed.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::smul (const T1 &x, const T2 &y, bool *overflow)\n+wi::smul (const T1 &x, const T2 &y, overflow_type *overflow)\n {\n   return mul (x, y, SIGNED, overflow);\n }\n \n /* Return X * Y, treating both X and Y as unsigned values.  Indicate in\n-   *OVERFLOW whether the operation overflowed.  */\n+  *OVERFLOW if the result overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::umul (const T1 &x, const T2 &y, bool *overflow)\n+wi::umul (const T1 &x, const T2 &y, overflow_type *overflow)\n {\n   return mul (x, y, UNSIGNED, overflow);\n }\n@@ -2581,7 +2635,7 @@ wi::mul_high (const T1 &x, const T2 &y, signop sgn)\n    overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::div_trunc (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::div_trunc (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);\n   unsigned int precision = get_precision (quotient);\n@@ -2616,7 +2670,7 @@ wi::udiv_trunc (const T1 &x, const T2 &y)\n    overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::div_floor (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::div_floor (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);\n   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);\n@@ -2658,7 +2712,7 @@ wi::udiv_floor (const T1 &x, const T2 &y)\n    overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::div_ceil (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::div_ceil (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);\n   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);\n@@ -2691,7 +2745,7 @@ wi::udiv_ceil (const T1 &x, const T2 &y)\n    in *OVERFLOW if the result overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::div_round (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::div_round (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);\n   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);\n@@ -2779,7 +2833,7 @@ wi::gcd (const T1 &a, const T2 &b, signop sgn)\n    in *OVERFLOW if the division overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::mod_trunc (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::mod_trunc (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);\n   unsigned int precision = get_precision (remainder);\n@@ -2818,7 +2872,7 @@ wi::umod_trunc (const T1 &x, const T2 &y)\n    in *OVERFLOW if the division overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::mod_floor (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::mod_floor (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);\n   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);\n@@ -2854,7 +2908,7 @@ wi::umod_floor (const T1 &x, const T2 &y)\n    in *OVERFLOW if the division overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::mod_ceil (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::mod_ceil (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);\n   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);\n@@ -2880,7 +2934,7 @@ wi::mod_ceil (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n    given by SGN.  Indicate in *OVERFLOW if the division overflows.  */\n template <typename T1, typename T2>\n inline WI_BINARY_RESULT (T1, T2)\n-wi::mod_round (const T1 &x, const T2 &y, signop sgn, bool *overflow)\n+wi::mod_round (const T1 &x, const T2 &y, signop sgn, overflow_type *overflow)\n {\n   WI_BINARY_RESULT_VAR (quotient, quotient_val, T1, x, T2, y);\n   WI_BINARY_RESULT_VAR (remainder, remainder_val, T1, x, T2, y);\n@@ -3395,4 +3449,18 @@ wi::set_bit_in_zero (unsigned int bit)\n   return shifted_mask <T> (bit, 1, false);\n }\n \n+/* Accumulate a set of overflows into OVERFLOW.  */\n+\n+static inline void\n+wi::accumulate_overflow (wi::overflow_type &overflow,\n+\t\t\t wi::overflow_type suboverflow)\n+{\n+  if (!suboverflow)\n+    return;\n+  if (!overflow)\n+    overflow = suboverflow;\n+  else if (overflow != suboverflow)\n+    overflow = wi::OVF_UNKNOWN;\n+}\n+\n #endif /* WIDE_INT_H */"}]}