{"sha": "f2e6e5307bece75988f49a2d69d56f2e83c35dda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJlNmU1MzA3YmVjZTc1OTg4ZjQ5YTJkNjlkNTZmMmU4M2MzNWRkYQ==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2001-08-01T08:10:00Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-08-01T08:10:00Z"}, "message": "c-parse.in (OBJC_NEED_RAW_IDENTIFIER): Define macro and flag for contextualizing Objective-C class name lookup by the...\n\n2001-08-01  Ziemowit Laski  <zlaski@apple.com>\n\n        * c-parse.in (OBJC_NEED_RAW_IDENTIFIER): Define macro and flag for\n\tcontextualizing Objective-C class name lookup by the lexer.\n\t(typespec_reserved_nonattr): Disable ObjC class name lookup after\n\tseeing a TYPESPEC.\n\t(protocoldef): Add support for forward @protocol declarations.\n\t(yylexname): Suppress ObjC class name lookup in certain contexts;\n\tre-enable after lookup is complete.\n\t(_yylex): Re-enable ObjC class name lookup when certain\n\tpunctuation marks are seen.\n\n\t* objc/objc-act.c (check_protocol_recursively): New function used\n\tfor finding circular dependencies in protocols.\n\t(objc_declare_protocols): New function for handling forward\n\t@protocol declarations.\n\t(receiver_is_class_object): Detect the case when 'self' is used\n\tinside of a class method.\n\t(build_message_expr): Issue a warning if class method is desired\n\tbut instance method is found instead.\n\t(conforms_to_protocol): Streamline.\n\t(objc_comptypes): Detect the fact that 'Bar<Foo> foo' conforms to\n\tprotocol Foo, even if 'Bar foo' does not.\n\t(check_protocols): Streamline.\n\t(start_protocol): Add checks for circular and duplicate protocol\n\tdefinitions.\n\t(encode_aggregate_within): For typedefs of structs, encode the\n\tunderlying struct.\n\t* objc/objc-act.h (PROTOCOL_DEFINED): New tree accessor.\n\t(objc_declare_protocols): New prototype.\n\nFrom-SVN: r44536", "tree": {"sha": "648dd272baeb69450a07f51b1c4e7565b12eafb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/648dd272baeb69450a07f51b1c4e7565b12eafb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2e6e5307bece75988f49a2d69d56f2e83c35dda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e6e5307bece75988f49a2d69d56f2e83c35dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2e6e5307bece75988f49a2d69d56f2e83c35dda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e6e5307bece75988f49a2d69d56f2e83c35dda/comments", "author": null, "committer": null, "parents": [{"sha": "80858e66df3f4aa8b0b27cf1006cb33541490655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80858e66df3f4aa8b0b27cf1006cb33541490655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80858e66df3f4aa8b0b27cf1006cb33541490655"}], "stats": {"total": 339, "additions": 263, "deletions": 76}, "files": [{"sha": "01ef78a5bef078c33c27aaebe67b4badeccb60a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2e6e5307bece75988f49a2d69d56f2e83c35dda", "patch": "@@ -1,3 +1,34 @@\n+2001-08-01  Ziemowit Laski  <zlaski@apple.com>\n+\n+        * c-parse.in (OBJC_NEED_RAW_IDENTIFIER): Define macro and flag for\n+\tcontextualizing Objective-C class name lookup by the lexer.\n+\t(typespec_reserved_nonattr): Disable ObjC class name lookup after\n+\tseeing a TYPESPEC.\n+\t(protocoldef): Add support for forward @protocol declarations.\n+\t(yylexname): Suppress ObjC class name lookup in certain contexts;\n+\tre-enable after lookup is complete.\n+\t(_yylex): Re-enable ObjC class name lookup when certain\n+\tpunctuation marks are seen.\n+\n+\t* objc/objc-act.c (check_protocol_recursively): New function used\n+\tfor finding circular dependencies in protocols.\n+\t(objc_declare_protocols): New function for handling forward\n+\t@protocol declarations.\n+\t(receiver_is_class_object): Detect the case when 'self' is used\n+\tinside of a class method.\n+\t(build_message_expr): Issue a warning if class method is desired\n+\tbut instance method is found instead.\n+\t(conforms_to_protocol): Streamline.\n+\t(objc_comptypes): Detect the fact that 'Bar<Foo> foo' conforms to\n+\tprotocol Foo, even if 'Bar foo' does not.\n+\t(check_protocols): Streamline.\n+\t(start_protocol): Add checks for circular and duplicate protocol\n+\tdefinitions.\n+\t(encode_aggregate_within): For typedefs of structs, encode the\n+\tunderlying struct.\n+\t* objc/objc-act.h (PROTOCOL_DEFINED): New tree accessor.\n+\t(objc_declare_protocols): New prototype.\n+\n 2001-08-01  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n \n \t* cpphash.h (struct cpp_reader): New members line, pseudo_newlines."}, {"sha": "d1320565bfc54997b1f67f2e7cf862e2ab96dabf", "filename": "gcc/c-parse.in", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=f2e6e5307bece75988f49a2d69d56f2e83c35dda", "patch": "@@ -29,10 +29,10 @@ Boston, MA 02111-1307, USA.  */\n    written by AT&T, but I have never seen it.  */\n \n ifobjc\n-%expect 31\n+%expect 31 /* shift/reduce conflicts, and 1 reduce/reduce conflict.  */\n end ifobjc\n ifc\n-%expect 10\n+%expect 10 /* shift/reduce conflicts, and no reduce/reduce conflicts.  */\n end ifc\n \n %{\n@@ -295,8 +295,18 @@ int objc_receiver_context;\n int objc_public_flag;\n int objc_pq_context;\n \n+/* The following flag is needed to contextualize ObjC lexical analysis.\n+   In some cases (e.g., 'int NSObject;'), it is undesirable to bind \n+   an identifier to an ObjC class, even if a class with that name \n+   exists.  */\n+int objc_need_raw_identifier;\n+#define OBJC_NEED_RAW_IDENTIFIER(VAL)\tobjc_need_raw_identifier = VAL\n end ifobjc\n \n+ifc\n+#define OBJC_NEED_RAW_IDENTIFIER(VAL)\t/* nothing */\n+end ifc\n+\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n@@ -444,7 +454,7 @@ identifier:\n \t| TYPENAME\n ifobjc\n \t| OBJECTNAME\n-        | CLASSNAME\n+\t| CLASSNAME\n end ifobjc\n \t;\n \n@@ -1384,6 +1394,7 @@ typespec_attr:\n \n typespec_reserved_nonattr:\n \t  TYPESPEC\n+\t\t{ OBJC_NEED_RAW_IDENTIFIER (1);\t}\n \t| structsp_nonattr\n \t;\n \n@@ -1694,6 +1705,9 @@ parm_declarator_starttypename:\n \t| parm_declarator_starttypename array_declarator  %prec '.'\n \t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n \t| TYPENAME\n+ifobjc\n+\t| OBJECTNAME\n+end ifobjc\n \t;\n \n parm_declarator_nostarttypename:\n@@ -2836,6 +2850,13 @@ protocoldef:\n \t\t  finish_protocol(objc_interface_context);\n \t\t  objc_interface_context = NULL_TREE;\n \t\t}\n+\t/* The @protocol forward-declaration production introduces a\n+\t   reduce/reduce conflict on ';', which should be resolved in\n+\t   favor of the production 'identifier_list -> identifier'.  */\n+\t| PROTOCOL identifier_list ';'\n+\t\t{\n+\t\t  objc_declare_protocols ($2);\n+\t\t}\n \t;\n \n protocolrefs:\n@@ -3119,8 +3140,9 @@ keywordselector:\n \n selector:\n \t  IDENTIFIER\n-        | TYPENAME\n-  \t| OBJECTNAME\n+\t| TYPENAME\n+\t| CLASSNAME\n+\t| OBJECTNAME\n \t| reservedwords\n \t;\n \n@@ -3615,12 +3637,26 @@ static int\n yylexname ()\n {\n   tree decl;\n-\n+  \n+ifobjc\n+  int objc_force_identifier = objc_need_raw_identifier;\n+  OBJC_NEED_RAW_IDENTIFIER (0);\n+end ifobjc\n+  \n   if (C_IS_RESERVED_WORD (yylval.ttype))\n     {\n       enum rid rid_code = C_RID_CODE (yylval.ttype);\n \n ifobjc\n+      /* Turn non-typedefed refs to \"id\" into plain identifiers; this\n+\t allows constructs like \"void foo(id id);\" to work.  */\n+      if (rid_code == RID_ID)\n+      {\n+\tdecl = lookup_name (yylval.ttype);\n+\tif (decl == NULL_TREE || TREE_CODE (decl) != TYPE_DECL)\n+\t  return IDENTIFIER;\n+      }\n+\n       if (!OBJC_IS_AT_KEYWORD (rid_code)\n \t  && (!OBJC_IS_PQ_KEYWORD (rid_code) || objc_pq_context))\n end ifobjc\n@@ -3653,8 +3689,11 @@ ifobjc\n   else\n     {\n       tree objc_interface_decl = is_class_name (yylval.ttype);\n-\n-      if (objc_interface_decl)\n+      /* ObjC class names are in the same namespace as variables and\n+\t typedefs, and hence are shadowed by local declarations.  */\n+      if (objc_interface_decl \n+\t  && (global_bindings_p () \n+\t      || (!objc_force_identifier && !decl)))\n \t{\n \t  yylval.ttype = objc_interface_decl;\n \t  return CLASSNAME;\n@@ -3692,10 +3731,7 @@ _yylex ()\n     case CPP_AND_AND:\t\t\t\t\treturn ANDAND;\n     case CPP_OR_OR:\t\t\t\t\treturn OROR;\n     case CPP_QUERY:\t\t\t\t\treturn '?';\n-    case CPP_COLON:\t\t\t\t\treturn ':';\n-    case CPP_COMMA:\t\t\t\t\treturn ',';\n     case CPP_OPEN_PAREN:\t\t\t\treturn '(';\n-    case CPP_CLOSE_PAREN:\t\t\t\treturn ')';\n     case CPP_EQ_EQ:\tyylval.code = EQ_EXPR;\t\treturn EQCOMPARE;\n     case CPP_NOT_EQ:\tyylval.code = NE_EXPR;\t\treturn EQCOMPARE;\n     case CPP_GREATER_EQ:yylval.code = GE_EXPR;\t\treturn ARITHCOMPARE;\n@@ -3716,14 +3752,20 @@ _yylex ()\n     case CPP_CLOSE_SQUARE:\t\t\t\treturn ']';\n     case CPP_OPEN_BRACE:\t\t\t\treturn '{';\n     case CPP_CLOSE_BRACE:\t\t\t\treturn '}';\n-    case CPP_SEMICOLON:\t\t\t\t\treturn ';';\n     case CPP_ELLIPSIS:\t\t\t\t\treturn ELLIPSIS;\n \n     case CPP_PLUS_PLUS:\t\t\t\t\treturn PLUSPLUS;\n     case CPP_MINUS_MINUS:\t\t\t\treturn MINUSMINUS;\n     case CPP_DEREF:\t\t\t\t\treturn POINTSAT;\n     case CPP_DOT:\t\t\t\t\treturn '.';\n \n+      /* The following tokens may affect the interpretation of any\n+\t identifiers following, if doing Objective-C.  */\n+    case CPP_COLON:\t\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ':';\n+    case CPP_COMMA:\t\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ',';\n+    case CPP_CLOSE_PAREN:\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ')';\n+    case CPP_SEMICOLON:\t\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ';';\n+\n     case CPP_EOF:\n       if (cpp_pop_buffer (parse_in) == 0)\n \treturn 0;\n@@ -3741,8 +3783,8 @@ _yylex ()\n     case CPP_WSTRING:\n       return STRING;\n       \n-      /* This token is Objective-C specific.  It gives the next\n-\t token special significance.  */\n+      /* This token is Objective-C specific.  It gives the next token\n+\t special significance.  */\n     case CPP_ATSIGN:\n ifobjc\n       {"}, {"sha": "03c3ae4f2627ba80e14ea54f9d911d882a5f8b76", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 173, "deletions": 61, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f2e6e5307bece75988f49a2d69d56f2e83c35dda", "patch": "@@ -253,6 +253,7 @@ static tree build_selector_reference_decl\tPARAMS ((void));\n \n static tree add_protocol\t\t\tPARAMS ((tree));\n static tree lookup_protocol\t\t\tPARAMS ((tree));\n+static void check_protocol_recursively\t\tPARAMS ((tree, tree));\n static tree lookup_and_install_protocols\tPARAMS ((tree));\n \n /* Type encoding.  */\n@@ -336,6 +337,8 @@ static tree check_duplicates\t\t\tPARAMS ((hash));\n static tree receiver_is_class_object\t\tPARAMS ((tree));\n static int check_methods\t\t\tPARAMS ((tree, tree, int));\n static int conforms_to_protocol\t\t\tPARAMS ((tree, tree));\n+static void check_protocol\t\t\tPARAMS ((tree, const char *,\n+\t\t\t\t\t\t       const char *));\n static void check_protocols\t\t\tPARAMS ((tree, const char *,\n \t\t\t\t\t\t       const char *));\n static tree encode_method_def\t\t\tPARAMS ((tree));\n@@ -1010,6 +1013,12 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t      tree cat;\n \n \t\t      rproto_list = CLASS_PROTOCOL_LIST (rinter);\n+\t\t      /* If the underlying ObjC class does not have\n+\t\t\t protocols attached to it, perhaps there are\n+\t\t\t \"one-off\" protocols attached to the rhs?\n+\t\t\t E.g., 'id<MyProt> foo;'.  */\n+\t\t      if (!rproto_list)\n+\t\t\trproto_list = TYPE_PROTOCOL_LIST (TREE_TYPE (rhs));\n \t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n \n \t\t      /* Check for protocols adopted by categories.  */\n@@ -1202,6 +1211,32 @@ get_object_reference (protocols)\n   return type;\n }\n \n+/* Check for circular dependencies in protocols.  The arguments are\n+   PROTO, the protocol to check, and LIST, a list of protocol it\n+   conforms to.  */\n+\n+static void \n+check_protocol_recursively (proto, list)\n+     tree proto;\n+     tree list;\n+{\n+  tree p;\n+\n+  for (p = list; p; p = TREE_CHAIN (p))\n+    {\n+      tree pp = TREE_VALUE (p);\n+\n+      if (TREE_CODE (pp) == IDENTIFIER_NODE)\n+\tpp = lookup_protocol (pp);\n+\n+      if (pp == proto)\n+\tfatal_error (\"protocol `%s' has circular dependency\",\n+\t\t     IDENTIFIER_POINTER (PROTOCOL_NAME (pp)));      \n+      if (pp)\n+\tcheck_protocol_recursively (proto, PROTOCOL_LIST (pp));\n+    }\n+}\n+\n static tree\n lookup_and_install_protocols (protocols)\n      tree protocols;\n@@ -4871,18 +4906,27 @@ check_duplicates (hsh)\n   return meth;\n }\n \n-/* If RECEIVER is a class reference, return the identifier node for the\n-   referenced class.  RECEIVER is created by get_class_reference, so we\n-   check the exact form created depending on which runtimes are used.  */\n+/* If RECEIVER is a class reference, return the identifier node for\n+   the referenced class.  RECEIVER is created by get_class_reference,\n+   so we check the exact form created depending on which runtimes are\n+   used.  */\n \n static tree\n receiver_is_class_object (receiver)\n       tree receiver;\n {\n   tree chain, exp, arg;\n+\n   if (flag_next_runtime)\n     {\n-      /* The receiver is a variable created by build_class_reference_decl.  */\n+      /* The receiver is 'self' in the context of a class method.  */\n+      if (objc_method_context\n+\t  && receiver == self_decl\n+\t  && TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)\n+\treturn CLASS_NAME (objc_implementation_context);\n+\n+      /* The receiver is a variable created by\n+         build_class_reference_decl.  */\n       if (TREE_CODE (receiver) == VAR_DECL\n \t  && TREE_TYPE (receiver) == objc_class_type)\n \t/* Look up the identifier.  */\n@@ -4899,7 +4943,7 @@ receiver_is_class_object (receiver)\n \t  && (exp = TREE_OPERAND (exp, 0))\n \t  && TREE_CODE (exp) == FUNCTION_DECL\n \t  && exp == objc_get_class_decl\n-\t  /* we have a call to objc_getClass! */\n+\t  /* We have a call to objc_getClass!  */\n \t  && (arg = TREE_OPERAND (receiver, 1))\n \t  && TREE_CODE (arg) == TREE_LIST\n \t  && (arg = TREE_VALUE (arg)))\n@@ -5143,7 +5187,8 @@ build_message_expr (mess)\n \t    method_prototype = lookup_class_method_static (iface, sel_name);\n \t}\n \n-      if (!method_prototype)\n+      if (!method_prototype \n+          || TREE_CODE (method_prototype) != CLASS_METHOD_DECL)\n \t{\n \t  warning (\"cannot find class (factory) method.\");\n \t  warning (\"return type for `%s' defaults to id\",\n@@ -5960,16 +6005,17 @@ check_methods (chain, list, mtype)\n     return first;\n }\n \n+/* Check if CLASS, or its superclasses, explicitly conforms to PROTOCOL.  */\n+\n static int\n conforms_to_protocol (class, protocol)\n      tree class;\n      tree protocol;\n {\n-   while (protocol)\n+   if (TREE_CODE (protocol) == PROTOCOL_INTERFACE_TYPE)\n      {\n        tree p = CLASS_PROTOCOL_LIST (class);\n-\n-       while (p && TREE_VALUE (p) != TREE_VALUE (protocol))\n+       while (p && TREE_VALUE (p) != protocol)\n \t p = TREE_CHAIN (p);\n \n        if (!p)\n@@ -5981,8 +6027,6 @@ conforms_to_protocol (class, protocol)\n \t   if (!tmp)\n \t     return 0;\n \t }\n-\n-       protocol = TREE_CHAIN (protocol);\n      }\n \n    return 1;\n@@ -6054,57 +6098,81 @@ check_methods_accessible (chain, context, mtype)\n     return first;\n }\n \n+/* Check whether the current interface (accessible via\n+   'implementation_context') actually implements protocol P, along\n+   with any protocols that P inherits.  */\n+   \n static void\n-check_protocols (proto_list, type, name)\n-     tree proto_list;\n+check_protocol (p, type, name)\n+     tree p;\n      const char *type;\n      const char *name;\n {\n-  for ( ; proto_list; proto_list = TREE_CHAIN (proto_list))\n+  if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n     {\n-      tree p = TREE_VALUE (proto_list);\n+      int f1, f2;\n \n-      if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n+      /* Ensure that all protocols have bodies!  */\n+      if (flag_warn_protocol)\n \t{\n-\t  int f1, f2;\n-\t  \n-\t  /* Ensure that all protocols have bodies.  */\n-\t  if (flag_warn_protocol) {\n-\t    f1 = check_methods (PROTOCOL_CLS_METHODS (p),\n-\t\t\t\tCLASS_CLS_METHODS (implementation_context),\n-\t\t\t\t'+');\n-\t    f2 = check_methods (PROTOCOL_NST_METHODS (p),\n-\t\t\t\tCLASS_NST_METHODS (implementation_context),\n-\t\t\t\t'-');\n-\t  } else {\n-\t    f1 = check_methods_accessible (PROTOCOL_CLS_METHODS (p),\n-\t\t\t\t\t   implementation_context,\n-\t\t\t\t\t   '+');\n-\t    f2 = check_methods_accessible (PROTOCOL_NST_METHODS (p),\n-\t\t\t\t\t   implementation_context,\n-\t\t\t\t\t   '-');\n-\t  }\n-\n-\t  if (!f1 || !f2)\n-\t    warning (\"%s `%s' does not fully implement the `%s' protocol\",\n-\t\t     type, name, IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n-\n+\t  f1 = check_methods (PROTOCOL_CLS_METHODS (p),\n+\t\t\t      CLASS_CLS_METHODS (implementation_context),\n+\t\t\t      '+');\n+\t  f2 = check_methods (PROTOCOL_NST_METHODS (p),\n+\t\t\t      CLASS_NST_METHODS (implementation_context),\n+\t\t\t      '-');\n \t}\n       else\n-        {\n-\t  ; /* An identifier if we could not find a protocol.  */\n-        }\n+\t{\n+\t  f1 = check_methods_accessible (PROTOCOL_CLS_METHODS (p),\n+\t\t\t\t\t implementation_context,\n+\t\t\t\t\t '+');\n+\t  f2 = check_methods_accessible (PROTOCOL_NST_METHODS (p),\n+\t\t\t\t\t implementation_context,\n+\t\t\t\t\t '-');\n+\t}\n \n-      /* Check protocols recursively.  */\n-      if (PROTOCOL_LIST (p))\n+      if (!f1 || !f2)\n+\twarning (\"%s `%s' does not fully implement the `%s' protocol\",\n+\t\t type, name, IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+    }\n+    \n+  /* Check protocols recursively.  */\n+  if (PROTOCOL_LIST (p))\n+    {\n+      tree subs = PROTOCOL_LIST (p);\n+      tree super_class =\n+\tlookup_interface (CLASS_SUPER_NAME (implementation_template));\n+      while (subs) \n \t{\n-\t  tree super_class\n-\t    = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n-\t  if (! conforms_to_protocol (super_class, PROTOCOL_LIST (p)))\n-\t    check_protocols (PROTOCOL_LIST (p), type, name);\n+\t  tree sub = TREE_VALUE (subs);\n+\n+\t  /* If the superclass does not conform to the protocols\n+\t     inherited by P, then we must!  */\n+\t  if (!super_class || !conforms_to_protocol (super_class, sub))\n+\t    check_protocol (sub, type, name);\n+\t  subs = TREE_CHAIN (subs);\n \t}\n     }\n }\n+\t\n+/* Check whether the current interface (accessible via\n+   'implementation_context') actually implements the protocols listed\n+   in PROTO_LIST.  */\n+   \n+static void\n+check_protocols (proto_list, type, name)\n+     tree proto_list;\n+     const char *type;\n+     const char *name;\n+{\n+  for ( ; proto_list; proto_list = TREE_CHAIN (proto_list))\n+    {\n+      tree p = TREE_VALUE (proto_list);\n+\n+      check_protocol (p, type, name);\n+    }\n+}\n \f\n /* Make sure that the class CLASS_NAME is defined\n    CODE says which kind of thing CLASS_NAME ought to be.\n@@ -6430,6 +6498,33 @@ lookup_protocol (ident)\n   return NULL_TREE;\n }\n \n+/* This function forward declares the protocols named by NAMES.  If\n+   they are already declared or defined, the function has no effect.  */\n+\n+void\n+objc_declare_protocols (names)\n+     tree names;\n+{\n+  tree list;\n+\n+  for (list = names; list; list = TREE_CHAIN (list))\n+    {\n+      tree name = TREE_VALUE (list);\n+\n+      if (lookup_protocol (name) == NULL_TREE)\n+\t{\n+\t  tree protocol = make_node (PROTOCOL_INTERFACE_TYPE);\n+\n+\t  TYPE_BINFO (protocol) = make_tree_vec (2);\n+\t  PROTOCOL_NAME (protocol) = name;\n+\t  PROTOCOL_LIST (protocol) = NULL_TREE;\n+\t  add_protocol (protocol);\n+\t  PROTOCOL_DEFINED (protocol) = 0;\n+\t  PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE;\n+\t}\n+    }\n+}\n+\n tree\n start_protocol (code, name, list)\n      enum tree_code code;\n@@ -6438,26 +6533,38 @@ start_protocol (code, name, list)\n {\n   tree protocol;\n \n-  /* This is as good a place as any.  Need to invoke push_tag_toplevel.  */\n+  /* This is as good a place as any.  Need to invoke\n+     push_tag_toplevel.  */\n   if (!objc_protocol_template)\n     objc_protocol_template = build_protocol_template ();\n \n-  protocol = make_node (code);\n-  TYPE_BINFO (protocol) = make_tree_vec (2);\n+  protocol = lookup_protocol (name);\n \n-  PROTOCOL_NAME (protocol) = name;\n-  PROTOCOL_LIST (protocol) = list;\n+  if (!protocol)\n+    {\n+      protocol = make_node (code);\n+      TYPE_BINFO (protocol) = make_tree_vec (2);\n \n-  lookup_and_install_protocols (list);\n+      PROTOCOL_NAME (protocol) = name;\n+      PROTOCOL_LIST (protocol) = lookup_and_install_protocols (list);\n+      add_protocol (protocol);\n+      PROTOCOL_DEFINED (protocol) = 1;\n+      PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE;\n \n-  if (lookup_protocol (name))\n-    warning (\"duplicate declaration for protocol `%s'\",\n-\t   IDENTIFIER_POINTER (name));\n-  else\n-    add_protocol (protocol);\n-\n-  PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE;\n+      check_protocol_recursively (protocol, list);\n+    }\n+  else if (! PROTOCOL_DEFINED (protocol))\n+    {\n+      PROTOCOL_DEFINED (protocol) = 1;\n+      PROTOCOL_LIST (protocol) = lookup_and_install_protocols (list);\n \n+      check_protocol_recursively (protocol, list);\n+    }\n+  else\n+    {\n+      warning (\"duplicate declaration for protocol `%s'\",\n+\t       IDENTIFIER_POINTER (name));\n+    }\n   return protocol;\n }\n \n@@ -6595,6 +6702,11 @@ encode_aggregate_within (type, curtype, format, left, right)\n      int left;\n      int right;\n {\n+  /* The RECORD_TYPE may in fact be a typedef!  For purposes\n+     of encoding, we need the real underlying enchilada.  */\n+  if (TYPE_MAIN_VARIANT (type))\n+    type = TYPE_MAIN_VARIANT (type);\n+\n   if (obstack_object_size (&util_obstack) > 0\n       && *(obstack_next_free (&util_obstack) - 1) == '^')\n     {"}, {"sha": "e659f916525ebef23b5755a60458134e2f4af879", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e6e5307bece75988f49a2d69d56f2e83c35dda/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=f2e6e5307bece75988f49a2d69d56f2e83c35dda", "patch": "@@ -1,5 +1,5 @@\n /* Declarations for objc-act.c.\n-   Copyright (C) 1990, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -59,6 +59,7 @@ extern tree objc_ellipsis_node;\n \n void objc_declare_alias\t\t\t\tPARAMS ((tree, tree));\n void objc_declare_class\t\t\t\tPARAMS ((tree));\n+void objc_declare_protocols\t\t\tPARAMS ((tree));\n \n extern int objc_receiver_context;\n \n@@ -101,6 +102,7 @@ tree build_encode_expr\t\t\t\tPARAMS ((tree));\n #define PROTOCOL_NST_METHODS(CLASS) ((CLASS)->type.minval)\n #define PROTOCOL_CLS_METHODS(CLASS) ((CLASS)->type.maxval)\n #define PROTOCOL_FORWARD_DECL(CLASS) TREE_VEC_ELT (TYPE_BINFO (CLASS), 1)\n+#define PROTOCOL_DEFINED(CLASS) TREE_USED (CLASS)\n #define TYPE_PROTOCOL_LIST(TYPE) ((TYPE)->type.context)\n \n /* Define the Objective-C or Objective-C++ language-specific tree codes.  */"}]}