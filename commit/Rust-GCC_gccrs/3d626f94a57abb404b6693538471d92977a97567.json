{"sha": "3d626f94a57abb404b6693538471d92977a97567", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q2MjZmOTRhNTdhYmI0MDRiNjY5MzUzODQ3MWQ5Mjk3N2E5NzU2Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-05-16T11:16:42Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-16T11:16:42Z"}, "message": "freeze.adb (Freeze_Array_Type): Call Addressable predicate instead of testing for individual sizes.\n\n\t* freeze.adb (Freeze_Array_Type): Call Addressable predicate instead\n\tof testing for individual sizes.\n\t(Freeze_Entity): Rework implementation of pragma Implicit_Packing for\n\tarray types, in particular test for suitable sizes upfront and do not\n\tmimic the processing that will be redone later in Freeze_Array_Type.\n\nFrom-SVN: r236281", "tree": {"sha": "c5c51d16287f4734a74cb64a46d33d3b1126fcc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5c51d16287f4734a74cb64a46d33d3b1126fcc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d626f94a57abb404b6693538471d92977a97567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d626f94a57abb404b6693538471d92977a97567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d626f94a57abb404b6693538471d92977a97567", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d626f94a57abb404b6693538471d92977a97567/comments", "author": null, "committer": null, "parents": [{"sha": "cce309d7ed3fb81d6b587ae06dfb9561039fb8ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce309d7ed3fb81d6b587ae06dfb9561039fb8ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce309d7ed3fb81d6b587ae06dfb9561039fb8ad"}], "stats": {"total": 93, "additions": 43, "deletions": 50}, "files": [{"sha": "ca337e7bf321206182ab8e1366af3157360236a9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d626f94a57abb404b6693538471d92977a97567/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d626f94a57abb404b6693538471d92977a97567/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3d626f94a57abb404b6693538471d92977a97567", "patch": "@@ -1,3 +1,11 @@\n+2016-05-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* freeze.adb (Freeze_Array_Type): Call Addressable predicate instead\n+\tof testing for individual sizes.\n+\t(Freeze_Entity): Rework implementation of pragma Implicit_Packing for\n+\tarray types, in particular test for suitable sizes upfront and do not\n+\tmimic the processing that will be redone later in Freeze_Array_Type.\n+\n 2016-05-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (elaborate_all_entities_for_package): Also skip"}, {"sha": "2a021e25cf19ccf53735c8bb56f651c47b9abf1f", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d626f94a57abb404b6693538471d92977a97567/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d626f94a57abb404b6693538471d92977a97567/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3d626f94a57abb404b6693538471d92977a97567", "patch": "@@ -2453,11 +2453,7 @@ package body Freeze is\n \n                      --  Bit packing is never needed for 8, 16, 32, 64\n \n-                     if        Csiz = 8\n-                       or else Csiz = 16\n-                       or else Csiz = 32\n-                       or else Csiz = 64\n-                     then\n+                     if Addressable (Csiz) then\n                         --  If the Esize of the component is known and equal to\n                         --  the component size then even packing is not needed.\n \n@@ -5295,20 +5291,20 @@ package body Freeze is\n \n          if E /= Base_Type (E) then\n \n-            --  Before we do anything else, a specialized test for the case of\n-            --  a size given for an array where the array needs to be packed,\n-            --  but was not so the size cannot be honored. This is the case\n-            --  where implicit packing may apply. The reason we do this so\n-            --  early is that if we have implicit packing, the layout of the\n-            --  base type is affected, so we must do this before we freeze\n-            --  the base type.\n+            --  Before we do anything else, a specific test for the case of a\n+            --  size given for an array where the array would need to be packed\n+            --  in order for the size to be honored, but is not. This is the\n+            --  case where implicit packing may apply. The reason we do this so\n+            --  early is that, if we have implicit packing, the layout of the\n+            --  base type is affected, so we must do this before we freeze the\n+            --  base type.\n \n             --  We could do this processing only if implicit packing is enabled\n             --  since in all other cases, the error would be caught by the back\n             --  end. However, we choose to do the check even if we do not have\n             --  implicit packing enabled, since this allows us to give a more\n-            --  useful error message (advising use of pragmas Implicit_Packing\n-            --  or Pack).\n+            --  useful error message (advising use of pragma Implicit_Packing\n+            --  or pragma Pack).\n \n             if Is_Array_Type (E) then\n                declare\n@@ -5321,7 +5317,8 @@ package body Freeze is\n                   Hi   : Node_Id;\n                   Indx : Node_Id;\n \n-                  Num_Elmts : Uint;\n+                  Dim       : Uint;\n+                  Num_Elmts : Uint := Uint_1;\n                   --  Number of elements in array\n \n                begin\n@@ -5337,21 +5334,28 @@ package body Freeze is\n                   --  a chance to freeze the base type (and it is that freeze\n                   --  action that causes stuff to be inherited).\n \n+                  --  The conditions on the size are identical to those used in\n+                  --  Freeze_Array_Type to set the Is_Packed flag.\n+\n                   if Has_Size_Clause (E)\n                     and then Known_Static_RM_Size (E)\n                     and then not Is_Packed (E)\n                     and then not Has_Pragma_Pack (E)\n                     and then not Has_Component_Size_Clause (E)\n                     and then Known_Static_RM_Size (Ctyp)\n-                    and then RM_Size (Ctyp) < 64\n+                    and then Rsiz <= 64\n+                    and then not (Addressable (Rsiz)\n+                                   and then Known_Static_Esize (Ctyp)\n+                                   and then Esize (Ctyp) = Rsiz)\n+                    and then not (Rsiz mod System_Storage_Unit = 0\n+                                   and then Is_Composite_Type (Ctyp))\n                     and then not Is_Limited_Composite (E)\n                     and then not Is_Packed (Root_Type (E))\n                     and then not Has_Component_Size_Clause (Root_Type (E))\n                     and then not (CodePeer_Mode or GNATprove_Mode)\n                   then\n                      --  Compute number of elements in array\n \n-                     Num_Elmts := Uint_1;\n                      Indx := First_Index (E);\n                      while Present (Indx) loop\n                         Get_Index_Bounds (Indx, Lo, Hi);\n@@ -5363,33 +5367,28 @@ package body Freeze is\n                            goto No_Implicit_Packing;\n                         end if;\n \n-                        Num_Elmts :=\n-                          Num_Elmts *\n-                            UI_Max (Uint_0,\n-                                    Expr_Value (Hi) - Expr_Value (Lo) + 1);\n+                        Dim := Expr_Value (Hi) - Expr_Value (Lo) + 1;\n+\n+                        if Dim >= 0 then\n+                           Num_Elmts := Num_Elmts * Dim;\n+                        else\n+                           Num_Elmts := Uint_0;\n+                        end if;\n+\n                         Next_Index (Indx);\n                      end loop;\n \n                      --  What we are looking for here is the situation where\n                      --  the RM_Size given would be exactly right if there was\n-                     --  a pragma Pack (resulting in the component size being\n-                     --  the same as the RM_Size). Furthermore, the component\n-                     --  type size must be an odd size (not a multiple of\n-                     --  storage unit). If the component RM size is an exact\n-                     --  number of storage units that is a power of two, the\n-                     --  array is not packed and has a standard representation.\n-\n-                     if RM_Size (E) = Num_Elmts * Rsiz\n-                       and then Rsiz mod System_Storage_Unit /= 0\n-                     then\n+                     --  a pragma Pack, resulting in the component size being\n+                     --  the RM_Size of the component type.\n+\n+                     if RM_Size (E) = Num_Elmts * Rsiz then\n                         --  For implicit packing mode, just set the component\n-                        --  size silently.\n+                        --  size and Freeze_Array_Type will do the rest.\n \n                         if Implicit_Packing then\n-                           Set_Component_Size       (Btyp, Rsiz);\n-                           Set_Is_Bit_Packed_Array  (Btyp);\n-                           Set_Is_Packed            (Btyp);\n-                           Set_Has_Non_Standard_Rep (Btyp);\n+                           Set_Component_Size (Btyp, Rsiz);\n \n                            --  Otherwise give an error message\n \n@@ -5400,20 +5399,6 @@ package body Freeze is\n                              (\"\\use explicit pragma Pack \"\n                               & \"or use pragma Implicit_Packing\", SZ);\n                         end if;\n-\n-                     elsif RM_Size (E) = Num_Elmts * Rsiz\n-                       and then Implicit_Packing\n-                       and then\n-                         (Rsiz / System_Storage_Unit = 1\n-                            or else\n-                          Rsiz / System_Storage_Unit = 2\n-                            or else\n-                          Rsiz / System_Storage_Unit = 4)\n-                     then\n-                        --  Not a packed array, but indicate the desired\n-                        --  component size, for the back-end.\n-\n-                        Set_Component_Size (Btyp, Rsiz);\n                      end if;\n                   end if;\n                end;"}]}