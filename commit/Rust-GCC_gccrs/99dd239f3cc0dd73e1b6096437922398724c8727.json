{"sha": "99dd239f3cc0dd73e1b6096437922398724c8727", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlkZDIzOWYzY2MwZGQ3M2UxYjYwOTY0Mzc5MjIzOTg3MjRjODcyNw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-07-25T17:19:39Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-07-25T17:19:39Z"}, "message": "cp-tree.h (TYPE_SET_PTRMEMFUNC_TYPE): Use GGC_CNEW.\n\n        * cp-tree.h (TYPE_SET_PTRMEMFUNC_TYPE): Use GGC_CNEW.\n        * typeck2.c (abstract_virtuals_error): Use GGC_NEW.\n        * name-lookup.c (binding_entry_make): Use GGC_NEW.\n        (binding_table_construct): Use GGC_CNEWVEC.\n        (binding_table_new): Use GGC_NEW.\n        (cxx_binding_make): Likewise.\n        (begin_scope): Likewise.\n        (push_to_top_level): Use GCC_CNEW.\n        * parser.c (cp_token_cache_new): Likewise.\n        (cp_token_cache_push_token): Likewise.\n        (cp_lexer_new_main): Likewise.\n        (cp_lexer_new_from_tokens): Likewise.\n        (cp_parser_context_new): Likewise.\n        (cp_parser_new): Likewise.\n        (cp_lexer_new_from_tokens): Use GGC_NEWVEC.\n        * lex.c (cxx_make_type): Use GGC_CNEW.\n        (retrofit_lang_decl): Use GGC_NEWVAR.\n        (cxx_dup_lang_specific_decl): Likewise.\n        (copy_lang_type): Likewise.\n        * decl.c (use_label): Use GGC_NEW instead of ggc_alloc.\n        (save_function_data): Likewise.\n        (lookup_label): Use GGC_CNEW instead of ggc_alloc_cleared.\n        (cxx_push_function_context): Likewise.\n\nFrom-SVN: r85150", "tree": {"sha": "1861ec0739680328c7b59c570b800a14d2d2c24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1861ec0739680328c7b59c570b800a14d2d2c24c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99dd239f3cc0dd73e1b6096437922398724c8727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99dd239f3cc0dd73e1b6096437922398724c8727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99dd239f3cc0dd73e1b6096437922398724c8727", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99dd239f3cc0dd73e1b6096437922398724c8727/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97b69e514a011eb1c529281c355d61399956edb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b69e514a011eb1c529281c355d61399956edb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b69e514a011eb1c529281c355d61399956edb4"}], "stats": {"total": 83, "additions": 53, "deletions": 30}, "files": [{"sha": "5fed73427cffb9905af94878aacd102c633a51a4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -1,3 +1,29 @@\n+2004-07-25  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cp-tree.h (TYPE_SET_PTRMEMFUNC_TYPE): Use GGC_CNEW.\n+\t* typeck2.c (abstract_virtuals_error): Use GGC_NEW.\n+\t* name-lookup.c (binding_entry_make): Use GGC_NEW.\n+\t(binding_table_construct): Use GGC_CNEWVEC.\n+\t(binding_table_new): Use GGC_NEW.\n+\t(cxx_binding_make): Likewise.\n+\t(begin_scope): Likewise.\n+\t(push_to_top_level): Use GCC_CNEW.\n+\t* parser.c (cp_token_cache_new): Likewise.\n+\t(cp_token_cache_push_token): Likewise.\n+\t(cp_lexer_new_main): Likewise.\n+\t(cp_lexer_new_from_tokens): Likewise.\n+\t(cp_parser_context_new): Likewise.\n+\t(cp_parser_new): Likewise.\n+\t(cp_lexer_new_from_tokens): Use GGC_NEWVEC.\n+\t* lex.c (cxx_make_type): Use GGC_CNEW.\n+\t(retrofit_lang_decl): Use GGC_NEWVAR.\n+\t(cxx_dup_lang_specific_decl): Likewise.\n+\t(copy_lang_type): Likewise.\n+\t* decl.c (use_label): Use GGC_NEW instead of ggc_alloc.\n+\t(save_function_data): Likewise.\n+\t(lookup_label): Use GGC_CNEW instead of ggc_alloc_cleared.\n+\t(cxx_push_function_context): Likewise.\n+\n 2004-07-25  Richard Henderson  <rth@redhat.com>\n \n \t* decl.c (start_preparsed_function): Set DECL_ARTIFICIAL and"}, {"sha": "6c0988c09098bc34965bd632b1824d99607af060", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -5014,8 +5014,9 @@ finish_struct_1 (tree t)\n   n_fields = count_fields (TYPE_FIELDS (t));\n   if (n_fields > 7)\n     {\n-      struct sorted_fields_type *field_vec = ggc_alloc (sizeof (struct sorted_fields_type) \n-\t+ n_fields * sizeof (tree));\n+      struct sorted_fields_type *field_vec = GGC_NEWVAR\n+         (struct sorted_fields_type,\n+          sizeof (struct sorted_fields_type) + n_fields * sizeof (tree));\n       field_vec->len = n_fields;\n       add_fields_to_record_type (TYPE_FIELDS (t), field_vec, 0);\n       qsort (field_vec->elts, n_fields, sizeof (tree),"}, {"sha": "28aed6ad2f5e3fbebd56242de312b8e6769a7174", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -2448,8 +2448,8 @@ struct lang_decl GTY(())\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (TYPE_LANG_SPECIFIC (NODE) == NULL)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tTYPE_LANG_SPECIFIC (NODE) = \t\t\t\t\t\\\n-\t  ggc_alloc_cleared (sizeof (struct lang_type_ptrmem));\t\t\\\n+\tTYPE_LANG_SPECIFIC (NODE) = GGC_CNEWVAR                         \\\n+         (struct lang_type, sizeof (struct lang_type_ptrmem));\t\\\n \tTYPE_LANG_SPECIFIC (NODE)->u.ptrmem.h.is_lang_type_class = 0;\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     TYPE_LANG_SPECIFIC (NODE)->u.ptrmem.record = (VALUE);\t\t\\"}, {"sha": "427d5c554f16d976b20b046b2031c6ec0642b53d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -2073,7 +2073,7 @@ use_label (tree decl)\n       || named_label_uses->label_decl != decl)\n     {\n       struct named_label_use_list *new_ent;\n-      new_ent = ggc_alloc (sizeof (struct named_label_use_list));\n+      new_ent = GGC_NEW (struct named_label_use_list);\n       new_ent->label_decl = decl;\n       new_ent->names_in_scope = current_binding_level->names;\n       new_ent->binding_level = current_binding_level;\n@@ -2109,7 +2109,7 @@ lookup_label (tree id)\n   /* Record this label on the list of labels used in this function.\n      We do this before calling make_label_decl so that we get the\n      IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n-  ent = ggc_alloc_cleared (sizeof (struct named_label_list));\n+  ent = GGC_CNEW (struct named_label_list);\n   ent->old_value = IDENTIFIER_LABEL_VALUE (id);\n   ent->next = named_labels;\n   named_labels = ent;\n@@ -10025,7 +10025,7 @@ save_function_data (tree decl)\n \t\t      19990908);\n \n   /* Make a copy.  */\n-  f = ggc_alloc (sizeof (struct language_function));\n+  f = GGC_NEW (struct language_function);\n   memcpy (f, cp_function_chain, sizeof (struct language_function));\n   DECL_SAVED_FUNCTION_DATA (decl) = f;\n \n@@ -10672,8 +10672,7 @@ revert_static_member_fn (tree decl)\n void\n cxx_push_function_context (struct function * f)\n {\n-  struct language_function *p\n-    = ggc_alloc_cleared (sizeof (struct language_function));\n+  struct language_function *p = GGC_CNEW (struct language_function);\n   f->language = p;\n \n   /* Whenever we start a new function, we destroy temporaries in the"}, {"sha": "c5b14460b94b8f79688677595e5ea5da981fa073", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -654,7 +654,7 @@ retrofit_lang_decl (tree t)\n   else\n     size = sizeof (struct lang_decl_flags);\n \n-  ld = ggc_alloc_cleared (size);\n+  ld = GGC_CNEWVAR (struct lang_decl, size);\n \n   ld->decl_flags.can_be_full = CAN_HAVE_FULL_LANG_DECL_P (t) ? 1 : 0;\n   ld->decl_flags.u1sel = TREE_CODE (t) == NAMESPACE_DECL ? 1 : 0;\n@@ -691,7 +691,7 @@ cxx_dup_lang_specific_decl (tree node)\n     size = sizeof (struct lang_decl_flags);\n   else\n     size = sizeof (struct lang_decl);\n-  ld = ggc_alloc (size);\n+  ld = GGC_NEWVAR (struct lang_decl, size);\n   memcpy (ld, DECL_LANG_SPECIFIC (node), size);\n   DECL_LANG_SPECIFIC (node) = ld;\n \n@@ -728,7 +728,7 @@ copy_lang_type (tree node)\n     size = sizeof (struct lang_type);\n   else\n     size = sizeof (struct lang_type_ptrmem);\n-  lt = ggc_alloc (size);\n+  lt = GGC_NEWVAR (struct lang_type, size);\n   memcpy (lt, TYPE_LANG_SPECIFIC (node), size);\n   TYPE_LANG_SPECIFIC (node) = lt;\n \n@@ -759,9 +759,7 @@ cxx_make_type (enum tree_code code)\n   if (IS_AGGR_TYPE_CODE (code)\n       || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n-      struct lang_type *pi;\n-\n-      pi = ggc_alloc_cleared (sizeof (struct lang_type));\n+      struct lang_type *pi = GGC_CNEW (struct lang_type);\n \n       TYPE_LANG_SPECIFIC (t) = pi;\n       pi->u.c.h.is_lang_type_class = 1;"}, {"sha": "8c36fe8bd0ec37693a51b499bbb7582a356d5c43", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -85,7 +85,7 @@ binding_entry_make (tree name, tree type)\n       free_binding_entry = entry->chain;\n     }\n   else\n-    entry = ggc_alloc (sizeof (struct binding_entry_s));\n+    entry = GGC_NEW (struct binding_entry_s);\n \n   entry->name = name;\n   entry->type = type;\n@@ -127,8 +127,7 @@ binding_table_construct (binding_table table, size_t chain_count)\n {\n   table->chain_count = chain_count;\n   table->entry_count = 0;\n-  table->chain = ggc_alloc_cleared\n-    (table->chain_count * sizeof (binding_entry));\n+  table->chain = GGC_CNEWVEC (binding_entry, table->chain_count);\n }\n \n /* Make TABLE's entries ready for reuse.  */\n@@ -161,7 +160,7 @@ binding_table_free (binding_table table)\n static inline binding_table\n binding_table_new (size_t chain_count)\n {\n-  binding_table table = ggc_alloc (sizeof (struct binding_table_s));\n+  binding_table table = GGC_NEW (struct binding_table_s);\n   table->chain = NULL;\n   binding_table_construct (table, chain_count);\n   return table;\n@@ -351,7 +350,7 @@ cxx_binding_make (tree value, tree type)\n       free_bindings = binding->previous;\n     }\n   else\n-    binding = ggc_alloc (sizeof (cxx_binding));\n+    binding = GGC_NEW (cxx_binding);\n \n   cxx_binding_init (binding, value, type);\n \n@@ -1309,7 +1308,7 @@ begin_scope (scope_kind kind, tree entity)\n       free_binding_level = scope->level_chain;\n     }\n   else\n-    scope = ggc_alloc (sizeof (cxx_scope));\n+    scope = GGC_NEW (cxx_scope);\n   memset (scope, 0, sizeof (cxx_scope));\n \n   scope->this_entity = entity;\n@@ -4941,7 +4940,7 @@ push_to_top_level (void)\n   int need_pop;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  s = ggc_alloc_cleared (sizeof (struct saved_scope));\n+  s = GGC_CNEW (struct saved_scope);\n \n   b = scope_chain ? current_binding_level : 0;\n "}, {"sha": "f19ab252e27d28924a3c2a667646b59761643bb2", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -131,7 +131,7 @@ static void cp_token_cache_push_token\n static cp_token_cache *\n cp_token_cache_new (void)\n {\n-  return ggc_alloc_cleared (sizeof (cp_token_cache));\n+  return GGC_CNEW (cp_token_cache);\n }\n \n /* Add *TOKEN to *CACHE.  */\n@@ -145,7 +145,7 @@ cp_token_cache_push_token (cp_token_cache *cache,\n   /* See if we need to allocate a new token block.  */\n   if (!b || b->num_tokens == CP_TOKEN_BLOCK_NUM_TOKENS)\n     {\n-      b = ggc_alloc_cleared (sizeof (cp_token_block));\n+      b = GGC_CNEW (cp_token_block);\n       b->prev = cache->last;\n       if (cache->last)\n \t{\n@@ -311,7 +311,7 @@ cp_lexer_new_main (void)\n   c_common_no_more_pch ();\n \n   /* Allocate the memory.  */\n-  lexer = ggc_alloc_cleared (sizeof (cp_lexer));\n+  lexer = GGC_CNEW (cp_lexer);\n \n   /* Create the circular buffer.  */\n   lexer->buffer = ggc_calloc (CP_TOKEN_BUFFER_SIZE, sizeof (cp_token));\n@@ -350,13 +350,13 @@ cp_lexer_new_from_tokens (cp_token_cache *tokens)\n   ptrdiff_t num_tokens;\n \n   /* Allocate the memory.  */\n-  lexer = ggc_alloc_cleared (sizeof (cp_lexer));\n+  lexer = GGC_CNEW (cp_lexer);\n \n   /* Create a new buffer, appropriately sized.  */\n   num_tokens = 0;\n   for (block = tokens->first; block != NULL; block = block->next)\n     num_tokens += block->num_tokens;\n-  lexer->buffer = ggc_alloc (num_tokens * sizeof (cp_token));\n+  lexer->buffer = GGC_NEWVEC (cp_token, num_tokens);\n   lexer->buffer_end = lexer->buffer + num_tokens;\n \n   /* Install the tokens.  */\n@@ -1348,7 +1348,7 @@ cp_parser_context_new (cp_parser_context* next)\n       memset (context, 0, sizeof (*context));\n     }\n   else\n-    context = ggc_alloc_cleared (sizeof (cp_parser_context));\n+    context = GGC_CNEW (cp_parser_context);\n   /* No errors have occurred yet in this context.  */\n   context->status = CP_PARSER_STATUS_KIND_NO_ERROR;\n   /* If this is not the bottomost context, copy information that we\n@@ -2539,7 +2539,7 @@ cp_parser_new (void)\n      cp_lexer_new_main might load a PCH file.  */\n   lexer = cp_lexer_new_main ();\n \n-  parser = ggc_alloc_cleared (sizeof (cp_parser));\n+  parser = GGC_CNEW (cp_parser);\n   parser->lexer = lexer;\n   parser->context = cp_parser_context_new (NULL);\n "}, {"sha": "3c018285fc182315c9fa9f9916a9d6e8fc02724e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dd239f3cc0dd73e1b6096437922398724c8727/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=99dd239f3cc0dd73e1b6096437922398724c8727", "patch": "@@ -263,7 +263,7 @@ abstract_virtuals_error (tree decl, tree type)\n       slot = htab_find_slot_with_hash (abstract_pending_vars, type,\n \t\t\t\t      (hashval_t)TYPE_UID (type), INSERT);\n \n-      pat = ggc_alloc (sizeof (struct pending_abstract_type));\n+      pat = GGC_NEW (struct pending_abstract_type);\n       pat->type = type;\n       pat->decl = decl;\n       pat->locus = ((decl && DECL_P (decl))"}]}