{"sha": "6fd5ac08f27178e29e89f34990357c3d4ec85a1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZkNWFjMDhmMjcxNzhlMjllODlmMzQ5OTAzNTdjM2Q0ZWM4NWExYg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-17T01:04:32Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-17T01:04:32Z"}, "message": "(push_reload): Add extra reload for inside of SUBREG if\nit is CONSTANT_P.\n\nFrom-SVN: r11833", "tree": {"sha": "d66f2e41899baaafde352dc4c7561c460b222169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d66f2e41899baaafde352dc4c7561c460b222169"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fd5ac08f27178e29e89f34990357c3d4ec85a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd5ac08f27178e29e89f34990357c3d4ec85a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd5ac08f27178e29e89f34990357c3d4ec85a1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd5ac08f27178e29e89f34990357c3d4ec85a1b/comments", "author": null, "committer": null, "parents": [{"sha": "8b295000784bf5c967a00c38cc2bedef5a00772b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b295000784bf5c967a00c38cc2bedef5a00772b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b295000784bf5c967a00c38cc2bedef5a00772b"}], "stats": {"total": 36, "additions": 22, "deletions": 14}, "files": [{"sha": "72887930604d7a0f7b011aa2659e161ce85267be", "filename": "gcc/reload.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fd5ac08f27178e29e89f34990357c3d4ec85a1b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fd5ac08f27178e29e89f34990357c3d4ec85a1b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6fd5ac08f27178e29e89f34990357c3d4ec85a1b", "patch": "@@ -926,18 +926,23 @@ push_reload (in, out, inloc, outloc, class,\n      However, we must reload the inner reg *as well as* the subreg in\n      that case.  */\n \n+  /* Similar issue for (SUBREG constant ...) if it was not handled by the\n+     code above.  This can happen if SUBREG_WORD != 0.  */\n+\n   if (in != 0 && GET_CODE (in) == SUBREG\n-      && GET_CODE (SUBREG_REG (in)) == REG\n-      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n-      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in)) + SUBREG_WORD (in),\n-\t\t\t\tinmode)\n-\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n-\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t  > UNITS_PER_WORD)\n-\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t   / UNITS_PER_WORD)\n-\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n-\t\t\t\t       GET_MODE (SUBREG_REG (in)))))))\n+      && (CONSTANT_P (SUBREG_REG (in))\n+\t  || (GET_CODE (SUBREG_REG (in)) == REG\n+\t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n+\t      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in))\n+\t\t\t\t\t+ SUBREG_WORD (in),\n+\t\t\t\t\tinmode)\n+\t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n+\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n+\t\t\t  > UNITS_PER_WORD)\n+\t\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n+\t\t\t   / UNITS_PER_WORD)\n+\t\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n+\t\t\t\t\t       GET_MODE (SUBREG_REG (in)))))))))\n     {\n       /* This relies on the fact that emit_reload_insns outputs the\n \t instructions for input reloads of type RELOAD_OTHER in the same\n@@ -950,7 +955,6 @@ push_reload (in, out, inloc, outloc, class,\n       dont_remove_subreg = 1;\n     }\n \n-\n   /* Similarly for paradoxical and problematical SUBREGs on the output.\n      Note that there is no reason we need worry about the previous value\n      of SUBREG_REG (out); even if wider than out,\n@@ -1271,9 +1275,13 @@ push_reload (in, out, inloc, outloc, class,\n \t For example, we may now have both IN and OUT\n \t while the old one may have just one of them.  */\n \n-      if (inmode != VOIDmode)\n+      /* The modes can be different.  If they are, we want to reload in\n+\t the larger mode, so that the value is valid for both modes.  */\n+      if (inmode != VOIDmode\n+\t  && GET_MODE_SIZE (inmode) > GET_MODE_SIZE (reload_inmode[i]))\n \treload_inmode[i] = inmode;\n-      if (outmode != VOIDmode)\n+      if (outmode != VOIDmode\n+\t  && GET_MODE_SIZE (outmode) > GET_MODE_SIZE (reload_outmode[i]))\n \treload_outmode[i] = outmode;\n       if (in != 0)\n \treload_in[i] = in;"}]}