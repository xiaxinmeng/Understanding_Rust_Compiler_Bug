{"sha": "29dc5138c3af990d84d312ac52954021b0ac8c3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkYzUxMzhjM2FmOTkwZDg0ZDMxMmFjNTI5NTQwMjFiMGFjOGMzYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-04-17T20:09:37Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-04-17T20:09:37Z"}, "message": "re PR fortran/17472 ([4.0 only] namelist does not handle arrays)\n\n-------------------------------------------------------------------\n\nFrom-SVN: r98287", "tree": {"sha": "d9306eebf9c2dd03d14aa1b070d6756da7970d6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9306eebf9c2dd03d14aa1b070d6756da7970d6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29dc5138c3af990d84d312ac52954021b0ac8c3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29dc5138c3af990d84d312ac52954021b0ac8c3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29dc5138c3af990d84d312ac52954021b0ac8c3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29dc5138c3af990d84d312ac52954021b0ac8c3c/comments", "author": null, "committer": null, "parents": [{"sha": "3f620b5f2ba5930bf574d0b005078f1f7e8497ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f620b5f2ba5930bf574d0b005078f1f7e8497ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f620b5f2ba5930bf574d0b005078f1f7e8497ae"}], "stats": {"total": 2831, "additions": 2432, "deletions": 399}, "files": [{"sha": "3fb03c3479f1958a8d97f46becbb01e22e0e0163", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,3 +1,19 @@\n+2005-04-17 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/17472\n+\tPR fortran/18209\n+\tPR fortran/18396\n+\tPR fortran/19467\n+\tPR fortran/19657\n+\t* fortran/trans-io.c (gfc_build_io_library_fndecls): Create declaration for\n+\tst_set_nml_var and st_set_nml_var_dim. Remove declarations of old\n+\tnamelist functions.\n+\t(build_dt): Simplified call to transfer_namelist_element.\n+\t(nml_get_addr_expr): Generates address expression for start of object data. New function.\n+\t(nml_full_name): Qualified name for derived type components. New function.\n+\t(transfer_namelist_element): Modified for calls to new functions and improved derived\n+\ttype handling.\n+\n 2005-04-17  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* scanner.c (gfc_next_char_literal): Reset truncation flag"}, {"sha": "8701d5ebee1581856323e6c109c8051a1cbc0ac4", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 225, "deletions": 139, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -125,11 +125,8 @@ static GTY(()) tree iocall_iolength_done;\n static GTY(()) tree iocall_rewind;\n static GTY(()) tree iocall_backspace;\n static GTY(()) tree iocall_endfile;\n-static GTY(()) tree iocall_set_nml_val_int;\n-static GTY(()) tree iocall_set_nml_val_float;\n-static GTY(()) tree iocall_set_nml_val_char;\n-static GTY(()) tree iocall_set_nml_val_complex;\n-static GTY(()) tree iocall_set_nml_val_log;\n+static GTY(()) tree iocall_set_nml_val;\n+static GTY(()) tree iocall_set_nml_val_dim;\n \n /* Variable for keeping track of what the last data transfer statement\n    was.  Used for deciding which subroutine to call when the data\n@@ -314,34 +311,19 @@ gfc_build_io_library_fndecls (void)\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_iolength_done\")),\n \t\t\t\t     gfc_int4_type_node, 0);\n \n-  iocall_set_nml_val_int =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_int\")),\n-                                     void_type_node, 4,\n-                                     pvoid_type_node, pvoid_type_node,\n-                                     gfc_int4_type_node,gfc_int4_type_node);\n \n-  iocall_set_nml_val_float =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_float\")),\n-                                     void_type_node, 4,\n-                                     pvoid_type_node, pvoid_type_node,\n-                                     gfc_int4_type_node,gfc_int4_type_node);\n-  iocall_set_nml_val_char =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_char\")),\n+  iocall_set_nml_val =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var\")),\n                                      void_type_node, 5,\n                                      pvoid_type_node, pvoid_type_node,\n-                                     gfc_int4_type_node, gfc_int4_type_node, \n-                                     gfc_charlen_type_node);\n-  iocall_set_nml_val_complex =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_complex\")),\n-                                     void_type_node, 4,\n-                                     pvoid_type_node, pvoid_type_node,\n-                                     gfc_int4_type_node,gfc_int4_type_node);\n-  iocall_set_nml_val_log =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_log\")),\n-                                     void_type_node, 4,\n-                                     pvoid_type_node, pvoid_type_node,\n-                                     gfc_int4_type_node,gfc_int4_type_node);\n+                                     gfc_int4_type_node, gfc_charlen_type_node, \n+\t\t\t\t     gfc_int4_type_node);\n \n+  iocall_set_nml_val_dim =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_dim\")),\n+\t\t\t\t     void_type_node, 4,\n+\t\t\t\t     gfc_int4_type_node, gfc_int4_type_node,\n+\t\t\t\t     gfc_int4_type_node, gfc_int4_type_node);\n }\n \n \n@@ -815,11 +797,11 @@ gfc_trans_inquire (gfc_code * code)\n   return gfc_finish_block (&block);\n }\n \n-\n static gfc_expr *\n gfc_new_nml_name_expr (const char * name)\n {\n    gfc_expr * nml_name;\n+\n    nml_name = gfc_get_expr();\n    nml_name->ref = NULL;\n    nml_name->expr_type = EXPR_CONSTANT;\n@@ -832,114 +814,229 @@ gfc_new_nml_name_expr (const char * name)\n    return nml_name;\n }\n \n-static gfc_expr *\n-get_new_var_expr(gfc_symbol * sym)\n+/* nml_full_name builds up the fully qualified name of a\n+   derived type component. */\n+\n+static char*\n+nml_full_name (const char* var_name, const char* cmp_name)\n {\n-  gfc_expr * nml_var;\n-\n-  nml_var = gfc_get_expr();\n-  nml_var->expr_type = EXPR_VARIABLE;\n-  nml_var->ts = sym->ts;\n-  if (sym->as)\n-    nml_var->rank = sym->as->rank;\n-  nml_var->symtree = (gfc_symtree *)gfc_getmem (sizeof (gfc_symtree));\n-  nml_var->symtree->n.sym = sym;\n-  nml_var->where = sym->declared_at;\n-  sym->attr.referenced = 1;\n-\n-  return nml_var;\n+  int full_name_length;\n+  char * full_name;\n+\n+  full_name_length = strlen (var_name) + strlen (cmp_name) + 1;\n+  full_name = (char*)gfc_getmem (full_name_length + 1);\n+  strcpy (full_name, var_name);\n+  full_name = strcat (full_name, \"%\");\n+  full_name = strcat (full_name, cmp_name);\n+  return full_name;\n }\n \n-/* For a scalar variable STRING whose address is ADDR_EXPR, generate a\n-   call to iocall_set_nml_val.  For derived type variable, recursively\n-   generate calls to iocall_set_nml_val for each leaf field. The leafs\n-   have no names -- their STRING field is null, and are interpreted by\n-   the run-time library as having only the value, as in the example:\n+/* nml_get_addr_expr builds an address expression from the\n+   gfc_symbol or gfc_component backend_decl's. An offset is\n+   provided so that the address of an element of an array of\n+   derived types is returned. This is used in the runtime to\n+   determine that span of the derived type. */\n+\n+static tree\n+nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n+\t\t   tree base_addr)\n+{\n+  tree decl = NULL_TREE;\n+  tree tmp;\n+  tree itmp;\n+  int array_flagged;\n+  int dummy_arg_flagged;\n+\n+  if (sym)\n+    {\n+      sym->attr.referenced = 1;\n+      decl = gfc_get_symbol_decl (sym);\n+    }\n+  else\n+    decl = c->backend_decl;\n+\n+  gcc_assert (decl && ((TREE_CODE (decl) == FIELD_DECL\n+\t\t     || TREE_CODE (decl) == VAR_DECL\n+\t\t     || TREE_CODE (decl) == PARM_DECL)\n+\t\t     || TREE_CODE (decl) == COMPONENT_REF));\n+\n+  tmp = decl;\n+\n+  /* Build indirect reference, if dummy argument.  */\n+\n+  dummy_arg_flagged = POINTER_TYPE_P (TREE_TYPE(tmp));\n \n-   &foo bzz=1,2,3,4,5/\n+  itmp = (dummy_arg_flagged) ? gfc_build_indirect_ref (tmp) : tmp;\n \n-   Note that the first output field appears after the name of the\n-   variable, not of the field name.  This causes a little complication\n-   documented below.  */\n+  /* If an array, set flag and use indirect ref. if built.  */\n+\n+  array_flagged = (TREE_CODE (TREE_TYPE (itmp)) == ARRAY_TYPE\n+\t\t   && !TYPE_STRING_FLAG (TREE_TYPE (itmp)));\n+\n+  if (array_flagged)\n+    tmp = itmp;\n+\n+  /* Treat the component of a derived type, using base_addr for\n+     the derived type.  */\n+\n+  if (TREE_CODE (decl) == FIELD_DECL)\n+    tmp = build3 (COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t  base_addr, tmp, NULL_TREE);\n+\n+  /* If we have a derived type component, a reference to the first\n+     element of the array is built.  This is done so that base_addr,\n+     used in the build of the component reference, always points to\n+     a RECORD_TYPE.  */\n+\n+  if (array_flagged)\n+    tmp = gfc_build_array_ref (tmp, gfc_index_zero_node);\n+\n+  /* Now build the address expression.  */\n+\n+  tmp = gfc_build_addr_expr (NULL, tmp);\n+\n+  /* If scalar dummy, resolve indirect reference now.  */\n+\n+  if (dummy_arg_flagged && !array_flagged)\n+    tmp = gfc_build_indirect_ref (tmp);\n+\n+  gcc_assert (tmp && POINTER_TYPE_P (TREE_TYPE (tmp)));\n+\n+  return tmp;\n+}\n+\n+/* For an object VAR_NAME whose base address is BASE_ADDR, generate a\n+   call to iocall_set_nml_val.  For derived type variable, recursively\n+   generate calls to iocall_set_nml_val for each component.  */\n+\n+#define NML_FIRST_ARG(a) args = gfc_chainon_list (NULL_TREE, a)\n+#define NML_ADD_ARG(a) args = gfc_chainon_list (args, a)\n+#define IARG(i) build_int_cst (gfc_array_index_type, i)\n \n static void\n-transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_expr, \n-                           tree string, tree string_length)\n+transfer_namelist_element (stmtblock_t * block, const char * var_name,\n+\t\t\t   gfc_symbol * sym, gfc_component * c,\n+\t\t\t   tree base_addr)\n {\n-  tree tmp, args, arg2;\n-  tree expr;\n+  gfc_typespec * ts = NULL;\n+  gfc_array_spec * as = NULL;\n+  tree addr_expr = NULL;\n+  tree dt = NULL;\n+  tree string;\n+  tree tmp;\n+  tree args;\n+  tree dtype;\n+  int n_dim; \n+  int itype;\n+  int rank = 0;\n \n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (addr_expr)));\n+  gcc_assert (sym || c);\n \n-  if (ts->type == BT_DERIVED)\n-    {\n-      gfc_component *c;\n-      expr = gfc_build_indirect_ref (addr_expr);\n+  /* Build the namelist object name.  */\n \n-      for (c = ts->derived->components; c; c = c->next)\n-        {\n-          tree field = c->backend_decl;\n-          gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n-          tmp = build3 (COMPONENT_REF, TREE_TYPE (field), \n-\t\t\texpr, field, NULL_TREE);\n+  string = gfc_build_cstring_const (var_name);\n+  string = gfc_build_addr_expr (pchar_type_node, string);\n \n-          if (c->dimension)\n-            gfc_todo_error (\"NAMELIST IO of array in derived type\");\n-          if (!c->pointer)\n-            tmp = gfc_build_addr_expr (NULL, tmp);\n-          transfer_namelist_element (block, &c->ts, tmp, string, string_length);\n-\n-          /* The first output field bears the name of the topmost\n-             derived type variable.  All other fields are anonymous\n-             and appear with nulls in their string and string_length\n-             fields.  After the first use, we set string and\n-             string_length to null.  */\n-          string = null_pointer_node;\n-          string_length = integer_zero_node;\n-        }\n+  /* Build ts, as and data address using symbol or component.  */\n \n-      return;\n-    }\n+  ts = (sym) ? &sym->ts : &c->ts;\n+  as = (sym) ? sym->as : c->as;\n \n-  args = gfc_chainon_list (NULL_TREE, addr_expr);\n-  args = gfc_chainon_list (args, string);\n-  args = gfc_chainon_list (args, string_length);\n-  arg2 = build_int_cst (gfc_array_index_type, ts->kind);\n-  args = gfc_chainon_list (args,arg2);\n+  addr_expr = nml_get_addr_expr (sym, c, base_addr);\n \n-  switch (ts->type)\n+  if (as)\n+    rank = as->rank;\n+\n+  if (rank)\n     {\n-    case BT_INTEGER:\n-      tmp = gfc_build_function_call (iocall_set_nml_val_int, args);\n-      break;\n+      dt =  TREE_TYPE ((sym) ? sym->backend_decl : c->backend_decl);\n+      dtype = gfc_get_dtype (dt);\n+    }\n+  else\n+    {\n+      itype = GFC_DTYPE_UNKNOWN;\n \n-    case BT_CHARACTER:\n-      expr = gfc_build_indirect_ref (addr_expr);\n-      gcc_assert (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE);\n-      args = gfc_chainon_list (args,\n-                               TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (expr))));\n-      tmp = gfc_build_function_call (iocall_set_nml_val_char, args);\n-      break;\n+      switch (ts->type)\n \n-    case BT_REAL:\n-      tmp = gfc_build_function_call (iocall_set_nml_val_float, args);\n-      break;\n+\t{\n+\tcase BT_INTEGER:\n+\t  itype = GFC_DTYPE_INTEGER;\n+\t  break;\n+\tcase BT_LOGICAL:\n+\t  itype = GFC_DTYPE_LOGICAL;\n+\t  break;\n+\tcase BT_REAL:\n+\t  itype = GFC_DTYPE_REAL;\n+\t  break;\n+\tcase BT_COMPLEX:\n+\t  itype = GFC_DTYPE_COMPLEX;\n+\tbreak;\n+\tcase BT_DERIVED:\n+\t  itype = GFC_DTYPE_DERIVED;\n+\t  break;\n+\tcase BT_CHARACTER:\n+\t  itype = GFC_DTYPE_CHARACTER;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n-    case BT_LOGICAL:\n-      tmp = gfc_build_function_call (iocall_set_nml_val_log, args);\n-      break;\n+      dtype = IARG (itype << GFC_DTYPE_TYPE_SHIFT);\n+    }\n \n-    case BT_COMPLEX:\n-      tmp = gfc_build_function_call (iocall_set_nml_val_complex, args);\n-      break;\n+  /* Build up the arguments for the transfer call.\n+     The call for the scalar part transfers:\n+     (address, name, type, kind or string_length, dtype)  */\n \n-    default :\n-      internal_error (\"Bad namelist IO basetype (%d)\", ts->type);\n-    }\n+  NML_FIRST_ARG (addr_expr);\n+  NML_ADD_ARG (string);\n+  NML_ADD_ARG (IARG (ts->kind));\n+\n+  if (ts->type == BT_CHARACTER)\n+    NML_ADD_ARG (ts->cl->backend_decl);\n+  else\n+    NML_ADD_ARG (convert (gfc_charlen_type_node, integer_zero_node));\n \n+  NML_ADD_ARG (dtype);\n+  tmp = gfc_build_function_call (iocall_set_nml_val, args);\n   gfc_add_expr_to_block (block, tmp);\n+\n+  /* If the object is an array, transfer rank times:\n+     (null pointer, name, stride, lbound, ubound)  */\n+\n+  for ( n_dim = 0 ; n_dim < rank ; n_dim++ )\n+    {\n+      NML_FIRST_ARG (IARG (n_dim));\n+      NML_ADD_ARG (GFC_TYPE_ARRAY_STRIDE (dt, n_dim));\n+      NML_ADD_ARG (GFC_TYPE_ARRAY_LBOUND (dt, n_dim));\n+      NML_ADD_ARG (GFC_TYPE_ARRAY_UBOUND (dt, n_dim));\n+      tmp = gfc_build_function_call (iocall_set_nml_val_dim, args);\n+      gfc_add_expr_to_block (block, tmp);\n+    }\n+\n+  if (ts->type == BT_DERIVED)\n+    {\n+      gfc_component *cmp;\n+\n+      /* Provide the RECORD_TYPE to build component references.  */\n+\n+      tree expr = gfc_build_indirect_ref (addr_expr);\n+\n+      for (cmp = ts->derived->components; cmp; cmp = cmp->next)\n+\t{\n+\t  char *full_name = nml_full_name (var_name, cmp->name);\n+\t  transfer_namelist_element (block,\n+\t\t\t\t     full_name,\n+\t\t\t\t     NULL, cmp, expr);\n+\t  gfc_free (full_name);\n+\t}\n+    }\n }\n \n+#undef IARG\n+#undef NML_ADD_ARG\n+#undef NML_FIRST_ARG\n+\n /* Create a data transfer statement.  Not all of the fields are valid\n    for both reading and writing, but improper use has been filtered\n    out by now.  */\n@@ -950,9 +1047,8 @@ build_dt (tree * function, gfc_code * code)\n   stmtblock_t block, post_block;\n   gfc_dt *dt;\n   tree tmp;\n-  gfc_expr *nmlname, *nmlvar;\n+  gfc_expr *nmlname;\n   gfc_namelist *nml;\n-  gfc_se se,se2;\n \n   gfc_init_block (&block);\n   gfc_init_block (&post_block);\n@@ -1010,30 +1106,20 @@ build_dt (tree * function, gfc_code * code)\n \n   if (dt->namelist)\n     {\n-       if (dt->format_expr || dt->format_label)\n-          fatal_error(\"A format cannot be specified with a namelist\");\n-\n-       nmlname = gfc_new_nml_name_expr(dt->namelist->name);\n-\n-       set_string (&block, &post_block, ioparm_namelist_name,\n-                ioparm_namelist_name_len, nmlname);\n-\n-       if (last_dt == READ)\n-          set_flag (&block, ioparm_namelist_read_mode);\n-\n-\tfor (nml = dt->namelist->namelist; nml; nml = nml->next)\n-\t  {\n-\t    gfc_init_se (&se, NULL);\n-\t    gfc_init_se (&se2, NULL);\n-\t    nmlvar = get_new_var_expr (nml->sym);\n-\t    nmlname = gfc_new_nml_name_expr (nml->sym->name);\n-\t    gfc_conv_expr_reference (&se2, nmlname);\n-\t    gfc_conv_expr_reference (&se, nmlvar);\n-\t    gfc_evaluate_now (se.expr, &se.pre); \n-\n-\t    transfer_namelist_element (&block, &nml->sym->ts, se.expr,\n-\t\t\t\t       se2.expr, se2.string_length);\n-\t  }\n+      if (dt->format_expr || dt->format_label)\n+        gfc_internal_error (\"build_dt: format with namelist\");\n+\n+      nmlname = gfc_new_nml_name_expr(dt->namelist->name);\n+\n+      set_string (&block, &post_block, ioparm_namelist_name,\n+\t\t  ioparm_namelist_name_len, nmlname);\n+\n+      if (last_dt == READ)\n+\tset_flag (&block, ioparm_namelist_read_mode);\n+\n+      for (nml = dt->namelist->namelist; nml; nml = nml->next)\n+\ttransfer_namelist_element (&block, nml->sym->name, nml->sym,\n+\t\t\t\t   NULL, NULL);\n     }\n \n   tmp = gfc_build_function_call (*function, NULL_TREE);"}, {"sha": "73501f20909615eb257292cb84a80ef8447e2d54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,3 +1,27 @@\n+2005-04-17 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR libfortran/12884 gfortran.dg/pr12884.f: New test\n+\tPR libfortran/17285 gfortran.dg/pr17285.f90: New test\n+\tPR libfortran/17472, 18396, 18209 gfortran.dg/pr17472.f: New test\n+\tPR libfortran/18122, 18591 gfortran.dg/pr18122.f90: New test\n+\tPR libfortran/18210 gfortran.dg/pr18210.f90: New test\n+\tPR libfortran/18392 gfortran.dg/pr18392.f90: New test\n+\tPR libfortran/19467 gfortran.dg/pr19467.f90: New test\n+\tPR libfortran/19657 gfortran.dg/pr19657.f90: New test\n+\t* gfortran.dg/namelist_1.f90: Correct comment (PUBLIC and PRIVATE wrong way round).\n+\t* gfortran.dg/namelist_2.f90: Variables with INTENT(IN) cannot be in namelists. New test\n+\t* gfortran.dg/namelist_3.f90: Pointers cannot be in namelists. New test\n+\t* gfortran.dg/namelist_11.f: Tests reals and qualifiers in namelist. New test\n+\t* gfortran.dg/namelist_12.f: Tests integers and qualifiers in namelist. New test\n+\t* gfortran.dg/namelist_13.f90: Tests derived types in namelist. New test\n+\t* gfortran.dg/namelist_14.f90: Tests trans-io.c namelist support. New test\n+\t* gfortran.dg/namelist_15.f90: Tests arrays of derived types in namelist. New test\n+\t* gfortran.dg/namelist_16.f90: Tests complex in namelist. New test\n+\t* gfortran.dg/namelist_17.f90: Tests logical in namelist. New test\n+\t* gfortran.dg/namelist_18.f90: Tests charcter delimiters in namelist. New test\n+\t* gfortran.dg/namelist_19.f90: Tests namelist errors. New test\n+\t* gfortran.dg/namelist_20.f90: Tests negative bounds for explicit arrays. New test\n+\n 2005-04-17  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* gfortran.dg/wtruncate.f: New testcase."}, {"sha": "ee028dd0e5e6b81cb14e86c3afebcfa151816e0c", "filename": "gcc/testsuite/gfortran.dg/namelist_1.f90", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_1.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,8 +1,7 @@\n ! { dg-do compile }\n-! Check that public entities in private namelists are rejected\n+! Check that private entities in public namelists are rejected\n module namelist_1\n   public\n   integer,private :: x\n   namelist /n/ x ! { dg-error \"cannot be member of PUBLIC namelist\" \"\" }\n end module\n-"}, {"sha": "4145a906a2b5856435dfe0321045ebdc02ebf0ff", "filename": "gcc/testsuite/gfortran.dg/namelist_11.f", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_11.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_11.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_11.f?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,55 @@\n+c { dg-do run }\n+c This program tests: namelist comment, a blank line before the nameilist name, the namelist name,\n+c a scalar qualifier, various combinations of space, comma and lf delimiters, f-formats, e-formats\n+c a blank line within the data read, nulls, a range qualifier, a new object name before end of data\n+c and an integer read.  It also tests that namelist output can be re-read by namelist input.\n+c provided by Paul Thomas - pault@gcc.gnu.org\n+\n+      program namelist_1\n+\n+      REAL*4 x(10)\n+      REAL*8 xx\n+      integer ier\n+      namelist /mynml/ x, xx\n+\n+      do i = 1 , 10\n+        x(i) = -1\n+      end do\n+      x(6) = 6.0\n+      x(10) = 10.0\n+      xx = 0d0\n+\n+      open (10,status=\"scratch\")\n+      write (10, *) \"!mynml\"\n+      write (10, *) \"\"\n+      write (10, *) \"&gf /\"\n+      write (10, *) \"&mynml  x(7) =+99.0e0 x=1.0, 2.0 ,\"\n+      write (10, *) \" 2*3.0, ,, 7.0e0,+0.08e+02 !comment\"\n+      write (10, *) \"\"\n+      write (10, *) \" 9000e-3 x(4:5)=4 ,5 \"\n+      write (10, *) \" x=,,3.0, xx=10d0 /\"\n+      rewind (10)\n+\n+      read (10, nml=mynml, IOSTAT=ier)\n+      if (ier.ne.0) call abort\n+      rewind (10)\n+\n+      do i = 1 , 10\n+        if ( abs( x(i) - real(i) ) .gt. 1e-8 ) call abort\n+      end do\n+      if ( abs( xx - 10d0 ) .gt. 1e-8 ) call abort\n+\n+      write (10, nml=mynml, iostat=ier)\n+      if (ier.ne.0) call abort\n+      rewind (10)\n+\n+      read (10, NML=mynml, IOSTAT=ier)\n+      if (ier.ne.0) call abort\n+      close (10)\n+\n+      do i = 1 , 10\n+        if ( abs( x(i) - real(i) ) .gt. 1e-8 ) call abort\n+      end do\n+      if ( abs( xx - 10d0 ) .gt. 1e-8 ) call abort\n+\n+      end program"}, {"sha": "e6d122463f1b091e016d27fb8f53985f723d69f5", "filename": "gcc/testsuite/gfortran.dg/namelist_12.f", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_12.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_12.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_12.f?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,56 @@\n+c{ dg-do run }\n+c This program repeats many of the same tests as test_nml_1 but for integer instead of real.\n+c  It also tests repeat nulls, comma delimited character read, a triplet qualifier, a range with\n+c and assumed start, a quote delimited string, a qualifier with an assumed end and a fully\n+c explicit range.  It also tests that integers and characters are successfully read back by\n+c namelist.\n+c Provided by Paul Thomas - pault@gcc.gnu.org\n+\n+      program namelist_12\n+\n+      integer*4 x(10)\n+      integer*8 xx\n+      integer ier\n+      character*10 ch , check\n+      namelist /mynml/ x, xx, ch\n+ \n+c set debug = 0 or 1 in the namelist! (line 33)\n+\n+      do i = 1 , 10\n+        x(i) = -1\n+      end do\n+      x(6) = 6\n+      x(10) = 10\n+      xx = 0\n+      ch =\"zzzzzzzzzz\"\n+      check=\"abcdefghij\"\n+\n+      open (10,status=\"scratch\")\n+      write (10, *) \"!mynml\"\n+      write (10, *) \" \"\n+      write (10, *) \"&mynml  x(7) =+99 x=1, 2 ,\"\n+      write (10, *) \" 2*3, ,, 2* !comment\"\n+      write (10, *) \" 9 ch=qqqdefghqq , x(8:7:-1) = 8 , 7\"\n+      write (10, *) \" ch(:3) =\"\"abc\"\",\"\n+      write (10, *) \" ch(9:)='ij' x(4:5)=4 ,5 xx = 42/\"\n+      rewind (10)\n+\n+      read (10, nml=mynml, IOSTAT=ier)\n+      if (ier.ne.0) call abort\n+      rewind (10)\n+\n+      write (10, nml=mynml, iostat=ier)\n+      if (ier.ne.0) call abort\n+      rewind (10)\n+\n+      read (10, NML=mynml, IOSTAT=ier)\n+      if (ier.ne.0) call abort\n+      close (10)\n+\n+      do i = 1 , 10\n+        if ( abs( x(i) - i ) .ne. 0 ) call abort ()\n+        if ( ch(i:i).ne.check(I:I) ) call abort\n+      end do\n+      if (xx.ne.42) call abort ()\n+\n+      end program"}, {"sha": "5b7122ca302de25e76fdd8256922c637cad02198", "filename": "gcc/testsuite/gfortran.dg/namelist_13.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_13.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,38 @@\n+!{ dg-do run }\n+! Tests simple derived types.\n+! Provided by Paul Thomas - pault@gcc.gnu.org\n+\n+program namelist_13\n+\n+  type                        ::      yourtype\n+    integer, dimension(2)     ::      yi = (/8,9/)\n+    real, dimension(2)        ::      yx = (/80.,90./)\n+    character(len=2)          ::      ych = \"xx\"\n+  end type yourtype\n+\n+  type                        ::      mytype\n+    integer, dimension(2)     ::      myi = (/800,900/)\n+    real, dimension(2)        ::      myx = (/8000.,9000./)\n+    character(len=2)          ::      mych = \"zz\"\n+    type(yourtype)            ::      my_yourtype\n+  end type mytype\n+\n+  type(mytype)                ::      z\n+  integer                     ::      ier\n+  integer                     ::      zeros(10)\n+  namelist /mynml/ zeros, z\n+\n+  zeros = 0\n+  zeros(5) = 1\n+\n+  open(10,status=\"scratch\")\n+  write (10, nml=mynml, iostat=ier)\n+  if (ier.ne.0) call abort\n+\n+  rewind (10)\n+  read (10, NML=mynml, IOSTAT=ier)\n+  if (ier.ne.0) call abort\n+  close (10)\n+\n+end program namelist_13\n+"}, {"sha": "d22040f8a2ad48f9b454895ca6a70db48e756d72", "filename": "gcc/testsuite/gfortran.dg/namelist_14.f90", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_14.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,94 @@\n+!{ dg-do run }\n+! Tests various combinations of intrinsic types, derived types, arrays,\n+! dummy arguments and common to check nml_get_addr_expr in trans-io.c.\n+! See comments below for selection.\n+! provided by Paul Thomas - pault@gcc.gnu.org\n+\n+module global\n+  type             ::  mt\n+    integer        ::  ii(4)\n+  end type mt\n+end module global\n+\n+program namelist_14\n+  use global\n+  common /myc/ cdt\n+  integer          ::  i(2) = (/101,201/)\n+  type(mt)         ::  dt(2)\n+  type(mt)         ::  cdt\n+  real*8           ::  pi = 3.14159_8\n+  character*10     ::  chs=\"singleton\"\n+  character*10     ::  cha(2)=(/\"first     \",\"second    \"/)\n+\n+  dt = mt ((/99,999,9999,99999/))\n+  cdt = mt ((/-99,-999,-9999,-99999/))\n+  call foo (i,dt,pi,chs,cha)\n+\n+contains\n+\n+  logical function dttest (dt1, dt2)\n+    use global\n+    type(mt)       :: dt1\n+    type(mt)       :: dt2\n+    dttest = any(dt1%ii == dt2%ii)\n+  end function dttest\n+\n+\n+  subroutine foo (i, dt, pi, chs, cha)\n+    use global\n+    common /myc/ cdt\n+    real *8        :: pi                   !local real scalar\n+    integer        :: i(2)                 !dummy arg. array\n+    integer        :: j(2) = (/21, 21/)    !equivalenced array\n+    integer        :: jj                   !    -||-     scalar\n+    integer        :: ier\n+    type(mt)       :: dt(2)                !dummy arg., derived array\n+    type(mt)       :: dtl(2)               !in-scope derived type array\n+    type(mt)       :: dts                  !in-scope derived type\n+    type(mt)       :: cdt                  !derived type in common block\n+    character*10   :: chs                  !dummy arg. character var.\n+    character*10   :: cha(:)               !dummy arg. character array\n+    character*10   :: chl=\"abcdefg\"        !in-scope character var.\n+    equivalence (j,jj)\n+    namelist /z/     dt, dtl, dts, cdt, j, jj, i, pi, chs, chl, cha\n+\n+    dts = mt ((/1, 2, 3, 4/))\n+    dtl = mt ((/41, 42, 43, 44/))\n+\n+    open (10, status = \"scratch\")\n+    write (10, nml = z, iostat = ier)\n+    if (ier /= 0 ) call abort()\n+    rewind (10)\n+\n+    i = 0\n+    j = 0\n+    jj = 0\n+    pi = 0\n+    dt  = mt ((/0, 0, 0, 0/))\n+    dtl = mt ((/0, 0, 0, 0/))\n+    dts = mt ((/0, 0, 0, 0/))\n+    cdt = mt ((/0, 0, 0, 0/))\n+    chs = \"\"\n+    cha = \"\"\n+    chl = \"\"\n+\n+    read (10, nml = z, iostat = ier)\n+    if (ier /= 0 ) call abort()\n+    close (10)\n+\n+    if (.not.(dttest (dt(1),  mt ((/99,999,9999,99999/))) .and.  &\n+\t      dttest (dt(2),  mt ((/99,999,9999,99999/))) .and.  &\n+\t      dttest (dtl(1), mt ((/41, 42, 43, 44/))) .and.     &\n+\t      dttest (dtl(2), mt ((/41, 42, 43, 44/))) .and.     &\n+\t      dttest (dts, mt ((/1, 2, 3, 4/))) .and.            &\n+\t      dttest (cdt, mt ((/-99,-999,-9999,-99999/))) .and. &\n+\t      all (j ==(/21, 21/)) .and.                         &\n+\t      all (i ==(/101, 201/)) .and.                       &\n+\t      (pi == 3.14159_8) .and.                            &\n+\t      (chs == \"singleton\") .and.                         &\n+\t      (chl == \"abcdefg\") .and.                           &\n+\t      (cha(1)(1:10) == \"first    \") .and.                &\n+\t      (cha(2)(1:10) == \"second    \"))) call abort ()\n+\n+    end subroutine foo\n+end program namelist_14 "}, {"sha": "8c64ab0ea225ebcff4d76856409c6004f90c908f", "filename": "gcc/testsuite/gfortran.dg/namelist_15.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_15.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,58 @@\n+!{ dg-do run }\n+! Tests arrays of derived types containing derived type arrays whose\n+! components are character arrays - exercises object name parser in\n+! list_read.c. Checks that namelist output can be reread. \n+! provided by Paul Thomas - pault@gcc.gnu.org\n+\n+module global\n+  type             ::  mt\n+    character(len=2) ::  ch(2) = (/\"aa\",\"bb\"/)\n+  end type mt\n+  type             ::  bt\n+    integer        ::  i(2) = (/1,2/)\n+    type(mt)       ::  m(2)\n+  end type bt\n+end module global\n+\n+program namelist_15\n+  use global\n+  type(bt)         ::  x(2)\n+\n+  namelist /mynml/ x\n+\n+  open (10, status = \"scratch\")\n+  write (10, '(A)') \"&MYNML\"\n+  write (10, '(A)') \" x = 3, 4, 'dd', 'ee', 'ff', 'gg',\"\n+  write (10, '(A)') \"     4, 5, 'hh', 'ii', 'jj', 'kk',\"\n+  write (10, '(A)') \" x%i = , ,-3, -4\"\n+  write (10, '(A)') \" x(2)%m(1)%ch(2) =q,\"\n+  write (10, '(A)') \" x(2)%m(2)%ch(1)(1) =w,\"\n+  write (10, '(A)') \" x%m%ch(:)(2) =z z z z z z z z,\"\n+  write (10, '(A)') \"&end\"\n+   \n+  rewind (10)\n+  read (10, nml = mynml, iostat = ier)\n+  if (ier .ne. 0) call abort () \n+  close (10)\n+\n+  open (10, status = \"scratch\")\n+  write (10, nml = mynml)\n+  rewind (10)\n+  read (10, nml = mynml, iostat = ier)\n+  if (ier .ne. 0) call abort () \n+  close(10)\n+\n+  if (.not. ((x(1)%i(1) == 3)          .and. &\n+             (x(1)%i(2) == 4)          .and. &\n+             (x(1)%m(1)%ch(1) == \"dz\") .and. &\n+\t     (x(1)%m(1)%ch(2) == \"ez\") .and. &\n+             (x(1)%m(2)%ch(1) == \"fz\") .and. &\n+\t     (x(1)%m(2)%ch(2) == \"gz\") .and. &\n+             (x(2)%i(1) == -3)         .and. &\n+             (x(2)%i(2) == -4)         .and. &\n+             (x(2)%m(1)%ch(1) == \"hz\") .and. &\n+\t     (x(2)%m(1)%ch(2) == \"qz\") .and. &\n+             (x(2)%m(2)%ch(1) == \"wz\") .and. &\n+\t     (x(2)%m(2)%ch(2) == \"kz\"))) call abort ()\n+\n+end program namelist_15 "}, {"sha": "c6eb8f75595afcd39530f24f8073b1f1efec6c50", "filename": "gcc/testsuite/gfortran.dg/namelist_16.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_16.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,29 @@\n+!{ dg-do run }\n+! Tests namelist on complex variables\n+! provided by Paul Thomas - pault@gcc.gnu.org\n+program namelist_16\n+  complex(kind=8), dimension(2)  ::   z\n+  namelist /mynml/ z\n+  z = (/(1.0,2.0), (3.0,4.0)/)\n+\n+  open (10, status = \"scratch\")\n+  write (10, '(A)') \"&mynml z(1)=(5.,6.) z(2)=(7.,8.) /\"\n+  rewind (10)\n+\n+  read (10, mynml, iostat = ier)\n+  if (ier .ne. 0) call abort ()\n+  close (10)\n+\n+  open (10, status = \"scratch\")\n+  write (10, mynml, iostat = ier)\n+  if (ier .ne. 0) call abort ()\n+  rewind (10)\n+\n+  z = (/(1.0,2.0), (3.0,4.0)/)\n+  read (10, mynml, iostat = ier)\n+  if (ier .ne. 0) call abort ()\n+  close (10)\n+\n+  if ((z(1) .ne. (5.0,6.0)) .or. (z(2) .ne. (7.0,8.0))) call abort ()\n+\n+end program namelist_16 "}, {"sha": "e3eac5210bf50d82ff24bb334b05f6a945f56191", "filename": "gcc/testsuite/gfortran.dg/namelist_17.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_17.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,30 @@\n+!{ dg-do run }\n+! Tests namelist on logical variables\n+! provided by Paul Thomas - pault@gcc.gnu.org\n+\n+program namelist_17\n+  logical, dimension(2)        ::   l\n+  namelist /mynml/ l\n+  l = (/.true., .false./)\n+\n+  open (10, status = \"scratch\")\n+  write (10, '(A)') \"&mynml l = F T /\"\n+  rewind (10)\n+  \n+  read (10, mynml, iostat = ier)\n+  if (ier .ne. 0) call abort ()\n+  close (10)\n+\n+  open (10, status = \"scratch\")\n+  write (10, mynml, iostat = ier)\n+  if (ier .ne. 0) call abort ()\n+  rewind (10)\n+\n+  l = (/.true., .false./)\n+  read (10, mynml, iostat = ier)\n+  if (ier .ne. 0) call abort ()\n+  close (10)\n+\n+  if (l(1) .or. (.not.l(2))) call abort ()\n+\n+end program namelist_17 "}, {"sha": "eba8b6bc573ee04cf17399dcf6cdd1c4903b84b7", "filename": "gcc/testsuite/gfortran.dg/namelist_18.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_18.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,37 @@\n+!{ dg-do run }\n+! Tests character delimiters for namelist write \n+! provided by Paul Thomas - pault@gcc.gnu.org\n+\n+program namelist_18\n+  character*3        ::   ch = \"foo\"\n+  character*80       ::   buffer\n+  namelist /mynml/ ch\n+\n+  open (10, status = \"scratch\")\n+  write (10, mynml)\n+  rewind (10)\n+  read (10, '(a)', iostat = ier) buffer\n+  read (10, '(a)', iostat = ier) buffer\n+  if (ier .ne. 0) call abort ()\n+  close (10)\n+  If ((buffer(5:5) /= \"f\") .or. (buffer(9:9) /= \" \")) call abort () \n+\n+  open (10, status = \"scratch\", delim =\"quote\")\n+  write (10, mynml)\n+  rewind (10)\n+  read (10, '(a)', iostat = ier) buffer\n+  read (10, '(a)', iostat = ier) buffer\n+  if (ier .ne. 0) call abort ()\n+  close (10)\n+  If ((buffer(5:5) /= \"\"\"\") .or. (buffer(9:9) /= \"\"\"\")) call abort ()\n+\n+  open (10, status = \"scratch\", delim =\"apostrophe\")\n+  write (10, mynml)\n+  rewind (10)\n+  read (10, '(a)', iostat = ier) buffer\n+  read (10, '(a)', iostat = ier) buffer\n+  if (ier .ne. 0) call abort ()\n+  close (10)\n+  If ((buffer(5:5) /= \"'\") .or. (buffer(9:9) /= \"'\")) call abort ()\n+\n+end program namelist_18"}, {"sha": "c06abf5295beec9b7894ed76597963903bba8649", "filename": "gcc/testsuite/gfortran.dg/namelist_19.f90", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_19.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,135 @@\n+!{ dg-do run }\n+! Test namelist error trapping.\n+! provided by Paul Thomas - pault@gcc.gnu.org\n+\n+program namelist_19\n+  character*80 wrong, right\n+  \n+! \"=\" before any object name\n+  wrong = \"&z = i = 1,2 /\"\n+  right = \"&z i = 1,2 /\"\n+  call test_err(wrong, right)\n+  \n+! &* instead of &end for termination \n+  wrong = \"&z i = 1,2 &xxx\"\n+  right = \"&z i = 1,2 &end\"\n+  call test_err(wrong, right)\n+  \n+! bad data \n+  wrong = \"&z i = 1,q /\"\n+  right = \"&z i = 1,2 /\"\n+  call test_err(wrong, right)\n+  \n+! object name not matched \n+  wrong = \"&z j = 1,2 /\"\n+  right = \"&z i = 1,2 /\"\n+  call test_err(wrong, right)\n+\n+! derived type component for intrinsic type\n+  wrong = \"&z i%j = 1,2 /\"\n+  right = \"&z i = 1,2 /\"\n+  call test_err(wrong, right)\n+\n+! step other than 1 for substring qualifier\n+  wrong = \"&z ch(1:2:2) = 'a'/\"\n+  right = \"&z ch(1:2) = 'ab' /\"\n+  call test_err(wrong, right)\n+\n+! qualifier for scalar \n+  wrong = \"&z k(2) = 1 /\"\n+  right = \"&z k    = 1 /\"\n+  call test_err(wrong, right)\n+\n+! no '=' after object name \n+  wrong = \"&z i   1,2 /\"\n+  right = \"&z i = 1,2 /\"\n+  call test_err(wrong, right)\n+\n+! repeat count too large \n+  wrong = \"&z i = 3*2 /\"\n+  right = \"&z i = 2*2 /\"\n+  call test_err(wrong, right)\n+\n+! too much data \n+  wrong = \"&z i = 1 2 3 /\"\n+  right = \"&z i = 1 2 /\"\n+  call test_err(wrong, right)\n+\n+! no '=' after object name \n+  wrong = \"&z i   1,2 /\"\n+  right = \"&z i = 1,2 /\"\n+  call test_err(wrong, right)\n+\n+! bad number of index fields\n+  wrong = \"&z i(1,2) = 1 /\"\n+  right = \"&z i(1)   = 1 /\"\n+  call test_err(wrong, right)\n+\n+! bad character in index field \n+  wrong = \"&z i(x) = 1 /\"\n+  right = \"&z i(1) = 1 /\"\n+  call test_err(wrong, right)\n+\n+! null index field \n+  wrong = \"&z i( ) = 1 /\"\n+  right = \"&z i(1) = 1 /\"\n+  call test_err(wrong, right)\n+\n+! null index field \n+  wrong = \"&z i(1::)   = 1 2/\"\n+  right = \"&z i(1:2:1) = 1 2 /\"\n+  call test_err(wrong, right)\n+\n+! null index field \n+  wrong = \"&z i(1:2:)  = 1 2/\"\n+  right = \"&z i(1:2:1) = 1 2 /\"\n+  call test_err(wrong, right)\n+\n+! index out of range \n+  wrong = \"&z i(10) = 1 /\"\n+  right = \"&z i(1)  = 1 /\"\n+  call test_err(wrong, right)\n+\n+! index out of range \n+  wrong = \"&z i(0:1) = 1 /\"\n+  right = \"&z i(1:1) = 1 /\"\n+  call test_err(wrong, right)\n+\n+! bad range\n+  wrong = \"&z i(1:2:-1) = 1 2 /\"\n+  right = \"&z i(1:2: 1) = 1 2 /\"\n+  call test_err(wrong, right)\n+\n+! bad range\n+  wrong = \"&z i(2:1: 1) = 1 2 /\"\n+  right = \"&z i(2:1:-1) = 1 2 /\"\n+  call test_err(wrong, right)\n+\n+contains\n+  subroutine test_err(wrong, right)\n+    character*80 wrong, right\n+    integer            :: i(2) = (/0, 0/)\n+    integer            :: k =0\n+    character*2        :: ch = \"  \"\n+    namelist /z/ i, k, ch\n+\n+! Check that wrong namelist input gives an error\n+\n+    open (10, status = \"scratch\")\n+    write (10, '(A)') wrong\n+    rewind (10)\n+    read (10, z, iostat = ier)\n+    close(10)\n+    if (ier == 0) call abort ()\n+\n+! Check that right namelist input gives no error\n+\n+    open (10, status = \"scratch\")\n+    write (10, '(A)') right\n+    rewind (10)\n+    read (10, z, iostat = ier)\n+    close(10)\n+    if (ier /= 0) call abort ()\n+  end subroutine test_err\n+  \n+end program namelist_19"}, {"sha": "b92e459415ce9b8d018f285304e3e27c1ec4c0a1", "filename": "gcc/testsuite/gfortran.dg/namelist_2.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_2.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+! Check that variable with intent(in) cannot be a member of a namelist\n+subroutine namelist_2(x)\n+  integer,intent(in) :: x\n+  namelist /n/ x\n+  read(*,n) ! { dg-error \"is INTENT\" \"\" }\n+end subroutine namelist_2"}, {"sha": "155cf6f8ed2eab2dc236c3dd948f3dc1dba51262", "filename": "gcc/testsuite/gfortran.dg/namelist_20.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_20.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,35 @@\n+!{ dg-do run }\n+! Tests namelist io for an explicit shape array with negative bounds\n+! provided by Paul Thomas - pault@gcc.gnu.org\n+\n+program namelist_20\n+  integer, dimension (-4:-2) :: x\n+  integer                    :: i, ier\n+  namelist /a/ x\n+\n+  open (10, status = \"scratch\")\n+  write (10, '(A)') \"&a x(-5)=0 /\"            !-ve index below lbound\n+  write (10, '(A)') \"&a x(-1)=0 /\"            !-ve index above ubound\n+  write (10, '(A)') \"&a x(1:2)=0 /\"           !+ve indices\n+  write (10, '(A)') \"&a x(-4:-2)= -4,-3,-2 /\" !correct\n+  write (10, '(A)') \" \"\n+  rewind (10)\n+\n+  ier=0\n+  read(10, a, iostat=ier)\n+  if (ier == 0) call abort ()\n+  ier=0\n+  read(10, a, iostat=ier)\n+  if (ier == 0) call abort ()\n+  ier=0\n+  read(10, a, iostat=ier)\n+  if (ier == 0) call abort ()\n+\n+  ier=0\n+  read(10, a, iostat=ier)\n+  if (ier /= 0) call abort ()\n+  do i = -4,-2\n+    if (x(i) /= i) call abort ()\n+  end do\n+\n+end program namelist_20 "}, {"sha": "68cc7d558ffd4de4d49683b731f130986ca01752", "filename": "gcc/testsuite/gfortran.dg/namelist_3.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_3.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+! Check that a pointer cannot be a member of a namelist\n+program namelist_3\n+  integer,pointer :: x\n+  allocate (x)\n+  namelist /n/ x ! { dg-error \"NAMELIST attribute conflicts with POINTER attribute\" \"\" }\n+end program namelist_3"}, {"sha": "425604c02c5541a6bf8bdb4d0899263bdef097b8", "filename": "gcc/testsuite/gfortran.dg/pr12884.f", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr12884.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr12884.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr12884.f?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,25 @@\n+c { dg-do run }\n+c pr 12884\n+c test namelist with input file containg / before namelist. Also checks\n+c non-standard use of $ instead of &\n+c Based on example provided by jean-pierre.flament@univ-lille1.fr\n+\n+      program pr12884\n+      integer ispher,nosym,runflg,noprop\n+      namelist /cntrl/ ispher,nosym,runflg,noprop\n+      ispher = 0\n+      nosym = 0\n+      runflg = 0\n+      noprop = 0 \n+      open (10, status = \"scratch\")\n+      write (10, '(A)') \" $FILE\"\n+      write (10, '(A)') \"   pseu  dir/file\"\n+      write (10, '(A)') \" $END\"\n+      write (10, '(A)') \" $cntrl ispher=1,nosym=2,\"\n+      write (10, '(A)') \" runflg=3,noprop=4,$END\"\n+      write (10, '(A)')\"/\"\n+      rewind (10)\n+      read (10, cntrl)\n+      if ((ispher.ne.1).or.(nosym.ne.2).or.(runflg.ne.3).or.\n+     &  (noprop.ne.4)) call abort ()\n+      end"}, {"sha": "58aee327aefb3328767a7e52ce123221ad2a5db6", "filename": "gcc/testsuite/gfortran.dg/pr17285.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17285.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17285.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17285.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! pr 17285\n+! Test that namelist can read its own output.\n+! At the same time, check arrays and different terminations\n+! Based on example provided by paulthomas2@wanadoo.fr\n+\n+program pr17285\n+  implicit none\n+  integer, dimension(10) :: number = 42\n+  integer                :: ctr, ierr\n+  namelist /mynml/ number\n+  open (10, status = \"scratch\")\n+  write (10,'(A)') &\n+    \"&mynml number(:)=42,42,42,42,42,42,42,42,42,42,/ \"\n+  write (10,mynml)\n+  write (10,'(A)') \"&mynml number(1:10)=10*42 &end\"\n+  rewind (10)\n+  do ctr = 1,3\n+    number = 0\n+    read (10, nml = mynml, iostat = ierr)\n+    if ((ierr /= 0) .or. (any (number /= 42))) &\n+      call abort ()\n+  end do\n+  close(10)\n+end program pr17285"}, {"sha": "4a1ecd937befb7c12c2ab563e2cc862a3bee9771", "filename": "gcc/testsuite/gfortran.dg/pr17472.f", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17472.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17472.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17472.f?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,12 @@\n+c { dg-do run }\n+c pr 17472\n+c test namelist handles arrays\n+c Based on example provided by thomas.koenig@online.de\n+\n+       integer a(10), ctr\n+       data a / 1,2,3,4,5,6,7,8,9,10 /\n+       namelist /ints/ a\n+       do ctr = 1,10\n+         if (a(ctr).ne.ctr) call abort ()\n+       end do\n+       end"}, {"sha": "3907f0ae15837f8d62d4ea2be1e3edcc374610ef", "filename": "gcc/testsuite/gfortran.dg/pr18122.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18122.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18122.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18122.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! test namelist with scalars and arrays.\n+! Based on example provided by thomas.koenig@online.de\n+\n+program sechs_w\n+  implicit none\n+\n+  integer, parameter :: dr=selected_real_kind(15)\n+\n+  integer, parameter :: nkmax=6\n+  real (kind=dr) :: rb(nkmax)\n+  integer :: z\n+\n+  real (kind=dr) :: dg\n+  real (kind=dr) :: a\n+  real (kind=dr) :: da\n+  real (kind=dr) :: delta\n+  real (kind=dr) :: s,t\n+  integer :: nk\n+  real (kind=dr) alpha0\n+\n+  real (kind=dr) :: phi, phi0, rad, rex, zk, z0, drdphi, dzdphi\n+\n+  namelist /schnecke/ z, dg, a, t, delta, s, nk, rb, alpha0\n+\n+  open (10,status=\"scratch\")\n+  write (10, *)  \"&SCHNECKE\"\n+  write (10, *)    \" z=1,\"\n+  write (10, *)    \" dg=58.4,\"\n+  write (10, *)    \" a=48.,\"\n+  write (10, *)    \" delta=0.4,\"\n+  write (10, *)    \" s=0.4,\"\n+  write (10, *)    \" nk=6,\"\n+  write (10, *)    \" rb=60, 0, 40,\"\n+  write (10, *)    \" alpha0=20.,\"\n+  write (10, *)    \"/\"\n+\n+  rewind (10)\n+  read (10,schnecke)\n+  close (10)\n+  if ((z /= 1)       .or. (dg /= 58.4_dr)  .or. (a /= 48.0_dr)   .or. &\n+    (delta /= 0.4_dr).or. (s /= 0.4_dr)    .or. (nk /= 6)        .or. &\n+    (rb(1) /= 60._dr).or. (rb(2) /= 0.0_dr).or. (rb(3) /=40.0_dr).or. &\n+    (alpha0 /= 20.0_dr)) call abort ()\n+end program sechs_w"}, {"sha": "6095984137899e7868f3040784e5d1b5c17f2dbb", "filename": "gcc/testsuite/gfortran.dg/pr18210.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18210.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18210.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18210.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! Names in upper case and object names starting column 2\n+! Based on example provided by thomas.koenig@online.de\n+\n+program pr18210\n+\n+  real :: a\n+  character*80 :: buffer\n+  namelist /foo/ a\n+\n+  a = 1.4\n+  open (10, status = \"scratch\")\n+  write (10,foo)\n+  rewind (10)\n+  read (10, '(a)') buffer\n+  if (buffer(2:4) /= \"FOO\") call abort ()\n+  read (10, '(a)') buffer\n+  if (buffer(1:2) /= \" A\") call abort ()\n+  close (10)\n+\n+end program pr18210"}, {"sha": "de156f5a5fdfa0f12274700f083dc3afdb478908", "filename": "gcc/testsuite/gfortran.dg/pr18392.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18392.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18392.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr18392.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! pr 18392\n+! test namelist with derived types\n+! Based on example provided by thomas.koenig@online.de\n+\n+program pr18392\n+  implicit none\n+  type foo\n+     integer a\n+     real b\n+  end type foo\n+  type(foo) :: a\n+  namelist /nl/ a\n+  open (10, status=\"scratch\")\n+  write (10,*) \" &NL\"\n+  write (10,*) \" A%A = 10,\"\n+  write (10,*) \"/\"\n+  rewind (10)\n+  read (10,nl)\n+  close (10)\n+  IF (a%a /= 10.0) call abort ()\n+end program pr18392"}, {"sha": "ab4fa99c40b07ea682517a2c1cc8b571d6b0a361", "filename": "gcc/testsuite/gfortran.dg/pr19467.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19467.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19467.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19467.f90?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! pr 19467\n+! test namelist with character arrays\n+! Based on example provided by paulthomas2@wanadoo.fr\n+\n+program pr19467\n+  implicit none\n+  integer             :: ier\n+  character(len=2)    :: ch(2)\n+  character(len=2)    :: dh(2)=(/\"aa\",\"bb\"/)\n+  namelist /a/ ch\n+  open (10, status = \"scratch\")\n+  write (10, *) \"&A ch = 'aa' , 'bb' /\"\n+  rewind (10)\n+  READ (10,nml=a, iostat = ier)\n+  close (10)\n+  if ((ier /= 0) .or. (any (ch /= dh))) call abort ()\n+end program pr19467"}, {"sha": "1fe32ac7497750f7976778fbda3b5430f66451af", "filename": "gcc/testsuite/gfortran.dg/pr19657.f", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19657.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19657.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19657.f?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -0,0 +1,21 @@\n+c { dg-do run }\n+c pr 19657\n+c test namelist not skipped if ending with logical.\n+c Based on example provided by fuyuki@ccsr.u-tokyo.ac.jp\n+\n+      program pr19657\n+      implicit none\n+      logical   l\n+      integer   i, ctr\n+      namelist /nm/ i, l\n+      open (10, status = \"scratch\")\n+      write (10,*) \"&nm i=1,l=t &end\"\n+      write (10,*) \"&nm i=2 &end\"\n+      write (10,*) \"&nm i=3 &end\"\n+      rewind (10)\n+      do ctr = 1,3\n+        read (10,nm,end=190)\n+        if (i.ne.ctr) call abort ()\n+      enddo\n+ 190  continue \n+      end"}, {"sha": "9c083ad8d99ff2e0d917f9aeedbec99dda1bf1a0", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,3 +1,43 @@\n+2005-04-17 Paul Thomas <pault@gcc.gnu.org>\n+\n+* io/list_read.c (eat_separator): at_eol = 1 replaced(zapped at some time?).\n+\n+2005-04-17 Paul Thomas <pault@gcc.gnu.org>\n+\n+\n+\tPR libgfortran/12884\n+\tPR libgfortran/17285\n+\tPR libgfortran/18122\n+\tPR libgfortran/18210\n+\tPR libgfortran/18392\n+\tPR libgfortran/18591\n+\tPR libgfortran/18879\n+\t* io/io.h (nml_ls): Declare.\n+\t(namelist_info): Modify for arrays.\n+\t* io/list_read.c (namelist_read): Reduced to call to new functions.\n+\t(match_namelist_name): Simplified.\n+\t(nml_query): Handles stdin queries ? and =?. New function.\n+\t(nml_get_obj_data): Parses object name. New function.\n+\t(touch_nml_nodes): Marks objects for read. New function.\n+\t(untouch_nml_nodes): Resets objects. New function.\n+\t(parse_qualifier): Parses and checks qualifiers. New function\n+\t(nml_read_object): Reads and stores object data. New function.\n+\t(eat_separator): No new_record on '/' in namelist.\n+\t(finish_separator): No new_record on '/' in namelist.\n+\t(read_logical): Error return for namelist.\n+\t(read_integer): Error return for namelist.\n+\t(read_complex): Error return for namelist.\n+\t(read_real): Error return for namelist.\n+\t* io/lock.c (library_end): Free extended namelist_info types.\n+\t* io/transfer.c (st_set_nml_var): Modified for arrays.\n+\t(st_set_nml_var_dim): Dimension descriptors. New function.\n+\t* io/write.c (namelist_write): Reduced to call to new functions.\n+\t(nml_write_obj): Writes output for object. New function.\n+\t(write_integer): Suppress leading blanks for repeat counts.\n+\t(write_int): Suppress leading blanks for repeat counts.\n+\t(write_float): Suppress leading blanks for repeat counts.\n+\t(output_float): Suppress leading blanks for repeat counts.\n+\n 2005-04-15  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/18495"}, {"sha": "4814d8daf22d50b8740feea44a059c0a846f4337", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -74,32 +74,75 @@ stream;\n #define sseek(s, pos) ((s)->seek)(s, pos)\n #define struncate(s) ((s)->truncate)(s)\n \n-/* Namelist represent object */\n-/*\n+/* Representation of a namelist object in libgfortran\n+\n    Namelist Records\n-       &groupname  object=value [,object=value].../\n+      &GROUPNAME  OBJECT=value[s] [,OBJECT=value[s]].../\n      or\n-       &groupname  object=value [,object=value]...&groupname\n+      &GROUPNAME  OBJECT=value[s] [,OBJECT=value[s]]...&END\n+\n+   The object can be a fully qualified, compound name for an instrinsic\n+   type, derived types or derived type components.  So, a substring\n+   a(:)%b(4)%ch(2:4)(1:7) has to be treated correctly in namelist\n+   read. Hence full information about the structure of the object has\n+   to be available to list_read.c and write.\n+\n+   These requirements are met by the following data structures.\n+\n+   nml_loop_spec contains the variables for the loops over index ranges\n+   that are encountered.  Since the variables can be negative, ssize_t\n+   is used.  */\n+\n+typedef struct nml_loop_spec\n+{\n \n-  Even more complex, during the execution of a program containing a\n-  namelist READ statement, you can specify a question mark character(?)\n-  or a question mark character preceded by an equal sign(=?) to get\n-  the information of the namelist group. By '?', the name of variables\n-  in the namelist will be displayed, by '=?', the name and value of\n-  variables will be displayed.\n+  /* Index counter for this dimension.  */\n+  ssize_t idx;\n \n-  All these requirements need a new data structure to record all info\n-  about the namelist.\n-*/\n+  /* Start for the index counter.  */\n+  ssize_t start;\n+\n+  /* End for the index counter.  */\n+  ssize_t end;\n+\n+  /* Step for the index counter.  */\n+  ssize_t step;\n+}\n+nml_loop_spec;\n+\n+/* namelist_info type contains all the scalar information about the\n+   object and arrays of descriptor_dimension and nml_loop_spec types for\n+   arrays.  */\n \n typedef struct namelist_type\n {\n+\n+  /* Object type, stored as GFC_DTYPE_xxxx.  */\n+  bt type;\n+\n+  /* Object name.  */\n   char * var_name;\n+\n+  /* Address for the start of the object's data.  */\n   void * mem_pos;\n-  int  value_acquired;\n+\n+  /* Flag to show that a read is to be attempted for this node.  */\n+  int touched;\n+\n+  /* Length of intrinsic type in bytes.  */\n   int len;\n-  int string_length;\n-  bt type;\n+\n+  /* Rank of the object.  */\n+  int var_rank;\n+\n+  /* Overall size of the object in bytes.  */\n+  index_type size;\n+\n+  /* Length of character string.  */\n+  index_type string_length;\n+\n+  descriptor_dimension * dim;\n+  nml_loop_spec * ls;\n   struct namelist_type * next;\n }\n namelist_info;"}, {"sha": "becf09edd06564c8b7ce6c6c2ae01a943b88a522", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 903, "deletions": 132, "changes": 1035, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,5 +1,6 @@\n-/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   Namelist input contributed by Paul Thomas\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -50,13 +51,22 @@ Boston, MA 02111-1307, USA.  */\n    ourselves.  Data is buffered in scratch[] until it becomes too\n    large, after which we start allocating memory on the heap.  */\n \n-static int repeat_count, saved_length, saved_used, input_complete, at_eol;\n-static int comma_flag, namelist_mode;\n-\n+static int repeat_count, saved_length, saved_used;\n+static int input_complete, at_eol, comma_flag;\n static char last_char, *saved_string;\n static bt saved_type;\n \n+/* A namelist specific flag used in the list directed library\n+   to flag that calls are being made from namelist read (eg. to ignore\n+   comments or to treat '/' as a terminator)  */\n+\n+static int namelist_mode;\n+\n+/* A namelist specific flag used in the list directed library to flag\n+   read errors and return, so that an attempt can be made to read a\n+   new object name.  */\n \n+static int nml_read_error;\n \n /* Storage area for values except for strings.  Must be large enough\n    to hold a complex value (two reals) of the largest kind.  */\n@@ -226,12 +236,16 @@ eat_separator (void)\n \n     case '/':\n       input_complete = 1;\n-      next_record (0);\n-      at_eol = 1;\n+      if (!namelist_mode)\n+\t{\n+\t  next_record (0);\n+\t  at_eol = 1;\n+\t}\n       break;\n \n     case '\\n':\n     case '\\r':\n+      at_eol = 1;\n       break;\n \n     case '!':\n@@ -282,7 +296,7 @@ finish_separator (void)\n \n     case '/':\n       input_complete = 1;\n-      next_record (0);\n+      if (!namelist_mode) next_record (0);\n       break;\n \n     case '\\n':\n@@ -305,6 +319,21 @@ finish_separator (void)\n     }\n }\n \n+/* This function is needed to catch bad conversions so that namelist can\n+   attempt to see if saved_string contains a new object name rather than\n+   a bad value.  */\n+\n+static int\n+nml_bad_return (char c)\n+{\n+  if (namelist_mode)\n+    {\n+      nml_read_error = 1;\n+      unget_char(c);\n+      return 1;\n+    }\n+  return 0;\n+}\n \n /* Convert an unsigned string to an integer.  The length value is -1\n    if we are working on a repeat count.  Returns nonzero if we have a\n@@ -525,6 +554,10 @@ read_logical (int length)\n   return;\n \n  bad_logical:\n+\n+  if (nml_bad_return (c))\n+    return;\n+\n   st_sprintf (message, \"Bad logical value while reading item %d\",\n \t      g.item_count);\n \n@@ -641,6 +674,10 @@ read_integer (int length)\n     }\n \n  bad_integer:\n+\n+  if (nml_bad_return (c))\n+    return;\n+\n   free_saved ();\n \n   st_sprintf (message, \"Bad integer for item %d in list input\", g.item_count);\n@@ -976,6 +1013,10 @@ read_complex (int length)\n   return;\n \n  bad_complex:\n+\n+  if (nml_bad_return (c))\n+    return;\n+\n   st_sprintf (message, \"Bad complex value in item %d of list input\",\n \t      g.item_count);\n \n@@ -1186,6 +1227,10 @@ read_real (int length)\n   return;\n \n  bad_real:\n+\n+  if (nml_bad_return (c))\n+    return;\n+\n   st_sprintf (message, \"Bad real number in item %d of list input\",\n \t      g.item_count);\n \n@@ -1380,184 +1425,910 @@ finish_list_read (void)\n   while (c != '\\n');\n }\n \n+/*\t\t\tNAMELIST INPUT\n+\n+void namelist_read (void)\n+calls:\n+   static void nml_match_name (char *name, int len)\n+   static int nml_query (void)\n+   static int nml_get_obj_data (void)\n+calls:\n+      static void nml_untouch_nodes (void)\n+      static namelist_info * find_nml_node (char * var_name)\n+      static int nml_parse_qualifier(descriptor_dimension * ad,\n+\t\t\t\t     nml_loop_spec * ls, int rank)\n+      static void nml_touch_nodes (namelist_info * nl)\n+      static int nml_read_obj (namelist_info * nl, index_type offset)\n+calls:\n+      -itself-  */\n+\n+/* Carries error messages from the qualifier parser.  */\n+static char parse_err_msg[30];\n+\n+/* Carries error messages for error returns.  */\n+static char nml_err_msg[100];\n+\n+/* Pointer to the previously read object, in case attempt is made to read\n+   new object name.  Should this fail, error message can give previous\n+   name.  */\n+\n+static namelist_info * prev_nl;\n+\n+/* Lower index for substring qualifier.  */\n+\n+static index_type clow;\n+\n+/* Upper index for substring qualifier.  */\n+\n+static index_type chigh;\n+\n+/* Inputs a rank-dimensional qualifier, which can contain\n+   singlets, doublets, triplets or ':' with the standard meanings.  */\n+\n+static try\n+nml_parse_qualifier(descriptor_dimension * ad,\n+\t\t    nml_loop_spec * ls, int rank)\n+{\n+  int dim;\n+  int indx;\n+  int neg;\n+  int null_flag;\n+  char c;\n+\n+  /* The next character in the stream should be the '('.  */\n+\n+  c = next_char ();\n+\n+  /* Process the qualifier, by dimension and triplet.  */\n+\n+  for (dim=0; dim < rank; dim++ )\n+    {\n+      for (indx=0; indx<3; indx++)\n+\t{\n+\t  free_saved ();\n+\t  eat_spaces ();\n+\t  neg = 0;\n+\n+\t  /*process a potential sign.  */\n+\n+\t  c = next_char ();\n+\t  switch (c)\n+\t    {\n+\t    case '-':\n+\t      neg = 1;\n+\t      break;\n+\n+\t    case '+':\n+\t      break;\n+\n+\t    default:\n+\t      unget_char (c);\n+\t      break;\n+\t    }\n+\n+\t  /*process characters up to the next ':' , ',' or ')'  */\n+\n+\t  for (;;)\n+\t    {\n+\t      c = next_char ();\n+\n+\t      switch (c)\n+\t\t{\n+\t\tcase ':':\n+\t\t  break;\n+\n+\t\tcase ',': case ')':\n+\t\t  if ( (c==',' && dim == rank -1)\n+\t\t    || (c==')' && dim  < rank -1))\n+\t\t    {\n+\t\t      st_sprintf (parse_err_msg,\n+\t\t\t\t  \"Bad number of index fields\");\n+\t\t      goto err_ret;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tCASE_DIGITS:\n+\t\t  push_char (c);\n+\t\t  continue;\n+\n+\t\tcase ' ': case '\\t':\n+\t\t  eat_spaces ();\n+\t\t  c = next_char ();\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  st_sprintf (parse_err_msg, \"Bad character in index\");\n+\t\t  goto err_ret;\n+\t\t}\n+\n+\t      if (( c==',' || c==')') && indx==0 && saved_string == 0 )\n+\t\t{\n+\t\t  st_sprintf (parse_err_msg, \"Null index field\");\n+\t\t  goto err_ret;\n+\t\t}\n+\n+\t      if ( ( c==':' && indx==1 && saved_string == 0)\n+\t\t|| (indx==2 && saved_string == 0))\n+\t\t{\n+\t\t  st_sprintf(parse_err_msg, \"Bad index triplet\");\n+\t\t  goto err_ret;\n+\t\t}\n+\n+\t      /* If '( : ? )' or '( ? : )' break and flag read failure.  */\n+\t      null_flag = 0;\n+\t      if ( (c==':'  && indx==0 && saved_string == 0)\n+\t\t|| (indx==1 && saved_string == 0))\n+\t\t{\n+\t\t  null_flag = 1;\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Now read the index.  */\n+\n+\t      if (convert_integer (sizeof(int),neg))\n+\t\t{\n+\t\t  st_sprintf (parse_err_msg, \"Bad integer in index\");\n+\t\t  goto err_ret;\n+\t\t}\n+\t      break;\n+\t    }\n+\n+\t  /*feed the index values to the triplet arrays.  */\n+\n+\t  if (!null_flag)\n+\t    {\n+\t      if (indx == 0)\n+\t\tls[dim].start = *(int *)value;\n+\t      if (indx == 1)\n+\t\tls[dim].end   = *(int *)value;\n+\t      if (indx == 2)\n+\t\tls[dim].step  = *(int *)value;\n+\t    }\n+\n+\t  /*singlet or doublet indices  */\n+\n+\t  if (c==',' || c==')')\n+\t    {\n+\t      if (indx == 0)\n+\t\t{\n+\t\t  ls[dim].start = *(int *)value;\n+\t\t  ls[dim].end = *(int *)value;\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+\n+      /*Check the values of the triplet indices.  */\n+\n+      if ( (ls[dim].start > (ssize_t)ad[dim].ubound) \n+\t|| (ls[dim].start < (ssize_t)ad[dim].lbound)\n+\t|| (ls[dim].end   > (ssize_t)ad[dim].ubound)\n+\t|| (ls[dim].end   < (ssize_t)ad[dim].lbound))\n+\t{\n+\t  st_sprintf (parse_err_msg, \"Index %d out of range\", dim + 1);\n+\t  goto err_ret;\n+\t}\n+      if (((ls[dim].end - ls[dim].start ) * ls[dim].step < 0)\n+\t|| (ls[dim].step == 0))\n+\t{\n+\t  st_sprintf (parse_err_msg, \"Bad range in index %d\", dim + 1);\n+\t  goto err_ret;\n+\t}\n+\n+      /* Initialise the loop index counter.  */\n+\n+      ls[dim].idx = ls[dim].start;\n+\n+    }\n+  eat_spaces ();\n+  return SUCCESS;\n+\n+err_ret:\n+\n+  return FAILURE;\n+}\n+\n static namelist_info *\n find_nml_node (char * var_name)\n {\n-   namelist_info * t = ionml;\n-   while (t != NULL)\n-     {\n-       if (strcmp (var_name,t->var_name) == 0)\n-         {\n-           t->value_acquired = 1;\n-           return t;\n-         }\n-       t = t->next;\n-     }\n+  namelist_info * t = ionml;\n+  while (t != NULL)\n+    {\n+      if (strcmp (var_name,t->var_name) == 0)\n+\t{\n+\t  t->touched = 1;\n+\t  return t;\n+\t}\n+      t = t->next;\n+    }\n   return NULL;\n }\n \n+/* Visits all the components of a derived type that have\n+   not explicitly been identified in the namelist input.\n+   touched is set and the loop specification initialised \n+   to default values  */\n+\n static void\n-match_namelist_name (char *name, int len)\n+nml_touch_nodes (namelist_info * nl)\n {\n-  int name_len;\n-  char c;\n-  char * namelist_name = name;\n-\n-  name_len = 0;\n-  /* Match the name of the namelist.  */\n-\n-  if (tolower (next_char ()) != tolower (namelist_name[name_len++]))\n+  index_type len = strlen (nl->var_name) + 1;\n+  int dim;\n+  char * ext_name = (char*)get_mem (len + 1);\n+  strcpy (ext_name, nl->var_name);\n+  strcat (ext_name, \"%\");\n+  for (nl = nl->next; nl; nl = nl->next)\n     {\n-    wrong_name:\n-      generate_error (ERROR_READ_VALUE, \"Wrong namelist name found\");\n-      return;\n+      if (strncmp (nl->var_name, ext_name, len) == 0)\n+\t{\n+\t  nl->touched = 1;\n+\t  for (dim=0; dim < nl->var_rank; dim++)\n+\t    {\n+\t      nl->ls[dim].step = 1;\n+\t      nl->ls[dim].end = nl->dim[dim].ubound;\n+\t      nl->ls[dim].start = nl->dim[dim].lbound;\n+\t      nl->ls[dim].idx = nl->ls[dim].start;\n+\t    }\n+\t}\n+      else\n+\tbreak;\n     }\n+  return;\n+}\n+\n+/* Resets touched for the entire list of nml_nodes, ready for a\n+   new object.  */\n+\n+static void\n+nml_untouch_nodes (void)\n+{\n+  namelist_info * t;\n+  for (t = ionml; t; t = t->next)\n+    t->touched = 0;\n+  return;\n+}\n+\n+/* Attempts to input name to namelist name.  Returns nml_read_error = 1\n+   on no match.  */\n \n-  while (name_len < len)\n+static void\n+nml_match_name (char *name, index_type len)\n+{\n+  index_type i;\n+  char c;\n+  nml_read_error = 0;\n+  for (i = 0; i < len; i++)\n     {\n       c = next_char ();\n-      if (tolower (c) != tolower (namelist_name[name_len++]))\n-        goto wrong_name;\n+      if (tolower (c) != tolower (name[i]))\n+\t{\n+\t  nml_read_error = 1;\n+\t  break;\n+\t}\n     }\n }\n \n+/* If the namelist read is from stdin, output the current state of the\n+   namelist to stdout.  This is used to implement the non-standard query\n+   features, ? and =?. If c == '=' the full namelist is printed. Otherwise\n+   the names alone are printed.  */\n \n-/********************************************************************\n-      Namelist reads\n-********************************************************************/\n-\n-/* Process a namelist read.  This subroutine initializes things,\n-   positions to the first element and \n-   FIXME: was this comment ever complete?  */\n-\n-void\n-namelist_read (void)\n+static void\n+nml_query (char c)\n {\n-  char c;\n-  int name_matched, next_name ;\n+  gfc_unit * temp_unit;\n   namelist_info * nl;\n-  int len, m;\n-  void * p;\n+  index_type len;\n+  char * p;\n \n-  namelist_mode = 1;\n+  if (current_unit->unit_number != options.stdin_unit)\n+    return;\n \n-  if (setjmp (g.eof_jump))\n+  /* Store the current unit and transfer to stdout.  */\n+\n+  temp_unit = current_unit;\n+  current_unit = find_unit (options.stdout_unit);\n+\n+  if (current_unit)\n     {\n-      generate_error (ERROR_END, NULL);\n-      return;\n+      g.mode =WRITING;\n+      next_record (0);\n+\n+      /* Write the namelist in its entirety.  */\n+\n+      if (c == '=')\n+\tnamelist_write ();\n+\n+      /* Or write the list of names.  */\n+\n+      else\n+\t{\n+\n+\t  /* \"&namelist_name\\n\"  */\n+\n+\t  len = ioparm.namelist_name_len;\n+\t  p = write_block (len + 2);\n+\t  if (!p)\n+\t    goto query_return;\n+\t  memcpy (p, \"&\", 1);\n+\t  memcpy ((char*)(p + 1), ioparm.namelist_name, len);\n+\t  memcpy ((char*)(p + len + 1), \"\\n\", 1);\n+\t  for (nl =ionml; nl; nl = nl->next)\n+\t    {\n+\n+\t      /* \" var_name\\n\"  */\n+\n+\t      len = strlen (nl->var_name);\n+\t      p = write_block (len + 2);\n+\t      if (!p)\n+\t\tgoto query_return;\n+\t      memcpy (p, \" \", 1);\n+\t      memcpy ((char*)(p + 1), nl->var_name, len);\n+\t      memcpy ((char*)(p + len + 1), \"\\n\", 1);\n+\t    }\n+\n+\t  /* \"&end\\n\"  */\n+\n+\t  p = write_block (5);\n+\t  if (!p)\n+\t    goto query_return;\n+\t  memcpy (p, \"&end\\n\", 5);\n+\t}\n+\n+      /* Flush the stream to force immediate output.  */\n+\n+      flush (current_unit->s);\n     }\n \n- restart:\n-  c = next_char ();\n-  switch (c)\n-    {\n-    case ' ':\n-      goto restart;\n-    case '!':\n-      do\n-        c = next_char ();\n-      while (c != '\\n');\n+query_return:\n \n-      goto restart;\n+  /* Restore the current unit.  */\n \n-    case '&':\n+  current_unit = temp_unit;\n+  g.mode = READING;\n+  return;\n+}\n+\n+/* Reads and stores the input for the namelist object nl.  For an array,\n+   the function loops over the ranges defined by the loop specification.\n+   This default to all the data or to the specification from a qualifier.\n+   nml_read_obj recursively calls itself to read derived types. It visits\n+   all its own components but only reads data for those that were touched\n+   when the name was parsed.  If a read error is encountered, an attempt is\n+   made to return to read a new object name because the standard allows too\n+   little data to be available.  On the other hand, too much data is an\n+   error.  */\n+\n+static try\n+nml_read_obj (namelist_info * nl, index_type offset)\n+{\n+\n+  namelist_info * cmp;\n+  char * obj_name;\n+  int nml_carry;\n+  int len;\n+  int dim;\n+  index_type dlen;\n+  index_type m;\n+  index_type obj_name_len;\n+  void * pdata ;\n+\n+  /* This object not touched in name parsing.  */\n+\n+  if (!nl->touched)\n+    return SUCCESS;\n+\n+  repeat_count = 0;\n+  eat_spaces();\n+\n+  len = nl->len;\n+  switch (nl->type)\n+  {\n+\n+    case GFC_DTYPE_INTEGER:\n+    case GFC_DTYPE_LOGICAL:\n+    case GFC_DTYPE_REAL:\n+      dlen = len;\n+      break;\n+\n+    case GFC_DTYPE_COMPLEX:\n+      dlen = 2* len;\n+      break;\n+\n+    case GFC_DTYPE_CHARACTER:\n+      dlen = chigh ? (chigh - clow + 1) : nl->string_length;\n       break;\n \n     default:\n-      generate_error (ERROR_READ_VALUE, \"Invalid character in namelist\");\n-      return;\n+      dlen = 0;\n     }\n \n-  /* Match the name of the namelist.  */\n-  match_namelist_name(ioparm.namelist_name, ioparm.namelist_name_len);\n-\n-  /* Ready to read namelist elements.  */\n-  while (!input_complete)\n+  do\n     {\n-      c = next_char ();\n-      switch (c)\n-        {\n-        case '/':\n-          input_complete = 1;\n-          next_record (0);\n-          break;\n-        case '&':\n-          match_namelist_name(\"end\",3);\n-          return;\n-        case '\\\\':\n-          return;\n-        case ' ':\n-        case '\\n':\n-       case '\\r':\n-        case '\\t':\n-          break;\n-        case ',':\n-          next_name = 1;\n-          break;\n \n-        case '=':\n-          name_matched = 1;\n-          nl = find_nml_node (saved_string);\n-          if (nl == NULL)\n-            internal_error (\"Can not match a namelist variable\");\n-          free_saved();\n+      /* Update the pointer to the data, using the current index vector  */\n \n-          len = nl->len;\n-          p = nl->mem_pos;\n+      pdata = (void*)(nl->mem_pos + offset);\n+      for (dim = 0; dim < nl->var_rank; dim++)\n+\tpdata = (void*)(pdata + (nl->ls[dim].idx - nl->dim[dim].lbound) *\n+\t\t nl->dim[dim].stride * nl->size);\n \n-          /* skip any blanks or tabs after the = */\n-          eat_spaces ();\n+      /* Reset the error flag and try to read next value, if \n+\t repeat_count=0  */\n+\n+      nml_read_error = 0;\n+      nml_carry = 0;\n+      if (--repeat_count <= 0)\n+\t{\n+\t  if (input_complete)\n+\t    return SUCCESS;\n+\t  if (at_eol)\n+\t    finish_separator ();\n+\t  if (input_complete)\n+\t    return SUCCESS;\n+\n+\t  /* GFC_TYPE_UNKNOWN through for nulls and is detected\n+\t     after the switch block.  */\n+\n+\t  saved_type = GFC_DTYPE_UNKNOWN;\n+\t  free_saved ();\n  \n           switch (nl->type)\n-            {\n-            case BT_INTEGER:\n+\t  {\n+\t  case GFC_DTYPE_INTEGER:\n               read_integer (len);\n               break;\n-            case BT_LOGICAL:\n+\n+\t  case GFC_DTYPE_LOGICAL:\n               read_logical (len);\n               break;\n-            case BT_CHARACTER:\n+\n+\t  case GFC_DTYPE_CHARACTER:\n               read_character (len);\n               break;\n-            case BT_REAL:\n+\n+\t  case GFC_DTYPE_REAL:\n               read_real (len);\n               break;\n-            case BT_COMPLEX:\n+\n+\t  case GFC_DTYPE_COMPLEX:\n               read_complex (len);\n               break;\n-            default:\n-              internal_error (\"Bad type for namelist read\");\n-            }\n-\n-           switch (saved_type)\n-            {\n-            case BT_COMPLEX:\n-              len = 2 * len;\n-              /* Fall through...  */\n-\n-            case BT_INTEGER:\n-            case BT_REAL:\n-            case BT_LOGICAL:\n-              memcpy (p, value, len);\n-              break;\n \n-            case BT_CHARACTER:\n-              m = (len < saved_used) ? len : saved_used;\n-              memcpy (p, saved_string, m);\n+\t  case GFC_DTYPE_DERIVED:\n+\t    obj_name_len = strlen (nl->var_name) + 1;\n+\t    obj_name = get_mem (obj_name_len+1);\n+\t    strcpy (obj_name, nl->var_name);\n+\t    strcat (obj_name, \"%\");\n+\n+\t    /* Now loop over the components. Update the component pointer\n+\t       with the return value from nml_write_obj.  This loop jumps\n+\t       past nested derived types by testing if the potential \n+\t       component name contains '%'.  */\n+\n+\t    for (cmp = nl->next;\n+\t\t cmp &&\n+\t\t   !strncmp (cmp->var_name, obj_name, obj_name_len) &&\n+\t\t   !strchr (cmp->var_name + obj_name_len, '%');\n+\t\t cmp = cmp->next)\n+\t      {\n+\n+\t\tif (nml_read_obj (cmp, (index_type)(pdata - nl->mem_pos)) == FAILURE)\n+\t\t  return FAILURE;\n+\n+\t\tif (input_complete)\n+\t\t  return SUCCESS;\n+\t      }\n+\n+\t    free_mem (obj_name);\n+\t    goto incr_idx;\n+\n+          default:\n+\t    st_sprintf (nml_err_msg, \"Bad type for namelist object %s\",\n+\t\t\tnl->var_name );\n+\t    internal_error (nml_err_msg);\n+\t    goto nml_err_ret;\n+          }\n+        }\n \n-              if (m < len)\n-                memset (((char *) p) + m, ' ', len - m);\n-              break;\n+      /* The standard permits array data to stop short of the number of\n+\t elements specified in the loop specification.  In this case, we\n+\t should be here with nml_read_error != 0.  Control returns to \n+\t nml_get_obj_data and an attempt is made to read object name.  */\n \n-            case BT_NULL:\n-              break;\n-            }\n+      prev_nl = nl;\n+      if (nml_read_error)\n+\treturn SUCCESS;\n \n-          break;\n+      if (saved_type == GFC_DTYPE_UNKNOWN)\n+\tgoto incr_idx;\n+\n+\n+      /* Note the switch from GFC_DTYPE_type to BT_type at this point.\n+\t This comes about because the read functions return BT_types.  */\n+\n+      switch (saved_type)\n+      {\n+\n+\tcase BT_COMPLEX:\n+\tcase BT_REAL:\n+\tcase BT_INTEGER:\n+\tcase BT_LOGICAL:\n+\t  memcpy (pdata, value, dlen);\n+\t  break;\n+\n+\tcase BT_CHARACTER:\n+\t  m = (dlen < saved_used) ? dlen : saved_used;\n+\t  pdata = (void*)( pdata + clow - 1 );\n+\t  memcpy (pdata, saved_string, m);\n+\t  if (m < dlen)\n+\t    memset ((void*)( pdata + m ), ' ', dlen - m);\n+\tbreak;\n+\n+\tdefault:\n+\t  break;\n+      }\n+\n+      /* Break out of loop if scalar.  */\n+\n+      if (!nl->var_rank)\n+\tbreak;\n+\n+      /* Now increment the index vector.  */\n+\n+incr_idx:\n+\n+      nml_carry = 1;\n+      for (dim = 0; dim < nl->var_rank; dim++)\n+\t{\n+\t  nl->ls[dim].idx += nml_carry * nl->ls[dim].step;\n+\t  nml_carry = 0;\n+\t  if (((nl->ls[dim].step > 0) && (nl->ls[dim].idx > nl->ls[dim].end))\n+\t      ||\n+\t      ((nl->ls[dim].step < 0) && (nl->ls[dim].idx < nl->ls[dim].end)))\n+\t    {\n+\t      nl->ls[dim].idx = nl->ls[dim].start;\n+\t      nml_carry = 1;\n+\t    }\n+        }\n+    } while (!nml_carry);\n+\n+  if (repeat_count > 1)\n+    {\n+       st_sprintf (nml_err_msg, \"Repeat count too large for namelist object %s\" ,\n+\t\t   nl->var_name );\n+       goto nml_err_ret;\n+    }\n+  return SUCCESS;\n+\n+nml_err_ret:\n+\n+  return FAILURE;\n+}\n+\n+/* Parses the object name, including array and substring qualifiers.  It\n+   iterates over derived type components, touching those components and\n+   setting their loop specifications, if there is a qualifier.  If the\n+   object is itself a derived type, its components and subcomponents are\n+   touched.  nml_read_obj is called at the end and this reads the data in\n+   the manner specified by the object name.  */\n+\n+static try\n+nml_get_obj_data (void)\n+{\n+  char c;\n+  char * ext_name;\n+  namelist_info * nl;\n+  namelist_info * first_nl;\n+  namelist_info * root_nl;\n+  int dim;\n+  int component_flag;\n+\n+  /* Look for end of input or object name.  If '?' or '=?' are encountered\n+     in stdin, print the node names or the namelist to stdout.  */\n+\n+  eat_separator ();\n+  if (input_complete)\n+    return SUCCESS;\n+\n+  if ( at_eol )\n+    finish_separator ();\n+  if (input_complete)\n+    return SUCCESS;\n+\n+  c = next_char ();\n+  switch (c)\n+    {\n+    case '=':\n+      c = next_char ();\n+      if (c != '?')\n+\t{\n+\t  st_sprintf (nml_err_msg, \"namelist read: missplaced = sign\");\n+\t  goto nml_err_ret;\n+\t}\n+      nml_query ('=');\n+      return SUCCESS;\n+\n+    case '?':\n+      nml_query ('?');\n+      return SUCCESS;\n+\n+    case '$':\n+    case '&':\n+      nml_match_name (\"end\", 3);\n+      if (nml_read_error)\n+\t{\n+\t  st_sprintf (nml_err_msg, \"namelist not terminated with / or &end\");\n+\t  goto nml_err_ret;\n+\t}\n+    case '/':\n+      input_complete = 1;\n+      return SUCCESS;\n+\n+    default :\n+      break;\n+    }\n+\n+  /* Untouch all nodes of the namelist and reset the flag that is set for\n+     derived type components.  */\n+\n+  nml_untouch_nodes();\n+  component_flag = 0;\n+\n+  /* Get the object name - should '!' and '\\n' be permitted separators?  */\n+\n+get_name:\n+\n+  free_saved ();\n+\n+  do\n+    {\n+      push_char(tolower(c));\n+      c = next_char ();\n+    } while (!( c=='=' || c==' ' || c=='\\t' || c =='(' || c =='%' ));\n+\n+  unget_char (c);\n+\n+  /* Check that the name is in the namelist and get pointer to object.\n+     Three error conditions exist: (i) An attempt is being made to\n+     identify a non-existent object, following a failed data read or\n+     (ii) The object name does not exist or (iii) Too many data items\n+     are present for an object.  (iii) gives the same error message\n+     as (i)  */\n+\n+  push_char ('\\0');\n+\n+  if (component_flag)\n+    {\n+      ext_name = (char*)get_mem (strlen (root_nl->var_name) +\n+\t\t  saved_string ? strlen (saved_string) : 0 + 1);\n+      strcpy (ext_name, root_nl->var_name);\n+      strcat (ext_name, saved_string);\n+      nl = find_nml_node (ext_name);\n+    }\n+  else\n+    nl = find_nml_node (saved_string);\n+\n+  if (nl == NULL)\n+    {\n+      if (nml_read_error && prev_nl)\n+\tst_sprintf (nml_err_msg, \"Bad data for namelist object %s\",\n+\t\t    prev_nl->var_name);\n+\n+      else\n+\tst_sprintf (nml_err_msg, \"Cannot match namelist object name %s\",\n+\t\t    saved_string);\n+\n+      goto nml_err_ret;\n+    }\n+\n+  /* Get the length, data length, base pointer and rank of the variable.\n+     Set the default loop specification first.  */\n+\n+  for (dim=0; dim < nl->var_rank; dim++)\n+    {\n+      nl->ls[dim].step = 1;\n+      nl->ls[dim].end = nl->dim[dim].ubound;\n+      nl->ls[dim].start = nl->dim[dim].lbound;\n+      nl->ls[dim].idx = nl->ls[dim].start;\n+    }\n+\n+/* Check to see if there is a qualifier: if so, parse it.*/\n+\n+  if (c == '(' && nl->var_rank)\n+    {\n+      if (nml_parse_qualifier (nl->dim, nl->ls, nl->var_rank) == FAILURE)\n+\t{\n+\t  st_sprintf (nml_err_msg, \"%s for namelist variable %s\",\n+\t\t      parse_err_msg, nl->var_name);\n+\t  goto nml_err_ret;\n+\t}\n+      c = next_char ();\n+      unget_char (c);\n+    }\n+\n+  /* Now parse a derived type component. The root namelist_info address\n+     is backed up, as is the previous component level.  The  component flag\n+     is set and the iteration is made by jumping back to get_name.  */\n+\n+  if (c == '%')\n+    {\n+\n+      if (nl->type != GFC_DTYPE_DERIVED)\n+\t{\n+\t  st_sprintf (nml_err_msg, \"Attempt to get derived component for %s\",\n+\t\t      nl->var_name);\n+\t  goto nml_err_ret;\n+\t}\n+\n+      if (!component_flag)\n+\tfirst_nl = nl;\n+\n+      root_nl = nl;\n+      component_flag = 1;\n+      c = next_char ();\n+      goto get_name;\n+\n+    }\n+\n+  /* Parse a character qualifier, if present.  chigh = 0 is a default\n+     that signals that the string length = string_length.  */\n+\n+  clow = 1;\n+  chigh = 0;\n+\n+  if (c == '(' && nl->type == GFC_DTYPE_CHARACTER)\n+    {\n+      descriptor_dimension chd[1] = {1, clow, nl->string_length};\n+      nml_loop_spec ind[1] = {1, clow, nl->string_length, 1};\n+\n+      if (nml_parse_qualifier (chd, ind, 1) == FAILURE)\n+\t{\n+\t  st_sprintf (nml_err_msg, \"%s for namelist variable %s\",\n+\t\t      parse_err_msg, nl->var_name);\n+\t  goto nml_err_ret;\n+\t}\n+\n+      clow = ind[0].start;\n+      chigh = ind[0].end;\n+\n+      if (ind[0].step != 1)\n+\t{\n+\t  st_sprintf (nml_err_msg,\n+\t\t      \"Bad step in substring for namelist object %s\",\n+\t\t      nl->var_name);\n+\t  goto nml_err_ret;\n+\t}\n+\n+      c = next_char ();\n+      unget_char (c);\n+    }\n+\n+  /* If a derived type touch its components and restore the root\n+     namelist_info if we have parsed a qualified derived type\n+     component.  */\n+\n+  if (nl->type == GFC_DTYPE_DERIVED)\n+    nml_touch_nodes (nl);\n+  if (component_flag)\n+    nl = first_nl;\n+\n+  /*make sure no extraneous qualifiers are there.*/\n+\n+  if (c == '(')\n+    {\n+      st_sprintf (nml_err_msg, \"Qualifier for a scalar or non-character\"\n+\t\t  \" namelist object %s\", nl->var_name);\n+      goto nml_err_ret;\n+    }\n+\n+/* According to the standard, an equal sign MUST follow an object name. The\n+   following is possibly lax - it allows comments, blank lines and so on to\n+   intervene.  eat_spaces (); c = next_char (); would be compliant*/\n+\n+  free_saved ();\n+\n+  eat_separator ();\n+  if (input_complete)\n+    return SUCCESS;\n+\n+  if (at_eol)\n+    finish_separator ();\n+  if (input_complete)\n+    return SUCCESS;\n+\n+  c = next_char ();\n+\n+  if (c != '=')\n+    {\n+      st_sprintf (nml_err_msg, \"Equal sign must follow namelist object name %s\",\n+\t\t  nl->var_name);\n+      goto nml_err_ret;\n+    }\n \n-        default :\n-          push_char(tolower(c));\n+  if (nml_read_obj (nl, 0) == FAILURE)\n+    goto nml_err_ret;\n+\n+  return SUCCESS;\n+\n+nml_err_ret:\n+\n+  return FAILURE;\n+}\n+\n+/* Entry point for namelist input.  Goes through input until namelist name\n+  is matched.  Then cycles through nml_get_obj_data until the input is\n+  completed or there is an error.  */\n+\n+void\n+namelist_read (void)\n+{\n+  char c;\n+\n+  namelist_mode = 1;\n+  input_complete = 0;\n+\n+  if (setjmp (g.eof_jump))\n+    {\n+      generate_error (ERROR_END, NULL);\n+      return;\n+    }\n+\n+  /* Look for &namelist_name .  Skip all characters, testing for $nmlname.\n+     Exit on success or EOF. If '?' or '=?' encountered in stdin, print\n+     node names or namelist on stdout.  */\n+\n+find_nml_name:\n+  switch (c = next_char ())\n+    {\n+    case '$':\n+    case '&':\n           break;\n+\n+    case '=':\n+      c = next_char ();\n+      if (c == '?')\n+\tnml_query ('=');\n+      else\n+\tunget_char (c);\n+      goto find_nml_name;\n+\n+    case '?':\n+      nml_query ('?');\n+\n+    default:\n+      goto find_nml_name;\n+    }\n+\n+  /* Match the name of the namelist.  */\n+\n+  nml_match_name (ioparm.namelist_name, ioparm.namelist_name_len);\n+\n+  if (nml_read_error)\n+    goto find_nml_name;\n+\n+  /* Ready to read namelist objects.  If there is an error in input\n+     from stdin, output the error message and continue.  */\n+\n+  while (!input_complete)\n+    {\n+      if (nml_get_obj_data ()  == FAILURE)\n+\t{\n+\t  if (current_unit->unit_number != options.stdin_unit)\n+\t    goto nml_err_ret;\n+\n+\t  st_printf (\"%s\\n\", nml_err_msg);\n+\t  flush (find_unit (options.stderr_unit)->s);\n         }\n+\n    }\n+\n+  return;\n+\n+  /* All namelist error calls return from here */\n+\n+nml_err_ret:\n+\n+  generate_error (ERROR_READ_VALUE , nml_err_msg);\n+  return;\n }"}, {"sha": "d85c9b8c93f9e06d2c8e48667df1d3bd54c8bce1", "filename": "libgfortran/io/lock.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flock.c?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,5 +1,5 @@\n /* Thread/recursion locking\n-   Copyright 2002 Free Software Foundation, Inc.\n+   Copyright 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org> and Andy Vaught\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -73,20 +73,28 @@ library_end (void)\n   g.in_library = 0;\n   filename = NULL;\n   line = 0;\n-\n   t = ioparm.library_return;\n+\n+  /* Delete the namelist, if it exists.  */\n+\n   if (ionml != NULL)\n     {\n       t1 = ionml;\n       while (t1 != NULL)\n-       {\n-         t2 = t1;\n-         t1 = t1->next;\n-         free_mem (t2);\n-       }\n+\t{\n+\t  t2 = t1;\n+\t  t1 = t1->next;\n+\t  free_mem (t2->var_name);\n+\t  if (t2->var_rank)\n+\t    {\n+\t     free_mem (t2->dim);\n+\t     free_mem (t2->ls);\n+\t    }\n+\t  free_mem (t2);\n+\t}\n     }\n-  \n   ionml = NULL;\n+\n   memset (&ioparm, '\\0', sizeof (ioparm));\n   ioparm.library_return = t;\n }"}, {"sha": "bece250d78ca1a5c9995741d7098a44dada4d3c3", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 51, "deletions": 66, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,5 +1,6 @@\n /* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   Namelist transfer functions contributed by Paul Thomas\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -1623,94 +1624,78 @@ st_write_done (void)\n   library_end ();\n }\n \n+/* Receives the scalar information for namelist objects and stores it\n+   in a linked list of namelist_info types.  */\n \n-static void\n-st_set_nml_var (void * var_addr, char * var_name, int var_name_len,\n-                int kind, bt type, int string_length)\n+void\n+st_set_nml_var (void * var_addr, char * var_name, GFC_INTEGER_4 len,\n+\t\tgfc_charlen_type string_length, GFC_INTEGER_4 dtype)\n {\n-  namelist_info *t1 = NULL, *t2 = NULL;\n-  namelist_info *nml = (namelist_info *) get_mem (sizeof (namelist_info));\n+  namelist_info *t1 = NULL;\n+  namelist_info *nml;\n+\n+  nml = (namelist_info*) get_mem (sizeof (namelist_info));\n+\n   nml->mem_pos = var_addr;\n-  if (var_name)\n+\n+  nml->var_name = (char*) get_mem (strlen (var_name) + 1);\n+  strcpy (nml->var_name, var_name);\n+\n+  nml->len = (int) len;\n+  nml->string_length = (index_type) string_length;\n+\n+  nml->var_rank = (int) (dtype & GFC_DTYPE_RANK_MASK);\n+  nml->size = (index_type) (dtype >> GFC_DTYPE_SIZE_SHIFT);\n+  nml->type = (bt) ((dtype & GFC_DTYPE_TYPE_MASK) >> GFC_DTYPE_TYPE_SHIFT);\n+\n+  if (nml->var_rank > 0)\n     {\n-      assert (var_name_len > 0);\n-      nml->var_name = (char*) get_mem (var_name_len+1);\n-      strncpy (nml->var_name, var_name, var_name_len);\n-      nml->var_name[var_name_len] = 0;\n+      nml->dim = (descriptor_dimension*)\n+\t\t   get_mem (nml->var_rank * sizeof (descriptor_dimension));\n+      nml->ls = (nml_loop_spec*)\n+\t\t  get_mem (nml->var_rank * sizeof (nml_loop_spec));\n     }\n   else\n     {\n-      assert (var_name_len == 0);\n-      nml->var_name = NULL;\n+      nml->dim = NULL;\n+      nml->ls = NULL;\n     }\n \n-  nml->len = kind;\n-  nml->type = type;\n-  nml->string_length = string_length;\n-\n   nml->next = NULL;\n \n   if (ionml == NULL)\n-     ionml = nml;\n+    ionml = nml;\n   else\n     {\n-      t1 = ionml;\n-      while (t1 != NULL)\n-       {\n-         t2 = t1;\n-         t1 = t1->next;\n-       }\n-       t2->next = nml;\n+      for (t1 = ionml; t1->next; t1 = t1->next);\n+      t1->next = nml;\n     }\n+  return;\n }\n \n-extern void st_set_nml_var_int (void *, char *, int, int);\n-export_proto(st_set_nml_var_int);\n-\n-extern void st_set_nml_var_float (void *, char *, int, int);\n-export_proto(st_set_nml_var_float);\n-\n-extern void st_set_nml_var_char (void *, char *, int, int, gfc_charlen_type);\n-export_proto(st_set_nml_var_char);\n-\n-extern void st_set_nml_var_complex (void *, char *, int, int);\n-export_proto(st_set_nml_var_complex);\n-\n-extern void st_set_nml_var_log (void *, char *, int, int);\n-export_proto(st_set_nml_var_log);\n+/* Store the dimensional information for the namelist object.  */\n \n void\n-st_set_nml_var_int (void * var_addr, char * var_name, int var_name_len,\n-\t\t    int kind)\n+st_set_nml_var_dim (GFC_INTEGER_4 n_dim, GFC_INTEGER_4 stride,\n+\t\t    GFC_INTEGER_4 lbound, GFC_INTEGER_4 ubound)\n {\n-  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_INTEGER, 0);\n-}\n+  namelist_info * nml;\n+  int n;\n \n-void\n-st_set_nml_var_float (void * var_addr, char * var_name, int var_name_len,\n-\t\t      int kind)\n-{\n-  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_REAL, 0);\n-}\n+  n = (int)n_dim;\n \n-void\n-st_set_nml_var_char (void * var_addr, char * var_name, int var_name_len,\n-\t\t     int kind, gfc_charlen_type string_length)\n-{\n-  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_CHARACTER,\n-\t\t  string_length);\n-}\n+  for (nml = ionml; nml->next; nml = nml->next);\n \n-void\n-st_set_nml_var_complex (void * var_addr, char * var_name, int var_name_len,\n-\t\t\tint kind)\n-{\n-  st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_COMPLEX, 0);\n+  nml->dim[n].stride = (ssize_t)stride;\n+  nml->dim[n].lbound = (ssize_t)lbound;\n+  nml->dim[n].ubound = (ssize_t)ubound;\n }\n \n-void\n-st_set_nml_var_log (void * var_addr, char * var_name, int var_name_len,\n-\t\t    int kind)\n-{\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_LOGICAL, 0);\n-}\n+extern void st_set_nml_var (void * ,char * ,\n+\t\t\t    GFC_INTEGER_4 ,gfc_charlen_type ,GFC_INTEGER_4);\n+export_proto(st_set_nml_var);\n+\n+extern void st_set_nml_var_dim (GFC_INTEGER_4, GFC_INTEGER_4,\n+\t\t\t\tGFC_INTEGER_4 ,GFC_INTEGER_4);\n+export_proto(st_set_nml_var_dim);\n+"}, {"sha": "c57ebac621938d30ed00f3fc34471e494cf6b711", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 327, "deletions": 36, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dc5138c3af990d84d312ac52954021b0ac8c3c/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=29dc5138c3af990d84d312ac52954021b0ac8c3c", "patch": "@@ -1,5 +1,6 @@\n /* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   Namelist output contibuted by Paul Thomas\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -29,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <string.h>\n+#include <ctype.h>\n #include <float.h>\n #include <stdio.h>\n #include <stdlib.h>\n@@ -44,6 +46,8 @@ typedef enum\n sign_t;\n \n \n+static int no_leading_blank = 0 ;\n+\n void\n write_a (fnode * f, const char *source, int len)\n {\n@@ -576,7 +580,9 @@ output_float (fnode *f, double value, int len)\n     leadzero = 0;\n \n   /* Padd to full field width.  */\n-  if (nblanks > 0)\n+\n+\n+  if ( ( nblanks > 0 ) && !no_leading_blank )\n     {\n       memset (out, ' ', nblanks);\n       out += nblanks;\n@@ -650,6 +656,13 @@ output_float (fnode *f, double value, int len)\n #endif\n       memcpy (out, buffer, edigits);\n     }\n+\n+  if ( no_leading_blank )\n+    {\n+      out += edigits;\n+      memset( out , ' ' , nblanks );\n+      no_leading_blank = 0;\n+    }\n }\n \n \n@@ -802,13 +815,24 @@ write_int (fnode *f, const char *source, int len, char *(*conv) (uint64_t))\n       goto done;\n     }\n \n+\n+  if (!no_leading_blank)\n+    {\n   memset (p, ' ', nblank);\n   p += nblank;\n-\n   memset (p, '0', nzero);\n   p += nzero;\n-\n   memcpy (p, q, digits);\n+    }\n+  else\n+    {\n+      memset (p, '0', nzero);\n+      p += nzero;\n+      memcpy (p, q, digits);\n+      p += digits;\n+      memset (p, ' ', nblank);\n+      no_leading_blank = 0;\n+    }\n \n  done:\n   return;\n@@ -1102,9 +1126,16 @@ write_integer (const char *source, int length)\n   if(width < digits )\n     width = digits ;\n   p = write_block (width) ;\n-\n+  if (no_leading_blank)\n+    {\n+      memcpy (p, q, digits);\n+      memset(p + digits ,' ', width - digits) ;\n+    }\n+  else\n+    {\n   memset(p ,' ', width - digits) ;\n   memcpy (p + width - digits, q, digits);\n+    }\n }\n \n \n@@ -1269,60 +1300,320 @@ list_formatted_write (bt type, void *p, int len)\n   char_flag = (type == BT_CHARACTER);\n }\n \n-void\n-namelist_write (void)\n-{\n-  namelist_info * t1, *t2;\n-  int len,num;\n-  void * p;\n+/*\t\t\tNAMELIST OUTPUT\n \n-  num = 0;\n-  write_character(\"&\",1);\n-  write_character (ioparm.namelist_name, ioparm.namelist_name_len);\n-  write_character(\"\\n\",1);\n+   nml_write_obj writes a namelist object to the output stream.  It is called\n+   recursively for derived type components:\n+\tobj    = is the namelist_info for the current object.\n+\toffset = the offset relative to the address held by the object for\n+\t\t derived type arrays.\n+\tbase   = is the namelist_info of the derived type, when obj is a\n+\t\t component.\n+\tbase_name = the full name for a derived type, including qualifiers\n+\t\t    if any.\n+   The returned value is a pointer to the object beyond the last one\n+   accessed, including nested derived types.  Notice that the namelist is\n+   a linear linked list of objects, including derived types and their\n+   components.  A tree, of sorts, is implied by the compound names of\n+   the derived type components and this is how this function recurses through\n+   the list.  */\n \n-  if (ionml != NULL)\n+/* A generous estimate of the number of characters needed to print\n+   repeat counts and indices, including commas, asterices and brackets.  */\n+\n+#define NML_DIGITS 20\n+\n+/* Stores the delimiter to be used for character objects.  */\n+\n+static char * nml_delim;\n+\n+static namelist_info *\n+nml_write_obj (namelist_info * obj, index_type offset,\n+\t       namelist_info * base, char * base_name)\n+{\n+  int rep_ctr;\n+  int num;\n+  int nml_carry;\n+  index_type len;\n+  index_type obj_size;\n+  index_type nelem;\n+  index_type dim_i;\n+  index_type clen;\n+  index_type elem_ctr;\n+  index_type obj_name_len;\n+  void * p ;\n+  char cup;\n+  char * obj_name;\n+  char * ext_name;\n+  char rep_buff[NML_DIGITS];\n+  namelist_info * cmp;\n+  namelist_info * retval = obj->next;\n+\n+  /* Write namelist variable names in upper case. If a derived type,\n+     nothing is output.  If a component, base and base_name are set.  */\n+\n+  if (obj->type != GFC_DTYPE_DERIVED)\n     {\n-      t1 = ionml;\n-      while (t1 != NULL)\n+      write_character (\"\\n \", 2);\n+      len = 0;\n+      if (base)\n \t{\n-          num ++;\n-          t2 = t1;\n-          t1 = t1->next;\n-          if (t2->var_name)\n+\t  len =strlen (base->var_name);\n+\t  for (dim_i = 0; dim_i < strlen (base_name); dim_i++)\n             {\n-              write_character(t2->var_name, strlen(t2->var_name));\n-              write_character(\"=\",1);\n+\t      cup = toupper (base_name[dim_i]);\n+\t      write_character (&cup, 1);\n             }\n-          len = t2->len;\n-          p = t2->mem_pos;\n-          switch (t2->type)\n-            {\n-            case BT_INTEGER:\n+\t}\n+      for (dim_i =len; dim_i < strlen (obj->var_name); dim_i++)\n+\t{\n+\t  cup = toupper (obj->var_name[dim_i]);\n+\t  write_character (&cup, 1);\n+\t}\n+      write_character (\"=\", 1);\n+    }\n+\n+  /* Counts the number of data output on a line, including names.  */\n+\n+  num = 1;\n+\n+  len = obj->len;\n+  obj_size = len;\n+  if (obj->type == GFC_DTYPE_COMPLEX)\n+    obj_size = 2*len;\n+  if (obj->type == GFC_DTYPE_CHARACTER)\n+    obj_size = obj->string_length;\n+  if (obj->var_rank)\n+    obj_size = obj->size;\n+\n+  /* Set the index vector and count the number of elements.  */\n+\n+  nelem = 1;\n+  for (dim_i=0; dim_i < obj->var_rank; dim_i++)\n+    {\n+      obj->ls[dim_i].idx = obj->dim[dim_i].lbound;\n+      nelem = nelem * (obj->dim[dim_i].ubound + 1 - obj->dim[dim_i].lbound);\n+    }\n+\n+  /* Main loop to output the data held in the object.  */\n+\n+  rep_ctr = 1;\n+  for (elem_ctr = 0; elem_ctr < nelem; elem_ctr++)\n+    {\n+\n+      /* Build the pointer to the data value.  The offset is passed by\n+\t recursive calls to this function for arrays of derived types.\n+\t Is NULL otherwise.  */\n+\n+      p = (void *)(obj->mem_pos + elem_ctr * obj_size);\n+      p += offset;\n+\n+      /* Check for repeat counts of intrinsic types.  */\n+\n+      if ((elem_ctr < (nelem - 1)) &&\n+\t  (obj->type != GFC_DTYPE_DERIVED) &&\n+\t  !memcmp (p, (void*)(p + obj_size ), obj_size ))\n+\t{\n+\t  rep_ctr++;\n+\t}\n+\n+      /* Execute a repeated output.  Note the flag no_leading_blank that\n+\t is used in the functions used to output the intrinsic types.  */\n+\n+      else\n+\t{\n+\t  if (rep_ctr > 1)\n+\t    {\n+\t      st_sprintf(rep_buff, \" %d*\", rep_ctr);\n+\t      write_character (rep_buff, strlen (rep_buff));\n+\t      no_leading_blank = 1;\n+\t    }\n+\t  num++;\n+\n+\t  /* Output the data, if an intrinsic type, or recurse into this \n+\t     routine to treat derived types.  */\n+\n+\t  switch (obj->type)\n+\t    {\n+\n+\t    case GFC_DTYPE_INTEGER:\n               write_integer (p, len);\n               break;\n-            case BT_LOGICAL:\n+\n+\t    case GFC_DTYPE_LOGICAL:\n               write_logical (p, len);\n               break;\n-            case BT_CHARACTER:\n-              write_character (p, t2->string_length);\n+\n+\t    case GFC_DTYPE_CHARACTER:\n+\t      if (nml_delim)\n+\t\twrite_character (nml_delim, 1);\n+\t      write_character (p, obj->string_length);\n+\t      if (nml_delim)\n+\t\twrite_character (nml_delim, 1);\n               break;\n-            case BT_REAL:\n+\n+\t    case GFC_DTYPE_REAL:\n               write_real (p, len);\n               break;\n-            case BT_COMPLEX:\n+\n+\t    case GFC_DTYPE_COMPLEX:\n+\t      no_leading_blank = 0;\n+\t      num++;\n               write_complex (p, len);\n               break;\n+\n+\t    case GFC_DTYPE_DERIVED:\n+\n+\t      /* To treat a derived type, we need to build two strings:\n+\t\t ext_name = the name, including qualifiers that prepends\n+\t\t\t    component names in the output - passed to \n+\t\t\t    nml_write_obj.\n+\t\t obj_name = the derived type name with no qualifiers but %\n+\t\t\t    appended.  This is used to identify the \n+\t\t\t    components.  */\n+\n+\t      /* First ext_name => get length of all possible components  */\n+\n+\t      ext_name = (char*)get_mem ( (base_name ? strlen (base_name) : 0)\n+\t\t\t\t\t+ (base ? strlen (base->var_name) : 0)\n+\t\t\t\t\t+ strlen (obj->var_name)\n+\t\t\t\t\t+ obj->var_rank * NML_DIGITS);\n+\n+\t      strcpy(ext_name, base_name ? base_name : \"\");\n+\t      clen = base ? strlen (base->var_name) : 0;\n+\t      strcat (ext_name, obj->var_name + clen);\n+\n+\t      /* Append the qualifier.  */\n+\n+\t      for (dim_i = 0; dim_i < obj->var_rank; dim_i++)\n+\t\t{\n+\t\t  strcat (ext_name, dim_i ? \"\" : \"(\");\n+\t\t  clen = strlen (ext_name);\n+\t\t  st_sprintf (ext_name + clen, \"%d\", obj->ls[dim_i].idx);\n+\t\t  strcat (ext_name, (dim_i == obj->var_rank - 1) ? \")\" : \",\");\n+\t\t}\n+\n+\t      /* Now obj_name.  */\n+\n+\t      obj_name_len = strlen (obj->var_name) + 1;\n+\t      obj_name = get_mem (obj_name_len+1);\n+\t      strcpy (obj_name, obj->var_name);\n+\t      strcat (obj_name, \"%\");\n+\n+\t      /* Now loop over the components. Update the component pointer\n+\t\t with the return value from nml_write_obj => this loop jumps\n+\t\t past nested derived types.  */\n+\n+\t      for (cmp = obj->next;\n+\t\t   cmp && !strncmp (cmp->var_name, obj_name, obj_name_len);\n+\t\t   cmp = retval)\n+\t\t{\n+\t\t  retval = nml_write_obj (cmp, (index_type)(p - obj->mem_pos),\n+\t\t\t\t\t  obj, ext_name);\n+\t\t}\n+\n+\t      free_mem (obj_name);\n+\t      free_mem (ext_name);\n+\t      goto obj_loop;\n+\n             default:\n               internal_error (\"Bad type for namelist write\");\n             }\n-\t  write_character(\",\",1);\n+\n+\t  /* Reset the leading blank suppression, write a comma and, if 5\n+\t     values have been output, write a newline and advance to column\n+\t     2. Reset the repeat counter.  */\n+\n+\t  no_leading_blank = 0;\n+\t  write_character (\",\", 1);\n \t  if (num > 5)\n \t    {\n \t      num = 0;\n-\t      write_character(\"\\n\",1);\n+\t      write_character (\"\\n \", 2);\n+\t    }\n+\t  rep_ctr = 1;\n+\t}\n+\n+    /* Cycle through and increment the index vector.  */\n+\n+obj_loop:\n+\n+    nml_carry = 1;\n+    for (dim_i = 0; nml_carry && (dim_i < obj->var_rank); dim_i++)\n+      {\n+\tobj->ls[dim_i].idx += nml_carry ;\n+\tnml_carry = 0;\n+\tif (obj->ls[dim_i].idx  > (ssize_t)obj->dim[dim_i].ubound)\n+\t  {\n+\t    obj->ls[dim_i].idx = obj->dim[dim_i].lbound;\n+\t    nml_carry = 1;\n+\t  }\n+       }\n+    }\n+\n+  /* Return a pointer beyond the furthest object accessed.  */\n+\n+  return retval;\n+}\n+\n+/* This is the entry function for namelist writes.  It outputs the name\n+   of the namelist and iterates through the namelist by calls to \n+   nml_write_obj.  The call below has dummys in the arguments used in \n+   the treatment of derived types.  */\n+\n+void\n+namelist_write (void)\n+{\n+  namelist_info * t1, *t2, *dummy = NULL;\n+  index_type i;\n+  index_type dummy_offset = 0;\n+  char c;\n+  char * dummy_name = NULL;\n+  unit_delim tmp_delim;\n+\n+  /* Set the delimiter for namelist output.  */\n+\n+  tmp_delim = current_unit->flags.delim;\n+  current_unit->flags.delim = DELIM_NONE;\n+  switch (tmp_delim)\n+    {\n+    case (DELIM_QUOTE):\n+      nml_delim = \"\\\"\";\n+      break;\n+\n+    case (DELIM_APOSTROPHE):\n+      nml_delim = \"'\";\n+      break;\n+\n+    default:\n+      nml_delim = NULL;\n+    }\n+\n+  write_character (\"&\",1);\n+\n+  /* Write namelist name in upper case - f95 std.  */\n+\n+  for (i = 0 ;i < ioparm.namelist_name_len ;i++ )\n+    {\n+      c = toupper (ioparm.namelist_name[i]);\n+      write_character (&c ,1);\n \t    }\n+\n+  if (ionml != NULL)\n+    {\n+      t1 = ionml;\n+      while (t1 != NULL)\n+\t{\n+\t  t2 = t1;\n+\t  t1 = nml_write_obj (t2, dummy_offset, dummy, dummy_name);\n \t}\n     }\n-  write_character(\"/\",1);\n+  write_character (\"  /\\n\", 4);\n+\n+  /* Recover the original delimiter.  */\n+\n+  current_unit->flags.delim = tmp_delim;\n }\n+\n+#undef NML_DIGITS\n+"}]}