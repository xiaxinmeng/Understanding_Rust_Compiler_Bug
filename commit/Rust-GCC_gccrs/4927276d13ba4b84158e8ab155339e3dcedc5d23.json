{"sha": "4927276d13ba4b84158e8ab155339e3dcedc5d23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkyNzI3NmQxM2JhNGI4NDE1OGU4YWIxNTUzMzllM2RjZWRjNWQyMw==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-11T20:12:06Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-11T20:12:06Z"}, "message": "x\n\nFrom-SVN: r13121", "tree": {"sha": "a118b8a2dcfbf02cca6e2ce3ba87ef56df36daa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a118b8a2dcfbf02cca6e2ce3ba87ef56df36daa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4927276d13ba4b84158e8ab155339e3dcedc5d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4927276d13ba4b84158e8ab155339e3dcedc5d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4927276d13ba4b84158e8ab155339e3dcedc5d23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4927276d13ba4b84158e8ab155339e3dcedc5d23/comments", "author": null, "committer": null, "parents": [{"sha": "810e3c45595f4076226ad67c5cbee217c15c3bc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/810e3c45595f4076226ad67c5cbee217c15c3bc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/810e3c45595f4076226ad67c5cbee217c15c3bc5"}], "stats": {"total": 184, "additions": 118, "deletions": 66}, "files": [{"sha": "03cbf5f7f93d82c60c54e4ac21b39585e383a1cd", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 87, "deletions": 16, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4927276d13ba4b84158e8ab155339e3dcedc5d23/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4927276d13ba4b84158e8ab155339e3dcedc5d23/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=4927276d13ba4b84158e8ab155339e3dcedc5d23", "patch": "@@ -144,9 +144,10 @@ Boston, MA 02111-1307, USA.  */\n \n #undef SET_ASM_OP\t/* Has no equivalent.  See ASM_OUTPUT_DEF below.  */\n \n-/* This is how to equate one symbol to another symbol.  The syntax used is\n-   `SYM1=SYM2'.  Note that this is different from the way equates are done\n-   with most svr4 assemblers, where the syntax is `.set SYM1,SYM2'.  */\n+#if 0\n+/* This is *NOT* how to equate one symbol to another symbol.  The assembler\n+   '=' syntax just equates a name to a constant expression.\n+   See ASM_OUTPUT_WEAK_ALIAS.  */\n \n #define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n  do {\tfprintf ((FILE), \"\\t\");\t\t\t\t\t\t\\\n@@ -155,6 +156,28 @@ Boston, MA 02111-1307, USA.  */\n \tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n \tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n   } while (0)\n+#endif\n+\n+/* Define the strings used for the special svr4 .type and .size directives.  */\n+\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+\n+/* This is how we tell the assembler that a symbol is weak.  */\n+\n+#define ASM_OUTPUT_WEAK_ALIAS(FILE,NAME,VALUE)\t\\\n+ do {\t\t\t\t\t\t\\\n+  fputs (\"\\t.weakext\\t\", FILE);\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\\\n+  if (VALUE)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fputc (' ', FILE);\t\t\t\\\n+      assemble_name (FILE, VALUE);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  fputc ('\\n', FILE);\t\t\t\t\\\n+ } while (0)\n+\n+#define ASM_WEAKEN_LABEL(FILE,NAME) ASM_OUTPUT_WEAK_ALIAS(FILE,NAME,0)\n \n #define POPSECTION_ASM_OP\t\".popsection\"\n \n@@ -195,6 +218,7 @@ Boston, MA 02111-1307, USA.  */\n    and dtor lists this way, so we use -init and -fini to invoke the\n    do_global_* functions instead of running collect2.  */\n \n+#define BSS_SECTION_ASM_OP\t\".section\\t.bss\"\n #define CONST_SECTION_ASM_OP_32\t\"\\t.rdata\"\n #define CONST_SECTION_ASM_OP_64\t\".section\\t.rodata\"\n #define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,1,2,0,4\"\n@@ -323,22 +347,69 @@ while (0)\n \n /* ??? SGI assembler gives warning whenever .lcomm is used.  */\n #undef ASM_OUTPUT_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)\t\\\n-do\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    if (mips_abi != ABI_32)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfputs (\"\\t.section\\t.bss\\n\", STREAM);\t\t\t\\\n-\tASM_DECLARE_OBJECT_NAME (STREAM, NAME, 0);\t\t\\\n-\tASM_OUTPUT_ALIGN (STREAM, floor_log2 (ALIGN / BITS_PER_UNIT));\t\\\n-\tASM_OUTPUT_SKIP (STREAM, SIZE);\t\t\t\t\\\n-\tfprintf (STREAM, \"\\t%s\\n\", POPSECTION_ASM_OP);\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)\t\t   \\\n+do\t\t\t\t\t\t\t\t\t   \\\n+  {\t\t\t\t\t\t\t\t\t   \\\n+    if (mips_abi != ABI_32)\t\t\t\t\t\t   \\\n+      {\t\t\t\t\t\t\t\t\t   \\\n+\tfprintf (STREAM, \"%s\\n\", BSS_SECTION_ASM_OP);\t\t\t   \\\n+\tmips_declare_object (STREAM, NAME, \"\", \":\\n\", 0);\t\t   \\\n+\tASM_OUTPUT_ALIGN (STREAM, floor_log2 (ALIGN / BITS_PER_UNIT));\t   \\\n+\tASM_OUTPUT_SKIP (STREAM, SIZE);\t\t\t\t\t   \\\n+\tfprintf (STREAM, \"\\t%s\\n\", POPSECTION_ASM_OP);\t\t\t   \\\n+      }\t\t\t\t\t\t\t\t\t   \\\n+    else\t\t\t\t\t\t\t\t   \\\n       mips_declare_object (STREAM, NAME, \"\\n\\t.lcomm\\t\", \",%u\\n\", (SIZE)); \\\n-  }\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t   \\\n while (0)\n \n+/* A C statement (sans semicolon) to output to the stdio stream\n+   FILE the assembler definition of uninitialized global DECL named\n+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.\n+   Try to use asm_output_aligned_bss to implement this macro.  */\n+\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+ {\t\t\t\t\t\t\t\t\t\\\n+   size_directive_output = 0;\t\t\t\t\t\t\\\n+   if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\\\n+     {\t\t\t\t\t\t\t\t\t\\\n+       size_directive_output = 1;\t\t\t\t\t\\\n+       fprintf (STREAM, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\\\n+       assemble_name (STREAM, NAME);\t\t\t\t\t\\\n+       fprintf (STREAM, \",%d\\n\", int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+     }\t\t\t\t\t\t\t\t\t\\\n+   mips_declare_object (STREAM, NAME, \"\", \":\\n\", 0);\t\t\t\\\n+ }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL))); \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n #undef LOCAL_LABEL_PREFIX\n #define LOCAL_LABEL_PREFIX (mips_abi == ABI_32 ? \"$\" : \".\")\n "}, {"sha": "51c58ffaaeac1953975fb94168ab56db70a5792f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4927276d13ba4b84158e8ab155339e3dcedc5d23/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4927276d13ba4b84158e8ab155339e3dcedc5d23/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4927276d13ba4b84158e8ab155339e3dcedc5d23", "patch": "@@ -252,19 +252,6 @@ pubname_entry;\n #define ASM_COMMENT_START \";#\"\n #endif\n \n-/* Define a macro which returns non-zero for any tagged type which is used\n-   (directly or indirectly) in the specification of either some function's\n-   return type or some formal parameter of some function. We use this macro\n-   when we are operating in \"terse\" mode to help us know what tagged types\n-   have to be represented in Dwarf (even in terse mode) and which ones don't.\n-   A flag bit with this meaning really should be a part of the normal GCC\n-   ..._TYPE nodes, but at the moment, there is no such bit defined for these\n-   nodes.  For now, we have to just fake it.  It it safe for us to simply\n-   return zero for all complete tagged types (which will get forced out\n-   anyway if they were used in the specification of some formal or return\n-   type) and non-zero for all incomplete tagged types.  */\n-#define TYPE_USED_FOR_FUNCTION(tagged_type) (TYPE_SIZE (tagged_type) == 0)\n-\n /* Define a macro which returns non-zero for a TYPE_DECL which was\n    implicitly generated for a tagged type.\n \n@@ -6089,7 +6076,8 @@ scope_die_for (t, context_die)\n \t{\n \t  assert (scope_die == comp_unit_die);\n \t  assert (TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 't');\n-\t  assert (TREE_ASM_WRITTEN (containing_scope));\n+\t  if (debug_info_level > DINFO_LEVEL_TERSE)\n+\t    assert (TREE_ASM_WRITTEN (containing_scope));\n \t}\n     }\n   return scope_die;\n@@ -6533,7 +6521,6 @@ gen_subprogram_die (decl, context_die)\n   register dw_die_ref subr_die;\n   register dw_loc_descr_ref fp_loc = NULL;\n   register unsigned fp_reg;\n-  register tree type;\n   register tree fn_arg_types;\n   register tree outer_scope;\n   dw_die_ref old_die = lookup_decl_die (decl);\n@@ -6581,9 +6568,12 @@ gen_subprogram_die (decl, context_die)\n       if (TREE_PUBLIC (decl))\n \tadd_AT_flag (subr_die, DW_AT_external, 1);\n       add_name_and_src_coords_attributes (subr_die, decl);\n-      type = TREE_TYPE (decl);\n-      add_prototyped_attribute (subr_die, type);\n-      add_type_attribute (subr_die, TREE_TYPE (type), 0, 0, context_die);\n+      if (debug_info_level > DINFO_LEVEL_TERSE)\n+\t{\n+\t  register tree type = TREE_TYPE (decl);\n+\t  add_prototyped_attribute (subr_die, type);\n+\t  add_type_attribute (subr_die, TREE_TYPE (type), 0, 0, context_die);\n+\t}\n       add_pure_or_virtual_attribute (subr_die, decl);\n       if (DECL_ARTIFICIAL (decl))\n \tadd_AT_flag (subr_die, DW_AT_artificial, 1);\n@@ -6668,7 +6658,9 @@ gen_subprogram_die (decl, context_die)\n   /* In the case where we are describing a mere function declaration, all we\n      need to do here (and all we *can* do here) is to describe the *types* of \n      its formal parameters.  */\n-  if (DECL_INITIAL (decl) == NULL_TREE)\n+  if (debug_info_level <= DINFO_LEVEL_TERSE)\n+    /* do nothing */;\n+  else if (DECL_INITIAL (decl) == NULL_TREE)\n     {\n       gen_formal_types_die (TREE_TYPE (decl), subr_die);\n     }\n@@ -7009,11 +7001,8 @@ gen_compile_unit_die (main_input_filename)\n      that the object file is stripped and has no debugging information.\n      To get the MIPS/SGI debugger to believe that there is debugging\n      information in the object file, we add a -g to the producer string.  */\n-  if (write_symbols != NO_DEBUG)\n-    {\n-       strcat (producer, \" -g\");\n-    }\n-\n+  if (debug_info_level > DINFO_LEVEL_TERSE)\n+    strcat (producer, \" -g\");\n #endif\n \n   add_AT_string (comp_unit_die, DW_AT_producer, producer);\n@@ -7548,26 +7537,18 @@ gen_decl_die (decl, context_die)\n \n       /* Before we describe the FUNCTION_DECL itself, make sure that we have\n          described its return type.  */\n-      gen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n+      if (debug_info_level > DINFO_LEVEL_TERSE)\n+\tgen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n \n       /* Now output a DIE to represent the function itself.  */\n       gen_subprogram_die (decl, context_die);\n       break;\n \n     case TYPE_DECL:\n       /* If we are in terse mode, don't generate any DIEs to represent any\n-         actual typedefs.  Note that even when we are in terse mode, we must\n-         still output DIEs to represent those tagged types which are used\n-         (directly or indirectly) in the specification of either a return\n-         type or a formal parameter type of some function.  */\n+         actual typedefs.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\t{\n-\t  if (! TYPE_DECL_IS_STUB (decl)\n-\t      || !TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n-\t    {\n-\t      break;\n-\t    }\n-\t}\n+\tbreak;\n \n       /* In the special case of a TYPE_DECL node representing the \n          declaration of some type tag, if the given TYPE_DECL is marked as\n@@ -7752,18 +7733,9 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \t}\n \n       /* If we are in terse mode, don't generate any DIEs to represent any\n-         actual typedefs.  Note that even when we are in terse mode, we must\n-         still output DIEs to represent those tagged types which are used\n-         (directly or indirectly) in the specification of either a return\n-         type or a formal parameter type of some function.  */\n+         actual typedefs.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\t{\n-\t  if (! TYPE_DECL_IS_STUB (decl)\n-\t      || !TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n-\t    {\n-\t      return;\n-\t    }\n-\t}\n+\treturn;\n       break;\n \n     default:\n@@ -8204,7 +8176,8 @@ dwarfout_init (asm_out_file, main_input_filename)\n   gen_compile_unit_die (main_input_filename);\n \n   /* clear the association between base types and their DIE's */\n-  init_base_type_table ();\n+  if (debug_info_level > DINFO_LEVEL_TERSE)\n+    init_base_type_table ();\n \n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n }"}, {"sha": "4659490e8483d32d30ef6ed3da166e28416cc89c", "filename": "gcc/varasm.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4927276d13ba4b84158e8ab155339e3dcedc5d23/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4927276d13ba4b84158e8ab155339e3dcedc5d23/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=4927276d13ba4b84158e8ab155339e3dcedc5d23", "patch": "@@ -4217,12 +4217,12 @@ void\n assemble_alias (decl, target)\n      tree decl, target;\n {\n-#ifdef ASM_OUTPUT_DEF\n   char *name;\n \n   make_decl_rtl (decl, (char *) 0, 1);\n   name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n \n+#ifdef ASM_OUTPUT_DEF\n   /* Make name accessible from other files, if appropriate.  */\n \n   if (TREE_PUBLIC (decl))\n@@ -4241,7 +4241,15 @@ assemble_alias (decl, target)\n   ASM_OUTPUT_DEF (asm_out_file, name, IDENTIFIER_POINTER (target));\n   TREE_ASM_WRITTEN (decl) = 1;\n #else\n-  warning (\"alias definitions not supported in this configuration\");\n+#ifdef ASM_OUTPUT_WEAK_ALIAS\n+  if (! DECL_WEAK (decl))\n+    warning (\"only weak aliases are supported in this configuration\");\n+\n+  ASM_OUTPUT_WEAK_ALIAS (asm_out_file, name, IDENTIFIER_POINTER (target));\n+  TREE_ASM_WRITTEN (decl) = 1;\n+#else\n+  warning (\"alias definitions not supported in this configuration; ignored\");\n+#endif\n #endif\n }\n "}]}