{"sha": "99b1c316ec974a39bdd949f8559bb28861b69592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTliMWMzMTZlYzk3NGEzOWJkZDk0OWY4NTU5YmIyODg2MWI2OTU5Mg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-07-09T18:32:49Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-07-09T18:32:49Z"}, "message": "PR c++/61339 - add mismatch between struct and class [-Wmismatched-tags] to non-bugs\n\ngcc/c/ChangeLog:\n\n\tPR c++/61339\n\t* c-decl.c (xref_tag): Change class-key of PODs to struct and others\n\tto class.\n\t(field_decl_cmp): Same.\n\t* c-parser.c (c_parser_struct_or_union_specifier): Same.\n\t* c-tree.h: Same.\n\t* gimple-parser.c (c_parser_gimple_compound_statement): Same.\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/61339\n\t* c-opts.c (handle_deferred_opts): : Change class-key of PODs to struct\n\tand others to class.\n\t* c-pretty-print.h: Same.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/61339\n\t* cp-tree.h: Change class-key of PODs to struct and others to class.\n\t* search.c: Same.\n\t* semantics.c (finalize_nrv_r): Same.\n\ngcc/lto/ChangeLog:\n\n\tPR c++/61339\n\t* lto-common.c (lto_splay_tree_new): : Change class-key of PODs\n\tto struct and others to class.\n\t(mentions_vars_p): Same.\n\t(register_resolution): Same.\n\t(lto_register_var_decl_in_symtab): Same.\n\t(lto_register_function_decl_in_symtab): Same.\n\t(cmp_tree): Same.\n\t(lto_read_decls): Same.\n\ngcc/ChangeLog:\n\n\tPR c++/61339\n\t* auto-profile.c: Change class-key of PODs to struct and others\n\tto class.\n\t* basic-block.h: Same.\n\t* bitmap.c (bitmap_alloc): Same.\n\t* bitmap.h: Same.\n\t* builtins.c (expand_builtin_prefetch): Same.\n\t(expand_builtin_interclass_mathfn): Same.\n\t(expand_builtin_strlen): Same.\n\t(expand_builtin_mempcpy_args): Same.\n\t(expand_cmpstr): Same.\n\t(expand_builtin___clear_cache): Same.\n\t(expand_ifn_atomic_bit_test_and): Same.\n\t(expand_builtin_thread_pointer): Same.\n\t(expand_builtin_set_thread_pointer): Same.\n\t* caller-save.c (setup_save_areas): Same.\n\t(replace_reg_with_saved_mem): Same.\n\t(insert_restore): Same.\n\t(insert_save): Same.\n\t(add_used_regs): Same.\n\t* cfg.c (get_bb_copy): Same.\n\t(set_loop_copy): Same.\n\t* cfg.h: Same.\n\t* cfganal.h: Same.\n\t* cfgexpand.c (alloc_stack_frame_space): Same.\n\t(add_stack_var): Same.\n\t(add_stack_var_conflict): Same.\n\t(add_scope_conflicts_1): Same.\n\t(update_alias_info_with_stack_vars): Same.\n\t(expand_used_vars): Same.\n\t* cfghooks.c (redirect_edge_and_branch_force): Same.\n\t(delete_basic_block): Same.\n\t(split_edge): Same.\n\t(make_forwarder_block): Same.\n\t(force_nonfallthru): Same.\n\t(duplicate_block): Same.\n\t(lv_flush_pending_stmts): Same.\n\t* cfghooks.h: Same.\n\t* cfgloop.c (flow_loops_cfg_dump): Same.\n\t(flow_loop_nested_p): Same.\n\t(superloop_at_depth): Same.\n\t(get_loop_latch_edges): Same.\n\t(flow_loop_dump): Same.\n\t(flow_loops_dump): Same.\n\t(flow_loops_free): Same.\n\t(flow_loop_nodes_find): Same.\n\t(establish_preds): Same.\n\t(flow_loop_tree_node_add): Same.\n\t(flow_loop_tree_node_remove): Same.\n\t(flow_loops_find): Same.\n\t(find_subloop_latch_edge_by_profile): Same.\n\t(find_subloop_latch_edge_by_ivs): Same.\n\t(mfb_redirect_edges_in_set): Same.\n\t(form_subloop): Same.\n\t(merge_latch_edges): Same.\n\t(disambiguate_multiple_latches): Same.\n\t(disambiguate_loops_with_multiple_latches): Same.\n\t(flow_bb_inside_loop_p): Same.\n\t(glb_enum_p): Same.\n\t(get_loop_body_with_size): Same.\n\t(get_loop_body): Same.\n\t(fill_sons_in_loop): Same.\n\t(get_loop_body_in_dom_order): Same.\n\t(get_loop_body_in_custom_order): Same.\n\t(release_recorded_exits): Same.\n\t(get_loop_exit_edges): Same.\n\t(num_loop_branches): Same.\n\t(remove_bb_from_loops): Same.\n\t(find_common_loop): Same.\n\t(delete_loop): Same.\n\t(cancel_loop): Same.\n\t(verify_loop_structure): Same.\n\t(loop_preheader_edge): Same.\n\t(loop_exit_edge_p): Same.\n\t(single_exit): Same.\n\t(loop_exits_to_bb_p): Same.\n\t(loop_exits_from_bb_p): Same.\n\t(get_loop_location): Same.\n\t(record_niter_bound): Same.\n\t(get_estimated_loop_iterations_int): Same.\n\t(max_stmt_executions_int): Same.\n\t(likely_max_stmt_executions_int): Same.\n\t(get_estimated_loop_iterations): Same.\n\t(get_max_loop_iterations): Same.\n\t(get_max_loop_iterations_int): Same.\n\t(get_likely_max_loop_iterations): Same.\n\t* cfgloop.h (simple_loop_desc): Same.\n\t(get_loop): Same.\n\t(loop_depth): Same.\n\t(loop_outer): Same.\n\t(loop_iterator::next): Same.\n\t(loop_outermost): Same.\n\t* cfgloopanal.c (mark_irreducible_loops): Same.\n\t(num_loop_insns): Same.\n\t(average_num_loop_insns): Same.\n\t(expected_loop_iterations_unbounded): Same.\n\t(expected_loop_iterations): Same.\n\t(mark_loop_exit_edges): Same.\n\t(single_likely_exit): Same.\n\t* cfgloopmanip.c (fix_bb_placement): Same.\n\t(fix_bb_placements): Same.\n\t(remove_path): Same.\n\t(place_new_loop): Same.\n\t(add_loop): Same.\n\t(scale_loop_frequencies): Same.\n\t(scale_loop_profile): Same.\n\t(create_empty_if_region_on_edge): Same.\n\t(create_empty_loop_on_edge): Same.\n\t(loopify): Same.\n\t(unloop): Same.\n\t(fix_loop_placements): Same.\n\t(copy_loop_info): Same.\n\t(duplicate_loop): Same.\n\t(duplicate_subloops): Same.\n\t(loop_redirect_edge): Same.\n\t(can_duplicate_loop_p): Same.\n\t(duplicate_loop_to_header_edge): Same.\n\t(mfb_keep_just): Same.\n\t(has_preds_from_loop): Same.\n\t(create_preheader): Same.\n\t(create_preheaders): Same.\n\t(lv_adjust_loop_entry_edge): Same.\n\t(loop_version): Same.\n\t* cfgloopmanip.h: Same.\n\t* cgraph.h: Same.\n\t* cgraphbuild.c: Same.\n\t* combine.c (make_extraction): Same.\n\t* config/i386/i386-features.c: Same.\n\t* config/i386/i386-features.h: Same.\n\t* config/i386/i386.c (ix86_emit_outlined_ms2sysv_save): Same.\n\t(ix86_emit_outlined_ms2sysv_restore): Same.\n\t(ix86_noce_conversion_profitable_p): Same.\n\t(ix86_init_cost): Same.\n\t(ix86_simd_clone_usable): Same.\n\t* configure.ac: Same.\n\t* coretypes.h: Same.\n\t* data-streamer-in.c (string_for_index): Same.\n\t(streamer_read_indexed_string): Same.\n\t(streamer_read_string): Same.\n\t(bp_unpack_indexed_string): Same.\n\t(bp_unpack_string): Same.\n\t(streamer_read_uhwi): Same.\n\t(streamer_read_hwi): Same.\n\t(streamer_read_gcov_count): Same.\n\t(streamer_read_wide_int): Same.\n\t* data-streamer.h (streamer_write_bitpack): Same.\n\t(bp_unpack_value): Same.\n\t(streamer_write_char_stream): Same.\n\t(streamer_write_hwi_in_range): Same.\n\t(streamer_write_record_start): Same.\n\t* ddg.c (create_ddg_dep_from_intra_loop_link): Same.\n\t(add_cross_iteration_register_deps): Same.\n\t(build_intra_loop_deps): Same.\n\t* df-core.c (df_analyze): Same.\n\t(loop_post_order_compute): Same.\n\t(loop_inverted_post_order_compute): Same.\n\t* df-problems.c (df_rd_alloc): Same.\n\t(df_rd_simulate_one_insn): Same.\n\t(df_rd_local_compute): Same.\n\t(df_rd_init_solution): Same.\n\t(df_rd_confluence_n): Same.\n\t(df_rd_transfer_function): Same.\n\t(df_rd_free): Same.\n\t(df_rd_dump_defs_set): Same.\n\t(df_rd_top_dump): Same.\n\t(df_lr_alloc): Same.\n\t(df_lr_reset): Same.\n\t(df_lr_local_compute): Same.\n\t(df_lr_init): Same.\n\t(df_lr_confluence_n): Same.\n\t(df_lr_free): Same.\n\t(df_lr_top_dump): Same.\n\t(df_lr_verify_transfer_functions): Same.\n\t(df_live_alloc): Same.\n\t(df_live_reset): Same.\n\t(df_live_init): Same.\n\t(df_live_confluence_n): Same.\n\t(df_live_finalize): Same.\n\t(df_live_free): Same.\n\t(df_live_top_dump): Same.\n\t(df_live_verify_transfer_functions): Same.\n\t(df_mir_alloc): Same.\n\t(df_mir_reset): Same.\n\t(df_mir_init): Same.\n\t(df_mir_confluence_n): Same.\n\t(df_mir_free): Same.\n\t(df_mir_top_dump): Same.\n\t(df_word_lr_alloc): Same.\n\t(df_word_lr_reset): Same.\n\t(df_word_lr_init): Same.\n\t(df_word_lr_confluence_n): Same.\n\t(df_word_lr_free): Same.\n\t(df_word_lr_top_dump): Same.\n\t(df_md_alloc): Same.\n\t(df_md_simulate_one_insn): Same.\n\t(df_md_reset): Same.\n\t(df_md_init): Same.\n\t(df_md_free): Same.\n\t(df_md_top_dump): Same.\n\t* df-scan.c (df_insn_delete): Same.\n\t(df_insn_rescan): Same.\n\t(df_notes_rescan): Same.\n\t(df_sort_and_compress_mws): Same.\n\t(df_install_mws): Same.\n\t(df_refs_add_to_chains): Same.\n\t(df_ref_create_structure): Same.\n\t(df_ref_record): Same.\n\t(df_def_record_1): Same.\n\t(df_find_hard_reg_defs): Same.\n\t(df_uses_record): Same.\n\t(df_get_conditional_uses): Same.\n\t(df_get_call_refs): Same.\n\t(df_recompute_luids): Same.\n\t(df_get_entry_block_def_set): Same.\n\t(df_entry_block_defs_collect): Same.\n\t(df_get_exit_block_use_set): Same.\n\t(df_exit_block_uses_collect): Same.\n\t(df_mws_verify): Same.\n\t(df_bb_verify): Same.\n\t* df.h (df_scan_get_bb_info): Same.\n\t* doc/tm.texi: Same.\n\t* dse.c (record_store): Same.\n\t* dumpfile.h: Same.\n\t* emit-rtl.c (const_fixed_hasher::equal): Same.\n\t(set_mem_attributes_minus_bitpos): Same.\n\t(change_address): Same.\n\t(adjust_address_1): Same.\n\t(offset_address): Same.\n\t* emit-rtl.h: Same.\n\t* except.c (dw2_build_landing_pads): Same.\n\t(sjlj_emit_dispatch_table): Same.\n\t* explow.c (allocate_dynamic_stack_space): Same.\n\t(emit_stack_probe): Same.\n\t(probe_stack_range): Same.\n\t* expmed.c (store_bit_field_using_insv): Same.\n\t(store_bit_field_1): Same.\n\t(store_integral_bit_field): Same.\n\t(extract_bit_field_using_extv): Same.\n\t(extract_bit_field_1): Same.\n\t(emit_cstore): Same.\n\t* expr.c (emit_block_move_via_cpymem): Same.\n\t(expand_cmpstrn_or_cmpmem): Same.\n\t(set_storage_via_setmem): Same.\n\t(emit_single_push_insn_1): Same.\n\t(expand_assignment): Same.\n\t(store_constructor): Same.\n\t(expand_expr_real_2): Same.\n\t(expand_expr_real_1): Same.\n\t(try_casesi): Same.\n\t* flags.h: Same.\n\t* function.c (try_fit_stack_local): Same.\n\t(assign_stack_local_1): Same.\n\t(assign_stack_local): Same.\n\t(cut_slot_from_list): Same.\n\t(insert_slot_to_list): Same.\n\t(max_slot_level): Same.\n\t(move_slot_to_level): Same.\n\t(temp_address_hasher::equal): Same.\n\t(remove_unused_temp_slot_addresses): Same.\n\t(assign_temp): Same.\n\t(combine_temp_slots): Same.\n\t(update_temp_slot_address): Same.\n\t(preserve_temp_slots): Same.\n\t* function.h: Same.\n\t* fwprop.c: Same.\n\t* gcc-rich-location.h: Same.\n\t* gcov.c: Same.\n\t* genattrtab.c (check_attr_test): Same.\n\t(check_attr_value): Same.\n\t(convert_set_attr_alternative): Same.\n\t(convert_set_attr): Same.\n\t(check_defs): Same.\n\t(copy_boolean): Same.\n\t(get_attr_value): Same.\n\t(expand_delays): Same.\n\t(make_length_attrs): Same.\n\t(min_fn): Same.\n\t(make_alternative_compare): Same.\n\t(simplify_test_exp): Same.\n\t(tests_attr_p): Same.\n\t(get_attr_order): Same.\n\t(clear_struct_flag): Same.\n\t(gen_attr): Same.\n\t(compares_alternatives_p): Same.\n\t(gen_insn): Same.\n\t(gen_delay): Same.\n\t(find_attrs_to_cache): Same.\n\t(write_test_expr): Same.\n\t(walk_attr_value): Same.\n\t(write_attr_get): Same.\n\t(eliminate_known_true): Same.\n\t(write_insn_cases): Same.\n\t(write_attr_case): Same.\n\t(write_attr_valueq): Same.\n\t(write_attr_value): Same.\n\t(write_dummy_eligible_delay): Same.\n\t(next_comma_elt): Same.\n\t(find_attr): Same.\n\t(make_internal_attr): Same.\n\t(copy_rtx_unchanging): Same.\n\t(gen_insn_reserv): Same.\n\t(check_tune_attr): Same.\n\t(make_automaton_attrs): Same.\n\t(handle_arg): Same.\n\t* genextract.c (gen_insn): Same.\n\t(VEC_char_to_string): Same.\n\t* genmatch.c (print_operand): Same.\n\t(lower): Same.\n\t(parser::parse_operation): Same.\n\t(parser::parse_capture): Same.\n\t(parser::parse_c_expr): Same.\n\t(parser::parse_simplify): Same.\n\t(main): Same.\n\t* genoutput.c (output_operand_data): Same.\n\t(output_get_insn_name): Same.\n\t(compare_operands): Same.\n\t(place_operands): Same.\n\t(process_template): Same.\n\t(validate_insn_alternatives): Same.\n\t(validate_insn_operands): Same.\n\t(gen_expand): Same.\n\t(note_constraint): Same.\n\t* genpreds.c (write_one_predicate_function): Same.\n\t(add_constraint): Same.\n\t(process_define_register_constraint): Same.\n\t(write_lookup_constraint_1): Same.\n\t(write_lookup_constraint_array): Same.\n\t(write_insn_constraint_len): Same.\n\t(write_reg_class_for_constraint_1): Same.\n\t(write_constraint_satisfied_p_array): Same.\n\t* genrecog.c (optimize_subroutine_group): Same.\n\t* gensupport.c (process_define_predicate): Same.\n\t(queue_pattern): Same.\n\t(remove_from_queue): Same.\n\t(process_rtx): Same.\n\t(is_predicable): Same.\n\t(change_subst_attribute): Same.\n\t(subst_pattern_match): Same.\n\t(alter_constraints): Same.\n\t(alter_attrs_for_insn): Same.\n\t(shift_output_template): Same.\n\t(alter_output_for_subst_insn): Same.\n\t(process_one_cond_exec): Same.\n\t(subst_dup): Same.\n\t(process_define_cond_exec): Same.\n\t(mnemonic_htab_callback): Same.\n\t(gen_mnemonic_attr): Same.\n\t(read_md_rtx): Same.\n\t* ggc-page.c: Same.\n\t* gimple-loop-interchange.cc (dump_reduction): Same.\n\t(dump_induction): Same.\n\t(loop_cand::~loop_cand): Same.\n\t(free_data_refs_with_aux): Same.\n\t(tree_loop_interchange::interchange_loops): Same.\n\t(tree_loop_interchange::map_inductions_to_loop): Same.\n\t(tree_loop_interchange::move_code_to_inner_loop): Same.\n\t(compute_access_stride): Same.\n\t(compute_access_strides): Same.\n\t(proper_loop_form_for_interchange): Same.\n\t(tree_loop_interchange_compute_ddrs): Same.\n\t(prune_datarefs_not_in_loop): Same.\n\t(prepare_data_references): Same.\n\t(pass_linterchange::execute): Same.\n\t* gimple-loop-jam.c (bb_prevents_fusion_p): Same.\n\t(unroll_jam_possible_p): Same.\n\t(fuse_loops): Same.\n\t(adjust_unroll_factor): Same.\n\t(tree_loop_unroll_and_jam): Same.\n\t* gimple-loop-versioning.cc (loop_versioning::~loop_versioning): Same.\n\t(loop_versioning::expensive_stmt_p): Same.\n\t(loop_versioning::version_for_unity): Same.\n\t(loop_versioning::dump_inner_likelihood): Same.\n\t(loop_versioning::find_per_loop_multiplication): Same.\n\t(loop_versioning::analyze_term_using_scevs): Same.\n\t(loop_versioning::record_address_fragment): Same.\n\t(loop_versioning::analyze_expr): Same.\n\t(loop_versioning::analyze_blocks): Same.\n\t(loop_versioning::prune_conditions): Same.\n\t(loop_versioning::merge_loop_info): Same.\n\t(loop_versioning::add_loop_to_queue): Same.\n\t(loop_versioning::decide_whether_loop_is_versionable): Same.\n\t(loop_versioning::make_versioning_decisions): Same.\n\t(loop_versioning::implement_versioning_decisions): Same.\n\t* gimple-ssa-evrp-analyze.c\n\t(evrp_range_analyzer::record_ranges_from_phis): Same.\n\t* gimple-ssa-store-merging.c (split_store::split_store): Same.\n\t(count_multiple_uses): Same.\n\t(split_group): Same.\n\t(imm_store_chain_info::output_merged_store): Same.\n\t(pass_store_merging::process_store): Same.\n\t* gimple-ssa-strength-reduction.c (slsr_process_phi): Same.\n\t* gimple-ssa-warn-alloca.c (adjusted_warn_limit): Same.\n\t(is_max): Same.\n\t(alloca_call_type): Same.\n\t(pass_walloca::execute): Same.\n\t* gimple-streamer-in.c (input_phi): Same.\n\t(input_gimple_stmt): Same.\n\t* gimple-streamer.h: Same.\n\t* godump.c (go_force_record_alignment): Same.\n\t(go_format_type): Same.\n\t(go_output_type): Same.\n\t(go_output_fndecl): Same.\n\t(go_output_typedef): Same.\n\t(keyword_hash_init): Same.\n\t(find_dummy_types): Same.\n\t* graph.c (draw_cfg_nodes_no_loops): Same.\n\t(draw_cfg_nodes_for_loop): Same.\n\t* hard-reg-set.h (hard_reg_set_iter_next): Same.\n\t* hsa-brig.c: Same.\n\t* hsa-common.h (hsa_internal_fn_hasher::equal): Same.\n\t* hsa-dump.c (dump_hsa_cfun): Same.\n\t* hsa-gen.c (gen_function_def_parameters): Same.\n\t* hsa-regalloc.c (dump_hsa_cfun_regalloc): Same.\n\t* input.c (dump_line_table_statistics): Same.\n\t(test_lexer): Same.\n\t* input.h: Same.\n\t* internal-fn.c (get_multi_vector_move): Same.\n\t(expand_load_lanes_optab_fn): Same.\n\t(expand_GOMP_SIMT_ENTER_ALLOC): Same.\n\t(expand_GOMP_SIMT_EXIT): Same.\n\t(expand_GOMP_SIMT_LAST_LANE): Same.\n\t(expand_GOMP_SIMT_ORDERED_PRED): Same.\n\t(expand_GOMP_SIMT_VOTE_ANY): Same.\n\t(expand_GOMP_SIMT_XCHG_BFLY): Same.\n\t(expand_GOMP_SIMT_XCHG_IDX): Same.\n\t(expand_addsub_overflow): Same.\n\t(expand_neg_overflow): Same.\n\t(expand_mul_overflow): Same.\n\t(expand_call_mem_ref): Same.\n\t(expand_mask_load_optab_fn): Same.\n\t(expand_scatter_store_optab_fn): Same.\n\t(expand_gather_load_optab_fn): Same.\n\t* ipa-cp.c (ipa_get_parm_lattices): Same.\n\t(print_all_lattices): Same.\n\t(ignore_edge_p): Same.\n\t(build_toporder_info): Same.\n\t(free_toporder_info): Same.\n\t(push_node_to_stack): Same.\n\t(ipcp_lattice<valtype>::set_contains_variable): Same.\n\t(set_agg_lats_to_bottom): Same.\n\t(ipcp_bits_lattice::meet_with): Same.\n\t(set_single_call_flag): Same.\n\t(initialize_node_lattices): Same.\n\t(ipa_get_jf_ancestor_result): Same.\n\t(ipcp_verify_propagated_values): Same.\n\t(propagate_scalar_across_jump_function): Same.\n\t(propagate_context_across_jump_function): Same.\n\t(propagate_bits_across_jump_function): Same.\n\t(ipa_vr_operation_and_type_effects): Same.\n\t(propagate_vr_across_jump_function): Same.\n\t(set_check_aggs_by_ref): Same.\n\t(set_chain_of_aglats_contains_variable): Same.\n\t(merge_aggregate_lattices): Same.\n\t(agg_pass_through_permissible_p): Same.\n\t(propagate_aggs_across_jump_function): Same.\n\t(call_passes_through_thunk_p): Same.\n\t(propagate_constants_across_call): Same.\n\t(devirtualization_time_bonus): Same.\n\t(good_cloning_opportunity_p): Same.\n\t(context_independent_aggregate_values): Same.\n\t(gather_context_independent_values): Same.\n\t(perform_estimation_of_a_value): Same.\n\t(estimate_local_effects): Same.\n\t(value_topo_info<valtype>::add_val): Same.\n\t(add_all_node_vals_to_toposort): Same.\n\t(value_topo_info<valtype>::propagate_effects): Same.\n\t(ipcp_propagate_stage): Same.\n\t(ipcp_discover_new_direct_edges): Same.\n\t(same_node_or_its_all_contexts_clone_p): Same.\n\t(cgraph_edge_brings_value_p): Same.\n\t(gather_edges_for_value): Same.\n\t(create_specialized_node): Same.\n\t(find_more_scalar_values_for_callers_subset): Same.\n\t(find_more_contexts_for_caller_subset): Same.\n\t(copy_plats_to_inter): Same.\n\t(intersect_aggregates_with_edge): Same.\n\t(find_aggregate_values_for_callers_subset): Same.\n\t(cgraph_edge_brings_all_agg_vals_for_node): Same.\n\t(decide_about_value): Same.\n\t(decide_whether_version_node): Same.\n\t(spread_undeadness): Same.\n\t(identify_dead_nodes): Same.\n\t(ipcp_store_vr_results): Same.\n\t* ipa-devirt.c (final_warning_record::grow_type_warnings): Same.\n\t* ipa-fnsummary.c (ipa_fn_summary::account_size_time): Same.\n\t(redirect_to_unreachable): Same.\n\t(edge_set_predicate): Same.\n\t(evaluate_conditions_for_known_args): Same.\n\t(evaluate_properties_for_edge): Same.\n\t(ipa_fn_summary_t::duplicate): Same.\n\t(ipa_call_summary_t::duplicate): Same.\n\t(dump_ipa_call_summary): Same.\n\t(ipa_dump_fn_summary): Same.\n\t(eliminated_by_inlining_prob): Same.\n\t(set_cond_stmt_execution_predicate): Same.\n\t(set_switch_stmt_execution_predicate): Same.\n\t(compute_bb_predicates): Same.\n\t(will_be_nonconstant_expr_predicate): Same.\n\t(phi_result_unknown_predicate): Same.\n\t(analyze_function_body): Same.\n\t(compute_fn_summary): Same.\n\t(estimate_edge_devirt_benefit): Same.\n\t(estimate_edge_size_and_time): Same.\n\t(estimate_calls_size_and_time): Same.\n\t(estimate_node_size_and_time): Same.\n\t(remap_edge_change_prob): Same.\n\t(remap_edge_summaries): Same.\n\t(ipa_merge_fn_summary_after_inlining): Same.\n\t(ipa_fn_summary_generate): Same.\n\t(inline_read_section): Same.\n\t(ipa_fn_summary_read): Same.\n\t(ipa_fn_summary_write): Same.\n\t* ipa-fnsummary.h: Same.\n\t* ipa-hsa.c (ipa_hsa_read_section): Same.\n\t* ipa-icf-gimple.c (func_checker::compare_loops): Same.\n\t* ipa-icf.c (sem_function::param_used_p): Same.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Same.\n\t* ipa-inline.c (edge_badness): Same.\n\t(inline_small_functions): Same.\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::stream_out): Same.\n\t* ipa-predicate.c (predicate::remap_after_duplication): Same.\n\t(predicate::remap_after_inlining): Same.\n\t(predicate::stream_out): Same.\n\t* ipa-predicate.h: Same.\n\t* ipa-profile.c (ipa_profile_read_summary): Same.\n\t* ipa-prop.c (ipa_get_param_decl_index_1): Same.\n\t(count_formal_params): Same.\n\t(ipa_dump_param): Same.\n\t(ipa_alloc_node_params): Same.\n\t(ipa_print_node_jump_functions_for_edge): Same.\n\t(ipa_print_node_jump_functions): Same.\n\t(ipa_load_from_parm_agg): Same.\n\t(get_ancestor_addr_info): Same.\n\t(ipa_compute_jump_functions_for_edge): Same.\n\t(ipa_analyze_virtual_call_uses): Same.\n\t(ipa_analyze_stmt_uses): Same.\n\t(ipa_analyze_params_uses_in_bb): Same.\n\t(update_jump_functions_after_inlining): Same.\n\t(try_decrement_rdesc_refcount): Same.\n\t(ipa_impossible_devirt_target): Same.\n\t(update_indirect_edges_after_inlining): Same.\n\t(combine_controlled_uses_counters): Same.\n\t(ipa_edge_args_sum_t::duplicate): Same.\n\t(ipa_write_jump_function): Same.\n\t(ipa_write_indirect_edge_info): Same.\n\t(ipa_write_node_info): Same.\n\t(ipa_read_edge_info): Same.\n\t(ipa_prop_read_section): Same.\n\t(read_replacements_section): Same.\n\t* ipa-prop.h (ipa_get_param_count): Same.\n\t(ipa_get_param): Same.\n\t(ipa_get_type): Same.\n\t(ipa_get_param_move_cost): Same.\n\t(ipa_set_param_used): Same.\n\t(ipa_get_controlled_uses): Same.\n\t(ipa_set_controlled_uses): Same.\n\t(ipa_get_cs_argument_count): Same.\n\t* ipa-pure-const.c (analyze_function): Same.\n\t(pure_const_read_summary): Same.\n\t* ipa-ref.h: Same.\n\t* ipa-reference.c (ipa_reference_read_optimization_summary): Same.\n\t* ipa-split.c (test_nonssa_use): Same.\n\t(dump_split_point): Same.\n\t(dominated_by_forbidden): Same.\n\t(split_part_set_ssa_name_p): Same.\n\t(find_split_points): Same.\n\t* ira-build.c (finish_loop_tree_nodes): Same.\n\t(low_pressure_loop_node_p): Same.\n\t* ira-color.c (ira_reuse_stack_slot): Same.\n\t* ira-int.h: Same.\n\t* ira.c (setup_reg_equiv): Same.\n\t(print_insn_chain): Same.\n\t(ira): Same.\n\t* loop-doloop.c (doloop_condition_get): Same.\n\t(add_test): Same.\n\t(record_reg_sets): Same.\n\t(doloop_optimize): Same.\n\t* loop-init.c (loop_optimizer_init): Same.\n\t(fix_loop_structure): Same.\n\t* loop-invariant.c (merge_identical_invariants): Same.\n\t(compute_always_reached): Same.\n\t(find_exits): Same.\n\t(may_assign_reg_p): Same.\n\t(find_invariants_bb): Same.\n\t(find_invariants_body): Same.\n\t(replace_uses): Same.\n\t(can_move_invariant_reg): Same.\n\t(free_inv_motion_data): Same.\n\t(move_single_loop_invariants): Same.\n\t(change_pressure): Same.\n\t(mark_ref_regs): Same.\n\t(calculate_loop_reg_pressure): Same.\n\t* loop-iv.c (biv_entry_hasher::equal): Same.\n\t(iv_extend_to_rtx_code): Same.\n\t(check_iv_ref_table_size): Same.\n\t(clear_iv_info): Same.\n\t(latch_dominating_def): Same.\n\t(iv_get_reaching_def): Same.\n\t(iv_constant): Same.\n\t(iv_subreg): Same.\n\t(iv_extend): Same.\n\t(iv_neg): Same.\n\t(iv_add): Same.\n\t(iv_mult): Same.\n\t(get_biv_step): Same.\n\t(record_iv): Same.\n\t(analyzed_for_bivness_p): Same.\n\t(record_biv): Same.\n\t(iv_analyze_biv): Same.\n\t(iv_analyze_expr): Same.\n\t(iv_analyze_def): Same.\n\t(iv_analyze_op): Same.\n\t(iv_analyze): Same.\n\t(iv_analyze_result): Same.\n\t(biv_p): Same.\n\t(eliminate_implied_conditions): Same.\n\t(simplify_using_initial_values): Same.\n\t(shorten_into_mode): Same.\n\t(canonicalize_iv_subregs): Same.\n\t(determine_max_iter): Same.\n\t(check_simple_exit): Same.\n\t(find_simple_exit): Same.\n\t(get_simple_loop_desc): Same.\n\t* loop-unroll.c (report_unroll): Same.\n\t(decide_unrolling): Same.\n\t(unroll_loops): Same.\n\t(loop_exit_at_end_p): Same.\n\t(decide_unroll_constant_iterations): Same.\n\t(unroll_loop_constant_iterations): Same.\n\t(compare_and_jump_seq): Same.\n\t(unroll_loop_runtime_iterations): Same.\n\t(decide_unroll_stupid): Same.\n\t(unroll_loop_stupid): Same.\n\t(referenced_in_one_insn_in_loop_p): Same.\n\t(reset_debug_uses_in_loop): Same.\n\t(analyze_iv_to_split_insn): Same.\n\t* lra-eliminations.c (lra_debug_elim_table): Same.\n\t(setup_can_eliminate): Same.\n\t(form_sum): Same.\n\t(lra_get_elimination_hard_regno): Same.\n\t(lra_eliminate_regs_1): Same.\n\t(eliminate_regs_in_insn): Same.\n\t(update_reg_eliminate): Same.\n\t(init_elimination): Same.\n\t(lra_eliminate): Same.\n\t* lra-int.h: Same.\n\t* lra-lives.c (initiate_live_solver): Same.\n\t* lra-remat.c (create_remat_bb_data): Same.\n\t* lra-spills.c (lra_spill): Same.\n\t* lra.c (lra_set_insn_recog_data): Same.\n\t(lra_set_used_insn_alternative_by_uid): Same.\n\t(init_reg_info): Same.\n\t(expand_reg_info): Same.\n\t* lto-cgraph.c (output_symtab): Same.\n\t(read_identifier): Same.\n\t(get_alias_symbol): Same.\n\t(input_node): Same.\n\t(input_varpool_node): Same.\n\t(input_ref): Same.\n\t(input_edge): Same.\n\t(input_cgraph_1): Same.\n\t(input_refs): Same.\n\t(input_symtab): Same.\n\t(input_offload_tables): Same.\n\t(output_cgraph_opt_summary): Same.\n\t(input_edge_opt_summary): Same.\n\t(input_cgraph_opt_section): Same.\n\t* lto-section-in.c (lto_free_raw_section_data): Same.\n\t(lto_create_simple_input_block): Same.\n\t(lto_free_function_in_decl_state_for_node): Same.\n\t* lto-streamer-in.c (lto_tag_check_set): Same.\n\t(lto_location_cache::revert_location_cache): Same.\n\t(lto_location_cache::input_location): Same.\n\t(lto_input_location): Same.\n\t(stream_input_location_now): Same.\n\t(lto_input_tree_ref): Same.\n\t(lto_input_eh_catch_list): Same.\n\t(input_eh_region): Same.\n\t(lto_init_eh): Same.\n\t(make_new_block): Same.\n\t(input_cfg): Same.\n\t(fixup_call_stmt_edges): Same.\n\t(input_struct_function_base): Same.\n\t(input_function): Same.\n\t(lto_read_body_or_constructor): Same.\n\t(lto_read_tree_1): Same.\n\t(lto_read_tree): Same.\n\t(lto_input_scc): Same.\n\t(lto_input_tree_1): Same.\n\t(lto_input_toplevel_asms): Same.\n\t(lto_input_mode_table): Same.\n\t(lto_reader_init): Same.\n\t(lto_data_in_create): Same.\n\t* lto-streamer-out.c (output_cfg): Same.\n\t* lto-streamer.h: Same.\n\t* modulo-sched.c (duplicate_insns_of_cycles): Same.\n\t(generate_prolog_epilog): Same.\n\t(mark_loop_unsched): Same.\n\t(dump_insn_location): Same.\n\t(loop_canon_p): Same.\n\t(sms_schedule): Same.\n\t* omp-expand.c (expand_omp_for_ordered_loops): Same.\n\t(expand_omp_for_generic): Same.\n\t(expand_omp_for_static_nochunk): Same.\n\t(expand_omp_for_static_chunk): Same.\n\t(expand_omp_simd): Same.\n\t(expand_omp_taskloop_for_inner): Same.\n\t(expand_oacc_for): Same.\n\t(expand_omp_atomic_pipeline): Same.\n\t(mark_loops_in_oacc_kernels_region): Same.\n\t* omp-offload.c (oacc_xform_loop): Same.\n\t* omp-simd-clone.c (simd_clone_adjust): Same.\n\t* optabs-query.c (get_traditional_extraction_insn): Same.\n\t* optabs.c (expand_vector_broadcast): Same.\n\t(expand_binop_directly): Same.\n\t(expand_twoval_unop): Same.\n\t(expand_twoval_binop): Same.\n\t(expand_unop_direct): Same.\n\t(emit_indirect_jump): Same.\n\t(emit_conditional_move): Same.\n\t(emit_conditional_neg_or_complement): Same.\n\t(emit_conditional_add): Same.\n\t(vector_compare_rtx): Same.\n\t(expand_vec_perm_1): Same.\n\t(expand_vec_perm_const): Same.\n\t(expand_vec_cond_expr): Same.\n\t(expand_vec_series_expr): Same.\n\t(maybe_emit_atomic_exchange): Same.\n\t(maybe_emit_sync_lock_test_and_set): Same.\n\t(expand_atomic_compare_and_swap): Same.\n\t(expand_atomic_load): Same.\n\t(expand_atomic_store): Same.\n\t(maybe_emit_op): Same.\n\t(valid_multiword_target_p): Same.\n\t(create_integer_operand): Same.\n\t(maybe_legitimize_operand_same_code): Same.\n\t(maybe_legitimize_operand): Same.\n\t(create_convert_operand_from_type): Same.\n\t(can_reuse_operands_p): Same.\n\t(maybe_legitimize_operands): Same.\n\t(maybe_gen_insn): Same.\n\t(maybe_expand_insn): Same.\n\t(maybe_expand_jump_insn): Same.\n\t(expand_insn): Same.\n\t* optabs.h (create_expand_operand): Same.\n\t(create_fixed_operand): Same.\n\t(create_output_operand): Same.\n\t(create_input_operand): Same.\n\t(create_convert_operand_to): Same.\n\t(create_convert_operand_from): Same.\n\t* optinfo.h: Same.\n\t* poly-int.h: Same.\n\t* predict.c (optimize_insn_for_speed_p): Same.\n\t(optimize_loop_for_size_p): Same.\n\t(optimize_loop_for_speed_p): Same.\n\t(optimize_loop_nest_for_speed_p): Same.\n\t(get_base_value): Same.\n\t(predicted_by_loop_heuristics_p): Same.\n\t(predict_extra_loop_exits): Same.\n\t(predict_loops): Same.\n\t(predict_paths_for_bb): Same.\n\t(predict_paths_leading_to): Same.\n\t(propagate_freq): Same.\n\t(pass_profile::execute): Same.\n\t* predict.h: Same.\n\t* profile-count.c (profile_count::differs_from_p): Same.\n\t(profile_probability::differs_lot_from_p): Same.\n\t* profile-count.h: Same.\n\t* profile.c (branch_prob): Same.\n\t* regrename.c (free_chain_data): Same.\n\t(mark_conflict): Same.\n\t(create_new_chain): Same.\n\t(merge_overlapping_regs): Same.\n\t(init_rename_info): Same.\n\t(merge_chains): Same.\n\t(regrename_analyze): Same.\n\t(regrename_do_replace): Same.\n\t(scan_rtx_reg): Same.\n\t(record_out_operands): Same.\n\t(build_def_use): Same.\n\t* regrename.h: Same.\n\t* reload.h: Same.\n\t* reload1.c (init_reload): Same.\n\t(maybe_fix_stack_asms): Same.\n\t(copy_reloads): Same.\n\t(count_pseudo): Same.\n\t(count_spilled_pseudo): Same.\n\t(find_reg): Same.\n\t(find_reload_regs): Same.\n\t(select_reload_regs): Same.\n\t(spill_hard_reg): Same.\n\t(fixup_eh_region_note): Same.\n\t(set_reload_reg): Same.\n\t(allocate_reload_reg): Same.\n\t(compute_reload_subreg_offset): Same.\n\t(reload_adjust_reg_for_icode): Same.\n\t(emit_input_reload_insns): Same.\n\t(emit_output_reload_insns): Same.\n\t(do_input_reload): Same.\n\t(inherit_piecemeal_p): Same.\n\t* rtl.h: Same.\n\t* sanopt.c (maybe_get_dominating_check): Same.\n\t(maybe_optimize_ubsan_ptr_ifn): Same.\n\t(can_remove_asan_check): Same.\n\t(maybe_optimize_asan_check_ifn): Same.\n\t(sanopt_optimize_walker): Same.\n\t* sched-deps.c (add_dependence_list): Same.\n\t(chain_to_prev_insn): Same.\n\t(add_insn_mem_dependence): Same.\n\t(create_insn_reg_set): Same.\n\t(maybe_extend_reg_info_p): Same.\n\t(sched_analyze_reg): Same.\n\t(sched_analyze_1): Same.\n\t(get_implicit_reg_pending_clobbers): Same.\n\t(chain_to_prev_insn_p): Same.\n\t(deps_analyze_insn): Same.\n\t(deps_start_bb): Same.\n\t(sched_free_deps): Same.\n\t(init_deps): Same.\n\t(init_deps_reg_last): Same.\n\t(free_deps): Same.\n\t* sched-ebb.c: Same.\n\t* sched-int.h: Same.\n\t* sched-rgn.c (add_branch_dependences): Same.\n\t(concat_insn_mem_list): Same.\n\t(deps_join): Same.\n\t(sched_rgn_compute_dependencies): Same.\n\t* sel-sched-ir.c (reset_target_context): Same.\n\t(copy_deps_context): Same.\n\t(init_id_from_df): Same.\n\t(has_dependence_p): Same.\n\t(change_loops_latches): Same.\n\t(bb_top_order_comparator): Same.\n\t(make_region_from_loop_preheader): Same.\n\t(sel_init_pipelining): Same.\n\t(get_loop_nest_for_rgn): Same.\n\t(make_regions_from_the_rest): Same.\n\t(sel_is_loop_preheader_p): Same.\n\t* sel-sched-ir.h (inner_loop_header_p): Same.\n\t(get_all_loop_exits): Same.\n\t* selftest.h: Same.\n\t* sese.c (sese_build_liveouts): Same.\n\t(sese_insert_phis_for_liveouts): Same.\n\t* sese.h (defined_in_sese_p): Same.\n\t* sreal.c (sreal::stream_out): Same.\n\t* sreal.h: Same.\n\t* streamer-hooks.h: Same.\n\t* target-globals.c (save_target_globals): Same.\n\t* target-globals.h: Same.\n\t* target.def: Same.\n\t* target.h: Same.\n\t* targhooks.c (default_has_ifunc_p): Same.\n\t(default_empty_mask_is_expensive): Same.\n\t(default_init_cost): Same.\n\t* targhooks.h: Same.\n\t* toplev.c: Same.\n\t* tree-affine.c (aff_combination_mult): Same.\n\t(aff_combination_expand): Same.\n\t(aff_combination_constant_multiple_p): Same.\n\t* tree-affine.h: Same.\n\t* tree-cfg.c (build_gimple_cfg): Same.\n\t(replace_loop_annotate_in_block): Same.\n\t(replace_uses_by): Same.\n\t(remove_bb): Same.\n\t(dump_cfg_stats): Same.\n\t(gimple_duplicate_sese_region): Same.\n\t(gimple_duplicate_sese_tail): Same.\n\t(move_block_to_fn): Same.\n\t(replace_block_vars_by_duplicates): Same.\n\t(move_sese_region_to_fn): Same.\n\t(print_loops_bb): Same.\n\t(print_loop): Same.\n\t(print_loops): Same.\n\t(debug): Same.\n\t(debug_loops): Same.\n\t* tree-cfg.h: Same.\n\t* tree-chrec.c (chrec_fold_plus_poly_poly): Same.\n\t(chrec_fold_multiply_poly_poly): Same.\n\t(chrec_evaluate): Same.\n\t(chrec_component_in_loop_num): Same.\n\t(reset_evolution_in_loop): Same.\n\t(is_multivariate_chrec): Same.\n\t(chrec_contains_symbols): Same.\n\t(nb_vars_in_chrec): Same.\n\t(chrec_convert_1): Same.\n\t(chrec_convert_aggressive): Same.\n\t* tree-chrec.h: Same.\n\t* tree-core.h: Same.\n\t* tree-data-ref.c (dump_data_dependence_relation): Same.\n\t(canonicalize_base_object_address): Same.\n\t(data_ref_compare_tree): Same.\n\t(prune_runtime_alias_test_list): Same.\n\t(get_segment_min_max): Same.\n\t(create_intersect_range_checks): Same.\n\t(conflict_fn_no_dependence): Same.\n\t(object_address_invariant_in_loop_p): Same.\n\t(analyze_ziv_subscript): Same.\n\t(analyze_siv_subscript_cst_affine): Same.\n\t(analyze_miv_subscript): Same.\n\t(analyze_overlapping_iterations): Same.\n\t(build_classic_dist_vector_1): Same.\n\t(add_other_self_distances): Same.\n\t(same_access_functions): Same.\n\t(build_classic_dir_vector): Same.\n\t(subscript_dependence_tester_1): Same.\n\t(subscript_dependence_tester): Same.\n\t(access_functions_are_affine_or_constant_p): Same.\n\t(get_references_in_stmt): Same.\n\t(loop_nest_has_data_refs): Same.\n\t(graphite_find_data_references_in_stmt): Same.\n\t(find_data_references_in_bb): Same.\n\t(get_base_for_alignment): Same.\n\t(find_loop_nest_1): Same.\n\t(find_loop_nest): Same.\n\t* tree-data-ref.h (dr_alignment): Same.\n\t(ddr_dependence_level): Same.\n\t* tree-if-conv.c (fold_build_cond_expr): Same.\n\t(add_to_predicate_list): Same.\n\t(add_to_dst_predicate_list): Same.\n\t(phi_convertible_by_degenerating_args): Same.\n\t(idx_within_array_bound): Same.\n\t(all_preds_critical_p): Same.\n\t(pred_blocks_visited_p): Same.\n\t(predicate_bbs): Same.\n\t(build_region): Same.\n\t(if_convertible_loop_p_1): Same.\n\t(is_cond_scalar_reduction): Same.\n\t(predicate_scalar_phi): Same.\n\t(remove_conditions_and_labels): Same.\n\t(combine_blocks): Same.\n\t(version_loop_for_if_conversion): Same.\n\t(versionable_outer_loop_p): Same.\n\t(ifcvt_local_dce): Same.\n\t(tree_if_conversion): Same.\n\t(pass_if_conversion::gate): Same.\n\t* tree-if-conv.h: Same.\n\t* tree-inline.c (maybe_move_debug_stmts_to_successors): Same.\n\t* tree-loop-distribution.c (bb_top_order_cmp): Same.\n\t(free_rdg): Same.\n\t(stmt_has_scalar_dependences_outside_loop): Same.\n\t(copy_loop_before): Same.\n\t(create_bb_after_loop): Same.\n\t(const_with_all_bytes_same): Same.\n\t(generate_memset_builtin): Same.\n\t(generate_memcpy_builtin): Same.\n\t(destroy_loop): Same.\n\t(build_rdg_partition_for_vertex): Same.\n\t(compute_access_range): Same.\n\t(data_ref_segment_size): Same.\n\t(latch_dominated_by_data_ref): Same.\n\t(compute_alias_check_pairs): Same.\n\t(fuse_memset_builtins): Same.\n\t(finalize_partitions): Same.\n\t(find_seed_stmts_for_distribution): Same.\n\t(prepare_perfect_loop_nest): Same.\n\t* tree-parloops.c (lambda_transform_legal_p): Same.\n\t(loop_parallel_p): Same.\n\t(reduc_stmt_res): Same.\n\t(add_field_for_name): Same.\n\t(create_call_for_reduction_1): Same.\n\t(replace_uses_in_bb_by): Same.\n\t(transform_to_exit_first_loop_alt): Same.\n\t(try_transform_to_exit_first_loop_alt): Same.\n\t(transform_to_exit_first_loop): Same.\n\t(num_phis): Same.\n\t(gen_parallel_loop): Same.\n\t(gather_scalar_reductions): Same.\n\t(get_omp_data_i_param): Same.\n\t(try_create_reduction_list): Same.\n\t(oacc_entry_exit_single_gang): Same.\n\t(parallelize_loops): Same.\n\t* tree-pass.h: Same.\n\t* tree-predcom.c (determine_offset): Same.\n\t(last_always_executed_block): Same.\n\t(split_data_refs_to_components): Same.\n\t(suitable_component_p): Same.\n\t(valid_initializer_p): Same.\n\t(find_looparound_phi): Same.\n\t(insert_looparound_copy): Same.\n\t(add_looparound_copies): Same.\n\t(determine_roots_comp): Same.\n\t(predcom_tmp_var): Same.\n\t(initialize_root_vars): Same.\n\t(initialize_root_vars_store_elim_1): Same.\n\t(initialize_root_vars_store_elim_2): Same.\n\t(finalize_eliminated_stores): Same.\n\t(initialize_root_vars_lm): Same.\n\t(remove_stmt): Same.\n\t(determine_unroll_factor): Same.\n\t(execute_pred_commoning_cbck): Same.\n\t(base_names_in_chain_on): Same.\n\t(combine_chains): Same.\n\t(pcom_stmt_dominates_stmt_p): Same.\n\t(try_combine_chains): Same.\n\t(prepare_initializers_chain_store_elim): Same.\n\t(prepare_initializers_chain): Same.\n\t(prepare_initializers): Same.\n\t(prepare_finalizers_chain): Same.\n\t(prepare_finalizers): Same.\n\t(insert_init_seqs): Same.\n\t* tree-scalar-evolution.c (loop_phi_node_p): Same.\n\t(compute_overall_effect_of_inner_loop): Same.\n\t(add_to_evolution_1): Same.\n\t(add_to_evolution): Same.\n\t(follow_ssa_edge_binary): Same.\n\t(follow_ssa_edge_expr): Same.\n\t(backedge_phi_arg_p): Same.\n\t(follow_ssa_edge_in_condition_phi_branch): Same.\n\t(follow_ssa_edge_in_condition_phi): Same.\n\t(follow_ssa_edge_inner_loop_phi): Same.\n\t(follow_ssa_edge): Same.\n\t(analyze_evolution_in_loop): Same.\n\t(analyze_initial_condition): Same.\n\t(interpret_loop_phi): Same.\n\t(interpret_condition_phi): Same.\n\t(interpret_rhs_expr): Same.\n\t(interpret_expr): Same.\n\t(interpret_gimple_assign): Same.\n\t(analyze_scalar_evolution_1): Same.\n\t(analyze_scalar_evolution): Same.\n\t(analyze_scalar_evolution_for_address_of): Same.\n\t(get_instantiated_value_entry): Same.\n\t(loop_closed_phi_def): Same.\n\t(instantiate_scev_name): Same.\n\t(instantiate_scev_poly): Same.\n\t(instantiate_scev_binary): Same.\n\t(instantiate_scev_convert): Same.\n\t(instantiate_scev_not): Same.\n\t(instantiate_scev_r): Same.\n\t(instantiate_scev): Same.\n\t(resolve_mixers): Same.\n\t(initialize_scalar_evolutions_analyzer): Same.\n\t(scev_reset_htab): Same.\n\t(scev_reset): Same.\n\t(derive_simple_iv_with_niters): Same.\n\t(simple_iv_with_niters): Same.\n\t(expression_expensive_p): Same.\n\t(final_value_replacement_loop): Same.\n\t* tree-scalar-evolution.h (block_before_loop): Same.\n\t* tree-ssa-address.h: Same.\n\t* tree-ssa-dce.c (find_obviously_necessary_stmts): Same.\n\t* tree-ssa-dom.c (edge_info::record_simple_equiv): Same.\n\t(record_edge_info): Same.\n\t* tree-ssa-live.c (var_map_base_fini): Same.\n\t(remove_unused_locals): Same.\n\t* tree-ssa-live.h: Same.\n\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Same.\n\t(pass_ch_vect::execute): Same.\n\t(pass_ch::process_loop_p): Same.\n\t* tree-ssa-loop-im.c (mem_ref_hasher::hash): Same.\n\t(movement_possibility): Same.\n\t(outermost_invariant_loop): Same.\n\t(stmt_cost): Same.\n\t(determine_max_movement): Same.\n\t(invariantness_dom_walker::before_dom_children): Same.\n\t(move_computations): Same.\n\t(may_move_till): Same.\n\t(force_move_till_op): Same.\n\t(force_move_till): Same.\n\t(memref_free): Same.\n\t(record_mem_ref_loc): Same.\n\t(set_ref_stored_in_loop): Same.\n\t(mark_ref_stored): Same.\n\t(sort_bbs_in_loop_postorder_cmp): Same.\n\t(sort_locs_in_loop_postorder_cmp): Same.\n\t(analyze_memory_references): Same.\n\t(mem_refs_may_alias_p): Same.\n\t(find_ref_loc_in_loop_cmp): Same.\n\t(rewrite_mem_ref_loc::operator): Same.\n\t(first_mem_ref_loc_1::operator): Same.\n\t(sm_set_flag_if_changed::operator): Same.\n\t(execute_sm_if_changed_flag_set): Same.\n\t(execute_sm): Same.\n\t(hoist_memory_references): Same.\n\t(ref_always_accessed::operator): Same.\n\t(refs_independent_p): Same.\n\t(record_dep_loop): Same.\n\t(ref_indep_loop_p_1): Same.\n\t(ref_indep_loop_p): Same.\n\t(can_sm_ref_p): Same.\n\t(find_refs_for_sm): Same.\n\t(loop_suitable_for_sm): Same.\n\t(store_motion_loop): Same.\n\t(store_motion): Same.\n\t(fill_always_executed_in): Same.\n\t* tree-ssa-loop-ivcanon.c (constant_after_peeling): Same.\n\t(estimated_unrolled_size): Same.\n\t(loop_edge_to_cancel): Same.\n\t(remove_exits_and_undefined_stmts): Same.\n\t(remove_redundant_iv_tests): Same.\n\t(unloop_loops): Same.\n\t(estimated_peeled_sequence_size): Same.\n\t(try_peel_loop): Same.\n\t(canonicalize_loop_induction_variables): Same.\n\t(canonicalize_induction_variables): Same.\n\t* tree-ssa-loop-ivopts.c (iv_inv_expr_hasher::equal): Same.\n\t(name_info): Same.\n\t(stmt_after_inc_pos): Same.\n\t(contains_abnormal_ssa_name_p): Same.\n\t(niter_for_exit): Same.\n\t(find_bivs): Same.\n\t(mark_bivs): Same.\n\t(find_givs_in_bb): Same.\n\t(find_induction_variables): Same.\n\t(find_interesting_uses_cond): Same.\n\t(outermost_invariant_loop_for_expr): Same.\n\t(idx_find_step): Same.\n\t(add_candidate_1): Same.\n\t(add_iv_candidate_derived_from_uses): Same.\n\t(alloc_use_cost_map): Same.\n\t(prepare_decl_rtl): Same.\n\t(generic_predict_doloop_p): Same.\n\t(computation_cost): Same.\n\t(determine_common_wider_type): Same.\n\t(get_computation_aff_1): Same.\n\t(get_use_type): Same.\n\t(determine_group_iv_cost_address): Same.\n\t(iv_period): Same.\n\t(difference_cannot_overflow_p): Same.\n\t(may_eliminate_iv): Same.\n\t(determine_set_costs): Same.\n\t(cheaper_cost_pair): Same.\n\t(compare_cost_pair): Same.\n\t(iv_ca_cand_for_group): Same.\n\t(iv_ca_recount_cost): Same.\n\t(iv_ca_set_remove_invs): Same.\n\t(iv_ca_set_no_cp): Same.\n\t(iv_ca_set_add_invs): Same.\n\t(iv_ca_set_cp): Same.\n\t(iv_ca_add_group): Same.\n\t(iv_ca_cost): Same.\n\t(iv_ca_compare_deps): Same.\n\t(iv_ca_delta_reverse): Same.\n\t(iv_ca_delta_commit): Same.\n\t(iv_ca_cand_used_p): Same.\n\t(iv_ca_delta_free): Same.\n\t(iv_ca_new): Same.\n\t(iv_ca_free): Same.\n\t(iv_ca_dump): Same.\n\t(iv_ca_extend): Same.\n\t(iv_ca_narrow): Same.\n\t(iv_ca_prune): Same.\n\t(cheaper_cost_with_cand): Same.\n\t(iv_ca_replace): Same.\n\t(try_add_cand_for): Same.\n\t(get_initial_solution): Same.\n\t(try_improve_iv_set): Same.\n\t(find_optimal_iv_set_1): Same.\n\t(create_new_iv): Same.\n\t(rewrite_use_compare): Same.\n\t(remove_unused_ivs): Same.\n\t(determine_scaling_factor): Same.\n\t* tree-ssa-loop-ivopts.h: Same.\n\t* tree-ssa-loop-manip.c (create_iv): Same.\n\t(compute_live_loop_exits): Same.\n\t(add_exit_phi): Same.\n\t(add_exit_phis): Same.\n\t(find_uses_to_rename_use): Same.\n\t(find_uses_to_rename_def): Same.\n\t(find_uses_to_rename_in_loop): Same.\n\t(rewrite_into_loop_closed_ssa): Same.\n\t(check_loop_closed_ssa_bb): Same.\n\t(split_loop_exit_edge): Same.\n\t(ip_end_pos): Same.\n\t(ip_normal_pos): Same.\n\t(copy_phi_node_args): Same.\n\t(gimple_duplicate_loop_to_header_edge): Same.\n\t(can_unroll_loop_p): Same.\n\t(determine_exit_conditions): Same.\n\t(scale_dominated_blocks_in_loop): Same.\n\t(niter_for_unrolled_loop): Same.\n\t(tree_transform_and_unroll_loop): Same.\n\t(rewrite_all_phi_nodes_with_iv): Same.\n\t* tree-ssa-loop-manip.h: Same.\n\t* tree-ssa-loop-niter.c (number_of_iterations_ne_max): Same.\n\t(number_of_iterations_ne): Same.\n\t(assert_no_overflow_lt): Same.\n\t(assert_loop_rolls_lt): Same.\n\t(number_of_iterations_lt): Same.\n\t(adjust_cond_for_loop_until_wrap): Same.\n\t(tree_simplify_using_condition): Same.\n\t(simplify_using_initial_conditions): Same.\n\t(simplify_using_outer_evolutions): Same.\n\t(loop_only_exit_p): Same.\n\t(ssa_defined_by_minus_one_stmt_p): Same.\n\t(number_of_iterations_popcount): Same.\n\t(number_of_iterations_exit): Same.\n\t(find_loop_niter): Same.\n\t(finite_loop_p): Same.\n\t(chain_of_csts_start): Same.\n\t(get_val_for): Same.\n\t(loop_niter_by_eval): Same.\n\t(derive_constant_upper_bound_ops): Same.\n\t(do_warn_aggressive_loop_optimizations): Same.\n\t(record_estimate): Same.\n\t(get_cst_init_from_scev): Same.\n\t(record_nonwrapping_iv): Same.\n\t(idx_infer_loop_bounds): Same.\n\t(infer_loop_bounds_from_ref): Same.\n\t(infer_loop_bounds_from_array): Same.\n\t(infer_loop_bounds_from_pointer_arith): Same.\n\t(infer_loop_bounds_from_signedness): Same.\n\t(bound_index): Same.\n\t(discover_iteration_bound_by_body_walk): Same.\n\t(maybe_lower_iteration_bound): Same.\n\t(estimate_numbers_of_iterations): Same.\n\t(estimated_loop_iterations): Same.\n\t(estimated_loop_iterations_int): Same.\n\t(max_loop_iterations): Same.\n\t(max_loop_iterations_int): Same.\n\t(likely_max_loop_iterations): Same.\n\t(likely_max_loop_iterations_int): Same.\n\t(estimated_stmt_executions_int): Same.\n\t(max_stmt_executions): Same.\n\t(likely_max_stmt_executions): Same.\n\t(estimated_stmt_executions): Same.\n\t(stmt_dominates_stmt_p): Same.\n\t(nowrap_type_p): Same.\n\t(loop_exits_before_overflow): Same.\n\t(scev_var_range_cant_overflow): Same.\n\t(scev_probably_wraps_p): Same.\n\t(free_numbers_of_iterations_estimates): Same.\n\t* tree-ssa-loop-niter.h: Same.\n\t* tree-ssa-loop-prefetch.c (release_mem_refs): Same.\n\t(idx_analyze_ref): Same.\n\t(analyze_ref): Same.\n\t(gather_memory_references_ref): Same.\n\t(mark_nontemporal_store): Same.\n\t(emit_mfence_after_loop): Same.\n\t(may_use_storent_in_loop_p): Same.\n\t(mark_nontemporal_stores): Same.\n\t(should_unroll_loop_p): Same.\n\t(volume_of_dist_vector): Same.\n\t(add_subscript_strides): Same.\n\t(self_reuse_distance): Same.\n\t(insn_to_prefetch_ratio_too_small_p): Same.\n\t* tree-ssa-loop-split.c (split_at_bb_p): Same.\n\t(patch_loop_exit): Same.\n\t(find_or_create_guard_phi): Same.\n\t(easy_exit_values): Same.\n\t(connect_loop_phis): Same.\n\t(connect_loops): Same.\n\t(compute_new_first_bound): Same.\n\t(split_loop): Same.\n\t(tree_ssa_split_loops): Same.\n\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops): Same.\n\t(is_maybe_undefined): Same.\n\t(tree_may_unswitch_on): Same.\n\t(simplify_using_entry_checks): Same.\n\t(tree_unswitch_single_loop): Same.\n\t(tree_unswitch_loop): Same.\n\t(tree_unswitch_outer_loop): Same.\n\t(empty_bb_without_guard_p): Same.\n\t(used_outside_loop_p): Same.\n\t(get_vop_from_header): Same.\n\t(hoist_guard): Same.\n\t* tree-ssa-loop.c (gate_oacc_kernels): Same.\n\t(get_lsm_tmp_name): Same.\n\t* tree-ssa-loop.h: Same.\n\t* tree-ssa-reassoc.c (add_repeat_to_ops_vec): Same.\n\t(build_and_add_sum): Same.\n\t(no_side_effect_bb): Same.\n\t(get_ops): Same.\n\t(linearize_expr): Same.\n\t(should_break_up_subtract): Same.\n\t(linearize_expr_tree): Same.\n\t* tree-ssa-scopedtables.c: Same.\n\t* tree-ssa-scopedtables.h: Same.\n\t* tree-ssa-structalias.c (condense_visit): Same.\n\t(label_visit): Same.\n\t(dump_pred_graph): Same.\n\t(perform_var_substitution): Same.\n\t(move_complex_constraints): Same.\n\t(remove_preds_and_fake_succs): Same.\n\t* tree-ssa-threadupdate.c (dbds_continue_enumeration_p): Same.\n\t(determine_bb_domination_status): Same.\n\t(duplicate_thread_path): Same.\n\t(thread_through_all_blocks): Same.\n\t* tree-ssa-threadupdate.h: Same.\n\t* tree-streamer-in.c (streamer_read_string_cst): Same.\n\t(input_identifier): Same.\n\t(unpack_ts_type_common_value_fields): Same.\n\t(unpack_ts_block_value_fields): Same.\n\t(unpack_ts_translation_unit_decl_value_fields): Same.\n\t(unpack_ts_omp_clause_value_fields): Same.\n\t(streamer_read_tree_bitfields): Same.\n\t(streamer_alloc_tree): Same.\n\t(lto_input_ts_common_tree_pointers): Same.\n\t(lto_input_ts_vector_tree_pointers): Same.\n\t(lto_input_ts_poly_tree_pointers): Same.\n\t(lto_input_ts_complex_tree_pointers): Same.\n\t(lto_input_ts_decl_minimal_tree_pointers): Same.\n\t(lto_input_ts_decl_common_tree_pointers): Same.\n\t(lto_input_ts_decl_non_common_tree_pointers): Same.\n\t(lto_input_ts_decl_with_vis_tree_pointers): Same.\n\t(lto_input_ts_field_decl_tree_pointers): Same.\n\t(lto_input_ts_function_decl_tree_pointers): Same.\n\t(lto_input_ts_type_common_tree_pointers): Same.\n\t(lto_input_ts_type_non_common_tree_pointers): Same.\n\t(lto_input_ts_list_tree_pointers): Same.\n\t(lto_input_ts_vec_tree_pointers): Same.\n\t(lto_input_ts_exp_tree_pointers): Same.\n\t(lto_input_ts_block_tree_pointers): Same.\n\t(lto_input_ts_binfo_tree_pointers): Same.\n\t(lto_input_ts_constructor_tree_pointers): Same.\n\t(lto_input_ts_omp_clause_tree_pointers): Same.\n\t(streamer_read_tree_body): Same.\n\t* tree-streamer.h: Same.\n\t* tree-switch-conversion.c (bit_test_cluster::is_beneficial): Same.\n\t* tree-vect-data-refs.c (vect_get_smallest_scalar_type): Same.\n\t(vect_analyze_possibly_independent_ddr): Same.\n\t(vect_analyze_data_ref_dependence): Same.\n\t(vect_compute_data_ref_alignment): Same.\n\t(vect_enhance_data_refs_alignment): Same.\n\t(vect_analyze_data_ref_access): Same.\n\t(vect_check_gather_scatter): Same.\n\t(vect_find_stmt_data_reference): Same.\n\t(vect_create_addr_base_for_vector_ref): Same.\n\t(vect_setup_realignment): Same.\n\t(vect_supportable_dr_alignment): Same.\n\t* tree-vect-loop-manip.c (rename_variables_in_bb): Same.\n\t(adjust_phi_and_debug_stmts): Same.\n\t(vect_set_loop_mask): Same.\n\t(add_preheader_seq): Same.\n\t(vect_maybe_permute_loop_masks): Same.\n\t(vect_set_loop_masks_directly): Same.\n\t(vect_set_loop_condition_masked): Same.\n\t(vect_set_loop_condition_unmasked): Same.\n\t(slpeel_duplicate_current_defs_from_edges): Same.\n\t(slpeel_add_loop_guard): Same.\n\t(slpeel_can_duplicate_loop_p): Same.\n\t(create_lcssa_for_virtual_phi): Same.\n\t(iv_phi_p): Same.\n\t(vect_update_ivs_after_vectorizer): Same.\n\t(vect_gen_vector_loop_niters_mult_vf): Same.\n\t(slpeel_update_phi_nodes_for_loops): Same.\n\t(slpeel_update_phi_nodes_for_guard1): Same.\n\t(find_guard_arg): Same.\n\t(slpeel_update_phi_nodes_for_guard2): Same.\n\t(slpeel_update_phi_nodes_for_lcssa): Same.\n\t(vect_do_peeling): Same.\n\t(vect_create_cond_for_alias_checks): Same.\n\t(vect_loop_versioning): Same.\n\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Same.\n\t(vect_inner_phi_in_double_reduction_p): Same.\n\t(vect_analyze_scalar_cycles_1): Same.\n\t(vect_fixup_scalar_cycles_with_patterns): Same.\n\t(vect_get_loop_niters): Same.\n\t(bb_in_loop_p): Same.\n\t(vect_get_max_nscalars_per_iter): Same.\n\t(vect_verify_full_masking): Same.\n\t(vect_compute_single_scalar_iteration_cost): Same.\n\t(vect_analyze_loop_form_1): Same.\n\t(vect_analyze_loop_form): Same.\n\t(vect_active_double_reduction_p): Same.\n\t(vect_analyze_loop_operations): Same.\n\t(neutral_op_for_slp_reduction): Same.\n\t(vect_is_simple_reduction): Same.\n\t(vect_model_reduction_cost): Same.\n\t(get_initial_def_for_reduction): Same.\n\t(get_initial_defs_for_reduction): Same.\n\t(vect_create_epilog_for_reduction): Same.\n\t(vectorize_fold_left_reduction): Same.\n\t(vectorizable_reduction): Same.\n\t(vectorizable_induction): Same.\n\t(vectorizable_live_operation): Same.\n\t(loop_niters_no_overflow): Same.\n\t(vect_get_loop_mask): Same.\n\t(vect_transform_loop_stmt): Same.\n\t(vect_transform_loop): Same.\n\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Same.\n\t(vect_determine_precisions): Same.\n\t(vect_pattern_recog_1): Same.\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Same.\n\t* tree-vect-stmts.c (stmt_vectype): Same.\n\t(process_use): Same.\n\t(vect_init_vector_1): Same.\n\t(vect_truncate_gather_scatter_offset): Same.\n\t(get_group_load_store_type): Same.\n\t(vect_build_gather_load_calls): Same.\n\t(vect_get_strided_load_store_ops): Same.\n\t(vectorizable_simd_clone_call): Same.\n\t(vectorizable_store): Same.\n\t(permute_vec_elements): Same.\n\t(vectorizable_load): Same.\n\t(vect_transform_stmt): Same.\n\t(supportable_widening_operation): Same.\n\t* tree-vectorizer.c (vec_info::replace_stmt): Same.\n\t(vec_info::free_stmt_vec_info): Same.\n\t(vect_free_loop_info_assumptions): Same.\n\t(vect_loop_vectorized_call): Same.\n\t(set_uid_loop_bbs): Same.\n\t(vectorize_loops): Same.\n\t* tree-vectorizer.h (STMT_VINFO_BB_VINFO): Same.\n\t* tree.c (add_tree_to_fld_list): Same.\n\t(fld_type_variant_equal_p): Same.\n\t(fld_decl_context): Same.\n\t(fld_incomplete_type_of): Same.\n\t(free_lang_data_in_binfo): Same.\n\t(need_assembler_name_p): Same.\n\t(find_decls_types_r): Same.\n\t(get_eh_types_for_runtime): Same.\n\t(find_decls_types_in_eh_region): Same.\n\t(find_decls_types_in_node): Same.\n\t(assign_assembler_name_if_needed): Same.\n\t* value-prof.c (stream_out_histogram_value): Same.\n\t* value-prof.h: Same.\n\t* var-tracking.c (use_narrower_mode): Same.\n\t(prepare_call_arguments): Same.\n\t(vt_expand_loc_callback): Same.\n\t(resolve_expansions_pending_recursion): Same.\n\t(vt_expand_loc): Same.\n\t* varasm.c (const_hash_1): Same.\n\t(compare_constant): Same.\n\t(tree_output_constant_def): Same.\n\t(simplify_subtraction): Same.\n\t(get_pool_constant): Same.\n\t(output_constant_pool_2): Same.\n\t(output_constant_pool_1): Same.\n\t(mark_constants_in_pattern): Same.\n\t(mark_constant_pool): Same.\n\t(get_section_anchor): Same.\n\t* vr-values.c (compare_range_with_value): Same.\n\t(vr_values::extract_range_from_phi_node): Same.\n\t* vr-values.h: Same.\n\t* web.c (unionfind_union): Same.\n\t* wide-int.h: Same.\n\nFrom-SVN: r273311", "tree": {"sha": "1de4b72ee58329bc7ebad81476075375fee586cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1de4b72ee58329bc7ebad81476075375fee586cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99b1c316ec974a39bdd949f8559bb28861b69592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b1c316ec974a39bdd949f8559bb28861b69592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99b1c316ec974a39bdd949f8559bb28861b69592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b1c316ec974a39bdd949f8559bb28861b69592/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18c0ed4b46990c504525aa4928aab45907c8256d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c0ed4b46990c504525aa4928aab45907c8256d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c0ed4b46990c504525aa4928aab45907c8256d"}], "stats": {"total": 6986, "additions": 4226, "deletions": 2760}, "files": [{"sha": "3872b6dbb8a89e2bb47093d6be8090d825788196", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1431, "deletions": 0, "changes": 1431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -5,6 +5,1437 @@\n \tfunction from rs6000-logue.c back to rs6000.c.\n \t* config/rs6000/rs6000.c (create_TOC_reference): Likewise.\n \n+2019-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* auto-profile.c: Change class-key of PODs to struct and others\n+\tto class.\n+\t* basic-block.h: Same.\n+\t* bitmap.c (bitmap_alloc): Same.\n+\t* bitmap.h: Same.\n+\t* builtins.c (expand_builtin_prefetch): Same.\n+\t(expand_builtin_interclass_mathfn): Same.\n+\t(expand_builtin_strlen): Same.\n+\t(expand_builtin_mempcpy_args): Same.\n+\t(expand_cmpstr): Same.\n+\t(expand_builtin___clear_cache): Same.\n+\t(expand_ifn_atomic_bit_test_and): Same.\n+\t(expand_builtin_thread_pointer): Same.\n+\t(expand_builtin_set_thread_pointer): Same.\n+\t* caller-save.c (setup_save_areas): Same.\n+\t(replace_reg_with_saved_mem): Same.\n+\t(insert_restore): Same.\n+\t(insert_save): Same.\n+\t(add_used_regs): Same.\n+\t* cfg.c (get_bb_copy): Same.\n+\t(set_loop_copy): Same.\n+\t* cfg.h: Same.\n+\t* cfganal.h: Same.\n+\t* cfgexpand.c (alloc_stack_frame_space): Same.\n+\t(add_stack_var): Same.\n+\t(add_stack_var_conflict): Same.\n+\t(add_scope_conflicts_1): Same.\n+\t(update_alias_info_with_stack_vars): Same.\n+\t(expand_used_vars): Same.\n+\t* cfghooks.c (redirect_edge_and_branch_force): Same.\n+\t(delete_basic_block): Same.\n+\t(split_edge): Same.\n+\t(make_forwarder_block): Same.\n+\t(force_nonfallthru): Same.\n+\t(duplicate_block): Same.\n+\t(lv_flush_pending_stmts): Same.\n+\t* cfghooks.h: Same.\n+\t* cfgloop.c (flow_loops_cfg_dump): Same.\n+\t(flow_loop_nested_p): Same.\n+\t(superloop_at_depth): Same.\n+\t(get_loop_latch_edges): Same.\n+\t(flow_loop_dump): Same.\n+\t(flow_loops_dump): Same.\n+\t(flow_loops_free): Same.\n+\t(flow_loop_nodes_find): Same.\n+\t(establish_preds): Same.\n+\t(flow_loop_tree_node_add): Same.\n+\t(flow_loop_tree_node_remove): Same.\n+\t(flow_loops_find): Same.\n+\t(find_subloop_latch_edge_by_profile): Same.\n+\t(find_subloop_latch_edge_by_ivs): Same.\n+\t(mfb_redirect_edges_in_set): Same.\n+\t(form_subloop): Same.\n+\t(merge_latch_edges): Same.\n+\t(disambiguate_multiple_latches): Same.\n+\t(disambiguate_loops_with_multiple_latches): Same.\n+\t(flow_bb_inside_loop_p): Same.\n+\t(glb_enum_p): Same.\n+\t(get_loop_body_with_size): Same.\n+\t(get_loop_body): Same.\n+\t(fill_sons_in_loop): Same.\n+\t(get_loop_body_in_dom_order): Same.\n+\t(get_loop_body_in_custom_order): Same.\n+\t(release_recorded_exits): Same.\n+\t(get_loop_exit_edges): Same.\n+\t(num_loop_branches): Same.\n+\t(remove_bb_from_loops): Same.\n+\t(find_common_loop): Same.\n+\t(delete_loop): Same.\n+\t(cancel_loop): Same.\n+\t(verify_loop_structure): Same.\n+\t(loop_preheader_edge): Same.\n+\t(loop_exit_edge_p): Same.\n+\t(single_exit): Same.\n+\t(loop_exits_to_bb_p): Same.\n+\t(loop_exits_from_bb_p): Same.\n+\t(get_loop_location): Same.\n+\t(record_niter_bound): Same.\n+\t(get_estimated_loop_iterations_int): Same.\n+\t(max_stmt_executions_int): Same.\n+\t(likely_max_stmt_executions_int): Same.\n+\t(get_estimated_loop_iterations): Same.\n+\t(get_max_loop_iterations): Same.\n+\t(get_max_loop_iterations_int): Same.\n+\t(get_likely_max_loop_iterations): Same.\n+\t* cfgloop.h (simple_loop_desc): Same.\n+\t(get_loop): Same.\n+\t(loop_depth): Same.\n+\t(loop_outer): Same.\n+\t(loop_iterator::next): Same.\n+\t(loop_outermost): Same.\n+\t* cfgloopanal.c (mark_irreducible_loops): Same.\n+\t(num_loop_insns): Same.\n+\t(average_num_loop_insns): Same.\n+\t(expected_loop_iterations_unbounded): Same.\n+\t(expected_loop_iterations): Same.\n+\t(mark_loop_exit_edges): Same.\n+\t(single_likely_exit): Same.\n+\t* cfgloopmanip.c (fix_bb_placement): Same.\n+\t(fix_bb_placements): Same.\n+\t(remove_path): Same.\n+\t(place_new_loop): Same.\n+\t(add_loop): Same.\n+\t(scale_loop_frequencies): Same.\n+\t(scale_loop_profile): Same.\n+\t(create_empty_if_region_on_edge): Same.\n+\t(create_empty_loop_on_edge): Same.\n+\t(loopify): Same.\n+\t(unloop): Same.\n+\t(fix_loop_placements): Same.\n+\t(copy_loop_info): Same.\n+\t(duplicate_loop): Same.\n+\t(duplicate_subloops): Same.\n+\t(loop_redirect_edge): Same.\n+\t(can_duplicate_loop_p): Same.\n+\t(duplicate_loop_to_header_edge): Same.\n+\t(mfb_keep_just): Same.\n+\t(has_preds_from_loop): Same.\n+\t(create_preheader): Same.\n+\t(create_preheaders): Same.\n+\t(lv_adjust_loop_entry_edge): Same.\n+\t(loop_version): Same.\n+\t* cfgloopmanip.h: Same.\n+\t* cgraph.h: Same.\n+\t* cgraphbuild.c: Same.\n+\t* combine.c (make_extraction): Same.\n+\t* config/i386/i386-features.c: Same.\n+\t* config/i386/i386-features.h: Same.\n+\t* config/i386/i386.c (ix86_emit_outlined_ms2sysv_save): Same.\n+\t(ix86_emit_outlined_ms2sysv_restore): Same.\n+\t(ix86_noce_conversion_profitable_p): Same.\n+\t(ix86_init_cost): Same.\n+\t(ix86_simd_clone_usable): Same.\n+\t* configure.ac: Same.\n+\t* coretypes.h: Same.\n+\t* data-streamer-in.c (string_for_index): Same.\n+\t(streamer_read_indexed_string): Same.\n+\t(streamer_read_string): Same.\n+\t(bp_unpack_indexed_string): Same.\n+\t(bp_unpack_string): Same.\n+\t(streamer_read_uhwi): Same.\n+\t(streamer_read_hwi): Same.\n+\t(streamer_read_gcov_count): Same.\n+\t(streamer_read_wide_int): Same.\n+\t* data-streamer.h (streamer_write_bitpack): Same.\n+\t(bp_unpack_value): Same.\n+\t(streamer_write_char_stream): Same.\n+\t(streamer_write_hwi_in_range): Same.\n+\t(streamer_write_record_start): Same.\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link): Same.\n+\t(add_cross_iteration_register_deps): Same.\n+\t(build_intra_loop_deps): Same.\n+\t* df-core.c (df_analyze): Same.\n+\t(loop_post_order_compute): Same.\n+\t(loop_inverted_post_order_compute): Same.\n+\t* df-problems.c (df_rd_alloc): Same.\n+\t(df_rd_simulate_one_insn): Same.\n+\t(df_rd_local_compute): Same.\n+\t(df_rd_init_solution): Same.\n+\t(df_rd_confluence_n): Same.\n+\t(df_rd_transfer_function): Same.\n+\t(df_rd_free): Same.\n+\t(df_rd_dump_defs_set): Same.\n+\t(df_rd_top_dump): Same.\n+\t(df_lr_alloc): Same.\n+\t(df_lr_reset): Same.\n+\t(df_lr_local_compute): Same.\n+\t(df_lr_init): Same.\n+\t(df_lr_confluence_n): Same.\n+\t(df_lr_free): Same.\n+\t(df_lr_top_dump): Same.\n+\t(df_lr_verify_transfer_functions): Same.\n+\t(df_live_alloc): Same.\n+\t(df_live_reset): Same.\n+\t(df_live_init): Same.\n+\t(df_live_confluence_n): Same.\n+\t(df_live_finalize): Same.\n+\t(df_live_free): Same.\n+\t(df_live_top_dump): Same.\n+\t(df_live_verify_transfer_functions): Same.\n+\t(df_mir_alloc): Same.\n+\t(df_mir_reset): Same.\n+\t(df_mir_init): Same.\n+\t(df_mir_confluence_n): Same.\n+\t(df_mir_free): Same.\n+\t(df_mir_top_dump): Same.\n+\t(df_word_lr_alloc): Same.\n+\t(df_word_lr_reset): Same.\n+\t(df_word_lr_init): Same.\n+\t(df_word_lr_confluence_n): Same.\n+\t(df_word_lr_free): Same.\n+\t(df_word_lr_top_dump): Same.\n+\t(df_md_alloc): Same.\n+\t(df_md_simulate_one_insn): Same.\n+\t(df_md_reset): Same.\n+\t(df_md_init): Same.\n+\t(df_md_free): Same.\n+\t(df_md_top_dump): Same.\n+\t* df-scan.c (df_insn_delete): Same.\n+\t(df_insn_rescan): Same.\n+\t(df_notes_rescan): Same.\n+\t(df_sort_and_compress_mws): Same.\n+\t(df_install_mws): Same.\n+\t(df_refs_add_to_chains): Same.\n+\t(df_ref_create_structure): Same.\n+\t(df_ref_record): Same.\n+\t(df_def_record_1): Same.\n+\t(df_find_hard_reg_defs): Same.\n+\t(df_uses_record): Same.\n+\t(df_get_conditional_uses): Same.\n+\t(df_get_call_refs): Same.\n+\t(df_recompute_luids): Same.\n+\t(df_get_entry_block_def_set): Same.\n+\t(df_entry_block_defs_collect): Same.\n+\t(df_get_exit_block_use_set): Same.\n+\t(df_exit_block_uses_collect): Same.\n+\t(df_mws_verify): Same.\n+\t(df_bb_verify): Same.\n+\t* df.h (df_scan_get_bb_info): Same.\n+\t* doc/tm.texi: Same.\n+\t* dse.c (record_store): Same.\n+\t* dumpfile.h: Same.\n+\t* emit-rtl.c (const_fixed_hasher::equal): Same.\n+\t(set_mem_attributes_minus_bitpos): Same.\n+\t(change_address): Same.\n+\t(adjust_address_1): Same.\n+\t(offset_address): Same.\n+\t* emit-rtl.h: Same.\n+\t* except.c (dw2_build_landing_pads): Same.\n+\t(sjlj_emit_dispatch_table): Same.\n+\t* explow.c (allocate_dynamic_stack_space): Same.\n+\t(emit_stack_probe): Same.\n+\t(probe_stack_range): Same.\n+\t* expmed.c (store_bit_field_using_insv): Same.\n+\t(store_bit_field_1): Same.\n+\t(store_integral_bit_field): Same.\n+\t(extract_bit_field_using_extv): Same.\n+\t(extract_bit_field_1): Same.\n+\t(emit_cstore): Same.\n+\t* expr.c (emit_block_move_via_cpymem): Same.\n+\t(expand_cmpstrn_or_cmpmem): Same.\n+\t(set_storage_via_setmem): Same.\n+\t(emit_single_push_insn_1): Same.\n+\t(expand_assignment): Same.\n+\t(store_constructor): Same.\n+\t(expand_expr_real_2): Same.\n+\t(expand_expr_real_1): Same.\n+\t(try_casesi): Same.\n+\t* flags.h: Same.\n+\t* function.c (try_fit_stack_local): Same.\n+\t(assign_stack_local_1): Same.\n+\t(assign_stack_local): Same.\n+\t(cut_slot_from_list): Same.\n+\t(insert_slot_to_list): Same.\n+\t(max_slot_level): Same.\n+\t(move_slot_to_level): Same.\n+\t(temp_address_hasher::equal): Same.\n+\t(remove_unused_temp_slot_addresses): Same.\n+\t(assign_temp): Same.\n+\t(combine_temp_slots): Same.\n+\t(update_temp_slot_address): Same.\n+\t(preserve_temp_slots): Same.\n+\t* function.h: Same.\n+\t* fwprop.c: Same.\n+\t* gcc-rich-location.h: Same.\n+\t* gcov.c: Same.\n+\t* genattrtab.c (check_attr_test): Same.\n+\t(check_attr_value): Same.\n+\t(convert_set_attr_alternative): Same.\n+\t(convert_set_attr): Same.\n+\t(check_defs): Same.\n+\t(copy_boolean): Same.\n+\t(get_attr_value): Same.\n+\t(expand_delays): Same.\n+\t(make_length_attrs): Same.\n+\t(min_fn): Same.\n+\t(make_alternative_compare): Same.\n+\t(simplify_test_exp): Same.\n+\t(tests_attr_p): Same.\n+\t(get_attr_order): Same.\n+\t(clear_struct_flag): Same.\n+\t(gen_attr): Same.\n+\t(compares_alternatives_p): Same.\n+\t(gen_insn): Same.\n+\t(gen_delay): Same.\n+\t(find_attrs_to_cache): Same.\n+\t(write_test_expr): Same.\n+\t(walk_attr_value): Same.\n+\t(write_attr_get): Same.\n+\t(eliminate_known_true): Same.\n+\t(write_insn_cases): Same.\n+\t(write_attr_case): Same.\n+\t(write_attr_valueq): Same.\n+\t(write_attr_value): Same.\n+\t(write_dummy_eligible_delay): Same.\n+\t(next_comma_elt): Same.\n+\t(find_attr): Same.\n+\t(make_internal_attr): Same.\n+\t(copy_rtx_unchanging): Same.\n+\t(gen_insn_reserv): Same.\n+\t(check_tune_attr): Same.\n+\t(make_automaton_attrs): Same.\n+\t(handle_arg): Same.\n+\t* genextract.c (gen_insn): Same.\n+\t(VEC_char_to_string): Same.\n+\t* genmatch.c (print_operand): Same.\n+\t(lower): Same.\n+\t(parser::parse_operation): Same.\n+\t(parser::parse_capture): Same.\n+\t(parser::parse_c_expr): Same.\n+\t(parser::parse_simplify): Same.\n+\t(main): Same.\n+\t* genoutput.c (output_operand_data): Same.\n+\t(output_get_insn_name): Same.\n+\t(compare_operands): Same.\n+\t(place_operands): Same.\n+\t(process_template): Same.\n+\t(validate_insn_alternatives): Same.\n+\t(validate_insn_operands): Same.\n+\t(gen_expand): Same.\n+\t(note_constraint): Same.\n+\t* genpreds.c (write_one_predicate_function): Same.\n+\t(add_constraint): Same.\n+\t(process_define_register_constraint): Same.\n+\t(write_lookup_constraint_1): Same.\n+\t(write_lookup_constraint_array): Same.\n+\t(write_insn_constraint_len): Same.\n+\t(write_reg_class_for_constraint_1): Same.\n+\t(write_constraint_satisfied_p_array): Same.\n+\t* genrecog.c (optimize_subroutine_group): Same.\n+\t* gensupport.c (process_define_predicate): Same.\n+\t(queue_pattern): Same.\n+\t(remove_from_queue): Same.\n+\t(process_rtx): Same.\n+\t(is_predicable): Same.\n+\t(change_subst_attribute): Same.\n+\t(subst_pattern_match): Same.\n+\t(alter_constraints): Same.\n+\t(alter_attrs_for_insn): Same.\n+\t(shift_output_template): Same.\n+\t(alter_output_for_subst_insn): Same.\n+\t(process_one_cond_exec): Same.\n+\t(subst_dup): Same.\n+\t(process_define_cond_exec): Same.\n+\t(mnemonic_htab_callback): Same.\n+\t(gen_mnemonic_attr): Same.\n+\t(read_md_rtx): Same.\n+\t* ggc-page.c: Same.\n+\t* gimple-loop-interchange.cc (dump_reduction): Same.\n+\t(dump_induction): Same.\n+\t(loop_cand::~loop_cand): Same.\n+\t(free_data_refs_with_aux): Same.\n+\t(tree_loop_interchange::interchange_loops): Same.\n+\t(tree_loop_interchange::map_inductions_to_loop): Same.\n+\t(tree_loop_interchange::move_code_to_inner_loop): Same.\n+\t(compute_access_stride): Same.\n+\t(compute_access_strides): Same.\n+\t(proper_loop_form_for_interchange): Same.\n+\t(tree_loop_interchange_compute_ddrs): Same.\n+\t(prune_datarefs_not_in_loop): Same.\n+\t(prepare_data_references): Same.\n+\t(pass_linterchange::execute): Same.\n+\t* gimple-loop-jam.c (bb_prevents_fusion_p): Same.\n+\t(unroll_jam_possible_p): Same.\n+\t(fuse_loops): Same.\n+\t(adjust_unroll_factor): Same.\n+\t(tree_loop_unroll_and_jam): Same.\n+\t* gimple-loop-versioning.cc (loop_versioning::~loop_versioning): Same.\n+\t(loop_versioning::expensive_stmt_p): Same.\n+\t(loop_versioning::version_for_unity): Same.\n+\t(loop_versioning::dump_inner_likelihood): Same.\n+\t(loop_versioning::find_per_loop_multiplication): Same.\n+\t(loop_versioning::analyze_term_using_scevs): Same.\n+\t(loop_versioning::record_address_fragment): Same.\n+\t(loop_versioning::analyze_expr): Same.\n+\t(loop_versioning::analyze_blocks): Same.\n+\t(loop_versioning::prune_conditions): Same.\n+\t(loop_versioning::merge_loop_info): Same.\n+\t(loop_versioning::add_loop_to_queue): Same.\n+\t(loop_versioning::decide_whether_loop_is_versionable): Same.\n+\t(loop_versioning::make_versioning_decisions): Same.\n+\t(loop_versioning::implement_versioning_decisions): Same.\n+\t* gimple-ssa-evrp-analyze.c\n+\t(evrp_range_analyzer::record_ranges_from_phis): Same.\n+\t* gimple-ssa-store-merging.c (split_store::split_store): Same.\n+\t(count_multiple_uses): Same.\n+\t(split_group): Same.\n+\t(imm_store_chain_info::output_merged_store): Same.\n+\t(pass_store_merging::process_store): Same.\n+\t* gimple-ssa-strength-reduction.c (slsr_process_phi): Same.\n+\t* gimple-ssa-warn-alloca.c (adjusted_warn_limit): Same.\n+\t(is_max): Same.\n+\t(alloca_call_type): Same.\n+\t(pass_walloca::execute): Same.\n+\t* gimple-streamer-in.c (input_phi): Same.\n+\t(input_gimple_stmt): Same.\n+\t* gimple-streamer.h: Same.\n+\t* godump.c (go_force_record_alignment): Same.\n+\t(go_format_type): Same.\n+\t(go_output_type): Same.\n+\t(go_output_fndecl): Same.\n+\t(go_output_typedef): Same.\n+\t(keyword_hash_init): Same.\n+\t(find_dummy_types): Same.\n+\t* graph.c (draw_cfg_nodes_no_loops): Same.\n+\t(draw_cfg_nodes_for_loop): Same.\n+\t* hard-reg-set.h (hard_reg_set_iter_next): Same.\n+\t* hsa-brig.c: Same.\n+\t* hsa-common.h (hsa_internal_fn_hasher::equal): Same.\n+\t* hsa-dump.c (dump_hsa_cfun): Same.\n+\t* hsa-gen.c (gen_function_def_parameters): Same.\n+\t* hsa-regalloc.c (dump_hsa_cfun_regalloc): Same.\n+\t* input.c (dump_line_table_statistics): Same.\n+\t(test_lexer): Same.\n+\t* input.h: Same.\n+\t* internal-fn.c (get_multi_vector_move): Same.\n+\t(expand_load_lanes_optab_fn): Same.\n+\t(expand_GOMP_SIMT_ENTER_ALLOC): Same.\n+\t(expand_GOMP_SIMT_EXIT): Same.\n+\t(expand_GOMP_SIMT_LAST_LANE): Same.\n+\t(expand_GOMP_SIMT_ORDERED_PRED): Same.\n+\t(expand_GOMP_SIMT_VOTE_ANY): Same.\n+\t(expand_GOMP_SIMT_XCHG_BFLY): Same.\n+\t(expand_GOMP_SIMT_XCHG_IDX): Same.\n+\t(expand_addsub_overflow): Same.\n+\t(expand_neg_overflow): Same.\n+\t(expand_mul_overflow): Same.\n+\t(expand_call_mem_ref): Same.\n+\t(expand_mask_load_optab_fn): Same.\n+\t(expand_scatter_store_optab_fn): Same.\n+\t(expand_gather_load_optab_fn): Same.\n+\t* ipa-cp.c (ipa_get_parm_lattices): Same.\n+\t(print_all_lattices): Same.\n+\t(ignore_edge_p): Same.\n+\t(build_toporder_info): Same.\n+\t(free_toporder_info): Same.\n+\t(push_node_to_stack): Same.\n+\t(ipcp_lattice<valtype>::set_contains_variable): Same.\n+\t(set_agg_lats_to_bottom): Same.\n+\t(ipcp_bits_lattice::meet_with): Same.\n+\t(set_single_call_flag): Same.\n+\t(initialize_node_lattices): Same.\n+\t(ipa_get_jf_ancestor_result): Same.\n+\t(ipcp_verify_propagated_values): Same.\n+\t(propagate_scalar_across_jump_function): Same.\n+\t(propagate_context_across_jump_function): Same.\n+\t(propagate_bits_across_jump_function): Same.\n+\t(ipa_vr_operation_and_type_effects): Same.\n+\t(propagate_vr_across_jump_function): Same.\n+\t(set_check_aggs_by_ref): Same.\n+\t(set_chain_of_aglats_contains_variable): Same.\n+\t(merge_aggregate_lattices): Same.\n+\t(agg_pass_through_permissible_p): Same.\n+\t(propagate_aggs_across_jump_function): Same.\n+\t(call_passes_through_thunk_p): Same.\n+\t(propagate_constants_across_call): Same.\n+\t(devirtualization_time_bonus): Same.\n+\t(good_cloning_opportunity_p): Same.\n+\t(context_independent_aggregate_values): Same.\n+\t(gather_context_independent_values): Same.\n+\t(perform_estimation_of_a_value): Same.\n+\t(estimate_local_effects): Same.\n+\t(value_topo_info<valtype>::add_val): Same.\n+\t(add_all_node_vals_to_toposort): Same.\n+\t(value_topo_info<valtype>::propagate_effects): Same.\n+\t(ipcp_propagate_stage): Same.\n+\t(ipcp_discover_new_direct_edges): Same.\n+\t(same_node_or_its_all_contexts_clone_p): Same.\n+\t(cgraph_edge_brings_value_p): Same.\n+\t(gather_edges_for_value): Same.\n+\t(create_specialized_node): Same.\n+\t(find_more_scalar_values_for_callers_subset): Same.\n+\t(find_more_contexts_for_caller_subset): Same.\n+\t(copy_plats_to_inter): Same.\n+\t(intersect_aggregates_with_edge): Same.\n+\t(find_aggregate_values_for_callers_subset): Same.\n+\t(cgraph_edge_brings_all_agg_vals_for_node): Same.\n+\t(decide_about_value): Same.\n+\t(decide_whether_version_node): Same.\n+\t(spread_undeadness): Same.\n+\t(identify_dead_nodes): Same.\n+\t(ipcp_store_vr_results): Same.\n+\t* ipa-devirt.c (final_warning_record::grow_type_warnings): Same.\n+\t* ipa-fnsummary.c (ipa_fn_summary::account_size_time): Same.\n+\t(redirect_to_unreachable): Same.\n+\t(edge_set_predicate): Same.\n+\t(evaluate_conditions_for_known_args): Same.\n+\t(evaluate_properties_for_edge): Same.\n+\t(ipa_fn_summary_t::duplicate): Same.\n+\t(ipa_call_summary_t::duplicate): Same.\n+\t(dump_ipa_call_summary): Same.\n+\t(ipa_dump_fn_summary): Same.\n+\t(eliminated_by_inlining_prob): Same.\n+\t(set_cond_stmt_execution_predicate): Same.\n+\t(set_switch_stmt_execution_predicate): Same.\n+\t(compute_bb_predicates): Same.\n+\t(will_be_nonconstant_expr_predicate): Same.\n+\t(phi_result_unknown_predicate): Same.\n+\t(analyze_function_body): Same.\n+\t(compute_fn_summary): Same.\n+\t(estimate_edge_devirt_benefit): Same.\n+\t(estimate_edge_size_and_time): Same.\n+\t(estimate_calls_size_and_time): Same.\n+\t(estimate_node_size_and_time): Same.\n+\t(remap_edge_change_prob): Same.\n+\t(remap_edge_summaries): Same.\n+\t(ipa_merge_fn_summary_after_inlining): Same.\n+\t(ipa_fn_summary_generate): Same.\n+\t(inline_read_section): Same.\n+\t(ipa_fn_summary_read): Same.\n+\t(ipa_fn_summary_write): Same.\n+\t* ipa-fnsummary.h: Same.\n+\t* ipa-hsa.c (ipa_hsa_read_section): Same.\n+\t* ipa-icf-gimple.c (func_checker::compare_loops): Same.\n+\t* ipa-icf.c (sem_function::param_used_p): Same.\n+\t* ipa-inline-analysis.c (do_estimate_edge_time): Same.\n+\t* ipa-inline.c (edge_badness): Same.\n+\t(inline_small_functions): Same.\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::stream_out): Same.\n+\t* ipa-predicate.c (predicate::remap_after_duplication): Same.\n+\t(predicate::remap_after_inlining): Same.\n+\t(predicate::stream_out): Same.\n+\t* ipa-predicate.h: Same.\n+\t* ipa-profile.c (ipa_profile_read_summary): Same.\n+\t* ipa-prop.c (ipa_get_param_decl_index_1): Same.\n+\t(count_formal_params): Same.\n+\t(ipa_dump_param): Same.\n+\t(ipa_alloc_node_params): Same.\n+\t(ipa_print_node_jump_functions_for_edge): Same.\n+\t(ipa_print_node_jump_functions): Same.\n+\t(ipa_load_from_parm_agg): Same.\n+\t(get_ancestor_addr_info): Same.\n+\t(ipa_compute_jump_functions_for_edge): Same.\n+\t(ipa_analyze_virtual_call_uses): Same.\n+\t(ipa_analyze_stmt_uses): Same.\n+\t(ipa_analyze_params_uses_in_bb): Same.\n+\t(update_jump_functions_after_inlining): Same.\n+\t(try_decrement_rdesc_refcount): Same.\n+\t(ipa_impossible_devirt_target): Same.\n+\t(update_indirect_edges_after_inlining): Same.\n+\t(combine_controlled_uses_counters): Same.\n+\t(ipa_edge_args_sum_t::duplicate): Same.\n+\t(ipa_write_jump_function): Same.\n+\t(ipa_write_indirect_edge_info): Same.\n+\t(ipa_write_node_info): Same.\n+\t(ipa_read_edge_info): Same.\n+\t(ipa_prop_read_section): Same.\n+\t(read_replacements_section): Same.\n+\t* ipa-prop.h (ipa_get_param_count): Same.\n+\t(ipa_get_param): Same.\n+\t(ipa_get_type): Same.\n+\t(ipa_get_param_move_cost): Same.\n+\t(ipa_set_param_used): Same.\n+\t(ipa_get_controlled_uses): Same.\n+\t(ipa_set_controlled_uses): Same.\n+\t(ipa_get_cs_argument_count): Same.\n+\t* ipa-pure-const.c (analyze_function): Same.\n+\t(pure_const_read_summary): Same.\n+\t* ipa-ref.h: Same.\n+\t* ipa-reference.c (ipa_reference_read_optimization_summary): Same.\n+\t* ipa-split.c (test_nonssa_use): Same.\n+\t(dump_split_point): Same.\n+\t(dominated_by_forbidden): Same.\n+\t(split_part_set_ssa_name_p): Same.\n+\t(find_split_points): Same.\n+\t* ira-build.c (finish_loop_tree_nodes): Same.\n+\t(low_pressure_loop_node_p): Same.\n+\t* ira-color.c (ira_reuse_stack_slot): Same.\n+\t* ira-int.h: Same.\n+\t* ira.c (setup_reg_equiv): Same.\n+\t(print_insn_chain): Same.\n+\t(ira): Same.\n+\t* loop-doloop.c (doloop_condition_get): Same.\n+\t(add_test): Same.\n+\t(record_reg_sets): Same.\n+\t(doloop_optimize): Same.\n+\t* loop-init.c (loop_optimizer_init): Same.\n+\t(fix_loop_structure): Same.\n+\t* loop-invariant.c (merge_identical_invariants): Same.\n+\t(compute_always_reached): Same.\n+\t(find_exits): Same.\n+\t(may_assign_reg_p): Same.\n+\t(find_invariants_bb): Same.\n+\t(find_invariants_body): Same.\n+\t(replace_uses): Same.\n+\t(can_move_invariant_reg): Same.\n+\t(free_inv_motion_data): Same.\n+\t(move_single_loop_invariants): Same.\n+\t(change_pressure): Same.\n+\t(mark_ref_regs): Same.\n+\t(calculate_loop_reg_pressure): Same.\n+\t* loop-iv.c (biv_entry_hasher::equal): Same.\n+\t(iv_extend_to_rtx_code): Same.\n+\t(check_iv_ref_table_size): Same.\n+\t(clear_iv_info): Same.\n+\t(latch_dominating_def): Same.\n+\t(iv_get_reaching_def): Same.\n+\t(iv_constant): Same.\n+\t(iv_subreg): Same.\n+\t(iv_extend): Same.\n+\t(iv_neg): Same.\n+\t(iv_add): Same.\n+\t(iv_mult): Same.\n+\t(get_biv_step): Same.\n+\t(record_iv): Same.\n+\t(analyzed_for_bivness_p): Same.\n+\t(record_biv): Same.\n+\t(iv_analyze_biv): Same.\n+\t(iv_analyze_expr): Same.\n+\t(iv_analyze_def): Same.\n+\t(iv_analyze_op): Same.\n+\t(iv_analyze): Same.\n+\t(iv_analyze_result): Same.\n+\t(biv_p): Same.\n+\t(eliminate_implied_conditions): Same.\n+\t(simplify_using_initial_values): Same.\n+\t(shorten_into_mode): Same.\n+\t(canonicalize_iv_subregs): Same.\n+\t(determine_max_iter): Same.\n+\t(check_simple_exit): Same.\n+\t(find_simple_exit): Same.\n+\t(get_simple_loop_desc): Same.\n+\t* loop-unroll.c (report_unroll): Same.\n+\t(decide_unrolling): Same.\n+\t(unroll_loops): Same.\n+\t(loop_exit_at_end_p): Same.\n+\t(decide_unroll_constant_iterations): Same.\n+\t(unroll_loop_constant_iterations): Same.\n+\t(compare_and_jump_seq): Same.\n+\t(unroll_loop_runtime_iterations): Same.\n+\t(decide_unroll_stupid): Same.\n+\t(unroll_loop_stupid): Same.\n+\t(referenced_in_one_insn_in_loop_p): Same.\n+\t(reset_debug_uses_in_loop): Same.\n+\t(analyze_iv_to_split_insn): Same.\n+\t* lra-eliminations.c (lra_debug_elim_table): Same.\n+\t(setup_can_eliminate): Same.\n+\t(form_sum): Same.\n+\t(lra_get_elimination_hard_regno): Same.\n+\t(lra_eliminate_regs_1): Same.\n+\t(eliminate_regs_in_insn): Same.\n+\t(update_reg_eliminate): Same.\n+\t(init_elimination): Same.\n+\t(lra_eliminate): Same.\n+\t* lra-int.h: Same.\n+\t* lra-lives.c (initiate_live_solver): Same.\n+\t* lra-remat.c (create_remat_bb_data): Same.\n+\t* lra-spills.c (lra_spill): Same.\n+\t* lra.c (lra_set_insn_recog_data): Same.\n+\t(lra_set_used_insn_alternative_by_uid): Same.\n+\t(init_reg_info): Same.\n+\t(expand_reg_info): Same.\n+\t* lto-cgraph.c (output_symtab): Same.\n+\t(read_identifier): Same.\n+\t(get_alias_symbol): Same.\n+\t(input_node): Same.\n+\t(input_varpool_node): Same.\n+\t(input_ref): Same.\n+\t(input_edge): Same.\n+\t(input_cgraph_1): Same.\n+\t(input_refs): Same.\n+\t(input_symtab): Same.\n+\t(input_offload_tables): Same.\n+\t(output_cgraph_opt_summary): Same.\n+\t(input_edge_opt_summary): Same.\n+\t(input_cgraph_opt_section): Same.\n+\t* lto-section-in.c (lto_free_raw_section_data): Same.\n+\t(lto_create_simple_input_block): Same.\n+\t(lto_free_function_in_decl_state_for_node): Same.\n+\t* lto-streamer-in.c (lto_tag_check_set): Same.\n+\t(lto_location_cache::revert_location_cache): Same.\n+\t(lto_location_cache::input_location): Same.\n+\t(lto_input_location): Same.\n+\t(stream_input_location_now): Same.\n+\t(lto_input_tree_ref): Same.\n+\t(lto_input_eh_catch_list): Same.\n+\t(input_eh_region): Same.\n+\t(lto_init_eh): Same.\n+\t(make_new_block): Same.\n+\t(input_cfg): Same.\n+\t(fixup_call_stmt_edges): Same.\n+\t(input_struct_function_base): Same.\n+\t(input_function): Same.\n+\t(lto_read_body_or_constructor): Same.\n+\t(lto_read_tree_1): Same.\n+\t(lto_read_tree): Same.\n+\t(lto_input_scc): Same.\n+\t(lto_input_tree_1): Same.\n+\t(lto_input_toplevel_asms): Same.\n+\t(lto_input_mode_table): Same.\n+\t(lto_reader_init): Same.\n+\t(lto_data_in_create): Same.\n+\t* lto-streamer-out.c (output_cfg): Same.\n+\t* lto-streamer.h: Same.\n+\t* modulo-sched.c (duplicate_insns_of_cycles): Same.\n+\t(generate_prolog_epilog): Same.\n+\t(mark_loop_unsched): Same.\n+\t(dump_insn_location): Same.\n+\t(loop_canon_p): Same.\n+\t(sms_schedule): Same.\n+\t* omp-expand.c (expand_omp_for_ordered_loops): Same.\n+\t(expand_omp_for_generic): Same.\n+\t(expand_omp_for_static_nochunk): Same.\n+\t(expand_omp_for_static_chunk): Same.\n+\t(expand_omp_simd): Same.\n+\t(expand_omp_taskloop_for_inner): Same.\n+\t(expand_oacc_for): Same.\n+\t(expand_omp_atomic_pipeline): Same.\n+\t(mark_loops_in_oacc_kernels_region): Same.\n+\t* omp-offload.c (oacc_xform_loop): Same.\n+\t* omp-simd-clone.c (simd_clone_adjust): Same.\n+\t* optabs-query.c (get_traditional_extraction_insn): Same.\n+\t* optabs.c (expand_vector_broadcast): Same.\n+\t(expand_binop_directly): Same.\n+\t(expand_twoval_unop): Same.\n+\t(expand_twoval_binop): Same.\n+\t(expand_unop_direct): Same.\n+\t(emit_indirect_jump): Same.\n+\t(emit_conditional_move): Same.\n+\t(emit_conditional_neg_or_complement): Same.\n+\t(emit_conditional_add): Same.\n+\t(vector_compare_rtx): Same.\n+\t(expand_vec_perm_1): Same.\n+\t(expand_vec_perm_const): Same.\n+\t(expand_vec_cond_expr): Same.\n+\t(expand_vec_series_expr): Same.\n+\t(maybe_emit_atomic_exchange): Same.\n+\t(maybe_emit_sync_lock_test_and_set): Same.\n+\t(expand_atomic_compare_and_swap): Same.\n+\t(expand_atomic_load): Same.\n+\t(expand_atomic_store): Same.\n+\t(maybe_emit_op): Same.\n+\t(valid_multiword_target_p): Same.\n+\t(create_integer_operand): Same.\n+\t(maybe_legitimize_operand_same_code): Same.\n+\t(maybe_legitimize_operand): Same.\n+\t(create_convert_operand_from_type): Same.\n+\t(can_reuse_operands_p): Same.\n+\t(maybe_legitimize_operands): Same.\n+\t(maybe_gen_insn): Same.\n+\t(maybe_expand_insn): Same.\n+\t(maybe_expand_jump_insn): Same.\n+\t(expand_insn): Same.\n+\t* optabs.h (create_expand_operand): Same.\n+\t(create_fixed_operand): Same.\n+\t(create_output_operand): Same.\n+\t(create_input_operand): Same.\n+\t(create_convert_operand_to): Same.\n+\t(create_convert_operand_from): Same.\n+\t* optinfo.h: Same.\n+\t* poly-int.h: Same.\n+\t* predict.c (optimize_insn_for_speed_p): Same.\n+\t(optimize_loop_for_size_p): Same.\n+\t(optimize_loop_for_speed_p): Same.\n+\t(optimize_loop_nest_for_speed_p): Same.\n+\t(get_base_value): Same.\n+\t(predicted_by_loop_heuristics_p): Same.\n+\t(predict_extra_loop_exits): Same.\n+\t(predict_loops): Same.\n+\t(predict_paths_for_bb): Same.\n+\t(predict_paths_leading_to): Same.\n+\t(propagate_freq): Same.\n+\t(pass_profile::execute): Same.\n+\t* predict.h: Same.\n+\t* profile-count.c (profile_count::differs_from_p): Same.\n+\t(profile_probability::differs_lot_from_p): Same.\n+\t* profile-count.h: Same.\n+\t* profile.c (branch_prob): Same.\n+\t* regrename.c (free_chain_data): Same.\n+\t(mark_conflict): Same.\n+\t(create_new_chain): Same.\n+\t(merge_overlapping_regs): Same.\n+\t(init_rename_info): Same.\n+\t(merge_chains): Same.\n+\t(regrename_analyze): Same.\n+\t(regrename_do_replace): Same.\n+\t(scan_rtx_reg): Same.\n+\t(record_out_operands): Same.\n+\t(build_def_use): Same.\n+\t* regrename.h: Same.\n+\t* reload.h: Same.\n+\t* reload1.c (init_reload): Same.\n+\t(maybe_fix_stack_asms): Same.\n+\t(copy_reloads): Same.\n+\t(count_pseudo): Same.\n+\t(count_spilled_pseudo): Same.\n+\t(find_reg): Same.\n+\t(find_reload_regs): Same.\n+\t(select_reload_regs): Same.\n+\t(spill_hard_reg): Same.\n+\t(fixup_eh_region_note): Same.\n+\t(set_reload_reg): Same.\n+\t(allocate_reload_reg): Same.\n+\t(compute_reload_subreg_offset): Same.\n+\t(reload_adjust_reg_for_icode): Same.\n+\t(emit_input_reload_insns): Same.\n+\t(emit_output_reload_insns): Same.\n+\t(do_input_reload): Same.\n+\t(inherit_piecemeal_p): Same.\n+\t* rtl.h: Same.\n+\t* sanopt.c (maybe_get_dominating_check): Same.\n+\t(maybe_optimize_ubsan_ptr_ifn): Same.\n+\t(can_remove_asan_check): Same.\n+\t(maybe_optimize_asan_check_ifn): Same.\n+\t(sanopt_optimize_walker): Same.\n+\t* sched-deps.c (add_dependence_list): Same.\n+\t(chain_to_prev_insn): Same.\n+\t(add_insn_mem_dependence): Same.\n+\t(create_insn_reg_set): Same.\n+\t(maybe_extend_reg_info_p): Same.\n+\t(sched_analyze_reg): Same.\n+\t(sched_analyze_1): Same.\n+\t(get_implicit_reg_pending_clobbers): Same.\n+\t(chain_to_prev_insn_p): Same.\n+\t(deps_analyze_insn): Same.\n+\t(deps_start_bb): Same.\n+\t(sched_free_deps): Same.\n+\t(init_deps): Same.\n+\t(init_deps_reg_last): Same.\n+\t(free_deps): Same.\n+\t* sched-ebb.c: Same.\n+\t* sched-int.h: Same.\n+\t* sched-rgn.c (add_branch_dependences): Same.\n+\t(concat_insn_mem_list): Same.\n+\t(deps_join): Same.\n+\t(sched_rgn_compute_dependencies): Same.\n+\t* sel-sched-ir.c (reset_target_context): Same.\n+\t(copy_deps_context): Same.\n+\t(init_id_from_df): Same.\n+\t(has_dependence_p): Same.\n+\t(change_loops_latches): Same.\n+\t(bb_top_order_comparator): Same.\n+\t(make_region_from_loop_preheader): Same.\n+\t(sel_init_pipelining): Same.\n+\t(get_loop_nest_for_rgn): Same.\n+\t(make_regions_from_the_rest): Same.\n+\t(sel_is_loop_preheader_p): Same.\n+\t* sel-sched-ir.h (inner_loop_header_p): Same.\n+\t(get_all_loop_exits): Same.\n+\t* selftest.h: Same.\n+\t* sese.c (sese_build_liveouts): Same.\n+\t(sese_insert_phis_for_liveouts): Same.\n+\t* sese.h (defined_in_sese_p): Same.\n+\t* sreal.c (sreal::stream_out): Same.\n+\t* sreal.h: Same.\n+\t* streamer-hooks.h: Same.\n+\t* target-globals.c (save_target_globals): Same.\n+\t* target-globals.h: Same.\n+\t* target.def: Same.\n+\t* target.h: Same.\n+\t* targhooks.c (default_has_ifunc_p): Same.\n+\t(default_empty_mask_is_expensive): Same.\n+\t(default_init_cost): Same.\n+\t* targhooks.h: Same.\n+\t* toplev.c: Same.\n+\t* tree-affine.c (aff_combination_mult): Same.\n+\t(aff_combination_expand): Same.\n+\t(aff_combination_constant_multiple_p): Same.\n+\t* tree-affine.h: Same.\n+\t* tree-cfg.c (build_gimple_cfg): Same.\n+\t(replace_loop_annotate_in_block): Same.\n+\t(replace_uses_by): Same.\n+\t(remove_bb): Same.\n+\t(dump_cfg_stats): Same.\n+\t(gimple_duplicate_sese_region): Same.\n+\t(gimple_duplicate_sese_tail): Same.\n+\t(move_block_to_fn): Same.\n+\t(replace_block_vars_by_duplicates): Same.\n+\t(move_sese_region_to_fn): Same.\n+\t(print_loops_bb): Same.\n+\t(print_loop): Same.\n+\t(print_loops): Same.\n+\t(debug): Same.\n+\t(debug_loops): Same.\n+\t* tree-cfg.h: Same.\n+\t* tree-chrec.c (chrec_fold_plus_poly_poly): Same.\n+\t(chrec_fold_multiply_poly_poly): Same.\n+\t(chrec_evaluate): Same.\n+\t(chrec_component_in_loop_num): Same.\n+\t(reset_evolution_in_loop): Same.\n+\t(is_multivariate_chrec): Same.\n+\t(chrec_contains_symbols): Same.\n+\t(nb_vars_in_chrec): Same.\n+\t(chrec_convert_1): Same.\n+\t(chrec_convert_aggressive): Same.\n+\t* tree-chrec.h: Same.\n+\t* tree-core.h: Same.\n+\t* tree-data-ref.c (dump_data_dependence_relation): Same.\n+\t(canonicalize_base_object_address): Same.\n+\t(data_ref_compare_tree): Same.\n+\t(prune_runtime_alias_test_list): Same.\n+\t(get_segment_min_max): Same.\n+\t(create_intersect_range_checks): Same.\n+\t(conflict_fn_no_dependence): Same.\n+\t(object_address_invariant_in_loop_p): Same.\n+\t(analyze_ziv_subscript): Same.\n+\t(analyze_siv_subscript_cst_affine): Same.\n+\t(analyze_miv_subscript): Same.\n+\t(analyze_overlapping_iterations): Same.\n+\t(build_classic_dist_vector_1): Same.\n+\t(add_other_self_distances): Same.\n+\t(same_access_functions): Same.\n+\t(build_classic_dir_vector): Same.\n+\t(subscript_dependence_tester_1): Same.\n+\t(subscript_dependence_tester): Same.\n+\t(access_functions_are_affine_or_constant_p): Same.\n+\t(get_references_in_stmt): Same.\n+\t(loop_nest_has_data_refs): Same.\n+\t(graphite_find_data_references_in_stmt): Same.\n+\t(find_data_references_in_bb): Same.\n+\t(get_base_for_alignment): Same.\n+\t(find_loop_nest_1): Same.\n+\t(find_loop_nest): Same.\n+\t* tree-data-ref.h (dr_alignment): Same.\n+\t(ddr_dependence_level): Same.\n+\t* tree-if-conv.c (fold_build_cond_expr): Same.\n+\t(add_to_predicate_list): Same.\n+\t(add_to_dst_predicate_list): Same.\n+\t(phi_convertible_by_degenerating_args): Same.\n+\t(idx_within_array_bound): Same.\n+\t(all_preds_critical_p): Same.\n+\t(pred_blocks_visited_p): Same.\n+\t(predicate_bbs): Same.\n+\t(build_region): Same.\n+\t(if_convertible_loop_p_1): Same.\n+\t(is_cond_scalar_reduction): Same.\n+\t(predicate_scalar_phi): Same.\n+\t(remove_conditions_and_labels): Same.\n+\t(combine_blocks): Same.\n+\t(version_loop_for_if_conversion): Same.\n+\t(versionable_outer_loop_p): Same.\n+\t(ifcvt_local_dce): Same.\n+\t(tree_if_conversion): Same.\n+\t(pass_if_conversion::gate): Same.\n+\t* tree-if-conv.h: Same.\n+\t* tree-inline.c (maybe_move_debug_stmts_to_successors): Same.\n+\t* tree-loop-distribution.c (bb_top_order_cmp): Same.\n+\t(free_rdg): Same.\n+\t(stmt_has_scalar_dependences_outside_loop): Same.\n+\t(copy_loop_before): Same.\n+\t(create_bb_after_loop): Same.\n+\t(const_with_all_bytes_same): Same.\n+\t(generate_memset_builtin): Same.\n+\t(generate_memcpy_builtin): Same.\n+\t(destroy_loop): Same.\n+\t(build_rdg_partition_for_vertex): Same.\n+\t(compute_access_range): Same.\n+\t(data_ref_segment_size): Same.\n+\t(latch_dominated_by_data_ref): Same.\n+\t(compute_alias_check_pairs): Same.\n+\t(fuse_memset_builtins): Same.\n+\t(finalize_partitions): Same.\n+\t(find_seed_stmts_for_distribution): Same.\n+\t(prepare_perfect_loop_nest): Same.\n+\t* tree-parloops.c (lambda_transform_legal_p): Same.\n+\t(loop_parallel_p): Same.\n+\t(reduc_stmt_res): Same.\n+\t(add_field_for_name): Same.\n+\t(create_call_for_reduction_1): Same.\n+\t(replace_uses_in_bb_by): Same.\n+\t(transform_to_exit_first_loop_alt): Same.\n+\t(try_transform_to_exit_first_loop_alt): Same.\n+\t(transform_to_exit_first_loop): Same.\n+\t(num_phis): Same.\n+\t(gen_parallel_loop): Same.\n+\t(gather_scalar_reductions): Same.\n+\t(get_omp_data_i_param): Same.\n+\t(try_create_reduction_list): Same.\n+\t(oacc_entry_exit_single_gang): Same.\n+\t(parallelize_loops): Same.\n+\t* tree-pass.h: Same.\n+\t* tree-predcom.c (determine_offset): Same.\n+\t(last_always_executed_block): Same.\n+\t(split_data_refs_to_components): Same.\n+\t(suitable_component_p): Same.\n+\t(valid_initializer_p): Same.\n+\t(find_looparound_phi): Same.\n+\t(insert_looparound_copy): Same.\n+\t(add_looparound_copies): Same.\n+\t(determine_roots_comp): Same.\n+\t(predcom_tmp_var): Same.\n+\t(initialize_root_vars): Same.\n+\t(initialize_root_vars_store_elim_1): Same.\n+\t(initialize_root_vars_store_elim_2): Same.\n+\t(finalize_eliminated_stores): Same.\n+\t(initialize_root_vars_lm): Same.\n+\t(remove_stmt): Same.\n+\t(determine_unroll_factor): Same.\n+\t(execute_pred_commoning_cbck): Same.\n+\t(base_names_in_chain_on): Same.\n+\t(combine_chains): Same.\n+\t(pcom_stmt_dominates_stmt_p): Same.\n+\t(try_combine_chains): Same.\n+\t(prepare_initializers_chain_store_elim): Same.\n+\t(prepare_initializers_chain): Same.\n+\t(prepare_initializers): Same.\n+\t(prepare_finalizers_chain): Same.\n+\t(prepare_finalizers): Same.\n+\t(insert_init_seqs): Same.\n+\t* tree-scalar-evolution.c (loop_phi_node_p): Same.\n+\t(compute_overall_effect_of_inner_loop): Same.\n+\t(add_to_evolution_1): Same.\n+\t(add_to_evolution): Same.\n+\t(follow_ssa_edge_binary): Same.\n+\t(follow_ssa_edge_expr): Same.\n+\t(backedge_phi_arg_p): Same.\n+\t(follow_ssa_edge_in_condition_phi_branch): Same.\n+\t(follow_ssa_edge_in_condition_phi): Same.\n+\t(follow_ssa_edge_inner_loop_phi): Same.\n+\t(follow_ssa_edge): Same.\n+\t(analyze_evolution_in_loop): Same.\n+\t(analyze_initial_condition): Same.\n+\t(interpret_loop_phi): Same.\n+\t(interpret_condition_phi): Same.\n+\t(interpret_rhs_expr): Same.\n+\t(interpret_expr): Same.\n+\t(interpret_gimple_assign): Same.\n+\t(analyze_scalar_evolution_1): Same.\n+\t(analyze_scalar_evolution): Same.\n+\t(analyze_scalar_evolution_for_address_of): Same.\n+\t(get_instantiated_value_entry): Same.\n+\t(loop_closed_phi_def): Same.\n+\t(instantiate_scev_name): Same.\n+\t(instantiate_scev_poly): Same.\n+\t(instantiate_scev_binary): Same.\n+\t(instantiate_scev_convert): Same.\n+\t(instantiate_scev_not): Same.\n+\t(instantiate_scev_r): Same.\n+\t(instantiate_scev): Same.\n+\t(resolve_mixers): Same.\n+\t(initialize_scalar_evolutions_analyzer): Same.\n+\t(scev_reset_htab): Same.\n+\t(scev_reset): Same.\n+\t(derive_simple_iv_with_niters): Same.\n+\t(simple_iv_with_niters): Same.\n+\t(expression_expensive_p): Same.\n+\t(final_value_replacement_loop): Same.\n+\t* tree-scalar-evolution.h (block_before_loop): Same.\n+\t* tree-ssa-address.h: Same.\n+\t* tree-ssa-dce.c (find_obviously_necessary_stmts): Same.\n+\t* tree-ssa-dom.c (edge_info::record_simple_equiv): Same.\n+\t(record_edge_info): Same.\n+\t* tree-ssa-live.c (var_map_base_fini): Same.\n+\t(remove_unused_locals): Same.\n+\t* tree-ssa-live.h: Same.\n+\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Same.\n+\t(pass_ch_vect::execute): Same.\n+\t(pass_ch::process_loop_p): Same.\n+\t* tree-ssa-loop-im.c (mem_ref_hasher::hash): Same.\n+\t(movement_possibility): Same.\n+\t(outermost_invariant_loop): Same.\n+\t(stmt_cost): Same.\n+\t(determine_max_movement): Same.\n+\t(invariantness_dom_walker::before_dom_children): Same.\n+\t(move_computations): Same.\n+\t(may_move_till): Same.\n+\t(force_move_till_op): Same.\n+\t(force_move_till): Same.\n+\t(memref_free): Same.\n+\t(record_mem_ref_loc): Same.\n+\t(set_ref_stored_in_loop): Same.\n+\t(mark_ref_stored): Same.\n+\t(sort_bbs_in_loop_postorder_cmp): Same.\n+\t(sort_locs_in_loop_postorder_cmp): Same.\n+\t(analyze_memory_references): Same.\n+\t(mem_refs_may_alias_p): Same.\n+\t(find_ref_loc_in_loop_cmp): Same.\n+\t(rewrite_mem_ref_loc::operator): Same.\n+\t(first_mem_ref_loc_1::operator): Same.\n+\t(sm_set_flag_if_changed::operator): Same.\n+\t(execute_sm_if_changed_flag_set): Same.\n+\t(execute_sm): Same.\n+\t(hoist_memory_references): Same.\n+\t(ref_always_accessed::operator): Same.\n+\t(refs_independent_p): Same.\n+\t(record_dep_loop): Same.\n+\t(ref_indep_loop_p_1): Same.\n+\t(ref_indep_loop_p): Same.\n+\t(can_sm_ref_p): Same.\n+\t(find_refs_for_sm): Same.\n+\t(loop_suitable_for_sm): Same.\n+\t(store_motion_loop): Same.\n+\t(store_motion): Same.\n+\t(fill_always_executed_in): Same.\n+\t* tree-ssa-loop-ivcanon.c (constant_after_peeling): Same.\n+\t(estimated_unrolled_size): Same.\n+\t(loop_edge_to_cancel): Same.\n+\t(remove_exits_and_undefined_stmts): Same.\n+\t(remove_redundant_iv_tests): Same.\n+\t(unloop_loops): Same.\n+\t(estimated_peeled_sequence_size): Same.\n+\t(try_peel_loop): Same.\n+\t(canonicalize_loop_induction_variables): Same.\n+\t(canonicalize_induction_variables): Same.\n+\t* tree-ssa-loop-ivopts.c (iv_inv_expr_hasher::equal): Same.\n+\t(name_info): Same.\n+\t(stmt_after_inc_pos): Same.\n+\t(contains_abnormal_ssa_name_p): Same.\n+\t(niter_for_exit): Same.\n+\t(find_bivs): Same.\n+\t(mark_bivs): Same.\n+\t(find_givs_in_bb): Same.\n+\t(find_induction_variables): Same.\n+\t(find_interesting_uses_cond): Same.\n+\t(outermost_invariant_loop_for_expr): Same.\n+\t(idx_find_step): Same.\n+\t(add_candidate_1): Same.\n+\t(add_iv_candidate_derived_from_uses): Same.\n+\t(alloc_use_cost_map): Same.\n+\t(prepare_decl_rtl): Same.\n+\t(generic_predict_doloop_p): Same.\n+\t(computation_cost): Same.\n+\t(determine_common_wider_type): Same.\n+\t(get_computation_aff_1): Same.\n+\t(get_use_type): Same.\n+\t(determine_group_iv_cost_address): Same.\n+\t(iv_period): Same.\n+\t(difference_cannot_overflow_p): Same.\n+\t(may_eliminate_iv): Same.\n+\t(determine_set_costs): Same.\n+\t(cheaper_cost_pair): Same.\n+\t(compare_cost_pair): Same.\n+\t(iv_ca_cand_for_group): Same.\n+\t(iv_ca_recount_cost): Same.\n+\t(iv_ca_set_remove_invs): Same.\n+\t(iv_ca_set_no_cp): Same.\n+\t(iv_ca_set_add_invs): Same.\n+\t(iv_ca_set_cp): Same.\n+\t(iv_ca_add_group): Same.\n+\t(iv_ca_cost): Same.\n+\t(iv_ca_compare_deps): Same.\n+\t(iv_ca_delta_reverse): Same.\n+\t(iv_ca_delta_commit): Same.\n+\t(iv_ca_cand_used_p): Same.\n+\t(iv_ca_delta_free): Same.\n+\t(iv_ca_new): Same.\n+\t(iv_ca_free): Same.\n+\t(iv_ca_dump): Same.\n+\t(iv_ca_extend): Same.\n+\t(iv_ca_narrow): Same.\n+\t(iv_ca_prune): Same.\n+\t(cheaper_cost_with_cand): Same.\n+\t(iv_ca_replace): Same.\n+\t(try_add_cand_for): Same.\n+\t(get_initial_solution): Same.\n+\t(try_improve_iv_set): Same.\n+\t(find_optimal_iv_set_1): Same.\n+\t(create_new_iv): Same.\n+\t(rewrite_use_compare): Same.\n+\t(remove_unused_ivs): Same.\n+\t(determine_scaling_factor): Same.\n+\t* tree-ssa-loop-ivopts.h: Same.\n+\t* tree-ssa-loop-manip.c (create_iv): Same.\n+\t(compute_live_loop_exits): Same.\n+\t(add_exit_phi): Same.\n+\t(add_exit_phis): Same.\n+\t(find_uses_to_rename_use): Same.\n+\t(find_uses_to_rename_def): Same.\n+\t(find_uses_to_rename_in_loop): Same.\n+\t(rewrite_into_loop_closed_ssa): Same.\n+\t(check_loop_closed_ssa_bb): Same.\n+\t(split_loop_exit_edge): Same.\n+\t(ip_end_pos): Same.\n+\t(ip_normal_pos): Same.\n+\t(copy_phi_node_args): Same.\n+\t(gimple_duplicate_loop_to_header_edge): Same.\n+\t(can_unroll_loop_p): Same.\n+\t(determine_exit_conditions): Same.\n+\t(scale_dominated_blocks_in_loop): Same.\n+\t(niter_for_unrolled_loop): Same.\n+\t(tree_transform_and_unroll_loop): Same.\n+\t(rewrite_all_phi_nodes_with_iv): Same.\n+\t* tree-ssa-loop-manip.h: Same.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_ne_max): Same.\n+\t(number_of_iterations_ne): Same.\n+\t(assert_no_overflow_lt): Same.\n+\t(assert_loop_rolls_lt): Same.\n+\t(number_of_iterations_lt): Same.\n+\t(adjust_cond_for_loop_until_wrap): Same.\n+\t(tree_simplify_using_condition): Same.\n+\t(simplify_using_initial_conditions): Same.\n+\t(simplify_using_outer_evolutions): Same.\n+\t(loop_only_exit_p): Same.\n+\t(ssa_defined_by_minus_one_stmt_p): Same.\n+\t(number_of_iterations_popcount): Same.\n+\t(number_of_iterations_exit): Same.\n+\t(find_loop_niter): Same.\n+\t(finite_loop_p): Same.\n+\t(chain_of_csts_start): Same.\n+\t(get_val_for): Same.\n+\t(loop_niter_by_eval): Same.\n+\t(derive_constant_upper_bound_ops): Same.\n+\t(do_warn_aggressive_loop_optimizations): Same.\n+\t(record_estimate): Same.\n+\t(get_cst_init_from_scev): Same.\n+\t(record_nonwrapping_iv): Same.\n+\t(idx_infer_loop_bounds): Same.\n+\t(infer_loop_bounds_from_ref): Same.\n+\t(infer_loop_bounds_from_array): Same.\n+\t(infer_loop_bounds_from_pointer_arith): Same.\n+\t(infer_loop_bounds_from_signedness): Same.\n+\t(bound_index): Same.\n+\t(discover_iteration_bound_by_body_walk): Same.\n+\t(maybe_lower_iteration_bound): Same.\n+\t(estimate_numbers_of_iterations): Same.\n+\t(estimated_loop_iterations): Same.\n+\t(estimated_loop_iterations_int): Same.\n+\t(max_loop_iterations): Same.\n+\t(max_loop_iterations_int): Same.\n+\t(likely_max_loop_iterations): Same.\n+\t(likely_max_loop_iterations_int): Same.\n+\t(estimated_stmt_executions_int): Same.\n+\t(max_stmt_executions): Same.\n+\t(likely_max_stmt_executions): Same.\n+\t(estimated_stmt_executions): Same.\n+\t(stmt_dominates_stmt_p): Same.\n+\t(nowrap_type_p): Same.\n+\t(loop_exits_before_overflow): Same.\n+\t(scev_var_range_cant_overflow): Same.\n+\t(scev_probably_wraps_p): Same.\n+\t(free_numbers_of_iterations_estimates): Same.\n+\t* tree-ssa-loop-niter.h: Same.\n+\t* tree-ssa-loop-prefetch.c (release_mem_refs): Same.\n+\t(idx_analyze_ref): Same.\n+\t(analyze_ref): Same.\n+\t(gather_memory_references_ref): Same.\n+\t(mark_nontemporal_store): Same.\n+\t(emit_mfence_after_loop): Same.\n+\t(may_use_storent_in_loop_p): Same.\n+\t(mark_nontemporal_stores): Same.\n+\t(should_unroll_loop_p): Same.\n+\t(volume_of_dist_vector): Same.\n+\t(add_subscript_strides): Same.\n+\t(self_reuse_distance): Same.\n+\t(insn_to_prefetch_ratio_too_small_p): Same.\n+\t* tree-ssa-loop-split.c (split_at_bb_p): Same.\n+\t(patch_loop_exit): Same.\n+\t(find_or_create_guard_phi): Same.\n+\t(easy_exit_values): Same.\n+\t(connect_loop_phis): Same.\n+\t(connect_loops): Same.\n+\t(compute_new_first_bound): Same.\n+\t(split_loop): Same.\n+\t(tree_ssa_split_loops): Same.\n+\t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops): Same.\n+\t(is_maybe_undefined): Same.\n+\t(tree_may_unswitch_on): Same.\n+\t(simplify_using_entry_checks): Same.\n+\t(tree_unswitch_single_loop): Same.\n+\t(tree_unswitch_loop): Same.\n+\t(tree_unswitch_outer_loop): Same.\n+\t(empty_bb_without_guard_p): Same.\n+\t(used_outside_loop_p): Same.\n+\t(get_vop_from_header): Same.\n+\t(hoist_guard): Same.\n+\t* tree-ssa-loop.c (gate_oacc_kernels): Same.\n+\t(get_lsm_tmp_name): Same.\n+\t* tree-ssa-loop.h: Same.\n+\t* tree-ssa-reassoc.c (add_repeat_to_ops_vec): Same.\n+\t(build_and_add_sum): Same.\n+\t(no_side_effect_bb): Same.\n+\t(get_ops): Same.\n+\t(linearize_expr): Same.\n+\t(should_break_up_subtract): Same.\n+\t(linearize_expr_tree): Same.\n+\t* tree-ssa-scopedtables.c: Same.\n+\t* tree-ssa-scopedtables.h: Same.\n+\t* tree-ssa-structalias.c (condense_visit): Same.\n+\t(label_visit): Same.\n+\t(dump_pred_graph): Same.\n+\t(perform_var_substitution): Same.\n+\t(move_complex_constraints): Same.\n+\t(remove_preds_and_fake_succs): Same.\n+\t* tree-ssa-threadupdate.c (dbds_continue_enumeration_p): Same.\n+\t(determine_bb_domination_status): Same.\n+\t(duplicate_thread_path): Same.\n+\t(thread_through_all_blocks): Same.\n+\t* tree-ssa-threadupdate.h: Same.\n+\t* tree-streamer-in.c (streamer_read_string_cst): Same.\n+\t(input_identifier): Same.\n+\t(unpack_ts_type_common_value_fields): Same.\n+\t(unpack_ts_block_value_fields): Same.\n+\t(unpack_ts_translation_unit_decl_value_fields): Same.\n+\t(unpack_ts_omp_clause_value_fields): Same.\n+\t(streamer_read_tree_bitfields): Same.\n+\t(streamer_alloc_tree): Same.\n+\t(lto_input_ts_common_tree_pointers): Same.\n+\t(lto_input_ts_vector_tree_pointers): Same.\n+\t(lto_input_ts_poly_tree_pointers): Same.\n+\t(lto_input_ts_complex_tree_pointers): Same.\n+\t(lto_input_ts_decl_minimal_tree_pointers): Same.\n+\t(lto_input_ts_decl_common_tree_pointers): Same.\n+\t(lto_input_ts_decl_non_common_tree_pointers): Same.\n+\t(lto_input_ts_decl_with_vis_tree_pointers): Same.\n+\t(lto_input_ts_field_decl_tree_pointers): Same.\n+\t(lto_input_ts_function_decl_tree_pointers): Same.\n+\t(lto_input_ts_type_common_tree_pointers): Same.\n+\t(lto_input_ts_type_non_common_tree_pointers): Same.\n+\t(lto_input_ts_list_tree_pointers): Same.\n+\t(lto_input_ts_vec_tree_pointers): Same.\n+\t(lto_input_ts_exp_tree_pointers): Same.\n+\t(lto_input_ts_block_tree_pointers): Same.\n+\t(lto_input_ts_binfo_tree_pointers): Same.\n+\t(lto_input_ts_constructor_tree_pointers): Same.\n+\t(lto_input_ts_omp_clause_tree_pointers): Same.\n+\t(streamer_read_tree_body): Same.\n+\t* tree-streamer.h: Same.\n+\t* tree-switch-conversion.c (bit_test_cluster::is_beneficial): Same.\n+\t* tree-vect-data-refs.c (vect_get_smallest_scalar_type): Same.\n+\t(vect_analyze_possibly_independent_ddr): Same.\n+\t(vect_analyze_data_ref_dependence): Same.\n+\t(vect_compute_data_ref_alignment): Same.\n+\t(vect_enhance_data_refs_alignment): Same.\n+\t(vect_analyze_data_ref_access): Same.\n+\t(vect_check_gather_scatter): Same.\n+\t(vect_find_stmt_data_reference): Same.\n+\t(vect_create_addr_base_for_vector_ref): Same.\n+\t(vect_setup_realignment): Same.\n+\t(vect_supportable_dr_alignment): Same.\n+\t* tree-vect-loop-manip.c (rename_variables_in_bb): Same.\n+\t(adjust_phi_and_debug_stmts): Same.\n+\t(vect_set_loop_mask): Same.\n+\t(add_preheader_seq): Same.\n+\t(vect_maybe_permute_loop_masks): Same.\n+\t(vect_set_loop_masks_directly): Same.\n+\t(vect_set_loop_condition_masked): Same.\n+\t(vect_set_loop_condition_unmasked): Same.\n+\t(slpeel_duplicate_current_defs_from_edges): Same.\n+\t(slpeel_add_loop_guard): Same.\n+\t(slpeel_can_duplicate_loop_p): Same.\n+\t(create_lcssa_for_virtual_phi): Same.\n+\t(iv_phi_p): Same.\n+\t(vect_update_ivs_after_vectorizer): Same.\n+\t(vect_gen_vector_loop_niters_mult_vf): Same.\n+\t(slpeel_update_phi_nodes_for_loops): Same.\n+\t(slpeel_update_phi_nodes_for_guard1): Same.\n+\t(find_guard_arg): Same.\n+\t(slpeel_update_phi_nodes_for_guard2): Same.\n+\t(slpeel_update_phi_nodes_for_lcssa): Same.\n+\t(vect_do_peeling): Same.\n+\t(vect_create_cond_for_alias_checks): Same.\n+\t(vect_loop_versioning): Same.\n+\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Same.\n+\t(vect_inner_phi_in_double_reduction_p): Same.\n+\t(vect_analyze_scalar_cycles_1): Same.\n+\t(vect_fixup_scalar_cycles_with_patterns): Same.\n+\t(vect_get_loop_niters): Same.\n+\t(bb_in_loop_p): Same.\n+\t(vect_get_max_nscalars_per_iter): Same.\n+\t(vect_verify_full_masking): Same.\n+\t(vect_compute_single_scalar_iteration_cost): Same.\n+\t(vect_analyze_loop_form_1): Same.\n+\t(vect_analyze_loop_form): Same.\n+\t(vect_active_double_reduction_p): Same.\n+\t(vect_analyze_loop_operations): Same.\n+\t(neutral_op_for_slp_reduction): Same.\n+\t(vect_is_simple_reduction): Same.\n+\t(vect_model_reduction_cost): Same.\n+\t(get_initial_def_for_reduction): Same.\n+\t(get_initial_defs_for_reduction): Same.\n+\t(vect_create_epilog_for_reduction): Same.\n+\t(vectorize_fold_left_reduction): Same.\n+\t(vectorizable_reduction): Same.\n+\t(vectorizable_induction): Same.\n+\t(vectorizable_live_operation): Same.\n+\t(loop_niters_no_overflow): Same.\n+\t(vect_get_loop_mask): Same.\n+\t(vect_transform_loop_stmt): Same.\n+\t(vect_transform_loop): Same.\n+\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Same.\n+\t(vect_determine_precisions): Same.\n+\t(vect_pattern_recog_1): Same.\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): Same.\n+\t* tree-vect-stmts.c (stmt_vectype): Same.\n+\t(process_use): Same.\n+\t(vect_init_vector_1): Same.\n+\t(vect_truncate_gather_scatter_offset): Same.\n+\t(get_group_load_store_type): Same.\n+\t(vect_build_gather_load_calls): Same.\n+\t(vect_get_strided_load_store_ops): Same.\n+\t(vectorizable_simd_clone_call): Same.\n+\t(vectorizable_store): Same.\n+\t(permute_vec_elements): Same.\n+\t(vectorizable_load): Same.\n+\t(vect_transform_stmt): Same.\n+\t(supportable_widening_operation): Same.\n+\t* tree-vectorizer.c (vec_info::replace_stmt): Same.\n+\t(vec_info::free_stmt_vec_info): Same.\n+\t(vect_free_loop_info_assumptions): Same.\n+\t(vect_loop_vectorized_call): Same.\n+\t(set_uid_loop_bbs): Same.\n+\t(vectorize_loops): Same.\n+\t* tree-vectorizer.h (STMT_VINFO_BB_VINFO): Same.\n+\t* tree.c (add_tree_to_fld_list): Same.\n+\t(fld_type_variant_equal_p): Same.\n+\t(fld_decl_context): Same.\n+\t(fld_incomplete_type_of): Same.\n+\t(free_lang_data_in_binfo): Same.\n+\t(need_assembler_name_p): Same.\n+\t(find_decls_types_r): Same.\n+\t(get_eh_types_for_runtime): Same.\n+\t(find_decls_types_in_eh_region): Same.\n+\t(find_decls_types_in_node): Same.\n+\t(assign_assembler_name_if_needed): Same.\n+\t* value-prof.c (stream_out_histogram_value): Same.\n+\t* value-prof.h: Same.\n+\t* var-tracking.c (use_narrower_mode): Same.\n+\t(prepare_call_arguments): Same.\n+\t(vt_expand_loc_callback): Same.\n+\t(resolve_expansions_pending_recursion): Same.\n+\t(vt_expand_loc): Same.\n+\t* varasm.c (const_hash_1): Same.\n+\t(compare_constant): Same.\n+\t(tree_output_constant_def): Same.\n+\t(simplify_subtraction): Same.\n+\t(get_pool_constant): Same.\n+\t(output_constant_pool_2): Same.\n+\t(output_constant_pool_1): Same.\n+\t(mark_constants_in_pattern): Same.\n+\t(mark_constant_pool): Same.\n+\t(get_section_anchor): Same.\n+\t* vr-values.c (compare_range_with_value): Same.\n+\t(vr_values::extract_range_from_phi_node): Same.\n+\t* vr-values.h: Same.\n+\t* web.c (unionfind_union): Same.\n+\t* wide-int.h: Same.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/61339"}, {"sha": "ee1a83abce237dfc75e76a5852c5b156ff7a5e3f", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -104,7 +104,7 @@ namespace autofdo\n /* Intermediate edge info used when propagating AutoFDO profile information.\n    We can't edge->count() directly since it's computed from edge's probability\n    while probability is yet not decided during propagation.  */\n-#define AFDO_EINFO(e)                     ((struct edge_info *) e->aux)\n+#define AFDO_EINFO(e)                     ((class edge_info *) e->aux)\n class edge_info\n {\n public:"}, {"sha": "5e0fbc0e2b32035af8f185f61c66889f7ad9b186", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -123,7 +123,7 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n   PTR GTY ((skip (\"\"))) aux;\n \n   /* Innermost loop containing the block.  */\n-  struct loop *loop_father;\n+  class loop *loop_father;\n \n   /* The dominance and postdominance information node.  */\n   struct et_node * GTY ((skip (\"\"))) dom[2];"}, {"sha": "c99d6465ed42bd614e9d809e050f919787c708ef", "filename": "gcc/bitmap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -775,7 +775,7 @@ bitmap_alloc (bitmap_obstack *bit_obstack MEM_STAT_DECL)\n     bit_obstack = &bitmap_default_obstack;\n   map = bit_obstack->heads;\n   if (map)\n-    bit_obstack->heads = (struct bitmap_head *) map->first;\n+    bit_obstack->heads = (class bitmap_head *) map->first;\n   else\n     map = XOBNEW (&bit_obstack->obstack, bitmap_head);\n   bitmap_initialize (map, bit_obstack PASS_MEM_STAT);"}, {"sha": "b0ca7b96c94d8a85a244b4701c260e5cab5bd001", "filename": "gcc/bitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -290,7 +290,7 @@ typedef unsigned long BITMAP_WORD;\n /* Obstack for allocating bitmaps and elements from.  */\n struct bitmap_obstack {\n   struct bitmap_element *elements;\n-  struct bitmap_head *heads;\n+  bitmap_head *heads;\n   struct obstack obstack;\n };\n "}, {"sha": "e5a9261e84cb195fc09a1832664beb4b8adde6c8", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1400,7 +1400,7 @@ expand_builtin_prefetch (tree exp)\n \n   if (targetm.have_prefetch ())\n     {\n-      struct expand_operand ops[3];\n+      class expand_operand ops[3];\n \n       create_address_operand (&ops[0], op0);\n       create_integer_operand (&ops[1], INTVAL (op1));\n@@ -2445,7 +2445,7 @@ expand_builtin_interclass_mathfn (tree exp, rtx target)\n \n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[1];\n+      class expand_operand ops[1];\n       rtx_insn *last = get_last_insn ();\n       tree orig_arg = arg;\n \n@@ -2946,7 +2946,7 @@ expand_builtin_strlen (tree exp, rtx target,\n   if (!validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   rtx pat;\n   tree len;\n   tree src = CALL_EXPR_ARG (exp, 0);\n@@ -3923,7 +3923,7 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n static rtx\n expand_movstr (tree dest, tree src, rtx target, memop_ret retmode)\n {\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   rtx dest_mem;\n   rtx src_mem;\n \n@@ -4633,7 +4633,7 @@ expand_cmpstr (insn_code icode, rtx target, rtx arg1_rtx, rtx arg2_rtx,\n   if (target && (!REG_P (target) || HARD_REGISTER_P (target)))\n     target = NULL_RTX;\n \n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   create_output_operand (&ops[0], target, insn_mode);\n   create_fixed_operand (&ops[1], arg1_rtx);\n   create_fixed_operand (&ops[2], arg2_rtx);\n@@ -5606,7 +5606,7 @@ expand_builtin___clear_cache (tree exp)\n \n   if (targetm.have_clear_cache ())\n     {\n-      struct expand_operand ops[2];\n+      class expand_operand ops[2];\n \n       begin = CALL_EXPR_ARG (exp, 0);\n       begin_rtx = expand_expr (begin, NULL_RTX, Pmode, EXPAND_NORMAL);\n@@ -6566,7 +6566,7 @@ expand_ifn_atomic_bit_test_and (gcall *call)\n   machine_mode mode = TYPE_MODE (TREE_TYPE (flag));\n   enum rtx_code code;\n   optab optab;\n-  struct expand_operand ops[5];\n+  class expand_operand ops[5];\n \n   gcc_assert (flag_inline_atomics);\n \n@@ -6874,7 +6874,7 @@ expand_builtin_thread_pointer (tree exp, rtx target)\n   icode = direct_optab_handler (get_thread_pointer_optab, Pmode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand op;\n+      class expand_operand op;\n       /* If the target is not sutitable then create a new target. */\n       if (target == NULL_RTX\n \t  || !REG_P (target)\n@@ -6897,7 +6897,7 @@ expand_builtin_set_thread_pointer (tree exp)\n   icode = direct_optab_handler (set_thread_pointer_optab, Pmode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand op;\n+      class expand_operand op;\n       rtx val = expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX,\n \t\t\t     Pmode, EXPAND_NORMAL);      \n       create_input_operand (&op, val, Pmode);"}, {"sha": "bbad47fc49737d768a34652285252ba70de57483", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1,3 +1,10 @@\n+2019-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* c-opts.c (handle_deferred_opts): : Change class-key of PODs to struct\n+\tand others to class.\n+\t* c-pretty-print.h: Same.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/61339"}, {"sha": "e97bbdf5c6f0e6c9664259c607dd99f664d72556", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1287,7 +1287,7 @@ handle_deferred_opts (void)\n   if (!deps_seen)\n     return;\n \n-  struct mkdeps *deps = cpp_get_deps (parse_in);\n+  mkdeps *deps = cpp_get_deps (parse_in);\n \n   for (size_t i = 0; i < deferred_count; i++)\n     {"}, {"sha": "8d69620b724062956be17cda6091eb3362ab5e25", "filename": "gcc/c-family/c-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc-family%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc-family%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -36,7 +36,7 @@ enum pp_c_pretty_print_flags\n \n /* The data type used to bundle information necessary for pretty-printing\n    a C or C++ entity.  */\n-struct c_pretty_printer;\n+class c_pretty_printer;\n \n /* The type of a C pretty-printer 'member' function.  */\n typedef void (*c_pretty_print_fn) (c_pretty_printer *, tree);"}, {"sha": "29836ff9595c76c7d3858c6638e62a11b890a61b", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1,3 +1,13 @@\n+2019-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* c-decl.c (xref_tag): Change class-key of PODs to struct and others\n+\tto class.\n+\t(field_decl_cmp): Same.\n+\t* c-parser.c (c_parser_struct_or_union_specifier): Same.\n+\t* c-tree.h: Same.\n+\t* gimple-parser.c (c_parser_gimple_compound_statement): Same.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/61339"}, {"sha": "d75648aa27384016a848f8ecf6875f5152ff4a99", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -592,7 +592,7 @@ class c_struct_parse_info\n \n /* Information for the struct or union currently being parsed, or\n    NULL if not parsing a struct or union.  */\n-static struct c_struct_parse_info *struct_parse_info;\n+static class c_struct_parse_info *struct_parse_info;\n \n /* Forward declarations.  */\n static tree lookup_name_in_scope (tree, struct c_scope *);\n@@ -7768,7 +7768,7 @@ xref_tag (enum tree_code code, tree name)\n \n tree\n start_struct (location_t loc, enum tree_code code, tree name,\n-\t      struct c_struct_parse_info **enclosing_struct_parse_info)\n+\t      class c_struct_parse_info **enclosing_struct_parse_info)\n {\n   /* If there is already a tag defined at this scope\n      (as a forward reference), just return it.  */\n@@ -8183,7 +8183,7 @@ field_decl_cmp (const void *x_p, const void *y_p)\n \n tree\n finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n-\t       struct c_struct_parse_info *enclosing_struct_parse_info)\n+\t       class c_struct_parse_info *enclosing_struct_parse_info)\n {\n   tree x;\n   bool toplevel = file_scope == current_scope;"}, {"sha": "3fa7e682b8fa7c2201647f5ecadc2f8e393f875c", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -3145,7 +3145,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n     {\n       /* Parse a struct or union definition.  Start the scope of the\n \t tag before parsing components.  */\n-      struct c_struct_parse_info *struct_info;\n+      class c_struct_parse_info *struct_info;\n       tree type = start_struct (struct_loc, code, ident, &struct_info);\n       tree postfix_attrs;\n       /* We chain the components in reverse order, then put them in"}, {"sha": "dae2979d482c06c0b0ec5203e99d98db82102b2f", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -525,7 +525,7 @@ extern void gen_aux_info_record (tree, int, int, int);\n \n /* in c-decl.c */\n struct c_spot_bindings;\n-struct c_struct_parse_info;\n+class c_struct_parse_info;\n extern struct obstack parser_obstack;\n extern tree c_break_label;\n extern tree c_cont_label;\n@@ -562,7 +562,7 @@ extern void finish_decl (tree, location_t, tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n extern void finish_function (void);\n extern tree finish_struct (location_t, tree, tree, tree,\n-\t\t\t   struct c_struct_parse_info *);\n+\t\t\t   class c_struct_parse_info *);\n extern struct c_arg_info *build_arg_info (void);\n extern struct c_arg_info *get_parm_info (bool, tree);\n extern tree grokfield (location_t, struct c_declarator *,\n@@ -586,7 +586,7 @@ extern bool start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n \t\t\ttree);\n extern tree start_struct (location_t, enum tree_code, tree,\n-\t\t\t  struct c_struct_parse_info **);\n+\t\t\t  class c_struct_parse_info **);\n extern void store_parm_decls (void);\n extern void store_parm_decls_from (struct c_arg_info *);\n extern void temp_store_parm_decls (tree, tree);"}, {"sha": "9a65394a020f54d42e1116223091b98b15a96d24", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -585,7 +585,7 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\t\t\t  profile_probability::always ());\n \n \t      /* We leave the proper setting to fixup.  */\n-\t      struct loop *loop_father = loops_for_fn (cfun)->tree_root;\n+\t      class loop *loop_father = loops_for_fn (cfun)->tree_root;\n \t      /* If the new block is a loop header, allocate a loop\n \t\t struct.  Fixup will take care of proper placement within\n \t\t the loop tree.  */\n@@ -598,7 +598,7 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      struct loop *loop = alloc_loop ();\n+\t\t      class loop *loop = alloc_loop ();\n \t\t      loop->num = is_loop_header_of;\n \t\t      loop->header = bb;\n \t\t      vec_safe_grow_cleared (loops_for_fn (cfun)->larray,"}, {"sha": "7c1de8949768c3e2b4c4e30dc0ff63f4d42cee80", "filename": "gcc/caller-save.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -88,11 +88,11 @@ static void mark_set_regs (rtx, const_rtx, void *);\n static void mark_referenced_regs (rtx *, refmarker_fn *mark, void *mark_arg);\n static refmarker_fn mark_reg_as_referenced;\n static refmarker_fn replace_reg_with_saved_mem;\n-static int insert_save (struct insn_chain *, int, HARD_REG_SET *,\n+static int insert_save (class insn_chain *, int, HARD_REG_SET *,\n \t\t\tmachine_mode *);\n-static int insert_restore (struct insn_chain *, int, int, int,\n+static int insert_restore (class insn_chain *, int, int, int,\n \t\t\t   machine_mode *);\n-static struct insn_chain *insert_one_insn (struct insn_chain *, int, int,\n+static class insn_chain *insert_one_insn (class insn_chain *, int, int,\n \t\t\t\t\t   rtx);\n static void add_stored_regs (rtx, const_rtx, void *);\n \n@@ -419,7 +419,7 @@ setup_save_areas (void)\n   HARD_REG_SET hard_regs_used;\n   struct saved_hard_reg *saved_reg;\n   rtx_insn *insn;\n-  struct insn_chain *chain, *next;\n+  class insn_chain *chain, *next;\n   unsigned int regno;\n   HARD_REG_SET hard_regs_to_save, used_regs, this_insn_sets;\n   reg_set_iterator rsi;\n@@ -744,7 +744,7 @@ setup_save_areas (void)\n void\n save_call_clobbered_regs (void)\n {\n-  struct insn_chain *chain, *next, *last = NULL;\n+  class insn_chain *chain, *next, *last = NULL;\n   machine_mode save_mode [FIRST_PSEUDO_REGISTER];\n \n   /* Computed in mark_set_regs, holds all registers set by the current\n@@ -1174,14 +1174,14 @@ replace_reg_with_saved_mem (rtx *loc,\n    Return the extra number of registers saved.  */\n \n static int\n-insert_restore (struct insn_chain *chain, int before_p, int regno,\n+insert_restore (class insn_chain *chain, int before_p, int regno,\n \t\tint maxrestore, machine_mode *save_mode)\n {\n   int i, k;\n   rtx pat = NULL_RTX;\n   int code;\n   unsigned int numregs = 0;\n-  struct insn_chain *new_chain;\n+  class insn_chain *new_chain;\n   rtx mem;\n \n   /* A common failure mode if register status is not correct in the\n@@ -1253,15 +1253,15 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n /* Like insert_restore above, but save registers instead.  */\n \n static int\n-insert_save (struct insn_chain *chain, int regno,\n+insert_save (class insn_chain *chain, int regno,\n \t     HARD_REG_SET *to_save, machine_mode *save_mode)\n {\n   int i;\n   unsigned int k;\n   rtx pat = NULL_RTX;\n   int code;\n   unsigned int numregs = 0;\n-  struct insn_chain *new_chain;\n+  class insn_chain *new_chain;\n   rtx mem;\n \n   /* A common failure mode if register status is not correct in the\n@@ -1351,11 +1351,11 @@ add_used_regs (rtx *loc, void *data)\n }\n \n /* Emit a new caller-save insn and set the code.  */\n-static struct insn_chain *\n-insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n+static class insn_chain *\n+insert_one_insn (class insn_chain *chain, int before_p, int code, rtx pat)\n {\n   rtx_insn *insn = chain->insn;\n-  struct insn_chain *new_chain;\n+  class insn_chain *new_chain;\n \n   /* If INSN references CC0, put our insns in front of the insn that sets\n      CC0.  This is always safe, since the only way we could be passed an"}, {"sha": "4757bab1deefaf78f49cf6c2145d04e8fc52fa6b", "filename": "gcc/cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1145,7 +1145,7 @@ get_bb_copy (basic_block bb)\n    initialized so passes not needing this don't need to care.  */\n \n void\n-set_loop_copy (struct loop *loop, struct loop *copy)\n+set_loop_copy (class loop *loop, class loop *copy)\n {\n   if (!copy)\n     copy_original_table_clear (loop_copy, loop->num);\n@@ -1155,8 +1155,8 @@ set_loop_copy (struct loop *loop, struct loop *copy)\n \n /* Get the copy of LOOP.  */\n \n-struct loop *\n-get_loop_copy (struct loop *loop)\n+class loop *\n+get_loop_copy (class loop *loop)\n {\n   struct htab_bb_copy_original_entry *entry;\n   struct htab_bb_copy_original_entry key;"}, {"sha": "12cd760899eab864d905b27b799eeb3e5412617b", "filename": "gcc/cfg.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -122,8 +122,8 @@ extern void set_bb_original (basic_block, basic_block);\n extern basic_block get_bb_original (basic_block);\n extern void set_bb_copy (basic_block, basic_block);\n extern basic_block get_bb_copy (basic_block);\n-void set_loop_copy (struct loop *, struct loop *);\n-struct loop *get_loop_copy (struct loop *);\n+void set_loop_copy (class loop *, class loop *);\n+class loop *get_loop_copy (class loop *);\n \n /* Generic RAII class to allocate a bit from storage of integer type T.\n    The allocated bit is accessible as mask with the single bit set"}, {"sha": "c928feae62568ccb61b6ebaace1463424f8c98bb", "filename": "gcc/cfganal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -72,8 +72,8 @@ extern int rev_post_order_and_mark_dfs_back_seme (struct function *, edge,\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(const_basic_block, const void *),\n \t\t\t       basic_block *, int, const void *);\n-extern void compute_dominance_frontiers (struct bitmap_head *);\n-extern bitmap compute_idf (bitmap, struct bitmap_head *);\n+extern void compute_dominance_frontiers (class bitmap_head *);\n+extern bitmap compute_idf (bitmap, class bitmap_head *);\n extern void bitmap_intersection_of_succs (sbitmap, sbitmap *, basic_block);\n extern void bitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);\n extern void bitmap_union_of_succs (sbitmap, sbitmap *, basic_block);"}, {"sha": "d0c1d31a2cce86accfb79e3debdadb63d4e1f2ba", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -332,7 +332,7 @@ class stack_var\n #define EOC  ((size_t)-1)\n \n /* We have an array of such objects while deciding allocation.  */\n-static struct stack_var *stack_vars;\n+static class stack_var *stack_vars;\n static size_t stack_vars_alloc;\n static size_t stack_vars_num;\n static hash_map<tree, size_t> *decl_to_stack_part;\n@@ -426,7 +426,7 @@ alloc_stack_frame_space (poly_int64 size, unsigned HOST_WIDE_INT align)\n static void\n add_stack_var (tree decl, bool really_expand)\n {\n-  struct stack_var *v;\n+  class stack_var *v;\n \n   if (stack_vars_num >= stack_vars_alloc)\n     {\n@@ -435,7 +435,7 @@ add_stack_var (tree decl, bool really_expand)\n       else\n \tstack_vars_alloc = 32;\n       stack_vars\n-\t= XRESIZEVEC (struct stack_var, stack_vars, stack_vars_alloc);\n+\t= XRESIZEVEC (class stack_var, stack_vars, stack_vars_alloc);\n     }\n   if (!decl_to_stack_part)\n     decl_to_stack_part = new hash_map<tree, size_t>;\n@@ -474,8 +474,8 @@ add_stack_var (tree decl, bool really_expand)\n static void\n add_stack_var_conflict (size_t x, size_t y)\n {\n-  struct stack_var *a = &stack_vars[x];\n-  struct stack_var *b = &stack_vars[y];\n+  class stack_var *a = &stack_vars[x];\n+  class stack_var *b = &stack_vars[y];\n   if (x == y)\n     return;\n   if (!a->conflicts)\n@@ -491,8 +491,8 @@ add_stack_var_conflict (size_t x, size_t y)\n static bool\n stack_var_conflict_p (size_t x, size_t y)\n {\n-  struct stack_var *a = &stack_vars[x];\n-  struct stack_var *b = &stack_vars[y];\n+  class stack_var *a = &stack_vars[x];\n+  class stack_var *b = &stack_vars[y];\n   if (x == y)\n     return false;\n   /* Partitions containing an SSA name result from gimple registers\n@@ -607,7 +607,7 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n \t      unsigned i;\n \t      EXECUTE_IF_SET_IN_BITMAP (work, 0, i, bi)\n \t\t{\n-\t\t  struct stack_var *a = &stack_vars[i];\n+\t\t  class stack_var *a = &stack_vars[i];\n \t\t  if (!a->conflicts)\n \t\t    a->conflicts = BITMAP_ALLOC (&stack_var_bitmap_obstack);\n \t\t  bitmap_ior_into (a->conflicts, work);\n@@ -853,7 +853,7 @@ update_alias_info_with_stack_vars (void)\n static void\n union_stack_vars (size_t a, size_t b)\n {\n-  struct stack_var *vb = &stack_vars[b];\n+  class stack_var *vb = &stack_vars[b];\n   bitmap_iterator bi;\n   unsigned u;\n \n@@ -1045,7 +1045,7 @@ class stack_vars_data\n    with that location.  */\n \n static void\n-expand_stack_vars (bool (*pred) (size_t), struct stack_vars_data *data)\n+expand_stack_vars (bool (*pred) (size_t), class stack_vars_data *data)\n {\n   size_t si, i, j, n = stack_vars_num;\n   poly_uint64 large_size = 0, large_alloc = 0;\n@@ -2232,7 +2232,7 @@ expand_used_vars (void)\n   /* Assign rtl to each variable based on these partitions.  */\n   if (stack_vars_num > 0)\n     {\n-      struct stack_vars_data data;\n+      class stack_vars_data data;\n \n       data.asan_base = NULL_RTX;\n       data.asan_alignb = 0;"}, {"sha": "7c00fc370f83b940a181fc8491701a0bf20fad3c", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -496,7 +496,7 @@ redirect_edge_and_branch_force (edge e, basic_block dest)\n     {\n       if (ret != NULL)\n \t{\n-\t  struct loop *loop\n+\t  class loop *loop\n \t    = find_common_loop (single_pred (ret)->loop_father,\n \t\t\t\tsingle_succ (ret)->loop_father);\n \t  add_bb_to_loop (ret, loop);\n@@ -604,7 +604,7 @@ delete_basic_block (basic_block bb)\n \n   if (current_loops != NULL)\n     {\n-      struct loop *loop = bb->loop_father;\n+      class loop *loop = bb->loop_father;\n \n       /* If we remove the header or the latch of a loop, mark the loop for\n \t removal.  */\n@@ -640,7 +640,7 @@ split_edge (edge e)\n   profile_count count = e->count ();\n   edge f;\n   bool irr = (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n-  struct loop *loop;\n+  class loop *loop;\n   basic_block src = e->src, dest = e->dest;\n \n   if (!cfg_hooks->split_edge)\n@@ -870,7 +870,7 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n   edge e, fallthru;\n   edge_iterator ei;\n   basic_block dummy, jump;\n-  struct loop *loop, *ploop, *cloop;\n+  class loop *loop, *ploop, *cloop;\n \n   if (!cfg_hooks->make_forwarder_block)\n     internal_error (\"%s does not support make_forwarder_block\",\n@@ -1035,7 +1035,7 @@ force_nonfallthru (edge e)\n \t{\n \t  basic_block pred = single_pred (ret);\n \t  basic_block succ = single_succ (ret);\n-\t  struct loop *loop\n+\t  class loop *loop\n \t    = find_common_loop (pred->loop_father, succ->loop_father);\n \t  rescan_loop_exit (e, false, true);\n \t  add_bb_to_loop (ret, loop);\n@@ -1118,8 +1118,8 @@ duplicate_block (basic_block bb, edge e, basic_block after, copy_bb_data *id)\n      of BB if the loop is not being copied.  */\n   if (current_loops != NULL)\n     {\n-      struct loop *cloop = bb->loop_father;\n-      struct loop *copy = get_loop_copy (cloop);\n+      class loop *cloop = bb->loop_father;\n+      class loop *copy = get_loop_copy (cloop);\n       /* If we copied the loop header block but not the loop\n \t we have created a loop with multiple entries.  Ditch the loop,\n \t add the new block to the outer loop and arrange for a fixup.  */\n@@ -1228,7 +1228,7 @@ lv_flush_pending_stmts (edge e)\n    a need to call the tree_duplicate_loop_to_header_edge rather\n    than duplicate_loop_to_header_edge when we are in tree mode.  */\n bool\n-cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n+cfg_hook_duplicate_loop_to_header_edge (class loop *loop, edge e,\n \t\t\t\t\tunsigned int ndupl,\n \t\t\t\t\tsbitmap wont_exit, edge orig,\n \t\t\t\t\tvec<edge> *to_remove,\n@@ -1336,7 +1336,7 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n void\n copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n \t  edge *edges, unsigned num_edges, edge *new_edges,\n-\t  struct loop *base, basic_block after, bool update_dominance)\n+\t  class loop *base, basic_block after, bool update_dominance)\n {\n   unsigned i, j;\n   basic_block bb, new_bb, dom_bb;"}, {"sha": "627eff9e186cc1ae9cce45f6a5ae0aa9209b4042", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -166,7 +166,7 @@ struct cfg_hooks\n \n   /* A hook for duplicating loop in CFG, currently this is used\n      in loop versioning.  */\n-  bool (*cfg_hook_duplicate_loop_to_header_edge) (struct loop *, edge,\n+  bool (*cfg_hook_duplicate_loop_to_header_edge) (class loop *, edge,\n \t\t\t\t\t\t  unsigned, sbitmap,\n \t\t\t\t\t\t  edge, vec<edge> *,\n \t\t\t\t\t\t  int);\n@@ -250,7 +250,7 @@ extern bool block_ends_with_condjump_p (const_basic_block bb);\n extern int flow_call_edges_add (sbitmap);\n extern void execute_on_growing_pred (edge);\n extern void execute_on_shrinking_pred (edge);\n-extern bool cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge,\n+extern bool cfg_hook_duplicate_loop_to_header_edge (class loop *loop, edge,\n \t\t\t\t\t\t    unsigned int ndupl,\n \t\t\t\t\t\t    sbitmap wont_exit,\n \t\t\t\t\t\t    edge orig,\n@@ -266,7 +266,7 @@ extern void lv_add_condition_to_bb (basic_block, basic_block, basic_block,\n \n extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,\n-\t\t      edge *, unsigned, edge *, struct loop *,\n+\t\t      edge *, unsigned, edge *, class loop *,\n \t\t      basic_block, bool);\n \n void profile_record_check_consistency (profile_record *);"}, {"sha": "4ad1f658708f83dbd8789666c26d4bd056837bc6", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -59,7 +59,7 @@ flow_loops_cfg_dump (FILE *file)\n /* Return nonzero if the nodes of LOOP are a subset of OUTER.  */\n \n bool\n-flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n+flow_loop_nested_p (const class loop *outer, const class loop *loop)\n {\n   unsigned odepth = loop_depth (outer);\n \n@@ -70,8 +70,8 @@ flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n /* Returns the loop such that LOOP is nested DEPTH (indexed from zero)\n    loops within LOOP.  */\n \n-struct loop *\n-superloop_at_depth (struct loop *loop, unsigned depth)\n+class loop *\n+superloop_at_depth (class loop *loop, unsigned depth)\n {\n   unsigned ldepth = loop_depth (loop);\n \n@@ -86,7 +86,7 @@ superloop_at_depth (struct loop *loop, unsigned depth)\n /* Returns the list of the latch edges of LOOP.  */\n \n static vec<edge> \n-get_loop_latch_edges (const struct loop *loop)\n+get_loop_latch_edges (const class loop *loop)\n {\n   edge_iterator ei;\n   edge e;\n@@ -105,8 +105,8 @@ get_loop_latch_edges (const struct loop *loop)\n    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n \n void\n-flow_loop_dump (const struct loop *loop, FILE *file,\n-\t\tvoid (*loop_dump_aux) (const struct loop *, FILE *, int),\n+flow_loop_dump (const class loop *loop, FILE *file,\n+\t\tvoid (*loop_dump_aux) (const class loop *, FILE *, int),\n \t\tint verbose)\n {\n   basic_block *bbs;\n@@ -160,9 +160,9 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n \n void\n-flow_loops_dump (FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *, int), int verbose)\n+flow_loops_dump (FILE *file, void (*loop_dump_aux) (const class loop *, FILE *, int), int verbose)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   if (!current_loops || ! file)\n     return;\n@@ -181,7 +181,7 @@ flow_loops_dump (FILE *file, void (*loop_dump_aux) (const struct loop *, FILE *,\n /* Free data allocated for LOOP.  */\n \n void\n-flow_loop_free (struct loop *loop)\n+flow_loop_free (class loop *loop)\n {\n   struct loop_exit *exit, *next;\n \n@@ -229,7 +229,7 @@ flow_loops_free (struct loops *loops)\n    Return the number of nodes within the loop.  */\n \n int\n-flow_loop_nodes_find (basic_block header, struct loop *loop)\n+flow_loop_nodes_find (basic_block header, class loop *loop)\n {\n   vec<basic_block> stack = vNULL;\n   int num_nodes = 1;\n@@ -278,7 +278,7 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n    superloop is FATHER.  */\n \n static void\n-establish_preds (struct loop *loop, struct loop *father)\n+establish_preds (class loop *loop, class loop *father)\n {\n   loop_p ploop;\n   unsigned depth = loop_depth (father) + 1;\n@@ -302,8 +302,8 @@ establish_preds (struct loop *loop, struct loop *father)\n    of FATHERs siblings.  */\n \n void\n-flow_loop_tree_node_add (struct loop *father, struct loop *loop,\n-\t\t\t struct loop *after)\n+flow_loop_tree_node_add (class loop *father, class loop *loop,\n+\t\t\t class loop *after)\n {\n   if (after)\n     {\n@@ -322,9 +322,9 @@ flow_loop_tree_node_add (struct loop *father, struct loop *loop,\n /* Remove LOOP from the loop hierarchy tree.  */\n \n void\n-flow_loop_tree_node_remove (struct loop *loop)\n+flow_loop_tree_node_remove (class loop *loop)\n {\n-  struct loop *prev, *father;\n+  class loop *prev, *father;\n \n   father = loop_outer (loop);\n \n@@ -343,10 +343,10 @@ flow_loop_tree_node_remove (struct loop *loop)\n \n /* Allocates and returns new loop structure.  */\n \n-struct loop *\n+class loop *\n alloc_loop (void)\n {\n-  struct loop *loop = ggc_cleared_alloc<struct loop> ();\n+  class loop *loop = ggc_cleared_alloc<class loop> ();\n \n   loop->exits = ggc_cleared_alloc<loop_exit> ();\n   loop->exits->next = loop->exits->prev = loop->exits;\n@@ -365,7 +365,7 @@ void\n init_loops_structure (struct function *fn,\n \t\t      struct loops *loops, unsigned num_loops)\n {\n-  struct loop *root;\n+  class loop *root;\n \n   memset (loops, 0, sizeof *loops);\n   vec_alloc (loops->larray, num_loops);\n@@ -460,7 +460,7 @@ flow_loops_find (struct loops *loops)\n       basic_block header = BASIC_BLOCK_FOR_FN (cfun, rc_order[b]);\n       if (bb_loop_header_p (header))\n \t{\n-\t  struct loop *loop;\n+\t  class loop *loop;\n \n \t  /* The current active loop tree has valid loop-fathers for\n \t     header blocks.  */\n@@ -503,7 +503,7 @@ flow_loops_find (struct loops *loops)\n      and assign basic-block ownership.  */\n   for (i = 0; i < larray.length (); ++i)\n     {\n-      struct loop *loop = larray[i];\n+      class loop *loop = larray[i];\n       basic_block header = loop->header;\n       edge_iterator ei;\n       edge e;\n@@ -539,8 +539,8 @@ static int *sort_sibling_loops_cmp_rpo;\n static int\n sort_sibling_loops_cmp (const void *la_, const void *lb_)\n {\n-  const struct loop *la = *(const struct loop * const *)la_;\n-  const struct loop *lb = *(const struct loop * const *)lb_;\n+  const class loop *la = *(const class loop * const *)la_;\n+  const class loop *lb = *(const class loop * const *)lb_;\n   return (sort_sibling_loops_cmp_rpo[la->header->index]\n \t  - sort_sibling_loops_cmp_rpo[lb->header->index]);\n }\n@@ -643,7 +643,7 @@ find_subloop_latch_edge_by_profile (vec<edge> latches)\n    another edge.  */\n \n static edge\n-find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, vec<edge> latches)\n+find_subloop_latch_edge_by_ivs (class loop *loop ATTRIBUTE_UNUSED, vec<edge> latches)\n {\n   edge e, latch = latches[0];\n   unsigned i;\n@@ -695,7 +695,7 @@ find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, vec<edge> la\n    returns NULL.  */\n \n static edge\n-find_subloop_latch_edge (struct loop *loop)\n+find_subloop_latch_edge (class loop *loop)\n {\n   vec<edge> latches = get_loop_latch_edges (loop);\n   edge latch = NULL;\n@@ -729,11 +729,11 @@ mfb_redirect_edges_in_set (edge e)\n /* Creates a subloop of LOOP with latch edge LATCH.  */\n \n static void\n-form_subloop (struct loop *loop, edge latch)\n+form_subloop (class loop *loop, edge latch)\n {\n   edge_iterator ei;\n   edge e, new_entry;\n-  struct loop *new_loop;\n+  class loop *new_loop;\n \n   mfb_reis_set = new hash_set<edge>;\n   FOR_EACH_EDGE (e, ei, loop->header->preds)\n@@ -759,7 +759,7 @@ form_subloop (struct loop *loop, edge latch)\n    a new latch of LOOP.  */\n \n static void\n-merge_latch_edges (struct loop *loop)\n+merge_latch_edges (class loop *loop)\n {\n   vec<edge> latches = get_loop_latch_edges (loop);\n   edge latch, e;\n@@ -792,7 +792,7 @@ merge_latch_edges (struct loop *loop)\n    loops with single latch edge.  */\n \n static void\n-disambiguate_multiple_latches (struct loop *loop)\n+disambiguate_multiple_latches (class loop *loop)\n {\n   edge e;\n \n@@ -836,7 +836,7 @@ disambiguate_multiple_latches (struct loop *loop)\n void\n disambiguate_loops_with_multiple_latches (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   FOR_EACH_LOOP (loop, 0)\n     {\n@@ -847,9 +847,9 @@ disambiguate_loops_with_multiple_latches (void)\n \n /* Return nonzero if basic block BB belongs to LOOP.  */\n bool\n-flow_bb_inside_loop_p (const struct loop *loop, const_basic_block bb)\n+flow_bb_inside_loop_p (const class loop *loop, const_basic_block bb)\n {\n-  struct loop *source_loop;\n+  class loop *source_loop;\n \n   if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun)\n       || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n@@ -863,7 +863,7 @@ flow_bb_inside_loop_p (const struct loop *loop, const_basic_block bb)\n static bool\n glb_enum_p (const_basic_block bb, const void *glb_loop)\n {\n-  const struct loop *const loop = (const struct loop *) glb_loop;\n+  const class loop *const loop = (const class loop *) glb_loop;\n   return (bb != loop->header\n \t  && dominated_by_p (CDI_DOMINATORS, bb, loop->header));\n }\n@@ -876,7 +876,7 @@ glb_enum_p (const_basic_block bb, const void *glb_loop)\n    returned.  */\n \n unsigned\n-get_loop_body_with_size (const struct loop *loop, basic_block *body,\n+get_loop_body_with_size (const class loop *loop, basic_block *body,\n \t\t\t unsigned max_size)\n {\n   return dfs_enumerate_from (loop->header, 1, glb_enum_p,\n@@ -888,7 +888,7 @@ get_loop_body_with_size (const struct loop *loop, basic_block *body,\n    header != latch, latch is the 1-st block.  */\n \n basic_block *\n-get_loop_body (const struct loop *loop)\n+get_loop_body (const class loop *loop)\n {\n   basic_block *body, bb;\n   unsigned tv = 0;\n@@ -918,7 +918,7 @@ get_loop_body (const struct loop *loop)\n    array TOVISIT from index *TV.  */\n \n static void\n-fill_sons_in_loop (const struct loop *loop, basic_block bb,\n+fill_sons_in_loop (const class loop *loop, basic_block bb,\n \t\t   basic_block *tovisit, int *tv)\n {\n   basic_block son, postpone = NULL;\n@@ -948,7 +948,7 @@ fill_sons_in_loop (const struct loop *loop, basic_block bb,\n    the latch, then only blocks dominated by s are be after it.  */\n \n basic_block *\n-get_loop_body_in_dom_order (const struct loop *loop)\n+get_loop_body_in_dom_order (const class loop *loop)\n {\n   basic_block *tovisit;\n   int tv;\n@@ -970,7 +970,7 @@ get_loop_body_in_dom_order (const struct loop *loop)\n /* Gets body of a LOOP sorted via provided BB_COMPARATOR.  */\n \n basic_block *\n-get_loop_body_in_custom_order (const struct loop *loop,\n+get_loop_body_in_custom_order (const class loop *loop,\n \t\t\t       int (*bb_comparator) (const void *, const void *))\n {\n   basic_block *bbs = get_loop_body (loop);\n@@ -983,7 +983,7 @@ get_loop_body_in_custom_order (const struct loop *loop,\n /* Get body of a LOOP in breadth first sort order.  */\n \n basic_block *\n-get_loop_body_in_bfs_order (const struct loop *loop)\n+get_loop_body_in_bfs_order (const class loop *loop)\n {\n   basic_block *blocks;\n   basic_block bb;\n@@ -1069,7 +1069,7 @@ void\n rescan_loop_exit (edge e, bool new_edge, bool removed)\n {\n   struct loop_exit *exits = NULL, *exit;\n-  struct loop *aloop, *cloop;\n+  class loop *aloop, *cloop;\n \n   if (!loops_state_satisfies_p (LOOPS_HAVE_RECORDED_EXITS))\n     return;\n@@ -1190,7 +1190,7 @@ release_recorded_exits (function *fn)\n /* Returns the list of the exit edges of a LOOP.  */\n \n vec<edge> \n-get_loop_exit_edges (const struct loop *loop)\n+get_loop_exit_edges (const class loop *loop)\n {\n   vec<edge> edges = vNULL;\n   edge e;\n@@ -1226,7 +1226,7 @@ get_loop_exit_edges (const struct loop *loop)\n /* Counts the number of conditional branches inside LOOP.  */\n \n unsigned\n-num_loop_branches (const struct loop *loop)\n+num_loop_branches (const class loop *loop)\n {\n   unsigned i, n;\n   basic_block * body;\n@@ -1245,7 +1245,7 @@ num_loop_branches (const struct loop *loop)\n \n /* Adds basic block BB to LOOP.  */\n void\n-add_bb_to_loop (basic_block bb, struct loop *loop)\n+add_bb_to_loop (basic_block bb, class loop *loop)\n {\n   unsigned i;\n   loop_p ploop;\n@@ -1273,7 +1273,7 @@ void\n remove_bb_from_loops (basic_block bb)\n {\n   unsigned i;\n-  struct loop *loop = bb->loop_father;\n+  class loop *loop = bb->loop_father;\n   loop_p ploop;\n   edge_iterator ei;\n   edge e;\n@@ -1295,8 +1295,8 @@ remove_bb_from_loops (basic_block bb)\n }\n \n /* Finds nearest common ancestor in loop tree for given loops.  */\n-struct loop *\n-find_common_loop (struct loop *loop_s, struct loop *loop_d)\n+class loop *\n+find_common_loop (class loop *loop_s, class loop *loop_d)\n {\n   unsigned sdepth, ddepth;\n \n@@ -1322,7 +1322,7 @@ find_common_loop (struct loop *loop_s, struct loop *loop_d)\n /* Removes LOOP from structures and frees its data.  */\n \n void\n-delete_loop (struct loop *loop)\n+delete_loop (class loop *loop)\n {\n   /* Remove the loop from structure.  */\n   flow_loop_tree_node_remove (loop);\n@@ -1337,11 +1337,11 @@ delete_loop (struct loop *loop)\n /* Cancels the LOOP; it must be innermost one.  */\n \n static void\n-cancel_loop (struct loop *loop)\n+cancel_loop (class loop *loop)\n {\n   basic_block *bbs;\n   unsigned i;\n-  struct loop *outer = loop_outer (loop);\n+  class loop *outer = loop_outer (loop);\n \n   gcc_assert (!loop->inner);\n \n@@ -1356,7 +1356,7 @@ cancel_loop (struct loop *loop)\n \n /* Cancels LOOP and all its subloops.  */\n void\n-cancel_loop_tree (struct loop *loop)\n+cancel_loop_tree (class loop *loop)\n {\n   while (loop->inner)\n     cancel_loop_tree (loop->inner);\n@@ -1385,7 +1385,7 @@ verify_loop_structure (void)\n {\n   unsigned *sizes, i, j;\n   basic_block bb, *bbs;\n-  struct loop *loop;\n+  class loop *loop;\n   int err = 0;\n   edge e;\n   unsigned num = number_of_loops (cfun);\n@@ -1727,14 +1727,14 @@ verify_loop_structure (void)\n \n /* Returns latch edge of LOOP.  */\n edge\n-loop_latch_edge (const struct loop *loop)\n+loop_latch_edge (const class loop *loop)\n {\n   return find_edge (loop->latch, loop->header);\n }\n \n /* Returns preheader edge of LOOP.  */\n edge\n-loop_preheader_edge (const struct loop *loop)\n+loop_preheader_edge (const class loop *loop)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1758,7 +1758,7 @@ loop_preheader_edge (const struct loop *loop)\n /* Returns true if E is an exit of LOOP.  */\n \n bool\n-loop_exit_edge_p (const struct loop *loop, const_edge e)\n+loop_exit_edge_p (const class loop *loop, const_edge e)\n {\n   return (flow_bb_inside_loop_p (loop, e->src)\n \t  && !flow_bb_inside_loop_p (loop, e->dest));\n@@ -1769,7 +1769,7 @@ loop_exit_edge_p (const struct loop *loop, const_edge e)\n    is returned always.  */\n \n edge\n-single_exit (const struct loop *loop)\n+single_exit (const class loop *loop)\n {\n   struct loop_exit *exit = loop->exits->next;\n \n@@ -1785,7 +1785,7 @@ single_exit (const struct loop *loop)\n /* Returns true when BB has an incoming edge exiting LOOP.  */\n \n bool\n-loop_exits_to_bb_p (struct loop *loop, basic_block bb)\n+loop_exits_to_bb_p (class loop *loop, basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1800,7 +1800,7 @@ loop_exits_to_bb_p (struct loop *loop, basic_block bb)\n /* Returns true when BB has an outgoing edge exiting LOOP.  */\n \n bool\n-loop_exits_from_bb_p (struct loop *loop, basic_block bb)\n+loop_exits_from_bb_p (class loop *loop, basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1815,10 +1815,10 @@ loop_exits_from_bb_p (struct loop *loop, basic_block bb)\n /* Return location corresponding to the loop control condition if possible.  */\n \n dump_user_location_t\n-get_loop_location (struct loop *loop)\n+get_loop_location (class loop *loop)\n {\n   rtx_insn *insn = NULL;\n-  struct niter_desc *desc = NULL;\n+  class niter_desc *desc = NULL;\n   edge exit;\n \n   /* For a for or while loop, we would like to return the location\n@@ -1869,7 +1869,7 @@ get_loop_location (struct loop *loop)\n    I_BOUND times.  */\n \n void\n-record_niter_bound (struct loop *loop, const widest_int &i_bound,\n+record_niter_bound (class loop *loop, const widest_int &i_bound,\n \t\t    bool realistic, bool upper)\n {\n   /* Update the bounds only when there is no previous estimation, or when the\n@@ -1920,7 +1920,7 @@ record_niter_bound (struct loop *loop, const widest_int &i_bound,\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-get_estimated_loop_iterations_int (struct loop *loop)\n+get_estimated_loop_iterations_int (class loop *loop)\n {\n   widest_int nit;\n   HOST_WIDE_INT hwi_nit;\n@@ -1940,7 +1940,7 @@ get_estimated_loop_iterations_int (struct loop *loop)\n    the number of execution of the latch by one.  */\n \n HOST_WIDE_INT\n-max_stmt_executions_int (struct loop *loop)\n+max_stmt_executions_int (class loop *loop)\n {\n   HOST_WIDE_INT nit = get_max_loop_iterations_int (loop);\n   HOST_WIDE_INT snit;\n@@ -1959,7 +1959,7 @@ max_stmt_executions_int (struct loop *loop)\n    the number of execution of the latch by one.  */\n \n HOST_WIDE_INT\n-likely_max_stmt_executions_int (struct loop *loop)\n+likely_max_stmt_executions_int (class loop *loop)\n {\n   HOST_WIDE_INT nit = get_likely_max_loop_iterations_int (loop);\n   HOST_WIDE_INT snit;\n@@ -1978,7 +1978,7 @@ likely_max_stmt_executions_int (struct loop *loop)\n    returns true.  */\n \n bool\n-get_estimated_loop_iterations (struct loop *loop, widest_int *nit)\n+get_estimated_loop_iterations (class loop *loop, widest_int *nit)\n {\n   /* Even if the bound is not recorded, possibly we can derrive one from\n      profile.  */\n@@ -2002,7 +2002,7 @@ get_estimated_loop_iterations (struct loop *loop, widest_int *nit)\n    false, otherwise returns true.  */\n \n bool\n-get_max_loop_iterations (const struct loop *loop, widest_int *nit)\n+get_max_loop_iterations (const class loop *loop, widest_int *nit)\n {\n   if (!loop->any_upper_bound)\n     return false;\n@@ -2016,7 +2016,7 @@ get_max_loop_iterations (const struct loop *loop, widest_int *nit)\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-get_max_loop_iterations_int (const struct loop *loop)\n+get_max_loop_iterations_int (const class loop *loop)\n {\n   widest_int nit;\n   HOST_WIDE_INT hwi_nit;\n@@ -2036,7 +2036,7 @@ get_max_loop_iterations_int (const struct loop *loop)\n    false, otherwise returns true.  */\n \n bool\n-get_likely_max_loop_iterations (struct loop *loop, widest_int *nit)\n+get_likely_max_loop_iterations (class loop *loop, widest_int *nit)\n {\n   if (!loop->any_likely_upper_bound)\n     return false;\n@@ -2050,7 +2050,7 @@ get_likely_max_loop_iterations (struct loop *loop, widest_int *nit)\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-get_likely_max_loop_iterations_int (struct loop *loop)\n+get_likely_max_loop_iterations_int (class loop *loop)\n {\n   widest_int nit;\n   HOST_WIDE_INT hwi_nit;"}, {"sha": "0b0154ffd7bf031a005de993b101d9db6dd98c43", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -66,7 +66,7 @@ class GTY ((chain_next (\"%h.next\"))) nb_iter_bound {\n   bool is_exit;\n \n   /* The next bound in the list.  */\n-  struct nb_iter_bound *next;\n+  class nb_iter_bound *next;\n };\n \n /* Description of the loop exit.  */\n@@ -92,7 +92,7 @@ struct loop_exit_hasher : ggc_ptr_hash<loop_exit>\n   static void remove (loop_exit *);\n };\n \n-typedef struct loop *loop_p;\n+typedef class loop *loop_p;\n \n /* An integer estimation of the number of iterations.  Estimate_state\n    describes what is the state of the estimation.  */\n@@ -142,10 +142,10 @@ class GTY ((chain_next (\"%h.next\"))) loop {\n   vec<loop_p, va_gc> *superloops;\n \n   /* The first inner (child) loop or NULL if innermost loop.  */\n-  struct loop *inner;\n+  class loop *inner;\n \n   /* Link to the next (sibling) loop.  */\n-  struct loop *next;\n+  class loop *next;\n \n   /* Auxiliary info specific to a pass.  */\n   PTR GTY ((skip (\"\"))) aux;\n@@ -252,7 +252,7 @@ class GTY ((chain_next (\"%h.next\"))) loop {\n   int orig_loop_num;\n \n   /* Upper bound on number of iterations of a loop.  */\n-  struct nb_iter_bound *bounds;\n+  class nb_iter_bound *bounds;\n \n   /* Non-overflow control ivs of a loop.  */\n   struct control_iv *control_ivs;\n@@ -261,7 +261,7 @@ class GTY ((chain_next (\"%h.next\"))) loop {\n   struct loop_exit *exits;\n \n   /* Number of iteration analysis data for RTL.  */\n-  struct niter_desc *simple_loop_desc;\n+  class niter_desc *simple_loop_desc;\n \n   /* For sanity checking during loop fixup we record here the former\n      loop header for loops marked for removal.  Note that this prevents\n@@ -277,21 +277,21 @@ class GTY ((chain_next (\"%h.next\"))) loop {\n \n /* Set C to the LOOP constraint.  */\n static inline void\n-loop_constraint_set (struct loop *loop, unsigned c)\n+loop_constraint_set (class loop *loop, unsigned c)\n {\n   loop->constraints |= c;\n }\n \n /* Clear C from the LOOP constraint.  */\n static inline void\n-loop_constraint_clear (struct loop *loop, unsigned c)\n+loop_constraint_clear (class loop *loop, unsigned c)\n {\n   loop->constraints &= ~c;\n }\n \n /* Check if C is set in the LOOP constraint.  */\n static inline bool\n-loop_constraint_set_p (struct loop *loop, unsigned c)\n+loop_constraint_set_p (class loop *loop, unsigned c)\n {\n   return (loop->constraints & c) == c;\n }\n@@ -327,7 +327,7 @@ struct GTY (()) loops {\n   hash_table<loop_exit_hasher> *GTY(()) exits;\n \n   /* Pointer to root of loop hierarchy tree.  */\n-  struct loop *tree_root;\n+  class loop *tree_root;\n };\n \n /* Loop recognition.  */\n@@ -337,12 +337,12 @@ extern struct loops *flow_loops_find (struct loops *);\n extern void disambiguate_loops_with_multiple_latches (void);\n extern void flow_loops_free (struct loops *);\n extern void flow_loops_dump (FILE *,\n-\t\t\t     void (*)(const struct loop *, FILE *, int), int);\n-extern void flow_loop_dump (const struct loop *, FILE *,\n-\t\t\t    void (*)(const struct loop *, FILE *, int), int);\n-struct loop *alloc_loop (void);\n-extern void flow_loop_free (struct loop *);\n-int flow_loop_nodes_find (basic_block, struct loop *);\n+\t\t\t     void (*)(const class loop *, FILE *, int), int);\n+extern void flow_loop_dump (const class loop *, FILE *,\n+\t\t\t    void (*)(const class loop *, FILE *, int), int);\n+class loop *alloc_loop (void);\n+extern void flow_loop_free (class loop *);\n+int flow_loop_nodes_find (basic_block, class loop *);\n unsigned fix_loop_structure (bitmap changed_bbs);\n bool mark_irreducible_loops (void);\n void release_recorded_exits (function *);\n@@ -351,54 +351,54 @@ void rescan_loop_exit (edge, bool, bool);\n void sort_sibling_loops (function *);\n \n /* Loop data structure manipulation/querying.  */\n-extern void flow_loop_tree_node_add (struct loop *, struct loop *,\n-\t\t\t\t     struct loop * = NULL);\n-extern void flow_loop_tree_node_remove (struct loop *);\n-extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n-extern bool flow_bb_inside_loop_p (const struct loop *, const_basic_block);\n-extern struct loop * find_common_loop (struct loop *, struct loop *);\n-struct loop *superloop_at_depth (struct loop *, unsigned);\n+extern void flow_loop_tree_node_add (class loop *, class loop *,\n+\t\t\t\t     class loop * = NULL);\n+extern void flow_loop_tree_node_remove (class loop *);\n+extern bool flow_loop_nested_p\t(const class loop *, const class loop *);\n+extern bool flow_bb_inside_loop_p (const class loop *, const_basic_block);\n+extern class loop * find_common_loop (class loop *, class loop *);\n+class loop *superloop_at_depth (class loop *, unsigned);\n struct eni_weights;\n-extern int num_loop_insns (const struct loop *);\n-extern int average_num_loop_insns (const struct loop *);\n-extern unsigned get_loop_level (const struct loop *);\n-extern bool loop_exit_edge_p (const struct loop *, const_edge);\n-extern bool loop_exits_to_bb_p (struct loop *, basic_block);\n-extern bool loop_exits_from_bb_p (struct loop *, basic_block);\n+extern int num_loop_insns (const class loop *);\n+extern int average_num_loop_insns (const class loop *);\n+extern unsigned get_loop_level (const class loop *);\n+extern bool loop_exit_edge_p (const class loop *, const_edge);\n+extern bool loop_exits_to_bb_p (class loop *, basic_block);\n+extern bool loop_exits_from_bb_p (class loop *, basic_block);\n extern void mark_loop_exit_edges (void);\n-extern dump_user_location_t get_loop_location (struct loop *loop);\n+extern dump_user_location_t get_loop_location (class loop *loop);\n \n /* Loops & cfg manipulation.  */\n-extern basic_block *get_loop_body (const struct loop *);\n-extern unsigned get_loop_body_with_size (const struct loop *, basic_block *,\n+extern basic_block *get_loop_body (const class loop *);\n+extern unsigned get_loop_body_with_size (const class loop *, basic_block *,\n \t\t\t\t\t unsigned);\n-extern basic_block *get_loop_body_in_dom_order (const struct loop *);\n-extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n-extern basic_block *get_loop_body_in_custom_order (const struct loop *,\n+extern basic_block *get_loop_body_in_dom_order (const class loop *);\n+extern basic_block *get_loop_body_in_bfs_order (const class loop *);\n+extern basic_block *get_loop_body_in_custom_order (const class loop *,\n \t\t\t       int (*) (const void *, const void *));\n \n-extern vec<edge> get_loop_exit_edges (const struct loop *);\n-extern edge single_exit (const struct loop *);\n-extern edge single_likely_exit (struct loop *loop);\n-extern unsigned num_loop_branches (const struct loop *);\n+extern vec<edge> get_loop_exit_edges (const class loop *);\n+extern edge single_exit (const class loop *);\n+extern edge single_likely_exit (class loop *loop);\n+extern unsigned num_loop_branches (const class loop *);\n \n-extern edge loop_preheader_edge (const struct loop *);\n-extern edge loop_latch_edge (const struct loop *);\n+extern edge loop_preheader_edge (const class loop *);\n+extern edge loop_latch_edge (const class loop *);\n \n-extern void add_bb_to_loop (basic_block, struct loop *);\n+extern void add_bb_to_loop (basic_block, class loop *);\n extern void remove_bb_from_loops (basic_block);\n \n-extern void cancel_loop_tree (struct loop *);\n-extern void delete_loop (struct loop *);\n+extern void cancel_loop_tree (class loop *);\n+extern void delete_loop (class loop *);\n \n \n extern void verify_loop_structure (void);\n \n /* Loop analysis.  */\n-extern bool just_once_each_iteration_p (const struct loop *, const_basic_block);\n-gcov_type expected_loop_iterations_unbounded (const struct loop *,\n+extern bool just_once_each_iteration_p (const class loop *, const_basic_block);\n+gcov_type expected_loop_iterations_unbounded (const class loop *,\n \t\t\t\t\t      bool *read_profile_p = NULL, bool by_profile_only = false);\n-extern unsigned expected_loop_iterations (struct loop *);\n+extern unsigned expected_loop_iterations (class loop *);\n extern rtx doloop_condition_get (rtx_insn *);\n \n void mark_loop_for_removal (loop_p);\n@@ -490,21 +490,21 @@ class GTY(()) niter_desc\n   rtx niter_expr;\n };\n \n-extern void iv_analysis_loop_init (struct loop *);\n-extern bool iv_analyze (rtx_insn *, scalar_int_mode, rtx, struct rtx_iv *);\n-extern bool iv_analyze_result (rtx_insn *, rtx, struct rtx_iv *);\n+extern void iv_analysis_loop_init (class loop *);\n+extern bool iv_analyze (rtx_insn *, scalar_int_mode, rtx, class rtx_iv *);\n+extern bool iv_analyze_result (rtx_insn *, rtx, class rtx_iv *);\n extern bool iv_analyze_expr (rtx_insn *, scalar_int_mode, rtx,\n-\t\t\t     struct rtx_iv *);\n-extern rtx get_iv_value (struct rtx_iv *, rtx);\n+\t\t\t     class rtx_iv *);\n+extern rtx get_iv_value (class rtx_iv *, rtx);\n extern bool biv_p (rtx_insn *, scalar_int_mode, rtx);\n-extern void find_simple_exit (struct loop *, struct niter_desc *);\n+extern void find_simple_exit (class loop *, class niter_desc *);\n extern void iv_analysis_done (void);\n \n-extern struct niter_desc *get_simple_loop_desc (struct loop *loop);\n-extern void free_simple_loop_desc (struct loop *loop);\n+extern class niter_desc *get_simple_loop_desc (class loop *loop);\n+extern void free_simple_loop_desc (class loop *loop);\n \n-static inline struct niter_desc *\n-simple_loop_desc (struct loop *loop)\n+static inline class niter_desc *\n+simple_loop_desc (class loop *loop)\n {\n   return loop->simple_loop_desc;\n }\n@@ -513,7 +513,7 @@ simple_loop_desc (struct loop *loop)\n \n /* Returns the loop with index NUM from FNs loop tree.  */\n \n-static inline struct loop *\n+static inline class loop *\n get_loop (struct function *fn, unsigned num)\n {\n   return (*loops_for_fn (fn)->larray)[num];\n@@ -522,16 +522,16 @@ get_loop (struct function *fn, unsigned num)\n /* Returns the number of superloops of LOOP.  */\n \n static inline unsigned\n-loop_depth (const struct loop *loop)\n+loop_depth (const class loop *loop)\n {\n   return vec_safe_length (loop->superloops);\n }\n \n /* Returns the immediate superloop of LOOP, or NULL if LOOP is the outermost\n    loop.  */\n \n-static inline struct loop *\n-loop_outer (const struct loop *loop)\n+static inline class loop *\n+loop_outer (const class loop *loop)\n {\n   unsigned n = vec_safe_length (loop->superloops);\n \n@@ -544,7 +544,7 @@ loop_outer (const struct loop *loop)\n /* Returns true if LOOP has at least one exit edge.  */\n \n static inline bool\n-loop_has_exit_edges (const struct loop *loop)\n+loop_has_exit_edges (const class loop *loop)\n {\n   return loop->exits->next->e != NULL;\n }\n@@ -692,7 +692,7 @@ loop_iterator::next ()\n inline\n loop_iterator::loop_iterator (function *fn, loop_p *loop, unsigned flags)\n {\n-  struct loop *aloop;\n+  class loop *aloop;\n   unsigned i;\n   int mn;\n \n@@ -843,11 +843,11 @@ enum\n \n extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n-extern vec<basic_block> get_loop_hot_path (const struct loop *loop);\n+extern vec<basic_block> get_loop_hot_path (const class loop *loop);\n \n /* Returns the outermost loop of the loop nest that contains LOOP.*/\n-static inline struct loop *\n-loop_outermost (struct loop *loop)\n+static inline class loop *\n+loop_outermost (class loop *loop)\n {\n   unsigned n = vec_safe_length (loop->superloops);\n \n@@ -857,13 +857,13 @@ loop_outermost (struct loop *loop)\n   return (*loop->superloops)[1];\n }\n \n-extern void record_niter_bound (struct loop *, const widest_int &, bool, bool);\n-extern HOST_WIDE_INT get_estimated_loop_iterations_int (struct loop *);\n-extern HOST_WIDE_INT get_max_loop_iterations_int (const struct loop *);\n-extern HOST_WIDE_INT get_likely_max_loop_iterations_int (struct loop *);\n-extern bool get_estimated_loop_iterations (struct loop *loop, widest_int *nit);\n-extern bool get_max_loop_iterations (const struct loop *loop, widest_int *nit);\n-extern bool get_likely_max_loop_iterations (struct loop *loop, widest_int *nit);\n+extern void record_niter_bound (class loop *, const widest_int &, bool, bool);\n+extern HOST_WIDE_INT get_estimated_loop_iterations_int (class loop *);\n+extern HOST_WIDE_INT get_max_loop_iterations_int (const class loop *);\n+extern HOST_WIDE_INT get_likely_max_loop_iterations_int (class loop *);\n+extern bool get_estimated_loop_iterations (class loop *loop, widest_int *nit);\n+extern bool get_max_loop_iterations (const class loop *loop, widest_int *nit);\n+extern bool get_likely_max_loop_iterations (class loop *loop, widest_int *nit);\n extern int bb_loop_depth (const_basic_block);\n \n /* Converts VAL to widest_int.  */"}, {"sha": "10037f0b1b006a95b98ac0b13f2d11cd0b914911", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -41,7 +41,7 @@ struct target_cfgloop *this_target_cfgloop = &default_target_cfgloop;\n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n \n bool\n-just_once_each_iteration_p (const struct loop *loop, const_basic_block bb)\n+just_once_each_iteration_p (const class loop *loop, const_basic_block bb)\n {\n   /* It must be executed at least once each iteration.  */\n   if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n@@ -81,7 +81,7 @@ mark_irreducible_loops (void)\n   unsigned depth;\n   struct graph *g;\n   int num = number_of_loops (cfun);\n-  struct loop *cloop;\n+  class loop *cloop;\n   bool irred_loop_found = false;\n   int i;\n \n@@ -173,7 +173,7 @@ mark_irreducible_loops (void)\n \n /* Counts number of insns inside LOOP.  */\n int\n-num_loop_insns (const struct loop *loop)\n+num_loop_insns (const class loop *loop)\n {\n   basic_block *bbs, bb;\n   unsigned i, ninsns = 0;\n@@ -197,7 +197,7 @@ num_loop_insns (const struct loop *loop)\n \n /* Counts number of insns executed on average per iteration LOOP.  */\n int\n-average_num_loop_insns (const struct loop *loop)\n+average_num_loop_insns (const class loop *loop)\n {\n   basic_block *bbs, bb;\n   unsigned i, binsns;\n@@ -238,7 +238,7 @@ average_num_loop_insns (const struct loop *loop)\n    return -1 in those scenarios.  */\n \n gcov_type\n-expected_loop_iterations_unbounded (const struct loop *loop,\n+expected_loop_iterations_unbounded (const class loop *loop,\n \t\t\t\t    bool *read_profile_p,\n \t\t\t\t    bool by_profile_only)\n {\n@@ -310,7 +310,7 @@ expected_loop_iterations_unbounded (const struct loop *loop,\n    by REG_BR_PROB_BASE.  */\n \n unsigned\n-expected_loop_iterations (struct loop *loop)\n+expected_loop_iterations (class loop *loop)\n {\n   gcov_type expected = expected_loop_iterations_unbounded (loop);\n   return (expected > REG_BR_PROB_BASE ? REG_BR_PROB_BASE : expected);\n@@ -319,9 +319,9 @@ expected_loop_iterations (struct loop *loop)\n /* Returns the maximum level of nesting of subloops of LOOP.  */\n \n unsigned\n-get_loop_level (const struct loop *loop)\n+get_loop_level (const class loop *loop)\n {\n-  const struct loop *ploop;\n+  const class loop *ploop;\n   unsigned mx = 0, l;\n \n   for (ploop = loop->inner; ploop; ploop = ploop->next)\n@@ -463,7 +463,7 @@ mark_loop_exit_edges (void)\n    to noreturn call.  */\n \n edge\n-single_likely_exit (struct loop *loop)\n+single_likely_exit (class loop *loop)\n {\n   edge found = single_exit (loop);\n   vec<edge> exits;\n@@ -500,7 +500,7 @@ single_likely_exit (struct loop *loop)\n    header != latch, latch is the 1-st block.  */\n \n vec<basic_block>\n-get_loop_hot_path (const struct loop *loop)\n+get_loop_hot_path (const class loop *loop)\n {\n   basic_block bb = loop->header;\n   vec<basic_block> path = vNULL;"}, {"sha": "727e951edeae7bcbf7d4122c66abe68c6334c12e", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -32,13 +32,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop-manip.h\"\n #include \"dumpfile.h\"\n \n-static void copy_loops_to (struct loop **, int,\n-\t\t\t   struct loop *);\n+static void copy_loops_to (class loop **, int,\n+\t\t\t   class loop *);\n static void loop_redirect_edge (edge, basic_block);\n static void remove_bbs (basic_block *, int);\n static bool rpe_enum_p (const_basic_block, const void *);\n static int find_path (edge, basic_block **);\n-static void fix_loop_placements (struct loop *, bool *);\n+static void fix_loop_placements (class loop *, bool *);\n static bool fix_bb_placement (basic_block);\n static void fix_bb_placements (basic_block, bool *, bitmap);\n \n@@ -89,7 +89,7 @@ fix_bb_placement (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n-  struct loop *loop = current_loops->tree_root, *act;\n+  class loop *loop = current_loops->tree_root, *act;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n@@ -122,12 +122,12 @@ fix_bb_placement (basic_block bb)\n    invalidate the information about irreducible regions.  */\n \n static bool\n-fix_loop_placement (struct loop *loop, bool *irred_invalidated)\n+fix_loop_placement (class loop *loop, bool *irred_invalidated)\n {\n   unsigned i;\n   edge e;\n   vec<edge> exits = get_loop_exit_edges (loop);\n-  struct loop *father = current_loops->tree_root, *act;\n+  class loop *father = current_loops->tree_root, *act;\n   bool ret = false;\n \n   FOR_EACH_VEC_ELT (exits, i, e)\n@@ -182,7 +182,7 @@ fix_bb_placements (basic_block from,\n \t\t   bitmap loop_closed_ssa_invalidated)\n {\n   basic_block *queue, *qtop, *qbeg, *qend;\n-  struct loop *base_loop, *target_loop;\n+  class loop *base_loop, *target_loop;\n   edge e;\n \n   /* We pass through blocks back-reachable from FROM, testing whether some\n@@ -255,7 +255,7 @@ fix_bb_placements (basic_block from,\n       FOR_EACH_EDGE (e, ei, from->preds)\n \t{\n \t  basic_block pred = e->src;\n-\t  struct loop *nca;\n+\t  class loop *nca;\n \n \t  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n \t    *irred_invalidated = true;\n@@ -307,7 +307,7 @@ remove_path (edge e, bool *irred_invalidated,\n   int i, nrem, n_bord_bbs;\n   bool local_irred_invalidated = false;\n   edge_iterator ei;\n-  struct loop *l, *f;\n+  class loop *l, *f;\n \n   if (! irred_invalidated)\n     irred_invalidated = &local_irred_invalidated;\n@@ -427,7 +427,7 @@ remove_path (edge e, bool *irred_invalidated,\n /* Creates place for a new LOOP in loops structure of FN.  */\n \n void\n-place_new_loop (struct function *fn, struct loop *loop)\n+place_new_loop (struct function *fn, class loop *loop)\n {\n   loop->num = number_of_loops (fn);\n   vec_safe_push (loops_for_fn (fn)->larray, loop);\n@@ -438,11 +438,11 @@ place_new_loop (struct function *fn, struct loop *loop)\n    outer.  */\n \n void\n-add_loop (struct loop *loop, struct loop *outer)\n+add_loop (class loop *loop, class loop *outer)\n {\n   basic_block *bbs;\n   int i, n;\n-  struct loop *subloop;\n+  class loop *subloop;\n   edge e;\n   edge_iterator ei;\n \n@@ -490,7 +490,7 @@ add_loop (struct loop *loop, struct loop *outer)\n /* Scale profile of loop by P.  */\n \n void\n-scale_loop_frequencies (struct loop *loop, profile_probability p)\n+scale_loop_frequencies (class loop *loop, profile_probability p)\n {\n   basic_block *bbs;\n \n@@ -508,7 +508,7 @@ scale_loop_frequencies (struct loop *loop, profile_probability p)\n    they need to be scaled synchronously.  */\n \n void\n-scale_loop_profile (struct loop *loop, profile_probability p,\n+scale_loop_profile (class loop *loop, profile_probability p,\n \t\t    gcov_type iteration_bound)\n {\n   edge e, preheader_e;\n@@ -618,7 +618,7 @@ scale_loop_profile (struct loop *loop, profile_probability p,\n /* Recompute dominance information for basic blocks outside LOOP.  */\n \n static void\n-update_dominators_in_loop (struct loop *loop)\n+update_dominators_in_loop (class loop *loop)\n {\n   vec<basic_block> dom_bbs = vNULL;\n   basic_block *body;\n@@ -763,17 +763,17 @@ create_empty_if_region_on_edge (edge entry_edge, tree condition)\n    should be used only when the UPPER_BOUND expression is a loop\n    invariant.  */\n \n-struct loop *\n+class loop *\n create_empty_loop_on_edge (edge entry_edge,\n \t\t\t   tree initial_value,\n \t\t\t   tree stride, tree upper_bound,\n \t\t\t   tree iv,\n \t\t\t   tree *iv_before,\n \t\t\t   tree *iv_after,\n-\t\t\t   struct loop *outer)\n+\t\t\t   class loop *outer)\n {\n   basic_block loop_header, loop_latch, succ_bb, pred_bb;\n-  struct loop *loop;\n+  class loop *loop;\n   gimple_stmt_iterator gsi;\n   gimple_seq stmts;\n   gcond *cond_expr;\n@@ -857,16 +857,16 @@ create_empty_loop_on_edge (edge entry_edge,\n    Returns the newly created loop.  Frequencies and counts in the new loop\n    are scaled by FALSE_SCALE and in the old one by TRUE_SCALE.  */\n \n-struct loop *\n+class loop *\n loopify (edge latch_edge, edge header_edge,\n \t basic_block switch_bb, edge true_edge, edge false_edge,\n \t bool redirect_all_edges, profile_probability true_scale,\n \t profile_probability false_scale)\n {\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n-  struct loop *loop = alloc_loop ();\n-  struct loop *outer = loop_outer (succ_bb->loop_father);\n+  class loop *loop = alloc_loop ();\n+  class loop *outer = loop_outer (succ_bb->loop_father);\n   profile_count cnt;\n \n   loop->header = header_edge->dest;\n@@ -923,11 +923,11 @@ loopify (edge latch_edge, edge header_edge,\n    basic blocks that had non-trivial update on their loop_father.*/\n \n void\n-unloop (struct loop *loop, bool *irred_invalidated,\n+unloop (class loop *loop, bool *irred_invalidated,\n \tbitmap loop_closed_ssa_invalidated)\n {\n   basic_block *body;\n-  struct loop *ploop;\n+  class loop *ploop;\n   unsigned i, n;\n   basic_block latch = loop->latch;\n   bool dummy = false;\n@@ -978,9 +978,9 @@ unloop (struct loop *loop, bool *irred_invalidated,\n    invalidate the information about irreducible regions.  */\n \n static void\n-fix_loop_placements (struct loop *loop, bool *irred_invalidated)\n+fix_loop_placements (class loop *loop, bool *irred_invalidated)\n {\n-  struct loop *outer;\n+  class loop *outer;\n \n   while (loop_outer (loop))\n     {\n@@ -1003,7 +1003,7 @@ fix_loop_placements (struct loop *loop, bool *irred_invalidated)\n    the loop into its duplicate.  */\n \n void\n-copy_loop_info (struct loop *loop, struct loop *target)\n+copy_loop_info (class loop *loop, class loop *target)\n {\n   gcc_checking_assert (!target->any_upper_bound && !target->any_estimate);\n   target->any_upper_bound = loop->any_upper_bound;\n@@ -1031,10 +1031,10 @@ copy_loop_info (struct loop *loop, struct loop *target)\n    created loop into loops structure.  If AFTER is non-null\n    the new loop is added at AFTER->next, otherwise in front of TARGETs\n    sibling list.  */\n-struct loop *\n-duplicate_loop (struct loop *loop, struct loop *target, struct loop *after)\n+class loop *\n+duplicate_loop (class loop *loop, class loop *target, class loop *after)\n {\n-  struct loop *cloop;\n+  class loop *cloop;\n   cloop = alloc_loop ();\n   place_new_loop (cfun, cloop);\n  \n@@ -1053,9 +1053,9 @@ duplicate_loop (struct loop *loop, struct loop *target, struct loop *after)\n    newly created loops into loop tree at the end of TARGETs sibling\n    list in the original order.  */\n void\n-duplicate_subloops (struct loop *loop, struct loop *target)\n+duplicate_subloops (class loop *loop, class loop *target)\n {\n-  struct loop *aloop, *cloop, *tail;\n+  class loop *aloop, *cloop, *tail;\n \n   for (tail = target->inner; tail && tail->next; tail = tail->next)\n     ;\n@@ -1072,9 +1072,9 @@ duplicate_subloops (struct loop *loop, struct loop *target)\n    into TARGET loop, placing newly created loops into loop tree adding\n    them to TARGETs sibling list at the end in order.  */\n static void\n-copy_loops_to (struct loop **copied_loops, int n, struct loop *target)\n+copy_loops_to (class loop **copied_loops, int n, class loop *target)\n {\n-  struct loop *aloop, *tail;\n+  class loop *aloop, *tail;\n   int i;\n \n   for (tail = target->inner; tail && tail->next; tail = tail->next)\n@@ -1100,7 +1100,7 @@ loop_redirect_edge (edge e, basic_block dest)\n \n /* Check whether LOOP's body can be duplicated.  */\n bool\n-can_duplicate_loop_p (const struct loop *loop)\n+can_duplicate_loop_p (const class loop *loop)\n {\n   int ret;\n   basic_block *bbs = get_loop_body (loop);\n@@ -1124,13 +1124,13 @@ can_duplicate_loop_p (const struct loop *loop)\n    impossible.  */\n \n bool\n-duplicate_loop_to_header_edge (struct loop *loop, edge e,\n+duplicate_loop_to_header_edge (class loop *loop, edge e,\n \t\t\t       unsigned int ndupl, sbitmap wont_exit,\n \t\t\t       edge orig, vec<edge> *to_remove,\n \t\t\t       int flags)\n {\n-  struct loop *target, *aloop;\n-  struct loop **orig_loops;\n+  class loop *target, *aloop;\n+  class loop **orig_loops;\n   unsigned n_orig_loops;\n   basic_block header = loop->header, latch = loop->latch;\n   basic_block *new_bbs, *bbs, *first_active;\n@@ -1276,7 +1276,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   n_orig_loops = 0;\n   for (aloop = loop->inner; aloop; aloop = aloop->next)\n     n_orig_loops++;\n-  orig_loops = XNEWVEC (struct loop *, n_orig_loops);\n+  orig_loops = XNEWVEC (class loop *, n_orig_loops);\n   for (aloop = loop->inner, i = 0; aloop; aloop = aloop->next, i++)\n     orig_loops[i] = aloop;\n \n@@ -1453,7 +1453,7 @@ mfb_keep_just (edge e)\n /* True when a candidate preheader BLOCK has predecessors from LOOP.  */\n \n static bool\n-has_preds_from_loop (basic_block block, struct loop *loop)\n+has_preds_from_loop (basic_block block, class loop *loop)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1473,7 +1473,7 @@ has_preds_from_loop (basic_block block, struct loop *loop)\n    The function also updates dominators.  */\n \n basic_block\n-create_preheader (struct loop *loop, int flags)\n+create_preheader (class loop *loop, int flags)\n {\n   edge e;\n   basic_block dummy;\n@@ -1573,7 +1573,7 @@ create_preheader (struct loop *loop, int flags)\n void\n create_preheaders (int flags)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   if (!current_loops)\n     return;\n@@ -1588,7 +1588,7 @@ create_preheaders (int flags)\n void\n force_single_succ_latches (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   edge e;\n \n   FOR_EACH_LOOP (loop, 0)\n@@ -1677,8 +1677,8 @@ lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n    If PLACE_AFTER is true, we place the new loop after LOOP in the\n    instruction stream, otherwise it is placed before LOOP.  */\n \n-struct loop *\n-loop_version (struct loop *loop,\n+class loop *\n+loop_version (class loop *loop,\n \t      void *cond_expr, basic_block *condition_bb,\n \t      profile_probability then_prob, profile_probability else_prob,\n \t      profile_probability then_scale, profile_probability else_scale,\n@@ -1687,7 +1687,7 @@ loop_version (struct loop *loop,\n   basic_block first_head, second_head;\n   edge entry, latch_edge, true_edge, false_edge;\n   int irred_flag;\n-  struct loop *nloop;\n+  class loop *nloop;\n   basic_block cond_bb;\n \n   /* Record entry and latch edges for the loop */"}, {"sha": "d14f49078c0e99a7e45585bb5728c34bfdecc5c5", "filename": "gcc/cfgloopmanip.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloopmanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcfgloopmanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -35,30 +35,30 @@ enum\n extern edge mfb_kj_edge;\n \n extern bool remove_path (edge, bool * = NULL, bitmap = NULL);\n-extern void place_new_loop (struct function *, struct loop *);\n-extern void add_loop (struct loop *, struct loop *);\n-extern void scale_loop_frequencies (struct loop *, profile_probability);\n-extern void scale_loop_profile (struct loop *, profile_probability, gcov_type);\n+extern void place_new_loop (struct function *, class loop *);\n+extern void add_loop (class loop *, class loop *);\n+extern void scale_loop_frequencies (class loop *, profile_probability);\n+extern void scale_loop_profile (class loop *, profile_probability, gcov_type);\n extern edge create_empty_if_region_on_edge (edge, tree);\n-extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n-\t\t\t\t\t       tree *, tree *, struct loop *);\n-extern struct loop *loopify (edge, edge,\n+extern class loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n+\t\t\t\t\t       tree *, tree *, class loop *);\n+extern class loop *loopify (edge, edge,\n \t\t\t     basic_block, edge, edge, bool,\n \t\t\t     profile_probability, profile_probability);\n-extern void unloop (struct loop *, bool *, bitmap);\n-extern void copy_loop_info (struct loop *loop, struct loop *target);\n-extern struct loop * duplicate_loop (struct loop *, struct loop *,\n-\t\t\t\t     struct loop * = NULL);\n-extern void duplicate_subloops (struct loop *, struct loop *);\n-extern bool can_duplicate_loop_p (const struct loop *loop);\n-extern bool duplicate_loop_to_header_edge (struct loop *, edge,\n+extern void unloop (class loop *, bool *, bitmap);\n+extern void copy_loop_info (class loop *loop, class loop *target);\n+extern class loop * duplicate_loop (class loop *, class loop *,\n+\t\t\t\t     class loop * = NULL);\n+extern void duplicate_subloops (class loop *, class loop *);\n+extern bool can_duplicate_loop_p (const class loop *loop);\n+extern bool duplicate_loop_to_header_edge (class loop *, edge,\n \t\t\t\t\t   unsigned, sbitmap, edge,\n  \t\t\t\t\t   vec<edge> *, int);\n extern bool mfb_keep_just (edge);\n-basic_block create_preheader (struct loop *, int);\n+basic_block create_preheader (class loop *, int);\n extern void create_preheaders (int);\n extern void force_single_succ_latches (void);\n-struct loop * loop_version (struct loop *, void *,\n+class loop * loop_version (class loop *, void *,\n \t\t\t    basic_block *,\n \t\t\t    profile_probability, profile_probability,\n \t\t\t    profile_probability, profile_probability, bool);"}, {"sha": "fa5224fb3a5d7a6115d8a46eedfbeeb8ec99da12", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -912,9 +912,8 @@ struct cgraph_edge_hasher : ggc_ptr_hash<cgraph_edge>\n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n-class GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n+struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n {\n-public:\n   friend class symbol_table;\n \n   /* Remove the node from cgraph and all inline clones inlined into it.\n@@ -1506,7 +1505,7 @@ struct cgraph_node_set_def\n typedef cgraph_node_set_def *cgraph_node_set;\n typedef struct varpool_node_set_def *varpool_node_set;\n \n-class varpool_node;\n+struct varpool_node;\n \n /* A varpool node set is a collection of varpool nodes.  A varpool node\n    can appear in multiple sets.  */\n@@ -1620,7 +1619,7 @@ class GTY(()) ipa_polymorphic_call_context {\n \n   /* LTO streaming.  */\n   void stream_out (struct output_block *) const;\n-  void stream_in (struct lto_input_block *, struct data_in *data_in);\n+  void stream_in (class lto_input_block *, class data_in *data_in);\n \n private:\n   bool combine_speculation_with (tree, HOST_WIDE_INT, bool, tree);\n@@ -1679,7 +1678,7 @@ class GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"),\n \t   for_user)) cgraph_edge\n {\n public:\n-  friend class cgraph_node;\n+  friend struct cgraph_node;\n   friend class symbol_table;\n \n   /* Remove the edge in the cgraph.  */\n@@ -2078,9 +2077,9 @@ struct asmname_hasher : ggc_ptr_hash <symtab_node>\n class GTY((tag (\"SYMTAB\"))) symbol_table\n {\n public:\n-  friend class symtab_node;\n-  friend class cgraph_node;\n-  friend class cgraph_edge;\n+  friend struct symtab_node;\n+  friend struct cgraph_node;\n+  friend struct cgraph_edge;\n \n   symbol_table (): cgraph_max_uid (1), cgraph_max_summary_id (0),\n   edges_max_uid (1), edges_max_summary_id (0)"}, {"sha": "2e7d0b5fe955f3b6304217182ccf554415fc3704", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n struct record_reference_ctx\n {\n   bool only_vars;\n-  class varpool_node *varpool_node;\n+  struct varpool_node *varpool_node;\n };\n \n /* Walk tree and record all calls and references to functions/variables."}, {"sha": "f7b1ebc8cc05b6395c6ecdfac150ab5c14c64a24", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -7829,7 +7829,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      For memory, assume that the desired extraction_mode and pos_mode\n      are the same as for a register operation, since at present we don't\n      have named patterns for aligned memory structures.  */\n-  struct extraction_insn insn;\n+  class extraction_insn insn;\n   unsigned int inner_size;\n   if (GET_MODE_BITSIZE (inner_mode).is_constant (&inner_size)\n       && get_best_reg_extraction_insn (&insn, pattern, inner_size, mode))"}, {"sha": "6ccd42a1874ac244c88c8f2968e4ad0d881fe461", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -152,7 +152,7 @@ const xlogue_layout xlogue_layout::s_instances[XLOGUE_SET_COUNT] = {\n \n /* Return an appropriate const instance of xlogue_layout based upon values\n    in cfun->machine and crtl.  */\n-const struct xlogue_layout &\n+const class xlogue_layout &\n xlogue_layout::get_instance ()\n {\n   enum xlogue_stub_sets stub_set;"}, {"sha": "f2c742fc0f70ba0bf8aff35c3168060822c11ebe", "filename": "gcc/config/i386/i386-features.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfig%2Fi386%2Fi386-features.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfig%2Fi386%2Fi386-features.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -84,7 +84,7 @@ class xlogue_layout {\n     return STUB_INDEX_OFFSET + m_stack_align_off_in;\n   }\n \n-  static const struct xlogue_layout &get_instance ();\n+  static const class xlogue_layout &get_instance ();\n   static unsigned count_stub_managed_regs ();\n   static bool is_stub_managed_reg (unsigned regno, unsigned count);\n "}, {"sha": "e278d9c76dfe418ad499571122947d998fa4a83d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -7689,7 +7689,7 @@ ix86_emit_outlined_ms2sysv_save (const struct ix86_frame &frame)\n   rtx_insn *insn;\n   rtx sym, addr;\n   rtx rax = gen_rtx_REG (word_mode, AX_REG);\n-  const struct xlogue_layout &xlogue = xlogue_layout::get_instance ();\n+  const class xlogue_layout &xlogue = xlogue_layout::get_instance ();\n \n   /* AL should only be live with sysv_abi.  */\n   gcc_assert (!ix86_eax_live_at_start_p ());\n@@ -8492,7 +8492,7 @@ ix86_emit_outlined_ms2sysv_restore (const struct ix86_frame &frame,\n   rtx sym, tmp;\n   rtx rsi = gen_rtx_REG (word_mode, SI_REG);\n   rtx r10 = NULL_RTX;\n-  const struct xlogue_layout &xlogue = xlogue_layout::get_instance ();\n+  const class xlogue_layout &xlogue = xlogue_layout::get_instance ();\n   HOST_WIDE_INT stub_ptr_offset = xlogue.get_stub_ptr_offset ();\n   HOST_WIDE_INT rsi_offset = frame.stack_realign_offset + stub_ptr_offset;\n   rtx rsi_frame_load = NULL_RTX;\n@@ -21503,7 +21503,7 @@ ix86_noce_conversion_profitable_p (rtx_insn *seq, struct noce_if_info *if_info)\n /* Implement targetm.vectorize.init_cost.  */\n \n static void *\n-ix86_init_cost (struct loop *)\n+ix86_init_cost (class loop *)\n {\n   unsigned *cost = XNEWVEC (unsigned, 3);\n   cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n@@ -21514,7 +21514,7 @@ ix86_init_cost (struct loop *)\n \n static unsigned\n ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n-\t\t    struct _stmt_vec_info *stmt_info, int misalign,\n+\t\t    class _stmt_vec_info *stmt_info, int misalign,\n \t\t    enum vect_cost_model_location where)\n {\n   unsigned *cost = (unsigned *) data;\n@@ -21942,7 +21942,7 @@ ix86_simd_clone_usable (struct cgraph_node *node)\n    (value 32 is used) as a heuristic. */\n \n static unsigned\n-ix86_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n+ix86_loop_unroll_adjust (unsigned nunroll, class loop *loop)\n {\n   basic_block *bbs;\n   rtx_insn *insn;"}, {"sha": "c620dd2f44755dac2466952e23568b2b46ba9c96", "filename": "gcc/configure.ac", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -482,7 +482,8 @@ AC_ARG_ENABLE(build-format-warnings,\n AS_IF([test $enable_build_format_warnings = no],\n       [wf_opt=-Wno-format],[wf_opt=])\n ACX_PROG_CXX_WARNING_OPTS(\n-\tm4_quote(m4_do([-W -Wall -Wno-narrowing -Wwrite-strings ],\n+\tm4_quote(m4_do([-W -Wall -Wclass-is-pod -Wmismatched-tags ],\n+\t\t       [-Wno-narrowing -Wstruct-not-pod -Wwrite-strings ],\n \t\t       [-Wcast-qual -Wno-error=format-diag $wf_opt])),\n \t\t       [loose_warn])\n ACX_PROG_CC_WARNING_OPTS("}, {"sha": "eac2f3931aa83d1cc25ce66892939f0634c45eb8", "filename": "gcc/coretypes.h", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -47,9 +47,9 @@ typedef int64_t gcov_type;\n typedef uint64_t gcov_type_unsigned;\n \n struct bitmap_obstack;\n-struct bitmap_head;\n-typedef struct bitmap_head *bitmap;\n-typedef const struct bitmap_head *const_bitmap;\n+class bitmap_head;\n+typedef class bitmap_head *bitmap;\n+typedef const class bitmap_head *const_bitmap;\n struct simple_bitmap_def;\n typedef struct simple_bitmap_def *sbitmap;\n typedef const struct simple_bitmap_def *const_sbitmap;\n@@ -65,27 +65,27 @@ template<typename> class opt_mode;\n typedef opt_mode<scalar_mode> opt_scalar_mode;\n typedef opt_mode<scalar_int_mode> opt_scalar_int_mode;\n typedef opt_mode<scalar_float_mode> opt_scalar_float_mode;\n-template<typename> class pod_mode;\n+template<typename> struct pod_mode;\n typedef pod_mode<scalar_mode> scalar_mode_pod;\n typedef pod_mode<scalar_int_mode> scalar_int_mode_pod;\n typedef pod_mode<fixed_size_mode> fixed_size_mode_pod;\n \n /* Subclasses of rtx_def, using indentation to show the class\n    hierarchy, along with the relevant invariant.\n    Where possible, keep this list in the same order as in rtl.def.  */\n-class rtx_def;\n-  class rtx_expr_list;           /* GET_CODE (X) == EXPR_LIST */\n-  class rtx_insn_list;           /* GET_CODE (X) == INSN_LIST */\n-  class rtx_sequence;            /* GET_CODE (X) == SEQUENCE */\n-  class rtx_insn;\n-    class rtx_debug_insn;      /* DEBUG_INSN_P (X) */\n-    class rtx_nonjump_insn;    /* NONJUMP_INSN_P (X) */\n-    class rtx_jump_insn;       /* JUMP_P (X) */\n-    class rtx_call_insn;       /* CALL_P (X) */\n-    class rtx_jump_table_data; /* JUMP_TABLE_DATA_P (X) */\n-    class rtx_barrier;         /* BARRIER_P (X) */\n-    class rtx_code_label;      /* LABEL_P (X) */\n-    class rtx_note;            /* NOTE_P (X) */\n+struct rtx_def;\n+  struct rtx_expr_list;           /* GET_CODE (X) == EXPR_LIST */\n+  struct rtx_insn_list;           /* GET_CODE (X) == INSN_LIST */\n+  struct rtx_sequence;            /* GET_CODE (X) == SEQUENCE */\n+  struct rtx_insn;\n+    struct rtx_debug_insn;      /* DEBUG_INSN_P (X) */\n+    struct rtx_nonjump_insn;    /* NONJUMP_INSN_P (X) */\n+    struct rtx_jump_insn;       /* JUMP_P (X) */\n+    struct rtx_call_insn;       /* CALL_P (X) */\n+    struct rtx_jump_table_data; /* JUMP_TABLE_DATA_P (X) */\n+    struct rtx_barrier;         /* BARRIER_P (X) */\n+    struct rtx_code_label;      /* LABEL_P (X) */\n+    struct rtx_note;            /* NOTE_P (X) */\n \n struct rtvec_def;\n typedef struct rtvec_def *rtvec;\n@@ -138,9 +138,9 @@ struct gomp_teams;\n /* Subclasses of symtab_node, using indentation to show the class\n    hierarchy.  */\n \n-class symtab_node;\n+struct symtab_node;\n   struct cgraph_node;\n-  class varpool_node;\n+  struct varpool_node;\n \n union section;\n typedef union section section;\n@@ -151,7 +151,7 @@ struct cl_option;\n struct cl_decoded_option;\n struct cl_option_handlers;\n struct diagnostic_context;\n-struct pretty_printer;\n+class pretty_printer;\n \n /* Address space number for named address space support.  */\n typedef unsigned char addr_space_t;\n@@ -298,9 +298,9 @@ enum warn_strict_overflow_code\n    set yet).  */\n typedef int alias_set_type;\n \n-struct edge_def;\n-typedef struct edge_def *edge;\n-typedef const struct edge_def *const_edge;\n+class edge_def;\n+typedef class edge_def *edge;\n+typedef const class edge_def *const_edge;\n struct basic_block_def;\n typedef struct basic_block_def *basic_block;\n typedef const struct basic_block_def *const_basic_block;"}, {"sha": "7609b206fbfdae0fd676194baaa610cf77f2c52e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1,3 +1,10 @@\n+2019-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* cp-tree.h: Change class-key of PODs to struct and others to class.\n+\t* search.c: Same.\n+\t* semantics.c (finalize_nrv_r): Same.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/61339"}, {"sha": "b441af8ff09cb1913106719dc027a739a5573175", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1275,7 +1275,7 @@ tree\n lookup_member_fuzzy (tree xbasetype, tree name, bool want_type_p)\n {\n   tree type = NULL_TREE, basetype_path = NULL_TREE;\n-  struct lookup_field_fuzzy_info lffi (want_type_p);\n+  class lookup_field_fuzzy_info lffi (want_type_p);\n \n   /* rval_binfo is the binfo associated with the found member, note,\n      this can be set with useful information, even when rval is not"}, {"sha": "aadfaffca2adcfeb3a7c3bc61d43cb3fdf3432c7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -4395,7 +4395,7 @@ class nrv_data\n static tree\n finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n {\n-  struct nrv_data *dp = (struct nrv_data *)data;\n+  class nrv_data *dp = (class nrv_data *)data;\n   tree_node **slot;\n \n   /* No need to walk into types.  There wouldn't be any need to walk into\n@@ -4453,7 +4453,7 @@ finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n void\n finalize_nrv (tree *tp, tree var, tree result)\n {\n-  struct nrv_data data;\n+  class nrv_data data;\n \n   /* Copy name from VAR to RESULT.  */\n   DECL_NAME (result) = DECL_NAME (var);"}, {"sha": "11ad084780b21d1481ae26da577b2ebb275bb11b", "filename": "gcc/data-streamer-in.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdata-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdata-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer-in.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n    IB.  Write the length to RLEN.  */\n \n static const char *\n-string_for_index (struct data_in *data_in, unsigned int loc, unsigned int *rlen)\n+string_for_index (class data_in *data_in, unsigned int loc, unsigned int *rlen)\n {\n   unsigned int len;\n   const char *result;\n@@ -62,8 +62,8 @@ string_for_index (struct data_in *data_in, unsigned int loc, unsigned int *rlen)\n    IB.  Write the length to RLEN.  */\n \n const char *\n-streamer_read_indexed_string (struct data_in *data_in,\n-\t\t\t      struct lto_input_block *ib, unsigned int *rlen)\n+streamer_read_indexed_string (class data_in *data_in,\n+\t\t\t      class lto_input_block *ib, unsigned int *rlen)\n {\n   return string_for_index (data_in, streamer_read_uhwi (ib), rlen);\n }\n@@ -72,7 +72,7 @@ streamer_read_indexed_string (struct data_in *data_in,\n /* Read a NULL terminated string from the string table in DATA_IN.  */\n \n const char *\n-streamer_read_string (struct data_in *data_in, struct lto_input_block *ib)\n+streamer_read_string (class data_in *data_in, class lto_input_block *ib)\n {\n   unsigned int len;\n   const char *ptr;\n@@ -91,7 +91,7 @@ streamer_read_string (struct data_in *data_in, struct lto_input_block *ib)\n    Write the length to RLEN.  */\n \n const char *\n-bp_unpack_indexed_string (struct data_in *data_in,\n+bp_unpack_indexed_string (class data_in *data_in,\n \t\t\t  struct bitpack_d *bp, unsigned int *rlen)\n {\n   return string_for_index (data_in, bp_unpack_var_len_unsigned (bp), rlen);\n@@ -101,7 +101,7 @@ bp_unpack_indexed_string (struct data_in *data_in,\n /* Read a NULL terminated string from the string table in DATA_IN.  */\n \n const char *\n-bp_unpack_string (struct data_in *data_in, struct bitpack_d *bp)\n+bp_unpack_string (class data_in *data_in, struct bitpack_d *bp)\n {\n   unsigned int len;\n   const char *ptr;\n@@ -119,7 +119,7 @@ bp_unpack_string (struct data_in *data_in, struct bitpack_d *bp)\n /* Read an unsigned HOST_WIDE_INT number from IB.  */\n \n unsigned HOST_WIDE_INT\n-streamer_read_uhwi (struct lto_input_block *ib)\n+streamer_read_uhwi (class lto_input_block *ib)\n {\n   unsigned HOST_WIDE_INT result;\n   int shift;\n@@ -154,7 +154,7 @@ streamer_read_uhwi (struct lto_input_block *ib)\n /* Read a HOST_WIDE_INT number from IB.  */\n \n HOST_WIDE_INT\n-streamer_read_hwi (struct lto_input_block *ib)\n+streamer_read_hwi (class lto_input_block *ib)\n {\n   HOST_WIDE_INT result = 0;\n   int shift = 0;\n@@ -178,7 +178,7 @@ streamer_read_hwi (struct lto_input_block *ib)\n /* Read gcov_type value from IB.  */\n \n gcov_type\n-streamer_read_gcov_count (struct lto_input_block *ib)\n+streamer_read_gcov_count (class lto_input_block *ib)\n {\n   gcov_type ret = streamer_read_hwi (ib);\n   return ret;\n@@ -188,7 +188,7 @@ streamer_read_gcov_count (struct lto_input_block *ib)\n    input block IB.  */\n \n wide_int\n-streamer_read_wide_int (struct lto_input_block *ib)\n+streamer_read_wide_int (class lto_input_block *ib)\n {\n   HOST_WIDE_INT a[WIDE_INT_MAX_ELTS];\n   int i;\n@@ -203,7 +203,7 @@ streamer_read_wide_int (struct lto_input_block *ib)\n    input block IB.  */\n \n widest_int\n-streamer_read_widest_int (struct lto_input_block *ib)\n+streamer_read_widest_int (class lto_input_block *ib)\n {\n   HOST_WIDE_INT a[WIDE_INT_MAX_ELTS];\n   int i;"}, {"sha": "c8bfd9a70304ba51c5afcfb1efaa173eca65d038", "filename": "gcc/data-streamer.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -73,18 +73,18 @@ void streamer_write_wide_int (struct output_block *, const wide_int &);\n void streamer_write_widest_int (struct output_block *, const widest_int &);\n \n /* In data-streamer-in.c  */\n-const char *streamer_read_string (struct data_in *, struct lto_input_block *);\n-const char *streamer_read_indexed_string (struct data_in *,\n-\t\t\t\t\t  struct lto_input_block *,\n+const char *streamer_read_string (class data_in *, class lto_input_block *);\n+const char *streamer_read_indexed_string (class data_in *,\n+\t\t\t\t\t  class lto_input_block *,\n \t\t\t\t\t  unsigned int *);\n-const char *bp_unpack_indexed_string (struct data_in *, struct bitpack_d *,\n+const char *bp_unpack_indexed_string (class data_in *, struct bitpack_d *,\n \t\t\t\t      unsigned int *);\n-const char *bp_unpack_string (struct data_in *, struct bitpack_d *);\n-unsigned HOST_WIDE_INT streamer_read_uhwi (struct lto_input_block *);\n-HOST_WIDE_INT streamer_read_hwi (struct lto_input_block *);\n-gcov_type streamer_read_gcov_count (struct lto_input_block *);\n-wide_int streamer_read_wide_int (struct lto_input_block *);\n-widest_int streamer_read_widest_int (struct lto_input_block *);\n+const char *bp_unpack_string (class data_in *, struct bitpack_d *);\n+unsigned HOST_WIDE_INT streamer_read_uhwi (class lto_input_block *);\n+HOST_WIDE_INT streamer_read_hwi (class lto_input_block *);\n+gcov_type streamer_read_gcov_count (class lto_input_block *);\n+wide_int streamer_read_wide_int (class lto_input_block *);\n+widest_int streamer_read_widest_int (class lto_input_block *);\n \n /* Returns a new bit-packing context for bit-packing into S.  */\n static inline struct bitpack_d\n@@ -149,7 +149,7 @@ streamer_write_bitpack (struct bitpack_d *bp)\n \n /* Returns a new bit-packing context for bit-unpacking from IB.  */\n static inline struct bitpack_d\n-streamer_read_bitpack (struct lto_input_block *ib)\n+streamer_read_bitpack (class lto_input_block *ib)\n {\n   struct bitpack_d bp;\n   bp.word = streamer_read_uhwi (ib);\n@@ -174,7 +174,7 @@ bp_unpack_value (struct bitpack_d *bp, unsigned nbits)\n   if (pos + nbits > BITS_PER_BITPACK_WORD)\n     {\n       bp->word = val \n-\t= streamer_read_uhwi ((struct lto_input_block *)bp->stream);\n+\t= streamer_read_uhwi ((class lto_input_block *)bp->stream);\n       bp->pos = nbits;\n       return val & mask;\n     }\n@@ -218,7 +218,7 @@ streamer_write_char_stream (struct lto_output_stream *obs, char c)\n /* Read byte from the input block.  */\n \n static inline unsigned char\n-streamer_read_uchar (struct lto_input_block *ib)\n+streamer_read_uchar (class lto_input_block *ib)\n {\n   if (ib->p >= ib->len)\n     lto_section_overrun (ib);\n@@ -248,7 +248,7 @@ streamer_write_hwi_in_range (struct lto_output_stream *obs,\n    to be compile time constant.  PURPOSE is used for error reporting.  */\n \n static inline HOST_WIDE_INT\n-streamer_read_hwi_in_range (struct lto_input_block *ib,\n+streamer_read_hwi_in_range (class lto_input_block *ib,\n \t\t\t\t const char *purpose,\n \t\t\t\t HOST_WIDE_INT min,\n \t\t\t\t HOST_WIDE_INT max)\n@@ -337,7 +337,7 @@ streamer_write_record_start (struct output_block *ob, enum LTO_tags tag)\n /* Return the next tag in the input block IB.  */\n \n static inline enum LTO_tags\n-streamer_read_record_start (struct lto_input_block *ib)\n+streamer_read_record_start (class lto_input_block *ib)\n {\n   return streamer_read_enum (ib, LTO_tags, LTO_NUM_TAGS);\n }"}, {"sha": "28b2be90f5951bd9229e8d02238324d6525a3076", "filename": "gcc/ddg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -215,7 +215,7 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n         {\n           int regno = REGNO (SET_DEST (set));\n           df_ref first_def;\n-          struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n+\t  class df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n \n           first_def = df_bb_regno_first_def_find (g->bb, regno);\n           gcc_assert (first_def);\n@@ -288,7 +288,7 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n \n   if (flag_checking && DF_REF_ID (last_def) != DF_REF_ID (first_def))\n     {\n-      struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n+      class df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n       gcc_assert (!bitmap_bit_p (&bb_info->gen, DF_REF_ID (first_def)));\n     }\n \n@@ -369,7 +369,7 @@ static void\n build_inter_loop_deps (ddg_ptr g)\n {\n   unsigned rd_num;\n-  struct df_rd_bb_info *rd_bb_info;\n+  class df_rd_bb_info *rd_bb_info;\n   bitmap_iterator bi;\n \n   rd_bb_info = DF_RD_BB_INFO (g->bb);\n@@ -475,7 +475,7 @@ build_intra_loop_deps (ddg_ptr g)\n {\n   int i;\n   /* Hold the dependency analysis state during dependency calculations.  */\n-  struct deps_desc tmp_deps;\n+  class deps_desc tmp_deps;\n   rtx_insn *head, *tail;\n \n   /* Build the dependence information, using the sched_analyze function.  */"}, {"sha": "44848aa176898a4302ddb6903f6bb806dfe09f97", "filename": "gcc/df-core.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -407,7 +407,7 @@ bitmap_obstack df_bitmap_obstack;\n   Functions to create, destroy and manipulate an instance of df.\n ----------------------------------------------------------------------------*/\n \n-struct df_d *df;\n+class df_d *df;\n \n /* Add PROBLEM (and any dependent problems) to the DF instance.  */\n \n@@ -684,7 +684,7 @@ static unsigned int\n rest_of_handle_df_initialize (void)\n {\n   gcc_assert (!df);\n-  df = XCNEW (struct df_d);\n+  df = XCNEW (class df_d);\n   df->changeable_flags = 0;\n \n   bitmap_obstack_initialize (&df_bitmap_obstack);\n@@ -1293,7 +1293,7 @@ df_analyze (void)\n    Returns the number of blocks which is always loop->num_nodes.  */\n \n static int\n-loop_post_order_compute (int *post_order, struct loop *loop)\n+loop_post_order_compute (int *post_order, class loop *loop)\n {\n   edge_iterator *stack;\n   int sp;\n@@ -1354,7 +1354,7 @@ loop_post_order_compute (int *post_order, struct loop *loop)\n    by LOOP.  Returns the number of blocks which is always loop->num_nodes.  */\n \n static void\n-loop_inverted_post_order_compute (vec<int> *post_order, struct loop *loop)\n+loop_inverted_post_order_compute (vec<int> *post_order, class loop *loop)\n {\n   basic_block bb;\n   edge_iterator *stack;\n@@ -1419,7 +1419,7 @@ loop_inverted_post_order_compute (vec<int> *post_order, struct loop *loop)\n /* Analyze dataflow info for the basic blocks contained in LOOP.  */\n \n void\n-df_analyze_loop (struct loop *loop)\n+df_analyze_loop (class loop *loop)\n {\n   free (df->postorder);\n "}, {"sha": "d32c688510c2df25bae8c2ba375866a76a81ba1e", "filename": "gcc/df-problems.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -162,7 +162,7 @@ static void\n df_rd_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t    void *vbb_info)\n {\n-  struct df_rd_bb_info *bb_info = (struct df_rd_bb_info *) vbb_info;\n+  class df_rd_bb_info *bb_info = (class df_rd_bb_info *) vbb_info;\n   if (bb_info)\n     {\n       bitmap_clear (&bb_info->kill);\n@@ -182,17 +182,17 @@ df_rd_alloc (bitmap all_blocks)\n {\n   unsigned int bb_index;\n   bitmap_iterator bi;\n-  struct df_rd_problem_data *problem_data;\n+  class df_rd_problem_data *problem_data;\n \n   if (df_rd->problem_data)\n     {\n-      problem_data = (struct df_rd_problem_data *) df_rd->problem_data;\n+      problem_data = (class df_rd_problem_data *) df_rd->problem_data;\n       bitmap_clear (&problem_data->sparse_invalidated_by_call);\n       bitmap_clear (&problem_data->dense_invalidated_by_call);\n     }\n   else\n     {\n-      problem_data = XNEW (struct df_rd_problem_data);\n+      problem_data = XNEW (class df_rd_problem_data);\n       df_rd->problem_data = problem_data;\n \n       bitmap_obstack_initialize (&problem_data->rd_bitmaps);\n@@ -209,7 +209,7 @@ df_rd_alloc (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+      class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n       \n       /* When bitmaps are already initialized, just clear them.  */\n       if (bb_info->kill.obstack)\n@@ -283,7 +283,7 @@ df_rd_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx_insn *insn,\n    of kill sets.   */\n \n static void\n-df_rd_bb_local_compute_process_def (struct df_rd_bb_info *bb_info,\n+df_rd_bb_local_compute_process_def (class df_rd_bb_info *bb_info,\n \t\t\t\t    df_ref def,\n \t\t\t\t    int top_flag)\n {\n@@ -340,7 +340,7 @@ static void\n df_rd_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+  class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   rtx_insn *insn;\n \n   bitmap_clear (&seen_in_block);\n@@ -390,8 +390,8 @@ df_rd_local_compute (bitmap all_blocks)\n   unsigned int bb_index;\n   bitmap_iterator bi;\n   unsigned int regno;\n-  struct df_rd_problem_data *problem_data\n-    = (struct df_rd_problem_data *) df_rd->problem_data;\n+  class df_rd_problem_data *problem_data\n+    = (class df_rd_problem_data *) df_rd->problem_data;\n   bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_call;\n   bitmap dense_invalidated = &problem_data->dense_invalidated_by_call;\n \n@@ -435,7 +435,7 @@ df_rd_init_solution (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+      class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n \n       bitmap_copy (&bb_info->out, &bb_info->gen);\n       bitmap_clear (&bb_info->in);\n@@ -456,8 +456,8 @@ df_rd_confluence_n (edge e)\n \n   if (e->flags & EDGE_EH)\n     {\n-      struct df_rd_problem_data *problem_data\n-\t= (struct df_rd_problem_data *) df_rd->problem_data;\n+      class df_rd_problem_data *problem_data\n+\t= (class df_rd_problem_data *) df_rd->problem_data;\n       bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_call;\n       bitmap dense_invalidated = &problem_data->dense_invalidated_by_call;\n       bitmap_iterator bi;\n@@ -485,7 +485,7 @@ df_rd_confluence_n (edge e)\n static bool\n df_rd_transfer_function (int bb_index)\n {\n-  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+  class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   unsigned int regno;\n   bitmap_iterator bi;\n   bitmap in = &bb_info->in;\n@@ -499,12 +499,12 @@ df_rd_transfer_function (int bb_index)\n     changed = bitmap_ior_and_compl (out, gen, in, kill);\n   else\n     {\n-      struct df_rd_problem_data *problem_data;\n+      class df_rd_problem_data *problem_data;\n       bitmap_head tmp;\n \n       /* Note that TMP is _not_ a temporary bitmap if we end up replacing\n \t OUT with TMP.  Therefore, allocate TMP in the RD bitmaps obstack.  */\n-      problem_data = (struct df_rd_problem_data *) df_rd->problem_data;\n+      problem_data = (class df_rd_problem_data *) df_rd->problem_data;\n       bitmap_initialize (&tmp, &problem_data->rd_bitmaps);\n \n       bitmap_and_compl (&tmp, in, kill);\n@@ -528,7 +528,7 @@ df_rd_transfer_function (int bb_index)\n \t basic block, and mask out DEFs of registers that are not live.\n \t Computing the mask looks costly, but the benefit of the pruning\n \t outweighs the cost.  */\n-      struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+      class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n       bitmap regs_live_out = &df_lr_get_bb_info (bb_index)->out;\n       bitmap live_defs = BITMAP_ALLOC (&df_bitmap_obstack);\n       unsigned int regno;\n@@ -550,8 +550,8 @@ df_rd_transfer_function (int bb_index)\n static void\n df_rd_free (void)\n {\n-  struct df_rd_problem_data *problem_data\n-    = (struct df_rd_problem_data *) df_rd->problem_data;\n+  class df_rd_problem_data *problem_data\n+    = (class df_rd_problem_data *) df_rd->problem_data;\n \n   if (problem_data)\n     {\n@@ -571,8 +571,8 @@ df_rd_free (void)\n static void\n df_rd_start_dump (FILE *file)\n {\n-  struct df_rd_problem_data *problem_data\n-    = (struct df_rd_problem_data *) df_rd->problem_data;\n+  class df_rd_problem_data *problem_data\n+    = (class df_rd_problem_data *) df_rd->problem_data;\n   unsigned int m = DF_REG_SIZE (df);\n   unsigned int regno;\n \n@@ -644,7 +644,7 @@ df_rd_dump_defs_set (bitmap defs_set, const char *prefix, FILE *file)\n static void\n df_rd_top_dump (basic_block bb, FILE *file)\n {\n-  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n+  class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n@@ -659,7 +659,7 @@ df_rd_top_dump (basic_block bb, FILE *file)\n static void\n df_rd_bottom_dump (basic_block bb, FILE *file)\n {\n-  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n+  class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n@@ -692,7 +692,7 @@ static const struct df_problem problem_RD =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  sizeof (struct df_rd_bb_info),/* Size of entry of block_info array.  */\n+  sizeof (class df_rd_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_RD,                   /* Timing variable.  */\n   true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -734,7 +734,7 @@ static void\n df_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t    void *vbb_info)\n {\n-  struct df_lr_bb_info *bb_info = (struct df_lr_bb_info *) vbb_info;\n+  class df_lr_bb_info *bb_info = (class df_lr_bb_info *) vbb_info;\n   if (bb_info)\n     {\n       bitmap_clear (&bb_info->use);\n@@ -770,7 +770,7 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n   EXECUTE_IF_SET_IN_BITMAP (df_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n-      struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n+      class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n       \n       /* When bitmaps are already initialized, just clear them.  */\n       if (bb_info->use.obstack)\n@@ -801,7 +801,7 @@ df_lr_reset (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n+      class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n@@ -815,7 +815,7 @@ static void\n df_lr_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n+  class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n   rtx_insn *insn;\n   df_ref def, use;\n \n@@ -930,7 +930,7 @@ df_lr_local_compute (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t{\n \t  /* The exit block is special for this problem and its bits are\n \t     computed from thin air.  */\n-\t  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (EXIT_BLOCK);\n+\t  class df_lr_bb_info *bb_info = df_lr_get_bb_info (EXIT_BLOCK);\n \t  bitmap_copy (&bb_info->use, df->exit_block_uses);\n \t}\n       else\n@@ -951,7 +951,7 @@ df_lr_init (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n+      class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n       bitmap_copy (&bb_info->in, &bb_info->use);\n       bitmap_clear (&bb_info->out);\n     }\n@@ -997,7 +997,7 @@ df_lr_confluence_n (edge e)\n static bool\n df_lr_transfer_function (int bb_index)\n {\n-  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n+  class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb_index);\n   bitmap in = &bb_info->in;\n   bitmap out = &bb_info->out;\n   bitmap use = &bb_info->use;\n@@ -1069,7 +1069,7 @@ df_lr_free (void)\n static void\n df_lr_top_dump (basic_block bb, FILE *file)\n {\n-  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n+  class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n   struct df_lr_problem_data *problem_data;\n   if (!bb_info)\n     return;\n@@ -1097,7 +1097,7 @@ df_lr_top_dump (basic_block bb, FILE *file)\n static void\n df_lr_bottom_dump (basic_block bb, FILE *file)\n {\n-  struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n+  class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n   struct df_lr_problem_data *problem_data;\n   if (!bb_info)\n     return;\n@@ -1214,7 +1214,7 @@ static const struct df_problem problem_LR =\n   df_lr_verify_solution_start,/* Incremental solution verify start.  */\n   df_lr_verify_solution_end,  /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  sizeof (struct df_lr_bb_info),/* Size of entry of block_info array.  */\n+  sizeof (class df_lr_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_LR,                   /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -1254,7 +1254,7 @@ df_lr_verify_transfer_functions (void)\n \n   FOR_ALL_BB_FN (bb, cfun)\n     {\n-      struct df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n+      class df_lr_bb_info *bb_info = df_lr_get_bb_info (bb->index);\n       bitmap_set_bit (&all_blocks, bb->index);\n \n       if (bb_info)\n@@ -1340,7 +1340,7 @@ static void\n df_live_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t    void *vbb_info)\n {\n-  struct df_live_bb_info *bb_info = (struct df_live_bb_info *) vbb_info;\n+  class df_live_bb_info *bb_info = (class df_live_bb_info *) vbb_info;\n   if (bb_info)\n     {\n       bitmap_clear (&bb_info->gen);\n@@ -1378,7 +1378,7 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n   EXECUTE_IF_SET_IN_BITMAP (df_live->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n-      struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n+      class df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n       \n       /* When bitmaps are already initialized, just clear them.  */\n       if (bb_info->kill.obstack)\n@@ -1408,7 +1408,7 @@ df_live_reset (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n+      class df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n@@ -1422,7 +1422,7 @@ static void\n df_live_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n+  class df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n   rtx_insn *insn;\n   df_ref def;\n   int luid = 0;\n@@ -1498,8 +1498,8 @@ df_live_init (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n-      struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n+      class df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n+      class df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n \n       /* No register may reach a location where it is not used.  Thus\n \t we trim the rr result to the places where it is used.  */\n@@ -1528,8 +1528,8 @@ df_live_confluence_n (edge e)\n static bool\n df_live_transfer_function (int bb_index)\n {\n-  struct df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n-  struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n+  class df_live_bb_info *bb_info = df_live_get_bb_info (bb_index);\n+  class df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n   bitmap in = &bb_info->in;\n   bitmap out = &bb_info->out;\n   bitmap gen = &bb_info->gen;\n@@ -1560,8 +1560,8 @@ df_live_finalize (bitmap all_blocks)\n \n       EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n \t{\n-\t  struct df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n-\t  struct df_live_bb_info *bb_live_info = df_live_get_bb_info (bb_index);\n+\t  class df_lr_bb_info *bb_lr_info = df_lr_get_bb_info (bb_index);\n+\t  class df_live_bb_info *bb_live_info = df_live_get_bb_info (bb_index);\n \n \t  /* No register may reach a location where it is not used.  Thus\n \t     we trim the rr result to the places where it is used.  */\n@@ -1601,7 +1601,7 @@ df_live_free (void)\n static void\n df_live_top_dump (basic_block bb, FILE *file)\n {\n-  struct df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n+  class df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n   struct df_live_problem_data *problem_data;\n \n   if (!bb_info)\n@@ -1630,7 +1630,7 @@ df_live_top_dump (basic_block bb, FILE *file)\n static void\n df_live_bottom_dump (basic_block bb, FILE *file)\n {\n-  struct df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n+  class df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n   struct df_live_problem_data *problem_data;\n \n   if (!bb_info)\n@@ -1742,7 +1742,7 @@ static const struct df_problem problem_LIVE =\n   df_live_verify_solution_start,/* Incremental solution verify start.  */\n   df_live_verify_solution_end,  /* Incremental solution verify end.  */\n   &problem_LR,                  /* Dependent problem.  */\n-  sizeof (struct df_live_bb_info),/* Size of entry of block_info array.  */\n+  sizeof (class df_live_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_LIVE,                   /* Timing variable.  */\n   false                         /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -1797,7 +1797,7 @@ df_live_verify_transfer_functions (void)\n \n   FOR_ALL_BB_FN (bb, cfun)\n     {\n-      struct df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n+      class df_live_bb_info *bb_info = df_live_get_bb_info (bb->index);\n       bitmap_set_bit (&all_blocks, bb->index);\n \n       if (bb_info)\n@@ -1859,7 +1859,7 @@ static void\n df_mir_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t     void *vbb_info)\n {\n-  struct df_mir_bb_info *bb_info = (struct df_mir_bb_info *) vbb_info;\n+  class df_mir_bb_info *bb_info = (class df_mir_bb_info *) vbb_info;\n   if (bb_info)\n     {\n       bitmap_clear (&bb_info->gen);\n@@ -1896,7 +1896,7 @@ df_mir_alloc (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+      class df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n \n       /* When bitmaps are already initialized, just clear them.  */\n       if (bb_info->kill.obstack)\n@@ -1929,7 +1929,7 @@ df_mir_reset (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+      class df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n \n       gcc_assert (bb_info);\n \n@@ -1947,7 +1947,7 @@ static void\n df_mir_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+  class df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n   rtx_insn *insn;\n   int luid = 0;\n \n@@ -2011,7 +2011,7 @@ df_mir_init (bitmap all_blocks)\n static void\n df_mir_confluence_0 (basic_block bb)\n {\n-  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n+  class df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n \n   bitmap_clear (&bb_info->in);\n }\n@@ -2039,7 +2039,7 @@ df_mir_confluence_n (edge e)\n static bool\n df_mir_transfer_function (int bb_index)\n {\n-  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n+  class df_mir_bb_info *bb_info = df_mir_get_bb_info (bb_index);\n   bitmap in = &bb_info->in;\n   bitmap out = &bb_info->out;\n   bitmap gen = &bb_info->gen;\n@@ -2074,7 +2074,7 @@ df_mir_free (void)\n static void\n df_mir_top_dump (basic_block bb, FILE *file)\n {\n-  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n+  class df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n \n   if (!bb_info)\n     return;\n@@ -2092,7 +2092,7 @@ df_mir_top_dump (basic_block bb, FILE *file)\n static void\n df_mir_bottom_dump (basic_block bb, FILE *file)\n {\n-  struct df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n+  class df_mir_bb_info *bb_info = df_mir_get_bb_info (bb->index);\n \n   if (!bb_info)\n     return;\n@@ -2193,7 +2193,7 @@ static const struct df_problem problem_MIR =\n   df_mir_verify_solution_start, /* Incremental solution verify start.  */\n   df_mir_verify_solution_end,   /* Incremental solution verify end.  */\n   NULL,                         /* Dependent problem.  */\n-  sizeof (struct df_mir_bb_info),/* Size of entry of block_info array.  */\n+  sizeof (class df_mir_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_MIR,                    /* Timing variable.  */\n   false                         /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -2456,7 +2456,7 @@ static void\n df_chain_create_bb (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+  class df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n   rtx_insn *insn;\n   bitmap_head cpy;\n \n@@ -2711,7 +2711,7 @@ static void\n df_word_lr_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n \t\t\t void *vbb_info)\n {\n-  struct df_word_lr_bb_info *bb_info = (struct df_word_lr_bb_info *) vbb_info;\n+  class df_word_lr_bb_info *bb_info = (class df_word_lr_bb_info *) vbb_info;\n   if (bb_info)\n     {\n       bitmap_clear (&bb_info->use);\n@@ -2754,7 +2754,7 @@ df_word_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \n   EXECUTE_IF_SET_IN_BITMAP (df_word_lr->out_of_date_transfer_functions, 0, bb_index, bi)\n     {\n-      struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n+      class df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n       \n       /* When bitmaps are already initialized, just clear them.  */\n       if (bb_info->use.obstack)\n@@ -2785,7 +2785,7 @@ df_word_lr_reset (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n+      class df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n@@ -2851,7 +2851,7 @@ static void\n df_word_lr_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n+  class df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n   rtx_insn *insn;\n   df_ref def, use;\n \n@@ -2918,7 +2918,7 @@ df_word_lr_init (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n+      class df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n       bitmap_copy (&bb_info->in, &bb_info->use);\n       bitmap_clear (&bb_info->out);\n     }\n@@ -2942,7 +2942,7 @@ df_word_lr_confluence_n (edge e)\n static bool\n df_word_lr_transfer_function (int bb_index)\n {\n-  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n+  class df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb_index);\n   bitmap in = &bb_info->in;\n   bitmap out = &bb_info->out;\n   bitmap use = &bb_info->use;\n@@ -2979,7 +2979,7 @@ df_word_lr_free (void)\n static void\n df_word_lr_top_dump (basic_block bb, FILE *file)\n {\n-  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb->index);\n+  class df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n@@ -2997,7 +2997,7 @@ df_word_lr_top_dump (basic_block bb, FILE *file)\n static void\n df_word_lr_bottom_dump (basic_block bb, FILE *file)\n {\n-  struct df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb->index);\n+  class df_word_lr_bb_info *bb_info = df_word_lr_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n@@ -3032,7 +3032,7 @@ static const struct df_problem problem_WORD_LR =\n   NULL,                            /* Incremental solution verify start.  */\n   NULL,                            /* Incremental solution verify end.  */\n   NULL,                            /* Dependent problem.  */\n-  sizeof (struct df_word_lr_bb_info),/* Size of entry of block_info array.  */\n+  sizeof (class df_word_lr_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_WORD_LR,                   /* Timing variable.  */\n   false                            /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n@@ -4348,7 +4348,7 @@ static void\n df_md_free_bb_info (basic_block bb ATTRIBUTE_UNUSED,\n                     void *vbb_info)\n {\n-  struct df_md_bb_info *bb_info = (struct df_md_bb_info *) vbb_info;\n+  class df_md_bb_info *bb_info = (class df_md_bb_info *) vbb_info;\n   if (bb_info)\n     {\n       bitmap_clear (&bb_info->kill);\n@@ -4383,7 +4383,7 @@ df_md_alloc (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+      class df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n       /* When bitmaps are already initialized, just clear them.  */\n       if (bb_info->init.obstack)\n         {\n@@ -4452,7 +4452,7 @@ df_md_simulate_one_insn (basic_block bb ATTRIBUTE_UNUSED, rtx_insn *insn,\n }\n \n static void\n-df_md_bb_local_compute_process_def (struct df_md_bb_info *bb_info,\n+df_md_bb_local_compute_process_def (class df_md_bb_info *bb_info,\n                                     df_ref def,\n                                     int top_flag)\n {\n@@ -4493,7 +4493,7 @@ static void\n df_md_bb_local_compute (unsigned int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+  class df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n   rtx_insn *insn;\n \n   /* Artificials are only hard regs.  */\n@@ -4571,7 +4571,7 @@ df_md_reset (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+      class df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n       gcc_assert (bb_info);\n       bitmap_clear (&bb_info->in);\n       bitmap_clear (&bb_info->out);\n@@ -4582,7 +4582,7 @@ static bool\n df_md_transfer_function (int bb_index)\n {\n   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, bb_index);\n-  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+  class df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n   bitmap in = &bb_info->in;\n   bitmap out = &bb_info->out;\n   bitmap gen = &bb_info->gen;\n@@ -4610,7 +4610,7 @@ df_md_init (bitmap all_blocks)\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n-      struct df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n+      class df_md_bb_info *bb_info = df_md_get_bb_info (bb_index);\n \n       bitmap_copy (&bb_info->in, &bb_info->init);\n       df_md_transfer_function (bb_index);\n@@ -4620,7 +4620,7 @@ df_md_init (bitmap all_blocks)\n static void\n df_md_confluence_0 (basic_block bb)\n {\n-  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n+  class df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n   bitmap_copy (&bb_info->in, &bb_info->init);\n }\n \n@@ -4667,7 +4667,7 @@ df_md_free (void)\n static void\n df_md_top_dump (basic_block bb, FILE *file)\n {\n-  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n+  class df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n@@ -4686,7 +4686,7 @@ df_md_top_dump (basic_block bb, FILE *file)\n static void\n df_md_bottom_dump (basic_block bb, FILE *file)\n {\n-  struct df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n+  class df_md_bb_info *bb_info = df_md_get_bb_info (bb->index);\n   if (!bb_info)\n     return;\n \n@@ -4718,7 +4718,7 @@ static const struct df_problem problem_MD =\n   NULL,\t\t\t      /* Incremental solution verify start.  */\n   NULL,\t\t\t      /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  sizeof (struct df_md_bb_info),/* Size of entry of block_info array.  */\n+  sizeof (class df_md_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_MD,                   /* Timing variable.  */\n   false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };"}, {"sha": "03294a8a2c3d83d4462e91dd4fdbf257955c2437", "filename": "gcc/df-scan.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -53,25 +53,25 @@ class df_collection_rec\n   auto_vec<df_mw_hardreg *, 32> mw_vec;\n };\n \n-static void df_ref_record (enum df_ref_class, struct df_collection_rec *,\n+static void df_ref_record (enum df_ref_class, class df_collection_rec *,\n \t\t\t   rtx, rtx *,\n \t\t\t   basic_block, struct df_insn_info *,\n \t\t\t   enum df_ref_type, int ref_flags);\n-static void df_def_record_1 (struct df_collection_rec *, rtx *,\n+static void df_def_record_1 (class df_collection_rec *, rtx *,\n \t\t\t     basic_block, struct df_insn_info *,\n \t\t\t     int ref_flags);\n-static void df_defs_record (struct df_collection_rec *, rtx,\n+static void df_defs_record (class df_collection_rec *, rtx,\n \t\t\t    basic_block, struct df_insn_info *,\n \t\t\t    int ref_flags);\n-static void df_uses_record (struct df_collection_rec *,\n+static void df_uses_record (class df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n \t\t\t    basic_block, struct df_insn_info *,\n \t\t\t    int ref_flags);\n \n static void df_install_ref_incremental (df_ref);\n-static void df_insn_refs_collect (struct df_collection_rec*,\n+static void df_insn_refs_collect (class df_collection_rec*,\n \t\t\t\t  basic_block, struct df_insn_info *);\n-static void df_canonize_collection_rec (struct df_collection_rec *);\n+static void df_canonize_collection_rec (class df_collection_rec *);\n \n static void df_get_regular_block_artificial_uses (bitmap);\n static void df_get_eh_block_artificial_uses (bitmap);\n@@ -84,13 +84,13 @@ static void df_grow_ref_info (struct df_ref_info *, unsigned int);\n static void df_ref_chain_delete_du_chain (df_ref);\n static void df_ref_chain_delete (df_ref);\n \n-static void df_refs_add_to_chains (struct df_collection_rec *,\n+static void df_refs_add_to_chains (class df_collection_rec *,\n \t\t\t\t   basic_block, rtx_insn *, unsigned int);\n \n-static bool df_insn_refs_verify (struct df_collection_rec *, basic_block,\n+static bool df_insn_refs_verify (class df_collection_rec *, basic_block,\n \t\t\t\t rtx_insn *, bool);\n-static void df_entry_block_defs_collect (struct df_collection_rec *, bitmap);\n-static void df_exit_block_uses_collect (struct df_collection_rec *, bitmap);\n+static void df_entry_block_defs_collect (class df_collection_rec *, bitmap);\n+static void df_exit_block_uses_collect (class df_collection_rec *, bitmap);\n static void df_install_ref (df_ref, struct df_reg_info *,\n \t\t\t    struct df_ref_info *, bool);\n \n@@ -983,7 +983,7 @@ df_insn_delete (rtx_insn *insn)\n /* Free all of the refs and the mw_hardregs in COLLECTION_REC.  */\n \n static void\n-df_free_collection_rec (struct df_collection_rec *collection_rec)\n+df_free_collection_rec (class df_collection_rec *collection_rec)\n {\n   unsigned int ix;\n   struct df_scan_problem_data *problem_data\n@@ -1014,7 +1014,7 @@ df_insn_rescan (rtx_insn *insn)\n   unsigned int uid = INSN_UID (insn);\n   struct df_insn_info *insn_info = NULL;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n-  struct df_collection_rec collection_rec;\n+  class df_collection_rec collection_rec;\n \n   if ((!df) || (!INSN_P (insn)))\n     return false;\n@@ -1976,7 +1976,7 @@ df_notes_rescan (rtx_insn *insn)\n     {\n       basic_block bb = BLOCK_FOR_INSN (insn);\n       rtx note;\n-      struct df_collection_rec collection_rec;\n+      class df_collection_rec collection_rec;\n       unsigned int i;\n \n       df_mw_hardreg_chain_delete_eq_uses (insn_info);\n@@ -2269,7 +2269,7 @@ df_sort_and_compress_mws (vec<df_mw_hardreg *, va_heap> *mw_vec)\n /* Sort and remove duplicates from the COLLECTION_REC.  */\n \n static void\n-df_canonize_collection_rec (struct df_collection_rec *collection_rec)\n+df_canonize_collection_rec (class df_collection_rec *collection_rec)\n {\n   df_sort_and_compress_refs (&collection_rec->def_vec);\n   df_sort_and_compress_refs (&collection_rec->use_vec);\n@@ -2405,7 +2405,7 @@ df_install_mws (const vec<df_mw_hardreg *, va_heap> *old_vec)\n    chains and update other necessary information.  */\n \n static void\n-df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n+df_refs_add_to_chains (class df_collection_rec *collection_rec,\n \t\t       basic_block bb, rtx_insn *insn, unsigned int flags)\n {\n   if (insn)\n@@ -2467,7 +2467,7 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n \n static df_ref\n df_ref_create_structure (enum df_ref_class cl,\n-\t\t\t struct df_collection_rec *collection_rec,\n+\t\t\t class df_collection_rec *collection_rec,\n \t\t\t rtx reg, rtx *loc,\n \t\t\t basic_block bb, struct df_insn_info *info,\n \t\t\t enum df_ref_type ref_type,\n@@ -2553,7 +2553,7 @@ df_ref_create_structure (enum df_ref_class cl,\n \n static void\n df_ref_record (enum df_ref_class cl,\n-\t       struct df_collection_rec *collection_rec,\n+\t       class df_collection_rec *collection_rec,\n                rtx reg, rtx *loc,\n \t       basic_block bb, struct df_insn_info *insn_info,\n \t       enum df_ref_type ref_type,\n@@ -2625,7 +2625,7 @@ df_ref_record (enum df_ref_class cl,\n    Any change here has to be matched in df_find_hard_reg_defs_1.  */\n \n static void\n-df_def_record_1 (struct df_collection_rec *collection_rec,\n+df_def_record_1 (class df_collection_rec *collection_rec,\n                  rtx *loc, basic_block bb, struct df_insn_info *insn_info,\n \t\t int flags)\n {\n@@ -2690,7 +2690,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n    here has to be matched in df_find_hard_reg_defs.  */\n \n static void\n-df_defs_record (struct df_collection_rec *collection_rec,\n+df_defs_record (class df_collection_rec *collection_rec,\n                 rtx x, basic_block bb, struct df_insn_info *insn_info,\n \t\tint flags)\n {\n@@ -2796,7 +2796,7 @@ df_find_hard_reg_defs (rtx x, HARD_REG_SET *defs)\n /* Process all the registers used in the rtx at address LOC.  */\n \n static void\n-df_uses_record (struct df_collection_rec *collection_rec,\n+df_uses_record (class df_collection_rec *collection_rec,\n                 rtx *loc, enum df_ref_type ref_type,\n \t\tbasic_block bb, struct df_insn_info *insn_info,\n \t\tint flags)\n@@ -3055,7 +3055,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n /* For all DF_REF_CONDITIONAL defs, add a corresponding uses.  */\n \n static void\n-df_get_conditional_uses (struct df_collection_rec *collection_rec)\n+df_get_conditional_uses (class df_collection_rec *collection_rec)\n {\n   unsigned int ix;\n   df_ref ref;\n@@ -3079,7 +3079,7 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n /* Get call's extra defs and uses (track caller-saved registers). */\n \n static void\n-df_get_call_refs (struct df_collection_rec *collection_rec,\n+df_get_call_refs (class df_collection_rec *collection_rec,\n                   basic_block bb,\n                   struct df_insn_info *insn_info,\n                   int flags)\n@@ -3162,7 +3162,7 @@ df_get_call_refs (struct df_collection_rec *collection_rec,\n    and reg chains. */\n \n static void\n-df_insn_refs_collect (struct df_collection_rec *collection_rec,\n+df_insn_refs_collect (class df_collection_rec *collection_rec,\n \t\t      basic_block bb, struct df_insn_info *insn_info)\n {\n   rtx note;\n@@ -3258,7 +3258,7 @@ df_recompute_luids (basic_block bb)\n    to COLLECTION_REC.  */\n \n static void\n-df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n+df_bb_refs_collect (class df_collection_rec *collection_rec, basic_block bb)\n {\n   collection_rec->def_vec.truncate (0);\n   collection_rec->use_vec.truncate (0);\n@@ -3558,7 +3558,7 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n    reference to include.  */\n \n static void\n-df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n+df_entry_block_defs_collect (class df_collection_rec *collection_rec,\n \t\t\t     bitmap entry_block_defs)\n {\n   unsigned int i;\n@@ -3580,7 +3580,7 @@ df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n static void\n df_record_entry_block_defs (bitmap entry_block_defs)\n {\n-  struct df_collection_rec collection_rec;\n+  class df_collection_rec collection_rec;\n   df_entry_block_defs_collect (&collection_rec, entry_block_defs);\n \n   /* Process bb_refs chain */\n@@ -3715,7 +3715,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n    It uses df->exit_block_uses to determine register to include.  */\n \n static void\n-df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exit_block_uses)\n+df_exit_block_uses_collect (class df_collection_rec *collection_rec, bitmap exit_block_uses)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -3744,7 +3744,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n static void\n df_record_exit_block_uses (bitmap exit_block_uses)\n {\n-  struct df_collection_rec collection_rec;\n+  class df_collection_rec collection_rec;\n   df_exit_block_uses_collect (&collection_rec, exit_block_uses);\n \n   /* Process bb_refs chain */\n@@ -4052,7 +4052,7 @@ df_mws_verify (const vec<df_mw_hardreg *, va_heap> *new_rec,\n    If ABORT_IF_FAIL is set, this function never returns false.  */\n \n static bool\n-df_insn_refs_verify (struct df_collection_rec *collection_rec,\n+df_insn_refs_verify (class df_collection_rec *collection_rec,\n \t\t     basic_block bb,\n                      rtx_insn *insn,\n \t\t     bool abort_if_fail)\n@@ -4093,7 +4093,7 @@ df_bb_verify (basic_block bb)\n {\n   rtx_insn *insn;\n   struct df_scan_bb_info *bb_info = df_scan_get_bb_info (bb->index);\n-  struct df_collection_rec collection_rec;\n+  class df_collection_rec collection_rec;\n \n   gcc_assert (bb_info);\n "}, {"sha": "2e3b825065ea11acab3c245d6e058a7d210d12fc", "filename": "gcc/df.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n \n struct dataflow;\n-struct df_d;\n+class df_d;\n struct df_problem;\n struct df_link;\n struct df_insn_info;\n@@ -935,7 +935,7 @@ class df_mir_bb_info\n /* This is used for debugging and for the dumpers to find the latest\n    instance so that the df info can be added to the dumps.  This\n    should not be used by regular code.  */\n-extern struct df_d *df;\n+extern class df_d *df;\n #define df_scan    (df->problems_by_index[DF_SCAN])\n #define df_rd      (df->problems_by_index[DF_RD])\n #define df_lr      (df->problems_by_index[DF_LR])\n@@ -968,7 +968,7 @@ extern void df_remove_problem (struct dataflow *);\n extern void df_finish_pass (bool);\n extern void df_analyze_problem (struct dataflow *, bitmap, int *, int);\n extern void df_analyze ();\n-extern void df_analyze_loop (struct loop *);\n+extern void df_analyze_loop (class loop *);\n extern int df_get_n_blocks (enum df_flow_dir);\n extern int *df_get_postorder (enum df_flow_dir);\n extern void df_simple_dataflow (enum df_flow_dir, df_init_function,\n@@ -1103,56 +1103,56 @@ df_scan_get_bb_info (unsigned int index)\n     return NULL;\n }\n \n-static inline struct df_rd_bb_info *\n+static inline class df_rd_bb_info *\n df_rd_get_bb_info (unsigned int index)\n {\n   if (index < df_rd->block_info_size)\n-    return &((struct df_rd_bb_info *) df_rd->block_info)[index];\n+    return &((class df_rd_bb_info *) df_rd->block_info)[index];\n   else\n     return NULL;\n }\n \n-static inline struct df_lr_bb_info *\n+static inline class df_lr_bb_info *\n df_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_lr->block_info_size)\n-    return &((struct df_lr_bb_info *) df_lr->block_info)[index];\n+    return &((class df_lr_bb_info *) df_lr->block_info)[index];\n   else\n     return NULL;\n }\n \n-static inline struct df_md_bb_info *\n+static inline class df_md_bb_info *\n df_md_get_bb_info (unsigned int index)\n {\n   if (index < df_md->block_info_size)\n-    return &((struct df_md_bb_info *) df_md->block_info)[index];\n+    return &((class df_md_bb_info *) df_md->block_info)[index];\n   else\n     return NULL;\n }\n \n-static inline struct df_live_bb_info *\n+static inline class df_live_bb_info *\n df_live_get_bb_info (unsigned int index)\n {\n   if (index < df_live->block_info_size)\n-    return &((struct df_live_bb_info *) df_live->block_info)[index];\n+    return &((class df_live_bb_info *) df_live->block_info)[index];\n   else\n     return NULL;\n }\n \n-static inline struct df_word_lr_bb_info *\n+static inline class df_word_lr_bb_info *\n df_word_lr_get_bb_info (unsigned int index)\n {\n   if (index < df_word_lr->block_info_size)\n-    return &((struct df_word_lr_bb_info *) df_word_lr->block_info)[index];\n+    return &((class df_word_lr_bb_info *) df_word_lr->block_info)[index];\n   else\n     return NULL;\n }\n \n-static inline struct df_mir_bb_info *\n+static inline class df_mir_bb_info *\n df_mir_get_bb_info (unsigned int index)\n {\n   if (index < df_mir->block_info_size)\n-    return &((struct df_mir_bb_info *) df_mir->block_info)[index];\n+    return &((class df_mir_bb_info *) df_mir->block_info)[index];\n   else\n     return NULL;\n }"}, {"sha": "8e5b01c93830f8d4d2df884a409d8e70c0fcf851", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -4301,7 +4301,7 @@ with machine mode @var{mode}.  The default version of this\n hook returns true for both @code{ptr_mode} and @code{Pmode}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_REF_MAY_ALIAS_ERRNO (struct ao_ref *@var{ref})\n+@deftypefn {Target Hook} bool TARGET_REF_MAY_ALIAS_ERRNO (ao_ref *@var{ref})\n Define this to return nonzero if the memory reference @var{ref}  may alias with the system C library errno location.  The default  version of this hook assumes the system C library errno location  is either a declaration of type int or accessed by dereferencing  a pointer to int.\n @end deftypefn\n \n@@ -6052,11 +6052,11 @@ type @code{internal_fn}) should be considered expensive when the mask is\n all zeros.  GCC can then try to branch around the instruction instead.\n @end deftypefn\n \n-@deftypefn {Target Hook} {void *} TARGET_VECTORIZE_INIT_COST (struct loop *@var{loop_info})\n+@deftypefn {Target Hook} {void *} TARGET_VECTORIZE_INIT_COST (class loop *@var{loop_info})\n This hook should initialize target-specific data structures in preparation for modeling the costs of vectorizing a loop or basic block.  The default allocates three unsigned integers for accumulating costs for the prologue, body, and epilogue of the loop or basic block.  If @var{loop_info} is non-NULL, it identifies the loop being vectorized; otherwise a single block is being vectorized.\n @end deftypefn\n \n-@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_ADD_STMT_COST (void *@var{data}, int @var{count}, enum vect_cost_for_stmt @var{kind}, struct _stmt_vec_info *@var{stmt_info}, int @var{misalign}, enum vect_cost_model_location @var{where})\n+@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_ADD_STMT_COST (void *@var{data}, int @var{count}, enum vect_cost_for_stmt @var{kind}, class _stmt_vec_info *@var{stmt_info}, int @var{misalign}, enum vect_cost_model_location @var{where})\n This hook should update the target-specific @var{data} in response to adding @var{count} copies of the given @var{kind} of statement to a loop or basic block.  The default adds the builtin vectorizer cost for the copies of the statement to the accumulator specified by @var{where}, (the prologue, body, or epilogue) and returns the amount added.  The return value should be viewed as a tentative cost that may later be revised.\n @end deftypefn\n \n@@ -11610,7 +11610,7 @@ function version at run-time for a given set of function versions.\n body must be generated.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_PREDICT_DOLOOP_P (struct loop *@var{loop})\n+@deftypefn {Target Hook} bool TARGET_PREDICT_DOLOOP_P (class loop *@var{loop})\n Return true if we can predict it is possible to use a low-overhead loop\n for a particular loop.  The parameter @var{loop} is a pointer to the loop.\n This target hook is required only when the target supports low-overhead\n@@ -11815,7 +11815,7 @@ This function prepares to emit a conditional comparison within a sequence\n  @var{bit_code} is @code{AND} or @code{IOR}, which is the op on the compares.\n @end deftypefn\n \n-@deftypefn {Target Hook} unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned @var{nunroll}, struct loop *@var{loop})\n+@deftypefn {Target Hook} unsigned TARGET_LOOP_UNROLL_ADJUST (unsigned @var{nunroll}, class loop *@var{loop})\n This target hook returns a new value for the number of times @var{loop}\n should be unrolled. The parameter @var{nunroll} is the number of times\n the loop is to be unrolled. The parameter @var{loop} is a pointer to"}, {"sha": "a1c7e3bc942437bcd1f159ad7ddeacb8e47f41ba", "filename": "gcc/dse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -278,7 +278,7 @@ class store_info\n     } positions_needed;\n \n   /* The next store info for this insn.  */\n-  struct store_info *next;\n+  class store_info *next;\n \n   /* The right hand side of the store.  This is used if there is a\n      subsequent reload of the mems address somewhere later in the\n@@ -326,9 +326,9 @@ class read_info_type\n   rtx mem;\n \n   /* The next read_info for this insn.  */\n-  struct read_info_type *next;\n+  class read_info_type *next;\n };\n-typedef struct read_info_type *read_info_t;\n+typedef class read_info_type *read_info_t;\n \n static object_allocator<read_info_type> read_info_type_pool (\"read_info_pool\");\n \n@@ -1509,7 +1509,7 @@ record_store (rtx body, bb_info_t bb_info)\n   while (ptr)\n     {\n       insn_info_t next = ptr->next_local_store;\n-      struct store_info *s_info = ptr->store_rec;\n+      class store_info *s_info = ptr->store_rec;\n       bool del = true;\n \n       /* Skip the clobbers. We delete the active insn if this insn"}, {"sha": "ad8bcb2a05a585f28e65b641fe6727196a7a89d0", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -648,7 +648,7 @@ extern void dump_combine_total_stats (FILE *);\n /* In cfghooks.c  */\n extern void dump_bb (FILE *, basic_block, int, dump_flags_t);\n \n-struct opt_pass;\n+class opt_pass;\n \n namespace gcc {\n "}, {"sha": "a667cdab94e63c520da5e9b305e2f9121154f606", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -351,7 +351,7 @@ const_fixed_hasher::equal (rtx x, rtx y)\n /* Return true if the given memory attributes are equal.  */\n \n bool\n-mem_attrs_eq_p (const struct mem_attrs *p, const struct mem_attrs *q)\n+mem_attrs_eq_p (const class mem_attrs *p, const class mem_attrs *q)\n {\n   if (p == q)\n     return true;\n@@ -1924,7 +1924,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n {\n   poly_int64 apply_bitpos = 0;\n   tree type;\n-  struct mem_attrs attrs, *defattrs, *refattrs;\n+  class mem_attrs attrs, *defattrs, *refattrs;\n   addr_space_t as;\n \n   /* It can happen that type_for_mode was given a mode for which there\n@@ -2334,7 +2334,7 @@ change_address (rtx memref, machine_mode mode, rtx addr)\n {\n   rtx new_rtx = change_address_1 (memref, mode, addr, 1, false);\n   machine_mode mmode = GET_MODE (new_rtx);\n-  struct mem_attrs *defattrs;\n+  class mem_attrs *defattrs;\n \n   mem_attrs attrs (*get_mem_attrs (memref));\n   defattrs = mode_mem_attrs[(int) mmode];\n@@ -2378,7 +2378,7 @@ adjust_address_1 (rtx memref, machine_mode mode, poly_int64 offset,\n   rtx addr = XEXP (memref, 0);\n   rtx new_rtx;\n   scalar_int_mode address_mode;\n-  struct mem_attrs attrs (*get_mem_attrs (memref)), *defattrs;\n+  class mem_attrs attrs (*get_mem_attrs (memref)), *defattrs;\n   unsigned HOST_WIDE_INT max_align;\n #ifdef POINTERS_EXTEND_UNSIGNED\n   scalar_int_mode pointer_mode\n@@ -2524,7 +2524,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n   rtx new_rtx, addr = XEXP (memref, 0);\n   machine_mode address_mode;\n-  struct mem_attrs *defattrs;\n+  class mem_attrs *defattrs;\n \n   mem_attrs attrs (*get_mem_attrs (memref));\n   address_mode = get_address_mode (memref);"}, {"sha": "7643bf9cefb87d5630e2adb5b7bd486482c4bfbf", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -20,8 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_EMIT_RTL_H\n #define GCC_EMIT_RTL_H\n \n-struct temp_slot;\n-typedef struct temp_slot *temp_slot_p;\n+class temp_slot;\n+typedef class temp_slot *temp_slot_p;\n \n /* Information mainlined about RTL representation of incoming arguments.  */\n struct GTY(()) incoming_args {\n@@ -110,7 +110,7 @@ struct GTY(()) rtl_data {\n   vec<rtx, va_gc> *x_stack_slot_list;\n \n   /* List of empty areas in the stack frame.  */\n-  struct frame_space *frame_space_list;\n+  class frame_space *frame_space_list;\n \n   /* Place after which to insert the tail_recursion_label if we need one.  */\n   rtx_note *x_stack_check_probe_note;\n@@ -136,7 +136,7 @@ struct GTY(()) rtl_data {\n   vec<temp_slot_p, va_gc> *x_used_temp_slots;\n \n   /* List of available temp slots.  */\n-  struct temp_slot *x_avail_temp_slots;\n+  class temp_slot *x_avail_temp_slots;\n \n   /* Current nesting level for temporaries.  */\n   int x_temp_slot_level;\n@@ -319,7 +319,7 @@ extern GTY(()) struct rtl_data x_rtl;\n #define crtl (&x_rtl)\n \n /* Return whether two MEM_ATTRs are equal.  */\n-bool mem_attrs_eq_p (const struct mem_attrs *, const struct mem_attrs *);\n+bool mem_attrs_eq_p (const class mem_attrs *, const class mem_attrs *);\n \n /* Set the alias set of MEM to SET.  */\n extern void set_mem_alias_set (rtx, alias_set_type);"}, {"sha": "1e6f8af258b5aedbd07556b110545f660b524c76", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1015,7 +1015,7 @@ dw2_build_landing_pads (void)\n       make_single_succ_edge (bb, bb->next_bb, e_flags);\n       if (current_loops)\n \t{\n-\t  struct loop *loop = bb->next_bb->loop_father;\n+\t  class loop *loop = bb->next_bb->loop_father;\n \t  /* If we created a pre-header block, add the new block to the\n \t     outer loop, otherwise to the loop itself.  */\n \t  if (bb->next_bb == loop->header)\n@@ -1389,7 +1389,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n \tmake_single_succ_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n \tif (current_loops)\n \t  {\n-\t    struct loop *loop = bb->next_bb->loop_father;\n+\t    class loop *loop = bb->next_bb->loop_father;\n \t    /* If we created a pre-header block, add the new block to the\n \t       outer loop, otherwise to the loop itself.  */\n \t    if (bb->next_bb == loop->header)\n@@ -1427,7 +1427,7 @@ sjlj_emit_dispatch_table (rtx_code_label *dispatch_label, int num_dispatch)\n       make_single_succ_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n       if (current_loops)\n \t{\n-\t  struct loop *loop = bb->next_bb->loop_father;\n+\t  class loop *loop = bb->next_bb->loop_father;\n \t  /* If we created a pre-header block, add the new block to the\n \t     outer loop, otherwise to the loop itself.  */\n \t  if (bb->next_bb == loop->header)"}, {"sha": "7eb854bca4a6dcc5b15e5c42df1a5e88a19f2464", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1489,7 +1489,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n      stack pointer, such as acquiring the space by calling malloc().  */\n   if (targetm.have_allocate_stack ())\n     {\n-      struct expand_operand ops[2];\n+      class expand_operand ops[2];\n       /* We don't have to check against the predicate for operand 0 since\n \t TARGET is known to be a pseudo of the proper mode, which must\n \t be valid for the operand.  */\n@@ -1620,7 +1620,7 @@ emit_stack_probe (rtx address)\n {\n   if (targetm.have_probe_stack_address ())\n     {\n-      struct expand_operand ops[1];\n+      class expand_operand ops[1];\n       insn_code icode = targetm.code_for_probe_stack_address;\n       create_address_operand (ops, address);\n       maybe_legitimize_operands (icode, 0, 1, ops);\n@@ -1680,7 +1680,7 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n   /* Next see if we have an insn to check the stack.  */\n   else if (targetm.have_check_stack ())\n     {\n-      struct expand_operand ops[1];\n+      class expand_operand ops[1];\n       rtx addr = memory_address (Pmode,\n \t\t\t\t gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n \t\t\t\t\t         stack_pointer_rtx,"}, {"sha": "c582f3a1e6262f70828a732f29edc7fc5054187b", "filename": "gcc/expmed.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -599,7 +599,7 @@ store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n \t\t\t    unsigned HOST_WIDE_INT bitnum,\n \t\t\t    rtx value, scalar_int_mode value_mode)\n {\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   rtx value1;\n   rtx xop0 = op0;\n   rtx_insn *last = get_last_insn ();\n@@ -759,7 +759,7 @@ store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n       && known_eq (bitsize, GET_MODE_BITSIZE (innermode))\n       && multiple_p (bitnum, GET_MODE_BITSIZE (innermode), &pos))\n     {\n-      struct expand_operand ops[3];\n+      class expand_operand ops[3];\n       enum insn_code icode = optab_handler (vec_set_optab, outermode);\n \n       create_fixed_operand (&ops[0], op0);\n@@ -870,7 +870,7 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n       && known_eq (bitsize, GET_MODE_BITSIZE (fieldmode))\n       && optab_handler (movstrict_optab, fieldmode) != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[2];\n+      class expand_operand ops[2];\n       enum insn_code icode = optab_handler (movstrict_optab, fieldmode);\n       rtx arg0 = op0;\n       unsigned HOST_WIDE_INT subreg_off;\n@@ -1499,7 +1499,7 @@ extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n \t\t\t      int unsignedp, rtx target,\n \t\t\t      machine_mode mode, machine_mode tmode)\n {\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n   scalar_int_mode ext_mode = extv->field_mode;\n@@ -1655,7 +1655,7 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t      != CODE_FOR_nothing)\n \t  && multiple_p (bitnum, GET_MODE_BITSIZE (tmode), &pos))\n \t{\n-\t  struct expand_operand ops[3];\n+\t  class expand_operand ops[3];\n \t  machine_mode outermode = new_mode;\n \t  machine_mode innermode = tmode;\n \t  enum insn_code icode\n@@ -1722,7 +1722,7 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t  && known_eq (bitsize, GET_MODE_BITSIZE (innermode))\n \t  && multiple_p (bitnum, GET_MODE_BITSIZE (innermode), &pos))\n \t{\n-\t  struct expand_operand ops[3];\n+\t  class expand_operand ops[3];\n \n \t  create_output_operand (&ops[0], target, innermode);\n \t  ops[0].target = 1;\n@@ -5428,7 +5428,7 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n \t     int unsignedp, rtx x, rtx y, int normalizep,\n \t     machine_mode target_mode)\n {\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   rtx op0, comparison, subtarget;\n   rtx_insn *last;\n   scalar_int_mode result_mode = targetm.cstore_mode (icode);"}, {"sha": "ff1f224d6ce1a38beeb3c4c53147770c4ba61970", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1769,7 +1769,7 @@ emit_block_move_via_cpymem (rtx x, rtx y, rtx size, unsigned int align,\n \t      || max_size <= (GET_MODE_MASK (mode) >> 1)\n \t      || GET_MODE_BITSIZE (mode) >= GET_MODE_BITSIZE (Pmode)))\n \t{\n-\t  struct expand_operand ops[9];\n+\t  class expand_operand ops[9];\n \t  unsigned int nops;\n \n \t  /* ??? When called via emit_block_move_for_call, it'd be\n@@ -1932,7 +1932,7 @@ expand_cmpstrn_or_cmpmem (insn_code icode, rtx target, rtx arg1_rtx,\n   if (target && (!REG_P (target) || HARD_REGISTER_P (target)))\n     target = NULL_RTX;\n \n-  struct expand_operand ops[5];\n+  class expand_operand ops[5];\n   create_output_operand (&ops[0], target, insn_mode);\n   create_fixed_operand (&ops[1], arg1_rtx);\n   create_fixed_operand (&ops[2], arg2_rtx);\n@@ -3137,7 +3137,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t      || max_size <= (GET_MODE_MASK (mode) >> 1)\n \t      || GET_MODE_BITSIZE (mode) >= GET_MODE_BITSIZE (Pmode)))\n \t{\n-\t  struct expand_operand ops[9];\n+\t  class expand_operand ops[9];\n \t  unsigned int nops;\n \n \t  nops = insn_data[(int) code].n_generator_args;\n@@ -4181,7 +4181,7 @@ emit_single_push_insn_1 (machine_mode mode, rtx x, tree type)\n   icode = optab_handler (push_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[1];\n+      class expand_operand ops[1];\n \n       create_input_operand (&ops[0], x, mode);\n       if (maybe_expand_insn (icode, 1, ops))\n@@ -5027,7 +5027,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       if (icode != CODE_FOR_nothing)\n \t{\n-\t  struct expand_operand ops[2];\n+\t  class expand_operand ops[2];\n \n \t  create_fixed_operand (&ops[0], mem);\n \t  create_input_operand (&ops[1], reg, mode);\n@@ -5456,7 +5456,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n bool\n emit_storent_insn (rtx to, rtx from)\n {\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   machine_mode mode = GET_MODE (to);\n   enum insn_code code = optab_handler (storent_optab, mode);\n \n@@ -6759,7 +6759,7 @@ store_constructor (tree exp, rtx target, int cleared, poly_int64 size,\n \t\t!= CODE_FOR_nothing)\n \t    && (elt = uniform_vector_p (exp)))\n \t  {\n-\t    struct expand_operand ops[2];\n+\t    class expand_operand ops[2];\n \t    create_output_operand (&ops[0], target, mode);\n \t    create_input_operand (&ops[1], expand_normal (elt), eltmode);\n \t    expand_insn (icode, 2, ops);\n@@ -9554,7 +9554,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t  && mode == TYPE_MODE (TREE_TYPE (treeop0))\n \t  && SCALAR_INT_MODE_P (mode))\n \t{\n-\t  struct expand_operand eops[4];\n+\t  class expand_operand eops[4];\n \t  machine_mode imode = TYPE_MODE (TREE_TYPE (treeop0));\n \t  expand_operands (treeop0, treeop1,\n \t\t\t   subtarget, &op0, &op1, EXPAND_NORMAL);\n@@ -10292,7 +10292,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    && ((icode = optab_handler (movmisalign_optab, mode))\n \t\t!= CODE_FOR_nothing))\n \t  {\n-\t    struct expand_operand ops[2];\n+\t    class expand_operand ops[2];\n \n \t    /* We've already validated the memory, and we're creating a\n \t       new pseudo destination.  The predicates really can't fail,\n@@ -10374,7 +10374,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    if ((icode = optab_handler (movmisalign_optab, mode))\n \t\t!= CODE_FOR_nothing)\n \t      {\n-\t\tstruct expand_operand ops[2];\n+\t\tclass expand_operand ops[2];\n \n \t\t/* We've already validated the memory, and we're creating a\n \t\t   new pseudo destination.  The predicates really can't fail,\n@@ -12180,7 +12180,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n \t    rtx table_label, rtx default_label, rtx fallback_label,\n             profile_probability default_probability)\n {\n-  struct expand_operand ops[5];\n+  class expand_operand ops[5];\n   scalar_int_mode index_mode = SImode;\n   rtx op1, op2, index;\n "}, {"sha": "0b9cd12e6cc057a39e3787f28ebe6251562fee91", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -56,9 +56,9 @@ class target_flag_state\n   enum excess_precision x_flag_excess_precision;\n };\n \n-extern struct target_flag_state default_target_flag_state;\n+extern class target_flag_state default_target_flag_state;\n #if SWITCHABLE_TARGET\n-extern struct target_flag_state *this_target_flag_state;\n+extern class target_flag_state *this_target_flag_state;\n #else\n #define this_target_flag_state (&default_target_flag_state)\n #endif"}, {"sha": "373c1f2beb2d0f87a2e0e9bb2a59e2d9ae79a73b", "filename": "gcc/function.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -133,7 +133,7 @@ vec<tree, va_gc> *types_used_by_cur_var_decl;\n \n /* Forward declarations.  */\n \n-static struct temp_slot *find_temp_slot_from_address (rtx);\n+static class temp_slot *find_temp_slot_from_address (rtx);\n static void pad_to_arg_alignment (struct args_size *, int, struct args_size *);\n static void pad_below (struct args_size *, machine_mode, tree);\n static void reorder_blocks_1 (rtx_insn *, tree, vec<tree> *);\n@@ -345,7 +345,7 @@ try_fit_stack_local (poly_int64 start, poly_int64 length,\n static void\n add_frame_space (poly_int64 start, poly_int64 end)\n {\n-  struct frame_space *space = ggc_alloc<frame_space> ();\n+  class frame_space *space = ggc_alloc<frame_space> ();\n   space->next = crtl->frame_space_list;\n   crtl->frame_space_list = space;\n   space->start = start;\n@@ -441,11 +441,11 @@ assign_stack_local_1 (machine_mode mode, poly_int64 size,\n     {\n       if (kind & ASLK_RECORD_PAD)\n \t{\n-\t  struct frame_space **psp;\n+\t  class frame_space **psp;\n \n \t  for (psp = &crtl->frame_space_list; *psp; psp = &(*psp)->next)\n \t    {\n-\t      struct frame_space *space = *psp;\n+\t      class frame_space *space = *psp;\n \t      if (!try_fit_stack_local (space->start, space->length, size,\n \t\t\t\t\talignment, &slot_offset))\n \t\tcontinue;\n@@ -559,9 +559,9 @@ assign_stack_local (machine_mode mode, poly_int64 size, int align)\n class GTY(()) temp_slot {\n public:\n   /* Points to next temporary slot.  */\n-  struct temp_slot *next;\n+  class temp_slot *next;\n   /* Points to previous temporary slot.  */\n-  struct temp_slot *prev;\n+  class temp_slot *prev;\n   /* The rtx to used to reference the slot.  */\n   rtx slot;\n   /* The size, in units, of the slot.  */\n@@ -589,7 +589,7 @@ class GTY(()) temp_slot {\n struct GTY((for_user)) temp_slot_address_entry {\n   hashval_t hash;\n   rtx address;\n-  struct temp_slot *temp_slot;\n+  class temp_slot *temp_slot;\n };\n \n struct temp_address_hasher : ggc_ptr_hash<temp_slot_address_entry>\n@@ -606,7 +606,7 @@ static size_t n_temp_slots_in_use;\n /* Removes temporary slot TEMP from LIST.  */\n \n static void\n-cut_slot_from_list (struct temp_slot *temp, struct temp_slot **list)\n+cut_slot_from_list (class temp_slot *temp, class temp_slot **list)\n {\n   if (temp->next)\n     temp->next->prev = temp->prev;\n@@ -621,7 +621,7 @@ cut_slot_from_list (struct temp_slot *temp, struct temp_slot **list)\n /* Inserts temporary slot TEMP to LIST.  */\n \n static void\n-insert_slot_to_list (struct temp_slot *temp, struct temp_slot **list)\n+insert_slot_to_list (class temp_slot *temp, class temp_slot **list)\n {\n   temp->next = *list;\n   if (*list)\n@@ -632,7 +632,7 @@ insert_slot_to_list (struct temp_slot *temp, struct temp_slot **list)\n \n /* Returns the list of used temp slots at LEVEL.  */\n \n-static struct temp_slot **\n+static class temp_slot **\n temp_slots_at_level (int level)\n {\n   if (level >= (int) vec_safe_length (used_temp_slots))\n@@ -655,7 +655,7 @@ max_slot_level (void)\n /* Moves temporary slot TEMP to LEVEL.  */\n \n static void\n-move_slot_to_level (struct temp_slot *temp, int level)\n+move_slot_to_level (class temp_slot *temp, int level)\n {\n   cut_slot_from_list (temp, temp_slots_at_level (temp->level));\n   insert_slot_to_list (temp, temp_slots_at_level (level));\n@@ -665,7 +665,7 @@ move_slot_to_level (struct temp_slot *temp, int level)\n /* Make temporary slot TEMP available.  */\n \n static void\n-make_slot_available (struct temp_slot *temp)\n+make_slot_available (class temp_slot *temp)\n {\n   cut_slot_from_list (temp, temp_slots_at_level (temp->level));\n   insert_slot_to_list (temp, &avail_temp_slots);\n@@ -701,7 +701,7 @@ temp_address_hasher::equal (temp_slot_address_entry *t1,\n \n /* Add ADDRESS as an alias of TEMP_SLOT to the addess -> temp slot mapping.  */\n static void\n-insert_temp_slot_address (rtx address, struct temp_slot *temp_slot)\n+insert_temp_slot_address (rtx address, class temp_slot *temp_slot)\n {\n   struct temp_slot_address_entry *t = ggc_alloc<temp_slot_address_entry> ();\n   t->address = address;\n@@ -735,10 +735,10 @@ remove_unused_temp_slot_addresses (void)\n \n /* Find the temp slot corresponding to the object at address X.  */\n \n-static struct temp_slot *\n+static class temp_slot *\n find_temp_slot_from_address (rtx x)\n {\n-  struct temp_slot *p;\n+  class temp_slot *p;\n   struct temp_slot_address_entry tmp, *t;\n \n   /* First try the easy way:\n@@ -787,7 +787,7 @@ rtx\n assign_stack_temp_for_type (machine_mode mode, poly_int64 size, tree type)\n {\n   unsigned int align;\n-  struct temp_slot *p, *best_p = 0, *selected = NULL, **pp;\n+  class temp_slot *p, *best_p = 0, *selected = NULL, **pp;\n   rtx slot;\n \n   gcc_assert (known_size_p (size));\n@@ -1031,7 +1031,7 @@ assign_temp (tree type_or_decl, int memory_required,\n static void\n combine_temp_slots (void)\n {\n-  struct temp_slot *p, *q, *next, *next_q;\n+  class temp_slot *p, *q, *next, *next_q;\n   int num_slots;\n \n   /* We can't combine slots, because the information about which slot\n@@ -1095,7 +1095,7 @@ combine_temp_slots (void)\n void\n update_temp_slot_address (rtx old_rtx, rtx new_rtx)\n {\n-  struct temp_slot *p;\n+  class temp_slot *p;\n \n   if (rtx_equal_p (old_rtx, new_rtx))\n     return;\n@@ -1149,7 +1149,7 @@ update_temp_slot_address (rtx old_rtx, rtx new_rtx)\n void\n preserve_temp_slots (rtx x)\n {\n-  struct temp_slot *p = 0, *next;\n+  class temp_slot *p = 0, *next;\n \n   if (x == 0)\n     return;\n@@ -1189,7 +1189,7 @@ preserve_temp_slots (rtx x)\n void\n free_temp_slots (void)\n {\n-  struct temp_slot *p, *next;\n+  class temp_slot *p, *next;\n   bool some_available = false;\n \n   for (p = *temp_slots_at_level (temp_slot_level); p; p = next)"}, {"sha": "43ac5dffd245794dd6822be0f471e42059b7942d", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -186,7 +186,7 @@ struct GTY(()) function_subsections {\n class GTY(()) frame_space\n {\n public:\n-  struct frame_space *next;\n+  class frame_space *next;\n \n   poly_int64 start;\n   poly_int64 length;\n@@ -243,7 +243,7 @@ struct GTY(()) function {\n   char *pass_startwith;\n \n   /* The stack usage of this function.  */\n-  struct stack_usage *su;\n+  class stack_usage *su;\n \n   /* Value histograms attached to particular statements.  */\n   htab_t GTY((skip)) value_histograms;"}, {"sha": "137864cb61b7375e067cdd34abd873b77c03735d", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -224,8 +224,8 @@ edge\n single_def_use_dom_walker::before_dom_children (basic_block bb)\n {\n   int bb_index = bb->index;\n-  struct df_md_bb_info *md_bb_info = df_md_get_bb_info (bb_index);\n-  struct df_lr_bb_info *lr_bb_info = df_lr_get_bb_info (bb_index);\n+  class df_md_bb_info *md_bb_info = df_md_get_bb_info (bb_index);\n+  class df_lr_bb_info *lr_bb_info = df_lr_get_bb_info (bb_index);\n   rtx_insn *insn;\n \n   bitmap_copy (local_md, &md_bb_info->in);"}, {"sha": "3bee2e82ad5ccdbc68ac27f83bea8df372869a4f", "filename": "gcc/gcc-rich-location.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgcc-rich-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgcc-rich-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -181,7 +181,7 @@ class maybe_range_label_for_tree_type_mismatch : public range_label\n   tree m_other_expr;\n };\n \n-struct op_location_t;\n+class op_location_t;\n \n /* A subclass of rich_location for showing problems with binary operations.\n "}, {"sha": "c65b7153765d2ea4f2ba8121fdfab9f472d160cb", "filename": "gcc/gcov.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -76,17 +76,17 @@ using namespace std;\n \n /* This is the size of the buffer used to read in source file lines.  */\n \n-struct function_info;\n-struct block_info;\n-struct source_info;\n+class function_info;\n+class block_info;\n+class source_info;\n \n /* Describes an arc between two basic blocks.  */\n \n struct arc_info\n {\n   /* source and destination blocks.  */\n-  struct block_info *src;\n-  struct block_info *dst;\n+  class block_info *src;\n+  class block_info *dst;\n \n   /* transition counts.  */\n   gcov_type count;\n@@ -178,7 +178,7 @@ class block_info\n \n   /* Temporary chain for solving graph, and for chaining blocks on one\n      line.  */\n-  struct block_info *chain;\n+  class block_info *chain;\n \n };\n \n@@ -297,7 +297,7 @@ class function_info\n   vector<line_info> lines;\n \n   /* Next function.  */\n-  struct function_info *next;\n+  class function_info *next;\n \n   /*  Get demangled name of a function.  The demangled name\n       is converted when it is used for the first time.  */"}, {"sha": "cdf0b5c12dc361aa8efc6a408f4b0a6032c68bc2", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -136,7 +136,7 @@ static struct obstack *temp_obstack = &obstack2;\n class insn_def\n {\n public:\n-  struct insn_def *next;\t/* Next insn in chain.  */\n+  class insn_def *next;\t/* Next insn in chain.  */\n   rtx def;\t\t\t/* The DEFINE_...  */\n   int insn_code;\t\t/* Instruction number.  */\n   int insn_index;\t\t/* Expression number in file, for errors.  */\n@@ -152,7 +152,7 @@ class insn_def\n struct insn_ent\n {\n   struct insn_ent *next;\t/* Next in chain.  */\n-  struct insn_def *def;\t\t/* Instruction definition.  */\n+  class insn_def *def;\t\t/* Instruction definition.  */\n };\n \n /* Each value of an attribute (either constant or computed) is assigned a\n@@ -175,7 +175,7 @@ class attr_desc\n public:\n   char *name;\t\t\t/* Name of attribute.  */\n   const char *enum_name;\t/* Enum name for DEFINE_ENUM_NAME.  */\n-  struct attr_desc *next;\t/* Next attribute.  */\n+  class attr_desc *next;\t/* Next attribute.  */\n   struct attr_value *first_value; /* First value of this attribute.  */\n   struct attr_value *default_val; /* Default value for this attribute.  */\n   file_location loc;\t\t/* Where in the .md files it occurs.  */\n@@ -190,7 +190,7 @@ class delay_desc\n {\n public:\n   rtx def;\t\t\t/* DEFINE_DELAY expression.  */\n-  struct delay_desc *next;\t/* Next DEFINE_DELAY.  */\n+  class delay_desc *next;\t/* Next DEFINE_DELAY.  */\n   file_location loc;\t\t/* Where in the .md files it occurs.  */\n   int num;\t\t\t/* Number of DEFINE_DELAY, starting at 1.  */\n };\n@@ -199,17 +199,17 @@ struct attr_value_list\n {\n   struct attr_value *av;\n   struct insn_ent *ie;\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n   struct attr_value_list *next;\n };\n \n /* Listheads of above structures.  */\n \n /* This one is indexed by the first character of the attribute name.  */\n #define MAX_ATTRS_INDEX 256\n-static struct attr_desc *attrs[MAX_ATTRS_INDEX];\n-static struct insn_def *defs;\n-static struct delay_desc *delays;\n+static class attr_desc *attrs[MAX_ATTRS_INDEX];\n+static class insn_def *defs;\n+static class delay_desc *delays;\n struct attr_value_list **insn_code_values;\n \n /* Other variables.  */\n@@ -260,7 +260,7 @@ static char *attr_string           (const char *, int);\n static char *attr_printf           (unsigned int, const char *, ...)\n   ATTRIBUTE_PRINTF_2;\n static rtx make_numeric_value      (int);\n-static struct attr_desc *find_attr (const char **, int);\n+static class attr_desc *find_attr (const char **, int);\n static rtx mk_attr_alt             (alternative_mask);\n static char *next_comma_elt\t   (const char **);\n static rtx insert_right_side\t   (enum rtx_code, rtx, rtx, int, int);\n@@ -278,15 +278,15 @@ static rtx copy_rtx_unchanging\t   (rtx);\n static bool attr_alt_subset_p      (rtx, rtx);\n static bool attr_alt_subset_of_compl_p (rtx, rtx);\n static void clear_struct_flag      (rtx);\n-static void write_attr_valueq\t   (FILE *, struct attr_desc *, const char *);\n-static struct attr_value *find_most_used  (struct attr_desc *);\n-static void write_attr_set\t   (FILE *, struct attr_desc *, int, rtx,\n+static void write_attr_valueq\t   (FILE *, class attr_desc *, const char *);\n+static struct attr_value *find_most_used  (class attr_desc *);\n+static void write_attr_set\t   (FILE *, class attr_desc *, int, rtx,\n \t\t\t\t    const char *, const char *, rtx,\n \t\t\t\t    int, int, unsigned int);\n-static void write_attr_case\t   (FILE *, struct attr_desc *,\n+static void write_attr_case\t   (FILE *, class attr_desc *,\n \t\t\t\t    struct attr_value *,\n \t\t\t\t    int, const char *, const char *, int, rtx);\n-static void write_attr_value\t   (FILE *, struct attr_desc *, rtx);\n+static void write_attr_value\t   (FILE *, class attr_desc *, rtx);\n static void write_upcase\t   (FILE *, const char *);\n static void write_indent\t   (FILE *, int);\n static rtx identity_fn\t\t   (rtx);\n@@ -847,7 +847,7 @@ check_attr_test (file_location loc, rtx exp, attr_desc *attr)\n    Return a perhaps modified replacement expression for the value.  */\n \n static rtx\n-check_attr_value (file_location loc, rtx exp, struct attr_desc *attr)\n+check_attr_value (file_location loc, rtx exp, class attr_desc *attr)\n {\n   struct attr_value *av;\n   const char *p;\n@@ -957,7 +957,7 @@ check_attr_value (file_location loc, rtx exp, struct attr_desc *attr)\n \n     case ATTR:\n       {\n-\tstruct attr_desc *attr2 = find_attr (&XSTR (exp, 0), 0);\n+\tclass attr_desc *attr2 = find_attr (&XSTR (exp, 0), 0);\n \tif (attr2 == NULL)\n \t  error_at (loc, \"unknown attribute `%s' in ATTR\",\n \t\t    XSTR (exp, 0));\n@@ -991,7 +991,7 @@ check_attr_value (file_location loc, rtx exp, struct attr_desc *attr)\n    It becomes a COND with each test being (eq_attr \"alternative\" \"n\") */\n \n static rtx\n-convert_set_attr_alternative (rtx exp, struct insn_def *id)\n+convert_set_attr_alternative (rtx exp, class insn_def *id)\n {\n   int num_alt = id->num_alternatives;\n   rtx condexp;\n@@ -1027,7 +1027,7 @@ convert_set_attr_alternative (rtx exp, struct insn_def *id)\n    list of values is given, convert to SET_ATTR_ALTERNATIVE first.  */\n \n static rtx\n-convert_set_attr (rtx exp, struct insn_def *id)\n+convert_set_attr (rtx exp, class insn_def *id)\n {\n   rtx newexp;\n   const char *name_ptr;\n@@ -1061,8 +1061,8 @@ convert_set_attr (rtx exp, struct insn_def *id)\n static void\n check_defs (void)\n {\n-  struct insn_def *id;\n-  struct attr_desc *attr;\n+  class insn_def *id;\n+  class attr_desc *attr;\n   int i;\n   rtx value;\n \n@@ -1119,7 +1119,7 @@ check_defs (void)\n    value.  LOC is the location to use for error reporting.  */\n \n static rtx\n-make_canonical (file_location loc, struct attr_desc *attr, rtx exp)\n+make_canonical (file_location loc, class attr_desc *attr, rtx exp)\n {\n   int i;\n   rtx newexp;\n@@ -1226,7 +1226,7 @@ copy_boolean (rtx exp)\n    alternatives.  LOC is the location to use for error reporting.  */\n \n static struct attr_value *\n-get_attr_value (file_location loc, rtx value, struct attr_desc *attr,\n+get_attr_value (file_location loc, rtx value, class attr_desc *attr,\n \t\tint insn_code)\n {\n   struct attr_value *av;\n@@ -1276,7 +1276,7 @@ get_attr_value (file_location loc, rtx value, struct attr_desc *attr,\n static void\n expand_delays (void)\n {\n-  struct delay_desc *delay;\n+  class delay_desc *delay;\n   rtx condexp;\n   rtx newexp;\n   int i;\n@@ -1362,11 +1362,11 @@ expand_delays (void)\n    the attribute.  */\n \n static void\n-fill_attr (struct attr_desc *attr)\n+fill_attr (class attr_desc *attr)\n {\n   struct attr_value *av;\n   struct insn_ent *ie;\n-  struct insn_def *id;\n+  class insn_def *id;\n   int i;\n   rtx value;\n \n@@ -1491,7 +1491,7 @@ make_length_attrs (void)\n   static rtx (*const address_fn[]) (rtx)\n     = {max_fn, min_fn, one_fn, identity_fn};\n   size_t i;\n-  struct attr_desc *length_attr, *new_attr;\n+  class attr_desc *length_attr, *new_attr;\n   struct attr_value *av, *new_av;\n   struct insn_ent *ie, *new_ie;\n \n@@ -1565,7 +1565,7 @@ min_fn (rtx exp)\n static void\n write_length_unit_log (FILE *outf)\n {\n-  struct attr_desc *length_attr = find_attr (&length_str, 0);\n+  class attr_desc *length_attr = find_attr (&length_str, 0);\n   struct attr_value *av;\n   struct insn_ent *ie;\n   unsigned int length_unit_log, length_or;\n@@ -1924,7 +1924,7 @@ make_alternative_compare (alternative_mask mask)\n    corresponding to INSN_CODE and INSN_INDEX.  */\n \n static rtx\n-evaluate_eq_attr (rtx exp, struct attr_desc *attr, rtx value,\n+evaluate_eq_attr (rtx exp, class attr_desc *attr, rtx value,\n \t\t  int insn_code, int insn_index)\n {\n   rtx orexp, andexp;\n@@ -2417,7 +2417,7 @@ static rtx\n simplify_test_exp (rtx exp, int insn_code, int insn_index)\n {\n   rtx left, right;\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n   struct attr_value *av;\n   struct insn_ent *ie;\n   struct attr_value_list *iv;\n@@ -2758,7 +2758,7 @@ simplify_test_exp (rtx exp, int insn_code, int insn_index)\n    otherwise return 0.  */\n \n static int\n-tests_attr_p (rtx p, struct attr_desc *attr)\n+tests_attr_p (rtx p, class attr_desc *attr)\n {\n   const char *fmt;\n   int i, ie, j, je;\n@@ -2799,18 +2799,18 @@ tests_attr_p (rtx p, struct attr_desc *attr)\n    attr_desc pointers), and return the size of that array.  */\n \n static int\n-get_attr_order (struct attr_desc ***ret)\n+get_attr_order (class attr_desc ***ret)\n {\n   int i, j;\n   int num = 0;\n-  struct attr_desc *attr;\n-  struct attr_desc **all, **sorted;\n+  class attr_desc *attr;\n+  class attr_desc **all, **sorted;\n   char *handled;\n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)\n       num++;\n-  all = XNEWVEC (struct attr_desc *, num);\n-  sorted = XNEWVEC (struct attr_desc *, num);\n+  all = XNEWVEC (class attr_desc *, num);\n+  sorted = XNEWVEC (class attr_desc *, num);\n   handled = XCNEWVEC (char, num);\n   num = 0;\n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n@@ -2858,7 +2858,7 @@ get_attr_order (struct attr_desc ***ret)\n   if (DEBUG)\n     for (j = 0; j < num; j++)\n       {\n-\tstruct attr_desc *attr2;\n+\tclass attr_desc *attr2;\n \tstruct attr_value *av;\n \n \tattr = sorted[j];\n@@ -2889,14 +2889,14 @@ get_attr_order (struct attr_desc ***ret)\n static void\n optimize_attrs (int num_insn_codes)\n {\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n   struct attr_value *av;\n   struct insn_ent *ie;\n   rtx newexp;\n   int i;\n   struct attr_value_list *ivbuf;\n   struct attr_value_list *iv;\n-  struct attr_desc **topsort;\n+  class attr_desc **topsort;\n   int topnum;\n \n   /* For each insn code, make a list of all the insn_ent's for it,\n@@ -3044,7 +3044,7 @@ clear_struct_flag (rtx x)\n /* Add attribute value NAME to the beginning of ATTR's list.  */\n \n static void\n-add_attr_value (struct attr_desc *attr, const char *name)\n+add_attr_value (class attr_desc *attr, const char *name)\n {\n   struct attr_value *av;\n \n@@ -3064,7 +3064,7 @@ gen_attr (md_rtx_info *info)\n {\n   struct enum_type *et;\n   struct enum_value *ev;\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n   const char *name_ptr;\n   char *p;\n   rtx def = info->def;\n@@ -3195,10 +3195,10 @@ compares_alternatives_p (rtx exp)\n static void\n gen_insn (md_rtx_info *info)\n {\n-  struct insn_def *id;\n+  class insn_def *id;\n   rtx def = info->def;\n \n-  id = oballoc (struct insn_def);\n+  id = oballoc (class insn_def);\n   id->next = defs;\n   defs = id;\n   id->def = def;\n@@ -3243,7 +3243,7 @@ gen_insn (md_rtx_info *info)\n static void\n gen_delay (md_rtx_info *info)\n {\n-  struct delay_desc *delay;\n+  class delay_desc *delay;\n   int i;\n \n   rtx def = info->def;\n@@ -3262,7 +3262,7 @@ gen_delay (md_rtx_info *info)\n \thave_annul_false = 1;\n     }\n \n-  delay = oballoc (struct delay_desc);\n+  delay = oballoc (class delay_desc);\n   delay->def = def;\n   delay->num = ++num_delays;\n   delay->next = delays;\n@@ -3289,7 +3289,7 @@ find_attrs_to_cache (rtx exp, bool create)\n {\n   int i;\n   const char *name;\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n \n   if (exp == NULL)\n     return;\n@@ -3369,7 +3369,7 @@ write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags,\n {\n   int comparison_operator = 0;\n   RTX_CODE code;\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n \n   if (emit_parens)\n     fprintf (outf, \"(\");\n@@ -4042,7 +4042,7 @@ walk_attr_value (rtx exp)\n /* Write out a function to obtain the attribute for a given INSN.  */\n \n static void\n-write_attr_get (FILE *outf, struct attr_desc *attr)\n+write_attr_get (FILE *outf, class attr_desc *attr)\n {\n   struct attr_value *av, *common_av;\n   int i, j;\n@@ -4099,7 +4099,7 @@ write_attr_get (FILE *outf, struct attr_desc *attr)\n     if ((attrs_seen_more_than_once & (1U << i)) != 0)\n       {\n \tconst char *name = cached_attrs[i];\n-\tstruct attr_desc *cached_attr;\n+\tclass attr_desc *cached_attr;\n \tif (i != j)\n \t  cached_attrs[j] = name;\n \tcached_attr = find_attr (&name, 0);\n@@ -4163,7 +4163,7 @@ eliminate_known_true (rtx known_true, rtx exp, int insn_code, int insn_index)\n    and \";\").  */\n \n static void\n-write_attr_set (FILE *outf, struct attr_desc *attr, int indent, rtx value,\n+write_attr_set (FILE *outf, class attr_desc *attr, int indent, rtx value,\n \t\tconst char *prefix, const char *suffix, rtx known_true,\n \t\tint insn_code, int insn_index, unsigned int attrs_cached)\n {\n@@ -4291,7 +4291,7 @@ write_insn_cases (FILE *outf, struct insn_ent *ie, int indent)\n /* Write out the computation for one attribute value.  */\n \n static void\n-write_attr_case (FILE *outf, struct attr_desc *attr, struct attr_value *av,\n+write_attr_case (FILE *outf, class attr_desc *attr, struct attr_value *av,\n \t\t int write_case_lines, const char *prefix, const char *suffix,\n \t\t int indent, rtx known_true)\n {\n@@ -4355,7 +4355,7 @@ write_attr_case (FILE *outf, struct attr_desc *attr, struct attr_value *av,\n /* Utilities to write in various forms.  */\n \n static void\n-write_attr_valueq (FILE *outf, struct attr_desc *attr, const char *s)\n+write_attr_valueq (FILE *outf, class attr_desc *attr, const char *s)\n {\n   if (attr->is_numeric)\n     {\n@@ -4375,7 +4375,7 @@ write_attr_valueq (FILE *outf, struct attr_desc *attr, const char *s)\n }\n \n static void\n-write_attr_value (FILE *outf, struct attr_desc *attr, rtx value)\n+write_attr_value (FILE *outf, class attr_desc *attr, rtx value)\n {\n   int op;\n \n@@ -4395,7 +4395,7 @@ write_attr_value (FILE *outf, struct attr_desc *attr, rtx value)\n \n     case ATTR:\n       {\n-\tstruct attr_desc *attr2 = find_attr (&XSTR (value, 0), 0);\n+\tclass attr_desc *attr2 = find_attr (&XSTR (value, 0), 0);\n \tif (attr->enum_name)\n \t  fprintf (outf, \"(enum %s)\", attr->enum_name);\n \telse if (!attr->is_numeric)\n@@ -4503,11 +4503,11 @@ write_dummy_eligible_delay (FILE *outf, const char *kind)\n static void\n write_eligible_delay (FILE *outf, const char *kind)\n {\n-  struct delay_desc *delay;\n+  class delay_desc *delay;\n   int max_slots;\n   char str[50];\n   const char *pstr;\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n   struct attr_value *av, *common_av;\n   int i;\n \n@@ -4639,14 +4639,14 @@ next_comma_elt (const char **pstr)\n   return attr_string (start, *pstr - start);\n }\n \n-/* Return a `struct attr_desc' pointer for a given named attribute.  If CREATE\n+/* Return a `class attr_desc' pointer for a given named attribute.  If CREATE\n    is nonzero, build a new attribute, if one does not exist.  *NAME_P is\n    replaced by a pointer to a canonical copy of the string.  */\n \n-static struct attr_desc *\n+static class attr_desc *\n find_attr (const char **name_p, int create)\n {\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n   int index;\n   const char *name = *name_p;\n \n@@ -4671,7 +4671,7 @@ find_attr (const char **name_p, int create)\n   if (! create)\n     return NULL;\n \n-  attr = oballoc (struct attr_desc);\n+  attr = oballoc (class attr_desc);\n   attr->name = DEF_ATTR_STRING (name);\n   attr->enum_name = 0;\n   attr->first_value = attr->default_val = NULL;\n@@ -4689,7 +4689,7 @@ find_attr (const char **name_p, int create)\n static void\n make_internal_attr (const char *name, rtx value, int special)\n {\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n \n   attr = find_attr (&name, 1);\n   gcc_assert (!attr->default_val);\n@@ -4704,7 +4704,7 @@ make_internal_attr (const char *name, rtx value, int special)\n /* Find the most used value of an attribute.  */\n \n static struct attr_value *\n-find_most_used (struct attr_desc *attr)\n+find_most_used (class attr_desc *attr)\n {\n   struct attr_value *av;\n   struct attr_value *most_used;\n@@ -4759,7 +4759,7 @@ copy_rtx_unchanging (rtx orig)\n static void\n write_const_num_delay_slots (FILE *outf)\n {\n-  struct attr_desc *attr = find_attr (&num_delay_slots_str, 0);\n+  class attr_desc *attr = find_attr (&num_delay_slots_str, 0);\n   struct attr_value *av;\n \n   if (attr)\n@@ -4815,7 +4815,7 @@ gen_insn_reserv (md_rtx_info *info)\n   struct insn_reserv *decl = oballoc (struct insn_reserv);\n   rtx def = info->def;\n \n-  struct attr_desc attr = { };\n+  class attr_desc attr = { };\n \n   attr.name = DEF_ATTR_STRING (XSTR (def, 0));\n   attr.loc = info->loc;\n@@ -4932,10 +4932,10 @@ check_tune_attr (const char *name, rtx exp)\n \n /* Try to find a const attribute (usually cpu or tune) that is used\n    in all define_insn_reservation conditions.  */\n-static struct attr_desc *\n+static class attr_desc *\n find_tune_attr (rtx exp)\n {\n-  struct attr_desc *attr;\n+  class attr_desc *attr;\n \n   switch (GET_CODE (exp))\n     {\n@@ -4979,7 +4979,7 @@ make_automaton_attrs (void)\n   int i;\n   struct insn_reserv *decl;\n   rtx code_exp, lats_exp, byps_exp;\n-  struct attr_desc *tune_attr;\n+  class attr_desc *tune_attr;\n \n   if (n_insn_reservs == 0)\n     return;\n@@ -5245,8 +5245,8 @@ handle_arg (const char *arg)\n int\n main (int argc, const char **argv)\n {\n-  struct attr_desc *attr;\n-  struct insn_def *id;\n+  class attr_desc *attr;\n+  class insn_def *id;\n   int i;\n \n   progname = \"genattrtab\";"}, {"sha": "5dff6830c1ea57711f93c6ade4067eec6a0b6542", "filename": "gcc/genextract.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -80,7 +80,7 @@ class accum_extract\n };\n \n /* Forward declarations.  */\n-static void walk_rtx (md_rtx_info *, rtx, struct accum_extract *);\n+static void walk_rtx (md_rtx_info *, rtx, class accum_extract *);\n \n #define UPPER_OFFSET ('A' - ('z' - 'a' + 1))\n \n@@ -89,7 +89,7 @@ static void walk_rtx (md_rtx_info *, rtx, struct accum_extract *);\n    in ACC.  */\n static void\n push_pathstr_operand (int operand, bool is_vector,\n-\t\t     struct accum_extract *acc)\n+\t\t     class accum_extract *acc)\n {\n   if (is_vector && 'a' + operand > 'z')\n     acc->pathstr.safe_push (operand + UPPER_OFFSET);\n@@ -106,7 +106,7 @@ gen_insn (md_rtx_info *info)\n   unsigned int op_count, dup_count, j;\n   struct extraction *p;\n   struct code_ptr *link;\n-  struct accum_extract acc;\n+  class accum_extract acc;\n \n   /* Walk the insn's pattern, remembering at all times the path\n      down to the walking point.  */\n@@ -224,7 +224,7 @@ VEC_char_to_string (vec<char> v)\n }\n \n static void\n-walk_rtx (md_rtx_info *info, rtx x, struct accum_extract *acc)\n+walk_rtx (md_rtx_info *info, rtx x, class accum_extract *acc)\n {\n   RTX_CODE code;\n   int i, len;"}, {"sha": "2e7bf27eedaebd37b54e007c16ee89f42bbc59f3", "filename": "gcc/genmatch.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -50,7 +50,7 @@ unsigned verbose;\n \n /* libccp helpers.  */\n \n-static struct line_maps *line_table;\n+static class line_maps *line_table;\n \n /* The rich_location class within libcpp requires a way to expand\n    location_t instances, and relies on the client code\n@@ -416,7 +416,7 @@ class fn_id : public id_base\n   unsigned int fn;\n };\n \n-struct simplify;\n+class simplify;\n \n /* Identifier that maps to a user-defined predicate.  */\n \n@@ -665,8 +665,8 @@ typedef hash_map<nofree_string_hash, unsigned> cid_map_t;\n \n /* The AST produced by parsing of the pattern definitions.  */\n \n-struct dt_operand;\n-struct capture_info;\n+class dt_operand;\n+class capture_info;\n \n /* The base class for operands.  */\n \n@@ -880,7 +880,7 @@ class simplify\n      produced when the pattern applies in the leafs.\n      For a (match ...) the leafs are either empty if it is a simple predicate\n      or the single expression specifying the matched operands.  */\n-  struct operand *result;\n+  class operand *result;\n   /* Collected 'for' expression operators that have to be replaced\n      in the lowering phase.  */\n   vec<vec<user_id *> > for_vec;\n@@ -933,7 +933,7 @@ print_operand (operand *o, FILE *f = stderr, bool flattened = false)\n }\n \n DEBUG_FUNCTION void\n-print_matches (struct simplify *s, FILE *f = stderr)\n+print_matches (class simplify *s, FILE *f = stderr)\n {\n   fprintf (f, \"for expression: \");\n   print_operand (s->match, f);\n@@ -1583,7 +1583,7 @@ lower (vec<simplify *>& simplifiers, bool gimple)\n    matching code.  It represents the 'match' expression of all\n    simplifies and has those as its leafs.  */\n \n-struct dt_simplify;\n+class dt_simplify;\n \n /* A hash-map collecting semantically equivalent leafs in the decision\n    tree for splitting out to separate functions.  */\n@@ -1719,7 +1719,7 @@ class decision_tree\n public:\n   dt_node *root;\n \n-  void insert (struct simplify *, unsigned);\n+  void insert (class simplify *, unsigned);\n   void gen (FILE *f, bool gimple);\n   void print (FILE *f = stderr);\n \n@@ -2025,7 +2025,7 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n /* Insert S into the decision tree.  */\n \n void\n-decision_tree::insert (struct simplify *s, unsigned pattern_no)\n+decision_tree::insert (class simplify *s, unsigned pattern_no)\n {\n   current_id = s->id;\n   dt_operand **indexes = XCNEWVEC (dt_operand *, s->capture_max + 1);\n@@ -4190,7 +4190,7 @@ parser::parse_operation ()\n /* Parse a capture.\n      capture = '@'<number>  */\n \n-struct operand *\n+class operand *\n parser::parse_capture (operand *op, bool require_existing)\n {\n   location_t src_loc = eat_token (CPP_ATSIGN)->src_loc;\n@@ -4227,7 +4227,7 @@ parser::parse_capture (operand *op, bool require_existing)\n /* Parse an expression\n      expr = '(' <operation>[capture][flag][type] <operand>... ')'  */\n \n-struct operand *\n+class operand *\n parser::parse_expr ()\n {\n   const cpp_token *token = peek ();\n@@ -4395,11 +4395,11 @@ parser::parse_c_expr (cpp_ttype start)\n    a standalone capture.\n      op = predicate | expr | c_expr | capture  */\n \n-struct operand *\n+class operand *\n parser::parse_op ()\n {\n   const cpp_token *token = peek ();\n-  struct operand *op = NULL;\n+  class operand *op = NULL;\n   if (token->type == CPP_OPEN_PAREN)\n     {\n       eat_token (CPP_OPEN_PAREN);\n@@ -4618,7 +4618,7 @@ parser::parse_simplify (simplify::simplify_kind kind,\n \n   const cpp_token *loc = peek ();\n   parsing_match_operand = true;\n-  struct operand *match = parse_op ();\n+  class operand *match = parse_op ();\n   finish_match_operand (match);\n   parsing_match_operand = false;\n   if (match->type == operand::OP_CAPTURE && !matcher)\n@@ -5090,7 +5090,7 @@ main (int argc, char **argv)\n \t}\n     }\n \n-  line_table = XCNEW (struct line_maps);\n+  line_table = XCNEW (class line_maps);\n   linemap_init (line_table, 0);\n   line_table->reallocator = xrealloc;\n   line_table->round_alloc_size = round_alloc_size;"}, {"sha": "03fa48286a284fbaa86ab4a9b3479c1e58c2215f", "filename": "gcc/genoutput.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -146,7 +146,7 @@ static struct operand_data **odata_end = &null_operand.next;\n class data\n {\n public:\n-  struct data *next;\n+  class data *next;\n   const char *name;\n   const char *template_code;\n   file_location loc;\n@@ -161,29 +161,29 @@ class data\n };\n \n /* This variable points to the first link in the insn chain.  */\n-static struct data *idata;\n+static class data *idata;\n \n /* This variable points to the end of the insn chain.  This is where\n    everything relevant from the machien description is appended to.  */\n-static struct data **idata_end;\n+static class data **idata_end;\n \n \f\n static void output_prologue (void);\n static void output_operand_data (void);\n static void output_insn_data (void);\n static void output_get_insn_name (void);\n-static void scan_operands (struct data *, rtx, int, int);\n+static void scan_operands (class data *, rtx, int, int);\n static int compare_operands (struct operand_data *,\n \t\t\t     struct operand_data *);\n-static void place_operands (struct data *);\n-static void process_template (struct data *, const char *);\n-static void validate_insn_alternatives (struct data *);\n-static void validate_insn_operands (struct data *);\n+static void place_operands (class data *);\n+static void process_template (class data *, const char *);\n+static void validate_insn_alternatives (class data *);\n+static void validate_insn_operands (class data *);\n \n class constraint_data\n {\n public:\n-  struct constraint_data *next_this_letter;\n+  class constraint_data *next_this_letter;\n   file_location loc;\n   unsigned int namelen;\n   char name[1];\n@@ -193,7 +193,7 @@ class constraint_data\n    are handled outside the define*_constraint mechanism.  */\n static const char indep_constraints[] = \",=+%*?!^$#&g\";\n \n-static struct constraint_data *\n+static class constraint_data *\n constraints_by_letter_table[1 << CHAR_BIT];\n \n static int mdep_constraint_len (const char *, file_location, int);\n@@ -277,12 +277,12 @@ output_operand_data (void)\n static void\n output_insn_data (void)\n {\n-  struct data *d;\n+  class data *d;\n   int name_offset = 0;\n   int next_name_offset;\n   const char * last_name = 0;\n   const char * next_name = 0;\n-  struct data *n;\n+  class data *n;\n \n   for (n = idata, next_name_offset = 1; n; n = n->next, next_name_offset++)\n     if (n->name)\n@@ -423,7 +423,7 @@ output_get_insn_name (void)\n    THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */\n \n static void\n-scan_operands (struct data *d, rtx part, int this_address_p,\n+scan_operands (class data *d, rtx part, int this_address_p,\n \t       int this_strict_low)\n {\n   int i, j;\n@@ -565,7 +565,7 @@ compare_operands (struct operand_data *d0, struct operand_data *d1)\n    find a subsequence that is the same, or allocate a new one at the end.  */\n \n static void\n-place_operands (struct data *d)\n+place_operands (class data *d)\n {\n   struct operand_data *od, *od2;\n   int i;\n@@ -619,7 +619,7 @@ place_operands (struct data *d)\n    templates, or C code to generate the assembler code template.  */\n \n static void\n-process_template (struct data *d, const char *template_code)\n+process_template (class data *d, const char *template_code)\n {\n   const char *cp;\n   int i;\n@@ -742,7 +742,7 @@ process_template (struct data *d, const char *template_code)\n /* Check insn D for consistency in number of constraint alternatives.  */\n \n static void\n-validate_insn_alternatives (struct data *d)\n+validate_insn_alternatives (class data *d)\n {\n   int n = 0, start;\n \n@@ -825,7 +825,7 @@ validate_insn_alternatives (struct data *d)\n /* Verify that there are no gaps in operand numbers for INSNs.  */\n \n static void\n-validate_insn_operands (struct data *d)\n+validate_insn_operands (class data *d)\n {\n   int i;\n \n@@ -835,7 +835,7 @@ validate_insn_operands (struct data *d)\n }\n \n static void\n-validate_optab_operands (struct data *d)\n+validate_optab_operands (class data *d)\n {\n   if (!d->name || d->name[0] == '\\0' || d->name[0] == '*')\n     return;\n@@ -980,7 +980,7 @@ gen_expand (md_rtx_info *info)\n static void\n init_insn_for_nothing (void)\n {\n-  idata = XCNEW (struct data);\n+  idata = XCNEW (class data);\n   new (idata) data ();\n   idata->name = \"*placeholder_for_nothing\";\n   idata->loc = file_location (\"<internal>\", 0, 0);\n@@ -1088,7 +1088,7 @@ note_constraint (md_rtx_info *info)\n {\n   rtx exp = info->def;\n   const char *name = XSTR (exp, 0);\n-  struct constraint_data **iter, **slot, *new_cdata;\n+  class constraint_data **iter, **slot, *new_cdata;\n \n   if (strcmp (name, \"TARGET_MEM_CONSTRAINT\") == 0)\n     name = general_mem;\n@@ -1138,8 +1138,8 @@ note_constraint (md_rtx_info *info)\n \t  return;\n \t}\n     }\n-  new_cdata = XNEWVAR (struct constraint_data,\n-\t\t       sizeof (struct constraint_data) + namelen);\n+  new_cdata = XNEWVAR (class constraint_data,\n+\t\t       sizeof (class constraint_data) + namelen);\n   new (new_cdata) constraint_data ();\n   strcpy (CONST_CAST (char *, new_cdata->name), name);\n   new_cdata->namelen = namelen;\n@@ -1155,7 +1155,7 @@ note_constraint (md_rtx_info *info)\n static int\n mdep_constraint_len (const char *s, file_location loc, int opno)\n {\n-  struct constraint_data *p;\n+  class constraint_data *p;\n \n   p = constraints_by_letter_table[(unsigned int)s[0]];\n "}, {"sha": "556c4bdd8695ae158e1b9769c138b3812b060174", "filename": "gcc/genpreds.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -669,8 +669,8 @@ write_one_predicate_function (struct pred_data *p)\n class constraint_data\n {\n public:\n-  struct constraint_data *next_this_letter;\n-  struct constraint_data *next_textual;\n+  class constraint_data *next_this_letter;\n+  class constraint_data *next_textual;\n   const char *name;\n   const char *c_name;    /* same as .name unless mangling is necessary */\n   file_location loc;     /* location of definition */\n@@ -690,13 +690,13 @@ class constraint_data\n \n /* Overview of all constraints beginning with a given letter.  */\n \n-static struct constraint_data *\n+static class constraint_data *\n constraints_by_letter_table[1<<CHAR_BIT];\n \n /* For looking up all the constraints in the order that they appeared\n    in the machine description.  */\n-static struct constraint_data *first_constraint;\n-static struct constraint_data **last_constraint_ptr = &first_constraint;\n+static class constraint_data *first_constraint;\n+static class constraint_data **last_constraint_ptr = &first_constraint;\n \n #define FOR_ALL_CONSTRAINTS(iter_) \\\n   for (iter_ = first_constraint; iter_; iter_ = iter_->next_textual)\n@@ -775,7 +775,7 @@ add_constraint (const char *name, const char *regclass,\n \t\trtx exp, bool is_memory, bool is_special_memory,\n \t\tbool is_address, file_location loc)\n {\n-  struct constraint_data *c, **iter, **slot;\n+  class constraint_data *c, **iter, **slot;\n   const char *p;\n   bool need_mangled_name = false;\n   bool is_const_int;\n@@ -909,7 +909,7 @@ add_constraint (const char *name, const char *regclass,\n     }\n \n \n-  c = XOBNEW (rtl_obstack, struct constraint_data);\n+  c = XOBNEW (rtl_obstack, class constraint_data);\n   c->name = name;\n   c->c_name = need_mangled_name ? mangle (name) : name;\n   c->loc = loc;\n@@ -980,7 +980,7 @@ process_define_register_constraint (md_rtx_info *info)\n static void\n choose_enum_order (void)\n {\n-  struct constraint_data *c;\n+  class constraint_data *c;\n \n   enum_order = XNEWVEC (const constraint_data *, num_constraints);\n   unsigned int next = 0;\n@@ -1077,7 +1077,7 @@ write_lookup_constraint_1 (void)\n \n   for (i = 0; i < ARRAY_SIZE (constraints_by_letter_table); i++)\n     {\n-      struct constraint_data *c = constraints_by_letter_table[i];\n+      class constraint_data *c = constraints_by_letter_table[i];\n       if (!c)\n \tcontinue;\n \n@@ -1117,7 +1117,7 @@ write_lookup_constraint_array (void)\n     {\n       if (i != 0)\n \tprintf (\",\\n  \");\n-      struct constraint_data *c = constraints_by_letter_table[i];\n+      class constraint_data *c = constraints_by_letter_table[i];\n       if (!c)\n \tprintf (\"CONSTRAINT__UNKNOWN\");\n       else if (c->namelen == 1)\n@@ -1143,7 +1143,7 @@ write_insn_constraint_len (void)\n \n   for (i = 0; i < ARRAY_SIZE (constraints_by_letter_table); i++)\n     {\n-      struct constraint_data *c = constraints_by_letter_table[i];\n+      class constraint_data *c = constraints_by_letter_table[i];\n \n       if (!c\n       \t  || c->namelen == 1)\n@@ -1152,7 +1152,7 @@ write_insn_constraint_len (void)\n       /* Constraints with multiple characters should have the same\n \t length.  */\n       {\n-\tstruct constraint_data *c2 = c->next_this_letter;\n+\tclass constraint_data *c2 = c->next_this_letter;\n \tsize_t len = c->namelen;\n \twhile (c2)\n \t  {\n@@ -1178,7 +1178,7 @@ write_insn_constraint_len (void)\n static void\n write_reg_class_for_constraint_1 (void)\n {\n-  struct constraint_data *c;\n+  class constraint_data *c;\n \n   puts (\"enum reg_class\\n\"\n \t\"reg_class_for_constraint_1 (enum constraint_num c)\\n\"\n@@ -1201,7 +1201,7 @@ write_reg_class_for_constraint_1 (void)\n static void\n write_tm_constrs_h (void)\n {\n-  struct constraint_data *c;\n+  class constraint_data *c;\n \n   printf (\"\\\n /* Generated automatically by the program '%s'\\n\\\n@@ -1288,7 +1288,7 @@ write_constraint_satisfied_p_array (void)\n static void\n write_insn_const_int_ok_for_constraint (void)\n {\n-  struct constraint_data *c;\n+  class constraint_data *c;\n \n   puts (\"bool\\n\"\n \t\"insn_const_int_ok_for_constraint (HOST_WIDE_INT ival, \""}, {"sha": "f20089eeee8e9d66b3e9b58213783c66616c6306", "filename": "gcc/genrecog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -950,7 +950,7 @@ list_head <T>::singleton () const\n   return first == last ? first : 0;\n }\n \f\n-struct state;\n+class state;\n \n /* Describes a possible successful return from a routine.  */\n struct acceptance_type\n@@ -1499,7 +1499,7 @@ operator != (const int_set &a, const int_set &b)\n   return !operator == (a, b);\n }\n \n-struct decision;\n+class decision;\n \n /* Represents a transition between states, dependent on the result of\n    a test T.  */\n@@ -2244,7 +2244,7 @@ optimize_subroutine_group (const char *type, state *root)\n \t   st.longest_backtrack, st.longest_backtrack_code);\n }\n \n-struct merge_pattern_info;\n+class merge_pattern_info;\n \n /* Represents a transition from one pattern to another.  */\n class merge_pattern_transition"}, {"sha": "0ad9995b6422df458531139f17d3c8495460551d", "filename": "gcc/gensupport.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -70,55 +70,55 @@ class queue_elem\n public:\n   rtx data;\n   file_location loc;\n-  struct queue_elem *next;\n+  class queue_elem *next;\n   /* In a DEFINE_INSN that came from a DEFINE_INSN_AND_SPLIT or\n      DEFINE_INSN_AND_REWRITE, SPLIT points to the generated DEFINE_SPLIT.  */\n-  struct queue_elem *split;\n+  class queue_elem *split;\n };\n \n #define MNEMONIC_ATTR_NAME \"mnemonic\"\n #define MNEMONIC_HTAB_SIZE 1024\n \n-static struct queue_elem *define_attr_queue;\n-static struct queue_elem **define_attr_tail = &define_attr_queue;\n-static struct queue_elem *define_pred_queue;\n-static struct queue_elem **define_pred_tail = &define_pred_queue;\n-static struct queue_elem *define_insn_queue;\n-static struct queue_elem **define_insn_tail = &define_insn_queue;\n-static struct queue_elem *define_cond_exec_queue;\n-static struct queue_elem **define_cond_exec_tail = &define_cond_exec_queue;\n-static struct queue_elem *define_subst_queue;\n-static struct queue_elem **define_subst_tail = &define_subst_queue;\n-static struct queue_elem *other_queue;\n-static struct queue_elem **other_tail = &other_queue;\n-static struct queue_elem *define_subst_attr_queue;\n-static struct queue_elem **define_subst_attr_tail = &define_subst_attr_queue;\n+static class queue_elem *define_attr_queue;\n+static class queue_elem **define_attr_tail = &define_attr_queue;\n+static class queue_elem *define_pred_queue;\n+static class queue_elem **define_pred_tail = &define_pred_queue;\n+static class queue_elem *define_insn_queue;\n+static class queue_elem **define_insn_tail = &define_insn_queue;\n+static class queue_elem *define_cond_exec_queue;\n+static class queue_elem **define_cond_exec_tail = &define_cond_exec_queue;\n+static class queue_elem *define_subst_queue;\n+static class queue_elem **define_subst_tail = &define_subst_queue;\n+static class queue_elem *other_queue;\n+static class queue_elem **other_tail = &other_queue;\n+static class queue_elem *define_subst_attr_queue;\n+static class queue_elem **define_subst_attr_tail = &define_subst_attr_queue;\n \n /* Mapping from DEFINE_* rtxes to their location in the source file.  */\n static hash_map <rtx, file_location> *rtx_locs;\n \n static void remove_constraints (rtx);\n \n-static int is_predicable (struct queue_elem *);\n+static int is_predicable (class queue_elem *);\n static void identify_predicable_attribute (void);\n static int n_alternatives (const char *);\n static void collect_insn_data (rtx, int *, int *);\n-static const char *alter_test_for_insn (struct queue_elem *,\n-\t\t\t\t\tstruct queue_elem *);\n+static const char *alter_test_for_insn (class queue_elem *,\n+\t\t\t\t\tclass queue_elem *);\n static char *shift_output_template (char *, const char *, int);\n-static const char *alter_output_for_insn (struct queue_elem *,\n-\t\t\t\t\t  struct queue_elem *,\n+static const char *alter_output_for_insn (class queue_elem *,\n+\t\t\t\t\t  class queue_elem *,\n \t\t\t\t\t  int, int);\n-static void process_one_cond_exec (struct queue_elem *);\n+static void process_one_cond_exec (class queue_elem *);\n static void process_define_cond_exec (void);\n static void init_predicate_table (void);\n static void record_insn_name (int, const char *);\n \n-static bool has_subst_attribute (struct queue_elem *, struct queue_elem *);\n+static bool has_subst_attribute (class queue_elem *, class queue_elem *);\n static const char * alter_output_for_subst_insn (rtx, int);\n-static void alter_attrs_for_subst_insn (struct queue_elem *, int);\n-static void process_substs_on_one_elem (struct queue_elem *,\n-\t\t\t\t\tstruct queue_elem *);\n+static void alter_attrs_for_subst_insn (class queue_elem *, int);\n+static void process_substs_on_one_elem (class queue_elem *,\n+\t\t\t\t\tclass queue_elem *);\n static rtx subst_dup (rtx, int, int);\n static void process_define_subst (void);\n \n@@ -400,11 +400,11 @@ process_define_predicate (rtx desc, file_location loc)\n /* Queue PATTERN on LIST_TAIL.  Return the address of the new queue\n    element.  */\n \n-static struct queue_elem *\n-queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n+static class queue_elem *\n+queue_pattern (rtx pattern, class queue_elem ***list_tail,\n \t       file_location loc)\n {\n-  struct queue_elem *e = XNEW (struct queue_elem);\n+  class queue_elem *e = XNEW (class queue_elem);\n   e->data = pattern;\n   e->loc = loc;\n   e->next = NULL;\n@@ -416,9 +416,9 @@ queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n \n /* Remove element ELEM from QUEUE.  */\n static void\n-remove_from_queue (struct queue_elem *elem, struct queue_elem **queue)\n+remove_from_queue (class queue_elem *elem, class queue_elem **queue)\n {\n-  struct queue_elem *prev, *e;\n+  class queue_elem *prev, *e;\n   prev = NULL;\n   for (e = *queue; e ; e = e->next)\n     {\n@@ -440,7 +440,7 @@ remove_from_queue (struct queue_elem *elem, struct queue_elem **queue)\n static void\n add_define_attr (const char *name)\n {\n-  struct queue_elem *e = XNEW (struct queue_elem);\n+  class queue_elem *e = XNEW (class queue_elem);\n   rtx t1 = rtx_alloc (DEFINE_ATTR);\n   XSTR (t1, 0) = name;\n   XSTR (t1, 1) = \"no,yes\";\n@@ -591,8 +591,8 @@ process_rtx (rtx desc, file_location loc)\n \trtx split;\n \trtvec attr;\n \tint i;\n-\tstruct queue_elem *insn_elem;\n-\tstruct queue_elem *split_elem;\n+\tclass queue_elem *insn_elem;\n+\tclass queue_elem *split_elem;\n \tint split_code = (GET_CODE (desc) == DEFINE_INSN_AND_REWRITE ? 5 : 6);\n \n \t/* Create a split with values from the insn_and_split.  */\n@@ -646,7 +646,7 @@ process_rtx (rtx desc, file_location loc)\n    a DEFINE_INSN.  */\n \n static int\n-is_predicable (struct queue_elem *elem)\n+is_predicable (class queue_elem *elem)\n {\n   rtvec vec = XVEC (elem->data, 4);\n   const char *value;\n@@ -716,8 +716,8 @@ is_predicable (struct queue_elem *elem)\n \n /* Find attribute SUBST in ELEM and assign NEW_VALUE to it.  */\n static void\n-change_subst_attribute (struct queue_elem *elem,\n-\t\t\tstruct queue_elem *subst_elem,\n+change_subst_attribute (class queue_elem *elem,\n+\t\t\tclass queue_elem *subst_elem,\n \t\t\tconst char *new_value)\n {\n   rtvec attrs_vec = XVEC (elem->data, 4);\n@@ -746,7 +746,7 @@ change_subst_attribute (struct queue_elem *elem,\n    words, we suppose the default value of the attribute to be 'no' since it is\n    always generated automatically in read-rtl.c.  */\n static bool\n-has_subst_attribute (struct queue_elem *elem, struct queue_elem *subst_elem)\n+has_subst_attribute (class queue_elem *elem, class queue_elem *subst_elem)\n {\n   rtvec attrs_vec = XVEC (elem->data, 4);\n   const char *value, *subst_name = XSTR (subst_elem->data, 0);\n@@ -979,7 +979,7 @@ subst_pattern_match (rtx x, rtx pt, file_location loc)\n static void\n identify_predicable_attribute (void)\n {\n-  struct queue_elem *elem;\n+  class queue_elem *elem;\n   char *p_true, *p_false;\n   const char *value;\n \n@@ -1327,8 +1327,8 @@ alter_constraints (rtx pattern, int n_dup, constraints_handler_t alter)\n }\n \n static const char *\n-alter_test_for_insn (struct queue_elem *ce_elem,\n-\t\t     struct queue_elem *insn_elem)\n+alter_test_for_insn (class queue_elem *ce_elem,\n+\t\t     class queue_elem *insn_elem)\n {\n   return rtx_reader_ptr->join_c_conditions (XSTR (ce_elem->data, 1),\n \t\t\t\t\t    XSTR (insn_elem->data, 2));\n@@ -1439,7 +1439,7 @@ alter_attrs_for_insn (rtx insn)\n \n   if (!global_changes_made)\n     {\n-      struct queue_elem *elem;\n+      class queue_elem *elem;\n \n       global_changes_made = true;\n       add_define_attr (\"ce_enabled\");\n@@ -1480,7 +1480,7 @@ alter_attrs_for_insn (rtx insn)\n    ELEM is a queue element, containing our rtl-template,\n    N_DUP - multiplication factor.  */\n static void\n-alter_attrs_for_subst_insn (struct queue_elem * elem, int n_dup)\n+alter_attrs_for_subst_insn (class queue_elem * elem, int n_dup)\n {\n   rtvec vec = XVEC (elem->data, 4);\n   int num_elem;\n@@ -1543,8 +1543,8 @@ shift_output_template (char *dest, const char *src, int disp)\n }\n \n static const char *\n-alter_output_for_insn (struct queue_elem *ce_elem,\n-\t\t       struct queue_elem *insn_elem,\n+alter_output_for_insn (class queue_elem *ce_elem,\n+\t\t       class queue_elem *insn_elem,\n \t\t       int alt, int max_op)\n {\n   const char *ce_out, *insn_out;\n@@ -1732,9 +1732,9 @@ alter_output_for_subst_insn (rtx insn, int alt)\n /* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */\n \n static void\n-process_one_cond_exec (struct queue_elem *ce_elem)\n+process_one_cond_exec (class queue_elem *ce_elem)\n {\n-  struct queue_elem *insn_elem;\n+  class queue_elem *insn_elem;\n   for (insn_elem = define_insn_queue; insn_elem ; insn_elem = insn_elem->next)\n     {\n       int alternatives, max_operand;\n@@ -1838,10 +1838,10 @@ process_one_cond_exec (struct queue_elem *ce_elem)\n    was applied, ELEM would be deleted.  */\n \n static void\n-process_substs_on_one_elem (struct queue_elem *elem,\n-\t\t\t    struct queue_elem *queue)\n+process_substs_on_one_elem (class queue_elem *elem,\n+\t\t\t    class queue_elem *queue)\n {\n-  struct queue_elem *subst_elem;\n+  class queue_elem *subst_elem;\n   int i, j, patterns_match;\n \n   for (subst_elem = define_subst_queue;\n@@ -2248,7 +2248,7 @@ subst_dup (rtx pattern, int n_alt, int n_subst_alt)\n static void\n process_define_cond_exec (void)\n {\n-  struct queue_elem *elem;\n+  class queue_elem *elem;\n \n   identify_predicable_attribute ();\n   if (have_error)\n@@ -2264,7 +2264,7 @@ process_define_cond_exec (void)\n static void\n process_define_subst (void)\n {\n-  struct queue_elem *elem, *elem_attr;\n+  class queue_elem *elem, *elem_attr;\n \n   /* Check if each define_subst has corresponding define_subst_attr.  */\n   for (elem = define_subst_queue; elem ; elem = elem->next)\n@@ -2475,7 +2475,7 @@ mnemonic_htab_callback (void **slot, void *info ATTRIBUTE_UNUSED)\n static void\n gen_mnemonic_attr (void)\n {\n-  struct queue_elem *elem;\n+  class queue_elem *elem;\n   rtx mnemonic_attr = NULL;\n   htab_t mnemonic_htab;\n   const char *str, *p;\n@@ -2552,7 +2552,7 @@ gen_mnemonic_attr (void)\n static void\n check_define_attr_duplicates ()\n {\n-  struct queue_elem *elem;\n+  class queue_elem *elem;\n   htab_t attr_htab;\n   char * attr_name;\n   void **slot;\n@@ -2648,7 +2648,7 @@ read_md_rtx (md_rtx_info *info)\n      to use elided pattern numbers for anything.  */\n   do\n     {\n-      struct queue_elem **queue, *elem;\n+      class queue_elem **queue, *elem;\n \n       /* Read all patterns from a given queue before moving on to the next.  */\n       if (define_attr_queue != NULL)"}, {"sha": "a2736bc1dfa0fa8d47ce3d7459fcdbeaf07e395d", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -200,7 +200,7 @@ static const size_t extra_order_size_table[] = {\n   sizeof (struct function),\n   sizeof (struct basic_block_def),\n   sizeof (struct cgraph_node),\n-  sizeof (struct loop),\n+  sizeof (class loop),\n };\n \n /* The total number of orders.  */"}, {"sha": "b56155b1fefec3585899cc3c95602880b4730f1d", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -159,7 +159,7 @@ dump_reduction (reduction_p re)\n \n /* Dump LOOP's induction IV.  */\n static void\n-dump_induction (struct loop *loop, induction_p iv)\n+dump_induction (class loop *loop, induction_p iv)\n {\n   fprintf (dump_file, \"  Induction:  \");\n   print_generic_expr (dump_file, iv->var, TDF_SLIM);\n@@ -175,7 +175,7 @@ dump_induction (struct loop *loop, induction_p iv)\n class loop_cand\n {\n public:\n-  loop_cand (struct loop *, struct loop *);\n+  loop_cand (class loop *, class loop *);\n   ~loop_cand ();\n \n   reduction_p find_reduction_by_stmt (gimple *);\n@@ -189,10 +189,10 @@ class loop_cand\n   void undo_simple_reduction (reduction_p, bitmap);\n \n   /* The loop itself.  */\n-  struct loop *m_loop;\n+  class loop *m_loop;\n   /* The outer loop for interchange.  It equals to loop if this loop cand\n      itself represents the outer loop.  */\n-  struct loop *m_outer;\n+  class loop *m_outer;\n   /* Vector of induction variables in loop.  */\n   vec<induction_p> m_inductions;\n   /* Vector of reduction variables in loop.  */\n@@ -211,7 +211,7 @@ class loop_cand\n \n /* Constructor.  */\n \n-loop_cand::loop_cand (struct loop *loop, struct loop *outer)\n+loop_cand::loop_cand (class loop *loop, class loop *outer)\n   : m_loop (loop), m_outer (outer), m_exit (single_exit (loop)),\n     m_bbs (get_loop_body (loop)), m_num_stmts (0), m_const_init_reduc (0)\n {\n@@ -241,7 +241,7 @@ loop_cand::~loop_cand ()\n /* Return single use stmt of VAR in LOOP, otherwise return NULL.  */\n \n static gimple *\n-single_use_in_loop (tree var, struct loop *loop)\n+single_use_in_loop (tree var, class loop *loop)\n {\n   gimple *stmt, *res = NULL;\n   use_operand_p use_p;\n@@ -951,7 +951,7 @@ free_data_refs_with_aux (vec<data_reference_p> datarefs)\n class tree_loop_interchange\n {\n public:\n-  tree_loop_interchange (vec<struct loop *> loop_nest)\n+  tree_loop_interchange (vec<class loop *> loop_nest)\n     : m_loop_nest (loop_nest), m_niters_iv_var (NULL_TREE),\n       m_dce_seeds (BITMAP_ALLOC (NULL)) { }\n   ~tree_loop_interchange () { BITMAP_FREE (m_dce_seeds); }\n@@ -962,10 +962,10 @@ class tree_loop_interchange\n   bool valid_data_dependences (unsigned, unsigned, vec<ddr_p>);\n   void interchange_loops (loop_cand &, loop_cand &);\n   void map_inductions_to_loop (loop_cand &, loop_cand &);\n-  void move_code_to_inner_loop (struct loop *, struct loop *, basic_block *);\n+  void move_code_to_inner_loop (class loop *, class loop *, basic_block *);\n \n   /* The whole loop nest in which interchange is ongoing.  */\n-  vec<struct loop *> m_loop_nest;\n+  vec<class loop *> m_loop_nest;\n   /* We create new IV which is only used in loop's exit condition check.\n      In case of 3-level loop nest interchange, when we interchange the\n      innermost two loops, new IV created in the middle level loop does\n@@ -1079,7 +1079,7 @@ tree_loop_interchange::interchange_loops (loop_cand &iloop, loop_cand &oloop)\n     }\n \n   /* Prepare niters for both loops.  */\n-  struct loop *loop_nest = m_loop_nest[0];\n+  class loop *loop_nest = m_loop_nest[0];\n   edge instantiate_below = loop_preheader_edge (loop_nest);\n   gsi = gsi_last_bb (loop_preheader_edge (loop_nest)->src);\n   i_niters = number_of_latch_executions (iloop.m_loop);\n@@ -1214,8 +1214,8 @@ tree_loop_interchange::map_inductions_to_loop (loop_cand &src, loop_cand &tgt)\n /* Move stmts of outer loop to inner loop.  */\n \n void\n-tree_loop_interchange::move_code_to_inner_loop (struct loop *outer,\n-\t\t\t\t\t\tstruct loop *inner,\n+tree_loop_interchange::move_code_to_inner_loop (class loop *outer,\n+\t\t\t\t\t\tclass loop *inner,\n \t\t\t\t\t\tbasic_block *outer_bbs)\n {\n   basic_block oloop_exit_bb = single_exit (outer)->src;\n@@ -1276,7 +1276,7 @@ tree_loop_interchange::move_code_to_inner_loop (struct loop *outer,\n \t   arr[i][j - 1][k] = 0;  */\n \n static void\n-compute_access_stride (struct loop *loop_nest, struct loop *loop,\n+compute_access_stride (class loop *loop_nest, class loop *loop,\n \t\t       data_reference_p dr)\n {\n   vec<tree> *strides = new vec<tree> ();\n@@ -1320,10 +1320,10 @@ compute_access_stride (struct loop *loop_nest, struct loop *loop,\n   if (! chrec_contains_undetermined (scev))\n     {\n       tree sl = scev;\n-      struct loop *expected = loop;\n+      class loop *expected = loop;\n       while (TREE_CODE (sl) == POLYNOMIAL_CHREC)\n \t{\n-\t  struct loop *sl_loop = get_chrec_loop (sl);\n+\t  class loop *sl_loop = get_chrec_loop (sl);\n \t  while (sl_loop != expected)\n \t    {\n \t      strides->safe_push (size_int (0));\n@@ -1351,8 +1351,8 @@ compute_access_stride (struct loop *loop_nest, struct loop *loop,\n    all data references.  If access strides cannot be computed at least\n    for two levels of loop for any data reference, it returns NULL.  */\n \n-static struct loop *\n-compute_access_strides (struct loop *loop_nest, struct loop *loop,\n+static class loop *\n+compute_access_strides (class loop *loop_nest, class loop *loop,\n \t\t\tvec<data_reference_p> datarefs)\n {\n   unsigned i, j, num_loops = (unsigned) -1;\n@@ -1390,8 +1390,8 @@ compute_access_strides (struct loop *loop_nest, struct loop *loop,\n    of loops that isn't in current LOOP_NEST.  */\n \n static void\n-prune_access_strides_not_in_loop (struct loop *loop_nest,\n-\t\t\t\t  struct loop *innermost,\n+prune_access_strides_not_in_loop (class loop *loop_nest,\n+\t\t\t\t  class loop *innermost,\n \t\t\t\t  vec<data_reference_p> datarefs)\n {\n   data_reference_p dr;\n@@ -1712,7 +1712,7 @@ class pass_linterchange : public gimple_opt_pass\n \tnest with LOOP.  */\n \n static bool\n-proper_loop_form_for_interchange (struct loop *loop, struct loop **min_outer)\n+proper_loop_form_for_interchange (class loop *loop, class loop **min_outer)\n {\n   edge e0, e1, exit;\n \n@@ -1811,14 +1811,14 @@ proper_loop_form_for_interchange (struct loop *loop, struct loop **min_outer)\n    should be interchanged by looking into all DATAREFS.  */\n \n static bool\n-should_interchange_loop_nest (struct loop *loop_nest, struct loop *innermost,\n+should_interchange_loop_nest (class loop *loop_nest, class loop *innermost,\n \t\t\t      vec<data_reference_p> datarefs)\n {\n   unsigned idx = loop_depth (innermost) - loop_depth (loop_nest);\n   gcc_assert (idx > 0);\n \n   /* Check if any two adjacent loops should be interchanged.  */\n-  for (struct loop *loop = innermost;\n+  for (class loop *loop = innermost;\n        loop != loop_nest; loop = loop_outer (loop), idx--)\n     if (should_interchange_loops (idx, idx - 1, datarefs, 0, 0,\n \t\t\t\t  loop == innermost, false))\n@@ -1838,7 +1838,7 @@ tree_loop_interchange_compute_ddrs (vec<loop_p> loop_nest,\n \t\t\t\t    vec<ddr_p> *ddrs)\n {\n   struct data_reference *a, *b;\n-  struct loop *innermost = loop_nest.last ();\n+  class loop *innermost = loop_nest.last ();\n \n   for (unsigned i = 0; datarefs.iterate (i, &a); ++i)\n     {\n@@ -1880,7 +1880,7 @@ tree_loop_interchange_compute_ddrs (vec<loop_p> loop_nest,\n /* Prune DATAREFS by removing any data reference not inside of LOOP.  */\n \n static inline void\n-prune_datarefs_not_in_loop (struct loop *loop, vec<data_reference_p> datarefs)\n+prune_datarefs_not_in_loop (class loop *loop, vec<data_reference_p> datarefs)\n {\n   unsigned i, j;\n   struct data_reference *dr;\n@@ -1907,10 +1907,10 @@ prune_datarefs_not_in_loop (struct loop *loop, vec<data_reference_p> datarefs)\n    inner loop of that basic block's father loop.  On success, return the\n    outer loop of the result loop nest.  */\n \n-static struct loop *\n-prepare_data_references (struct loop *loop, vec<data_reference_p> *datarefs)\n+static class loop *\n+prepare_data_references (class loop *loop, vec<data_reference_p> *datarefs)\n {\n-  struct loop *loop_nest = loop;\n+  class loop *loop_nest = loop;\n   vec<data_reference_p> *bb_refs;\n   basic_block bb, *bbs = get_loop_body_in_dom_order (loop);\n \n@@ -1974,11 +1974,11 @@ prepare_data_references (struct loop *loop, vec<data_reference_p> *datarefs)\n    in interchange.  */\n \n static bool\n-prepare_perfect_loop_nest (struct loop *loop, vec<loop_p> *loop_nest,\n+prepare_perfect_loop_nest (class loop *loop, vec<loop_p> *loop_nest,\n \t\t\t   vec<data_reference_p> *datarefs, vec<ddr_p> *ddrs)\n {\n-  struct loop *start_loop = NULL, *innermost = loop;\n-  struct loop *outermost = loops_for_fn (cfun)->tree_root;\n+  class loop *start_loop = NULL, *innermost = loop;\n+  class loop *outermost = loops_for_fn (cfun)->tree_root;\n \n   /* Find loop nest from the innermost loop.  The outermost is the innermost\n      outer*/\n@@ -2064,7 +2064,7 @@ pass_linterchange::execute (function *fun)\n     return 0;\n \n   bool changed_p = false;\n-  struct loop *loop;\n+  class loop *loop;\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n       vec<loop_p> loop_nest = vNULL;"}, {"sha": "11153f5402555737fa888bb8f4b4e558756ccf2a", "filename": "gcc/gimple-loop-jam.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-loop-jam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-loop-jam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-jam.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -103,11 +103,11 @@ along with GCC; see the file COPYING3.  If not see\n    to the OLD loop or the outer loop of OLD now is inside LOOP.  */\n \n static void\n-merge_loop_tree (struct loop *loop, struct loop *old)\n+merge_loop_tree (class loop *loop, class loop *old)\n {\n   basic_block *bbs;\n   int i, n;\n-  struct loop *subloop;\n+  class loop *subloop;\n   edge e;\n   edge_iterator ei;\n \n@@ -186,11 +186,11 @@ bb_prevents_fusion_p (basic_block bb)\n    If so return true, otherwise return false.  */\n \n static bool\n-unroll_jam_possible_p (struct loop *outer, struct loop *loop)\n+unroll_jam_possible_p (class loop *outer, class loop *loop)\n {\n   basic_block *bbs;\n   int i, n;\n-  struct tree_niter_desc niter;\n+  class tree_niter_desc niter;\n \n   /* When fusing the loops we skip the latch block\n      of the first one, so it mustn't have any effects to\n@@ -301,9 +301,9 @@ unroll_jam_possible_p (struct loop *outer, struct loop *loop)\n    be in appropriate form.  */\n \n static void\n-fuse_loops (struct loop *loop)\n+fuse_loops (class loop *loop)\n {\n-  struct loop *next = loop->next;\n+  class loop *next = loop->next;\n \n   while (next)\n     {\n@@ -353,7 +353,7 @@ fuse_loops (struct loop *loop)\n \n       merge_loop_tree (loop, next);\n       gcc_assert (!next->num_nodes);\n-      struct loop *ln = next->next;\n+      class loop *ln = next->next;\n       delete_loop (next);\n       next = ln;\n     }\n@@ -422,15 +422,15 @@ adjust_unroll_factor (struct data_dependence_relation *ddr,\n static unsigned int\n tree_loop_unroll_and_jam (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool changed = false;\n \n   gcc_assert (scev_initialized_p ());\n \n   /* Go through all innermost loops.  */\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     {\n-      struct loop *outer = loop_outer (loop);\n+      class loop *outer = loop_outer (loop);\n \n       if (loop_depth (loop) < 2\n \t  || optimize_loop_nest_for_size_p (outer))\n@@ -442,7 +442,7 @@ tree_loop_unroll_and_jam (void)\n       vec<data_reference_p> datarefs;\n       vec<ddr_p> dependences;\n       unsigned unroll_factor, profit_unroll, removed;\n-      struct tree_niter_desc desc;\n+      class tree_niter_desc desc;\n       bool unroll = false;\n \n       auto_vec<loop_p, 3> loop_nest;"}, {"sha": "be8c2d89cfda40782c7842ed77455ad9fbd98ea0", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -190,7 +190,7 @@ class address_info\n \n   /* The loop containing STMT (cached for convenience).  If multiple\n      statements share the same address, they all belong to this loop.  */\n-  struct loop *loop;\n+  class loop *loop;\n \n   /* A decomposition of the calculation into a sum of terms plus an\n      optional base.  When BASE is provided, it is never an SSA name.\n@@ -229,7 +229,7 @@ class loop_info\n \n   /* The outermost loop that can handle all the version checks\n      described below.  */\n-  struct loop *outermost;\n+  class loop *outermost;\n \n   /* The first entry in the list of blocks that belong to this loop\n      (and not to subloops).  m_next_block_in_loop provides the chain\n@@ -242,7 +242,7 @@ class loop_info\n \n   /* If versioning succeeds, this points the version of the loop that\n      assumes the version conditions holds.  */\n-  struct loop *optimized_loop;\n+  class loop *optimized_loop;\n };\n \n /* The main pass structure.  */\n@@ -285,9 +285,9 @@ class loop_versioning\n     loop_info &m_li;\n   };\n \n-  loop_info &get_loop_info (struct loop *loop) { return m_loops[loop->num]; }\n+  loop_info &get_loop_info (class loop *loop) { return m_loops[loop->num]; }\n \n-  unsigned int max_insns_for_loop (struct loop *);\n+  unsigned int max_insns_for_loop (class loop *);\n   bool expensive_stmt_p (gimple *);\n \n   void version_for_unity (gimple *, tree);\n@@ -298,7 +298,7 @@ class loop_versioning\n   inner_likelihood get_inner_likelihood (tree, unsigned HOST_WIDE_INT);\n   void dump_inner_likelihood (address_info &, address_term_info &);\n   void analyze_stride (address_info &, address_term_info &,\n-\t\t       tree, struct loop *);\n+\t\t       tree, class loop *);\n   bool find_per_loop_multiplication (address_info &, address_term_info &);\n   bool analyze_term_using_scevs (address_info &, address_term_info &);\n   void analyze_arbitrary_term (address_info &, address_term_info &);\n@@ -309,15 +309,15 @@ class loop_versioning\n   bool analyze_block (basic_block);\n   bool analyze_blocks ();\n \n-  void prune_loop_conditions (struct loop *, vr_values *);\n+  void prune_loop_conditions (class loop *, vr_values *);\n   bool prune_conditions ();\n \n-  void merge_loop_info (struct loop *, struct loop *);\n-  void add_loop_to_queue (struct loop *);\n-  bool decide_whether_loop_is_versionable (struct loop *);\n+  void merge_loop_info (class loop *, class loop *);\n+  void add_loop_to_queue (class loop *);\n+  bool decide_whether_loop_is_versionable (class loop *);\n   bool make_versioning_decisions ();\n \n-  bool version_loop (struct loop *);\n+  bool version_loop (class loop *);\n   void implement_versioning_decisions ();\n \n   /* The function we're optimizing.  */\n@@ -348,7 +348,7 @@ class loop_versioning\n   auto_vec<basic_block> m_next_block_in_loop;\n \n   /* The list of loops that we've decided to version.  */\n-  auto_vec<struct loop *> m_loops_to_version;\n+  auto_vec<class loop *> m_loops_to_version;\n \n   /* A table of addresses in the current loop, keyed off their values\n      but not their offsets.  */\n@@ -602,7 +602,7 @@ loop_versioning::~loop_versioning ()\n    interchange or outer-loop vectorization).  */\n \n unsigned int\n-loop_versioning::max_insns_for_loop (struct loop *loop)\n+loop_versioning::max_insns_for_loop (class loop *loop)\n {\n   return (loop->inner\n \t  ? PARAM_VALUE (PARAM_LOOP_VERSIONING_MAX_OUTER_INSNS)\n@@ -633,15 +633,15 @@ loop_versioning::expensive_stmt_p (gimple *stmt)\n void\n loop_versioning::version_for_unity (gimple *stmt, tree name)\n {\n-  struct loop *loop = loop_containing_stmt (stmt);\n+  class loop *loop = loop_containing_stmt (stmt);\n   loop_info &li = get_loop_info (loop);\n \n   if (bitmap_set_bit (&li.unity_names, SSA_NAME_VERSION (name)))\n     {\n       /* This is the first time we've wanted to version LOOP for NAME.\n \t Keep track of the outermost loop that can handle all versioning\n \t checks in LI.  */\n-      struct loop *outermost\n+      class loop *outermost\n \t= outermost_invariant_loop_for_expr (loop, name);\n       if (loop_depth (li.outermost) < loop_depth (outermost))\n \tli.outermost = outermost;\n@@ -834,7 +834,7 @@ loop_versioning::dump_inner_likelihood (address_info &address,\n void\n loop_versioning::analyze_stride (address_info &address,\n \t\t\t\t address_term_info &term,\n-\t\t\t\t tree stride, struct loop *op_loop)\n+\t\t\t\t tree stride, class loop *op_loop)\n {\n   term.stride = stride;\n \n@@ -895,7 +895,7 @@ loop_versioning::find_per_loop_multiplication (address_info &address,\n   if (!mult || gimple_assign_rhs_code (mult) != MULT_EXPR)\n     return false;\n \n-  struct loop *mult_loop = loop_containing_stmt (mult);\n+  class loop *mult_loop = loop_containing_stmt (mult);\n   if (!loop_outer (mult_loop))\n     return false;\n \n@@ -937,7 +937,7 @@ loop_versioning::analyze_term_using_scevs (address_info &address,\n   if (!setter)\n     return false;\n \n-  struct loop *wrt_loop = loop_containing_stmt (setter);\n+  class loop *wrt_loop = loop_containing_stmt (setter);\n   if (!loop_outer (wrt_loop))\n     return false;\n \n@@ -1199,7 +1199,7 @@ loop_versioning::record_address_fragment (gimple *stmt,\n \n   /* Quick exit if no part of the address is calculated in STMT's loop,\n      since such addresses have no versioning opportunities.  */\n-  struct loop *loop = loop_containing_stmt (stmt);\n+  class loop *loop = loop_containing_stmt (stmt);\n   if (expr_invariant_in_loop_p (loop, expr))\n     return;\n \n@@ -1375,7 +1375,7 @@ loop_versioning::analyze_expr (gimple *stmt, tree expr)\n bool\n loop_versioning::analyze_block (basic_block bb)\n {\n-  struct loop *loop = bb->loop_father;\n+  class loop *loop = bb->loop_father;\n   loop_info &li = get_loop_info (loop);\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n        gsi_next (&gsi))\n@@ -1424,7 +1424,7 @@ loop_versioning::analyze_blocks ()\n      versioning at that level could be useful in some cases.  */\n   get_loop_info (get_loop (m_fn, 0)).rejected_p = true;\n \n-  struct loop *loop;\n+  class loop *loop;\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       loop_info &linfo = get_loop_info (loop);\n@@ -1435,7 +1435,7 @@ loop_versioning::analyze_blocks ()\n \n       /* See whether an inner loop prevents versioning of this loop.  */\n       if (!linfo.rejected_p)\n-\tfor (struct loop *inner = loop->inner; inner; inner = inner->next)\n+\tfor (class loop *inner = loop->inner; inner; inner = inner->next)\n \t  if (get_loop_info (inner).rejected_p)\n \t    {\n \t      linfo.rejected_p = true;\n@@ -1479,7 +1479,7 @@ loop_versioning::analyze_blocks ()\n    LOOP.  */\n \n void\n-loop_versioning::prune_loop_conditions (struct loop *loop, vr_values *vrs)\n+loop_versioning::prune_loop_conditions (class loop *loop, vr_values *vrs)\n {\n   loop_info &li = get_loop_info (loop);\n \n@@ -1525,7 +1525,7 @@ loop_versioning::prune_conditions ()\n    OUTER.  */\n \n void\n-loop_versioning::merge_loop_info (struct loop *outer, struct loop *inner)\n+loop_versioning::merge_loop_info (class loop *outer, class loop *inner)\n {\n   loop_info &inner_li = get_loop_info (inner);\n   loop_info &outer_li = get_loop_info (outer);\n@@ -1549,7 +1549,7 @@ loop_versioning::merge_loop_info (struct loop *outer, struct loop *inner)\n /* Add LOOP to the queue of loops to version.  */\n \n void\n-loop_versioning::add_loop_to_queue (struct loop *loop)\n+loop_versioning::add_loop_to_queue (class loop *loop)\n {\n   loop_info &li = get_loop_info (loop);\n \n@@ -1571,15 +1571,15 @@ loop_versioning::add_loop_to_queue (struct loop *loop)\n    We have already made this decision for all inner loops of LOOP.  */\n \n bool\n-loop_versioning::decide_whether_loop_is_versionable (struct loop *loop)\n+loop_versioning::decide_whether_loop_is_versionable (class loop *loop)\n {\n   loop_info &li = get_loop_info (loop);\n \n   if (li.rejected_p)\n     return false;\n \n   /* Examine the decisions made for inner loops.  */\n-  for (struct loop *inner = loop->inner; inner; inner = inner->next)\n+  for (class loop *inner = loop->inner; inner; inner = inner->next)\n     {\n       loop_info &inner_li = get_loop_info (inner);\n       if (inner_li.rejected_p)\n@@ -1631,7 +1631,7 @@ loop_versioning::decide_whether_loop_is_versionable (struct loop *loop)\n     }\n \n   /* Hoist all version checks from subloops to this loop.  */\n-  for (struct loop *subloop = loop->inner; subloop; subloop = subloop->next)\n+  for (class loop *subloop = loop->inner; subloop; subloop = subloop->next)\n     merge_loop_info (loop, subloop);\n \n   return true;\n@@ -1646,7 +1646,7 @@ loop_versioning::make_versioning_decisions ()\n   AUTO_DUMP_SCOPE (\"make_versioning_decisions\",\n \t\t   dump_user_location_t::from_function_decl (m_fn->decl));\n \n-  struct loop *loop;\n+  class loop *loop;\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n       loop_info &linfo = get_loop_info (loop);\n@@ -1663,7 +1663,7 @@ loop_versioning::make_versioning_decisions ()\n \t  /* We can't version this loop, so individually version any\n \t     subloops that would benefit and haven't been versioned yet.  */\n \t  linfo.rejected_p = true;\n-\t  for (struct loop *subloop = loop->inner; subloop;\n+\t  for (class loop *subloop = loop->inner; subloop;\n \t       subloop = subloop->next)\n \t    if (get_loop_info (subloop).worth_versioning_p ())\n \t      add_loop_to_queue (subloop);\n@@ -1677,7 +1677,7 @@ loop_versioning::make_versioning_decisions ()\n    cached in the associated loop_info.  Return true on success.  */\n \n bool\n-loop_versioning::version_loop (struct loop *loop)\n+loop_versioning::version_loop (class loop *loop)\n {\n   loop_info &li = get_loop_info (loop);\n \n@@ -1739,7 +1739,7 @@ loop_versioning::implement_versioning_decisions ()\n      user-facing at this point.  */\n \n   bool any_succeeded_p = false;\n-  struct loop *loop;\n+  class loop *loop;\n   unsigned int i;\n   FOR_EACH_VEC_ELT (m_loops_to_version, i, loop)\n     if (version_loop (loop))"}, {"sha": "46f5a019776223a767c55c842fedc375db8eb76f", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -262,7 +262,7 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n \t     use PHI arg ranges which may be still UNDEFINED but have\n \t     to use VARYING for them.  But we can still resort to\n \t     SCEV for loop header PHIs.  */\n-\t  struct loop *l;\n+\t  class loop *l;\n \t  if (scev_initialized_p ()\n \t      && interesting\n \t      && (l = loop_containing_stmt (phi))"}, {"sha": "0bf64b314d697d36173cb6bc1dc28c96a80ec7a9", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -2159,7 +2159,7 @@ class pass_store_merging : public gimple_opt_pass\n   virtual unsigned int execute (function *);\n \n private:\n-  hash_map<tree_operand_hash, struct imm_store_chain_info *> m_stores;\n+  hash_map<tree_operand_hash, class imm_store_chain_info *> m_stores;\n \n   /* Form a doubly-linked stack of the elements of m_stores, so that\n      we can iterate over them in a predictable way.  Using this order\n@@ -3097,7 +3097,7 @@ split_store::split_store (unsigned HOST_WIDE_INT bp,\n    if there is exactly one original store in the range.  */\n \n static store_immediate_info *\n-find_constituent_stores (struct merged_store_group *group,\n+find_constituent_stores (class merged_store_group *group,\n \t\t\t vec<store_immediate_info *> *stores,\n \t\t\t unsigned int *first,\n \t\t\t unsigned HOST_WIDE_INT bitpos,\n@@ -3240,7 +3240,7 @@ count_multiple_uses (store_immediate_info *info)\n static unsigned int\n split_group (merged_store_group *group, bool allow_unaligned_store,\n \t     bool allow_unaligned_load, bool bzero_first,\n-\t     vec<struct split_store *> *split_stores,\n+\t     vec<split_store *> *split_stores,\n \t     unsigned *total_orig,\n \t     unsigned *total_new)\n {\n@@ -3277,7 +3277,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \t  if (align_bitpos)\n \t    align = least_bit_hwi (align_bitpos);\n \t  bytepos = group->start / BITS_PER_UNIT;\n-\t  struct split_store *store\n+\t  split_store *store\n \t    = new split_store (bytepos, group->width, align);\n \t  unsigned int first = 0;\n \t  find_constituent_stores (group, &store->orig_stores,\n@@ -3335,7 +3335,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n       ret = 1;\n       if (split_stores)\n \t{\n-\t  struct split_store *store\n+\t  split_store *store\n \t    = new split_store (bytepos, group->stores[0]->bitsize, align_base);\n \t  store->orig_stores.safe_push (group->stores[0]);\n \t  store->orig = true;\n@@ -3462,7 +3462,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \n       if (split_stores)\n \t{\n-\t  struct split_store *store\n+\t  split_store *store\n \t    = new split_store (try_pos, try_size, align);\n \t  info = find_constituent_stores (group, &store->orig_stores,\n \t\t\t\t\t  &first, try_bitpos, try_size);\n@@ -3483,7 +3483,7 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n   if (total_orig)\n     {\n       unsigned int i;\n-      struct split_store *store;\n+      split_store *store;\n       /* If we are reusing some original stores and any of the\n \t original SSA_NAMEs had multiple uses, we need to subtract\n \t those now before we add the new ones.  */\n@@ -3650,7 +3650,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   if (orig_num_stmts < 2)\n     return false;\n \n-  auto_vec<struct split_store *, 32> split_stores;\n+  auto_vec<class split_store *, 32> split_stores;\n   bool allow_unaligned_store\n     = !STRICT_ALIGNMENT && PARAM_VALUE (PARAM_STORE_MERGING_ALLOW_UNALIGNED);\n   bool allow_unaligned_load = allow_unaligned_store;\n@@ -4610,7 +4610,7 @@ pass_store_merging::process_store (gimple *stmt)\n   if (!ins_stmt)\n     memset (&n, 0, sizeof (n));\n \n-  struct imm_store_chain_info **chain_info = NULL;\n+  class imm_store_chain_info **chain_info = NULL;\n   if (base_addr)\n     chain_info = m_stores.get (base_addr);\n \n@@ -4646,7 +4646,7 @@ pass_store_merging::process_store (gimple *stmt)\n   /* Store aliases any existing chain?  */\n   terminate_all_aliasing_chains (NULL, stmt);\n   /* Start a new chain.  */\n-  struct imm_store_chain_info *new_chain\n+  class imm_store_chain_info *new_chain\n     = new imm_store_chain_info (m_stores_head, base_addr);\n   info = new store_immediate_info (const_bitsize, const_bitpos,\n \t\t\t\t   const_bitregion_start,"}, {"sha": "d343da005e4a55465b8ade9a4946e5e2c4166e04", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -297,8 +297,8 @@ class slsr_cand_d\n   tree cached_basis;\n };\n \n-typedef struct slsr_cand_d slsr_cand, *slsr_cand_t;\n-typedef const struct slsr_cand_d *const_slsr_cand_t;\n+typedef class slsr_cand_d slsr_cand, *slsr_cand_t;\n+typedef const class slsr_cand_d *const_slsr_cand_t;\n \n /* Pointers to candidates are chained together as part of a mapping\n    from base expressions to the candidates that use them.  */\n@@ -354,7 +354,7 @@ class incr_info_d\n   basic_block init_bb;\n };\n \n-typedef struct incr_info_d incr_info, *incr_info_t;\n+typedef class incr_info_d incr_info, *incr_info_t;\n \n /* Candidates are maintained in a vector.  If candidate X dominates\n    candidate Y, then X appears before Y in the vector; but the\n@@ -807,7 +807,7 @@ slsr_process_phi (gphi *phi, bool speed)\n   unsigned i;\n   tree arg0_base = NULL_TREE, base_type;\n   slsr_cand_t c;\n-  struct loop *cand_loop = gimple_bb (phi)->loop_father;\n+  class loop *cand_loop = gimple_bb (phi)->loop_father;\n   unsigned savings = 0;\n \n   /* A CAND_PHI requires each of its arguments to have the same"}, {"sha": "af39ff415e1b45e86255dc62835c2f47faafe804", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -185,7 +185,7 @@ adjusted_warn_limit (bool idx)\n // MAX_SIZE is WARN_ALLOCA= adjusted for VLAs.  It is the maximum size\n // in bytes we allow for arg.\n \n-static struct alloca_type_and_limit\n+static class alloca_type_and_limit\n alloca_call_type_by_arg (tree arg, tree arg_casted, edge e,\n \t\t\t unsigned HOST_WIDE_INT max_size)\n {\n@@ -326,7 +326,7 @@ is_max (tree x, wide_int max)\n // type to an unsigned type, set *INVALID_CASTED_TYPE to the\n // problematic signed type.\n \n-static struct alloca_type_and_limit\n+static class alloca_type_and_limit\n alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n {\n   gcc_assert (gimple_alloca_call_p (stmt));\n@@ -459,7 +459,7 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n   // If we couldn't find anything, try a few heuristics for things we\n   // can easily determine.  Check these misc cases but only accept\n   // them if all predecessors have a known bound.\n-  struct alloca_type_and_limit ret = alloca_type_and_limit (ALLOCA_OK);\n+  class alloca_type_and_limit ret = alloca_type_and_limit (ALLOCA_OK);\n   FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->preds)\n     {\n       gcc_assert (!len_casted || TYPE_UNSIGNED (TREE_TYPE (len_casted)));\n@@ -536,7 +536,7 @@ pass_walloca::execute (function *fun)\n \t    continue;\n \n \t  tree invalid_casted_type = NULL;\n-\t  struct alloca_type_and_limit t\n+\t  class alloca_type_and_limit t\n \t    = alloca_call_type (stmt, is_vla, &invalid_casted_type);\n \n \t  unsigned HOST_WIDE_INT adjusted_alloca_limit"}, {"sha": "72a847d40fa660d7c73fcc811566d6394262ab50", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n    the file being read.  IB is the input block to use for reading.  */\n \n static gphi *\n-input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n+input_phi (class lto_input_block *ib, basic_block bb, class data_in *data_in,\n \t   struct function *fn)\n {\n   unsigned HOST_WIDE_INT ix;\n@@ -83,7 +83,7 @@ input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n    descriptors in DATA_IN.  */\n \n static gimple *\n-input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n+input_gimple_stmt (class lto_input_block *ib, class data_in *data_in,\n \t\t   enum LTO_tags tag)\n {\n   gimple *stmt;\n@@ -249,8 +249,8 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n    FN is the function being processed.  */\n \n void\n-input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n-\t  struct data_in *data_in, struct function *fn,\n+input_bb (class lto_input_block *ib, enum LTO_tags tag,\n+\t  class data_in *data_in, struct function *fn,\n \t  int count_materialization_scale)\n {\n   unsigned int index;"}, {"sha": "ee36192bbacc2686ffa2d0e2253ad4a81a8be1af", "filename": "gcc/gimple-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgimple-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n \n /* In gimple-streamer-in.c  */\n-void input_bb (struct lto_input_block *, enum LTO_tags, struct data_in *,\n+void input_bb (class lto_input_block *, enum LTO_tags, class data_in *,\n \t       struct function *, int);\n \n /* In gimple-streamer-out.c  */"}, {"sha": "ddb19fd414df0a378765ed6c448aa48e63f74aa9", "filename": "gcc/godump.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -680,7 +680,7 @@ go_force_record_alignment (struct obstack *ob, const char *type_string,\n    calls from go_format_type() itself.  */\n \n static bool\n-go_format_type (struct godump_container *container, tree type,\n+go_format_type (class godump_container *container, tree type,\n \t\tbool use_type_name, bool is_func_ok, unsigned int *p_art_i,\n \t\tbool is_anon_record_or_union)\n {\n@@ -1092,7 +1092,7 @@ go_format_type (struct godump_container *container, tree type,\n    it.  */\n \n static void\n-go_output_type (struct godump_container *container)\n+go_output_type (class godump_container *container)\n {\n   struct obstack *ob;\n \n@@ -1105,7 +1105,7 @@ go_output_type (struct godump_container *container)\n /* Output a function declaration.  */\n \n static void\n-go_output_fndecl (struct godump_container *container, tree decl)\n+go_output_fndecl (class godump_container *container, tree decl)\n {\n   if (!go_format_type (container, TREE_TYPE (decl), false, true, NULL, false))\n     fprintf (go_dump_file, \"// \");\n@@ -1119,7 +1119,7 @@ go_output_fndecl (struct godump_container *container, tree decl)\n /* Output a typedef or something like a struct definition.  */\n \n static void\n-go_output_typedef (struct godump_container *container, tree decl)\n+go_output_typedef (class godump_container *container, tree decl)\n {\n   /* If we have an enum type, output the enum constants\n      separately.  */\n@@ -1246,7 +1246,7 @@ go_output_typedef (struct godump_container *container, tree decl)\n /* Output a variable.  */\n \n static void\n-go_output_var (struct godump_container *container, tree decl)\n+go_output_var (class godump_container *container, tree decl)\n {\n   bool is_valid;\n   tree type_name;\n@@ -1335,7 +1335,7 @@ static const char * const keywords[] = {\n };\n \n static void\n-keyword_hash_init (struct godump_container *container)\n+keyword_hash_init (class godump_container *container)\n {\n   size_t i;\n   size_t count = sizeof (keywords) / sizeof (keywords[0]);\n@@ -1355,7 +1355,7 @@ keyword_hash_init (struct godump_container *container)\n bool\n find_dummy_types (const char *const &ptr, godump_container *adata)\n {\n-  struct godump_container *data = (struct godump_container *) adata;\n+  class godump_container *data = (class godump_container *) adata;\n   const char *type = (const char *) ptr;\n   void **slot;\n   void **islot;\n@@ -1372,7 +1372,7 @@ find_dummy_types (const char *const &ptr, godump_container *adata)\n static void\n go_finish (const char *filename)\n {\n-  struct godump_container container;\n+  class godump_container container;\n   unsigned int ix;\n   tree decl;\n "}, {"sha": "5452822f21e309a94396666a3713ddbb65a87a6d", "filename": "gcc/graph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -197,7 +197,7 @@ draw_cfg_nodes_no_loops (pretty_printer *pp, struct function *fun)\n \n static void\n draw_cfg_nodes_for_loop (pretty_printer *pp, int funcdef_no,\n-\t\t\t struct loop *loop)\n+\t\t\t class loop *loop)\n {\n   basic_block *body;\n   unsigned int i;\n@@ -217,7 +217,7 @@ draw_cfg_nodes_for_loop (pretty_printer *pp, int funcdef_no,\n \t       fillcolors[(loop_depth (loop) - 1) % 3],\n \t       loop->num);\n \n-  for (struct loop *inner = loop->inner; inner; inner = inner->next)\n+  for (class loop *inner = loop->inner; inner; inner = inner->next)\n     draw_cfg_nodes_for_loop (pp, funcdef_no, inner);\n \n   if (loop->header == NULL)"}, {"sha": "bd4249b5a1765b607a1efc6c125778863f5ba6ce", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -613,8 +613,8 @@ hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n \n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n-struct simplifiable_subreg;\n-struct subreg_shape;\n+class simplifiable_subreg;\n+class subreg_shape;\n \n struct simplifiable_subregs_hasher : nofree_ptr_hash <simplifiable_subreg>\n {"}, {"sha": "45f4149969aaa2379b790d668ff5321fdc0f64d5", "filename": "gcc/hsa-brig.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-brig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-brig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-brig.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -150,9 +150,8 @@ struct hsa_brig_data_chunk\n \n /* Structure representing a BRIG section, holding and writing its data.  */\n \n-class hsa_brig_section\n+struct hsa_brig_section\n {\n-public:\n   /* Section name that will be output to the BRIG.  */\n   const char *section_name;\n   /* Size in bytes of all data stored in the section.  */\n@@ -579,7 +578,7 @@ static void emit_immediate_operand (hsa_op_immed *imm);\n    Return the offset of the directive.  */\n \n static unsigned\n-emit_directive_variable (struct hsa_symbol *symbol)\n+emit_directive_variable (class hsa_symbol *symbol)\n {\n   struct BrigDirectiveVariable dirvar;\n   unsigned name_offset;"}, {"sha": "912253974b6f1fcebe284c449c84c874bcc52b82", "filename": "gcc/hsa-common.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-common.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1068,7 +1068,7 @@ class hsa_bb\n static inline hsa_bb *\n hsa_bb_for_bb (basic_block bb)\n {\n-  return (struct hsa_bb *) bb->aux;\n+  return (class hsa_bb *) bb->aux;\n }\n \n /* Class for hashing local hsa_symbols.  */\n@@ -1150,14 +1150,14 @@ class hsa_function_representation\n   hash_map <tree, hsa_symbol *> m_string_constants_map;\n \n   /* Vector of pointers to spill symbols.  */\n-  vec <struct hsa_symbol *> m_spill_symbols;\n+  vec <class hsa_symbol *> m_spill_symbols;\n \n   /* Vector of pointers to global variables and transformed string constants\n      that are used by the function.  */\n-  vec <struct hsa_symbol *> m_global_symbols;\n+  vec <class hsa_symbol *> m_global_symbols;\n \n   /* Private function artificial variables.  */\n-  vec <struct hsa_symbol *> m_private_variables;\n+  vec <class hsa_symbol *> m_private_variables;\n \n   /* Vector of called function declarations.  */\n   vec <tree> m_called_functions;\n@@ -1318,7 +1318,7 @@ hsa_internal_fn_hasher::equal (const value_type a, const compare_type b)\n }\n \n /* in hsa-common.c */\n-extern struct hsa_function_representation *hsa_cfun;\n+extern class hsa_function_representation *hsa_cfun;\n extern hash_map <tree, vec <const char *> *> *hsa_decl_kernel_dependencies;\n extern hsa_summary_t *hsa_summaries;\n extern hsa_symbol *hsa_num_threads;"}, {"sha": "2d856012c4a08065fe9f0283854c711781eae54a", "filename": "gcc/hsa-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-dump.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1229,7 +1229,7 @@ dump_hsa_cfun (FILE *f)\n \n   FOR_ALL_BB_FN (bb, cfun)\n     {\n-      hsa_bb *hbb = (struct hsa_bb *) bb->aux;\n+      hsa_bb *hbb = (class hsa_bb *) bb->aux;\n       dump_hsa_bb (f, hbb);\n     }\n }"}, {"sha": "26e1e2496bf5d383da9dfb4e94de6d78178a9823", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -6070,7 +6070,7 @@ gen_function_def_parameters ()\n   for (parm = DECL_ARGUMENTS (cfun->decl); parm;\n        parm = DECL_CHAIN (parm))\n     {\n-      struct hsa_symbol **slot;\n+      class hsa_symbol **slot;\n \n       hsa_symbol *arg\n \t= new hsa_symbol (BRIG_TYPE_NONE, hsa_cfun->m_kern_p\n@@ -6128,7 +6128,7 @@ gen_function_def_parameters ()\n \n   if (!VOID_TYPE_P (TREE_TYPE (TREE_TYPE (cfun->decl))))\n     {\n-      struct hsa_symbol **slot;\n+      class hsa_symbol **slot;\n \n       hsa_cfun->m_output_arg = new hsa_symbol (BRIG_TYPE_NONE, BRIG_SEGMENT_ARG,\n \t\t\t\t\t       BRIG_LINKAGE_FUNCTION);"}, {"sha": "597bb666c6eee3c73865aa3f13cd33f977130f7a", "filename": "gcc/hsa-regalloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-regalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fhsa-regalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-regalloc.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -256,7 +256,7 @@ dump_hsa_cfun_regalloc (FILE *f)\n \n   FOR_ALL_BB_FN (bb, cfun)\n   {\n-    hsa_bb *hbb = (struct hsa_bb *) bb->aux;\n+    hsa_bb *hbb = (class hsa_bb *) bb->aux;\n     bitmap_print (dump_file, hbb->m_livein, \"m_livein  \", \"\\n\");\n     dump_hsa_bb (f, hbb);\n     bitmap_print (dump_file, hbb->m_liveout, \"m_liveout \", \"\\n\");"}, {"sha": "00301ef68dd73e3592514556e5e8e7e1fedae44e", "filename": "gcc/input.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -124,14 +124,14 @@ class fcache\n \n location_t input_location = UNKNOWN_LOCATION;\n \n-struct line_maps *line_table;\n+class line_maps *line_table;\n \n /* A stashed copy of \"line_table\" for use by selftest::line_table_test.\n    This needs to be a global so that it can be a GC root, and thus\n    prevent the stashed copy from being garbage-collected if the GC runs\n    during a line_table_test.  */\n \n-struct line_maps *saved_line_table;\n+class line_maps *saved_line_table;\n \n static fcache *fcache_tab;\n static const size_t fcache_tab_size = 16;\n@@ -980,7 +980,7 @@ dump_line_table_statistics (void)\n /* Get location one beyond the final location in ordinary map IDX.  */\n \n static location_t\n-get_end_location (struct line_maps *set, unsigned int idx)\n+get_end_location (class line_maps *set, unsigned int idx)\n {\n   if (idx == LINEMAPS_ORDINARY_USED (set) - 1)\n     return set->highest_location;\n@@ -2051,7 +2051,7 @@ test_lexer (const line_table_case &case_)\n \n /* Forward decls.  */\n \n-struct lexer_test;\n+class lexer_test;\n class lexer_test_options;\n \n /* A class for specifying options of a lexer_test."}, {"sha": "c459bf28553ef3c91ad5f52fed6009d73b91e8ce", "filename": "gcc/input.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -23,8 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"line-map.h\"\n \n-extern GTY(()) struct line_maps *line_table;\n-extern GTY(()) struct line_maps *saved_line_table;\n+extern GTY(()) class line_maps *line_table;\n+extern GTY(()) class line_maps *saved_line_table;\n \n /* A value which will never be used to represent a real location.  */\n #define UNKNOWN_LOCATION ((location_t) 0)"}, {"sha": "1067376995847c06c976a3b60322a649b17da766", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -149,7 +149,7 @@ get_multi_vector_move (tree array_type, convert_optab optab)\n static void\n expand_load_lanes_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   tree type, lhs, rhs;\n   rtx target, mem;\n \n@@ -173,7 +173,7 @@ expand_load_lanes_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n static void\n expand_store_lanes_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   tree type, lhs, rhs;\n   rtx target, reg;\n \n@@ -227,7 +227,7 @@ expand_GOMP_SIMT_ENTER_ALLOC (internal_fn, gcall *stmt)\n     target = gen_reg_rtx (Pmode);\n   rtx size = expand_normal (gimple_call_arg (stmt, 0));\n   rtx align = expand_normal (gimple_call_arg (stmt, 1));\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   create_output_operand (&ops[0], target, Pmode);\n   create_input_operand (&ops[1], size, Pmode);\n   create_input_operand (&ops[2], align, Pmode);\n@@ -242,7 +242,7 @@ expand_GOMP_SIMT_EXIT (internal_fn, gcall *stmt)\n {\n   gcc_checking_assert (!gimple_call_lhs (stmt));\n   rtx arg = expand_normal (gimple_call_arg (stmt, 0));\n-  struct expand_operand ops[1];\n+  class expand_operand ops[1];\n   create_input_operand (&ops[0], arg, Pmode);\n   gcc_assert (targetm.have_omp_simt_exit ());\n   expand_insn (targetm.code_for_omp_simt_exit, 1, ops);\n@@ -285,7 +285,7 @@ expand_GOMP_SIMT_LAST_LANE (internal_fn, gcall *stmt)\n   rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   rtx cond = expand_normal (gimple_call_arg (stmt, 0));\n   machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   create_output_operand (&ops[0], target, mode);\n   create_input_operand (&ops[1], cond, mode);\n   gcc_assert (targetm.have_omp_simt_last_lane ());\n@@ -304,7 +304,7 @@ expand_GOMP_SIMT_ORDERED_PRED (internal_fn, gcall *stmt)\n   rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   rtx ctr = expand_normal (gimple_call_arg (stmt, 0));\n   machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   create_output_operand (&ops[0], target, mode);\n   create_input_operand (&ops[1], ctr, mode);\n   gcc_assert (targetm.have_omp_simt_ordered ());\n@@ -324,7 +324,7 @@ expand_GOMP_SIMT_VOTE_ANY (internal_fn, gcall *stmt)\n   rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   rtx cond = expand_normal (gimple_call_arg (stmt, 0));\n   machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   create_output_operand (&ops[0], target, mode);\n   create_input_operand (&ops[1], cond, mode);\n   gcc_assert (targetm.have_omp_simt_vote_any ());\n@@ -345,7 +345,7 @@ expand_GOMP_SIMT_XCHG_BFLY (internal_fn, gcall *stmt)\n   rtx src = expand_normal (gimple_call_arg (stmt, 0));\n   rtx idx = expand_normal (gimple_call_arg (stmt, 1));\n   machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   create_output_operand (&ops[0], target, mode);\n   create_input_operand (&ops[1], src, mode);\n   create_input_operand (&ops[2], idx, SImode);\n@@ -366,7 +366,7 @@ expand_GOMP_SIMT_XCHG_IDX (internal_fn, gcall *stmt)\n   rtx src = expand_normal (gimple_call_arg (stmt, 0));\n   rtx idx = expand_normal (gimple_call_arg (stmt, 1));\n   machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   create_output_operand (&ops[0], target, mode);\n   create_input_operand (&ops[1], src, mode);\n   create_input_operand (&ops[2], idx, SImode);\n@@ -774,7 +774,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n                                        : usubv4_optab, mode);\n       if (icode != CODE_FOR_nothing)\n \t{\n-\t  struct expand_operand ops[4];\n+\t  class expand_operand ops[4];\n \t  rtx_insn *last = get_last_insn ();\n \n \t  res = gen_reg_rtx (mode);\n@@ -995,7 +995,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\t\t     : subv4_optab, mode);\n     if (icode != CODE_FOR_nothing)\n       {\n-\tstruct expand_operand ops[4];\n+\tclass expand_operand ops[4];\n \trtx_insn *last = get_last_insn ();\n \n \tres = gen_reg_rtx (mode);\n@@ -1146,7 +1146,7 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan,\n   enum insn_code icode = optab_handler (negv3_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[3];\n+      class expand_operand ops[3];\n       rtx_insn *last = get_last_insn ();\n \n       res = gen_reg_rtx (mode);\n@@ -1539,7 +1539,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     }\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[4];\n+      class expand_operand ops[4];\n       rtx_insn *last = get_last_insn ();\n \n       res = gen_reg_rtx (mode);\n@@ -2475,7 +2475,7 @@ expand_call_mem_ref (tree type, gcall *stmt, int index)\n static void\n expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n   rtx mem, target, mask;\n   insn_code icode;\n@@ -2510,7 +2510,7 @@ expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n static void\n expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n   rtx mem, reg, mask;\n   insn_code icode;\n@@ -2771,7 +2771,7 @@ expand_scatter_store_optab_fn (internal_fn, gcall *stmt, direct_optab optab)\n   HOST_WIDE_INT scale_int = tree_to_shwi (scale);\n   rtx rhs_rtx = expand_normal (rhs);\n \n-  struct expand_operand ops[6];\n+  class expand_operand ops[6];\n   int i = 0;\n   create_address_operand (&ops[i++], base_rtx);\n   create_input_operand (&ops[i++], offset_rtx, TYPE_MODE (TREE_TYPE (offset)));\n@@ -2805,7 +2805,7 @@ expand_gather_load_optab_fn (internal_fn, gcall *stmt, direct_optab optab)\n   HOST_WIDE_INT scale_int = tree_to_shwi (scale);\n \n   int i = 0;\n-  struct expand_operand ops[6];\n+  class expand_operand ops[6];\n   create_output_operand (&ops[i++], lhs_rtx, TYPE_MODE (TREE_TYPE (lhs)));\n   create_address_operand (&ops[i++], base_rtx);\n   create_input_operand (&ops[i++], offset_rtx, TYPE_MODE (TREE_TYPE (offset)));"}, {"sha": "0fd36506c00852d0d833bf52292bdc653cd89830", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -381,8 +381,8 @@ static hash_map<const char *, unsigned> *clone_num_suffixes;\n \n /* Return the param lattices structure corresponding to the Ith formal\n    parameter of the function described by INFO.  */\n-static inline struct ipcp_param_lattices *\n-ipa_get_parm_lattices (struct ipa_node_params *info, int i)\n+static inline class ipcp_param_lattices *\n+ipa_get_parm_lattices (class ipa_node_params *info, int i)\n {\n   gcc_assert (i >= 0 && i < ipa_get_param_count (info));\n   gcc_checking_assert (!info->ipcp_orig_node);\n@@ -393,18 +393,18 @@ ipa_get_parm_lattices (struct ipa_node_params *info, int i)\n /* Return the lattice corresponding to the scalar value of the Ith formal\n    parameter of the function described by INFO.  */\n static inline ipcp_lattice<tree> *\n-ipa_get_scalar_lat (struct ipa_node_params *info, int i)\n+ipa_get_scalar_lat (class ipa_node_params *info, int i)\n {\n-  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+  class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n   return &plats->itself;\n }\n \n /* Return the lattice corresponding to the scalar value of the Ith formal\n    parameter of the function described by INFO.  */\n static inline ipcp_lattice<ipa_polymorphic_call_context> *\n-ipa_get_poly_ctx_lat (struct ipa_node_params *info, int i)\n+ipa_get_poly_ctx_lat (class ipa_node_params *info, int i)\n {\n-  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+  class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n   return &plats->ctxlat;\n }\n \n@@ -539,7 +539,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n   fprintf (f, \"\\nLattices:\\n\");\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     {\n-      struct ipa_node_params *info;\n+      class ipa_node_params *info;\n \n       info = IPA_NODE_REF (node);\n       /* Skip constprop clones since we don't make lattices for them.  */\n@@ -550,7 +550,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_agg_lattice *aglat;\n-\t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\t  class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  fprintf (f, \"    param [%d]: \", i);\n \t  plats->itself.print (f, dump_sources, dump_benefits);\n \t  fprintf (f, \"         ctxs: \");\n@@ -585,7 +585,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \n static void\n determine_versionability (struct cgraph_node *node,\n-\t\t\t  struct ipa_node_params *info)\n+\t\t\t  class ipa_node_params *info)\n {\n   const char *reason = NULL;\n \n@@ -823,7 +823,7 @@ ignore_edge_p (cgraph_edge *e)\n /* Allocate the arrays in TOPO and topologically sort the nodes into order.  */\n \n static void\n-build_toporder_info (struct ipa_topo_info *topo)\n+build_toporder_info (class ipa_topo_info *topo)\n {\n   topo->order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   topo->stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n@@ -837,7 +837,7 @@ build_toporder_info (struct ipa_topo_info *topo)\n    TOPO.  */\n \n static void\n-free_toporder_info (struct ipa_topo_info *topo)\n+free_toporder_info (class ipa_topo_info *topo)\n {\n   ipa_free_postorder_info ();\n   free (topo->order);\n@@ -847,9 +847,9 @@ free_toporder_info (struct ipa_topo_info *topo)\n /* Add NODE to the stack in TOPO, unless it is already there.  */\n \n static inline void\n-push_node_to_stack (struct ipa_topo_info *topo, struct cgraph_node *node)\n+push_node_to_stack (class ipa_topo_info *topo, struct cgraph_node *node)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   if (info->node_enqueued)\n     return;\n   info->node_enqueued = 1;\n@@ -860,7 +860,7 @@ push_node_to_stack (struct ipa_topo_info *topo, struct cgraph_node *node)\n    is empty.  */\n \n static struct cgraph_node *\n-pop_node_from_stack (struct ipa_topo_info *topo)\n+pop_node_from_stack (class ipa_topo_info *topo)\n {\n   if (topo->stack_top)\n     {\n@@ -902,7 +902,7 @@ ipcp_lattice<valtype>::set_contains_variable ()\n    not previously set as such.  */\n \n static inline bool\n-set_agg_lats_to_bottom (struct ipcp_param_lattices *plats)\n+set_agg_lats_to_bottom (class ipcp_param_lattices *plats)\n {\n   bool ret = !plats->aggs_bottom;\n   plats->aggs_bottom = true;\n@@ -913,7 +913,7 @@ set_agg_lats_to_bottom (struct ipcp_param_lattices *plats)\n    return true if they were not previously marked as such.  */\n \n static inline bool\n-set_agg_lats_contain_variable (struct ipcp_param_lattices *plats)\n+set_agg_lats_contain_variable (class ipcp_param_lattices *plats)\n {\n   bool ret = !plats->aggs_contain_variable;\n   plats->aggs_contain_variable = true;\n@@ -1123,7 +1123,7 @@ ipcp_bits_lattice::meet_with (ipcp_bits_lattice& other, unsigned precision,\n    return true is any of them has not been marked as such so far.  */\n \n static inline bool\n-set_all_contains_variable (struct ipcp_param_lattices *plats)\n+set_all_contains_variable (class ipcp_param_lattices *plats)\n {\n   bool ret;\n   ret = plats->itself.set_contains_variable ();\n@@ -1173,7 +1173,7 @@ set_single_call_flag (cgraph_node *node, void *)\n static void\n initialize_node_lattices (struct cgraph_node *node)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   struct cgraph_edge *ie;\n   bool disable = false, variable = false;\n   int i;\n@@ -1203,15 +1203,15 @@ initialize_node_lattices (struct cgraph_node *node)\n \n   for (i = 0; i < ipa_get_param_count (info); i++)\n     {\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       plats->m_value_range.init ();\n     }\n \n   if (disable || variable)\n     {\n       for (i = 0; i < ipa_get_param_count (info); i++)\n \t{\n-\t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\t  class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  if (disable)\n \t    {\n \t      plats->itself.set_to_bottom ();\n@@ -1304,7 +1304,7 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n    passed.  */\n \n tree\n-ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc,\n+ipa_value_from_jfunc (class ipa_node_params *info, struct ipa_jump_func *jfunc,\n \t\t      tree parm_type)\n {\n   if (jfunc->type == IPA_JF_CONST)\n@@ -1422,7 +1422,7 @@ ipcp_verify_propagated_values (void)\n \n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     {\n-      struct ipa_node_params *info = IPA_NODE_REF (node);\n+      class ipa_node_params *info = IPA_NODE_REF (node);\n       int i, count = ipa_get_param_count (info);\n \n       for (i = 0; i < count; i++)\n@@ -1674,7 +1674,7 @@ propagate_scalar_across_jump_function (struct cgraph_edge *cs,\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n \t   || jfunc->type == IPA_JF_ANCESTOR)\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n       ipcp_lattice<tree> *src_lat;\n       int src_idx;\n       bool ret;\n@@ -1736,7 +1736,7 @@ propagate_context_across_jump_function (cgraph_edge *cs,\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       || jfunc->type == IPA_JF_ANCESTOR)\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n       int src_idx;\n       ipcp_lattice<ipa_polymorphic_call_context> *src_lat;\n \n@@ -1812,7 +1812,7 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n \n   enum availability availability;\n   cgraph_node *callee = cs->callee->function_symbol (&availability);\n-  struct ipa_node_params *callee_info = IPA_NODE_REF (callee);\n+  class ipa_node_params *callee_info = IPA_NODE_REF (callee);\n   tree parm_type = ipa_get_type (callee_info, idx);\n \n   /* For K&R C programs, ipa_get_type() could return NULL_TREE.  Avoid the\n@@ -1835,7 +1835,7 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       || jfunc->type == IPA_JF_ANCESTOR)\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n       tree operand = NULL_TREE;\n       enum tree_code code;\n       unsigned src_idx;\n@@ -1855,7 +1855,7 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n \t  operand = build_int_cstu (size_type_node, offset);\n \t}\n \n-      struct ipcp_param_lattices *src_lats\n+      class ipcp_param_lattices *src_lats\n \t= ipa_get_parm_lattices (caller_info, src_idx);\n \n       /* Try to propagate bits if src_lattice is bottom, but jfunc is known.\n@@ -1909,7 +1909,7 @@ ipa_vr_operation_and_type_effects (value_range_base *dst_vr,\n \n static bool\n propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n-\t\t\t\t   struct ipcp_param_lattices *dest_plats,\n+\t\t\t\t   class ipcp_param_lattices *dest_plats,\n \t\t\t\t   tree param_type)\n {\n   ipcp_vr_lattice *dest_lat = &dest_plats->m_value_range;\n@@ -1928,10 +1928,10 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \n       if (TREE_CODE_CLASS (operation) == tcc_unary)\n \t{\n-\t  struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+\t  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n \t  int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n \t  tree operand_type = ipa_get_type (caller_info, src_idx);\n-\t  struct ipcp_param_lattices *src_lats\n+\t  class ipcp_param_lattices *src_lats\n \t    = ipa_get_parm_lattices (caller_info, src_idx);\n \n \t  if (src_lats->m_value_range.bottom_p ())\n@@ -1974,7 +1974,7 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n    aggs_by_ref to NEW_AGGS_BY_REF.  */\n \n static bool\n-set_check_aggs_by_ref (struct ipcp_param_lattices *dest_plats,\n+set_check_aggs_by_ref (class ipcp_param_lattices *dest_plats,\n \t\t       bool new_aggs_by_ref)\n {\n   if (dest_plats->aggs)\n@@ -2001,7 +2001,7 @@ set_check_aggs_by_ref (struct ipcp_param_lattices *dest_plats,\n    true.  */\n \n static bool\n-merge_agg_lats_step (struct ipcp_param_lattices *dest_plats,\n+merge_agg_lats_step (class ipcp_param_lattices *dest_plats,\n \t\t     HOST_WIDE_INT offset, HOST_WIDE_INT val_size,\n \t\t     struct ipcp_agg_lattice ***aglat,\n \t\t     bool pre_existing, bool *change)\n@@ -2079,8 +2079,8 @@ set_chain_of_aglats_contains_variable (struct ipcp_agg_lattice *aglat)\n \n static bool\n merge_aggregate_lattices (struct cgraph_edge *cs,\n-\t\t\t  struct ipcp_param_lattices *dest_plats,\n-\t\t\t  struct ipcp_param_lattices *src_plats,\n+\t\t\t  class ipcp_param_lattices *dest_plats,\n+\t\t\t  class ipcp_param_lattices *src_plats,\n \t\t\t  int src_idx, HOST_WIDE_INT offset_delta)\n {\n   bool pre_existing = dest_plats->aggs != NULL;\n@@ -2134,7 +2134,7 @@ merge_aggregate_lattices (struct cgraph_edge *cs,\n    rules about propagating values passed by reference.  */\n \n static bool\n-agg_pass_through_permissible_p (struct ipcp_param_lattices *src_plats,\n+agg_pass_through_permissible_p (class ipcp_param_lattices *src_plats,\n \t\t\t\tstruct ipa_jump_func *jfunc)\n {\n   return src_plats->aggs\n@@ -2148,7 +2148,7 @@ agg_pass_through_permissible_p (struct ipcp_param_lattices *src_plats,\n static bool\n propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n \t\t\t\t     struct ipa_jump_func *jfunc,\n-\t\t\t\t     struct ipcp_param_lattices *dest_plats)\n+\t\t\t\t     class ipcp_param_lattices *dest_plats)\n {\n   bool ret = false;\n \n@@ -2158,9 +2158,9 @@ propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n       int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n-      struct ipcp_param_lattices *src_plats;\n+      class ipcp_param_lattices *src_plats;\n \n       src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n       if (agg_pass_through_permissible_p (src_plats, jfunc))\n@@ -2177,9 +2177,9 @@ propagate_aggs_across_jump_function (struct cgraph_edge *cs,\n   else if (jfunc->type == IPA_JF_ANCESTOR\n \t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n       int src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n-      struct ipcp_param_lattices *src_plats;\n+      class ipcp_param_lattices *src_plats;\n \n       src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n       if (src_plats->aggs && src_plats->aggs_by_ref)\n@@ -2250,10 +2250,10 @@ call_passes_through_thunk_p (cgraph_edge *cs)\n static bool\n propagate_constants_across_call (struct cgraph_edge *cs)\n {\n-  struct ipa_node_params *callee_info;\n+  class ipa_node_params *callee_info;\n   enum availability availability;\n   cgraph_node *callee;\n-  struct ipa_edge_args *args;\n+  class ipa_edge_args *args;\n   bool ret = false;\n   int i, args_count, parms_count;\n \n@@ -2284,7 +2284,7 @@ propagate_constants_across_call (struct cgraph_edge *cs)\n   for (; (i < args_count) && (i < parms_count); i++)\n     {\n       struct ipa_jump_func *jump_func = ipa_get_ith_jump_func (args, i);\n-      struct ipcp_param_lattices *dest_plats;\n+      class ipcp_param_lattices *dest_plats;\n       tree param_type = ipa_get_type (callee_info, i);\n \n       dest_plats = ipa_get_parm_lattices (callee_info, i);\n@@ -2563,7 +2563,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n   for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n     {\n       struct cgraph_node *callee;\n-      struct ipa_fn_summary *isummary;\n+      class ipa_fn_summary *isummary;\n       enum availability avail;\n       tree target;\n       bool speculative;\n@@ -2645,7 +2645,7 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \n   gcc_assert (size_cost > 0);\n \n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   if (max_count > profile_count::zero ())\n     {\n       int factor = RDIV (count_sum.probability_in\n@@ -2692,7 +2692,7 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n    vector.  Return NULL if there are none.  */\n \n static vec<ipa_agg_jf_item, va_gc> *\n-context_independent_aggregate_values (struct ipcp_param_lattices *plats)\n+context_independent_aggregate_values (class ipcp_param_lattices *plats)\n {\n   vec<ipa_agg_jf_item, va_gc> *res = NULL;\n \n@@ -2721,7 +2721,7 @@ context_independent_aggregate_values (struct ipcp_param_lattices *plats)\n    it.  */\n \n static bool\n-gather_context_independent_values (struct ipa_node_params *info,\n+gather_context_independent_values (class ipa_node_params *info,\n \t\t\t\t   vec<tree> *known_csts,\n \t\t\t\t   vec<ipa_polymorphic_call_context>\n \t\t\t\t   *known_contexts,\n@@ -2746,7 +2746,7 @@ gather_context_independent_values (struct ipa_node_params *info,\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n \n       if (lat->is_single_const ())\n@@ -2863,7 +2863,7 @@ perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n static void\n estimate_local_effects (struct cgraph_node *node)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n   vec<tree> known_csts;\n   vec<ipa_polymorphic_call_context> known_contexts;\n@@ -2943,7 +2943,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n       ipcp_value<tree> *val;\n \n@@ -2977,7 +2977,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \n       if (!plats->virt_call)\n \tcontinue;\n@@ -3012,7 +3012,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       struct ipa_agg_jump_function *ajf;\n       struct ipcp_agg_lattice *aglat;\n \n@@ -3129,12 +3129,12 @@ value_topo_info<valtype>::add_val (ipcp_value<valtype> *cur_val)\n static void\n add_all_node_vals_to_toposort (cgraph_node *node, ipa_topo_info *topo)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n       struct ipcp_agg_lattice *aglat;\n \n@@ -3169,7 +3169,7 @@ add_all_node_vals_to_toposort (cgraph_node *node, ipa_topo_info *topo)\n    connected components.  */\n \n static void\n-propagate_constants_topo (struct ipa_topo_info *topo)\n+propagate_constants_topo (class ipa_topo_info *topo)\n {\n   int i;\n \n@@ -3272,7 +3272,7 @@ value_topo_info<valtype>::propagate_effects ()\n    summaries interprocedurally.  */\n \n static void\n-ipcp_propagate_stage (struct ipa_topo_info *topo)\n+ipcp_propagate_stage (class ipa_topo_info *topo)\n {\n   struct cgraph_node *node;\n \n@@ -3283,12 +3283,12 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n   {\n-    struct ipa_node_params *info = IPA_NODE_REF (node);\n+    class ipa_node_params *info = IPA_NODE_REF (node);\n \n     determine_versionability (node, info);\n     if (node->has_gimple_body_p ())\n       {\n-\tinfo->lattices = XCNEWVEC (struct ipcp_param_lattices,\n+\tinfo->lattices = XCNEWVEC (class ipcp_param_lattices,\n \t\t\t\t   ipa_get_param_count (info));\n \tinitialize_node_lattices (node);\n       }\n@@ -3352,7 +3352,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \n \t  if (cs && !agg_contents && !polymorphic)\n \t    {\n-\t      struct ipa_node_params *info = IPA_NODE_REF (node);\n+\t      class ipa_node_params *info = IPA_NODE_REF (node);\n \t      int c = ipa_get_controlled_uses (info, param_index);\n \t      if (c != IPA_UNDESCRIBED_USE)\n \t\t{\n@@ -3461,7 +3461,7 @@ same_node_or_its_all_contexts_clone_p (cgraph_node *node, cgraph_node *dest)\n   if (node == dest)\n     return true;\n \n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   return info->is_all_contexts_clone && info->ipcp_orig_node == dest;\n }\n \n@@ -3472,7 +3472,7 @@ static bool\n cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n \t\t\t    cgraph_node *dest, ipcp_value<tree> *dest_val)\n {\n-  struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n   enum availability availability;\n   cgraph_node *real_dest = cs->callee->function_symbol (&availability);\n \n@@ -3503,7 +3503,7 @@ cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n \treturn true;\n \n       struct ipcp_agg_lattice *aglat;\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n \t\t\t\t\t\t\t\t src->index);\n       if (src->offset == -1)\n \treturn (plats->itself.is_single_const ()\n@@ -3532,7 +3532,7 @@ cgraph_edge_brings_value_p (cgraph_edge *cs,\n \t\t\t    cgraph_node *dest,\n \t\t\t    ipcp_value<ipa_polymorphic_call_context> *)\n {\n-  struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n   cgraph_node *real_dest = cs->callee->function_symbol ();\n \n   if (!same_node_or_its_all_contexts_clone_p (real_dest, dest)\n@@ -3546,7 +3546,7 @@ cgraph_edge_brings_value_p (cgraph_edge *cs,\n       && values_equal_for_ipcp_p (src->val->value,\n \t\t\t\t  caller_info->known_contexts[src->index]);\n \n-  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n+  class ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n \t\t\t\t\t\t\t     src->index);\n   return plats->ctxlat.is_single_const ()\n     && values_equal_for_ipcp_p (src->val->value,\n@@ -3639,7 +3639,7 @@ gather_edges_for_value (ipcp_value<valtype> *val, cgraph_node *dest,\n    Return it or NULL if for some reason it cannot be created.  */\n \n static struct ipa_replace_map *\n-get_replacement_map (struct ipa_node_params *info, tree value, int parm_num)\n+get_replacement_map (class ipa_node_params *info, tree value, int parm_num)\n {\n   struct ipa_replace_map *replace_map;\n \n@@ -3808,7 +3808,7 @@ create_specialized_node (struct cgraph_node *node,\n \t\t\t struct ipa_agg_replacement_value *aggvals,\n \t\t\t vec<cgraph_edge *> callers)\n {\n-  struct ipa_node_params *new_info, *info = IPA_NODE_REF (node);\n+  class ipa_node_params *new_info, *info = IPA_NODE_REF (node);\n   vec<ipa_replace_map *, va_gc> *replace_trees = NULL;\n   struct ipa_agg_replacement_value *av;\n   struct cgraph_node *new_node;\n@@ -3942,7 +3942,7 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t\t\t\t\t    vec<tree> known_csts,\n \t\t\t\t\t    vec<cgraph_edge *> callers)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n \n   for (i = 0; i < count; i++)\n@@ -4075,7 +4075,7 @@ find_more_contexts_for_caller_subset (cgraph_node *node,\n    offsets (minus OFFSET) of lattices that contain only a single value.  */\n \n static vec<ipa_agg_jf_item>\n-copy_plats_to_inter (struct ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n+copy_plats_to_inter (class ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n {\n   vec<ipa_agg_jf_item> res = vNULL;\n \n@@ -4097,7 +4097,7 @@ copy_plats_to_inter (struct ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n    subtracting OFFSET).  */\n \n static void\n-intersect_with_plats (struct ipcp_param_lattices *plats,\n+intersect_with_plats (class ipcp_param_lattices *plats,\n \t\t      vec<ipa_agg_jf_item> *inter,\n \t\t      HOST_WIDE_INT offset)\n {\n@@ -4217,13 +4217,13 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n   if (jfunc->type == IPA_JF_PASS_THROUGH\n       && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n       int src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n \n       if (caller_info->ipcp_orig_node)\n \t{\n \t  struct cgraph_node *orig_node = caller_info->ipcp_orig_node;\n-\t  struct ipcp_param_lattices *orig_plats;\n+\t  class ipcp_param_lattices *orig_plats;\n \t  orig_plats = ipa_get_parm_lattices (IPA_NODE_REF (orig_node),\n \t\t\t\t\t      src_idx);\n \t  if (agg_pass_through_permissible_p (orig_plats, jfunc))\n@@ -4242,7 +4242,7 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \t}\n       else\n \t{\n-\t  struct ipcp_param_lattices *src_plats;\n+\t  class ipcp_param_lattices *src_plats;\n \t  src_plats = ipa_get_parm_lattices (caller_info, src_idx);\n \t  if (agg_pass_through_permissible_p (src_plats, jfunc))\n \t    {\n@@ -4264,9 +4264,9 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n   else if (jfunc->type == IPA_JF_ANCESTOR\n \t   && ipa_get_jf_ancestor_agg_preserved (jfunc))\n     {\n-      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n       int src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n-      struct ipcp_param_lattices *src_plats;\n+      class ipcp_param_lattices *src_plats;\n       HOST_WIDE_INT delta = ipa_get_jf_ancestor_offset (jfunc);\n \n       if (caller_info->ipcp_orig_node)\n@@ -4341,7 +4341,7 @@ static struct ipa_agg_replacement_value *\n find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n \t\t\t\t\t  vec<cgraph_edge *> callers)\n {\n-  struct ipa_node_params *dest_info = IPA_NODE_REF (node);\n+  class ipa_node_params *dest_info = IPA_NODE_REF (node);\n   struct ipa_agg_replacement_value *res;\n   struct ipa_agg_replacement_value **tail = &res;\n   struct cgraph_edge *cs;\n@@ -4359,7 +4359,7 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n       struct cgraph_edge *cs;\n       vec<ipa_agg_jf_item> inter = vNULL;\n       struct ipa_agg_jf_item *item;\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (dest_info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (dest_info, i);\n       int j;\n \n       /* Among other things, the following check should deal with all by_ref\n@@ -4412,10 +4412,10 @@ static bool\n cgraph_edge_brings_all_scalars_for_node (struct cgraph_edge *cs,\n \t\t\t\t\t struct cgraph_node *node)\n {\n-  struct ipa_node_params *dest_info = IPA_NODE_REF (node);\n+  class ipa_node_params *dest_info = IPA_NODE_REF (node);\n   int count = ipa_get_param_count (dest_info);\n-  struct ipa_node_params *caller_info;\n-  struct ipa_edge_args *args;\n+  class ipa_node_params *caller_info;\n+  class ipa_edge_args *args;\n   int i;\n \n   caller_info = IPA_NODE_REF (cs->caller);\n@@ -4446,7 +4446,7 @@ static bool\n cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n \t\t\t\t\t  struct cgraph_node *node)\n {\n-  struct ipa_node_params *orig_node_info;\n+  class ipa_node_params *orig_node_info;\n   struct ipa_agg_replacement_value *aggval;\n   int i, ec, count;\n \n@@ -4466,7 +4466,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n   for (i = 0; i < count; i++)\n     {\n       static vec<ipa_agg_jf_item> values = vec<ipa_agg_jf_item>();\n-      struct ipcp_param_lattices *plats;\n+      class ipcp_param_lattices *plats;\n       bool interesting = false;\n       for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n \tif (aggval->index == i)\n@@ -4722,7 +4722,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n static bool\n decide_whether_version_node (struct cgraph_node *node)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n   vec<tree> known_csts;\n   vec<ipa_polymorphic_call_context> known_contexts;\n@@ -4742,7 +4742,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \n   for (i = 0; i < count;i++)\n     {\n-      struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n       ipcp_lattice<tree> *lat = &plats->itself;\n       ipcp_lattice<ipa_polymorphic_call_context> *ctxlat = &plats->ctxlat;\n \n@@ -4832,7 +4832,7 @@ spread_undeadness (struct cgraph_node *node)\n     if (ipa_edge_within_scc (cs))\n       {\n \tstruct cgraph_node *callee;\n-\tstruct ipa_node_params *info;\n+\tclass ipa_node_params *info;\n \n \tcallee = cs->callee->function_symbol (NULL);\n \tinfo = IPA_NODE_REF (callee);\n@@ -4895,7 +4895,7 @@ identify_dead_nodes (struct cgraph_node *node)\n    TOPO and make specialized clones if deemed beneficial.  */\n \n static void\n-ipcp_decision_stage (struct ipa_topo_info *topo)\n+ipcp_decision_stage (class ipa_topo_info *topo)\n {\n   int i;\n \n@@ -5069,7 +5069,7 @@ ipcp_store_vr_results (void)\n static unsigned int\n ipcp_driver (void)\n {\n-  struct ipa_topo_info topo;\n+  class ipa_topo_info topo;\n \n   if (edge_clone_summaries == NULL)\n     edge_clone_summaries = new edge_clone_summary_t (symtab);"}, {"sha": "95e2d950fe968f3f4dd33c70d0cac7586eff29a5", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -2974,7 +2974,7 @@ final_warning_record::grow_type_warnings (unsigned newlen)\n     }\n }\n \n-struct final_warning_record *final_warning_records;\n+class final_warning_record *final_warning_records;\n \n /* Return vector containing possible targets of polymorphic call of type\n    OTR_TYPE calling method OTR_TOKEN within type of OTR_OUTER_TYPE and OFFSET."}, {"sha": "09986211a1dea32c7c9771c9449e3b5c3beb3c64", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -212,7 +212,7 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n     }\n   if (!found)\n     {\n-      struct size_time_entry new_entry;\n+      class size_time_entry new_entry;\n       new_entry.size = size;\n       new_entry.time = time;\n       new_entry.exec_predicate = exec_pred;\n@@ -241,7 +241,7 @@ redirect_to_unreachable (struct cgraph_edge *e)\n     e->make_direct (target);\n   else\n     e->redirect_callee (target);\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  class ipa_call_summary *es = ipa_call_summaries->get (e);\n   e->inline_failed = CIF_UNREACHABLE;\n   e->count = profile_count::zero ();\n   es->call_stmt_size = 0;\n@@ -266,7 +266,7 @@ edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n       && (!e->speculative || e->callee))\n     e = redirect_to_unreachable (e);\n \n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  class ipa_call_summary *es = ipa_call_summaries->get (e);\n   if (predicate && *predicate != true)\n     {\n       if (!es->predicate)\n@@ -328,7 +328,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n   clause_t nonspec_clause = 1 << predicate::not_inlined_condition;\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get (node);\n   int i;\n   struct condition *c;\n \n@@ -428,7 +428,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n   vec<tree> known_vals = vNULL;\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n \n@@ -443,9 +443,9 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n       && !e->call_stmt_cannot_inline_p\n       && ((clause_ptr && info->conds) || known_vals_ptr || known_contexts_ptr))\n     {\n-      struct ipa_node_params *caller_parms_info, *callee_pi;\n-      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      class ipa_node_params *caller_parms_info, *callee_pi;\n+      class ipa_edge_args *args = IPA_EDGE_REF (e);\n+      class ipa_call_summary *es = ipa_call_summaries->get (e);\n       int i, count = ipa_get_cs_argument_count (args);\n \n       if (e->caller->global.inlined_to)\n@@ -604,7 +604,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n     {\n       vec<size_time_entry, va_gc> *entry = info->size_time_table;\n       /* Use SRC parm info since it may not be copied yet.  */\n-      struct ipa_node_params *parms_info = IPA_NODE_REF (src);\n+      class ipa_node_params *parms_info = IPA_NODE_REF (src);\n       vec<tree> known_vals = vNULL;\n       int count = ipa_get_param_count (parms_info);\n       int i, j;\n@@ -668,7 +668,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->callees; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+\t  class ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \t  next = edge->next_callee;\n \n \t  if (!edge->inline_failed)\n@@ -687,7 +687,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->indirect_calls; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  struct ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+\t  class ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n \t  next = edge->next_callee;\n \n \t  gcc_checking_assert (edge->inline_failed);\n@@ -744,8 +744,8 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n void\n ipa_call_summary_t::duplicate (struct cgraph_edge *src,\n \t\t\t       struct cgraph_edge *dst,\n-\t\t\t       struct ipa_call_summary *srcinfo,\n-\t\t\t       struct ipa_call_summary *info)\n+\t\t\t       class ipa_call_summary *srcinfo,\n+\t\t\t       class ipa_call_summary *info)\n {\n   new (info) ipa_call_summary (*srcinfo);\n   info->predicate = NULL;\n@@ -765,12 +765,12 @@ ipa_call_summary_t::duplicate (struct cgraph_edge *src,\n \n static void\n dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n-\t\t       struct ipa_fn_summary *info)\n+\t\t       class ipa_fn_summary *info)\n {\n   struct cgraph_edge *edge;\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+      class ipa_call_summary *es = ipa_call_summaries->get (edge);\n       struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n       int i;\n \n@@ -821,7 +821,7 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n     }\n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+      class ipa_call_summary *es = ipa_call_summaries->get (edge);\n       fprintf (f, \"%*sindirect call loop depth:%2i freq:%4.2f size:%2i\"\n \t       \" time: %2i\",\n \t       indent, \"\",\n@@ -844,7 +844,7 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n {\n   if (node->definition)\n     {\n-      struct ipa_fn_summary *s = ipa_fn_summaries->get (node);\n+      class ipa_fn_summary *s = ipa_fn_summaries->get (node);\n       if (s != NULL)\n \t{\n \t  size_time_entry *e;\n@@ -1183,7 +1183,7 @@ eliminated_by_inlining_prob (ipa_func_body_info *fbi, gimple *stmt)\n \n static void\n set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n-\t\t\t\t   struct ipa_fn_summary *summary,\n+\t\t\t\t   class ipa_fn_summary *summary,\n \t\t\t\t   basic_block bb)\n {\n   gimple *last;\n@@ -1268,7 +1268,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \n static void\n set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n-\t\t\t\t     struct ipa_fn_summary *summary,\n+\t\t\t\t     class ipa_fn_summary *summary,\n \t\t\t\t     basic_block bb)\n {\n   gimple *lastg;\n@@ -1322,8 +1322,8 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t      unshare_expr_without_location (max));\n \t  p = p1 & p2;\n \t}\n-      *(struct predicate *) e->aux\n-\t= p.or_with (summary->conds, *(struct predicate *) e->aux);\n+      *(class predicate *) e->aux\n+\t= p.or_with (summary->conds, *(class predicate *) e->aux);\n     }\n }\n \n@@ -1334,7 +1334,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n static void\n compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t       struct cgraph_node *node,\n-\t\t       struct ipa_fn_summary *summary)\n+\t\t       class ipa_fn_summary *summary)\n {\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   bool done = false;\n@@ -1368,7 +1368,7 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t  predicate this_bb_predicate\n \t\t    = *(predicate *) e->src->aux;\n \t\t  if (e->aux)\n-\t\t    this_bb_predicate &= (*(struct predicate *) e->aux);\n+\t\t    this_bb_predicate &= (*(class predicate *) e->aux);\n \t\t  p = p.or_with (summary->conds, this_bb_predicate);\n \t\t  if (p == true)\n \t\t    break;\n@@ -1407,7 +1407,7 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \n static predicate\n will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n-\t\t\t\t    struct ipa_fn_summary *summary,\n+\t\t\t\t    class ipa_fn_summary *summary,\n \t\t\t\t    tree expr,\n \t\t\t\t    vec<predicate> nonconstant_names)\n {\n@@ -1478,7 +1478,7 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n \n static predicate\n will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n-\t\t\t       struct ipa_fn_summary *summary,\n+\t\t\t       class ipa_fn_summary *summary,\n \t\t\t       gimple *stmt,\n \t\t\t       vec<predicate> nonconstant_names)\n {\n@@ -1586,7 +1586,7 @@ struct record_modified_bb_info\n static basic_block\n get_minimal_bb (basic_block init_bb, basic_block use_bb)\n {\n-  struct loop *l = find_common_loop (init_bb->loop_father, use_bb->loop_father);\n+  class loop *l = find_common_loop (init_bb->loop_father, use_bb->loop_father);\n   if (l && l->header->count < init_bb->count)\n     return l->header;\n   return init_bb;\n@@ -1797,7 +1797,7 @@ phi_result_unknown_predicate (ipa_func_body_info *fbi,\n    NONCONSTANT_NAMES, if possible.  */\n \n static void\n-predicate_for_phi_result (struct ipa_fn_summary *summary, gphi *phi,\n+predicate_for_phi_result (class ipa_fn_summary *summary, gphi *phi,\n \t\t\t  predicate *p,\n \t\t\t  vec<predicate> nonconstant_names)\n {\n@@ -1995,7 +1995,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   basic_block bb;\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   sreal freq;\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   predicate bb_predicate;\n   struct ipa_func_body_info fbi;\n   vec<predicate> nonconstant_names = vNULL;\n@@ -2236,7 +2236,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\t\\tWill be eliminated by inlining\\n\");\n \n-\t      struct predicate p = bb_predicate & will_be_nonconstant;\n+\t      class predicate p = bb_predicate & will_be_nonconstant;\n \n \t      /* We can ignore statement when we proved it is never going\n \t\t to happen, but we cannot do that for call statements\n@@ -2285,7 +2285,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \n   if (nonconstant_names.exists () && !early)\n     {\n-      struct loop *loop;\n+      class loop *loop;\n       predicate loop_iterations = true;\n       predicate loop_stride = true;\n \n@@ -2297,7 +2297,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  vec<edge> exits;\n \t  edge ex;\n \t  unsigned int j;\n-\t  struct tree_niter_desc niter_desc;\n+\t  class tree_niter_desc niter_desc;\n \t  bb_predicate = *(predicate *) loop->header->aux;\n \n \t  exits = get_loop_exit_edges (loop);\n@@ -2413,7 +2413,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n {\n   HOST_WIDE_INT self_stack_size;\n   struct cgraph_edge *e;\n-  struct ipa_fn_summary *info;\n+  class ipa_fn_summary *info;\n \n   gcc_assert (!node->global.inlined_to);\n \n@@ -2539,7 +2539,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n {\n   tree target;\n   struct cgraph_node *callee;\n-  struct ipa_fn_summary *isummary;\n+  class ipa_fn_summary *isummary;\n   enum availability avail;\n   bool speculative;\n \n@@ -2587,7 +2587,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     ipa_hints *hints)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  class ipa_call_summary *es = ipa_call_summaries->get (e);\n   int call_size = es->call_stmt_size;\n   int call_time = es->call_stmt_time;\n   int cur_size;\n@@ -2624,7 +2624,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+      class ipa_call_summary *es = ipa_call_summaries->get_create (e);\n \n       /* Do not care about zero sized builtins.  */\n       if (e->inline_failed && !es->call_stmt_size)\n@@ -2655,7 +2655,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+      class ipa_call_summary *es = ipa_call_summaries->get_create (e);\n       if (!es->predicate\n \t  || es->predicate->evaluate (possible_truths))\n \testimate_edge_size_and_time (e, size,\n@@ -2690,7 +2690,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n {\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   size_time_entry *e;\n   int size = 0;\n   sreal time = 0;\n@@ -2881,9 +2881,9 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n   if (ipa_node_params_sum)\n     {\n       int i;\n-      struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n-      struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n-      struct ipa_call_summary *inlined_es\n+      class ipa_edge_args *args = IPA_EDGE_REF (edge);\n+      class ipa_call_summary *es = ipa_call_summaries->get (edge);\n+      class ipa_call_summary *inlined_es\n \t= ipa_call_summaries->get (inlined_edge);\n \n       if (es->param.length () == 0)\n@@ -2924,8 +2924,8 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n static void\n remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \t\t      struct cgraph_node *node,\n-\t\t      struct ipa_fn_summary *info,\n-\t\t      struct ipa_fn_summary *callee_info,\n+\t\t      class ipa_fn_summary *info,\n+\t\t      class ipa_fn_summary *callee_info,\n \t\t      vec<int> operand_map,\n \t\t      vec<int> offset_map,\n \t\t      clause_t possible_truths,\n@@ -2934,7 +2934,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n   struct cgraph_edge *e, *next;\n   for (e = node->callees; e; e = next)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      class ipa_call_summary *es = ipa_call_summaries->get (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -2960,7 +2960,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n     }\n   for (e = node->indirect_calls; e; e = next)\n     {\n-      struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+      class ipa_call_summary *es = ipa_call_summaries->get (e);\n       predicate p;\n       next = e->next_callee;\n \n@@ -2980,8 +2980,8 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n /* Same as remap_predicate, but set result into hint *HINT.  */\n \n static void\n-remap_hint_predicate (struct ipa_fn_summary *info,\n-\t\t      struct ipa_fn_summary *callee_info,\n+remap_hint_predicate (class ipa_fn_summary *info,\n+\t\t      class ipa_fn_summary *callee_info,\n \t\t      predicate **hint,\n \t\t      vec<int> operand_map,\n \t\t      vec<int> offset_map,\n@@ -3013,15 +3013,15 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   ipa_fn_summary *callee_info = ipa_fn_summaries->get (edge->callee);\n   struct cgraph_node *to = (edge->caller->global.inlined_to\n \t\t\t    ? edge->caller->global.inlined_to : edge->caller);\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (to);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get (to);\n   clause_t clause = 0;\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n   vec<int> operand_map = vNULL;\n   vec<int> offset_map = vNULL;\n   int i;\n   predicate toplev_predicate;\n   predicate true_p = true;\n-  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  class ipa_call_summary *es = ipa_call_summaries->get (edge);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n@@ -3034,7 +3034,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n     evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL, NULL);\n   if (ipa_node_params_sum && callee_info->conds)\n     {\n-      struct ipa_edge_args *args = IPA_EDGE_REF (edge);\n+      class ipa_edge_args *args = IPA_EDGE_REF (edge);\n       int count = ipa_get_cs_argument_count (args);\n       int i;\n \n@@ -3127,7 +3127,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n void\n ipa_update_overall_fn_summary (struct cgraph_node *node)\n {\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   size_time_entry *e;\n   int i;\n \n@@ -3223,10 +3223,10 @@ ipa_fn_summary_generate (void)\n /* Write inline summary for edge E to OB.  */\n \n static void\n-read_ipa_call_summary (struct lto_input_block *ib, struct cgraph_edge *e,\n+read_ipa_call_summary (class lto_input_block *ib, struct cgraph_edge *e,\n \t\t       bool prevails)\n {\n-  struct ipa_call_summary *es = prevails\n+  class ipa_call_summary *es = prevails\n \t\t\t\t? ipa_call_summaries->get_create (e) : NULL;\n   predicate p;\n   int length, i;\n@@ -3277,7 +3277,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n   const int cfg_offset = sizeof (struct lto_function_header);\n   const int main_offset = cfg_offset + header->cfg_size;\n   const int string_offset = main_offset + header->main_size;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   unsigned int i, count2, j;\n   unsigned int f_count;\n \n@@ -3292,7 +3292,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n     {\n       unsigned int index;\n       struct cgraph_node *node;\n-      struct ipa_fn_summary *info;\n+      class ipa_fn_summary *info;\n       lto_symtab_encoder_t encoder;\n       struct bitpack_d bp;\n       struct cgraph_edge *e;\n@@ -3349,7 +3349,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       gcc_assert (!info || !info->size_time_table);\n       for (j = 0; j < count2; j++)\n \t{\n-\t  struct size_time_entry e;\n+\t  class size_time_entry e;\n \n \t  e.size = streamer_read_uhwi (&ib);\n \t  e.time = sreal::stream_in (&ib);\n@@ -3423,7 +3423,7 @@ ipa_fn_summary_read (void)\n static void\n write_ipa_call_summary (struct output_block *ob, struct cgraph_edge *e)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (e);\n+  class ipa_call_summary *es = ipa_call_summaries->get (e);\n   int i;\n \n   streamer_write_uhwi (ob, es->call_stmt_size);\n@@ -3471,7 +3471,7 @@ ipa_fn_summary_write (void)\n       cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n       if (cnode && cnode->definition && !cnode->alias)\n \t{\n-\t  struct ipa_fn_summary *info = ipa_fn_summaries->get (cnode);\n+\t  class ipa_fn_summary *info = ipa_fn_summaries->get (cnode);\n \t  struct bitpack_d bp;\n \t  struct cgraph_edge *edge;\n \t  int i;"}, {"sha": "55bc34146aa775f36fa46e90c4730e059836c917", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -184,7 +184,7 @@ class GTY((user)) ipa_fn_summary_t:\n \n   static ipa_fn_summary_t *create_ggc (symbol_table *symtab)\n   {\n-    struct ipa_fn_summary_t *summary = new (ggc_alloc <ipa_fn_summary_t> ())\n+    class ipa_fn_summary_t *summary = new (ggc_alloc <ipa_fn_summary_t> ())\n       ipa_fn_summary_t (symtab);\n     summary->disable_insertion_hook ();\n     return summary;"}, {"sha": "8af1d734d855c1792522e9bd8c38e90411aa5425", "filename": "gcc/ipa-hsa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-hsa.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -221,7 +221,7 @@ ipa_hsa_read_section (struct lto_file_decl_data *file_data, const char *data,\n   const int cfg_offset = sizeof (struct lto_function_header);\n   const int main_offset = cfg_offset + header->cfg_size;\n   const int string_offset = main_offset + header->main_size;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   unsigned int i;\n   unsigned int count;\n "}, {"sha": "4060c0e8eb38ec14d0407805f73b03fb47ded1f9", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -614,8 +614,8 @@ func_checker::compare_loops (basic_block bb1, basic_block bb2)\n   if ((bb1->loop_father == NULL) != (bb2->loop_father == NULL))\n     return return_false ();\n \n-  struct loop *l1 = bb1->loop_father;\n-  struct loop *l2 = bb2->loop_father;\n+  class loop *l1 = bb1->loop_father;\n+  class loop *l2 = bb2->loop_father;\n   if (l1 == NULL)\n     return true;\n "}, {"sha": "2174fb7494c1105ea592942eca887ba213a28c03", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -482,7 +482,7 @@ sem_function::param_used_p (unsigned int i)\n   if (ipa_node_params_sum == NULL)\n     return true;\n \n-  struct ipa_node_params *parms_info = IPA_NODE_REF (get_node ());\n+  class ipa_node_params *parms_info = IPA_NODE_REF (get_node ());\n \n   if (vec_safe_length (parms_info->descriptors) <= i)\n     return true;"}, {"sha": "a66af277d03f99305fec86d8a20653897ccf5196", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -128,7 +128,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   vec<tree> known_vals;\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n-  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  class ipa_call_summary *es = ipa_call_summaries->get (edge);\n   int min_size;\n \n   callee = edge->callee->ultimate_alias_target ();\n@@ -264,7 +264,7 @@ int\n estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  struct ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  class ipa_call_summary *es = ipa_call_summaries->get (edge);\n   ipa_fn_summary *s = ipa_fn_summaries->get (node);\n   if (!es->predicate || *es->predicate != false)\n     {\n@@ -321,7 +321,7 @@ int\n estimate_growth (struct cgraph_node *node)\n {\n   struct growth_data d = { node, false, false, 0 };\n-  struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get (node);\n \n   node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true);\n "}, {"sha": "939d86ef94a4cd74c18e96d8fdbbfecf9e78b2a5", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1037,7 +1037,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   int growth;\n   sreal edge_time, unspec_edge_time;\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n-  struct ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n+  class ipa_fn_summary *callee_info = ipa_fn_summaries->get (callee);\n   ipa_hints hints;\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n@@ -1799,7 +1799,7 @@ inline_small_functions (void)\n \t    && (node->has_gimple_body_p () || node->thunk.thunk_p)\n \t    && opt_for_fn (node->decl, optimize))\n \t  {\n-\t    struct ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+\t    class ipa_fn_summary *info = ipa_fn_summaries->get (node);\n \t    struct ipa_dfs_info *dfs = (struct ipa_dfs_info *) node->aux;\n \n \t    /* Do not account external functions, they will be optimized out"}, {"sha": "705af03d20cebbe24234be717a76ffa285fb7066", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -688,8 +688,8 @@ ipa_polymorphic_call_context::stream_out (struct output_block *ob) const\n /* Stream in the context from IB and DATA_IN.  */\n \n void\n-ipa_polymorphic_call_context::stream_in (struct lto_input_block *ib,\n-\t\t\t\t\t struct data_in *data_in)\n+ipa_polymorphic_call_context::stream_in (class lto_input_block *ib,\n+\t\t\t\t\t class data_in *data_in)\n {\n   struct bitpack_d bp = streamer_read_bitpack (ib);\n "}, {"sha": "49622e9cd337ff3650b0781d19dc0c2b5961224a", "filename": "gcc/ipa-predicate.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -398,8 +398,8 @@ predicate::remap_after_duplication (clause_t possible_truths)\n    for other purposes).  */\n \n predicate\n-predicate::remap_after_inlining (struct ipa_fn_summary *info,\n-\t\t\t\t struct ipa_fn_summary *callee_info,\n+predicate::remap_after_inlining (class ipa_fn_summary *info,\n+\t\t\t\t class ipa_fn_summary *callee_info,\n \t\t\t\t vec<int> operand_map,\n \t\t\t\t vec<int> offset_map,\n \t\t\t\t clause_t possible_truths,\n@@ -483,7 +483,7 @@ predicate::remap_after_inlining (struct ipa_fn_summary *info,\n /* Read predicate from IB.  */\n \n void\n-predicate::stream_in (struct lto_input_block *ib)\n+predicate::stream_in (class lto_input_block *ib)\n {\n   clause_t clause;\n   int k = 0;\n@@ -522,7 +522,7 @@ predicate::stream_out (struct output_block *ob)\n    It can be NULL, which means this not a load from an aggregate.  */\n \n predicate\n-add_condition (struct ipa_fn_summary *summary, int operand_num,\n+add_condition (class ipa_fn_summary *summary, int operand_num,\n \t       HOST_WIDE_INT size, struct agg_position_info *aggpos,\n \t       enum tree_code code, tree val)\n {"}, {"sha": "c2adba30551e4e9e8cac17e43e6bdfcde1730850", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -205,11 +205,11 @@ class predicate\n   predicate remap_after_duplication (clause_t);\n \n   /* Return predicate equal to THIS after inlining.  */\n-  predicate remap_after_inlining (struct ipa_fn_summary *,\n-\t\t\t          struct ipa_fn_summary *,\n+  predicate remap_after_inlining (class ipa_fn_summary *,\n+\t\t\t          class ipa_fn_summary *,\n \t\t\t          vec<int>, vec<int>, clause_t, const predicate &);\n \n-  void stream_in (struct lto_input_block *);\n+  void stream_in (class lto_input_block *);\n   void stream_out (struct output_block *);\n \n private:\n@@ -227,6 +227,6 @@ class predicate\n };\n \n void dump_condition (FILE *f, conditions conditions, int cond);\n-predicate add_condition (struct ipa_fn_summary *summary, int operand_num,\n+predicate add_condition (class ipa_fn_summary *summary, int operand_num,\n \t\t\t HOST_WIDE_INT size, struct agg_position_info *aggpos,\n \t\t\t enum tree_code code, tree val);"}, {"sha": "1fb939b73d0d206294ae543556cdd47ca465338a", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -258,7 +258,7 @@ ipa_profile_read_summary (void)\n     {\n       const char *data;\n       size_t len;\n-      struct lto_input_block *ib\n+      class lto_input_block *ib\n \t= lto_create_simple_input_block (file_data,\n \t\t\t\t\t LTO_section_ipa_profile,\n \t\t\t\t\t &data, &len);"}, {"sha": "344b78ea02fee59eb3cc836ae96f1afe0284c0ae", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -203,7 +203,7 @@ ipa_get_param_decl_index_1 (vec<ipa_param_descriptor, va_gc> *descriptors,\n    to INFO.  */\n \n int\n-ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n+ipa_get_param_decl_index (class ipa_node_params *info, tree ptree)\n {\n   return ipa_get_param_decl_index_1 (info->descriptors, ptree);\n }\n@@ -253,7 +253,7 @@ count_formal_params (tree fndecl)\n    using ipa_initialize_node_params. */\n \n void\n-ipa_dump_param (FILE *file, struct ipa_node_params *info, int i)\n+ipa_dump_param (FILE *file, class ipa_node_params *info, int i)\n {\n   fprintf (file, \"param #%i\", i);\n   if ((*info->descriptors)[i].decl_or_type)\n@@ -269,7 +269,7 @@ ipa_dump_param (FILE *file, struct ipa_node_params *info, int i)\n static bool\n ipa_alloc_node_params (struct cgraph_node *node, int param_count)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n \n   if (!info->descriptors && param_count)\n     {\n@@ -287,7 +287,7 @@ ipa_alloc_node_params (struct cgraph_node *node, int param_count)\n void\n ipa_initialize_node_params (struct cgraph_node *node)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n \n   if (!info->descriptors\n       && ipa_alloc_node_params (node, count_formal_params (node->decl)))\n@@ -375,7 +375,7 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t    }\n \t}\n \n-      struct ipa_polymorphic_call_context *ctx\n+      class ipa_polymorphic_call_context *ctx\n \t= ipa_get_ith_polymorhic_call_context (IPA_EDGE_REF (cs), i);\n       if (ctx && !ctx->useless_p ())\n \t{\n@@ -432,7 +432,7 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \n   for (cs = node->indirect_calls; cs; cs = cs->next_callee)\n     {\n-      struct cgraph_indirect_call_info *ii;\n+      class cgraph_indirect_call_info *ii;\n       if (!ipa_edge_args_info_available_for_edge_p (cs))\n \tcontinue;\n \n@@ -1190,7 +1190,7 @@ ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n \n static void\n compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n-\t\t\t\t  struct ipa_node_params *info,\n+\t\t\t\t  class ipa_node_params *info,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n \t\t\t\t  gcall *call, gimple *stmt, tree name,\n \t\t\t\t  tree param_type)\n@@ -1346,7 +1346,7 @@ get_ancestor_addr_info (gimple *assign, tree *obj_p, HOST_WIDE_INT *offset)\n \n static void\n compute_complex_ancestor_jump_func (struct ipa_func_body_info *fbi,\n-\t\t\t\t    struct ipa_node_params *info,\n+\t\t\t\t    class ipa_node_params *info,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n \t\t\t\t    gcall *call, gphi *phi)\n {\n@@ -1855,8 +1855,8 @@ static void\n ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t\t\t\t     struct cgraph_edge *cs)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n-  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  class ipa_node_params *info = IPA_NODE_REF (cs->caller);\n+  class ipa_edge_args *args = IPA_EDGE_REF (cs);\n   gcall *call = cs->call_stmt;\n   int n, arg_num = gimple_call_num_args (call);\n   bool useful_context = false;\n@@ -1880,7 +1880,7 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n       if (flag_devirtualize && POINTER_TYPE_P (TREE_TYPE (arg)))\n \t{\n \t  tree instance;\n-\t  struct ipa_polymorphic_call_context context (cs->caller->decl,\n+\t  class ipa_polymorphic_call_context context (cs->caller->decl,\n \t\t\t\t\t\t       arg, cs->call_stmt,\n \t\t\t\t\t\t       &instance);\n \t  context.get_dynamic_type (instance, arg, NULL, cs->call_stmt,\n@@ -2197,7 +2197,7 @@ static void\n ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n \t\t\t\ttree target)\n {\n-  struct ipa_node_params *info = fbi->info;\n+  class ipa_node_params *info = fbi->info;\n   HOST_WIDE_INT offset;\n   bool by_ref;\n \n@@ -2348,7 +2348,7 @@ ipa_analyze_virtual_call_uses (struct ipa_func_body_info *fbi,\n   if (TREE_CODE (obj) != SSA_NAME)\n     return;\n \n-  struct ipa_node_params *info = fbi->info;\n+  class ipa_node_params *info = fbi->info;\n   if (SSA_NAME_IS_DEFAULT_DEF (obj))\n     {\n       struct ipa_jump_func jfunc;\n@@ -2380,7 +2380,7 @@ ipa_analyze_virtual_call_uses (struct ipa_func_body_info *fbi,\n     }\n \n   struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n-  struct cgraph_indirect_call_info *ii = cs->indirect_info;\n+  class cgraph_indirect_call_info *ii = cs->indirect_info;\n   ii->offset = anc_offset;\n   ii->otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n   ii->otr_type = obj_type_ref_class (target);\n@@ -2452,7 +2452,7 @@ ipa_analyze_stmt_uses (struct ipa_func_body_info *fbi, gimple *stmt)\n static bool\n visit_ref_for_mod_analysis (gimple *, tree op, tree, void *data)\n {\n-  struct ipa_node_params *info = (struct ipa_node_params *) data;\n+  class ipa_node_params *info = (class ipa_node_params *) data;\n \n   op = get_base_address (op);\n   if (op\n@@ -2500,7 +2500,7 @@ ipa_analyze_params_uses_in_bb (struct ipa_func_body_info *fbi, basic_block bb)\n static void\n ipa_analyze_controlled_uses (struct cgraph_node *node)\n {\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n \n   for (int i = 0; i < ipa_get_param_count (info); i++)\n     {\n@@ -2592,7 +2592,7 @@ void\n ipa_analyze_node (struct cgraph_node *node)\n {\n   struct ipa_func_body_info fbi;\n-  struct ipa_node_params *info;\n+  class ipa_node_params *info;\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n@@ -2652,22 +2652,22 @@ static void\n update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t      struct cgraph_edge *e)\n {\n-  struct ipa_edge_args *top = IPA_EDGE_REF (cs);\n-  struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+  class ipa_edge_args *top = IPA_EDGE_REF (cs);\n+  class ipa_edge_args *args = IPA_EDGE_REF (e);\n   int count = ipa_get_cs_argument_count (args);\n   int i;\n \n   for (i = 0; i < count; i++)\n     {\n       struct ipa_jump_func *dst = ipa_get_ith_jump_func (args, i);\n-      struct ipa_polymorphic_call_context *dst_ctx\n+      class ipa_polymorphic_call_context *dst_ctx\n \t= ipa_get_ith_polymorhic_call_context (args, i);\n \n       if (dst->type == IPA_JF_ANCESTOR)\n \t{\n \t  struct ipa_jump_func *src;\n \t  int dst_fid = dst->value.ancestor.formal_id;\n-\t  struct ipa_polymorphic_call_context *src_ctx\n+\t  class ipa_polymorphic_call_context *src_ctx\n \t    = ipa_get_ith_polymorhic_call_context (top, dst_fid);\n \n \t  /* Variable number of arguments can cause havoc if we try to access\n@@ -2683,7 +2683,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \n \t  if (src_ctx && !src_ctx->useless_p ())\n \t    {\n-\t      struct ipa_polymorphic_call_context ctx = *src_ctx;\n+\t      class ipa_polymorphic_call_context ctx = *src_ctx;\n \n \t      /* TODO: Make type preserved safe WRT contexts.  */\n \t      if (!ipa_get_jf_ancestor_type_preserved (dst))\n@@ -2753,12 +2753,12 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      int dst_fid = dst->value.pass_through.formal_id;\n \t      src = ipa_get_ith_jump_func (top, dst_fid);\n \t      bool dst_agg_p = ipa_get_jf_pass_through_agg_preserved (dst);\n-\t      struct ipa_polymorphic_call_context *src_ctx\n+\t      class ipa_polymorphic_call_context *src_ctx\n \t\t= ipa_get_ith_polymorhic_call_context (top, dst_fid);\n \n \t      if (src_ctx && !src_ctx->useless_p ())\n \t\t{\n-\t\t  struct ipa_polymorphic_call_context ctx = *src_ctx;\n+\t\t  class ipa_polymorphic_call_context ctx = *src_ctx;\n \n \t\t  /* TODO: Make type preserved safe WRT contexts.  */\n \t\t  if (!ipa_get_jf_pass_through_type_preserved (dst))\n@@ -3231,7 +3231,7 @@ try_decrement_rdesc_refcount (struct ipa_jump_func *jfunc)\n static struct cgraph_edge *\n try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n \t\t\t\t  struct ipa_jump_func *jfunc, tree target_type,\n-\t\t\t\t  struct ipa_node_params *new_root_info)\n+\t\t\t\t  class ipa_node_params *new_root_info)\n {\n   struct cgraph_edge *cs;\n   tree target;\n@@ -3302,7 +3302,7 @@ ipa_impossible_devirt_target (struct cgraph_edge *ie, tree target)\n static struct cgraph_edge *\n try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t   struct ipa_jump_func *jfunc,\n-\t\t\t\t   struct ipa_polymorphic_call_context ctx)\n+\t\t\t\t   class ipa_polymorphic_call_context ctx)\n {\n   tree target = NULL;\n   bool speculative = false;\n@@ -3412,9 +3412,9 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t      struct cgraph_node *node,\n \t\t\t\t      vec<cgraph_edge *> *new_edges)\n {\n-  struct ipa_edge_args *top;\n+  class ipa_edge_args *top;\n   struct cgraph_edge *ie, *next_ie, *new_direct_edge;\n-  struct ipa_node_params *new_root_info, *inlined_node_info;\n+  class ipa_node_params *new_root_info, *inlined_node_info;\n   bool res = false;\n \n   ipa_check_create_edge_args ();\n@@ -3426,7 +3426,7 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n-      struct cgraph_indirect_call_info *ici = ie->indirect_info;\n+      class cgraph_indirect_call_info *ici = ie->indirect_info;\n       struct ipa_jump_func *jfunc;\n       int param_index;\n       cgraph_node *spec_target = NULL;\n@@ -3583,11 +3583,11 @@ combine_controlled_uses_counters (int c, int d)\n static void\n propagate_controlled_uses (struct cgraph_edge *cs)\n {\n-  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  class ipa_edge_args *args = IPA_EDGE_REF (cs);\n   struct cgraph_node *new_root = cs->caller->global.inlined_to\n     ? cs->caller->global.inlined_to : cs->caller;\n-  struct ipa_node_params *new_root_info = IPA_NODE_REF (new_root);\n-  struct ipa_node_params *old_root_info = IPA_NODE_REF (cs->callee);\n+  class ipa_node_params *new_root_info = IPA_NODE_REF (new_root);\n+  class ipa_node_params *old_root_info = IPA_NODE_REF (cs->callee);\n   int count, i;\n \n   count = MIN (ipa_get_cs_argument_count (args),\n@@ -3881,7 +3881,7 @@ ipa_edge_args_sum_t::duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t{\n \t  struct cgraph_node *inline_root = dst->caller->global.inlined_to\n \t    ? dst->caller->global.inlined_to : dst->caller;\n-\t  struct ipa_node_params *root_info = IPA_NODE_REF (inline_root);\n+\t  class ipa_node_params *root_info = IPA_NODE_REF (inline_root);\n \t  int idx = ipa_get_jf_pass_through_formal_id (dst_jf);\n \n \t  int c = ipa_get_controlled_uses (root_info, idx);\n@@ -4025,7 +4025,7 @@ void\n ipa_print_node_params (FILE *f, struct cgraph_node *node)\n {\n   int i, count;\n-  struct ipa_node_params *info;\n+  class ipa_node_params *info;\n \n   if (!node->definition)\n     return;\n@@ -4173,10 +4173,10 @@ ipa_write_jump_function (struct output_block *ob,\n /* Read in jump function JUMP_FUNC from IB.  */\n \n static void\n-ipa_read_jump_function (struct lto_input_block *ib,\n+ipa_read_jump_function (class lto_input_block *ib,\n \t\t\tstruct ipa_jump_func *jump_func,\n \t\t\tstruct cgraph_edge *cs,\n-\t\t\tstruct data_in *data_in,\n+\t\t\tclass data_in *data_in,\n \t\t\tbool prevails)\n {\n   enum jump_func_type jftype;\n@@ -4285,7 +4285,7 @@ static void\n ipa_write_indirect_edge_info (struct output_block *ob,\n \t\t\t      struct cgraph_edge *cs)\n {\n-  struct cgraph_indirect_call_info *ii = cs->indirect_info;\n+  class cgraph_indirect_call_info *ii = cs->indirect_info;\n   struct bitpack_d bp;\n \n   streamer_write_hwi (ob, ii->param_index);\n@@ -4314,11 +4314,11 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n    relevant to indirect inlining from IB.  */\n \n static void\n-ipa_read_indirect_edge_info (struct lto_input_block *ib,\n-\t\t\t     struct data_in *data_in,\n+ipa_read_indirect_edge_info (class lto_input_block *ib,\n+\t\t\t     class data_in *data_in,\n \t\t\t     struct cgraph_edge *cs)\n {\n-  struct cgraph_indirect_call_info *ii = cs->indirect_info;\n+  class cgraph_indirect_call_info *ii = cs->indirect_info;\n   struct bitpack_d bp;\n \n   ii->param_index = (int) streamer_read_hwi (ib);\n@@ -4348,7 +4348,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n {\n   int node_ref;\n   lto_symtab_encoder_t encoder;\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF (node);\n   int j;\n   struct cgraph_edge *e;\n   struct bitpack_d bp;\n@@ -4375,7 +4375,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     }\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+      class ipa_edge_args *args = IPA_EDGE_REF (e);\n \n       streamer_write_uhwi (ob,\n \t\t\t   ipa_get_cs_argument_count (args) * 2\n@@ -4389,7 +4389,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n-      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+      class ipa_edge_args *args = IPA_EDGE_REF (e);\n \n       streamer_write_uhwi (ob,\n \t\t\t   ipa_get_cs_argument_count (args) * 2\n@@ -4407,8 +4407,8 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n /* Stream in edge E from IB.  */\n \n static void\n-ipa_read_edge_info (struct lto_input_block *ib,\n-\t\t    struct data_in *data_in,\n+ipa_read_edge_info (class lto_input_block *ib,\n+\t\t    class data_in *data_in,\n \t\t    struct cgraph_edge *e, bool prevails)\n {\n   int count = streamer_read_uhwi (ib);\n@@ -4419,7 +4419,7 @@ ipa_read_edge_info (struct lto_input_block *ib,\n     return;\n   if (prevails && e->possibly_call_in_translation_unit_p ())\n     {\n-      struct ipa_edge_args *args = IPA_EDGE_REF (e);\n+      class ipa_edge_args *args = IPA_EDGE_REF (e);\n       vec_safe_grow_cleared (args->jump_functions, count);\n       if (contexts_computed)\n \tvec_safe_grow_cleared (args->polymorphic_call_contexts, count);\n@@ -4441,7 +4441,7 @@ ipa_read_edge_info (struct lto_input_block *ib,\n \t\t\t\t  data_in, prevails);\n \t  if (contexts_computed)\n \t    {\n-\t      struct ipa_polymorphic_call_context ctx;\n+\t      class ipa_polymorphic_call_context ctx;\n \t      ctx.stream_in (ib, data_in);\n \t    }\n \t}\n@@ -4451,14 +4451,14 @@ ipa_read_edge_info (struct lto_input_block *ib,\n /* Stream in NODE info from IB.  */\n \n static void\n-ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n-\t\t    struct data_in *data_in)\n+ipa_read_node_info (class lto_input_block *ib, struct cgraph_node *node,\n+\t\t    class data_in *data_in)\n {\n   int k;\n   struct cgraph_edge *e;\n   struct bitpack_d bp;\n   bool prevails = node->prevailing_p ();\n-  struct ipa_node_params *info = prevails ? IPA_NODE_REF (node) : NULL;\n+  class ipa_node_params *info = prevails ? IPA_NODE_REF (node) : NULL;\n \n   int param_count = streamer_read_uhwi (ib);\n   if (prevails)\n@@ -4555,7 +4555,7 @@ ipa_prop_read_section (struct lto_file_decl_data *file_data, const char *data,\n   const int cfg_offset = sizeof (struct lto_function_header);\n   const int main_offset = cfg_offset + header->cfg_size;\n   const int string_offset = main_offset + header->main_size;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   unsigned int i;\n   unsigned int count;\n \n@@ -4803,7 +4803,7 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n   const int cfg_offset = sizeof (struct lto_function_header);\n   const int main_offset = cfg_offset + header->cfg_size;\n   const int string_offset = main_offset + header->main_size;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   unsigned int i;\n   unsigned int count;\n "}, {"sha": "6470c938ecd75d1fa0cd100cd97343e558e7fb29", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -179,12 +179,12 @@ struct GTY (()) ipa_jump_func\n   /* Information about zero/non-zero bits.  The pointed to structure is shared\n      betweed different jump functions.  Use ipa_set_jfunc_bits to set this\n      field.  */\n-  struct ipa_bits *bits;\n+  class ipa_bits *bits;\n \n   /* Information about value range, containing valid data only when vr_known is\n      true.  The pointed to structure is shared betweed different jump\n      functions.  Use ipa_set_jfunc_vr to set this field.  */\n-  struct value_range_base *m_vr;\n+  class value_range_base *m_vr;\n \n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump\n@@ -335,7 +335,7 @@ class GTY((for_user)) ipa_node_params\n   vec<ipa_param_descriptor, va_gc> *descriptors;\n   /* Pointer to an array of structures describing individual formal\n      parameters.  */\n-  struct ipcp_param_lattices * GTY((skip)) lattices;\n+  class ipcp_param_lattices * GTY((skip)) lattices;\n   /* Only for versioned nodes this field would not be NULL,\n      it points to the node that IPA cp cloned from.  */\n   struct cgraph_node * GTY((skip)) ipcp_orig_node;\n@@ -423,7 +423,7 @@ struct ipa_func_body_info\n   cgraph_node *node;\n \n   /* Its info.  */\n-  struct ipa_node_params *info;\n+  class ipa_node_params *info;\n \n   /* Information about individual BBs. */\n   vec<ipa_bb_info> bb_infos;\n@@ -442,7 +442,7 @@ struct ipa_func_body_info\n /* Return the number of formal parameters. */\n \n static inline int\n-ipa_get_param_count (struct ipa_node_params *info)\n+ipa_get_param_count (class ipa_node_params *info)\n {\n   return vec_safe_length (info->descriptors);\n }\n@@ -453,7 +453,7 @@ ipa_get_param_count (struct ipa_node_params *info)\n    WPA.  */\n \n static inline tree\n-ipa_get_param (struct ipa_node_params *info, int i)\n+ipa_get_param (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n   gcc_checking_assert (!flag_wpa);\n@@ -466,7 +466,7 @@ ipa_get_param (struct ipa_node_params *info, int i)\n    to INFO if it is known or NULL if not.  */\n \n static inline tree\n-ipa_get_type (struct ipa_node_params *info, int i)\n+ipa_get_type (class ipa_node_params *info, int i)\n {\n   if (vec_safe_length (info->descriptors) <= (unsigned) i)\n     return NULL;\n@@ -483,7 +483,7 @@ ipa_get_type (struct ipa_node_params *info, int i)\n    to INFO.  */\n \n static inline int\n-ipa_get_param_move_cost (struct ipa_node_params *info, int i)\n+ipa_get_param_move_cost (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n   return (*info->descriptors)[i].move_cost;\n@@ -493,7 +493,7 @@ ipa_get_param_move_cost (struct ipa_node_params *info, int i)\n    associated with INFO to VAL.  */\n \n static inline void\n-ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n+ipa_set_param_used (class ipa_node_params *info, int i, bool val)\n {\n   gcc_checking_assert (info->descriptors);\n   (*info->descriptors)[i].used = val;\n@@ -503,7 +503,7 @@ ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n    IPA_UNDESCRIBED_USE if there is a use that is not described by these\n    structures.  */\n static inline int\n-ipa_get_controlled_uses (struct ipa_node_params *info, int i)\n+ipa_get_controlled_uses (class ipa_node_params *info, int i)\n {\n   /* FIXME: introducing speculation causes out of bounds access here.  */\n   if (vec_safe_length (info->descriptors) > (unsigned)i)\n@@ -514,7 +514,7 @@ ipa_get_controlled_uses (struct ipa_node_params *info, int i)\n /* Set the controlled counter of a given parameter.  */\n \n static inline void\n-ipa_set_controlled_uses (struct ipa_node_params *info, int i, int val)\n+ipa_set_controlled_uses (class ipa_node_params *info, int i, int val)\n {\n   gcc_checking_assert (info->descriptors);\n   (*info->descriptors)[i].controlled_uses = val;\n@@ -524,7 +524,7 @@ ipa_set_controlled_uses (struct ipa_node_params *info, int i, int val)\n    function associated with INFO.  */\n \n static inline bool\n-ipa_is_param_used (struct ipa_node_params *info, int i)\n+ipa_is_param_used (class ipa_node_params *info, int i)\n {\n   gcc_checking_assert (info->descriptors);\n   return (*info->descriptors)[i].used;\n@@ -592,7 +592,7 @@ class GTY((for_user)) ipa_edge_args\n /* Return the number of actual arguments. */\n \n static inline int\n-ipa_get_cs_argument_count (struct ipa_edge_args *args)\n+ipa_get_cs_argument_count (class ipa_edge_args *args)\n {\n   return vec_safe_length (args->jump_functions);\n }\n@@ -602,15 +602,15 @@ ipa_get_cs_argument_count (struct ipa_edge_args *args)\n    ipa_compute_jump_functions. */\n \n static inline struct ipa_jump_func *\n-ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n+ipa_get_ith_jump_func (class ipa_edge_args *args, int i)\n {\n   return &(*args->jump_functions)[i];\n }\n \n /* Returns a pointer to the polymorphic call context for the ith argument.\n    NULL if contexts are not computed.  */\n-static inline struct ipa_polymorphic_call_context *\n-ipa_get_ith_polymorhic_call_context (struct ipa_edge_args *args, int i)\n+static inline class ipa_polymorphic_call_context *\n+ipa_get_ith_polymorhic_call_context (class ipa_edge_args *args, int i)\n {\n   if (!args->polymorphic_call_contexts)\n     return NULL;\n@@ -781,11 +781,11 @@ extern object_allocator<ipcp_value<ipa_polymorphic_call_context> >\n   ipcp_poly_ctx_values_pool;\n \n template <typename valtype>\n-class ipcp_value_source;\n+struct ipcp_value_source;\n \n extern object_allocator<ipcp_value_source<tree> > ipcp_sources_pool;\n \n-class ipcp_agg_lattice;\n+struct ipcp_agg_lattice;\n \n extern object_allocator<ipcp_agg_lattice> ipcp_agg_lattice_pool;\n \n@@ -795,15 +795,15 @@ void ipa_prop_write_jump_functions (void);\n void ipa_prop_read_jump_functions (void);\n void ipcp_write_transformation_summaries (void);\n void ipcp_read_transformation_summaries (void);\n-int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n-tree ipa_value_from_jfunc (struct ipa_node_params *info,\n+int ipa_get_param_decl_index (class ipa_node_params *, tree);\n+tree ipa_value_from_jfunc (class ipa_node_params *info,\n \t\t\t   struct ipa_jump_func *jfunc, tree type);\n unsigned int ipcp_transform_function (struct cgraph_node *node);\n ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,\n \t\t\t\t\t\t     cgraph_edge *,\n \t\t\t\t\t\t     int,\n \t\t\t\t\t\t     ipa_jump_func *);\n-void ipa_dump_param (FILE *, struct ipa_node_params *info, int i);\n+void ipa_dump_param (FILE *, class ipa_node_params *info, int i);\n void ipa_release_body_info (struct ipa_func_body_info *);\n tree ipa_get_callee_param_type (struct cgraph_edge *e, int i);\n "}, {"sha": "db91d2c1a32521d54e0801558e1fae84be84d279", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -122,7 +122,7 @@ class funct_state_d\n   enum malloc_state_e malloc_state;\n };\n \n-typedef struct funct_state_d * funct_state;\n+typedef class funct_state_d * funct_state;\n \n /* The storage of the funct_state is abstracted because there is the\n    possibility that it may be desirable to move this to the cgraph\n@@ -1014,7 +1014,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   funct_state l;\n   basic_block this_block;\n \n-  l = XCNEW (struct funct_state_d);\n+  l = XCNEW (class funct_state_d);\n   l->pure_const_state = IPA_CONST;\n   l->state_previously_known = IPA_NEITHER;\n   l->looping_previously_known = true;\n@@ -1086,7 +1086,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t    }\n \t  else\n \t    {\n-\t      struct loop *loop;\n+\t      class loop *loop;\n \t      scev_initialize ();\n \t      FOR_EACH_LOOP (loop, 0)\n \t\tif (!finite_loop_p (loop))\n@@ -1279,7 +1279,7 @@ pure_const_read_summary (void)\n     {\n       const char *data;\n       size_t len;\n-      struct lto_input_block *ib\n+      class lto_input_block *ib\n \t= lto_create_simple_input_block (file_data,\n \t\t\t\t\t LTO_section_ipa_pure_const,\n \t\t\t\t\t &data, &len);"}, {"sha": "0d8e509c932f4ed2c94ea0aa7e952e437cceb33c", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -22,8 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_IPA_REF_H\n \n struct cgraph_node;\n-class varpool_node;\n-class symtab_node;\n+struct varpool_node;\n+struct symtab_node;\n \n \n /* How the reference is done.  */"}, {"sha": "78737aa9e3f3b8ace8e78f09814fc2982bb7e2fe", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1069,7 +1069,7 @@ ipa_reference_read_optimization_summary (void)\n     {\n       const char *data;\n       size_t len;\n-      struct lto_input_block *ib\n+      class lto_input_block *ib\n \t= lto_create_simple_input_block (file_data,\n \t\t\t\t\t LTO_section_ipa_reference,\n \t\t\t\t\t &data, &len);"}, {"sha": "86b26d3cef37771daa197376842355d54757dbc4", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -146,7 +146,7 @@ class split_point\n \n /* Best split point found.  */\n \n-struct split_point best_split_point;\n+class split_point best_split_point;\n \n /* Set of basic blocks that are not allowed to dominate a split point.  */\n \n@@ -193,7 +193,7 @@ test_nonssa_use (gimple *, tree t, tree, void *data)\n /* Dump split point CURRENT.  */\n \n static void\n-dump_split_point (FILE * file, struct split_point *current)\n+dump_split_point (FILE * file, class split_point *current)\n {\n   fprintf (file,\n \t   \"Split point at BB %i\\n\"\n@@ -212,7 +212,7 @@ dump_split_point (FILE * file, struct split_point *current)\n    Parameters are the same as for consider_split.  */\n \n static bool\n-verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n+verify_non_ssa_vars (class split_point *current, bitmap non_ssa_vars,\n \t\t     basic_block return_bb)\n {\n   bitmap seen = BITMAP_ALLOC (NULL);\n@@ -406,7 +406,7 @@ dominated_by_forbidden (basic_block bb)\n /* For give split point CURRENT and return block RETURN_BB return 1\n    if ssa name VAL is set by split part and 0 otherwise.  */\n static bool\n-split_part_set_ssa_name_p (tree val, struct split_point *current,\n+split_part_set_ssa_name_p (tree val, class split_point *current,\n \t\t\t   basic_block return_bb)\n {\n   if (TREE_CODE (val) != SSA_NAME)\n@@ -423,7 +423,7 @@ split_part_set_ssa_name_p (tree val, struct split_point *current,\n    See if we can split function here.  */\n \n static void\n-consider_split (struct split_point *current, bitmap non_ssa_vars,\n+consider_split (class split_point *current, bitmap non_ssa_vars,\n \t\tbasic_block return_bb)\n {\n   tree parm;\n@@ -1035,7 +1035,7 @@ find_split_points (basic_block return_bb, sreal overall_time, int overall_size)\n   stack_entry first;\n   vec<stack_entry> stack = vNULL;\n   basic_block bb;\n-  struct split_point current;\n+  class split_point current;\n \n   current.header_time = overall_time;\n   current.header_size = overall_size;\n@@ -1181,7 +1181,7 @@ find_split_points (basic_block return_bb, sreal overall_time, int overall_size)\n /* Split function at SPLIT_POINT.  */\n \n static void\n-split_function (basic_block return_bb, struct split_point *split_point,\n+split_function (basic_block return_bb, class split_point *split_point,\n \t\tbool add_tsan_func_exit)\n {\n   vec<tree> args_to_pass = vNULL;"}, {"sha": "c7457fa443191a1967a2bb9a671b118a7874be66", "filename": "gcc/ira-build.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -253,10 +253,10 @@ finish_loop_tree_nodes (void)\n    loop designating the whole function when CFG loops are not\n    built.  */\n static void\n-add_loop_to_tree (struct loop *loop)\n+add_loop_to_tree (class loop *loop)\n {\n   int loop_num;\n-  struct loop *parent;\n+  class loop *parent;\n   ira_loop_tree_node_t loop_node, parent_node;\n \n   /* We cannot use loop node access macros here because of potential\n@@ -331,7 +331,7 @@ static void\n form_loop_tree (void)\n {\n   basic_block bb;\n-  struct loop *parent;\n+  class loop *parent;\n   ira_loop_tree_node_t bb_node, loop_node;\n \n   /* We cannot use loop/bb node access macros because of potential\n@@ -2168,7 +2168,7 @@ low_pressure_loop_node_p (ira_loop_tree_node_t node)\n    form a region from such loop if the target use stack register\n    because reg-stack.c cannot deal with such edges.  */\n static bool\n-loop_with_complex_edge_p (struct loop *loop)\n+loop_with_complex_edge_p (class loop *loop)\n {\n   int i;\n   edge_iterator ei;"}, {"sha": "99236994d645b35c0baf4e505856e55502391e14", "filename": "gcc/ira-color.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -4557,7 +4557,7 @@ ira_reuse_stack_slot (int regno, poly_uint64 inherent_size,\n   ira_allocno_t another_allocno, allocno = ira_regno_allocno_map[regno];\n   rtx x;\n   bitmap_iterator bi;\n-  struct ira_spilled_reg_stack_slot *slot = NULL;\n+  class ira_spilled_reg_stack_slot *slot = NULL;\n \n   ira_assert (! ira_use_lra_p);\n \n@@ -4669,7 +4669,7 @@ ira_reuse_stack_slot (int regno, poly_uint64 inherent_size,\n void\n ira_mark_new_stack_slot (rtx x, int regno, poly_uint64 total_size)\n {\n-  struct ira_spilled_reg_stack_slot *slot;\n+  class ira_spilled_reg_stack_slot *slot;\n   int slot_num;\n   ira_allocno_t allocno;\n "}, {"sha": "92b7dfb11198695c6f866c6a587ed84b454e6011", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -82,7 +82,7 @@ struct ira_loop_tree_node\n   /* The node represents basic block if children == NULL.  */\n   basic_block bb;    /* NULL for loop.  */\n   /* NULL for BB or for loop tree root if we did not build CFG loop tree.  */\n-  struct loop *loop;\n+  class loop *loop;\n   /* NEXT/SUBLOOP_NEXT is the next node/loop-node of the same parent.\n      SUBLOOP_NEXT is always NULL for BBs.  */\n   ira_loop_tree_node_t subloop_next, next;\n@@ -613,7 +613,7 @@ extern int ira_spilled_reg_stack_slots_num;\n \n /* The following array contains info about spilled pseudo-registers\n    stack slots used in current function so far.  */\n-extern struct ira_spilled_reg_stack_slot *ira_spilled_reg_stack_slots;\n+extern class ira_spilled_reg_stack_slot *ira_spilled_reg_stack_slots;\n \n /* Correspondingly overall cost of the allocation, cost of the\n    allocnos assigned to hard-registers, cost of the allocnos assigned\n@@ -909,9 +909,9 @@ class target_ira_int {\n   bool x_ira_prohibited_mode_move_regs_initialized_p;\n };\n \n-extern struct target_ira_int default_target_ira_int;\n+extern class target_ira_int default_target_ira_int;\n #if SWITCHABLE_TARGET\n-extern struct target_ira_int *this_target_ira_int;\n+extern class target_ira_int *this_target_ira_int;\n #else\n #define this_target_ira_int (&default_target_ira_int)\n #endif"}, {"sha": "c58daba6e79949874e83780465936e50903f129e", "filename": "gcc/ira.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -394,10 +394,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"print-rtl.h\"\n \n struct target_ira default_target_ira;\n-struct target_ira_int default_target_ira_int;\n+class target_ira_int default_target_ira_int;\n #if SWITCHABLE_TARGET\n struct target_ira *this_target_ira = &default_target_ira;\n-struct target_ira_int *this_target_ira_int = &default_target_ira_int;\n+class target_ira_int *this_target_ira_int = &default_target_ira_int;\n #endif\n \n /* A modified value of flag `-fira-verbose' used internally.  */\n@@ -411,7 +411,7 @@ int ira_spilled_reg_stack_slots_num;\n \n /* The following array contains info about spilled pseudo-registers\n    stack slots used in current function so far.  */\n-struct ira_spilled_reg_stack_slot *ira_spilled_reg_stack_slots;\n+class ira_spilled_reg_stack_slot *ira_spilled_reg_stack_slots;\n \n /* Correspondingly overall cost of the allocation, overall cost before\n    reload, cost of the allocnos assigned to hard-registers, cost of\n@@ -4061,7 +4061,7 @@ setup_reg_equiv (void)\n \n /* Print chain C to FILE.  */\n static void\n-print_insn_chain (FILE *file, struct insn_chain *c)\n+print_insn_chain (FILE *file, class insn_chain *c)\n {\n   fprintf (file, \"insn=%d, \", INSN_UID (c->insn));\n   bitmap_print (file, &c->live_throughout, \"live_throughout: \", \", \");\n@@ -4073,7 +4073,7 @@ print_insn_chain (FILE *file, struct insn_chain *c)\n static void\n print_insn_chains (FILE *file)\n {\n-  struct insn_chain *c;\n+  class insn_chain *c;\n   for (c = reload_insn_chain; c ; c = c->next)\n     print_insn_chain (file, c);\n }\n@@ -4134,10 +4134,10 @@ static void\n build_insn_chain (void)\n {\n   unsigned int i;\n-  struct insn_chain **p = &reload_insn_chain;\n+  class insn_chain **p = &reload_insn_chain;\n   basic_block bb;\n-  struct insn_chain *c = NULL;\n-  struct insn_chain *next = NULL;\n+  class insn_chain *c = NULL;\n+  class insn_chain *next = NULL;\n   auto_bitmap live_relevant_regs;\n   auto_bitmap elim_regset;\n   /* live_subregs is a vector used to keep accurate information about\n@@ -5467,11 +5467,11 @@ ira (FILE *f)\n \t{\n \t  ira_spilled_reg_stack_slots_num = 0;\n \t  ira_spilled_reg_stack_slots\n-\t    = ((struct ira_spilled_reg_stack_slot *)\n+\t    = ((class ira_spilled_reg_stack_slot *)\n \t       ira_allocate (max_regno\n-\t\t\t     * sizeof (struct ira_spilled_reg_stack_slot)));\n+\t\t\t     * sizeof (class ira_spilled_reg_stack_slot)));\n \t  memset ((void *)ira_spilled_reg_stack_slots, 0,\n-\t\t  max_regno * sizeof (struct ira_spilled_reg_stack_slot));\n+\t\t  max_regno * sizeof (class ira_spilled_reg_stack_slot));\n \t}\n     }\n   allocate_initial_values ();"}, {"sha": "0efe7b449ffdced745bc69e6510ec1e2ac00c311", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -263,7 +263,7 @@ doloop_condition_get (rtx_insn *doloop_pat)\n    describes the number of iterations of the loop.  */\n \n static bool\n-doloop_valid_p (struct loop *loop, struct niter_desc *desc)\n+doloop_valid_p (class loop *loop, class niter_desc *desc)\n {\n   basic_block *body = get_loop_body (loop), bb;\n   rtx_insn *insn;\n@@ -405,7 +405,7 @@ add_test (rtx cond, edge *e, basic_block dest)\n    DOLOOP_SEQ.  COUNT is the number of iterations of the LOOP.  */\n \n static void\n-doloop_modify (struct loop *loop, struct niter_desc *desc,\n+doloop_modify (class loop *loop, class niter_desc *desc,\n \t       rtx_insn *doloop_seq, rtx condition, rtx count)\n {\n   rtx counter_reg;\n@@ -603,7 +603,7 @@ record_reg_sets (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n    modified.  */\n \n static bool\n-doloop_optimize (struct loop *loop)\n+doloop_optimize (class loop *loop)\n {\n   scalar_int_mode mode;\n   rtx doloop_reg;\n@@ -614,7 +614,7 @@ doloop_optimize (struct loop *loop)\n   unsigned level;\n   HOST_WIDE_INT est_niter;\n   int max_cost;\n-  struct niter_desc *desc;\n+  class niter_desc *desc;\n   unsigned word_mode_size;\n   unsigned HOST_WIDE_INT word_mode_max;\n   int entered_at_top;\n@@ -754,7 +754,7 @@ doloop_optimize (struct loop *loop)\n void\n doloop_optimize_loops (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   if (optimize == 1)\n     {"}, {"sha": "4b3bbccd63566bd689f71b3c382b76dd9f80464b", "filename": "gcc/loop-init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -135,7 +135,7 @@ loop_optimizer_init (unsigned flags)\n void\n loop_optimizer_finalize (struct function *fn)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   basic_block bb;\n \n   timevar_push (TV_LOOP_FINI);\n@@ -194,7 +194,7 @@ fix_loop_structure (bitmap changed_bbs)\n {\n   basic_block bb;\n   int record_exits = 0;\n-  struct loop *loop;\n+  class loop *loop;\n   unsigned old_nloops, i;\n \n   timevar_push (TV_LOOP_INIT);\n@@ -237,7 +237,7 @@ fix_loop_structure (bitmap changed_bbs)\n \n       while (loop->inner)\n \t{\n-\t  struct loop *ploop = loop->inner;\n+\t  class loop *ploop = loop->inner;\n \t  flow_loop_tree_node_remove (ploop);\n \t  flow_loop_tree_node_add (loop_outer (loop), ploop);\n \t}"}, {"sha": "644ecfc6fbbae35fd812b533f5c73516a6d747eb", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -61,7 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n class loop_data\n {\n public:\n-  struct loop *outermost_exit;\t/* The outermost exit of the loop.  */\n+  class loop *outermost_exit;\t/* The outermost exit of the loop.  */\n   bool has_call;\t\t/* True if the loop contains a call.  */\n   /* Maximal register pressure inside loop for given register class\n      (defined only for the pressure classes).  */\n@@ -71,7 +71,7 @@ class loop_data\n   bitmap_head regs_live;\n };\n \n-#define LOOP_DATA(LOOP) ((struct loop_data *) (LOOP)->aux)\n+#define LOOP_DATA(LOOP) ((class loop_data *) (LOOP)->aux)\n \n /* The description of an use.  */\n \n@@ -144,7 +144,7 @@ struct invariant\n };\n \n /* Currently processed loop.  */\n-static struct loop *curr_loop;\n+static class loop *curr_loop;\n \n /* Table of invariants indexed by the df_ref uid field.  */\n \n@@ -558,7 +558,7 @@ merge_identical_invariants (void)\n    get_loop_body_in_dom_order.  */\n \n static void\n-compute_always_reached (struct loop *loop, basic_block *body,\n+compute_always_reached (class loop *loop, basic_block *body,\n \t\t\tbitmap may_exit, bitmap always_reached)\n {\n   unsigned i;\n@@ -578,13 +578,13 @@ compute_always_reached (struct loop *loop, basic_block *body,\n    additionally mark blocks that may exit due to a call.  */\n \n static void\n-find_exits (struct loop *loop, basic_block *body,\n+find_exits (class loop *loop, basic_block *body,\n \t    bitmap may_exit, bitmap has_exit)\n {\n   unsigned i;\n   edge_iterator ei;\n   edge e;\n-  struct loop *outermost_exit = loop, *aexit;\n+  class loop *outermost_exit = loop, *aexit;\n   bool has_call = false;\n   rtx_insn *insn;\n \n@@ -645,7 +645,7 @@ find_exits (struct loop *loop, basic_block *body,\n \n   if (loop->aux == NULL)\n     {\n-      loop->aux = xcalloc (1, sizeof (struct loop_data));\n+      loop->aux = xcalloc (1, sizeof (class loop_data));\n       bitmap_initialize (&LOOP_DATA (loop)->regs_ref, &reg_obstack);\n       bitmap_initialize (&LOOP_DATA (loop)->regs_live, &reg_obstack);\n     }\n@@ -673,7 +673,7 @@ may_assign_reg_p (rtx x)\n    BODY.  */\n \n static void\n-find_defs (struct loop *loop)\n+find_defs (class loop *loop)\n {\n   if (dump_file)\n     {\n@@ -1210,7 +1210,7 @@ find_invariants_bb (basic_block bb, bool always_reached, bool always_executed)\n    ends due to a function call.  */\n \n static void\n-find_invariants_body (struct loop *loop, basic_block *body,\n+find_invariants_body (class loop *loop, basic_block *body,\n \t\t      bitmap always_reached, bitmap always_executed)\n {\n   unsigned i;\n@@ -1224,7 +1224,7 @@ find_invariants_body (struct loop *loop, basic_block *body,\n /* Finds invariants in LOOP.  */\n \n static void\n-find_invariants (struct loop *loop)\n+find_invariants (class loop *loop)\n {\n   auto_bitmap may_exit;\n   auto_bitmap always_reached;\n@@ -1687,7 +1687,7 @@ replace_uses (struct invariant *inv, rtx reg, bool in_group)\n    the block preceding its header.  */\n \n static bool\n-can_move_invariant_reg (struct loop *loop, struct invariant *inv, rtx reg)\n+can_move_invariant_reg (class loop *loop, struct invariant *inv, rtx reg)\n {\n   df_ref def, use;\n   unsigned int dest_regno, defs_in_loop_count = 0;\n@@ -1760,7 +1760,7 @@ can_move_invariant_reg (struct loop *loop, struct invariant *inv, rtx reg)\n    otherwise.  */\n \n static bool\n-move_invariant_reg (struct loop *loop, unsigned invno)\n+move_invariant_reg (class loop *loop, unsigned invno)\n {\n   struct invariant *inv = invariants[invno];\n   struct invariant *repr = invariants[inv->eqto];\n@@ -1866,7 +1866,7 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n    in TEMPORARY_REGS.  */\n \n static void\n-move_invariants (struct loop *loop)\n+move_invariants (class loop *loop)\n {\n   struct invariant *inv;\n   unsigned i;\n@@ -1939,7 +1939,7 @@ free_inv_motion_data (void)\n /* Move the invariants out of the LOOP.  */\n \n static void\n-move_single_loop_invariants (struct loop *loop)\n+move_single_loop_invariants (class loop *loop)\n {\n   init_inv_motion_data ();\n \n@@ -1954,9 +1954,9 @@ move_single_loop_invariants (struct loop *loop)\n /* Releases the auxiliary data for LOOP.  */\n \n static void\n-free_loop_data (struct loop *loop)\n+free_loop_data (class loop *loop)\n {\n-  struct loop_data *data = LOOP_DATA (loop);\n+  class loop_data *data = LOOP_DATA (loop);\n   if (!data)\n     return;\n \n@@ -2035,7 +2035,7 @@ change_pressure (int regno, bool incr_p)\n static void\n mark_regno_live (int regno)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   for (loop = curr_loop;\n        loop != current_loops->tree_root;\n@@ -2104,7 +2104,7 @@ mark_ref_regs (rtx x)\n   code = GET_CODE (x);\n   if (code == REG)\n     {\n-      struct loop *loop;\n+      class loop *loop;\n \n       for (loop = curr_loop;\n \t   loop != current_loops->tree_root;\n@@ -2136,12 +2136,12 @@ calculate_loop_reg_pressure (void)\n   basic_block bb;\n   rtx_insn *insn;\n   rtx link;\n-  struct loop *loop, *parent;\n+  class loop *loop, *parent;\n \n   FOR_EACH_LOOP (loop, 0)\n     if (loop->aux == NULL)\n       {\n-\tloop->aux = xcalloc (1, sizeof (struct loop_data));\n+\tloop->aux = xcalloc (1, sizeof (class loop_data));\n \tbitmap_initialize (&LOOP_DATA (loop)->regs_ref, &reg_obstack);\n \tbitmap_initialize (&LOOP_DATA (loop)->regs_live, &reg_obstack);\n       }\n@@ -2253,7 +2253,7 @@ calculate_loop_reg_pressure (void)\n void\n move_loop_invariants (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   if (optimize == 1)\n     df_live_add_problem ();"}, {"sha": "2274cc3075b9abb447f6954dac86aefd09319052", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -89,23 +89,23 @@ class biv_entry\n {\n public:\n   unsigned regno;\t/* The register of the biv.  */\n-  struct rtx_iv iv;\t/* Value of the biv.  */\n+  class rtx_iv iv;\t/* Value of the biv.  */\n };\n \n static bool clean_slate = true;\n \n static unsigned int iv_ref_table_size = 0;\n \n /* Table of rtx_ivs indexed by the df_ref uid field.  */\n-static struct rtx_iv ** iv_ref_table;\n+static class rtx_iv ** iv_ref_table;\n \n /* Induction variable stored at the reference.  */\n #define DF_REF_IV(REF) iv_ref_table[DF_REF_ID (REF)]\n #define DF_REF_IV_SET(REF, IV) iv_ref_table[DF_REF_ID (REF)] = (IV)\n \n /* The current loop.  */\n \n-static struct loop *current_loop;\n+static class loop *current_loop;\n \n /* Hashtable helper.  */\n \n@@ -136,7 +136,7 @@ biv_entry_hasher::equal (const biv_entry *b, const rtx_def *r)\n \n static hash_table<biv_entry_hasher> *bivs;\n \n-static bool iv_analyze_op (rtx_insn *, scalar_int_mode, rtx, struct rtx_iv *);\n+static bool iv_analyze_op (rtx_insn *, scalar_int_mode, rtx, class rtx_iv *);\n \n /* Return the RTX code corresponding to the IV extend code EXTEND.  */\n static inline enum rtx_code\n@@ -156,9 +156,9 @@ iv_extend_to_rtx_code (enum iv_extend_code extend)\n \n /* Dumps information about IV to FILE.  */\n \n-extern void dump_iv_info (FILE *, struct rtx_iv *);\n+extern void dump_iv_info (FILE *, class rtx_iv *);\n void\n-dump_iv_info (FILE *file, struct rtx_iv *iv)\n+dump_iv_info (FILE *file, class rtx_iv *iv)\n {\n   if (!iv->base)\n     {\n@@ -204,9 +204,9 @@ check_iv_ref_table_size (void)\n   if (iv_ref_table_size < DF_DEFS_TABLE_SIZE ())\n     {\n       unsigned int new_size = DF_DEFS_TABLE_SIZE () + (DF_DEFS_TABLE_SIZE () / 4);\n-      iv_ref_table = XRESIZEVEC (struct rtx_iv *, iv_ref_table, new_size);\n+      iv_ref_table = XRESIZEVEC (class rtx_iv *, iv_ref_table, new_size);\n       memset (&iv_ref_table[iv_ref_table_size], 0,\n-\t      (new_size - iv_ref_table_size) * sizeof (struct rtx_iv *));\n+\t      (new_size - iv_ref_table_size) * sizeof (class rtx_iv *));\n       iv_ref_table_size = new_size;\n     }\n }\n@@ -245,7 +245,7 @@ static void\n clear_iv_info (void)\n {\n   unsigned i, n_defs = DF_DEFS_TABLE_SIZE ();\n-  struct rtx_iv *iv;\n+  class rtx_iv *iv;\n \n   check_iv_ref_table_size ();\n   for (i = 0; i < n_defs; i++)\n@@ -265,7 +265,7 @@ clear_iv_info (void)\n /* Prepare the data for an induction variable analysis of a LOOP.  */\n \n void\n-iv_analysis_loop_init (struct loop *loop)\n+iv_analysis_loop_init (class loop *loop)\n {\n   current_loop = loop;\n \n@@ -303,7 +303,7 @@ latch_dominating_def (rtx reg, df_ref *def)\n {\n   df_ref single_rd = NULL, adef;\n   unsigned regno = REGNO (reg);\n-  struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (current_loop->latch);\n+  class df_rd_bb_info *bb_info = DF_RD_BB_INFO (current_loop->latch);\n \n   for (adef = DF_REG_DEF_CHAIN (regno); adef; adef = DF_REF_NEXT_REG (adef))\n     {\n@@ -386,7 +386,7 @@ iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n    consistency with other iv manipulation functions that may fail).  */\n \n static bool\n-iv_constant (struct rtx_iv *iv, scalar_int_mode mode, rtx cst)\n+iv_constant (class rtx_iv *iv, scalar_int_mode mode, rtx cst)\n {\n   iv->mode = mode;\n   iv->base = cst;\n@@ -403,7 +403,7 @@ iv_constant (struct rtx_iv *iv, scalar_int_mode mode, rtx cst)\n /* Evaluates application of subreg to MODE on IV.  */\n \n static bool\n-iv_subreg (struct rtx_iv *iv, scalar_int_mode mode)\n+iv_subreg (class rtx_iv *iv, scalar_int_mode mode)\n {\n   /* If iv is invariant, just calculate the new value.  */\n   if (iv->step == const0_rtx\n@@ -445,7 +445,7 @@ iv_subreg (struct rtx_iv *iv, scalar_int_mode mode)\n /* Evaluates application of EXTEND to MODE on IV.  */\n \n static bool\n-iv_extend (struct rtx_iv *iv, enum iv_extend_code extend, scalar_int_mode mode)\n+iv_extend (class rtx_iv *iv, enum iv_extend_code extend, scalar_int_mode mode)\n {\n   /* If iv is invariant, just calculate the new value.  */\n   if (iv->step == const0_rtx\n@@ -483,7 +483,7 @@ iv_extend (struct rtx_iv *iv, enum iv_extend_code extend, scalar_int_mode mode)\n /* Evaluates negation of IV.  */\n \n static bool\n-iv_neg (struct rtx_iv *iv)\n+iv_neg (class rtx_iv *iv)\n {\n   if (iv->extend == IV_UNKNOWN_EXTEND)\n     {\n@@ -506,7 +506,7 @@ iv_neg (struct rtx_iv *iv)\n /* Evaluates addition or subtraction (according to OP) of IV1 to IV0.  */\n \n static bool\n-iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n+iv_add (class rtx_iv *iv0, class rtx_iv *iv1, enum rtx_code op)\n {\n   scalar_int_mode mode;\n   rtx arg;\n@@ -576,7 +576,7 @@ iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n /* Evaluates multiplication of IV by constant CST.  */\n \n static bool\n-iv_mult (struct rtx_iv *iv, rtx mby)\n+iv_mult (class rtx_iv *iv, rtx mby)\n {\n   scalar_int_mode mode = iv->extend_mode;\n \n@@ -601,7 +601,7 @@ iv_mult (struct rtx_iv *iv, rtx mby)\n /* Evaluates shift of IV by constant CST.  */\n \n static bool\n-iv_shift (struct rtx_iv *iv, rtx mby)\n+iv_shift (class rtx_iv *iv, rtx mby)\n {\n   scalar_int_mode mode = iv->extend_mode;\n \n@@ -811,9 +811,9 @@ get_biv_step (df_ref last_def, scalar_int_mode outer_mode, rtx reg,\n /* Records information that DEF is induction variable IV.  */\n \n static void\n-record_iv (df_ref def, struct rtx_iv *iv)\n+record_iv (df_ref def, class rtx_iv *iv)\n {\n-  struct rtx_iv *recorded_iv = XNEW (struct rtx_iv);\n+  class rtx_iv *recorded_iv = XNEW (class rtx_iv);\n \n   *recorded_iv = *iv;\n   check_iv_ref_table_size ();\n@@ -824,9 +824,9 @@ record_iv (df_ref def, struct rtx_iv *iv)\n    IV and return true.  Otherwise return false.  */\n \n static bool\n-analyzed_for_bivness_p (rtx def, struct rtx_iv *iv)\n+analyzed_for_bivness_p (rtx def, class rtx_iv *iv)\n {\n-  struct biv_entry *biv = bivs->find_with_hash (def, REGNO (def));\n+  class biv_entry *biv = bivs->find_with_hash (def, REGNO (def));\n \n   if (!biv)\n     return false;\n@@ -836,9 +836,9 @@ analyzed_for_bivness_p (rtx def, struct rtx_iv *iv)\n }\n \n static void\n-record_biv (rtx def, struct rtx_iv *iv)\n+record_biv (rtx def, class rtx_iv *iv)\n {\n-  struct biv_entry *biv = XNEW (struct biv_entry);\n+  class biv_entry *biv = XNEW (class biv_entry);\n   biv_entry **slot = bivs->find_slot_with_hash (def, REGNO (def), INSERT);\n \n   biv->regno = REGNO (def);\n@@ -851,7 +851,7 @@ record_biv (rtx def, struct rtx_iv *iv)\n    to *IV.  OUTER_MODE is the mode of DEF.  */\n \n static bool\n-iv_analyze_biv (scalar_int_mode outer_mode, rtx def, struct rtx_iv *iv)\n+iv_analyze_biv (scalar_int_mode outer_mode, rtx def, class rtx_iv *iv)\n {\n   rtx inner_step, outer_step;\n   scalar_int_mode inner_mode;\n@@ -929,11 +929,11 @@ iv_analyze_biv (scalar_int_mode outer_mode, rtx def, struct rtx_iv *iv)\n \n bool\n iv_analyze_expr (rtx_insn *insn, scalar_int_mode mode, rtx rhs,\n-\t\t struct rtx_iv *iv)\n+\t\t class rtx_iv *iv)\n {\n   rtx mby = NULL_RTX;\n   rtx op0 = NULL_RTX, op1 = NULL_RTX;\n-  struct rtx_iv iv0, iv1;\n+  class rtx_iv iv0, iv1;\n   enum rtx_code code = GET_CODE (rhs);\n   scalar_int_mode omode = mode;\n \n@@ -1040,7 +1040,7 @@ iv_analyze_expr (rtx_insn *insn, scalar_int_mode mode, rtx rhs,\n /* Analyzes iv DEF and stores the result to *IV.  */\n \n static bool\n-iv_analyze_def (df_ref def, struct rtx_iv *iv)\n+iv_analyze_def (df_ref def, class rtx_iv *iv)\n {\n   rtx_insn *insn = DF_REF_INSN (def);\n   rtx reg = DF_REF_REG (def);\n@@ -1104,7 +1104,7 @@ iv_analyze_def (df_ref def, struct rtx_iv *iv)\n    mode of OP.  */\n \n static bool\n-iv_analyze_op (rtx_insn *insn, scalar_int_mode mode, rtx op, struct rtx_iv *iv)\n+iv_analyze_op (rtx_insn *insn, scalar_int_mode mode, rtx op, class rtx_iv *iv)\n {\n   df_ref def = NULL;\n   enum iv_grd_result res;\n@@ -1165,7 +1165,7 @@ iv_analyze_op (rtx_insn *insn, scalar_int_mode mode, rtx op, struct rtx_iv *iv)\n    mode of VAL.  */\n \n bool\n-iv_analyze (rtx_insn *insn, scalar_int_mode mode, rtx val, struct rtx_iv *iv)\n+iv_analyze (rtx_insn *insn, scalar_int_mode mode, rtx val, class rtx_iv *iv)\n {\n   rtx reg;\n \n@@ -1190,7 +1190,7 @@ iv_analyze (rtx_insn *insn, scalar_int_mode mode, rtx val, struct rtx_iv *iv)\n /* Analyzes definition of DEF in INSN and stores the result to IV.  */\n \n bool\n-iv_analyze_result (rtx_insn *insn, rtx def, struct rtx_iv *iv)\n+iv_analyze_result (rtx_insn *insn, rtx def, class rtx_iv *iv)\n {\n   df_ref adef;\n \n@@ -1210,7 +1210,7 @@ iv_analyze_result (rtx_insn *insn, rtx def, struct rtx_iv *iv)\n bool\n biv_p (rtx_insn *insn, scalar_int_mode mode, rtx reg)\n {\n-  struct rtx_iv iv;\n+  class rtx_iv iv;\n   df_ref def, last_def;\n \n   if (!simple_reg_p (reg))\n@@ -1232,7 +1232,7 @@ biv_p (rtx_insn *insn, scalar_int_mode mode, rtx reg)\n /* Calculates value of IV at ITERATION-th iteration.  */\n \n rtx\n-get_iv_value (struct rtx_iv *iv, rtx iteration)\n+get_iv_value (class rtx_iv *iv, rtx iteration)\n {\n   rtx val;\n \n@@ -1851,7 +1851,7 @@ eliminate_implied_conditions (enum rtx_code op, rtx *head, rtx tail)\n    is a list, its elements are assumed to be combined using OP.  */\n \n static void\n-simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n+simplify_using_initial_values (class loop *loop, enum rtx_code op, rtx *expr)\n {\n   bool expression_valid;\n   rtx head, tail, last_valid_expr;\n@@ -2072,8 +2072,8 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n    is SIGNED_P to DESC.  */\n \n static void\n-shorten_into_mode (struct rtx_iv *iv, scalar_int_mode mode,\n-\t\t   enum rtx_code cond, bool signed_p, struct niter_desc *desc)\n+shorten_into_mode (class rtx_iv *iv, scalar_int_mode mode,\n+\t\t   enum rtx_code cond, bool signed_p, class niter_desc *desc)\n {\n   rtx mmin, mmax, cond_over, cond_under;\n \n@@ -2131,8 +2131,8 @@ shorten_into_mode (struct rtx_iv *iv, scalar_int_mode mode,\n    some assumptions to DESC).  */\n \n static bool\n-canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n-\t\t\t enum rtx_code cond, struct niter_desc *desc)\n+canonicalize_iv_subregs (class rtx_iv *iv0, class rtx_iv *iv1,\n+\t\t\t enum rtx_code cond, class niter_desc *desc)\n {\n   scalar_int_mode comp_mode;\n   bool signed_p;\n@@ -2247,7 +2247,7 @@ canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n    expression for the number of iterations, before we tried to simplify it.  */\n \n static uint64_t\n-determine_max_iter (struct loop *loop, struct niter_desc *desc, rtx old_niter)\n+determine_max_iter (class loop *loop, class niter_desc *desc, rtx old_niter)\n {\n   rtx niter = desc->niter_expr;\n   rtx mmin, mmax, cmp;\n@@ -2305,11 +2305,11 @@ determine_max_iter (struct loop *loop, struct niter_desc *desc, rtx old_niter)\n    (basically its rtl version), complicated by things like subregs.  */\n \n static void\n-iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n-\t\t\t struct niter_desc *desc)\n+iv_number_of_iterations (class loop *loop, rtx_insn *insn, rtx condition,\n+\t\t\t class niter_desc *desc)\n {\n   rtx op0, op1, delta, step, bound, may_xform, tmp, tmp0, tmp1;\n-  struct rtx_iv iv0, iv1;\n+  class rtx_iv iv0, iv1;\n   rtx assumption, may_not_xform;\n   enum rtx_code cond;\n   machine_mode nonvoid_mode;\n@@ -2867,7 +2867,7 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n    into DESC.  */\n \n static void\n-check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n+check_simple_exit (class loop *loop, edge e, class niter_desc *desc)\n {\n   basic_block exit_bb;\n   rtx condition;\n@@ -2915,12 +2915,12 @@ check_simple_exit (struct loop *loop, edge e, struct niter_desc *desc)\n /* Finds a simple exit of LOOP and stores its description into DESC.  */\n \n void\n-find_simple_exit (struct loop *loop, struct niter_desc *desc)\n+find_simple_exit (class loop *loop, class niter_desc *desc)\n {\n   unsigned i;\n   basic_block *body;\n   edge e;\n-  struct niter_desc act;\n+  class niter_desc act;\n   bool any = false;\n   edge_iterator ei;\n \n@@ -3018,10 +3018,10 @@ find_simple_exit (struct loop *loop, struct niter_desc *desc)\n /* Creates a simple loop description of LOOP if it was not computed\n    already.  */\n \n-struct niter_desc *\n-get_simple_loop_desc (struct loop *loop)\n+class niter_desc *\n+get_simple_loop_desc (class loop *loop)\n {\n-  struct niter_desc *desc = simple_loop_desc (loop);\n+  class niter_desc *desc = simple_loop_desc (loop);\n \n   if (desc)\n     return desc;\n@@ -3038,9 +3038,9 @@ get_simple_loop_desc (struct loop *loop)\n /* Releases simple loop description for LOOP.  */\n \n void\n-free_simple_loop_desc (struct loop *loop)\n+free_simple_loop_desc (class loop *loop)\n {\n-  struct niter_desc *desc = simple_loop_desc (loop);\n+  class niter_desc *desc = simple_loop_desc (loop);\n \n   if (!desc)\n     return;"}, {"sha": "63fccd23fae38f8918a7d94411aaa43c72830dd3", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -163,19 +163,19 @@ struct opt_info\n   basic_block loop_preheader;      /* The loop preheader basic block.  */\n };\n \n-static void decide_unroll_stupid (struct loop *, int);\n-static void decide_unroll_constant_iterations (struct loop *, int);\n-static void decide_unroll_runtime_iterations (struct loop *, int);\n-static void unroll_loop_stupid (struct loop *);\n+static void decide_unroll_stupid (class loop *, int);\n+static void decide_unroll_constant_iterations (class loop *, int);\n+static void decide_unroll_runtime_iterations (class loop *, int);\n+static void unroll_loop_stupid (class loop *);\n static void decide_unrolling (int);\n-static void unroll_loop_constant_iterations (struct loop *);\n-static void unroll_loop_runtime_iterations (struct loop *);\n-static struct opt_info *analyze_insns_in_loop (struct loop *);\n+static void unroll_loop_constant_iterations (class loop *);\n+static void unroll_loop_runtime_iterations (class loop *);\n+static struct opt_info *analyze_insns_in_loop (class loop *);\n static void opt_info_start_duplication (struct opt_info *);\n static void apply_opt_in_copies (struct opt_info *, unsigned, bool, bool);\n static void free_opt_info (struct opt_info *);\n-static struct var_to_expand *analyze_insn_to_expand_var (struct loop*, rtx_insn *);\n-static bool referenced_in_one_insn_in_loop_p (struct loop *, rtx, int *);\n+static struct var_to_expand *analyze_insn_to_expand_var (class loop*, rtx_insn *);\n+static bool referenced_in_one_insn_in_loop_p (class loop *, rtx, int *);\n static struct iv_to_split *analyze_iv_to_split_insn (rtx_insn *);\n static void expand_var_during_unrolling (struct var_to_expand *, rtx_insn *);\n static void insert_var_expansion_initialization (struct var_to_expand *,\n@@ -189,7 +189,7 @@ static rtx get_expansion (struct var_to_expand *);\n    appropriate given the dump or -fopt-info settings.  */\n \n static void\n-report_unroll (struct loop *loop, dump_location_t locus)\n+report_unroll (class loop *loop, dump_location_t locus)\n {\n   dump_flags_t report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS;\n \n@@ -215,7 +215,7 @@ report_unroll (struct loop *loop, dump_location_t locus)\n static void\n decide_unrolling (int flags)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   /* Scan the loops, inner ones first.  */\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n@@ -279,7 +279,7 @@ decide_unrolling (int flags)\n void\n unroll_loops (int flags)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool changed = false;\n \n   /* Now decide rest of unrolling.  */\n@@ -322,9 +322,9 @@ unroll_loops (int flags)\n /* Check whether exit of the LOOP is at the end of loop body.  */\n \n static bool\n-loop_exit_at_end_p (struct loop *loop)\n+loop_exit_at_end_p (class loop *loop)\n {\n-  struct niter_desc *desc = get_simple_loop_desc (loop);\n+  class niter_desc *desc = get_simple_loop_desc (loop);\n   rtx_insn *insn;\n \n   /* We should never have conditional in latch block.  */\n@@ -347,10 +347,10 @@ loop_exit_at_end_p (struct loop *loop)\n    and how much.  */\n \n static void\n-decide_unroll_constant_iterations (struct loop *loop, int flags)\n+decide_unroll_constant_iterations (class loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, best_copies, best_unroll = 0, n_copies, i;\n-  struct niter_desc *desc;\n+  class niter_desc *desc;\n   widest_int iterations;\n \n   /* If we were not asked to unroll this loop, just return back silently.  */\n@@ -480,14 +480,14 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)\n      }\n   */\n static void\n-unroll_loop_constant_iterations (struct loop *loop)\n+unroll_loop_constant_iterations (class loop *loop)\n {\n   unsigned HOST_WIDE_INT niter;\n   unsigned exit_mod;\n   unsigned i;\n   edge e;\n   unsigned max_unroll = loop->lpt_decision.times;\n-  struct niter_desc *desc = get_simple_loop_desc (loop);\n+  class niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n   struct opt_info *opt_info = NULL;\n   bool ok;\n@@ -667,10 +667,10 @@ unroll_loop_constant_iterations (struct loop *loop)\n /* Decide whether to unroll LOOP iterating runtime computable number of times\n    and how much.  */\n static void\n-decide_unroll_runtime_iterations (struct loop *loop, int flags)\n+decide_unroll_runtime_iterations (class loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n-  struct niter_desc *desc;\n+  class niter_desc *desc;\n   widest_int iterations;\n \n   /* If we were not asked to unroll this loop, just return back silently.  */\n@@ -881,7 +881,7 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp,\n      }\n    */\n static void\n-unroll_loop_runtime_iterations (struct loop *loop)\n+unroll_loop_runtime_iterations (class loop *loop)\n {\n   rtx old_niter, niter, tmp;\n   rtx_insn *init_code, *branch_code;\n@@ -894,7 +894,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   edge e;\n   bool extra_zero_check, last_may_exit;\n   unsigned max_unroll = loop->lpt_decision.times;\n-  struct niter_desc *desc = get_simple_loop_desc (loop);\n+  class niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n   struct opt_info *opt_info = NULL;\n   bool ok;\n@@ -1152,10 +1152,10 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \n /* Decide whether to unroll LOOP stupidly and how much.  */\n static void\n-decide_unroll_stupid (struct loop *loop, int flags)\n+decide_unroll_stupid (class loop *loop, int flags)\n {\n   unsigned nunroll, nunroll_by_av, i;\n-  struct niter_desc *desc;\n+  class niter_desc *desc;\n   widest_int iterations;\n \n   /* If we were not asked to unroll this loop, just return back silently.  */\n@@ -1250,10 +1250,10 @@ decide_unroll_stupid (struct loop *loop, int flags)\n      }\n    */\n static void\n-unroll_loop_stupid (struct loop *loop)\n+unroll_loop_stupid (class loop *loop)\n {\n   unsigned nunroll = loop->lpt_decision.times;\n-  struct niter_desc *desc = get_simple_loop_desc (loop);\n+  class niter_desc *desc = get_simple_loop_desc (loop);\n   struct opt_info *opt_info = NULL;\n   bool ok;\n \n@@ -1301,7 +1301,7 @@ unroll_loop_stupid (struct loop *loop)\n    variable.  */\n \n static bool\n-referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg,\n+referenced_in_one_insn_in_loop_p (class loop *loop, rtx reg,\n \t\t\t\t  int *debug_uses)\n {\n   basic_block *body, bb;\n@@ -1329,7 +1329,7 @@ referenced_in_one_insn_in_loop_p (struct loop *loop, rtx reg,\n /* Reset the DEBUG_USES debug insns in LOOP that reference REG.  */\n \n static void\n-reset_debug_uses_in_loop (struct loop *loop, rtx reg, int debug_uses)\n+reset_debug_uses_in_loop (class loop *loop, rtx reg, int debug_uses)\n {\n   basic_block *body, bb;\n   unsigned i;\n@@ -1378,7 +1378,7 @@ reset_debug_uses_in_loop (struct loop *loop, rtx reg, int debug_uses)\n */\n \n static struct var_to_expand *\n-analyze_insn_to_expand_var (struct loop *loop, rtx_insn *insn)\n+analyze_insn_to_expand_var (class loop *loop, rtx_insn *insn)\n {\n   rtx set, dest, src;\n   struct var_to_expand *ves;\n@@ -1519,7 +1519,7 @@ static struct iv_to_split *\n analyze_iv_to_split_insn (rtx_insn *insn)\n {\n   rtx set, dest;\n-  struct rtx_iv iv;\n+  class rtx_iv iv;\n   struct iv_to_split *ivts;\n   scalar_int_mode mode;\n   bool ok;\n@@ -1571,7 +1571,7 @@ analyze_iv_to_split_insn (rtx_insn *insn)\n    is undefined for the return value.  */\n \n static struct opt_info *\n-analyze_insns_in_loop (struct loop *loop)\n+analyze_insns_in_loop (class loop *loop)\n {\n   basic_block *body, bb;\n   unsigned i;"}, {"sha": "943da8888485fabafbb65af2b05bfc50e02ba9b6", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -100,7 +100,7 @@ class lra_elim_table\n    of eliminating a register in favor of another.  If there is more\n    than one way of eliminating a particular register, the most\n    preferred should be specified first.\t */\n-static struct lra_elim_table *reg_eliminate = 0;\n+static class lra_elim_table *reg_eliminate = 0;\n \n /* This is an intermediate structure to initialize the table.  It has\n    exactly the members provided by ELIMINABLE_REGS.  */\n@@ -118,7 +118,7 @@ static const struct elim_table_1\n static void\n print_elim_table (FILE *f)\n {\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n \n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n@@ -142,7 +142,7 @@ lra_debug_elim_table (void)\n    VALUE.  Setup FRAME_POINTER_NEEDED if elimination from frame\n    pointer to stack pointer is not possible anymore.  */\n static void\n-setup_can_eliminate (struct lra_elim_table *ep, bool value)\n+setup_can_eliminate (class lra_elim_table *ep, bool value)\n {\n   ep->can_eliminate = ep->prev_can_eliminate = value;\n   if (! value\n@@ -156,12 +156,12 @@ setup_can_eliminate (struct lra_elim_table *ep, bool value)\n    or NULL if none.  The elimination table may contain more than\n    one elimination for the same hard register, but this map specifies\n    the one that we are currently using.  */\n-static struct lra_elim_table *elimination_map[FIRST_PSEUDO_REGISTER];\n+static class lra_elim_table *elimination_map[FIRST_PSEUDO_REGISTER];\n \n /* When an eliminable hard register becomes not eliminable, we use the\n    following special structure to restore original offsets for the\n    register.  */\n-static struct lra_elim_table self_elim_table;\n+static class lra_elim_table self_elim_table;\n \n /* Offsets should be used to restore original offsets for eliminable\n    hard register which just became not eliminable.  Zero,\n@@ -177,7 +177,7 @@ static void\n setup_elimination_map (void)\n {\n   int i;\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     elimination_map[i] = NULL;\n@@ -242,7 +242,7 @@ form_sum (rtx x, rtx y)\n int\n lra_get_elimination_hard_regno (int hard_regno)\n {\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n \n   if (hard_regno < 0 || hard_regno >= FIRST_PSEUDO_REGISTER)\n     return hard_regno;\n@@ -253,11 +253,11 @@ lra_get_elimination_hard_regno (int hard_regno)\n \n /* Return elimination which will be used for hard reg REG, NULL\n    otherwise.  */\n-static struct lra_elim_table *\n+static class lra_elim_table *\n get_elimination (rtx reg)\n {\n   int hard_regno;\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n \n   lra_assert (REG_P (reg));\n   if ((hard_regno = REGNO (reg)) < 0 || hard_regno >= FIRST_PSEUDO_REGISTER)\n@@ -334,7 +334,7 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t\t      poly_int64 update_sp_offset, bool full_p)\n {\n   enum rtx_code code = GET_CODE (x);\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n   rtx new_rtx;\n   int i, j;\n   const char *fmt;\n@@ -731,7 +731,7 @@ static void\n mark_not_eliminable (rtx x, machine_mode mem_mode)\n {\n   enum rtx_code code = GET_CODE (x);\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n   int i, j;\n   const char *fmt;\n   poly_int64 offset = 0;\n@@ -901,7 +901,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n   int i;\n   rtx substed_operand[MAX_RECOG_OPERANDS];\n   rtx orig_operand[MAX_RECOG_OPERANDS];\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n   rtx plus_src, plus_cst_src;\n   lra_insn_recog_data_t id;\n   struct lra_static_insn_data *static_id;\n@@ -1109,7 +1109,7 @@ static bool\n update_reg_eliminate (bitmap insns_with_changed_offsets)\n {\n   bool prev, result;\n-  struct lra_elim_table *ep, *ep1;\n+  class lra_elim_table *ep, *ep1;\n   HARD_REG_SET temp_hard_reg_set;\n \n   targetm.compute_frame_layout ();\n@@ -1214,12 +1214,12 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n static void\n init_elim_table (void)\n {\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n   bool value_p;\n   const struct elim_table_1 *ep1;\n \n   if (!reg_eliminate)\n-    reg_eliminate = XCNEWVEC (struct lra_elim_table, NUM_ELIMINABLE_REGS);\n+    reg_eliminate = XCNEWVEC (class lra_elim_table, NUM_ELIMINABLE_REGS);\n \n   memset (self_elim_offsets, 0, sizeof (self_elim_offsets));\n   /* Initiate member values which will be never changed.  */\n@@ -1262,7 +1262,7 @@ init_elimination (void)\n   bool stop_to_sp_elimination_p;\n   basic_block bb;\n   rtx_insn *insn;\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n \n   init_elim_table ();\n   FOR_EACH_BB_FN (bb, cfun)\n@@ -1296,7 +1296,7 @@ void\n lra_eliminate_reg_if_possible (rtx *loc)\n {\n   int regno;\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n \n   lra_assert (REG_P (*loc));\n   if ((regno = REGNO (*loc)) >= FIRST_PSEUDO_REGISTER\n@@ -1340,7 +1340,7 @@ lra_eliminate (bool final_p, bool first_p)\n   unsigned int uid;\n   bitmap_head insns_with_changed_offsets;\n   bitmap_iterator bi;\n-  struct lra_elim_table *ep;\n+  class lra_elim_table *ep;\n \n   gcc_assert (! final_p || ! first_p);\n "}, {"sha": "f8db969122aecb8764af5f48cbf4d6a994e6f8e4", "filename": "gcc/lra-int.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -119,7 +119,7 @@ class lra_reg\n };\n \n /* References to the common info about each register.  */\n-extern struct lra_reg *lra_reg_info;\n+extern class lra_reg *lra_reg_info;\n \n extern HARD_REG_SET hard_regs_spilled_into;\n \n@@ -244,7 +244,7 @@ class lra_insn_recog_data\n   struct lra_insn_reg *regs;\n };\n \n-typedef struct lra_insn_recog_data *lra_insn_recog_data_t;\n+typedef class lra_insn_recog_data *lra_insn_recog_data_t;\n \n /* Whether the clobber is used temporary in LRA.  */\n #define LRA_TEMP_CLOBBER_P(x) \\"}, {"sha": "96aa7c4717b5b77687a98090134c35a110933ff7", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -394,7 +394,7 @@ class bb_data_pseudos\n };\n \n /* Array for all BB data.  Indexed by the corresponding BB index.  */\n-typedef struct bb_data_pseudos *bb_data_t;\n+typedef class bb_data_pseudos *bb_data_t;\n \n /* All basic block data are referred through the following array.  */\n static bb_data_t bb_data;\n@@ -470,7 +470,7 @@ initiate_live_solver (void)\n {\n   bitmap_initialize (&all_hard_regs_bitmap, &reg_obstack);\n   bitmap_set_range (&all_hard_regs_bitmap, 0, FIRST_PSEUDO_REGISTER);\n-  bb_data = XNEWVEC (struct bb_data_pseudos, last_basic_block_for_fn (cfun));\n+  bb_data = XNEWVEC (class bb_data_pseudos, last_basic_block_for_fn (cfun));\n   bitmap_initialize (&all_blocks, &reg_obstack);\n \n   basic_block bb;"}, {"sha": "6a5bf4f3f68c25726ad99841bd9a4239ba1d7efd", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -145,7 +145,7 @@ class remat_bb_data\n };\n \n /* Array for all BB data.  Indexed by the corresponding BB index.  */\n-typedef struct remat_bb_data *remat_bb_data_t;\n+typedef class remat_bb_data *remat_bb_data_t;\n \n /* Basic blocks for data flow problems -- all bocks except the special\n    ones.  */\n@@ -510,7 +510,7 @@ create_remat_bb_data (void)\n   basic_block bb;\n   remat_bb_data_t bb_info;\n \n-  remat_bb_data = XNEWVEC (struct remat_bb_data,\n+  remat_bb_data = XNEWVEC (class remat_bb_data,\n \t\t\t   last_basic_block_for_fn (cfun));\n   FOR_ALL_BB_FN (bb, cfun)\n     {"}, {"sha": "c73d50131675c96d739ff9262c744be2c2ef58b2", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -122,7 +122,7 @@ class slot\n \n /* Array containing info about the stack slots.\t The array element is\n    indexed by the stack slot number in the range [0..slots_num).  */\n-static struct slot *slots;\n+static class slot *slots;\n /* The number of the stack slots currently existing.  */\n static int slots_num;\n \n@@ -587,7 +587,7 @@ lra_spill (void)\n       spill_hard_reg[i] = NULL_RTX;\n       pseudo_slots[i].mem = NULL_RTX;\n     }\n-  slots = XNEWVEC (struct slot, regs_num);\n+  slots = XNEWVEC (class slot, regs_num);\n   /* Sort regnos according their usage frequencies.  */\n   qsort (pseudo_regnos, n, sizeof (int), regno_freq_compare);\n   n = assign_spill_hard_regs (pseudo_regnos, n);"}, {"sha": "af40f43f835ce31d0d241714ca7e3479e8662dc2", "filename": "gcc/lra.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -972,7 +972,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n \t/* It might be a new simple insn which is not recognized yet.  */\n \tINSN_CODE (insn) = icode = recog_memoized (insn);\n     }\n-  data = XNEW (struct lra_insn_recog_data);\n+  data = XNEW (class lra_insn_recog_data);\n   lra_insn_recog_data[uid] = data;\n   data->insn = insn;\n   data->used_insn_alternative = LRA_UNKNOWN_ALT;\n@@ -1306,7 +1306,7 @@ lra_set_used_insn_alternative_by_uid (int uid, int alt)\n /* The size of the following array.  */\n static int reg_info_size;\n /* Common info about each register.  */\n-struct lra_reg *lra_reg_info;\n+class lra_reg *lra_reg_info;\n \n HARD_REG_SET hard_regs_spilled_into;\n \n@@ -1356,7 +1356,7 @@ init_reg_info (void)\n \n   last_reg_value = 0;\n   reg_info_size = max_reg_num () * 3 / 2 + 1;\n-  lra_reg_info = XNEWVEC (struct lra_reg, reg_info_size);\n+  lra_reg_info = XNEWVEC (class lra_reg, reg_info_size);\n   for (i = 0; i < reg_info_size; i++)\n     initialize_lra_reg_info_element (i);\n   copy_vec.truncate (0);\n@@ -1385,7 +1385,7 @@ expand_reg_info (void)\n   if (reg_info_size > max_reg_num ())\n     return;\n   reg_info_size = max_reg_num () * 3 / 2 + 1;\n-  lra_reg_info = XRESIZEVEC (struct lra_reg, lra_reg_info, reg_info_size);\n+  lra_reg_info = XRESIZEVEC (class lra_reg, lra_reg_info, reg_info_size);\n   for (i = old; i < reg_info_size; i++)\n     initialize_lra_reg_info_element (i);\n }"}, {"sha": "bc0f0107333e201c78135e1b328e65dac2d690a4", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1012,7 +1012,7 @@ output_symtab (void)\n /* Return identifier encoded in IB as a plain string.  */\n \n static tree\n-read_identifier (struct lto_input_block *ib)\n+read_identifier (class lto_input_block *ib)\n {\n   unsigned int len = strnlen (ib->data + ib->p, ib->len - ib->p - 1);\n   tree id;\n@@ -1032,7 +1032,7 @@ read_identifier (struct lto_input_block *ib)\n /* Return string encoded in IB, NULL if string is empty.  */\n \n static const char *\n-read_string (struct lto_input_block *ib)\n+read_string (class lto_input_block *ib)\n {\n   unsigned int len = strnlen (ib->data + ib->p, ib->len - ib->p - 1);\n   const char *str;\n@@ -1203,7 +1203,7 @@ get_alias_symbol (tree decl)\n \n static struct cgraph_node *\n input_node (struct lto_file_decl_data *file_data,\n-\t    struct lto_input_block *ib,\n+\t    class lto_input_block *ib,\n \t    enum LTO_symtab_tags tag,\n \t    vec<symtab_node *> nodes)\n {\n@@ -1326,7 +1326,7 @@ input_node (struct lto_file_decl_data *file_data,\n \n static varpool_node *\n input_varpool_node (struct lto_file_decl_data *file_data,\n-\t\t    struct lto_input_block *ib)\n+\t\t    class lto_input_block *ib)\n {\n   int decl_index;\n   tree var_decl;\n@@ -1402,7 +1402,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n    Return the node read or overwriten.  */\n \n static void\n-input_ref (struct lto_input_block *ib,\n+input_ref (class lto_input_block *ib,\n \t   symtab_node *referring_node,\n \t   vec<symtab_node *> nodes)\n {\n@@ -1428,7 +1428,7 @@ input_ref (struct lto_input_block *ib,\n    indirect_unknown_callee set).  */\n \n static void\n-input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n+input_edge (class lto_input_block *ib, vec<symtab_node *> nodes,\n \t    bool indirect)\n {\n   struct cgraph_node *caller, *callee;\n@@ -1496,7 +1496,7 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n \n static vec<symtab_node *> \n input_cgraph_1 (struct lto_file_decl_data *file_data,\n-\t\tstruct lto_input_block *ib)\n+\t\tclass lto_input_block *ib)\n {\n   enum LTO_symtab_tags tag;\n   vec<symtab_node *> nodes = vNULL;\n@@ -1573,7 +1573,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n /* Input ipa_refs.  */\n \n static void\n-input_refs (struct lto_input_block *ib,\n+input_refs (class lto_input_block *ib,\n \t    vec<symtab_node *> nodes)\n {\n   int count;\n@@ -1596,7 +1596,7 @@ input_refs (struct lto_input_block *ib,\n \t    \n /* Input profile_info from IB.  */\n static void\n-input_profile_summary (struct lto_input_block *ib,\n+input_profile_summary (class lto_input_block *ib,\n \t\t       struct lto_file_decl_data *file_data)\n {\n   unsigned int runs = streamer_read_uhwi (ib);\n@@ -1693,7 +1693,7 @@ input_symtab (void)\n     {\n       const char *data;\n       size_t len;\n-      struct lto_input_block *ib;\n+      class lto_input_block *ib;\n       vec<symtab_node *> nodes;\n \n       ib = lto_create_simple_input_block (file_data, LTO_section_symtab_nodes,\n@@ -1750,7 +1750,7 @@ input_offload_tables (bool do_force_output)\n     {\n       const char *data;\n       size_t len;\n-      struct lto_input_block *ib\n+      class lto_input_block *ib\n \t= lto_create_simple_input_block (file_data, LTO_section_offload_table,\n \t\t\t\t\t &data, &len);\n       if (!ib)\n@@ -1909,16 +1909,16 @@ output_cgraph_opt_summary (void)\n \n static void\n input_edge_opt_summary (struct cgraph_edge *edge ATTRIBUTE_UNUSED,\n-\t\t\tstruct lto_input_block *ib_main ATTRIBUTE_UNUSED)\n+\t\t\tclass lto_input_block *ib_main ATTRIBUTE_UNUSED)\n {\n }\n \n /* Input optimisation summary of NODE.  */\n \n static void\n input_node_opt_summary (struct cgraph_node *node,\n-\t\t\tstruct lto_input_block *ib_main,\n-\t\t\tstruct data_in *data_in)\n+\t\t\tclass lto_input_block *ib_main,\n+\t\t\tclass data_in *data_in)\n {\n   int i;\n   int count;\n@@ -1973,7 +1973,7 @@ input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n   const int cfg_offset = sizeof (struct lto_function_header);\n   const int main_offset = cfg_offset + header->cfg_size;\n   const int string_offset = main_offset + header->main_size;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   unsigned int i;\n   unsigned int count;\n "}, {"sha": "4c2870176ae5d6316bd26c8045d3623aad82e48d", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -228,7 +228,7 @@ lto_free_raw_section_data (struct lto_file_decl_data *file_data,\n    raw pointer to the section is returned in DATAR and LEN.  These are\n    used to free the section.  Return NULL if the section is not present.  */\n \n-struct lto_input_block *\n+class lto_input_block *\n lto_create_simple_input_block (struct lto_file_decl_data *file_data,\n \t\t\t       enum lto_section_type section_type,\n \t\t\t       const char **datar, size_t *len)\n@@ -257,7 +257,7 @@ lto_create_simple_input_block (struct lto_file_decl_data *file_data,\n void\n lto_destroy_simple_input_block (struct lto_file_decl_data *file_data,\n \t\t\t\tenum lto_section_type section_type,\n-\t\t\t\tstruct lto_input_block *ib,\n+\t\t\t\tclass lto_input_block *ib,\n \t\t\t\tconst char *data, size_t len)\n {\n   delete ib;\n@@ -437,7 +437,7 @@ lto_free_function_in_decl_state_for_node (symtab_node *node)\n /* Report read pass end of the section.  */\n \n void\n-lto_section_overrun (struct lto_input_block *ib)\n+lto_section_overrun (class lto_input_block *ib)\n {\n   fatal_error (input_location, \"bytecode stream: trying to read %d bytes \"\n \t       \"after the end of the input buffer\", ib->p - ib->len);"}, {"sha": "155805b3c433acd7a03aae76c3506bbc20f12f34", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -84,7 +84,7 @@ lto_tag_check_set (enum LTO_tags actual, int ntags, ...)\n /* Read LENGTH bytes from STREAM to ADDR.  */\n \n void\n-lto_input_data_block (struct lto_input_block *ib, void *addr, size_t length)\n+lto_input_data_block (class lto_input_block *ib, void *addr, size_t length)\n {\n   size_t i;\n   unsigned char *const buffer = (unsigned char *) addr;\n@@ -232,7 +232,7 @@ lto_location_cache::revert_location_cache ()\n \n void\n lto_location_cache::input_location (location_t *loc, struct bitpack_d *bp,\n-\t\t\t\t    struct data_in *data_in)\n+\t\t\t\t    class data_in *data_in)\n {\n   static const char *stream_file;\n   static int stream_line;\n@@ -287,7 +287,7 @@ lto_location_cache::input_location (location_t *loc, struct bitpack_d *bp,\n \n void\n lto_input_location (location_t *loc, struct bitpack_d *bp,\n-\t\t    struct data_in *data_in)\n+\t\t    class data_in *data_in)\n {\n   data_in->location_cache.input_location (loc, bp, data_in);\n }\n@@ -297,7 +297,7 @@ lto_input_location (location_t *loc, struct bitpack_d *bp,\n    discarded.  */\n \n location_t\n-stream_input_location_now (struct bitpack_d *bp, struct data_in *data_in)\n+stream_input_location_now (struct bitpack_d *bp, class data_in *data_in)\n {\n   location_t loc;\n   stream_input_location (&loc, bp, data_in);\n@@ -313,7 +313,7 @@ stream_input_location_now (struct bitpack_d *bp, struct data_in *data_in)\n    function scope for the read tree.  */\n \n tree\n-lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n+lto_input_tree_ref (class lto_input_block *ib, class data_in *data_in,\n \t\t    struct function *fn, enum LTO_tags tag)\n {\n   unsigned HOST_WIDE_INT ix_u;\n@@ -378,7 +378,7 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n    block IB, using descriptors in DATA_IN.  */\n \n static struct eh_catch_d *\n-lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n+lto_input_eh_catch_list (class lto_input_block *ib, class data_in *data_in,\n \t\t\t eh_catch *last_p)\n {\n   eh_catch first;\n@@ -424,7 +424,7 @@ lto_input_eh_catch_list (struct lto_input_block *ib, struct data_in *data_in,\n    in DATA_IN.  */\n \n static eh_region\n-input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n+input_eh_region (class lto_input_block *ib, class data_in *data_in, int ix)\n {\n   enum LTO_tags tag;\n   eh_region r;\n@@ -499,7 +499,7 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n    in DATA_IN.  */\n \n static eh_landing_pad\n-input_eh_lp (struct lto_input_block *ib, struct data_in *data_in, int ix)\n+input_eh_lp (class lto_input_block *ib, class data_in *data_in, int ix)\n {\n   enum LTO_tags tag;\n   eh_landing_pad lp;\n@@ -603,7 +603,7 @@ lto_init_eh (void)\n    in DATA_IN.  */\n \n static void\n-input_eh_regions (struct lto_input_block *ib, struct data_in *data_in,\n+input_eh_regions (class lto_input_block *ib, class data_in *data_in,\n \t\t  struct function *fn)\n {\n   HOST_WIDE_INT i, root_region, len;\n@@ -714,7 +714,7 @@ make_new_block (struct function *fn, unsigned int index)\n /* Read the CFG for function FN from input block IB.  */\n \n static void\n-input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n+input_cfg (class lto_input_block *ib, class data_in *data_in,\n \t   struct function *fn)\n {\n   unsigned int bb_count;\n@@ -807,7 +807,7 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n \t  continue;\n \t}\n \n-      struct loop *loop = alloc_loop ();\n+      class loop *loop = alloc_loop ();\n       loop->header = BASIC_BLOCK_FOR_FN (fn, header_index);\n       loop->header->loop_father = loop;\n \n@@ -847,7 +847,7 @@ input_cfg (struct lto_input_block *ib, struct data_in *data_in,\n    block IB.  */\n \n static void\n-input_ssa_names (struct lto_input_block *ib, struct data_in *data_in,\n+input_ssa_names (class lto_input_block *ib, class data_in *data_in,\n \t\t struct function *fn)\n {\n   unsigned int i, size;\n@@ -964,8 +964,8 @@ fixup_call_stmt_edges (struct cgraph_node *orig, gimple **stmts)\n    using input block IB.  */\n \n static void\n-input_struct_function_base (struct function *fn, struct data_in *data_in,\n-                            struct lto_input_block *ib)\n+input_struct_function_base (struct function *fn, class data_in *data_in,\n+\t                    class lto_input_block *ib)\n {\n   struct bitpack_d bp;\n   int len;\n@@ -1029,8 +1029,8 @@ input_struct_function_base (struct function *fn, struct data_in *data_in,\n /* Read the body of function FN_DECL from DATA_IN using input block IB.  */\n \n static void\n-input_function (tree fn_decl, struct data_in *data_in,\n-\t\tstruct lto_input_block *ib, struct lto_input_block *ib_cfg)\n+input_function (tree fn_decl, class data_in *data_in,\n+\t\tclass lto_input_block *ib, class lto_input_block *ib_cfg)\n {\n   struct function *fn;\n   enum LTO_tags tag;\n@@ -1233,8 +1233,8 @@ input_function (tree fn_decl, struct data_in *data_in,\n /* Read the body of function FN_DECL from DATA_IN using input block IB.  */\n \n static void\n-input_constructor (tree var, struct data_in *data_in,\n-\t\t   struct lto_input_block *ib)\n+input_constructor (tree var, class data_in *data_in,\n+\t\t   class lto_input_block *ib)\n {\n   DECL_INITIAL (var) = stream_read_tree (ib, data_in);\n }\n@@ -1251,7 +1251,7 @@ lto_read_body_or_constructor (struct lto_file_decl_data *file_data, struct symta\n \t\t\t      const char *data, enum lto_section_type section_type)\n {\n   const struct lto_function_header *header;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   int cfg_offset;\n   int main_offset;\n   int string_offset;\n@@ -1364,7 +1364,7 @@ vec<dref_entry> dref_queue;\n    input block IB using the per-file context in DATA_IN.  */\n \n static void\n-lto_read_tree_1 (struct lto_input_block *ib, struct data_in *data_in, tree expr)\n+lto_read_tree_1 (class lto_input_block *ib, class data_in *data_in, tree expr)\n {\n   /* Read all the bitfield values in EXPR.  Note that for LTO, we\n      only write language-independent bitfields, so no more unpacking is\n@@ -1402,7 +1402,7 @@ lto_read_tree_1 (struct lto_input_block *ib, struct data_in *data_in, tree expr)\n    input block IB using the per-file context in DATA_IN.  */\n \n static tree\n-lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n+lto_read_tree (class lto_input_block *ib, class data_in *data_in,\n \t       enum LTO_tags tag, hashval_t hash)\n {\n   /* Instantiate a new tree node.  */\n@@ -1425,7 +1425,7 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n    following in the IB, DATA_IN stream.  */\n \n hashval_t\n-lto_input_scc (struct lto_input_block *ib, struct data_in *data_in,\n+lto_input_scc (class lto_input_block *ib, class data_in *data_in,\n \t       unsigned *len, unsigned *entry_len)\n {\n   /* A blob of unnamed tree nodes, fill the cache from it and\n@@ -1482,7 +1482,7 @@ lto_input_scc (struct lto_input_block *ib, struct data_in *data_in,\n    to previously read nodes.  */\n \n tree\n-lto_input_tree_1 (struct lto_input_block *ib, struct data_in *data_in,\n+lto_input_tree_1 (class lto_input_block *ib, class data_in *data_in,\n \t\t  enum LTO_tags tag, hashval_t hash)\n {\n   tree result;\n@@ -1532,7 +1532,7 @@ lto_input_tree_1 (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n tree\n-lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n+lto_input_tree (class lto_input_block *ib, class data_in *data_in)\n {\n   enum LTO_tags tag;\n \n@@ -1564,7 +1564,7 @@ lto_input_toplevel_asms (struct lto_file_decl_data *file_data, int order_base)\n   const struct lto_simple_header_with_strings *header\n     = (const struct lto_simple_header_with_strings *) data;\n   int string_offset;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   tree str;\n \n   if (! data)\n@@ -1612,7 +1612,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n   const struct lto_simple_header_with_strings *header\n     = (const struct lto_simple_header_with_strings *) data;\n   int string_offset;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   string_offset = sizeof (*header) + header->main_size;\n \n   lto_input_block ib (data + sizeof (*header), header->main_size, NULL);\n@@ -1727,12 +1727,12 @@ lto_reader_init (void)\n    table to use with LEN strings.  RESOLUTIONS is the vector of linker\n    resolutions (NULL if not using a linker plugin).  */\n \n-struct data_in *\n+class data_in *\n lto_data_in_create (struct lto_file_decl_data *file_data, const char *strings,\n \t\t    unsigned len,\n \t\t    vec<ld_plugin_symbol_resolution_t> resolutions)\n {\n-  struct data_in *data_in = new (struct data_in);\n+  class data_in *data_in = new (class data_in);\n   data_in->file_data = file_data;\n   data_in->strings = strings;\n   data_in->strings_len = len;\n@@ -1745,7 +1745,7 @@ lto_data_in_create (struct lto_file_decl_data *file_data, const char *strings,\n /* Remove DATA_IN.  */\n \n void\n-lto_data_in_delete (struct data_in *data_in)\n+lto_data_in_delete (class data_in *data_in)\n {\n   data_in->globals_resolution.release ();\n   streamer_tree_cache_delete (data_in->reader_cache);"}, {"sha": "35dcae4d5891e89d09ba8e5a89a0724fa5ef1cd3", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1911,7 +1911,7 @@ output_cfg (struct output_block *ob, struct function *fn)\n   /* Output each loop, skipping the tree root which has number zero.  */\n   for (unsigned i = 1; i < number_of_loops (fn); ++i)\n     {\n-      struct loop *loop = get_loop (fn, i);\n+      class loop *loop = get_loop (fn, i);\n \n       /* Write the index of the loop header.  That's enough to rebuild\n          the loop tree on the reader side.  Stream -1 for an unused"}, {"sha": "3c35d8a3f9adeafec9e5e23333770f31b4f83993", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -308,7 +308,7 @@ class lto_location_cache\n   /* Tree merging did suceed; throw away recent changes.  */\n   void revert_location_cache ();\n   void input_location (location_t *loc, struct bitpack_d *bp,\n-\t\t       struct data_in *data_in);\n+\t\t       class data_in *data_in);\n   lto_location_cache ()\n      : loc_cache (), accepted_length (0), current_file (NULL), current_line (0),\n        current_col (0), current_sysp (false), current_loc (UNKNOWN_LOCATION)\n@@ -759,13 +759,13 @@ class data_in\n \n \n /* In lto-section-in.c  */\n-extern struct lto_input_block * lto_create_simple_input_block (\n+extern class lto_input_block * lto_create_simple_input_block (\n \t\t\t       struct lto_file_decl_data *,\n \t\t\t       enum lto_section_type, const char **, size_t *);\n extern void\n lto_destroy_simple_input_block (struct lto_file_decl_data *,\n \t\t\t\tenum lto_section_type,\n-\t\t\t\tstruct lto_input_block *, const char *, size_t);\n+\t\t\t\tclass lto_input_block *, const char *, size_t);\n extern void lto_set_in_hooks (struct lto_file_decl_data **,\n \t\t\t      lto_get_section_data_f *,\n \t\t\t      lto_free_section_data_f *);\n@@ -795,7 +795,7 @@ extern struct lto_in_decl_state *lto_get_function_in_decl_state (\n \t\t\t\t      struct lto_file_decl_data *, tree);\n extern void lto_free_function_in_decl_state (struct lto_in_decl_state *);\n extern void lto_free_function_in_decl_state_for_node (symtab_node *);\n-extern void lto_section_overrun (struct lto_input_block *) ATTRIBUTE_NORETURN;\n+extern void lto_section_overrun (class lto_input_block *) ATTRIBUTE_NORETURN;\n extern void lto_value_range_error (const char *,\n \t\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT) ATTRIBUTE_NORETURN;\n@@ -860,23 +860,23 @@ extern void lto_input_constructors_and_inits (struct lto_file_decl_data *,\n \t\t\t\t\t      const char *);\n extern void lto_input_toplevel_asms (struct lto_file_decl_data *, int);\n extern void lto_input_mode_table (struct lto_file_decl_data *);\n-extern struct data_in *lto_data_in_create (struct lto_file_decl_data *,\n+extern class data_in *lto_data_in_create (struct lto_file_decl_data *,\n \t\t\t\t    const char *, unsigned,\n \t\t\t\t    vec<ld_plugin_symbol_resolution_t> );\n-extern void lto_data_in_delete (struct data_in *);\n-extern void lto_input_data_block (struct lto_input_block *, void *, size_t);\n-void lto_input_location (location_t *, struct bitpack_d *, struct data_in *);\n+extern void lto_data_in_delete (class data_in *);\n+extern void lto_input_data_block (class lto_input_block *, void *, size_t);\n+void lto_input_location (location_t *, struct bitpack_d *, class data_in *);\n location_t stream_input_location_now (struct bitpack_d *bp,\n-\t\t\t\t      struct data_in *data);\n-tree lto_input_tree_ref (struct lto_input_block *, struct data_in *,\n+\t\t\t\t      class data_in *data);\n+tree lto_input_tree_ref (class lto_input_block *, class data_in *,\n \t\t\t struct function *, enum LTO_tags);\n void lto_tag_check_set (enum LTO_tags, int, ...);\n void lto_init_eh (void);\n-hashval_t lto_input_scc (struct lto_input_block *, struct data_in *,\n+hashval_t lto_input_scc (class lto_input_block *, class data_in *,\n \t\t\t unsigned *, unsigned *);\n-tree lto_input_tree_1 (struct lto_input_block *, struct data_in *,\n+tree lto_input_tree_1 (class lto_input_block *, class data_in *,\n \t\t       enum LTO_tags, hashval_t hash);\n-tree lto_input_tree (struct lto_input_block *, struct data_in *);\n+tree lto_input_tree (class lto_input_block *, class data_in *);\n \n \n /* In lto-streamer-out.c  */\n@@ -931,14 +931,14 @@ void select_what_to_stream (void);\n void cl_target_option_stream_out (struct output_block *, struct bitpack_d *,\n \t\t\t\t  struct cl_target_option *);\n \n-void cl_target_option_stream_in (struct data_in *,\n+void cl_target_option_stream_in (class data_in *,\n \t\t\t\t struct bitpack_d *,\n \t\t\t\t struct cl_target_option *);\n \n void cl_optimization_stream_out (struct output_block *,\n \t\t\t\t struct bitpack_d *, struct cl_optimization *);\n \n-void cl_optimization_stream_in (struct data_in *,\n+void cl_optimization_stream_in (class data_in *,\n \t\t\t\tstruct bitpack_d *, struct cl_optimization *);\n \n "}, {"sha": "83d166d94a44bc927fce0317cc056e6ebc66b5cd", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1,3 +1,15 @@\n+2019-07-09  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/61339\n+\t* lto-common.c (lto_splay_tree_new): : Change class-key of PODs\n+\tto struct and others to class.\n+\t(mentions_vars_p): Same.\n+\t(register_resolution): Same.\n+\t(lto_register_var_decl_in_symtab): Same.\n+\t(lto_register_function_decl_in_symtab): Same.\n+\t(cmp_tree): Same.\n+\t(lto_read_decls): Same.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/61339"}, {"sha": "c9d97815cfbffee1d58939c3fd4db66c0619c07b", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -179,7 +179,7 @@ lto_splay_tree_new (void)\n    input.  */\n \n static const uint32_t *\n-lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n+lto_read_in_decl_state (class data_in *data_in, const uint32_t *data,\n \t\t\tstruct lto_in_decl_state *state)\n {\n   uint32_t ix;\n@@ -868,7 +868,7 @@ mentions_vars_p (tree t)\n /* Return the resolution for the decl with index INDEX from DATA_IN.  */\n \n static enum ld_plugin_symbol_resolution\n-get_resolution (struct data_in *data_in, unsigned index)\n+get_resolution (class data_in *data_in, unsigned index)\n {\n   if (data_in->globals_resolution.exists ())\n     {\n@@ -911,7 +911,7 @@ register_resolution (struct lto_file_decl_data *file_data, tree decl,\n    different files.  */\n \n static void\n-lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl,\n+lto_register_var_decl_in_symtab (class data_in *data_in, tree decl,\n \t\t\t\t unsigned ix)\n {\n   tree context;\n@@ -936,7 +936,7 @@ lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl,\n    file being read.  */\n \n static void\n-lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl,\n+lto_register_function_decl_in_symtab (class data_in *data_in, tree decl,\n \t\t\t\t      unsigned ix)\n {\n   /* If this variable has already been declared, queue the\n@@ -949,7 +949,7 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl,\n /* Check if T is a decl and needs register its resolution info.  */\n \n static void\n-lto_maybe_register_decl (struct data_in *data_in, tree t, unsigned ix)\n+lto_maybe_register_decl (class data_in *data_in, tree t, unsigned ix)\n {\n   if (TREE_CODE (t) == VAR_DECL)\n     lto_register_var_decl_in_symtab (data_in, t, ix);\n@@ -1624,7 +1624,7 @@ cmp_tree (const void *p1_, const void *p2_)\n    that was successful, otherwise return false.  */\n \n static bool\n-unify_scc (struct data_in *data_in, unsigned from,\n+unify_scc (class data_in *data_in, unsigned from,\n \t   unsigned len, unsigned scc_entry_len, hashval_t scc_hash)\n {\n   bool unified_p = false;\n@@ -1787,7 +1787,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n   const int decl_offset = sizeof (struct lto_decl_header);\n   const int main_offset = decl_offset + header->decl_state_size;\n   const int string_offset = main_offset + header->main_size;\n-  struct data_in *data_in;\n+  class data_in *data_in;\n   unsigned int i;\n   const uint32_t *data_ptr, *data_end;\n   uint32_t num_decl_states;"}, {"sha": "c355594bb6bd3da23640a87e59517354e41b05cd", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -211,7 +211,7 @@ static int sms_order_nodes (ddg_ptr, int, int *, int *);\n static void set_node_sched_params (ddg_ptr);\n static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);\n static void permute_partial_schedule (partial_schedule_ptr, rtx_insn *);\n-static void generate_prolog_epilog (partial_schedule_ptr, struct loop *,\n+static void generate_prolog_epilog (partial_schedule_ptr, class loop *,\n                                     rtx, rtx);\n static int calculate_stage_count (partial_schedule_ptr, int);\n static void calculate_must_precede_follow (ddg_node_ptr, int, int,\n@@ -1124,7 +1124,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \n /* Generate the instructions (including reg_moves) for prolog & epilog.  */\n static void\n-generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,\n+generate_prolog_epilog (partial_schedule_ptr ps, class loop *loop,\n                         rtx count_reg, rtx count_init)\n {\n   int i;\n@@ -1181,7 +1181,7 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,\n /* Mark LOOP as software pipelined so the later\n    scheduling passes don't touch it.  */\n static void\n-mark_loop_unsched (struct loop *loop)\n+mark_loop_unsched (class loop *loop)\n {\n   unsigned i;\n   basic_block *bbs = get_loop_body (loop);\n@@ -1195,7 +1195,7 @@ mark_loop_unsched (struct loop *loop)\n /* Return true if all the BBs of the loop are empty except the\n    loop header.  */\n static bool\n-loop_single_full_bb_p (struct loop *loop)\n+loop_single_full_bb_p (class loop *loop)\n {\n   unsigned i;\n   basic_block *bbs = get_loop_body (loop);\n@@ -1251,7 +1251,7 @@ dump_insn_location (rtx_insn *insn)\n /* Return true if the loop is in its canonical form and false if not.\n    i.e. SIMPLE_SMS_LOOP_P and have one preheader block, and single exit.  */\n static bool\n-loop_canon_p (struct loop *loop)\n+loop_canon_p (class loop *loop)\n {\n \n   if (loop->inner || !loop_outer (loop))\n@@ -1294,7 +1294,7 @@ loop_canon_p (struct loop *loop)\n    make it one by splitting the first entry edge and\n    redirecting the others to the new BB.  */\n static void\n-canon_loop (struct loop *loop)\n+canon_loop (class loop *loop)\n {\n   edge e;\n   edge_iterator i;\n@@ -1346,7 +1346,7 @@ sms_schedule (void)\n   int maxii, max_asap;\n   partial_schedule_ptr ps;\n   basic_block bb = NULL;\n-  struct loop *loop;\n+  class loop *loop;\n   basic_block condition_bb = NULL;\n   edge latch_edge;\n   HOST_WIDE_INT trip_count, max_trip_count;"}, {"sha": "c007ec168d51c6f74ac1b1dee06c967e36916932", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -2516,7 +2516,7 @@ expand_omp_for_ordered_loops (struct omp_for_data *fd, tree *counts,\n \n       if (e2)\n \t{\n-\t  struct loop *loop = alloc_loop ();\n+\t  class loop *loop = alloc_loop ();\n \t  loop->header = new_header;\n \t  loop->latch = e2->src;\n \t  add_loop (loop, body_bb->loop_father);\n@@ -3477,14 +3477,14 @@ expand_omp_for_generic (struct omp_region *region,\n       /* We enter expand_omp_for_generic with a loop.  This original loop may\n \t have its own loop struct, or it may be part of an outer loop struct\n \t (which may be the fake loop).  */\n-      struct loop *outer_loop = entry_bb->loop_father;\n+      class loop *outer_loop = entry_bb->loop_father;\n       bool orig_loop_has_loop_struct = l1_bb->loop_father != outer_loop;\n \n       add_bb_to_loop (l2_bb, outer_loop);\n \n       /* We've added a new loop around the original loop.  Allocate the\n \t corresponding loop struct.  */\n-      struct loop *new_loop = alloc_loop ();\n+      class loop *new_loop = alloc_loop ();\n       new_loop->header = l0_bb;\n       new_loop->latch = l2_bb;\n       add_loop (new_loop, outer_loop);\n@@ -3494,7 +3494,7 @@ expand_omp_for_generic (struct omp_region *region,\n       if (!orig_loop_has_loop_struct\n \t  && !gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n-\t  struct loop *orig_loop = alloc_loop ();\n+\t  class loop *orig_loop = alloc_loop ();\n \t  orig_loop->header = l1_bb;\n \t  /* The loop may have multiple latches.  */\n \t  add_loop (orig_loop, new_loop);\n@@ -4356,7 +4356,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       set_immediate_dominator (CDI_DOMINATORS, exit3_bb, exit_bb);\n     }\n \n-  struct loop *loop = body_bb->loop_father;\n+  class loop *loop = body_bb->loop_father;\n   if (loop != entry_bb->loop_father)\n     {\n       gcc_assert (broken_loop || loop->header == body_bb);\n@@ -5104,8 +5104,8 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \n   if (!broken_loop)\n     {\n-      struct loop *loop = body_bb->loop_father;\n-      struct loop *trip_loop = alloc_loop ();\n+      class loop *loop = body_bb->loop_father;\n+      class loop *trip_loop = alloc_loop ();\n       trip_loop->header = iter_part_bb;\n       trip_loop->latch = trip_update_bb;\n       add_loop (trip_loop, iter_part_bb->loop_father);\n@@ -5523,7 +5523,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \n   if (!broken_loop)\n     {\n-      struct loop *loop = alloc_loop ();\n+      class loop *loop = alloc_loop ();\n       loop->header = l1_bb;\n       loop->latch = cont_bb;\n       add_loop (loop, l1_bb->loop_father);\n@@ -5944,7 +5944,7 @@ expand_omp_taskloop_for_inner (struct omp_region *region,\n \n   if (!broken_loop && !gimple_omp_for_combined_p (fd->for_stmt))\n     {\n-      struct loop *loop = alloc_loop ();\n+      class loop *loop = alloc_loop ();\n       loop->header = body_bb;\n       if (collapse_bb == NULL)\n \tloop->latch = cont_bb;\n@@ -6461,12 +6461,12 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n     {\n       /* We now have one, two or three nested loops.  Update the loop\n \t structures.  */\n-      struct loop *parent = entry_bb->loop_father;\n-      struct loop *body = body_bb->loop_father;\n+      class loop *parent = entry_bb->loop_father;\n+      class loop *body = body_bb->loop_father;\n \n       if (chunking)\n \t{\n-\t  struct loop *chunk_loop = alloc_loop ();\n+\t  class loop *chunk_loop = alloc_loop ();\n \t  chunk_loop->header = head_bb;\n \t  chunk_loop->latch = bottom_bb;\n \t  add_loop (chunk_loop, parent);\n@@ -6482,15 +6482,15 @@ expand_oacc_for (struct omp_region *region, struct omp_for_data *fd)\n \n       if (parent)\n \t{\n-\t  struct loop *body_loop = alloc_loop ();\n+\t  class loop *body_loop = alloc_loop ();\n \t  body_loop->header = body_bb;\n \t  body_loop->latch = cont_bb;\n \t  add_loop (body_loop, parent);\n \n \t  if (fd->tiling)\n \t    {\n \t      /* Insert tiling's element loop.  */\n-\t      struct loop *inner_loop = alloc_loop ();\n+\t      class loop *inner_loop = alloc_loop ();\n \t      inner_loop->header = elem_body_bb;\n \t      inner_loop->latch = elem_cont_bb;\n \t      add_loop (inner_loop, body_loop);\n@@ -7475,7 +7475,7 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n   /* Remove GIMPLE_OMP_ATOMIC_STORE.  */\n   gsi_remove (&si, true);\n \n-  struct loop *loop = alloc_loop ();\n+  class loop *loop = alloc_loop ();\n   loop->header = loop_header;\n   loop->latch = store_bb;\n   add_loop (loop, loop_header->loop_father);\n@@ -7625,14 +7625,14 @@ static void\n mark_loops_in_oacc_kernels_region (basic_block region_entry,\n \t\t\t\t   basic_block region_exit)\n {\n-  struct loop *outer = region_entry->loop_father;\n+  class loop *outer = region_entry->loop_father;\n   gcc_assert (region_exit == NULL || outer == region_exit->loop_father);\n \n   /* Don't parallelize the kernels region if it contains more than one outer\n      loop.  */\n   unsigned int nr_outer_loops = 0;\n-  struct loop *single_outer = NULL;\n-  for (struct loop *loop = outer->inner; loop != NULL; loop = loop->next)\n+  class loop *single_outer = NULL;\n+  for (class loop *loop = outer->inner; loop != NULL; loop = loop->next)\n     {\n       gcc_assert (loop_outer (loop) == outer);\n \n@@ -7649,14 +7649,14 @@ mark_loops_in_oacc_kernels_region (basic_block region_entry,\n   if (nr_outer_loops != 1)\n     return;\n \n-  for (struct loop *loop = single_outer->inner;\n+  for (class loop *loop = single_outer->inner;\n        loop != NULL;\n        loop = loop->inner)\n     if (loop->next)\n       return;\n \n   /* Mark the loops in the region.  */\n-  for (struct loop *loop = single_outer; loop != NULL; loop = loop->inner)\n+  for (class loop *loop = single_outer; loop != NULL; loop = loop->inner)\n     loop->in_oacc_kernels_region = true;\n }\n "}, {"sha": "da788d9f5141aa403a0488c0936c28658edf71f5", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -389,8 +389,8 @@ oacc_xform_loop (gcall *call)\n \t      || !global_options_set.x_flag_tree_loop_vectorize))\n \t{\n \t  basic_block bb = gsi_bb (gsi);\n-\t  struct loop *parent = bb->loop_father;\n-\t  struct loop *body = parent->inner;\n+\t  class loop *parent = bb->loop_father;\n+\t  class loop *body = parent->inner;\n \n \t  parent->force_vectorize = true;\n \t  parent->safelen = INT_MAX;"}, {"sha": "caa8da3cba57c5b70d5fdde5b140497f3c999018", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1194,7 +1194,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \n   gimple *g;\n   basic_block incr_bb = NULL;\n-  struct loop *loop = NULL;\n+  class loop *loop = NULL;\n \n   /* Create a new BB right before the original exit BB, to hold the\n      iteration increment and the condition/branch.  */"}, {"sha": "2a066960e222269fb6ab88d6cd9c671b15863454", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -120,7 +120,7 @@ get_traditional_extraction_insn (extraction_insn *insn,\n    POS_OP is the operand number of the bit position.  */\n \n static bool\n-get_optab_extraction_insn (struct extraction_insn *insn,\n+get_optab_extraction_insn (class extraction_insn *insn,\n \t\t\t   enum extraction_type type,\n \t\t\t   machine_mode mode, direct_optab reg_optab,\n \t\t\t   direct_optab misalign_optab, int pos_op)"}, {"sha": "193cd9135b7de16d20eff9b191efe6a12818d00d", "filename": "gcc/optabs.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -250,7 +250,7 @@ rtx\n expand_widen_pattern_expr (sepops ops, rtx op0, rtx op1, rtx wide_op,\n \t\t\t   rtx target, int unsignedp)\n {\n-  struct expand_operand eops[4];\n+  class expand_operand eops[4];\n   tree oprnd0, oprnd1, oprnd2;\n   machine_mode wmode = VOIDmode, tmode0, tmode1 = VOIDmode;\n   optab widen_pattern_optab;\n@@ -344,7 +344,7 @@ rtx\n expand_ternary_op (machine_mode mode, optab ternary_optab, rtx op0,\n \t\t   rtx op1, rtx op2, rtx target, int unsignedp)\n {\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   enum insn_code icode = optab_handler (ternary_optab, mode);\n \n   gcc_assert (optab_handler (ternary_optab, mode) != CODE_FOR_nothing);\n@@ -413,7 +413,7 @@ expand_vector_broadcast (machine_mode vmode, rtx op)\n   insn_code icode = optab_handler (vec_duplicate_optab, vmode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[2];\n+      class expand_operand ops[2];\n       create_output_operand (&ops[0], NULL_RTX, vmode);\n       create_input_operand (&ops[1], op, GET_MODE (op));\n       expand_insn (icode, 2, ops);\n@@ -1039,7 +1039,7 @@ expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,\n   machine_mode xmode0 = insn_data[(int) icode].operand[1].mode;\n   machine_mode xmode1 = insn_data[(int) icode].operand[2].mode;\n   machine_mode mode0, mode1, tmp_mode;\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   bool commutative_p;\n   rtx_insn *pat;\n   rtx xop0 = op0, xop1 = op1;\n@@ -2012,7 +2012,7 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n   if (optab_handler (unoptab, mode) != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[3];\n+      class expand_operand ops[3];\n       enum insn_code icode = optab_handler (unoptab, mode);\n \n       create_fixed_operand (&ops[0], targ0);\n@@ -2084,7 +2084,7 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   if (optab_handler (binoptab, mode) != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[4];\n+      class expand_operand ops[4];\n       enum insn_code icode = optab_handler (binoptab, mode);\n       machine_mode mode0 = insn_data[icode].operand[1].mode;\n       machine_mode mode1 = insn_data[icode].operand[2].mode;\n@@ -2724,7 +2724,7 @@ expand_unop_direct (machine_mode mode, optab unoptab, rtx op0, rtx target,\n {\n   if (optab_handler (unoptab, mode) != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[2];\n+      class expand_operand ops[2];\n       enum insn_code icode = optab_handler (unoptab, mode);\n       rtx_insn *last = get_last_insn ();\n       rtx_insn *pat;\n@@ -3578,7 +3578,7 @@ bool\n maybe_emit_unop_insn (enum insn_code icode, rtx target, rtx op0,\n \t\t      enum rtx_code code)\n {\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   rtx_insn *pat;\n \n   create_output_operand (&ops[0], target, GET_MODE (target));\n@@ -4289,7 +4289,7 @@ emit_indirect_jump (rtx loc)\n     sorry (\"indirect jumps are not available on this target\");\n   else\n     {\n-      struct expand_operand ops[1];\n+      class expand_operand ops[1];\n       create_address_operand (&ops[0], loc);\n       expand_jump_insn (targetm.code_for_indirect_jump, 1, ops);\n       emit_barrier ();\n@@ -4394,7 +4394,7 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t\t    OPTAB_WIDEN, &comparison, &cmpmode);\n \t  if (comparison)\n \t    {\n-\t      struct expand_operand ops[4];\n+\t      class expand_operand ops[4];\n \n \t      create_output_operand (&ops[0], target, mode);\n \t      create_fixed_operand (&ops[1], comparison);\n@@ -4460,7 +4460,7 @@ emit_conditional_neg_or_complement (rtx target, rtx_code code,\n     target = gen_reg_rtx (mode);\n \n   rtx_insn *last = get_last_insn ();\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n \n   create_output_operand (&ops[0], target, mode);\n   create_fixed_operand (&ops[1], cond);\n@@ -4548,7 +4548,7 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n                     &comparison, &cmode);\n   if (comparison)\n     {\n-      struct expand_operand ops[4];\n+      class expand_operand ops[4];\n \n       create_output_operand (&ops[0], target, mode);\n       create_fixed_operand (&ops[1], comparison);\n@@ -5414,7 +5414,7 @@ vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n \t\t    tree t_op0, tree t_op1, bool unsignedp,\n \t\t    enum insn_code icode, unsigned int opno)\n {\n-  struct expand_operand ops[2];\n+  class expand_operand ops[2];\n   rtx rtx_op0, rtx_op1;\n   machine_mode m0, m1;\n   enum rtx_code rcode = get_rtx_code (tcode, unsignedp);\n@@ -5509,7 +5509,7 @@ expand_vec_perm_1 (enum insn_code icode, rtx target,\n {\n   machine_mode tmode = GET_MODE (target);\n   machine_mode smode = GET_MODE (sel);\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n \n   gcc_assert (GET_MODE_CLASS (smode) == MODE_VECTOR_INT\n \t      || mode_for_int_vector (tmode).require () == smode);\n@@ -5596,7 +5596,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n       rtx shift_amt = shift_amt_for_vec_perm_mask (mode, indices, shift_optab);\n       if (shift_amt)\n \t{\n-\t  struct expand_operand ops[3];\n+\t  class expand_operand ops[3];\n \t  if (shift_code != CODE_FOR_nothing)\n \t    {\n \t      create_output_operand (&ops[0], target, mode);\n@@ -5782,7 +5782,7 @@ rtx\n expand_vec_cond_mask_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n \t\t\t   rtx target)\n {\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   machine_mode mode = TYPE_MODE (vec_cond_type);\n   machine_mode mask_mode = TYPE_MODE (TREE_TYPE (op0));\n   enum insn_code icode = get_vcond_mask_icode (mode, mask_mode);\n@@ -5814,7 +5814,7 @@ rtx\n expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n \t\t      rtx target)\n {\n-  struct expand_operand ops[6];\n+  class expand_operand ops[6];\n   enum insn_code icode;\n   rtx comparison, rtx_op1, rtx_op2;\n   machine_mode mode = TYPE_MODE (vec_cond_type);\n@@ -5884,7 +5884,7 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n rtx\n expand_vec_series_expr (machine_mode vmode, rtx op0, rtx op1, rtx target)\n {\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n   enum insn_code icode;\n   machine_mode emode = GET_MODE_INNER (vmode);\n \n@@ -5904,7 +5904,7 @@ expand_vec_series_expr (machine_mode vmode, rtx op0, rtx op1, rtx target)\n rtx\n expand_vec_cmp_expr (tree type, tree exp, rtx target)\n {\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   enum insn_code icode;\n   rtx comparison;\n   machine_mode mask_mode = TYPE_MODE (type);\n@@ -5945,7 +5945,7 @@ rtx\n expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n \t\t      rtx target, bool uns_p)\n {\n-  struct expand_operand eops[3];\n+  class expand_operand eops[3];\n   enum insn_code icode;\n   int method, i;\n   machine_mode wmode;\n@@ -6098,7 +6098,7 @@ maybe_emit_atomic_exchange (rtx target, rtx mem, rtx val, enum memmodel model)\n   icode = direct_optab_handler (atomic_exchange_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[4];\n+      class expand_operand ops[4];\n \n       create_output_operand (&ops[0], target, mode);\n       create_fixed_operand (&ops[1], mem);\n@@ -6136,7 +6136,7 @@ maybe_emit_sync_lock_test_and_set (rtx target, rtx mem, rtx val,\n \n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[3];\n+      class expand_operand ops[3];\n       create_output_operand (&ops[0], target, mode);\n       create_fixed_operand (&ops[1], mem);\n       create_input_operand (&ops[2], val, mode);\n@@ -6196,7 +6196,7 @@ static rtx\n maybe_emit_atomic_test_and_set (rtx target, rtx mem, enum memmodel model)\n {\n   machine_mode pat_bool_mode;\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n \n   if (!targetm.have_atomic_test_and_set ())\n     return NULL_RTX;\n@@ -6366,7 +6366,7 @@ expand_atomic_compare_and_swap (rtx *ptarget_bool, rtx *ptarget_oval,\n \t\t\t\tenum memmodel fail_model)\n {\n   machine_mode mode = GET_MODE (mem);\n-  struct expand_operand ops[8];\n+  class expand_operand ops[8];\n   enum insn_code icode;\n   rtx target_oval, target_bool = NULL_RTX;\n   rtx libfunc;\n@@ -6568,7 +6568,7 @@ expand_atomic_load (rtx target, rtx mem, enum memmodel model)\n   icode = direct_optab_handler (atomic_load_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      struct expand_operand ops[3];\n+      class expand_operand ops[3];\n       rtx_insn *last = get_last_insn ();\n       if (is_mm_seq_cst (model))\n \texpand_memory_blockage ();\n@@ -6621,7 +6621,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n {\n   machine_mode mode = GET_MODE (mem);\n   enum insn_code icode;\n-  struct expand_operand ops[3];\n+  class expand_operand ops[3];\n \n   /* If the target supports the store directly, great.  */\n   icode = direct_optab_handler (atomic_store_optab, mode);\n@@ -6831,7 +6831,7 @@ maybe_emit_op (const struct atomic_op_functions *optab, rtx target, rtx mem,\n \t       rtx val, bool use_memmodel, enum memmodel model, bool after)\n {\n   machine_mode mode = GET_MODE (mem);\n-  struct expand_operand ops[4];\n+  class expand_operand ops[4];\n   enum insn_code icode;\n   int op_counter = 0;\n   int num_ops;\n@@ -7145,7 +7145,7 @@ valid_multiword_target_p (rtx target)\n    of that rtx if so.  */\n \n void\n-create_integer_operand (struct expand_operand *op, poly_int64 intval)\n+create_integer_operand (class expand_operand *op, poly_int64 intval)\n {\n   create_expand_operand (op, EXPAND_INTEGER,\n \t\t\t gen_int_mode (intval, MAX_MODE_INT),\n@@ -7157,7 +7157,7 @@ create_integer_operand (struct expand_operand *op, poly_int64 intval)\n \n static bool\n maybe_legitimize_operand_same_code (enum insn_code icode, unsigned int opno,\n-\t\t\t\t    struct expand_operand *op)\n+\t\t\t\t    class expand_operand *op)\n {\n   /* See if the operand matches in its current form.  */\n   if (insn_operand_matches (icode, opno, op->value))\n@@ -7199,7 +7199,7 @@ maybe_legitimize_operand_same_code (enum insn_code icode, unsigned int opno,\n \n static bool\n maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n-\t\t\t  struct expand_operand *op)\n+\t\t\t  class expand_operand *op)\n {\n   machine_mode mode, imode;\n   bool old_volatile_ok, result;\n@@ -7281,7 +7281,7 @@ maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n    TYPE is the type of VALUE.  */\n \n void\n-create_convert_operand_from_type (struct expand_operand *op,\n+create_convert_operand_from_type (class expand_operand *op,\n \t\t\t\t  rtx value, tree type)\n {\n   create_convert_operand_from (op, value, TYPE_MODE (type),\n@@ -7296,8 +7296,8 @@ create_convert_operand_from_type (struct expand_operand *op,\n static inline bool\n can_reuse_operands_p (enum insn_code icode,\n \t\t      unsigned int opno1, unsigned int opno2,\n-\t\t      const struct expand_operand *op1,\n-\t\t      const struct expand_operand *op2)\n+\t\t      const class expand_operand *op1,\n+\t\t      const class expand_operand *op2)\n {\n   /* Check requirements that are common to all types.  */\n   if (op1->type != op2->type\n@@ -7332,7 +7332,7 @@ can_reuse_operands_p (enum insn_code icode,\n \n bool\n maybe_legitimize_operands (enum insn_code icode, unsigned int opno,\n-\t\t\t   unsigned int nops, struct expand_operand *ops)\n+\t\t\t   unsigned int nops, class expand_operand *ops)\n {\n   rtx_insn *last = get_last_insn ();\n   rtx *orig_values = XALLOCAVEC (rtx, nops);\n@@ -7374,7 +7374,7 @@ maybe_legitimize_operands (enum insn_code icode, unsigned int opno,\n \n rtx_insn *\n maybe_gen_insn (enum insn_code icode, unsigned int nops,\n-\t\tstruct expand_operand *ops)\n+\t\tclass expand_operand *ops)\n {\n   gcc_assert (nops == (unsigned int) insn_data[(int) icode].n_generator_args);\n   if (!maybe_legitimize_operands (icode, 0, nops, ops))\n@@ -7418,7 +7418,7 @@ maybe_gen_insn (enum insn_code icode, unsigned int nops,\n \n bool\n maybe_expand_insn (enum insn_code icode, unsigned int nops,\n-\t\t   struct expand_operand *ops)\n+\t\t   class expand_operand *ops)\n {\n   rtx_insn *pat = maybe_gen_insn (icode, nops, ops);\n   if (pat)\n@@ -7433,7 +7433,7 @@ maybe_expand_insn (enum insn_code icode, unsigned int nops,\n \n bool\n maybe_expand_jump_insn (enum insn_code icode, unsigned int nops,\n-\t\t\tstruct expand_operand *ops)\n+\t\t\tclass expand_operand *ops)\n {\n   rtx_insn *pat = maybe_gen_insn (icode, nops, ops);\n   if (pat)\n@@ -7449,7 +7449,7 @@ maybe_expand_jump_insn (enum insn_code icode, unsigned int nops,\n \n void\n expand_insn (enum insn_code icode, unsigned int nops,\n-\t     struct expand_operand *ops)\n+\t     class expand_operand *ops)\n {\n   if (!maybe_expand_insn (icode, nops, ops))\n     gcc_unreachable ();\n@@ -7459,7 +7459,7 @@ expand_insn (enum insn_code icode, unsigned int nops,\n \n void\n expand_jump_insn (enum insn_code icode, unsigned int nops,\n-\t\t  struct expand_operand *ops)\n+\t\t  class expand_operand *ops)\n {\n   if (!maybe_expand_jump_insn (icode, nops, ops))\n     gcc_unreachable ();"}, {"sha": "0654107d6e32b53cc5de320dca9cefbaa5753216", "filename": "gcc/optabs.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -71,7 +71,7 @@ class expand_operand {\n    to their default values.  */\n \n static inline void\n-create_expand_operand (struct expand_operand *op,\n+create_expand_operand (class expand_operand *op,\n \t\t       enum expand_operand_type type,\n \t\t       rtx value, machine_mode mode,\n \t\t       bool unsigned_p, poly_int64 int_value = 0)\n@@ -87,7 +87,7 @@ create_expand_operand (struct expand_operand *op,\n /* Make OP describe an operand that must use rtx X, even if X is volatile.  */\n \n static inline void\n-create_fixed_operand (struct expand_operand *op, rtx x)\n+create_fixed_operand (class expand_operand *op, rtx x)\n {\n   create_expand_operand (op, EXPAND_FIXED, x, VOIDmode, false);\n }\n@@ -98,7 +98,7 @@ create_fixed_operand (struct expand_operand *op, rtx x)\n    be ignored in that case.  */\n \n static inline void\n-create_output_operand (struct expand_operand *op, rtx x,\n+create_output_operand (class expand_operand *op, rtx x,\n \t\t       machine_mode mode)\n {\n   create_expand_operand (op, EXPAND_OUTPUT, x, mode, false);\n@@ -110,7 +110,7 @@ create_output_operand (struct expand_operand *op, rtx x,\n    as an operand.  */\n \n static inline void\n-create_input_operand (struct expand_operand *op, rtx value,\n+create_input_operand (class expand_operand *op, rtx value,\n \t\t      machine_mode mode)\n {\n   create_expand_operand (op, EXPAND_INPUT, value, mode, false);\n@@ -120,7 +120,7 @@ create_input_operand (struct expand_operand *op, rtx value,\n    to mode MODE.  UNSIGNED_P says whether VALUE is unsigned.  */\n \n static inline void\n-create_convert_operand_to (struct expand_operand *op, rtx value,\n+create_convert_operand_to (class expand_operand *op, rtx value,\n \t\t\t   machine_mode mode, bool unsigned_p)\n {\n   create_expand_operand (op, EXPAND_CONVERT_TO, value, mode, unsigned_p);\n@@ -132,7 +132,7 @@ create_convert_operand_to (struct expand_operand *op, rtx value,\n    UNSIGNED_P says whether VALUE is unsigned.  */\n \n static inline void\n-create_convert_operand_from (struct expand_operand *op, rtx value,\n+create_convert_operand_from (class expand_operand *op, rtx value,\n \t\t\t     machine_mode mode, bool unsigned_p)\n {\n   create_expand_operand (op, EXPAND_CONVERT_FROM, value, mode, unsigned_p);\n@@ -143,12 +143,12 @@ create_convert_operand_from (struct expand_operand *op, rtx value,\n    of the address, but it may need to be converted to Pmode first.  */\n \n static inline void\n-create_address_operand (struct expand_operand *op, rtx value)\n+create_address_operand (class expand_operand *op, rtx value)\n {\n   create_expand_operand (op, EXPAND_ADDRESS, value, Pmode, false);\n }\n \n-extern void create_integer_operand (struct expand_operand *, poly_int64);\n+extern void create_integer_operand (class expand_operand *, poly_int64);\n \n /* Passed to expand_simple_binop and expand_binop to say which options\n    to try to use if the requested operation can't be open-coded on the\n@@ -336,21 +336,21 @@ rtx expand_atomic_fetch_op (rtx, rtx, rtx, enum rtx_code, enum memmodel,\n extern bool insn_operand_matches (enum insn_code icode, unsigned int opno,\n \t\t\t\t  rtx operand);\n extern bool valid_multiword_target_p (rtx);\n-extern void create_convert_operand_from_type (struct expand_operand *op,\n+extern void create_convert_operand_from_type (class expand_operand *op,\n \t\t\t\t\t      rtx value, tree type);\n extern bool maybe_legitimize_operands (enum insn_code icode,\n \t\t\t\t       unsigned int opno, unsigned int nops,\n-\t\t\t\t       struct expand_operand *ops);\n+\t\t\t\t       class expand_operand *ops);\n extern rtx_insn *maybe_gen_insn (enum insn_code icode, unsigned int nops,\n-\t\t\t\t struct expand_operand *ops);\n+\t\t\t\t class expand_operand *ops);\n extern bool maybe_expand_insn (enum insn_code icode, unsigned int nops,\n-\t\t\t       struct expand_operand *ops);\n+\t\t\t       class expand_operand *ops);\n extern bool maybe_expand_jump_insn (enum insn_code icode, unsigned int nops,\n-\t\t\t\t    struct expand_operand *ops);\n+\t\t\t\t    class expand_operand *ops);\n extern void expand_insn (enum insn_code icode, unsigned int nops,\n-\t\t\t struct expand_operand *ops);\n+\t\t\t class expand_operand *ops);\n extern void expand_jump_insn (enum insn_code icode, unsigned int nops,\n-\t\t\t      struct expand_operand *ops);\n+\t\t\t      class expand_operand *ops);\n \n extern enum rtx_code get_rtx_code (enum tree_code tcode, bool unsignedp);\n "}, {"sha": "04786b4c03b69cf91193634998e29a2db90ea784", "filename": "gcc/optinfo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Foptinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -65,7 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n \n \n /* Forward decls.  */\n-struct opt_pass;\n+class opt_pass;\n class optinfo_item;\n \n /* Return true if any of the active optinfo destinations make use"}, {"sha": "0ccdf680f43c223b5c42147cad4b376d01e35ae4", "filename": "gcc/poly-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef HAVE_POLY_INT_H\n #define HAVE_POLY_INT_H\n \n-template<unsigned int N, typename T> class poly_int_pod;\n+template<unsigned int N, typename T> struct poly_int_pod;\n template<unsigned int N, typename T> class poly_int;\n \n /* poly_coeff_traiits<T> describes the properties of a poly_int"}, {"sha": "07f66aab7a368777a6a944fd481e9853ef5709c9", "filename": "gcc/predict.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -87,10 +87,10 @@ static void dump_prediction (FILE *, enum br_predictor, int, basic_block,\n \t\t\t     enum predictor_reason, edge);\n static void predict_paths_leading_to (basic_block, enum br_predictor,\n \t\t\t\t      enum prediction,\n-\t\t\t\t      struct loop *in_loop = NULL);\n+\t\t\t\t      class loop *in_loop = NULL);\n static void predict_paths_leading_to_edge (edge, enum br_predictor,\n \t\t\t\t\t   enum prediction,\n-\t\t\t\t\t   struct loop *in_loop = NULL);\n+\t\t\t\t\t   class loop *in_loop = NULL);\n static bool can_predict_insn_p (const rtx_insn *);\n static HOST_WIDE_INT get_predictor_value (br_predictor, HOST_WIDE_INT);\n static void determine_unlikely_bbs ();\n@@ -355,25 +355,25 @@ optimize_insn_for_speed_p (void)\n /* Return TRUE when LOOP should be optimized for size.  */\n \n bool\n-optimize_loop_for_size_p (struct loop *loop)\n+optimize_loop_for_size_p (class loop *loop)\n {\n   return optimize_bb_for_size_p (loop->header);\n }\n \n /* Return TRUE when LOOP should be optimized for speed.  */\n \n bool\n-optimize_loop_for_speed_p (struct loop *loop)\n+optimize_loop_for_speed_p (class loop *loop)\n {\n   return optimize_bb_for_speed_p (loop->header);\n }\n \n /* Return TRUE when LOOP nest should be optimized for speed.  */\n \n bool\n-optimize_loop_nest_for_speed_p (struct loop *loop)\n+optimize_loop_nest_for_speed_p (class loop *loop)\n {\n-  struct loop *l = loop;\n+  class loop *l = loop;\n   if (optimize_loop_for_speed_p (loop))\n     return true;\n   l = loop->inner;\n@@ -399,7 +399,7 @@ optimize_loop_nest_for_speed_p (struct loop *loop)\n /* Return TRUE when LOOP nest should be optimized for size.  */\n \n bool\n-optimize_loop_nest_for_size_p (struct loop *loop)\n+optimize_loop_nest_for_size_p (class loop *loop)\n {\n   return !optimize_loop_nest_for_speed_p (loop);\n }\n@@ -1471,7 +1471,7 @@ get_base_value (tree t)\n    Otherwise return false and set LOOP_INVAIANT to NULL.  */\n \n static bool\n-is_comparison_with_loop_invariant_p (gcond *stmt, struct loop *loop,\n+is_comparison_with_loop_invariant_p (gcond *stmt, class loop *loop,\n \t\t\t\t     tree *loop_invariant,\n \t\t\t\t     enum tree_code *compare_code,\n \t\t\t\t     tree *loop_step,\n@@ -1637,7 +1637,7 @@ predicted_by_loop_heuristics_p (basic_block bb)\n   In this loop, we will predict the branch inside the loop to be taken.  */\n \n static void\n-predict_iv_comparison (struct loop *loop, basic_block bb,\n+predict_iv_comparison (class loop *loop, basic_block bb,\n \t\t       tree loop_bound_var,\n \t\t       tree loop_iv_base_var,\n \t\t       enum tree_code loop_bound_code,\n@@ -1896,9 +1896,9 @@ predict_extra_loop_exits (edge exit_edge)\n static void\n predict_loops (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   basic_block bb;\n-  hash_set <struct loop *> with_recursion(10);\n+  hash_set <class loop *> with_recursion(10);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -1923,9 +1923,9 @@ predict_loops (void)\n       basic_block bb, *bbs;\n       unsigned j, n_exits = 0;\n       vec<edge> exits;\n-      struct tree_niter_desc niter_desc;\n+      class tree_niter_desc niter_desc;\n       edge ex;\n-      struct nb_iter_bound *nb_iter;\n+      class nb_iter_bound *nb_iter;\n       enum tree_code loop_bound_code = ERROR_MARK;\n       tree loop_bound_step = NULL;\n       tree loop_bound_var = NULL;\n@@ -3135,7 +3135,7 @@ static void\n predict_paths_for_bb (basic_block cur, basic_block bb,\n \t\t      enum br_predictor pred,\n \t\t      enum prediction taken,\n-\t\t      bitmap visited, struct loop *in_loop = NULL)\n+\t\t      bitmap visited, class loop *in_loop = NULL)\n {\n   edge e;\n   edge_iterator ei;\n@@ -3201,7 +3201,7 @@ predict_paths_for_bb (basic_block cur, basic_block bb,\n \n static void\n predict_paths_leading_to (basic_block bb, enum br_predictor pred,\n-\t\t\t  enum prediction taken, struct loop *in_loop)\n+\t\t\t  enum prediction taken, class loop *in_loop)\n {\n   predict_paths_for_bb (bb, bb, pred, taken, auto_bitmap (), in_loop);\n }\n@@ -3210,7 +3210,7 @@ predict_paths_leading_to (basic_block bb, enum br_predictor pred,\n \n static void\n predict_paths_leading_to_edge (edge e, enum br_predictor pred,\n-\t\t\t       enum prediction taken, struct loop *in_loop)\n+\t\t\t       enum prediction taken, class loop *in_loop)\n {\n   bool has_nonloop_edge = false;\n   edge_iterator ei;\n@@ -3400,9 +3400,9 @@ propagate_freq (basic_block head, bitmap tovisit)\n /* Estimate frequencies in loops at same nest level.  */\n \n static void\n-estimate_loops_at_level (struct loop *first_loop)\n+estimate_loops_at_level (class loop *first_loop)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   for (loop = first_loop; loop; loop = loop->next)\n     {\n@@ -4052,7 +4052,7 @@ pass_profile::execute (function *fun)\n     profile_status_for_fn (fun) = PROFILE_GUESSED;\n  if (dump_file && (dump_flags & TDF_DETAILS))\n    {\n-     struct loop *loop;\n+     class loop *loop;\n      FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n        if (loop->header->count.initialized_p ())\n          fprintf (dump_file, \"Loop got predicted %d to iterate %i times.\\n\","}, {"sha": "5149a97cce4a60c81e8eba4e7267d460b4280298", "filename": "gcc/predict.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -68,10 +68,10 @@ extern bool optimize_edge_for_size_p (edge);\n extern bool optimize_edge_for_speed_p (edge);\n extern bool optimize_insn_for_size_p (void);\n extern bool optimize_insn_for_speed_p (void);\n-extern bool optimize_loop_for_size_p (struct loop *);\n-extern bool optimize_loop_for_speed_p (struct loop *);\n-extern bool optimize_loop_nest_for_speed_p (struct loop *);\n-extern bool optimize_loop_nest_for_size_p (struct loop *);\n+extern bool optimize_loop_for_size_p (class loop *);\n+extern bool optimize_loop_for_speed_p (class loop *);\n+extern bool optimize_loop_nest_for_speed_p (class loop *);\n+extern bool optimize_loop_nest_for_size_p (class loop *);\n extern bool predictable_edge_p (edge);\n extern void rtl_profile_for_bb (basic_block);\n extern void rtl_profile_for_edge (edge);"}, {"sha": "6198675eb89294a22944e2c2f6c0e57feb02e1d4", "filename": "gcc/profile-count.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -125,7 +125,7 @@ profile_count::differs_from_p (profile_count other) const\n /* Stream THIS from IB.  */\n \n profile_count\n-profile_count::stream_in (struct lto_input_block *ib)\n+profile_count::stream_in (class lto_input_block *ib)\n {\n   profile_count ret;\n   ret.m_val = streamer_read_gcov_count (ib);\n@@ -216,7 +216,7 @@ profile_probability::differs_lot_from_p (profile_probability other) const\n /* Stream THIS from IB.  */\n \n profile_probability\n-profile_probability::stream_in (struct lto_input_block *ib)\n+profile_probability::stream_in (class lto_input_block *ib)\n {\n   profile_probability ret;\n   ret.m_val = streamer_read_uhwi (ib);"}, {"sha": "ef84ddcc535f1ef579a9d3eccf909b10e1aaa18e", "filename": "gcc/profile-count.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_PROFILE_COUNT_H\n \n struct function;\n-class profile_count;\n+struct profile_count;\n \n /* Quality of the profile count.  Because gengtype does not support enums\n    inside of classes, this is in global namespace.  */\n@@ -154,7 +154,7 @@ class GTY((user)) profile_probability\n   uint32_t m_val : 29;\n   enum profile_quality m_quality : 3;\n \n-  friend class profile_count;\n+  friend struct profile_count;\n public:\n   profile_probability (): m_val (uninitialized_probability),\n     m_quality (GUESSED)\n@@ -615,7 +615,7 @@ class GTY((user)) profile_probability\n \t\t\t\t\t  profile_count count2) const;\n \n   /* LTO streaming support.  */\n-  static profile_probability stream_in (struct lto_input_block *);\n+  static profile_probability stream_in (class lto_input_block *);\n   void stream_out (struct output_block *);\n   void stream_out (struct lto_output_stream *);\n };\n@@ -1201,7 +1201,7 @@ struct GTY(()) profile_count\n \t\t\t\t       profile_quality quality = PRECISE);\n \n   /* LTO streaming support.  */\n-  static profile_count stream_in (struct lto_input_block *);\n+  static profile_count stream_in (class lto_input_block *);\n   void stream_out (struct output_block *);\n   void stream_out (struct lto_output_stream *);\n };"}, {"sha": "441cb8eb18308e84a04ccea0a57bd7d2a523505c", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1370,7 +1370,7 @@ branch_prob (bool thunk)\n   if (flag_branch_probabilities\n       && (profile_status_for_fn (cfun) == PROFILE_READ))\n     {\n-      struct loop *loop;\n+      class loop *loop;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \treport_predictor_hitrates ();\n "}, {"sha": "73c0ceda34155fa9fdf7a3be05c1b2b3c1f99df7", "filename": "gcc/regrename.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -116,7 +116,7 @@ static unsigned current_id;\n static vec<du_head_p> id_to_chain;\n \n /* List of currently open chains.  */\n-static struct du_head *open_chains;\n+static class du_head *open_chains;\n \n /* Bitmap of open chains.  The bits set always match the list found in\n    open_chains.  */\n@@ -135,7 +135,7 @@ static HARD_REG_SET live_hard_regs;\n static operand_rr_info *cur_operand;\n \n /* Set while scanning RTL if a register dies.  Used to tie chains.  */\n-static struct du_head *terminated_this_insn;\n+static class du_head *terminated_this_insn;\n \n /* Return the chain corresponding to id number ID.  Take into account that\n    chains may have been merged.  */\n@@ -192,7 +192,7 @@ free_chain_data (void)\n    another chain whose id is ID.  */\n \n static void\n-mark_conflict (struct du_head *chains, unsigned id)\n+mark_conflict (class du_head *chains, unsigned id)\n {\n   while (chains)\n     {\n@@ -205,7 +205,7 @@ mark_conflict (struct du_head *chains, unsigned id)\n    use THIS_DU which is part of the chain HEAD.  */\n \n static void\n-record_operand_use (struct du_head *head, struct du_chain *this_du)\n+record_operand_use (class du_head *head, struct du_chain *this_du)\n {\n   if (cur_operand == NULL || cur_operand->failed)\n     return;\n@@ -227,7 +227,7 @@ static du_head_p\n create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n \t\t  rtx_insn *insn, enum reg_class cl)\n {\n-  struct du_head *head = XOBNEW (&rename_obstack, struct du_head);\n+  class du_head *head = XOBNEW (&rename_obstack, class du_head);\n   struct du_chain *this_du;\n   int nregs;\n \n@@ -288,7 +288,7 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n    set the corresponding bits in *PSET.  */\n \n static void\n-merge_overlapping_regs (HARD_REG_SET *pset, struct du_head *head)\n+merge_overlapping_regs (HARD_REG_SET *pset, class du_head *head)\n {\n   bitmap_iterator bi;\n   unsigned i;\n@@ -309,7 +309,7 @@ merge_overlapping_regs (HARD_REG_SET *pset, struct du_head *head)\n \n static bool\n check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n-\t\t struct du_head *this_head, HARD_REG_SET this_unavailable)\n+\t\t class du_head *this_head, HARD_REG_SET this_unavailable)\n {\n   machine_mode mode = GET_MODE (*this_head->first->loc);\n   int nregs = hard_regno_nregs (new_reg, mode);\n@@ -561,7 +561,7 @@ class bb_rename_info\n /* Initialize a rename_info structure P for basic block BB, which starts a new\n    scan.  */\n static void\n-init_rename_info (struct bb_rename_info *p, basic_block bb)\n+init_rename_info (class bb_rename_info *p, basic_block bb)\n {\n   int i;\n   df_ref def;\n@@ -616,7 +616,7 @@ init_rename_info (struct bb_rename_info *p, basic_block bb)\n /* Record in RI that the block corresponding to it has an incoming\n    live value, described by CHAIN.  */\n static void\n-set_incoming_from_chain (struct bb_rename_info *ri, du_head_p chain)\n+set_incoming_from_chain (class bb_rename_info *ri, du_head_p chain)\n {\n   int i;\n   int incoming_nregs = ri->incoming[chain->regno].nregs;\n@@ -690,7 +690,7 @@ merge_chains (du_head_p c1, du_head_p c2)\n void\n regrename_analyze (bitmap bb_mask)\n {\n-  struct bb_rename_info *rename_info;\n+  class bb_rename_info *rename_info;\n   int i;\n   basic_block bb;\n   int n_bbs;\n@@ -700,11 +700,11 @@ regrename_analyze (bitmap bb_mask)\n   n_bbs = pre_and_rev_post_order_compute (NULL, inverse_postorder, false);\n \n   /* Gather some information about the blocks in this function.  */\n-  rename_info = XCNEWVEC (struct bb_rename_info, n_basic_blocks_for_fn (cfun));\n+  rename_info = XCNEWVEC (class bb_rename_info, n_basic_blocks_for_fn (cfun));\n   i = 0;\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      struct bb_rename_info *ri = rename_info + i;\n+      class bb_rename_info *ri = rename_info + i;\n       ri->bb = bb;\n       if (bb_mask != NULL && !bitmap_bit_p (bb_mask, bb->index))\n \tbb->aux = NULL;\n@@ -725,13 +725,13 @@ regrename_analyze (bitmap bb_mask)\n   for (i = 0; i < n_bbs; i++)\n     {\n       basic_block bb1 = BASIC_BLOCK_FOR_FN (cfun, inverse_postorder[i]);\n-      struct bb_rename_info *this_info;\n+      class bb_rename_info *this_info;\n       bool success;\n       edge e;\n       edge_iterator ei;\n       int old_length = id_to_chain.length ();\n \n-      this_info = (struct bb_rename_info *) bb1->aux;\n+      this_info = (class bb_rename_info *) bb1->aux;\n       if (this_info == NULL)\n \tcontinue;\n \n@@ -771,15 +771,15 @@ regrename_analyze (bitmap bb_mask)\n \t will be used to pre-open chains when processing the successors.  */\n       FOR_EACH_EDGE (e, ei, bb1->succs)\n \t{\n-\t  struct bb_rename_info *dest_ri;\n-\t  struct du_head *chain;\n+\t  class bb_rename_info *dest_ri;\n+\t  class du_head *chain;\n \n \t  if (dump_file)\n \t    fprintf (dump_file, \"successor block %d\\n\", e->dest->index);\n \n \t  if (e->flags & (EDGE_EH | EDGE_ABNORMAL))\n \t    continue;\n-\t  dest_ri = (struct bb_rename_info *)e->dest->aux;\n+\t  dest_ri = (class bb_rename_info *)e->dest->aux;\n \t  if (dest_ri == NULL)\n \t    continue;\n \t  for (chain = open_chains; chain; chain = chain->next_chain)\n@@ -808,7 +808,7 @@ regrename_analyze (bitmap bb_mask)\n      edges).  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      struct bb_rename_info *bb_ri = (struct bb_rename_info *) bb->aux;\n+      class bb_rename_info *bb_ri = (class bb_rename_info *) bb->aux;\n       unsigned j;\n       bitmap_iterator bi;\n \n@@ -822,12 +822,12 @@ regrename_analyze (bitmap bb_mask)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n-\t  struct du_head *chain = regrename_chain_from_id (j);\n+\t  class du_head *chain = regrename_chain_from_id (j);\n \t  int n_preds_used = 0, n_preds_joined = 0;\n \n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n-\t      struct bb_rename_info *src_ri;\n+\t      class bb_rename_info *src_ri;\n \t      unsigned k;\n \t      bitmap_iterator bi2;\n \t      HARD_REG_SET live;\n@@ -842,14 +842,14 @@ regrename_analyze (bitmap bb_mask)\n \t      if (e->flags & (EDGE_EH | EDGE_ABNORMAL))\n \t\tcontinue;\n \n-\t      src_ri = (struct bb_rename_info *)e->src->aux;\n+\t      src_ri = (class bb_rename_info *)e->src->aux;\n \t      if (src_ri == NULL)\n \t\tcontinue;\n \n \t      EXECUTE_IF_SET_IN_BITMAP (&src_ri->open_chains_set,\n \t\t\t\t\t0, k, bi2)\n \t\t{\n-\t\t  struct du_head *outgoing_chain = regrename_chain_from_id (k);\n+\t\t  class du_head *outgoing_chain = regrename_chain_from_id (k);\n \n \t\t  if (outgoing_chain->regno == chain->regno\n \t\t      && outgoing_chain->nregs == chain->nregs)\n@@ -873,7 +873,7 @@ regrename_analyze (bitmap bb_mask)\n     }\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      struct bb_rename_info *bb_ri = (struct bb_rename_info *) bb->aux;\n+      class bb_rename_info *bb_ri = (class bb_rename_info *) bb->aux;\n       unsigned j;\n       bitmap_iterator bi;\n \n@@ -887,13 +887,13 @@ regrename_analyze (bitmap bb_mask)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n-\t  struct du_head *chain = regrename_chain_from_id (j);\n+\t  class du_head *chain = regrename_chain_from_id (j);\n \t  int n_succs_used = 0, n_succs_joined = 0;\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n \t      bool printed = false;\n-\t      struct bb_rename_info *dest_ri;\n+\t      class bb_rename_info *dest_ri;\n \t      unsigned k;\n \t      bitmap_iterator bi2;\n \t      HARD_REG_SET live;\n@@ -905,14 +905,14 @@ regrename_analyze (bitmap bb_mask)\n \t      \n \t      n_succs_used++;\n \n-\t      dest_ri = (struct bb_rename_info *)e->dest->aux;\n+\t      dest_ri = (class bb_rename_info *)e->dest->aux;\n \t      if (dest_ri == NULL)\n \t\tcontinue;\n \n \t      EXECUTE_IF_SET_IN_BITMAP (&dest_ri->incoming_open_chains_set,\n \t\t\t\t\t0, k, bi2)\n \t\t{\n-\t\t  struct du_head *incoming_chain = regrename_chain_from_id (k);\n+\t\t  class du_head *incoming_chain = regrename_chain_from_id (k);\n \n \t\t  if (incoming_chain->regno == chain->regno\n \t\t      && incoming_chain->nregs == chain->nregs)\n@@ -959,7 +959,7 @@ regrename_analyze (bitmap bb_mask)\n    numbering in its subpatterns.  */\n \n bool\n-regrename_do_replace (struct du_head *head, int reg)\n+regrename_do_replace (class du_head *head, int reg)\n {\n   struct du_chain *chain;\n   unsigned int base_regno = head->regno;\n@@ -969,7 +969,7 @@ regrename_do_replace (struct du_head *head, int reg)\n   for (chain = head->first; chain; chain = chain->next_use)\n     {\n       unsigned int regno = ORIGINAL_REGNO (*chain->loc);\n-      struct reg_attrs *attr = REG_ATTRS (*chain->loc);\n+      class reg_attrs *attr = REG_ATTRS (*chain->loc);\n       int reg_ptr = REG_POINTER (*chain->loc);\n \n       if (DEBUG_INSN_P (chain->insn) && REGNO (*chain->loc) != base_regno)\n@@ -1053,7 +1053,7 @@ static void\n note_sets_clobbers (rtx x, const_rtx set, void *data)\n {\n   enum rtx_code code = *(enum rtx_code *)data;\n-  struct du_head *chain;\n+  class du_head *chain;\n \n   if (GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n@@ -1070,7 +1070,7 @@ static void\n scan_rtx_reg (rtx_insn *insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t      enum op_type type)\n {\n-  struct du_head **p;\n+  class du_head **p;\n   rtx x = *loc;\n   unsigned this_regno = REGNO (x);\n   int this_nregs = REG_NREGS (x);\n@@ -1116,8 +1116,8 @@ scan_rtx_reg (rtx_insn *insn, rtx *loc, enum reg_class cl, enum scan_actions act\n \n   for (p = &open_chains; *p;)\n     {\n-      struct du_head *head = *p;\n-      struct du_head *next = head->next_chain;\n+      class du_head *head = *p;\n+      class du_head *next = head->next_chain;\n       int exact_match = (head->regno == this_regno\n \t\t\t && head->nregs == this_nregs);\n       int superset = (this_regno <= head->regno\n@@ -1588,7 +1588,7 @@ record_out_operands (rtx_insn *insn, bool earlyclobber, insn_rr_info *insn_info)\n       rtx op = *loc;\n       enum reg_class cl = alternative_class (op_alt, opn);\n \n-      struct du_head *prev_open;\n+      class du_head *prev_open;\n \n       if (recog_data.operand_type[opn] != OP_OUT\n \t  || op_alt[opn].earlyclobber != earlyclobber)\n@@ -1835,7 +1835,7 @@ build_def_use (basic_block bb)\n \t     requires a caller-saved reg.  */\n \t  if (CALL_P (insn))\n \t    {\n-\t      struct du_head *p;\n+\t      class du_head *p;\n \t      for (p = open_chains; p; p = p->next_chain)\n \t\tp->need_caller_save_reg = 1;\n \t    }"}, {"sha": "2fe12d5aa611b6a0c5a581dabbc344d5d1197e5f", "filename": "gcc/regrename.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fregrename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fregrename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -26,11 +26,11 @@ class du_head\n {\n public:\n   /* The next chain.  */\n-  struct du_head *next_chain;\n+  class du_head *next_chain;\n   /* The first and last elements of this chain.  */\n   struct du_chain *first, *last;\n   /* The chain that this chain is tied to.  */\n-  struct du_head *tied_chain;\n+  class du_head *tied_chain;\n   /* Describes the register being tracked.  */\n   unsigned regno;\n   int nregs;\n@@ -56,7 +56,7 @@ class du_head\n   unsigned int target_data_2;\n };\n \n-typedef struct du_head *du_head_p;\n+typedef class du_head *du_head_p;\n \n /* This struct describes a single occurrence of a register.  */\n struct du_chain\n@@ -82,7 +82,7 @@ struct operand_rr_info\n   /* Holds either the chain for the operand itself, or for the registers in\n      a memory operand.  */\n   struct du_chain *chains[MAX_REGS_PER_ADDRESS];\n-  struct du_head *heads[MAX_REGS_PER_ADDRESS];\n+  class du_head *heads[MAX_REGS_PER_ADDRESS];\n };\n \n /* A struct to hold a vector of operand_rr_info structures describing the"}, {"sha": "eb49771249838cb59b3d4d71f2ed27b0479595f2", "filename": "gcc/reload.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -282,11 +282,11 @@ class insn_chain\n {\n public:\n   /* Links to the neighbor instructions.  */\n-  struct insn_chain *next, *prev;\n+  class insn_chain *next, *prev;\n \n   /* Link through a chains set up by calculate_needs_all_insns, containing\n      all insns that need reloading.  */\n-  struct insn_chain *next_need_reload;\n+  class insn_chain *next_need_reload;\n \n   /* The rtx of the insn.  */\n   rtx_insn *insn;\n@@ -320,10 +320,10 @@ class insn_chain\n \n /* A chain of insn_chain structures to describe all non-note insns in\n    a function.  */\n-extern struct insn_chain *reload_insn_chain;\n+extern class insn_chain *reload_insn_chain;\n \n /* Allocate a new insn_chain structure.  */\n-extern struct insn_chain *new_insn_chain (void);\n+extern class insn_chain *new_insn_chain (void);\n #endif\n \n #if defined SET_HARD_REG_BIT"}, {"sha": "38ee356a791dd917df1c971bd40c5f31400797a5", "filename": "gcc/reload1.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -243,14 +243,14 @@ static char *reload_insn_firstobj;\n \n /* List of insn_chain instructions, one for every insn that reload needs to\n    examine.  */\n-struct insn_chain *reload_insn_chain;\n+class insn_chain *reload_insn_chain;\n \n /* TRUE if we potentially left dead insns in the insn stream and want to\n    run DCE immediately after reload, FALSE otherwise.  */\n static bool need_dce;\n \n /* List of all insns needing reloads.  */\n-static struct insn_chain *insns_need_reload;\n+static class insn_chain *insns_need_reload;\n \f\n /* This structure is used to record information about register eliminations.\n    Each array entry describes one possible way of eliminating a register\n@@ -336,10 +336,10 @@ static int num_labels;\n \f\n static void replace_pseudos_in (rtx *, machine_mode, rtx);\n static void maybe_fix_stack_asms (void);\n-static void copy_reloads (struct insn_chain *);\n+static void copy_reloads (class insn_chain *);\n static void calculate_needs_all_insns (int);\n-static int find_reg (struct insn_chain *, int);\n-static void find_reload_regs (struct insn_chain *);\n+static int find_reg (class insn_chain *, int);\n+static void find_reload_regs (class insn_chain *);\n static void select_reload_regs (void);\n static void delete_caller_save_insns (void);\n \n@@ -368,7 +368,7 @@ static void spill_hard_reg (unsigned int, int);\n static int finish_spills (int);\n static void scan_paradoxical_subregs (rtx);\n static void count_pseudo (int);\n-static void order_regs_for_reload (struct insn_chain *);\n+static void order_regs_for_reload (class insn_chain *);\n static void reload_as_needed (int);\n static void forget_old_reloads_1 (rtx, const_rtx, void *);\n static void forget_marked_reloads (regset);\n@@ -382,19 +382,19 @@ static int reload_reg_free_for_value_p (int, int, int, enum reload_type,\n \t\t\t\t\trtx, rtx, int, int);\n static int free_for_value_p (int, machine_mode, int, enum reload_type,\n \t\t\t     rtx, rtx, int, int);\n-static int allocate_reload_reg (struct insn_chain *, int, int);\n+static int allocate_reload_reg (class insn_chain *, int, int);\n static int conflicts_with_override (rtx);\n static void failed_reload (rtx_insn *, int);\n static int set_reload_reg (int, int);\n-static void choose_reload_regs_init (struct insn_chain *, rtx *);\n-static void choose_reload_regs (struct insn_chain *);\n-static void emit_input_reload_insns (struct insn_chain *, struct reload *,\n+static void choose_reload_regs_init (class insn_chain *, rtx *);\n+static void choose_reload_regs (class insn_chain *);\n+static void emit_input_reload_insns (class insn_chain *, struct reload *,\n \t\t\t\t     rtx, int);\n-static void emit_output_reload_insns (struct insn_chain *, struct reload *,\n+static void emit_output_reload_insns (class insn_chain *, struct reload *,\n \t\t\t\t      int);\n-static void do_input_reload (struct insn_chain *, struct reload *, int);\n-static void do_output_reload (struct insn_chain *, struct reload *, int);\n-static void emit_reload_insns (struct insn_chain *);\n+static void do_input_reload (class insn_chain *, struct reload *, int);\n+static void do_output_reload (class insn_chain *, struct reload *, int);\n+static void emit_reload_insns (class insn_chain *);\n static void delete_output_reload (rtx_insn *, int, int, rtx);\n static void delete_address_reloads (rtx_insn *, rtx_insn *);\n static void delete_address_reloads_1 (rtx_insn *, rtx, rtx_insn *);\n@@ -467,17 +467,17 @@ init_reload (void)\n }\n \n /* List of insn chains that are currently unused.  */\n-static struct insn_chain *unused_insn_chains = 0;\n+static class insn_chain *unused_insn_chains = 0;\n \n /* Allocate an empty insn_chain structure.  */\n-struct insn_chain *\n+class insn_chain *\n new_insn_chain (void)\n {\n-  struct insn_chain *c;\n+  class insn_chain *c;\n \n   if (unused_insn_chains == 0)\n     {\n-      c = XOBNEW (&reload_obstack, struct insn_chain);\n+      c = XOBNEW (&reload_obstack, class insn_chain);\n       INIT_REG_SET (&c->live_throughout);\n       INIT_REG_SET (&c->dead_or_set);\n     }\n@@ -1315,7 +1315,7 @@ maybe_fix_stack_asms (void)\n #ifdef STACK_REGS\n   const char *constraints[MAX_RECOG_OPERANDS];\n   machine_mode operand_mode[MAX_RECOG_OPERANDS];\n-  struct insn_chain *chain;\n+  class insn_chain *chain;\n \n   for (chain = reload_insn_chain; chain != 0; chain = chain->next)\n     {\n@@ -1414,7 +1414,7 @@ maybe_fix_stack_asms (void)\n /* Copy the global variables n_reloads and rld into the corresponding elts\n    of CHAIN.  */\n static void\n-copy_reloads (struct insn_chain *chain)\n+copy_reloads (class insn_chain *chain)\n {\n   chain->n_reloads = n_reloads;\n   chain->rld = XOBNEWVEC (&reload_obstack, struct reload, n_reloads);\n@@ -1428,8 +1428,8 @@ copy_reloads (struct insn_chain *chain)\n static void\n calculate_needs_all_insns (int global)\n {\n-  struct insn_chain **pprev_reload = &insns_need_reload;\n-  struct insn_chain *chain, *next = 0;\n+  class insn_chain **pprev_reload = &insns_need_reload;\n+  class insn_chain *chain, *next = 0;\n \n   something_needs_elimination = 0;\n \n@@ -1725,7 +1725,7 @@ count_pseudo (int reg)\n    contents of BAD_SPILL_REGS for the insn described by CHAIN.  */\n \n static void\n-order_regs_for_reload (struct insn_chain *chain)\n+order_regs_for_reload (class insn_chain *chain)\n {\n   unsigned i;\n   HARD_REG_SET used_by_pseudos;\n@@ -1809,7 +1809,7 @@ count_spilled_pseudo (int spilled, int spilled_nregs, int reg)\n /* Find reload register to use for reload number ORDER.  */\n \n static int\n-find_reg (struct insn_chain *chain, int order)\n+find_reg (class insn_chain *chain, int order)\n {\n   int rnum = reload_order[order];\n   struct reload *rl = rld + rnum;\n@@ -1954,7 +1954,7 @@ find_reg (struct insn_chain *chain, int order)\n    for a smaller class even though it belongs to that class.  */\n \n static void\n-find_reload_regs (struct insn_chain *chain)\n+find_reload_regs (class insn_chain *chain)\n {\n   int i;\n \n@@ -2016,7 +2016,7 @@ find_reload_regs (struct insn_chain *chain)\n static void\n select_reload_regs (void)\n {\n-  struct insn_chain *chain;\n+  class insn_chain *chain;\n \n   /* Try to satisfy the needs for each insn.  */\n   for (chain = insns_need_reload; chain != 0;\n@@ -2029,13 +2029,13 @@ select_reload_regs (void)\n static void\n delete_caller_save_insns (void)\n {\n-  struct insn_chain *c = reload_insn_chain;\n+  class insn_chain *c = reload_insn_chain;\n \n   while (c != 0)\n     {\n       while (c != 0 && c->is_caller_save_insn)\n \t{\n-\t  struct insn_chain *next = c->next;\n+\t  class insn_chain *next = c->next;\n \t  rtx_insn *insn = c->insn;\n \n \t  if (c == reload_insn_chain)\n@@ -4194,7 +4194,7 @@ spill_hard_reg (unsigned int regno, int cant_eliminate)\n static int\n finish_spills (int global)\n {\n-  struct insn_chain *chain;\n+  class insn_chain *chain;\n   int something_changed = 0;\n   unsigned i;\n   reg_set_iterator rsi;\n@@ -4459,7 +4459,7 @@ fixup_eh_region_note (rtx_insn *insn, rtx_insn *prev, rtx_insn *next)\n static void\n reload_as_needed (int live_known)\n {\n-  struct insn_chain *chain;\n+  class insn_chain *chain;\n #if AUTO_INC_DEC\n   int i;\n #endif\n@@ -6092,7 +6092,7 @@ set_reload_reg (int i, int r)\n    we didn't change anything.  */\n \n static int\n-allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n+allocate_reload_reg (class insn_chain *chain ATTRIBUTE_UNUSED, int r,\n \t\t     int last_reload)\n {\n   int i, pass, count;\n@@ -6223,7 +6223,7 @@ allocate_reload_reg (struct insn_chain *chain ATTRIBUTE_UNUSED, int r,\n    is the array we use to restore the reg_rtx field for every reload.  */\n \n static void\n-choose_reload_regs_init (struct insn_chain *chain, rtx *save_reload_reg_rtx)\n+choose_reload_regs_init (class insn_chain *chain, rtx *save_reload_reg_rtx)\n {\n   int i;\n \n@@ -6324,7 +6324,7 @@ compute_reload_subreg_offset (machine_mode outermode,\n    finding a reload reg in the proper class.  */\n \n static void\n-choose_reload_regs (struct insn_chain *chain)\n+choose_reload_regs (class insn_chain *chain)\n {\n   rtx_insn *insn = chain->insn;\n   int i, j;\n@@ -7113,7 +7113,7 @@ reload_adjust_reg_for_icode (rtx *reload_reg, rtx alt_reload_reg,\n    has the number J.  OLD contains the value to be used as input.  */\n \n static void\n-emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n+emit_input_reload_insns (class insn_chain *chain, struct reload *rl,\n \t\t\t rtx old, int j)\n {\n   rtx_insn *insn = chain->insn;\n@@ -7573,7 +7573,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n /* Generate insns to for the output reload RL, which is for the insn described\n    by CHAIN and has the number J.  */\n static void\n-emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n+emit_output_reload_insns (class insn_chain *chain, struct reload *rl,\n \t\t\t  int j)\n {\n   rtx reloadreg;\n@@ -7779,7 +7779,7 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n /* Do input reloading for reload RL, which is for the insn described by CHAIN\n    and has the number J.  */\n static void\n-do_input_reload (struct insn_chain *chain, struct reload *rl, int j)\n+do_input_reload (class insn_chain *chain, struct reload *rl, int j)\n {\n   rtx_insn *insn = chain->insn;\n   rtx old = (rl->in && MEM_P (rl->in)\n@@ -7880,7 +7880,7 @@ do_input_reload (struct insn_chain *chain, struct reload *rl, int j)\n    ??? At some point we need to support handling output reloads of\n    JUMP_INSNs or insns that set cc0.  */\n static void\n-do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n+do_output_reload (class insn_chain *chain, struct reload *rl, int j)\n {\n   rtx note, old;\n   rtx_insn *insn = chain->insn;\n@@ -7986,7 +7986,7 @@ inherit_piecemeal_p (int dest ATTRIBUTE_UNUSED,\n /* Output insns to reload values in and out of the chosen reload regs.  */\n \n static void\n-emit_reload_insns (struct insn_chain *chain)\n+emit_reload_insns (class insn_chain *chain)\n {\n   rtx_insn *insn = chain->insn;\n "}, {"sha": "039ab05f9510023ae27e4c7b2d0ae61abb9d25a7", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -210,7 +210,7 @@ union rtunion\n   tree rt_tree;\n   basic_block rt_bb;\n   mem_attrs *rt_mem;\n-  struct constant_descriptor_rtx *rt_constant;\n+  class constant_descriptor_rtx *rt_constant;\n   struct dw_cfi_node *rt_cfi;\n };\n \n@@ -3726,7 +3726,7 @@ struct GTY(()) target_rtl {\n   rtx x_static_reg_base_value[FIRST_PSEUDO_REGISTER];\n \n   /* The default memory attributes for each mode.  */\n-  struct mem_attrs *x_mode_mem_attrs[(int) MAX_MACHINE_MODE];\n+  class mem_attrs *x_mode_mem_attrs[(int) MAX_MACHINE_MODE];\n \n   /* Track if RTL has been initialized.  */\n   bool target_specific_initialized;\n@@ -3760,10 +3760,10 @@ extern struct target_rtl *this_target_rtl;\n \n #ifndef GENERATOR_FILE\n /* Return the attributes of a MEM rtx.  */\n-static inline const struct mem_attrs *\n+static inline const class mem_attrs *\n get_mem_attrs (const_rtx x)\n {\n-  struct mem_attrs *attrs;\n+  class mem_attrs *attrs;\n \n   attrs = MEM_ATTRS (x);\n   if (!attrs)"}, {"sha": "00ade87283223798038e58c37e9138fe483de5a1", "filename": "gcc/sanopt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -354,7 +354,7 @@ maybe_get_dominating_check (auto_vec<gimple *> &v)\n /* Optimize away redundant UBSAN_NULL calls.  */\n \n static bool\n-maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n+maybe_optimize_ubsan_null_ifn (class sanopt_ctx *ctx, gimple *stmt)\n {\n   gcc_assert (gimple_call_num_args (stmt) == 3);\n   tree ptr = gimple_call_arg (stmt, 0);\n@@ -591,7 +591,7 @@ maybe_optimize_ubsan_ptr_ifn (sanopt_ctx *ctx, gimple *stmt)\n    when we can actually optimize.  */\n \n static bool\n-maybe_optimize_ubsan_vptr_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n+maybe_optimize_ubsan_vptr_ifn (class sanopt_ctx *ctx, gimple *stmt)\n {\n   gcc_assert (gimple_call_num_args (stmt) == 5);\n   sanopt_tree_triplet triplet;\n@@ -695,7 +695,7 @@ can_remove_asan_check (auto_vec<gimple *> &v, tree len, basic_block bb)\n /* Optimize away redundant ASAN_CHECK calls.  */\n \n static bool\n-maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n+maybe_optimize_asan_check_ifn (class sanopt_ctx *ctx, gimple *stmt)\n {\n   gcc_assert (gimple_call_num_args (stmt) == 4);\n   tree ptr = gimple_call_arg (stmt, 1);\n@@ -768,7 +768,7 @@ maybe_optimize_asan_check_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n    anything anymore.  CTX is a sanopt context.  */\n \n static void\n-sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n+sanopt_optimize_walker (basic_block bb, class sanopt_ctx *ctx)\n {\n   basic_block son;\n   gimple_stmt_iterator gsi;\n@@ -887,7 +887,7 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n static int\n sanopt_optimize (function *fun, bool *contains_asan_mark)\n {\n-  struct sanopt_ctx ctx;\n+  class sanopt_ctx ctx;\n   ctx.asan_num_accesses = 0;\n   ctx.contains_asan_mark = false;\n "}, {"sha": "5cb4a462ce9819226ba3c249991cf246ddd1b431", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -475,16 +475,16 @@ static int deps_may_trap_p (const_rtx);\n static void add_dependence_1 (rtx_insn *, rtx_insn *, enum reg_note);\n static void add_dependence_list (rtx_insn *, rtx_insn_list *, int,\n \t\t\t\t enum reg_note, bool);\n-static void add_dependence_list_and_free (struct deps_desc *, rtx_insn *,\n+static void add_dependence_list_and_free (class deps_desc *, rtx_insn *,\n \t\t\t\t\t  rtx_insn_list **, int, enum reg_note,\n \t\t\t\t\t  bool);\n static void delete_all_dependences (rtx_insn *);\n static void chain_to_prev_insn (rtx_insn *);\n \n-static void flush_pending_lists (struct deps_desc *, rtx_insn *, int, int);\n-static void sched_analyze_1 (struct deps_desc *, rtx, rtx_insn *);\n-static void sched_analyze_2 (struct deps_desc *, rtx, rtx_insn *);\n-static void sched_analyze_insn (struct deps_desc *, rtx, rtx_insn *);\n+static void flush_pending_lists (class deps_desc *, rtx_insn *, int, int);\n+static void sched_analyze_1 (class deps_desc *, rtx, rtx_insn *);\n+static void sched_analyze_2 (class deps_desc *, rtx, rtx_insn *);\n+static void sched_analyze_insn (class deps_desc *, rtx, rtx_insn *);\n \n static bool sched_has_condition_p (const rtx_insn *);\n static int conditions_mutex_p (const_rtx, const_rtx, bool, bool);\n@@ -1574,7 +1574,7 @@ add_dependence_list (rtx_insn *insn, rtx_insn_list *list, int uncond,\n    newly created dependencies.  */\n \n static void\n-add_dependence_list_and_free (struct deps_desc *deps, rtx_insn *insn,\n+add_dependence_list_and_free (class deps_desc *deps, rtx_insn *insn,\n \t\t\t      rtx_insn_list **listp,\n                               int uncond, enum reg_note dep_type, bool hard)\n {\n@@ -1708,7 +1708,7 @@ chain_to_prev_insn (rtx_insn *insn)\n    so that we can do memory aliasing on it.  */\n \n static void\n-add_insn_mem_dependence (struct deps_desc *deps, bool read_p,\n+add_insn_mem_dependence (class deps_desc *deps, bool read_p,\n \t\t\t rtx_insn *insn, rtx mem)\n {\n   rtx_insn_list **insn_list;\n@@ -1749,7 +1749,7 @@ add_insn_mem_dependence (struct deps_desc *deps, bool read_p,\n    dependencies for a read operation, similarly with FOR_WRITE.  */\n \n static void\n-flush_pending_lists (struct deps_desc *deps, rtx_insn *insn, int for_read,\n+flush_pending_lists (class deps_desc *deps, rtx_insn *insn, int for_read,\n \t\t     int for_write)\n {\n   if (for_write)\n@@ -1953,7 +1953,7 @@ create_insn_reg_set (int regno, rtx insn)\n \n /* Set up insn register uses for INSN and dependency context DEPS.  */\n static void\n-setup_insn_reg_uses (struct deps_desc *deps, rtx_insn *insn)\n+setup_insn_reg_uses (class deps_desc *deps, rtx_insn *insn)\n {\n   unsigned i;\n   reg_set_iterator rsi;\n@@ -2245,7 +2245,7 @@ static bool can_start_lhs_rhs_p;\n /* Extend reg info for the deps context DEPS given that\n    we have just generated a register numbered REGNO.  */\n static void\n-extend_deps_reg_info (struct deps_desc *deps, int regno)\n+extend_deps_reg_info (class deps_desc *deps, int regno)\n {\n   int max_regno = regno + 1;\n \n@@ -2294,7 +2294,7 @@ maybe_extend_reg_info_p (void)\n    CLOBBER, PRE_DEC, POST_DEC, PRE_INC, POST_INC or USE.  */\n \n static void\n-sched_analyze_reg (struct deps_desc *deps, int regno, machine_mode mode,\n+sched_analyze_reg (class deps_desc *deps, int regno, machine_mode mode,\n \t\t   enum rtx_code ref, rtx_insn *insn)\n {\n   /* We could emit new pseudos in renaming.  Extend the reg structures.  */\n@@ -2382,7 +2382,7 @@ sched_analyze_reg (struct deps_desc *deps, int regno, machine_mode mode,\n    destination of X, and reads of everything mentioned.  */\n \n static void\n-sched_analyze_1 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n+sched_analyze_1 (class deps_desc *deps, rtx x, rtx_insn *insn)\n {\n   rtx dest = XEXP (x, 0);\n   enum rtx_code code = GET_CODE (x);\n@@ -2556,7 +2556,7 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n \n /* Analyze the uses of memory and registers in rtx X in INSN.  */\n static void\n-sched_analyze_2 (struct deps_desc *deps, rtx x, rtx_insn *insn)\n+sched_analyze_2 (class deps_desc *deps, rtx x, rtx_insn *insn)\n {\n   int i;\n   int j;\n@@ -2890,7 +2890,7 @@ get_implicit_reg_pending_clobbers (HARD_REG_SET *temp, rtx_insn *insn)\n \n /* Analyze an INSN with pattern X to find all dependencies.  */\n static void\n-sched_analyze_insn (struct deps_desc *deps, rtx x, rtx_insn *insn)\n+sched_analyze_insn (class deps_desc *deps, rtx x, rtx_insn *insn)\n {\n   RTX_CODE code = GET_CODE (x);\n   rtx link;\n@@ -3648,7 +3648,7 @@ chain_to_prev_insn_p (rtx_insn *insn)\n \n /* Analyze INSN with DEPS as a context.  */\n void\n-deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n+deps_analyze_insn (class deps_desc *deps, rtx_insn *insn)\n {\n   if (sched_deps_info->start_insn)\n     sched_deps_info->start_insn (insn);\n@@ -3815,7 +3815,7 @@ deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n \n /* Initialize DEPS for the new block beginning with HEAD.  */\n void\n-deps_start_bb (struct deps_desc *deps, rtx_insn *head)\n+deps_start_bb (class deps_desc *deps, rtx_insn *head)\n {\n   gcc_assert (!deps->readonly);\n \n@@ -3834,7 +3834,7 @@ deps_start_bb (struct deps_desc *deps, rtx_insn *head)\n /* Analyze every insn between HEAD and TAIL inclusive, creating backward\n    dependencies for each insn.  */\n void\n-sched_analyze (struct deps_desc *deps, rtx_insn *head, rtx_insn *tail)\n+sched_analyze (class deps_desc *deps, rtx_insn *head, rtx_insn *tail)\n {\n   rtx_insn *insn;\n \n@@ -3928,10 +3928,10 @@ sched_free_deps (rtx_insn *head, rtx_insn *tail, bool resolved_p)\n \f\n /* Initialize variables for region data dependence analysis.\n    When LAZY_REG_LAST is true, do not allocate reg_last array\n-   of struct deps_desc immediately.  */\n+   of class deps_desc immediately.  */\n \n void\n-init_deps (struct deps_desc *deps, bool lazy_reg_last)\n+init_deps (class deps_desc *deps, bool lazy_reg_last)\n {\n   int max_reg = (reload_completed ? FIRST_PSEUDO_REGISTER : max_reg_num ());\n \n@@ -3968,7 +3968,7 @@ init_deps (struct deps_desc *deps, bool lazy_reg_last)\n /* Init only reg_last field of DEPS, which was not allocated before as\n    we inited DEPS lazily.  */\n void\n-init_deps_reg_last (struct deps_desc *deps)\n+init_deps_reg_last (class deps_desc *deps)\n {\n   gcc_assert (deps && deps->max_reg > 0);\n   gcc_assert (deps->reg_last == NULL);\n@@ -3980,7 +3980,7 @@ init_deps_reg_last (struct deps_desc *deps)\n /* Free insn lists found in DEPS.  */\n \n void\n-free_deps (struct deps_desc *deps)\n+free_deps (class deps_desc *deps)\n {\n   unsigned i;\n   reg_set_iterator rsi;\n@@ -4028,7 +4028,7 @@ free_deps (struct deps_desc *deps)\n \n /* Remove INSN from dependence contexts DEPS.  */\n void\n-remove_from_deps (struct deps_desc *deps, rtx_insn *insn)\n+remove_from_deps (class deps_desc *deps, rtx_insn *insn)\n {\n   int removed;\n   unsigned i;"}, {"sha": "a594b49ec66e554eea093b6dabcc08125d0d867a", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -472,7 +472,7 @@ basic_block\n schedule_ebb (rtx_insn *head, rtx_insn *tail, bool modulo_scheduling)\n {\n   basic_block first_bb, target_bb;\n-  struct deps_desc tmp_deps;\n+  class deps_desc tmp_deps;\n   bool success;\n \n   /* Blah.  We should fix the rest of the code not to get confused by"}, {"sha": "fca1bcfe7f01c36c68f6a53e5741f45e3312d817", "filename": "gcc/sched-int.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -571,7 +571,7 @@ class deps_desc\n   BOOL_BITFIELD readonly : 1;\n };\n \n-typedef struct deps_desc *deps_t;\n+typedef class deps_desc *deps_t;\n \n /* This structure holds some state of the current scheduling pass, and\n    contains some function pointers that abstract out some of the non-generic\n@@ -1347,14 +1347,14 @@ extern bool sched_insns_conditions_mutex_p (const rtx_insn *,\n \t\t\t\t\t    const rtx_insn *);\n extern bool sched_insn_is_legitimate_for_speculation_p (const rtx_insn *, ds_t);\n extern void add_dependence (rtx_insn *, rtx_insn *, enum reg_note);\n-extern void sched_analyze (struct deps_desc *, rtx_insn *, rtx_insn *);\n-extern void init_deps (struct deps_desc *, bool);\n-extern void init_deps_reg_last (struct deps_desc *);\n-extern void free_deps (struct deps_desc *);\n+extern void sched_analyze (class deps_desc *, rtx_insn *, rtx_insn *);\n+extern void init_deps (class deps_desc *, bool);\n+extern void init_deps_reg_last (class deps_desc *);\n+extern void free_deps (class deps_desc *);\n extern void init_deps_global (void);\n extern void finish_deps_global (void);\n-extern void deps_analyze_insn (struct deps_desc *, rtx_insn *);\n-extern void remove_from_deps (struct deps_desc *, rtx_insn *);\n+extern void deps_analyze_insn (class deps_desc *, rtx_insn *);\n+extern void remove_from_deps (class deps_desc *, rtx_insn *);\n extern void init_insn_reg_pressure_info (rtx_insn *);\n extern void get_implicit_reg_pending_clobbers (HARD_REG_SET *, rtx_insn *);\n \n@@ -1377,7 +1377,7 @@ extern void haifa_note_reg_use (int);\n \n extern void maybe_extend_reg_info_p (void);\n \n-extern void deps_start_bb (struct deps_desc *, rtx_insn *);\n+extern void deps_start_bb (class deps_desc *, rtx_insn *);\n extern enum reg_note ds_to_dt (ds_t);\n \n extern bool deps_pools_are_empty_p (void);\n@@ -1509,7 +1509,7 @@ extern void dump_rgn_dependencies_dot (const char *);\n extern void free_rgn_deps (void);\n extern int contributes_to_priority (rtx_insn *, rtx_insn *);\n extern void extend_rgns (int *, int *, sbitmap, int *);\n-extern void deps_join (struct deps_desc *, struct deps_desc *);\n+extern void deps_join (class deps_desc *, class deps_desc *);\n \n extern void rgn_setup_common_sched_info (void);\n extern void rgn_setup_sched_infos (void);"}, {"sha": "59ee6a0a57cf8895fdcbbe962ccc4bf51cca2b6c", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -248,7 +248,7 @@ static void compute_block_dependences (int);\n static void schedule_region (int);\n static void concat_insn_mem_list (rtx_insn_list *, rtx_expr_list *,\n \t\t\t\t  rtx_insn_list **, rtx_expr_list **);\n-static void propagate_deps (int, struct deps_desc *);\n+static void propagate_deps (int, class deps_desc *);\n static void free_pending_lists (void);\n \n /* Functions for construction of the control flow graph.  */\n@@ -2583,7 +2583,7 @@ add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n    the variables of its predecessors.  When the analysis for a bb completes,\n    we save the contents to the corresponding bb_deps[bb] variable.  */\n \n-static struct deps_desc *bb_deps;\n+static class deps_desc *bb_deps;\n \n static void\n concat_insn_mem_list (rtx_insn_list *copy_insns,\n@@ -2608,7 +2608,7 @@ concat_insn_mem_list (rtx_insn_list *copy_insns,\n \n /* Join PRED_DEPS to the SUCC_DEPS.  */\n void\n-deps_join (struct deps_desc *succ_deps, struct deps_desc *pred_deps)\n+deps_join (class deps_desc *succ_deps, class deps_desc *pred_deps)\n {\n   unsigned reg;\n   reg_set_iterator rsi;\n@@ -2670,7 +2670,7 @@ deps_join (struct deps_desc *succ_deps, struct deps_desc *pred_deps)\n /* After computing the dependencies for block BB, propagate the dependencies\n    found in TMP_DEPS to the successors of the block.  */\n static void\n-propagate_deps (int bb, struct deps_desc *pred_deps)\n+propagate_deps (int bb, class deps_desc *pred_deps)\n {\n   basic_block block = BASIC_BLOCK_FOR_FN (cfun, BB_TO_BLOCK (bb));\n   edge_iterator ei;\n@@ -2727,7 +2727,7 @@ static void\n compute_block_dependences (int bb)\n {\n   rtx_insn *head, *tail;\n-  struct deps_desc tmp_deps;\n+  class deps_desc tmp_deps;\n \n   tmp_deps = bb_deps[bb];\n \n@@ -3351,7 +3351,7 @@ sched_rgn_compute_dependencies (int rgn)\n       init_deps_global ();\n \n       /* Initializations for region data dependence analysis.  */\n-      bb_deps = XNEWVEC (struct deps_desc, current_nr_blocks);\n+      bb_deps = XNEWVEC (class deps_desc, current_nr_blocks);\n       for (bb = 0; bb < current_nr_blocks; bb++)\n \tinit_deps (bb_deps + bb, false);\n "}, {"sha": "bb8016bb530e5cba0148404357aa58bfb305500e", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -61,7 +61,7 @@ struct succs_info current_succs;\n static struct common_sched_info_def sel_common_sched_info;\n \n /* The loop nest being pipelined.  */\n-struct loop *current_loop_nest;\n+class loop *current_loop_nest;\n \n /* LOOP_NESTS is a vector containing the corresponding loop nest for\n    each region.  */\n@@ -424,7 +424,7 @@ reset_target_context (tc_t tc, bool clean_p)\n }\n \f\n /* Functions to work with dependence contexts.\n-   Dc (aka deps context, aka deps_t, aka struct deps_desc *) is short for dependence\n+   Dc (aka deps context, aka deps_t, aka class deps_desc *) is short for dependence\n    context.  It accumulates information about processed insns to decide if\n    current insn is dependent on the processed ones.  */\n \n@@ -440,7 +440,7 @@ copy_deps_context (deps_t to, deps_t from)\n static deps_t\n alloc_deps_context (void)\n {\n-  return XNEW (struct deps_desc);\n+  return XNEW (class deps_desc);\n }\n \n /* Allocate and initialize dep context.  */\n@@ -2749,7 +2749,7 @@ init_id_from_df (idata_t id, insn_t insn, bool force_unique_p)\n static void\n deps_init_id (idata_t id, insn_t insn, bool force_unique_p)\n {\n-  struct deps_desc _dc, *dc = &_dc;\n+  class deps_desc _dc, *dc = &_dc;\n \n   deps_init_id_data.where = DEPS_IN_NOWHERE;\n   deps_init_id_data.id = id;\n@@ -3390,7 +3390,7 @@ has_dependence_p (expr_t expr, insn_t pred, ds_t **has_dep_pp)\n {\n   int i;\n   ds_t ds;\n-  struct deps_desc *dc;\n+  class deps_desc *dc;\n \n   if (INSN_SIMPLEJUMP_P (pred))\n     /* Unconditional jump is just a transfer of control flow.\n@@ -5397,7 +5397,7 @@ change_loops_latches (basic_block from, basic_block to)\n \n   if (current_loop_nest)\n     {\n-      struct loop *loop;\n+      class loop *loop;\n \n       for (loop = current_loop_nest; loop; loop = loop_outer (loop))\n         if (considered_for_pipelining_p (loop) && loop->latch == from)\n@@ -6002,11 +6002,11 @@ bb_top_order_comparator (const void *x, const void *y)\n /* Create a region for LOOP and return its number.  If we don't want\n    to pipeline LOOP, return -1.  */\n static int\n-make_region_from_loop (struct loop *loop)\n+make_region_from_loop (class loop *loop)\n {\n   unsigned int i;\n   int new_rgn_number = -1;\n-  struct loop *inner;\n+  class loop *inner;\n \n   /* Basic block index, to be assigned to BLOCK_TO_BB.  */\n   int bb_ord_index = 0;\n@@ -6095,9 +6095,9 @@ make_region_from_loop_preheader (vec<basic_block> *&loop_blocks)\n    pipelined before outer loops.  Returns true when a region for LOOP\n    is created.  */\n static bool\n-make_regions_from_loop_nest (struct loop *loop)\n+make_regions_from_loop_nest (class loop *loop)\n {\n-  struct loop *cur_loop;\n+  class loop *cur_loop;\n   int rgn_number;\n \n   /* Traverse all inner nodes of the loop.  */\n@@ -6133,7 +6133,7 @@ sel_init_pipelining (void)\n   recompute_rev_top_order ();\n }\n \n-/* Returns a struct loop for region RGN.  */\n+/* Returns a class loop for region RGN.  */\n loop_p\n get_loop_nest_for_rgn (unsigned int rgn)\n {\n@@ -6147,7 +6147,7 @@ get_loop_nest_for_rgn (unsigned int rgn)\n \n /* True when LOOP was included into pipelining regions.   */\n bool\n-considered_for_pipelining_p (struct loop *loop)\n+considered_for_pipelining_p (class loop *loop)\n {\n   if (loop_depth (loop) == 0)\n     return false;\n@@ -6249,7 +6249,7 @@ make_regions_from_the_rest (void)\n /* Free data structures used in pipelining of loops.  */\n void sel_finish_pipelining (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   /* Release aux fields so we don't free them later by mistake.  */\n   FOR_EACH_LOOP (loop, 0)\n@@ -6324,7 +6324,7 @@ sel_is_loop_preheader_p (basic_block bb)\n {\n   if (current_loop_nest)\n     {\n-      struct loop *outer;\n+      class loop *outer;\n \n       if (preheader_removed)\n         return false;"}, {"sha": "b5824aec36962db27d9117e83c686dfc08ab27ba", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -746,7 +746,7 @@ class _sel_insn_data\n   htab_t transformed_insns;\n \n   /* A context incapsulating this insn.  */\n-  struct deps_desc deps_context;\n+  class deps_desc deps_context;\n \n   /* This field is initialized at the beginning of scheduling and is used\n      to handle sched group instructions.  If it is non-null, then it points\n@@ -775,7 +775,7 @@ class _sel_insn_data\n   BOOL_BITFIELD after_stall_p : 1;\n };\n \n-typedef struct _sel_insn_data sel_insn_data_def;\n+typedef class _sel_insn_data sel_insn_data_def;\n typedef sel_insn_data_def *sel_insn_data_t;\n \n extern vec<sel_insn_data_def> s_i_d;\n@@ -954,7 +954,7 @@ extern vec<sel_region_bb_info_def> sel_region_bb_info;\n extern bitmap_head *forced_ebb_heads;\n \n /* The loop nest being pipelined.  */\n-extern struct loop *current_loop_nest;\n+extern class loop *current_loop_nest;\n \n /* Saves pipelined blocks.  Bitmap is indexed by bb->index.  */\n extern sbitmap bbs_pipelined;\n@@ -1043,7 +1043,7 @@ extern bool in_current_region_p (basic_block);\n static inline bool\n inner_loop_header_p (basic_block bb)\n {\n-  struct loop *inner_loop;\n+  class loop *inner_loop;\n \n   if (!current_loop_nest)\n     return false;\n@@ -1069,7 +1069,7 @@ inner_loop_header_p (basic_block bb)\n \n /* Return exit edges of LOOP, filtering out edges with the same dest bb.  */\n static inline vec<edge> \n-get_loop_exit_edges_unique_dests (const struct loop *loop)\n+get_loop_exit_edges_unique_dests (const class loop *loop)\n {\n   vec<edge> edges = vNULL;\n   struct loop_exit *exit;\n@@ -1142,8 +1142,8 @@ get_all_loop_exits (basic_block bb)\n   /* And now check whether we should skip over inner loop.  */\n   if (inner_loop_header_p (bb))\n     {\n-      struct loop *this_loop;\n-      struct loop *pred_loop = NULL;\n+      class loop *this_loop;\n+      class loop *pred_loop = NULL;\n       int i;\n       unsigned this_depth;\n       edge e;\n@@ -1642,7 +1642,7 @@ extern void sel_init_pipelining (void);\n extern void sel_finish_pipelining (void);\n extern void sel_sched_region (int);\n extern loop_p get_loop_nest_for_rgn (unsigned int);\n-extern bool considered_for_pipelining_p (struct loop *);\n+extern bool considered_for_pipelining_p (class loop *);\n extern void make_region_from_loop_preheader (vec<basic_block> *&);\n extern void sel_add_loop_preheaders (bb_vec_t *);\n extern bool sel_is_loop_preheader_p (basic_block);"}, {"sha": "75b2cd836e1a790d1a007fecaf32b584890b5d94", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -150,7 +150,7 @@ class auto_fix_quotes\n    The following struct describes a particular case within our test\n    matrix.  */\n \n-struct line_table_case;\n+class line_table_case;\n \n /* A class for overriding the global \"line_table\" within a selftest,\n    restoring its value afterwards.  At most one instance of this"}, {"sha": "4b3065a2ee0ffbbf71bb870964232be0f7e4f572", "filename": "gcc/sese.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -149,7 +149,7 @@ sese_build_liveouts (sese_info_p region)\n sese_info_p\n new_sese_info (edge entry, edge exit)\n {\n-  sese_info_p region = XNEW (struct sese_info_t);\n+  sese_info_p region = XNEW (class sese_info_t);\n \n   region->region.entry = entry;\n   region->region.exit = exit;\n@@ -217,10 +217,10 @@ sese_insert_phis_for_liveouts (sese_info_p region, basic_block bb,\n \n /* Returns the outermost loop in SCOP that contains BB.  */\n \n-struct loop *\n+class loop *\n outermost_loop_in_sese_1 (sese_l &region, basic_block bb)\n {\n-  struct loop *nest;\n+  class loop *nest;\n \n   nest = bb->loop_father;\n   while (loop_outer (nest)"}, {"sha": "6a62bb6c9bffb8351267e25de4379d2cf2c6693f", "filename": "gcc/sese.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -101,7 +101,7 @@ typedef class sese_info_t\n extern sese_info_p new_sese_info (edge, edge);\n extern void free_sese_info (sese_info_p);\n extern void sese_insert_phis_for_liveouts (sese_info_p, basic_block, edge, edge);\n-extern struct loop *outermost_loop_in_sese (sese_l &, basic_block);\n+extern class loop *outermost_loop_in_sese (sese_l &, basic_block);\n extern tree scalar_evolution_in_region (const sese_l &, loop_p, tree);\n extern bool scev_analyzable_p (tree, sese_l &);\n extern bool invariant_in_sese_p_rec (tree, const sese_l &, bool *);\n@@ -156,7 +156,7 @@ defined_in_sese_p (tree name, const sese_l &r)\n /* Returns true when LOOP is in REGION.  */\n \n static inline bool\n-loop_in_sese_p (struct loop *loop, const sese_l &region)\n+loop_in_sese_p (class loop *loop, const sese_l &region)\n {\n   return (bb_in_sese_p (loop->header, region)\n \t  && bb_in_sese_p (loop->latch, region));\n@@ -272,7 +272,7 @@ typedef struct gimple_poly_bb\n \n /* Return the innermost loop that contains the basic block GBB.  */\n \n-static inline struct loop *\n+static inline class loop *\n gbb_loop (gimple_poly_bb_p gbb)\n {\n   return GBB_BB (gbb)->loop_father;"}, {"sha": "5418481758c3f6beb5a3ec21ef26d54771029bb2", "filename": "gcc/sreal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -258,7 +258,7 @@ sreal::stream_out (struct output_block *ob)\n /* Read sreal value from IB.  */\n \n sreal\n-sreal::stream_in (struct lto_input_block *ib)\n+sreal::stream_in (class lto_input_block *ib)\n {\n   sreal val;\n   val.m_sig = streamer_read_hwi (ib);"}, {"sha": "cb363d4392a8e3924919930d0d22db806d48a573", "filename": "gcc/sreal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsreal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fsreal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -34,7 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #define SREAL_ABS(v) (v < 0 ? -v: v)\n \n struct output_block;\n-struct lto_input_block;\n+class lto_input_block;\n \n /* Structure for holding a simple real number.  */\n class sreal\n@@ -53,7 +53,7 @@ class sreal\n   int64_t to_int () const;\n   double to_double () const;\n   void stream_out (struct output_block *);\n-  static sreal stream_in (struct lto_input_block *);\n+  static sreal stream_in (class lto_input_block *);\n   sreal operator+ (const sreal &other) const;\n   sreal operator- (const sreal &other) const;\n   sreal operator* (const sreal &other) const;"}, {"sha": "14d158e8e9a7a18fa2e22a24d23c060928d359bd", "filename": "gcc/streamer-hooks.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fstreamer-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fstreamer-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -25,8 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Forward declarations to avoid including unnecessary headers.  */\n struct output_block;\n-struct lto_input_block;\n-struct data_in;\n+class lto_input_block;\n+class data_in;\n \n /* Streamer hooks.  These functions do additional processing as\n    needed by the module.  There are two types of callbacks, those that\n@@ -49,10 +49,10 @@ struct streamer_hooks {\n      to the buffer where to read from and a data_in instance with tables\n      and descriptors needed by the unpickling routines.  It returns the\n      tree instantiated from the stream.  */\n-  tree (*read_tree) (struct lto_input_block *, struct data_in *);\n+  tree (*read_tree) (class lto_input_block *, class data_in *);\n \n   /* [REQ] Called by every streaming routine that needs to read a location.  */\n-  void (*input_location) (location_t *, struct bitpack_d *, struct data_in *);\n+  void (*input_location) (location_t *, struct bitpack_d *, class data_in *);\n \n   /* [REQ] Called by every streaming routine that needs to write a location.  */\n   void (*output_location) (struct output_block *, struct bitpack_d *, location_t);"}, {"sha": "8928fc19fd3461fadd9982cf8810f811aa2e8185", "filename": "gcc/target-globals.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lower-subreg.h\"\n \n #if SWITCHABLE_TARGET\n-struct target_globals default_target_globals = {\n+class target_globals default_target_globals = {\n   &default_target_flag_state,\n   &default_target_regs,\n   &default_target_rtl,\n@@ -61,11 +61,11 @@ struct target_globals default_target_globals = {\n   &default_target_lower_subreg\n };\n \n-struct target_globals *\n+class target_globals *\n save_target_globals (void)\n {\n-  struct target_globals *g = ggc_cleared_alloc <target_globals> ();\n-  g->flag_state = XCNEW (struct target_flag_state);\n+  class target_globals *g = ggc_cleared_alloc <target_globals> ();\n+  g->flag_state = XCNEW (class target_flag_state);\n   g->regs = XCNEW (struct target_regs);\n   g->rtl = ggc_cleared_alloc<target_rtl> ();\n   g->recog = XCNEW (struct target_recog);\n@@ -76,7 +76,7 @@ save_target_globals (void)\n   g->libfuncs = ggc_cleared_alloc<target_libfuncs> ();\n   g->cfgloop = XCNEW (struct target_cfgloop);\n   g->ira = XCNEW (struct target_ira);\n-  g->ira_int = XCNEW (struct target_ira_int);\n+  g->ira_int = XCNEW (class target_ira_int);\n   g->builtins = XCNEW (struct target_builtins);\n   g->gcse = XCNEW (struct target_gcse);\n   g->bb_reorder = XCNEW (struct target_bb_reorder);\n@@ -91,10 +91,10 @@ save_target_globals (void)\n    correctly when a previous function has changed\n    *this_target_optabs.  */\n \n-struct target_globals *\n+class target_globals *\n save_target_globals_default_opts ()\n {\n-  struct target_globals *globals;\n+  class target_globals *globals;\n \n   if (optimization_current_node != optimization_default_node)\n     {"}, {"sha": "ceb216a6a9bf543411e8360a421c860c32a48e5a", "filename": "gcc/target-globals.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define TARGET_GLOBALS_H 1\n \n #if SWITCHABLE_TARGET\n-extern struct target_flag_state *this_target_flag_state;\n+extern class target_flag_state *this_target_flag_state;\n extern struct target_regs *this_target_regs;\n extern struct target_rtl *this_target_rtl;\n extern struct target_recog *this_target_recog;\n@@ -32,7 +32,7 @@ extern struct target_optabs *this_target_optabs;\n extern struct target_libfuncs *this_target_libfuncs;\n extern struct target_cfgloop *this_target_cfgloop;\n extern struct target_ira *this_target_ira;\n-extern struct target_ira_int *this_target_ira_int;\n+extern class target_ira_int *this_target_ira_int;\n extern struct target_builtins *this_target_builtins;\n extern struct target_gcse *this_target_gcse;\n extern struct target_bb_reorder *this_target_bb_reorder;\n@@ -43,7 +43,7 @@ class GTY(()) target_globals {\n public:\n   ~target_globals ();\n \n-  struct target_flag_state *GTY((skip)) flag_state;\n+  class target_flag_state *GTY((skip)) flag_state;\n   struct target_regs *GTY((skip)) regs;\n   struct target_rtl *rtl;\n   struct target_recog *GTY((skip)) recog;\n@@ -54,21 +54,21 @@ class GTY(()) target_globals {\n   struct target_libfuncs *libfuncs;\n   struct target_cfgloop *GTY((skip)) cfgloop;\n   struct target_ira *GTY((skip)) ira;\n-  struct target_ira_int *GTY((skip)) ira_int;\n+  class target_ira_int *GTY((skip)) ira_int;\n   struct target_builtins *GTY((skip)) builtins;\n   struct target_gcse *GTY((skip)) gcse;\n   struct target_bb_reorder *GTY((skip)) bb_reorder;\n   struct target_lower_subreg *GTY((skip)) lower_subreg;\n };\n \n #if SWITCHABLE_TARGET\n-extern struct target_globals default_target_globals;\n+extern class target_globals default_target_globals;\n \n-extern struct target_globals *save_target_globals (void);\n-extern struct target_globals *save_target_globals_default_opts (void);\n+extern class target_globals *save_target_globals (void);\n+extern class target_globals *save_target_globals_default_opts (void);\n \n static inline void\n-restore_target_globals (struct target_globals *g)\n+restore_target_globals (class target_globals *g)\n {\n   this_target_flag_state = g->flag_state;\n   this_target_regs = g->regs;"}, {"sha": "7cc0f37a0d17d095a8b970281336e53eca1e0420", "filename": "gcc/target.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1970,7 +1970,7 @@ DEFHOOK\n  \"non-NULL, it identifies the loop being vectorized; otherwise a single block \"\n  \"is being vectorized.\",\n  void *,\n- (struct loop *loop_info),\n+ (class loop *loop_info),\n  default_init_cost)\n \n /* Target function to record N statements of the given kind using the\n@@ -1987,7 +1987,7 @@ DEFHOOK\n  \"revised.\",\n  unsigned,\n  (void *data, int count, enum vect_cost_for_stmt kind,\n-  struct _stmt_vec_info *stmt_info, int misalign,\n+  class _stmt_vec_info *stmt_info, int misalign,\n   enum vect_cost_model_location where),\n  default_add_stmt_cost)\n \n@@ -2665,7 +2665,7 @@ the loop is to be unrolled. The parameter @var{loop} is a pointer to\\n\\\n the loop, which is going to be checked for unrolling. This target hook\\n\\\n is required only when the target has special constraints like maximum\\n\\\n number of memory accesses.\",\n- unsigned, (unsigned nunroll, struct loop *loop),\n+ unsigned, (unsigned nunroll, class loop *loop),\n  NULL)\n \n /* True if X is a legitimate MODE-mode immediate operand.  */\n@@ -3182,7 +3182,7 @@ DEFHOOK\n   version of this hook assumes the system C library errno location\\\n   is either a declaration of type int or accessed by dereferencing\\\n   a pointer to int.\",\n- bool, (struct ao_ref *ref),\n+ bool, (ao_ref *ref),\n  default_ref_may_alias_errno)\n \n /* Support for named address spaces.  */\n@@ -4243,7 +4243,7 @@ for a particular loop.  The parameter @var{loop} is a pointer to the loop.\\n\\\n This target hook is required only when the target supports low-overhead\\n\\\n loops, and will help ivopts to make some decisions.\\n\\\n The default version of this hook returns false.\",\n- bool, (struct loop *loop),\n+ bool, (class loop *loop),\n  default_predict_doloop_p)\n \n DEFHOOK"}, {"sha": "633e38469a9779ed5991c0768dbc712fbc70d819", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -138,20 +138,20 @@ struct _dep;\n struct ddg;\n \n /* This is defined in cfgloop.h .  */\n-struct loop;\n+class loop;\n \n /* This is defined in ifcvt.h.  */\n struct noce_if_info;\n \n /* This is defined in tree-ssa-alias.h.  */\n-struct ao_ref;\n+class ao_ref;\n \n /* This is defined in tree-vectorizer.h.  */\n-struct _stmt_vec_info;\n+class _stmt_vec_info;\n \n /* These are defined in tree-vect-stmts.c.  */\n-extern tree stmt_vectype (struct _stmt_vec_info *);\n-extern bool stmt_in_inner_loop_p (struct _stmt_vec_info *);\n+extern tree stmt_vectype (class _stmt_vec_info *);\n+extern bool stmt_in_inner_loop_p (class _stmt_vec_info *);\n \n /* Assembler instructions for creating various kinds of integer object.  */\n "}, {"sha": "fa797b445a7335d423b7a6f5ae03dba64af8a0b4", "filename": "gcc/targhooks.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -651,7 +651,7 @@ default_has_ifunc_p (void)\n    if the target can take advantage of it.  */\n \n bool\n-default_predict_doloop_p (struct loop *loop ATTRIBUTE_UNUSED)\n+default_predict_doloop_p (class loop *loop ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n@@ -1366,7 +1366,7 @@ default_empty_mask_is_expensive (unsigned ifn)\n    array of three unsigned ints, set it to zero, and return its address.  */\n \n void *\n-default_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n+default_init_cost (class loop *loop_info ATTRIBUTE_UNUSED)\n {\n   unsigned *cost = XNEWVEC (unsigned, 3);\n   cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n@@ -1379,7 +1379,7 @@ default_init_cost (struct loop *loop_info ATTRIBUTE_UNUSED)\n \n unsigned\n default_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n-\t\t       struct _stmt_vec_info *stmt_info, int misalign,\n+\t\t       class _stmt_vec_info *stmt_info, int misalign,\n \t\t       enum vect_cost_model_location where)\n {\n   unsigned *cost = (unsigned *) data;"}, {"sha": "ca2e37d093b36aa10abd8839236ebe9f92619c1b", "filename": "gcc/targhooks.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -85,7 +85,7 @@ extern bool default_fixed_point_supported_p (void);\n \n extern bool default_has_ifunc_p (void);\n \n-extern bool default_predict_doloop_p (struct loop *);\n+extern bool default_predict_doloop_p (class loop *);\n extern const char * default_invalid_within_doloop (const rtx_insn *);\n \n extern tree default_builtin_vectorized_function (unsigned int, tree, tree);\n@@ -114,9 +114,9 @@ extern machine_mode default_split_reduction (machine_mode);\n extern void default_autovectorize_vector_sizes (vector_sizes *, bool);\n extern opt_machine_mode default_get_mask_mode (poly_uint64, poly_uint64);\n extern bool default_empty_mask_is_expensive (unsigned);\n-extern void *default_init_cost (struct loop *);\n+extern void *default_init_cost (class loop *);\n extern unsigned default_add_stmt_cost (void *, int, enum vect_cost_for_stmt,\n-\t\t\t\t       struct _stmt_vec_info *, int,\n+\t\t\t\t       class _stmt_vec_info *, int,\n \t\t\t\t       enum vect_cost_model_location);\n extern void default_finish_cost (void *, unsigned *, unsigned *, unsigned *);\n extern void default_destroy_cost_data (void *);\n@@ -188,7 +188,7 @@ extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);\n extern bool default_valid_pointer_mode (scalar_int_mode);\n-extern bool default_ref_may_alias_errno (struct ao_ref *);\n+extern bool default_ref_may_alias_errno (class ao_ref *);\n extern scalar_int_mode default_addr_space_pointer_mode (addr_space_t);\n extern scalar_int_mode default_addr_space_address_mode (addr_space_t);\n extern bool default_addr_space_valid_pointer_mode (scalar_int_mode,"}, {"sha": "2567fe2e697c2ec9156935fe32ab6e9f5ff8a6e8", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -159,9 +159,9 @@ HOST_WIDE_INT random_seed;\n    the support provided depends on the backend.  */\n rtx stack_limit_rtx;\n \n-struct target_flag_state default_target_flag_state;\n+class target_flag_state default_target_flag_state;\n #if SWITCHABLE_TARGET\n-struct target_flag_state *this_target_flag_state = &default_target_flag_state;\n+class target_flag_state *this_target_flag_state = &default_target_flag_state;\n #else\n #define this_target_flag_state (&default_target_flag_state)\n #endif"}, {"sha": "976cf3c6cf67765c508b823ce695ba5e4851508b", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -675,7 +675,7 @@ aff_combination_mult (aff_tree *c1, aff_tree *c2, aff_tree *r)\n    element exists.  If IDX is not NULL, it is set to the index of VAL in\n    COMB.  */\n \n-static struct aff_comb_elt *\n+static class aff_comb_elt *\n aff_combination_find_elt (aff_tree *comb, tree val, unsigned *idx)\n {\n   unsigned i;\n@@ -716,7 +716,7 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n   tree e;\n   gimple *def;\n   widest_int scale;\n-  struct name_expansion *exp;\n+  class name_expansion *exp;\n \n   aff_combination_zero (&to_add, comb->type);\n   for (i = 0; i < comb->n; i++)\n@@ -795,7 +795,7 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n \t    default:\n \t      continue;\n \t    }\n-\t  exp = XNEW (struct name_expansion);\n+\t  exp = XNEW (class name_expansion);\n \t  exp->in_progress = 1;\n \t  if (!*cache)\n \t    *cache = new hash_map<tree, name_expansion *>;\n@@ -932,7 +932,7 @@ aff_combination_constant_multiple_p (aff_tree *val, aff_tree *div,\n \n   for (i = 0; i < div->n; i++)\n     {\n-      struct aff_comb_elt *elt\n+      class aff_comb_elt *elt\n \t      = aff_combination_find_elt (val, div->elts[i].val, NULL);\n       if (!elt)\n \treturn false;"}, {"sha": "216482016e2a58910e14a0a017dce2ffa2a41210", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -56,15 +56,15 @@ class aff_tree\n \n      The coefficients are always sign extended from the precision of TYPE\n      (regardless of signedness of TYPE).  */\n-  struct aff_comb_elt elts[MAX_AFF_ELTS];\n+  class aff_comb_elt elts[MAX_AFF_ELTS];\n \n   /* Remainder of the expression.  Usually NULL, used only if there are more\n      than MAX_AFF_ELTS elements.  Type of REST will be either sizetype for\n      TYPE of POINTER_TYPEs or TYPE.  */\n   tree rest;\n };\n \n-struct name_expansion;\n+class name_expansion;\n \n void aff_combination_const (aff_tree *, tree, const poly_widest_int &);\n void aff_combination_elt (aff_tree *, tree, tree);"}, {"sha": "5c67d024608c1c45b945b1b47763a19bd39f59ad", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -256,7 +256,7 @@ build_gimple_cfg (gimple_seq seq)\n    come immediately before the condition in BB, if any.  */\n \n static void\n-replace_loop_annotate_in_block (basic_block bb, struct loop *loop)\n+replace_loop_annotate_in_block (basic_block bb, class loop *loop)\n {\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n   gimple *stmt = gsi_stmt (gsi);\n@@ -311,7 +311,7 @@ replace_loop_annotate_in_block (basic_block bb, struct loop *loop)\n static void\n replace_loop_annotate (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n   gimple *stmt;\n@@ -1996,7 +1996,7 @@ replace_uses_by (tree name, tree val)\n   /* Also update the trees stored in loop structures.  */\n   if (current_loops)\n     {\n-      struct loop *loop;\n+      class loop *loop;\n \n       FOR_EACH_LOOP (loop, 0)\n \t{\n@@ -2223,7 +2223,7 @@ remove_bb (basic_block bb)\n \n   if (current_loops)\n     {\n-      struct loop *loop = bb->loop_father;\n+      class loop *loop = bb->loop_father;\n \n       /* If a loop gets removed, clean up the information associated\n \t with it.  */\n@@ -2547,7 +2547,7 @@ dump_cfg_stats (FILE *file)\n   num_edges = 0;\n   FOR_EACH_BB_FN (bb, cfun)\n     num_edges += EDGE_COUNT (bb->succs);\n-  size = num_edges * sizeof (struct edge_def);\n+  size = num_edges * sizeof (class edge_def);\n   total += size;\n   fprintf (file, fmt_str_2, \"Edges\", num_edges, SIZE_AMOUNT (size));\n \n@@ -6383,7 +6383,7 @@ gimple_duplicate_sese_region (edge entry, edge exit,\n {\n   unsigned i;\n   bool free_region_copy = false, copying_header = false;\n-  struct loop *loop = entry->dest->loop_father;\n+  class loop *loop = entry->dest->loop_father;\n   edge exit_copy;\n   vec<basic_block> doms = vNULL;\n   edge redirected;\n@@ -6549,8 +6549,8 @@ gimple_duplicate_sese_tail (edge entry, edge exit,\n {\n   unsigned i;\n   bool free_region_copy = false;\n-  struct loop *loop = exit->dest->loop_father;\n-  struct loop *orig_loop = entry->dest->loop_father;\n+  class loop *loop = exit->dest->loop_father;\n+  class loop *orig_loop = entry->dest->loop_father;\n   basic_block switch_bb, entry_bb, nentry_bb;\n   vec<basic_block> doms;\n   profile_count total_count = profile_count::uninitialized (),\n@@ -6563,7 +6563,7 @@ gimple_duplicate_sese_tail (edge entry, edge exit,\n   gphi_iterator psi;\n   gphi *phi;\n   tree def;\n-  struct loop *target, *aloop, *cloop;\n+  class loop *target, *aloop, *cloop;\n \n   gcc_assert (EDGE_COUNT (exit->src->succs) == 2);\n   exits[0] = exit;\n@@ -7040,7 +7040,7 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n   /* Move BB from its current loop to the copy in the new function.  */\n   if (current_loops)\n     {\n-      struct loop *new_loop = (struct loop *)bb->loop_father->aux;\n+      class loop *new_loop = (class loop *)bb->loop_father->aux;\n       if (new_loop)\n \tbb->loop_father = new_loop;\n     }\n@@ -7304,7 +7304,7 @@ replace_block_vars_by_duplicates (tree block, hash_map<tree, tree> *vars_map,\n \n static void\n fixup_loop_arrays_after_move (struct function *fn1, struct function *fn2,\n-\t\t\t      struct loop *loop)\n+\t\t\t      class loop *loop)\n {\n   /* Discard it from the old loop array.  */\n   (*get_loops (fn1))[loop->num] = NULL;\n@@ -7464,8 +7464,8 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   edge_iterator ei;\n   htab_t new_label_map;\n   hash_map<void *, void *> *eh_map;\n-  struct loop *loop = entry_bb->loop_father;\n-  struct loop *loop0 = get_loop (saved_cfun, 0);\n+  class loop *loop = entry_bb->loop_father;\n+  class loop *loop0 = get_loop (saved_cfun, 0);\n   struct move_stmt_d d;\n \n   /* If ENTRY does not strictly dominate EXIT, this cannot be an SESE\n@@ -7573,8 +7573,8 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n     {\n       if (bb->loop_father->header == bb)\n \t{\n-\t  struct loop *this_loop = bb->loop_father;\n-\t  struct loop *outer = loop_outer (this_loop);\n+\t  class loop *this_loop = bb->loop_father;\n+\t  class loop *outer = loop_outer (this_loop);\n \t  if (outer == loop\n \t      /* If the SESE region contains some bbs ending with\n \t\t a noreturn call, those are considered to belong\n@@ -7614,7 +7614,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n \n   /* Fix up orig_loop_num.  If the block referenced in it has been moved\n      to dest_cfun, update orig_loop_num field, otherwise clear it.  */\n-  struct loop *dloop;\n+  class loop *dloop;\n   signed char *moved_orig_loop_num = NULL;\n   FOR_EACH_LOOP_FN (dest_cfun, dloop, 0)\n     if (dloop->orig_loop_num)\n@@ -7722,14 +7722,14 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   loop0->aux = NULL;\n   /* Loop sizes are no longer correct, fix them up.  */\n   loop->num_nodes -= num_nodes;\n-  for (struct loop *outer = loop_outer (loop);\n+  for (class loop *outer = loop_outer (loop);\n        outer; outer = loop_outer (outer))\n     outer->num_nodes -= num_nodes;\n   loop0->num_nodes -= bbs.length () - num_nodes;\n \n   if (saved_cfun->has_simduid_loops || saved_cfun->has_force_vectorize_loops)\n     {\n-      struct loop *aloop;\n+      class loop *aloop;\n       for (i = 0; vec_safe_iterate (loops->larray, i, &aloop); i++)\n \tif (aloop != NULL)\n \t  {\n@@ -8180,14 +8180,14 @@ print_loops_bb (FILE *file, basic_block bb, int indent, int verbosity)\n     }\n }\n \n-static void print_loop_and_siblings (FILE *, struct loop *, int, int);\n+static void print_loop_and_siblings (FILE *, class loop *, int, int);\n \n /* Pretty print LOOP on FILE, indented INDENT spaces.  Following\n    VERBOSITY level this outputs the contents of the loop, or just its\n    structure.  */\n \n static void\n-print_loop (FILE *file, struct loop *loop, int indent, int verbosity)\n+print_loop (FILE *file, class loop *loop, int indent, int verbosity)\n {\n   char *s_indent;\n   basic_block bb;\n@@ -8253,7 +8253,7 @@ print_loop (FILE *file, struct loop *loop, int indent, int verbosity)\n    loop, or just its structure.  */\n \n static void\n-print_loop_and_siblings (FILE *file, struct loop *loop, int indent,\n+print_loop_and_siblings (FILE *file, class loop *loop, int indent,\n \t\t\t int verbosity)\n {\n   if (loop == NULL)\n@@ -8280,13 +8280,13 @@ print_loops (FILE *file, int verbosity)\n /* Dump a loop.  */\n \n DEBUG_FUNCTION void\n-debug (struct loop &ref)\n+debug (class loop &ref)\n {\n   print_loop (stderr, &ref, 0, /*verbosity*/0);\n }\n \n DEBUG_FUNCTION void\n-debug (struct loop *ptr)\n+debug (class loop *ptr)\n {\n   if (ptr)\n     debug (*ptr);\n@@ -8297,13 +8297,13 @@ debug (struct loop *ptr)\n /* Dump a loop verbosely.  */\n \n DEBUG_FUNCTION void\n-debug_verbose (struct loop &ref)\n+debug_verbose (class loop &ref)\n {\n   print_loop (stderr, &ref, 0, /*verbosity*/3);\n }\n \n DEBUG_FUNCTION void\n-debug_verbose (struct loop *ptr)\n+debug_verbose (class loop *ptr)\n {\n   if (ptr)\n     debug (*ptr);\n@@ -8323,7 +8323,7 @@ debug_loops (int verbosity)\n /* Print on stderr the code of LOOP, at some VERBOSITY level.  */\n \n DEBUG_FUNCTION void\n-debug_loop (struct loop *loop, int verbosity)\n+debug_loop (class loop *loop, int verbosity)\n {\n   print_loop (stderr, loop, 0, verbosity);\n }"}, {"sha": "732916177faaf173312d34a633bc699ce883837e", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -83,12 +83,12 @@ extern void dump_function_to_file (tree, FILE *, dump_flags_t);\n extern void debug_function (tree, dump_flags_t);\n extern void print_loops_bb (FILE *, basic_block, int, int);\n extern void print_loops (FILE *, int);\n-extern void debug (struct loop &ref);\n-extern void debug (struct loop *ptr);\n-extern void debug_verbose (struct loop &ref);\n-extern void debug_verbose (struct loop *ptr);\n+extern void debug (class loop &ref);\n+extern void debug (class loop *ptr);\n+extern void debug_verbose (class loop &ref);\n+extern void debug_verbose (class loop *ptr);\n extern void debug_loops (int);\n-extern void debug_loop (struct loop *, int);\n+extern void debug_loop (class loop *, int);\n extern void debug_loop_num (unsigned, int);\n extern void remove_edge_and_dominated_blocks (edge);\n extern bool gimple_purge_dead_eh_edges (basic_block);"}, {"sha": "5ed62260993caaa3648420323ee1edc15fab9d58", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -52,8 +52,8 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n \t\t\t   tree poly1)\n {\n   tree left, right;\n-  struct loop *loop0 = get_chrec_loop (poly0);\n-  struct loop *loop1 = get_chrec_loop (poly1);\n+  class loop *loop0 = get_chrec_loop (poly0);\n+  class loop *loop1 = get_chrec_loop (poly1);\n   tree rtype = code == POINTER_PLUS_EXPR ? chrec_type (poly1) : type;\n \n   gcc_assert (poly0);\n@@ -144,8 +144,8 @@ chrec_fold_multiply_poly_poly (tree type,\n {\n   tree t0, t1, t2;\n   int var;\n-  struct loop *loop0 = get_chrec_loop (poly0);\n-  struct loop *loop1 = get_chrec_loop (poly1);\n+  class loop *loop0 = get_chrec_loop (poly0);\n+  class loop *loop1 = get_chrec_loop (poly1);\n \n   gcc_assert (poly0);\n   gcc_assert (poly1);\n@@ -539,7 +539,7 @@ chrec_evaluate (unsigned var, tree chrec, tree n, unsigned int k)\n {\n   tree arg0, arg1, binomial_n_k;\n   tree type = TREE_TYPE (chrec);\n-  struct loop *var_loop = get_loop (cfun, var);\n+  class loop *var_loop = get_loop (cfun, var);\n \n   while (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n \t && flow_loop_nested_p (var_loop, get_chrec_loop (chrec)))\n@@ -720,7 +720,7 @@ tree\n hide_evolution_in_other_loops_than_loop (tree chrec,\n \t\t\t\t\t unsigned loop_num)\n {\n-  struct loop *loop = get_loop (cfun, loop_num), *chloop;\n+  class loop *loop = get_loop (cfun, loop_num), *chloop;\n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n \n@@ -761,7 +761,7 @@ chrec_component_in_loop_num (tree chrec,\n \t\t\t     bool right)\n {\n   tree component;\n-  struct loop *loop = get_loop (cfun, loop_num), *chloop;\n+  class loop *loop = get_loop (cfun, loop_num), *chloop;\n \n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n@@ -843,7 +843,7 @@ reset_evolution_in_loop (unsigned loop_num,\n \t\t\t tree chrec,\n \t\t\t tree new_evol)\n {\n-  struct loop *loop = get_loop (cfun, loop_num);\n+  class loop *loop = get_loop (cfun, loop_num);\n \n   if (POINTER_TYPE_P (chrec_type (chrec)))\n     gcc_assert (ptrofftype_p (chrec_type (new_evol)));\n@@ -939,7 +939,7 @@ is_multivariate_chrec (const_tree chrec)\n \n static bool\n chrec_contains_symbols (const_tree chrec, hash_set<const_tree> &visited,\n-\t\t\tstruct loop *loop)\n+\t\t\tclass loop *loop)\n {\n   int i, n;\n \n@@ -977,7 +977,7 @@ chrec_contains_symbols (const_tree chrec, hash_set<const_tree> &visited,\n    the chrec is considered as a SYMBOL.  */\n \n bool\n-chrec_contains_symbols (const_tree chrec, struct loop* loop)\n+chrec_contains_symbols (const_tree chrec, class loop* loop)\n {\n   hash_set<const_tree> visited;\n   return chrec_contains_symbols (chrec, visited, loop);\n@@ -1296,7 +1296,7 @@ nb_vars_in_chrec (tree chrec)\n    the conversion succeeded, false otherwise.  */\n \n bool\n-convert_affine_scev (struct loop *loop, tree type,\n+convert_affine_scev (class loop *loop, tree type,\n \t\t     tree *base, tree *step, gimple *at_stmt,\n \t\t     bool use_overflow_semantics, tree from)\n {\n@@ -1427,7 +1427,7 @@ chrec_convert_1 (tree type, tree chrec, gimple *at_stmt,\n {\n   tree ct, res;\n   tree base, step;\n-  struct loop *loop;\n+  class loop *loop;\n \n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n@@ -1563,7 +1563,7 @@ chrec_convert_aggressive (tree type, tree chrec, bool *fold_conversions)\n   if (!*fold_conversions && evolution_function_is_affine_p (chrec))\n     {\n       tree base, step;\n-      struct loop *loop;\n+      class loop *loop;\n \n       loop = get_chrec_loop (chrec);\n       base = CHREC_LEFT (chrec);"}, {"sha": "423d8fba9d31c5217831fc93c36a5df7f34cdea9", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -77,13 +77,13 @@ extern tree hide_evolution_in_other_loops_than_loop (tree, unsigned);\n extern tree reset_evolution_in_loop (unsigned, tree, tree);\n extern tree chrec_merge (tree, tree);\n extern void for_each_scev_op (tree *, bool (*) (tree *, void *), void *);\n-extern bool convert_affine_scev (struct loop *, tree, tree *, tree *, gimple *,\n+extern bool convert_affine_scev (class loop *, tree, tree *, tree *, gimple *,\n \t\t\t\t bool, tree = NULL);\n \n /* Observers.  */\n extern bool eq_evolutions_p (const_tree, const_tree);\n extern bool is_multivariate_chrec (const_tree);\n-extern bool chrec_contains_symbols (const_tree, struct loop * = NULL);\n+extern bool chrec_contains_symbols (const_tree, class loop * = NULL);\n extern bool chrec_contains_symbols_defined_in_loop (const_tree, unsigned);\n extern bool chrec_contains_undetermined (const_tree);\n extern bool tree_contains_chrecs (const_tree, int *);"}, {"sha": "b5dde47da4f29b2590b379400842a98c489398ee", "filename": "gcc/tree-core.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1908,15 +1908,15 @@ struct GTY(()) tree_optimization_option {\n \n /* Forward declaration, defined in target-globals.h.  */\n \n-struct GTY(()) target_globals;\n+class GTY(()) target_globals;\n \n /* Target options used by a function.  */\n \n struct GTY(()) tree_target_option {\n   struct tree_base base;\n \n   /* Target globals for the corresponding target option.  */\n-  struct target_globals *globals;\n+  class target_globals *globals;\n \n   /* The optimization options used by the user.  */\n   struct cl_target_option *opts;"}, {"sha": "df1a7b8016ea1d8888d785ff202dda33ead9e657", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -127,7 +127,7 @@ static struct datadep_stats\n \n static bool subscript_dependence_tester_1 (struct data_dependence_relation *,\n \t\t\t\t\t   unsigned int, unsigned int,\n-\t\t\t\t\t   struct loop *);\n+\t\t\t\t\t   class loop *);\n /* Returns true iff A divides B.  */\n \n static inline bool\n@@ -448,7 +448,7 @@ dump_data_dependence_relation (FILE *outf,\n   else if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n     {\n       unsigned int i;\n-      struct loop *loopi;\n+      class loop *loopi;\n \n       subscript *sub;\n       FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)\n@@ -873,7 +873,7 @@ canonicalize_base_object_address (tree addr)\n \n opt_result\n dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n-\t\t      struct loop *loop, const gimple *stmt)\n+\t\t      class loop *loop, const gimple *stmt)\n {\n   poly_int64 pbitsize, pbitpos;\n   tree base, poffset;\n@@ -1351,7 +1351,7 @@ data_ref_compare_tree (tree t1, tree t2)\n    check.  */\n \n opt_result\n-runtime_alias_check_p (ddr_p ddr, struct loop *loop, bool speed_p)\n+runtime_alias_check_p (ddr_p ddr, class loop *loop, bool speed_p)\n {\n   if (dump_enabled_p ())\n     dump_printf (MSG_NOTE,\n@@ -1624,7 +1624,7 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n    Note evolution step of index needs to be considered in comparison.  */\n \n static bool\n-create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n+create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n \t\t\t\t     const dr_with_seg_len& dr_a,\n \t\t\t\t     const dr_with_seg_len& dr_b)\n {\n@@ -1858,7 +1858,7 @@ get_segment_min_max (const dr_with_seg_len &d, tree *seg_min_out,\n      || (DR_B_addr_0 + DER_B_segment_length_0) <= DR_A_addr_0))  */\n \n static void\n-create_intersect_range_checks (struct loop *loop, tree *cond_expr,\n+create_intersect_range_checks (class loop *loop, tree *cond_expr,\n \t\t\t       const dr_with_seg_len& dr_a,\n \t\t\t       const dr_with_seg_len& dr_b)\n {\n@@ -1917,7 +1917,7 @@ create_intersect_range_checks (struct loop *loop, tree *cond_expr,\n    that controls which version of the loop gets executed at runtime.  */\n \n void\n-create_runtime_alias_checks (struct loop *loop,\n+create_runtime_alias_checks (class loop *loop,\n \t\t\t     vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t\t\t     tree * cond_expr)\n {\n@@ -2197,7 +2197,7 @@ conflict_fn_no_dependence (void)\n /* Returns true if the address of OBJ is invariant in LOOP.  */\n \n static bool\n-object_address_invariant_in_loop_p (const struct loop *loop, const_tree obj)\n+object_address_invariant_in_loop_p (const class loop *loop, const_tree obj)\n {\n   while (handled_component_p (obj))\n     {\n@@ -2231,7 +2231,7 @@ object_address_invariant_in_loop_p (const struct loop *loop, const_tree obj)\n \n bool\n dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,\n-\t\tstruct loop *loop_nest)\n+\t\tclass loop *loop_nest)\n {\n   tree addr_a = DR_BASE_OBJECT (a);\n   tree addr_b = DR_BASE_OBJECT (b);\n@@ -2892,7 +2892,7 @@ analyze_ziv_subscript (tree chrec_a,\n    chrec_dont_know.  */\n \n static tree\n-max_stmt_executions_tree (struct loop *loop)\n+max_stmt_executions_tree (class loop *loop)\n {\n   widest_int nit;\n \n@@ -3046,7 +3046,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n \t\t      HOST_WIDE_INT numiter;\n-\t\t      struct loop *loop = get_chrec_loop (chrec_b);\n+\t\t      class loop *loop = get_chrec_loop (chrec_b);\n \n \t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n \t\t      tmp = fold_build2 (EXACT_DIV_EXPR, type,\n@@ -3127,7 +3127,7 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t  if (tree_fold_divides_p (CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n \t\t      HOST_WIDE_INT numiter;\n-\t\t      struct loop *loop = get_chrec_loop (chrec_b);\n+\t\t      class loop *loop = get_chrec_loop (chrec_b);\n \n \t\t      *overlaps_a = conflict_fn (1, affine_fn_cst (integer_zero_node));\n \t\t      tmp = fold_build2 (EXACT_DIV_EXPR, type, difference,\n@@ -4023,7 +4023,7 @@ analyze_miv_subscript (tree chrec_a,\n \t\t       conflict_function **overlaps_a,\n \t\t       conflict_function **overlaps_b,\n \t\t       tree *last_conflicts,\n-\t\t       struct loop *loop_nest)\n+\t\t       class loop *loop_nest)\n {\n   tree type, difference;\n \n@@ -4125,7 +4125,7 @@ analyze_overlapping_iterations (tree chrec_a,\n \t\t\t\ttree chrec_b,\n \t\t\t\tconflict_function **overlap_iterations_a,\n \t\t\t\tconflict_function **overlap_iterations_b,\n-\t\t\t\ttree *last_conflicts, struct loop *loop_nest)\n+\t\t\t\ttree *last_conflicts, class loop *loop_nest)\n {\n   unsigned int lnn = loop_nest->num;\n \n@@ -4275,7 +4275,7 @@ build_classic_dist_vector_1 (struct data_dependence_relation *ddr,\n {\n   unsigned i;\n   lambda_vector init_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n-  struct loop *loop = DDR_LOOP_NEST (ddr)[0];\n+  class loop *loop = DDR_LOOP_NEST (ddr)[0];\n \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n@@ -4426,7 +4426,7 @@ add_other_self_distances (struct data_dependence_relation *ddr)\n   unsigned i;\n   int index_carry = DDR_NB_LOOPS (ddr);\n   subscript *sub;\n-  struct loop *loop = DDR_LOOP_NEST (ddr)[0];\n+  class loop *loop = DDR_LOOP_NEST (ddr)[0];\n \n   FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)\n     {\n@@ -4546,7 +4546,7 @@ same_access_functions (const struct data_dependence_relation *ddr)\n \n static bool\n build_classic_dist_vector (struct data_dependence_relation *ddr,\n-\t\t\t   struct loop *loop_nest)\n+\t\t\t   class loop *loop_nest)\n {\n   bool init_b = false;\n   int index_carry = DDR_NB_LOOPS (ddr);\n@@ -4733,7 +4733,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr)\n static bool\n subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n \t\t\t       unsigned int a_index, unsigned int b_index,\n-\t\t\t       struct loop *loop_nest)\n+\t\t\t       class loop *loop_nest)\n {\n   unsigned int i;\n   tree last_conflicts;\n@@ -4792,7 +4792,7 @@ subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n \n static void\n subscript_dependence_tester (struct data_dependence_relation *ddr,\n-\t\t\t     struct loop *loop_nest)\n+\t\t\t     class loop *loop_nest)\n {\n   if (subscript_dependence_tester_1 (ddr, 0, 1, loop_nest))\n     dependence_stats.num_dependence_dependent++;\n@@ -4807,7 +4807,7 @@ subscript_dependence_tester (struct data_dependence_relation *ddr,\n \n static bool\n access_functions_are_affine_or_constant_p (const struct data_reference *a,\n-\t\t\t\t\t   const struct loop *loop_nest)\n+\t\t\t\t\t   const class loop *loop_nest)\n {\n   unsigned int i;\n   vec<tree> fns = DR_ACCESS_FNS (a);\n@@ -4832,7 +4832,7 @@ access_functions_are_affine_or_constant_p (const struct data_reference *a,\n \n void\n compute_affine_dependence (struct data_dependence_relation *ddr,\n-\t\t\t   struct loop *loop_nest)\n+\t\t\t   class loop *loop_nest)\n {\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n@@ -4975,7 +4975,7 @@ get_references_in_stmt (gimple *stmt, vec<data_ref_loc, va_heap> *references)\n \t  {\n \t  case IFN_GOMP_SIMD_LANE:\n \t    {\n-\t      struct loop *loop = gimple_bb (stmt)->loop_father;\n+\t      class loop *loop = gimple_bb (stmt)->loop_father;\n \t      tree uid = gimple_call_arg (stmt, 0);\n \t      gcc_assert (TREE_CODE (uid) == SSA_NAME);\n \t      if (loop == NULL\n@@ -5117,7 +5117,7 @@ loop_nest_has_data_refs (loop_p loop)\n    loop of the loop nest in which the references should be analyzed.  */\n \n opt_result\n-find_data_references_in_stmt (struct loop *nest, gimple *stmt,\n+find_data_references_in_stmt (class loop *nest, gimple *stmt,\n \t\t\t      vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n@@ -5176,7 +5176,7 @@ graphite_find_data_references_in_stmt (edge nest, loop_p loop, gimple *stmt,\n    difficult case, returns NULL_TREE otherwise.  */\n \n tree\n-find_data_references_in_bb (struct loop *loop, basic_block bb,\n+find_data_references_in_bb (class loop *loop, basic_block bb,\n                             vec<data_reference_p> *datarefs)\n {\n   gimple_stmt_iterator bsi;\n@@ -5206,7 +5206,7 @@ find_data_references_in_bb (struct loop *loop, basic_block bb,\n    arithmetic as if they were array accesses, etc.  */\n \n tree\n-find_data_references_in_loop (struct loop *loop,\n+find_data_references_in_loop (class loop *loop,\n \t\t\t      vec<data_reference_p> *datarefs)\n {\n   basic_block bb, *bbs;\n@@ -5331,7 +5331,7 @@ get_base_for_alignment (tree addr, unsigned int *max_alignment)\n /* Recursive helper function.  */\n \n static bool\n-find_loop_nest_1 (struct loop *loop, vec<loop_p> *loop_nest)\n+find_loop_nest_1 (class loop *loop, vec<loop_p> *loop_nest)\n {\n   /* Inner loops of the nest should not contain siblings.  Example:\n      when there are two consecutive loops,\n@@ -5362,7 +5362,7 @@ find_loop_nest_1 (struct loop *loop, vec<loop_p> *loop_nest)\n    appear in the classic distance vector.  */\n \n bool\n-find_loop_nest (struct loop *loop, vec<loop_p> *loop_nest)\n+find_loop_nest (class loop *loop, vec<loop_p> *loop_nest)\n {\n   loop_nest->safe_push (loop);\n   if (loop->inner)\n@@ -5378,7 +5378,7 @@ find_loop_nest (struct loop *loop, vec<loop_p> *loop_nest)\n    COMPUTE_SELF_AND_READ_READ_DEPENDENCES is TRUE.  */\n \n bool\n-compute_data_dependences_for_loop (struct loop *loop,\n+compute_data_dependences_for_loop (class loop *loop,\n \t\t\t\t   bool compute_self_and_read_read_dependences,\n \t\t\t\t   vec<loop_p> *loop_nest,\n \t\t\t\t   vec<data_reference_p> *datarefs,"}, {"sha": "998937fef6844c9e495b33e345311589c8427e79", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -421,8 +421,8 @@ typedef struct data_dependence_relation *ddr_p;\n \n \f\n opt_result dr_analyze_innermost (innermost_loop_behavior *, tree,\n-\t\t\t\t struct loop *, const gimple *);\n-extern bool compute_data_dependences_for_loop (struct loop *, bool,\n+\t\t\t\t class loop *, const gimple *);\n+extern bool compute_data_dependences_for_loop (class loop *, bool,\n \t\t\t\t\t       vec<loop_p> *,\n \t\t\t\t\t       vec<data_reference_p> *,\n \t\t\t\t\t       vec<ddr_p> *);\n@@ -443,15 +443,15 @@ extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (vec<ddr_p> );\n extern void free_data_ref (data_reference_p);\n extern void free_data_refs (vec<data_reference_p> );\n-extern opt_result find_data_references_in_stmt (struct loop *, gimple *,\n+extern opt_result find_data_references_in_stmt (class loop *, gimple *,\n \t\t\t\t\t\tvec<data_reference_p> *);\n extern bool graphite_find_data_references_in_stmt (edge, loop_p, gimple *,\n \t\t\t\t\t\t   vec<data_reference_p> *);\n-tree find_data_references_in_loop (struct loop *, vec<data_reference_p> *);\n+tree find_data_references_in_loop (class loop *, vec<data_reference_p> *);\n bool loop_nest_has_data_refs (loop_p loop);\n struct data_reference *create_data_ref (edge, loop_p, tree, gimple *, bool,\n \t\t\t\t\tbool);\n-extern bool find_loop_nest (struct loop *, vec<loop_p> *);\n+extern bool find_loop_nest (class loop *, vec<loop_p> *);\n extern struct data_dependence_relation *initialize_data_dependence_relation\n      (struct data_reference *, struct data_reference *, vec<loop_p>);\n extern void compute_affine_dependence (struct data_dependence_relation *,\n@@ -460,7 +460,7 @@ extern void compute_self_dependence (struct data_dependence_relation *);\n extern bool compute_all_dependences (vec<data_reference_p> ,\n \t\t\t\t     vec<ddr_p> *,\n \t\t\t\t     vec<loop_p>, bool);\n-extern tree find_data_references_in_bb (struct loop *, basic_block,\n+extern tree find_data_references_in_bb (class loop *, basic_block,\n                                         vec<data_reference_p> *);\n extern unsigned int dr_alignment (innermost_loop_behavior *);\n extern tree get_base_for_alignment (tree, unsigned int *);\n@@ -475,15 +475,15 @@ dr_alignment (data_reference *dr)\n }\n \n extern bool dr_may_alias_p (const struct data_reference *,\n-\t\t\t    const struct data_reference *, struct loop *);\n+\t\t\t    const struct data_reference *, class loop *);\n extern bool dr_equal_offsets_p (struct data_reference *,\n                                 struct data_reference *);\n \n-extern opt_result runtime_alias_check_p (ddr_p, struct loop *, bool);\n+extern opt_result runtime_alias_check_p (ddr_p, class loop *, bool);\n extern int data_ref_compare_tree (tree, tree);\n extern void prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *,\n \t\t\t\t\t   poly_uint64);\n-extern void create_runtime_alias_checks (struct loop *,\n+extern void create_runtime_alias_checks (class loop *,\n \t\t\t\t\t vec<dr_with_seg_len_pair_t> *, tree*);\n extern tree dr_direction_indicator (struct data_reference *);\n extern tree dr_zero_step_indicator (struct data_reference *);\n@@ -574,7 +574,7 @@ ddr_dependence_level (ddr_p ddr)\n static inline int\n index_in_loop_nest (int var, vec<loop_p> loop_nest)\n {\n-  struct loop *loopi;\n+  class loop *loopi;\n   int var_index;\n \n   for (var_index = 0; loop_nest.iterate (var_index, &loopi); var_index++)"}, {"sha": "d9e540f1d5af9c9a7b8e90367a6431da565d3968", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -502,7 +502,7 @@ fold_build_cond_expr (tree type, tree cond, tree rhs, tree lhs)\n    cd-equivalent if they are executed under the same condition.  */\n \n static inline void\n-add_to_predicate_list (struct loop *loop, basic_block bb, tree nc)\n+add_to_predicate_list (class loop *loop, basic_block bb, tree nc)\n {\n   tree bc, *tp;\n   basic_block dom_bb;\n@@ -567,7 +567,7 @@ add_to_predicate_list (struct loop *loop, basic_block bb, tree nc)\n    the loop to be if-converted.  */\n \n static void\n-add_to_dst_predicate_list (struct loop *loop, edge e,\n+add_to_dst_predicate_list (class loop *loop, edge e,\n \t\t\t   tree prev_cond, tree cond)\n {\n   if (!flow_bb_inside_loop_p (loop, e->dest))\n@@ -584,7 +584,7 @@ add_to_dst_predicate_list (struct loop *loop, edge e,\n /* Return true if one of the successor edges of BB exits LOOP.  */\n \n static bool\n-bb_with_exit_edge_p (struct loop *loop, basic_block bb)\n+bb_with_exit_edge_p (class loop *loop, basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -661,7 +661,7 @@ phi_convertible_by_degenerating_args (gphi *phi)\n    ANY_COMPLICATED_PHI if PHI is complicated.  */\n \n static bool\n-if_convertible_phi_p (struct loop *loop, basic_block bb, gphi *phi)\n+if_convertible_phi_p (class loop *loop, basic_block bb, gphi *phi)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -756,7 +756,7 @@ idx_within_array_bound (tree ref, tree *idx, void *dta)\n   widest_int niter, valid_niter, delta, wi_step;\n   tree ev, init, step;\n   tree low, high;\n-  struct loop *loop = (struct loop*) dta;\n+  class loop *loop = (class loop*) dta;\n \n   /* Only support within-bound access for array references.  */\n   if (TREE_CODE (ref) != ARRAY_REF)\n@@ -822,7 +822,7 @@ idx_within_array_bound (tree ref, tree *idx, void *dta)\n static bool\n ref_within_array_bound (gimple *stmt, tree ref)\n {\n-  struct loop *loop = loop_containing_stmt (stmt);\n+  class loop *loop = loop_containing_stmt (stmt);\n \n   gcc_assert (loop != NULL);\n   return for_each_index (&ref, idx_within_array_bound, loop);\n@@ -1128,7 +1128,7 @@ all_preds_critical_p (basic_block bb)\n    inside LOOP.  */\n \n static bool\n-if_convertible_bb_p (struct loop *loop, basic_block bb, basic_block exit_bb)\n+if_convertible_bb_p (class loop *loop, basic_block bb, basic_block exit_bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1197,7 +1197,7 @@ pred_blocks_visited_p (basic_block bb, bitmap *visited)\n    predecessors are already selected.  */\n \n static basic_block *\n-get_loop_body_in_if_conv_order (const struct loop *loop)\n+get_loop_body_in_if_conv_order (const class loop *loop)\n {\n   basic_block *blocks, *blocks_in_bfs_order;\n   basic_block bb;\n@@ -1344,7 +1344,7 @@ predicate_bbs (loop_p loop)\n /* Build region by adding loop pre-header and post-header blocks.  */\n \n static vec<basic_block>\n-build_region (struct loop *loop)\n+build_region (class loop *loop)\n {\n   vec<basic_block> region = vNULL;\n   basic_block exit_bb = NULL;\n@@ -1378,7 +1378,7 @@ build_region (struct loop *loop)\n    in if_convertible_loop_p.  */\n \n static bool\n-if_convertible_loop_p_1 (struct loop *loop, vec<data_reference_p> *refs)\n+if_convertible_loop_p_1 (class loop *loop, vec<data_reference_p> *refs)\n {\n   unsigned int i;\n   basic_block exit_bb = NULL;\n@@ -1518,7 +1518,7 @@ if_convertible_loop_p_1 (struct loop *loop, vec<data_reference_p> *refs)\n    - if its basic blocks and phi nodes are if convertible.  */\n \n static bool\n-if_convertible_loop_p (struct loop *loop)\n+if_convertible_loop_p (class loop *loop)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1597,7 +1597,7 @@ is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n   gimple *header_phi = NULL;\n   enum tree_code reduction_op;\n   basic_block bb = gimple_bb (phi);\n-  struct loop *loop = bb->loop_father;\n+  class loop *loop = bb->loop_father;\n   edge latch_e = loop_latch_edge (loop);\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n@@ -2004,7 +2004,7 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n    LOOP->header block with conditional modify expressions.  */\n \n static void\n-predicate_all_scalar_phis (struct loop *loop)\n+predicate_all_scalar_phis (class loop *loop)\n {\n   basic_block bb;\n   unsigned int orig_loop_num_nodes = loop->num_nodes;\n@@ -2526,7 +2526,7 @@ remove_conditions_and_labels (loop_p loop)\n    blocks.  Replace PHI nodes with conditional modify expressions.  */\n \n static void\n-combine_blocks (struct loop *loop)\n+combine_blocks (class loop *loop)\n {\n   basic_block bb, exit_bb, merge_target_bb;\n   unsigned int orig_loop_num_nodes = loop->num_nodes;\n@@ -2719,12 +2719,12 @@ combine_blocks (struct loop *loop)\n    out of LOOP_VECTORIZED must have 100% probability so the profile remains\n    consistent after the condition is folded in the vectorizer.  */\n \n-static struct loop *\n-version_loop_for_if_conversion (struct loop *loop, vec<gimple *> *preds)\n+static class loop *\n+version_loop_for_if_conversion (class loop *loop, vec<gimple *> *preds)\n {\n   basic_block cond_bb;\n   tree cond = make_ssa_name (boolean_type_node);\n-  struct loop *new_loop;\n+  class loop *new_loop;\n   gimple *g;\n   gimple_stmt_iterator gsi;\n   unsigned int save_length;\n@@ -2781,7 +2781,7 @@ version_loop_for_if_conversion (struct loop *loop, vec<gimple *> *preds)\n       inner loop's exit block.  */\n \n static bool\n-versionable_outer_loop_p (struct loop *loop)\n+versionable_outer_loop_p (class loop *loop)\n {\n   if (!loop_outer (loop)\n       || loop->dont_vectorize\n@@ -2815,7 +2815,7 @@ versionable_outer_loop_p (struct loop *loop)\n    Last restriction is valid only if AGGRESSIVE_IF_CONV is false.  */\n \n static bool\n-ifcvt_split_critical_edges (struct loop *loop, bool aggressive_if_conv)\n+ifcvt_split_critical_edges (class loop *loop, bool aggressive_if_conv)\n {\n   basic_block *body;\n   basic_block bb;\n@@ -2982,11 +2982,11 @@ ifcvt_local_dce (basic_block bb)\n    changed.  */\n \n unsigned int\n-tree_if_conversion (struct loop *loop, vec<gimple *> *preds)\n+tree_if_conversion (class loop *loop, vec<gimple *> *preds)\n {\n   unsigned int todo = 0;\n   bool aggressive_if_conv;\n-  struct loop *rloop;\n+  class loop *rloop;\n   bitmap exit_bbs;\n \n  again:\n@@ -3001,7 +3001,7 @@ tree_if_conversion (struct loop *loop, vec<gimple *> *preds)\n   aggressive_if_conv = loop->force_vectorize;\n   if (!aggressive_if_conv)\n     {\n-      struct loop *outer_loop = loop_outer (loop);\n+      class loop *outer_loop = loop_outer (loop);\n       if (outer_loop && outer_loop->force_vectorize)\n \taggressive_if_conv = true;\n     }\n@@ -3027,10 +3027,10 @@ tree_if_conversion (struct loop *loop, vec<gimple *> *preds)\n       || any_complicated_phi\n       || flag_tree_loop_if_convert != 1)\n     {\n-      struct loop *vloop\n+      class loop *vloop\n \t= (versionable_outer_loop_p (loop_outer (loop))\n \t   ? loop_outer (loop) : loop);\n-      struct loop *nloop = version_loop_for_if_conversion (vloop, preds);\n+      class loop *nloop = version_loop_for_if_conversion (vloop, preds);\n       if (nloop == NULL)\n \tgoto cleanup;\n       if (vloop != loop)\n@@ -3138,7 +3138,7 @@ pass_if_conversion::gate (function *fun)\n unsigned int\n pass_if_conversion::execute (function *fun)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   unsigned todo = 0;\n \n   if (number_of_loops (fun) <= 1)"}, {"sha": "a83380b8a69c2900e6b525e907232579675de305", "filename": "gcc/tree-if-conv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-if-conv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-if-conv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -19,6 +19,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_IF_CONV_H\n #define GCC_TREE_IF_CONV_H\n \n-unsigned int tree_if_conversion (struct loop *, vec<gimple *> * = NULL);\n+unsigned int tree_if_conversion (class loop *, vec<gimple *> * = NULL);\n \n #endif  /* GCC_TREE_IF_CONV_H  */"}, {"sha": "4311309accee33a1e12e060765e8e8015b9636e9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -2804,15 +2804,15 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n \n static void\n copy_loops (copy_body_data *id,\n-\t    struct loop *dest_parent, struct loop *src_parent)\n+\t    class loop *dest_parent, class loop *src_parent)\n {\n-  struct loop *src_loop = src_parent->inner;\n+  class loop *src_loop = src_parent->inner;\n   while (src_loop)\n     {\n       if (!id->blocks_to_copy\n \t  || bitmap_bit_p (id->blocks_to_copy, src_loop->header->index))\n \t{\n-\t  struct loop *dest_loop = alloc_loop ();\n+\t  class loop *dest_loop = alloc_loop ();\n \n \t  /* Assign the new loop its header and latch and associate\n \t     those with the new loop.  */"}, {"sha": "81784866ad11956dc04a15f79aba344b5c0d9b4e", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -506,7 +506,7 @@ bb_top_order_cmp (const void *x, const void *y)\n    statements in loop copies.  */\n \n static void\n-stmts_from_loop (struct loop *loop, vec<gimple *> *stmts)\n+stmts_from_loop (class loop *loop, vec<gimple *> *stmts)\n {\n   unsigned int i;\n   basic_block *bbs = get_loop_body_in_custom_order (loop, bb_top_order_cmp);\n@@ -564,7 +564,7 @@ free_rdg (struct graph *rdg)\n    collected and recorded in global data DATAREFS_VEC.  */\n \n static struct graph *\n-build_rdg (struct loop *loop, control_dependences *cd)\n+build_rdg (class loop *loop, control_dependences *cd)\n {\n   struct graph *rdg;\n \n@@ -787,10 +787,10 @@ stmt_has_scalar_dependences_outside_loop (loop_p loop, gimple *stmt)\n \n /* Return a copy of LOOP placed before LOOP.  */\n \n-static struct loop *\n-copy_loop_before (struct loop *loop)\n+static class loop *\n+copy_loop_before (class loop *loop)\n {\n-  struct loop *res;\n+  class loop *res;\n   edge preheader = loop_preheader_edge (loop);\n \n   initialize_original_copy_tables ();\n@@ -805,7 +805,7 @@ copy_loop_before (struct loop *loop)\n /* Creates an empty basic block after LOOP.  */\n \n static void\n-create_bb_after_loop (struct loop *loop)\n+create_bb_after_loop (class loop *loop)\n {\n   edge exit = single_exit (loop);\n \n@@ -822,7 +822,7 @@ create_bb_after_loop (struct loop *loop)\n    basic blocks of a loop are taken in dom order.  */\n \n static void\n-generate_loops_for_partition (struct loop *loop, partition *partition,\n+generate_loops_for_partition (class loop *loop, partition *partition,\n \t\t\t      bool copy_p)\n {\n   unsigned i;\n@@ -994,7 +994,7 @@ const_with_all_bytes_same (tree val)\n /* Generate a call to memset for PARTITION in LOOP.  */\n \n static void\n-generate_memset_builtin (struct loop *loop, partition *partition)\n+generate_memset_builtin (class loop *loop, partition *partition)\n {\n   gimple_stmt_iterator gsi;\n   tree mem, fn, nb_bytes;\n@@ -1048,7 +1048,7 @@ generate_memset_builtin (struct loop *loop, partition *partition)\n /* Generate a call to memcpy for PARTITION in LOOP.  */\n \n static void\n-generate_memcpy_builtin (struct loop *loop, partition *partition)\n+generate_memcpy_builtin (class loop *loop, partition *partition)\n {\n   gimple_stmt_iterator gsi;\n   gimple *fn_call;\n@@ -1092,7 +1092,7 @@ generate_memcpy_builtin (struct loop *loop, partition *partition)\n /* Remove and destroy the loop LOOP.  */\n \n static void\n-destroy_loop (struct loop *loop)\n+destroy_loop (class loop *loop)\n {\n   unsigned nbbs = loop->num_nodes;\n   edge exit = single_exit (loop);\n@@ -1169,7 +1169,7 @@ destroy_loop (struct loop *loop)\n /* Generates code for PARTITION.  Return whether LOOP needs to be destroyed.  */\n \n static bool \n-generate_code_for_partition (struct loop *loop,\n+generate_code_for_partition (class loop *loop,\n \t\t\t     partition *partition, bool copy_p)\n {\n   switch (partition->kind)\n@@ -1346,7 +1346,7 @@ build_rdg_partition_for_vertex (struct graph *rdg, int v)\n    data references.  */\n \n static bool\n-find_single_drs (struct loop *loop, struct graph *rdg, partition *partition,\n+find_single_drs (class loop *loop, struct graph *rdg, partition *partition,\n \t\t data_reference_p *dst_dr, data_reference_p *src_dr)\n {\n   unsigned i;\n@@ -1469,7 +1469,7 @@ compute_access_range (loop_p loop_nest, data_reference_p dr, tree *base,\n {\n   location_t loc = gimple_location (DR_STMT (dr));\n   basic_block bb = gimple_bb (DR_STMT (dr));\n-  struct loop *loop = bb->loop_father;\n+  class loop *loop = bb->loop_father;\n   tree ref = DR_REF (dr);\n   tree access_base = build_fold_addr_expr (ref);\n   tree access_size = TYPE_SIZE_UNIT (TREE_TYPE (ref));\n@@ -2426,7 +2426,7 @@ data_ref_segment_size (struct data_reference *dr, tree niters)\n    DR.  */\n \n static inline bool\n-latch_dominated_by_data_ref (struct loop *loop, data_reference *dr)\n+latch_dominated_by_data_ref (class loop *loop, data_reference *dr)\n {\n   return dominated_by_p (CDI_DOMINATORS, single_exit (loop)->src,\n \t\t\t gimple_bb (DR_STMT (dr)));\n@@ -2436,7 +2436,7 @@ latch_dominated_by_data_ref (struct loop *loop, data_reference *dr)\n    data dependence relations ALIAS_DDRS.  */\n \n static void\n-compute_alias_check_pairs (struct loop *loop, vec<ddr_p> *alias_ddrs,\n+compute_alias_check_pairs (class loop *loop, vec<ddr_p> *alias_ddrs,\n \t\t\t   vec<dr_with_seg_len_pair_t> *comp_alias_pairs)\n {\n   unsigned int i;\n@@ -2508,11 +2508,11 @@ compute_alias_check_pairs (struct loop *loop, vec<ddr_p> *alias_ddrs,\n \n static void\n version_loop_by_alias_check (vec<struct partition *> *partitions,\n-\t\t\t     struct loop *loop, vec<ddr_p> *alias_ddrs)\n+\t\t\t     class loop *loop, vec<ddr_p> *alias_ddrs)\n {\n   profile_probability prob;\n   basic_block cond_bb;\n-  struct loop *nloop;\n+  class loop *nloop;\n   tree lhs, arg0, cond_expr = NULL_TREE;\n   gimple_seq cond_stmts = NULL;\n   gimple *call_stmt = NULL;\n@@ -2723,7 +2723,7 @@ fuse_memset_builtins (vec<struct partition *> *partitions)\n    ALIAS_DDRS contains ddrs which need runtime alias check.  */\n \n static void\n-finalize_partitions (struct loop *loop, vec<struct partition *> *partitions,\n+finalize_partitions (class loop *loop, vec<struct partition *> *partitions,\n \t\t     vec<ddr_p> *alias_ddrs)\n {\n   unsigned i;\n@@ -2780,7 +2780,7 @@ finalize_partitions (struct loop *loop, vec<struct partition *> *partitions,\n    Set *DESTROY_P to whether LOOP needs to be destroyed.  */\n \n static int\n-distribute_loop (struct loop *loop, vec<gimple *> stmts,\n+distribute_loop (class loop *loop, vec<gimple *> stmts,\n \t\t control_dependences *cd, int *nb_calls, bool *destroy_p,\n \t\t bool only_patterns_p)\n {\n@@ -3060,7 +3060,7 @@ class pass_loop_distribution : public gimple_opt_pass\n    WORK_LIST.  Return false if there is nothing for distribution.  */\n \n static bool\n-find_seed_stmts_for_distribution (struct loop *loop, vec<gimple *> *work_list)\n+find_seed_stmts_for_distribution (class loop *loop, vec<gimple *> *work_list)\n {\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n \n@@ -3114,10 +3114,10 @@ find_seed_stmts_for_distribution (struct loop *loop, vec<gimple *> *work_list)\n /* Given innermost LOOP, return the outermost enclosing loop that forms a\n    perfect loop nest.  */\n \n-static struct loop *\n-prepare_perfect_loop_nest (struct loop *loop)\n+static class loop *\n+prepare_perfect_loop_nest (class loop *loop)\n {\n-  struct loop *outer = loop_outer (loop);\n+  class loop *outer = loop_outer (loop);\n   tree niters = number_of_latch_executions (loop);\n \n   /* TODO: We only support the innermost 3-level loop nest distribution\n@@ -3143,7 +3143,7 @@ prepare_perfect_loop_nest (struct loop *loop)\n unsigned int\n pass_loop_distribution::execute (function *fun)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool changed = false;\n   basic_block bb;\n   control_dependences *cd = NULL;"}, {"sha": "f5cb411f087bd4221c0f5cf7ba6ee0c51d9e3528", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -412,7 +412,7 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n    in parallel).  */\n \n static bool\n-loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)\n+loop_parallel_p (class loop *loop, struct obstack * parloop_obstack)\n {\n   vec<ddr_p> dependence_relations;\n   vec<data_reference_p> datarefs;\n@@ -468,7 +468,7 @@ loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)\n    BB_IRREDUCIBLE_LOOP flag.  */\n \n static inline bool\n-loop_has_blocks_with_irreducible_flag (struct loop *loop)\n+loop_has_blocks_with_irreducible_flag (class loop *loop)\n {\n   unsigned i;\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n@@ -572,7 +572,7 @@ reduc_stmt_res (gimple *stmt)\n    the loop described in DATA.  */\n \n int\n-initialize_reductions (reduction_info **slot, struct loop *loop)\n+initialize_reductions (reduction_info **slot, class loop *loop)\n {\n   tree init;\n   tree type, arg;\n@@ -1034,7 +1034,7 @@ add_field_for_name (name_to_copy_elt **slot, tree type)\n    reduction's data structure.  */\n \n int\n-create_phi_for_local_result (reduction_info **slot, struct loop *loop)\n+create_phi_for_local_result (reduction_info **slot, class loop *loop)\n {\n   struct reduction_info *const reduc = *slot;\n   edge e;\n@@ -1158,11 +1158,11 @@ create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n    LD_ST_DATA describes the shared data structure where\n    shared data is stored in and loaded from.  */\n static void\n-create_call_for_reduction (struct loop *loop,\n+create_call_for_reduction (class loop *loop,\n \t\t\t   reduction_info_table_type *reduction_list,\n \t\t\t   struct clsn_data *ld_st_data)\n {\n-  reduction_list->traverse <struct loop *, create_phi_for_local_result> (loop);\n+  reduction_list->traverse <class loop *, create_phi_for_local_result> (loop);\n   /* Find the fallthru edge from GIMPLE_OMP_CONTINUE.  */\n   basic_block continue_bb = single_pred (loop->latch);\n   ld_st_data->load_bb = FALLTHRU_EDGE (continue_bb)->dest;\n@@ -1640,7 +1640,7 @@ replace_uses_in_bb_by (tree name, tree val, basic_block bb)\n    bound.  */\n \n static void\n-transform_to_exit_first_loop_alt (struct loop *loop,\n+transform_to_exit_first_loop_alt (class loop *loop,\n \t\t\t\t  reduction_info_table_type *reduction_list,\n \t\t\t\t  tree bound)\n {\n@@ -1797,7 +1797,7 @@ transform_to_exit_first_loop_alt (struct loop *loop,\n    transformation is successful.  */\n \n static bool\n-try_transform_to_exit_first_loop_alt (struct loop *loop,\n+try_transform_to_exit_first_loop_alt (class loop *loop,\n \t\t\t\t      reduction_info_table_type *reduction_list,\n \t\t\t\t      tree nit)\n {\n@@ -1916,7 +1916,7 @@ try_transform_to_exit_first_loop_alt (struct loop *loop,\n    LOOP.  */\n \n static void\n-transform_to_exit_first_loop (struct loop *loop,\n+transform_to_exit_first_loop (class loop *loop,\n \t\t\t      reduction_info_table_type *reduction_list,\n \t\t\t      tree nit)\n {\n@@ -2030,7 +2030,7 @@ transform_to_exit_first_loop (struct loop *loop,\n    that number is to be determined later.  */\n \n static void\n-create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n+create_parallel_loop (class loop *loop, tree loop_fn, tree data,\n \t\t      tree new_data, unsigned n_threads, location_t loc,\n \t\t      bool oacc_kernels_p)\n {\n@@ -2266,9 +2266,9 @@ num_phis (basic_block bb, bool count_virtual_p)\n    REDUCTION_LIST describes the reductions existent in the LOOP.  */\n \n static void\n-gen_parallel_loop (struct loop *loop,\n+gen_parallel_loop (class loop *loop,\n \t\t   reduction_info_table_type *reduction_list,\n-\t\t   unsigned n_threads, struct tree_niter_desc *niter,\n+\t\t   unsigned n_threads, class tree_niter_desc *niter,\n \t\t   bool oacc_kernels_p)\n {\n   tree many_iterations_cond, type, nit;\n@@ -2441,7 +2441,7 @@ gen_parallel_loop (struct loop *loop,\n \n   /* Generate initializations for reductions.  */\n   if (!reduction_list->is_empty ())\n-    reduction_list->traverse <struct loop *, initialize_reductions> (loop);\n+    reduction_list->traverse <class loop *, initialize_reductions> (loop);\n \n   /* Eliminate the references to local variables from the loop.  */\n   gcc_assert (single_exit (loop));\n@@ -2489,7 +2489,7 @@ gen_parallel_loop (struct loop *loop,\n /* Returns true when LOOP contains vector phi nodes.  */\n \n static bool\n-loop_has_vector_phi_nodes (struct loop *loop ATTRIBUTE_UNUSED)\n+loop_has_vector_phi_nodes (class loop *loop ATTRIBUTE_UNUSED)\n {\n   unsigned i;\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n@@ -2695,7 +2695,7 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n /* Try to initialize NITER for code generation part.  */\n \n static bool\n-try_get_loop_niter (loop_p loop, struct tree_niter_desc *niter)\n+try_get_loop_niter (loop_p loop, class tree_niter_desc *niter)\n {\n   edge exit = single_dom_exit (loop);\n \n@@ -2737,7 +2737,7 @@ get_omp_data_i_param (void)\n    and return addr.  Otherwise, return NULL_TREE.  */\n \n static tree\n-find_reduc_addr (struct loop *loop, gphi *phi)\n+find_reduc_addr (class loop *loop, gphi *phi)\n {\n   edge e = loop_preheader_edge (loop);\n   tree arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n@@ -2907,7 +2907,7 @@ try_create_reduction_list (loop_p loop,\n /* Return true if LOOP contains phis with ADDR_EXPR in args.  */\n \n static bool\n-loop_has_phi_with_address_arg (struct loop *loop)\n+loop_has_phi_with_address_arg (class loop *loop)\n {\n   basic_block *bbs = get_loop_body (loop);\n   bool res = false;\n@@ -3244,7 +3244,7 @@ oacc_entry_exit_single_gang (bitmap in_loop_bbs, vec<basic_block> region_bbs,\n    outside LOOP by guarding them such that only a single gang executes them.  */\n \n static bool\n-oacc_entry_exit_ok (struct loop *loop,\n+oacc_entry_exit_ok (class loop *loop,\n \t\t    reduction_info_table_type *reduction_list)\n {\n   basic_block *loop_bbs = get_loop_body_in_dom_order (loop);\n@@ -3289,9 +3289,9 @@ parallelize_loops (bool oacc_kernels_p)\n {\n   unsigned n_threads;\n   bool changed = false;\n-  struct loop *loop;\n-  struct loop *skip_loop = NULL;\n-  struct tree_niter_desc niter_desc;\n+  class loop *loop;\n+  class loop *skip_loop = NULL;\n+  class tree_niter_desc niter_desc;\n   struct obstack parloop_obstack;\n   HOST_WIDE_INT estimated;\n "}, {"sha": "1c8df3d0a719b97322b89f69711bfbd09e43d3d4", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -132,7 +132,7 @@ class rtl_opt_pass : public opt_pass\n   }\n };\n \n-class varpool_node;\n+struct varpool_node;\n struct cgraph_node;\n struct lto_symtab_encoder_d;\n "}, {"sha": "299c45e287bf8f16e6dfdd422f1a149c8fbe6d70", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -735,7 +735,7 @@ determine_offset (struct data_reference *a, struct data_reference *b,\n    it is executed whenever the loop is entered.  */\n \n static basic_block\n-last_always_executed_block (struct loop *loop)\n+last_always_executed_block (class loop *loop)\n {\n   unsigned i;\n   vec<edge> exits = get_loop_exit_edges (loop);\n@@ -752,7 +752,7 @@ last_always_executed_block (struct loop *loop)\n /* Splits dependence graph on DATAREFS described by DEPENDS to components.  */\n \n static struct component *\n-split_data_refs_to_components (struct loop *loop,\n+split_data_refs_to_components (class loop *loop,\n \t\t\t       vec<data_reference_p> datarefs,\n \t\t\t       vec<ddr_p> depends)\n {\n@@ -896,7 +896,7 @@ split_data_refs_to_components (struct loop *loop,\n \t  comps[ca] = comp;\n \t}\n \n-      dataref = XCNEW (struct dref_d);\n+      dataref = XCNEW (class dref_d);\n       dataref->ref = dr;\n       dataref->stmt = DR_STMT (dr);\n       dataref->offset = 0;\n@@ -931,7 +931,7 @@ split_data_refs_to_components (struct loop *loop,\n    loop.  */\n \n static bool\n-suitable_component_p (struct loop *loop, struct component *comp)\n+suitable_component_p (class loop *loop, struct component *comp)\n {\n   unsigned i;\n   dref a, first;\n@@ -987,7 +987,7 @@ suitable_component_p (struct loop *loop, struct component *comp)\n    the beginning of this file.  LOOP is the current loop.  */\n \n static struct component *\n-filter_suitable_components (struct loop *loop, struct component *comps)\n+filter_suitable_components (class loop *loop, struct component *comps)\n {\n   struct component **comp, *act;\n \n@@ -1232,7 +1232,7 @@ valid_initializer_p (struct data_reference *ref,\n    is the root of the current chain.  */\n \n static gphi *\n-find_looparound_phi (struct loop *loop, dref ref, dref root)\n+find_looparound_phi (class loop *loop, dref ref, dref root)\n {\n   tree name, init, init_ref;\n   gphi *phi = NULL;\n@@ -1296,7 +1296,7 @@ find_looparound_phi (struct loop *loop, dref ref, dref root)\n static void\n insert_looparound_copy (chain_p chain, dref ref, gphi *phi)\n {\n-  dref nw = XCNEW (struct dref_d), aref;\n+  dref nw = XCNEW (class dref_d), aref;\n   unsigned i;\n \n   nw->stmt = phi;\n@@ -1321,7 +1321,7 @@ insert_looparound_copy (chain_p chain, dref ref, gphi *phi)\n    (also, it may allow us to combine chains together).  */\n \n static void\n-add_looparound_copies (struct loop *loop, chain_p chain)\n+add_looparound_copies (class loop *loop, chain_p chain)\n {\n   unsigned i;\n   dref ref, root = get_chain_root (chain);\n@@ -1346,7 +1346,7 @@ add_looparound_copies (struct loop *loop, chain_p chain)\n    loop.  */\n \n static void\n-determine_roots_comp (struct loop *loop,\n+determine_roots_comp (class loop *loop,\n \t\t      struct component *comp,\n \t\t      vec<chain_p> *chains)\n {\n@@ -1436,7 +1436,7 @@ determine_roots_comp (struct loop *loop,\n    separates the references to CHAINS.  LOOP is the current loop.  */\n \n static void\n-determine_roots (struct loop *loop,\n+determine_roots (class loop *loop,\n \t\t struct component *comps, vec<chain_p> *chains)\n {\n   struct component *comp;\n@@ -1653,7 +1653,7 @@ predcom_tmp_var (tree ref, unsigned i, bitmap tmp_vars)\n    temporary variables are marked in TMP_VARS.  */\n \n static void\n-initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n+initialize_root_vars (class loop *loop, chain_p chain, bitmap tmp_vars)\n {\n   unsigned i;\n   unsigned n = chain->length;\n@@ -1707,7 +1707,7 @@ initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n    In this case, we can use these invariant values directly after LOOP.  */\n \n static bool\n-is_inv_store_elimination_chain (struct loop *loop, chain_p chain)\n+is_inv_store_elimination_chain (class loop *loop, chain_p chain)\n {\n   if (chain->length == 0 || chain->type != CT_STORE_STORE)\n     return false;\n@@ -1801,7 +1801,7 @@ initialize_root_vars_store_elim_1 (chain_p chain)\n    of the newly created root variables are marked in TMP_VARS.  */\n \n static void\n-initialize_root_vars_store_elim_2 (struct loop *loop,\n+initialize_root_vars_store_elim_2 (class loop *loop,\n \t\t\t\t   chain_p chain, bitmap tmp_vars)\n {\n   unsigned i, n = chain->length;\n@@ -1886,7 +1886,7 @@ initialize_root_vars_store_elim_2 (struct loop *loop,\n    (CHAIN->length - 1) iterations.  */\n \n static void\n-finalize_eliminated_stores (struct loop *loop, chain_p chain)\n+finalize_eliminated_stores (class loop *loop, chain_p chain)\n {\n   unsigned i, n = chain->length;\n \n@@ -1914,7 +1914,7 @@ finalize_eliminated_stores (struct loop *loop, chain_p chain)\n    initializer.  */\n \n static void\n-initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n+initialize_root_vars_lm (class loop *loop, dref root, bool written,\n \t\t\t vec<tree> *vars, vec<tree> inits,\n \t\t\t bitmap tmp_vars)\n {\n@@ -1962,7 +1962,7 @@ initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n    created temporary variables are marked in TMP_VARS.  */\n \n static void\n-execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n+execute_load_motion (class loop *loop, chain_p chain, bitmap tmp_vars)\n {\n   auto_vec<tree> vars;\n   dref a;\n@@ -2103,7 +2103,7 @@ remove_stmt (gimple *stmt)\n    Uids of the newly created temporary variables are marked in TMP_VARS.*/\n \n static void\n-execute_pred_commoning_chain (struct loop *loop, chain_p chain,\n+execute_pred_commoning_chain (class loop *loop, chain_p chain,\n \t\t\t      bitmap tmp_vars)\n {\n   unsigned i;\n@@ -2234,7 +2234,7 @@ determine_unroll_factor (vec<chain_p> chains)\n    Uids of the newly created temporary variables are marked in TMP_VARS.  */\n \n static void\n-execute_pred_commoning (struct loop *loop, vec<chain_p> chains,\n+execute_pred_commoning (class loop *loop, vec<chain_p> chains,\n \t\t\tbitmap tmp_vars)\n {\n   chain_p chain;\n@@ -2317,7 +2317,7 @@ struct epcc_data\n };\n \n static void\n-execute_pred_commoning_cbck (struct loop *loop, void *data)\n+execute_pred_commoning_cbck (class loop *loop, void *data)\n {\n   struct epcc_data *const dta = (struct epcc_data *) data;\n \n@@ -2333,7 +2333,7 @@ execute_pred_commoning_cbck (struct loop *loop, void *data)\n    the header of the LOOP.  */\n \n static void\n-base_names_in_chain_on (struct loop *loop, tree name, tree var)\n+base_names_in_chain_on (class loop *loop, tree name, tree var)\n {\n   gimple *stmt, *phi;\n   imm_use_iterator iter;\n@@ -2366,7 +2366,7 @@ base_names_in_chain_on (struct loop *loop, tree name, tree var)\n    for those we want to perform this.  */\n \n static void\n-eliminate_temp_copies (struct loop *loop, bitmap tmp_vars)\n+eliminate_temp_copies (class loop *loop, bitmap tmp_vars)\n {\n   edge e;\n   gphi *phi;\n@@ -2751,7 +2751,7 @@ combine_chains (chain_p ch1, chain_p ch2)\n   for (i = 0; (ch1->refs.iterate (i, &r1)\n \t       && ch2->refs.iterate (i, &r2)); i++)\n     {\n-      nw = XCNEW (struct dref_d);\n+      nw = XCNEW (class dref_d);\n       nw->stmt = stmt_combining_refs (r1, r2);\n       nw->distance = r1->distance;\n \n@@ -2801,7 +2801,7 @@ pcom_stmt_dominates_stmt_p (gimple *s1, gimple *s2)\n /* Try to combine the CHAINS in LOOP.  */\n \n static void\n-try_combine_chains (struct loop *loop, vec<chain_p> *chains)\n+try_combine_chains (class loop *loop, vec<chain_p> *chains)\n {\n   unsigned i, j;\n   chain_p ch1, ch2, cch;\n@@ -2911,7 +2911,7 @@ try_combine_chains (struct loop *loop, vec<chain_p> *chains)\n    otherwise.  */\n \n static bool\n-prepare_initializers_chain_store_elim (struct loop *loop, chain_p chain)\n+prepare_initializers_chain_store_elim (class loop *loop, chain_p chain)\n {\n   unsigned i, n = chain->length;\n \n@@ -2978,7 +2978,7 @@ prepare_initializers_chain_store_elim (struct loop *loop, chain_p chain)\n    impossible because one of these initializers may trap, true otherwise.  */\n \n static bool\n-prepare_initializers_chain (struct loop *loop, chain_p chain)\n+prepare_initializers_chain (class loop *loop, chain_p chain)\n {\n   unsigned i, n = (chain->type == CT_INVARIANT) ? 1 : chain->length;\n   struct data_reference *dr = get_chain_root (chain)->ref;\n@@ -3034,7 +3034,7 @@ prepare_initializers_chain (struct loop *loop, chain_p chain)\n    be used because the initializers might trap.  */\n \n static void\n-prepare_initializers (struct loop *loop, vec<chain_p> chains)\n+prepare_initializers (class loop *loop, vec<chain_p> chains)\n {\n   chain_p chain;\n   unsigned i;\n@@ -3056,7 +3056,7 @@ prepare_initializers (struct loop *loop, vec<chain_p> chains)\n    if finalizer code for CHAIN can be generated, otherwise false.  */\n \n static bool\n-prepare_finalizers_chain (struct loop *loop, chain_p chain)\n+prepare_finalizers_chain (class loop *loop, chain_p chain)\n {\n   unsigned i, n = chain->length;\n   struct data_reference *dr = get_chain_root (chain)->ref;\n@@ -3104,7 +3104,7 @@ prepare_finalizers_chain (struct loop *loop, chain_p chain)\n    if finalizer code generation for CHAINS breaks loop closed ssa form.  */\n \n static bool\n-prepare_finalizers (struct loop *loop, vec<chain_p> chains)\n+prepare_finalizers (class loop *loop, vec<chain_p> chains)\n {\n   chain_p chain;\n   unsigned i;\n@@ -3143,7 +3143,7 @@ prepare_finalizers (struct loop *loop, vec<chain_p> chains)\n /* Insert all initializing gimple stmts into loop's entry edge.  */\n \n static void\n-insert_init_seqs (struct loop *loop, vec<chain_p> chains)\n+insert_init_seqs (class loop *loop, vec<chain_p> chains)\n {\n   unsigned i;\n   edge entry = loop_preheader_edge (loop);\n@@ -3161,14 +3161,14 @@ insert_init_seqs (struct loop *loop, vec<chain_p> chains)\n    form was corrupted.  */\n \n static unsigned\n-tree_predictive_commoning_loop (struct loop *loop)\n+tree_predictive_commoning_loop (class loop *loop)\n {\n   vec<data_reference_p> datarefs;\n   vec<ddr_p> dependences;\n   struct component *components;\n   vec<chain_p> chains = vNULL;\n   unsigned unroll_factor;\n-  struct tree_niter_desc desc;\n+  class tree_niter_desc desc;\n   bool unroll = false, loop_closed_ssa = false;\n   edge exit;\n \n@@ -3304,7 +3304,7 @@ end: ;\n unsigned\n tree_predictive_commoning (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   unsigned ret = 0, changed = 0;\n \n   initialize_original_copy_tables ();"}, {"sha": "4b72a25d350a1c766ca726346d18d4575ed9e8ff", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -286,8 +286,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"case-cfn-macros.h\"\n \n-static tree analyze_scalar_evolution_1 (struct loop *, tree);\n-static tree analyze_scalar_evolution_for_address_of (struct loop *loop,\n+static tree analyze_scalar_evolution_1 (class loop *, tree);\n+static tree analyze_scalar_evolution_for_address_of (class loop *loop,\n \t\t\t\t\t\t     tree var);\n \n /* The cached information about an SSA name with version NAME_VERSION,\n@@ -445,7 +445,7 @@ loop_phi_node_p (gimple *phi)\n */\n \n tree\n-compute_overall_effect_of_inner_loop (struct loop *loop, tree evolution_fn)\n+compute_overall_effect_of_inner_loop (class loop *loop, tree evolution_fn)\n {\n   bool val = false;\n \n@@ -454,7 +454,7 @@ compute_overall_effect_of_inner_loop (struct loop *loop, tree evolution_fn)\n \n   else if (TREE_CODE (evolution_fn) == POLYNOMIAL_CHREC)\n     {\n-      struct loop *inner_loop = get_chrec_loop (evolution_fn);\n+      class loop *inner_loop = get_chrec_loop (evolution_fn);\n \n       if (inner_loop == loop\n \t  || flow_loop_nested_p (loop, inner_loop))\n@@ -593,7 +593,7 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \t\t    gimple *at_stmt)\n {\n   tree type, left, right;\n-  struct loop *loop = get_loop (cfun, loop_nb), *chloop;\n+  class loop *loop = get_loop (cfun, loop_nb), *chloop;\n \n   switch (TREE_CODE (chrec_before))\n     {\n@@ -840,7 +840,7 @@ add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n    analyze, then give up.  */\n \n gcond *\n-get_loop_exit_condition (const struct loop *loop)\n+get_loop_exit_condition (const class loop *loop)\n {\n   gcond *res = NULL;\n   edge exit_edge = single_exit (loop);\n@@ -876,14 +876,14 @@ enum t_bool {\n };\n \n \n-static t_bool follow_ssa_edge (struct loop *loop, gimple *, gphi *,\n+static t_bool follow_ssa_edge (class loop *loop, gimple *, gphi *,\n \t\t\t       tree *, int);\n \n /* Follow the ssa edge into the binary expression RHS0 CODE RHS1.\n    Return true if the strongly connected component has been found.  */\n \n static t_bool\n-follow_ssa_edge_binary (struct loop *loop, gimple *at_stmt,\n+follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t\t\ttree type, tree rhs0, enum tree_code code, tree rhs1,\n \t\t\tgphi *halting_phi, tree *evolution_of_loop,\n \t\t\tint limit)\n@@ -1018,7 +1018,7 @@ follow_ssa_edge_binary (struct loop *loop, gimple *at_stmt,\n    Return true if the strongly connected component has been found.  */\n \n static t_bool\n-follow_ssa_edge_expr (struct loop *loop, gimple *at_stmt, tree expr,\n+follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n \t\t      gphi *halting_phi, tree *evolution_of_loop,\n \t\t      int limit)\n {\n@@ -1109,7 +1109,7 @@ follow_ssa_edge_expr (struct loop *loop, gimple *at_stmt, tree expr,\n    Return true if the strongly connected component has been found.  */\n \n static t_bool\n-follow_ssa_edge_in_rhs (struct loop *loop, gimple *stmt,\n+follow_ssa_edge_in_rhs (class loop *loop, gimple *stmt,\n \t\t\tgphi *halting_phi, tree *evolution_of_loop,\n \t\t\tint limit)\n {\n@@ -1170,7 +1170,7 @@ backedge_phi_arg_p (gphi *phi, int i)\n \n static inline t_bool\n follow_ssa_edge_in_condition_phi_branch (int i,\n-\t\t\t\t\t struct loop *loop,\n+\t\t\t\t\t class loop *loop,\n \t\t\t\t\t gphi *condition_phi,\n \t\t\t\t\t gphi *halting_phi,\n \t\t\t\t\t tree *evolution_of_branch,\n@@ -1205,7 +1205,7 @@ follow_ssa_edge_in_condition_phi_branch (int i,\n    loop.  */\n \n static t_bool\n-follow_ssa_edge_in_condition_phi (struct loop *loop,\n+follow_ssa_edge_in_condition_phi (class loop *loop,\n \t\t\t\t  gphi *condition_phi,\n \t\t\t\t  gphi *halting_phi,\n \t\t\t\t  tree *evolution_of_loop, int limit)\n@@ -1252,12 +1252,12 @@ follow_ssa_edge_in_condition_phi (struct loop *loop,\n    considered as a single statement.  */\n \n static t_bool\n-follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n+follow_ssa_edge_inner_loop_phi (class loop *outer_loop,\n \t\t\t\tgphi *loop_phi_node,\n \t\t\t\tgphi *halting_phi,\n \t\t\t\ttree *evolution_of_loop, int limit)\n {\n-  struct loop *loop = loop_containing_stmt (loop_phi_node);\n+  class loop *loop = loop_containing_stmt (loop_phi_node);\n   tree ev = analyze_scalar_evolution (loop, PHI_RESULT (loop_phi_node));\n \n   /* Sometimes, the inner loop is too difficult to analyze, and the\n@@ -1299,10 +1299,10 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n    path that is analyzed on the return walk.  */\n \n static t_bool\n-follow_ssa_edge (struct loop *loop, gimple *def, gphi *halting_phi,\n+follow_ssa_edge (class loop *loop, gimple *def, gphi *halting_phi,\n \t\t tree *evolution_of_loop, int limit)\n {\n-  struct loop *def_loop;\n+  class loop *def_loop;\n \n   if (gimple_nop_p (def))\n     return t_false;\n@@ -1374,7 +1374,7 @@ follow_ssa_edge (struct loop *loop, gimple *def, gphi *halting_phi,\n    See PR41488.  */\n \n static tree\n-simplify_peeled_chrec (struct loop *loop, tree arg, tree init_cond)\n+simplify_peeled_chrec (class loop *loop, tree arg, tree init_cond)\n {\n   aff_tree aff1, aff2;\n   tree ev, left, right, type, step_val;\n@@ -1432,7 +1432,7 @@ analyze_evolution_in_loop (gphi *loop_phi_node,\n {\n   int i, n = gimple_phi_num_args (loop_phi_node);\n   tree evolution_function = chrec_not_analyzed_yet;\n-  struct loop *loop = loop_containing_stmt (loop_phi_node);\n+  class loop *loop = loop_containing_stmt (loop_phi_node);\n   basic_block bb;\n   static bool simplify_peeled_chrec_p = true;\n \n@@ -1560,7 +1560,7 @@ analyze_initial_condition (gphi *loop_phi_node)\n {\n   int i, n;\n   tree init_cond = chrec_not_analyzed_yet;\n-  struct loop *loop = loop_containing_stmt (loop_phi_node);\n+  class loop *loop = loop_containing_stmt (loop_phi_node);\n \n   if (dump_file && (dump_flags & TDF_SCEV))\n     {\n@@ -1617,10 +1617,10 @@ analyze_initial_condition (gphi *loop_phi_node)\n /* Analyze the scalar evolution for LOOP_PHI_NODE.  */\n \n static tree\n-interpret_loop_phi (struct loop *loop, gphi *loop_phi_node)\n+interpret_loop_phi (class loop *loop, gphi *loop_phi_node)\n {\n   tree res;\n-  struct loop *phi_loop = loop_containing_stmt (loop_phi_node);\n+  class loop *phi_loop = loop_containing_stmt (loop_phi_node);\n   tree init_cond;\n \n   gcc_assert (phi_loop == loop);\n@@ -1654,7 +1654,7 @@ interpret_loop_phi (struct loop *loop, gphi *loop_phi_node)\n    analyzed.  */\n \n static tree\n-interpret_condition_phi (struct loop *loop, gphi *condition_phi)\n+interpret_condition_phi (class loop *loop, gphi *condition_phi)\n {\n   int i, n = gimple_phi_num_args (condition_phi);\n   tree res = chrec_not_analyzed_yet;\n@@ -1688,7 +1688,7 @@ interpret_condition_phi (struct loop *loop, gphi *condition_phi)\n    analyze the effect of an inner loop: see interpret_loop_phi.  */\n \n static tree\n-interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n+interpret_rhs_expr (class loop *loop, gimple *at_stmt,\n \t\t    tree type, tree rhs1, enum tree_code code, tree rhs2)\n {\n   tree res, chrec1, chrec2, ctype;\n@@ -1958,7 +1958,7 @@ interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n /* Interpret the expression EXPR.  */\n \n static tree\n-interpret_expr (struct loop *loop, gimple *at_stmt, tree expr)\n+interpret_expr (class loop *loop, gimple *at_stmt, tree expr)\n {\n   enum tree_code code;\n   tree type = TREE_TYPE (expr), op0, op1;\n@@ -1980,7 +1980,7 @@ interpret_expr (struct loop *loop, gimple *at_stmt, tree expr)\n /* Interpret the rhs of the assignment STMT.  */\n \n static tree\n-interpret_gimple_assign (struct loop *loop, gimple *stmt)\n+interpret_gimple_assign (class loop *loop, gimple *stmt)\n {\n   tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n@@ -2001,11 +2001,11 @@ interpret_gimple_assign (struct loop *loop, gimple *stmt)\n /* Helper recursive function.  */\n \n static tree\n-analyze_scalar_evolution_1 (struct loop *loop, tree var)\n+analyze_scalar_evolution_1 (class loop *loop, tree var)\n {\n   gimple *def;\n   basic_block bb;\n-  struct loop *def_loop;\n+  class loop *def_loop;\n   tree res;\n \n   if (TREE_CODE (var) != SSA_NAME)\n@@ -2025,7 +2025,7 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var)\n   if (loop != def_loop)\n     {\n       res = analyze_scalar_evolution_1 (def_loop, var);\n-      struct loop *loop_to_skip = superloop_at_depth (def_loop,\n+      class loop *loop_to_skip = superloop_at_depth (def_loop,\n \t\t\t\t\t\t      loop_depth (loop) + 1);\n       res = compute_overall_effect_of_inner_loop (loop_to_skip, res);\n       if (chrec_contains_symbols_defined_in_loop (res, loop->num))\n@@ -2077,7 +2077,7 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var)\n */\n \n tree\n-analyze_scalar_evolution (struct loop *loop, tree var)\n+analyze_scalar_evolution (class loop *loop, tree var)\n {\n   tree res;\n \n@@ -2122,7 +2122,7 @@ analyze_scalar_evolution (struct loop *loop, tree var)\n /* Analyzes and returns the scalar evolution of VAR address in LOOP.  */\n \n static tree\n-analyze_scalar_evolution_for_address_of (struct loop *loop, tree var)\n+analyze_scalar_evolution_for_address_of (class loop *loop, tree var)\n {\n   return analyze_scalar_evolution (loop, build_fold_addr_expr (var));\n }\n@@ -2178,7 +2178,7 @@ analyze_scalar_evolution_for_address_of (struct loop *loop, tree var)\n    */\n \n static tree\n-analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n+analyze_scalar_evolution_in_loop (class loop *wrto_loop, class loop *use_loop,\n \t\t\t\t  tree version, bool *folded_casts)\n {\n   bool val = false;\n@@ -2278,7 +2278,7 @@ get_instantiated_value_entry (instantiate_cache_type &cache,\n static tree\n loop_closed_phi_def (tree var)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   edge exit;\n   gphi *phi;\n   gphi_iterator psi;\n@@ -2302,7 +2302,7 @@ loop_closed_phi_def (tree var)\n   return NULL_TREE;\n }\n \n-static tree instantiate_scev_r (edge, struct loop *, struct loop *,\n+static tree instantiate_scev_r (edge, class loop *, class loop *,\n \t\t\t\ttree, bool *, int);\n \n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n@@ -2322,13 +2322,13 @@ static tree instantiate_scev_r (edge, struct loop *, struct loop *,\n \n static tree\n instantiate_scev_name (edge instantiate_below,\n-\t\t       struct loop *evolution_loop, struct loop *inner_loop,\n+\t\t       class loop *evolution_loop, class loop *inner_loop,\n \t\t       tree chrec,\n \t\t       bool *fold_conversions,\n \t\t       int size_expr)\n {\n   tree res;\n-  struct loop *def_loop;\n+  class loop *def_loop;\n   basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (chrec));\n \n   /* A parameter, nothing to do.  */\n@@ -2472,7 +2472,7 @@ instantiate_scev_name (edge instantiate_below,\n \n static tree\n instantiate_scev_poly (edge instantiate_below,\n-\t\t       struct loop *evolution_loop, struct loop *,\n+\t\t       class loop *evolution_loop, class loop *,\n \t\t       tree chrec, bool *fold_conversions, int size_expr)\n {\n   tree op1;\n@@ -2517,7 +2517,7 @@ instantiate_scev_poly (edge instantiate_below,\n \n static tree\n instantiate_scev_binary (edge instantiate_below,\n-\t\t\t struct loop *evolution_loop, struct loop *inner_loop,\n+\t\t\t class loop *evolution_loop, class loop *inner_loop,\n \t\t\t tree chrec, enum tree_code code,\n \t\t\t tree type, tree c0, tree c1,\n \t\t\t bool *fold_conversions, int size_expr)\n@@ -2585,7 +2585,7 @@ instantiate_scev_binary (edge instantiate_below,\n \n static tree\n instantiate_scev_convert (edge instantiate_below,\n-\t\t\t  struct loop *evolution_loop, struct loop *inner_loop,\n+\t\t\t  class loop *evolution_loop, class loop *inner_loop,\n \t\t\t  tree chrec, tree type, tree op,\n \t\t\t  bool *fold_conversions, int size_expr)\n {\n@@ -2636,7 +2636,7 @@ instantiate_scev_convert (edge instantiate_below,\n \n static tree\n instantiate_scev_not (edge instantiate_below,\n-\t\t      struct loop *evolution_loop, struct loop *inner_loop,\n+\t\t      class loop *evolution_loop, class loop *inner_loop,\n \t\t      tree chrec,\n \t\t      enum tree_code code, tree type, tree op,\n \t\t      bool *fold_conversions, int size_expr)\n@@ -2687,7 +2687,7 @@ instantiate_scev_not (edge instantiate_below,\n \n static tree\n instantiate_scev_r (edge instantiate_below,\n-\t\t    struct loop *evolution_loop, struct loop *inner_loop,\n+\t\t    class loop *evolution_loop, class loop *inner_loop,\n \t\t    tree chrec,\n \t\t    bool *fold_conversions, int size_expr)\n {\n@@ -2761,7 +2761,7 @@ instantiate_scev_r (edge instantiate_below,\n    a function parameter.  */\n \n tree\n-instantiate_scev (edge instantiate_below, struct loop *evolution_loop,\n+instantiate_scev (edge instantiate_below, class loop *evolution_loop,\n \t\t  tree chrec)\n {\n   tree res;\n@@ -2810,7 +2810,7 @@ instantiate_scev (edge instantiate_below, struct loop *evolution_loop,\n    of an expression.  */\n \n tree\n-resolve_mixers (struct loop *loop, tree chrec, bool *folded_casts)\n+resolve_mixers (class loop *loop, tree chrec, bool *folded_casts)\n {\n   bool destr = false;\n   bool fold_conversions = false;\n@@ -2859,10 +2859,10 @@ resolve_mixers (struct loop *loop, tree chrec, bool *folded_casts)\n    the loop body has been executed 6 times.  */\n \n tree\n-number_of_latch_executions (struct loop *loop)\n+number_of_latch_executions (class loop *loop)\n {\n   edge exit;\n-  struct tree_niter_desc niter_desc;\n+  class tree_niter_desc niter_desc;\n   tree may_be_zero;\n   tree res;\n \n@@ -3047,7 +3047,7 @@ gather_stats_on_scev_database (void)\n void\n scev_initialize (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   gcc_assert (! scev_initialized_p ());\n \n@@ -3085,7 +3085,7 @@ scev_reset_htab (void)\n void\n scev_reset (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   scev_reset_htab ();\n \n@@ -3104,7 +3104,7 @@ scev_reset (void)\n    hypotetical IVs to be inserted into code.  */\n \n bool\n-iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n+iv_can_overflow_p (class loop *loop, tree type, tree base, tree step)\n {\n   widest_int nit;\n   wide_int base_min, base_max, step_min, step_max, type_min, type_max;\n@@ -3267,7 +3267,7 @@ derive_simple_iv_with_niters (tree ev, tree *niters)\n    infinite.  */\n \n bool\n-simple_iv_with_niters (struct loop *wrto_loop, struct loop *use_loop,\n+simple_iv_with_niters (class loop *wrto_loop, class loop *use_loop,\n \t\t       tree op, affine_iv *iv, tree *iv_niters,\n \t\t       bool allow_nonconstant_step)\n {\n@@ -3407,7 +3407,7 @@ simple_iv_with_niters (struct loop *wrto_loop, struct loop *use_loop,\n    affine iv unconditionally.  */\n \n bool\n-simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n+simple_iv (class loop *wrto_loop, class loop *use_loop, tree op,\n \t   affine_iv *iv, bool allow_nonconstant_step)\n {\n   return simple_iv_with_niters (wrto_loop, use_loop, op, iv,\n@@ -3565,7 +3565,7 @@ expression_expensive_p (tree expr)\n /* Do final value replacement for LOOP, return true if we did anything.  */\n \n bool\n-final_value_replacement_loop (struct loop *loop)\n+final_value_replacement_loop (class loop *loop)\n {\n   /* If we do not know exact number of iterations of the loop, we cannot\n      replace the final value.  */\n@@ -3584,7 +3584,7 @@ final_value_replacement_loop (struct loop *loop)\n   /* Set stmt insertion pointer.  All stmts are inserted before this point.  */\n   gimple_stmt_iterator gsi = gsi_after_labels (exit->dest);\n \n-  struct loop *ex_loop\n+  class loop *ex_loop\n     = superloop_at_depth (loop,\n \t\t\t  loop_depth (exit->dest->loop_father) + 1);\n "}, {"sha": "d4d6ec58e538ab46eb754f6f5a2292f5a56c638b", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -21,27 +21,27 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SCALAR_EVOLUTION_H\n #define GCC_TREE_SCALAR_EVOLUTION_H\n \n-extern tree number_of_latch_executions (struct loop *);\n-extern gcond *get_loop_exit_condition (const struct loop *);\n+extern tree number_of_latch_executions (class loop *);\n+extern gcond *get_loop_exit_condition (const class loop *);\n \n extern void scev_initialize (void);\n extern bool scev_initialized_p (void);\n extern void scev_reset (void);\n extern void scev_reset_htab (void);\n extern void scev_finalize (void);\n-extern tree analyze_scalar_evolution (struct loop *, tree);\n-extern tree instantiate_scev (edge, struct loop *, tree);\n-extern tree resolve_mixers (struct loop *, tree, bool *);\n+extern tree analyze_scalar_evolution (class loop *, tree);\n+extern tree instantiate_scev (edge, class loop *, tree);\n+extern tree resolve_mixers (class loop *, tree, bool *);\n extern void gather_stats_on_scev_database (void);\n-extern bool final_value_replacement_loop (struct loop *);\n+extern bool final_value_replacement_loop (class loop *);\n extern unsigned int scev_const_prop (void);\n extern bool expression_expensive_p (tree);\n-extern bool simple_iv_with_niters (struct loop *, struct loop *, tree,\n+extern bool simple_iv_with_niters (class loop *, class loop *, tree,\n \t\t\t\t   struct affine_iv *, tree *, bool);\n-extern bool simple_iv (struct loop *, struct loop *, tree, struct affine_iv *,\n+extern bool simple_iv (class loop *, class loop *, tree, struct affine_iv *,\n \t\t       bool);\n-extern bool iv_can_overflow_p (struct loop *, tree, tree, tree);\n-extern tree compute_overall_effect_of_inner_loop (struct loop *, tree);\n+extern bool iv_can_overflow_p (class loop *, tree, tree, tree);\n+extern tree compute_overall_effect_of_inner_loop (class loop *, tree);\n \n /* Returns the basic block preceding LOOP, or the CFG entry block when\n    the loop is function's body.  */\n@@ -58,14 +58,14 @@ block_before_loop (loop_p loop)\n    be analyzed and instantiated.  */\n \n static inline tree\n-instantiate_parameters (struct loop *loop, tree chrec)\n+instantiate_parameters (class loop *loop, tree chrec)\n {\n   return instantiate_scev (loop_preheader_edge (loop), loop, chrec);\n }\n \n /* Returns the loop of the polynomial chrec CHREC.  */\n \n-static inline struct loop *\n+static inline class loop *\n get_chrec_loop (const_tree chrec)\n {\n   return get_loop (cfun, CHREC_VARIABLE (chrec));"}, {"sha": "05a2321248842ec6d7234e4df4edf22ee911c643", "filename": "gcc/tree-ssa-address.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-address.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-address.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -33,9 +33,9 @@ extern void get_address_description (tree, struct mem_address *);\n extern tree tree_mem_ref_addr (tree, tree);\n extern bool valid_mem_ref_p (machine_mode, addr_space_t, struct mem_address *);\n extern void move_fixed_address_to_symbol (struct mem_address *,\n-\t\t\t\t\t  struct aff_tree *);\n+\t\t\t\t\t  class aff_tree *);\n tree create_mem_ref (gimple_stmt_iterator *, tree,\n-\t\t     struct aff_tree *, tree, tree, tree, bool);\n+\t\t     class aff_tree *, tree, tree, tree, bool);\n extern void copy_ref_info (tree, tree);\n tree maybe_fold_tmr (tree);\n "}, {"sha": "6398c1e44576a99613f398d42049b67be1c46838", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -411,7 +411,7 @@ find_obviously_necessary_stmts (bool aggressive)\n   /* Prevent the empty possibly infinite loops from being removed.  */\n   if (aggressive)\n     {\n-      struct loop *loop;\n+      class loop *loop;\n       if (mark_irreducible_loops ())\n \tFOR_EACH_BB_FN (bb, cfun)\n \t  {"}, {"sha": "2d0386670e6d51b42df6a4eea05bb8283287ada3", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -395,7 +395,7 @@ edge_info::record_simple_equiv (tree lhs, tree rhs)\n void\n free_dom_edge_info (edge e)\n {\n-  class edge_info *edge_info = (struct edge_info *)e->aux;\n+  class edge_info *edge_info = (class edge_info *)e->aux;\n \n   if (edge_info)\n     delete edge_info;\n@@ -543,7 +543,7 @@ record_edge_info (basic_block bb)\n               bool can_infer_simple_equiv\n                 = !(HONOR_SIGNED_ZEROS (op0)\n                     && real_zerop (op0));\n-              struct edge_info *edge_info;\n+\t      class edge_info *edge_info;\n \n \t      edge_info = new class edge_info (true_edge);\n               record_conditions (&edge_info->cond_equivalences, cond, inverted);\n@@ -567,7 +567,7 @@ record_edge_info (basic_block bb)\n               bool can_infer_simple_equiv\n                 = !(HONOR_SIGNED_ZEROS (op1)\n                     && (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));\n-              struct edge_info *edge_info;\n+\t      class edge_info *edge_info;\n \n \t      edge_info = new class edge_info (true_edge);\n               record_conditions (&edge_info->cond_equivalences, cond, inverted);"}, {"sha": "99087946c3e985da791d11e1d302d1ff4d18a206", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -79,7 +79,7 @@ var_map_base_fini (var_map map)\n    function.  */\n \n var_map\n-init_var_map (int size, struct loop *loop)\n+init_var_map (int size, class loop *loop)\n {\n   var_map map;\n \n@@ -852,7 +852,7 @@ remove_unused_locals (void)\n \n   if (cfun->has_simduid_loops)\n     {\n-      struct loop *loop;\n+      class loop *loop;\n       FOR_EACH_LOOP (loop, 0)\n \tif (loop->simduid && !is_used_p (loop->simduid))\n \t  loop->simduid = NULL_TREE;"}, {"sha": "5bef4d5d7670a97400851558777c07a8ab74c2f8", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -80,7 +80,7 @@ typedef struct _var_map\n /* Value used to represent no partition number.  */\n #define NO_PARTITION\t\t-1\n \n-extern var_map init_var_map (int, struct loop* = NULL);\n+extern var_map init_var_map (int, class loop* = NULL);\n extern void delete_var_map (var_map);\n extern int var_union (var_map, tree, tree);\n extern void partition_view_normal (var_map);"}, {"sha": "d92d7c856901c46abe4fb24781a026f7ba617590", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n    amount.  */\n \n static bool\n-should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n+should_duplicate_loop_header_p (basic_block header, class loop *loop,\n \t\t\t\tint *limit)\n {\n   gimple_stmt_iterator bsi;\n@@ -211,7 +211,7 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n /* Checks whether LOOP is a do-while style loop.  */\n \n static bool\n-do_while_loop_p (struct loop *loop)\n+do_while_loop_p (class loop *loop)\n {\n   gimple *stmt = last_stmt (loop->latch);\n \n@@ -268,7 +268,7 @@ class ch_base : public gimple_opt_pass\n   unsigned int copy_headers (function *fun);\n \n   /* Return true to copy headers of LOOP or false to skip.  */\n-  virtual bool process_loop_p (struct loop *loop) = 0;\n+  virtual bool process_loop_p (class loop *loop) = 0;\n };\n \n const pass_data pass_data_ch =\n@@ -301,7 +301,7 @@ class pass_ch : public ch_base\n \n protected:\n   /* ch_base method: */\n-  virtual bool process_loop_p (struct loop *loop);\n+  virtual bool process_loop_p (class loop *loop);\n }; // class pass_ch\n \n const pass_data pass_data_ch_vect =\n@@ -339,7 +339,7 @@ class pass_ch_vect : public ch_base\n \n protected:\n   /* ch_base method: */\n-  virtual bool process_loop_p (struct loop *loop);\n+  virtual bool process_loop_p (class loop *loop);\n }; // class pass_ch_vect\n \n /* For all loops, copy the condition at the end of the loop body in front\n@@ -349,7 +349,7 @@ class pass_ch_vect : public ch_base\n unsigned int\n ch_base::copy_headers (function *fun)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   basic_block header;\n   edge exit, entry;\n   basic_block *bbs, *copied_bbs;\n@@ -549,15 +549,15 @@ pass_ch_vect::execute (function *fun)\n /* Apply header copying according to a very simple test of do-while shape.  */\n \n bool\n-pass_ch::process_loop_p (struct loop *loop)\n+pass_ch::process_loop_p (class loop *loop)\n {\n   return !do_while_loop_p (loop);\n }\n \n /* Apply header-copying to loops where we might enable vectorization.  */\n \n bool\n-pass_ch_vect::process_loop_p (struct loop *loop)\n+pass_ch_vect::process_loop_p (class loop *loop)\n {\n   if (!flag_tree_loop_vectorize && !loop->force_vectorize)\n     return false;"}, {"sha": "12176e076364317452f4e2f92e985ac7b2d73064", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -75,13 +75,13 @@ along with GCC; see the file COPYING3.  If not see\n \n struct lim_aux_data\n {\n-  struct loop *max_loop;\t/* The outermost loop in that the statement\n+  class loop *max_loop;\t/* The outermost loop in that the statement\n \t\t\t\t   is invariant.  */\n \n-  struct loop *tgt_loop;\t/* The loop out of that we want to move the\n+  class loop *tgt_loop;\t/* The loop out of that we want to move the\n \t\t\t\t   invariant.  */\n \n-  struct loop *always_executed_in;\n+  class loop *always_executed_in;\n \t\t\t\t/* The outermost loop for that we are sure\n \t\t\t\t   the statement is executed if the loop\n \t\t\t\t   is entered.  */\n@@ -160,15 +160,15 @@ struct mem_ref_hasher : nofree_ptr_hash <im_mem_ref>\n   static inline bool equal (const im_mem_ref *, const ao_ref *);\n };\n \n-/* A hash function for struct im_mem_ref object OBJ.  */\n+/* A hash function for class im_mem_ref object OBJ.  */\n \n inline hashval_t\n mem_ref_hasher::hash (const im_mem_ref *mem)\n {\n   return mem->hash;\n }\n \n-/* An equality function for struct im_mem_ref object MEM1 with\n+/* An equality function for class im_mem_ref object MEM1 with\n    memory reference OBJ2.  */\n \n inline bool\n@@ -226,15 +226,15 @@ static struct\n static bitmap_obstack lim_bitmap_obstack;\n static obstack mem_ref_obstack;\n \n-static bool ref_indep_loop_p (struct loop *, im_mem_ref *);\n-static bool ref_always_accessed_p (struct loop *, im_mem_ref *, bool);\n+static bool ref_indep_loop_p (class loop *, im_mem_ref *);\n+static bool ref_always_accessed_p (class loop *, im_mem_ref *, bool);\n \n /* Minimum cost of an expensive expression.  */\n #define LIM_EXPENSIVE ((unsigned) PARAM_VALUE (PARAM_LIM_EXPENSIVE))\n \n /* The outermost loop for which execution of the header guarantees that the\n    block will be executed.  */\n-#define ALWAYS_EXECUTED_IN(BB) ((struct loop *) (BB)->aux)\n+#define ALWAYS_EXECUTED_IN(BB) ((class loop *) (BB)->aux)\n #define SET_ALWAYS_EXECUTED_IN(BB, VAL) ((BB)->aux = (void *) (VAL))\n \n /* ID of the shared unanalyzable mem.  */\n@@ -396,12 +396,12 @@ movement_possibility (gimple *stmt)\n    other operands, i.e. the outermost loop enclosing LOOP in that the value\n    of DEF is invariant.  */\n \n-static struct loop *\n-outermost_invariant_loop (tree def, struct loop *loop)\n+static class loop *\n+outermost_invariant_loop (tree def, class loop *loop)\n {\n   gimple *def_stmt;\n   basic_block def_bb;\n-  struct loop *max_loop;\n+  class loop *max_loop;\n   struct lim_aux_data *lim_data;\n \n   if (!def)\n@@ -444,12 +444,12 @@ outermost_invariant_loop (tree def, struct loop *loop)\n    If DEF is not invariant in LOOP, return false.  Otherwise return TRUE.  */\n \n static bool\n-add_dependency (tree def, struct lim_aux_data *data, struct loop *loop,\n+add_dependency (tree def, struct lim_aux_data *data, class loop *loop,\n \t\tbool add_cost)\n {\n   gimple *def_stmt = SSA_NAME_DEF_STMT (def);\n   basic_block def_bb = gimple_bb (def_stmt);\n-  struct loop *max_loop;\n+  class loop *max_loop;\n   struct lim_aux_data *def_data;\n \n   if (!def_bb)\n@@ -560,10 +560,10 @@ stmt_cost (gimple *stmt)\n    REF is independent.  If REF is not independent in LOOP, NULL is returned\n    instead.  */\n \n-static struct loop *\n-outermost_indep_loop (struct loop *outer, struct loop *loop, im_mem_ref *ref)\n+static class loop *\n+outermost_indep_loop (class loop *outer, class loop *loop, im_mem_ref *ref)\n {\n-  struct loop *aloop;\n+  class loop *aloop;\n \n   if (ref->stored && bitmap_bit_p (ref->stored, loop->num))\n     return NULL;\n@@ -649,8 +649,8 @@ static bool\n determine_max_movement (gimple *stmt, bool must_preserve_exec)\n {\n   basic_block bb = gimple_bb (stmt);\n-  struct loop *loop = bb->loop_father;\n-  struct loop *level;\n+  class loop *loop = bb->loop_father;\n+  class loop *level;\n   struct lim_aux_data *lim_data = get_lim_data (stmt);\n   tree val;\n   ssa_op_iter iter;\n@@ -777,9 +777,9 @@ determine_max_movement (gimple *stmt, bool must_preserve_exec)\n    operands) is hoisted at least out of the loop LEVEL.  */\n \n static void\n-set_level (gimple *stmt, struct loop *orig_loop, struct loop *level)\n+set_level (gimple *stmt, class loop *orig_loop, class loop *level)\n {\n-  struct loop *stmt_loop = gimple_bb (stmt)->loop_father;\n+  class loop *stmt_loop = gimple_bb (stmt)->loop_father;\n   struct lim_aux_data *lim_data;\n   gimple *dep_stmt;\n   unsigned i;\n@@ -974,7 +974,7 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n   gimple_stmt_iterator bsi;\n   gimple *stmt;\n   bool maybe_never = ALWAYS_EXECUTED_IN (bb) == NULL;\n-  struct loop *outermost = ALWAYS_EXECUTED_IN (bb);\n+  class loop *outermost = ALWAYS_EXECUTED_IN (bb);\n   struct lim_aux_data *lim_data;\n \n   if (!loop_outer (bb->loop_father))\n@@ -1053,7 +1053,7 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n \t{\n \t  tree op0 = gimple_assign_rhs1 (stmt);\n \t  tree op1 = gimple_assign_rhs2 (stmt);\n-\t  struct loop *ol1 = outermost_invariant_loop (op1,\n+\t  class loop *ol1 = outermost_invariant_loop (op1,\n \t\t\t\t\tloop_containing_stmt (stmt));\n \n \t  /* If divisor is invariant, convert a/b to a*(1/b), allowing reciprocal\n@@ -1112,7 +1112,7 @@ invariantness_dom_walker::before_dom_children (basic_block bb)\n unsigned int\n move_computations_worker (basic_block bb)\n {\n-  struct loop *level;\n+  class loop *level;\n   unsigned cost = 0;\n   struct lim_aux_data *lim_data;\n   unsigned int todo = 0;\n@@ -1296,7 +1296,7 @@ move_computations (void)\n static bool\n may_move_till (tree ref, tree *index, void *data)\n {\n-  struct loop *loop = (struct loop *) data, *max_loop;\n+  class loop *loop = (class loop *) data, *max_loop;\n \n   /* If REF is an array reference, check also that the step and the lower\n      bound is invariant in LOOP.  */\n@@ -1325,7 +1325,7 @@ may_move_till (tree ref, tree *index, void *data)\n    moved out of the LOOP.  ORIG_LOOP is the loop in that EXPR is used.  */\n \n static void\n-force_move_till_op (tree op, struct loop *orig_loop, struct loop *loop)\n+force_move_till_op (tree op, class loop *orig_loop, class loop *loop)\n {\n   gimple *stmt;\n \n@@ -1348,8 +1348,8 @@ force_move_till_op (tree op, struct loop *orig_loop, struct loop *loop)\n \n struct fmt_data\n {\n-  struct loop *loop;\n-  struct loop *orig_loop;\n+  class loop *loop;\n+  class loop *orig_loop;\n };\n \n static bool\n@@ -1374,7 +1374,7 @@ force_move_till (tree ref, tree *index, void *data)\n /* A function to free the mem_ref object OBJ.  */\n \n static void\n-memref_free (struct im_mem_ref *mem)\n+memref_free (class im_mem_ref *mem)\n {\n   mem->accesses_in_loop.release ();\n }\n@@ -1385,7 +1385,7 @@ memref_free (struct im_mem_ref *mem)\n static im_mem_ref *\n mem_ref_alloc (ao_ref *mem, unsigned hash, unsigned id)\n {\n-  im_mem_ref *ref = XOBNEW (&mem_ref_obstack, struct im_mem_ref);\n+  im_mem_ref *ref = XOBNEW (&mem_ref_obstack, class im_mem_ref);\n   if (mem)\n     ref->mem = *mem;\n   else\n@@ -1418,7 +1418,7 @@ record_mem_ref_loc (im_mem_ref *ref, gimple *stmt, tree *loc)\n    necessary.  Return whether a bit was changed.  */\n \n static bool\n-set_ref_stored_in_loop (im_mem_ref *ref, struct loop *loop)\n+set_ref_stored_in_loop (im_mem_ref *ref, class loop *loop)\n {\n   if (!ref->stored)\n     ref->stored = BITMAP_ALLOC (&lim_bitmap_obstack);\n@@ -1428,7 +1428,7 @@ set_ref_stored_in_loop (im_mem_ref *ref, struct loop *loop)\n /* Marks reference REF as stored in LOOP.  */\n \n static void\n-mark_ref_stored (im_mem_ref *ref, struct loop *loop)\n+mark_ref_stored (im_mem_ref *ref, class loop *loop)\n {\n   while (loop != current_loops->tree_root\n \t && set_ref_stored_in_loop (ref, loop))\n@@ -1441,7 +1441,7 @@ mark_ref_stored (im_mem_ref *ref, struct loop *loop)\n    well.  */\n \n static void\n-gather_mem_refs_stmt (struct loop *loop, gimple *stmt)\n+gather_mem_refs_stmt (class loop *loop, gimple *stmt)\n {\n   tree *mem = NULL;\n   hashval_t hash;\n@@ -1583,8 +1583,8 @@ sort_bbs_in_loop_postorder_cmp (const void *bb1_, const void *bb2_)\n {\n   basic_block bb1 = *(basic_block *)const_cast<void *>(bb1_);\n   basic_block bb2 = *(basic_block *)const_cast<void *>(bb2_);\n-  struct loop *loop1 = bb1->loop_father;\n-  struct loop *loop2 = bb2->loop_father;\n+  class loop *loop1 = bb1->loop_father;\n+  class loop *loop2 = bb2->loop_father;\n   if (loop1->num == loop2->num)\n     return bb1->index - bb2->index;\n   return bb_loop_postorder[loop1->num] < bb_loop_postorder[loop2->num] ? -1 : 1;\n@@ -1597,8 +1597,8 @@ sort_locs_in_loop_postorder_cmp (const void *loc1_, const void *loc2_)\n {\n   mem_ref_loc *loc1 = (mem_ref_loc *)const_cast<void *>(loc1_);\n   mem_ref_loc *loc2 = (mem_ref_loc *)const_cast<void *>(loc2_);\n-  struct loop *loop1 = gimple_bb (loc1->stmt)->loop_father;\n-  struct loop *loop2 = gimple_bb (loc2->stmt)->loop_father;\n+  class loop *loop1 = gimple_bb (loc1->stmt)->loop_father;\n+  class loop *loop2 = gimple_bb (loc2->stmt)->loop_father;\n   if (loop1->num == loop2->num)\n     return 0;\n   return bb_loop_postorder[loop1->num] < bb_loop_postorder[loop2->num] ? -1 : 1;\n@@ -1611,7 +1611,7 @@ analyze_memory_references (void)\n {\n   gimple_stmt_iterator bsi;\n   basic_block bb, *bbs;\n-  struct loop *loop, *outer;\n+  class loop *loop, *outer;\n   unsigned i, n;\n \n   /* Collect all basic-blocks in loops and sort them after their\n@@ -1702,9 +1702,9 @@ mem_refs_may_alias_p (im_mem_ref *mem1, im_mem_ref *mem2,\n static int\n find_ref_loc_in_loop_cmp (const void *loop_, const void *loc_)\n {\n-  struct loop *loop = (struct loop *)const_cast<void *>(loop_);\n+  class loop *loop = (class loop *)const_cast<void *>(loop_);\n   mem_ref_loc *loc = (mem_ref_loc *)const_cast<void *>(loc_);\n-  struct loop *loc_loop = gimple_bb (loc->stmt)->loop_father;\n+  class loop *loc_loop = gimple_bb (loc->stmt)->loop_father;\n   if (loop->num  == loc_loop->num\n       || flow_loop_nested_p (loop, loc_loop))\n     return 0;\n@@ -1719,7 +1719,7 @@ find_ref_loc_in_loop_cmp (const void *loop_, const void *loc_)\n \n template <typename FN>\n static bool\n-for_all_locs_in_loop (struct loop *loop, im_mem_ref *ref, FN fn)\n+for_all_locs_in_loop (class loop *loop, im_mem_ref *ref, FN fn)\n {\n   unsigned i;\n   mem_ref_loc *loc;\n@@ -1776,7 +1776,7 @@ rewrite_mem_ref_loc::operator () (mem_ref_loc *loc)\n /* Rewrites all references to REF in LOOP by variable TMP_VAR.  */\n \n static void\n-rewrite_mem_refs (struct loop *loop, im_mem_ref *ref, tree tmp_var)\n+rewrite_mem_refs (class loop *loop, im_mem_ref *ref, tree tmp_var)\n {\n   for_all_locs_in_loop (loop, ref, rewrite_mem_ref_loc (tmp_var));\n }\n@@ -1801,7 +1801,7 @@ first_mem_ref_loc_1::operator () (mem_ref_loc *loc)\n /* Returns the first reference location to REF in LOOP.  */\n \n static mem_ref_loc *\n-first_mem_ref_loc (struct loop *loop, im_mem_ref *ref)\n+first_mem_ref_loc (class loop *loop, im_mem_ref *ref)\n {\n   mem_ref_loc *locp = NULL;\n   for_all_locs_in_loop (loop, ref, first_mem_ref_loc_1 (&locp));\n@@ -2049,7 +2049,7 @@ sm_set_flag_if_changed::operator () (mem_ref_loc *loc)\n    set, set an appropriate flag indicating the store.  */\n \n static tree\n-execute_sm_if_changed_flag_set (struct loop *loop, im_mem_ref *ref,\n+execute_sm_if_changed_flag_set (class loop *loop, im_mem_ref *ref,\n \t\t\t\thash_set <basic_block> *bbs)\n {\n   tree flag;\n@@ -2065,7 +2065,7 @@ execute_sm_if_changed_flag_set (struct loop *loop, im_mem_ref *ref,\n    to the reference from the temporary variable are emitted to exits.  */\n \n static void\n-execute_sm (struct loop *loop, vec<edge> exits, im_mem_ref *ref)\n+execute_sm (class loop *loop, vec<edge> exits, im_mem_ref *ref)\n {\n   tree tmp_var, store_flag = NULL_TREE;\n   unsigned i;\n@@ -2141,7 +2141,7 @@ execute_sm (struct loop *loop, vec<edge> exits, im_mem_ref *ref)\n    edges of the LOOP.  */\n \n static void\n-hoist_memory_references (struct loop *loop, bitmap mem_refs,\n+hoist_memory_references (class loop *loop, bitmap mem_refs,\n \t\t\t vec<edge> exits)\n {\n   im_mem_ref *ref;\n@@ -2158,17 +2158,17 @@ hoist_memory_references (struct loop *loop, bitmap mem_refs,\n class ref_always_accessed\n {\n public:\n-  ref_always_accessed (struct loop *loop_, bool stored_p_)\n+  ref_always_accessed (class loop *loop_, bool stored_p_)\n       : loop (loop_), stored_p (stored_p_) {}\n   bool operator () (mem_ref_loc *loc);\n-  struct loop *loop;\n+  class loop *loop;\n   bool stored_p;\n };\n \n bool\n ref_always_accessed::operator () (mem_ref_loc *loc)\n {\n-  struct loop *must_exec;\n+  class loop *must_exec;\n \n   if (!get_lim_data (loc->stmt))\n     return false;\n@@ -2198,7 +2198,7 @@ ref_always_accessed::operator () (mem_ref_loc *loc)\n    make sure REF is always stored to in LOOP.  */\n \n static bool\n-ref_always_accessed_p (struct loop *loop, im_mem_ref *ref, bool stored_p)\n+ref_always_accessed_p (class loop *loop, im_mem_ref *ref, bool stored_p)\n {\n   return for_all_locs_in_loop (loop, ref,\n \t\t\t       ref_always_accessed (loop, stored_p));\n@@ -2234,7 +2234,7 @@ refs_independent_p (im_mem_ref *ref1, im_mem_ref *ref2)\n    and its super-loops.  */\n \n static void\n-record_dep_loop (struct loop *loop, im_mem_ref *ref, bool stored_p)\n+record_dep_loop (class loop *loop, im_mem_ref *ref, bool stored_p)\n {\n   /* We can propagate dependent-in-loop bits up the loop\n      hierarchy to all outer loops.  */\n@@ -2247,7 +2247,7 @@ record_dep_loop (struct loop *loop, im_mem_ref *ref, bool stored_p)\n    references in LOOP.  */\n \n static bool\n-ref_indep_loop_p_1 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n+ref_indep_loop_p_1 (class loop *loop, im_mem_ref *ref, bool stored_p)\n {\n   stored_p |= (ref->stored && bitmap_bit_p (ref->stored, loop->num));\n \n@@ -2268,7 +2268,7 @@ ref_indep_loop_p_1 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n       if (bitmap_bit_p (&ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n \treturn false;\n \n-      struct loop *inner = loop->inner;\n+      class loop *inner = loop->inner;\n       while (inner)\n \t{\n \t  if (!ref_indep_loop_p_1 (inner, ref, stored_p))\n@@ -2328,7 +2328,7 @@ ref_indep_loop_p_1 (struct loop *loop, im_mem_ref *ref, bool stored_p)\n    LOOP.  */\n \n static bool\n-ref_indep_loop_p (struct loop *loop, im_mem_ref *ref)\n+ref_indep_loop_p (class loop *loop, im_mem_ref *ref)\n {\n   gcc_checking_assert (MEM_ANALYZABLE (ref));\n \n@@ -2338,7 +2338,7 @@ ref_indep_loop_p (struct loop *loop, im_mem_ref *ref)\n /* Returns true if we can perform store motion of REF from LOOP.  */\n \n static bool\n-can_sm_ref_p (struct loop *loop, im_mem_ref *ref)\n+can_sm_ref_p (class loop *loop, im_mem_ref *ref)\n {\n   tree base;\n \n@@ -2379,7 +2379,7 @@ can_sm_ref_p (struct loop *loop, im_mem_ref *ref)\n    motion was performed in one of the outer loops.  */\n \n static void\n-find_refs_for_sm (struct loop *loop, bitmap sm_executed, bitmap refs_to_sm)\n+find_refs_for_sm (class loop *loop, bitmap sm_executed, bitmap refs_to_sm)\n {\n   bitmap refs = &memory_accesses.all_refs_stored_in_loop[loop->num];\n   unsigned i;\n@@ -2399,7 +2399,7 @@ find_refs_for_sm (struct loop *loop, bitmap sm_executed, bitmap refs_to_sm)\n    on its exits).  */\n \n static bool\n-loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED,\n+loop_suitable_for_sm (class loop *loop ATTRIBUTE_UNUSED,\n \t\t      vec<edge> exits)\n {\n   unsigned i;\n@@ -2417,10 +2417,10 @@ loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED,\n    store motion was executed in one of the outer loops.  */\n \n static void\n-store_motion_loop (struct loop *loop, bitmap sm_executed)\n+store_motion_loop (class loop *loop, bitmap sm_executed)\n {\n   vec<edge> exits = get_loop_exit_edges (loop);\n-  struct loop *subloop;\n+  class loop *subloop;\n   bitmap sm_in_loop = BITMAP_ALLOC (&lim_bitmap_obstack);\n \n   if (loop_suitable_for_sm (loop, exits))\n@@ -2443,7 +2443,7 @@ store_motion_loop (struct loop *loop, bitmap sm_executed)\n static void\n store_motion (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bitmap sm_executed = BITMAP_ALLOC (&lim_bitmap_obstack);\n \n   for (loop = current_loops->tree_root->inner; loop != NULL; loop = loop->next)\n@@ -2459,12 +2459,12 @@ store_motion (void)\n    blocks that contain a nonpure call.  */\n \n static void\n-fill_always_executed_in_1 (struct loop *loop, sbitmap contains_call)\n+fill_always_executed_in_1 (class loop *loop, sbitmap contains_call)\n {\n   basic_block bb = NULL, *bbs, last = NULL;\n   unsigned i;\n   edge e;\n-  struct loop *inn_loop = loop;\n+  class loop *inn_loop = loop;\n \n   if (ALWAYS_EXECUTED_IN (loop->header) == NULL)\n     {\n@@ -2537,7 +2537,7 @@ static void\n fill_always_executed_in (void)\n {\n   basic_block bb;\n-  struct loop *loop;\n+  class loop *loop;\n \n   auto_sbitmap contains_call (last_basic_block_for_fn (cfun));\n   bitmap_clear (contains_call);\n@@ -2564,7 +2564,7 @@ fill_always_executed_in (void)\n static void\n tree_ssa_lim_initialize (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   unsigned i;\n \n   bitmap_obstack_initialize (&lim_bitmap_obstack);"}, {"sha": "5952cad7bba729153a66edff57301cf734a5ee1b", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -82,7 +82,7 @@ enum unroll_level\n    if they are not NULL.  */\n \n void\n-create_canonical_iv (struct loop *loop, edge exit, tree niter,\n+create_canonical_iv (class loop *loop, edge exit, tree niter,\n \t\t     tree *var_before = NULL, tree *var_after = NULL)\n {\n   edge in;\n@@ -161,7 +161,7 @@ struct loop_size\n /* Return true if OP in STMT will be constant after peeling LOOP.  */\n \n static bool\n-constant_after_peeling (tree op, gimple *stmt, struct loop *loop)\n+constant_after_peeling (tree op, gimple *stmt, class loop *loop)\n {\n   if (is_gimple_min_invariant (op))\n     return true;\n@@ -211,7 +211,7 @@ constant_after_peeling (tree op, gimple *stmt, struct loop *loop)\n    Stop estimating after UPPER_BOUND is met.  Return true in this case.  */\n \n static bool\n-tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel,\n+tree_estimate_loop_size (class loop *loop, edge exit, edge edge_to_cancel,\n \t\t\t struct loop_size *size, int upper_bound)\n {\n   basic_block *body = get_loop_body (loop);\n@@ -441,7 +441,7 @@ estimated_unrolled_size (struct loop_size *size,\n    The other cases are hopefully rare and will be cleaned up later.  */\n \n static edge\n-loop_edge_to_cancel (struct loop *loop)\n+loop_edge_to_cancel (class loop *loop)\n {\n   vec<edge> exits;\n   unsigned i;\n@@ -495,9 +495,9 @@ loop_edge_to_cancel (struct loop *loop)\n    known to not be executed.  */\n \n static bool\n-remove_exits_and_undefined_stmts (struct loop *loop, unsigned int npeeled)\n+remove_exits_and_undefined_stmts (class loop *loop, unsigned int npeeled)\n {\n-  struct nb_iter_bound *elt;\n+  class nb_iter_bound *elt;\n   bool changed = false;\n \n   for (elt = loop->bounds; elt; elt = elt->next)\n@@ -553,9 +553,9 @@ remove_exits_and_undefined_stmts (struct loop *loop, unsigned int npeeled)\n    discovered.  */\n \n static bool\n-remove_redundant_iv_tests (struct loop *loop)\n+remove_redundant_iv_tests (class loop *loop)\n {\n-  struct nb_iter_bound *elt;\n+  class nb_iter_bound *elt;\n   bool changed = false;\n \n   if (!loop->any_upper_bound)\n@@ -569,7 +569,7 @@ remove_redundant_iv_tests (struct loop *loop)\n \t{\n \t  basic_block bb = gimple_bb (elt->stmt);\n \t  edge exit_edge = EDGE_SUCC (bb, 0);\n-\t  struct tree_niter_desc niter;\n+\t  class tree_niter_desc niter;\n \n \t  if (!loop_exit_edge_p (loop, exit_edge))\n \t    exit_edge = EDGE_SUCC (bb, 1);\n@@ -629,7 +629,7 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n {\n   while (loops_to_unloop.length ())\n     {\n-      struct loop *loop = loops_to_unloop.pop ();\n+      class loop *loop = loops_to_unloop.pop ();\n       int n_unroll = loops_to_unloop_nunroll.pop ();\n       basic_block latch = loop->latch;\n       edge latch_edge = loop_latch_edge (loop);\n@@ -688,7 +688,7 @@ unloop_loops (bitmap loop_closed_ssa_invalidated,\n    a summary of the unroll to the dump file.  */\n \n static bool\n-try_unroll_loop_completely (struct loop *loop,\n+try_unroll_loop_completely (class loop *loop,\n \t\t\t    edge exit, tree niter, bool may_be_zero,\n \t\t\t    enum unroll_level ul,\n \t\t\t    HOST_WIDE_INT maxiter,\n@@ -986,7 +986,7 @@ estimated_peeled_sequence_size (struct loop_size *size,\n    Parameters are the same as for try_unroll_loops_completely */\n \n static bool\n-try_peel_loop (struct loop *loop,\n+try_peel_loop (class loop *loop,\n \t       edge exit, tree niter, bool may_be_zero,\n \t       HOST_WIDE_INT maxiter)\n {\n@@ -1155,7 +1155,7 @@ try_peel_loop (struct loop *loop,\n    Returns true if cfg is changed.   */\n \n static bool\n-canonicalize_loop_induction_variables (struct loop *loop,\n+canonicalize_loop_induction_variables (class loop *loop,\n \t\t\t\t       bool create_iv, enum unroll_level ul,\n \t\t\t\t       bool try_eval, bool allow_peel)\n {\n@@ -1164,7 +1164,7 @@ canonicalize_loop_induction_variables (struct loop *loop,\n   HOST_WIDE_INT maxiter;\n   bool modified = false;\n   dump_user_location_t locus;\n-  struct tree_niter_desc niter_desc;\n+  class tree_niter_desc niter_desc;\n   bool may_be_zero = false;\n \n   /* For unrolling allow conditional constant or zero iterations, thus\n@@ -1282,7 +1282,7 @@ canonicalize_loop_induction_variables (struct loop *loop,\n unsigned int\n canonicalize_induction_variables (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool changed = false;\n   bool irred_invalidated = false;\n   bitmap loop_closed_ssa_invalidated = BITMAP_ALLOC (NULL);\n@@ -1324,11 +1324,11 @@ canonicalize_induction_variables (void)\n \n static bool\n tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n-\t\t\t\tbitmap father_bbs, struct loop *loop)\n+\t\t\t\tbitmap father_bbs, class loop *loop)\n {\n-  struct loop *loop_father;\n+  class loop *loop_father;\n   bool changed = false;\n-  struct loop *inner;\n+  class loop *inner;\n   enum unroll_level ul;\n   unsigned num = number_of_loops (cfun);\n "}, {"sha": "fd5e99b3886e98588b5eb97149a531a0ef73c534", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -121,7 +121,7 @@ along with GCC; see the file COPYING3.  If not see\n    exists. */\n \n static inline HOST_WIDE_INT\n-avg_loop_niter (struct loop *loop)\n+avg_loop_niter (class loop *loop)\n {\n   HOST_WIDE_INT niter = estimated_stmt_executions_int (loop);\n   if (niter == -1)\n@@ -398,7 +398,7 @@ struct iv_group\n   /* Number of IV candidates in the cost_map.  */\n   unsigned n_map_members;\n   /* The costs wrto the iv candidates.  */\n-  struct cost_pair *cost_map;\n+  class cost_pair *cost_map;\n   /* The selected candidate for the group.  */\n   struct iv_cand *selected;\n   /* Uses in the group.  */\n@@ -551,7 +551,7 @@ iv_inv_expr_hasher::equal (const iv_inv_expr_ent *expr1,\n struct ivopts_data\n {\n   /* The currently optimized loop.  */\n-  struct loop *current_loop;\n+  class loop *current_loop;\n   location_t loop_loc;\n \n   /* Numbers of iterations for all exits of the current loop.  */\n@@ -629,7 +629,7 @@ class iv_ca\n   unsigned bad_groups;\n \n   /* Candidate assigned to a use, together with the related costs.  */\n-  struct cost_pair **cand_for_group;\n+  class cost_pair **cand_for_group;\n \n   /* Number of times each candidate is used.  */\n   unsigned *n_cand_uses;\n@@ -668,10 +668,10 @@ struct iv_ca_delta\n   struct iv_group *group;\n \n   /* An old assignment (for rollback purposes).  */\n-  struct cost_pair *old_cp;\n+  class cost_pair *old_cp;\n \n   /* A new assignment.  */\n-  struct cost_pair *new_cp;\n+  class cost_pair *new_cp;\n \n   /* Next change in the list.  */\n   struct iv_ca_delta *next;\n@@ -704,7 +704,7 @@ static comp_cost force_expr_to_var_cost (tree, bool);\n /* The single loop exit if it dominates the latch, NULL otherwise.  */\n \n edge\n-single_dom_exit (struct loop *loop)\n+single_dom_exit (class loop *loop)\n {\n   edge exit = single_exit (loop);\n \n@@ -885,7 +885,7 @@ name_info (struct ivopts_data *data, tree name)\n    emitted in LOOP.  */\n \n static bool\n-stmt_after_ip_normal_pos (struct loop *loop, gimple *stmt)\n+stmt_after_ip_normal_pos (class loop *loop, gimple *stmt)\n {\n   basic_block bb = ip_normal_pos (loop), sbb = gimple_bb (stmt);\n \n@@ -926,7 +926,7 @@ stmt_after_inc_pos (struct iv_cand *cand, gimple *stmt, bool true_if_equal)\n    CAND is incremented in LOOP.  */\n \n static bool\n-stmt_after_increment (struct loop *loop, struct iv_cand *cand, gimple *stmt)\n+stmt_after_increment (class loop *loop, struct iv_cand *cand, gimple *stmt)\n {\n   switch (cand->pos)\n     {\n@@ -976,10 +976,10 @@ contains_abnormal_ssa_name_p (tree expr)\n /*  Returns the structure describing number of iterations determined from\n     EXIT of DATA->current_loop, or NULL if something goes wrong.  */\n \n-static struct tree_niter_desc *\n+static class tree_niter_desc *\n niter_for_exit (struct ivopts_data *data, edge exit)\n {\n-  struct tree_niter_desc *desc;\n+  class tree_niter_desc *desc;\n   tree_niter_desc **slot;\n \n   if (!data->niters)\n@@ -995,7 +995,7 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n       /* Try to determine number of iterations.  We cannot safely work with ssa\n \t names that appear in phi nodes on abnormal edges, so that we do not\n \t create overlapping life ranges for them (PR 27283).  */\n-      desc = XNEW (struct tree_niter_desc);\n+      desc = XNEW (class tree_niter_desc);\n       if (!number_of_iterations_exit (data->current_loop,\n \t\t\t\t      exit, desc, true)\n      \t  || contains_abnormal_ssa_name_p (desc->niter))\n@@ -1015,7 +1015,7 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n    single dominating exit of DATA->current_loop, or NULL if something\n    goes wrong.  */\n \n-static struct tree_niter_desc *\n+static class tree_niter_desc *\n niter_for_single_dom_exit (struct ivopts_data *data)\n {\n   edge exit = single_dom_exit (data->current_loop);\n@@ -1246,7 +1246,7 @@ find_bivs (struct ivopts_data *data)\n   affine_iv iv;\n   tree step, type, base, stop;\n   bool found = false;\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n   gphi_iterator psi;\n \n   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n@@ -1304,7 +1304,7 @@ mark_bivs (struct ivopts_data *data)\n   gimple *def;\n   tree var;\n   struct iv *iv, *incr_iv;\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n   basic_block incr_bb;\n   gphi_iterator psi;\n \n@@ -1351,7 +1351,7 @@ static bool\n find_givs_in_stmt_scev (struct ivopts_data *data, gimple *stmt, affine_iv *iv)\n {\n   tree lhs, stop;\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n \n   iv->base = NULL_TREE;\n   iv->step = NULL_TREE;\n@@ -1415,7 +1415,7 @@ find_givs_in_bb (struct ivopts_data *data, basic_block bb)\n static void\n find_givs (struct ivopts_data *data)\n {\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n   basic_block *body = get_loop_body_in_dom_order (loop);\n   unsigned i;\n \n@@ -1441,7 +1441,7 @@ find_induction_variables (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      struct tree_niter_desc *niter = niter_for_single_dom_exit (data);\n+      class tree_niter_desc *niter = niter_for_single_dom_exit (data);\n \n       if (niter)\n \t{\n@@ -1741,8 +1741,8 @@ find_interesting_uses_cond (struct ivopts_data *data, gimple *stmt)\n    outside of the returned loop.  Returns NULL if EXPR is not\n    even obviously invariant in LOOP.  */\n \n-struct loop *\n-outermost_invariant_loop_for_expr (struct loop *loop, tree expr)\n+class loop *\n+outermost_invariant_loop_for_expr (class loop *loop, tree expr)\n {\n   basic_block def_bb;\n   unsigned i, len;\n@@ -1771,7 +1771,7 @@ outermost_invariant_loop_for_expr (struct loop *loop, tree expr)\n   len = TREE_OPERAND_LENGTH (expr);\n   for (i = 0; i < len; i++)\n     {\n-      struct loop *ivloop;\n+      class loop *ivloop;\n       if (!TREE_OPERAND (expr, i))\n \tcontinue;\n \n@@ -1789,7 +1789,7 @@ outermost_invariant_loop_for_expr (struct loop *loop, tree expr)\n    should not be the function body.  */\n \n bool\n-expr_invariant_in_loop_p (struct loop *loop, tree expr)\n+expr_invariant_in_loop_p (class loop *loop, tree expr)\n {\n   basic_block def_bb;\n   unsigned i, len;\n@@ -1982,7 +1982,7 @@ idx_find_step (tree base, tree *idx, void *data)\n   struct iv *iv;\n   bool use_overflow_semantics = false;\n   tree step, iv_base, iv_step, lbound, off;\n-  struct loop *loop = dta->ivopts_data->current_loop;\n+  class loop *loop = dta->ivopts_data->current_loop;\n \n   /* If base is a component ref, require that the offset of the reference\n      be invariant.  */\n@@ -3140,7 +3140,7 @@ add_candidate_1 (struct ivopts_data *data,\n    is already nonempty.  */\n \n static bool\n-allow_ip_end_pos_p (struct loop *loop)\n+allow_ip_end_pos_p (class loop *loop)\n {\n   if (!ip_normal_pos (loop))\n     return true;\n@@ -3331,8 +3331,8 @@ static void\n record_common_cand (struct ivopts_data *data, tree base,\n \t\t    tree step, struct iv_use *use)\n {\n-  struct iv_common_cand ent;\n-  struct iv_common_cand **slot;\n+  class iv_common_cand ent;\n+  class iv_common_cand **slot;\n \n   ent.base = base;\n   ent.step = step;\n@@ -3361,10 +3361,10 @@ static int\n common_cand_cmp (const void *p1, const void *p2)\n {\n   unsigned n1, n2;\n-  const struct iv_common_cand *const *const ccand1\n-    = (const struct iv_common_cand *const *)p1;\n-  const struct iv_common_cand *const *const ccand2\n-    = (const struct iv_common_cand *const *)p2;\n+  const class iv_common_cand *const *const ccand1\n+    = (const class iv_common_cand *const *)p1;\n+  const class iv_common_cand *const *const ccand2\n+    = (const class iv_common_cand *const *)p2;\n \n   n1 = (*ccand1)->uses.length ();\n   n2 = (*ccand2)->uses.length ();\n@@ -3382,7 +3382,7 @@ add_iv_candidate_derived_from_uses (struct ivopts_data *data)\n   data->iv_common_cands.qsort (common_cand_cmp);\n   for (i = 0; i < data->iv_common_cands.length (); i++)\n     {\n-      struct iv_common_cand *ptr = data->iv_common_cands[i];\n+      class iv_common_cand *ptr = data->iv_common_cands[i];\n \n       /* Only add IV candidate if it's derived from multiple uses.  */\n       if (ptr->uses.length () <= 1)\n@@ -3558,7 +3558,7 @@ alloc_use_cost_map (struct ivopts_data *data)\n \t}\n \n       group->n_map_members = size;\n-      group->cost_map = XCNEWVEC (struct cost_pair, size);\n+      group->cost_map = XCNEWVEC (class cost_pair, size);\n     }\n }\n \n@@ -3614,12 +3614,12 @@ set_group_iv_cost (struct ivopts_data *data,\n \n /* Gets cost of (GROUP, CAND) pair.  */\n \n-static struct cost_pair *\n+static class cost_pair *\n get_group_iv_cost (struct ivopts_data *data, struct iv_group *group,\n \t\t   struct iv_cand *cand)\n {\n   unsigned i, s;\n-  struct cost_pair *ret;\n+  class cost_pair *ret;\n \n   if (!cand)\n     return NULL;\n@@ -3753,7 +3753,7 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n static bool ATTRIBUTE_UNUSED\n generic_predict_doloop_p (struct ivopts_data *data)\n {\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n \n   /* Call target hook for target dependent checks.  */\n   if (!targetm.predict_doloop_p (loop))\n@@ -3768,7 +3768,7 @@ generic_predict_doloop_p (struct ivopts_data *data)\n      suitable or not.  Keep it as simple as possible, feel free to extend it\n      if you find any multiple exits cases matter.  */\n   edge exit = single_dom_exit (loop);\n-  struct tree_niter_desc *niter_desc;\n+  class tree_niter_desc *niter_desc;\n   if (!exit || !(niter_desc = niter_for_exit (data, exit)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3832,7 +3832,7 @@ computation_cost (tree expr, bool speed)\n /* Returns variable containing the value of candidate CAND at statement AT.  */\n \n static tree\n-var_at_stmt (struct loop *loop, struct iv_cand *cand, gimple *stmt)\n+var_at_stmt (class loop *loop, struct iv_cand *cand, gimple *stmt)\n {\n   if (stmt_after_increment (loop, cand, stmt))\n     return cand->var_after;\n@@ -3883,9 +3883,9 @@ determine_common_wider_type (tree *a, tree *b)\n    non-null.  Returns false if USE cannot be expressed using CAND.  */\n \n static bool\n-get_computation_aff_1 (struct loop *loop, gimple *at, struct iv_use *use,\n-\t\t       struct iv_cand *cand, struct aff_tree *aff_inv,\n-\t\t       struct aff_tree *aff_var, widest_int *prat = NULL)\n+get_computation_aff_1 (class loop *loop, gimple *at, struct iv_use *use,\n+\t\t       struct iv_cand *cand, class aff_tree *aff_inv,\n+\t\t       class aff_tree *aff_var, widest_int *prat = NULL)\n {\n   tree ubase = use->iv->base, ustep = use->iv->step;\n   tree cbase = cand->iv->base, cstep = cand->iv->step;\n@@ -3989,8 +3989,8 @@ get_computation_aff_1 (struct loop *loop, gimple *at, struct iv_use *use,\n    form into AFF.  Returns false if USE cannot be expressed using CAND.  */\n \n static bool\n-get_computation_aff (struct loop *loop, gimple *at, struct iv_use *use,\n-\t\t     struct iv_cand *cand, struct aff_tree *aff)\n+get_computation_aff (class loop *loop, gimple *at, struct iv_use *use,\n+\t\t     struct iv_cand *cand, class aff_tree *aff)\n {\n   aff_tree aff_var;\n \n@@ -4027,7 +4027,7 @@ get_use_type (struct iv_use *use)\n    CAND at statement AT in LOOP.  The computation is unshared.  */\n \n static tree\n-get_computation_at (struct loop *loop, gimple *at,\n+get_computation_at (class loop *loop, gimple *at,\n \t\t    struct iv_use *use, struct iv_cand *cand)\n {\n   aff_tree aff;\n@@ -4809,7 +4809,7 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n    stores it to VAL.  */\n \n static void\n-cand_value_at (struct loop *loop, struct iv_cand *cand, gimple *at, tree niter,\n+cand_value_at (class loop *loop, struct iv_cand *cand, gimple *at, tree niter,\n \t       aff_tree *val)\n {\n   aff_tree step, delta, nit;\n@@ -4868,7 +4868,7 @@ iv_period (struct iv *iv)\n static enum tree_code\n iv_elimination_compare (struct ivopts_data *data, struct iv_use *use)\n {\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n   basic_block ex_bb;\n   edge exit;\n \n@@ -4992,10 +4992,10 @@ difference_cannot_overflow_p (struct ivopts_data *data, tree base, tree offset)\n static bool\n iv_elimination_compare_lt (struct ivopts_data *data,\n \t\t\t   struct iv_cand *cand, enum tree_code *comp_p,\n-\t\t\t   struct tree_niter_desc *niter)\n+\t\t\t   class tree_niter_desc *niter)\n {\n   tree cand_type, a, b, mbz, nit_type = TREE_TYPE (niter->niter), offset;\n-  struct aff_tree nit, tmpa, tmpb;\n+  class aff_tree nit, tmpa, tmpb;\n   enum tree_code comp;\n   HOST_WIDE_INT step;\n \n@@ -5094,9 +5094,9 @@ may_eliminate_iv (struct ivopts_data *data,\n   basic_block ex_bb;\n   edge exit;\n   tree period;\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n   aff_tree bnd;\n-  struct tree_niter_desc *desc = NULL;\n+  class tree_niter_desc *desc = NULL;\n \n   if (TREE_CODE (cand->iv->step) != INTEGER_CST)\n     return false;\n@@ -5704,7 +5704,7 @@ determine_set_costs (struct ivopts_data *data)\n   gphi *phi;\n   gphi_iterator psi;\n   tree op;\n-  struct loop *loop = data->current_loop;\n+  class loop *loop = data->current_loop;\n   bitmap_iterator bi;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -5761,7 +5761,7 @@ determine_set_costs (struct ivopts_data *data)\n /* Returns true if A is a cheaper cost pair than B.  */\n \n static bool\n-cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n+cheaper_cost_pair (class cost_pair *a, class cost_pair *b)\n {\n   if (!a)\n     return false;\n@@ -5786,7 +5786,7 @@ cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n    for more expensive, equal and cheaper respectively.  */\n \n static int\n-compare_cost_pair (struct cost_pair *a, struct cost_pair *b)\n+compare_cost_pair (class cost_pair *a, class cost_pair *b)\n {\n   if (cheaper_cost_pair (a, b))\n     return -1;\n@@ -5798,16 +5798,16 @@ compare_cost_pair (struct cost_pair *a, struct cost_pair *b)\n \n /* Returns candidate by that USE is expressed in IVS.  */\n \n-static struct cost_pair *\n-iv_ca_cand_for_group (struct iv_ca *ivs, struct iv_group *group)\n+static class cost_pair *\n+iv_ca_cand_for_group (class iv_ca *ivs, struct iv_group *group)\n {\n   return ivs->cand_for_group[group->id];\n }\n \n /* Computes the cost field of IVS structure.  */\n \n static void\n-iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n+iv_ca_recount_cost (struct ivopts_data *data, class iv_ca *ivs)\n {\n   comp_cost cost = ivs->cand_use_cost;\n \n@@ -5820,7 +5820,7 @@ iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n    and IVS.  */\n \n static void\n-iv_ca_set_remove_invs (struct iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n+iv_ca_set_remove_invs (class iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n {\n   bitmap_iterator bi;\n   unsigned iid;\n@@ -5840,11 +5840,11 @@ iv_ca_set_remove_invs (struct iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n /* Set USE not to be expressed by any candidate in IVS.  */\n \n static void\n-iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n+iv_ca_set_no_cp (struct ivopts_data *data, class iv_ca *ivs,\n \t\t struct iv_group *group)\n {\n   unsigned gid = group->id, cid;\n-  struct cost_pair *cp;\n+  class cost_pair *cp;\n \n   cp = ivs->cand_for_group[gid];\n   if (!cp)\n@@ -5874,7 +5874,7 @@ iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n    IVS.  */\n \n static void\n-iv_ca_set_add_invs (struct iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n+iv_ca_set_add_invs (class iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n {\n   bitmap_iterator bi;\n   unsigned iid;\n@@ -5894,8 +5894,8 @@ iv_ca_set_add_invs (struct iv_ca *ivs, bitmap invs, unsigned *n_inv_uses)\n /* Set cost pair for GROUP in set IVS to CP.  */\n \n static void\n-iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n-\t      struct iv_group *group, struct cost_pair *cp)\n+iv_ca_set_cp (struct ivopts_data *data, class iv_ca *ivs,\n+\t      struct iv_group *group, class cost_pair *cp)\n {\n   unsigned gid = group->id, cid;\n \n@@ -5933,10 +5933,10 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n    set IVS don't give any result.  */\n \n static void\n-iv_ca_add_group (struct ivopts_data *data, struct iv_ca *ivs,\n+iv_ca_add_group (struct ivopts_data *data, class iv_ca *ivs,\n \t       struct iv_group *group)\n {\n-  struct cost_pair *best_cp = NULL, *cp;\n+  class cost_pair *best_cp = NULL, *cp;\n   bitmap_iterator bi;\n   unsigned i;\n   struct iv_cand *cand;\n@@ -5970,7 +5970,7 @@ iv_ca_add_group (struct ivopts_data *data, struct iv_ca *ivs,\n /* Get cost for assignment IVS.  */\n \n static comp_cost\n-iv_ca_cost (struct iv_ca *ivs)\n+iv_ca_cost (class iv_ca *ivs)\n {\n   /* This was a conditional expression but it triggered a bug in\n      Sun C 5.5.  */\n@@ -5985,9 +5985,9 @@ iv_ca_cost (struct iv_ca *ivs)\n    respectively.  */\n \n static int\n-iv_ca_compare_deps (struct ivopts_data *data, struct iv_ca *ivs,\n-\t\t    struct iv_group *group, struct cost_pair *old_cp,\n-\t\t    struct cost_pair *new_cp)\n+iv_ca_compare_deps (struct ivopts_data *data, class iv_ca *ivs,\n+\t\t    struct iv_group *group, class cost_pair *old_cp,\n+\t\t    class cost_pair *new_cp)\n {\n   gcc_assert (old_cp && new_cp && old_cp != new_cp);\n   unsigned old_n_invs = ivs->n_invs;\n@@ -6002,8 +6002,8 @@ iv_ca_compare_deps (struct ivopts_data *data, struct iv_ca *ivs,\n    it before NEXT.  */\n \n static struct iv_ca_delta *\n-iv_ca_delta_add (struct iv_group *group, struct cost_pair *old_cp,\n-\t\t struct cost_pair *new_cp, struct iv_ca_delta *next)\n+iv_ca_delta_add (struct iv_group *group, class cost_pair *old_cp,\n+\t\t class cost_pair *new_cp, struct iv_ca_delta *next)\n {\n   struct iv_ca_delta *change = XNEW (struct iv_ca_delta);\n \n@@ -6059,10 +6059,10 @@ iv_ca_delta_reverse (struct iv_ca_delta *delta)\n    reverted instead.  */\n \n static void\n-iv_ca_delta_commit (struct ivopts_data *data, struct iv_ca *ivs,\n+iv_ca_delta_commit (struct ivopts_data *data, class iv_ca *ivs,\n \t\t    struct iv_ca_delta *delta, bool forward)\n {\n-  struct cost_pair *from, *to;\n+  class cost_pair *from, *to;\n   struct iv_ca_delta *act;\n \n   if (!forward)\n@@ -6083,15 +6083,15 @@ iv_ca_delta_commit (struct ivopts_data *data, struct iv_ca *ivs,\n /* Returns true if CAND is used in IVS.  */\n \n static bool\n-iv_ca_cand_used_p (struct iv_ca *ivs, struct iv_cand *cand)\n+iv_ca_cand_used_p (class iv_ca *ivs, struct iv_cand *cand)\n {\n   return ivs->n_cand_uses[cand->id] > 0;\n }\n \n /* Returns number of induction variable candidates in the set IVS.  */\n \n static unsigned\n-iv_ca_n_cands (struct iv_ca *ivs)\n+iv_ca_n_cands (class iv_ca *ivs)\n {\n   return ivs->n_cands;\n }\n@@ -6114,14 +6114,14 @@ iv_ca_delta_free (struct iv_ca_delta **delta)\n \n /* Allocates new iv candidates assignment.  */\n \n-static struct iv_ca *\n+static class iv_ca *\n iv_ca_new (struct ivopts_data *data)\n {\n-  struct iv_ca *nw = XNEW (struct iv_ca);\n+  class iv_ca *nw = XNEW (class iv_ca);\n \n   nw->upto = 0;\n   nw->bad_groups = 0;\n-  nw->cand_for_group = XCNEWVEC (struct cost_pair *,\n+  nw->cand_for_group = XCNEWVEC (class cost_pair *,\n \t\t\t\t data->vgroups.length ());\n   nw->n_cand_uses = XCNEWVEC (unsigned, data->vcands.length ());\n   nw->cands = BITMAP_ALLOC (NULL);\n@@ -6139,7 +6139,7 @@ iv_ca_new (struct ivopts_data *data)\n /* Free memory occupied by the set IVS.  */\n \n static void\n-iv_ca_free (struct iv_ca **ivs)\n+iv_ca_free (class iv_ca **ivs)\n {\n   free ((*ivs)->cand_for_group);\n   free ((*ivs)->n_cand_uses);\n@@ -6153,7 +6153,7 @@ iv_ca_free (struct iv_ca **ivs)\n /* Dumps IVS to FILE.  */\n \n static void\n-iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n+iv_ca_dump (struct ivopts_data *data, FILE *file, class iv_ca *ivs)\n {\n   unsigned i;\n   comp_cost cost = iv_ca_cost (ivs);\n@@ -6168,7 +6168,7 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n   for (i = 0; i < ivs->upto; i++)\n     {\n       struct iv_group *group = data->vgroups[i];\n-      struct cost_pair *cp = iv_ca_cand_for_group (ivs, group);\n+      class cost_pair *cp = iv_ca_cand_for_group (ivs, group);\n       if (cp)\n         fprintf (file, \"   group:%d --> iv_cand:%d, cost=(\"\n \t\t \"%\" PRId64 \",%d)\\n\", group->id, cp->cand->id,\n@@ -6204,14 +6204,14 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n    the function will try to find a solution with mimimal iv candidates.  */\n \n static comp_cost\n-iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n+iv_ca_extend (struct ivopts_data *data, class iv_ca *ivs,\n \t      struct iv_cand *cand, struct iv_ca_delta **delta,\n \t      unsigned *n_ivs, bool min_ncand)\n {\n   unsigned i;\n   comp_cost cost;\n   struct iv_group *group;\n-  struct cost_pair *old_cp, *new_cp;\n+  class cost_pair *old_cp, *new_cp;\n \n   *delta = NULL;\n   for (i = 0; i < ivs->upto; i++)\n@@ -6257,13 +6257,13 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n    the candidate with which we start narrowing.  */\n \n static comp_cost\n-iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n+iv_ca_narrow (struct ivopts_data *data, class iv_ca *ivs,\n \t      struct iv_cand *cand, struct iv_cand *start,\n \t      struct iv_ca_delta **delta)\n {\n   unsigned i, ci;\n   struct iv_group *group;\n-  struct cost_pair *old_cp, *new_cp, *cp;\n+  class cost_pair *old_cp, *new_cp, *cp;\n   bitmap_iterator bi;\n   struct iv_cand *cnd;\n   comp_cost cost, best_cost, acost;\n@@ -6351,7 +6351,7 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n    differences in DELTA.  */\n \n static comp_cost\n-iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n+iv_ca_prune (struct ivopts_data *data, class iv_ca *ivs,\n \t     struct iv_cand *except_cand, struct iv_ca_delta **delta)\n {\n   bitmap_iterator bi;\n@@ -6400,13 +6400,13 @@ iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n    cheaper local cost for GROUP than BEST_CP.  Return pointer to\n    the corresponding cost_pair, otherwise just return BEST_CP.  */\n \n-static struct cost_pair*\n+static class cost_pair*\n cheaper_cost_with_cand (struct ivopts_data *data, struct iv_group *group,\n \t\t\tunsigned int cand_idx, struct iv_cand *old_cand,\n-\t\t\tstruct cost_pair *best_cp)\n+\t\t\tclass cost_pair *best_cp)\n {\n   struct iv_cand *cand;\n-  struct cost_pair *cp;\n+  class cost_pair *cp;\n \n   gcc_assert (old_cand != NULL && best_cp != NULL);\n   if (cand_idx == old_cand->id)\n@@ -6428,15 +6428,15 @@ cheaper_cost_with_cand (struct ivopts_data *data, struct iv_group *group,\n    candidate replacement in list DELTA.  */\n \n static comp_cost\n-iv_ca_replace (struct ivopts_data *data, struct iv_ca *ivs,\n+iv_ca_replace (struct ivopts_data *data, class iv_ca *ivs,\n \t       struct iv_ca_delta **delta)\n {\n   bitmap_iterator bi, bj;\n   unsigned int i, j, k;\n   struct iv_cand *cand;\n   comp_cost orig_cost, acost;\n   struct iv_ca_delta *act_delta, *tmp_delta;\n-  struct cost_pair *old_cp, *best_cp = NULL;\n+  class cost_pair *old_cp, *best_cp = NULL;\n \n   *delta = NULL;\n   orig_cost = iv_ca_cost (ivs);\n@@ -6503,15 +6503,15 @@ iv_ca_replace (struct ivopts_data *data, struct iv_ca *ivs,\n    based on any memory object.  */\n \n static bool\n-try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n+try_add_cand_for (struct ivopts_data *data, class iv_ca *ivs,\n \t\t  struct iv_group *group, bool originalp)\n {\n   comp_cost best_cost, act_cost;\n   unsigned i;\n   bitmap_iterator bi;\n   struct iv_cand *cand;\n   struct iv_ca_delta *best_delta = NULL, *act_delta;\n-  struct cost_pair *cp;\n+  class cost_pair *cp;\n \n   iv_ca_add_group (data, ivs, group);\n   best_cost = iv_ca_cost (ivs);\n@@ -6615,11 +6615,11 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \n /* Finds an initial assignment of candidates to uses.  */\n \n-static struct iv_ca *\n+static class iv_ca *\n get_initial_solution (struct ivopts_data *data, bool originalp)\n {\n   unsigned i;\n-  struct iv_ca *ivs = iv_ca_new (data);\n+  class iv_ca *ivs = iv_ca_new (data);\n \n   for (i = 0; i < data->vgroups.length (); i++)\n     if (!try_add_cand_for (data, ivs, data->vgroups[i], originalp))\n@@ -6637,7 +6637,7 @@ get_initial_solution (struct ivopts_data *data, bool originalp)\n \n static bool\n try_improve_iv_set (struct ivopts_data *data,\n-\t\t    struct iv_ca *ivs, bool *try_replace_p)\n+\t\t    class iv_ca *ivs, bool *try_replace_p)\n {\n   unsigned i, n_ivs;\n   comp_cost acost, best_cost = iv_ca_cost (ivs);\n@@ -6708,10 +6708,10 @@ try_improve_iv_set (struct ivopts_data *data,\n    greedy heuristic -- we try to replace at most one candidate in the selected\n    solution and remove the unused ivs while this improves the cost.  */\n \n-static struct iv_ca *\n+static class iv_ca *\n find_optimal_iv_set_1 (struct ivopts_data *data, bool originalp)\n {\n-  struct iv_ca *set;\n+  class iv_ca *set;\n   bool try_replace_p = true;\n \n   /* Get the initial solution.  */\n@@ -6749,12 +6749,12 @@ find_optimal_iv_set_1 (struct ivopts_data *data, bool originalp)\n   return set;\n }\n \n-static struct iv_ca *\n+static class iv_ca *\n find_optimal_iv_set (struct ivopts_data *data)\n {\n   unsigned i;\n   comp_cost cost, origcost;\n-  struct iv_ca *set, *origset;\n+  class iv_ca *set, *origset;\n \n   /* Determine the cost based on a strategy that starts with original IVs,\n      and try again using a strategy that prefers candidates not based\n@@ -6850,7 +6850,7 @@ create_new_iv (struct ivopts_data *data, struct iv_cand *cand)\n /* Creates new induction variables described in SET.  */\n \n static void\n-create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n+create_new_ivs (struct ivopts_data *data, class iv_ca *set)\n {\n   unsigned i;\n   struct iv_cand *cand;\n@@ -7204,7 +7204,7 @@ rewrite_use_compare (struct ivopts_data *data,\n   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);\n   enum tree_code compare;\n   struct iv_group *group = data->vgroups[use->group_id];\n-  struct cost_pair *cp = get_group_iv_cost (data, group, cand);\n+  class cost_pair *cp = get_group_iv_cost (data, group, cand);\n \n   bound = cp->value;\n   if (bound)\n@@ -7416,7 +7416,7 @@ remove_unused_ivs (struct ivopts_data *data, bitmap toremove)\n     }\n }\n \n-/* Frees memory occupied by struct tree_niter_desc in *VALUE. Callback\n+/* Frees memory occupied by class tree_niter_desc in *VALUE. Callback\n    for hash_map::traverse.  */\n \n bool\n@@ -7599,11 +7599,11 @@ determine_scaling_factor (struct ivopts_data *data, basic_block *body)\n /* Optimizes the LOOP.  Returns true if anything changed.  */\n \n static bool\n-tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop,\n+tree_ssa_iv_optimize_loop (struct ivopts_data *data, class loop *loop,\n \t\t\t   bitmap toremove)\n {\n   bool changed = false;\n-  struct iv_ca *iv_ca;\n+  class iv_ca *iv_ca;\n   edge exit = single_dom_exit (loop);\n   basic_block *body;\n \n@@ -7689,7 +7689,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop,\n void\n tree_ssa_iv_optimize (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   struct ivopts_data data;\n   auto_bitmap toremove;\n "}, {"sha": "1ad4a77c3568ebd2aa86f4bdc38fdab16f738047", "filename": "gcc/tree-ssa-loop-ivopts.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ivopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-ivopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -20,18 +20,18 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_LOOP_IVOPTS_H\n #define GCC_TREE_SSA_LOOP_IVOPTS_H\n \n-extern edge single_dom_exit (struct loop *);\n+extern edge single_dom_exit (class loop *);\n extern void dump_iv (FILE *, struct iv *);\n extern void dump_use (FILE *, struct iv_use *);\n extern void dump_uses (FILE *, struct ivopts_data *);\n extern void dump_cand (FILE *, struct iv_cand *);\n extern bool contains_abnormal_ssa_name_p (tree);\n-extern struct loop *outermost_invariant_loop_for_expr (struct loop *, tree);\n-extern bool expr_invariant_in_loop_p (struct loop *, tree);\n+extern class loop *outermost_invariant_loop_for_expr (class loop *, tree);\n+extern bool expr_invariant_in_loop_p (class loop *, tree);\n extern tree strip_offset (tree, poly_uint64_pod *);\n bool may_be_nonaddressable_p (tree expr);\n void tree_ssa_iv_optimize (void);\n \n-void create_canonical_iv (struct loop *, edge, tree,\n+void create_canonical_iv (class loop *, edge, tree,\n \t\t\t  tree * = NULL, tree * = NULL);\n #endif /* GCC_TREE_SSA_LOOP_IVOPTS_H */"}, {"sha": "6a1bbaae573e0cfdb3d929f423d849001628ede1", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -58,7 +58,7 @@ static bitmap_obstack loop_renamer_obstack;\n    VAR_AFTER (unless they are NULL).  */\n \n void\n-create_iv (tree base, tree step, tree var, struct loop *loop,\n+create_iv (tree base, tree step, tree var, class loop *loop,\n \t   gimple_stmt_iterator *incr_pos, bool after,\n \t   tree *var_before, tree *var_after)\n {\n@@ -156,8 +156,8 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n /* Return the innermost superloop LOOP of USE_LOOP that is a superloop of\n    both DEF_LOOP and USE_LOOP.  */\n \n-static inline struct loop *\n-find_sibling_superloop (struct loop *use_loop, struct loop *def_loop)\n+static inline class loop *\n+find_sibling_superloop (class loop *use_loop, class loop *def_loop)\n {\n   unsigned ud = loop_depth (use_loop);\n   unsigned dd = loop_depth (def_loop);\n@@ -196,7 +196,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n {\n   unsigned i;\n   bitmap_iterator bi;\n-  struct loop *def_loop = def_bb->loop_father;\n+  class loop *def_loop = def_bb->loop_father;\n   unsigned def_loop_depth = loop_depth (def_loop);\n   bitmap def_loop_exits;\n \n@@ -208,7 +208,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n   EXECUTE_IF_SET_IN_BITMAP (use_blocks, 0, i, bi)\n     {\n       basic_block use_bb = BASIC_BLOCK_FOR_FN (cfun, i);\n-      struct loop *use_loop = use_bb->loop_father;\n+      class loop *use_loop = use_bb->loop_father;\n       gcc_checking_assert (def_loop != use_loop\n \t\t\t   && ! flow_loop_nested_p (def_loop, use_loop));\n       if (! flow_loop_nested_p (use_loop, def_loop))\n@@ -234,7 +234,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{\n \t  basic_block pred = e->src;\n-\t  struct loop *pred_loop = pred->loop_father;\n+\t  class loop *pred_loop = pred->loop_father;\n \t  unsigned pred_loop_depth = loop_depth (pred_loop);\n \t  bool pred_visited;\n \n@@ -268,7 +268,7 @@ compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,\n     }\n \n   def_loop_exits = BITMAP_ALLOC (&loop_renamer_obstack);\n-  for (struct loop *loop = def_loop;\n+  for (class loop *loop = def_loop;\n        loop != current_loops->tree_root;\n        loop = loop_outer (loop))\n     bitmap_ior_into (def_loop_exits, loop_exits[loop->num]);\n@@ -293,7 +293,7 @@ add_exit_phi (basic_block exit, tree var)\n       basic_block def_bb = gimple_bb (def_stmt);\n       FOR_EACH_EDGE (e, ei, exit->preds)\n \t{\n-\t  struct loop *aloop = find_common_loop (def_bb->loop_father,\n+\t  class loop *aloop = find_common_loop (def_bb->loop_father,\n \t\t\t\t\t\t e->src->loop_father);\n \t  if (!flow_bb_inside_loop_p (aloop, e->dest))\n \t    break;\n@@ -357,7 +357,7 @@ add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap *loop_exits)\n static void\n get_loops_exits (bitmap *loop_exits)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   unsigned j;\n   edge e;\n \n@@ -383,7 +383,7 @@ find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks,\n {\n   unsigned ver;\n   basic_block def_bb;\n-  struct loop *def_loop;\n+  class loop *def_loop;\n \n   if (TREE_CODE (use) != SSA_NAME)\n     return;\n@@ -532,7 +532,7 @@ find_uses_to_rename_def (tree def, bitmap *use_blocks, bitmap need_phis)\n    USE_BLOCKS.  Record the SSA names that will need exit PHIs in NEED_PHIS.  */\n \n static void\n-find_uses_to_rename_in_loop (struct loop *loop, bitmap *use_blocks,\n+find_uses_to_rename_in_loop (class loop *loop, bitmap *use_blocks,\n \t\t\t     bitmap need_phis, int use_flags)\n {\n   bool do_virtuals = (use_flags & SSA_OP_VIRTUAL_USES) != 0;\n@@ -624,7 +624,7 @@ find_uses_to_rename_in_loop (struct loop *loop, bitmap *use_blocks,\n \n void\n rewrite_into_loop_closed_ssa_1 (bitmap changed_bbs, unsigned update_flag,\n-\t\t\t\tint use_flags, struct loop *loop)\n+\t\t\t\tint use_flags, class loop *loop)\n {\n   bitmap *use_blocks;\n   bitmap names_to_rename;\n@@ -698,7 +698,7 @@ rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)\n    form.  */\n \n void\n-rewrite_virtuals_into_loop_closed_ssa (struct loop *loop)\n+rewrite_virtuals_into_loop_closed_ssa (class loop *loop)\n {\n   rewrite_into_loop_closed_ssa_1 (NULL, 0, SSA_OP_VIRTUAL_USES, loop);\n }\n@@ -754,7 +754,7 @@ check_loop_closed_ssa_bb (basic_block bb)\n    if LOOP is NULL, otherwise, only LOOP is checked.  */\n \n DEBUG_FUNCTION void\n-verify_loop_closed_ssa (bool verify_ssa_p, struct loop *loop)\n+verify_loop_closed_ssa (bool verify_ssa_p, class loop *loop)\n {\n   if (number_of_loops (cfun) <= 1)\n     return;\n@@ -830,7 +830,7 @@ split_loop_exit_edge (edge exit, bool copy_constants_p)\n    variables incremented at the end of the LOOP.  */\n \n basic_block\n-ip_end_pos (struct loop *loop)\n+ip_end_pos (class loop *loop)\n {\n   return loop->latch;\n }\n@@ -839,7 +839,7 @@ ip_end_pos (struct loop *loop)\n    variables incremented just before exit condition of a LOOP.  */\n \n basic_block\n-ip_normal_pos (struct loop *loop)\n+ip_normal_pos (class loop *loop)\n {\n   gimple *last;\n   basic_block bb;\n@@ -870,7 +870,7 @@ ip_normal_pos (struct loop *loop)\n    the increment should be inserted after *BSI.  */\n \n void\n-standard_iv_increment_position (struct loop *loop, gimple_stmt_iterator *bsi,\n+standard_iv_increment_position (class loop *loop, gimple_stmt_iterator *bsi,\n \t\t\t\tbool *insert_after)\n {\n   basic_block bb = ip_normal_pos (loop), latch = ip_end_pos (loop);\n@@ -918,7 +918,7 @@ copy_phi_node_args (unsigned first_new_block)\n    after the loop has been duplicated.  */\n \n bool\n-gimple_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n+gimple_duplicate_loop_to_header_edge (class loop *loop, edge e,\n \t\t\t\t    unsigned int ndupl, sbitmap wont_exit,\n \t\t\t\t    edge orig, vec<edge> *to_remove,\n \t\t\t\t    int flags)\n@@ -950,8 +950,8 @@ gimple_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n    of iterations of the loop is returned in NITER.  */\n \n bool\n-can_unroll_loop_p (struct loop *loop, unsigned factor,\n-\t\t   struct tree_niter_desc *niter)\n+can_unroll_loop_p (class loop *loop, unsigned factor,\n+\t\t   class tree_niter_desc *niter)\n {\n   edge exit;\n \n@@ -997,7 +997,7 @@ can_unroll_loop_p (struct loop *loop, unsigned factor,\n    how the exit from the unrolled loop should be controlled.  */\n \n static void\n-determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n+determine_exit_conditions (class loop *loop, class tree_niter_desc *desc,\n \t\t\t   unsigned factor, tree *enter_cond,\n \t\t\t   tree *exit_base, tree *exit_step,\n \t\t\t   enum tree_code *exit_cmp, tree *exit_bound)\n@@ -1106,7 +1106,7 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n    dominated by BB by NUM/DEN.  */\n \n static void\n-scale_dominated_blocks_in_loop (struct loop *loop, basic_block bb,\n+scale_dominated_blocks_in_loop (class loop *loop, basic_block bb,\n \t\t\t\tprofile_count num, profile_count den)\n {\n   basic_block son;\n@@ -1128,7 +1128,7 @@ scale_dominated_blocks_in_loop (struct loop *loop, basic_block bb,\n /* Return estimated niter for LOOP after unrolling by FACTOR times.  */\n \n gcov_type\n-niter_for_unrolled_loop (struct loop *loop, unsigned factor)\n+niter_for_unrolled_loop (class loop *loop, unsigned factor)\n {\n   gcc_assert (factor != 0);\n   bool profile_p = false;\n@@ -1225,8 +1225,8 @@ niter_for_unrolled_loop (struct loop *loop, unsigned factor)\n #define PROB_UNROLLED_LOOP_ENTERED 90\n \n void\n-tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n-\t\t\t\tedge exit, struct tree_niter_desc *desc,\n+tree_transform_and_unroll_loop (class loop *loop, unsigned factor,\n+\t\t\t\tedge exit, class tree_niter_desc *desc,\n \t\t\t\ttransform_callback transform,\n \t\t\t\tvoid *data)\n {\n@@ -1237,7 +1237,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   gphi *phi_old_loop, *phi_new_loop, *phi_rest;\n   gphi_iterator psi_old_loop, psi_new_loop;\n   tree init, next, new_init;\n-  struct loop *new_loop;\n+  class loop *new_loop;\n   basic_block rest, exit_bb;\n   edge old_entry, new_entry, old_latch, precond_edge, new_exit;\n   edge new_nonexit, e;\n@@ -1435,8 +1435,8 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n    of the arguments is the same as for tree_transform_and_unroll_loop.  */\n \n void\n-tree_unroll_loop (struct loop *loop, unsigned factor,\n-\t\t  edge exit, struct tree_niter_desc *desc)\n+tree_unroll_loop (class loop *loop, unsigned factor,\n+\t\t  edge exit, class tree_niter_desc *desc)\n {\n   tree_transform_and_unroll_loop (loop, factor, exit, desc,\n \t\t\t\t  NULL, NULL);\n@@ -1518,7 +1518,7 @@ rewrite_all_phi_nodes_with_iv (loop_p loop, tree main_iv)\n    created.  */\n \n tree\n-canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)\n+canonicalize_loop_ivs (class loop *loop, tree *nit, bool bump_in_latch)\n {\n   unsigned precision = TYPE_PRECISION (TREE_TYPE (*nit));\n   unsigned original_precision = precision;"}, {"sha": "8263a679288d8015e11508688cafc95743049dc5", "filename": "gcc/tree-ssa-loop-manip.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-manip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-manip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -20,41 +20,41 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_LOOP_MANIP_H\n #define GCC_TREE_SSA_LOOP_MANIP_H\n \n-typedef void (*transform_callback)(struct loop *, void *);\n+typedef void (*transform_callback)(class loop *, void *);\n \n-extern void create_iv (tree, tree, tree, struct loop *, gimple_stmt_iterator *,\n+extern void create_iv (tree, tree, tree, class loop *, gimple_stmt_iterator *,\n \t\t       bool, tree *, tree *);\n extern void rewrite_into_loop_closed_ssa_1 (bitmap, unsigned, int,\n-\t\t\t\t\t    struct loop *);\n+\t\t\t\t\t    class loop *);\n extern void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n-extern void rewrite_virtuals_into_loop_closed_ssa (struct loop *);\n-extern void verify_loop_closed_ssa (bool, struct loop * = NULL);\n+extern void rewrite_virtuals_into_loop_closed_ssa (class loop *);\n+extern void verify_loop_closed_ssa (bool, class loop * = NULL);\n \n static inline void\n-checking_verify_loop_closed_ssa (bool verify_ssa_p, struct loop *loop = NULL)\n+checking_verify_loop_closed_ssa (bool verify_ssa_p, class loop *loop = NULL)\n {\n   if (flag_checking)\n     verify_loop_closed_ssa (verify_ssa_p, loop);\n }\n \n extern basic_block split_loop_exit_edge (edge, bool = false);\n-extern basic_block ip_end_pos (struct loop *);\n-extern basic_block ip_normal_pos (struct loop *);\n-extern void standard_iv_increment_position (struct loop *,\n+extern basic_block ip_end_pos (class loop *);\n+extern basic_block ip_normal_pos (class loop *);\n+extern void standard_iv_increment_position (class loop *,\n \t\t\t\t\t    gimple_stmt_iterator *, bool *);\n-extern bool gimple_duplicate_loop_to_header_edge (struct loop *, edge,\n+extern bool gimple_duplicate_loop_to_header_edge (class loop *, edge,\n \t\t\t\t\t\t  unsigned int, sbitmap,\n \t\t\t\t\t\t  edge, vec<edge> *,\n \t\t\t\t\t\t  int);\n-extern bool can_unroll_loop_p (struct loop *loop, unsigned factor,\n-\t\t\t       struct tree_niter_desc *niter);\n-extern gcov_type niter_for_unrolled_loop (struct loop *, unsigned);\n-extern void tree_transform_and_unroll_loop (struct loop *, unsigned,\n-\t\t\t\t\t    edge, struct tree_niter_desc *,\n+extern bool can_unroll_loop_p (class loop *loop, unsigned factor,\n+\t\t\t       class tree_niter_desc *niter);\n+extern gcov_type niter_for_unrolled_loop (class loop *, unsigned);\n+extern void tree_transform_and_unroll_loop (class loop *, unsigned,\n+\t\t\t\t\t    edge, class tree_niter_desc *,\n \t\t\t\t\t    transform_callback, void *);\n-extern void tree_unroll_loop (struct loop *, unsigned,\n-\t\t\t      edge, struct tree_niter_desc *);\n-extern tree canonicalize_loop_ivs (struct loop *, tree *, bool);\n+extern void tree_unroll_loop (class loop *, unsigned,\n+\t\t\t      edge, class tree_niter_desc *);\n+extern tree canonicalize_loop_ivs (class loop *, tree *, bool);\n \n \n "}, {"sha": "cd2ced369719c37afd4aac08ff360719d7702e42", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -65,7 +65,7 @@ struct bounds\n \n static bool number_of_iterations_popcount (loop_p loop, edge exit,\n \t\t\t\t\t   enum tree_code code,\n-\t\t\t\t\t   struct tree_niter_desc *niter);\n+\t\t\t\t\t   class tree_niter_desc *niter);\n \n \n /* Splits expression EXPR to a variable part VAR and constant OFFSET.  */\n@@ -346,7 +346,7 @@ refine_value_range_using_guard (tree type, tree var,\n    in TYPE to MIN and MAX.  */\n \n static void\n-determine_value_range (struct loop *loop, tree type, tree var, mpz_t off,\n+determine_value_range (class loop *loop, tree type, tree var, mpz_t off,\n \t\t       mpz_t min, mpz_t max)\n {\n   int cnt = 0;\n@@ -704,7 +704,7 @@ refine_bounds_using_guard (tree type, tree varx, mpz_t offx,\n    comparisons before the loop (usually created by loop header copying).  */\n \n static void\n-bound_difference (struct loop *loop, tree x, tree y, bounds *bnds)\n+bound_difference (class loop *loop, tree x, tree y, bounds *bnds)\n {\n   tree type = TREE_TYPE (x);\n   tree varx, vary;\n@@ -964,8 +964,8 @@ number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n    bounds on the difference FINAL - IV->base.  */\n \n static bool\n-number_of_iterations_ne (struct loop *loop, tree type, affine_iv *iv,\n-\t\t\t tree final, struct tree_niter_desc *niter,\n+number_of_iterations_ne (class loop *loop, tree type, affine_iv *iv,\n+\t\t\t tree final, class tree_niter_desc *niter,\n \t\t\t bool exit_must_be_taken, bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n@@ -1149,7 +1149,7 @@ number_of_iterations_ne (struct loop *loop, tree type, affine_iv *iv,\n \n static bool\n number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t\t       struct tree_niter_desc *niter,\n+\t\t\t       class tree_niter_desc *niter,\n \t\t\t       tree *delta, tree step,\n \t\t\t       bool exit_must_be_taken, bounds *bnds)\n {\n@@ -1268,7 +1268,7 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \n static bool\n assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t       struct tree_niter_desc *niter, tree step)\n+\t\t       class tree_niter_desc *niter, tree step)\n {\n   tree bound, d, assumption, diff;\n   tree niter_type = TREE_TYPE (step);\n@@ -1337,7 +1337,7 @@ assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \n static void\n assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n-\t\t      struct tree_niter_desc *niter, bounds *bnds)\n+\t\t      class tree_niter_desc *niter, bounds *bnds)\n {\n   tree assumption = boolean_true_node, bound, diff;\n   tree mbz, mbzl, mbzr, type1;\n@@ -1463,8 +1463,8 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n    that the exit must be taken eventually.  */\n \n static bool\n-number_of_iterations_lt (struct loop *loop, tree type, affine_iv *iv0,\n-\t\t\t affine_iv *iv1, struct tree_niter_desc *niter,\n+number_of_iterations_lt (class loop *loop, tree type, affine_iv *iv0,\n+\t\t\t affine_iv *iv1, class tree_niter_desc *niter,\n \t\t\t bool exit_must_be_taken, bounds *bnds)\n {\n   tree niter_type = unsigned_type_for (type);\n@@ -1576,8 +1576,8 @@ number_of_iterations_lt (struct loop *loop, tree type, affine_iv *iv0,\n    is the case).  BNDS bounds the difference IV1->base - IV0->base.  */\n \n static bool\n-number_of_iterations_le (struct loop *loop, tree type, affine_iv *iv0,\n-\t\t\t affine_iv *iv1, struct tree_niter_desc *niter,\n+number_of_iterations_le (class loop *loop, tree type, affine_iv *iv0,\n+\t\t\t affine_iv *iv1, class tree_niter_desc *niter,\n \t\t\t bool exit_must_be_taken, bounds *bnds)\n {\n   tree assumption;\n@@ -1721,14 +1721,14 @@ adjust_cond_for_loop_until_wrap (tree type, affine_iv *iv0, tree_code *code,\n    if EVERY_ITERATION is true, we know the test is executed on every iteration.\n \n    The results (number of iterations and assumptions as described in\n-   comments at struct tree_niter_desc in tree-ssa-loop.h) are stored to NITER.\n+   comments at class tree_niter_desc in tree-ssa-loop.h) are stored to NITER.\n    Returns false if it fails to determine number of iterations, true if it\n    was determined (possibly with some assumptions).  */\n \n static bool\n-number_of_iterations_cond (struct loop *loop,\n+number_of_iterations_cond (class loop *loop,\n \t\t\t   tree type, affine_iv *iv0, enum tree_code code,\n-\t\t\t   affine_iv *iv1, struct tree_niter_desc *niter,\n+\t\t\t   affine_iv *iv1, class tree_niter_desc *niter,\n \t\t\t   bool only_exit, bool every_iteration)\n {\n   bool exit_must_be_taken = false, ret;\n@@ -2263,7 +2263,7 @@ tree_simplify_using_condition (tree cond, tree expr)\n    simplification was possible).  */\n \n tree\n-simplify_using_initial_conditions (struct loop *loop, tree expr)\n+simplify_using_initial_conditions (class loop *loop, tree expr)\n {\n   edge e;\n   basic_block bb;\n@@ -2315,7 +2315,7 @@ simplify_using_initial_conditions (struct loop *loop, tree expr)\n    (or EXPR unchanged, if no simplification was possible).  */\n \n static tree\n-simplify_using_outer_evolutions (struct loop *loop, tree expr)\n+simplify_using_outer_evolutions (class loop *loop, tree expr)\n {\n   enum tree_code code = TREE_CODE (expr);\n   bool changed;\n@@ -2368,7 +2368,7 @@ simplify_using_outer_evolutions (struct loop *loop, tree expr)\n /* Returns true if EXIT is the only possible exit from LOOP.  */\n \n bool\n-loop_only_exit_p (const struct loop *loop, const_edge exit)\n+loop_only_exit_p (const class loop *loop, const_edge exit)\n {\n   basic_block *body;\n   gimple_stmt_iterator bsi;\n@@ -2395,15 +2395,15 @@ loop_only_exit_p (const struct loop *loop, const_edge exit)\n /* Stores description of number of iterations of LOOP derived from\n    EXIT (an exit edge of the LOOP) in NITER.  Returns true if some useful\n    information could be derived (and fields of NITER have meaning described\n-   in comments at struct tree_niter_desc declaration), false otherwise.\n+   in comments at class tree_niter_desc declaration), false otherwise.\n    When EVERY_ITERATION is true, only tests that are known to be executed\n    every iteration are considered (i.e. only test that alone bounds the loop).\n    If AT_STMT is not NULL, this function stores LOOP's condition statement in\n    it when returning true.  */\n \n bool\n-number_of_iterations_exit_assumptions (struct loop *loop, edge exit,\n-\t\t\t\t       struct tree_niter_desc *niter,\n+number_of_iterations_exit_assumptions (class loop *loop, edge exit,\n+\t\t\t\t       class tree_niter_desc *niter,\n \t\t\t\t       gcond **at_stmt, bool every_iteration)\n {\n   gimple *last;\n@@ -2598,7 +2598,7 @@ ssa_defined_by_minus_one_stmt_p (tree op, tree val)\n static bool\n number_of_iterations_popcount (loop_p loop, edge exit,\n \t\t\t       enum tree_code code,\n-\t\t\t       struct tree_niter_desc *niter)\n+\t\t\t       class tree_niter_desc *niter)\n {\n   bool adjust = true;\n   tree iter;\n@@ -2720,8 +2720,8 @@ number_of_iterations_popcount (loop_p loop, edge exit,\n    the niter information holds unconditionally.  */\n \n bool\n-number_of_iterations_exit (struct loop *loop, edge exit,\n-\t\t\t   struct tree_niter_desc *niter,\n+number_of_iterations_exit (class loop *loop, edge exit,\n+\t\t\t   class tree_niter_desc *niter,\n \t\t\t   bool warn, bool every_iteration)\n {\n   gcond *stmt;\n@@ -2746,13 +2746,13 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n    chrec_dont_know is returned.  */\n \n tree\n-find_loop_niter (struct loop *loop, edge *exit)\n+find_loop_niter (class loop *loop, edge *exit)\n {\n   unsigned i;\n   vec<edge> exits = get_loop_exit_edges (loop);\n   edge ex;\n   tree niter = NULL_TREE, aniter;\n-  struct tree_niter_desc desc;\n+  class tree_niter_desc desc;\n \n   *exit = NULL;\n   FOR_EACH_VEC_ELT (exits, i, ex)\n@@ -2808,7 +2808,7 @@ find_loop_niter (struct loop *loop, edge *exit)\n /* Return true if loop is known to have bounded number of iterations.  */\n \n bool\n-finite_loop_p (struct loop *loop)\n+finite_loop_p (class loop *loop)\n {\n   widest_int nit;\n   int flags;\n@@ -2870,7 +2870,7 @@ finite_loop_p (struct loop *loop)\n    operands are constants.  */\n \n static gphi *\n-chain_of_csts_start (struct loop *loop, tree x)\n+chain_of_csts_start (class loop *loop, tree x)\n {\n   gimple *stmt = SSA_NAME_DEF_STMT (x);\n   tree use;\n@@ -2919,7 +2919,7 @@ chain_of_csts_start (struct loop *loop, tree x)\n    If such phi node exists, it is returned, otherwise NULL is returned.  */\n \n static gphi *\n-get_base_for (struct loop *loop, tree x)\n+get_base_for (class loop *loop, tree x)\n {\n   gphi *phi;\n   tree init, next;\n@@ -3007,7 +3007,7 @@ get_val_for (tree x, tree base)\n    of the iterations of LOOP if successful, chrec_dont_know otherwise.  */\n \n tree\n-loop_niter_by_eval (struct loop *loop, edge exit)\n+loop_niter_by_eval (class loop *loop, edge exit)\n {\n   tree acnd;\n   tree op[2], val[2], next[2], aval[2];\n@@ -3108,7 +3108,7 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n    determines the number of iterations, chrec_dont_know is returned.  */\n \n tree\n-find_loop_niter_by_eval (struct loop *loop, edge *exit)\n+find_loop_niter_by_eval (class loop *loop, edge *exit)\n {\n   unsigned i;\n   vec<edge> exits = get_loop_exit_edges (loop);\n@@ -3325,7 +3325,7 @@ derive_constant_upper_bound_ops (tree type, tree op0,\n /* Emit a -Waggressive-loop-optimizations warning if needed.  */\n \n static void\n-do_warn_aggressive_loop_optimizations (struct loop *loop,\n+do_warn_aggressive_loop_optimizations (class loop *loop,\n \t\t\t\t       widest_int i_bound, gimple *stmt)\n {\n   /* Don't warn if the loop doesn't have known constant bound.  */\n@@ -3367,7 +3367,7 @@ do_warn_aggressive_loop_optimizations (struct loop *loop,\n    BOUND times.  I_BOUND is a widest_int upper estimate on BOUND.  */\n \n static void\n-record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,\n+record_estimate (class loop *loop, tree bound, const widest_int &i_bound,\n \t\t gimple *at_stmt, bool is_exit, bool realistic, bool upper)\n {\n   widest_int delta;\n@@ -3399,7 +3399,7 @@ record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,\n \t  || loop->nb_iterations == NULL_TREE\n \t  || TREE_CODE (loop->nb_iterations) != INTEGER_CST))\n     {\n-      struct nb_iter_bound *elt = ggc_alloc<nb_iter_bound> ();\n+      class nb_iter_bound *elt = ggc_alloc<nb_iter_bound> ();\n \n       elt->bound = i_bound;\n       elt->stmt = at_stmt;\n@@ -3436,7 +3436,7 @@ record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,\n    and doesn't overflow.  */\n \n static void\n-record_control_iv (struct loop *loop, struct tree_niter_desc *niter)\n+record_control_iv (class loop *loop, class tree_niter_desc *niter)\n {\n   struct control_iv *iv;\n \n@@ -3470,7 +3470,7 @@ get_cst_init_from_scev (tree var, wide_int *init, bool is_min)\n     return false;\n \n   gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n-  struct loop *loop = loop_containing_stmt (def_stmt);\n+  class loop *loop = loop_containing_stmt (def_stmt);\n \n   if (loop == NULL)\n     return false;\n@@ -3499,7 +3499,7 @@ get_cst_init_from_scev (tree var, wide_int *init, bool is_min)\n    UPPER is true if we are sure the induction variable does not wrap.  */\n \n static void\n-record_nonwrapping_iv (struct loop *loop, tree base, tree step, gimple *stmt,\n+record_nonwrapping_iv (class loop *loop, tree base, tree step, gimple *stmt,\n \t\t       tree low, tree high, bool realistic, bool upper)\n {\n   tree niter_bound, extreme, delta;\n@@ -3576,7 +3576,7 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, gimple *stmt,\n \n struct ilb_data\n {\n-  struct loop *loop;\n+  class loop *loop;\n   gimple *stmt;\n };\n \n@@ -3587,7 +3587,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   tree ev, init, step;\n   tree low, high, type, next;\n   bool sign, upper = true, at_end = false;\n-  struct loop *loop = data->loop;\n+  class loop *loop = data->loop;\n \n   if (TREE_CODE (base) != ARRAY_REF)\n     return true;\n@@ -3601,7 +3601,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n       upper = false;\n     }\n \n-  struct loop *dloop = loop_containing_stmt (data->stmt);\n+  class loop *dloop = loop_containing_stmt (data->stmt);\n   if (!dloop)\n     return true;\n \n@@ -3676,7 +3676,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n    STMT is guaranteed to be executed in every iteration of LOOP.*/\n \n static void\n-infer_loop_bounds_from_ref (struct loop *loop, gimple *stmt, tree ref)\n+infer_loop_bounds_from_ref (class loop *loop, gimple *stmt, tree ref)\n {\n   struct ilb_data data;\n \n@@ -3690,7 +3690,7 @@ infer_loop_bounds_from_ref (struct loop *loop, gimple *stmt, tree ref)\n    executed in every iteration of LOOP.  */\n \n static void\n-infer_loop_bounds_from_array (struct loop *loop, gimple *stmt)\n+infer_loop_bounds_from_array (class loop *loop, gimple *stmt)\n {\n   if (is_gimple_assign (stmt))\n     {\n@@ -3727,7 +3727,7 @@ infer_loop_bounds_from_array (struct loop *loop, gimple *stmt)\n    that pointer arithmetics in STMT does not overflow.  */\n \n static void\n-infer_loop_bounds_from_pointer_arith (struct loop *loop, gimple *stmt)\n+infer_loop_bounds_from_pointer_arith (class loop *loop, gimple *stmt)\n {\n   tree def, base, step, scev, type, low, high;\n   tree var, ptr;\n@@ -3752,7 +3752,7 @@ infer_loop_bounds_from_pointer_arith (struct loop *loop, gimple *stmt)\n   if (TYPE_PRECISION (type) != TYPE_PRECISION (TREE_TYPE (var)))\n     return;\n \n-  struct loop *uloop = loop_containing_stmt (stmt);\n+  class loop *uloop = loop_containing_stmt (stmt);\n   scev = instantiate_parameters (loop, analyze_scalar_evolution (uloop, def));\n   if (chrec_contains_undetermined (scev))\n     return;\n@@ -3786,7 +3786,7 @@ infer_loop_bounds_from_pointer_arith (struct loop *loop, gimple *stmt)\n    that signed arithmetics in STMT does not overflow.  */\n \n static void\n-infer_loop_bounds_from_signedness (struct loop *loop, gimple *stmt)\n+infer_loop_bounds_from_signedness (class loop *loop, gimple *stmt)\n {\n   tree def, base, step, scev, type, low, high;\n \n@@ -3838,7 +3838,7 @@ infer_loop_bounds_from_signedness (struct loop *loop, gimple *stmt)\n */\n \n static void\n-infer_loop_bounds_from_undefined (struct loop *loop)\n+infer_loop_bounds_from_undefined (class loop *loop)\n {\n   unsigned i;\n   basic_block *bbs;\n@@ -3918,9 +3918,9 @@ bound_index (vec<widest_int> bounds, const widest_int &bound)\n    some bounded statement.  */\n \n static void\n-discover_iteration_bound_by_body_walk (struct loop *loop)\n+discover_iteration_bound_by_body_walk (class loop *loop)\n {\n-  struct nb_iter_bound *elt;\n+  class nb_iter_bound *elt;\n   auto_vec<widest_int> bounds;\n   vec<vec<basic_block> > queues = vNULL;\n   vec<basic_block> queue = vNULL;\n@@ -4083,10 +4083,10 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n    count by 1.  */\n \n static void\n-maybe_lower_iteration_bound (struct loop *loop)\n+maybe_lower_iteration_bound (class loop *loop)\n {\n   hash_set<gimple *> *not_executed_last_iteration = NULL;\n-  struct nb_iter_bound *elt;\n+  class nb_iter_bound *elt;\n   bool found_exit = false;\n   auto_vec<basic_block> queue;\n   bitmap visited;\n@@ -4236,12 +4236,12 @@ get_upper_bound_based_on_builtin_expr_with_prob (gcond *cond)\n    is true also use estimates derived from undefined behavior.  */\n \n void\n-estimate_numbers_of_iterations (struct loop *loop)\n+estimate_numbers_of_iterations (class loop *loop)\n {\n   vec<edge> exits;\n   tree niter, type;\n   unsigned i;\n-  struct tree_niter_desc niter_desc;\n+  class tree_niter_desc niter_desc;\n   edge ex;\n   widest_int bound;\n   edge likely_exit;\n@@ -4337,7 +4337,7 @@ estimate_numbers_of_iterations (struct loop *loop)\n    the function returns false, otherwise returns true.  */\n \n bool\n-estimated_loop_iterations (struct loop *loop, widest_int *nit)\n+estimated_loop_iterations (class loop *loop, widest_int *nit)\n {\n   /* When SCEV information is available, try to update loop iterations\n      estimate.  Otherwise just return whatever we recorded earlier.  */\n@@ -4352,7 +4352,7 @@ estimated_loop_iterations (struct loop *loop, widest_int *nit)\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-estimated_loop_iterations_int (struct loop *loop)\n+estimated_loop_iterations_int (class loop *loop)\n {\n   widest_int nit;\n   HOST_WIDE_INT hwi_nit;\n@@ -4373,7 +4373,7 @@ estimated_loop_iterations_int (struct loop *loop)\n    false, otherwise returns true.  */\n \n bool\n-max_loop_iterations (struct loop *loop, widest_int *nit)\n+max_loop_iterations (class loop *loop, widest_int *nit)\n {\n   /* When SCEV information is available, try to update loop iterations\n      estimate.  Otherwise just return whatever we recorded earlier.  */\n@@ -4388,7 +4388,7 @@ max_loop_iterations (struct loop *loop, widest_int *nit)\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-max_loop_iterations_int (struct loop *loop)\n+max_loop_iterations_int (class loop *loop)\n {\n   widest_int nit;\n   HOST_WIDE_INT hwi_nit;\n@@ -4408,7 +4408,7 @@ max_loop_iterations_int (struct loop *loop)\n    false, otherwise returns true.  */\n \n bool\n-likely_max_loop_iterations (struct loop *loop, widest_int *nit)\n+likely_max_loop_iterations (class loop *loop, widest_int *nit)\n {\n   /* When SCEV information is available, try to update loop iterations\n      estimate.  Otherwise just return whatever we recorded earlier.  */\n@@ -4423,7 +4423,7 @@ likely_max_loop_iterations (struct loop *loop, widest_int *nit)\n    on the number of iterations of LOOP could not be derived, returns -1.  */\n \n HOST_WIDE_INT\n-likely_max_loop_iterations_int (struct loop *loop)\n+likely_max_loop_iterations_int (class loop *loop)\n {\n   widest_int nit;\n   HOST_WIDE_INT hwi_nit;\n@@ -4443,7 +4443,7 @@ likely_max_loop_iterations_int (struct loop *loop)\n    the number of execution of the latch by one.  */\n \n HOST_WIDE_INT\n-estimated_stmt_executions_int (struct loop *loop)\n+estimated_stmt_executions_int (class loop *loop)\n {\n   HOST_WIDE_INT nit = estimated_loop_iterations_int (loop);\n   HOST_WIDE_INT snit;\n@@ -4462,7 +4462,7 @@ estimated_stmt_executions_int (struct loop *loop)\n    false, otherwise returns true.  */\n \n bool\n-max_stmt_executions (struct loop *loop, widest_int *nit)\n+max_stmt_executions (class loop *loop, widest_int *nit)\n {\n   widest_int nit_minus_one;\n \n@@ -4481,7 +4481,7 @@ max_stmt_executions (struct loop *loop, widest_int *nit)\n    false, otherwise returns true.  */\n \n bool\n-likely_max_stmt_executions (struct loop *loop, widest_int *nit)\n+likely_max_stmt_executions (class loop *loop, widest_int *nit)\n {\n   widest_int nit_minus_one;\n \n@@ -4500,7 +4500,7 @@ likely_max_stmt_executions (struct loop *loop, widest_int *nit)\n    false, otherwise returns true.  */\n \n bool\n-estimated_stmt_executions (struct loop *loop, widest_int *nit)\n+estimated_stmt_executions (class loop *loop, widest_int *nit)\n {\n   widest_int nit_minus_one;\n \n@@ -4519,7 +4519,7 @@ estimated_stmt_executions (struct loop *loop, widest_int *nit)\n void\n estimate_numbers_of_iterations (function *fn)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   /* We don't want to issue signed overflow warnings while getting\n      loop iteration estimates.  */\n@@ -4577,7 +4577,7 @@ stmt_dominates_stmt_p (gimple *s1, gimple *s2)\n \n static bool\n n_of_executions_at_most (gimple *stmt,\n-\t\t\t struct nb_iter_bound *niter_bound,\n+\t\t\t class nb_iter_bound *niter_bound,\n \t\t\t tree niter)\n {\n   widest_int bound = niter_bound->bound;\n@@ -4664,11 +4664,11 @@ nowrap_type_p (tree type)\n \n static bool\n loop_exits_before_overflow (tree base, tree step,\n-\t\t\t    gimple *at_stmt, struct loop *loop)\n+\t\t\t    gimple *at_stmt, class loop *loop)\n {\n   widest_int niter;\n   struct control_iv *civ;\n-  struct nb_iter_bound *bound;\n+  class nb_iter_bound *bound;\n   tree e, delta, step_abs, unsigned_base;\n   tree type = TREE_TYPE (step);\n   tree unsigned_type, valid_niter;\n@@ -4856,7 +4856,7 @@ loop_exits_before_overflow (tree base, tree step,\n    (4294967295, 4294967296, ...).  */\n \n static bool\n-scev_var_range_cant_overflow (tree var, tree step, struct loop *loop)\n+scev_var_range_cant_overflow (tree var, tree step, class loop *loop)\n {\n   tree type;\n   wide_int minv, maxv, diff, step_wi;\n@@ -4910,7 +4910,7 @@ scev_var_range_cant_overflow (tree var, tree step, struct loop *loop)\n \n bool\n scev_probably_wraps_p (tree var, tree base, tree step,\n-\t\t       gimple *at_stmt, struct loop *loop,\n+\t\t       gimple *at_stmt, class loop *loop,\n \t\t       bool use_overflow_semantics)\n {\n   /* FIXME: We really need something like\n@@ -4962,16 +4962,16 @@ scev_probably_wraps_p (tree var, tree base, tree step,\n /* Frees the information on upper bounds on numbers of iterations of LOOP.  */\n \n void\n-free_numbers_of_iterations_estimates (struct loop *loop)\n+free_numbers_of_iterations_estimates (class loop *loop)\n {\n   struct control_iv *civ;\n-  struct nb_iter_bound *bound;\n+  class nb_iter_bound *bound;\n \n   loop->nb_iterations = NULL;\n   loop->estimate_state = EST_NOT_COMPUTED;\n   for (bound = loop->bounds; bound;)\n     {\n-      struct nb_iter_bound *next = bound->next;\n+      class nb_iter_bound *next = bound->next;\n       ggc_free (bound);\n       bound = next;\n     }\n@@ -4991,7 +4991,7 @@ free_numbers_of_iterations_estimates (struct loop *loop)\n void\n free_numbers_of_iterations_estimates (function *fn)\n {\n-  struct loop *loop;\n+  class loop *loop;\n \n   FOR_EACH_LOOP_FN (fn, loop, 0)\n     free_numbers_of_iterations_estimates (loop);\n@@ -5001,7 +5001,7 @@ free_numbers_of_iterations_estimates (function *fn)\n    at LOOP.  */\n \n void\n-substitute_in_loop_info (struct loop *loop, tree name, tree val)\n+substitute_in_loop_info (class loop *loop, tree name, tree val)\n {\n   loop->nb_iterations = simplify_replace_tree (loop->nb_iterations, name, val);\n }"}, {"sha": "4454c1ac78e02228047511a9e0214c82946855b8", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -21,39 +21,39 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SSA_LOOP_NITER_H\n \n extern tree expand_simple_operations (tree, tree = NULL);\n-extern tree simplify_using_initial_conditions (struct loop *, tree);\n-extern bool loop_only_exit_p (const struct loop *, const_edge);\n-extern bool number_of_iterations_exit (struct loop *, edge,\n-\t\t\t\t       struct tree_niter_desc *niter, bool,\n+extern tree simplify_using_initial_conditions (class loop *, tree);\n+extern bool loop_only_exit_p (const class loop *, const_edge);\n+extern bool number_of_iterations_exit (class loop *, edge,\n+\t\t\t\t       class tree_niter_desc *niter, bool,\n \t\t\t\t       bool every_iteration = true);\n-extern bool number_of_iterations_exit_assumptions (struct loop *, edge,\n-\t\t\t\t\t\t   struct tree_niter_desc *,\n+extern bool number_of_iterations_exit_assumptions (class loop *, edge,\n+\t\t\t\t\t\t   class tree_niter_desc *,\n \t\t\t\t\t\t   gcond **, bool = true);\n-extern tree find_loop_niter (struct loop *, edge *);\n-extern bool finite_loop_p (struct loop *);\n-extern tree loop_niter_by_eval (struct loop *, edge);\n-extern tree find_loop_niter_by_eval (struct loop *, edge *);\n-extern bool estimated_loop_iterations (struct loop *, widest_int *);\n-extern HOST_WIDE_INT estimated_loop_iterations_int (struct loop *);\n-extern bool max_loop_iterations (struct loop *, widest_int *);\n-extern HOST_WIDE_INT max_loop_iterations_int (struct loop *);\n-extern bool likely_max_loop_iterations (struct loop *, widest_int *);\n-extern HOST_WIDE_INT likely_max_loop_iterations_int (struct loop *);\n-extern HOST_WIDE_INT max_stmt_executions_int (struct loop *);\n-extern HOST_WIDE_INT likely_max_stmt_executions_int (struct loop *);\n-extern HOST_WIDE_INT estimated_stmt_executions_int (struct loop *);\n-extern bool max_stmt_executions (struct loop *, widest_int *);\n-extern bool likely_max_stmt_executions (struct loop *, widest_int *);\n-extern bool estimated_stmt_executions (struct loop *, widest_int *);\n+extern tree find_loop_niter (class loop *, edge *);\n+extern bool finite_loop_p (class loop *);\n+extern tree loop_niter_by_eval (class loop *, edge);\n+extern tree find_loop_niter_by_eval (class loop *, edge *);\n+extern bool estimated_loop_iterations (class loop *, widest_int *);\n+extern HOST_WIDE_INT estimated_loop_iterations_int (class loop *);\n+extern bool max_loop_iterations (class loop *, widest_int *);\n+extern HOST_WIDE_INT max_loop_iterations_int (class loop *);\n+extern bool likely_max_loop_iterations (class loop *, widest_int *);\n+extern HOST_WIDE_INT likely_max_loop_iterations_int (class loop *);\n+extern HOST_WIDE_INT max_stmt_executions_int (class loop *);\n+extern HOST_WIDE_INT likely_max_stmt_executions_int (class loop *);\n+extern HOST_WIDE_INT estimated_stmt_executions_int (class loop *);\n+extern bool max_stmt_executions (class loop *, widest_int *);\n+extern bool likely_max_stmt_executions (class loop *, widest_int *);\n+extern bool estimated_stmt_executions (class loop *, widest_int *);\n extern void estimate_numbers_of_iterations (function *);\n-extern void estimate_numbers_of_iterations (struct loop *);\n+extern void estimate_numbers_of_iterations (class loop *);\n extern bool stmt_dominates_stmt_p (gimple *, gimple *);\n extern bool nowrap_type_p (tree);\n extern bool scev_probably_wraps_p (tree, tree, tree, gimple *,\n-\t\t\t\t   struct loop *, bool);\n-extern void free_numbers_of_iterations_estimates (struct loop *);\n+\t\t\t\t   class loop *, bool);\n+extern void free_numbers_of_iterations_estimates (class loop *);\n extern void free_numbers_of_iterations_estimates (function *);\n extern tree simplify_replace_tree (tree, tree, tree, tree (*)(tree) = NULL);\n-extern void substitute_in_loop_info (struct loop *, tree, tree);\n+extern void substitute_in_loop_info (class loop *, tree, tree);\n \n #endif /* GCC_TREE_SSA_LOOP_NITER_H */"}, {"sha": "04ff5244b69e03e10d25d05f80cebf3831599c8d", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -421,7 +421,7 @@ release_mem_refs (struct mem_ref_group *groups)\n \n struct ar_data\n {\n-  struct loop *loop;\t\t\t/* Loop of the reference.  */\n+  class loop *loop;\t\t\t/* Loop of the reference.  */\n   gimple *stmt;\t\t\t\t/* Statement of the reference.  */\n   tree *step;\t\t\t\t/* Step of the memory reference.  */\n   HOST_WIDE_INT *delta;\t\t\t/* Offset of the memory reference.  */\n@@ -486,7 +486,7 @@ idx_analyze_ref (tree base, tree *index, void *data)\n    references from REF_P.  */\n \n static bool\n-analyze_ref (struct loop *loop, tree *ref_p, tree *base,\n+analyze_ref (class loop *loop, tree *ref_p, tree *base,\n \t     tree *step, HOST_WIDE_INT *delta,\n \t     gimple *stmt)\n {\n@@ -535,7 +535,7 @@ analyze_ref (struct loop *loop, tree *ref_p, tree *base,\n    reference was recorded, false otherwise.  */\n \n static bool\n-gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n+gather_memory_references_ref (class loop *loop, struct mem_ref_group **refs,\n \t\t\t      tree ref, bool write_p, gimple *stmt)\n {\n   tree base, step;\n@@ -606,7 +606,7 @@ gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n    true if there are no other memory references inside the loop.  */\n \n static struct mem_ref_group *\n-gather_memory_references (struct loop *loop, bool *no_other_refs, unsigned *ref_count)\n+gather_memory_references (class loop *loop, bool *no_other_refs, unsigned *ref_count)\n {\n   basic_block *body = get_loop_body_in_dom_order (loop);\n   basic_block bb;\n@@ -1286,7 +1286,7 @@ mark_nontemporal_store (struct mem_ref *ref)\n /* Issue a memory fence instruction after LOOP.  */\n \n static void\n-emit_mfence_after_loop (struct loop *loop)\n+emit_mfence_after_loop (class loop *loop)\n {\n   vec<edge> exits = get_loop_exit_edges (loop);\n   edge exit;\n@@ -1315,7 +1315,7 @@ emit_mfence_after_loop (struct loop *loop)\n /* Returns true if we can use storent in loop, false otherwise.  */\n \n static bool\n-may_use_storent_in_loop_p (struct loop *loop)\n+may_use_storent_in_loop_p (class loop *loop)\n {\n   bool ret = true;\n \n@@ -1345,7 +1345,7 @@ may_use_storent_in_loop_p (struct loop *loop)\n    references in the loop.  */\n \n static void\n-mark_nontemporal_stores (struct loop *loop, struct mem_ref_group *groups)\n+mark_nontemporal_stores (class loop *loop, struct mem_ref_group *groups)\n {\n   struct mem_ref *ref;\n   bool any = false;\n@@ -1366,7 +1366,7 @@ mark_nontemporal_stores (struct loop *loop, struct mem_ref_group *groups)\n    iterations.  */\n \n static bool\n-should_unroll_loop_p (struct loop *loop, struct tree_niter_desc *desc,\n+should_unroll_loop_p (class loop *loop, class tree_niter_desc *desc,\n \t\t      unsigned factor)\n {\n   if (!can_unroll_loop_p (loop, factor, desc))\n@@ -1390,8 +1390,8 @@ should_unroll_loop_p (struct loop *loop, struct tree_niter_desc *desc,\n    the loop, or -1 if no estimate is available.  */\n \n static unsigned\n-determine_unroll_factor (struct loop *loop, struct mem_ref_group *refs,\n-\t\t\t unsigned ninsns, struct tree_niter_desc *desc,\n+determine_unroll_factor (class loop *loop, struct mem_ref_group *refs,\n+\t\t\t unsigned ninsns, class tree_niter_desc *desc,\n \t\t\t HOST_WIDE_INT est_niter)\n {\n   unsigned upper_bound;\n@@ -1493,9 +1493,9 @@ volume_of_dist_vector (lambda_vector vec, unsigned *loop_sizes, unsigned n)\n \n static void\n add_subscript_strides (tree access_fn, unsigned stride,\n-\t\t       HOST_WIDE_INT *strides, unsigned n, struct loop *loop)\n+\t\t       HOST_WIDE_INT *strides, unsigned n, class loop *loop)\n {\n-  struct loop *aloop;\n+  class loop *aloop;\n   tree step;\n   HOST_WIDE_INT astep;\n   unsigned min_depth = loop_depth (loop) - n;\n@@ -1526,7 +1526,7 @@ add_subscript_strides (tree access_fn, unsigned stride,\n \n static unsigned\n self_reuse_distance (data_reference_p dr, unsigned *loop_sizes, unsigned n,\n-\t\t     struct loop *loop)\n+\t\t     class loop *loop)\n {\n   tree stride, access_fn;\n   HOST_WIDE_INT *strides, astride;\n@@ -1596,10 +1596,10 @@ self_reuse_distance (data_reference_p dr, unsigned *loop_sizes, unsigned n,\n    memory references in the loop.  Return false if the analysis fails.  */\n \n static bool\n-determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n+determine_loop_nest_reuse (class loop *loop, struct mem_ref_group *refs,\n \t\t\t   bool no_other_refs)\n {\n-  struct loop *nest, *aloop;\n+  class loop *nest, *aloop;\n   vec<data_reference_p> datarefs = vNULL;\n   vec<ddr_p> dependences = vNULL;\n   struct mem_ref_group *gr;\n@@ -1879,12 +1879,12 @@ insn_to_prefetch_ratio_too_small_p (unsigned ninsns, unsigned prefetch_count,\n    true if the LOOP was unrolled.  */\n \n static bool\n-loop_prefetch_arrays (struct loop *loop)\n+loop_prefetch_arrays (class loop *loop)\n {\n   struct mem_ref_group *refs;\n   unsigned ahead, ninsns, time, unroll_factor;\n   HOST_WIDE_INT est_niter;\n-  struct tree_niter_desc desc;\n+  class tree_niter_desc desc;\n   bool unrolled = false, no_other_refs;\n   unsigned prefetch_count;\n   unsigned mem_ref_count;\n@@ -1982,7 +1982,7 @@ loop_prefetch_arrays (struct loop *loop)\n unsigned int\n tree_ssa_prefetch_arrays (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool unrolled = false;\n   int todo_flags = 0;\n "}, {"sha": "f5f083384bc78336b8a2dfcf078f303d630785b6", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -70,7 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n    point in *BORDER and the comparison induction variable in IV.  */\n \n static tree\n-split_at_bb_p (struct loop *loop, basic_block bb, tree *border, affine_iv *iv)\n+split_at_bb_p (class loop *loop, basic_block bb, tree *border, affine_iv *iv)\n {\n   gimple *last;\n   gcond *stmt;\n@@ -102,7 +102,7 @@ split_at_bb_p (struct loop *loop, basic_block bb, tree *border, affine_iv *iv)\n \n   tree op0 = gimple_cond_lhs (stmt);\n   tree op1 = gimple_cond_rhs (stmt);\n-  struct loop *useloop = loop_containing_stmt (stmt);\n+  class loop *useloop = loop_containing_stmt (stmt);\n \n   if (!simple_iv (loop, useloop, op0, iv, false))\n     return NULL_TREE;\n@@ -150,7 +150,7 @@ split_at_bb_p (struct loop *loop, basic_block bb, tree *border, affine_iv *iv)\n    also be true/false in the next iteration.  */\n \n static void\n-patch_loop_exit (struct loop *loop, gcond *guard, tree nextval, tree newbound,\n+patch_loop_exit (class loop *loop, gcond *guard, tree nextval, tree newbound,\n \t\t bool initial_true)\n {\n   edge exit = single_exit (loop);\n@@ -181,7 +181,7 @@ patch_loop_exit (struct loop *loop, gcond *guard, tree nextval, tree newbound,\n    such phi node.  Return that phi node.  */\n \n static gphi *\n-find_or_create_guard_phi (struct loop *loop, tree guard_iv, affine_iv * /*iv*/)\n+find_or_create_guard_phi (class loop *loop, tree guard_iv, affine_iv * /*iv*/)\n {\n   gimple *def = SSA_NAME_DEF_STMT (guard_iv);\n   gphi *phi;\n@@ -197,7 +197,7 @@ find_or_create_guard_phi (struct loop *loop, tree guard_iv, affine_iv * /*iv*/)\n    determined easily (i.e. that connect_loop_phis can determine them).  */\n \n static bool\n-easy_exit_values (struct loop *loop)\n+easy_exit_values (class loop *loop)\n {\n   edge exit = single_exit (loop);\n   edge latch = loop_latch_edge (loop);\n@@ -229,7 +229,7 @@ easy_exit_values (struct loop *loop)\n    this.  The loops need to fulfill easy_exit_values().  */\n \n static void\n-connect_loop_phis (struct loop *loop1, struct loop *loop2, edge new_e)\n+connect_loop_phis (class loop *loop1, class loop *loop2, edge new_e)\n {\n   basic_block rest = loop_preheader_edge (loop2)->src;\n   gcc_assert (new_e->dest == rest);\n@@ -323,7 +323,7 @@ connect_loop_phis (struct loop *loop1, struct loop *loop2, edge new_e)\n    This doesn't update the SSA form, see connect_loop_phis for that.  */\n \n static edge\n-connect_loops (struct loop *loop1, struct loop *loop2)\n+connect_loops (class loop *loop1, class loop *loop2)\n {\n   edge exit = single_exit (loop1);\n   basic_block skip_bb = split_edge (exit);\n@@ -387,7 +387,7 @@ connect_loops (struct loop *loop1, struct loop *loop2)\n    and add or subtract 1.  This routine computes newend above.  */\n \n static tree\n-compute_new_first_bound (gimple_seq *stmts, struct tree_niter_desc *niter,\n+compute_new_first_bound (gimple_seq *stmts, class tree_niter_desc *niter,\n \t\t\t tree border,\n \t\t\t enum tree_code guard_code, tree guard_init)\n {\n@@ -487,7 +487,7 @@ compute_new_first_bound (gimple_seq *stmts, struct tree_niter_desc *niter,\n    single exit of LOOP.  */\n \n static bool\n-split_loop (struct loop *loop1, struct tree_niter_desc *niter)\n+split_loop (class loop *loop1, class tree_niter_desc *niter)\n {\n   basic_block *bbs;\n   unsigned i;\n@@ -557,7 +557,7 @@ split_loop (struct loop *loop1, struct tree_niter_desc *niter)\n \tinitialize_original_copy_tables ();\n \tbasic_block cond_bb;\n \n-\tstruct loop *loop2 = loop_version (loop1, cond, &cond_bb,\n+\tclass loop *loop2 = loop_version (loop1, cond, &cond_bb,\n \t\t\t\t\t   profile_probability::always (),\n \t\t\t\t\t   profile_probability::always (),\n \t\t\t\t\t   profile_probability::always (),\n@@ -617,7 +617,7 @@ split_loop (struct loop *loop1, struct tree_niter_desc *niter)\n static unsigned int\n tree_ssa_split_loops (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool changed = false;\n \n   gcc_assert (scev_initialized_p ());\n@@ -627,7 +627,7 @@ tree_ssa_split_loops (void)\n   /* Go through all loops starting from innermost.  */\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n-      struct tree_niter_desc niter;\n+      class tree_niter_desc niter;\n       if (loop->aux)\n \t{\n \t  /* If any of our inner loops was split, don't split us,"}, {"sha": "e60019db9466e11c4f25d6dfc6fd9dd543498a8d", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -75,23 +75,23 @@ along with GCC; see the file COPYING3.  If not see\n    tree-ssa-loop-im.c ensures that all the suitable conditions are in this\n    shape.  */\n \n-static struct loop *tree_unswitch_loop (struct loop *, basic_block, tree);\n-static bool tree_unswitch_single_loop (struct loop *, int);\n-static tree tree_may_unswitch_on (basic_block, struct loop *);\n-static bool tree_unswitch_outer_loop (struct loop *);\n-static edge find_loop_guard (struct loop *);\n-static bool empty_bb_without_guard_p (struct loop *, basic_block);\n-static bool used_outside_loop_p (struct loop *, tree);\n-static void hoist_guard (struct loop *, edge);\n-static bool check_exit_phi (struct loop *);\n-static tree get_vop_from_header (struct loop *);\n+static class loop *tree_unswitch_loop (class loop *, basic_block, tree);\n+static bool tree_unswitch_single_loop (class loop *, int);\n+static tree tree_may_unswitch_on (basic_block, class loop *);\n+static bool tree_unswitch_outer_loop (class loop *);\n+static edge find_loop_guard (class loop *);\n+static bool empty_bb_without_guard_p (class loop *, basic_block);\n+static bool used_outside_loop_p (class loop *, tree);\n+static void hoist_guard (class loop *, edge);\n+static bool check_exit_phi (class loop *);\n+static tree get_vop_from_header (class loop *);\n \n /* Main entry point.  Perform loop unswitching on all suitable loops.  */\n \n unsigned int\n tree_ssa_unswitch_loops (void)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool changed = false;\n \n   /* Go through all loops starting from innermost.  */\n@@ -114,7 +114,7 @@ tree_ssa_unswitch_loops (void)\n    considering for unswitching and LOOP is the loop it appears in.  */\n \n static bool\n-is_maybe_undefined (const tree name, gimple *stmt, struct loop *loop)\n+is_maybe_undefined (const tree name, gimple *stmt, class loop *loop)\n {\n   /* The loop header is the only block we can trivially determine that\n      will always be executed.  If the comparison is in the loop\n@@ -187,7 +187,7 @@ is_maybe_undefined (const tree name, gimple *stmt, struct loop *loop)\n    basic blocks (for what it means see comments below).  */\n \n static tree\n-tree_may_unswitch_on (basic_block bb, struct loop *loop)\n+tree_may_unswitch_on (basic_block bb, class loop *loop)\n {\n   gimple *last, *def;\n   gcond *stmt;\n@@ -232,7 +232,7 @@ tree_may_unswitch_on (basic_block bb, struct loop *loop)\n    unnecessarily).  */\n \n static tree\n-simplify_using_entry_checks (struct loop *loop, tree cond)\n+simplify_using_entry_checks (class loop *loop, tree cond)\n {\n   edge e = loop_preheader_edge (loop);\n   gimple *stmt;\n@@ -265,10 +265,10 @@ simplify_using_entry_checks (struct loop *loop, tree cond)\n    grow exponentially.  */\n \n static bool\n-tree_unswitch_single_loop (struct loop *loop, int num)\n+tree_unswitch_single_loop (class loop *loop, int num)\n {\n   basic_block *bbs;\n-  struct loop *nloop;\n+  class loop *nloop;\n   unsigned i, found;\n   tree cond = NULL_TREE;\n   gimple *stmt;\n@@ -476,8 +476,8 @@ tree_unswitch_single_loop (struct loop *loop, int num)\n    loop is entered -- the new loop is entered if COND is true.  Returns NULL\n    if impossible, new loop otherwise.  */\n \n-static struct loop *\n-tree_unswitch_loop (struct loop *loop,\n+static class loop *\n+tree_unswitch_loop (class loop *loop,\n \t\t    basic_block unswitch_on, tree cond)\n {\n   profile_probability prob_true;\n@@ -500,7 +500,7 @@ tree_unswitch_loop (struct loop *loop,\n /* Unswitch outer loops by hoisting invariant guard on\n    inner loop without code duplication.  */\n static bool\n-tree_unswitch_outer_loop (struct loop *loop)\n+tree_unswitch_outer_loop (class loop *loop)\n {\n   edge exit, guard;\n   HOST_WIDE_INT iterations;\n@@ -544,7 +544,7 @@ tree_unswitch_outer_loop (struct loop *loop)\n    otherwise returns NULL.  */\n \n static edge\n-find_loop_guard (struct loop *loop)\n+find_loop_guard (class loop *loop)\n {\n   basic_block header = loop->header;\n   edge guard_edge, te, fe;\n@@ -701,7 +701,7 @@ find_loop_guard (struct loop *loop)\n    are invariant or not.  */\n \n static bool\n-empty_bb_without_guard_p (struct loop *loop, basic_block bb)\n+empty_bb_without_guard_p (class loop *loop, basic_block bb)\n {\n   basic_block exit_bb = single_exit (loop)->src;\n   bool may_be_used_outside = (bb == exit_bb\n@@ -749,7 +749,7 @@ empty_bb_without_guard_p (struct loop *loop, basic_block bb)\n /* Return true if NAME is used outside of LOOP.  */\n \n static bool\n-used_outside_loop_p (struct loop *loop, tree name)\n+used_outside_loop_p (class loop *loop, tree name)\n {\n   imm_use_iterator it;\n   use_operand_p use;\n@@ -767,7 +767,7 @@ used_outside_loop_p (struct loop *loop, tree name)\n /* Return argument for loop preheader edge in header virtual phi if any.  */\n \n static tree\n-get_vop_from_header (struct loop *loop)\n+get_vop_from_header (class loop *loop)\n {\n   for (gphi_iterator gsi = gsi_start_phis (loop->header);\n        !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -783,7 +783,7 @@ get_vop_from_header (struct loop *loop)\n /* Move the check of GUARD outside of LOOP.  */\n \n static void\n-hoist_guard (struct loop *loop, edge guard)\n+hoist_guard (class loop *loop, edge guard)\n {\n   edge exit = single_exit (loop);\n   edge preh = loop_preheader_edge (loop);\n@@ -934,7 +934,7 @@ hoist_guard (struct loop *loop, edge guard)\n    for edge around loop.  */\n \n static bool\n-check_exit_phi (struct loop *loop)\n+check_exit_phi (class loop *loop)\n {\n   edge exit = single_exit (loop);\n   basic_block pre_header = loop_preheader_edge (loop)->src;"}, {"sha": "fc9f08363ce206564e3600321c1471392da3a3a9", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -157,7 +157,7 @@ gate_oacc_kernels (function *fn)\n   if (!lookup_attribute (\"oacc kernels\", DECL_ATTRIBUTES (fn->decl)))\n     return false;\n \n-  struct loop *loop;\n+  class loop *loop;\n   FOR_EACH_LOOP (loop, 0)\n     if (loop->in_oacc_kernels_region)\n       return true;\n@@ -455,7 +455,7 @@ class pass_scev_cprop : public gimple_opt_pass\n unsigned\n pass_scev_cprop::execute (function *)\n {\n-  struct loop *loop;\n+  class loop *loop;\n   bool any = false;\n \n   /* Perform final value replacement in loops, in case the replacement\n@@ -776,7 +776,7 @@ get_lsm_tmp_name (tree ref, unsigned n, const char *suffix)\n /* Computes an estimated number of insns in LOOP, weighted by WEIGHTS.  */\n \n unsigned\n-tree_num_loop_insns (struct loop *loop, eni_weights *weights)\n+tree_num_loop_insns (class loop *loop, eni_weights *weights)\n {\n   basic_block *body = get_loop_body (loop);\n   gimple_stmt_iterator gsi;"}, {"sha": "e523de2138035b70b86bcf94dc93764d9b0623e6", "filename": "gcc/tree-ssa-loop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -66,11 +66,11 @@ class tree_niter_desc\n \n extern bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n extern char *get_lsm_tmp_name (tree ref, unsigned n, const char *suffix = NULL);\n-extern unsigned tree_num_loop_insns (struct loop *, struct eni_weights *);\n+extern unsigned tree_num_loop_insns (class loop *, struct eni_weights *);\n \n /* Returns the loop of the statement STMT.  */\n \n-static inline struct loop *\n+static inline class loop *\n loop_containing_stmt (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);"}, {"sha": "635fc9376173341295d56e149846da983dac307e", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -270,7 +270,7 @@ static long\n phi_rank (gimple *stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n-  struct loop *father = bb->loop_father;\n+  class loop *father = bb->loop_father;\n   tree res;\n   unsigned i;\n   use_operand_p use;\n@@ -603,7 +603,7 @@ add_repeat_to_ops_vec (vec<operand_entry *> *ops, tree op,\n    operation with tree code CODE, and is inside LOOP.  */\n \n static bool\n-is_reassociable_op (gimple *stmt, enum tree_code code, struct loop *loop)\n+is_reassociable_op (gimple *stmt, enum tree_code code, class loop *loop)\n {\n   basic_block bb = gimple_bb (stmt);\n \n@@ -1560,7 +1560,7 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n \n static bool\n undistribute_ops_list (enum tree_code opcode,\n-\t\t       vec<operand_entry *> *ops, struct loop *loop)\n+\t\t       vec<operand_entry *> *ops, class loop *loop)\n {\n   unsigned int length = ops->length ();\n   operand_entry *oe1;\n@@ -3861,7 +3861,7 @@ no_side_effect_bb (basic_block bb)\n \n static bool\n get_ops (tree var, enum tree_code code, vec<operand_entry *> *ops,\n-\t struct loop *loop)\n+\t class loop *loop)\n {\n   gimple *stmt = SSA_NAME_DEF_STMT (var);\n   tree rhs[2];\n@@ -3896,7 +3896,7 @@ get_ops (tree var, enum tree_code code, vec<operand_entry *> *ops,\n \n static tree\n update_ops (tree var, enum tree_code code, vec<operand_entry *> ops,\n-\t    unsigned int *pidx, struct loop *loop)\n+\t    unsigned int *pidx, class loop *loop)\n {\n   gimple *stmt = SSA_NAME_DEF_STMT (var);\n   tree rhs[4];\n@@ -4834,7 +4834,7 @@ linearize_expr (gimple *stmt)\n   gimple *oldbinrhs = binrhs;\n   enum tree_code rhscode = gimple_assign_rhs_code (stmt);\n   gimple *newbinrhs = NULL;\n-  struct loop *loop = loop_containing_stmt (stmt);\n+  class loop *loop = loop_containing_stmt (stmt);\n   tree lhs = gimple_assign_lhs (stmt);\n \n   gcc_assert (is_reassociable_op (binlhs, rhscode, loop)\n@@ -4968,7 +4968,7 @@ should_break_up_subtract (gimple *stmt)\n   tree binlhs = gimple_assign_rhs1 (stmt);\n   tree binrhs = gimple_assign_rhs2 (stmt);\n   gimple *immusestmt;\n-  struct loop *loop = loop_containing_stmt (stmt);\n+  class loop *loop = loop_containing_stmt (stmt);\n \n   if (TREE_CODE (binlhs) == SSA_NAME\n       && is_reassociable_op (SSA_NAME_DEF_STMT (binlhs), PLUS_EXPR, loop))\n@@ -5123,7 +5123,7 @@ linearize_expr_tree (vec<operand_entry *> *ops, gimple *stmt,\n   bool binlhsisreassoc = false;\n   bool binrhsisreassoc = false;\n   enum tree_code rhscode = gimple_assign_rhs_code (stmt);\n-  struct loop *loop = loop_containing_stmt (stmt);\n+  class loop *loop = loop_containing_stmt (stmt);\n \n   if (set_visited)\n     gimple_set_visited (stmt, true);"}, {"sha": "574bc30eee18600566e98bb6a607ef7bc7bcccef", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1028,9 +1028,9 @@ bool\n expr_elt_hasher::equal (const value_type &p1, const compare_type &p2)\n {\n   const struct hashable_expr *expr1 = p1->expr ();\n-  const struct expr_hash_elt *stamp1 = p1->stamp ();\n+  const class expr_hash_elt *stamp1 = p1->stamp ();\n   const struct hashable_expr *expr2 = p2->expr ();\n-  const struct expr_hash_elt *stamp2 = p2->stamp ();\n+  const class expr_hash_elt *stamp2 = p2->stamp ();\n \n   /* This case should apply only when removing entries from the table.  */\n   if (stamp1 == stamp2)"}, {"sha": "4818500682312e8c6bc464a43c756afc3a2b4965", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -96,7 +96,7 @@ class expr_hash_elt\n \n   /* A unique stamp, typically the address of the hash\n      element itself, used in removing entries from the table.  */\n-  struct expr_hash_elt *m_stamp;\n+  class expr_hash_elt *m_stamp;\n \n   /* We should never be making assignments between objects in this class.\n      Though it might allow us to exploit C++11 move semantics if we"}, {"sha": "f8962d618d6497c7e0863f4a652fc9c0f249c3bd", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1420,7 +1420,7 @@ class scc_info\n    number 1, pages 9-14.  */\n \n static void\n-scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n+scc_visit (constraint_graph_t graph, class scc_info *si, unsigned int n)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -2023,7 +2023,7 @@ static int location_equiv_class;\n    and label it's nodes with DFS numbers.  */\n \n static void\n-condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n+condense_visit (constraint_graph_t graph, class scc_info *si, unsigned int n)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -2128,7 +2128,7 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n    3. Hashable.  */\n \n static void\n-label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n+label_visit (constraint_graph_t graph, class scc_info *si, unsigned int n)\n {\n   unsigned int i, first_pred;\n   bitmap_iterator bi;\n@@ -2215,7 +2215,7 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n /* Print the pred graph in dot format.  */\n \n static void\n-dump_pred_graph (struct scc_info *si, FILE *file)\n+dump_pred_graph (class scc_info *si, FILE *file)\n {\n   unsigned int i;\n \n@@ -2290,7 +2290,7 @@ dump_pred_graph (struct scc_info *si, FILE *file)\n /* Perform offline variable substitution, discovering equivalence\n    classes, and eliminating non-pointer variables.  */\n \n-static struct scc_info *\n+static class scc_info *\n perform_var_substitution (constraint_graph_t graph)\n {\n   unsigned int i;\n@@ -2424,7 +2424,7 @@ perform_var_substitution (constraint_graph_t graph)\n    substitution.  */\n \n static void\n-free_var_substitution_info (struct scc_info *si)\n+free_var_substitution_info (class scc_info *si)\n {\n   delete si;\n   free (graph->pointer_label);\n@@ -2548,7 +2548,7 @@ move_complex_constraints (constraint_graph_t graph)\n \n static void\n rewrite_constraints (constraint_graph_t graph,\n-\t\t     struct scc_info *si)\n+\t\t     class scc_info *si)\n {\n   int i;\n   constraint_t c;\n@@ -7184,7 +7184,7 @@ remove_preds_and_fake_succs (constraint_graph_t graph)\n static void\n solve_constraints (void)\n {\n-  struct scc_info *si;\n+  class scc_info *si;\n \n   /* Sort varinfos so that ones that cannot be pointed to are last.\n      This makes bitmaps more efficient.  */"}, {"sha": "51a316a0066f2392f51ef98b7186d173c11baf7d", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1556,7 +1556,7 @@ dbds_continue_enumeration_p (const_basic_block bb, const void *stop)\n    returns the state.  */\n \n enum bb_dom_status\n-determine_bb_domination_status (struct loop *loop, basic_block bb)\n+determine_bb_domination_status (class loop *loop, basic_block bb)\n {\n   basic_block *bblocks;\n   unsigned nblocks, i;\n@@ -1614,7 +1614,7 @@ determine_bb_domination_status (struct loop *loop, basic_block bb)\n    to the inside of the loop.  */\n \n static bool\n-thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n+thread_through_loop_header (class loop *loop, bool may_peel_loop_headers)\n {\n   basic_block header = loop->header;\n   edge e, tgt_edge, latch = loop_latch_edge (loop);\n@@ -2317,7 +2317,7 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,\n \t\t       unsigned n_region, unsigned current_path_no)\n {\n   unsigned i;\n-  struct loop *loop = entry->dest->loop_father;\n+  class loop *loop = entry->dest->loop_father;\n   edge exit_copy;\n   edge redirected;\n   profile_count curr_count;\n@@ -2517,7 +2517,7 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n {\n   bool retval = false;\n   unsigned int i;\n-  struct loop *loop;\n+  class loop *loop;\n   auto_bitmap threaded_blocks;\n   hash_set<edge> visited_starting_edges;\n "}, {"sha": "dc6de2f62b2999e9050f21052e152c2fac26354e", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -59,6 +59,6 @@ enum bb_dom_status\n   DOMST_DOMINATING\n };\n \n-enum bb_dom_status determine_bb_domination_status (struct loop *, basic_block);\n+enum bb_dom_status determine_bb_domination_status (class loop *, basic_block);\n \n #endif"}, {"sha": "dc8bbf81cc9202d442827cd94457f884be66f7cb", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n    block IB.  */\n \n tree\n-streamer_read_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n+streamer_read_string_cst (class data_in *data_in, class lto_input_block *ib)\n {\n   unsigned int len;\n   const char * ptr;\n@@ -57,7 +57,7 @@ streamer_read_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n    block IB.  */\n \n static tree\n-input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n+input_identifier (class data_in *data_in, class lto_input_block *ib)\n {\n   unsigned int len;\n   const char *ptr;\n@@ -73,7 +73,7 @@ input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n    tables and descriptors for the file being read.  */\n \n tree\n-streamer_read_chain (struct lto_input_block *ib, struct data_in *data_in)\n+streamer_read_chain (class lto_input_block *ib, class data_in *data_in)\n {\n   tree first, prev, curr;\n \n@@ -404,7 +404,7 @@ unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n    of expression EXPR from bitpack BP.  */\n \n static void\n-unpack_ts_block_value_fields (struct data_in *data_in,\n+unpack_ts_block_value_fields (class data_in *data_in,\n \t\t\t      struct bitpack_d *bp, tree expr)\n {\n   /* BLOCK_NUMBER is recomputed.  */\n@@ -415,7 +415,7 @@ unpack_ts_block_value_fields (struct data_in *data_in,\n    structure of expression EXPR from bitpack BP.  */\n \n static void\n-unpack_ts_translation_unit_decl_value_fields (struct data_in *data_in,\n+unpack_ts_translation_unit_decl_value_fields (class data_in *data_in,\n \t\t\t\t\t      struct bitpack_d *bp, tree expr)\n {\n   TRANSLATION_UNIT_LANGUAGE (expr) = xstrdup (bp_unpack_string (data_in, bp));\n@@ -427,7 +427,7 @@ unpack_ts_translation_unit_decl_value_fields (struct data_in *data_in,\n    structure of expression EXPR from bitpack BP.  */\n \n static void\n-unpack_ts_omp_clause_value_fields (struct data_in *data_in,\n+unpack_ts_omp_clause_value_fields (class data_in *data_in,\n \t\t\t\t   struct bitpack_d *bp, tree expr)\n {\n   stream_input_location (&OMP_CLAUSE_LOCATION (expr), bp, data_in);\n@@ -473,8 +473,8 @@ unpack_ts_omp_clause_value_fields (struct data_in *data_in,\n    bitfield values that the writer may have written.  */\n \n void\n-streamer_read_tree_bitfields (struct lto_input_block *ib,\n-\t\t\t      struct data_in *data_in, tree expr)\n+streamer_read_tree_bitfields (class lto_input_block *ib,\n+\t\t\t      class data_in *data_in, tree expr)\n {\n   enum tree_code code;\n   struct bitpack_d bp;\n@@ -570,7 +570,7 @@ streamer_read_tree_bitfields (struct lto_input_block *ib,\n    *IX_P the index into the reader cache where the new tree is stored.  */\n \n tree\n-streamer_alloc_tree (struct lto_input_block *ib, struct data_in *data_in,\n+streamer_alloc_tree (class lto_input_block *ib, class data_in *data_in,\n \t\t     enum LTO_tags tag)\n {\n   enum tree_code code;\n@@ -640,8 +640,8 @@ streamer_alloc_tree (struct lto_input_block *ib, struct data_in *data_in,\n \n \n static void\n-lto_input_ts_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t   struct data_in *data_in, tree expr)\n+lto_input_ts_common_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t   class data_in *data_in, tree expr)\n {\n   if (TREE_CODE (expr) != IDENTIFIER_NODE)\n     TREE_TYPE (expr) = stream_read_tree (ib, data_in);\n@@ -653,8 +653,8 @@ lto_input_ts_common_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t   struct data_in *data_in, tree expr)\n+lto_input_ts_vector_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t   class data_in *data_in, tree expr)\n {\n   unsigned int count = vector_cst_encoded_nelts (expr);\n   for (unsigned int i = 0; i < count; ++i)\n@@ -667,8 +667,8 @@ lto_input_ts_vector_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_poly_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t struct data_in *data_in, tree expr)\n+lto_input_ts_poly_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t class data_in *data_in, tree expr)\n {\n   for (unsigned int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n     POLY_INT_CST_COEFF (expr, i) = stream_read_tree (ib, data_in);\n@@ -680,8 +680,8 @@ lto_input_ts_poly_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_complex_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t    struct data_in *data_in, tree expr)\n+lto_input_ts_complex_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t    class data_in *data_in, tree expr)\n {\n   TREE_REALPART (expr) = stream_read_tree (ib, data_in);\n   TREE_IMAGPART (expr) = stream_read_tree (ib, data_in);\n@@ -693,8 +693,8 @@ lto_input_ts_complex_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_decl_minimal_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t struct data_in *data_in, tree expr)\n+lto_input_ts_decl_minimal_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t\t class data_in *data_in, tree expr)\n {\n   DECL_NAME (expr) = stream_read_tree (ib, data_in);\n   DECL_CONTEXT (expr) = stream_read_tree (ib, data_in);\n@@ -706,8 +706,8 @@ lto_input_ts_decl_minimal_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\tstruct data_in *data_in, tree expr)\n+lto_input_ts_decl_common_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t\tclass data_in *data_in, tree expr)\n {\n   DECL_SIZE (expr) = stream_read_tree (ib, data_in);\n   DECL_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n@@ -733,8 +733,8 @@ lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_decl_non_common_tree_pointers (struct lto_input_block *,\n-\t\t\t\t\t    struct data_in *, tree)\n+lto_input_ts_decl_non_common_tree_pointers (class lto_input_block *,\n+\t\t\t\t\t    class data_in *, tree)\n {\n }\n \n@@ -744,8 +744,8 @@ lto_input_ts_decl_non_common_tree_pointers (struct lto_input_block *,\n    file being read.  */\n \n static void\n-lto_input_ts_decl_with_vis_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t          struct data_in *data_in, tree expr)\n+lto_input_ts_decl_with_vis_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t          class data_in *data_in, tree expr)\n {\n   tree id;\n \n@@ -763,8 +763,8 @@ lto_input_ts_decl_with_vis_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t       struct data_in *data_in, tree expr)\n+lto_input_ts_field_decl_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t       class data_in *data_in, tree expr)\n {\n   DECL_FIELD_OFFSET (expr) = stream_read_tree (ib, data_in);\n   DECL_BIT_FIELD_TYPE (expr) = stream_read_tree (ib, data_in);\n@@ -778,8 +778,8 @@ lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_function_decl_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t  struct data_in *data_in, tree expr)\n+lto_input_ts_function_decl_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t\t  class data_in *data_in, tree expr)\n {\n   /* DECL_STRUCT_FUNCTION is loaded on demand by cgraph_get_body.  */\n   DECL_FUNCTION_PERSONALITY (expr) = stream_read_tree (ib, data_in);\n@@ -816,8 +816,8 @@ lto_input_ts_function_decl_tree_pointers (struct lto_input_block *ib,\n    being read.  */\n \n static void\n-lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\tstruct data_in *data_in, tree expr)\n+lto_input_ts_type_common_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t\tclass data_in *data_in, tree expr)\n {\n   TYPE_SIZE (expr) = stream_read_tree (ib, data_in);\n   TYPE_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n@@ -838,8 +838,8 @@ lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t\t    struct data_in *data_in,\n+lto_input_ts_type_non_common_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t\t    class data_in *data_in,\n \t\t\t\t\t    tree expr)\n {\n   if (TREE_CODE (expr) == ENUMERAL_TYPE)\n@@ -863,8 +863,8 @@ lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t struct data_in *data_in, tree expr)\n+lto_input_ts_list_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t class data_in *data_in, tree expr)\n {\n   TREE_PURPOSE (expr) = stream_read_tree (ib, data_in);\n   TREE_VALUE (expr) = stream_read_tree (ib, data_in);\n@@ -877,8 +877,8 @@ lto_input_ts_list_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_vec_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\tstruct data_in *data_in, tree expr)\n+lto_input_ts_vec_tree_pointers (class lto_input_block *ib,\n+\t\t\t\tclass data_in *data_in, tree expr)\n {\n   int i;\n \n@@ -895,8 +895,8 @@ lto_input_ts_vec_tree_pointers (struct lto_input_block *ib,\n \n \n static void\n-lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n-\t\t\t        struct data_in *data_in, tree expr)\n+lto_input_ts_exp_tree_pointers (class lto_input_block *ib,\n+\t\t\t        class data_in *data_in, tree expr)\n {\n   int i;\n   tree block;\n@@ -921,8 +921,8 @@ lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_block_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t  struct data_in *data_in, tree expr)\n+lto_input_ts_block_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t  class data_in *data_in, tree expr)\n {\n   BLOCK_VARS (expr) = streamer_read_chain (ib, data_in);\n \n@@ -967,8 +967,8 @@ lto_input_ts_block_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t  struct data_in *data_in, tree expr)\n+lto_input_ts_binfo_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t  class data_in *data_in, tree expr)\n {\n   tree t;\n \n@@ -999,8 +999,8 @@ lto_input_ts_binfo_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_constructor_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t        struct data_in *data_in, tree expr)\n+lto_input_ts_constructor_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t        class data_in *data_in, tree expr)\n {\n   unsigned i;\n \n@@ -1019,8 +1019,8 @@ lto_input_ts_constructor_tree_pointers (struct lto_input_block *ib,\n    file being read.  */\n \n static void\n-lto_input_ts_omp_clause_tree_pointers (struct lto_input_block *ib,\n-\t\t\t\t       struct data_in *data_in, tree expr)\n+lto_input_ts_omp_clause_tree_pointers (class lto_input_block *ib,\n+\t\t\t\t       class data_in *data_in, tree expr)\n {\n   int i;\n \n@@ -1034,7 +1034,7 @@ lto_input_ts_omp_clause_tree_pointers (struct lto_input_block *ib,\n    contains tables and descriptors for the file being read.  */\n \n void\n-streamer_read_tree_body (struct lto_input_block *ib, struct data_in *data_in,\n+streamer_read_tree_body (class lto_input_block *ib, class data_in *data_in,\n \t\t\t tree expr)\n {\n   enum tree_code code;\n@@ -1104,7 +1104,7 @@ streamer_read_tree_body (struct lto_input_block *ib, struct data_in *data_in,\n    DATA_IN->FILE_DATA->GLOBALS_INDEX[IX].  */\n \n tree\n-streamer_get_pickled_tree (struct lto_input_block *ib, struct data_in *data_in)\n+streamer_get_pickled_tree (class lto_input_block *ib, class data_in *data_in)\n {\n   unsigned HOST_WIDE_INT ix;\n   tree result;"}, {"sha": "01ddd638e379dbd08165d796ebc35c0cd2b82beb", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -58,14 +58,14 @@ struct streamer_tree_cache_d\n };\n \n /* In tree-streamer-in.c.  */\n-tree streamer_read_string_cst (struct data_in *, struct lto_input_block *);\n-tree streamer_read_chain (struct lto_input_block *, struct data_in *);\n-tree streamer_alloc_tree (struct lto_input_block *, struct data_in *,\n+tree streamer_read_string_cst (class data_in *, class lto_input_block *);\n+tree streamer_read_chain (class lto_input_block *, class data_in *);\n+tree streamer_alloc_tree (class lto_input_block *, class data_in *,\n \t\t          enum LTO_tags);\n-void streamer_read_tree_body (struct lto_input_block *, struct data_in *, tree);\n-tree streamer_get_pickled_tree (struct lto_input_block *, struct data_in *);\n-void streamer_read_tree_bitfields (struct lto_input_block *,\n-\t\t\t\t   struct data_in *, tree);\n+void streamer_read_tree_body (class lto_input_block *, class data_in *, tree);\n+tree streamer_get_pickled_tree (class lto_input_block *, class data_in *);\n+void streamer_read_tree_bitfields (class lto_input_block *,\n+\t\t\t\t   class data_in *, tree);\n \n /* In tree-streamer-out.c.  */\n void streamer_write_string_cst (struct output_block *,\n@@ -117,7 +117,7 @@ static inline machine_mode\n bp_unpack_machine_mode (struct bitpack_d *bp)\n {\n   return (machine_mode)\n-\t   ((struct lto_input_block *)\n+\t   ((class lto_input_block *)\n \t    bp->stream)->mode_table[bp_unpack_enum (bp, machine_mode, 1 << 8)];\n }\n "}, {"sha": "776db77f53a500763d75828e3f1c1c63cb321242", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -1448,8 +1448,8 @@ bit_test_cluster::is_beneficial (const vec<cluster *> &clusters,\n int\n case_bit_test::cmp (const void *p1, const void *p2)\n {\n-  const struct case_bit_test *const d1 = (const struct case_bit_test *) p1;\n-  const struct case_bit_test *const d2 = (const struct case_bit_test *) p2;\n+  const case_bit_test *const d1 = (const case_bit_test *) p1;\n+  const case_bit_test *const d2 = (const case_bit_test *) p2;\n \n   if (d2->bits != d1->bits)\n     return d2->bits - d1->bits;\n@@ -1480,7 +1480,7 @@ void\n bit_test_cluster::emit (tree index_expr, tree index_type,\n \t\t\ttree, basic_block default_bb)\n {\n-  struct case_bit_test test[m_max_case_bit_tests] = { {} };\n+  case_bit_test test[m_max_case_bit_tests] = { {} };\n   unsigned int i, j, k;\n   unsigned int count;\n "}, {"sha": "6390b1949b50b47193dbeb72ac0740d16920a97f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592", "patch": "@@ -183,7 +183,7 @@ vect_get_smallest_scalar_type (stmt_vec_info stmt_info,\n static opt_result\n vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if ((unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS) == 0)\n     return opt_result::failure_at (vect_location,\n@@ -306,7 +306,7 @@ vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n \t\t\t\t       loop_vec_info loop_vinfo,\n \t\t\t\t       int loop_depth, unsigned int *max_vf)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   lambda_vector dist_v;\n   unsigned int i;\n   FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n@@ -363,7 +363,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\t\t\t  unsigned int *max_vf)\n {\n   unsigned int i;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n   dr_vec_info *dr_info_a = loop_vinfo->lookup_dr (dra);\n@@ -867,7 +867,7 @@ void\n vect_record_base_alignments (vec_info *vinfo)\n {\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n-  struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n+  class loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n   data_reference *dr;\n   unsigned int i;\n   FOR_EACH_VEC_ELT (vinfo->shared->datarefs, i, dr)\n@@ -914,7 +914,7 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n   stmt_vec_info stmt_info = dr_info->stmt;\n   vec_base_alignments *base_alignments = &stmt_info->vinfo->base_alignments;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = NULL;\n+  class loop *loop = NULL;\n   tree ref = DR_REF (dr_info->dr);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n@@ -1659,7 +1659,7 @@ opt_result\n vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum dr_alignment_support supportable_dr_alignment;\n   dr_vec_info *first_store = NULL;\n   dr_vec_info *dr0_info = NULL;\n@@ -1822,7 +1822,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t computation will be invariant in the outermost loop.  */\n \t      else if (same_align_drs_max == same_align_drs)\n \t\t{\n-\t\t  struct loop *ivloop0, *ivloop;\n+\t\t  class loop *ivloop0, *ivloop;\n \t\t  ivloop0 = outermost_invariant_loop_for_expr\n \t\t    (loop, DR_BASE_ADDRESS (dr0_info->dr));\n \t\t  ivloop = outermost_invariant_loop_for_expr\n@@ -2710,7 +2710,7 @@ vect_analyze_data_ref_access (dr_vec_info *dr_info)\n   tree scalar_type = TREE_TYPE (DR_REF (dr));\n   stmt_vec_info stmt_info = dr_info->stmt;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = NULL;\n+  class loop *loop = NULL;\n \n   if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     return true;\n@@ -3730,7 +3730,7 @@ vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n {\n   HOST_WIDE_INT scale = 1;\n   poly_int64 pbitpos, pbitsize;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree offtype = NULL_TREE;\n   tree decl = NULL_TREE, base, off;\n@@ -4162,7 +4162,7 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n opt_result\n vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf, bool *fatal)\n {\n-  struct loop *loop = NULL;\n+  class loop *loop = NULL;\n   unsigned int i;\n   struct data_reference *dr;\n   tree scalar_type;\n@@ -4673,16 +4673,16 @@ vect_create_addr_base_for_vector_ref (stmt_vec_info stmt_info,\n \n tree\n vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n-\t\t\t  struct loop *at_loop, tree offset,\n+\t\t\t  class loop *at_loop, tree offset,\n \t\t\t  tree *initial_address, gimple_stmt_iterator *gsi,\n \t\t\t  gimple **ptr_incr, bool only_init,\n \t\t\t  tree byte_offset, tree iv_step)\n {\n   const char *base_name;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = NULL;\n+  class loop *loop = NULL;\n   bool nested_in_vect_loop = false;\n-  struct loop *containing_loop = NULL;\n+  class loop *containing_loop = NULL;\n   tree aggr_ptr_type;\n   tree aggr_ptr;\n   tree new_temp;\n@@ -5427,13 +5427,13 @@ vect_setup_realignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n                         tree *realignment_token,\n \t\t\tenum dr_alignment_support alignment_support_scheme,\n \t\t\ttree init_addr,\n-\t\t\tstruct loop **at_loop)\n+\t\t\tclass loop **at_loop)\n {\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n   struct data_reference *dr = dr_info->dr;\n-  struct loop *loop = NULL;\n+  class loop *loop = NULL;\n   edge pe = NULL;\n   tree scalar_dest = gimple_assign_lhs (stmt_info->stmt);\n   tree vec_dest;\n@@ -5448,8 +5448,8 @@ vect_setup_realignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   gimple_seq stmts = NULL;\n   bool compute_in_loop = false;\n   bool nested_in_vect_loop = false;\n-  struct loop *containing_loop = (gimple_bb (stmt_info->stmt))->loop_father;\n-  struct loop *loop_for_initial_load = NULL;\n+  class loop *containing_loop = (gimple_bb (stmt_info->stmt))->loop_father;\n+  class loop *loop_for_initial_load = NULL;\n \n   if (loop_vinfo)\n     {\n@@ -6459,7 +6459,7 @@ vect_supportable_dr_alignment (dr_vec_info *dr_info,\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   machine_mode mode = TYPE_MODE (vectype);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *vect_loop = NULL;\n+  class loop *vect_loop = NULL;\n   bool nested_in_vect_loop = false;\n \n   if (aligned_access_p (dr_info) && !check_aligned_accesses)"}, {"sha": "5c25441c70a271f04730486e513437fffa75b7e3", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "b0cbbac0cb5ba1ffce706715d3dbb9139063803d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "8430c98acc68de4894c5563677895e48746ee045", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "d172c3a75ae2f221166a74ec88d7360c01840c57", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "e921225b5ec873e877822a892b19f03f78aa8fb0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "173e6b51652fd023893b38da786ff28f827553b5", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "1456cde4c2c2dec7244c504d2c496248894a4f1e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "a6099639fb0ea9ccab631b7fdcfd1862a1f596a3", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "32e6ddd81656bceef041cbaab89ea9b42eb8680a", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "ca846d08cbd7da7acfe45f55e32916c5657654f3", "filename": "gcc/value-prof.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "67f25c1c79584e8cf4cc4e894254c2ffafd3b2e1", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "e886cdc71b8a8470a6644222a34fb53705067802", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "9a4aea0bf86056a43e1afc9ae9da54c4896fe964", "filename": "gcc/vr-values.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "3856da1f9a876cecc3ac7a99de79caec3f3c0a46", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "dcc15ca4d783081429378237a7f8c3ad6a6a39bc", "filename": "gcc/web.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "bb8ced123508d305e51c6e6bac36f75722553c89", "filename": "gcc/wide-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "847225af825334eca4000faaa770946cc26e0b5d", "filename": "libcpp/directives-only.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fdirectives-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fdirectives-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives-only.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "ddf8979d5139cf14c045cf891bfe443f5d5a78aa", "filename": "libcpp/directives.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "6ef6d07b89767bb98b71042521ae774e621d5893", "filename": "libcpp/files.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "a645f8136a6567b4cc28be3bf575d674b95be0ed", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "bde5e533c2be51a2cc86d293b23b39931dcb50f6", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "c6eb24fedeaa61cb4969224261c9fec752f18e42", "filename": "libcpp/include/mkdeps.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finclude%2Fmkdeps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finclude%2Fmkdeps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fmkdeps.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "472f104cb5f390162982b73f304e3ee3ba98216e", "filename": "libcpp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "45167a9500eba086dfffe5cdb963208f6e7caeab", "filename": "libcpp/internal.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "572d7f416f5a9aa98eb09bd8a4715c5d136025fa", "filename": "libcpp/line-map.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}, {"sha": "147aa909be70a9925851f86e19599a14149bf147", "filename": "libcpp/mkdeps.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99b1c316ec974a39bdd949f8559bb28861b69592/libcpp%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmkdeps.c?ref=99b1c316ec974a39bdd949f8559bb28861b69592"}]}