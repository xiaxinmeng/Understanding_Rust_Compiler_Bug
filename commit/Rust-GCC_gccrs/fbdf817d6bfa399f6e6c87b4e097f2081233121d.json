{"sha": "fbdf817d6bfa399f6e6c87b4e097f2081233121d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJkZjgxN2Q2YmZhMzk5ZjZlNmM4N2I0ZTA5N2YyMDgxMjMzMTIxZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-05-12T11:42:53Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-05-12T11:42:53Z"}, "message": "re PR target/37197 (-msse4 ICE on __builtin_parityl)\n\n\tPR target/37197\n\t* config/i386/driver-i386.c (processor_signatures): New enum.\n\t(SIG_GEODE): Move from vendor_signatures to processor_signatures.\n\t(host_detect_local_cpu): For SIG_AMD vendor, check for SIG_GEODE\n\tprocessor signature to detect geode processor.\n\nFrom-SVN: r147429", "tree": {"sha": "91b6815babd9775346da1a7aeb87980dc5be28e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91b6815babd9775346da1a7aeb87980dc5be28e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbdf817d6bfa399f6e6c87b4e097f2081233121d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdf817d6bfa399f6e6c87b4e097f2081233121d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbdf817d6bfa399f6e6c87b4e097f2081233121d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbdf817d6bfa399f6e6c87b4e097f2081233121d/comments", "author": null, "committer": null, "parents": [{"sha": "5e8d18263db963468b8ac2c15e352c91b7c9a3e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8d18263db963468b8ac2c15e352c91b7c9a3e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8d18263db963468b8ac2c15e352c91b7c9a3e6"}], "stats": {"total": 1104, "additions": 559, "deletions": 545}, "files": [{"sha": "4a46d51f06bb21f85e8583424af1242ca689bf59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 536, "deletions": 534, "changes": 1070, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdf817d6bfa399f6e6c87b4e097f2081233121d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdf817d6bfa399f6e6c87b4e097f2081233121d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbdf817d6bfa399f6e6c87b4e097f2081233121d", "patch": "@@ -1,3 +1,11 @@\n+2009-05-12  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/37197\n+\t* config/i386/driver-i386.c (processor_signatures): New enum.\n+\t(SIG_GEODE): Move from vendor_signatures to processor_signatures.\n+\t(host_detect_local_cpu): For SIG_AMD vendor, check for SIG_GEODE\n+\tprocessor signature to detect geode processor.\n+\n 2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \tRevert:\n@@ -9,64 +17,65 @@\n \n 2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n \n-        * dojump.c (compare_from_rtx): Delete.\n-        * expmed.c (emit_store_flag): Only try cstore_optab.  Canonicalize\n-        any MODE_CC mode to the cstorecc4 pattern.  Use prepare_operand, fail\n+\t* dojump.c (compare_from_rtx): Delete.\n+\t* expmed.c (emit_store_flag): Only try cstore_optab.  Canonicalize\n+\tany MODE_CC mode to the cstorecc4 pattern.  Use prepare_operand, fail\n \tif the comparison does not satisfy the predicate; test predicates for\n \toperands 2 and 3 of a cstore pattern.  Don't try cstore optab\n \tfurther if one existing pattern fails.\n-        * expr.h (compare_from_rtx): Delete.\n+\t* expr.h (compare_from_rtx): Delete.\n \t(prepare_operand): Declare it.\n-        * optabs.c: Change \"lib call\" to \"libcall\" throughout.\n+\t* optabs.c: Change \"lib call\" to \"libcall\" throughout.\n \t(bcc_gen_fctn, setcc_gen_code, trap_rtx,\n-        HAVE_conditional_trap, emit_cmp_insn): Delete.\n-        (can_compare_p): Delete cmp_optab case.\n+\tHAVE_conditional_trap, emit_cmp_insn): Delete.\n+\t(can_compare_p): Delete cmp_optab case.\n \t(prepare_float_lib_cmp): Return an rtx and a machine mode.\n-        Accept other parameters by value.\n-        (prepare_operand): Make non-static.\n-        (prepare_cmp_insn): Return an rtx and a machine mode.  Accept\n-        other parameters by value.  Try to widen operands here based on\n-        an optab_methods argument and looking at cbranch_optab.\n-        (emit_cmp_and_jump_insn_1): Accept test and mode, remove widening loop.\n-\tUse cbranch_optab directly.\n-        (emit_cmp_and_jump_insns): Fix comment.  Adjust call to prepare_cmp_insn\n-\tand emit_cmp_and_jump_insn_1, remove obsolete assertion.\n-        (emit_conditional_move, emit_conditional_add): Inline what's needed\n-        of compare_from_rtx, using new prepare_cmp_insn for the rest.\n-        (init_optabs): Init cmp_optab with UNKNOWN, cbranch_optab\n-        with COMPARE.  Move cmov_optab and cstore_optab above\n-        with cbranch_optab, move cmp_optab down with ucmp_optab,\n-        remove tst_otpab.  Do not initialize trap_rtx.\n-        (gen_cond_trap): Do it here.  Use ctrap_optab.  Test predicate\n+\tAccept other parameters by value.\n+\t(prepare_operand): Make non-static.\n+\t(prepare_cmp_insn): Return an rtx and a machine mode.  Accept\n+\tother parameters by value.  Try to widen operands here based on\n+\tan optab_methods argument and looking at cbranch_optab.\n+\t(emit_cmp_and_jump_insn_1): Accept test and mode, remove widening\n+\tloop.  Use cbranch_optab directly.\n+\t(emit_cmp_and_jump_insns): Fix comment.  Adjust call to\n+\tprepare_cmp_insn and emit_cmp_and_jump_insn_1, remove obsolete\n+\tassertion.\n+\t(emit_conditional_move, emit_conditional_add): Inline what's needed\n+\tof compare_from_rtx, using new prepare_cmp_insn for the rest.\n+\t(init_optabs): Init cmp_optab with UNKNOWN, cbranch_optab\n+\twith COMPARE.  Move cmov_optab and cstore_optab above\n+\twith cbranch_optab, move cmp_optab down with ucmp_optab,\n+\tremove tst_otpab.  Do not initialize trap_rtx.\n+\t(gen_cond_trap): Do it here.  Use ctrap_optab.  Test predicate\n \tfor trap code.  Do not check HAVE_conditional_trap.  Use\n \tprepare_cmp_insn.  Accept no predicate for operand 3.\n-        * optabs.h (OTI_cmp): Mark as used only for libcalls.\n-        (OTI_ctrap, ctrap_optab): New.\n-        (tst_optab): Delete.\n-        (bcc_gen_fctn, setcc_gen_code, emit_cmp_insn): Delete.\n-        * ifcvt.c (find_if_header): Replace HAVE_conditional_trap\n-        with lookup of ctrap_optab.\n-        * genopinit.c (cmp_optab, tst_optab, bcc_gen_fctn,\n-        setcc_gen_code): Delete.\n-        (ctrap_optab): New.\n-\n-        * combine.c (combine_simplify_rtx, simplify_set): Do not\n-        special case comparing against zero for cc0 machines.\n+\t* optabs.h (OTI_cmp): Mark as used only for libcalls.\n+\t(OTI_ctrap, ctrap_optab): New.\n+\t(tst_optab): Delete.\n+\t(bcc_gen_fctn, setcc_gen_code, emit_cmp_insn): Delete.\n+\t* ifcvt.c (find_if_header): Replace HAVE_conditional_trap\n+\twith lookup of ctrap_optab.\n+\t* genopinit.c (cmp_optab, tst_optab, bcc_gen_fctn,\n+\tsetcc_gen_code): Delete.\n+\t(ctrap_optab): New.\n+\n+\t* combine.c (combine_simplify_rtx, simplify_set): Do not\n+\tspecial case comparing against zero for cc0 machines.\n \t* simplify-rtx.c (simplify_binary_operation_1): Never remove\n \tCOMPARE on cc0 machines.\n \t(simplify_relational_operation): Return a new expression when\n \ta COMPARE could be removed.\n-        * final.c (final_scan_insn): Compare cc_status values\n-        against LHS of a (compare FOO (const_int 0)) cc0 source.\n-        Also check if cc_status.value is the full compare.\n+\t* final.c (final_scan_insn): Compare cc_status values\n+\tagainst LHS of a (compare FOO (const_int 0)) cc0 source.\n+\tAlso check if cc_status.value is the full compare.\n \n-        * doc/md.texi (bCC, sCC, tstMM, cmpMM): Delete.\n-        (cstoreMM4): Document.\n+\t* doc/md.texi (bCC, sCC, tstMM, cmpMM): Delete.\n+\t(cstoreMM4): Document.\n \t(conditional_trap): Document ctrapMM4 instead.\n-        (sync_compare_and_swapMM): Refer to cbranchcc4.\n+\t(sync_compare_and_swapMM): Refer to cbranchcc4.\n \t(Dependent Patterns): Eliminate obsolete information referring to\n \tthe old jump optimization phase.\n-        (Canonicalization): Include cbranchcc4 case, omit canonicalization\n+\t(Canonicalization): Include cbranchcc4 case, omit canonicalization\n \tof compares with 0 on cc0 machines.\n \t(Jump Patterns): Refer to MODE_CC jump patterns preferably,\n \tavoiding references to cc0.  Remove text about storing operands\n@@ -75,120 +84,118 @@\n \tcondition code representations, separate into subsections for\n \tCC0, MODE_CC and conditional execution.\n \n-        * config/alpha/alpha-protos.h (alpha_emit_conditional_branch,\n-        alpha_emit_setcc): Accept operands and a machine mode.\n-        * config/alpha/alpha.c (alpha_emit_conditional_branch):\n-        Get code/op0/op1 from operands, use machine mode argument\n-        instead of alpha_compare.fp_p.  Emit the branch here.\n-        (alpha_emit_setcc): Likewise, and return boolean.\n-        (alpha_emit_conditional_move): Likewise.  Assert that\n-        cmp_op_mode == cmp_mode, and simplify accordingly.\n-        * config/alpha/alpha.h (struct alpha_compare, alpha_compare): Delete.\n-        * config/alpha/alpha.md (cmpdf, cmptf, cmpdi, bCC, sCC): Delete.\n-        (cbranchdf4, cbranchtf4, cbranchdi4, cstoredf4, cstoretf4,\n-        cstoredi4): Delete.\n-        (stack probe test): Use cbranchdi4.\n-        * config/alpha/predicates.md (alpha_cbranch_operator): New.\n-\n-        * config/arc/arc.c (gen_compare_reg): Do not emit cmp. \n-        * config/arc/arc.h (movsicc, movsfcc): Use it.\n-        (movdicc, *movdicc_insn, movdfcc, *movdfcc_insn): Remove.\n-        (cbranchsi4, cstoresi4): New.\n-        (cmpsi, bCC and sCC expanders): Remove. \n-\n-        * config/arm/arm.c (arm_compare_op0, arm_compare_op1): Delete.\n-        * config/arm/arm.h (arm_compare_op0, arm_compare_op1): Delete.\n-        * config/arm/predicates.md (arm_comparison_operator): Only include\n-        floating-point operators if there is a hardware floating-point unit.\n-        * config/arm/arm.md (cbranchsi4, cstoresi4): Enable for TARGET_32BIT,\n-        deferring to cbranch_cc and cstore_cc respectively.\n-        (cbranchsf4, cbranchdf4, cbranchdi4, cstoresf4, cstoredf4, cstoredi4,\n-        cbranch_cc, cstore_cc): New.\n-        (movsicc, movsfcc, movdfcc): Do not use arm_compare_op0 and\n+\t* config/alpha/alpha-protos.h (alpha_emit_conditional_branch,\n+\talpha_emit_setcc): Accept operands and a machine mode.\n+\t* config/alpha/alpha.c (alpha_emit_conditional_branch):\n+\tGet code/op0/op1 from operands, use machine mode argument\n+\tinstead of alpha_compare.fp_p.  Emit the branch here.\n+\t(alpha_emit_setcc): Likewise, and return boolean.\n+\t(alpha_emit_conditional_move): Likewise.  Assert that\n+\tcmp_op_mode == cmp_mode, and simplify accordingly.\n+\t* config/alpha/alpha.h (struct alpha_compare, alpha_compare): Delete.\n+\t* config/alpha/alpha.md (cmpdf, cmptf, cmpdi, bCC, sCC): Delete.\n+\t(cbranchdf4, cbranchtf4, cbranchdi4, cstoredf4, cstoretf4,cstoredi4):\n+\tDelete.\n+\t(stack probe test): Use cbranchdi4.\n+\t* config/alpha/predicates.md (alpha_cbranch_operator): New.\n+\n+\t* config/arc/arc.c (gen_compare_reg): Do not emit cmp. \n+\t* config/arc/arc.h (movsicc, movsfcc): Use it.\n+\t(movdicc, *movdicc_insn, movdfcc, *movdfcc_insn): Remove.\n+\t(cbranchsi4, cstoresi4): New.\n+\t(cmpsi, bCC and sCC expanders): Remove. \n+\n+\t* config/arm/arm.c (arm_compare_op0, arm_compare_op1): Delete.\n+\t* config/arm/arm.h (arm_compare_op0, arm_compare_op1): Delete.\n+\t* config/arm/predicates.md (arm_comparison_operator): Only include\n+\tfloating-point operators if there is a hardware floating-point unit.\n+\t* config/arm/arm.md (cbranchsi4, cstoresi4): Enable for TARGET_32BIT,\n+\tdeferring to cbranch_cc and cstore_cc respectively.\n+\t(cbranchsf4, cbranchdf4, cbranchdi4, cstoresf4, cstoredf4, cstoredi4,\n+\tcbranch_cc, cstore_cc): New.\n+\t(movsicc, movsfcc, movdfcc): Do not use arm_compare_op0 and\n \tarm_compare_op1.\n-        (bCC, sCC, cmpsi, cmpsf, cmpdf, cmpdi): Delete.\n-\n-        * config/avr/avr-protos.h (out_tstsi, out_tsthi): Adjust prototype.\n-        * config/avr/avr.c (out_tstsi, out_tsthi): Get the tested operand\n-        as an argument.\n-        (adjust_insn_length): Adjust calls.\n-        (avr_reorg): Handle (compare (foo) (const_int 0)).\n-        * config/avr/avr.md (tstqi, tsthi, tstsi): Remove.\n-        (*negated_tstqi, *negated_tsthi, *negated_tstsi): Unmacroize.\n-        (*reversed_tsthi, *reversed_tstsi): Add a scratch for simplicity.\n-        (cmpqi, cmphi, cmpsi): Prepend asterisk, fuse tst[qhs]i here.\n-        (bCC): Remove.\n-        (cbranchqi4, cbranchhi4, cbranchsi4): New.\n+\t(bCC, sCC, cmpsi, cmpsf, cmpdf, cmpdi): Delete.\n+\n+\t* config/avr/avr-protos.h (out_tstsi, out_tsthi): Adjust prototype.\n+\t* config/avr/avr.c (out_tstsi, out_tsthi): Get the tested operand\n+\tas an argument.\n+\t(adjust_insn_length): Adjust calls.\n+\t(avr_reorg): Handle (compare (foo) (const_int 0)).\n+\t* config/avr/avr.md (tstqi, tsthi, tstsi): Remove.\n+\t(*negated_tstqi, *negated_tsthi, *negated_tstsi): Unmacroize.\n+\t(*reversed_tsthi, *reversed_tstsi): Add a scratch for simplicity.\n+\t(cmpqi, cmphi, cmpsi): Prepend asterisk, fuse tst[qhs]i here.\n+\t(bCC): Remove.\n+\t(cbranchqi4, cbranchhi4, cbranchsi4): New.\n \t(tst -> sbrc/sbrs peephole2, cpse peephole): Wrap RHS with COMPARE.\n \n-        * config/bfin/bfin.md (cmpbi, cmpsi, bCC, sCC): Delete.\n-        (cbranchsi4, cstorebi4, cstoresi4): New.\n+\t* config/bfin/bfin.md (cmpbi, cmpsi, bCC, sCC): Delete.\n+\t(cbranchsi4, cstorebi4, cstoresi4): New.\n \t(movbisi): This insn is duplicate, split it to zero_extend.\n-        * config/bfin/bfin.c (bfin_compare_op0, bfin_compare_op1): Delete\n-        (bfin_gen_compare): Do not use them.  Emit VOIDmode SET, not BImode.\n-        (bfin_optimize_loop): Use cbranch expander.\n-        * config/bfin/bfin.h (bfin_compare_op0, bfin_compare_op1): Delete.\n-        * config/bfin/predicates.md (bfin_cbranch_operator): Rename to...\n-        (bfin_bimode_comparison_operator): ... this.\n-        (bfin_direct_comparison_operator): New.\n+\t* config/bfin/bfin.c (bfin_compare_op0, bfin_compare_op1): Delete\n+\t(bfin_gen_compare): Do not use them.  Emit VOIDmode SET, not BImode.\n+\t(bfin_optimize_loop): Use cbranch expander.\n+\t* config/bfin/bfin.h (bfin_compare_op0, bfin_compare_op1): Delete.\n+\t* config/bfin/predicates.md (bfin_cbranch_operator): Rename to...\n+\t(bfin_bimode_comparison_operator): ... this.\n+\t(bfin_direct_comparison_operator): New.\n  \n-        * config/cris/cris.c (cris_normal_notice_update_cc): Look\n-        inside (compare FOO (const_int 0)).\n-        (cris_rtx_costs): Handle ZERO_EXTRACT.\n-        * config/cris/cris.md (tstdi, tst<mode>, cmpdi): Delete.\n-        (*tstdi_non_v32): Fold in *cmpdi_non_v32.\n-        (*tstdi_v32): Delete.\n-        (*cmpdi_non_v32): Add M alternative for operand 1.\n-        (cmpsi, cmp<mode>): Make private.\n-        (*tstsi, *tst<mode>_cmp, *tst<mode>_non_cmp, *btst): Wrap\n-        LHS with COMPARE.\n-        (cbranch<mode>4, cbranchdi4, cstore<mode>4): New.\n-\n-        * config/crx/crx.md (cstore<mode>4, cbranchcc4): New.\n-        (cmp<mode>, bCOND_internal, b<code>, s<code>): Delete.\n-        (cbranch<mode>4, sCOND_internal): Use ordered_comparison_operator.\n+\t* config/cris/cris.c (cris_normal_notice_update_cc): Look\n+\tinside (compare FOO (const_int 0)).\n+\t(cris_rtx_costs): Handle ZERO_EXTRACT.\n+\t* config/cris/cris.md (tstdi, tst<mode>, cmpdi): Delete.\n+\t(*tstdi_non_v32): Fold in *cmpdi_non_v32.\n+\t(*tstdi_v32): Delete.\n+\t(*cmpdi_non_v32): Add M alternative for operand 1.\n+\t(cmpsi, cmp<mode>): Make private.\n+\t(*tstsi, *tst<mode>_cmp, *tst<mode>_non_cmp, *btst): Wrap LHS\n+\twith COMPARE.\n+\t(cbranch<mode>4, cbranchdi4, cstore<mode>4): New.\n+\n+\t* config/crx/crx.md (cstore<mode>4, cbranchcc4): New.\n+\t(cmp<mode>, bCOND_internal, b<code>, s<code>): Delete.\n+\t(cbranch<mode>4, sCOND_internal): Use ordered_comparison_operator.\n \t(cc_reg_operand): New.\n \t(any_cond): Delete.\n-        * config/crx/crx.c (crx_compare_op0, crx_compare_op1,\n-        crx_expand_compare, crx_expand_branch, crx_expand_scond): Delete.\n-        * config/crx/crx.h (crx_compare_op0, crx_compare_op1): Delete.\n-        * config/crx/crx-protos.h (crx_expand_compare, crx_expand_branch,\n-        crx_expand_scond): Delete.\n-\n-        * config/fr30/fr30.md (cmp<mode>, bCC): Delete.\n-        (cbranchsi4): New.\n-        * config/fr30/fr30.c (fr30_compare_op0, fr30_compare_op1): Delete\n-        * config/fr30/fr30.h (fr30_compare_op0, fr30_compare_op1): Delete.\n-\n-        * config/frv/frv.md (cbranchsi4, cbranchsf4, cbranchdf4,\n-        cstoresi4, cstoresf4, cstoredf4): New.\n-        (cmpdi, cmpsi, cmpsf, cmpdf, bCC, sCC): Remove.\n-        * config/frv/frv-protos.h (frv_emit_cbranch, frv_emit_scc):\n-        Receive the entire operands array.\n-        * config/frv/frv.h (frv_compare_op0,\n-        frv_compare_op1): Delete.\n-        * config/frv/frv.c (frv_compare_op0,\n-        frv_compare_op1): Delete.\n-        * config/frv/frv-protos.h (frv_emit_cbranch, frv_emit_scc):\n-        Get test/op0/op1 from the operands array.\n-        (frv_emit_cond_move): Get test/op0/op1 from the test_rtx.\n-\n-        * config/h8300/h8300-protos.h (h8300_expand_branch): Accept operands.\n-        (h8300_expand_store): New.\n-        * config/h8300/h8300.c (h8300_rtx_costs): Handle (compare FOO\n-        (const_int 0)).\n-        (h8300_expand_branch): Emit compare here.  Adjust for new arguments.\n-        (h8300_expand_store): New.\n-        * config/h8300/h8300.md (btst combine patterns): Wrap with COMPARE\n-        or do not try to produce (set (cc0) REG).\n-        (peepholes): Wrap arguments with COMPARE.  Add a peephole to\n-        change a compare into a move to a scratch register.  Disable some\n-        peepholes when comparing with zero.\n-        (tstsi, tsthi, tstsi, cmpqi): Make private.\n-        (cmphi): Delete.\n-        (bCC, sCC): Delete.\n-        (cbranchqi4, cbranchhi4, cbranchsi4, cstoreqi4, cstorehi4,\n-        cstoresi4): New.\n+\t* config/crx/crx.c (crx_compare_op0, crx_compare_op1,\n+\tcrx_expand_compare, crx_expand_branch, crx_expand_scond): Delete.\n+\t* config/crx/crx.h (crx_compare_op0, crx_compare_op1): Delete.\n+\t* config/crx/crx-protos.h (crx_expand_compare, crx_expand_branch,\n+\tcrx_expand_scond): Delete.\n+\n+\t* config/fr30/fr30.md (cmp<mode>, bCC): Delete.\n+\t(cbranchsi4): New.\n+\t* config/fr30/fr30.c (fr30_compare_op0, fr30_compare_op1): Delete\n+\t* config/fr30/fr30.h (fr30_compare_op0, fr30_compare_op1): Delete.\n+\n+\t* config/frv/frv.md (cbranchsi4, cbranchsf4, cbranchdf4,\n+\tcstoresi4, cstoresf4, cstoredf4): New.\n+\t(cmpdi, cmpsi, cmpsf, cmpdf, bCC, sCC): Remove.\n+\t* config/frv/frv-protos.h (frv_emit_cbranch, frv_emit_scc):\n+\tReceive the entire operands array.\n+\t* config/frv/frv.h (frv_compare_op0, frv_compare_op1): Delete.\n+\t* config/frv/frv.c (frv_compare_op0, frv_compare_op1): Delete.\n+\t* config/frv/frv-protos.h (frv_emit_cbranch, frv_emit_scc):\n+\tGet test/op0/op1 from the operands array.\n+\t(frv_emit_cond_move): Get test/op0/op1 from the test_rtx.\n+\n+\t* config/h8300/h8300-protos.h (h8300_expand_branch): Accept operands.\n+\t(h8300_expand_store): New.\n+\t* config/h8300/h8300.c (h8300_rtx_costs): Handle (compare FOO\n+\t(const_int 0)).\n+\t(h8300_expand_branch): Emit compare here.  Adjust for new arguments.\n+\t(h8300_expand_store): New.\n+\t* config/h8300/h8300.md (btst combine patterns): Wrap with COMPARE\n+\tor do not try to produce (set (cc0) REG).\n+\t(peepholes): Wrap arguments with COMPARE.  Add a peephole to\n+\tchange a compare into a move to a scratch register.  Disable some\n+\tpeepholes when comparing with zero.\n+\t(tstsi, tsthi, tstsi, cmpqi): Make private.\n+\t(cmphi): Delete.\n+\t(bCC, sCC): Delete.\n+\t(cbranchqi4, cbranchhi4, cbranchsi4, cstoreqi4, cstorehi4,\n+\tcstoresi4): New.\n \n \t* config/i386/i386.c (ix86_expand_int_movcc, ix86_expand_int_addcc,\n \tix86_expand_fp_movcc): Set ix86_compare_op0 and ix86_compare_op1.\n@@ -198,381 +205,383 @@\n \t* config/i386/i386-protos.h (ix86_expand_setcc): Return void.\n \t* config/i386/i386.md (cmpti, cmpdi, cmpsi, cmphi, cmpqi, cmpxf,\n \tcmp<MODEF>, cmpcc): Remove.\n-\t(cbranchti4, cbranchdi4, cbranchsi4, cbranchhi4, cbranchqi4, cbranchxf4,\n-\tcbranch<MODEF>4, cbranchcc4, cstoredi4, cstoresi4, cstorehi4,\n-\tcstoreqi4, cstorexf4, cstore<MODEF>4, cstorecc): New.\n+\t(cbranchti4, cbranchdi4, cbranchsi4, cbranchhi4, cbranchqi4,\n+\tcbranchxf4, cbranch<MODEF>4, cbranchcc4, cstoredi4, cstoresi4,\n+\tcstorehi4, cstoreqi4, cstorexf4, cstore<MODEF>4, cstorecc): New.\n \t(sCC and bCC expanders): Remove.\n \t(stack_protect_test): Use cbranchcc4.\n \n-        * config/ia64/ia64-protos.h (ia64_compare_op0, ia64_compare_op1):\n-        Delete.\n-        (ia64_expand_compare): Accept three rtx by reference and return void.\n-        * config/ia64/ia64.c (ia64_compare_op0, ia64_compare_op1): Delete.\n-        (ia64_expand_compare): Replace op0/op1 with *op0/*op1.  Get code\n-        from *expr.  Update *expr with the BImode comparison to do.\n-        * config/ia64/ia64.md (cmpbi, cmpsi, cmpdi, cmpsf, cmpdf, cmpxf,\n-        cmptf, bCC, sCC, conditional_trap): Delete.\n-        (cbranchbi4, cbranchsi4, cbranchdi4, cbranchsf4, cbranchdf4, \n-        cbranchxf4, cbranchtf4, cstorebi4, cstoresi4, cstoredi4, cstoresf4,\n-        cstoredf4, cstorexf4, cstoretf4, ctrapbi4, ctrapsi4, ctrapdi4,\n-        ctrapsf4, ctrapdf4, ctrapxf4, ctraptf4): New.\n-        * config/ia64/predicates.md (ia64_cbranch_operator): New.\n-\n-        * config/iq2000/iq2000-protos.h (gen_conditional_branch): Change\n-        type of last argument.\n-        * config/iq2000/iq2000.c (branch_cmp, branch_type): Remove.\n-        (gen_conditional_branch): Get code/cmp0/cmp1 from operands,\n-        use machine mode argument instead of branch_type.  Remove dead\n-        code for floating-point comparisons.\n-        * config/iq2000/iq2000.h (branch_cmp, branch_type): Remove.\n-        * config/iq2000/iq2000.md (cmpsi, cmpdi, cmpsf, cmpdf, tstsi,\n-        bCC): Remove.\n-        (cbranchsi4, cstoresi4): New.\n-        * config/iq2000/predicates.md (reg_or_const_operand): New.\n-\n-        * config/m32c/m32c.md (cbranch splitter): Use match_op_dup.\n-        * config/m32c/m32c.md (any_cond, gl_cond): Delete.\n-        (b<code>_op): Rewrite to...\n-        (bcc_op): ... this, using match_operator.\n-        (s<code>_op): Rewrite to...\n-        (scc_op): ... this, using match_operator.\n-        (s<code>_24_op): Rewrite to...\n-        (scc_op_24): ... this, using match_operator.\n-        (s<code>_<mode>): Rewrite to...\n-        (cstore<mode>4): ... this, using match_operator.\n-        (s<code>_<mode>_24): Rewrite to...\n-        (cstore<mode>4_24): ... this, using match_operator.\n-        * config/m32c/m32c-protos.h (m32c_cmp_flg_0, m32c_pend_compare,\n-        m32c_unpend_compare, m32c_expand_scc): Delete.\n-        * config/m32c/m32c.c (compare_op0, compare_op1, m32c_cmp_flg_0,\n-        m32c_pend_compare, m32c_unpend_compare, m32c_expand_scc): Delete.\n-        (m32c_expand_movcc): Change NE to EQ if necessary.\n-        (m32c_init_libfuncs): Modify cstore optab instead of setcc_gen_code.\n-\n-        * config/m32r/m32r-protos.h (gen_cond_store): New.\n-        * config/m32r/m32r.c (m32r_compare_op0, m32r_compare_op1): Delete.\n-        (gen_cond_store): New, from sCC patterns.\n-        (m32r_expand_block_move): Use cbranchsi4.\n-        * config/m32r/m32r.h (m32r_compare_op0, m32r_compare_op1): Delete.\n-        * config/m32r/m32r.md (cmpsi, bCC, sCC): Delete.\n-        (cbranchsi4, cstoresi4): New.\n-        \n-        * config/m68hc11/m68hc11.c (m68hc11_compare_op0, m68hc11_compare_op1):\n-        Delete.\n-        (m68hc11_rtx_costs_1, m68hc11_rtx_costs): Handle ZERO_EXTRACT.\n+\t* config/ia64/ia64-protos.h (ia64_compare_op0, ia64_compare_op1):\n+\tDelete.\n+\t(ia64_expand_compare): Accept three rtx by reference and return void.\n+\t* config/ia64/ia64.c (ia64_compare_op0, ia64_compare_op1): Delete.\n+\t(ia64_expand_compare): Replace op0/op1 with *op0/*op1.  Get code\n+\tfrom *expr.  Update *expr with the BImode comparison to do.\n+\t* config/ia64/ia64.md (cmpbi, cmpsi, cmpdi, cmpsf, cmpdf, cmpxf,\n+\tcmptf, bCC, sCC, conditional_trap): Delete.\n+\t(cbranchbi4, cbranchsi4, cbranchdi4, cbranchsf4, cbranchdf4, \n+\tcbranchxf4, cbranchtf4, cstorebi4, cstoresi4, cstoredi4, cstoresf4,\n+\tcstoredf4, cstorexf4, cstoretf4, ctrapbi4, ctrapsi4, ctrapdi4,\n+\tctrapsf4, ctrapdf4, ctrapxf4, ctraptf4): New.\n+\t* config/ia64/predicates.md (ia64_cbranch_operator): New.\n+\n+\t* config/iq2000/iq2000-protos.h (gen_conditional_branch): Change\n+\ttype of last argument.\n+\t* config/iq2000/iq2000.c (branch_cmp, branch_type): Remove.\n+\t(gen_conditional_branch): Get code/cmp0/cmp1 from operands,\n+\tuse machine mode argument instead of branch_type.  Remove dead\n+\tcode for floating-point comparisons.\n+\t* config/iq2000/iq2000.h (branch_cmp, branch_type): Remove.\n+\t* config/iq2000/iq2000.md (cmpsi, cmpdi, cmpsf, cmpdf, tstsi, bCC):\n+\tRemove.\n+\t(cbranchsi4, cstoresi4): New.\n+\t* config/iq2000/predicates.md (reg_or_const_operand): New.\n+\n+\t* config/m32c/m32c.md (cbranch splitter): Use match_op_dup.\n+\t* config/m32c/m32c.md (any_cond, gl_cond): Delete.\n+\t(b<code>_op): Rewrite to...\n+\t(bcc_op): ... this, using match_operator.\n+\t(s<code>_op): Rewrite to...\n+\t(scc_op): ... this, using match_operator.\n+\t(s<code>_24_op): Rewrite to...\n+\t(scc_op_24): ... this, using match_operator.\n+\t(s<code>_<mode>): Rewrite to...\n+\t(cstore<mode>4): ... this, using match_operator.\n+\t(s<code>_<mode>_24): Rewrite to...\n+\t(cstore<mode>4_24): ... this, using match_operator.\n+\t* config/m32c/m32c-protos.h (m32c_cmp_flg_0, m32c_pend_compare,\n+\tm32c_unpend_compare, m32c_expand_scc): Delete.\n+\t* config/m32c/m32c.c (compare_op0, compare_op1, m32c_cmp_flg_0,\n+\tm32c_pend_compare, m32c_unpend_compare, m32c_expand_scc): Delete.\n+\t(m32c_expand_movcc): Change NE to EQ if necessary.\n+\t(m32c_init_libfuncs): Modify cstore optab instead of setcc_gen_code.\n+\n+\t* config/m32r/m32r-protos.h (gen_cond_store): New.\n+\t* config/m32r/m32r.c (m32r_compare_op0, m32r_compare_op1): Delete.\n+\t(gen_cond_store): New, from sCC patterns.\n+\t(m32r_expand_block_move): Use cbranchsi4.\n+\t* config/m32r/m32r.h (m32r_compare_op0, m32r_compare_op1): Delete.\n+\t* config/m32r/m32r.md (cmpsi, bCC, sCC): Delete.\n+\t(cbranchsi4, cstoresi4): New.\n+\t\n+\t* config/m68hc11/m68hc11.c (m68hc11_compare_op0, m68hc11_compare_op1):\n+\tDelete.\n+\t(m68hc11_rtx_costs_1, m68hc11_rtx_costs): Handle ZERO_EXTRACT.\n \t(m68hc11_notice_update_cc): Look into a compare with 0.\n-        * config/m68hc11/m68hc11.h (m68hc11_compare_op0, m68hc11_compare_op1):\n-        Delete.\n-        * config/m68hc11/m68hc11.md (tstsi, tsthi, tstqi, cmpsi,\n-        cmphi, cmpqi, bCC): Delete.\n-        (cbranchsi4, cbranchhi4, cbranchqi4): New.\n-        (tstqi_1, tstqi_z_used, tstqi_1, bitcmpqi, bitcmpqi_z_used,\n-        bitcmpqi_12, bitcmphi, various splits and peephole2s): Wrap cc0<-reg\n-        sets with COMPARE.\n-\n-        * config/m68k/predicates.md (m68k_cstore_comparison_operator,\n-        const0_operand, const1_operand, m68k_subword_comparison_operand): New.\n-        * config/m68k/constraints.md (H): New.\n-        * config/m68k/m68k.md (tstdi): Remove define_expand, use name for\n-        the define_insn below.\n-        (tstsi, tsthi, tst<FP:mode>, cmphi, cmpqi, cmp<FP:mode>): Delete.\n-        (*tstsi_internal_68020_cf, *tstsi_internal, *tsthi_internal,\n-        *tstqi_internal, tst<mode>_6881, tst<mode>_cf, many unnamed\n-        patterns): Wrap RHS with COMPARE.\n-        (tst<FP>_68881, tst<FP>_cf): Use const0_operand.\n-        (*cmpdi_internal): Name this pattern.\n-        (cmpdi): Change to define_insn.\n-        (cbranchdi4, cstoredi4, cbranchsi4, cstoresi4, cbranchhi4, cstorehi4,\n-        cbranchqi4, cstoreqi4, cbranch<FP:mode>4, cstore<FP:mode>4): New.\n-        (scc0_di, scc0_di_5200, scc_di): Use the ordered_comparison_operator\n-        predicate.\n-        (seq, sne, sgt, sgtu, slt, sltu, sge, sgeu, sle, sleu, sordered,\n-        sunordered, suneq, sunge, sungt, sunle, sunlt, sltgt): Delete\n-        (conditional_trap): Change to...\n-        (ctrapdi4, ctrapsi4, ctraphi4, ctrapqi4): ... these.\n-        (*conditional_trap): Use the ordered_comparison_operator and\n-        const1_operand predicates.\n-        * config/m68k/m68k.c (m68k_last_compare_had_fp_operands): Delete.\n-        (m68k_expand_prologue): Use ctrapsi4 instead of cmpsi+conditional_trap.\n-        (m68k_rtx_costs): Look for ZERO_EXTRACT in a COMPARE.\n-        * config/m68k/m68k.h (m68k_last_compare_had_fp_operands): Delete.\n-\n-        * config/mcore/mcore-protos.h (arch_compare_op0, arch_compare_op1,\n-        mcore_modify_comparison, mcore_gen_compare_reg): Remove.\n-        (mcore_gen_compare): New. \n-        * config/mcore/mcore.c (arch_compare_op0, arch_compare_op1): Delete.\n-        (mcore_modify_comparison, mcore_gen_compare_reg): Fold into...\n-        (mcore_gen_compare): ... this.\n-        * config/mcore/mcore.md (cmpsi, bCC, sCC): Remove.\n-        (cbranchsi4, cstoresi4): New, using mcore_gen_compare.\n-        (stack probe pattern): Use cbranchsi4.\n-\n-        * config/mips/predicates.md (mips_cstore_operator): New.\n-        * config/mips/mips-ps-3d.md (movv2sfcc): Do not use cmp_operands.\n-        * config/mips/mips.md (any_cond): Delete.\n-        (conditional_trap): Rename to ctrap<GPR:mode>4.  Adjust predicates,\n-        always succeed.\n-        (fixuns_truncdfsi2, fixuns_truncdfdi2, fixuns_truncsfsi2,\n-        fixuns_truncsfdi2): Use cbranch patterns.\n-        (cmp<GPR:mode>, cmp<SCALARF:mode>): Delete. \n-        (b<code>): Change to cbranch<GPR:mode>4 and cbranch<SCALARF:mode>4.\n-        Adjust call to mips_expand_conditional_branch.\n-        (seq, sne, slt<u>, sle<u>, sgt<u>, sge<u>): Change to cstore<GPR:mode>4.\n-        * config/mips/mips-protos.h (mips_expand_conditional_branch,\n-        mips_expand_scc, mips_expand_conditional_trap): Adjust prototypes.\n-        * config/mips/mips.c (cmp_operands): Delete.\n-        (mips_emit_compare): Get comparison operands from *op0/*op1.\n-        (mips_expand_scc): Get code/op0/op1/target from operands.  Assert\n-        that it succeeds.  Use op0/op1 instead of cmp_operands.\n-        (mips_expand_conditional_branch, mips_expand_conditional_move,\n-        mips_expand_conditional_trap): Likewise.\n-        (mips_block_move_loop): Use cbranch patterns. \n-        * config/mips/mips.h (cmp_operands): Delete.\n-\n-        * config/mmix/mmix.c (mmix_valid_comparison): Delete.\n-        (mmix_gen_compare_reg): Just return a register in the right CC mode.\n-        * config/mmix/mmix.h (mmix_compare_op0, mmix_compare_op1): New.\n-        * config/mmix/mmix.md (cmpdi, cmpdf): Remove.\n-        (*cmpcc_folded): Rename to...\n-        (*cmpdi_folded): this.\n-        (*cmpcc): Rename to...\n-        (*cmps): ... this.\n-        (movdfcc, movdicc): Adjust for new semantics of mmix_gen_compare_reg.\n-        (bCC): Remove.\n-        (cbranchdi4): New.\n-        (cbranchdf4): New.  Handle invalid comparisons here.\n-        * config/mmix/predicates.md (float_comparison_operator): New.\n-\n-        * config/mn10300/mn10300.c (mn10300_rtx_costs): Consider 0 and\n-        zero_extract to be cheap in (compare (zero_extract) (const_int 0).\n-        * config/mn10300/mn10300.md (tst): Delete.\n-        (*tst_extqisi_am33, *tst_extqisi, *tst_exthisi_am33, *tst_exthisi):\n-        Name these patterns and wrap RHS in a compare.\n-        (*cmpsi): Make this pattern private.  Include tst.\n-        (*cmpsf): Make this pattern private.\n-        (and and zero_extract cc0 set): Wrap RHS in a COMPARE.\n-        (compare with zero peepholes): Likewise.\n-        (bCC): Remove.\n-        (cbranchsi4, cbranchsf4): New.\n-        (casesi): Use cbranchsi4.\n-\n-        * config/pa/pa.c (hppa_compare_op0, hppa_compare_op1,\n-        hppa_branch_type): Delete.\n-        (return_addr_rtx): Use cbranchsi4.\n-        (emit_bcond_fp): Accept all operands.  Replace CODE with NE.\n-        Emit CCFPmode comparison here.\n-        (gen_cmp_fp): Delete, now part of emit_bcond_fp.\n-        * config/pa/pa.h (enum cmp_type, hppa_compare_op0, hppa_compare_op1,\n-        hppa_branch_type): Delete.\n-        * config/pa/pa.md (cmpdi, cmpsi, cmpsf, cmpdf, sCC, bCC): Delete.\n-        (movsicc, movdicc): Remove references to hppa_compare_op0,\n-        hppa_compare_op1 and compare_from_rtx.\n-        (cbranchdi4, cbranchsi4, cbranchsf4, cbranchdf4, cstoresi4): New.\n-        (casesi): Use cbranchsi4.\n-\n-        * config/pdp11/pdp11-protos.h (output_jump): Change prototype.\n-        * config/pdp11/pdp11.c (output_jump): Embed opcodes here.\n-        * config/pdp11/pdp11.md (register_or_const0_operand): New.\n-        (cmpdf, cmphi, cmpqi): Make private.  Add tst alternatives.\n-        (cmpsi, tstsi, tstdf, tsthi, tstqi): Delete.\n-        (bCC): Delete.\n-        (cbranchdf4, cbranchhi4, cbranchqi4): New.\n-        (*branch, *branch_inverted): New.\n-\n-        * config/picochip/picochip.md (cbranchhi4): Use\n-        ordered_comparison_operator.\n-        (cmphi, bCC): Remove.\n-\n-        * config/rs6000/predicates.md (rs6000_cbranch_operator): New.\n-        (trap_comparison_operator): Delete.\n-        * config/rs6000/rs6000-protos.h (rs6000_emit_sCOND,\n-        rs6000_emit_cbranch): Accept mode and operands.\n-        * config/rs6000/rs6000.c (rs6000_compare_op0, rs6000_compare_op1,\n-        rs6000_compare_fp_p): Delete.   \n-        (rs6000_generate_compare): Accept mode and comparison.  Extract code\n-        and op0/op1 from there.  Replace references to rs6000_compare_op0\n-        and rs6000_compare_op1.\n-        (rs6000_emit_sCOND): Adjust call to rs6000_generate_compare and\n-        extract result from passed operands.\n-        (rs6000_emit_cbranch): Adjust call to rs6000_generate_compare and\n-        extract loc from passed operands.\n-        (rs6000_emit_cmove): Likewise.\n-        * config/rs6000/rs6000.h (rs6000_compare_op0, rs6000_compare_op1,\n-        rs6000_compare_fp_p): Delete.\n-        * config/rs6000/rs6000.md (cmp<GPR>, cmp<FP>, bCC, sCC): Delete.\n-        (cbranch<GPR>4, cbranch<FP>4): New.\n-        (cstore<mode>4): New.  Consolidate here all choices about when to use\n-        portable or specialized sCC sequences.\n-        (stack_protect_test): Use cbranchsi4.\n-        (conditional_trap): Replace with ctrap<GPR>4.\n-        (conditional trap insn): Replace trap_comparison_operator with\n-        ordered_comparison_operator. \n-\n-        * config/s390/s390.c (s390_compare_op0, s390_compare_op1): Delete.\n-        (s390_emit_prologue): Use ctrap.\n-        * config/s390/s390.h (s390_compare_op0, s390_compare_op1): Delete.\n-        * config/s390/predicates.md (s390_eqne_operator, s390_scond_operator):\n-        New predicates replacing...\n-        * config/s390/s390.md (COMPARE, SCOND): ... these iterators.\n-        (cmp<GPR>, cmp<FP>, cmpcc): Delete.\n-        (trunc patterns): Use emit_cmp_and_jump_insns instead of cmp/branch.\n-        (add<mode>cc): Do not use s390_compare_op0/op1.\n-        (s<code>): Change to...\n-        (cstore<mode>4): ... this. Do not use s390_compare_op0/op1.\n-        (seq): Change to...\n-        (cstorecc4): ... this.  Handle EQ or NE equally.\n-        (*sne): Un-privatize for use in cstorecc4.\n-        (b<code>): Change to...\n-        (cbranch<GPR>4, cbranch<FP>4, cbranchcc4): ... these.\n-        (conditional_trap): Replace with...\n-        (ctrap<GPR>4, ctrap<FP>4): ... these.\n-        (stack_protect): Use cbranchcc4.\n-\n-        * config/score/score-conv.h (cmp_op0, cmp_op1): Delete.\n-        * config/score/score-protos.h (score_gen_cmp): Delete.\n-        * config/score/score.c (cmp_op0, cmp_op1, score_gen_cmp): Delete.\n-        (score_block_move-loop): Use cbranchsi4.\n-        * config/score/score.md (cbranchsi4): New.\n-        (cmpsi, bCC): Delete.\n-        * config/score/score3.c (cmp_op0, cmp_op1, score3_gen_cmp): Delete.\n-        (score3_movsicc): Use ops[1] operands instead of cmp_op0/cmp_op1.\n-        * config/score/score7.c (cmp_op0, cmp_op1, score7_gen_cmp): Delete.\n-        (score7_movsicc): Use ops[1] operands instead of cmp_op0/cmp_op1.\n-        * config/score/score3.h (score3_gen_cmp): Delete.\n-        * config/score/score7.h (score7_gen_cmp): Delete.\n-\n-        * config/sh/sh-protos.h (prepare_scc_operands): Rename to...\n-        (sh_emit_scc_to_t): ... this.  Return void.\n-        (from_compare): Rename to...\n-        (sh_emit_compare_and_branch): ... this.\n-        (sh_emit_compare_and_set): New.\n-        (sh_expand_t_scc): Accept operands.\n-        * config/sh/predicates.md (sh_float_comparison_operator): New.\n-        * config/sh/sh.c (sh_compare_op0, sh_compare_op1): Delete.\n-        (prepare_scc_operands): Rename to...\n-        (sh_emit_scc_to_t): ... this.  Return void.  Get op0/op1 from arguments.\n-        (sh_emit_cheap_store_flag): New.\n+\t* config/m68hc11/m68hc11.h (m68hc11_compare_op0, m68hc11_compare_op1):\n+\tDelete.\n+\t* config/m68hc11/m68hc11.md (tstsi, tsthi, tstqi, cmpsi,\n+\tcmphi, cmpqi, bCC): Delete.\n+\t(cbranchsi4, cbranchhi4, cbranchqi4): New.\n+\t(tstqi_1, tstqi_z_used, tstqi_1, bitcmpqi, bitcmpqi_z_used,\n+\tbitcmpqi_12, bitcmphi, various splits and peephole2s): Wrap cc0<-reg\n+\tsets with COMPARE.\n+\n+\t* config/m68k/predicates.md (m68k_cstore_comparison_operator,\n+\tconst0_operand, const1_operand, m68k_subword_comparison_operand): New.\n+\t* config/m68k/constraints.md (H): New.\n+\t* config/m68k/m68k.md (tstdi): Remove define_expand, use name for\n+\tthe define_insn below.\n+\t(tstsi, tsthi, tst<FP:mode>, cmphi, cmpqi, cmp<FP:mode>): Delete.\n+\t(*tstsi_internal_68020_cf, *tstsi_internal, *tsthi_internal,\n+\t*tstqi_internal, tst<mode>_6881, tst<mode>_cf, many unnamed\n+\tpatterns): Wrap RHS with COMPARE.\n+\t(tst<FP>_68881, tst<FP>_cf): Use const0_operand.\n+\t(*cmpdi_internal): Name this pattern.\n+\t(cmpdi): Change to define_insn.\n+\t(cbranchdi4, cstoredi4, cbranchsi4, cstoresi4, cbranchhi4, cstorehi4,\n+\tcbranchqi4, cstoreqi4, cbranch<FP:mode>4, cstore<FP:mode>4): New.\n+\t(scc0_di, scc0_di_5200, scc_di): Use the ordered_comparison_operator\n+\tpredicate.\n+\t(seq, sne, sgt, sgtu, slt, sltu, sge, sgeu, sle, sleu, sordered,\n+\tsunordered, suneq, sunge, sungt, sunle, sunlt, sltgt): Delete\n+\t(conditional_trap): Change to...\n+\t(ctrapdi4, ctrapsi4, ctraphi4, ctrapqi4): ... these.\n+\t(*conditional_trap): Use the ordered_comparison_operator and\n+\tconst1_operand predicates.\n+\t* config/m68k/m68k.c (m68k_last_compare_had_fp_operands): Delete.\n+\t(m68k_expand_prologue): Use ctrapsi4 instead of cmpsi+conditional_trap.\n+\t(m68k_rtx_costs): Look for ZERO_EXTRACT in a COMPARE.\n+\t* config/m68k/m68k.h (m68k_last_compare_had_fp_operands): Delete.\n+\n+\t* config/mcore/mcore-protos.h (arch_compare_op0, arch_compare_op1,\n+\tmcore_modify_comparison, mcore_gen_compare_reg): Remove.\n+\t(mcore_gen_compare): New. \n+\t* config/mcore/mcore.c (arch_compare_op0, arch_compare_op1): Delete.\n+\t(mcore_modify_comparison, mcore_gen_compare_reg): Fold into...\n+\t(mcore_gen_compare): ... this.\n+\t* config/mcore/mcore.md (cmpsi, bCC, sCC): Remove.\n+\t(cbranchsi4, cstoresi4): New, using mcore_gen_compare.\n+\t(stack probe pattern): Use cbranchsi4.\n+\n+\t* config/mips/predicates.md (mips_cstore_operator): New.\n+\t* config/mips/mips-ps-3d.md (movv2sfcc): Do not use cmp_operands.\n+\t* config/mips/mips.md (any_cond): Delete.\n+\t(conditional_trap): Rename to ctrap<GPR:mode>4.  Adjust predicates,\n+\talways succeed.\n+\t(fixuns_truncdfsi2, fixuns_truncdfdi2, fixuns_truncsfsi2,\n+\tfixuns_truncsfdi2): Use cbranch patterns.\n+\t(cmp<GPR:mode>, cmp<SCALARF:mode>): Delete. \n+\t(b<code>): Change to cbranch<GPR:mode>4 and cbranch<SCALARF:mode>4.\n+\tAdjust call to mips_expand_conditional_branch.\n+\t(seq, sne, slt<u>, sle<u>, sgt<u>, sge<u>): Change to\n+\tcstore<GPR:mode>4.\n+\t* config/mips/mips-protos.h (mips_expand_conditional_branch,\n+\tmips_expand_scc, mips_expand_conditional_trap): Adjust prototypes.\n+\t* config/mips/mips.c (cmp_operands): Delete.\n+\t(mips_emit_compare): Get comparison operands from *op0/*op1.\n+\t(mips_expand_scc): Get code/op0/op1/target from operands.  Assert\n+\tthat it succeeds.  Use op0/op1 instead of cmp_operands.\n+\t(mips_expand_conditional_branch, mips_expand_conditional_move,\n+\tmips_expand_conditional_trap): Likewise.\n+\t(mips_block_move_loop): Use cbranch patterns. \n+\t* config/mips/mips.h (cmp_operands): Delete.\n+\n+\t* config/mmix/mmix.c (mmix_valid_comparison): Delete.\n+\t(mmix_gen_compare_reg): Just return a register in the right CC mode.\n+\t* config/mmix/mmix.h (mmix_compare_op0, mmix_compare_op1): New.\n+\t* config/mmix/mmix.md (cmpdi, cmpdf): Remove.\n+\t(*cmpcc_folded): Rename to...\n+\t(*cmpdi_folded): this.\n+\t(*cmpcc): Rename to...\n+\t(*cmps): ... this.\n+\t(movdfcc, movdicc): Adjust for new semantics of mmix_gen_compare_reg.\n+\t(bCC): Remove.\n+\t(cbranchdi4): New.\n+\t(cbranchdf4): New.  Handle invalid comparisons here.\n+\t* config/mmix/predicates.md (float_comparison_operator): New.\n+\n+\t* config/mn10300/mn10300.c (mn10300_rtx_costs): Consider 0 and\n+\tzero_extract to be cheap in (compare (zero_extract) (const_int 0).\n+\t* config/mn10300/mn10300.md (tst): Delete.\n+\t(*tst_extqisi_am33, *tst_extqisi, *tst_exthisi_am33, *tst_exthisi):\n+\tName these patterns and wrap RHS in a compare.\n+\t(*cmpsi): Make this pattern private.  Include tst.\n+\t(*cmpsf): Make this pattern private.\n+\t(and and zero_extract cc0 set): Wrap RHS in a COMPARE.\n+\t(compare with zero peepholes): Likewise.\n+\t(bCC): Remove.\n+\t(cbranchsi4, cbranchsf4): New.\n+\t(casesi): Use cbranchsi4.\n+\n+\t* config/pa/pa.c (hppa_compare_op0, hppa_compare_op1,\n+\thppa_branch_type): Delete.\n+\t(return_addr_rtx): Use cbranchsi4.\n+\t(emit_bcond_fp): Accept all operands.  Replace CODE with NE.\n+\tEmit CCFPmode comparison here.\n+\t(gen_cmp_fp): Delete, now part of emit_bcond_fp.\n+\t* config/pa/pa.h (enum cmp_type, hppa_compare_op0, hppa_compare_op1,\n+\thppa_branch_type): Delete.\n+\t* config/pa/pa.md (cmpdi, cmpsi, cmpsf, cmpdf, sCC, bCC): Delete.\n+\t(movsicc, movdicc): Remove references to hppa_compare_op0,\n+\thppa_compare_op1 and compare_from_rtx.\n+\t(cbranchdi4, cbranchsi4, cbranchsf4, cbranchdf4, cstoresi4): New.\n+\t(casesi): Use cbranchsi4.\n+\n+\t* config/pdp11/pdp11-protos.h (output_jump): Change prototype.\n+\t* config/pdp11/pdp11.c (output_jump): Embed opcodes here.\n+\t* config/pdp11/pdp11.md (register_or_const0_operand): New.\n+\t(cmpdf, cmphi, cmpqi): Make private.  Add tst alternatives.\n+\t(cmpsi, tstsi, tstdf, tsthi, tstqi): Delete.\n+\t(bCC): Delete.\n+\t(cbranchdf4, cbranchhi4, cbranchqi4): New.\n+\t(*branch, *branch_inverted): New.\n+\n+\t* config/picochip/picochip.md (cbranchhi4): Use\n+\tordered_comparison_operator.\n+\t(cmphi, bCC): Remove.\n+\n+\t* config/rs6000/predicates.md (rs6000_cbranch_operator): New.\n+\t(trap_comparison_operator): Delete.\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_sCOND,\n+\trs6000_emit_cbranch): Accept mode and operands.\n+\t* config/rs6000/rs6000.c (rs6000_compare_op0, rs6000_compare_op1,\n+\trs6000_compare_fp_p): Delete.   \n+\t(rs6000_generate_compare): Accept mode and comparison.  Extract code\n+\tand op0/op1 from there.  Replace references to rs6000_compare_op0\n+\tand rs6000_compare_op1.\n+\t(rs6000_emit_sCOND): Adjust call to rs6000_generate_compare and\n+\textract result from passed operands.\n+\t(rs6000_emit_cbranch): Adjust call to rs6000_generate_compare and\n+\textract loc from passed operands.\n+\t(rs6000_emit_cmove): Likewise.\n+\t* config/rs6000/rs6000.h (rs6000_compare_op0, rs6000_compare_op1,\n+\trs6000_compare_fp_p): Delete.\n+\t* config/rs6000/rs6000.md (cmp<GPR>, cmp<FP>, bCC, sCC): Delete.\n+\t(cbranch<GPR>4, cbranch<FP>4): New.\n+\t(cstore<mode>4): New.  Consolidate here all choices about when to use\n+\tportable or specialized sCC sequences.\n+\t(stack_protect_test): Use cbranchsi4.\n+\t(conditional_trap): Replace with ctrap<GPR>4.\n+\t(conditional trap insn): Replace trap_comparison_operator with\n+\tordered_comparison_operator. \n+\n+\t* config/s390/s390.c (s390_compare_op0, s390_compare_op1): Delete.\n+\t(s390_emit_prologue): Use ctrap.\n+\t* config/s390/s390.h (s390_compare_op0, s390_compare_op1): Delete.\n+\t* config/s390/predicates.md (s390_eqne_operator, s390_scond_operator):\n+\tNew predicates replacing...\n+\t* config/s390/s390.md (COMPARE, SCOND): ... these iterators.\n+\t(cmp<GPR>, cmp<FP>, cmpcc): Delete.\n+\t(trunc patterns): Use emit_cmp_and_jump_insns instead of cmp/branch.\n+\t(add<mode>cc): Do not use s390_compare_op0/op1.\n+\t(s<code>): Change to...\n+\t(cstore<mode>4): ... this. Do not use s390_compare_op0/op1.\n+\t(seq): Change to...\n+\t(cstorecc4): ... this.  Handle EQ or NE equally.\n+\t(*sne): Un-privatize for use in cstorecc4.\n+\t(b<code>): Change to...\n+\t(cbranch<GPR>4, cbranch<FP>4, cbranchcc4): ... these.\n+\t(conditional_trap): Replace with...\n+\t(ctrap<GPR>4, ctrap<FP>4): ... these.\n+\t(stack_protect): Use cbranchcc4.\n+\n+\t* config/score/score-conv.h (cmp_op0, cmp_op1): Delete.\n+\t* config/score/score-protos.h (score_gen_cmp): Delete.\n+\t* config/score/score.c (cmp_op0, cmp_op1, score_gen_cmp): Delete.\n+\t(score_block_move-loop): Use cbranchsi4.\n+\t* config/score/score.md (cbranchsi4): New.\n+\t(cmpsi, bCC): Delete.\n+\t* config/score/score3.c (cmp_op0, cmp_op1, score3_gen_cmp): Delete.\n+\t(score3_movsicc): Use ops[1] operands instead of cmp_op0/cmp_op1.\n+\t* config/score/score7.c (cmp_op0, cmp_op1, score7_gen_cmp): Delete.\n+\t(score7_movsicc): Use ops[1] operands instead of cmp_op0/cmp_op1.\n+\t* config/score/score3.h (score3_gen_cmp): Delete.\n+\t* config/score/score7.h (score7_gen_cmp): Delete.\n+\n+\t* config/sh/sh-protos.h (prepare_scc_operands): Rename to...\n+\t(sh_emit_scc_to_t): ... this.  Return void.\n+\t(from_compare): Rename to...\n+\t(sh_emit_compare_and_branch): ... this.\n+\t(sh_emit_compare_and_set): New.\n+\t(sh_expand_t_scc): Accept operands.\n+\t* config/sh/predicates.md (sh_float_comparison_operator): New.\n+\t* config/sh/sh.c (sh_compare_op0, sh_compare_op1): Delete.\n+\t(prepare_scc_operands): Rename to...\n+\t(sh_emit_scc_to_t): ... this.  Return void.  Get op0/op1 from\n+\targuments.\n+\t(sh_emit_cheap_store_flag): New.\n \t(sh_emit_set_t_insn): New.\n-        (from_compare): Rename to...\n-        (sh_emit_compare_and_branch): ... this.  Accept mode.  Rewrite\n-        handling of TARGET_SH2E floating point to avoid recursive call.\n-        Generate branch here.\n-        (sh_emit_compare_and_set): New.\n-        (sh_expand_t_scc): Get op0/op1 from arguments.\n-        (sh_emit_cheap_store_flag): New.\n-        * config/sh/sh.md (cbranchdi4, cbranchsi4): Include -mno-cbranchdi\n-        cases.\n+\t(from_compare): Rename to...\n+\t(sh_emit_compare_and_branch): ... this.  Accept mode.  Rewrite\n+\thandling of TARGET_SH2E floating point to avoid recursive call.\n+\tGenerate branch here.\n+\t(sh_emit_compare_and_set): New.\n+\t(sh_expand_t_scc): Get op0/op1 from arguments.\n+\t(sh_emit_cheap_store_flag): New.\n+\t* config/sh/sh.md (cbranchdi4, cbranchsi4): Include -mno-cbranchdi\n+\tcases.\n \t(cbranchdi4_i): Use an \"I08\" constraint instead of an \"i\" constraint.\n-        (cmpsi, cmpdi, cmpsf, cmpdf): Delete.\n-        (movsicc, movdicc): Do nothing when it recreated operands from\n-        sh_compare_*. Use sh_emit_cheap_store_flag.  Adjust call to\n-        prepare_scc_operands (now sh_emit_scc_to_t).\n-        (udivdi3): Use cstoresi4.\n-        (beq_media, bne_media, bge_media, bgtu_media, bgeu_media, beq,\n-        bne, bgt, blt, ble, bge, bgtu, bltu, bgeu, bleu, bunordered):\n-        Delete.\n-        (cbranchint4_media, cbranchfp4_media): New.\n-        (casesi): Use cbranchdi4.\n-        (seq, slt, sle, sgt, sge, sgtu, sltu, sgeu, sne, sleu, sunordered):\n-        Delete.\n-        (cstore4_media, cstoresi4, cstoredi4, cstoresf4, cstoredf4): New.\n-        (movnegt): Remove second operand.\n-        (cbranchsf4, cbranchdf4): New.\n-        (stack_protect): Use cbranchdi4/cbranchsi4.\n-\n-        * config/sparc/sparc.c (sparc_compare_op0, sparc_compare_op1): Delete.\n-        (gen_compare_reg): Accept comparison, extract part of it to...\n-        (gen_compare_reg_1): ... this. \n-        (gen_compare_operator): Delete.\n-        (gen_v9_scc): Accept separate destination, comparison code and arms.\n-        Do not use sparc_compare_op0/sparc_compare_op1.\n-        (emit_scc_insn, emit_conditional_branch_insn): New.\n-        (emit_v9_brxx): Make static.  Remove useless assertion.\n-        (sparc_emit_float_lib_cmp): Return RTL instead of calling emit_cmp_insn.\n-        (sparc_expand_compare_and_swap_12): Use gen_compare_reg_1+cbranchcc4.\n-        * config/sparc/sparc-protos.h (gen_compare_reg,\n+\t(cmpsi, cmpdi, cmpsf, cmpdf): Delete.\n+\t(movsicc, movdicc): Do nothing when it recreated operands from\n+\tsh_compare_*. Use sh_emit_cheap_store_flag.  Adjust call to\n+\tprepare_scc_operands (now sh_emit_scc_to_t).\n+\t(udivdi3): Use cstoresi4.\n+\t(beq_media, bne_media, bge_media, bgtu_media, bgeu_media, beq,\n+\tbne, bgt, blt, ble, bge, bgtu, bltu, bgeu, bleu, bunordered): Delete.\n+\t(cbranchint4_media, cbranchfp4_media): New.\n+\t(casesi): Use cbranchdi4.\n+\t(seq, slt, sle, sgt, sge, sgtu, sltu, sgeu, sne, sleu, sunordered):\n+\tDelete.\n+\t(cstore4_media, cstoresi4, cstoredi4, cstoresf4, cstoredf4): New.\n+\t(movnegt): Remove second operand.\n+\t(cbranchsf4, cbranchdf4): New.\n+\t(stack_protect): Use cbranchdi4/cbranchsi4.\n+\n+\t* config/sparc/sparc.c (sparc_compare_op0, sparc_compare_op1): Delete.\n+\t(gen_compare_reg): Accept comparison, extract part of it to...\n+\t(gen_compare_reg_1): ... this. \n+\t(gen_compare_operator): Delete.\n+\t(gen_v9_scc): Accept separate destination, comparison code and arms.\n+\tDo not use sparc_compare_op0/sparc_compare_op1.\n+\t(emit_scc_insn, emit_conditional_branch_insn): New.\n+\t(emit_v9_brxx): Make static.  Remove useless assertion.\n+\t(sparc_emit_float_lib_cmp): Return RTL instead of calling\n+\temit_cmp_insn.\n+\t(sparc_expand_compare_and_swap_12): Use gen_compare_reg_1+cbranchcc4.\n+\t* config/sparc/sparc-protos.h (gen_compare_reg,\n \tsparc_emit_float_lib_cmp): Adjust prototype.\n \t(emit_scc_insn, emit_conditional_branch_insn): New.\n \t(gen_v9_scc, emit_v9_brxx_insn, gen_compare_operator): Delete.\n-        * config/sparc/sparc.h (sparc_compare_op0, sparc_compare_op1): Delete.\n-        * config/sparc/sparc.md (P, I, F, V32, V32I, V64, V64I): Move all\n-        iterators to the top.\n-        (cmpsi, cmpdi, cmpsf, cmpdf, cmptf, seqsi_special_extend,\n-        snesi_special_extend, sCC, bCC, seqdi_special_trunc,\n+\t* config/sparc/sparc.h (sparc_compare_op0, sparc_compare_op1): Delete.\n+\t* config/sparc/sparc.md (P, I, F, V32, V32I, V64, V64I): Move all\n+\titerators to the top.\n+\t(cmpsi, cmpdi, cmpsf, cmpdf, cmptf, seqsi_special_extend,\n+\tsnesi_special_extend, sCC, bCC, seqdi_special_trunc,\n \tsnedi_special_trunc): Delete.\n- \t(seqdi_special, snedi_special): Use expansion of seqdi_special_trunc\n+\t(seqdi_special, snedi_special): Use expansion of seqdi_special_trunc\n \tand snedi_special_trunc.\n-        (cstoresi4, cstoredi4, cstore<F:mode>4, cbranchcc4, cbranchsi4,\n-        cbranchdi4, cbranch<F:mode>4): New.\n-        (mov<I:mode>cc, mov<F:mode>cc): Handle sparc_emit_float_lib_cmp\n-        here.  Use gen_compare_reg instead of gen_compare_operator.\n-        (conditional_trap): Replace with...\n-        (ctrapsi4, ctrapdi4): ... this.\n-        (stack_protect_test): Use cbranchcc4.\n-\n-        * config/spu/spu-protos.h (spu_emit_branch_or_set): Change second\n-        argument to rtx.\n-        * config/spu/spu.c (spu_compare_op0, spu_compare_op1): Remove. \n-        (spu_emit_branch_or_set): Get code/op0/op1 from second argument.\n-        Change spu_compare_op0/op1 to op0/op1 throughout.  Get target\n-        from operands[0] or operands[3] depending on is_set.\n-        * config/spu/spu.h (spu_compare_op0, spu_compare_op1): Remove.\n-        * config/spu/spu.md (cmp<mode:VQHSI>, cmp<mode:DTI>, cmp<mode:VSF>,\n-        cmpdf, bCC), sCC: Remove.\n-        (cbranch<mode:VQHSI>4, cbranch<mode:DTI>, cbranch<mode:VSF>4, \n-        cbranchdf4, cstore<mode:VQHSI>4, cstore<mode:DTI>, cstore<mode:VSF>4,\n-        cstoredf4): New.\n-        (mov<mode>cc): Accept ordered_comparison_operator, adjust call to\n-        spu_emit_branch_or_set.\n-\n-        * config/stormy16/stormy16-protos.h (xstormy16_emit_cbranch):\n-        Add two arguments.\n-        * config/stormy16/stormy16.h (xstormy16_compare_op0,\n-        xstormy16_compare_op1): Delete.\n-        * config/stormy16/stormy16.c (xstormy16_compare_op0,\n-        xstormy16_compare_op1): Delete. \n-        (xstormy16_emit_cbranch): Get op0/op1 from the new arguments.\n-        Adjust calls.\n-        * config/stormy16/stormy16.md (cbranchsi4, cbranchhi4): New.\n-        (cmphi, cmpsi, bCC): Remove.\n-\n-        * config/v850/v850.md (tstsi, cmpsi): Fold into...\n-        (*cmpsi): ... this one.\n-        (cbranchsi4, cstoresi4): New.\n-        (bCC expanders): Delete.\n-        (sCC insns): Fold into...\n-        (*setcc): ... this one.\n-        (casesi): Do not use gen_cmpsi and gen_bgtu. \n+\t(cstoresi4, cstoredi4, cstore<F:mode>4, cbranchcc4, cbranchsi4,\n+\tcbranchdi4, cbranch<F:mode>4): New.\n+\t(mov<I:mode>cc, mov<F:mode>cc): Handle sparc_emit_float_lib_cmp\n+\there.  Use gen_compare_reg instead of gen_compare_operator.\n+\t(conditional_trap): Replace with...\n+\t(ctrapsi4, ctrapdi4): ... this.\n+\t(stack_protect_test): Use cbranchcc4.\n+\n+\t* config/spu/spu-protos.h (spu_emit_branch_or_set): Change second\n+\targument to rtx.\n+\t* config/spu/spu.c (spu_compare_op0, spu_compare_op1): Remove. \n+\t(spu_emit_branch_or_set): Get code/op0/op1 from second argument.\n+\tChange spu_compare_op0/op1 to op0/op1 throughout.  Get target\n+\tfrom operands[0] or operands[3] depending on is_set.\n+\t* config/spu/spu.h (spu_compare_op0, spu_compare_op1): Remove.\n+\t* config/spu/spu.md (cmp<mode:VQHSI>, cmp<mode:DTI>, cmp<mode:VSF>,\n+\tcmpdf, bCC), sCC: Remove.\n+\t(cbranch<mode:VQHSI>4, cbranch<mode:DTI>, cbranch<mode:VSF>4, \n+\tcbranchdf4, cstore<mode:VQHSI>4, cstore<mode:DTI>, cstore<mode:VSF>4,\n+\tcstoredf4): New.\n+\t(mov<mode>cc): Accept ordered_comparison_operator, adjust call to\n+\tspu_emit_branch_or_set.\n+\n+\t* config/stormy16/stormy16-protos.h (xstormy16_emit_cbranch):\n+\tAdd two arguments.\n+\t* config/stormy16/stormy16.h (xstormy16_compare_op0,\n+\txstormy16_compare_op1): Delete.\n+\t* config/stormy16/stormy16.c (xstormy16_compare_op0,\n+\txstormy16_compare_op1): Delete. \n+\t(xstormy16_emit_cbranch): Get op0/op1 from the new arguments.\n+\tAdjust calls.\n+\t* config/stormy16/stormy16.md (cbranchsi4, cbranchhi4): New.\n+\t(cmphi, cmpsi, bCC): Remove.\n+\n+\t* config/v850/v850.md (tstsi, cmpsi): Fold into...\n+\t(*cmpsi): ... this one.\n+\t(cbranchsi4, cstoresi4): New.\n+\t(bCC expanders): Delete.\n+\t(sCC insns): Fold into...\n+\t(*setcc): ... this one.\n+\t(casesi): Do not use gen_cmpsi and gen_bgtu. \n \t(various splits): Wrap \"naked\" RHS of a cc0 set with COMPARE.\n \t(movsicc): Simplify.\n \t* config/v850/v850.c (v850_rtx_costs): Handle ZERO_EXTRACT in COMPARE.\n \n-        * config/vax/vax-protos.h (cond_name): New.\n-        (vax_output_conditional_branch): Remove.\n-        * config/vax/vax.c (cond_name): New.\n-        (vax_output_conditional_branch): Remove.\n-        * config/vax/vax.h (PRINT_OPERAND): Dispatch %c to cond_name.\n-        * config/vax/vax.md (tst<VAXint>, tst<VAXfp>): Remove.\n-        (cmp<VAXint>, cmp<VAXfp>): Privatize.  Add constraints for tst.\n-        (bit<VAXint>): Wrap source with (compare).\n-        (b<code> and following unnamed pattern): Rename to *branch and\n-        *branch_reversed.  Change macroization to match_operator.\n-        (cbranch<VAXint>4, cbranch<VAXfp>4): New.\n-\n-        * config/xtensa/predicates.md (xtensa_cstoresi_operator): New.\n-        * config/xtensa/xtensa-protos.h (xtensa_expand_conditional_branch):\n-        Change last argument to machine_mode.\n-        (xtensa_expand_scc): Add machine_mode argument.\n-        * config/xtensa/xtensa.c (branch_cmp, branch_type): Remove.\n-        (gen_conditional_move, xtensa_expand_conditional_branch,\n-        xtensa_expand_scc, xtensa_expand_conditional_move): Use mode\n-        instead of branch_type, fetch cmp0/cmp1/test_code from operands[].\n-        Adjust operand numbers.\n-        * config/xtensa/xtensa.h (enum cmp_type, branch_cmp, branch_type):\n-        Delete.\n-        * config/xtensa/xtensa.md (any_cond, any_scc): Delete.\n-        (cmpsi, cmpsf, b<code>, s<code>): Delete.\n-        (cbranchsi4, cbranchsf4, cstoresi4, cstoresf4): New.\n+\t* config/vax/vax-protos.h (cond_name): New.\n+\t(vax_output_conditional_branch): Remove.\n+\t* config/vax/vax.c (cond_name): New.\n+\t(vax_output_conditional_branch): Remove.\n+\t* config/vax/vax.h (PRINT_OPERAND): Dispatch %c to cond_name.\n+\t* config/vax/vax.md (tst<VAXint>, tst<VAXfp>): Remove.\n+\t(cmp<VAXint>, cmp<VAXfp>): Privatize.  Add constraints for tst.\n+\t(bit<VAXint>): Wrap source with (compare).\n+\t(b<code> and following unnamed pattern): Rename to *branch and\n+\t*branch_reversed.  Change macroization to match_operator.\n+\t(cbranch<VAXint>4, cbranch<VAXfp>4): New.\n+\n+\t* config/xtensa/predicates.md (xtensa_cstoresi_operator): New.\n+\t* config/xtensa/xtensa-protos.h (xtensa_expand_conditional_branch):\n+\tChange last argument to machine_mode.\n+\t(xtensa_expand_scc): Add machine_mode argument.\n+\t* config/xtensa/xtensa.c (branch_cmp, branch_type): Remove.\n+\t(gen_conditional_move, xtensa_expand_conditional_branch,\n+\txtensa_expand_scc, xtensa_expand_conditional_move): Use mode\n+\tinstead of branch_type, fetch cmp0/cmp1/test_code from operands[].\n+\tAdjust operand numbers.\n+\t* config/xtensa/xtensa.h (enum cmp_type, branch_cmp, branch_type):\n+\tDelete.\n+\t* config/xtensa/xtensa.md (any_cond, any_scc): Delete.\n+\t(cmpsi, cmpsf, b<code>, s<code>): Delete.\n+\t(cbranchsi4, cbranchsf4, cstoresi4, cstoresf4): New.\n \n 2009-05-12  Paolo Bonzini  <bonzini@gnu.org>\n \n@@ -671,20 +680,16 @@\n \tcgraph_local_info.\n \t* cgraphunit.c (enum cgraph_order_sort_kind): New enum, broken out\n \tof struct cgraph_order_sort.\n-\t* combine.c (enum undo_kind): New enum, broken out of struct\n-\tundo.\n+\t* combine.c (enum undo_kind): New enum, broken out of struct undo.\n \t* cse.c (struct branch_path): Break out of struct\n \tcse_basic_block_data.\n \t* except.h (enum eh_region_type): Break out of struct eh_region.\n \t* gcc.c (enum add_del): Break out of struct modify_target.\n-\t* genrecog.c (enum decision_type): Break out of struct\n-\tdecision_test.\n+\t* genrecog.c (enum decision_type): Break out of struct decision_test.\n \t* ggc-page.c (struct ggc_pch_ondisk): Break out of struct\n \tggc_pch_data.\n-\t* matrix-reorg.c (struct free_info): Break out of struct\n-\tmatrix_info.\n-\t* regmove.c (enum match_use): New enum, broken out of struct\n-\tmatch.\n+\t* matrix-reorg.c (struct free_info): Break out of struct matrix_info.\n+\t* regmove.c (enum match_use): New enum, broken out of struct match.\n \t* sched-int.h (enum post_call_group): New enum, broken out of\n \tstruct deps.\n \t(struct deps_reg): Break out of struct deps.\n@@ -706,8 +711,7 @@\n \tand loc parameters.  Change all callers.  Change error calls to\n \terror_at, using loc.  For a redefinition, if the location of the\n \toriginal definition is known, report it.  Set in_struct and\n-\tstruct_types.  If -Wc++-compat warn if in sizeof, typeof, or\n-\talignof.\n+\tstruct_types.  If -Wc++-compat warn if in sizeof, typeof, or alignof.\n \t(finish_struct): Add new parameters enclosing_in_struct and\n \tenclosing_struct_types.  Change all callers.  Set\n \tC_TYPE_DEFINED_IN_STRUCT for all struct/union/enum types defined\n@@ -717,10 +721,8 @@\n \tlocation of the original definition is known, report it.  If in a\n \tstruct, add this enum type to struct_types.  If -Wc++-compat warn\n \tif in sizeof, typeof, or alignof.\n-\t* c-parser.c (disable_extension_diagnostics): Disable\n-\t-Wc++-compat.\n-\t(enable_extension_diagnostics): Reenable -Wc++-compat if\n-\tappropriate.\n+\t* c-parser.c (disable_extension_diagnostics): Disable -Wc++-compat.\n+\t(enable_extension_diagnostics): Reenable -Wc++-compat if appropriate.\n \t(c_parser_enum_specifier): Get enum location for start_enum.\n \t(c_parser_struct_or_union_specifier): Get struct location for\n \tstart_struct.  Save in_struct and struct_types status between\n@@ -729,12 +731,10 @@\n \t(c_parser_alignof_expression): Get location of type.\n \t(c_parser_postfix_expression): Likewise.\n \t(c_parser_postfix_expression_after_paren_type): Add type_loc\n-\tparameter.  Change all callers.  Call\n-\tcheck_compound_literal_type.  Use type_loc for error about\n-\tvariable size type.\n-\t* c-typeck.c (build_external_ref): If -Wc++-compat, warn about a\n-\tuse of an enum constant from an enum type defined in a struct or\n-\tunion.\n+\tparameter.  Change all callers.  Call check_compound_literal_type.\n+\tUse type_loc for error about variable size type.\n+\t* c-typeck.c (build_external_ref): If -Wc++-compat, warn about a use\n+\tof an enum constant from an enum type defined in a struct or union.\n \t(c_cast_expr): Add loc parameter.  Change all callers.  If\n \t-Wc++-compat, warn about defining a type in a cast.\n \t* c-tree.h (C_TYPE_DEFINED_IN_STRUCT): Define.\n@@ -768,7 +768,8 @@\n 2009-05-10  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-inline.c (delete_unreachable_blocks_update_callgraph): Declare.\n-\t(estimate_move_cost): Assert that it does not get called for VOID_TYPE_P.\n+\t(estimate_move_cost): Assert that it does not get called for\n+\tVOID_TYPE_P.\n \t(estimate_num_insns): Skip VOID types in argument handling.\n \t(optimize_inline_calls): Delete unreachable blocks and verify that\n \tcallgraph is valid.\n@@ -2080,8 +2081,8 @@\n \t(vectorize_loops): Fix comment. Use REPORT_VECTORIZED_LOCATIONS\n \tand vect_location. Use REPORT_UNVECTORIZED_LOCATIONS\n \tinstead REPORT_UNVECTORIZED_LOOPS.\n-\t* tree-vectorizer.h (enum vect_def_type): Rename vect_invariant_def and\n-\tvect_loop_def to vect_external_def and vect_internal_def.\n+\t* tree-vectorizer.h (enum vect_def_type): Rename vect_invariant_def\n+\tand vect_loop_def to vect_external_def and vect_internal_def.\n \t(enum verbosity_levels): Rename REPORT_VECTORIZED_LOOPS\n \tand REPORT_UNVECTORIZED_LOOPS to REPORT_VECTORIZED_LOCATIONS and \n \tREPORT_UNVECTORIZED_LOCATIONS.\n@@ -2101,8 +2102,9 @@\n \tvect_analyze_operations.\n \t(vect_is_simple_reduction): Use new names.\n \t(vectorizable_live_operation, vect_transform_loop): Likewise.\n-\t* tree-vect-data-refs.c (vect_check_interleaving): Add a return value to\n-\tspecify whether the data references can be a part of interleaving chain.\n+\t* tree-vect-data-refs.c (vect_check_interleaving): Add a return value\n+\tto specify whether the data references can be a part of interleaving\n+\tchain.\n \t(vect_analyze_data_ref_dependence): Use new names.\n \t(vect_analyze_data_refs_alignment, vect_analyze_data_refs): Likewise.\n \t(vect_create_addr_base_for_vector_ref): Remove redundant code."}, {"sha": "cb669378a439b7d0fcbfc18c4e44c9c23c90bc5a", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbdf817d6bfa399f6e6c87b4e097f2081233121d/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbdf817d6bfa399f6e6c87b4e097f2081233121d/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=fbdf817d6bfa399f6e6c87b4e097f2081233121d", "patch": "@@ -336,7 +336,11 @@ detect_caches_intel (bool xeon_mp, unsigned max_level, unsigned max_ext_level)\n enum vendor_signatures\n {\n   SIG_INTEL =\t0x756e6547 /* Genu */,\n-  SIG_AMD =\t0x68747541 /* Auth */,\n+  SIG_AMD =\t0x68747541 /* Auth */\n+};\n+\n+enum processor_signatures\n+{\n   SIG_GEODE =\t0x646f6547 /* Geod */\n };\n \n@@ -433,19 +437,27 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \n   if (vendor == SIG_AMD)\n     {\n-      processor = PROCESSOR_PENTIUM;\n+      unsigned int name;\n \n-      if (has_mmx)\n-\tprocessor = PROCESSOR_K6;\n-      if (has_3dnowp)\n-\tprocessor = PROCESSOR_ATHLON;\n-      if (has_sse2 || has_longmode)\n-\tprocessor = PROCESSOR_K8;\n-      if (has_sse4a)\n+      /* Detect geode processor by its processor signature.  */\n+      if (ext_level > 0x80000001)\n+\t__cpuid (0x80000002, name, ebx, ecx, edx);\n+      else\n+\tname = 0;\n+\n+      if (name == SIG_GEODE)\n+\tprocessor = PROCESSOR_GEODE;\n+      else if (has_sse4a)\n \tprocessor = PROCESSOR_AMDFAM10;\n+      else if (has_sse2 || has_longmode)\n+\tprocessor = PROCESSOR_K8;\n+      else if (has_3dnowp)\n+\tprocessor = PROCESSOR_ATHLON;\n+      else if (has_mmx)\n+\tprocessor = PROCESSOR_K6;\n+      else\n+\tprocessor = PROCESSOR_PENTIUM;\n     }\n-  else if (vendor == SIG_GEODE)\n-    processor = PROCESSOR_GEODE;\n   else\n     {\n       switch (family)"}]}