{"sha": "9abaec9c1ce6de2035637ba50e57f64dcdf5f22f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFiYWVjOWMxY2U2ZGUyMDM1NjM3YmE1MGU1N2Y2NGRjZGY1ZjIyZg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2013-11-20T16:22:57Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2013-11-20T16:22:57Z"}, "message": "rs6000.c (rs6000_cannot_change_mode_class): Do not allow subregs of TDmode in FPRs of smaller size in little-endian.\n\n\t* config/rs6000/rs6000.c (rs6000_cannot_change_mode_class): Do not\n\tallow subregs of TDmode in FPRs of smaller size in little-endian.\n\t(rs6000_split_multireg_move): When splitting an access to TDmode\n\tin FPRs, do not use simplify_gen_subreg.\n\nFrom-SVN: r205123", "tree": {"sha": "e0e73a67068d231ddcf242ff608a6e33d9fb6bd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0e73a67068d231ddcf242ff608a6e33d9fb6bd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f/comments", "author": null, "committer": null, "parents": [{"sha": "547101fb67fb77fb069acd04669e18f6d4684c9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/547101fb67fb77fb069acd04669e18f6d4684c9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/547101fb67fb77fb069acd04669e18f6d4684c9f"}], "stats": {"total": 47, "additions": 47, "deletions": 0}, "files": [{"sha": "32a75226727542aa3bff5aaf780008e1fc81156b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9abaec9c1ce6de2035637ba50e57f64dcdf5f22f", "patch": "@@ -1,3 +1,10 @@\n+2013-11-20  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_cannot_change_mode_class): Do not\n+\tallow subregs of TDmode in FPRs of smaller size in little-endian.\n+\t(rs6000_split_multireg_move): When splitting an access to TDmode\n+\tin FPRs, do not use simplify_gen_subreg.\n+\n 2013-11-20  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR middle-end/21718"}, {"sha": "bd4e8943413dd95fdb5a29a1d64700550334d3e8", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abaec9c1ce6de2035637ba50e57f64dcdf5f22f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9abaec9c1ce6de2035637ba50e57f64dcdf5f22f", "patch": "@@ -16676,6 +16676,13 @@ rs6000_cannot_change_mode_class (enum machine_mode from,\n \t  if (TARGET_IEEEQUAD && (to == TFmode || from == TFmode))\n \t    return true;\n \n+\t  /* TDmode in floating-mode registers must always go into a register\n+\t     pair with the most significant word in the even-numbered register\n+\t     to match ISA requirements.  In little-endian mode, this does not\n+\t     match subreg numbering, so we cannot allow subregs.  */\n+\t  if (!BYTES_BIG_ENDIAN && (to == TDmode || from == TDmode))\n+\t    return true;\n+\n \t  if (from_size < 8 || to_size < 8)\n \t    return true;\n \n@@ -19618,6 +19625,39 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \n   gcc_assert (reg_mode_size * nregs == GET_MODE_SIZE (mode));\n \n+  /* TDmode residing in FP registers is special, since the ISA requires that\n+     the lower-numbered word of a register pair is always the most significant\n+     word, even in little-endian mode.  This does not match the usual subreg\n+     semantics, so we cannnot use simplify_gen_subreg in those cases.  Access\n+     the appropriate constituent registers \"by hand\" in little-endian mode.\n+\n+     Note we do not need to check for destructive overlap here since TDmode\n+     can only reside in even/odd register pairs.  */\n+  if (FP_REGNO_P (reg) && DECIMAL_FLOAT_MODE_P (mode) && !BYTES_BIG_ENDIAN)\n+    {\n+      rtx p_src, p_dst;\n+      int i;\n+\n+      for (i = 0; i < nregs; i++)\n+\t{\n+\t  if (REG_P (src) && FP_REGNO_P (REGNO (src)))\n+\t    p_src = gen_rtx_REG (reg_mode, REGNO (src) + nregs - 1 - i);\n+\t  else\n+\t    p_src = simplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t i * reg_mode_size);\n+\n+\t  if (REG_P (dst) && FP_REGNO_P (REGNO (dst)))\n+\t    p_dst = gen_rtx_REG (reg_mode, REGNO (dst) + nregs - 1 - i);\n+\t  else\n+\t    p_dst = simplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t i * reg_mode_size);\n+\n+\t  emit_insn (gen_rtx_SET (VOIDmode, p_dst, p_src));\n+\t}\n+\n+      return;\n+    }\n+\n   if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n     {\n       /* Move register range backwards, if we might have destructive"}]}