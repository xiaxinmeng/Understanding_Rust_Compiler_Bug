{"sha": "53b2323e9d8f59f02918edad69830000ed0886e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNiMjMyM2U5ZDhmNTlmMDI5MThlZGFkNjk4MzAwMDBlZDA4ODZlNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-06-12T03:08:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-06-12T03:08:11Z"}, "message": "common.opt (gdwarf-): Accept a version number.\n\n\t* common.opt (gdwarf-): Accept a version number.\n\t* doc/invoke.texi (gdwarf-): Update docs.\n\t* opth-gen.awk: Special case -gdwarf+ to OPT_gdwarfplus.\n\t* opts.c (common_handle_option) [OPT_gdwarf_]: Verify dwarf\n\tversion level, and record it.\n\n\t* dwarf2.h (DW_CIE_VERSION): Remove.\n\t* dwarf2out.c (DWARF_VERSION): Remove.\n\t(add_fde_cfi): Skip DW_CFA_set_loc addition for dwarf3.\n\t(output_call_frame_info): Use CIE version 3 for dwarf3,\n\tor if the return register column is out of range for version 1.\n\t(dwarf_stack_op_name): Add all dwarf3 values.\n\t(DEBUG_PUBTYPES_SECTION): New.\n\t(size_of_die) [dw_val_class_die_ref]: Handle DW_FORM_ref_addr\n\tencoding change for dwarf3.\n\t(output_die) [dw_val_class_die_ref]: Likewise.\n\t(output_compilation_unit_header): Emit correct version for dwarf3.\n\t(output_line_info): Likewise.\n\t(output_pubnames): Update for DWARF_VERSION removal.\n\t(output_aranges): Likewise.\n\t(gen_subprogram_die): Emit DW_OP_call_frame_cfa if emitting dwarf3.\n\t(dwarf2out_init): Don't ifdef DEBUG_PUBTYPES_SECTION.\n\t(dwarf2out_finish): Likewise.\n\nada/\n\t* gcc-interface/misc.c (gnat_handle_option): Rename\n\tOPT_gdwarf_ to OPT_gdwarfplus.\n\nFrom-SVN: r148408", "tree": {"sha": "fd7d91723687fd70cb56d41663782239fd5c88bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd7d91723687fd70cb56d41663782239fd5c88bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53b2323e9d8f59f02918edad69830000ed0886e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53b2323e9d8f59f02918edad69830000ed0886e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53b2323e9d8f59f02918edad69830000ed0886e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53b2323e9d8f59f02918edad69830000ed0886e4/comments", "author": null, "committer": null, "parents": [{"sha": "1c3bbaa728d1b29f12ea2eee28f16ca8995c1909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c3bbaa728d1b29f12ea2eee28f16ca8995c1909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c3bbaa728d1b29f12ea2eee28f16ca8995c1909"}], "stats": {"total": 251, "additions": 146, "deletions": 105}, "files": [{"sha": "b3a38faf220521160280bcfe5389f462b6639f1a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -1,3 +1,8 @@\n+2009-06-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc-interface/misc.c (gnat_handle_option): Rename\n+\tOPT_gdwarf_ to OPT_gdwarfplus.\n+\n 2009-06-11  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_attr.adb (Resolve_Attribute, case 'access): Add missing\n@@ -105,15 +110,15 @@\n \t* gcc-interface/Make-lang.in: Fix formatting.\n \n 2009-06-01  Olivier Hainque  <hainque@adacore.com>\n-            Eric Botcazou  <ebotcazou@adacore.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n \t\n \t* gcc-interface/utils.c (convert) <CONSTRUCTOR case>: When converting\n \tto the packable version of the type, clear TREE_STATIC/TREE_CONSTANT\n \ton the result if at least one of the input fields couldn't be output\n \tas a static constant any more.\n \n 2009-06-01  Olivier Hainque  <hainque@adacore.com>\n-            Eric Botcazou  <ebotcazou@adacore.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n \t\n \t* gcc-interface/utils2.c (gnat_build_constructor): Factor\n \tout code.  Use initializer_constant_valid_for_bitfield_p and\n@@ -293,7 +298,7 @@\n \tGPS.\n \n \t* sinput.ads, sinput.adb (Expr_First_Char): New function\n-        (Expr_Last_Char): New function\n+\t(Expr_Last_Char): New function\n \n 2009-05-06  Sergey Rybin  <rybin@adacore.com>\n \n@@ -1313,9 +1318,9 @@\n \n \t* prj-proc.adb, prj.adb, prj.ads, prj-nmsc.adb, prj-env.adb\n \t(Source_Iterator): new type.\n-        This removes the need for having the sources on three different\n-        lists at the project tree, project and language level. They are now\n-        on a single list.\n+\tThis removes the need for having the sources on three different\n+\tlists at the project tree, project and language level. They are now\n+\ton a single list.\n \n 2009-04-24  Emmanuel Briot  <briot@adacore.com>\n \n@@ -1344,7 +1349,7 @@\n \tefficient.\n \n 2009-04-24  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-            Thomas Quinot  <quinot@adacore.com>\n+\t    Thomas Quinot  <quinot@adacore.com>\n \n \t* fe.h (Set_Identifier_Casing): Add const to second parameter.\n \t* gcc-interface/misc.c (internal_error_function): Make copy of return\n@@ -5522,17 +5527,17 @@\n \n 2009-04-09  Robert Dewar  <dewar@adacore.com>\n \n-        * checks.adb:\n-        (Insert_Valid_Check): Avoid unnecessary generation of junk declaration\n-        when no invalid values exist, Avoid duplicate read of atomic variable.\n+\t* checks.adb:\n+\t(Insert_Valid_Check): Avoid unnecessary generation of junk declaration\n+\twhen no invalid values exist, Avoid duplicate read of atomic variable.\n \n-        * cstand.adb (Build_Signed_Integer_Type): Set Is_Known_Valid\n-        (Standard_Unsigned): Set Is_Known_Valid\n+\t* cstand.adb (Build_Signed_Integer_Type): Set Is_Known_Valid\n+\t(Standard_Unsigned): Set Is_Known_Valid\n \n-        * sem_ch3.adb (Analyze_Subtype_Declaration): Copy Is_Known_Valid on\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): Copy Is_Known_Valid on\n \tsubtype declaration if no constraint.\n-        (Set_Modular_Size): Set Is_Known_Valid if appropriate\n-        (Build_Derived_Numeric_Type): Copy Is_Known_Valid if no constraint\n+\t(Set_Modular_Size): Set Is_Known_Valid if appropriate\n+\t(Build_Derived_Numeric_Type): Copy Is_Known_Valid if no constraint\n \n 2009-04-09  Robert Dewar  <dewar@adacore.com>\n "}, {"sha": "63d7805796f061449412a4d3c203d8378bed1fe4", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -272,8 +272,8 @@ gnat_handle_option (size_t scode, const char *arg, int value)\n       gnat_argc++;\n       break;\n \n-    case OPT_gdwarf_:\n-      gnat_dwarf_extensions ++;\n+    case OPT_gdwarfplus:\n+      gnat_dwarf_extensions = 1;\n       break;\n \n     default:"}, {"sha": "2006a5b46fd394ac3689bac0d39c026e5ddce33a", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -1410,12 +1410,12 @@ Common JoinedOrMissing\n Generate debug information in default format\n \n gcoff\n-Common JoinedOrMissing Negative(gdwarf-2)\n+Common JoinedOrMissing Negative(gdwarf-)\n Generate debug information in COFF format\n \n-gdwarf-2\n-Common JoinedOrMissing Negative(gstabs)\n-Generate debug information in DWARF v2 format\n+gdwarf-\n+Common Joined UInteger Var(dwarf_version) Init(2) Negative(gstabs)\n+Generate debug information in DWARF v2 (or later) format\n \n ggdb\n Common JoinedOrMissing"}, {"sha": "4b1ca700a7439432c99597a7feda29ed0ec296a7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -310,7 +310,7 @@ Objective-C and Objective-C++ Dialects}.\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol\n -ftest-coverage  -ftime-report -fvar-tracking @gol\n--g  -g@var{level}  -gtoggle  -gcoff  -gdwarf-2 @gol\n+-g  -g@var{level}  -gtoggle  -gcoff  -gdwarf-@var{version} @gol\n -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol\n -fno-merge-debug-strings -fno-dwarf2-cfi-asm @gol\n -fdebug-prefix-map=@var{old}=@var{new} @gol\n@@ -4344,13 +4344,14 @@ use of these extensions is likely to make other debuggers crash or\n refuse to read the program, and may cause assemblers other than the GNU\n assembler (GAS) to fail with an error.\n \n-@item -gdwarf-2\n-@opindex gdwarf-2\n-Produce debugging information in DWARF version 2 format (if that is\n-supported).  This is the format used by DBX on IRIX 6.  With this\n-option, GCC uses features of DWARF version 3 when they are useful;\n-version 3 is upward compatible with version 2, but may still cause\n-problems for older debuggers.\n+@item -gdwarf-@var{version}\n+@opindex gdwarf-@var{version}\n+Produce debugging information in DWARF format (if that is\n+supported).  This is the format used by DBX on IRIX 6.  The value\n+of @var{version} may be either 2 or 3; the default version is 2.\n+\n+Note that with DWARF version 2 some ports require, and will always\n+use, some non-conflicting DWARF 3 extensions in the unwind tables.\n \n @item -gvms\n @opindex gvms\n@@ -4384,7 +4385,7 @@ debug information in version 1 of the DWARF format (which is very\n different from version 2), and it would have been too confusing.  That\n debug format is long obsolete, but the option cannot be changed now.\n Instead use an additional @option{-g@var{level}} option to change the\n-debug level for DWARF2.\n+debug level for DWARF.\n \n @item -gtoggle\n @opindex gtoggle"}, {"sha": "d106b670ea5435d0e0761a8fbcb5388ed0e81e73", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -782,7 +782,6 @@ enum dwarf_call_frame_info\n \n #define DW_CIE_ID\t  0xffffffff\n #define DW64_CIE_ID\t  0xffffffffffffffffULL\n-#define DW_CIE_VERSION\t  1\n \n #define DW_CFA_extended   0\n "}, {"sha": "bbd763a5aa922216df4a7b186fcd18d1ef778230", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 101, "deletions": 71, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -317,8 +317,6 @@ dw_fde_node;\n #define DWARF_INITIAL_LENGTH_SIZE (DWARF_OFFSET_SIZE == 4 ? 4 : 12)\n #endif\n \n-#define DWARF_VERSION 2\n-\n /* Round SIZE up to the nearest BOUNDARY.  */\n #define DWARF_ROUND(SIZE,BOUNDARY) \\\n   ((((SIZE) + (BOUNDARY) - 1) / (BOUNDARY)) * (BOUNDARY))\n@@ -749,50 +747,51 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n \n \t  gcc_assert (fde != NULL);\n \n-\t  /* We still have to add the cfi to the list so that\n-\t     lookup_cfa works later on.  When -g2 and above we\n-\t     even need to force emitting of CFI labels and\n-\t     add to list a DW_CFA_set_loc for convert_cfa_to_fb_loc_list\n-\t     purposes.  */\n-\t  switch (cfi->dw_cfi_opc)\n+\t  /* We still have to add the cfi to the list so that lookup_cfa\n+\t     works later on.  When -g2 and above we even need to force\n+\t     emitting of CFI labels and add to list a DW_CFA_set_loc for\n+\t     convert_cfa_to_fb_loc_list purposes.  If we're generating\n+\t     DWARF3 output we use DW_OP_call_frame_cfa and so don't use\n+\t     convert_cfa_to_fb_loc_list.  */\n+\t  if (dwarf_version == 2\n+\t      && debug_info_level > DINFO_LEVEL_TERSE\n+\t      && (write_symbols == DWARF2_DEBUG\n+\t\t  || write_symbols == VMS_AND_DWARF2_DEBUG))\n \t    {\n-\t    case DW_CFA_def_cfa_offset:\n-\t    case DW_CFA_def_cfa_offset_sf:\n-\t    case DW_CFA_def_cfa_register:\n-\t    case DW_CFA_def_cfa:\n-\t    case DW_CFA_def_cfa_sf:\n-\t    case DW_CFA_def_cfa_expression:\n-\t    case DW_CFA_restore_state:\n-\t      if (write_symbols != DWARF2_DEBUG\n-\t\t  && write_symbols != VMS_AND_DWARF2_DEBUG)\n-\t\tbreak;\n-\t      if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\t\tbreak;\n-\n-\t      if (*label == 0 || strcmp (label, \"<do not output>\") == 0)\n-\t\tlabel = dwarf2out_cfi_label (true);\n-\n-\t      if (fde->dw_fde_current_label == NULL\n-\t\t  || strcmp (label, fde->dw_fde_current_label) != 0)\n+\t      switch (cfi->dw_cfi_opc)\n \t\t{\n-\t\t  dw_cfi_ref xcfi;\n-\n-\t\t  label = xstrdup (label);\n-\n-\t\t  /* Set the location counter to the new label.  */\n-\t\t  xcfi = new_cfi ();\n-\t\t  /* It doesn't metter whether DW_CFA_set_loc\n-\t\t     or DW_CFA_advance_loc4 is added here, those aren't\n-\t\t     emitted into assembly, only looked up by\n-\t\t     convert_cfa_to_fb_loc_list.  */\n-\t\t  xcfi->dw_cfi_opc = DW_CFA_set_loc;\n-\t\t  xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n-\t\t  add_cfi (&fde->dw_fde_cfi, xcfi);\n-\t\t  fde->dw_fde_current_label = label;\n-\t\t}\n-\t      break;\n-\t    default:\n-\t      break;\n+\t\tcase DW_CFA_def_cfa_offset:\n+\t\tcase DW_CFA_def_cfa_offset_sf:\n+\t\tcase DW_CFA_def_cfa_register:\n+\t\tcase DW_CFA_def_cfa:\n+\t\tcase DW_CFA_def_cfa_sf:\n+\t\tcase DW_CFA_def_cfa_expression:\n+\t\tcase DW_CFA_restore_state:\n+\t\t  if (*label == 0 || strcmp (label, \"<do not output>\") == 0)\n+\t\t    label = dwarf2out_cfi_label (true);\n+\n+\t\t  if (fde->dw_fde_current_label == NULL\n+\t\t      || strcmp (label, fde->dw_fde_current_label) != 0)\n+\t\t    {\n+\t\t      dw_cfi_ref xcfi;\n+\n+\t\t      label = xstrdup (label);\n+\n+\t\t      /* Set the location counter to the new label.  */\n+\t\t      xcfi = new_cfi ();\n+\t\t      /* It doesn't metter whether DW_CFA_set_loc\n+\t\t         or DW_CFA_advance_loc4 is added here, those aren't\n+\t\t         emitted into assembly, only looked up by\n+\t\t         convert_cfa_to_fb_loc_list.  */\n+\t\t      xcfi->dw_cfi_opc = DW_CFA_set_loc;\n+\t\t      xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n+\t\t      add_cfi (&fde->dw_fde_cfi, xcfi);\n+\t\t      fde->dw_fde_current_label = label;\n+\t\t    }\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t        }\n \t    }\n \n \t  output_cfi_directive (cfi);\n@@ -3197,6 +3196,7 @@ output_call_frame_info (int for_eh)\n   int per_encoding = DW_EH_PE_absptr;\n   int lsda_encoding = DW_EH_PE_absptr;\n   int return_reg;\n+  int dw_cie_version;\n \n   /* Don't emit a CIE if there won't be any FDEs.  */\n   if (fde_table_in_use == 0)\n@@ -3277,7 +3277,14 @@ output_call_frame_info (int for_eh)\n \t\t       (for_eh ? 0 : DWARF_CIE_ID),\n \t\t       \"CIE Identifier Tag\");\n \n-  dw2_asm_output_data (1, DW_CIE_VERSION, \"CIE Version\");\n+  /* Use the CIE version 3 for DWARF3; allow DWARF2 to continue to\n+     use CIE version 1, unless that would produce incorrect results\n+     due to overflowing the return register column.  */\n+  return_reg = DWARF2_FRAME_REG_OUT (DWARF_FRAME_RETURN_COLUMN, for_eh);\n+  dw_cie_version = 1;\n+  if (return_reg >= 256 || dwarf_version > 2)\n+    dw_cie_version = 3;\n+  dw2_asm_output_data (1, dw_cie_version, \"CIE Version\");\n \n   augmentation[0] = 0;\n   augmentation_size = 0;\n@@ -3349,8 +3356,7 @@ output_call_frame_info (int for_eh)\n   dw2_asm_output_data_sleb128 (DWARF_CIE_DATA_ALIGNMENT,\n \t\t\t       \"CIE Data Alignment Factor\");\n \n-  return_reg = DWARF2_FRAME_REG_OUT (DWARF_FRAME_RETURN_COLUMN, for_eh);\n-  if (DW_CIE_VERSION == 1)\n+  if (dw_cie_version == 1)\n     dw2_asm_output_data (1, return_reg, \"CIE RA Column\");\n   else\n     dw2_asm_output_data_uleb128 (return_reg, \"CIE RA Column\");\n@@ -4187,6 +4193,7 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_xderef_size\";\n     case DW_OP_nop:\n       return \"DW_OP_nop\";\n+\n     case DW_OP_push_object_address:\n       return \"DW_OP_push_object_address\";\n     case DW_OP_call2:\n@@ -4195,10 +4202,20 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_call4\";\n     case DW_OP_call_ref:\n       return \"DW_OP_call_ref\";\n+    case DW_OP_form_tls_address:\n+      return \"DW_OP_form_tls_address\";\n+    case DW_OP_call_frame_cfa:\n+      return \"DW_OP_call_frame_cfa\";\n+    case DW_OP_bit_piece:\n+      return \"DW_OP_bit_piece\";\n+\n     case DW_OP_GNU_push_tls_address:\n       return \"DW_OP_GNU_push_tls_address\";\n     case DW_OP_GNU_uninit:\n       return \"DW_OP_GNU_uninit\";\n+    case DW_OP_GNU_encoded_addr:\n+      return \"DW_OP_GNU_encoded_addr\";\n+\n     default:\n       return \"OP_<unknown>\";\n     }\n@@ -5617,6 +5634,9 @@ static int maybe_emit_file (struct dwarf_file_data *fd);\n #ifndef DEBUG_PUBNAMES_SECTION\n #define DEBUG_PUBNAMES_SECTION\t\".debug_pubnames\"\n #endif\n+#ifndef DEBUG_PUBTYPES_SECTION\n+#define DEBUG_PUBTYPES_SECTION\t\".debug_pubtypes\"\n+#endif\n #ifndef DEBUG_STR_SECTION\n #define DEBUG_STR_SECTION\t\".debug_str\"\n #endif\n@@ -7869,7 +7889,6 @@ build_abbrev_table (dw_die_ref die)\n \t&& AT_ref (a)->die_mark == 0)\n       {\n \tgcc_assert (AT_ref (a)->die_symbol);\n-\n \tset_AT_ref_external (a, 1);\n       }\n \n@@ -7997,7 +8016,9 @@ size_of_die (dw_die_ref die)\n \t  size += 1;\n \t  break;\n \tcase dw_val_class_die_ref:\n-\t  if (AT_ref_external (a))\n+\t  /* In DWARF2, DW_FORM_ref_addr is sized by target address length,\n+\t     whereas in DWARF3 it's always sized as an offset.  */\n+\t  if (AT_ref_external (a) && dwarf_version == 2)\n \t    size += DWARF2_ADDR_SIZE;\n \t  else\n \t    size += DWARF_OFFSET_SIZE;\n@@ -8526,10 +8547,17 @@ output_die (dw_die_ref die)\n \t  if (AT_ref_external (a))\n \t    {\n \t      char *sym = AT_ref (a)->die_symbol;\n+\t      int size;\n \n \t      gcc_assert (sym);\n-\t      dw2_asm_output_offset (DWARF2_ADDR_SIZE, sym, debug_info_section,\n-\t\t\t\t     \"%s\", name);\n+\n+\t      /* In DWARF2, DW_FORM_ref_addr is sized by target address\n+\t\t length, whereas in DWARF3 it's always sized as an offset.  */\n+\t      if (dwarf_version == 2)\n+\t\tsize = DWARF2_ADDR_SIZE;\n+\t      else\n+\t\tsize = DWARF_OFFSET_SIZE;\n+\t      dw2_asm_output_offset (size, sym, debug_info_section, \"%s\", name);\n \t    }\n \t  else\n \t    {\n@@ -8608,7 +8636,7 @@ output_compilation_unit_header (void)\n   dw2_asm_output_data (DWARF_OFFSET_SIZE,\n \t\t       next_die_offset - DWARF_INITIAL_LENGTH_SIZE,\n \t\t       \"Length of Compilation Unit Info\");\n-  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF version number\");\n+  dw2_asm_output_data (2, dwarf_version, \"DWARF version number\");\n   dw2_asm_output_offset (DWARF_OFFSET_SIZE, abbrev_section_label,\n \t\t\t debug_abbrev_section,\n \t\t\t \"Offset Into Abbrev. Section\");\n@@ -8689,7 +8717,6 @@ add_pubname_string (const char *str, dw_die_ref die)\n static void\n add_pubname (tree decl, dw_die_ref die)\n {\n-\n   if (TREE_PUBLIC (decl))\n     add_pubname_string (dwarf2_name (decl, 1), die);\n }\n@@ -8749,7 +8776,8 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n   else\n     dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n \t\t\t \"Length of Public Type Names Info\");\n-  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n+  /* Version number for pubnames/pubtypes is still 2, even in DWARF3.  */\n+  dw2_asm_output_data (2, 2, \"DWARF Version\");\n   dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n \t\t\t debug_info_section,\n \t\t\t \"Offset of Compilation Unit Info\");\n@@ -8811,7 +8839,8 @@ output_aranges (void)\n       \"Initial length escape value indicating 64-bit DWARF extension\");\n   dw2_asm_output_data (DWARF_OFFSET_SIZE, aranges_length,\n \t\t       \"Length of Address Ranges Info\");\n-  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n+  /* Version number for aranges is still 2, even in DWARF3.  */\n+  dw2_asm_output_data (2, 2, \"DWARF Version\");\n   dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_info_section_label,\n \t\t\t debug_info_section,\n \t\t\t \"Offset of Compilation Unit Info\");\n@@ -9356,7 +9385,7 @@ output_line_info (void)\n \t\t\t\"Length of Source Line Info\");\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n-  dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n+  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n   dw2_asm_output_delta (DWARF_OFFSET_SIZE, p2, p1, \"Prolog Length\");\n   ASM_OUTPUT_LABEL (asm_out_file, p1);\n \n@@ -14079,17 +14108,19 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t (3) We can at least reuse the code inspection and interpretation\n \t code that determines the CFA position at various points in the\n \t function.  */\n-      /* ??? Use some command-line or configury switch to enable the use\n-\t of dwarf3 DW_OP_call_frame_cfa.  At present there are no dwarf\n-\t consumers that understand it; fall back to \"pure\" dwarf2 and\n-\t convert the CFA data into a location list.  */\n-      {\n-\tdw_loc_list_ref list = convert_cfa_to_fb_loc_list (cfa_fb_offset);\n-\tif (list->dw_loc_next)\n-\t  add_AT_loc_list (subr_die, DW_AT_frame_base, list);\n-\telse\n-\t  add_AT_loc (subr_die, DW_AT_frame_base, list->expr);\n-      }\n+      if (dwarf_version >= 3)\n+\t{\n+\t  dw_loc_descr_ref op = new_loc_descr (DW_OP_call_frame_cfa, 0, 0);\n+\t  add_AT_loc (subr_die, DW_AT_frame_base, op);\n+\t}\n+      else\n+\t{\n+\t  dw_loc_list_ref list = convert_cfa_to_fb_loc_list (cfa_fb_offset);\n+\t  if (list->dw_loc_next)\n+\t    add_AT_loc_list (subr_die, DW_AT_frame_base, list);\n+\t  else\n+\t    add_AT_loc (subr_die, DW_AT_frame_base, list->expr);\n+\t}\n \n       /* Compute a displacement from the \"steady-state frame pointer\" to\n \t the CFA.  The former is what all stack slots and argument slots\n@@ -16457,10 +16488,8 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \t\t\t\t   SECTION_DEBUG, NULL);\n   debug_pubnames_section = get_section (DEBUG_PUBNAMES_SECTION,\n \t\t\t\t\tSECTION_DEBUG, NULL);\n-#ifdef DEBUG_PUBTYPES_SECTION\n   debug_pubtypes_section = get_section (DEBUG_PUBTYPES_SECTION,\n \t\t\t\t\tSECTION_DEBUG, NULL);\n-#endif\n   debug_str_section = get_section (DEBUG_STR_SECTION,\n \t\t\t\t   DEBUG_STR_SECTION_FLAGS, NULL);\n   debug_ranges_section = get_section (DEBUG_RANGES_SECTION,\n@@ -17092,14 +17121,15 @@ dwarf2out_finish (const char *filename)\n       output_pubnames (pubname_table);\n     }\n \n-#ifdef DEBUG_PUBTYPES_SECTION\n   /* Output public types table if necessary.  */\n+  /* ??? Only defined by DWARF3, but emitted by Darwin for DWARF2.\n+     It shouldn't hurt to emit it always, since pure DWARF2 consumers\n+     simply won't look for the section.  */\n   if (!VEC_empty (pubname_entry, pubtype_table))\n     {\n       switch_to_section (debug_pubtypes_section);\n       output_pubnames (pubtype_table);\n     }\n-#endif\n \n   /* Output the address range information.  We only put functions in the arange\n      table, so don't write it out if we don't have any.  */"}, {"sha": "fb262bd93b7f60e8ecdb361cc7c636e7147813fd", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -333,6 +333,8 @@ for (i = 0; i < n_opts; i++) {\n \tenum = \"OPT_\" opts[i]\n \tif (opts[i] == \"finline-limit=\" || opts[i] == \"Wlarger-than=\")\n \t\tenum = enum \"eq\"\n+\tif (opts[i] == \"gdwarf+\")\n+\t\tenum = \"OPT_gdwarfplus\"\n \tgsub (\"[^A-Za-z0-9]\", \"_\", enum)\n \n \t# If this switch takes joined arguments, back-chain all\n@@ -348,7 +350,7 @@ for (i = 0; i < n_opts; i++) {\n \t\t}\n \t}\n \n-\ts = substr(\"                                     \", length (opts[i]))\n+\ts = substr(\"                                         \", length (enum))\n \tif (i + 1 == n_opts)\n \t\tcomma = \"\"\n "}, {"sha": "210140c63c35ca9b193fa824b18f89de8836ba3a", "filename": "gcc/opts.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53b2323e9d8f59f02918edad69830000ed0886e4/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=53b2323e9d8f59f02918edad69830000ed0886e4", "patch": "@@ -2033,8 +2033,12 @@ common_handle_option (size_t scode, const char *arg, int value,\n       set_debug_level (SDB_DEBUG, false, arg);\n       break;\n \n-    case OPT_gdwarf_2:\n-      set_debug_level (DWARF2_DEBUG, false, arg);\n+    case OPT_gdwarf_:\n+      if (value < 2 || value > 3)\n+\terror (\"dwarf version %d is not supported\", value);\n+      else\n+\tdwarf_version = value;\n+      set_debug_level (DWARF2_DEBUG, false, \"\");\n       break;\n \n     case OPT_ggdb:"}]}