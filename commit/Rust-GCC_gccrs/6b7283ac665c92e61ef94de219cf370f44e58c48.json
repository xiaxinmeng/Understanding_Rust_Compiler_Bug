{"sha": "6b7283ac665c92e61ef94de219cf370f44e58c48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI3MjgzYWM2NjVjOTJlNjFlZjk0ZGUyMTljZjM3MGY0NGU1OGM0OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-10-19T20:22:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-10-19T20:22:04Z"}, "message": "fold-const.c (add_double): Rename to add_double_with_sign.\n\n\t* fold-const.c (add_double): Rename to add_double_with_sign.\n\tAdd 'unsigned_p' parameter and take it into account for the overflow.\n\t(mul_double): Rename to mul_double_with_sign. \n\tAdd 'unsigned_p' parameter and take it into account for the overflow.\n\t(fold_div_compare): Call add_double_with_sign instead of add_double\n\tand mul_double_with_sign instead of mul_double, passing them the\n\tunsignedness of the type.\n\t* tree.h (add_double): Macroize.\n\t(add_double_with_sign): New prototype.\n\t(mul_double): Macroize.\n\t(mul_double_with_sign): New prototype.\n\nFrom-SVN: r117887", "tree": {"sha": "7e3609b598845139fb6a9e14f67acf3ce9219904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e3609b598845139fb6a9e14f67acf3ce9219904"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b7283ac665c92e61ef94de219cf370f44e58c48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7283ac665c92e61ef94de219cf370f44e58c48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b7283ac665c92e61ef94de219cf370f44e58c48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b7283ac665c92e61ef94de219cf370f44e58c48/comments", "author": null, "committer": null, "parents": [{"sha": "93ef7c1f7e34843c5480d363ccea716ddd6ae496", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93ef7c1f7e34843c5480d363ccea716ddd6ae496", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93ef7c1f7e34843c5480d363ccea716ddd6ae496"}], "stats": {"total": 114, "additions": 86, "deletions": 28}, "files": [{"sha": "7f0267afe02b97e3be9a5695ba43dee2e41fef27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b7283ac665c92e61ef94de219cf370f44e58c48", "patch": "@@ -1,3 +1,17 @@\n+2006-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fold-const.c (add_double): Rename to add_double_with_sign.\n+\tAdd 'unsigned_p' parameter and take it into account for the overflow.\n+\t(mul_double): Rename to mul_double_with_sign. \n+\tAdd 'unsigned_p' parameter and take it into account for the overflow.\n+\t(fold_div_compare): Call add_double_with_sign instead of add_double\n+\tand mul_double_with_sign instead of mul_double, passing them the\n+\tunsignedness of the type.\n+\t* tree.h (add_double): Macroize.\n+\t(add_double_with_sign): New prototype.\n+\t(mul_double): Macroize.\n+\t(mul_double_with_sign): New prototype.\n+\n 2006-10-19  Chen Liqin  <liqin@sunnorth.com.cn>\n \n         * config/score/crti.asm: New file."}, {"sha": "30efccd7ea74a8d07c7fc4ebf027befc7cf8b29d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6b7283ac665c92e61ef94de219cf370f44e58c48", "patch": "@@ -291,14 +291,16 @@ force_fit_type (tree t, int overflowable,\n }\n \f\n /* Add two doubleword integers with doubleword result.\n+   Return nonzero if the operation overflows according to UNSIGNED_P.\n    Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-add_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t    unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n-\t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+add_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n+\t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t\t      bool unsigned_p)\n {\n   unsigned HOST_WIDE_INT l;\n   HOST_WIDE_INT h;\n@@ -308,7 +310,11 @@ add_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \n   *lv = l;\n   *hv = h;\n-  return OVERFLOW_SUM_SIGN (h1, h2, h);\n+\n+  if (unsigned_p)\n+    return (unsigned HOST_WIDE_INT) h < (unsigned HOST_WIDE_INT) h1;\n+  else\n+    return OVERFLOW_SUM_SIGN (h1, h2, h);\n }\n \n /* Negate a doubleword integer with doubleword result.\n@@ -335,15 +341,16 @@ neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n }\n \f\n /* Multiply two doubleword integers with doubleword result.\n-   Return nonzero if the operation overflows, assuming it's signed.\n+   Return nonzero if the operation overflows according to UNSIGNED_P.\n    Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n-mul_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t    unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n-\t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n+\t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t\t      bool unsigned_p)\n {\n   HOST_WIDE_INT arg1[4];\n   HOST_WIDE_INT arg2[4];\n@@ -374,11 +381,15 @@ mul_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n       prod[i + 4] = carry;\n     }\n \n-  decode (prod, lv, hv);\t/* This ignores prod[4] through prod[4*2-1] */\n-\n-  /* Check for overflow by calculating the top half of the answer in full;\n-     it should agree with the low half's sign bit.  */\n+  decode (prod, lv, hv);\n   decode (prod + 4, &toplow, &tophigh);\n+\n+  /* Unsigned overflow is immediate.  */\n+  if (unsigned_p)\n+    return (toplow | tophigh) != 0;\n+\n+  /* Check for signed overflow by calculating the signed representation of the\n+     top half of the result; it should agree with the low half's sign bit.  */\n   if (h1 < 0)\n     {\n       neg_double (l2, h2, &neglow, &neghigh);\n@@ -6083,30 +6094,32 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n   tree arg01 = TREE_OPERAND (arg0, 1);\n   unsigned HOST_WIDE_INT lpart;\n   HOST_WIDE_INT hpart;\n+  bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (arg0));\n   bool neg_overflow;\n   int overflow;\n \n   /* We have to do this the hard way to detect unsigned overflow.\n      prod = int_const_binop (MULT_EXPR, arg01, arg1, 0);  */\n-  overflow = mul_double (TREE_INT_CST_LOW (arg01),\n-\t\t\t TREE_INT_CST_HIGH (arg01),\n-\t\t\t TREE_INT_CST_LOW (arg1),\n-\t\t\t TREE_INT_CST_HIGH (arg1), &lpart, &hpart);\n+  overflow = mul_double_with_sign (TREE_INT_CST_LOW (arg01),\n+\t\t\t\t   TREE_INT_CST_HIGH (arg01),\n+\t\t\t\t   TREE_INT_CST_LOW (arg1),\n+\t\t\t\t   TREE_INT_CST_HIGH (arg1),\n+\t\t\t\t   &lpart, &hpart, unsigned_p);\n   prod = build_int_cst_wide (TREE_TYPE (arg00), lpart, hpart);\n   prod = force_fit_type (prod, -1, overflow, false);\n   neg_overflow = false;\n \n-  if (TYPE_UNSIGNED (TREE_TYPE (arg0)))\n+  if (unsigned_p)\n     {\n       tmp = int_const_binop (MINUS_EXPR, arg01, integer_one_node, 0);\n       lo = prod;\n \n       /* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp, 0).  */\n-      overflow = add_double (TREE_INT_CST_LOW (prod),\n-\t\t\t     TREE_INT_CST_HIGH (prod),\n-\t\t\t     TREE_INT_CST_LOW (tmp),\n-\t\t\t     TREE_INT_CST_HIGH (tmp),\n-\t\t\t     &lpart, &hpart);\n+      overflow = add_double_with_sign (TREE_INT_CST_LOW (prod),\n+\t\t\t\t       TREE_INT_CST_HIGH (prod),\n+\t\t\t\t       TREE_INT_CST_LOW (tmp),\n+\t\t\t\t       TREE_INT_CST_HIGH (tmp),\n+\t\t\t\t       &lpart, &hpart, unsigned_p);\n       hi = build_int_cst_wide (TREE_TYPE (arg00), lpart, hpart);\n       hi = force_fit_type (hi, -1, overflow | TREE_OVERFLOW (prod),\n \t\t\t   TREE_CONSTANT_OVERFLOW (prod));"}, {"sha": "eb5d88fd80c0c440461e75730710137905957736", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6b7283ac665c92e61ef94de219cf370f44e58c48", "patch": "@@ -1,3 +1,7 @@\n+2006-10-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/div-compare-1.c: New test.\n+\n 2006-10-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29216"}, {"sha": "61adafe140d126692b19553007e79e3187247e82", "filename": "gcc/testsuite/gcc.dg/div-compare-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ftestsuite%2Fgcc.dg%2Fdiv-compare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ftestsuite%2Fgcc.dg%2Fdiv-compare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiv-compare-1.c?ref=6b7283ac665c92e61ef94de219cf370f44e58c48", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99\" } */\n+\n+extern void abort(void);\n+\n+typedef unsigned long long uint64;\n+\n+int very_large_value (uint64 t)\n+{\n+  return (t / 1000000000ULL) > 9223372037ULL;\n+}\n+\n+int main(void)\n+{\n+  uint64 t = 0xC000000000000000ULL;\n+\n+  if (!very_large_value (t))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e6a861ca24af4a8efc911568d3645486d4dda162", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b7283ac665c92e61ef94de219cf370f44e58c48/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6b7283ac665c92e61ef94de219cf370f44e58c48", "patch": "@@ -4210,14 +4210,20 @@ extern tree fold_indirect_ref_1 (tree, tree);\n \n extern tree force_fit_type (tree, int, bool, bool);\n \n-extern int add_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t bool);\n+#define add_double(l1,h1,l2,h2,lv,hv) \\\n+  add_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n extern int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n-extern int mul_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t bool);\n+#define mul_double(l1,h1,l2,h2,lv,hv) \\\n+  mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t   HOST_WIDE_INT, unsigned int,\n \t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, int);"}]}