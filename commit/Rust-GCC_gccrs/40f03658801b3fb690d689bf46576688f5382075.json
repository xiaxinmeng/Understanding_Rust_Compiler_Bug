{"sha": "40f03658801b3fb690d689bf46576688f5382075", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmMDM2NTg4MDFiM2ZiNjkwZDY4OWJmNDY1NzY2ODhmNTM4MjA3NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-26T22:25:14Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-26T22:25:14Z"}, "message": "c-common.h: Follow spelling conventions.\n\n\t* c-common.h: Follow spelling conventions.\n\t* cpplex.c: Likewise.\n\t* cpplib.h: Likewise.\n\t* gthr-dce.h: Likewise.\n\t* gthr-posix.h: Likewise.\n\t* optabs.c: Likewise.\n\t* output.h: Likewise.\n\t* profile.c: Likewise.\n\t* protoize.c: Likewise.\n\t* ra-rewrite.c: Likewise.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regmove.c: Likewise.\n\t* reload.c: Likewise.\n\t* reload.h: Likewise.\n\t* reload1.c: Likewise.\n\t* reorg.c: Likewise.\n\t* resource.c: Likewise.\n\t* rtl.h: Likewise.\n\t* rtlanal.c: Likewise.\n\nFrom-SVN: r57555", "tree": {"sha": "778e5c00812009bde0b1783be2f952fd29b9acd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/778e5c00812009bde0b1783be2f952fd29b9acd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40f03658801b3fb690d689bf46576688f5382075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f03658801b3fb690d689bf46576688f5382075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f03658801b3fb690d689bf46576688f5382075", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f03658801b3fb690d689bf46576688f5382075/comments", "author": null, "committer": null, "parents": [{"sha": "ee8a73d6e7e9523bcdedd76ff3bc414910c8d0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8a73d6e7e9523bcdedd76ff3bc414910c8d0c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee8a73d6e7e9523bcdedd76ff3bc414910c8d0c4"}], "stats": {"total": 145, "additions": 85, "deletions": 60}, "files": [{"sha": "3be743b2b12e5d2517ef749975f66c90c18e06e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -1,3 +1,28 @@\n+2002-09-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-common.h: Follow spelling conventions.\n+\t* cpplex.c: Likewise.\n+\t* cpplib.h: Likewise.\n+\t* gthr-dce.h: Likewise.\n+\t* gthr-posix.h: Likewise.\n+\t* optabs.c: Likewise.\n+\t* output.h: Likewise.\n+\t* profile.c: Likewise.\n+\t* protoize.c: Likewise.\n+\t* ra-rewrite.c: Likewise.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* reload.h: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reorg.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* rtl.h: Likewise.\n+\t* rtlanal.c: Likewise.\n+\n 2002-09-26  Steve Ellcey  <sje@cup.hp.com>\n \n \t* config/ia64/ia64.c (ia64_expand_load_address): Ensure correct mode"}, {"sha": "ef04ca8b2e721ede0ca06efa11f64659d4d64c56", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -43,7 +43,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n */\n \n /* Reserved identifiers.  This is the union of all the keywords for C,\n-   C++, and Objective C.  All the type modifiers have to be in one\n+   C++, and Objective-C.  All the type modifiers have to be in one\n    block at the beginning, because they are used as mask bits.  There\n    are 27 type modifiers; if we add many more we will have to redesign\n    the mask mechanism.  */\n@@ -93,7 +93,7 @@ enum rid\n   /* casts */\n   RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n \n-  /* Objective C */\n+  /* Objective-C */\n   RID_ID,          RID_AT_ENCODE,    RID_AT_END,\n   RID_AT_CLASS,    RID_AT_ALIAS,     RID_AT_DEFS,\n   RID_AT_PRIVATE,  RID_AT_PROTECTED, RID_AT_PUBLIC,"}, {"sha": "7db6b24b253812bf65fa0110fcc634cdea28bd2d", "filename": "gcc/cpplex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -1329,7 +1329,7 @@ _cpp_lex_direct (pfile)\n     case '}': result->type = CPP_CLOSE_BRACE; break;\n     case ';': result->type = CPP_SEMICOLON; break;\n \n-      /* @ is a punctuator in Objective C.  */\n+      /* @ is a punctuator in Objective-C.  */\n     case '@': result->type = CPP_ATSIGN; break;\n \n     case '$':"}, {"sha": "7b3a54a3576eb12aedcb1fde635037ec357d598d", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -123,7 +123,7 @@ struct file_name_map_list;\n   OP(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n   OP(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n   OP(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n-  OP(CPP_ATSIGN,\t\"@\")  /* used in Objective C */ \\\n+  OP(CPP_ATSIGN,\t\"@\")  /* used in Objective-C */ \\\n \\\n   TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n   TK(CPP_NUMBER,\tSPELL_NUMBER)\t/* 34_be+ta  */\t\t\t\\"}, {"sha": "3577ce5ec91c4d6f2c345b0e96f0cc0a5fe2241d", "filename": "gcc/gthr-dce.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fgthr-dce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fgthr-dce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-dce.h?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -74,7 +74,7 @@ typedef pthread_mutex_t __gthread_mutex_t;\n #pragma weak pthread_mutex_unlock\n \n #ifdef _LIBOBJC\n-/* Objective C.  */\n+/* Objective-C.  */\n #pragma weak pthread_cond_broadcast\n #pragma weak pthread_cond_destroy\n #pragma weak pthread_cond_init"}, {"sha": "80f6ff742a28e348d1bc0aba690972b3d1f82686", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -57,7 +57,7 @@ typedef pthread_mutex_t __gthread_mutex_t;\n #pragma weak pthread_mutex_unlock\n \n #ifdef _LIBOBJC\n-/* Objective C.  */\n+/* Objective-C.  */\n #pragma weak pthread_cond_broadcast\n #pragma weak pthread_cond_destroy\n #pragma weak pthread_cond_init"}, {"sha": "ec03c1908d8879e2ee4a96dd33c59bc2dff722de", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -2979,7 +2979,7 @@ emit_unop_insn (icode, target, op0, code)\n    TARGET, OP0, and OP1 are the output and inputs of the operations,\n    respectively.  OP1 may be zero for a unary operation.\n \n-   EQUIV, if non-zero, is an expression to be placed into a REG_EQUAL note\n+   EQUIV, if nonzero, is an expression to be placed into a REG_EQUAL note\n    on the last insn.\n \n    If TARGET is not a register, INSNS is simply emitted with no special\n@@ -4152,7 +4152,7 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n   return target;\n }\n \n-/* Return non-zero if a conditional move of mode MODE is supported.\n+/* Return nonzero if a conditional move of mode MODE is supported.\n \n    This function is for combine so it can tell whether an insn that looks\n    like a conditional move is actually supported by the hardware.  If we"}, {"sha": "cd5cd09e22bf2fc0aecbde33477af89b876ef8e6", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -327,7 +327,7 @@ extern bool default_assemble_integer\tPARAMS ((rtx, unsigned int, int));\n \n /* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n    the alignment of the integer in bits.  Return 1 if we were able to output\n-   the constant, otherwise 0.  If FORCE is non-zero, abort if we can't output\n+   the constant, otherwise 0.  If FORCE is nonzero, abort if we can't output\n    the constant.  */\n extern bool assemble_integer\t\tPARAMS ((rtx, unsigned, unsigned, int));\n "}, {"sha": "1ee4735140926e69fcc31257772e29a35e8a4006", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -162,7 +162,7 @@ static long compute_checksum PARAMS ((void));\n static basic_block find_group PARAMS ((basic_block));\n static void union_groups PARAMS ((basic_block, basic_block));\n \n-/* If non-zero, we need to output a constructor to set up the\n+/* If nonzero, we need to output a constructor to set up the\n    per-object-file data.  */\n static int need_func_profiler = 0;\n \f"}, {"sha": "e039d6d4775041a024375838c19f17784d07019a", "filename": "gcc/protoize.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -363,7 +363,7 @@ struct def_dec_info_struct {\n \n static const char *pname;\n \n-/* Error counter.  Will be non-zero if we should give up at the next convenient\n+/* Error counter.  Will be nonzero if we should give up at the next convenient\n    stopping point.  */\n \n static int errors = 0;\n@@ -669,7 +669,7 @@ is_id_char (ch)\n }\n \n /* Give a message indicating the proper way to invoke this program and then\n-   exit with non-zero status.  */\n+   exit with nonzero status.  */\n \n static void\n usage ()\n@@ -1437,7 +1437,7 @@ find_corresponding_lparen (p)\n /* Given a line from  an aux info file, and a time at which the aux info\n    file it came from was created, check to see if the item described in\n    the line comes from a file which has been modified since the aux info\n-   file was created.  If so, return non-zero, else return zero.  */\n+   file was created.  If so, return nonzero, else return zero.  */\n \n static int\n referenced_file_is_newer (l, aux_info_mtime)\n@@ -3202,7 +3202,7 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n    list that lies to the left of the one it was originally called to work\n    on.  Thus, a whole set gets done in right-to-left order.\n \n-   This routine returns non-zero if it thinks that it should not be trying\n+   This routine returns nonzero if it thinks that it should not be trying\n    to convert this particular function definition (because the name of the\n    function doesn't match the one expected).  */\n \n@@ -3254,7 +3254,7 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n \n   /* Check that the function name in the header we are working on is the same\n      as the one we would expect to find.  If not, issue a warning and return\n-     non-zero.  */\n+     nonzero.  */\n \n   if (f_list_count == 0)\n     {"}, {"sha": "61645e22a1d33da040a79c68a8098f431c150f9b", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -550,7 +550,7 @@ remember_slot (list, x)\n }\n \n /* Given two rtx' S1 and S2, either being REGs or MEMs (or SUBREGs\n-   thereof), return non-zero, if they overlap.  REGs and MEMs don't\n+   thereof), return nonzero, if they overlap.  REGs and MEMs don't\n    overlap, and if they are MEMs they must have an easy address\n    (plus (basereg) (const_inst x)), otherwise they overlap.  */\n "}, {"sha": "0d8547b9c7da48255028366976b33976bc2d246a", "filename": "gcc/real.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -507,7 +507,7 @@ normalize (r)\n   int shift = 0, exp;\n   int i, j;\n \n-  /* Find the first word that is non-zero.  */\n+  /* Find the first word that is nonzero.  */\n   for (i = SIGSZ - 1; i >= 0; i--)\n     if (r->sig[i] == 0)\n       shift += HOST_BITS_PER_LONG;\n@@ -522,7 +522,7 @@ normalize (r)\n       return;\n     }\n \n-  /* Find the first bit that is non-zero.  */\n+  /* Find the first bit that is nonzero.  */\n   for (j = 0; ; j++)\n     if (r->sig[i] & ((unsigned long)1 << (HOST_BITS_PER_LONG - 1 - j)))\n       break;\n@@ -2114,7 +2114,7 @@ round_for_format (fmt, r)\n     }\n \n   /* There are P2 true significand bits, followed by one guard bit,\n-     followed by one sticky bit, followed by stuff.  Fold non-zero\n+     followed by one sticky bit, followed by stuff.  Fold nonzero\n      stuff into the sticky bit.  */\n \n   sticky = 0;"}, {"sha": "6b6117fa5c5ecb59bff972c5e76c6c5c406320fe", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -191,7 +191,7 @@ static int num_changes = 0;\n    an INSN, CALL_INSN, or JUMP_INSN, the insn will be re-recognized with\n    the change in place.\n \n-   IN_GROUP is non-zero if this is part of a group of changes that must be\n+   IN_GROUP is nonzero if this is part of a group of changes that must be\n    performed as a group.  In that case, the changes will be stored.  The\n    function `apply_change_group' will validate and apply the changes.\n \n@@ -856,7 +856,7 @@ find_single_use_1 (dest, loc)\n    sequel.  If so, return a pointer to the innermost rtx expression in which\n    it is used.\n \n-   If PLOC is non-zero, *PLOC is set to the insn containing the single use.\n+   If PLOC is nonzero, *PLOC is set to the insn containing the single use.\n \n    This routine will return usually zero either before flow is called (because\n    there will be no LOG_LINKS notes) or after reload (because the REG_DEAD\n@@ -2341,7 +2341,7 @@ preprocess_constraints ()\n    This is used in final, just before printing the assembler code and by\n    the routines that determine an insn's attribute.\n \n-   If STRICT is a positive non-zero value, it means that we have been\n+   If STRICT is a positive nonzero value, it means that we have been\n    called after reload has been completed.  In that case, we must\n    do all checks strictly.  If it is zero, it means that we have been called\n    before reload has completed.  In that case, we first try to see if we can"}, {"sha": "eafc1e4df802778f0a50e7976f988c1f459c5981", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -268,7 +268,7 @@ static rtx next_flags_user \t\tPARAMS ((rtx));\n static void record_label_references\tPARAMS ((rtx, rtx));\n static bool compensate_edge\t\tPARAMS ((edge, FILE *));\n \f\n-/* Return non-zero if any stack register is mentioned somewhere within PAT.  */\n+/* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n \n static int\n stack_regs_mentioned_p (pat)"}, {"sha": "e229826d7fce3397712b16287638360d740f1381", "filename": "gcc/regclass.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -220,7 +220,7 @@ static int may_move_out_cost[MAX_MACHINE_MODE][N_REG_CLASSES][N_REG_CLASSES];\n \n static int forbidden_inc_dec_class[N_REG_CLASSES];\n \n-/* Indexed by n, is non-zero if (REG n) is used in an auto-inc or auto-dec\n+/* Indexed by n, is nonzero if (REG n) is used in an auto-inc or auto-dec\n    context.  */\n \n static char *in_inc_dec;\n@@ -254,7 +254,7 @@ struct reg_info_data {\n   struct reg_info_data *next;\t/* next set of reg_info structures */\n   size_t min_index;\t\t/* minimum index # */\n   size_t max_index;\t\t/* maximum index # */\n-  char used_p;\t\t\t/* non-zero if this has been used previously */\n+  char used_p;\t\t\t/* nonzero if this has been used previously */\n   reg_info data[1];\t\t/* beginning of the reg_info data */\n };\n \n@@ -1904,7 +1904,7 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t}\n }\n \f\n-/* Compute the cost of loading X into (if TO_P is non-zero) or from (if\n+/* Compute the cost of loading X into (if TO_P is nonzero) or from (if\n    TO_P is zero) a register of class CLASS in mode MODE.\n \n    X must not be a pseudo.  */"}, {"sha": "7853e041f89c2b4eca7f0fa9095c4263d52887f8", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -80,7 +80,7 @@ static int regclass_compatible_p PARAMS ((int, int));\n static int replacement_quality PARAMS ((rtx));\n static int fixup_match_2 PARAMS ((rtx, rtx, rtx, rtx, FILE *));\n \n-/* Return non-zero if registers with CLASS1 and CLASS2 can be merged without\n+/* Return nonzero if registers with CLASS1 and CLASS2 can be merged without\n    causing too much register allocation problems.  */\n static int\n regclass_compatible_p (class0, class1)"}, {"sha": "ba5d075a988df4d3a3f45d7d3398bb0657b589ec", "filename": "gcc/reload.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -276,7 +276,7 @@ static int find_inc_amount\tPARAMS ((rtx, rtx));\n #ifdef HAVE_SECONDARY_RELOADS\n \n /* Determine if any secondary reloads are needed for loading (if IN_P is\n-   non-zero) or storing (if IN_P is zero) X to or from a reload register of\n+   nonzero) or storing (if IN_P is zero) X to or from a reload register of\n    register class RELOAD_CLASS in mode RELOAD_MODE.  If secondary reloads\n    are needed, push them.\n \n@@ -368,7 +368,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \n   if (icode != CODE_FOR_nothing)\n     {\n-      /* If IN_P is non-zero, the reload register will be the output in\n+      /* If IN_P is nonzero, the reload register will be the output in\n \t operand 0.  If IN_P is zero, the reload register will be the input\n \t in operand 1.  Outputs should have an initial \"=\", which we must\n \t skip.  */\n@@ -836,7 +836,7 @@ reload_inner_reg_of_subreg (x, mode)\n    (IN is zero for data not read, and OUT is zero for data not written.)\n    INLOC and OUTLOC point to the places in the instructions where\n    IN and OUT were found.\n-   If IN and OUT are both non-zero, it means the same register must be used\n+   If IN and OUT are both nonzero, it means the same register must be used\n    to reload both IN and OUT.\n \n    CLASS is a register class required for the reloaded data.\n@@ -1601,7 +1601,7 @@ transfer_replacements (to, from)\n /* IN_RTX is the value loaded by a reload that we now decided to inherit,\n    or a subpart of it.  If we have any replacements registered for IN_RTX,\n    cancel the reloads that were supposed to load them.\n-   Return non-zero if we canceled any reloads.  */\n+   Return nonzero if we canceled any reloads.  */\n int\n remove_address_replacements (in_rtx)\n      rtx in_rtx;\n@@ -1840,7 +1840,7 @@ combine_reloads ()\n    If FOR_REAL is -1, this should not be done, because this call\n    is just to see if a register can be found, not to find and install it.\n \n-   EARLYCLOBBER is non-zero if OUT is an earlyclobber operand.  This\n+   EARLYCLOBBER is nonzero if OUT is an earlyclobber operand.  This\n    puts an additional constraint on being able to use IN for OUT since\n    IN must not appear elsewhere in the insn (it is assumed that IN itself\n    is safe from the earlyclobber).  */"}, {"sha": "0463224591245a50c771b457f94188ad4575b577", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -270,7 +270,7 @@ extern void transfer_replacements PARAMS ((int, int));\n /* IN_RTX is the value loaded by a reload that we now decided to inherit,\n    or a subpart of it.  If we have any replacements registered for IN_RTX,\n    chancel the reloads that were supposed to load them.\n-   Return non-zero if we chanceled any reloads.  */\n+   Return nonzero if we chanceled any reloads.  */\n extern int remove_address_replacements PARAMS ((rtx in_rtx));\n \n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match"}, {"sha": "726a4bfcd15e90af3332ac11d3c6c339d5eb5580", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -340,7 +340,7 @@ static const struct elim_table_1\n #define NUM_ELIMINABLE_REGS ARRAY_SIZE (reg_eliminate_1)\n \n /* Record the number of pending eliminations that have an offset not equal\n-   to their initial offset.  If non-zero, we use a new copy of each\n+   to their initial offset.  If nonzero, we use a new copy of each\n    replacement result in any insns encountered.  */\n int num_not_at_initial_offset;\n \n@@ -2118,7 +2118,7 @@ mark_home_live (regno)\n \n    INSN is the insn that it came from, if any.\n \n-   INITIAL_P is non-zero if we are to set the offset to be the initial\n+   INITIAL_P is nonzero if we are to set the offset to be the initial\n    offset and zero if we are setting the offset of the label to be the\n    current offset.  */\n \n@@ -2273,7 +2273,7 @@ set_label_offsets (x, insn, initial_p)\n    to record the fact that a register is referenced outside a MEM.\n \n    If INSN is an insn, it is the insn containing X.  If we replace a REG\n-   in a SET_DEST with an equivalent MEM and INSN is non-zero, write a\n+   in a SET_DEST with an equivalent MEM and INSN is nonzero, write a\n    CLOBBER of the pseudo after INSN so find_equiv_regs will know that\n    the REG is being modified.\n \n@@ -4752,7 +4752,7 @@ char reload_inherited[MAX_RELOADS];\n    if we know it.  Otherwise, this is 0.  */\n rtx reload_inheritance_insn[MAX_RELOADS];\n \n-/* If non-zero, this is a place to get the value of the reload,\n+/* If nonzero, this is a place to get the value of the reload,\n    rather than using reload_in.  */\n rtx reload_override_in[MAX_RELOADS];\n \n@@ -4993,7 +4993,7 @@ reload_reg_free_for_value_p (start_regno, regno, opnum, type, value, out,\n    determine how many hard regs to test.\n \n    Other read-only reloads with the same value do not conflict\n-   unless OUT is non-zero and these other reloads have to live while\n+   unless OUT is nonzero and these other reloads have to live while\n    output reloads live.\n    If OUT is CONST0_RTX, this is a special case: it means that the\n    test should not be for using register REGNO as reload register, but\n@@ -5116,7 +5116,7 @@ set_reload_reg (i, r)\n }\n \n /* Find a spill register to use as a reload register for reload R.\n-   LAST_RELOAD is non-zero if this is the last reload for the insn being\n+   LAST_RELOAD is nonzero if this is the last reload for the insn being\n    processed.\n \n    Set rld[R].reg_rtx to the register allocated.\n@@ -6009,7 +6009,7 @@ deallocate_reload_reg (r)\n   reload_spill_index[r] = -1;\n }\n \f\n-/* If SMALL_REGISTER_CLASSES is non-zero, we may not have merged two\n+/* If SMALL_REGISTER_CLASSES is nonzero, we may not have merged two\n    reloads of the same item for fear that we might not have enough reload\n    registers. However, normally they will get the same reload register\n    and hence actually need not be loaded twice.\n@@ -7922,7 +7922,7 @@ inc_for_reload (reloadreg, in, value, inc_amount)\n   rtx real_in = in == value ? XEXP (in, 0) : in;\n \n   /* No hard register is equivalent to this register after\n-     inc/dec operation.  If REG_LAST_RELOAD_REG were non-zero,\n+     inc/dec operation.  If REG_LAST_RELOAD_REG were nonzero,\n      we could inc/dec that register as well (maybe even using it for\n      the source), but I'm not sure it's worth worrying about.  */\n   if (GET_CODE (incloc) == REG)"}, {"sha": "31918ec43e30bd5b9c144ea6e7e708980e6a1203", "filename": "gcc/reorg.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -928,7 +928,7 @@ rare_destination (insn)\n    taken, return 1.  If the branch is slightly less likely to be taken,\n    return 0 and if the branch is highly unlikely to be taken, return -1.\n \n-   CONDITION, if non-zero, is the condition that JUMP_INSN is testing.  */\n+   CONDITION, if nonzero, is the condition that JUMP_INSN is testing.  */\n \n static int\n mostly_true_jump (jump_insn, condition)\n@@ -1098,7 +1098,7 @@ get_branch_condition (insn, target)\n   return 0;\n }\n \n-/* Return non-zero if CONDITION is more strict than the condition of\n+/* Return nonzero if CONDITION is more strict than the condition of\n    INSN, i.e., if INSN will always branch if CONDITION is true.  */\n \n static int\n@@ -1126,7 +1126,7 @@ condition_dominates_p (condition, insn)\n   return comparison_dominates_p (code, other_code);\n }\n \n-/* Return non-zero if redirecting JUMP to NEWLABEL does not invalidate\n+/* Return nonzero if redirecting JUMP to NEWLABEL does not invalidate\n    any insns already in the delay slot of JUMP.  */\n \n static int\n@@ -1138,7 +1138,7 @@ redirect_with_delay_slots_safe_p (jump, newlabel, seq)\n \n   /* Make sure all the delay slots of this jump would still\n      be valid after threading the jump.  If they are still\n-     valid, then return non-zero.  */\n+     valid, then return nonzero.  */\n \n   flags = get_jump_flags (jump, newlabel);\n   for (i = 1; i < XVECLEN (pat, 0); i++)\n@@ -1161,7 +1161,7 @@ redirect_with_delay_slots_safe_p (jump, newlabel, seq)\n   return (i == XVECLEN (pat, 0));\n }\n \n-/* Return non-zero if redirecting JUMP to NEWLABEL does not invalidate\n+/* Return nonzero if redirecting JUMP to NEWLABEL does not invalidate\n    any insns we wish to place in the delay slot of JUMP.  */\n \n static int\n@@ -1173,7 +1173,7 @@ redirect_with_delay_list_safe_p (jump, newlabel, delay_list)\n \n   /* Make sure all the insns in DELAY_LIST would still be\n      valid after threading the jump.  If they are still\n-     valid, then return non-zero.  */\n+     valid, then return nonzero.  */\n \n   flags = get_jump_flags (jump, newlabel);\n   for (li = delay_list, i = 0; li; li = XEXP (li, 1), i++)\n@@ -1233,9 +1233,9 @@ check_annul_list_true_false (annul_true_p, delay_list)\n    insns in DELAY_LIST).  It is updated with the number that have been\n    filled from the SEQUENCE, if any.\n \n-   PANNUL_P points to a non-zero value if we already know that we need\n+   PANNUL_P points to a nonzero value if we already know that we need\n    to annul INSN.  If this routine determines that annulling is needed,\n-   it may set that value non-zero.\n+   it may set that value nonzero.\n \n    PNEW_THREAD points to a location that is to receive the place at which\n    execution should continue.  */\n@@ -1856,9 +1856,9 @@ redundant_insn (insn, target, delay_list)\n   return 0;\n }\n \f\n-/* Return 1 if THREAD can only be executed in one way.  If LABEL is non-zero,\n+/* Return 1 if THREAD can only be executed in one way.  If LABEL is nonzero,\n    it is the target of the branch insn being scanned.  If ALLOW_FALLTHROUGH\n-   is non-zero, we are allowed to fall into this thread; otherwise, we are\n+   is nonzero, we are allowed to fall into this thread; otherwise, we are\n    not.\n \n    If LABEL is used more than one or we pass a label other than LABEL before\n@@ -2040,7 +2040,7 @@ update_reg_unused_notes (insn, redundant_insn)\n /* Scan a function looking for insns that need a delay slot and find insns to\n    put into the delay slot.\n \n-   NON_JUMPS_P is non-zero if we are to only try to fill non-jump insns (such\n+   NON_JUMPS_P is nonzero if we are to only try to fill non-jump insns (such\n    as calls).  We do these first since we don't want jump insns (that are\n    easier to fill) to get the only insns that could be used for non-jump insns.\n    When it is zero, only try to fill JUMP_INSNs.\n@@ -2543,7 +2543,7 @@ fill_simple_delay_slots (non_jumps_p)\n    OPPOSITE_THREAD is the thread in the opposite direction.  It is used\n    to see if any potential delay slot insns set things needed there.\n \n-   LIKELY is non-zero if it is extremely likely that the branch will be\n+   LIKELY is nonzero if it is extremely likely that the branch will be\n    taken and THREAD_IF_TRUE is set.  This is used for the branch at the\n    end of a loop back up to the top.\n "}, {"sha": "a72dd9ce1a4fec4d9ccec9e3ba183faa9381c03e", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -372,7 +372,7 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \t     We assume that they both use and set all registers.  Using all\n \t     registers ensures that a register will not be considered dead\n \t     just because it crosses a setjmp call.  A register should be\n-\t     considered dead only if the setjmp call returns non-zero.  */\n+\t     considered dead only if the setjmp call returns nonzero.  */\n \t  if (find_reg_note (x, REG_SETJMP, NULL))\n \t    SET_HARD_REG_SET (res->regs);\n \n@@ -1178,7 +1178,7 @@ init_resource_info (epilogue_insn)\n   /* Indicate what resources are required to be valid at the end of the current\n      function.  The condition code never is and memory always is.  If the\n      frame pointer is needed, it is and so is the stack pointer unless\n-     EXIT_IGNORE_STACK is non-zero.  If the frame pointer is not needed, the\n+     EXIT_IGNORE_STACK is nonzero.  If the frame pointer is not needed, the\n      stack pointer is.  Registers used to return the function value are\n      needed.  Registers holding global variables are needed.  */\n "}, {"sha": "e2afd90ad43b65e3cd72a1142457b1937217d6cf", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -1103,7 +1103,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define MEM_SCALAR_P(RTX)\t\t\t\t\t\t\\\n   (RTL_FLAG_CHECK1(\"MEM_SCALAR_P\", (RTX), MEM)->frame_related)\n \n-/* If VAL is non-zero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n+/* If VAL is nonzero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n    RTX.  Otherwise, vice versa.  Use this macro only when you are\n    *sure* that you know that the MEM is in a structure, or is a\n    scalar.  VAL is evaluated only once.  */"}, {"sha": "c992c439bc3fbabbcd1297c9f873b06b5b700186", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f03658801b3fb690d689bf46576688f5382075/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f03658801b3fb690d689bf46576688f5382075/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=40f03658801b3fb690d689bf46576688f5382075", "patch": "@@ -353,7 +353,7 @@ get_related_value (x)\n    into the jump table.  If the offset cannot be determined, then return\n    NULL_RTX.\n \n-   If EARLIEST is non-zero, it is a pointer to a place where the earliest\n+   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n    insn used in locating the offset was found.  */\n \n rtx\n@@ -541,7 +541,7 @@ global_reg_mentioned_p_1 (loc, data)\n   return 0;\n }\n \n-/* Returns non-zero if X mentions a global register.  */\n+/* Returns nonzero if X mentions a global register.  */\n \n int\n global_reg_mentioned_p (x)\n@@ -2786,7 +2786,7 @@ computed_jump_p (insn)\n    sub-expression (including X itself).  F is also passed the DATA.\n    If F returns -1, do not traverse sub-expressions, but continue\n    traversing the rest of the tree.  If F ever returns any other\n-   non-zero value, stop the traversal, and return the value returned\n+   nonzero value, stop the traversal, and return the value returned\n    by F.  Otherwise, return 0.  This function does not traverse inside\n    tree structure that contains RTX_EXPRs, or into sub-expressions\n    whose format code is `0' since it is not known whether or not those\n@@ -3039,7 +3039,7 @@ insns_safe_to_move_p (from, to, new_to)\n   return 0;\n }\n \n-/* Return non-zero if IN contains a piece of rtl that has the address LOC */\n+/* Return nonzero if IN contains a piece of rtl that has the address LOC */\n int\n loc_mentioned_in_p (loc, in)\n      rtx *loc, in;"}]}