{"sha": "5bb77598866d730419f52a846b3bf9d7412aba2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJiNzc1OTg4NjZkNzMwNDE5ZjUyYTg0NmIzYmY5ZDc0MTJhYmEyYQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2008-06-30T18:00:42Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2008-06-30T18:00:42Z"}, "message": "i386.c (contains_aligned_value_p): Return true for __float128.\n\n2008-06-30  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386.c (contains_aligned_value_p): Return true\n\tfor __float128.\n\t(ix86_function_arg_boundary): Return its natural boundary for\n\tfor __float128.\n\t(return_in_memory_32): Don't check TDmode.\n\t(ix86_split_to_parts): Support splitting into 4 parts and\n\tsupport TFmode for 32bit target.\n\t(ix86_split_long_move): Support splitting into 4 parts.\n\t(bdesc_args): Enable IX86_BUILTIN_FABSQ and IX86_BUILTIN_COPYSIGNQ\n\tfor SSE2.\n\t(ix86_init_mmx_sse_builtins): Move __float80 and __float128\n\tto ...\n\t(ix86_init_builtins): Here.\n\t(ix86_scalar_mode_supported_p): Always return true for TFmode.\n\t(ix86_c_mode_for_suffix): Always return TFmode and XFmode for\n\t'q' and 'w', respectively. \n\n\t* config/i386/i386.md (movtf): Check TARGET_SSE2 instead of\n\tTARGET_64BIT.\n\t(movtf_internal): Likewise.\n\t(<code>tf2): Likewise.\n\t(*absnegtf2_sse): Likewise.\n\t(copysign<mode>3): Likewise.\n\t(copysign<mode>3_const): Likewise.\n\t(copysign<mode>3_var): Likewise.\n\t(define_split UNSPEC_COPYSIGN): Likewise.\n\t* config/i386/sse.md (*nandtf3): Likewise.\n\t(<code>tf3): Likewise.\n\t(*<code>tf3): Likewise.\n\nFrom-SVN: r137276", "tree": {"sha": "bd29adf39875f0bab15c7e7a497bdbb22e5820ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd29adf39875f0bab15c7e7a497bdbb22e5820ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bb77598866d730419f52a846b3bf9d7412aba2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb77598866d730419f52a846b3bf9d7412aba2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb77598866d730419f52a846b3bf9d7412aba2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb77598866d730419f52a846b3bf9d7412aba2a/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38aa4d08b72826276844708d538e5e610d65f0b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38aa4d08b72826276844708d538e5e610d65f0b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38aa4d08b72826276844708d538e5e610d65f0b2"}], "stats": {"total": 331, "additions": 177, "deletions": 154}, "files": [{"sha": "ed06103f65ebb9a1c18d641e89140f0ca0085a2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5bb77598866d730419f52a846b3bf9d7412aba2a", "patch": "@@ -1,3 +1,35 @@\n+2008-06-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386.c (contains_aligned_value_p): Return true\n+\tfor __float128.\n+\t(ix86_function_arg_boundary): Return its natural boundary for\n+\tfor __float128.\n+\t(return_in_memory_32): Don't check TDmode.\n+\t(ix86_split_to_parts): Support splitting into 4 parts and\n+\tsupport TFmode for 32bit target.\n+\t(ix86_split_long_move): Support splitting into 4 parts.\n+\t(bdesc_args): Enable IX86_BUILTIN_FABSQ and IX86_BUILTIN_COPYSIGNQ\n+\tfor SSE2.\n+\t(ix86_init_mmx_sse_builtins): Move __float80 and __float128\n+\tto ...\n+\t(ix86_init_builtins): Here.\n+\t(ix86_scalar_mode_supported_p): Always return true for TFmode.\n+\t(ix86_c_mode_for_suffix): Always return TFmode and XFmode for\n+\t'q' and 'w', respectively. \n+\n+\t* config/i386/i386.md (movtf): Check TARGET_SSE2 instead of\n+\tTARGET_64BIT.\n+\t(movtf_internal): Likewise.\n+\t(<code>tf2): Likewise.\n+\t(*absnegtf2_sse): Likewise.\n+\t(copysign<mode>3): Likewise.\n+\t(copysign<mode>3_const): Likewise.\n+\t(copysign<mode>3_var): Likewise.\n+\t(define_split UNSPEC_COPYSIGN): Likewise.\n+\t* config/i386/sse.md (*nandtf3): Likewise.\n+\t(<code>tf3): Likewise.\n+\t(*<code>tf3): Likewise.\n+\n 2008-06-30  Joey Ye  <joey.ye@intel.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "2edeec01c58a98b6cbdf502c9a99203931015cb6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 134, "deletions": 143, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5bb77598866d730419f52a846b3bf9d7412aba2a", "patch": "@@ -4744,7 +4744,9 @@ static bool\n contains_aligned_value_p (tree type)\n {\n   enum machine_mode mode = TYPE_MODE (type);\n-  if (((TARGET_SSE && SSE_REG_MODE_P (mode)) || mode == TDmode)\n+  if (((TARGET_SSE && SSE_REG_MODE_P (mode))\n+       || mode == TDmode\n+       || mode == TFmode)\n       && (!TYPE_USER_ALIGN (type) || TYPE_ALIGN (type) > 128))\n     return true;\n   if (TYPE_ALIGN (type) < 128)\n@@ -4803,8 +4805,9 @@ ix86_function_arg_boundary (enum machine_mode mode, tree type)\n     align = GET_MODE_ALIGNMENT (mode);\n   if (align < PARM_BOUNDARY)\n     align = PARM_BOUNDARY;\n-  /* In 32bit, only _Decimal128 is aligned to its natural boundary.  */\n-  if (!TARGET_64BIT && mode != TDmode)\n+  /* In 32bit, only _Decimal128 and __float128 are aligned to their\n+     natural boundaries.  */\n+  if (!TARGET_64BIT && mode != TDmode && mode != TFmode)\n     {\n       /* i386 ABI defines all arguments to be 4 byte aligned.  We have to\n \t make an exception for SSE modes since these require 128bit\n@@ -4815,7 +4818,7 @@ ix86_function_arg_boundary (enum machine_mode mode, tree type)\n \t to 8 byte boundaries.  */\n       if (!type)\n \t{\n-\t  if (!(TARGET_SSE && SSE_REG_MODE_P (mode)) && mode != TDmode)\n+\t  if (!(TARGET_SSE && SSE_REG_MODE_P (mode)))\n \t    align = PARM_BOUNDARY;\n \t}\n       else\n@@ -5041,9 +5044,6 @@ return_in_memory_32 (const_tree type, enum machine_mode mode)\n   if (mode == XFmode)\n     return 0;\n \n-  if (mode == TDmode)\n-    return 1;\n-\n   if (size > 12)\n     return 1;\n   return 0;\n@@ -14122,7 +14122,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n     size = (GET_MODE_SIZE (mode) + 4) / 8;\n \n   gcc_assert (!REG_P (operand) || !MMX_REGNO_P (REGNO (operand)));\n-  gcc_assert (size >= 2 && size <= 3);\n+  gcc_assert (size >= 2 && size <= 4);\n \n   /* Optimize constant pool reference to immediates.  This is used by fp\n      moves, that force all constants to memory to allow combining.  */\n@@ -14142,7 +14142,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \n       operand = copy_rtx (operand);\n       PUT_MODE (operand, Pmode);\n-      parts[0] = parts[1] = parts[2] = operand;\n+      parts[0] = parts[1] = parts[2] = parts[3] = operand;\n       return size;\n     }\n \n@@ -14163,21 +14163,20 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \tsplit_di (&operand, 1, &parts[0], &parts[1]);\n       else\n \t{\n+\t  int i;\n+\n \t  if (REG_P (operand))\n \t    {\n \t      gcc_assert (reload_completed);\n-\t      parts[0] = gen_rtx_REG (SImode, REGNO (operand) + 0);\n-\t      parts[1] = gen_rtx_REG (SImode, REGNO (operand) + 1);\n-\t      if (size == 3)\n-\t\tparts[2] = gen_rtx_REG (SImode, REGNO (operand) + 2);\n+\t      for (i = 0; i < size; i++)\n+\t\tparts[i] = gen_rtx_REG (SImode, REGNO (operand) + i);\n \t    }\n \t  else if (offsettable_memref_p (operand))\n \t    {\n \t      operand = adjust_address (operand, SImode, 0);\n \t      parts[0] = operand;\n-\t      parts[1] = adjust_address (operand, SImode, 4);\n-\t      if (size == 3)\n-\t\tparts[2] = adjust_address (operand, SImode, 8);\n+\t      for (i = 1; i < size; i++)\n+\t\tparts[i] = adjust_address (operand, SImode, 4 * i);\n \t    }\n \t  else if (GET_CODE (operand) == CONST_DOUBLE)\n \t    {\n@@ -14187,6 +14186,11 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \t      REAL_VALUE_FROM_CONST_DOUBLE (r, operand);\n \t      switch (mode)\n \t\t{\n+\t\tcase TFmode:\n+\t\t  real_to_target (l, &r, mode);\n+\t\t  parts[3] = gen_int_mode (l[3], SImode);\n+\t\t  parts[2] = gen_int_mode (l[2], SImode);\n+\t\t  break;\n \t\tcase XFmode:\n \t\t  REAL_VALUE_TO_TARGET_LONG_DOUBLE (r, l);\n \t\t  parts[2] = gen_int_mode (l[2], SImode);\n@@ -14260,19 +14264,20 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n   return size;\n }\n \n-/* Emit insns to perform a move or push of DI, DF, and XF values.\n+/* Emit insns to perform a move or push of DI, DF, XF, and TF values.\n    Return false when normal moves are needed; true when all required\n    insns have been emitted.  Operands 2-4 contain the input values\n    int the correct order; operands 5-7 contain the output values.  */\n \n void\n ix86_split_long_move (rtx operands[])\n {\n-  rtx part[2][3];\n-  int nparts;\n+  rtx part[2][4];\n+  int nparts, i, j;\n   int push = 0;\n   int collisions = 0;\n   enum machine_mode mode = GET_MODE (operands[0]);\n+  bool collisionparts[4];\n \n   /* The DFmode expanders may ask us to move double.\n      For 64bit target this is single move.  By hiding the fact\n@@ -14311,34 +14316,46 @@ ix86_split_long_move (rtx operands[])\n   /* When emitting push, take care for source operands on the stack.  */\n   if (push && MEM_P (operands[1])\n       && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n-    {\n-      if (nparts == 3)\n-\tpart[1][1] = change_address (part[1][1], GET_MODE (part[1][1]),\n-\t\t\t\t     XEXP (part[1][2], 0));\n-      part[1][0] = change_address (part[1][0], GET_MODE (part[1][0]),\n-\t\t\t\t   XEXP (part[1][1], 0));\n-    }\n+    for (i = 0; i < nparts - 1; i++)\n+      part[1][i] = change_address (part[1][i],\n+\t\t\t\t   GET_MODE (part[1][i]),\n+\t\t\t\t   XEXP (part[1][i + 1], 0));\n \n   /* We need to do copy in the right order in case an address register\n      of the source overlaps the destination.  */\n   if (REG_P (part[0][0]) && MEM_P (part[1][0]))\n     {\n-      if (reg_overlap_mentioned_p (part[0][0], XEXP (part[1][0], 0)))\n-\tcollisions++;\n-      if (reg_overlap_mentioned_p (part[0][1], XEXP (part[1][0], 0)))\n-\tcollisions++;\n-      if (nparts == 3\n-\t  && reg_overlap_mentioned_p (part[0][2], XEXP (part[1][0], 0)))\n-\tcollisions++;\n+      rtx tmp;\n+\n+      for (i = 0; i < nparts; i++)\n+\t{\n+\t  collisionparts[i]\n+\t    = reg_overlap_mentioned_p (part[0][i], XEXP (part[1][0], 0));\n+\t  if (collisionparts[i])\n+\t    collisions++;\n+\t}\n \n       /* Collision in the middle part can be handled by reordering.  */\n-      if (collisions == 1 && nparts == 3\n-\t  && reg_overlap_mentioned_p (part[0][1], XEXP (part[1][0], 0)))\n+      if (collisions == 1 && nparts == 3 && collisionparts [1])\n \t{\n-\t  rtx tmp;\n \t  tmp = part[0][1]; part[0][1] = part[0][2]; part[0][2] = tmp;\n \t  tmp = part[1][1]; part[1][1] = part[1][2]; part[1][2] = tmp;\n \t}\n+      else if (collisions == 1\n+\t       && nparts == 4\n+\t       && (collisionparts [1] || collisionparts [2]))\n+\t{\n+\t  if (collisionparts [1])\n+\t    {\n+\t      tmp = part[0][1]; part[0][1] = part[0][2]; part[0][2] = tmp;\n+\t      tmp = part[1][1]; part[1][1] = part[1][2]; part[1][2] = tmp;\n+\t    }\n+\t  else\n+\t    {\n+\t      tmp = part[0][2]; part[0][2] = part[0][3]; part[0][3] = tmp;\n+\t      tmp = part[1][2]; part[1][2] = part[1][3]; part[1][3] = tmp;\n+\t    }\n+\t}\n \n       /* If there are more collisions, we can't handle it by reordering.\n \t Do an lea to the last part and use only one colliding move.  */\n@@ -14357,11 +14374,11 @@ ix86_split_long_move (rtx operands[])\n \n \t  emit_insn (gen_rtx_SET (VOIDmode, base, XEXP (part[1][0], 0)));\n \t  part[1][0] = replace_equiv_address (part[1][0], base);\n-\t  part[1][1] = replace_equiv_address (part[1][1],\n-\t\t\t\t      plus_constant (base, UNITS_PER_WORD));\n-\t  if (nparts == 3)\n-\t    part[1][2] = replace_equiv_address (part[1][2],\n-\t\t\t\t      plus_constant (base, 8));\n+\t  for (i = 1; i < nparts; i++)\n+\t    {\n+\t      tmp = plus_constant (base, UNITS_PER_WORD * i);\n+\t      part[1][i] = replace_equiv_address (part[1][i], tmp);\n+\t    }\n \t}\n     }\n \n@@ -14375,6 +14392,11 @@ ix86_split_long_move (rtx operands[])\n                 emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (-4)));\n \t      emit_move_insn (part[0][2], part[1][2]);\n \t    }\n+\t  else if (nparts == 4)\n+\t    {\n+\t      emit_move_insn (part[0][3], part[1][3]);\n+\t      emit_move_insn (part[0][2], part[1][2]);\n+\t    }\n \t}\n       else\n \t{\n@@ -14412,77 +14434,42 @@ ix86_split_long_move (rtx operands[])\n        && REG_P (part[1][1])\n        && (REGNO (part[0][0]) == REGNO (part[1][1])\n \t   || (nparts == 3\n-\t       && REGNO (part[0][0]) == REGNO (part[1][2]))))\n+\t       && REGNO (part[0][0]) == REGNO (part[1][2]))\n+\t   || (nparts == 4\n+\t       && REGNO (part[0][0]) == REGNO (part[1][3]))))\n       || (collisions > 0\n \t  && reg_overlap_mentioned_p (part[0][0], XEXP (part[1][0], 0))))\n     {\n-      if (nparts == 3)\n-\t{\n-\t  operands[2] = part[0][2];\n-\t  operands[3] = part[0][1];\n-\t  operands[4] = part[0][0];\n-\t  operands[5] = part[1][2];\n-\t  operands[6] = part[1][1];\n-\t  operands[7] = part[1][0];\n-\t}\n-      else\n+      for (i = 0, j = nparts - 1; i < nparts; i++, j--)\n \t{\n-\t  operands[2] = part[0][1];\n-\t  operands[3] = part[0][0];\n-\t  operands[5] = part[1][1];\n-\t  operands[6] = part[1][0];\n+\t  operands[2 + i] = part[0][j];\n+\t  operands[6 + i] = part[1][j];\n \t}\n     }\n   else\n     {\n-      if (nparts == 3)\n-\t{\n-\t  operands[2] = part[0][0];\n-\t  operands[3] = part[0][1];\n-\t  operands[4] = part[0][2];\n-\t  operands[5] = part[1][0];\n-\t  operands[6] = part[1][1];\n-\t  operands[7] = part[1][2];\n-\t}\n-      else\n+      for (i = 0; i < nparts; i++)\n \t{\n-\t  operands[2] = part[0][0];\n-\t  operands[3] = part[0][1];\n-\t  operands[5] = part[1][0];\n-\t  operands[6] = part[1][1];\n+\t  operands[2 + i] = part[0][i];\n+\t  operands[6 + i] = part[1][i];\n \t}\n     }\n \n   /* If optimizing for size, attempt to locally unCSE nonzero constants.  */\n   if (optimize_size)\n     {\n-      if (CONST_INT_P (operands[5])\n-\t  && operands[5] != const0_rtx\n-\t  && REG_P (operands[2]))\n-\t{\n-\t  if (CONST_INT_P (operands[6])\n-\t      && INTVAL (operands[6]) == INTVAL (operands[5]))\n-\t    operands[6] = operands[2];\n-\n-\t  if (nparts == 3\n-\t      && CONST_INT_P (operands[7])\n-\t      && INTVAL (operands[7]) == INTVAL (operands[5]))\n-\t    operands[7] = operands[2];\n-\t}\n-\n-      if (nparts == 3\n-\t  && CONST_INT_P (operands[6])\n-\t  && operands[6] != const0_rtx\n-\t  && REG_P (operands[3])\n-\t  && CONST_INT_P (operands[7])\n-\t  && INTVAL (operands[7]) == INTVAL (operands[6]))\n-\toperands[7] = operands[3];\n+      for (j = 0; j < nparts - 1; j++)\n+\tif (CONST_INT_P (operands[6 + j])\n+\t    && operands[6 + j] != const0_rtx\n+\t    && REG_P (operands[2 + j]))\n+\t  for (i = j; i < nparts - 1; i++)\n+\t    if (CONST_INT_P (operands[7 + i])\n+\t\t&& INTVAL (operands[7 + i]) == INTVAL (operands[6 + j]))\n+\t      operands[7 + i] = operands[2 + j];\n     }\n \n-  emit_move_insn (operands[2], operands[5]);\n-  emit_move_insn (operands[3], operands[6]);\n-  if (nparts == 3)\n-    emit_move_insn (operands[4], operands[7]);\n+  for (i = 0; i < nparts; i++)\n+    emit_move_insn (operands[2 + i], operands[6 + i]);\n \n   return;\n }\n@@ -18674,6 +18661,9 @@ static const struct builtin_description bdesc_args[] =\n \n   { OPTION_MASK_ISA_SSE2, CODE_FOR_sse2_vmsqrtv2df2, \"__builtin_ia32_sqrtsd\", IX86_BUILTIN_SQRTSD, UNKNOWN, (int) V2DF_FTYPE_V2DF_VEC_MERGE },\n \n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_abstf2, 0, IX86_BUILTIN_FABSQ, UNKNOWN, (int) FLOAT128_FTYPE_FLOAT128 },\n+  { OPTION_MASK_ISA_SSE2, CODE_FOR_copysigntf3, 0, IX86_BUILTIN_COPYSIGNQ, UNKNOWN, (int) FLOAT128_FTYPE_FLOAT128_FLOAT128 },\n+\n   /* SSE2 MMX */\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_mmx_addv1di3, \"__builtin_ia32_paddq\", IX86_BUILTIN_PADDQ, UNKNOWN, (int) V1DI_FTYPE_V1DI_V1DI },\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_mmx_subv1di3, \"__builtin_ia32_psubq\", IX86_BUILTIN_PSUBQ, UNKNOWN, (int) V1DI_FTYPE_V1DI_V1DI },\n@@ -18799,10 +18789,6 @@ static const struct builtin_description bdesc_args[] =\n \n   /* PCLMUL */\n   { OPTION_MASK_ISA_SSE2, CODE_FOR_pclmulqdq, 0, IX86_BUILTIN_PCLMULQDQ128, UNKNOWN, (int) V2DI_FTYPE_V2DI_V2DI_INT },\n-\n-   /* 64bit */\n-  { OPTION_MASK_ISA_64BIT, CODE_FOR_abstf2, 0, IX86_BUILTIN_FABSQ, UNKNOWN, (int) FLOAT128_FTYPE_FLOAT128 },\n-  { OPTION_MASK_ISA_64BIT, CODE_FOR_copysigntf3, 0, IX86_BUILTIN_COPYSIGNQ, UNKNOWN, (int) FLOAT128_FTYPE_FLOAT128_FLOAT128 },\n };\n \n /* SSE5 */\n@@ -19600,47 +19586,6 @@ ix86_init_mmx_sse_builtins (void)\n \n   tree ftype;\n \n-  /* The __float80 type.  */\n-  if (TYPE_MODE (long_double_type_node) == XFmode)\n-    (*lang_hooks.types.register_builtin_type) (long_double_type_node,\n-\t\t\t\t\t       \"__float80\");\n-  else\n-    {\n-      /* The __float80 type.  */\n-      tree float80_type_node = make_node (REAL_TYPE);\n-\n-      TYPE_PRECISION (float80_type_node) = 80;\n-      layout_type (float80_type_node);\n-      (*lang_hooks.types.register_builtin_type) (float80_type_node,\n-\t\t\t\t\t\t \"__float80\");\n-    }\n-\n-  if (TARGET_64BIT)\n-    {\n-      tree float128_type_node = make_node (REAL_TYPE);\n-\n-      TYPE_PRECISION (float128_type_node) = 128;\n-      layout_type (float128_type_node);\n-      (*lang_hooks.types.register_builtin_type) (float128_type_node,\n-\t\t\t\t\t\t \"__float128\");\n-\n-      /* TFmode support builtins.  */\n-      ftype = build_function_type (float128_type_node,\n-\t\t\t\t   void_list_node);\n-      def_builtin (OPTION_MASK_ISA_64BIT, \"__builtin_infq\", ftype, IX86_BUILTIN_INFQ);\n-\n-      ftype = build_function_type_list (float128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n-\t\t\t\t\tNULL_TREE);\n-      def_builtin_const (OPTION_MASK_ISA_64BIT, \"__builtin_fabsq\", ftype, IX86_BUILTIN_FABSQ);\n-\n-      ftype = build_function_type_list (float128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n-\t\t\t\t\tfloat128_type_node,\n-\t\t\t\t\tNULL_TREE);\n-      def_builtin_const (OPTION_MASK_ISA_64BIT, \"__builtin_copysignq\", ftype, IX86_BUILTIN_COPYSIGNQ);\n-    }\n-\n   /* Add all special builtins with variable number of operands.  */\n   for (i = 0, d = bdesc_special_args;\n        i < ARRAY_SIZE (bdesc_special_args);\n@@ -20246,6 +20191,52 @@ ix86_init_mmx_sse_builtins (void)\n static void\n ix86_init_builtins (void)\n {\n+  tree float128_type_node = make_node (REAL_TYPE);\n+  tree ftype, decl;\n+\n+  /* The __float80 type.  */\n+  if (TYPE_MODE (long_double_type_node) == XFmode)\n+    (*lang_hooks.types.register_builtin_type) (long_double_type_node,\n+\t\t\t\t\t       \"__float80\");\n+  else\n+    {\n+      /* The __float80 type.  */\n+      tree float80_type_node = make_node (REAL_TYPE);\n+\n+      TYPE_PRECISION (float80_type_node) = 80;\n+      layout_type (float80_type_node);\n+      (*lang_hooks.types.register_builtin_type) (float80_type_node,\n+\t\t\t\t\t\t \"__float80\");\n+    }\n+\n+  /* The __float128 type.  */\n+  TYPE_PRECISION (float128_type_node) = 128;\n+  layout_type (float128_type_node);\n+  (*lang_hooks.types.register_builtin_type) (float128_type_node,\n+\t\t\t\t\t     \"__float128\");\n+\n+  /* TFmode support builtins.  */\n+  ftype = build_function_type (float128_type_node, void_list_node);\n+  decl = add_builtin_function (\"__builtin_infq\", ftype,\n+\t\t\t       IX86_BUILTIN_INFQ, BUILT_IN_MD,\n+\t\t\t       NULL, NULL_TREE);\n+  ix86_builtins[(int) IX86_BUILTIN_INFQ] = decl;\n+\n+  if (HOST_BITS_PER_WIDE_INT >= 64)\n+    {\n+      /* Those builtins need TImode to compile.  */\n+      ftype = build_function_type_list (float128_type_node,\n+\t\t\t\t\tfloat128_type_node,\n+\t\t\t\t\tNULL_TREE);\n+      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_fabsq\", ftype, IX86_BUILTIN_FABSQ);\n+\n+      ftype = build_function_type_list (float128_type_node,\n+\t\t\t\t\tfloat128_type_node,\n+\t\t\t\t\tfloat128_type_node,\n+\t\t\t\t\tNULL_TREE);\n+      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_copysignq\", ftype, IX86_BUILTIN_COPYSIGNQ);\n+    }\n+\n   if (TARGET_MMX)\n     ix86_init_mmx_sse_builtins ();\n }\n@@ -24702,7 +24693,7 @@ ix86_scalar_mode_supported_p (enum machine_mode mode)\n   if (DECIMAL_FLOAT_MODE_P (mode))\n     return true;\n   else if (mode == TFmode)\n-    return TARGET_64BIT;\n+    return true;\n   else\n     return default_scalar_mode_supported_p (mode);\n }\n@@ -24726,9 +24717,9 @@ ix86_vector_mode_supported_p (enum machine_mode mode)\n static enum machine_mode\n ix86_c_mode_for_suffix (char suffix)\n {\n-  if (TARGET_64BIT && suffix == 'q')\n+  if (suffix == 'q')\n     return TFmode;\n-  if (TARGET_MMX && suffix == 'w')\n+  if (suffix == 'w')\n     return XFmode;\n \n   return VOIDmode;"}, {"sha": "ed3c0d17b36dc75bd45d7852e85b6dea996aec21", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5bb77598866d730419f52a846b3bf9d7412aba2a", "patch": "@@ -3261,7 +3261,7 @@\n (define_expand \"movtf\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:TF 1 \"nonimmediate_operand\" \"\"))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_SSE2\"\n {\n   ix86_expand_move (TFmode, operands);\n   DONE;\n@@ -3270,7 +3270,7 @@\n (define_insn \"*movtf_internal\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,m,x,?r,?o\")\n \t(match_operand:TF 1 \"general_operand\" \"xm,x,C,roF,Fr\"))]\n-  \"TARGET_64BIT\n+  \"TARGET_SSE2\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (which_alternative)\n@@ -10348,7 +10348,7 @@\n (define_expand \"<code>tf2\"\n   [(set (match_operand:TF 0 \"register_operand\" \"\")\n \t(absneg:TF (match_operand:TF 1 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_SSE2\"\n   \"ix86_expand_fp_absneg_operator (<CODE>, TFmode, operands); DONE;\")\n \n (define_insn \"*absnegtf2_sse\"\n@@ -10357,7 +10357,7 @@\n \t  [(match_operand:TF 1 \"register_operand\" \"0,x\")]))\n    (use (match_operand:TF 2 \"nonimmediate_operand\" \"xm,0\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_SSE2\"\n   \"#\")\n \n ;; Splitters for fp abs and neg.\n@@ -10536,7 +10536,7 @@\n    (match_operand:CSGNMODE 1 \"nonmemory_operand\" \"\")\n    (match_operand:CSGNMODE 2 \"register_operand\" \"\")]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-   || (TARGET_64BIT && (<MODE>mode == TFmode))\"\n+   || (TARGET_SSE2 && (<MODE>mode == TFmode))\"\n {\n   ix86_expand_copysign (operands);\n   DONE;\n@@ -10550,7 +10550,7 @@\n \t   (match_operand:<CSGNVMODE> 3 \"nonimmediate_operand\" \"xm\")]\n \t  UNSPEC_COPYSIGN))]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-   || (TARGET_64BIT && (<MODE>mode == TFmode))\"\n+   || (TARGET_SSE2 && (<MODE>mode == TFmode))\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n@@ -10569,7 +10569,7 @@\n \t  UNSPEC_COPYSIGN))\n    (clobber (match_scratch:<CSGNVMODE> 1 \"=x,x,x,x,x\"))]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-   || (TARGET_64BIT && (<MODE>mode == TFmode))\"\n+   || (TARGET_SSE2 && (<MODE>mode == TFmode))\"\n   \"#\")\n \n (define_split\n@@ -10582,7 +10582,7 @@\n \t  UNSPEC_COPYSIGN))\n    (clobber (match_scratch:<CSGNVMODE> 1 \"\"))]\n   \"((SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-    || (TARGET_64BIT && (<MODE>mode == TFmode)))\n+    || (TARGET_SSE2 && (<MODE>mode == TFmode)))\n    && reload_completed\"\n   [(const_int 0)]\n {"}, {"sha": "84fb001cd632570161be2d1daf8f9f2e36cb805a", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb77598866d730419f52a846b3bf9d7412aba2a/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=5bb77598866d730419f52a846b3bf9d7412aba2a", "patch": "@@ -3895,7 +3895,7 @@\n \t(and:TF\n \t  (not:TF (match_operand:TF 1 \"register_operand\" \"0\"))\n \t  (match_operand:TF 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_SSE2\"\n   \"pandn\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_data16\" \"1\")\n@@ -3936,15 +3936,15 @@\n \t(plogic:TF\n \t  (match_operand:TF 1 \"nonimmediate_operand\" \"\")\n \t  (match_operand:TF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_SSE2\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, TFmode, operands);\")\n \n (define_insn \"*<code>tf3\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=x\")\n \t(plogic:TF\n \t  (match_operand:TF 1 \"nonimmediate_operand\" \"%0\")\n \t  (match_operand:TF 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, TFmode, operands)\"\n+  \"TARGET_SSE2 && ix86_binary_operator_ok (<CODE>, TFmode, operands)\"\n   \"p<plogicprefix>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_data16\" \"1\")"}]}