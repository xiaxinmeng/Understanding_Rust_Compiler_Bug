{"sha": "af0d16cdec59d270a017f82ac209c44dfa748ea3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYwZDE2Y2RlYzU5ZDI3MGEwMTdmODJhYzIwOWM0NGRmYTc0OGVhMw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-04-22T17:48:02Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-04-22T17:48:02Z"}, "message": "cppfiles.c (_cpp_pop_file_buffer): Return void.\n\n\t* cppfiles.c (_cpp_pop_file_buffer): Return void.  Move\n\tfile change and include code to _cpp_pop_buffer.\n\t* cpphash.h (struct pending_option): Predeclare.\n\t(struct cpp_reader): New member next_include_file.\n\t(_cpp_pop_file_buffer): Update.\n\t(_cpp_push_next_buffer): Update, rename.\n\t* cppinit.c (cpp_destroy): Free include chain and pending here.\n\t(cpp_finish_options): Simplify.\n\t(_cpp_push_next_buffer): Rename and clean up.\n\t* cpplib.c (cpp_pop_buffer): Move code from _cpp_pop_file_buffer.\n\tClarify.\n\t* cppmacro.c (cpp_scan_nooutput): Set return_at_eof here.\n\nFrom-SVN: r52621", "tree": {"sha": "0fc130b06a7d9e6cdc2502aaa5f671bb726c8773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fc130b06a7d9e6cdc2502aaa5f671bb726c8773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af0d16cdec59d270a017f82ac209c44dfa748ea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0d16cdec59d270a017f82ac209c44dfa748ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af0d16cdec59d270a017f82ac209c44dfa748ea3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0d16cdec59d270a017f82ac209c44dfa748ea3/comments", "author": null, "committer": null, "parents": [{"sha": "74b273d68f6a479fa9a563ff87ef3e9561408c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b273d68f6a479fa9a563ff87ef3e9561408c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b273d68f6a479fa9a563ff87ef3e9561408c2c"}], "stats": {"total": 158, "additions": 82, "deletions": 76}, "files": [{"sha": "8d9bb2cef5ed61d7b2adade99feead3871765d49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af0d16cdec59d270a017f82ac209c44dfa748ea3", "patch": "@@ -1,3 +1,18 @@\n+2002-04-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppfiles.c (_cpp_pop_file_buffer): Return void.  Move\n+\tfile change and include code to _cpp_pop_buffer.\n+\t* cpphash.h (struct pending_option): Predeclare.\n+\t(struct cpp_reader): New member next_include_file.\n+\t(_cpp_pop_file_buffer): Update.\n+\t(_cpp_push_next_buffer): Update, rename.\n+\t* cppinit.c (cpp_destroy): Free include chain and pending here.\n+\t(cpp_finish_options): Simplify.\n+\t(_cpp_push_next_buffer): Rename and clean up.\n+\t* cpplib.c (cpp_pop_buffer): Move code from _cpp_pop_file_buffer.\n+\tClarify.\n+\t* cppmacro.c (cpp_scan_nooutput): Set return_at_eof here.\n+\n 2002-04-22  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/altivec.h (vec_xor): Add variant for both args"}, {"sha": "7600523b0097791d1b4fe444a67386aceeb0808b", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=af0d16cdec59d270a017f82ac209c44dfa748ea3", "patch": "@@ -761,14 +761,12 @@ _cpp_read_file (pfile, fname)\n }\n \n /* Do appropriate cleanup when a file INC's buffer is popped off the\n-   input stack.  Push the next -include file, if any remain.  */\n-bool\n+   input stack.  */\n+void\n _cpp_pop_file_buffer (pfile, inc)\n      cpp_reader *pfile;\n      struct include_file *inc;\n {\n-  bool pushed = false;\n-\n   /* Record the inclusion-preventing macro, which could be NULL\n      meaning no controlling macro.  */\n   if (pfile->mi_valid && inc->cmacro == NULL)\n@@ -780,18 +778,6 @@ _cpp_pop_file_buffer (pfile, inc)\n   inc->refcnt--;\n   if (inc->refcnt == 0 && DO_NOT_REREAD (inc))\n     purge_cache (inc);\n-\n-  /* Don't generate a callback for popping the main file.  */\n-  if (pfile->buffer)\n-    {\n-      _cpp_do_file_change (pfile, LC_LEAVE, 0, 0, 0);\n-\n-      /* Finally, push the next -included file, if any.  */\n-      if (!pfile->buffer->prev)\n-\tpushed = _cpp_push_next_buffer (pfile);\n-    }\n-\n-  return pushed;\n }\n \n /* Returns the first place in the include chain to start searching for"}, {"sha": "773c3cc954f70b394bce7873aabd90ab5147901c", "filename": "gcc/cpphash.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=af0d16cdec59d270a017f82ac209c44dfa748ea3", "patch": "@@ -26,6 +26,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"hashtable.h\"\n \n struct directive;\t\t/* Deliberately incomplete.  */\n+struct pending_option;\n \n /* Test if a sign is valid within a preprocessing number.  */\n #define VALID_SIGN(c, prevc) \\\n@@ -250,6 +251,11 @@ struct cpp_reader\n   /* If in_directive, the directive if known.  */\n   const struct directive *directive;\n \n+  /* The next -include-d file; NULL if they all are done.  If it\n+     points to NULL, the last one is in progress, and\n+     _cpp_maybe_push_include_file has yet to restore the line map.  */\n+  struct pending_option **next_include_file;\n+\n   /* Multiple inlcude optimisation.  */\n   const cpp_hashnode *mi_cmacro;\n   const cpp_hashnode *mi_ind_cmacro;\n@@ -381,7 +387,7 @@ extern int _cpp_compare_file_date       PARAMS ((cpp_reader *,\n extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\n extern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));\n-extern bool _cpp_pop_file_buffer\tPARAMS ((cpp_reader *,\n+extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct include_file *));\n \n /* In cppexp.c */\n@@ -396,7 +402,7 @@ extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n extern void _cpp_init_tokenrun\t\tPARAMS ((tokenrun *, unsigned int));\n \n /* In cppinit.c.  */\n-extern bool _cpp_push_next_buffer\tPARAMS ((cpp_reader *));\n+extern void _cpp_maybe_push_include_file PARAMS ((cpp_reader *));\n \n /* In cpplib.c */\n extern int _cpp_test_assertion PARAMS ((cpp_reader *, int *));"}, {"sha": "c444f832fb325b5d8c5f6ef9ba022b6b50d158f8", "filename": "gcc/cppinit.c", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=af0d16cdec59d270a017f82ac209c44dfa748ea3", "patch": "@@ -554,6 +554,9 @@ cpp_destroy (pfile)\n   cpp_context *context, *contextn;\n   tokenrun *run, *runn;\n \n+  free_chain (CPP_OPTION (pfile, pending)->include_head);\n+  free (CPP_OPTION (pfile, pending));\n+\n   while (CPP_BUFFER (pfile) != NULL)\n     _cpp_pop_buffer (pfile);\n \n@@ -1014,65 +1017,44 @@ cpp_finish_options (pfile)\n       for (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)\n \t(*p->handler) (pfile, p->arg);\n \n-      /* Scan -imacros files after command line defines, but before\n-\t files given with -include.  */\n-      while ((p = CPP_OPTION (pfile, pending)->imacros_head) != NULL)\n-\t{\n-\t  if (push_include (pfile, p))\n-\t    {\n-\t      pfile->buffer->return_at_eof = true;\n-\t      cpp_scan_nooutput (pfile);\n-\t    }\n-\t  CPP_OPTION (pfile, pending)->imacros_head = p->next;\n-\t  free (p);\n-\t}\n+      /* Scan -imacros files after -D, -U, but before -include.\n+\t pfile->next_include_file is NULL, so _cpp_pop_buffer does not\n+\t push -include files.  */\n+      for (p = CPP_OPTION (pfile, pending)->imacros_head; p; p = p->next)\n+\tif (push_include (pfile, p))\n+\t  cpp_scan_nooutput (pfile);\n+\n+      pfile->next_include_file = &CPP_OPTION (pfile, pending)->include_head;\n+      _cpp_maybe_push_include_file (pfile);\n     }\n \n+  free_chain (CPP_OPTION (pfile, pending)->imacros_head);\n   free_chain (CPP_OPTION (pfile, pending)->directive_head);\n-  _cpp_push_next_buffer (pfile);\n }\n \n-/* Called to push the next buffer on the stack given by -include.  If\n-   there are none, free the pending structure and restore the line map\n-   for the main file.  */\n-bool\n-_cpp_push_next_buffer (pfile)\n+/* Push the next buffer on the stack given by -include, if any.  */\n+void\n+_cpp_maybe_push_include_file (pfile)\n      cpp_reader *pfile;\n {\n-  bool pushed = false;\n-\n-  /* This is't pretty; we'd rather not be relying on this as a boolean\n-     for reverting the line map.  Further, we only free the chains in\n-     this conditional, so an early call to cpp_finish / cpp_destroy\n-     will leak that memory.  */\n-  if (CPP_OPTION (pfile, pending)\n-      && CPP_OPTION (pfile, pending)->imacros_head == NULL)\n+  if (pfile->next_include_file)\n     {\n-      while (!pushed)\n-\t{\n-\t  struct pending_option *p = CPP_OPTION (pfile, pending)->include_head;\n-\n-\t  if (p == NULL)\n-\t    break;\n-\t  if (! CPP_OPTION (pfile, preprocessed))\n-\t    pushed = push_include (pfile, p);\n-\t  CPP_OPTION (pfile, pending)->include_head = p->next;\n-\t  free (p);\n-\t}\n+      struct pending_option *head = *pfile->next_include_file;\n+  \n+      while (head && !push_include (pfile, head))\n+\thead = head->next;\n \n-      if (!pushed)\n+      if (head)\n+\tpfile->next_include_file = &head->next;\n+      else\n \t{\n-\t  free (CPP_OPTION (pfile, pending));\n-\t  CPP_OPTION (pfile, pending) = NULL;\n-\n-\t  /* Restore the line map for the main file.  */\n-\t  if (! CPP_OPTION (pfile, preprocessed))\n-\t    _cpp_do_file_change (pfile, LC_RENAME,\n-\t\t\t\t pfile->line_maps.maps[0].to_file, 1, 0);\n+\t  /* All done; restore the line map from <command line>.  */\n+\t  _cpp_do_file_change (pfile, LC_RENAME,\n+\t\t\t       pfile->line_maps.maps[0].to_file, 1, 0);\n+\t  /* Don't come back here again.  */\n+\t  pfile->next_include_file = NULL;\n \t}\n     }\n-\n-  return pushed;\n }\n \n /* Use mkdeps.c to output dependency information.  */"}, {"sha": "712b9dfe478bf5e0bd11d2643262a75f1a750af5", "filename": "gcc/cpplib.c", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=af0d16cdec59d270a017f82ac209c44dfa748ea3", "patch": "@@ -1900,16 +1900,15 @@ cpp_push_buffer (pfile, buffer, len, from_stage3, return_at_eof)\n   return new;\n }\n \n-/* If called from do_line, pops a single buffer.  Otherwise pops all\n-   buffers until a real file is reached.  Generates appropriate\n-   call-backs.  */\n+/* Pops a single buffer, with a file change call-back if appropriate.\n+   Then pushes the next -include file, if any remain.  */\n void\n _cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n+  struct include_file *inc = buffer->inc;\n   struct if_stack *ifs;\n-  bool pushed = false;\n \n   /* Walk back up the conditional stack till we reach its level at\n      entry to this file, issuing error messages.  */\n@@ -1920,14 +1919,28 @@ _cpp_pop_buffer (pfile)\n   /* In case of a missing #endif.  */\n   pfile->state.skipping = 0;\n \n-  /* Update the reader's buffer before _cpp_do_file_change.  */\n+  /* _cpp_do_file_change expects pfile->buffer to be the new one.  */\n   pfile->buffer = buffer->prev;\n \n-  if (buffer->inc)\n-    pushed = _cpp_pop_file_buffer (pfile, buffer->inc);\n+  /* Free the buffer object now; we may want to push a new buffer\n+     in _cpp_push_next_include_file.  */\n+  obstack_free (&pfile->buffer_ob, buffer);\n \n-  if (!pushed)\n-    obstack_free (&pfile->buffer_ob, buffer);\n+  if (inc)\n+    {\n+      _cpp_pop_file_buffer (pfile, inc);\n+\n+      /* Don't generate a callback for popping the main file.  */\n+      if (pfile->buffer)\n+\t{\n+\t  _cpp_do_file_change (pfile, LC_LEAVE, 0, 0, 0);\n+\n+\t  /* If this is the main file, there may be some -include\n+\t     files left to push.  */\n+\t  if (!pfile->buffer->prev)\n+\t    _cpp_maybe_push_include_file (pfile);\n+\t}\n+    }\n }\n \n /* Enter all recognised directives in the hash table.  */"}, {"sha": "876506bbaad37cf290a3461c991ac5685dd4d8f0", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0d16cdec59d270a017f82ac209c44dfa748ea3/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=af0d16cdec59d270a017f82ac209c44dfa748ea3", "patch": "@@ -1074,12 +1074,16 @@ cpp_sys_macro_p (pfile)\n   return node && node->value.macro && node->value.macro->syshdr;\n }\n \n-/* Read each token in, until EOF.  Directives are transparently\n-   processed.  */\n+/* Read each token in, until end of the current file.  Directives are\n+   transparently processed.  */\n void\n cpp_scan_nooutput (pfile)\n      cpp_reader *pfile;\n {\n+  /* Request a CPP_EOF token at the end of this file, rather than\n+     transparently continuing with the including file.  */\n+  pfile->buffer->return_at_eof = true;\n+\n   while (cpp_get_token (pfile)->type != CPP_EOF)\n     ;\n }"}]}