{"sha": "32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJlZTdkMWQ4ZDAyNDVlYzM2YTNjODQyZjE3ZGEzMDNjZDg4YzI4Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-04-05T16:28:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-04-05T16:28:44Z"}, "message": "i386.c (function_arg): Return constm1_rtx for last argument.\n\n\n\t* i386.c (function_arg): Return constm1_rtx for last argument.\n\t(ix86_expand_prologue): Update gen_call calls.\n\t* i386.h (FUNCTION_BLOCK_PROFILER_EXIT): Likewise.\n\t* i386.md (call_pop): Likewise.\n\t(call): Second operand is VOIDmode.\n\t(call_0): Likewise; Support 64bits.\n\t(call_exp): New expander.\n\t(call_1): Get to the sync.\n\t(call_1_exp): New pattern.\n\t(call_value): Support 64bit.\n\t(call_value_exp): New pattern.\n\t(untyped_call): Update gen_call call.\n\t(call_value_pop): Disable for 64bit.\n\t(call_value_0_rex64): New pattern.\n\t(call_value_1_rex64): Likewise.\n\nFrom-SVN: r41120", "tree": {"sha": "b32d734b76fffe8e401c99134ca6ed4544a51e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b32d734b76fffe8e401c99134ca6ed4544a51e79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/comments", "author": null, "committer": null, "parents": [{"sha": "60e589efa8600560385309c556766cc5124ab7f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60e589efa8600560385309c556766cc5124ab7f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60e589efa8600560385309c556766cc5124ab7f9"}], "stats": {"total": 164, "additions": 147, "deletions": 17}, "files": [{"sha": "359435cc98048dcb824231ae79cfdd6405f9ac77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "patch": "@@ -1,3 +1,21 @@\n+Thu Apr  5 18:25:56 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (function_arg): Return constm1_rtx for last argument.\n+\t(ix86_expand_prologue): Update gen_call calls.\n+\t* i386.h (FUNCTION_BLOCK_PROFILER_EXIT): Likewise.\n+\t* i386.md (call_pop): Likewise.\n+\t(call): Second operand is VOIDmode.\n+\t(call_0): Likewise; Support 64bits.\n+\t(call_exp): New expander.\n+\t(call_1): Get to the sync.\n+\t(call_1_exp): New pattern.\n+\t(call_value): Support 64bit.\n+\t(call_value_exp): New pattern.\n+\t(untyped_call): Update gen_call call.\n+\t(call_value_pop): Disable for 64bit.\n+\t(call_value_0_rex64): New pattern.\n+\t(call_value_1_rex64): Likewise.\n+\n 2001-04-05  Bo Thorsen  <bo@suse.de>\n \n \t* i386.md: Don't allow \"builtin_setjmp_receiver\" for TARGET_64BIT."}, {"sha": "7d08309bd4fb34f49341dedaa95ecddc54a8a0be", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "patch": "@@ -1105,6 +1105,9 @@ function_arg (cum, mode, type, named)\n     (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n+  if (mode == VOIDmode)\n+    return constm1_rtx;\n+\n   switch (mode)\n     {\n       /* For now, pass fp/complex values on the stack.  */\n@@ -2510,7 +2513,7 @@ ix86_expand_prologue ()\n \n       sym = gen_rtx_MEM (FUNCTION_MODE,\n \t\t\t gen_rtx_SYMBOL_REF (Pmode, \"_alloca\"));\n-      insn = emit_call_insn (gen_call (sym, const0_rtx));\n+      insn = emit_call_insn (gen_call (sym, const0_rtx, constm1_rtx));\n \n       CALL_INSN_FUNCTION_USAGE (insn)\n \t= gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_USE (VOIDmode, arg0),\n@@ -6842,7 +6845,7 @@ ix86_split_to_parts (operand, parts, mode)\n \t      operand = change_address (operand, DImode, XEXP (operand, 0));\n \t      parts[0] = operand;\n \t      parts[1] = adj_offsettable_operand (operand, 8);\n-\t      parts[1] = change_address (parts[1], SImode, XEXP (operand, 0));\n+\t      parts[1] = change_address (parts[1], SImode, XEXP (parts[1], 0));\n \t    }\n \t  else if (GET_CODE (operand) == CONST_DOUBLE)\n \t    {"}, {"sha": "8ccf8911212990fe9261a67b49fab94b64b2093e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "patch": "@@ -1632,7 +1632,7 @@ typedef struct ix86_args {\n #define FUNCTION_BLOCK_PROFILER_EXIT\t\t\t\\\n emit_call_insn (gen_call (gen_rtx_MEM (QImode,\t\t\\\n   gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_trace_ret\")),\t\\\n-  const0_rtx))\n+  const0_rtx, constm1_rtx))\n \n /* The function `__bb_trace_func' is called in every basic block\n    and is not allowed to change the machine state. Saving (restoring)"}, {"sha": "51e0c9631a079207febd02401a35851e8f13530e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 123, "deletions": 14, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ee7d1d8d0245ec36a3c842f17da303cd88c28c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=32ee7d1d8d0245ec36a3c842f17da303cd88c28c", "patch": "@@ -7232,7 +7232,25 @@\n \t    (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=a\"))\n    (clobber (reg:CC 17))]\n-  \"!TARGET_64BIT\"\n+  \"\"\n+  \"mul{l}\\\\t%2\"\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"ppro_uops\" \"few\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"*umulsi3_highpart_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:DI (truncate:SI\n+\t  (lshiftrt:DI\n+\t    (mult:DI (zero_extend:DI\n+\t\t       (match_operand:SI 1 \"register_operand\" \"%a\"))\n+\t\t     (zero_extend:DI\n+\t\t       (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n+\t    (const_int 32)))))\n+   (clobber (match_scratch:SI 3 \"=a\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n   \"mul{l}\\\\t%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"ppro_uops\" \"few\")\n@@ -12716,7 +12734,7 @@\n {\n   if (operands[3] == const0_rtx)\n     {\n-      emit_insn (gen_call (operands[0], operands[1]));\n+      emit_insn (gen_call (operands[0], operands[1], constm1_rtx));\n       DONE;\n     }\n   /* Static functions and indirect calls don't need\n@@ -12770,7 +12788,7 @@\n \n (define_expand \"call\"\n   [(call (match_operand:QI 0 \"\" \"\")\n-\t (match_operand:SI 1 \"\" \"\"))]\n+\t (match_operand 2 \"\" \"\"))]\n   ;; Operand 1 not used on the i386.\n   \"\"\n   \"\n@@ -12781,13 +12799,29 @@\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF\n       && ! SYMBOL_REF_FLAG (XEXP (operands[0], 0)))\n     current_function_uses_pic_offset_table = 1;\n+\n   if (! call_insn_operand (XEXP (operands[0], 0), Pmode))\n     XEXP (operands[0], 0) = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  if (TARGET_64BIT && INTVAL (operands[2]) >= 0)\n+    {\n+      rtx insn;\n+      rtx reg = gen_rtx_REG (QImode, 0);\n+      emit_move_insn (reg, operands[2]);\n+      insn = emit_call_insn (gen_call_exp (operands[0], operands[2]));\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), reg);\n+      DONE;\n+    }\n }\")\n \n+(define_expand \"call_exp\"\n+  [(call (match_operand:QI 0 \"\" \"\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"\")\n+\n (define_insn \"*call_0\"\n-  [(call (mem:QI (match_operand:SI 0 \"constant_call_address_operand\" \"\"))\n-\t (match_operand:SI 1 \"\" \"\"))]\n+  [(call (mem:QI (match_operand 0 \"constant_call_address_operand\" \"\"))\n+\t (match_operand 1 \"\" \"\"))]\n   \"\"\n   \"*\n {\n@@ -12800,8 +12834,28 @@\n \n (define_insn \"*call_1\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"rsm\"))\n-\t (match_operand:SI 1 \"\" \"\"))]\n-  \"\"\n+\t (match_operand 1 \"\" \"\"))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  if (constant_call_address_operand (operands[0], QImode))\n+    {\n+      if (SIBLING_CALL_P (insn))\n+\treturn \\\"jmp\\\\t%P0\\\";\n+      else\n+\treturn \\\"call\\\\t%P0\\\";\n+    }\n+  if (SIBLING_CALL_P (insn))\n+    return \\\"jmp\\\\t%A0\\\";\n+  else\n+    return \\\"call\\\\t%A0\\\";\n+}\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"*call_1_rex64\"\n+  [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n+\t (match_operand 1 \"\" \"\"))]\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   if (constant_call_address_operand (operands[0], QImode))\n@@ -12833,7 +12887,8 @@\n {\n   if (operands[4] == const0_rtx)\n     {\n-      emit_insn (gen_call_value (operands[0], operands[1], operands[2]));\n+      emit_insn (gen_call_value (operands[0], operands[1], operands[2],\n+\t\t\t\t constm1_rtx));\n       DONE;\n     }\n   /* Static functions and indirect calls don't need\n@@ -12849,7 +12904,7 @@\n (define_expand \"call_value\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (match_operand:QI 1 \"\" \"\")\n-\t      (match_operand:SI 2 \"\" \"\")))]\n+\t      (match_operand:SI 3 \"\" \"\")))]\n   ;; Operand 2 not used on the i386.\n   \"\"\n   \"\n@@ -12862,8 +12917,25 @@\n     current_function_uses_pic_offset_table = 1;\n   if (! call_insn_operand (XEXP (operands[1], 0), Pmode))\n     XEXP (operands[1], 0) = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+  if (TARGET_64BIT && INTVAL (operands[3]) >= 0)\n+    {\n+      rtx insn;\n+      rtx reg = gen_rtx_REG (QImode, 0);\n+      emit_move_insn (reg, operands[3]);\n+      insn = emit_call_insn (gen_call_value_exp (operands[0], operands[1],\n+\t\t\t\t\t\t operands[3]));\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), reg);\n+      DONE;\n+    }\n }\")\n \n+(define_expand \"call_value_exp\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:QI 1 \"\" \"\")\n+\t      (match_operand:SI 2 \"\" \"\")))]\n+  \"\"\n+  \"\")\n+\n ;; Call subroutine returning any type.\n \n (define_expand \"untyped_call\"\n@@ -12883,8 +12955,10 @@\n \n   emit_call_insn (TARGET_80387\n                   ? gen_call_value (gen_rtx_REG (XCmode, FIRST_FLOAT_REG),\n-\t\t\t\t    operands[0], const0_rtx)\n-                  : gen_call (operands[0], const0_rtx));\n+\t\t\t\t    operands[0], const0_rtx,\n+\t\t\t\t    GEN_INT (SSE_REGPARM_MAX - 1))\n+                  : gen_call (operands[0], const0_rtx,\n+\t\t\t      GEN_INT (SSE_REGPARM_MAX - 1)));\n \n   for (i = 0; i < XVECLEN (operands[2], 0); i++)\n     {\n@@ -12975,7 +13049,7 @@\n \t\t   (plus:SI (match_operand:SI 1 \"symbolic_operand\" \"\")\n \t\t\t    (minus:SI (pc) (match_operand 2 \"\" \"\"))))] 1))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == LABEL_REF)\n@@ -16751,7 +16825,21 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"constant_call_address_operand\" \"\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  if (SIBLING_CALL_P (insn))\n+    return \\\"jmp\\\\t%P1\\\";\n+  else\n+    return \\\"call\\\\t%P1\\\";\n+}\"\n+  [(set_attr \"type\" \"callv\")])\n+\n+(define_insn \"*call_value_0_rex64\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))\n+\t      (match_operand:DI 2 \"const_int_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n   \"*\n {\n   if (SIBLING_CALL_P (insn))\n@@ -16765,7 +16853,28 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"rsm\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  if (constant_call_address_operand (operands[1], QImode))\n+    {\n+      if (SIBLING_CALL_P (insn))\n+\treturn \\\"jmp\\\\t%P1\\\";\n+      else\n+\treturn \\\"call\\\\t%P1\\\";\n+    }\n+  if (SIBLING_CALL_P (insn))\n+    return \\\"jmp\\\\t%*%1\\\";\n+  else\n+    return \\\"call\\\\t%*%1\\\";\n+}\"\n+  [(set_attr \"type\" \"callv\")])\n+\n+(define_insn \"*call_value_1_rex64\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rsm\"))\n+\t      (match_operand:DI 2 \"\" \"\")))]\n+  \"TARGET_64BIT\"\n   \"*\n {\n   if (constant_call_address_operand (operands[1], QImode))"}]}