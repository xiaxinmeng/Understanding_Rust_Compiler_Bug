{"sha": "7d3bec9db50a2d46f697ad621edd50165e51c168", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzYmVjOWRiNTBhMmQ0NmY2OTdhZDYyMWVkZDUwMTY1ZTUxYzE2OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2006-08-25T16:56:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2006-08-25T16:56:07Z"}, "message": "re PR c++/27787 (Qualified lookup fails to find inherited class template)\n\ncp/\n\tPR c++/27787\n\t* decl.c (make_typename_type): Only try and resolve it when\n\tcontext is not dependent.  Refactor.\n\t* decl2.c (check_classfn): Push to class scope before looking for\n\tthe function.\ntestsuite/\n\tPR c++/27787\n\t* g++.dg/template/typename10.C: New.\n\t* g++.dg/template/lookup4.C: Remove bogus error marker.\n\nFrom-SVN: r116409", "tree": {"sha": "1975a26da88ae00800dc1b09ba8808327325e61d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1975a26da88ae00800dc1b09ba8808327325e61d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d3bec9db50a2d46f697ad621edd50165e51c168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3bec9db50a2d46f697ad621edd50165e51c168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3bec9db50a2d46f697ad621edd50165e51c168", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3bec9db50a2d46f697ad621edd50165e51c168/comments", "author": null, "committer": null, "parents": [{"sha": "9eb8a531c0127cff8323c43fc9b148e585cd9288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb8a531c0127cff8323c43fc9b148e585cd9288", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb8a531c0127cff8323c43fc9b148e585cd9288"}], "stats": {"total": 172, "additions": 104, "deletions": 68}, "files": [{"sha": "629ba67d3f071465cebae26d531bd18185184e72", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7d3bec9db50a2d46f697ad621edd50165e51c168", "patch": "@@ -1,3 +1,11 @@\n+2006-08-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/27787\n+\t* decl.c (make_typename_type): Only try and resolve it when\n+\tcontext is not dependent.  Refactor.\n+\t* decl2.c (check_classfn): Push to class scope before looking for\n+\tthe function.\n+\n 2006-08-24  Danny Smith   <dannysmith@users.sourceforge.net>\n \n \tPR driver/28528"}, {"sha": "8ba2a13578a319dc923534607ba2304155102232", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 50, "deletions": 61, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7d3bec9db50a2d46f697ad621edd50165e51c168", "patch": "@@ -2779,6 +2779,8 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n \t\t    tsubst_flags_t complain)\n {\n   tree fullname;\n+  tree t;\n+  bool want_template;\n \n   if (name == error_mark_node\n       || context == NULL_TREE\n@@ -2816,73 +2818,60 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n   gcc_assert (TYPE_P (context));\n \n-  if (!dependent_type_p (context)\n-      || currently_open_class (context))\n-    {\n-      if (TREE_CODE (fullname) == TEMPLATE_ID_EXPR)\n-\t{\n-\t  tree tmpl = NULL_TREE;\n-\t  if (IS_AGGR_TYPE (context))\n-\t    tmpl = lookup_field (context, name, 0, false);\n-\t  if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"no class template named %q#T in %q#T\",\n-\t\t       name, context);\n-\t      return error_mark_node;\n-\t    }\n-\n-\t  if (complain & tf_error)\n-\t    perform_or_defer_access_check (TYPE_BINFO (context), tmpl);\n-\n-\t  return lookup_template_class (tmpl,\n-\t\t\t\t\tTREE_OPERAND (fullname, 1),\n-\t\t\t\t\tNULL_TREE, context,\n-\t\t\t\t\t/*entering_scope=*/0,\n-\t\t\t\t\ttf_warning_or_error | tf_user);\n-\t}\n-      else\n-\t{\n-\t  tree t;\n+  /* When the CONTEXT is a dependent type,  NAME could refer to a\n+     dependent base class of CONTEXT.  So we cannot peek inside it,\n+     even if CONTEXT is a currently open scope.  */\n+  if (dependent_type_p (context))\n+    return build_typename_type (context, name, fullname, tag_type);\n \n-\t  if (!IS_AGGR_TYPE (context))\n-\t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"no type named %q#T in %q#T\", name, context);\n-\t      return error_mark_node;\n-\t    }\n-\n-\t  t = lookup_field (context, name, 0, true);\n-\t  if (t)\n-\t    {\n-\t      if (TREE_CODE (t) != TYPE_DECL)\n-\t\t{\n-\t\t  if (complain & tf_error)\n-\t\t    error (\"no type named %q#T in %q#T\", name, context);\n-\t\t  return error_mark_node;\n-\t\t}\n-\n-\t      if (complain & tf_error)\n-\t\tperform_or_defer_access_check (TYPE_BINFO (context), t);\n-\n-\t      if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n-\t\tt = TREE_TYPE (t);\n-\n-\t      return t;\n-\t    }\n-\t}\n+  if (!IS_AGGR_TYPE (context))\n+    {\n+      if (complain & tf_error)\n+\terror (\"%q#T is not a class\", context);\n+      return error_mark_node;\n     }\n-\n-  /* If the CONTEXT is not a template type, then either the field is\n-     there now or its never going to be.  */\n-  if (!dependent_type_p (context))\n+  \n+  want_template = TREE_CODE (fullname) == TEMPLATE_ID_EXPR;\n+  \n+  /* We should only set WANT_TYPE when we're a nested typename type.\n+     Then we can give better diagnostics if we find a non-type.  */\n+  t = lookup_field (context, name, 0, /*want_type=*/true);\n+  if (!t)\n     {\n       if (complain & tf_error)\n-\terror (\"no type named %q#T in %q#T\", name, context);\n+\terror (want_template ? \"no class template named %q#T in %q#T\"\n+\t       : \"no type named %q#T in %q#T\", name, context);\n       return error_mark_node;\n     }\n-\n-  return build_typename_type (context, name, fullname, tag_type);\n+  \n+  if (want_template && !DECL_CLASS_TEMPLATE_P (t))\n+    {\n+      if (complain & tf_error)\n+\terror (\"%<typename %T::%D%> names %q#T, which is not a class template\",\n+\t       context, name, t);\n+      return error_mark_node;\n+    }\n+  if (!want_template && TREE_CODE (t) != TYPE_DECL)\n+    {\n+      if (complain & tf_error)\n+\terror (\"%<typename %T::%D%> names %q#T, which is not a type\",\n+\t       context, name, t);\n+      return error_mark_node;\n+    }\n+  \n+  if (complain & tf_error)\n+    perform_or_defer_access_check (TYPE_BINFO (context), t);\n+\n+  if (want_template)\n+    return lookup_template_class (t, TREE_OPERAND (fullname, 1),\n+\t\t\t\t  NULL_TREE, context,\n+\t\t\t\t  /*entering_scope=*/0,\n+\t\t\t\t  tf_warning_or_error | tf_user);\n+  \n+  if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n+    t = TREE_TYPE (t);\n+  \n+  return t;\n }\n \n /* Resolve `CONTEXT::template NAME'.  Returns a TEMPLATE_DECL if the name"}, {"sha": "db1e9179a2ba23590b085efd3ab247173581cd6a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7d3bec9db50a2d46f697ad621edd50165e51c168", "patch": "@@ -553,7 +553,8 @@ check_classfn (tree ctype, tree function, tree template_parms)\n {\n   int ix;\n   bool is_template;\n-\n+  tree pushed_scope;\n+  \n   if (DECL_USE_TEMPLATE (function)\n       && !(TREE_CODE (function) == TEMPLATE_DECL\n \t   && DECL_TEMPLATE_SPECIALIZATION (function))\n@@ -583,16 +584,18 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   /* OK, is this a definition of a member template?  */\n   is_template = (template_parms != NULL_TREE);\n \n+  /* We must enter the scope here, because conversion operators are\n+     named by target type, and type equivalence relies on typenames\n+     resolving within the scope of CTYPE.  */\n+  pushed_scope = push_scope (ctype);\n   ix = class_method_index_for_fn (complete_type (ctype), function);\n   if (ix >= 0)\n     {\n       VEC(tree,gc) *methods = CLASSTYPE_METHOD_VEC (ctype);\n       tree fndecls, fndecl = 0;\n       bool is_conv_op;\n-      tree pushed_scope;\n       const char *format = NULL;\n \n-      pushed_scope = push_scope (ctype);\n       for (fndecls = VEC_index (tree, methods, ix);\n \t   fndecls; fndecls = OVL_NEXT (fndecls))\n \t{\n@@ -631,10 +634,13 @@ check_classfn (tree ctype, tree function, tree template_parms)\n \t\t      == DECL_TI_TEMPLATE (fndecl))))\n \t    break;\n \t}\n-      if (pushed_scope)\n-\tpop_scope (pushed_scope);\n       if (fndecls)\n-\treturn OVL_CURRENT (fndecls);\n+\t{\n+\t  if (pushed_scope)\n+\t    pop_scope (pushed_scope);\n+\t  return OVL_CURRENT (fndecls);\n+\t}\n+      \n       error (\"prototype for %q#D does not match any in class %qT\",\n \t     function, ctype);\n       is_conv_op = DECL_CONV_FN_P (fndecl);\n@@ -682,6 +688,9 @@ check_classfn (tree ctype, tree function, tree template_parms)\n      properly within the class.  */\n   if (COMPLETE_TYPE_P (ctype))\n     add_method (ctype, function, NULL_TREE);\n+  \n+  if (pushed_scope)\n+    pop_scope (pushed_scope);\n   return NULL_TREE;\n }\n "}, {"sha": "8e9e60a35ae9cdc0a247345e45e55a03a9ac8118", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d3bec9db50a2d46f697ad621edd50165e51c168", "patch": "@@ -1,3 +1,9 @@\n+2006-08-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/27787\n+\t* g++.dg/template/typename10.C: New.\n+\t* g++.dg/template/lookup4.C: Remove bogus error marker.\n+\n 2006-08-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR testsuite/28829"}, {"sha": "3bd73a34e60d5c1729ff17a3cc9e55a406ecf671", "filename": "gcc/testsuite/g++.dg/template/lookup4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flookup4.C?ref=7d3bec9db50a2d46f697ad621edd50165e51c168", "patch": "@@ -2,5 +2,5 @@\n \n template <class T> struct Base {};\n template <class T> struct Derived: public Base<T> {\n-  typename Derived::template Base<double>* p1; // { dg-error \"\" }\n+  typename Derived::template Base<double>* p1;\n };"}, {"sha": "f6f9931dfaf80ef8865f3066ae9b0fca44309eae", "filename": "gcc/testsuite/g++.dg/template/typename10.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3bec9db50a2d46f697ad621edd50165e51c168/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename10.C?ref=7d3bec9db50a2d46f697ad621edd50165e51c168", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 25 Aug 2006 <nathan@codesourcery.com>\n+\n+// Origin: Tobias Schwinger <tschwinger@neoscientists.org>\n+// PR 27787. Too eager to resolve a typename\n+\n+template<typename X>\n+struct x\n+{\n+  template<typename Y>\n+  struct y\n+  {\n+    typedef Y type;\n+  };\n+};\n+\n+template<typename A>\n+struct a : x<A>\n+{\n+  template<typename B>\n+  typename a::template y<B>::type f(B);\n+};"}]}