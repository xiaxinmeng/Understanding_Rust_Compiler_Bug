{"sha": "9bb2f479f391114f46f6cb5d957b274ff0066135", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiMmY0NzlmMzkxMTE0ZjQ2ZjZjYjVkOTU3YjI3NGZmMDA2NjEzNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-11-10T02:35:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-11-10T02:35:19Z"}, "message": "re PR tree-optimization/40436 (0.5% code size regression caused by r147852)\n\n\n\tPR tree-optimization/40436\n\t* ipa-inline.c (leaf_node_p): Implement using is_inexpensive_builtin.\n\t* tree-inline.c (estimate_num_insns): Inexpensive builtins are like\n\tnormal instructions; be sure bultin is not implemented in this file;\n\tcompute non-zero return cost.\n\t(init_inline_once): Reduce builtin_call_cost to 1; set return cost.\n\t* tree-inline.h (eni_weights_d): Add return cost.\n\nFrom-SVN: r166517", "tree": {"sha": "c179f7d98e8b98e288509bbe8a5cf077dada2455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c179f7d98e8b98e288509bbe8a5cf077dada2455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb2f479f391114f46f6cb5d957b274ff0066135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb2f479f391114f46f6cb5d957b274ff0066135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb2f479f391114f46f6cb5d957b274ff0066135", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb2f479f391114f46f6cb5d957b274ff0066135/comments", "author": null, "committer": null, "parents": [{"sha": "b8cbdff525821c2ca8aa8758ed48d50f101138db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8cbdff525821c2ca8aa8758ed48d50f101138db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8cbdff525821c2ca8aa8758ed48d50f101138db"}], "stats": {"total": 45, "additions": 36, "deletions": 9}, "files": [{"sha": "0f219668d618e36dfcbdc3dfb2b3a0e0b2cffcb7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bb2f479f391114f46f6cb5d957b274ff0066135", "patch": "@@ -1,3 +1,13 @@\n+2010-11-09   Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/40436\n+\t* ipa-inline.c (leaf_node_p): Implement using is_inexpensive_builtin.\n+\t* tree-inline.c (estimate_num_insns): Inexpensive builtins are like\n+\tnormal instructions; be sure bultin is not implemented in this file;\n+\tcompute non-zero return cost.\n+\t(init_inline_once): Reduce builtin_call_cost to 1; set return cost.\n+\t* tree-inline.h (eni_weights_d): Add return cost.\n+\n 2010-11-09  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-parser.c (c_parser_struct_declaration): Handle declaration"}, {"sha": "0072d61bfc36d2c84a20f0d7b560144b42af33d0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9bb2f479f391114f46f6cb5d957b274ff0066135", "patch": "@@ -1578,16 +1578,15 @@ cgraph_decide_inlining (void)\n   return 0;\n }\n \n-/* Return true when N is leaf function.  Accept cheap (pure&const) builtins\n+/* Return true when N is leaf function.  Accept cheap builtins\n    in leaf functions.  */\n+\n static bool\n leaf_node_p (struct cgraph_node *n)\n {\n   struct cgraph_edge *e;\n   for (e = n->callees; e; e = e->next_callee)\n-    if (!DECL_BUILT_IN (e->callee->decl)\n-\t|| (!TREE_READONLY (e->callee->decl)\n-\t    || DECL_PURE_P (e->callee->decl)))\n+    if (!is_inexpensive_builtin (e->callee->decl))\n       return false;\n   return true;\n }"}, {"sha": "e4cb43653478132f945d3ae9a1994e5c2504a4ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bb2f479f391114f46f6cb5d957b274ff0066135", "patch": "@@ -1,3 +1,7 @@\n+2010-11-09   Jan Hubicka  <jh@suse.cz>\n+\n+\t* testsuite/gcc.target/i386/recip-vec-sqrtf-avx.c: Update for loop unrolling.\n+\n 2010-11-09  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/struct-semi-4.c: New test."}, {"sha": "506df88f956198c89567a5d893a2a45e2fe7031b", "filename": "gcc/testsuite/gcc.target/i386/recip-vec-sqrtf-avx.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frecip-vec-sqrtf-avx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frecip-vec-sqrtf-avx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frecip-vec-sqrtf-avx.c?ref=9bb2f479f391114f46f6cb5d957b274ff0066135", "patch": "@@ -31,4 +31,5 @@ void t3(void)\n    r[i] = sqrtf (a[i]);\n }\n \n-/* { dg-final { scan-assembler-times \"vrsqrtps\\[ \\\\t\\]+\\[^\\n\\]*%ymm\" 3 } } */\n+/* Last loop is small enough to be fully unrolled.  */\n+/* { dg-final { scan-assembler-times \"vrsqrtps\\[ \\\\t\\]+\\[^\\n\\]*%ymm\" 4 } } */"}, {"sha": "fc470a7637e31012ea2a9eb5130ac5f035977ab1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=9bb2f479f391114f46f6cb5d957b274ff0066135", "patch": "@@ -3484,10 +3484,16 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \tif (POINTER_TYPE_P (funtype))\n \t  funtype = TREE_TYPE (funtype);\n \n-\tif (is_simple_builtin (decl))\n+\t/* Do not special case builtins where we see the body.\n+\t   This just confuse inliner.  */\n+\tif (!decl || cgraph_node (decl)->analyzed)\n+\t  cost = weights->call_cost;\n+\t/* For buitins that are likely expanded to nothing or\n+\t   inlined do not account operand costs.  */\n+\telse if (is_simple_builtin (decl))\n \t  return 0;\n \telse if (is_inexpensive_builtin (decl))\n-\t  cost = weights->target_builtin_call_cost;\n+\t  return weights->target_builtin_call_cost;\n \telse\n \t  cost = weights->call_cost;\n \n@@ -3536,11 +3542,13 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \tbreak;\n       }\n \n+    case GIMPLE_RETURN:\n+      return weights->return_cost;\n+\n     case GIMPLE_GOTO:\n     case GIMPLE_LABEL:\n     case GIMPLE_NOP:\n     case GIMPLE_PHI:\n-    case GIMPLE_RETURN:\n     case GIMPLE_PREDICT:\n     case GIMPLE_DEBUG:\n       return 0;\n@@ -3640,16 +3648,18 @@ init_inline_once (void)\n   eni_size_weights.div_mod_cost = 1;\n   eni_size_weights.omp_cost = 40;\n   eni_size_weights.time_based = false;\n+  eni_size_weights.return_cost = 1;\n \n   /* Estimating time for call is difficult, since we have no idea what the\n      called function does.  In the current uses of eni_time_weights,\n      underestimating the cost does less harm than overestimating it, so\n      we choose a rather small value here.  */\n   eni_time_weights.call_cost = 10;\n-  eni_time_weights.target_builtin_call_cost = 10;\n+  eni_time_weights.target_builtin_call_cost = 1;\n   eni_time_weights.div_mod_cost = 10;\n   eni_time_weights.omp_cost = 40;\n   eni_time_weights.time_based = true;\n+  eni_time_weights.return_cost = 2;\n }\n \n /* Estimate the number of instructions in a gimple_seq. */"}, {"sha": "fa0353735a750b77deca800088954db85ddcd7c6", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb2f479f391114f46f6cb5d957b274ff0066135/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=9bb2f479f391114f46f6cb5d957b274ff0066135", "patch": "@@ -144,6 +144,9 @@ typedef struct eni_weights_d\n   /* Cost for omp construct.  */\n   unsigned omp_cost;\n \n+  /* Cost of return.  */\n+  unsigned return_cost;\n+\n   /* True when time of statemnt should be estimated.  Thus i.e\n      cost of switch statement is logarithmic rather than linear in number\n      of cases.  */"}]}