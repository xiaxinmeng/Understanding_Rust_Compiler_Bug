{"sha": "c1874a876fe3c66e40e84862a0b79a4951f7476b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE4NzRhODc2ZmUzYzY2ZTQwZTg0ODYyYTBiNzlhNDk1MWY3NDc2Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-02-13T11:42:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-02-13T11:42:04Z"}, "message": "loop-init.c (loop_optimizer_init): Clear loop state when re-initializing preserved loops.\n\n2013-02-13  Richard Biener  <rguenther@suse.de>\n\n\t* loop-init.c (loop_optimizer_init): Clear loop state when\n\tre-initializing preserved loops.\n\t* loop-unswitch.c (unswitch_single_loop): Return whether\n\twe unswitched the loop.  Do not verify loop state here.\n\t(unswitch_loops): When we unswitched a loop discover new\n\tloops.\n\nFrom-SVN: r196010", "tree": {"sha": "3a095d13c848a658690fb0f5f21604a2e0184c40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a095d13c848a658690fb0f5f21604a2e0184c40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1874a876fe3c66e40e84862a0b79a4951f7476b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1874a876fe3c66e40e84862a0b79a4951f7476b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1874a876fe3c66e40e84862a0b79a4951f7476b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1874a876fe3c66e40e84862a0b79a4951f7476b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4ab7d34f5ee89e23f75cb25585bc851c7f713b3"}], "stats": {"total": 50, "additions": 35, "deletions": 15}, "files": [{"sha": "38339d0def760d64d15c62eb1a03972d4e883038", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1874a876fe3c66e40e84862a0b79a4951f7476b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1874a876fe3c66e40e84862a0b79a4951f7476b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1874a876fe3c66e40e84862a0b79a4951f7476b", "patch": "@@ -1,3 +1,12 @@\n+2013-02-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* loop-init.c (loop_optimizer_init): Clear loop state when\n+\tre-initializing preserved loops.\n+\t* loop-unswitch.c (unswitch_single_loop): Return whether\n+\twe unswitched the loop.  Do not verify loop state here.\n+\t(unswitch_loops): When we unswitched a loop discover new\n+\tloops.\n+\n 2013-02-13  Kostya Serebryany  <kcc@google.com>\n \n \t* config/i386/i386.c: Use 0x7fff8000 as asan_shadow_offset on x86_64"}, {"sha": "b1954ca484f79bd46d54a6e0a586db218d1c7e7a", "filename": "gcc/loop-init.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1874a876fe3c66e40e84862a0b79a4951f7476b/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1874a876fe3c66e40e84862a0b79a4951f7476b/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=c1874a876fe3c66e40e84862a0b79a4951f7476b", "patch": "@@ -99,6 +99,9 @@ loop_optimizer_init (unsigned flags)\n #ifdef ENABLE_CHECKING\n       verify_loop_structure ();\n #endif\n+\n+      /* Clear all flags.  */\n+      loops_state_clear (~0U);\n     }\n \n   /* Apply flags to loops.  */"}, {"sha": "6a12952cc991ccc8755653cc1218e215a534eee4", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1874a876fe3c66e40e84862a0b79a4951f7476b/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1874a876fe3c66e40e84862a0b79a4951f7476b/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=c1874a876fe3c66e40e84862a0b79a4951f7476b", "patch": "@@ -78,7 +78,7 @@ along with GCC; see the file COPYING3.  If not see\n   with handling this case.  */\n \n static struct loop *unswitch_loop (struct loop *, basic_block, rtx, rtx);\n-static void unswitch_single_loop (struct loop *, rtx, int);\n+static bool unswitch_single_loop (struct loop *, rtx, int);\n static rtx may_unswitch_on (basic_block, struct loop *, rtx *);\n \n /* Prepare a sequence comparing OP0 with OP1 using COMP and jumping to LABEL if\n@@ -140,13 +140,22 @@ unswitch_loops (void)\n {\n   loop_iterator li;\n   struct loop *loop;\n+  bool changed = false;\n \n   /* Go through inner loops (only original ones).  */\n \n   FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)\n-    unswitch_single_loop (loop, NULL_RTX, 0);\n+    changed |= unswitch_single_loop (loop, NULL_RTX, 0);\n \n   iv_analysis_done ();\n+\n+  /* If we unswitched any loop discover new loops that are eventually\n+     exposed by making irreducible regions reducible.  */\n+  if (changed)\n+    {\n+      calculate_dominance_info (CDI_DOMINATORS);\n+      fix_loop_structure (NULL);\n+    }\n }\n \n /* Checks whether we can unswitch LOOP on condition at end of BB -- one of its\n@@ -241,8 +250,9 @@ reversed_condition (rtx cond)\n /* Unswitch single LOOP.  COND_CHECKED holds list of conditions we already\n    unswitched on and are therefore known to be true in this LOOP.  NUM is\n    number of unswitchings done; do not allow it to grow too much, it is too\n-   easy to create example on that the code would grow exponentially.  */\n-static void\n+   easy to create example on that the code would grow exponentially.\n+   Returns true LOOP was unswitched.  */\n+static bool \n unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n {\n   basic_block *bbs;\n@@ -258,39 +268,39 @@ unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unswitching anymore, hit max level\\n\");\n-      return;\n+      return false;\n     }\n \n   /* Only unswitch innermost loops.  */\n   if (loop->inner)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unswitching, not innermost loop\\n\");\n-      return;\n+      return false;\n     }\n \n   /* We must be able to duplicate loop body.  */\n   if (!can_duplicate_loop_p (loop))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unswitching, can't duplicate loop\\n\");\n-      return;\n+      return false;\n     }\n \n   /* The loop should not be too large, to limit code growth.  */\n   if (num_loop_insns (loop) > PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unswitching, loop too big\\n\");\n-      return;\n+      return false;\n     }\n \n   /* Do not unswitch in cold areas.  */\n   if (optimize_loop_for_size_p (loop))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unswitching, not hot area\\n\");\n-      return;\n+      return false;\n     }\n \n   /* Nor if the loop usually does not roll.  */\n@@ -299,7 +309,7 @@ unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \";; Not unswitching, loop iterations < 1\\n\");\n-      return;\n+      return false;\n     }\n \n   do\n@@ -317,7 +327,7 @@ unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n       if (i == loop->num_nodes)\n \t{\n \t  free (bbs);\n-\t  return;\n+\t  return false;\n \t}\n \n       if (cond != const0_rtx\n@@ -364,10 +374,6 @@ unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n   nloop = unswitch_loop (loop, bbs[i], copy_rtx_if_shared (cond), cinsn);\n   gcc_assert (nloop);\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-#endif\n-\n   /* Invoke itself on modified loops.  */\n   unswitch_single_loop (nloop, rconds, num + 1);\n   unswitch_single_loop (loop, conds, num + 1);\n@@ -377,6 +383,8 @@ unswitch_single_loop (struct loop *loop, rtx cond_checked, int num)\n     free_EXPR_LIST_node (rconds);\n \n   free (bbs);\n+\n+  return true;\n }\n \n /* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support"}]}