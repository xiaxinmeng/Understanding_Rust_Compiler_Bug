{"sha": "8576f0942e3b46cb72409e5a487230d9c8c5c5ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU3NmYwOTQyZTNiNDZjYjcyNDA5ZTVhNDg3MjMwZDljOGM1YzVlYw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-06-14T17:15:35Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-06-14T17:15:35Z"}, "message": "[multiple changes]\n\nMon Jun 14 13:13:39 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (qualify_ambiguous_name): Reorganized the post\n \tevaluation of non WFL leading expression nodes.\nFri Jun 11 21:37:18 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (qualify_ambiguous_name): Handle ARRAY_REF after\n \tCONVERT_EXPR.\nThu Jun 10 22:26:17 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (qualify_ambiguous_name): Handle qualified expression\n \tbeginning with a STRING_CST.\nThu Jun 10 20:27:25 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y (register_fields): Set DECL_INITIAL on both\n \tpre-initialized static and public fields.\n\t(resolve_field_access): Static field access expressions to always\n \tuse pointer types.\n\t(qualify_ambiguous_name): Work out buried CALL_EXPR for proper\n \tqualification. CONVERT_EXPR to be resolved as an expression name.\n\t(java_complete_lhs): Identify and access qualified final\n \tinitialized field in switch statement case expression.\n\t(fold_constant_for_init): Pre-initialized field decl constant to\n \tbe folded.\n\nFrom-SVN: r27523", "tree": {"sha": "981f78397a53d81d6e9b91669e732bab3f2c4fc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/981f78397a53d81d6e9b91669e732bab3f2c4fc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8576f0942e3b46cb72409e5a487230d9c8c5c5ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8576f0942e3b46cb72409e5a487230d9c8c5c5ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8576f0942e3b46cb72409e5a487230d9c8c5c5ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8576f0942e3b46cb72409e5a487230d9c8c5c5ec/comments", "author": null, "committer": null, "parents": [{"sha": "6d1a9047b8b56477e1f4321a73add8fd36bc06cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1a9047b8b56477e1f4321a73add8fd36bc06cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1a9047b8b56477e1f4321a73add8fd36bc06cf"}], "stats": {"total": 176, "additions": 128, "deletions": 48}, "files": [{"sha": "bf8e310dcfcc6c6624fc81fa0184eede8795e53f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8576f0942e3b46cb72409e5a487230d9c8c5c5ec/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8576f0942e3b46cb72409e5a487230d9c8c5c5ec/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8576f0942e3b46cb72409e5a487230d9c8c5c5ec", "patch": "@@ -1,3 +1,31 @@\n+Mon Jun 14 13:13:39 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (qualify_ambiguous_name): Reorganized the post\n+ \tevaluation of non WFL leading expression nodes.\n+\n+Fri Jun 11 21:37:18 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (qualify_ambiguous_name): Handle ARRAY_REF after\n+ \tCONVERT_EXPR.\n+\n+Thu Jun 10 22:26:17 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (qualify_ambiguous_name): Handle qualified expression\n+ \tbeginning with a STRING_CST.\n+\n+Thu Jun 10 20:27:25 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (register_fields): Set DECL_INITIAL on both\n+ \tpre-initialized static and public fields.\n+\t(resolve_field_access): Static field access expressions to always\n+ \tuse pointer types.\n+\t(qualify_ambiguous_name): Work out buried CALL_EXPR for proper\n+ \tqualification. CONVERT_EXPR to be resolved as an expression name.\n+\t(java_complete_lhs): Identify and access qualified final\n+ \tinitialized field in switch statement case expression.\n+\t(fold_constant_for_init): Pre-initialized field decl constant to\n+ \tbe folded.\n+\n Mon Jun  7 16:09:51 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (note_possible_classname): Mark returned node with"}, {"sha": "fb032c98fa3ba2450938460d360f38b176fe298c", "filename": "gcc/java/parse.c", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8576f0942e3b46cb72409e5a487230d9c8c5c5ec/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8576f0942e3b46cb72409e5a487230d9c8c5c5ec/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=8576f0942e3b46cb72409e5a487230d9c8c5c5ec", "patch": "@@ -5799,7 +5799,6 @@ register_fields (flags, type, variable_list)\n \t\t appropriately. */\n \t      TREE_CHAIN (init) = ctxp->static_initialized;\n \t      ctxp->static_initialized = init;\n-\t      DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t      if (TREE_OPERAND (init, 1) \n \t\t  && TREE_CODE (TREE_OPERAND (init, 1)) == NEW_ARRAY_INIT)\n \t\tTREE_STATIC (TREE_OPERAND (init, 1)) = 1;\n@@ -5813,6 +5812,7 @@ register_fields (flags, type, variable_list)\n \t      ctxp->non_static_initialized = init;\n \t    }\n \t  MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n+\t  DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t}\n     }\n   lineno = saved_lineno;\n@@ -8896,6 +8896,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \t      && TREE_CODE (where_found) != RECORD_TYPE)\n \t    {\n \t      tree type = QUAL_DECL_TYPE (field_ref);\n+\t      if (TREE_CODE (type) == RECORD_TYPE)\n+\t\ttype = build_pointer_type (type);\n \t      field_ref = build (COMPOUND_EXPR, type, where_found, field_ref);\n \t    }\n \t}\n@@ -10111,6 +10113,7 @@ qualify_ambiguous_name (id)\n {\n   tree qual, qual_wfl, name, decl, ptr_type, saved_current_class;\n   int again, super_found = 0, this_found = 0, new_array_found = 0;\n+  int code;\n \n   /* We first qualify the first element, then derive qualification of\n      others based on the first one. If the first element is qualified\n@@ -10140,7 +10143,7 @@ qualify_ambiguous_name (id)\n \tbreak;\n       case NEW_ARRAY_EXPR:\n \tqual = TREE_CHAIN (qual);\n-\tnew_array_found = again = 1;\n+\tnew_array_found = 1;\n \tcontinue;\n       case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n@@ -10150,13 +10153,41 @@ qualify_ambiguous_name (id)\n \twhile (TREE_CODE (qual_wfl) == ARRAY_REF)\n \t  qual_wfl = TREE_OPERAND (qual_wfl, 0);\n \tbreak;\n+      case STRING_CST:\n+\tqual = TREE_CHAIN (qual);\n+\tqual_wfl = QUAL_WFL (qual);\n+\tbreak;\n       default:\n \t/* Fix for -Wall. Just break doing nothing */\n \tbreak;\n       }\n-    name = EXPR_WFL_NODE (qual_wfl);\n+\n     ptr_type = current_class;\n     again = 0;\n+    code = TREE_CODE (qual_wfl);\n+\n+    /* Pos evaluation: non WFL leading expression nodes */\n+    if (code == CONVERT_EXPR\n+\t&& TREE_CODE (TREE_TYPE (qual_wfl)) == EXPR_WITH_FILE_LOCATION)\n+      name = EXPR_WFL_NODE (TREE_TYPE (qual_wfl));\n+\n+    else if (code == ARRAY_REF &&\n+\t     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)\n+      name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));\n+\n+    else if (code == CALL_EXPR && \n+\t     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)\n+      name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));\n+\n+    else if (code == STRING_CST || code == CONDITIONAL_EXPR)\n+      {\n+\tqual = TREE_CHAIN (qual);\n+\tqual_wfl = QUAL_WFL (qual);\n+\tagain = 1;\n+      }\n+    else \n+      name = EXPR_WFL_NODE (qual_wfl);\n+    \n     /* If we have a THIS (from a primary), we set the context accordingly */\n     if (name == this_identifier_node)\n       {\n@@ -10184,22 +10215,7 @@ qualify_ambiguous_name (id)\n \t/* Do one more interation to set things up */\n \tsuper_found = again = 1;\n       }\n-    /* Loop one more time if we're dealing with ?: or a string\n-       constant, or a convert expression */\n-    if (TREE_CODE (qual_wfl) == CONDITIONAL_EXPR\n-\t|| TREE_CODE (qual_wfl) == STRING_CST\n-\t|| TREE_CODE (qual_wfl) == CONVERT_EXPR)\n-      {\n-\tif (TREE_CODE (qual_wfl) == CONVERT_EXPR\n-\t    && TREE_CODE (TREE_TYPE (qual_wfl)) == EXPR_WITH_FILE_LOCATION)\n-\t    name = EXPR_WFL_NODE (TREE_TYPE (qual_wfl));\n-\telse\n-\t  {\n-\t    qual = TREE_CHAIN (qual);\n-\t    qual_wfl = QUAL_WFL (qual);\n-\t    again = 1;\n-\t  }\n-      }\n+\n   } while (again);\n   \n   /* If name appears within the scope of a location variable\n@@ -10239,7 +10255,8 @@ qualify_ambiguous_name (id)\n \n   /* Method call are expression name */\n   else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR\n-\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF)\n+\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF\n+\t   || TREE_CODE (QUAL_WFL (qual)) == CONVERT_EXPR)\n     RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n \n   /* Check here that NAME isn't declared by more than one\n@@ -10511,8 +10528,15 @@ java_complete_lhs (node)\n       if (cn == error_mark_node)\n \treturn cn;\n \n-      /* First, the case expression must be constant */\n+      /* First, the case expression must be constant. Values of final\n+         fields are accepted. */\n       cn = fold (cn);\n+      if ((TREE_CODE (cn) == COMPOUND_EXPR || TREE_CODE (cn) == COMPONENT_REF)\n+\t  && JDECL_P (TREE_OPERAND (cn, 1))\n+\t  && FIELD_FINAL (TREE_OPERAND (cn, 1))\n+\t  && DECL_INITIAL (TREE_OPERAND (cn, 1)))\n+\tcn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),\n+\t\t\t\t     TREE_OPERAND (cn, 1));\n \n       if (!TREE_CONSTANT (cn) && !flag_emit_xref)\n \t{\n@@ -14112,7 +14136,7 @@ fold_constant_for_init (node, context)\n \n   if (code == INTEGER_CST || code == REAL_CST)\n     return convert (TREE_TYPE (context), node);\n-  if (TREE_TYPE (node) != NULL_TREE && code != VAR_DECL)\n+  if (TREE_TYPE (node) != NULL_TREE && code != VAR_DECL && code != FIELD_DECL)\n     return NULL_TREE;\n \n   switch (code)\n@@ -14178,7 +14202,8 @@ fold_constant_for_init (node, context)\n \t: TREE_OPERAND (node, 2);\n \n     case VAR_DECL:\n-      if (! FIELD_STATIC (node) || ! FIELD_FINAL (node)\n+    case FIELD_DECL:\n+      if (! FIELD_FINAL (node)\n \t  || DECL_INITIAL (node) == NULL_TREE)\n \treturn NULL_TREE;\n       val = DECL_INITIAL (node);\n@@ -14200,7 +14225,8 @@ fold_constant_for_init (node, context)\n \t  else if (! QUALIFIED_P (name))\n \t    {\n \t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n-\t      if (decl == NULL_TREE || ! FIELD_STATIC (decl))\n+\t      if (decl == NULL_TREE \n+\t\t  || (! FIELD_STATIC (decl) && ! FIELD_FINAL (decl)))\n \t\treturn NULL_TREE;\n \t      return fold_constant_for_init (decl, decl);\n \t    }"}, {"sha": "d691bc3602b5745d1807629cd50cd766202b37da", "filename": "gcc/java/parse.y", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8576f0942e3b46cb72409e5a487230d9c8c5c5ec/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8576f0942e3b46cb72409e5a487230d9c8c5c5ec/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=8576f0942e3b46cb72409e5a487230d9c8c5c5ec", "patch": "@@ -3214,7 +3214,6 @@ register_fields (flags, type, variable_list)\n \t\t appropriately. */\n \t      TREE_CHAIN (init) = ctxp->static_initialized;\n \t      ctxp->static_initialized = init;\n-\t      DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t      if (TREE_OPERAND (init, 1) \n \t\t  && TREE_CODE (TREE_OPERAND (init, 1)) == NEW_ARRAY_INIT)\n \t\tTREE_STATIC (TREE_OPERAND (init, 1)) = 1;\n@@ -3228,6 +3227,7 @@ register_fields (flags, type, variable_list)\n \t      ctxp->non_static_initialized = init;\n \t    }\n \t  MODIFY_EXPR_FROM_INITIALIZATION_P (init) = 1;\n+\t  DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t}\n     }\n   lineno = saved_lineno;\n@@ -6311,6 +6311,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \t      && TREE_CODE (where_found) != RECORD_TYPE)\n \t    {\n \t      tree type = QUAL_DECL_TYPE (field_ref);\n+\t      if (TREE_CODE (type) == RECORD_TYPE)\n+\t\ttype = build_pointer_type (type);\n \t      field_ref = build (COMPOUND_EXPR, type, where_found, field_ref);\n \t    }\n \t}\n@@ -7526,6 +7528,7 @@ qualify_ambiguous_name (id)\n {\n   tree qual, qual_wfl, name, decl, ptr_type, saved_current_class;\n   int again, super_found = 0, this_found = 0, new_array_found = 0;\n+  int code;\n \n   /* We first qualify the first element, then derive qualification of\n      others based on the first one. If the first element is qualified\n@@ -7555,7 +7558,7 @@ qualify_ambiguous_name (id)\n \tbreak;\n       case NEW_ARRAY_EXPR:\n \tqual = TREE_CHAIN (qual);\n-\tnew_array_found = again = 1;\n+\tnew_array_found = 1;\n \tcontinue;\n       case NEW_CLASS_EXPR:\n       case CONVERT_EXPR:\n@@ -7565,13 +7568,41 @@ qualify_ambiguous_name (id)\n \twhile (TREE_CODE (qual_wfl) == ARRAY_REF)\n \t  qual_wfl = TREE_OPERAND (qual_wfl, 0);\n \tbreak;\n+      case STRING_CST:\n+\tqual = TREE_CHAIN (qual);\n+\tqual_wfl = QUAL_WFL (qual);\n+\tbreak;\n       default:\n \t/* Fix for -Wall. Just break doing nothing */\n \tbreak;\n       }\n-    name = EXPR_WFL_NODE (qual_wfl);\n+\n     ptr_type = current_class;\n     again = 0;\n+    code = TREE_CODE (qual_wfl);\n+\n+    /* Pos evaluation: non WFL leading expression nodes */\n+    if (code == CONVERT_EXPR\n+\t&& TREE_CODE (TREE_TYPE (qual_wfl)) == EXPR_WITH_FILE_LOCATION)\n+      name = EXPR_WFL_NODE (TREE_TYPE (qual_wfl));\n+\n+    else if (code == ARRAY_REF &&\n+\t     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)\n+      name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));\n+\n+    else if (code == CALL_EXPR && \n+\t     TREE_CODE (TREE_OPERAND (qual_wfl, 0)) == EXPR_WITH_FILE_LOCATION)\n+      name = EXPR_WFL_NODE (TREE_OPERAND (qual_wfl, 0));\n+\n+    else if (code == STRING_CST || code == CONDITIONAL_EXPR)\n+      {\n+\tqual = TREE_CHAIN (qual);\n+\tqual_wfl = QUAL_WFL (qual);\n+\tagain = 1;\n+      }\n+    else \n+      name = EXPR_WFL_NODE (qual_wfl);\n+    \n     /* If we have a THIS (from a primary), we set the context accordingly */\n     if (name == this_identifier_node)\n       {\n@@ -7599,22 +7630,7 @@ qualify_ambiguous_name (id)\n \t/* Do one more interation to set things up */\n \tsuper_found = again = 1;\n       }\n-    /* Loop one more time if we're dealing with ?: or a string\n-       constant, or a convert expression */\n-    if (TREE_CODE (qual_wfl) == CONDITIONAL_EXPR\n-\t|| TREE_CODE (qual_wfl) == STRING_CST\n-\t|| TREE_CODE (qual_wfl) == CONVERT_EXPR)\n-      {\n-\tif (TREE_CODE (qual_wfl) == CONVERT_EXPR\n-\t    && TREE_CODE (TREE_TYPE (qual_wfl)) == EXPR_WITH_FILE_LOCATION)\n-\t    name = EXPR_WFL_NODE (TREE_TYPE (qual_wfl));\n-\telse\n-\t  {\n-\t    qual = TREE_CHAIN (qual);\n-\t    qual_wfl = QUAL_WFL (qual);\n-\t    again = 1;\n-\t  }\n-      }\n+\n   } while (again);\n   \n   /* If name appears within the scope of a location variable\n@@ -7654,7 +7670,8 @@ qualify_ambiguous_name (id)\n \n   /* Method call are expression name */\n   else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR\n-\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF)\n+\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF\n+\t   || TREE_CODE (QUAL_WFL (qual)) == CONVERT_EXPR)\n     RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n \n   /* Check here that NAME isn't declared by more than one\n@@ -7926,8 +7943,15 @@ java_complete_lhs (node)\n       if (cn == error_mark_node)\n \treturn cn;\n \n-      /* First, the case expression must be constant */\n+      /* First, the case expression must be constant. Values of final\n+         fields are accepted. */\n       cn = fold (cn);\n+      if ((TREE_CODE (cn) == COMPOUND_EXPR || TREE_CODE (cn) == COMPONENT_REF)\n+\t  && JDECL_P (TREE_OPERAND (cn, 1))\n+\t  && FIELD_FINAL (TREE_OPERAND (cn, 1))\n+\t  && DECL_INITIAL (TREE_OPERAND (cn, 1)))\n+\tcn = fold_constant_for_init (DECL_INITIAL (TREE_OPERAND (cn, 1)),\n+\t\t\t\t     TREE_OPERAND (cn, 1));\n \n       if (!TREE_CONSTANT (cn) && !flag_emit_xref)\n \t{\n@@ -11527,7 +11551,7 @@ fold_constant_for_init (node, context)\n \n   if (code == INTEGER_CST || code == REAL_CST)\n     return convert (TREE_TYPE (context), node);\n-  if (TREE_TYPE (node) != NULL_TREE && code != VAR_DECL)\n+  if (TREE_TYPE (node) != NULL_TREE && code != VAR_DECL && code != FIELD_DECL)\n     return NULL_TREE;\n \n   switch (code)\n@@ -11593,7 +11617,8 @@ fold_constant_for_init (node, context)\n \t: TREE_OPERAND (node, 2);\n \n     case VAR_DECL:\n-      if (! FIELD_STATIC (node) || ! FIELD_FINAL (node)\n+    case FIELD_DECL:\n+      if (! FIELD_FINAL (node)\n \t  || DECL_INITIAL (node) == NULL_TREE)\n \treturn NULL_TREE;\n       val = DECL_INITIAL (node);\n@@ -11615,7 +11640,8 @@ fold_constant_for_init (node, context)\n \t  else if (! QUALIFIED_P (name))\n \t    {\n \t      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);\n-\t      if (decl == NULL_TREE || ! FIELD_STATIC (decl))\n+\t      if (decl == NULL_TREE \n+\t\t  || (! FIELD_STATIC (decl) && ! FIELD_FINAL (decl)))\n \t\treturn NULL_TREE;\n \t      return fold_constant_for_init (decl, decl);\n \t    }"}]}