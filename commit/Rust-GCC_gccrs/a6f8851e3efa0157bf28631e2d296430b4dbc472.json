{"sha": "a6f8851e3efa0157bf28631e2d296430b4dbc472", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZmODg1MWUzZWZhMDE1N2JmMjg2MzFlMmQyOTY0MzBiNGRiYzQ3Mg==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2012-04-12T16:15:13Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-04-12T16:15:13Z"}, "message": "re PR tree-optimization/18589 (could optimize FP multiplies better)\n\ngcc:\n\n2012-04-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/18589\n\t* tree-ssa-reassoc.c (reassociate_stats): Add two fields.\n\t(operand_entry): Add count field.\n\t(add_repeat_to_ops_vec): New function.\n\t(completely_remove_stmt): Likewise.\n\t(remove_def_if_absorbed_call): Likewise.\n\t(remove_visited_stmt_chain): Remove feeding builtin pow/powi calls.\n\t(acceptable_pow_call): New function.\n\t(linearize_expr_tree): Look for builtin pow/powi calls and add operand\n\tentries with repeat counts when found.\n\t(repeat_factor_d): New struct and associated typedefs.\n\t(repeat_factor_vec): New static vector variable.\n\t(compare_repeat_factors): New function.\n\t(get_reassoc_pow_ssa_name): Likewise.\n\t(attempt_builtin_powi): Likewise.\n\t(reassociate_bb): Call attempt_builtin_powi.\n\t(fini_reassoc): Two new calls to statistics_counter_event.\n\ngcc/testsuite:\n\n2012-04-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/18589\n\t* gcc.dg/tree-ssa/pr18589-1.c: New test.\n\t* gcc.dg/tree-ssa/pr18589-2.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-3.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-4.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-5.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-6.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-7.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-8.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-9.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18589-10.c: Likewise.\n\nFrom-SVN: r186384", "tree": {"sha": "46ca9b251c6bcce042ae014fc4bbc5136990a8d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46ca9b251c6bcce042ae014fc4bbc5136990a8d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6f8851e3efa0157bf28631e2d296430b4dbc472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f8851e3efa0157bf28631e2d296430b4dbc472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6f8851e3efa0157bf28631e2d296430b4dbc472", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f8851e3efa0157bf28631e2d296430b4dbc472/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "452aa9c5105180110e7e80aa74044426ca8271cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/452aa9c5105180110e7e80aa74044426ca8271cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/452aa9c5105180110e7e80aa74044426ca8271cf"}], "stats": {"total": 669, "additions": 659, "deletions": 10}, "files": [{"sha": "be5fc05353b88326d288c6cf049ddb973e2c6fcc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -1,3 +1,23 @@\n+2012-04-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/18589\n+\t* tree-ssa-reassoc.c (reassociate_stats): Add two fields.\n+\t(operand_entry): Add count field.\n+\t(add_repeat_to_ops_vec): New function.\n+\t(completely_remove_stmt): Likewise.\n+\t(remove_def_if_absorbed_call): Likewise.\n+\t(remove_visited_stmt_chain): Remove feeding builtin pow/powi calls.\n+\t(acceptable_pow_call): New function.\n+\t(linearize_expr_tree): Look for builtin pow/powi calls and add operand\n+\tentries with repeat counts when found.\n+\t(repeat_factor_d): New struct and associated typedefs.\n+\t(repeat_factor_vec): New static vector variable.\n+\t(compare_repeat_factors): New function.\n+\t(get_reassoc_pow_ssa_name): Likewise.\n+\t(attempt_builtin_powi): Likewise.\n+\t(reassociate_bb): Call attempt_builtin_powi.\n+\t(fini_reassoc): Two new calls to statistics_counter_event.\n+\n 2012-04-12  Richard Guenther  <rguenther@suse.de>\n \n \t* Makefile.in (cgraphunit.o): Add $(EXCEPT_H) dependency."}, {"sha": "ae2922df145fb441af0393efa9448dc2030a302f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -1,3 +1,17 @@\n+2012-04-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/18589\n+\t* gcc.dg/tree-ssa/pr18589-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr18589-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-5.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-6.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-7.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-8.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-9.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18589-10.c: Likewise.\n+\n 2012-04-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/52943"}, {"sha": "48c904d0f8f9ddda69ee7f46aaa6b9be5c0bd056", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-1.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y)\n+{\n+  return x * x * x * x * y * y * y * y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "4a6120abd6dd80539e3693754ca98eb16453bd37", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-10.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-10.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y, double z)\n+{\n+  return (__builtin_pow (x, 4.0) * __builtin_pow (y, 2.0)\n+\t  * __builtin_pow (z, 4.0));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 5 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d8b7fca00ee34a0d987c2070a596fb81fcf5dca6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-2.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y)\n+{\n+  return x * y * y * x * y * x * x * y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "26c1893bae789555252b8306656d95691ef6aeef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-3.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y, double z)\n+{\n+  return x * x * y * y * y * z * z * z * z;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 5 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "55c2d43b3979d32ed454ccd71a9118629b385491", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-4.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y, double z, double u)\n+{\n+  return x * x * y * y * y * z * z * z * z * u;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 6 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ea60f8eca1c7448d67acdc8b18b89ebf1aba9ede", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-5.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-5.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y, double z, double u)\n+{\n+  return x * x * x * y * y * y * z * z * z * z * u * u * u * u;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 6 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5044020cf44532b13a888a8209353766aa8bcebf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-6.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-6.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y)\n+{\n+  return __builtin_pow (x, 3.0) * __builtin_pow (y, 4.0);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 4 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d4c5241583acd98f9e297742fab514995360a9db", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-7.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-7.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+float baz (float x, float y)\n+{\n+  return x * x * x * x * y * y * y * y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5335fa229e8f4d0c9348090a5a2ee1b341cdf404", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-8.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-8.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+long double baz (long double x, long double y)\n+{\n+  return x * x * x * x * y * y * y * y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 3 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "08d5798e2cdfb1bf0272b0d5d19539ec9da2eab3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18589-9.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18589-9.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" } */\n+\n+double baz (double x, double y, double z)\n+{\n+  return (__builtin_pow (x, 3.0) * __builtin_pow (y, 2.0)\n+\t  * __builtin_pow (z, 5.0));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 6 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "eb46bfa7f6b9736ef4e98dfc53c26ac2448148ee", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 523, "deletions": 10, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f8851e3efa0157bf28631e2d296430b4dbc472/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=a6f8851e3efa0157bf28631e2d296430b4dbc472", "patch": "@@ -61,6 +61,10 @@ along with GCC; see the file COPYING3.  If not see\n     3. Optimization of the operand lists, eliminating things like a +\n     -a, a & a, etc.\n \n+    3a. Combine repeated factors with the same occurrence counts\n+    into a __builtin_powi call that will later be optimized into\n+    an optimal number of multiplies.\n+\n     4. Rewrite the expression trees we linearized and optimized so\n     they are in proper rank order.\n \n@@ -169,6 +173,8 @@ static struct\n   int constants_eliminated;\n   int ops_eliminated;\n   int rewritten;\n+  int pows_encountered;\n+  int pows_created;\n } reassociate_stats;\n \n /* Operator, rank pair.  */\n@@ -177,6 +183,7 @@ typedef struct operand_entry\n   unsigned int rank;\n   int id;\n   tree op;\n+  unsigned int count;\n } *operand_entry_t;\n \n static alloc_pool operand_entry_pool;\n@@ -515,9 +522,28 @@ add_to_ops_vec (VEC(operand_entry_t, heap) **ops, tree op)\n   oe->op = op;\n   oe->rank = get_rank (op);\n   oe->id = next_operand_entry_id++;\n+  oe->count = 1;\n   VEC_safe_push (operand_entry_t, heap, *ops, oe);\n }\n \n+/* Add an operand entry to *OPS for the tree operand OP with repeat\n+   count REPEAT.  */\n+\n+static void\n+add_repeat_to_ops_vec (VEC(operand_entry_t, heap) **ops, tree op,\n+\t\t       HOST_WIDE_INT repeat)\n+{\n+  operand_entry_t oe = (operand_entry_t) pool_alloc (operand_entry_pool);\n+\n+  oe->op = op;\n+  oe->rank = get_rank (op);\n+  oe->id = next_operand_entry_id++;\n+  oe->count = repeat;\n+  VEC_safe_push (operand_entry_t, heap, *ops, oe);\n+\n+  reassociate_stats.pows_encountered++;\n+}\n+\n /* Return true if STMT is reassociable operation containing a binary\n    operation with tree code CODE, and is inside LOOP.  */\n \n@@ -2049,6 +2075,32 @@ is_phi_for_stmt (gimple stmt, tree operand)\n   return false;\n }\n \n+/* Remove STMT, unlink its virtual defs, and release its SSA defs.  */\n+\n+static inline void\n+completely_remove_stmt (gimple stmt)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  gsi_remove (&gsi, true);\n+  unlink_stmt_vdef (stmt);\n+  release_defs (stmt);\n+}\n+\n+/* If OP is defined by a builtin call that has been absorbed by\n+   reassociation, remove its defining statement completely.  */\n+\n+static inline void\n+remove_def_if_absorbed_call (tree op)\n+{\n+  gimple stmt;\n+\n+  if (TREE_CODE (op) == SSA_NAME\n+      && has_zero_uses (op)\n+      && is_gimple_call ((stmt = SSA_NAME_DEF_STMT (op)))\n+      && gimple_visited_p (stmt))\n+    completely_remove_stmt (stmt);\n+}\n+\n /* Remove def stmt of VAR if VAR has zero uses and recurse\n    on rhs1 operand if so.  */\n \n@@ -2057,19 +2109,31 @@ remove_visited_stmt_chain (tree var)\n {\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n+  tree var2;\n \n   while (1)\n     {\n       if (TREE_CODE (var) != SSA_NAME || !has_zero_uses (var))\n \treturn;\n       stmt = SSA_NAME_DEF_STMT (var);\n-      if (!is_gimple_assign (stmt)\n-\t  || !gimple_visited_p (stmt))\n+      if (is_gimple_assign (stmt) && gimple_visited_p (stmt))\n+\t{\n+\t  var = gimple_assign_rhs1 (stmt);\n+\t  var2 = gimple_assign_rhs2 (stmt);\n+\t  gsi = gsi_for_stmt (stmt);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (stmt);\n+\t  /* A multiply whose operands are both fed by builtin pow/powi\n+\t     calls must check whether to remove rhs2 as well.  */\n+\t  remove_def_if_absorbed_call (var2);\n+\t}\n+      else if (is_gimple_call (stmt) && gimple_visited_p (stmt))\n+\t{\n+\t  completely_remove_stmt (stmt);\n+\t  return;\n+\t}\n+      else\n \treturn;\n-      var = gimple_assign_rhs1 (stmt);\n-      gsi = gsi_for_stmt (stmt);\n-      gsi_remove (&gsi, true);\n-      release_defs (stmt);\n     }\n }\n \n@@ -2564,6 +2628,75 @@ break_up_subtract (gimple stmt, gimple_stmt_iterator *gsip)\n   update_stmt (stmt);\n }\n \n+/* Determine whether STMT is a builtin call that raises an SSA name\n+   to an integer power and has only one use.  If so, and this is early\n+   reassociation and unsafe math optimizations are permitted, place\n+   the SSA name in *BASE and the exponent in *EXPONENT, and return TRUE.\n+   If any of these conditions does not hold, return FALSE.  */\n+\n+static bool\n+acceptable_pow_call (gimple stmt, tree *base, HOST_WIDE_INT *exponent)\n+{\n+  tree fndecl, arg1;\n+  REAL_VALUE_TYPE c, cint;\n+\n+  if (!first_pass_instance\n+      || !flag_unsafe_math_optimizations\n+      || !is_gimple_call (stmt)\n+      || !has_single_use (gimple_call_lhs (stmt)))\n+    return false;\n+\n+  fndecl = gimple_call_fndecl (stmt);\n+\n+  if (!fndecl\n+      || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n+    return false;\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    CASE_FLT_FN (BUILT_IN_POW):\n+      *base = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+\n+      if (TREE_CODE (arg1) != REAL_CST)\n+\treturn false;\n+\n+      c = TREE_REAL_CST (arg1);\n+\n+      if (REAL_EXP (&c) > HOST_BITS_PER_WIDE_INT)\n+\treturn false;\n+\n+      *exponent = real_to_integer (&c);\n+      real_from_integer (&cint, VOIDmode, *exponent,\n+\t\t\t *exponent < 0 ? -1 : 0, 0);\n+      if (!real_identical (&c, &cint))\n+\treturn false;\n+\n+      break;\n+\n+    CASE_FLT_FN (BUILT_IN_POWI):\n+      *base = gimple_call_arg (stmt, 0);\n+      arg1 = gimple_call_arg (stmt, 1);\n+\n+      if (!host_integerp (arg1, 0))\n+\treturn false;\n+\n+      *exponent = TREE_INT_CST_LOW (arg1);\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  /* Expanding negative exponents is generally unproductive, so we don't\n+     complicate matters with those.  Exponents of zero and one should\n+     have been handled by expression folding.  */\n+  if (*exponent < 2 || TREE_CODE (*base) != SSA_NAME)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Recursively linearize a binary expression that is the RHS of STMT.\n    Place the operands of the expression tree in the vector named OPS.  */\n \n@@ -2573,11 +2706,13 @@ linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt,\n {\n   tree binlhs = gimple_assign_rhs1 (stmt);\n   tree binrhs = gimple_assign_rhs2 (stmt);\n-  gimple binlhsdef, binrhsdef;\n+  gimple binlhsdef = NULL, binrhsdef = NULL;\n   bool binlhsisreassoc = false;\n   bool binrhsisreassoc = false;\n   enum tree_code rhscode = gimple_assign_rhs_code (stmt);\n   struct loop *loop = loop_containing_stmt (stmt);\n+  tree base = NULL_TREE;\n+  HOST_WIDE_INT exponent = 0;\n \n   if (set_visited)\n     gimple_set_visited (stmt, true);\n@@ -2615,8 +2750,26 @@ linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt,\n \n       if (!binrhsisreassoc)\n \t{\n-\t  add_to_ops_vec (ops, binrhs);\n-\t  add_to_ops_vec (ops, binlhs);\n+\t  if (rhscode == MULT_EXPR\n+\t      && TREE_CODE (binrhs) == SSA_NAME\n+\t      && acceptable_pow_call (binrhsdef, &base, &exponent))\n+\t    {\n+\t      add_repeat_to_ops_vec (ops, base, exponent);\n+\t      gimple_set_visited (binrhsdef, true);\n+\t    }\n+\t  else\n+\t    add_to_ops_vec (ops, binrhs);\n+\n+\t  if (rhscode == MULT_EXPR\n+\t      && TREE_CODE (binlhs) == SSA_NAME\n+\t      && acceptable_pow_call (binlhsdef, &base, &exponent))\n+\t    {\n+\t      add_repeat_to_ops_vec (ops, base, exponent);\n+\t      gimple_set_visited (binlhsdef, true);\n+\t    }\n+\t  else\n+\t    add_to_ops_vec (ops, binlhs);\n+\n \t  return;\n \t}\n \n@@ -2655,7 +2808,16 @@ linearize_expr_tree (VEC(operand_entry_t, heap) **ops, gimple stmt,\n \t\t\t\t      rhscode, loop));\n   linearize_expr_tree (ops, SSA_NAME_DEF_STMT (binlhs),\n \t\t       is_associative, set_visited);\n-  add_to_ops_vec (ops, binrhs);\n+\n+  if (rhscode == MULT_EXPR\n+      && TREE_CODE (binrhs) == SSA_NAME\n+      && acceptable_pow_call (SSA_NAME_DEF_STMT (binrhs), &base, &exponent))\n+    {\n+      add_repeat_to_ops_vec (ops, base, exponent);\n+      gimple_set_visited (SSA_NAME_DEF_STMT (binrhs), true);\n+    }\n+  else\n+    add_to_ops_vec (ops, binrhs);\n }\n \n /* Repropagate the negates back into subtracts, since no other pass\n@@ -2815,6 +2977,347 @@ break_up_subtract_bb (basic_block bb)\n     break_up_subtract_bb (son);\n }\n \n+/* Used for repeated factor analysis.  */\n+struct repeat_factor_d\n+{\n+  /* An SSA name that occurs in a multiply chain.  */\n+  tree factor;\n+\n+  /* Cached rank of the factor.  */\n+  unsigned rank;\n+\n+  /* Number of occurrences of the factor in the chain.  */\n+  HOST_WIDE_INT count;\n+\n+  /* An SSA name representing the product of this factor and\n+     all factors appearing later in the repeated factor vector.  */\n+  tree repr;\n+};\n+\n+typedef struct repeat_factor_d repeat_factor, *repeat_factor_t;\n+typedef const struct repeat_factor_d *const_repeat_factor_t;\n+\n+DEF_VEC_O (repeat_factor);\n+DEF_VEC_ALLOC_O (repeat_factor, heap);\n+\n+static VEC (repeat_factor, heap) *repeat_factor_vec;\n+\n+/* Used for sorting the repeat factor vector.  Sort primarily by\n+   ascending occurrence count, secondarily by descending rank.  */\n+\n+static int\n+compare_repeat_factors (const void *x1, const void *x2)\n+{\n+  const_repeat_factor_t rf1 = (const_repeat_factor_t) x1;\n+  const_repeat_factor_t rf2 = (const_repeat_factor_t) x2;\n+\n+  if (rf1->count != rf2->count)\n+    return rf1->count - rf2->count;\n+\n+  return rf2->rank - rf1->rank;\n+}\n+\n+/* Get a new SSA name for register variable *TARGET of type TYPE.\n+   If *TARGET is null or incompatible with TYPE, create the variable\n+   first.  */\n+\n+static tree\n+get_reassoc_pow_ssa_name (tree *target, tree type)\n+{\n+  if (!*target || !types_compatible_p (type, TREE_TYPE (*target)))\n+    {\n+      *target = create_tmp_reg (type, \"reassocpow\");\n+      add_referenced_var (*target);\n+    }\n+\n+  return make_ssa_name (*target, NULL);\n+}\n+\n+/* Look for repeated operands in OPS in the multiply tree rooted at\n+   STMT.  Replace them with an optimal sequence of multiplies and powi\n+   builtin calls, and remove the used operands from OPS.  Push new\n+   SSA names onto OPS that represent the introduced multiplies and\n+   builtin calls.  */\n+\n+static void\n+attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops,\n+\t\t      tree *target)\n+{\n+  unsigned i, j, vec_len;\n+  int ii;\n+  operand_entry_t oe;\n+  repeat_factor_t rf1, rf2;\n+  repeat_factor rfnew;\n+  tree target_ssa, iter_result;\n+  tree type = TREE_TYPE (gimple_get_lhs (stmt));\n+  tree powi_fndecl = mathfn_built_in (type, BUILT_IN_POWI);\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  gimple mul_stmt, pow_stmt;\n+\n+  /* Nothing to do if BUILT_IN_POWI doesn't exist for this type and\n+     target.  */\n+  if (!powi_fndecl)\n+    return;\n+\n+  /* Allocate the repeated factor vector.  */\n+  repeat_factor_vec = VEC_alloc (repeat_factor, heap, 10);\n+\n+  /* Scan the OPS vector for all SSA names in the product and build\n+     up a vector of occurrence counts for each factor.  */\n+  FOR_EACH_VEC_ELT (operand_entry_t, *ops, i, oe)\n+    {\n+      if (TREE_CODE (oe->op) == SSA_NAME)\n+\t{\n+\t  FOR_EACH_VEC_ELT (repeat_factor, repeat_factor_vec, j, rf1)\n+\t    {\n+\t      if (rf1->factor == oe->op)\n+\t\t{\n+\t\t  rf1->count += oe->count;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (j >= VEC_length (repeat_factor, repeat_factor_vec))\n+\t    {\n+\t      rfnew.factor = oe->op;\n+\t      rfnew.rank = oe->rank;\n+\t      rfnew.count = oe->count;\n+\t      rfnew.repr = NULL_TREE;\n+\t      VEC_safe_push (repeat_factor, heap, repeat_factor_vec, &rfnew);\n+\t    }\n+\t}\n+    }\n+\n+  /* Sort the repeated factor vector by (a) increasing occurrence count,\n+     and (b) decreasing rank.  */\n+  VEC_qsort (repeat_factor, repeat_factor_vec, compare_repeat_factors);\n+\n+  /* It is generally best to combine as many base factors as possible\n+     into a product before applying __builtin_powi to the result.\n+     However, the sort order chosen for the repeated factor vector\n+     allows us to cache partial results for the product of the base\n+     factors for subsequent use.  When we already have a cached partial\n+     result from a previous iteration, it is best to make use of it\n+     before looking for another __builtin_pow opportunity.\n+\n+     As an example, consider x * x * y * y * y * z * z * z * z.\n+     We want to first compose the product x * y * z, raise it to the\n+     second power, then multiply this by y * z, and finally multiply\n+     by z.  This can be done in 5 multiplies provided we cache y * z\n+     for use in both expressions:\n+\n+        t1 = y * z\n+\tt2 = t1 * x\n+\tt3 = t2 * t2\n+\tt4 = t1 * t3\n+\tresult = t4 * z\n+\n+     If we instead ignored the cached y * z and first multiplied by\n+     the __builtin_pow opportunity z * z, we would get the inferior:\n+\n+        t1 = y * z\n+\tt2 = t1 * x\n+\tt3 = t2 * t2\n+\tt4 = z * z\n+\tt5 = t3 * t4\n+        result = t5 * y  */\n+\n+  vec_len = VEC_length (repeat_factor, repeat_factor_vec);\n+  \n+  /* Repeatedly look for opportunities to create a builtin_powi call.  */\n+  while (true)\n+    {\n+      HOST_WIDE_INT power;\n+\n+      /* First look for the largest cached product of factors from\n+\t preceding iterations.  If found, create a builtin_powi for\n+\t it if the minimum occurrence count for its factors is at\n+\t least 2, or just use this cached product as our next \n+\t multiplicand if the minimum occurrence count is 1.  */\n+      FOR_EACH_VEC_ELT (repeat_factor, repeat_factor_vec, j, rf1)\n+\t{\n+\t  if (rf1->repr && rf1->count > 0)\n+\t    break;\n+\t}\n+\n+      if (j < vec_len)\n+\t{\n+\t  power = rf1->count;\n+\n+\t  if (power == 1)\n+\t    {\n+\t      iter_result = rf1->repr;\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  unsigned elt;\n+\t\t  repeat_factor_t rf;\n+\t\t  fputs (\"Multiplying by cached product \", dump_file);\n+\t\t  for (elt = j; elt < vec_len; elt++)\n+\t\t    {\n+\t\t      rf = VEC_index (repeat_factor, repeat_factor_vec, elt);\n+\t\t      print_generic_expr (dump_file, rf->factor, 0);\n+\t\t      if (elt < vec_len - 1)\n+\t\t\tfputs (\" * \", dump_file);\n+\t\t    }\n+\t\t  fputs (\"\\n\", dump_file);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      iter_result = get_reassoc_pow_ssa_name (target, type);\n+\t      pow_stmt = gimple_build_call (powi_fndecl, 2, rf1->repr, \n+\t\t\t\t\t    build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t   power));\n+\t      gimple_call_set_lhs (pow_stmt, iter_result);\n+\t      gimple_set_location (pow_stmt, gimple_location (stmt));\n+\t      gsi_insert_before (&gsi, pow_stmt, GSI_SAME_STMT);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  unsigned elt;\n+\t\t  repeat_factor_t rf;\n+\t\t  fputs (\"Building __builtin_pow call for cached product (\",\n+\t\t\t dump_file);\n+\t\t  for (elt = j; elt < vec_len; elt++)\n+\t\t    {\n+\t\t      rf = VEC_index (repeat_factor, repeat_factor_vec, elt);\n+\t\t      print_generic_expr (dump_file, rf->factor, 0);\n+\t\t      if (elt < vec_len - 1)\n+\t\t\tfputs (\" * \", dump_file);\n+\t\t    }\n+\t\t  fprintf (dump_file, \")^%ld\\n\", power);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, find the first factor in the repeated factor\n+\t     vector whose occurrence count is at least 2.  If no such\n+\t     factor exists, there are no builtin_powi opportunities\n+\t     remaining.  */\n+\t  FOR_EACH_VEC_ELT (repeat_factor, repeat_factor_vec, j, rf1)\n+\t    {\n+\t      if (rf1->count >= 2)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (j >= vec_len)\n+\t    break;\n+\n+\t  power = rf1->count;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      unsigned elt;\n+\t      repeat_factor_t rf;\n+\t      fputs (\"Building __builtin_pow call for (\", dump_file);\n+\t      for (elt = j; elt < vec_len; elt++)\n+\t\t{\n+\t\t  rf = VEC_index (repeat_factor, repeat_factor_vec, elt);\n+\t\t  print_generic_expr (dump_file, rf->factor, 0);\n+\t\t  if (elt < vec_len - 1)\n+\t\t    fputs (\" * \", dump_file);\n+\t\t}\n+\t      fprintf (dump_file, \")^%ld\\n\", power);\n+\t    }\n+\n+\t  reassociate_stats.pows_created++;\n+\n+\t  /* Visit each element of the vector in reverse order (so that\n+\t     high-occurrence elements are visited first, and within the\n+\t     same occurrence count, lower-ranked elements are visited\n+\t     first).  Form a linear product of all elements in this order\n+\t     whose occurrencce count is at least that of element J.\n+\t     Record the SSA name representing the product of each element\n+\t     with all subsequent elements in the vector.  */\n+\t  if (j == vec_len - 1)\n+\t    rf1->repr = rf1->factor;\n+\t  else\n+\t    {\n+\t      for (ii = vec_len - 2; ii >= (int)j; ii--)\n+\t\t{\n+\t\t  tree op1, op2;\n+\n+\t\t  rf1 = VEC_index (repeat_factor, repeat_factor_vec, ii);\n+\t\t  rf2 = VEC_index (repeat_factor, repeat_factor_vec, ii + 1);\n+\n+\t\t  /* Init the last factor's representative to be itself.  */\n+\t\t  if (!rf2->repr)\n+\t\t    rf2->repr = rf2->factor;\n+\n+\t\t  op1 = rf1->factor;\n+\t\t  op2 = rf2->repr;\n+\n+\t\t  target_ssa = get_reassoc_pow_ssa_name (target, type);\n+\t\t  mul_stmt = gimple_build_assign_with_ops (MULT_EXPR,\n+\t\t\t\t\t\t\t   target_ssa,\n+\t\t\t\t\t\t\t   op1, op2);\n+\t\t  gimple_set_location (mul_stmt, gimple_location (stmt));\n+\t\t  gsi_insert_before (&gsi, mul_stmt, GSI_SAME_STMT);\n+\t\t  rf1->repr = target_ssa;\n+\n+\t\t  /* Don't reprocess the multiply we just introduced.  */\n+\t\t  gimple_set_visited (mul_stmt, true);\n+\t\t}\n+\t    }\n+\n+\t  /* Form a call to __builtin_powi for the maximum product\n+\t     just formed, raised to the power obtained earlier.  */\n+\t  rf1 = VEC_index (repeat_factor, repeat_factor_vec, j);\n+\t  iter_result = get_reassoc_pow_ssa_name (target, type);\n+\t  pow_stmt = gimple_build_call (powi_fndecl, 2, rf1->repr, \n+\t\t\t\t\tbuild_int_cst (integer_type_node,\n+\t\t\t\t\t\t       power));\n+\t  gimple_call_set_lhs (pow_stmt, iter_result);\n+\t  gimple_set_location (pow_stmt, gimple_location (stmt));\n+\t  gsi_insert_before (&gsi, pow_stmt, GSI_SAME_STMT);\n+\t}\n+\n+      /* Append the result of this iteration to the ops vector.  */\n+      add_to_ops_vec (ops, iter_result);\n+\n+      /* Decrement the occurrence count of each element in the product\n+\t by the count found above, and remove this many copies of each\n+\t factor from OPS.  */\n+      for (i = j; i < vec_len; i++)\n+\t{\n+\t  unsigned k = power;\n+\t  unsigned n;\n+\n+\t  rf1 = VEC_index (repeat_factor, repeat_factor_vec, i);\n+\t  rf1->count -= power;\n+\t  \n+\t  FOR_EACH_VEC_ELT_REVERSE (operand_entry_t, *ops, n, oe)\n+\t    {\n+\t      if (oe->op == rf1->factor)\n+\t\t{\n+\t\t  if (oe->count <= k)\n+\t\t    {\n+\t\t      VEC_ordered_remove (operand_entry_t, *ops, n);\n+\t\t      k -= oe->count;\n+\n+\t\t      if (k == 0)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      oe->count -= k;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* At this point all elements in the repeated factor vector have a\n+     remaining occurrence count of 0 or 1, and those with a count of 1\n+     don't have cached representatives.  Re-sort the ops vector and\n+     clean up.  */\n+  VEC_qsort (operand_entry_t, *ops, sort_by_operand_rank);\n+  VEC_free (repeat_factor, heap, repeat_factor_vec);\n+}\n+\n /* Reassociate expressions in basic block BB and its post-dominator as\n    children.  */\n \n@@ -2823,6 +3326,7 @@ reassociate_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   basic_block son;\n+  tree target = NULL_TREE;\n \n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n@@ -2904,6 +3408,11 @@ reassociate_bb (basic_block bb)\n \t      if (rhs_code == BIT_IOR_EXPR || rhs_code == BIT_AND_EXPR)\n \t\toptimize_range_tests (rhs_code, &ops);\n \n+\t      if (first_pass_instance\n+\t\t  && rhs_code == MULT_EXPR\n+\t\t  && flag_unsafe_math_optimizations)\n+\t\tattempt_builtin_powi (stmt, &ops, &target);\n+\n \t      if (VEC_length (operand_entry_t, ops) == 1)\n \t\t{\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3054,6 +3563,10 @@ fini_reassoc (void)\n \t\t\t    reassociate_stats.ops_eliminated);\n   statistics_counter_event (cfun, \"Statements rewritten\",\n \t\t\t    reassociate_stats.rewritten);\n+  statistics_counter_event (cfun, \"Built-in pow[i] calls encountered\",\n+\t\t\t    reassociate_stats.pows_encountered);\n+  statistics_counter_event (cfun, \"Built-in powi calls created\",\n+\t\t\t    reassociate_stats.pows_created);\n \n   pointer_map_destroy (operand_rank);\n   free_alloc_pool (operand_entry_pool);"}]}