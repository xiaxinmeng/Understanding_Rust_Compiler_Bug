{"sha": "87c476a22c6090159a3ab645561d9e1853af8d09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjNDc2YTIyYzYwOTAxNTlhM2FiNjQ1NTYxZDllMTg1M2FmOGQwOQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-26T19:53:13Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-26T19:53:13Z"}, "message": "bitmap.h (EXECUTE_IF_SET_IN_BITMAP, [...]): Changed to iterator style.\n\n\t* bitmap.h (EXECUTE_IF_SET_IN_BITMAP, EXECUTE_IF_AND_COMPL_IN_BITMAP,\n\tEXECUTE_IF_AND_IN_BITMAP): Changed to iterator style.\n\t(bitmap_iterator): New type.\n\t(bmp_iter_common_next_1, bmp_iter_single_next_1, bmp_iter_single_init,\n\tbmp_iter_end_p, bmp_iter_single_next, bmp_iter_and_not_next_1,\n\tbmp_iter_and_not_init, bmp_iter_and_not_next, bmp_iter_and_next_1,\n\tbmp_iter_and_init, bmp_iter_and_next): New functions.\n\t* basic-block.h (EXECUTE_IF_SET_IN_REG_SET,\n\tEXECUTE_IF_AND_COMPL_IN_REG_SET, EXECUTE_IF_AND_IN_REG_SET): Changed to\n\tuse iterator-style EXECUTE_IF_IN_BITMAP macros.\n\t* bitmap.c (bitmap_print): Ditto.\n\t* bt-load.c (clear_btr_from_live_range, add_btr_to_live_range,\n\tbtr_def_live_range): Ditto.\n\t* cfganal.c (compute_dominance_frontiers_1) Ditto.\n\t* cgraphunit.c (convert_UIDs_in_bitmap, cgraph_characterize_statics):\n\tDitto.\n\t* ddg.c (build_inter_loop_deps): Ditto.\n\t* df.c (FOR_EACH_BB_IN_BITMAP, df_bb_reg_info_compute, df_refs_update):\n\tDitto.\n\t* except.c (remove_eh_handler): Ditto.\n\t* flow.c (reg_set_to_hard_reg_set): Ditto.\n\t* gcse.c (clear_modify_mem_tables): Ditto.\n\t* global.c (build_insn_chain): Ditto.\n\t* ifcvt.c (dead_or_predicable): Ditto.\n\t* loop-invariant.c (get_inv_cost, set_move_mark, move_invariant_reg):\n\tDitto.\n\t* ra-build.c (livethrough_conflicts_bb, conflicts_between_webs): Ditto.\n\t* ra-rewrite.c (reloads_to_loads, rewrite_program2,\n\tdetect_web_parts_to_rebuild, delete_useless_defs, actual_spill): Ditto.\n\t* tree-cfg.c (allocate_ssa_names, tree_duplicate_sese_region,\n\ttree_purge_all_dead_eh_edges): Ditto.\n\t* tree-into-ssa.c (compute_global_livein, insert_phi_nodes,\n\tinsert_phi_nodes_for, debug_def_blocks_r, invalidate_name_tags,\n\trewrite_ssa_into_ssa): Ditto.\n\t* tree-outof-ssa.c (find_replaceable_exprs): Ditto.\n\t* tree-sra.c (scan_function, decide_instantiations, scalarize_parms):\n\tDitto.\n\t* tree-ssa-alias.c (init_alias_info, compute_points_to_and_addr_escape,\n\tcompute_flow_sensitive_aliasing, maybe_create_global_var,\n\tdump_points_to_info_for): Ditto.\n\t* tree-ssa-dce.c (EXECUTE_IF_CONTROL_DEPENDENT): Ditto.\n\t* tree-ssa-dse.c (dse_finalize_block): Ditto.\n\t* tree-ssa-live.c (live_worklist, calculate_live_on_entry,\n\tcalculate_live_on_exit, build_tree_conflict_graph, dump_live_info):\n\tDitto.\n\t* tree-ssa-loop-ivopts.c (find_induction_variables,\n\tfind_interesting_uses, add_old_ivs_candidates, alloc_use_cost_map,\n\tdetermine_use_iv_costs, determine_set_costs, find_best_candidate,\n\tset_cost_up_to, create_new_ivs, remove_unused_ivs, free_loop_data):\n\tDitto.\n\t* tree-ssa-loop-manip.c (add_exit_phis_var, add_exit_phis): Ditto.\n\t* tree-ssa-operands.c (get_asm_expr_operands, add_call_clobber_ops,\n\tadd_call_read_ops): Ditto.\n\t* tree-ssa-pre.c (bitmap_print_value_set, insert_aux): Ditto.\n\nFrom-SVN: r88145", "tree": {"sha": "5a3c9bcba3d78b6ee1c1f3cb79e280b227446aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a3c9bcba3d78b6ee1c1f3cb79e280b227446aa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87c476a22c6090159a3ab645561d9e1853af8d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c476a22c6090159a3ab645561d9e1853af8d09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c476a22c6090159a3ab645561d9e1853af8d09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c476a22c6090159a3ab645561d9e1853af8d09/comments", "author": null, "committer": null, "parents": [{"sha": "69049ba07afa22a5686db85e7e9a1602be795d62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69049ba07afa22a5686db85e7e9a1602be795d62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69049ba07afa22a5686db85e7e9a1602be795d62"}], "stats": {"total": 1420, "additions": 946, "deletions": 474}, "files": [{"sha": "5bde1115c963a34307a34b70ee0ac1d12bc8d1a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1,3 +1,60 @@\n+2004-09-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* bitmap.h (EXECUTE_IF_SET_IN_BITMAP, EXECUTE_IF_AND_COMPL_IN_BITMAP,\n+\tEXECUTE_IF_AND_IN_BITMAP): Changed to iterator style.\n+\t(bitmap_iterator): New type.\n+\t(bmp_iter_common_next_1, bmp_iter_single_next_1, bmp_iter_single_init,\n+\tbmp_iter_end_p, bmp_iter_single_next, bmp_iter_and_not_next_1,\n+\tbmp_iter_and_not_init, bmp_iter_and_not_next, bmp_iter_and_next_1,\n+\tbmp_iter_and_init, bmp_iter_and_next): New functions.\n+\t* basic-block.h (EXECUTE_IF_SET_IN_REG_SET,\n+\tEXECUTE_IF_AND_COMPL_IN_REG_SET, EXECUTE_IF_AND_IN_REG_SET): Changed to\n+\tuse iterator-style EXECUTE_IF_IN_BITMAP macros.\n+\t* bitmap.c (bitmap_print): Ditto.\n+\t* bt-load.c (clear_btr_from_live_range, add_btr_to_live_range,\n+\tbtr_def_live_range): Ditto.\n+\t* cfganal.c (compute_dominance_frontiers_1) Ditto.\n+\t* cgraphunit.c (convert_UIDs_in_bitmap, cgraph_characterize_statics):\n+\tDitto.\n+\t* ddg.c (build_inter_loop_deps): Ditto.\n+\t* df.c (FOR_EACH_BB_IN_BITMAP, df_bb_reg_info_compute, df_refs_update):\n+\tDitto.\n+\t* except.c (remove_eh_handler): Ditto.\n+\t* flow.c (reg_set_to_hard_reg_set): Ditto.\n+\t* gcse.c (clear_modify_mem_tables): Ditto.\n+\t* global.c (build_insn_chain): Ditto.\n+\t* ifcvt.c (dead_or_predicable): Ditto.\n+\t* loop-invariant.c (get_inv_cost, set_move_mark, move_invariant_reg):\n+\tDitto.\n+\t* ra-build.c (livethrough_conflicts_bb, conflicts_between_webs): Ditto.\n+\t* ra-rewrite.c (reloads_to_loads, rewrite_program2,\n+\tdetect_web_parts_to_rebuild, delete_useless_defs, actual_spill): Ditto.\n+\t* tree-cfg.c (allocate_ssa_names, tree_duplicate_sese_region,\n+\ttree_purge_all_dead_eh_edges): Ditto.\n+\t* tree-into-ssa.c (compute_global_livein, insert_phi_nodes,\n+\tinsert_phi_nodes_for, debug_def_blocks_r, invalidate_name_tags,\n+\trewrite_ssa_into_ssa): Ditto.\n+\t* tree-outof-ssa.c (find_replaceable_exprs): Ditto.\n+\t* tree-sra.c (scan_function, decide_instantiations, scalarize_parms):\n+\tDitto.\n+\t* tree-ssa-alias.c (init_alias_info, compute_points_to_and_addr_escape,\n+\tcompute_flow_sensitive_aliasing, maybe_create_global_var,\n+\tdump_points_to_info_for): Ditto.\n+\t* tree-ssa-dce.c (EXECUTE_IF_CONTROL_DEPENDENT): Ditto.\n+\t* tree-ssa-dse.c (dse_finalize_block): Ditto.\n+\t* tree-ssa-live.c (live_worklist, calculate_live_on_entry,\n+\tcalculate_live_on_exit, build_tree_conflict_graph, dump_live_info):\n+\tDitto.\n+\t* tree-ssa-loop-ivopts.c (find_induction_variables,\n+\tfind_interesting_uses, add_old_ivs_candidates, alloc_use_cost_map,\n+\tdetermine_use_iv_costs, determine_set_costs, find_best_candidate,\n+\tset_cost_up_to, create_new_ivs, remove_unused_ivs, free_loop_data):\n+\tDitto.\n+\t* tree-ssa-loop-manip.c (add_exit_phis_var, add_exit_phis): Ditto.\n+\t* tree-ssa-operands.c (get_asm_expr_operands, add_call_clobber_ops,\n+\tadd_call_read_ops): Ditto.\n+\t* tree-ssa-pre.c (bitmap_print_value_set, insert_aux): Ditto.\n+\n 2004-09-26  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.c (print_operand): Use non-trapping completers for UNLE, UNLT,"}, {"sha": "978f313a3cce2811da280a4089d83d33bfda30ee", "filename": "gcc/basic-block.h", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -84,19 +84,43 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Loop over all registers in REGSET, starting with MIN, setting REGNUM to the\n    register number and executing CODE for all registers that are set.  */\n #define EXECUTE_IF_SET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\t\\\n-  EXECUTE_IF_SET_IN_BITMAP (REGSET, MIN, REGNUM, CODE)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bitmap_iterator bi;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      EXECUTE_IF_SET_IN_BITMAP (REGSET, MIN, REGNUM, bi)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  CODE;\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    } while (0)\n \n /* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n    REGNUM to the register number and executing CODE for all registers that are\n    set in the first regset and not set in the second.  */\n #define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n-  EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bitmap_iterator bi;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, bi) \\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  CODE;\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    } while (0)\n \n /* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n    REGNUM to the register number and executing CODE for all registers that are\n    set in both regsets.  */\n #define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n-  EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bitmap_iterator bi;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, bi)\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  CODE;\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    } while (0)\n \n /* Allocate a register set with oballoc.  */\n #define OBSTACK_ALLOC_REG_SET(OBSTACK) BITMAP_OBSTACK_ALLOC (OBSTACK)"}, {"sha": "b678df99d69b6ff2daab34e8649a1cda84138c07", "filename": "gcc/bitmap.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -779,13 +779,14 @@ bitmap_print (FILE *file, bitmap head, const char *prefix, const char *suffix)\n {\n   const char *comma = \"\";\n   int i;\n+  bitmap_iterator bi;\n \n   fputs (prefix, file);\n-  EXECUTE_IF_SET_IN_BITMAP (head, 0, i,\n-\t\t\t    {\n-\t\t\t      fprintf (file, \"%s%d\", comma, i);\n-\t\t\t      comma = \", \";\n-\t\t\t    });\n+  EXECUTE_IF_SET_IN_BITMAP (head, 0, i, bi)\n+    {\n+      fprintf (file, \"%s%d\", comma, i);\n+      comma = \", \";\n+    }\n   fputs (suffix, file);\n }\n "}, {"sha": "76cd473cee640d33dca12c2470d3ffb3fa48f292", "filename": "gcc/bitmap.h", "status": "modified", "additions": 418, "deletions": 187, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -162,194 +162,425 @@ do {\t\t\t\t\t\t\\\n /* Do any one-time initializations needed for bitmaps.  */\n #define BITMAP_INIT_ONCE()\n \n-/* Loop over all bits in BITMAP, starting with MIN, setting BITNUM to the\n-   bit number and executing CODE for all bits that are set.  */\n-\n-#define EXECUTE_IF_SET_IN_BITMAP(BITMAP, MIN, BITNUM, CODE)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  bitmap_element *ptr_ = (BITMAP)->first;\t\t\t\t\\\n-  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n-  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n-  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* Find the block the minimum bit is in.  */\t\t\t\t\\\n-  while (ptr_ != 0 && ptr_->indx < indx_)\t\t\t\t\\\n-    ptr_ = ptr_->next;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (ptr_ != 0 && ptr_->indx != indx_)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      bit_num_ = 0;\t\t\t\t\t\t\t\\\n-      word_num_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (; ptr_ != 0; ptr_ = ptr_->next)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  BITMAP_WORD word_ = ptr_->bits[word_num_];\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  if (word_ != 0)\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n-\t\t    {\t\t\t\t\t\t\t\\\n-\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n-\t\t      (BITNUM) = (ptr_->indx * BITMAP_ELEMENT_ALL_BITS  \\\n-\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n-\t\t\t\t  + bit_num_);\t\t\t\t\\\n-\t\t      CODE;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t      if (word_ == 0)\t\t\t\t\t\\\n-\t\t\tbreak;\t\t\t\t\t\t\\\n-\t\t    }\t\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      word_num_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+/* Iterator for bitmaps.  */\n \n-/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n-   BITNUM to the bit number and executing CODE for all bits that are set in\n-   the first bitmap and not set in the second.  */\n-\n-#define EXECUTE_IF_AND_COMPL_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n-  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n-  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n-  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n-  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n-  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n-    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      bit_num_ = 0;\t\t\t\t\t\t\t\\\n-      word_num_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Advance BITMAP2 to the equivalent link, using an all\t\t\\\n-\t zero element if an equivalent link doesn't exist.  */\t\t\\\n-      bitmap_element *tmp2_;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n-\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      tmp2_ = ((ptr2_ != 0 && ptr2_->indx == ptr1_->indx)\t\t\\\n-\t       ? ptr2_ : &bitmap_zero_bits);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  BITMAP_WORD word_ = (ptr1_->bits[word_num_]\t\t\t\\\n-\t\t\t       & ~ tmp2_->bits[word_num_]);\t\t\\\n-\t  if (word_ != 0)\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n-\t\t    {\t\t\t\t\t\t\t\\\n-\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n-\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n-\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n-\t\t\t\t  + bit_num_);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t      CODE;\t\t\t\t\t\t\\\n-\t\t      if (word_ == 0)\t\t\t\t\t\\\n-\t\t\tbreak;\t\t\t\t\t\t\\\n-\t\t    }\t\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      word_num_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+typedef struct\n+{\n+  /* Actual elements in the bitmaps.  */\n+  bitmap_element *ptr1, *ptr2;\n \n-/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n-   BITNUM to the bit number and executing CODE for all bits that are set in\n-   the both bitmaps.  */\n-\n-#define EXECUTE_IF_AND_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n-  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n-  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n-  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n-  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n-  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n-    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      bit_num_ = 0;\t\t\t\t\t\t\t\\\n-      word_num_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Advance BITMAP2 to the equivalent link.  */\t\t\t\\\n-      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n-\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (ptr2_ == 0)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  /* If there are no more elements in BITMAP2, exit loop now.  */ \\\n-\t  ptr1_ = (bitmap_element *)0;\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (ptr2_->indx > ptr1_->indx)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  bit_num_ = word_num_ = 0;\t\t\t\t\t\\\n-\t  continue;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  BITMAP_WORD word_ = (ptr1_->bits[word_num_]\t\t\t\\\n-\t\t\t       & ptr2_->bits[word_num_]);\t\t\\\n-\t  if (word_ != 0)\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n-\t\t    {\t\t\t\t\t\t\t\\\n-\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n-\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n-\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n-\t\t\t\t  + bit_num_);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t      CODE;\t\t\t\t\t\t\\\n-\t\t      if (word_ == 0)\t\t\t\t\t\\\n-\t\t\tbreak;\t\t\t\t\t\t\\\n-\t\t    }\t\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      word_num_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  /* Position of an actual word in the elements.  */\n+  unsigned word;\n+\n+  /* Position of a bit corresponding to the start of word.  */\n+  unsigned word_bit;\n+\n+  /* Position of the actual bit.  */\n+  unsigned bit;\n+\n+  /* Contents of the actually processed word.  When finding next bit\n+     it is shifted right, so that the actual bit is always the least\n+     significant bit of ACTUAL.  */\n+  BITMAP_WORD actual;\n+} bitmap_iterator;\n+\n+/* Moves the iterator BI to the first set bit on or after the current\n+   position in bitmap and returns the bit if available.  The bit is\n+   found in ACTUAL field only.  */\n+\n+static inline unsigned\n+bmp_iter_common_next_1 (bitmap_iterator *bi)\n+{\n+  while (!(bi->actual & 1))\n+    {\n+      bi->actual >>= 1;\n+      bi->bit++;\n+    }\n+\n+  return bi->bit;\n+}\n+\n+/* Moves the iterator BI to the first set bit on or after the current\n+   position in bitmap and returns the bit if available.  */\n+\n+static inline unsigned\n+bmp_iter_single_next_1 (bitmap_iterator *bi)\n+{\n+  if (bi->actual)\n+    return bmp_iter_common_next_1 (bi);\n+\n+  bi->word++;\n+  bi->word_bit += BITMAP_WORD_BITS;\n+\n+  while (1)\n+    {\n+      for (;\n+\t   bi->word < BITMAP_ELEMENT_WORDS;\n+\t   bi->word++, bi->word_bit += BITMAP_WORD_BITS)\n+\t{\n+\t  bi->actual = bi->ptr1->bits[bi->word];\n+\t  if (bi->actual)\n+\t    {\n+\t      bi->bit = bi->word_bit;\n+\t      return bmp_iter_common_next_1 (bi);\n+\t    }\n+\t}\n+\n+      bi->ptr1 = bi->ptr1->next;\n+      if (!bi->ptr1)\n+\treturn 0;\n+\n+      bi->word = 0;\n+      bi->word_bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+    }\n+}\n+\n+/* Initializes a bitmap iterator BI for looping over bits of bitmap\n+   BMP, starting with bit MIN.  Returns the first bit of BMP greater\n+   or equal to MIN if there is any.  */\n+\n+static inline unsigned\n+bmp_iter_single_init (bitmap_iterator *bi, bitmap bmp, unsigned min)\n+{\n+  unsigned indx = min / BITMAP_ELEMENT_ALL_BITS;\n+\n+  for (bi->ptr1 = bmp->first;\n+       bi->ptr1 && bi->ptr1->indx < indx;\n+       bi->ptr1 = bi->ptr1->next)\n+    continue;\n+\n+  if (!bi->ptr1)\n+    {\n+      /* To avoid warnings.  */\n+      bi->word = 0;\n+      bi->bit = 0;\n+      bi->word_bit = 0;\n+      bi->actual = 0;\n+      bi->ptr2 = NULL;\n+      return 0;\n+    }\n+\n+  if (bi->ptr1->indx == indx)\n+    {\n+      unsigned bit_in_elt = min - BITMAP_ELEMENT_ALL_BITS * indx;\n+      unsigned word_in_elt = bit_in_elt / BITMAP_WORD_BITS;\n+      unsigned bit_in_word = bit_in_elt % BITMAP_WORD_BITS;\n+\n+      bi->word = word_in_elt;\n+      bi->word_bit = min - bit_in_word;\n+      bi->bit = min;\n+      bi->actual = bi->ptr1->bits[word_in_elt] >> bit_in_elt;\n+    }\n+  else\n+    {\n+      bi->word = 0;\n+      bi->bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      bi->word_bit = bi->bit;\n+      bi->actual = bi->ptr1->bits[0];\n+    }\n+\n+  return bmp_iter_single_next_1 (bi);\n+}\n+\n+/* Returns true if all elements of the bitmap refered to by iterator BI\n+   were processed.  */\n+\n+static inline bool\n+bmp_iter_end_p (bitmap_iterator bi)\n+{\n+  return bi.ptr1 == NULL;\n+}\n+\n+/* Moves the iterator BI to the next bit of bitmap and returns the bit\n+   if available.  */\n+\n+static inline unsigned\n+bmp_iter_single_next (bitmap_iterator *bi)\n+{\n+  bi->bit++;\n+  bi->actual >>= 1;\n+  return bmp_iter_single_next_1 (bi);\n+}\n+\n+/* Loop over all bits in BITMAP, starting with MIN and setting BITNUM to\n+   the bit number.  ITER is a bitmap iterator.  */\n+\n+#define EXECUTE_IF_SET_IN_BITMAP(BITMAP, MIN, BITNUM, ITER)\t\t\\\n+  for ((BITNUM) = bmp_iter_single_init (&(ITER), (BITMAP), (MIN));\t\\\n+       !bmp_iter_end_p (ITER);\t\t\t\t\t\\\n+       (BITNUM) = bmp_iter_single_next (&(ITER)))\n+\n+/* Moves the iterator BI to the first set bit on or after the current\n+   position in difference of bitmaps and returns the bit if available.  */\n+\n+static inline unsigned\n+bmp_iter_and_not_next_1 (bitmap_iterator *bi)\n+{\n+  if (bi->actual)\n+    return bmp_iter_common_next_1 (bi);\n+\n+  bi->word++;\n+  bi->word_bit += BITMAP_WORD_BITS;\n+\n+  while (1)\n+    {\n+      bitmap_element *snd;\n+\n+      if (bi->ptr2 && bi->ptr2->indx == bi->ptr1->indx)\n+\tsnd = bi->ptr2;\n+      else\n+\tsnd = &bitmap_zero_bits;\n+\n+      for (;\n+\t   bi->word < BITMAP_ELEMENT_WORDS;\n+\t   bi->word++, bi->word_bit += BITMAP_WORD_BITS)\n+\t{\n+\t  bi->actual = (bi->ptr1->bits[bi->word]\n+\t\t\t& ~snd->bits[bi->word]);\n+\t  if (bi->actual)\n+\t    {\n+\t      bi->bit = bi->word_bit;\n+\t      return bmp_iter_common_next_1 (bi);\n+\t    }\n+\t}\n+\n+      bi->ptr1 = bi->ptr1->next;\n+      if (!bi->ptr1)\n+\treturn 0;\n+\n+      while (bi->ptr2\n+\t     && bi->ptr2->indx < bi->ptr1->indx)\n+\tbi->ptr2 = bi->ptr2->next;\n+\n+      bi->word = 0;\n+      bi->word_bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+    }\n+}\n+\n+/* Initializes a bitmap iterator BI for looping over bits of bitmap\n+   BMP1 &~ BMP2, starting with bit MIN.  Returns the first bit of\n+   BMP1 &~ BMP2 greater or equal to MIN if there is any.  */\n+\n+static inline unsigned\n+bmp_iter_and_not_init (bitmap_iterator *bi, bitmap bmp1, bitmap bmp2,\n+\t\t       unsigned min)\n+{\n+  unsigned indx = min / BITMAP_ELEMENT_ALL_BITS;\n+\n+  for (bi->ptr1 = bmp1->first;\n+       bi->ptr1 && bi->ptr1->indx < indx;\n+       bi->ptr1 = bi->ptr1->next)\n+    continue;\n+\n+  if (!bi->ptr1)\n+    {\n+      /* To avoid warnings.  */\n+      bi->word = 0;\n+      bi->bit = 0;\n+      bi->word_bit = 0;\n+      bi->actual = 0;\n+      bi->ptr2 = NULL;\n+      return 0;\n+    }\n+\n+  for (bi->ptr2 = bmp2->first;\n+       bi->ptr2 && bi->ptr2->indx < bi->ptr1->indx;\n+       bi->ptr2 = bi->ptr2->next)\n+    continue;\n+\n+  if (bi->ptr1->indx == indx)\n+    {\n+      unsigned bit_in_elt = min - BITMAP_ELEMENT_ALL_BITS * indx;\n+      unsigned word_in_elt = bit_in_elt / BITMAP_WORD_BITS;\n+      unsigned bit_in_word = bit_in_elt % BITMAP_WORD_BITS;\n+\n+      bi->word = word_in_elt;\n+      bi->word_bit = min - bit_in_word;\n+      bi->bit = min;\n+\n+      if (bi->ptr2 && bi->ptr2->indx == indx)\n+\tbi->actual = (bi->ptr1->bits[word_in_elt]\n+\t\t      & ~bi->ptr2->bits[word_in_elt]) >> bit_in_elt;\n+      else\n+\tbi->actual = bi->ptr1->bits[word_in_elt] >> bit_in_elt;\n+    }\n+  else\n+    {\n+      bi->word = 0;\n+      bi->bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      bi->word_bit = bi->bit;\n+\n+      if (bi->ptr2 && bi->ptr2->indx == bi->ptr1->indx)\n+\tbi->actual = (bi->ptr1->bits[0] & ~bi->ptr2->bits[0]);\n+      else\n+\tbi->actual = bi->ptr1->bits[0];\n+    }\n+\n+  return bmp_iter_and_not_next_1 (bi);\n+}\n+\n+/* Moves the iterator BI to the next bit of difference of bitmaps and returns\n+   the bit if available.  */\n+\n+static inline unsigned\n+bmp_iter_and_not_next (bitmap_iterator *bi)\n+{\n+  bi->bit++;\n+  bi->actual >>= 1;\n+  return bmp_iter_and_not_next_1 (bi);\n+}\n+\n+/* Loop over all bits in BMP1 and BMP2, starting with MIN, setting\n+   BITNUM to the bit number for all bits that are set in the first bitmap\n+   and not set in the second.  ITER is a bitmap iterator.  */\n+\n+#define EXECUTE_IF_AND_COMPL_IN_BITMAP(BMP1, BMP2, MIN, BITNUM, ITER)\t\\\n+  for ((BITNUM) = bmp_iter_and_not_init (&(ITER), (BMP1), (BMP2), (MIN)); \\\n+       !bmp_iter_end_p (ITER);\t\t\t\t\t\t\\\n+       (BITNUM) = bmp_iter_and_not_next (&(ITER)))\n+\n+/* Moves the iterator BI to the first set bit on or after the current\n+   position in intersection of bitmaps and returns the bit if available.  */\n+\n+static inline unsigned\n+bmp_iter_and_next_1 (bitmap_iterator *bi)\n+{\n+  if (bi->actual)\n+    return bmp_iter_common_next_1 (bi);\n+\n+  bi->word++;\n+  bi->word_bit += BITMAP_WORD_BITS;\n+\n+  while (1)\n+    {\n+      for (;\n+\t   bi->word < BITMAP_ELEMENT_WORDS;\n+\t   bi->word++, bi->word_bit += BITMAP_WORD_BITS)\n+\t{\n+\t  bi->actual = (bi->ptr1->bits[bi->word]\n+\t\t\t& bi->ptr2->bits[bi->word]);\n+\t  if (bi->actual)\n+\t    {\n+\t      bi->bit = bi->word_bit;\n+\t      return bmp_iter_common_next_1 (bi);\n+\t    }\n+\t}\n+\n+      do\n+\t{\n+\t  bi->ptr1 = bi->ptr1->next;\n+\t  if (!bi->ptr1)\n+\t    return 0;\n+\n+\t  while (bi->ptr2->indx < bi->ptr1->indx)\n+\t    {\n+\t      bi->ptr2 = bi->ptr2->next;\n+\t      if (!bi->ptr2)\n+\t\t{\n+\t\t  bi->ptr1 = NULL;\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t}\n+      while (bi->ptr1->indx != bi->ptr2->indx);\n+\n+      bi->word = 0;\n+      bi->word_bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+    }\n+}\n+\n+/* Initializes a bitmap iterator BI for looping over bits of bitmap\n+   BMP1 & BMP2, starting with bit MIN.  Returns the first bit of\n+   BMP1 & BMP2 greater or equal to MIN if there is any.  */\n+\n+static inline unsigned\n+bmp_iter_and_init (bitmap_iterator *bi, bitmap bmp1, bitmap bmp2,\n+\t\t       unsigned min)\n+{\n+  unsigned indx = min / BITMAP_ELEMENT_ALL_BITS;\n+\n+  for (bi->ptr1 = bmp1->first;\n+       bi->ptr1 && bi->ptr1->indx < indx;\n+       bi->ptr1 = bi->ptr1->next)\n+    continue;\n+\n+  if (!bi->ptr1)\n+    goto empty;\n+\n+  bi->ptr2 = bmp2->first;\n+  if (!bi->ptr2)\n+    goto empty;\n+\n+  while (1)\n+    {\n+      while (bi->ptr2->indx < bi->ptr1->indx)\n+\t{\n+\t  bi->ptr2 = bi->ptr2->next;\n+\t  if (!bi->ptr2)\n+\t    goto empty;\n+\t}\n+\n+      if (bi->ptr1->indx == bi->ptr2->indx)\n+\tbreak;\n+\n+      bi->ptr1 = bi->ptr1->next;\n+      if (!bi->ptr1)\n+\tgoto empty;\n+    }\n+\n+  if (bi->ptr1->indx == indx)\n+    {\n+      unsigned bit_in_elt = min - BITMAP_ELEMENT_ALL_BITS * indx;\n+      unsigned word_in_elt = bit_in_elt / BITMAP_WORD_BITS;\n+      unsigned bit_in_word = bit_in_elt % BITMAP_WORD_BITS;\n+\n+      bi->word = word_in_elt;\n+      bi->word_bit = min - bit_in_word;\n+      bi->bit = min;\n+\n+      bi->actual = (bi->ptr1->bits[word_in_elt]\n+\t\t    & bi->ptr2->bits[word_in_elt]) >> bit_in_elt;\n+    }\n+  else\n+    {\n+      bi->word = 0;\n+      bi->bit = bi->ptr1->indx * BITMAP_ELEMENT_ALL_BITS;\n+      bi->word_bit = bi->bit;\n+\n+      bi->actual = (bi->ptr1->bits[0] & bi->ptr2->bits[0]);\n+    }\n+\n+  return bmp_iter_and_next_1 (bi);\n+\n+empty:\n+  /* To avoid warnings.  */\n+  bi->word = 0;\n+  bi->bit = 0;\n+  bi->word_bit = 0;\n+  bi->actual = 0;\n+  bi->ptr1 = NULL;\n+  bi->ptr2 = NULL;\n+  return 0;\n+}\n+\n+/* Moves the iterator BI to the next bit of intersection of bitmaps and returns\n+   the bit if available.  */\n+\n+static inline unsigned\n+bmp_iter_and_next (bitmap_iterator *bi)\n+{\n+  bi->bit++;\n+  bi->actual >>= 1;\n+  return bmp_iter_and_next_1 (bi);\n+}\n+\n+/* Loop over all bits in BMP1 and BMP2, starting with MIN, setting\n+   BITNUM to the bit number for all bits that are set in both bitmaps.\n+   ITER is a bitmap iterator.  */\n+\n+#define EXECUTE_IF_AND_IN_BITMAP(BMP1, BMP2, MIN, BITNUM, ITER)\t\t\\\n+  for ((BITNUM) = bmp_iter_and_init (&(ITER), (BMP1), (BMP2), (MIN));\t\\\n+       !bmp_iter_end_p (ITER);\t\t\t\t\t\t\\\n+       (BITNUM) = bmp_iter_and_next (&(ITER)))\n \n #endif /* GCC_BITMAP_H */"}, {"sha": "ef4cf92864aeed6a8672c70c2dca54e1c0c63235", "filename": "gcc/bt-load.c", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -822,20 +822,20 @@ static void\n clear_btr_from_live_range (btr_def def)\n {\n   int bb;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP\n-    (def->live_range, 0, bb,\n-     {\n-       if ((!def->other_btr_uses_before_def\n-\t     && !def->other_btr_uses_after_use)\n-\t   || !block_at_edge_of_live_range_p (bb, def))\n-\t {\n-\t   CLEAR_HARD_REG_BIT (btrs_live[bb], def->btr);\n-\t   CLEAR_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n-\t   if (dump_file)\n-\t     dump_btrs_live (bb);\n-\t }\n-     });\n+  EXECUTE_IF_SET_IN_BITMAP (def->live_range, 0, bb, bi)\n+    {\n+      if ((!def->other_btr_uses_before_def\n+\t   && !def->other_btr_uses_after_use)\n+\t  || !block_at_edge_of_live_range_p (bb, def))\n+\t{\n+\t  CLEAR_HARD_REG_BIT (btrs_live[bb], def->btr);\n+\t  CLEAR_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n+\t  if (dump_file)\n+\t    dump_btrs_live (bb);\n+\t}\n+    }\n }\n \n \n@@ -846,14 +846,15 @@ static void\n add_btr_to_live_range (btr_def def)\n {\n   int bb;\n-  EXECUTE_IF_SET_IN_BITMAP\n-    (def->live_range, 0, bb,\n-     {\n-       SET_HARD_REG_BIT (btrs_live[bb], def->btr);\n-       SET_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n-       if (dump_file)\n-\t dump_btrs_live (bb);\n-     });\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (def->live_range, 0, bb, bi)\n+    {\n+      SET_HARD_REG_BIT (btrs_live[bb], def->btr);\n+      SET_HARD_REG_BIT (btrs_live_at_end[bb], def->btr);\n+      if (dump_file)\n+\tdump_btrs_live (bb);\n+    }\n }\n \n /* Update a live range to contain the basic block NEW_BLOCK, and all\n@@ -990,22 +991,25 @@ btr_def_live_range (btr_def def, HARD_REG_SET *btrs_live_in_range)\n       */\n       int bb;\n       int def_bb = def->bb->index;\n+      bitmap_iterator bi;\n \n       CLEAR_HARD_REG_SET (*btrs_live_in_range);\n       if (flag_btr_bb_exclusive)\n-\tEXECUTE_IF_SET_IN_BITMAP\n-\t  (def->live_range, 0, bb,\n-\t   {\n-\t     IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[bb]);\n-\t   });\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (def->live_range, 0, bb, bi)\n+\t    {\n+\t      IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[bb]);\n+\t    }\n+\t}\n       else\n-\tEXECUTE_IF_SET_IN_BITMAP\n-\t  (def->live_range, 0, bb,\n-\t   {\n-\t     IOR_HARD_REG_SET (*btrs_live_in_range,\n-\t\t\t       (def_bb == bb\n-\t\t\t\t? btrs_live_at_end : btrs_live) [bb]);\n-\t   });\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (def->live_range, 0, bb, bi)\n+\t    {\n+\t      IOR_HARD_REG_SET (*btrs_live_in_range,\n+\t\t\t\t(def_bb == bb\n+\t\t\t\t ? btrs_live_at_end : btrs_live) [bb]);\n+\t    }\n+\t}\n     }\n   if (!def->other_btr_uses_before_def &&\n       !def->other_btr_uses_after_use)"}, {"sha": "01f5f7d04b68b3c4f7ecf23f859d68da9ed2f298", "filename": "gcc/cfganal.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1086,12 +1086,13 @@ compute_dominance_frontiers_1 (bitmap *frontiers, basic_block bb, sbitmap done)\n        c = next_dom_son (CDI_DOMINATORS, c))\n     {\n       int x;\n+      bitmap_iterator bi;\n \n-      EXECUTE_IF_SET_IN_BITMAP (frontiers[c->index], 0, x,\n+      EXECUTE_IF_SET_IN_BITMAP (frontiers[c->index], 0, x, bi)\n \t{\n \t  if (get_immediate_dominator (CDI_DOMINATORS, BASIC_BLOCK (x)) != bb)\n \t    bitmap_set_bit (frontiers[bb->index], x);\n-\t});\n+\t}\n     }\n }\n "}, {"sha": "a5c42b4d16fb306b4b6fb9ff6162daf2e98a9f38", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -352,18 +352,20 @@ static void\n convert_UIDs_in_bitmap (bitmap in_ann, bitmap in_decl) \n {\n   int index;\n-  EXECUTE_IF_SET_IN_BITMAP(in_decl, 0, index,\n-      {\n-\tsplay_tree_node n = \n-\t  splay_tree_lookup (static_vars_to_consider_by_uid, index);\n-\tif (n != NULL) \n-\t  {\n-\t    tree t = (tree)n->value;\n-\t    var_ann_t va = var_ann (t);\n-\t    if (va) \n-\t      bitmap_set_bit(in_ann, va->uid);\n-\t  }\n-      });\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP(in_decl, 0, index, bi)\n+    {\n+      splay_tree_node n = \n+\t      splay_tree_lookup (static_vars_to_consider_by_uid, index);\n+      if (n != NULL) \n+\t{\n+\t  tree t = (tree)n->value;\n+\t  var_ann_t va = var_ann (t);\n+\t  if (va) \n+\t    bitmap_set_bit(in_ann, va->uid);\n+\t}\n+    }\n }\n \n /* FIXME -- PROFILE-RESTRUCTURE: Delete all stmts initing *_decl_uid\n@@ -2456,8 +2458,12 @@ cgraph_characterize_statics (void)\n      (i.e. have there address taken).  */\n   {\n     int index;\n-    EXECUTE_IF_SET_IN_BITMAP (module_statics_escape,\n-\t\t\t      0, index, clear_static_vars_maps (index));\n+    bitmap_iterator bi;\n+\n+    EXECUTE_IF_SET_IN_BITMAP (module_statics_escape, 0, index, bi)\n+      {\n+\tclear_static_vars_maps (index);\n+      }\n     bitmap_operation (all_module_statics, all_module_statics,\n \t\t      module_statics_escape, BITMAP_AND_COMPL);\n \n@@ -2484,21 +2490,27 @@ cgraph_characterize_statics (void)\n \t{\n \t  int index;\n \t  local_static_vars_info_t l;\n+\t  bitmap_iterator bi;\n+\n \t  node = order[i];\n \t  l = node->static_vars_info->local;\n \t  fprintf (cgraph_dump_file, \n \t\t   \"\\nFunction name:%s/%i:\", \n \t\t   cgraph_node_name (node), node->uid);\n \t  fprintf (cgraph_dump_file, \"\\n  locals read: \");\n \t  EXECUTE_IF_SET_IN_BITMAP (l->statics_read_by_decl_uid,\n-\t\t\t\t    0, index,\n-\t\t\t\t    fprintf (cgraph_dump_file, \"%s \",\n-\t\t\t\t\t     cgraph_get_static_name_by_uid (index)));\n+\t\t\t\t    0, index, bi)\n+\t    {\n+\t      fprintf (cgraph_dump_file, \"%s \",\n+\t\t       cgraph_get_static_name_by_uid (index));\n+\t    }\n \t  fprintf (cgraph_dump_file, \"\\n  locals written: \");\n \t  EXECUTE_IF_SET_IN_BITMAP (l->statics_written_by_decl_uid,\n-\t\t\t\t    0, index,\n-\t\t\t\t    fprintf(cgraph_dump_file, \"%s \",\n-\t\t\t\t\t   cgraph_get_static_name_by_uid (index)));\n+\t\t\t\t    0, index, bi)\n+\t    {\n+\t      fprintf(cgraph_dump_file, \"%s \",\n+\t\t      cgraph_get_static_name_by_uid (index));\n+\t    }\n \t}\n     }\n \n@@ -2597,6 +2609,8 @@ cgraph_characterize_statics (void)\n \t  static_vars_info_t node_info;\n \t  global_static_vars_info_t node_g;\n \t  int index;\n+\t  bitmap_iterator bi;\n+\n \t  node = order[i];\n \t  node_info = node->static_vars_info;\n \t  node_g = node_info->global;\n@@ -2612,14 +2626,18 @@ cgraph_characterize_statics (void)\n \t    }\n \t  fprintf (cgraph_dump_file, \"\\n  globals read: \");\n \t  EXECUTE_IF_SET_IN_BITMAP (node_g->statics_read_by_decl_uid,\n-\t\t\t\t    0, index,\n-\t\t\t\t    fprintf (cgraph_dump_file, \"%s \",\n-\t\t\t\t\t     cgraph_get_static_name_by_uid (index)));\n+\t\t\t\t    0, index, bi)\n+\t    {\n+\t      fprintf (cgraph_dump_file, \"%s \",\n+\t\t       cgraph_get_static_name_by_uid (index));\n+\t    }\n \t  fprintf (cgraph_dump_file, \"\\n  globals written: \");\n \t  EXECUTE_IF_SET_IN_BITMAP (node_g->statics_written_by_decl_uid,\n-\t\t\t\t    0, index,\n-\t\t\t\t    fprintf (cgraph_dump_file, \"%s \",\n-\t\t\t\t\t     cgraph_get_static_name_by_uid (index)));\n+\t\t\t\t    0, index, bi)\n+\t    {\n+\t      fprintf (cgraph_dump_file, \"%s \",\n+\t\t       cgraph_get_static_name_by_uid (index));\n+\t    }\n \t}\n     }\n "}, {"sha": "4212ac4d9b6ef9f047239bc83bd55fa437b444e6", "filename": "gcc/ddg.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -313,28 +313,29 @@ build_inter_loop_deps (ddg_ptr g, struct df *df)\n {\n   int rd_num, u_num;\n   struct bb_info *bb_info;\n+  bitmap_iterator bi;\n \n   bb_info = DF_BB_INFO (df, g->bb);\n \n   /* Find inter-loop output and true deps by connecting downward exposed defs\n      to the first def of the BB and to upwards exposed uses.  */\n-  EXECUTE_IF_SET_IN_BITMAP (bb_info->rd_gen, 0, rd_num,\n+  EXECUTE_IF_SET_IN_BITMAP (bb_info->rd_gen, 0, rd_num, bi)\n     {\n       struct ref *rd = df->defs[rd_num];\n \n       add_deps_for_def (g, df, rd);\n-    });\n+    }\n \n   /* Find inter-loop anti deps.  We are interested in uses of the block that\n      appear below all defs; this implies that these uses are killed.  */\n-  EXECUTE_IF_SET_IN_BITMAP (bb_info->ru_kill, 0, u_num,\n+  EXECUTE_IF_SET_IN_BITMAP (bb_info->ru_kill, 0, u_num, bi)\n     {\n       struct ref *use = df->uses[u_num];\n \n       /* We are interested in uses of this BB.  */\n       if (BLOCK_FOR_INSN (use->insn) == g->bb)\n       \tadd_deps_for_use (g, df,use);\n-    });\n+    }\n }\n \n /* Given two nodes, analyze their RTL insns and add inter-loop mem deps"}, {"sha": "2a59ca42b2dbd5fac64a9fd6f0ce6487185ce9c9", "filename": "gcc/df.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -192,8 +192,12 @@ and again mark them read/write.\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       unsigned int node_;\t\t\t\t\\\n-      EXECUTE_IF_SET_IN_BITMAP (BITMAP, MIN, node_,\t\\\n-      {(BB) = BASIC_BLOCK (node_); CODE;});\t\t\\\n+      bitmap_iterator bi;\t\t\t\t\\\n+      EXECUTE_IF_SET_IN_BITMAP (BITMAP, MIN, node_, bi)\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  (BB) = BASIC_BLOCK (node_);\t\t\t\\\n+\t  CODE;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -1829,6 +1833,7 @@ df_bb_reg_info_compute (struct df *df, basic_block bb, bitmap live)\n       unsigned int uid = INSN_UID (insn);\n       unsigned int regno;\n       struct df_link *link;\n+      bitmap_iterator bi;\n \n       if (! INSN_P (insn))\n \tcontinue;\n@@ -1854,10 +1859,10 @@ df_bb_reg_info_compute (struct df *df, basic_block bb, bitmap live)\n \t}\n \n       /* Increment lifetimes of all live registers.  */\n-      EXECUTE_IF_SET_IN_BITMAP (live, 0, regno,\n-      {\n-\treg_info[regno].lifetime++;\n-      });\n+      EXECUTE_IF_SET_IN_BITMAP (live, 0, regno, bi)\n+\t{\n+\t  reg_info[regno].lifetime++;\n+\t}\n     }\n }\n \n@@ -2251,10 +2256,12 @@ df_refs_update (struct df *df, bitmap blocks)\n     }\n   else\n     {\n-      EXECUTE_IF_AND_IN_BITMAP (df->bbs_modified, blocks, 0, bbno,\n+      bitmap_iterator bi;\n+\n+      EXECUTE_IF_AND_IN_BITMAP (df->bbs_modified, blocks, 0, bbno, bi)\n \t{\n \t  count += df_bb_refs_update (df, BASIC_BLOCK (bbno));\n-\t});\n+\t}\n     }\n \n   df_refs_process (df);"}, {"sha": "6b3a1e2f2aecc6f388db41e2a27d8ce40f551864", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -2274,8 +2274,12 @@ remove_eh_handler (struct eh_region *region)\n   if (region->aka)\n     {\n       int i;\n-      EXECUTE_IF_SET_IN_BITMAP (region->aka, 0, i,\n-\t{ cfun->eh->region_array[i] = outer; });\n+      bitmap_iterator bi;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (region->aka, 0, i, bi)\n+\t{\n+\t  cfun->eh->region_array[i] = outer;\n+\t}\n     }\n \n   if (outer)"}, {"sha": "1cabde3c87499e847ccc3ab05cdfead7caecdff6", "filename": "gcc/flow.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -4320,12 +4320,12 @@ void\n reg_set_to_hard_reg_set (HARD_REG_SET *to, bitmap from)\n {\n   int i;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP\n-    (from, 0, i,\n-     {\n-       if (i >= FIRST_PSEUDO_REGISTER)\n-\t return;\n-       SET_HARD_REG_BIT (*to, i);\n-     });\n+  EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n+    {\n+      if (i >= FIRST_PSEUDO_REGISTER)\n+\treturn;\n+      SET_HARD_REG_BIT (*to, i);\n+    }\n }"}, {"sha": "daac742b8c6d0f38bada549249f81ffdc9d16bc9", "filename": "gcc/gcse.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -2272,14 +2272,18 @@ static void\n clear_modify_mem_tables (void)\n {\n   int i;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP\n-    (modify_mem_list_set, 0, i, free_INSN_LIST_list (modify_mem_list + i));\n+  EXECUTE_IF_SET_IN_BITMAP (modify_mem_list_set, 0, i, bi)\n+    {\n+      free_INSN_LIST_list (modify_mem_list + i);\n+    }\n   bitmap_clear (modify_mem_list_set);\n \n-  EXECUTE_IF_SET_IN_BITMAP\n-    (canon_modify_mem_list_set, 0, i,\n-     free_insn_expr_list_list (canon_modify_mem_list + i));\n+  EXECUTE_IF_SET_IN_BITMAP (canon_modify_mem_list_set, 0, i, bi)\n+    {\n+      free_insn_expr_list_list (canon_modify_mem_list + i);\n+    }\n   bitmap_clear (canon_modify_mem_list_set);\n }\n "}, {"sha": "4398e30b377aa6f23c6d59030f1459da4a5f9896", "filename": "gcc/global.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1816,17 +1816,17 @@ build_insn_chain (rtx first)\n       if (first == BB_HEAD (b))\n \t{\n \t  int i;\n+\t  bitmap_iterator bi;\n \n \t  CLEAR_REG_SET (live_relevant_regs);\n \n-\t  EXECUTE_IF_SET_IN_BITMAP\n-\t    (b->global_live_at_start, 0, i,\n-\t     {\n-\t       if (i < FIRST_PSEUDO_REGISTER\n-\t\t   ? ! TEST_HARD_REG_BIT (eliminable_regset, i)\n-\t\t   : reg_renumber[i] >= 0)\n-\t\t SET_REGNO_REG_SET (live_relevant_regs, i);\n-\t     });\n+\t  EXECUTE_IF_SET_IN_BITMAP (b->global_live_at_start, 0, i, bi)\n+\t    {\n+\t      if (i < FIRST_PSEUDO_REGISTER\n+\t\t  ? ! TEST_HARD_REG_BIT (eliminable_regset, i)\n+\t\t  : reg_renumber[i] >= 0)\n+\t\tSET_REGNO_REG_SET (live_relevant_regs, i);\n+\t    }\n \t}\n \n       if (!NOTE_P (first) && !BARRIER_P (first))"}, {"sha": "c7c053113f42c292170cfaca2aad69581017f818", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -3140,6 +3140,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       regset merge_set, tmp, test_live, test_set;\n       struct propagate_block_info *pbi;\n       int i, fail = 0;\n+      bitmap_iterator bi;\n \n       /* Check for no calls or trapping operations.  */\n       for (insn = head; ; insn = NEXT_INSN (insn))\n@@ -3191,14 +3192,13 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t hard registers before reload.  */\n       if (SMALL_REGISTER_CLASSES && ! reload_completed)\n \t{\n-          EXECUTE_IF_SET_IN_BITMAP\n-\t    (merge_set, 0, i,\n-\t     {\n-\t       if (i < FIRST_PSEUDO_REGISTER\n-\t\t   && ! fixed_regs[i]\n-\t\t   && ! global_regs[i])\n+          EXECUTE_IF_SET_IN_BITMAP (merge_set, 0, i, bi)\n+\t    {\n+\t      if (i < FIRST_PSEUDO_REGISTER\n+\t\t  && ! fixed_regs[i]\n+\t\t  && ! global_regs[i])\n \t\tfail = 1;\n-\t     });\n+\t    }\n \t}\n \n       /* For TEST, we're interested in a range of insns, not a whole block.\n@@ -3225,11 +3225,13 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n       bitmap_operation (tmp, test_set, test_live, BITMAP_IOR);\n       bitmap_operation (tmp, tmp, merge_set, BITMAP_AND);\n-      EXECUTE_IF_SET_IN_BITMAP(tmp, 0, i, fail = 1);\n+      if (bitmap_first_set_bit (tmp) >= 0)\n+\tfail = 1;\n \n       bitmap_operation (tmp, test_set, merge_bb->global_live_at_start,\n \t\t\tBITMAP_AND);\n-      EXECUTE_IF_SET_IN_BITMAP(tmp, 0, i, fail = 1);\n+      if (bitmap_first_set_bit (tmp) >= 0)\n+\tfail = 1;\n \n       FREE_REG_SET (tmp);\n       FREE_REG_SET (merge_set);"}, {"sha": "e0824e03ef57a35a3bd0e680a3e53a8aec144f11", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -599,6 +599,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   unsigned aregs_needed;\n   unsigned depno;\n   struct invariant *dep;\n+  bitmap_iterator bi;\n \n   *comp_cost = 0;\n   *regs_needed = 0;\n@@ -610,7 +611,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   (*regs_needed)++;\n   (*comp_cost) += inv->cost;\n \n-  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno,\n+  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno, bi)\n     {\n       dep = VARRAY_GENERIC_PTR_NOGC (invariants, depno);\n \n@@ -631,7 +632,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \n       (*regs_needed) += aregs_needed;\n       (*comp_cost) += acomp_cost;\n-    });\n+    }\n }\n \n /* Calculates gain for eliminating invariant INV.  REGS_USED is the number\n@@ -696,6 +697,7 @@ static void\n set_move_mark (unsigned invno)\n {\n   struct invariant *inv = VARRAY_GENERIC_PTR_NOGC (invariants, invno);\n+  bitmap_iterator bi;\n \n   if (inv->move)\n     return;\n@@ -704,7 +706,10 @@ set_move_mark (unsigned invno)\n   if (dump_file)\n     fprintf (dump_file, \"Decided to move invariant %d\\n\", invno);\n \n-  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, invno, set_move_mark (invno));\n+  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, invno, bi)\n+    {\n+      set_move_mark (invno);\n+    }\n }\n \n /* Determines which invariants to move.  DF is the dataflow object.  */\n@@ -761,17 +766,18 @@ move_invariant_reg (struct loop *loop, unsigned invno, struct df *df)\n   basic_block preheader = loop_preheader_edge (loop)->src;\n   rtx reg, set;\n   struct use *use;\n+  bitmap_iterator bi;\n \n   if (inv->processed)\n     return;\n   inv->processed = true;\n \n   if (inv->depends_on)\n     {\n-      EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, i, bi)\n \t{\n \t  move_invariant_reg (loop, i, df);\n-\t});\n+\t}\n     }\n \n   /* Move the set out of the loop.  If the set is always executed (we could"}, {"sha": "69f6aaa587238a2780343c1c83344bf458ff2abe", "filename": "gcc/ra-build.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1056,17 +1056,21 @@ livethrough_conflicts_bb (basic_block bb)\n   if (deaths > 0\n       || contains_call\n       || bitmap_first_set_bit (all_defs) >= 0)\n-    EXECUTE_IF_SET_IN_BITMAP (info->live_throughout, first, use_id,\n-      {\n-        struct web_part *wp = &web_parts[df->def_id + use_id];\n-        unsigned int bl = rtx_to_bits (DF_REF_REG (wp->ref));\n-        bitmap conflicts;\n-        wp = find_web_part (wp);\n-        wp->spanned_deaths += deaths;\n-\twp->crosses_call |= contains_call;\n-        conflicts = get_sub_conflicts (wp, bl);\n-        bitmap_operation (conflicts, conflicts, all_defs, BITMAP_IOR);\n-      });\n+    {\n+      bitmap_iterator bi;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (info->live_throughout, first, use_id, bi)\n+\t{\n+\t  struct web_part *wp = &web_parts[df->def_id + use_id];\n+\t  unsigned int bl = rtx_to_bits (DF_REF_REG (wp->ref));\n+\t  bitmap conflicts;\n+\t  wp = find_web_part (wp);\n+\t  wp->spanned_deaths += deaths;\n+\t  wp->crosses_call |= contains_call;\n+\t  conflicts = get_sub_conflicts (wp, bl);\n+\t  bitmap_operation (conflicts, conflicts, all_defs, BITMAP_IOR);\n+\t}\n+    }\n \n   BITMAP_XFREE (all_defs);\n }\n@@ -2191,6 +2195,8 @@ conflicts_between_webs (struct df *df)\n \t  {\n \t    int j;\n \t    struct web *web1 = find_subweb_2 (supweb1, cl->size_word);\n+\t    bitmap_iterator bi;\n+\n \t    if (have_ignored)\n \t      bitmap_operation (cl->conflicts, cl->conflicts, ignore_defs,\n \t\t\t        BITMAP_AND_COMPL);\n@@ -2205,8 +2211,7 @@ conflicts_between_webs (struct df *df)\n \t    pass++;\n \n \t    /* Note, that there are only defs in the conflicts bitset.  */\n-\t    EXECUTE_IF_SET_IN_BITMAP (\n-\t      cl->conflicts, 0, j,\n+\t    EXECUTE_IF_SET_IN_BITMAP (cl->conflicts, 0, j, bi)\n \t      {\n \t\tstruct web *web2 = def2web[j];\n \t\tunsigned int id2 = web2->id;\n@@ -2215,7 +2220,7 @@ conflicts_between_webs (struct df *df)\n \t\t    pass_cache[id2] = pass;\n \t\t    record_conflict (web1, web2);\n \t\t  }\n-\t      });\n+\t      }\n \t  }\n     }\n "}, {"sha": "23c26ba9c3f09a8f4364958a7b6109247fa55e8b", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1013,8 +1013,10 @@ reloads_to_loads (struct rewrite_info *ri, struct ref **refs,\n       if (is_death)\n \t{\n \t  int old_num_r = num_reloads;\n+\t  bitmap_iterator bi;\n+\n \t  bitmap_clear (ri->scratch);\n-\t  EXECUTE_IF_SET_IN_BITMAP (ri->need_reload, 0, j,\n+\t  EXECUTE_IF_SET_IN_BITMAP (ri->need_reload, 0, j, bi)\n \t    {\n \t      struct web *web2 = ID2WEB (j);\n \t      struct web *aweb2 = alias (find_web_for_subweb (web2));\n@@ -1030,7 +1032,7 @@ reloads_to_loads (struct rewrite_info *ri, struct ref **refs,\n \t\t  bitmap_set_bit (ri->scratch, j);\n \t\t  num_reloads--;\n \t\t}\n-\t    });\n+\t    }\n \t  if (num_reloads != old_num_r)\n \t    bitmap_operation (ri->need_reload, ri->need_reload, ri->scratch,\n \t\t\t      BITMAP_AND_COMPL);\n@@ -1062,6 +1064,8 @@ rewrite_program2 (bitmap new_deaths)\n       basic_block last_bb = NULL;\n       rtx last_block_insn;\n       int i, j;\n+      bitmap_iterator bi;\n+\n       if (!INSN_P (insn))\n \tinsn = prev_real_insn (insn);\n       while (insn && !(bb = BLOCK_FOR_INSN (insn)))\n@@ -1073,7 +1077,7 @@ rewrite_program2 (bitmap new_deaths)\n \n       sbitmap_zero (ri.live);\n       CLEAR_HARD_REG_SET (ri.colors_in_use);\n-      EXECUTE_IF_SET_IN_BITMAP (live_at_end[i - 2], 0, j,\n+      EXECUTE_IF_SET_IN_BITMAP (live_at_end[i - 2], 0, j, bi)\n \t{\n \t  struct web *web = use2web[j];\n \t  struct web *aweb = alias (find_web_for_subweb (web));\n@@ -1090,7 +1094,7 @@ rewrite_program2 (bitmap new_deaths)\n \t      if (aweb->type != SPILLED)\n \t        update_spill_colors (&(ri.colors_in_use), web, 1);\n \t    }\n-\t});\n+\t}\n \n       bitmap_clear (ri.need_reload);\n       ri.num_reloads = 0;\n@@ -1130,7 +1134,9 @@ rewrite_program2 (bitmap new_deaths)\n \t  if (INSN_P (insn) && BLOCK_FOR_INSN (insn) != last_bb)\n \t    {\n \t      int index = BLOCK_FOR_INSN (insn)->index + 2;\n-\t      EXECUTE_IF_SET_IN_BITMAP (live_at_end[index - 2], 0, j,\n+\t      bitmap_iterator bi;\n+\n+\t      EXECUTE_IF_SET_IN_BITMAP (live_at_end[index - 2], 0, j, bi)\n \t\t{\n \t\t  struct web *web = use2web[j];\n \t\t  struct web *aweb = alias (find_web_for_subweb (web));\n@@ -1139,9 +1145,9 @@ rewrite_program2 (bitmap new_deaths)\n \t\t      SET_BIT (ri.live, web->id);\n \t\t      update_spill_colors (&(ri.colors_in_use), web, 1);\n \t\t    }\n-\t\t});\n+\t\t}\n \t      bitmap_clear (ri.scratch);\n-\t      EXECUTE_IF_SET_IN_BITMAP (ri.need_reload, 0, j,\n+\t      EXECUTE_IF_SET_IN_BITMAP (ri.need_reload, 0, j, bi)\n \t\t{\n \t\t  struct web *web2 = ID2WEB (j);\n \t\t  struct web *supweb2 = find_web_for_subweb (web2);\n@@ -1156,7 +1162,7 @@ rewrite_program2 (bitmap new_deaths)\n \t\t      bitmap_set_bit (ri.scratch, j);\n \t\t      ri.num_reloads--;\n \t\t    }\n-\t\t});\n+\t\t}\n \t      bitmap_operation (ri.need_reload, ri.need_reload, ri.scratch,\n \t\t\t\tBITMAP_AND_COMPL);\n \t      last_bb = BLOCK_FOR_INSN (insn);\n@@ -1344,26 +1350,28 @@ rewrite_program2 (bitmap new_deaths)\n \t  int in_ir = 0;\n \t  edge e;\n \t  int num = 0;\n+\t  bitmap_iterator bi;\n+\n \t  HARD_REG_SET cum_colors, colors;\n \t  CLEAR_HARD_REG_SET (cum_colors);\n \t  for (e = bb->pred; e && num < 5; e = e->pred_next, num++)\n \t    {\n \t      int j;\n \t      CLEAR_HARD_REG_SET (colors);\n-\t      EXECUTE_IF_SET_IN_BITMAP (live_at_end[e->src->index], 0, j,\n+\t      EXECUTE_IF_SET_IN_BITMAP (live_at_end[e->src->index], 0, j, bi)\n \t\t{\n \t\t  struct web *web = use2web[j];\n \t\t  struct web *aweb = alias (find_web_for_subweb (web));\n \t\t  if (aweb->type != SPILLED)\n \t\t    update_spill_colors (&colors, web, 1);\n-\t\t});\n+\t\t}\n \t      IOR_HARD_REG_SET (cum_colors, colors);\n \t    }\n \t  if (num == 5)\n \t    in_ir = 1;\n \n \t  bitmap_clear (ri.scratch);\n-\t  EXECUTE_IF_SET_IN_BITMAP (ri.need_reload, 0, j,\n+\t  EXECUTE_IF_SET_IN_BITMAP (ri.need_reload, 0, j, bi)\n \t    {\n \t      struct web *web2 = ID2WEB (j);\n \t      struct web *supweb2 = find_web_for_subweb (web2);\n@@ -1384,7 +1392,7 @@ rewrite_program2 (bitmap new_deaths)\n \t\t  bitmap_set_bit (ri.scratch, j);\n \t\t  ri.num_reloads--;\n \t\t}\n-\t    });\n+\t  }\n \t  bitmap_operation (ri.need_reload, ri.need_reload, ri.scratch,\n \t\t\t    BITMAP_AND_COMPL);\n \t}\n@@ -1458,6 +1466,8 @@ detect_web_parts_to_rebuild (void)\n         struct web *web = DLIST_WEB (d);\n \tstruct conflict_link *wl;\n \tunsigned int j;\n+\tbitmap_iterator bi;\n+\n \t/* This check is only needed for coalesced nodes, but hey.  */\n \tif (alias (web)->type != SPILLED)\n \t  continue;\n@@ -1494,14 +1504,14 @@ detect_web_parts_to_rebuild (void)\n \t    SET_BIT (already_webs, wl->t->id);\n \t    mark_refs_for_checking (wl->t, uses_as_bitmap);\n \t  }\n-\tEXECUTE_IF_SET_IN_BITMAP (web->useless_conflicts, 0, j,\n+\tEXECUTE_IF_SET_IN_BITMAP (web->useless_conflicts, 0, j, bi)\n \t  {\n \t    struct web *web2 = ID2WEB (j);\n \t    if (TEST_BIT (already_webs, web2->id))\n \t      continue;\n \t    SET_BIT (already_webs, web2->id);\n \t    mark_refs_for_checking (web2, uses_as_bitmap);\n-\t  });\n+\t  }\n       }\n \n   /* We also recheck unconditionally all uses of any hardregs.  This means\n@@ -1550,10 +1560,12 @@ static void\n delete_useless_defs (void)\n {\n   unsigned int i;\n+  bitmap_iterator bi;\n+\n   /* If the insn only sets the def without any sideeffect (besides\n      clobbers or uses), we can delete it.  single_set() also tests\n      for INSN_P(insn).  */\n-  EXECUTE_IF_SET_IN_BITMAP (useless_defs, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (useless_defs, 0, i, bi)\n     {\n       rtx insn = DF_REF_INSN (df->defs[i]);\n       rtx set = single_set (insn);\n@@ -1566,7 +1578,7 @@ delete_useless_defs (void)\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t  df_insn_modify (df, BLOCK_FOR_INSN (insn), insn);\n \t}\n-    });\n+    }\n }\n \n /* Look for spilled webs, on whose behalf no insns were emitted.\n@@ -1617,7 +1629,9 @@ void\n actual_spill (void)\n {\n   int i;\n+  bitmap_iterator bi;\n   bitmap new_deaths = BITMAP_XMALLOC ();\n+\n   reset_changed_flag ();\n   spill_coalprop ();\n   choose_spill_colors ();\n@@ -1633,8 +1647,10 @@ actual_spill (void)\n   insns_with_deaths = sbitmap_alloc (get_max_uid ());\n   death_insns_max_uid = get_max_uid ();\n   sbitmap_zero (insns_with_deaths);\n-  EXECUTE_IF_SET_IN_BITMAP (new_deaths, 0, i,\n-    { SET_BIT (insns_with_deaths, i);});\n+  EXECUTE_IF_SET_IN_BITMAP (new_deaths, 0, i, bi)\n+    {\n+      SET_BIT (insns_with_deaths, i);\n+    }\n   detect_non_changed_webs ();\n   detect_web_parts_to_rebuild ();\n   BITMAP_XFREE (new_deaths);"}, {"sha": "6f5284ec10c445f73f18f49a3061bab914417717", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -4386,11 +4386,12 @@ allocate_ssa_names (bitmap definitions, htab_t *map)\n   struct ssa_name_map_entry *entry;\n   PTR *slot;\n   unsigned ver;\n+  bitmap_iterator bi;\n \n   if (!*map)\n     *map = htab_create (10, ssa_name_map_entry_hash,\n \t\t\tssa_name_map_entry_eq, free);\n-  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver,\n+  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n     {\n       name = ssa_name (ver);\n       slot = htab_find_slot_with_hash (*map, name, SSA_NAME_VERSION (name),\n@@ -4404,7 +4405,7 @@ allocate_ssa_names (bitmap definitions, htab_t *map)\n \t  *slot = entry;\n \t}\n       entry->to_name = duplicate_ssa_name (name, SSA_NAME_DEF_STMT (name));\n-    });\n+    }\n }\n \n /* Rewrite the definition DEF in statement STMT to new ssa name as specified\n@@ -4555,6 +4556,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   basic_block *doms;\n   htab_t ssa_name_map = NULL;\n   edge redirected;\n+  bitmap_iterator bi;\n \n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n@@ -4639,7 +4641,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   /* Add phi nodes for definitions at exit.  TODO -- once we have immediate\n      uses, it should be possible to emit phi nodes just for definitions that\n      are used outside region.  */\n-  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver,\n+  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver, bi)\n     {\n       tree name = ssa_name (ver);\n \n@@ -4648,7 +4650,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n       add_phi_arg (&phi, name, exit_copy);\n \n       SSA_NAME_DEF_STMT (name) = phi;\n-    });\n+    }\n \n   /* And create new definitions inside region and its copy.  TODO -- once we\n      have immediate uses, it might be better to leave definitions in region\n@@ -5070,9 +5072,12 @@ tree_purge_all_dead_eh_edges (bitmap blocks)\n {\n   bool changed = false;\n   size_t i;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n-    { changed |= tree_purge_dead_eh_edges (BASIC_BLOCK (i)); });\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+    {\n+      changed |= tree_purge_dead_eh_edges (BASIC_BLOCK (i));\n+    }\n \n   return changed;\n }"}, {"sha": "696bdfdc1d1e25260b78283a734a1525cc46ec04", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -231,14 +231,15 @@ compute_global_livein (bitmap livein, bitmap def_blocks)\n {\n   basic_block bb, *worklist, *tos;\n   int i;\n+  bitmap_iterator bi;\n \n   tos = worklist\n     = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n-  EXECUTE_IF_SET_IN_BITMAP (livein, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (livein, 0, i, bi)\n     {\n-\t*tos++ = BASIC_BLOCK (i);\n-    });\n+      *tos++ = BASIC_BLOCK (i);\n+    }\n \n   /* Iterate until the worklist is empty.  */\n   while (tos != worklist)\n@@ -602,6 +603,7 @@ insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n {\n   size_t i;\n   varray_type work_stack;\n+  bitmap_iterator bi;\n \n   timevar_push (TV_TREE_INSERT_PHI_NODES);\n \n@@ -615,15 +617,17 @@ insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n      each definition block.  */\n   if (names_to_rename)\n     {\n-      EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n \t{\n \t  if (ssa_name (i))\n \t    insert_phi_nodes_1 (ssa_name (i), dfs, &work_stack);\n-\t});\n+\t}\n     }\n   else if (vars_to_rename)\n-    EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i,\n-\tinsert_phi_nodes_1 (referenced_var (i), dfs, &work_stack));\n+    EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n+      {\n+\tinsert_phi_nodes_1 (referenced_var (i), dfs, &work_stack);\n+      }\n   else\n     for (i = 0; i < num_referenced_vars; i++)\n       insert_phi_nodes_1 (referenced_var (i), dfs, &work_stack);\n@@ -964,17 +968,18 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n   edge e;\n   tree phi;\n   basic_block bb;\n+  bitmap_iterator bi;\n \n   def_map = find_def_blocks_for (var);\n   if (def_map == NULL)\n     return;\n \n   phi_insertion_points = BITMAP_XMALLOC ();\n \n-  EXECUTE_IF_SET_IN_BITMAP (def_map->def_blocks, 0, bb_index,\n+  EXECUTE_IF_SET_IN_BITMAP (def_map->def_blocks, 0, bb_index, bi)\n     {\n       VARRAY_PUSH_GENERIC_PTR_NOGC (*work_stack, BASIC_BLOCK (bb_index));\n-    });\n+    }\n \n   /* Pop a block off the worklist, add every block that appears in\n      the original block's dfs that we have not already processed to\n@@ -991,6 +996,7 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n   while (VARRAY_ACTIVE_SIZE (*work_stack) > 0)\n     {\n       int dfs_index;\n+      bitmap_iterator bi;\n \n       bb = VARRAY_TOP_GENERIC_PTR_NOGC (*work_stack);\n       bb_index = bb->index;\n@@ -999,13 +1005,13 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n       \n       EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index],\n \t\t\t\t      phi_insertion_points,\n-\t\t\t\t      0, dfs_index,\n+\t\t\t\t      0, dfs_index, bi)\n \t{\n \t  basic_block bb = BASIC_BLOCK (dfs_index);\n \n \t  VARRAY_PUSH_GENERIC_PTR_NOGC (*work_stack, bb);\n \t  bitmap_set_bit (phi_insertion_points, dfs_index);\n-\t});\n+\t}\n     }\n \n   /* Remove the blocks where we already have the phis.  */\n@@ -1018,21 +1024,19 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n \n   /* And insert the PHI nodes.  */\n   EXECUTE_IF_AND_IN_BITMAP (phi_insertion_points, def_map->livein_blocks,\n-\t\t\t    0, bb_index,\n-    do\n-      {\n-\tbb = BASIC_BLOCK (bb_index);\n+\t\t\t    0, bb_index, bi)\n+    {\n+      bb = BASIC_BLOCK (bb_index);\n \n-\tphi = create_phi_node (var, bb);\n+      phi = create_phi_node (var, bb);\n \n-\t/* If we are rewriting ssa names, add also the phi arguments.  */\n-\tif (TREE_CODE (var) == SSA_NAME)\n-\t  {\n-\t    for (e = bb->pred; e; e = e->pred_next)\n-\t      add_phi_arg (&phi, var, e);\n-\t  }\n-      }\n-    while (0));\n+      /* If we are rewriting ssa names, add also the phi arguments.  */\n+      if (TREE_CODE (var) == SSA_NAME)\n+\t{\n+\t  for (e = bb->pred; e; e = e->pred_next)\n+\t    add_phi_arg (&phi, var, e);\n+\t}\n+    }\n \n   BITMAP_XFREE (phi_insertion_points);\n }\n@@ -1260,16 +1264,21 @@ debug_def_blocks_r (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   unsigned long i;\n   struct def_blocks_d *db_p = (struct def_blocks_d *) *slot;\n+  bitmap_iterator bi;\n   \n   fprintf (stderr, \"VAR: \");\n   print_generic_expr (stderr, db_p->var, dump_flags);\n   fprintf (stderr, \", DEF_BLOCKS: { \");\n-  EXECUTE_IF_SET_IN_BITMAP (db_p->def_blocks, 0, i,\n-\t\t\t    fprintf (stderr, \"%ld \", i));\n+  EXECUTE_IF_SET_IN_BITMAP (db_p->def_blocks, 0, i, bi)\n+    {\n+      fprintf (stderr, \"%ld \", i);\n+    }\n   fprintf (stderr, \"}\");\n   fprintf (stderr, \", LIVEIN_BLOCKS: { \");\n-  EXECUTE_IF_SET_IN_BITMAP (db_p->livein_blocks, 0, i,\n-\t\t\t    fprintf (stderr, \"%ld \", i));\n+  EXECUTE_IF_SET_IN_BITMAP (db_p->livein_blocks, 0, i, bi)\n+    {\n+      fprintf (stderr, \"%ld \", i);\n+    }\n   fprintf (stderr, \"}\\n\");\n \n   return 1;\n@@ -1334,14 +1343,17 @@ invalidate_name_tags (bitmap vars_to_rename)\n {\n   size_t i;\n   bool rename_name_tags_p;\n+  bitmap_iterator bi;\n \n   rename_name_tags_p = false;\n-  EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i, bi)\n+    {\n       if (POINTER_TYPE_P (TREE_TYPE (referenced_var (i))))\n \t{\n \t  rename_name_tags_p = true;\n \t  break;\n-\t});\n+\t}\n+    }\n \n   if (rename_name_tags_p)\n     for (i = 0; i < num_referenced_vars; i++)\n@@ -1550,6 +1562,7 @@ rewrite_ssa_into_ssa (void)\n   sbitmap snames_to_rename;\n   tree name;\n   bitmap to_rename;\n+  bitmap_iterator bi;\n   \n   if (!any_marked_for_rewrite_p ())\n     return;\n@@ -1598,8 +1611,10 @@ rewrite_ssa_into_ssa (void)\n \n   snames_to_rename = sbitmap_alloc (num_ssa_names);\n   sbitmap_zero (snames_to_rename);\n-  EXECUTE_IF_SET_IN_BITMAP (to_rename, 0, i,\n-\t\t\t    SET_BIT (snames_to_rename, i));\n+  EXECUTE_IF_SET_IN_BITMAP (to_rename, 0, i, bi)\n+    {\n+      SET_BIT (snames_to_rename, i);\n+    }\n \n   mark_def_sites_global_data.kills = sbitmap_alloc (num_ssa_names);\n   mark_def_sites_global_data.names_to_rename = snames_to_rename;\n@@ -1657,7 +1672,10 @@ rewrite_ssa_into_ssa (void)\n \n   unmark_all_for_rewrite ();\n \n-  EXECUTE_IF_SET_IN_BITMAP (to_rename, 0, i, release_ssa_name (ssa_name (i)));\n+  EXECUTE_IF_SET_IN_BITMAP (to_rename, 0, i, bi)\n+    {\n+      release_ssa_name (ssa_name (i));\n+    }\n \n   sbitmap_free (snames_to_rename);\n "}, {"sha": "e23f0a182b6ec472b1f8579a2691149c48855e38", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1706,11 +1706,13 @@ find_replaceable_exprs (var_map map)\n   table = new_temp_expr_table (map);\n   FOR_EACH_BB (bb)\n     {\n+      bitmap_iterator bi;\n+\n       find_replaceable_in_bb (table, bb);\n-      EXECUTE_IF_SET_IN_BITMAP ((table->partition_in_use), 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP ((table->partition_in_use), 0, i, bi)\n         {\n \t  kill_expr (table, i, false);\n-\t});\n+\t}\n     }\n \n   ret = free_temp_expr_table (table);"}, {"sha": "53c125c698d0ab0bc5266c026c04ca1b46580d97", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1011,6 +1011,7 @@ scan_function (void)\n   static const struct sra_walk_fns fns = {\n     scan_use, scan_copy, scan_init, scan_ldst, true\n   };\n+  bitmap_iterator bi;\n \n   sra_walk_function (&fns);\n \n@@ -1019,13 +1020,13 @@ scan_function (void)\n       size_t i;\n \n       fputs (\"\\nScan results:\\n\", dump_file);\n-      EXECUTE_IF_SET_IN_BITMAP (sra_candidates, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (sra_candidates, 0, i, bi)\n \t{\n \t  tree var = referenced_var (i);\n \t  struct sra_elt *elt = lookup_element (NULL, var, NULL, NO_INSERT);\n \t  if (elt)\n \t    scan_dump (elt);\n-\t});\n+\t}\n       fputc ('\\n', dump_file);\n     }\n }\n@@ -1351,13 +1352,14 @@ decide_instantiations (void)\n   unsigned int i;\n   bool cleared_any;\n   struct bitmap_head_def done_head;\n+  bitmap_iterator bi;\n \n   /* We cannot clear bits from a bitmap we're iterating over,\n      so save up all the bits to clear until the end.  */\n   bitmap_initialize (&done_head, 1);\n   cleared_any = false;\n \n-  EXECUTE_IF_SET_IN_BITMAP (sra_candidates, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (sra_candidates, 0, i, bi)\n     {\n       tree var = referenced_var (i);\n       struct sra_elt *elt = lookup_element (NULL, var, NULL, NO_INSERT);\n@@ -1372,7 +1374,7 @@ decide_instantiations (void)\n \t  bitmap_set_bit (&done_head, i);\n \t  cleared_any = true;\n \t}\n-    });\n+    }\n \n   if (cleared_any)\n     {\n@@ -1957,13 +1959,14 @@ scalarize_parms (void)\n {\n   tree list = NULL;\n   size_t i;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (needs_copy_in, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (needs_copy_in, 0, i, bi)\n     {\n       tree var = referenced_var (i);\n       struct sra_elt *elt = lookup_element (NULL, var, NULL, NO_INSERT);\n       generate_copy_inout (elt, true, var, &list);\n-    });\n+    }\n \n   if (list)\n     insert_edge_copies (list, ENTRY_BLOCK_PTR);"}, {"sha": "883c53d935e628e3cad24917032bcc74f59cbfd6", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -382,10 +382,11 @@ init_alias_info (void)\n   if (aliases_computed_p)\n     {\n       size_t i;\n+      bitmap_iterator bi;\n \n       /* Clear the call-clobbered set.  We are going to re-discover\n \t  call-clobbered variables.  */\n-      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n \t{\n \t  tree var = referenced_var (i);\n \n@@ -394,7 +395,7 @@ init_alias_info (void)\n \t     code, so we can't remove them from CALL_CLOBBERED_VARS.  */\n \t  if (!is_call_clobbered (var))\n \t    bitmap_clear_bit (call_clobbered_vars, var_ann (var)->uid);\n-\t});\n+\t}\n \n       /* Similarly, clear the set of addressable variables.  In this\n \t case, we can just clear the set because addressability is\n@@ -589,6 +590,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  bitmap addr_taken;\n \t  tree stmt = bsi_stmt (si);\n \t  bool stmt_escapes_p = is_escape_site (stmt, &ai->num_calls_found);\n+\t  bitmap_iterator bi;\n \n \t  /* Mark all the variables whose address are taken by the\n \t     statement.  Note that this will miss all the addresses taken\n@@ -597,13 +599,13 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  get_stmt_operands (stmt);\n \t  addr_taken = addresses_taken (stmt);\n \t  if (addr_taken)\n-\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i,\n-\t\t{\n-\t\t  tree var = referenced_var (i);\n-\t\t  bitmap_set_bit (ai->addresses_needed, var_ann (var)->uid);\n-\t\t  if (stmt_escapes_p)\n-\t\t    mark_call_clobbered (var);\n-\t\t});\n+\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)\n+\t      {\n+\t\ttree var = referenced_var (i);\n+\t\tbitmap_set_bit (ai->addresses_needed, var_ann (var)->uid);\n+\t\tif (stmt_escapes_p)\n+\t\t  mark_call_clobbered (var);\n+\t      }\n \n \t  if (stmt_escapes_p)\n \t    block_ann->has_escape_site = 1;\n@@ -618,11 +620,11 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t  if (addr_taken\n \t      && TREE_CODE (stmt) == MODIFY_EXPR\n \t      && !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (stmt, 0))))\n-\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i,\n-\t\t{\n-\t\t  tree var = referenced_var (i);\n-\t\t  mark_call_clobbered (var);\n-\t\t});\n+\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)\n+\t      {\n+\t\ttree var = referenced_var (i);\n+\t\tmark_call_clobbered (var);\n+\t      }\n \n \t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n \t    {\n@@ -835,6 +837,7 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n       tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n       var_ann_t v_ann = var_ann (SSA_NAME_VAR (ptr));\n+      bitmap_iterator bi;\n \n       if (pi->value_escapes_p || pi->pt_anything)\n \t{\n@@ -847,16 +850,20 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n \t    mark_call_clobbered (v_ann->type_mem_tag);\n \n \t  if (pi->pt_vars)\n-\t    EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j,\n-\t\tmark_call_clobbered (referenced_var (j)));\n+\t    EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n+\t      {\n+\t\tmark_call_clobbered (referenced_var (j));\n+\t      }\n \t}\n \n       /* Set up aliasing information for PTR's name memory tag (if it has\n \t one).  Note that only pointers that have been dereferenced will\n \t have a name memory tag.  */\n       if (pi->name_mem_tag && pi->pt_vars)\n-\tEXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j,\n-\t    add_may_alias (pi->name_mem_tag, referenced_var (j)));\n+\tEXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n+\t  {\n+\t    add_may_alias (pi->name_mem_tag, referenced_var (j));\n+\t  }\n \n       /* If the name tag is call clobbered, so is the type tag\n \t associated with the base VAR_DECL.  */\n@@ -1476,13 +1483,17 @@ static void\n maybe_create_global_var (struct alias_info *ai)\n {\n   size_t i, n_clobbered;\n+  bitmap_iterator bi;\n   \n   /* No need to create it, if we have one already.  */\n   if (global_var == NULL_TREE)\n     {\n       /* Count all the call-clobbered variables.  */\n       n_clobbered = 0;\n-      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, n_clobbered++);\n+      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+\t{\n+\t  n_clobbered++;\n+\t}\n \n       /* Create .GLOBAL_VAR if we have too many call-clobbered\n \t variables.  We also create .GLOBAL_VAR when there no\n@@ -1510,15 +1521,15 @@ maybe_create_global_var (struct alias_info *ai)\n   /* If the function has calls to clobbering functions and .GLOBAL_VAR has\n      been created, make it an alias for all call-clobbered variables.  */\n   if (global_var)\n-    EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n+    EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n       {\n \ttree var = referenced_var (i);\n \tif (var != global_var)\n \t  {\n \t     add_may_alias (var, global_var);\n \t     bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n \t  }\n-      });\n+      }\n }\n \n \n@@ -2315,13 +2326,14 @@ dump_points_to_info_for (FILE *file, tree ptr)\n       if (pi->pt_vars)\n \t{\n \t  unsigned ix;\n+\t  bitmap_iterator bi;\n \n \t  fprintf (file, \", points-to vars: { \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix,\n-\t      {\n-\t\tprint_generic_expr (file, referenced_var (ix), dump_flags);\n-\t\tfprintf (file, \" \");\n-\t      });\n+\t  EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix, bi)\n+\t    {\n+\t      print_generic_expr (file, referenced_var (ix), dump_flags);\n+\t      fprintf (file, \" \");\n+\t    }\n \t  fprintf (file, \"}\");\n \t}\n     }"}, {"sha": "dfa719a446e3b07e84a10f5a3316a6983f558058", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -95,7 +95,14 @@ bitmap *control_dependence_map;\n /* Execute CODE for each edge (given number EDGE_NUMBER within the CODE)\n    for which the block with index N is control dependent.  */\n #define EXECUTE_IF_CONTROL_DEPENDENT(N, EDGE_NUMBER, CODE)\t\t      \\\n-  EXECUTE_IF_SET_IN_BITMAP (control_dependence_map[N], 0, EDGE_NUMBER, CODE)\n+  {\t\t\t\t\t\t\t\t\t      \\\n+    bitmap_iterator bi;\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+    EXECUTE_IF_SET_IN_BITMAP (control_dependence_map[N], 0, EDGE_NUMBER, bi)  \\\n+      {\t\t\t\t\t\t\t\t\t      \\\n+\tCODE;\t\t\t\t\t\t\t\t      \\\n+      }\t\t\t\t\t\t\t\t\t      \\\n+  }\n \n /* Local function prototypes.  */\n static inline void set_control_dependence_map_bit (basic_block, int);"}, {"sha": "93ceaeb0730a0dae7bd42507366ecf3253cc8366", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -368,10 +368,14 @@ dse_finalize_block (struct dom_walk_data *walk_data,\n   struct dse_global_data *dse_gd = walk_data->global_data;\n   bitmap stores = dse_gd->stores;\n   unsigned int i;\n+  bitmap_iterator bi;\n \n   /* Unwind the stores noted in this basic block.  */\n   if (bd->stores)\n-    EXECUTE_IF_SET_IN_BITMAP (bd->stores, 0, i, bitmap_clear_bit (stores, i););\n+    EXECUTE_IF_SET_IN_BITMAP (bd->stores, 0, i, bi)\n+      {\n+\tbitmap_clear_bit (stores, i);\n+      }\n }\n \n static void"}, {"sha": "41b970f17205649e553c0c0d460fcfbc56bea26d", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -488,15 +488,16 @@ live_worklist (tree_live_info_p live, varray_type stack, int i)\n   basic_block def_bb = NULL;\n   edge e;\n   var_map map = live->map;\n+  bitmap_iterator bi;\n \n   var = partition_to_var (map, i);\n   if (SSA_NAME_DEF_STMT (var))\n     def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (var));\n \n-  EXECUTE_IF_SET_IN_BITMAP (live->livein[i], 0, b,\n+  EXECUTE_IF_SET_IN_BITMAP (live->livein[i], 0, b, bi)\n     {\n       VARRAY_PUSH_INT (stack, b);\n-    });\n+    }\n \n   while (VARRAY_ACTIVE_SIZE (stack) > 0)\n     {\n@@ -565,6 +566,7 @@ calculate_live_on_entry (var_map map)\n   block_stmt_iterator bsi;\n   stmt_ann_t ann;\n   ssa_op_iter iter;\n+  bitmap_iterator bi;\n #ifdef ENABLE_CHECKING\n   int num;\n #endif\n@@ -628,10 +630,10 @@ calculate_live_on_entry (var_map map)\n     }\n \n   VARRAY_INT_INIT (stack, last_basic_block, \"stack\");\n-  EXECUTE_IF_SET_IN_BITMAP (live->global, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (live->global, 0, i, bi)\n     {\n       live_worklist (live, stack, i);\n-    });\n+    }\n \n #ifdef ENABLE_CHECKING\n    /* Check for live on entry partitions and report those with a DEF in\n@@ -758,13 +760,15 @@ calculate_live_on_exit (tree_live_info_p liveinfo)\n   /* Set live on exit for all predecessors of live on entry's.  */\n   for (i = 0; i < num_var_partitions (map); i++)\n     {\n+      bitmap_iterator bi;\n+\n       on_entry = live_entry_blocks (liveinfo, i);\n-      EXECUTE_IF_SET_IN_BITMAP (on_entry, 0, b,\n+      EXECUTE_IF_SET_IN_BITMAP (on_entry, 0, b, bi)\n         {\n \t  for (e = BASIC_BLOCK(b)->pred; e; e = e->pred_next)\n \t    if (e->src != ENTRY_BLOCK_PTR)\n \t      bitmap_set_bit (on_exit[e->src->index], i);\n-\t});\n+\t}\n     }\n \n   liveinfo->liveout = on_exit;\n@@ -1295,6 +1299,7 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n   varray_type partition_link, tpa_to_clear, tpa_nodes;\n   unsigned l;\n   ssa_op_iter iter;\n+  bitmap_iterator bi;\n \n   map = live_var_map (liveinfo);\n   graph = conflict_graph_new (num_var_partitions (map));\n@@ -1411,7 +1416,7 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \t tpa_clear contains all the tpa_roots processed, and these are the only\n \t entries which need to be zero'd out for a clean restart.  */\n \n-      EXECUTE_IF_SET_IN_BITMAP (live, 0, x,\n+      EXECUTE_IF_SET_IN_BITMAP (live, 0, x, bi)\n         {\n \t  i = tpa_find_tree (tpa, x);\n \t  if (i != TPA_NONE)\n@@ -1428,7 +1433,7 @@ build_tree_conflict_graph (tree_live_info_p liveinfo, tpa_p tpa,\n \t      VARRAY_INT (tpa_nodes, i) = x + 1;\n \t      VARRAY_INT (partition_link, x + 1) = start;\n \t    }\n-\t});\n+\t}\n \n \t/* Now clear the used tpa root references.  */\n \tfor (l = 0; l < VARRAY_ACTIVE_SIZE (tpa_to_clear); l++)\n@@ -1745,6 +1750,7 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n   basic_block bb;\n   int i;\n   var_map map = live->map;\n+  bitmap_iterator bi;\n \n   if ((flag & LIVEDUMP_ENTRY) && live->livein)\n     {\n@@ -1768,11 +1774,11 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n       FOR_EACH_BB (bb)\n \t{\n \t  fprintf (f, \"\\nLive on exit from BB%d : \", bb->index);\n-\t  EXECUTE_IF_SET_IN_BITMAP (live->liveout[bb->index], 0, i,\n+\t  EXECUTE_IF_SET_IN_BITMAP (live->liveout[bb->index], 0, i, bi)\n \t    {\n \t      print_generic_expr (f, partition_to_var (map, i), TDF_SLIM);\n \t      fprintf (f, \"  \");\n-\t    });\n+\t    }\n \t  fprintf (f, \"\\n\");\n \t}\n     }"}, {"sha": "e33d57209c359498214a6a83fbc92c1b6934d1d4", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -944,6 +944,7 @@ find_induction_variables (struct ivopts_data *data)\n {\n   unsigned i;\n   struct loop *loop = data->current_loop;\n+  bitmap_iterator bi;\n \n   if (!find_bivs (data))\n     return false;\n@@ -975,11 +976,11 @@ find_induction_variables (struct ivopts_data *data)\n  \n       fprintf (dump_file, \"Induction variables:\\n\\n\");\n \n-      EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n \t{\n \t  if (ver_info (data, i)->iv)\n \t    dump_iv (dump_file, ver_info (data, i)->iv);\n-\t});\n+\t}\n     }\n \n   return true;\n@@ -1524,9 +1525,11 @@ find_interesting_uses (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n+      bitmap_iterator bi;\n+\n       fprintf (dump_file, \"\\n\");\n \n-      EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n \t{\n \t  info = ver_info (data, i);\n \t  if (info->inv_id)\n@@ -1536,7 +1539,7 @@ find_interesting_uses (struct ivopts_data *data)\n \t      fprintf (dump_file, \" is invariant (%d)%s\\n\",\n \t\t       info->inv_id, info->has_nonlin_use ? \"\" : \", eliminable\");\n \t    }\n-\t});\n+\t}\n \n       fprintf (dump_file, \"\\n\");\n     }\n@@ -1718,13 +1721,14 @@ add_old_ivs_candidates (struct ivopts_data *data)\n {\n   unsigned i;\n   struct iv *iv;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n     {\n       iv = ver_info (data, i)->iv;\n       if (iv && iv->biv_p && !zero_p (iv->step))\n \tadd_old_iv_candidates (data, iv);\n-    });\n+    }\n }\n \n /* Adds candidates based on the value of the induction variable IV and USE.  */\n@@ -1896,6 +1900,7 @@ alloc_use_cost_map (struct ivopts_data *data)\n   for (i = 0; i < n_iv_uses (data); i++)\n     {\n       struct iv_use *use = iv_use (data, i);\n+      bitmap_iterator bi;\n \n       if (data->consider_all_candidates)\n \t{\n@@ -1905,7 +1910,10 @@ alloc_use_cost_map (struct ivopts_data *data)\n       else\n \t{\n \t  size = n_imp;\n-\t  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, j, size++);\n+\t  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, j, bi)\n+\t    {\n+\t      size++;\n+\t    }\n \t  use->n_map_members = 0;\n \t}\n \n@@ -3204,12 +3212,14 @@ determine_use_iv_costs (struct ivopts_data *data)\n \t}\n       else\n \t{\n-\t  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, j,\n+\t  bitmap_iterator bi;\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, j, bi)\n \t    {\n \t      cand = iv_cand (data, j);\n \t      if (!cand->important)\n \t        determine_use_iv_cost (data, use, cand);\n-\t    });\n+\t    }\n \t}\n     }\n \n@@ -3331,6 +3341,7 @@ determine_set_costs (struct ivopts_data *data)\n   unsigned j, n;\n   tree phi, op;\n   struct loop *loop = data->current_loop;\n+  bitmap_iterator bi;\n \n   /* We use the following model (definitely improvable, especially the\n      cost function -- TODO):\n@@ -3375,13 +3386,13 @@ determine_set_costs (struct ivopts_data *data)\n       n++;\n     }\n \n-  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, j,\n+  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, j, bi)\n     {\n       struct version_info *info = ver_info (data, j);\n \n       if (info->inv_id && info->has_nonlin_use)\n \tn++;\n-    });\n+    }\n \n   loop_data (loop)->regs_used = n;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3412,6 +3423,7 @@ find_best_candidate (struct ivopts_data *data,\n   unsigned best_cost = INFTY, cost;\n   struct iv_cand *cnd = NULL, *acnd;\n   bitmap depends_on = NULL, asol;\n+  bitmap_iterator bi, bi1;\n \n   if (data->consider_all_candidates)\n     asol = sol;\n@@ -3421,34 +3433,37 @@ find_best_candidate (struct ivopts_data *data,\n       bitmap_a_and_b (asol, sol, use->related_cands);\n     }\n \n-  EXECUTE_IF_SET_IN_BITMAP (asol, 0, c,\n+  EXECUTE_IF_SET_IN_BITMAP (asol, 0, c, bi)\n     {\n       acnd = iv_cand (data, c);\n       cost = get_use_iv_cost (data, use, acnd, &depends_on);\n \n       if (cost == INFTY)\n-\tgoto next_cand;\n+\tcontinue;\n       if (cost > best_cost)\n-\tgoto next_cand;\n+\tcontinue;\n       if (cost == best_cost)\n \t{\n \t  /* Prefer the cheaper iv.  */\n \t  if (acnd->cost >= cnd->cost)\n-\t    goto next_cand;\n+\t    continue;\n \t}\n \n       if (depends_on)\n \t{\n-\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (depends_on, inv, 0, d,\n-\t\t\t\t\t  goto next_cand);\n+\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (depends_on, inv, 0, d, bi1)\n+\t    {\n+\t      goto next_cand;\n+\t    }\n \t  if (used_inv)\n \t    bitmap_a_or_b (used_inv, used_inv, depends_on);\n \t}\n \n       cnd = acnd;\n       best_cost = cost;\n+\n next_cand: ;\n-    });\n+    }\n \n   if (cnd && used_ivs)\n     bitmap_set_bit (used_ivs, cnd->id);\n@@ -3475,6 +3490,7 @@ set_cost_up_to (struct ivopts_data *data, bitmap sol, bitmap inv,\n   struct iv_use *use;\n   struct iv_cand *cand;\n   bitmap used_ivs = BITMAP_XMALLOC (), used_inv = BITMAP_XMALLOC ();\n+  bitmap_iterator bi;\n \n   for (i = 0; i < max_use; i++)\n     {\n@@ -3490,7 +3506,7 @@ set_cost_up_to (struct ivopts_data *data, bitmap sol, bitmap inv,\n       cost += acost;\n     }\n \n-  EXECUTE_IF_SET_IN_BITMAP (used_ivs, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (used_ivs, 0, i, bi)\n     {\n       cand = iv_cand (data, i);\n \n@@ -3499,8 +3515,11 @@ set_cost_up_to (struct ivopts_data *data, bitmap sol, bitmap inv,\n \tsize++;\n \n       cost += cand->cost;\n-    });\n-  EXECUTE_IF_SET_IN_BITMAP (used_inv, 0, i, size++);\n+    }\n+  EXECUTE_IF_SET_IN_BITMAP (used_inv, 0, i, bi)\n+    {\n+      size++;\n+    }\n   cost += ivopts_global_cost_for_size (data, size);\n \n   bitmap_copy (sol, used_ivs);\n@@ -3774,12 +3793,13 @@ create_new_ivs (struct ivopts_data *data, bitmap set)\n {\n   unsigned i;\n   struct iv_cand *cand;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (set, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n     {\n       cand = iv_cand (data, i);\n       create_new_iv (data, cand);\n-    });\n+    }\n }\n \n /* Removes statement STMT (real or a phi node).  If INCLUDING_DEFINED_NAME\n@@ -4270,8 +4290,9 @@ static void\n remove_unused_ivs (struct ivopts_data *data)\n {\n   unsigned j;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, j,\n+  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, j, bi)\n     {\n       struct version_info *info;\n \n@@ -4282,7 +4303,7 @@ remove_unused_ivs (struct ivopts_data *data)\n \t  && !info->iv->have_use_for\n \t  && !info->preserve_biv)\n \tremove_statement (SSA_NAME_DEF_STMT (info->iv->ssa_name), true);\n-    });\n+    }\n }\n \n /* Frees data allocated by the optimization of a single loop.  */\n@@ -4291,8 +4312,9 @@ static void\n free_loop_data (struct ivopts_data *data)\n {\n   unsigned i, j;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n     {\n       struct version_info *info;\n \n@@ -4303,7 +4325,7 @@ free_loop_data (struct ivopts_data *data)\n       info->has_nonlin_use = false;\n       info->preserve_biv = false;\n       info->inv_id = 0;\n-    });\n+    }\n   bitmap_clear (data->relevant);\n \n   for (i = 0; i < n_iv_uses (data); i++)"}, {"sha": "78572580af7dcbcbb43b78543b9ab7312cc4acd6", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -153,6 +153,7 @@ add_exit_phis_var (tree var, bitmap livein, bitmap exits)\n   bitmap def;\n   int index;\n   basic_block def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (var));\n+  bitmap_iterator bi;\n \n   bitmap_clear_bit (livein, def_bb->index);\n \n@@ -161,8 +162,10 @@ add_exit_phis_var (tree var, bitmap livein, bitmap exits)\n   compute_global_livein (livein, def);\n   BITMAP_XFREE (def);\n \n-  EXECUTE_IF_AND_IN_BITMAP (exits, livein, 0, index,\n-\t\t\t    add_exit_phis_edge (BASIC_BLOCK (index), var));\n+  EXECUTE_IF_AND_IN_BITMAP (exits, livein, 0, index, bi)\n+    {\n+      add_exit_phis_edge (BASIC_BLOCK (index), var);\n+    }\n }\n \n /* Add exit phis for the names marked in NAMES_TO_RENAME.\n@@ -173,11 +176,12 @@ static void\n add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap loop_exits)\n {\n   unsigned i;\n+  bitmap_iterator bi;\n \n-  EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i,\n+  EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n     {\n       add_exit_phis_var (ssa_name (i), use_blocks[i], loop_exits);\n-    });\n+    }\n }\n \n /* Returns a bitmap of all loop exit edge targets.  */"}, {"sha": "2506761d6248b5d47f94153a4344c7711dfd0aa3", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -1264,24 +1264,25 @@ get_asm_expr_operands (tree stmt)\n     if (strcmp (TREE_STRING_POINTER (TREE_VALUE (link)), \"memory\") == 0)\n       {\n \tsize_t i;\n+\tbitmap_iterator bi;\n \n \t/* Clobber all call-clobbered variables (or .GLOBAL_VAR if we\n \t   decided to group them).  */\n \tif (global_var)\n \t  add_stmt_operand (&global_var, stmt, opf_is_def);\n \telse\n-\t  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n+\t  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n \t      {\n \t\ttree var = referenced_var (i);\n \t\tadd_stmt_operand (&var, stmt, opf_is_def);\n-\t      });\n+\t      }\n \n \t/* Now clobber all addressables.  */\n-\tEXECUTE_IF_SET_IN_BITMAP (addressable_vars, 0, i,\n+\tEXECUTE_IF_SET_IN_BITMAP (addressable_vars, 0, i, bi)\n \t    {\n \t      tree var = referenced_var (i);\n \t      add_stmt_operand (&var, stmt, opf_is_def);\n-\t    });\n+\t    }\n \n \tbreak;\n       }\n@@ -1597,6 +1598,7 @@ add_call_clobber_ops (tree stmt, tree callee)\n     {\n       size_t i;\n       bitmap not_read_b = NULL, not_written_b = NULL;\n+      bitmap_iterator bi;\n \n       /* Get info for module level statics.  There is a bit set for\n \t each static if the call being processed does not read or\n@@ -1609,7 +1611,7 @@ add_call_clobber_ops (tree stmt, tree callee)\n \t  not_written_b = get_global_statics_not_written (callee);\n \t}\n \n-      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n \t{\n \t  tree var = referenced_var (i);\n \n@@ -1648,7 +1650,7 @@ add_call_clobber_ops (tree stmt, tree callee)\n \t      else\n \t\tadd_stmt_operand (&var, stmt, opf_is_def);\n \t    }\n-\t});\n+\t}\n     }\n }\n \n@@ -1659,6 +1661,8 @@ add_call_clobber_ops (tree stmt, tree callee)\n static void\n add_call_read_ops (tree stmt, tree callee)\n {\n+  bitmap_iterator bi;\n+\n   /* Otherwise, if the function is not pure, it may reference memory.  Add\n      a VUSE for .GLOBAL_VAR if it has been created.  Otherwise, add a VUSE\n      for each call-clobbered variable.  See add_referenced_var for the\n@@ -1671,14 +1675,14 @@ add_call_read_ops (tree stmt, tree callee)\n       bitmap not_read_b = callee \n \t? get_global_statics_not_read (callee) : NULL; \n \n-      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n+      EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n \t{\n \t  tree var = referenced_var (i);\n \t  bool not_read = not_read_b \n \t    ? bitmap_bit_p(not_read_b, i) : false;\n \t  if (!not_read)\n \t  add_stmt_operand (&var, stmt, opf_none);\n-\t});\n+\t}\n     }\n }\n "}, {"sha": "92932b63def8c3f174d78a14a63475b811e6af2e", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c476a22c6090159a3ab645561d9e1853af8d09/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=87c476a22c6090159a3ab645561d9e1853af8d09", "patch": "@@ -769,16 +769,18 @@ bitmap_print_value_set (FILE *outfile, bitmap_set_t set,\n   if (set)\n     {\n       int i;\n-      EXECUTE_IF_SET_IN_BITMAP (set->expressions, 0, i,\n-      {\n-\tprint_generic_expr (outfile, ssa_name (i), 0);\n+      bitmap_iterator bi;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (set->expressions, 0, i, bi)\n+\t{\n+\t  print_generic_expr (outfile, ssa_name (i), 0);\n \t\n-\tfprintf (outfile, \" (\");\n-\tprint_generic_expr (outfile, get_value_handle (ssa_name (i)), 0);\n-\tfprintf (outfile, \") \");\n-\tif (bitmap_last_set_bit (set->expressions) != i)\n-\t  fprintf (outfile, \", \");\n-      });\n+\t  fprintf (outfile, \" (\");\n+\t  print_generic_expr (outfile, get_value_handle (ssa_name (i)), 0);\n+\t  fprintf (outfile, \") \");\n+\t  if (bitmap_last_set_bit (set->expressions) != i)\n+\t    fprintf (outfile, \", \");\n+\t}\n     }\n   fprintf (outfile, \" }\\n\");\n }\n@@ -1416,12 +1418,14 @@ insert_aux (basic_block block)\n       if (dom)\n \t{\n \t  int i;\n+\t  bitmap_iterator bi;\n+\n \t  bitmap_set_t newset = NEW_SETS (dom);\n-\t  EXECUTE_IF_SET_IN_BITMAP (newset->expressions, 0, i,\n-          {\n-\t    bitmap_insert_into_set (NEW_SETS (block), ssa_name (i));\n-\t    bitmap_value_replace_in_set (AVAIL_OUT (block), ssa_name (i));\n-\t  });\n+\t  EXECUTE_IF_SET_IN_BITMAP (newset->expressions, 0, i, bi)\n+\t    {\n+\t      bitmap_insert_into_set (NEW_SETS (block), ssa_name (i));\n+\t      bitmap_value_replace_in_set (AVAIL_OUT (block), ssa_name (i));\n+\t    }\n \t  if (block->pred->pred_next)\n \t    {\n \t      value_set_node_t node;"}]}