{"sha": "a2e687765acbe0eccc1d66bcbd26733390b934aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJlNjg3NzY1YWNiZTBlY2NjMWQ2NmJjYmQyNjczMzM5MGI5MzRhYQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-04-16T22:00:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-16T22:00:09Z"}, "message": "haifa-sched.c (build_control_flow): Accept raw data as inputs instead of computing it locally.\n\n        * haifa-sched.c (build_control_flow): Accept raw data as inputs\n        instead of computing it locally.  Callers changed.\n        (find_rgns): Several new arguments.  Callers changed.\n        Generally clean up and comment better.  Use dominators to\n        identify reducible loops.  Convert some flag arrays to bitmaps.\n        Convert most of the code to work on pred/succ lists instead of\n        an edge table.  Add comments for future improvements.\n        (schedule_insns): Allocate temporary tables for flow data, call\n        routines to compute flow data and pass it along to children as\n        arguments.\n        (debug_control_flow): Delete.  Use dump_bb_data instead.\nGeneral cleanup + fix a bug or two.\n\nFrom-SVN: r19244", "tree": {"sha": "0503576c88164ffc045d44b0e9624789743af13d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0503576c88164ffc045d44b0e9624789743af13d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2e687765acbe0eccc1d66bcbd26733390b934aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e687765acbe0eccc1d66bcbd26733390b934aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2e687765acbe0eccc1d66bcbd26733390b934aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e687765acbe0eccc1d66bcbd26733390b934aa/comments", "author": null, "committer": null, "parents": [{"sha": "97b1ef1cf4ac9e2bc92e440f70d02a523540bf4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b1ef1cf4ac9e2bc92e440f70d02a523540bf4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b1ef1cf4ac9e2bc92e440f70d02a523540bf4b"}], "stats": {"total": 504, "additions": 267, "deletions": 237}, "files": [{"sha": "7becfbd871b107f221741f23ef7306be05742611", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e687765acbe0eccc1d66bcbd26733390b934aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e687765acbe0eccc1d66bcbd26733390b934aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2e687765acbe0eccc1d66bcbd26733390b934aa", "patch": "@@ -1,5 +1,17 @@\n Thu Apr 16 22:41:02 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* haifa-sched.c (build_control_flow): Accept raw data as inputs\n+\tinstead of computing it locally.  Callers changed.\n+\t(find_rgns): Several new arguments.  Callers changed.\n+\tGenerally clean up and comment better.  Use dominators to\n+\tidentify reducible loops.  Convert some flag arrays to bitmaps.\n+\tConvert most of the code to work on pred/succ lists instead of\n+\tan edge table.  Add comments for future improvements.\n+\t(schedule_insns): Allocate temporary tables for flow data, call\n+\troutines to compute flow data and pass it along to children as\n+\targuments.\n+\t(debug_control_flow): Delete.  Use dump_bb_data instead.\n+\n \t* basic-block.h (compute_dominators): Declare.\n \n \t* flow.c (dump_sbitmap, dump_sbitmap_vector): New debugging"}, {"sha": "ba48a29e19a934d23dd8ed78768fa47c87708ba8", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 255, "deletions": 237, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e687765acbe0eccc1d66bcbd26733390b934aa/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e687765acbe0eccc1d66bcbd26733390b934aa/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=a2e687765acbe0eccc1d66bcbd26733390b934aa", "patch": "@@ -519,7 +519,8 @@ extern rtx forced_labels;\n \n static int is_cfg_nonregular PROTO ((void));\n void debug_control_flow PROTO ((void));\n-static int build_control_flow PROTO ((void));\n+static int build_control_flow PROTO ((int_list_ptr *, int_list_ptr *,\n+\t\t\t\t      int *, int *));\n static void new_edge PROTO ((int, int));\n \n \n@@ -560,7 +561,8 @@ static int *containing_rgn;\n \n void debug_regions PROTO ((void));\n static void find_single_block_region PROTO ((void));\n-static void find_rgns PROTO ((void));\n+static void find_rgns PROTO ((int_list_ptr *, int_list_ptr *,\n+\t\t\t      int *, int *, sbitmap *));\n static int too_large PROTO ((int, int *, int *));\n \n extern void debug_live PROTO ((int, int));\n@@ -1133,51 +1135,6 @@ is_cfg_nonregular ()\n   return 0;\n }\n \n-/* Print the control flow graph, for debugging purposes.\n-   Callable from the debugger.  */\n-\n-void\n-debug_control_flow ()\n-{\n-  int i, e, next;\n-\n-  fprintf (dump, \";;   --------- CONTROL FLOW GRAPH --------- \\n\\n\");\n-\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      fprintf (dump, \";;\\tBasic block %d: first insn %d, last %d.\\n\",\n-\t       i,\n-\t       INSN_UID (basic_block_head[i]),\n-\t       INSN_UID (basic_block_end[i]));\n-\n-      fprintf (dump, \";;\\tPredecessor blocks:\");\n-      for (e = IN_EDGES (i); e; e = next)\n-\t{\n-\t  fprintf (dump, \" %d\", FROM_BLOCK (e));\n-\n-\t  next = NEXT_IN (e);\n-\n-\t  if (next == IN_EDGES (i))\n-\t    break;\n-\t}\n-\n-      fprintf (dump, \"\\n;;\\tSuccesor blocks:\");\n-      for (e = OUT_EDGES (i); e; e = next)\n-\t{\n-\t  fprintf (dump, \" %d\", TO_BLOCK (e));\n-\n-\t  next = NEXT_OUT (e);\n-\n-\t  if (next == OUT_EDGES (i))\n-\t    break;\n-\t}\n-\n-      fprintf (dump, \" \\n\\n\");\n-\n-    }\n-}\n-\n-\n /* Build the control flow graph and set nr_edges.\n \n    Instead of trying to build a cfg ourselves, we rely on flow to\n@@ -1187,33 +1144,16 @@ debug_control_flow ()\n    prevent cross block scheduling.  */\n \n static int\n-build_control_flow ()\n+build_control_flow (s_preds, s_succs, num_preds, num_succs)\n+     int_list_ptr *s_preds;\n+     int_list_ptr *s_succs;\n+     int *num_preds;\n+     int *num_succs;\n {\n   int i;\n-  int_list_ptr *s_preds;\n-  int_list_ptr *s_succs;\n   int_list_ptr succ;\n-  int *num_preds;\n-  int *num_succs;\n   int unreachable;\n \n-  /* The scheduler runs after flow; therefore, we can't blindly call\n-     back into find_basic_blocks since doing so could invalidate the\n-     info in basic_block_live_at_start.\n-\n-     Consider a block consisting entirely of dead stores; after life\n-     analysis it would be a block of NOTE_INSN_DELETED notes.  If\n-     we call find_basic_blocks again, then the block would be removed\n-     entirely and invalidate our the register live information.\n-\n-     We could (should?) recompute register live information.  Doing\n-     so may even be beneficial.  */\n-  s_preds = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n-  s_succs = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n-  num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n-  num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n-  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n-\n   /* Count the number of edges in the cfg.  */\n   nr_edges = 0;\n   unreachable = 0;\n@@ -1249,9 +1189,6 @@ build_control_flow ()\n   /* increment by 1, since edge 0 is unused.  */\n   nr_edges++;\n \n-  /* For now.  This will move as more and more of haifa is converted\n-     to using the cfg code in flow.c  */\n-  free_bb_mem ();\n   return unreachable;\n }\n \n@@ -1495,212 +1432,225 @@ too_large (block, num_bbs, num_insns)\n   if (max_hdr[blk] == -1)                                            \\\n     max_hdr[blk] = hdr;                                              \\\n   else if (dfs_nr[max_hdr[blk]] > dfs_nr[hdr])                       \\\n-         inner[hdr] = 0;                                             \\\n+         RESET_BIT (inner, hdr);                                     \\\n   else if (dfs_nr[max_hdr[blk]] < dfs_nr[hdr])                       \\\n          {                                                           \\\n-            inner[max_hdr[blk]] = 0;                                 \\\n+            RESET_BIT (inner,max_hdr[blk]);\t\t\t     \\\n             max_hdr[blk] = hdr;                                      \\\n          }                                                           \\\n }\n \n \n-/* Find regions for interblock scheduling: a loop-free procedure, a reducible\n-   inner loop, or a basic block not contained in any other region.\n-   The procedures control flow graph is traversed twice.\n-   First traversal, a DFS, finds the headers of inner loops  in the graph,\n-   and verifies that there are no unreacable blocks.\n-   Second traversal processes headers of inner loops, checking that the\n-   loop is reducible.  The loop blocks that form a region are put into the\n-   region's blocks list in topological order.\n+/* Find regions for interblock scheduling.\n+\n+   A region for scheduling can be:\n+\n+     * A loop-free procedure, or\n+\n+     * A reducible inner loop, or\n+\n+     * A basic block not contained in any other region.\n+\n+\n+   ?!? In theory we could build other regions based on extended basic\n+   blocks or reverse extended basic blocks.  Is it worth the trouble?\n+\n+   Loop blocks that form a region are put into the region's block list\n+   in topological order.\n+\n+   This procedure stores its results into the following global (ick) variables\n+\n+     * rgn_nr\n+     * rgn_table\n+     * rgn_bb_table\n+     * block_to_bb\n+     * containing region\n+\n+\n+   We use dominator relationships to avoid making regions out of non-reducible\n+   loops.\n \n-   The following variables are changed by the function: rgn_nr, rgn_table,\n-   rgn_bb_table, block_to_bb and containing_rgn.  */\n+   This procedure needs to be converted to work on pred/succ lists instead\n+   of edge tables.  That would simplify it somewhat.  */\n \n static void\n-find_rgns ()\n+find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n+     int_list_ptr *s_preds;\n+     int_list_ptr *s_succs;\n+     int *num_preds;\n+     int *num_succs;\n+     sbitmap *dom;\n {\n   int *max_hdr, *dfs_nr, *stack, *queue, *degree;\n-  char *header, *inner, *passed, *in_stack, *in_queue, no_loops = 1;\n-  int node, child, loop_head, i, j, fst_edge, head, tail;\n+  char no_loops = 1;\n+  int node, child, loop_head, i, j, head, tail;\n   int count = 0, sp, idx = 0, current_edge = out_edges[0];\n   int num_bbs, num_insns;\n   int too_large_failure;\n \n-  /*\n-     The following data structures are computed by the first traversal and\n-     are used by the second traversal:\n-     header[i] - flag set if the block i is the header of a loop.\n-     inner[i] - initially set. It is reset if the the block i is the header\n-     of a non-inner loop.\n-     max_hdr[i] - the header of the inner loop containing block i.\n-     (for a block i not in an inner loop it may be -1 or the\n-     header of the most inner loop containing the block).\n-\n-     These data structures are used by the first traversal only:\n-     stack - non-recursive DFS implementation which uses a stack of edges.\n-     sp - top of the stack of edges\n-     dfs_nr[i] - the DFS ordering of block i.\n-     in_stack[i] - flag set if the block i is in the DFS stack.\n-\n-     These data structures are used by the second traversal only:\n-     queue - queue containing the blocks of the current region.\n-     head and tail - queue boundaries.\n-     in_queue[i] - flag set if the block i is in queue */\n-\n-  /* function's inner arrays allocation and initialization */\n+  /* Note if an edge has been passed.  */\n+  sbitmap passed;\n+\n+  /* Note if a block is a natural loop header.  */\n+  sbitmap header;\n+\n+  /* Note if a block is an natural inner loop header.  */\n+  sbitmap inner;\n+\n+  /* Note if a block is in the block queue. */\n+  sbitmap in_queue;\n+\n+  /* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops\n+     and a mapping from block to its loop header (if the block is contained\n+     in a loop, else -1).\n+\n+     Store results in HEADER, INNER, and MAX_HDR respectively, these will\n+     be used as inputs to the second traversal.\n+\n+     STACK, SP and DFS_NR are only used during the first traversal.  */\n+\n+  /* Allocate and initialize variables for the first traversal.  */\n   max_hdr = (int *) alloca (n_basic_blocks * sizeof (int));\n   dfs_nr = (int *) alloca (n_basic_blocks * sizeof (int));\n   bzero ((char *) dfs_nr, n_basic_blocks * sizeof (int));\n   stack = (int *) alloca (nr_edges * sizeof (int));\n-  queue = (int *) alloca (n_basic_blocks * sizeof (int));\n \n-  inner = (char *) alloca (n_basic_blocks * sizeof (char));\n-  header = (char *) alloca (n_basic_blocks * sizeof (char));\n-  bzero ((char *) header, n_basic_blocks * sizeof (char));\n-  passed = (char *) alloca (nr_edges * sizeof (char));\n-  bzero ((char *) passed, nr_edges * sizeof (char));\n-  in_stack = (char *) alloca (nr_edges * sizeof (char));\n-  bzero ((char *) in_stack, nr_edges * sizeof (char));\n+  inner = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_ones (inner);\n+\n+  header = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (header);\n \n-  in_queue = (char *) alloca (n_basic_blocks * sizeof (char));\n+  passed = sbitmap_alloc (nr_edges);\n+  sbitmap_zero (passed);\n+\n+  in_queue = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (in_queue);\n \n   for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      inner[i] = 1;\n-      max_hdr[i] = -1;\n-    }\n+    max_hdr[i] = -1;\n \n-  /* First traversal: DFS, finds inner loops in control flow graph */\n+  /* DFS traversal to find inner loops in the cfg.  */\n \n   sp = -1;\n   while (1)\n     {\n-      if (current_edge == 0 || passed[current_edge])\n+      if (current_edge == 0 || TEST_BIT (passed, current_edge))\n \t{\n-\t  /*  Here, if  current_edge <  0, this is  a leaf  block.\n-\t     Otherwise current_edge  was already passed.  Note that in\n-\t     the latter case, not  only current_edge but also  all its\n-\t     NEXT_OUT edges are also passed.   We have to \"climb up on\n-\t     edges in  the  stack\", looking for the  first  (already\n-\t     passed) edge whose NEXT_OUT was not passed yet.  */\n-\n-\t  while (sp >= 0 && (current_edge == 0 || passed[current_edge]))\n+\t  /* We have reached a leaf node or a node that was already\n+\t     proc4essed.  Pop edges off the stack until we find\n+\t     an edge that has not yet been processed.  */\n+\t  while (sp >= 0\n+\t\t && (current_edge == 0 || TEST_BIT (passed, current_edge)))\n \t    {\n+\t      /* Pop entry off the stack.  */\n \t      current_edge = stack[sp--];\n \t      node = FROM_BLOCK (current_edge);\n \t      child = TO_BLOCK (current_edge);\n-\t      in_stack[child] = 0;\n-\t      if (max_hdr[child] >= 0 && in_stack[max_hdr[child]])\n+\t      if (max_hdr[child] >= 0 && TEST_BIT (dom[node], max_hdr[child]))\n \t\tUPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n \t      current_edge = NEXT_OUT (current_edge);\n \t    }\n \n-\t  /* stack empty - the whole graph is traversed.  */\n-\t  if (sp < 0 && passed[current_edge])\n+\t  /* See if have finished the DFS tree traversal.  */\n+\t  if (sp < 0 && TEST_BIT (passed, current_edge))\n \t    break;\n+\n+\t  /* Nope, continue the traversal with the popped node.  */\n \t  continue;\n \t}\n \n+      /* Process a node.  */\n       node = FROM_BLOCK (current_edge);\n-      dfs_nr[node] = ++count;\n-      in_stack[node] = 1;\n       child = TO_BLOCK (current_edge);\n+      dfs_nr[node] = ++count;\n \n-      /* found a loop header */\n-      if (in_stack[child])\n+      /* If the successor block dominates the current block, then\n+\t we've found a natural loop, record the header block for\n+\t future reference.  */\n+      if (TEST_BIT (dom[node], child))\n \t{\n \t  no_loops = 0;\n-\t  header[child] = 1;\n-\t  max_hdr[child] = child;\n+\t  SET_BIT (header, child);\n \t  UPDATE_LOOP_RELATIONS (node, child);\n-\t  passed[current_edge] = 1;\n+\t  SET_BIT (passed, current_edge);\n \t  current_edge = NEXT_OUT (current_edge);\n \t  continue;\n \t}\n \n-      /* the  child was already visited once, no need to go down from\n-         it, everything is traversed there.  */\n+      /* If the child was already visited, then there is no need to visit\n+\t it again.  Just update the loop relationships and restart\n+\t with a new edge.  */\n       if (dfs_nr[child])\n \t{\n-\t  if (max_hdr[child] >= 0 && in_stack[max_hdr[child]])\n+\t  if (max_hdr[child] >= 0 && TEST_BIT (dom[node], max_hdr[child]))\n \t    UPDATE_LOOP_RELATIONS (node, max_hdr[child]);\n-\t  passed[current_edge] = 1;\n+\t  SET_BIT (passed, current_edge);\n \t  current_edge = NEXT_OUT (current_edge);\n \t  continue;\n \t}\n \n-      /* this is a step down in the dfs traversal */\n+      /* Push an entry on the stack and continue DFS traversal.  */\n       stack[++sp] = current_edge;\n-      passed[current_edge] = 1;\n+      SET_BIT (passed, current_edge);\n       current_edge = OUT_EDGES (child);\n-    }\t\t\t\t/* while (1); */\n-\n-  /* Second travsersal: find reducible inner loops, and sort\n-     topologically the blocks of each region */\n-  degree = dfs_nr;\t\t/* reuse dfs_nr array - it is not needed anymore */\n-  bzero ((char *) in_queue, n_basic_blocks * sizeof (char));\n+    }\n \n+  /* ?!? This might be a good place to detect unreachable loops and\n+     avoid problems with them by forcing single block scheduling.  */\n   if (no_loops)\n-    header[0] = 1;\n+    SET_BIT (header, 0);\n+\n+  /* Second travsersal:find reducible inner loops and topologically sort\n+     block of each region.  */\n+\n+  /* Gross.  To avoid wasting memory, the second pass uses the dfs_nr array\n+     to hold degree counts.  */\n+  degree = dfs_nr;\n \n-  /* compute the in-degree of every block in the graph */\n+  /* Compute the in-degree of every block in the graph */\n   for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      fst_edge = IN_EDGES (i);\n-      if (fst_edge > 0)\n-\t{\n-\t  degree[i] = 1;\n-\t  current_edge = NEXT_IN (fst_edge);\n-\t  while (fst_edge != current_edge)\n-\t    {\n-\t      ++degree[i];\n-\t      current_edge = NEXT_IN (current_edge);\n-\t    }\n-\t}\n-      else\n-\tdegree[i] = 0;\n-    }\n+    degree[i] = num_preds[i];\n+\n+  queue = (int *) alloca (n_basic_blocks * sizeof (int));\n \n-  /* pass through all graph blocks, looking for headers of inner loops */\n+  /* Find blocks which are inner loop headers.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n-\n-      if (header[i] && inner[i])\n+      if (TEST_BIT (header, i) && TEST_BIT (inner, i))\n \t{\n+\t  int_list_ptr ps;\n \n-\t  /* i is a header of a potentially reducible inner loop, or\n-\t     block 0 in a subroutine with no loops at all */\n+\t  /* I is a header of a reducible inner loop, or block 0 in a\n+\t     subroutine with no loops at all.  */\n \t  head = tail = -1;\n \t  too_large_failure = 0;\n \t  loop_head = max_hdr[i];\n \n-\t  /* decrease in_degree of all i's successors, (this is needed\n-\t     for the topological ordering) */\n-\t  fst_edge = current_edge = OUT_EDGES (i);\n-\t  if (fst_edge > 0)\n-\t    {\n-\t      do\n-\t\t{\n-\t\t  --degree[TO_BLOCK (current_edge)];\n-\t\t  current_edge = NEXT_OUT (current_edge);\n-\t\t}\n-\t      while (fst_edge != current_edge);\n-\t    }\n+\t  /* Decrease degree of all I's successors for topological\n+\t     ordering.  */\n+\t  for (ps = s_succs[i]; ps; ps = ps->next)\n+\t    if (INT_LIST_VAL (ps) != EXIT_BLOCK\n+\t\t&& INT_LIST_VAL (ps) != ENTRY_BLOCK)\n+\t      --degree[INT_LIST_VAL (ps)];\n \n-\t  /* estimate # insns, and count # blocks in the region.  */\n+\t  /* Estimate # insns, and count # blocks in the region.  */\n \t  num_bbs = 1;\n-\t  num_insns = INSN_LUID (basic_block_end[i]) - INSN_LUID (basic_block_head[i]);\n+\t  num_insns\n+\t    = INSN_LUID (basic_block_end[i]) - INSN_LUID (basic_block_head[i]);\n \n \n-\t  /* find all loop latches, if it is a true loop header, or\n-\t     all leaves if the graph has no loops at all */\n+\t  /* Find all loop latches (blocks which back edges to the loop\n+\t     header) or all the leaf blocks in the cfg has no loops.\n+\n+\t     Place those blocks into the queue.  */\n \t  if (no_loops)\n \t    {\n \t      for (j = 0; j < n_basic_blocks; j++)\n-\t\tif (out_edges[j] == 0)\t/* a leaf */\n+\t\tif (num_succs[j] == 0)\n \t\t  {\n \t\t    queue[++tail] = j;\n-\t\t    in_queue[j] = 1;\n+\t\t    SET_BIT (in_queue, j);\n \n \t\t    if (too_large (j, &num_bbs, &num_insns))\n \t\t      {\n@@ -1711,74 +1661,110 @@ find_rgns ()\n \t    }\n \t  else\n \t    {\n-\t      fst_edge = current_edge = IN_EDGES (i);\n-\t      do\n+\t      int_list_ptr ps;\n+\n+\t      for (ps = s_preds[i]; ps; ps = ps->next)\n \t\t{\n-\t\t  node = FROM_BLOCK (current_edge);\n-\t\t  if (max_hdr[node] == loop_head && node != i)\t/* a latch */\n+\t\t  node = INT_LIST_VAL (ps);\n+\n+\t\t  if (node == ENTRY_BLOCK || node == EXIT_BLOCK)\n+\t\t    continue;\n+ \n+\t\t  if (max_hdr[node] == loop_head && node != i)\n \t\t    {\n+\t\t      /* This is a loop latch.  */\n \t\t      queue[++tail] = node;\n-\t\t      in_queue[node] = 1;\n+\t\t      SET_BIT (in_queue, node);\n \n \t\t      if (too_large (node, &num_bbs, &num_insns))\n \t\t\t{\n \t\t\t  too_large_failure = 1;\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n-\t\t  current_edge = NEXT_IN (current_edge);\n+\t\t  \n \t\t}\n-\t      while (fst_edge != current_edge);\n \t    }\n \n-\t  /* Put in queue[] all blocks that belong to the loop.  Check\n-\t     that the loop is reducible, traversing back from the loop\n-\t     latches up to the loop header.  */\n+\t  /* Now add all the blocks in the loop to the queue.\n+\n+\t     We know the loop is a natural loop; however the algorithm\n+\t     above will not always mark certain blocks as being in the\n+\t     loop.  Consider:\n+\t\tnode   children\n+\t\t a\t  b,c\n+\t\t b\t  c\n+\t\t c\t  a,d\n+\t\t d\t  b\n+\n+\n+\t     The algorithm in the DFS traversal may not mark B & D as part\n+\t     of the loop (ie they will not have max_hdr set to A).\n+\n+\t     We know they can not be loop latches (else they would have\n+\t     had max_hdr set since they'd have a backedge to a dominator\n+\t     block).  So we don't need them on the initial queue.\n+\n+\t     We know they are part of the loop because they are dominated\n+\t     by the loop header and can be reached by a backwards walk of\n+\t     the edges starting with nodes on the initial queue.\n+\n+\t     It is safe and desirable to include those nodes in the\n+\t     loop/scheduling region.  To do so we would need to decrease\n+\t     the degree of a node if it is the target of a backedge\n+\t     within the loop itself as the node is placed in the queue.\n+\n+\t     We do not do this because I'm not sure that the actual\n+\t     scheduling code will properly handle this case. ?!? */\n+\t\n \t  while (head < tail && !too_large_failure)\n \t    {\n+\t      int_list_ptr ps;\n \t      child = queue[++head];\n-\t      fst_edge = current_edge = IN_EDGES (child);\n-\t      do\n+\n+\t      for (ps = s_preds[child]; ps; ps = ps->next)\n \t\t{\n-\t\t  node = FROM_BLOCK (current_edge);\n+\t\t  node = INT_LIST_VAL (ps);\n \n-\t\t  if (max_hdr[node] != loop_head)\n-\t\t    {\t\t/* another entry to loop, it is irreducible */\n+\t\t  /* See discussion above about nodes not marked as in\n+\t\t     this loop during the initial DFS traversal.  */\n+\t\t  if (node == ENTRY_BLOCK || node == EXIT_BLOCK\n+\t\t      || max_hdr[node] != loop_head)\n+\t\t    {\n \t\t      tail = -1;\n \t\t      break;\n \t\t    }\n-\t\t  else if (!in_queue[node] && node != i)\n+\t\t  else if (!TEST_BIT (in_queue, node) && node != i)\n \t\t    {\n \t\t      queue[++tail] = node;\n-\t\t      in_queue[node] = 1;\n+\t\t      SET_BIT (in_queue, node);\n \n \t\t      if (too_large (node, &num_bbs, &num_insns))\n \t\t\t{\n \t\t\t  too_large_failure = 1;\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n-\t\t  current_edge = NEXT_IN (current_edge);\n \t\t}\n-\t      while (fst_edge != current_edge);\n \t    }\n \n \t  if (tail >= 0 && !too_large_failure)\n \t    {\n-\t      /* Place the loop header into list of region blocks */\n+\t      /* Place the loop header into list of region blocks.  */\n \t      degree[i] = -1;\n \t      rgn_bb_table[idx] = i;\n \t      RGN_NR_BLOCKS (nr_regions) = num_bbs;\n \t      RGN_BLOCKS (nr_regions) = idx++;\n \t      CONTAINING_RGN (i) = nr_regions;\n \t      BLOCK_TO_BB (i) = count = 0;\n \n-\t      /* remove blocks from queue[], (in topological order), when\n-\t         their  in_degree becomes 0.  We  scan  the queue over and\n-\t         over  again until   it is empty.   Note: there may be a more\n-\t         efficient way to do it.  */\n+\t      /* Remove blocks from queue[] when their in degree becomes\n+\t\t zero.  Repeat until no blocks are left on the list.  This\n+\t\t produces a topological list of blocks in the region.  */\n \t      while (tail >= 0)\n \t\t{\n+\t\t  int_list_ptr ps;\n+\n \t\t  if (head < 0)\n \t\t    head = tail;\n \t\t  child = queue[head];\n@@ -1789,17 +1775,11 @@ find_rgns ()\n \t\t      BLOCK_TO_BB (child) = ++count;\n \t\t      CONTAINING_RGN (child) = nr_regions;\n \t\t      queue[head] = queue[tail--];\n-\t\t      fst_edge = current_edge = OUT_EDGES (child);\n \n-\t\t      if (fst_edge > 0)\n-\t\t\t{\n-\t\t\t  do\n-\t\t\t    {\n-\t\t\t      --degree[TO_BLOCK (current_edge)];\n-\t\t\t      current_edge = NEXT_OUT (current_edge);\n-\t\t\t    }\n-\t\t\t  while (fst_edge != current_edge);\n-\t\t\t}\n+\t\t      for (ps = s_succs[child]; ps; ps = ps->next)\n+\t\t\tif (INT_LIST_VAL (ps) != ENTRY_BLOCK\n+\t\t\t    && INT_LIST_VAL (ps) != EXIT_BLOCK)\n+\t\t\t  --degree[INT_LIST_VAL (ps)];\n \t\t    }\n \t\t  else\n \t\t    --head;\n@@ -1809,7 +1789,8 @@ find_rgns ()\n \t}\n     }\n \n-  /* define each of all other blocks as a region itself */\n+  /* Any block that did not end up in a region is placed into a region\n+     by itself.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     if (degree[i] >= 0)\n       {\n@@ -1820,7 +1801,11 @@ find_rgns ()\n \tBLOCK_TO_BB (i) = 0;\n       }\n \n-}\t\t\t\t/* find_rgns */\n+  free (passed);\n+  free (header);\n+  free (inner);\n+  free (in_queue);\n+}\n \n \n /* functions for regions scheduling information */\n@@ -8436,20 +8421,53 @@ schedule_insns (dump_file)\n \t}\n       else\n \t{\n+\t  int_list_ptr *s_preds, *s_succs;\n+\t  int *num_preds, *num_succs;\n+\t  sbitmap *dom, *pdom;\n+\n+\t  s_preds = (int_list_ptr *) alloca (n_basic_blocks\n+\t\t\t\t\t     * sizeof (int_list_ptr));\n+\t  s_succs = (int_list_ptr *) alloca (n_basic_blocks\n+\t\t\t\t\t     * sizeof (int_list_ptr));\n+\t  num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n+\t  num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n+\t  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+\t  pdom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+\n+\t  /* The scheduler runs after flow; therefore, we can't blindly call\n+\t     back into find_basic_blocks since doing so could invalidate the\n+\t     info in basic_block_live_at_start.\n+\n+\t     Consider a block consisting entirely of dead stores; after life\n+\t     analysis it would be a block of NOTE_INSN_DELETED notes.  If\n+\t     we call find_basic_blocks again, then the block would be removed\n+\t     entirely and invalidate our the register live information.\n+\n+\t     We could (should?) recompute register live information.  Doing\n+\t     so may even be beneficial.  */\n+\n+\t  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n+\n+\t  /* Compute the dominators and post dominators.  We don't currently use\n+\t     post dominators, but we should for speculative motion analysis.  */\n+\t  compute_dominators (dom, pdom, s_preds, s_succs);\n+\n \t  /* build_control_flow will return nonzero if it detects unreachable\n \t     blocks or any other irregularity with the cfg which prevents\n \t     cross block scheduling.  */\n-\t  if (build_control_flow () != 0)\n+\t  if (build_control_flow (s_preds, s_succs, num_preds, num_succs) != 0)\n \t    find_single_block_region ();\n \t  else\n-\t    find_rgns ();\n+\t    find_rgns (s_preds, s_succs, num_preds, num_succs, dom);\n \n \t  if (sched_verbose >= 3)\n-\t    {\n-\t      debug_control_flow ();\n-\t      debug_regions ();\n-\t    }\n+\t    debug_regions ();\n \n+\t  /* For now.  This will move as more and more of haifa is converted\n+\t     to using the cfg code in flow.c  */\n+\t  free_bb_mem ();\n+\t  free (dom);\n+\t  free (pdom);\n \t}\n     }\n "}]}