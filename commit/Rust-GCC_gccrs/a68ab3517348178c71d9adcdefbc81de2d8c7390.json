{"sha": "a68ab3517348178c71d9adcdefbc81de2d8c7390", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY4YWIzNTE3MzQ4MTc4YzcxZDlhZGNkZWZiYzgxZGUyZDhjNzM5MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-06-06T13:01:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-06-06T13:01:54Z"}, "message": "c-cppbuiltin.c (c_cpp_builtins): Change _OPENMP value to 200805.\n\n\t* c-cppbuiltin.c (c_cpp_builtins): Change _OPENMP value to\n\t200805.\n\t* langhooks.h (struct lang_hooks_for_decls): Add omp_finish_clause.\n\tAdd omp_private_outer_ref hook, add another argument to\n\tomp_clause_default_ctor hook.\n\t* langhooks-def.h (LANG_HOOKS_OMP_FINISH_CLAUSE): Define.\n\t(LANG_HOOKS_OMP_PRIVATE_OUTER_REF): Define.\n\t(LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR): Change to\n\thook_tree_tree_tree_tree_null.\n\t(LANG_HOOKS_DECLS): Add LANG_HOOKS_OMP_FINISH_CLAUSE and\n\tLANG_HOOKS_OMP_PRIVATE_OUTER_REF.\n\t* hooks.c (hook_tree_tree_tree_tree_null): New function.\n\t* hooks.h (hook_tree_tree_tree_tree_null): New prototype.\n\t* tree.def (OMP_TASK): New tree code.\n\t* tree.h (OMP_TASK_COPYFN, OMP_TASK_ARG_SIZE, OMP_TASK_ARG_ALIGN,\n\tOMP_CLAUSE_PRIVATE_OUTER_REF, OMP_CLAUSE_LASTPRIVATE_STMT,\n\tOMP_CLAUSE_COLLAPSE_ITERVAR, OMP_CLAUSE_COLLAPSE_COUNT,\n\tOMP_TASKREG_CHECK, OMP_TASKREG_BODY, OMP_TASKREG_CLAUSES,\n\tOMP_TASKREG_FN, OMP_TASKREG_DATA_ARG, OMP_TASK_BODY,\n\tOMP_TASK_CLAUSES, OMP_TASK_FN, OMP_TASK_DATA_ARG,\n\tOMP_CLAUSE_COLLAPSE_EXPR): Define.\n\t(enum omp_clause_default_kind): Add OMP_CLAUSE_DEFAULT_FIRSTPRIVATE.\n\t(OMP_DIRECTIVE_P): Add OMP_TASK.\n\t(OMP_CLAUSE_COLLAPSE, OMP_CLAUSE_UNTIED): New clause codes.\n\t(OMP_CLAUSE_SCHEDULE_AUTO): New schedule kind.\n\t* tree.c (omp_clause_code_name): Add OMP_CLAUSE_COLLAPSE\n\tand OMP_CLAUSE_UNTIED entries.\n\t(omp_clause_num_ops): Likewise.  Increase OMP_CLAUSE_LASTPRIVATE\n\tnum_ops to 2.\n\t(walk_tree_1): Handle OMP_CLAUSE_COLLAPSE and OMP_CLAUSE_UNTIED.\n\tWalk OMP_CLAUSE_LASTPRIVATE_STMT.\n\t* tree-pretty-print.c (dump_omp_clause): Handle\n\tOMP_CLAUSE_SCHEDULE_AUTO, OMP_CLAUSE_UNTIED, OMP_CLAUSE_COLLAPSE,\n\tOMP_CLAUSE_DEFAULT_FIRSTPRIVATE.\n\t(dump_generic_node): Handle OMP_TASK and collapsed OMP_FOR loops.\n\t* c-omp.c (c_finish_omp_for): Allow pointer iterators.  Remove\n\twarning about unsigned iterators.  Change decl/init/cond/incr\n\targuments to TREE_VECs, check arguments for all collapsed loops.\n\t(c_finish_omp_taskwait): New function.\n\t(c_split_parallel_clauses): Put OMP_CLAUSE_COLLAPSE clause to\n\tws_clauses.\n\t* c-parser.c (c_parser_omp_for_loop): Parse collapsed loops.  Call\n\tdefault_function_array_conversion on init.  Add par_clauses argument.\n\tIf decl is present in parallel's lastprivate clause, change it to\n\tshared and add lastprivate clause for decl to OMP_FOR_CLAUSES.\n\tAdd clauses argument, on success set OMP_FOR_CLAUSES to it.  Look up\n\tcollapse count in clauses.\n\t(c_parser_omp_for, c_parser_omp_parallel): Adjust\n\tc_parser_omp_for_loop callers.\n\t(OMP_FOR_CLAUSE_MASK): Add 1 << PRAGMA_OMP_CLAUSE_COLLAPSE.\n\t(c_parser_pragma): Handle PRAGMA_OMP_TASKWAIT.\n\t(c_parser_omp_clause_name): Handle collapse and untied clauses.\n\t(c_parser_omp_clause_collapse, c_parser_omp_clause_untied): New\n\tfunctions.\n\t(c_parser_omp_clause_schedule): Handle schedule(auto).\n\tInclude correct location in the error message.\n\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_COLLAPSE\n\tand PRAGMA_OMP_CLAUSE_UNTIED.\n\t(OMP_TASK_CLAUSE_MASK): Define.\n\t(c_parser_omp_task, c_parser_omp_taskwait): New functions.\n\t(c_parser_omp_construct): Handle PRAGMA_OMP_TASK.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Handle OMP_CLAUSE_LASTPRIVATE_STMT,\n\tOMP_CLAUSE_REDUCTION_INIT, OMP_CLAUSE_REDUCTION_MERGE,\n\tOMP_CLAUSE_COLLAPSE and OMP_CLAUSE_UNTIED.\n\tDon't handle TREE_STATIC or DECL_EXTERNAL VAR_DECLs in\n\tOMP_CLAUSE_DECL.\n\t(conver_nonlocal_reference, convert_local_reference,\n\tconvert_call_expr): Handle OMP_TASK the same as OMP_PARALLEL.  Use\n\tOMP_TASKREG_* macros rather than OMP_PARALLEL_*.\n\t(walk_omp_for): Adjust for OMP_FOR_{INIT,COND,INCR} changes.\n\t* tree-gimple.c (is_gimple_stmt): Handle OMP_TASK.\n\t* c-tree.h (c_begin_omp_task, c_finish_omp_task): New prototypes.\n\t* c-pragma.h (PRAGMA_OMP_TASK, PRAGMA_OMP_TASKWAIT): New.\n\t(PRAGMA_OMP_CLAUSE_COLLAPSE, PRAGMA_OMP_CLAUSE_UNTIED): New.\n\t* c-typeck.c (c_begin_omp_task, c_finish_omp_task): New functions.\n\t(c_finish_omp_clauses): Handle OMP_CLAUSE_COLLAPSE and\n\tOMP_CLAUSE_UNTIED.\n\t* c-pragma.c (init_pragma): Init omp task and omp taskwait pragmas.\n\t* c-common.h (c_finish_omp_taskwait): New prototype.\n\t* gimple-low.c (lower_stmt): Handle OMP_TASK.\n\t* tree-parloops.c (create_parallel_loop): Create 1 entry\n\tvectors for OMP_FOR_{INIT,COND,INCR}.\n\t* tree-cfg.c (remove_useless_stmts_1): Handle OMP_* containers.\n\t(make_edges): Handle OMP_TASK.\n\t* tree-ssa-operands.c (get_expr_operands): Handle collapsed OMP_FOR\n\tloops, adjust for OMP_FOR_{INIT,COND,INCR} changes.\n\t* tree-inline.c (estimate_num_insns_1): Handle OMP_TASK.\n\t* builtin-types.def (BT_PTR_ULONGLONG, BT_PTR_FN_VOID_PTR_PTR,\n\tBT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR,\n\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): New.\n\t* omp-builtins.def (BUILT_IN_GOMP_TASK, BUILT_IN_GOMP_TASKWAIT,\n\tBUILT_IN_GOMP_LOOP_ULL_STATIC_START,\n\tBUILT_IN_GOMP_LOOP_ULL_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_ULL_GUIDED_START,\n\tBUILT_IN_GOMP_LOOP_ULL_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_START,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_START,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_START,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_START,\n\tBUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_DYNAMIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_GUIDED_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_RUNTIME_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_NEXT,\n\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_NEXT): New builtins.\n\t* gimplify.c (gimplify_omp_for): Allow pointer type for decl,\n\thandle POINTER_PLUS_EXPR.  If loop counter has been replaced and\n\toriginal iterator is present in lastprivate clause or if\n\tcollapse > 1, set OMP_CLAUSE_LASTPRIVATE_STMT.  Handle collapsed\n\tOMP_FOR loops, adjust for OMP_FOR_{INIT,COND,INCR} changes.\n\t(gimplify_expr): Handle OMP_SECTIONS_SWITCH and OMP_TASK.\n\t(enum gimplify_omp_var_data): Add GOVD_PRIVATE_OUTER_REF.\n\t(omp_notice_variable): Set GOVD_PRIVATE_OUTER_REF if needed,\n\tif it is set, lookup var in outer contexts too.  Handle\n\tOMP_CLAUSE_DEFAULT_FIRSTPRIVATE.  Handle vars that are supposed\n\tto be implicitly determined firstprivate for task regions.\n\t(gimplify_scan_omp_clauses): Set GOVD_PRIVATE_OUTER_REF if needed,\n\tif it is set, lookup var in outer contexts too.  Set\n\tOMP_CLAUSE_PRIVATE_OUTER_REF if GOVD_PRIVATE_OUTER_REF is set.\n\tHandle OMP_CLAUSE_LASTPRIVATE_STMT, OMP_CLAUSE_COLLAPSE and\n\tOMP_CLAUSE_UNTIED.  Take region_type as last argument\n\tinstead of in_parallel and in_combined_parallel.\n\t(gimplify_omp_parallel, gimplify_omp_for, gimplify_omp_workshare):\n\tAdjust callers.\n\t(gimplify_adjust_omp_clauses_1): Set OMP_CLAUSE_PRIVATE_OUTER_REF if\n\tGOVD_PRIVATE_OUTER_REF is set.  Call omp_finish_clause\n\tlanghook.\n\t(new_omp_context): Set default_kind to\n\tOMP_CLAUSE_DEFAULT_UNSPECIFIED for OMP_TASK regions.\n\t(omp_region_type): New enum.\n\t(struct gimplify_omp_ctx): Remove is_parallel and is_combined_parallel\n\tfields, add region_type.\n\t(new_omp_context): Take region_type as argument instead of is_parallel\n\tand is_combined_parallel.\n\t(gimple_add_tmp_var, omp_firstprivatize_variable, omp_notice_variable,\n\tomp_is_private, omp_check_private): Adjust ctx->is_parallel and\n\tctx->is_combined_parallel checks.\n\t(gimplify_omp_task): New function.\n\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_COLLAPSE and\n\tOMP_CLAUSE_UNTIED.\n\t* omp-low.c (extract_omp_for_data): Use schedule(static)\n\tfor schedule(auto).  Handle pointer and unsigned iterators.\n\tCompute fd->iter_type.  Handle POINTER_PLUS_EXPR increments.\n\tAdd loops argument.  Extract data for collapsed OMP_FOR loops.\n\t(expand_parallel_call): Assert sched_kind isn't auto,\n\tmap runtime schedule to index 3.\n\t(struct omp_for_data_loop): New type.\n\t(struct omp_for_data): Remove v, n1, n2, step, cond_code fields.\n\tAdd loop, loops, collapse and iter_type fields.\n\t(workshare_safe_to_combine_p): Disallow combined for if\n\titer_type is unsigned long long.  Don't combine collapse > 1 loops\n\tunless all bounds and steps are constant.  Adjust extract_omp_for_data\n\tcaller.\n\t(expand_omp_for_generic): Handle pointer, unsigned and long long\n\titerators.  Handle collapsed OMP_FOR loops.  Adjust\n\tfor struct omp_for_data changes.  If libgomp function doesn't return\n\tboolean_type_node, add comparison of the return value with 0.\n\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk): Handle\n\tpointer, unsigned and long long iterators.  Adjust for struct\n\tomp_for_data changes.\n\t(expand_omp_for): Assert sched_kind isn't auto, map runtime schedule\n\tto index 3.  Use GOMP_loop_ull*{start,next} if iter_type is\n\tunsigned long long.  Allocate loops array, pass it to\n\textract_omp_for_data.  For collapse > 1 loops use always\n\texpand_omp_for_generic.\n\t(omp_context): Add sfield_map and srecord_type fields.\n\t(is_task_ctx, lookup_sfield): New functions.\n\t(use_pointer_for_field): Use is_task_ctx helper.  Change first\n\targument's type from const_tree to tree.  Clarify comment.\n\tIn OMP_TASK disallow copy-in/out sharing.\n\t(build_sender_ref): Call lookup_sfield instead of lookup_field.\n\t(install_var_field): Add mask argument.  Populate both record_type\n\tand srecord_type if needed.\n\t(delete_omp_context): Destroy sfield_map, clear DECL_ABSTRACT_ORIGIN\n\tin srecord_type.\n\t(fixup_child_record_type): Also remap FIELD_DECL's DECL_SIZE{,_UNIT}\n\tand DECL_FIELD_OFFSET.\n\t(scan_sharing_clauses): Adjust install_var_field callers.  For\n\tfirstprivate clauses on explicit tasks allocate the var by value in\n\trecord_type unconditionally, rather than by reference.\n\tHandle OMP_CLAUSE_PRIVATE_OUTER_REF.  Scan OMP_CLAUSE_LASTPRIVATE_STMT.\n\tUse is_taskreg_ctx instead of is_parallel_ctx.\n\tHandle OMP_CLAUSE_COLLAPSE and OMP_CLAUSE_UNTIED.\n\t(create_omp_child_function_name): Add task_copy argument, use\n\t*_omp_cpyfn* names if it is true.\n\t(create_omp_child_function): Add task_copy argument, if true create\n\t*_omp_cpyfn* helper function.\n\t(scan_omp_parallel): Adjust create_omp_child_function callers.\n\tRename parallel_nesting_level to taskreg_nesting_level.\n\t(scan_omp_task): New function.\n\t(lower_rec_input_clauses): Don't run constructors for firstprivate\n\texplicit task vars which are initialized by *_omp_cpyfn*.  \n\tPass outer var ref to omp_clause_default_ctor hook if\n\tOMP_CLAUSE_PRIVATE_OUTER_REF or OMP_CLAUSE_LASTPRIVATE.\n\tReplace OMP_CLAUSE_REDUCTION_PLACEHOLDER decls in\n\tOMP_CLAUSE_REDUCTION_INIT.\n\t(lower_send_clauses): Clear DECL_ABSTRACT_ORIGIN if in task to\n\tavoid duplicate setting of fields.  Handle\n\tOMP_CLAUSE_PRIVATE_OUTER_REF.\n\t(lower_send_shared_vars): Use srecord_type if non-NULL.  Don't\n\tcopy-out if TREE_READONLY, only copy-in.\n\t(expand_task_copyfn): New function.\n\t(expand_task_call): New function.\n\t(struct omp_taskcopy_context): New type.\n\t(task_copyfn_copy_decl, task_copyfn_remap_type, create_task_copyfn):\n\tNew functions.\n\t(lower_omp_parallel): Rename to...\n\t(lower_omp_taskreg): ... this.  Use OMP_TASKREG_* macros where needed.\n\tCall create_task_copyfn if srecord_type is needed.  Adjust\n\tsender_decl type.\n\t(task_shared_vars): New variable.\n\t(check_omp_nesting_restrictions): Warn if work-sharing,\n\tbarrier, master or ordered region is closely nested inside OMP_TASK.\n\tAdd warnings for barrier if closely nested inside of work-sharing,\n\tordered, or master region.\n\t(scan_omp_1): Call check_omp_nesting_restrictions even for\n\tGOMP_barrier calls.  Rename parallel_nesting_level to\n\ttaskreg_nesting_level.  Handle OMP_TASK.\n\t(lower_lastprivate_clauses): Even if some lastprivate is found on a\n\twork-sharing construct, continue looking for them on parent parallel\n\tconstruct.\n\t(lower_omp_for_lastprivate): Add lastprivate clauses\n\tto the beginning of dlist rather than end.  Adjust for struct\n\tomp_for_data changes.\n\t(lower_omp_for): Add rec input clauses before OMP_FOR_PRE_BODY,\n\tnot after it.  Handle collapsed OMP_FOR loops, adjust for\n\tOMP_FOR_{INIT,COND,INCR} changes, adjust extract_omp_for_data\n\tcaller.\n\t(get_ws_args_for): Adjust extract_omp_for_data caller.\n\t(scan_omp_for): Handle collapsed OMP_FOR\n\tloops, adjust for OMP_FOR_{INIT,COND,INCR} changes.\n\t(lower_omp_single_simple): If libgomp function doesn't return\n\tboolean_type_node, add comparison of the return value with 0.\n\t(diagnose_sb_1, diagnose_sb_2): Handle collapsed OMP_FOR\n\tloops, adjust for OMP_FOR_{INIT,COND,INCR} changes.  Handle OMP_TASK.\n\t(parallel_nesting_level): Rename to...\n\t(taskreg_nesting_level): ... this.\n\t(is_taskreg_ctx): New function.\n\t(build_outer_var_ref, omp_copy_decl): Use is_taskreg_ctx instead\n\tof is_parallel_ctx.\n\t(execute_lower_omp): Rename parallel_nesting_level to\n\ttaskreg_nesting_level.\n\t(expand_omp_parallel): Rename to...\n\t(expand_omp_taskreg): ... this.  Use OMP_TASKREG_* macros where needed.\n\tCall omp_task_call for OMP_TASK regions.\n\t(expand_omp): Adjust caller, handle OMP_TASK.\n\t(lower_omp_1): Adjust lower_omp_taskreg caller, handle OMP_TASK.\n\n\t* bitmap.c (bitmap_default_obstack_depth): New variable.\n\t(bitmap_obstack_initialize, bitmap_obstack_release): Do nothing\n\tif argument is NULL and bitmap_default_obstack is already initialized.\n\t* ipa-struct-reorg.c (do_reorg_1): Call bitmap_obstack_release\n\tat the end.\n\t* matrix-reorg.c (matrix_reorg): Likewise.\ncp/\n\t* cp-tree.h (cxx_omp_finish_clause, cxx_omp_create_clause_info,\n\tdependent_omp_for_p, begin_omp_task, finish_omp_task,\n\tfinish_omp_taskwait): New prototypes.\n\t(cxx_omp_clause_default_ctor): Add outer argument.\n\t(finish_omp_for): Add new clauses argument.\n\t* cp-gimplify.c (cxx_omp_finish_clause): New function.\n\t(cxx_omp_predetermined_sharing): Moved from semantics.c, rewritten.\n\t(cxx_omp_clause_default_ctor): Add outer argument.\n\t(cp_genericize_r): Walk OMP_CLAUSE_LASTPRIVATE_STMT.\n\t* cp-objcp-common.h (LANG_HOOKS_OMP_FINISH_CLAUSE): Define.\n\t* parser.c (cp_parser_omp_for_loop): Parse collapsed for loops.\n\tAdd par_clauses argument.  If decl is present in parallel's\n\tlastprivate clause, change that clause to shared and add\n\ta lastprivate clause for decl to OMP_FOR_CLAUSES.\n\tFix wording of error messages.  Adjust finish_omp_for caller.\n\tAdd clauses argument.  Parse loops with random access iterators.\n\t(cp_parser_omp_clause_collapse, cp_parser_omp_clause_untied): New\n\tfunctions.\n\t(cp_parser_omp_for, cp_parser_omp_parallel): Adjust\n\tcp_parser_omp_for_loop callers.\n\t(cp_parser_omp_for_cond, cp_parser_omp_for_incr): New helper\n\tfunctions.\n\t(cp_parser_omp_clause_name): Handle collapse and untied\n\tclauses.\n\t(cp_parser_omp_clause_schedule): Handle auto schedule.\n\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_COLLAPSE\n\tand PRAGMA_OMP_CLAUSE_UNTIED.\n\t(OMP_FOR_CLAUSE_MASK): Add PRAGMA_OMP_CLAUSE_COLLAPSE.\n\t(OMP_TASK_CLAUSE_MASK): Define.\n\t(cp_parser_omp_task, cp_parser_omp_taskwait): New functions.\n\t(cp_parser_omp_construct): Handle PRAGMA_OMP_TASK.\n\t(cp_parser_pragma): Handle PRAGMA_OMP_TASK and\n\tPRAGMA_OMP_TASKWAIT.\n\t* pt.c (tsubst_omp_clauses): Handle OMP_CLAUSE_COLLAPSE and\n\tOMP_CLAUSE_UNTIED.  Handle OMP_CLAUSE_LASTPRIVATE_STMT.\n\t(tsubst_omp_for_iterator): New function.\n\t(dependent_omp_for_p): New function.\n\t(tsubst_expr) <case OMP_FOR>: Use it.  Handle collapsed OMP_FOR\n\tloops.  Adjust finish_omp_for caller.  Handle loops with random\n\taccess iterators.  Adjust for OMP_FOR_{INIT,COND,INCR} changes.\n\t(tsubst_expr): Handle OMP_TASK.\n\t* semantics.c (cxx_omp_create_clause_info): New function.\n\t(finish_omp_clauses): Call it.  Handle OMP_CLAUSE_UNTIED and\n\tOMP_CLAUSE_COLLAPSE.\n\t(cxx_omp_predetermined_sharing): Removed.\n\t* semantics.c (finish_omp_for): Allow pointer iterators.  Use\n\thandle_omp_for_class_iterator and dependent_omp_for_p.  Handle\n\tcollapsed for loops.  Adjust c_finish_omp_for caller.  Add new\n\tclauses argument.  Fix check for type dependent cond or incr.\n\tSet OMP_FOR_CLAUSES to clauses.  Use cp_convert instead of\n\tfold_convert to convert incr amount to difference_type.  Only\n\tfold if not in template.  If decl is mentioned in lastprivate\n\tclause, set OMP_CLAUSE_LASTPRIVATE_STMT.  Handle loops with random\n\taccess iterators.  Adjust for OMP_FOR_{INIT,COND,INCR}\n\tchanges.\n\t(finish_omp_threadprivate): Allow static class members of the\n\tcurrent class.\n\t(handle_omp_for_class_iterator, begin_omp_task, finish_omp_task,\n\tfinish_omp_taskwait): New functions.\n\n\t* parser.c (cp_parser_binary_expression): Add prec argument.\n\t(cp_parser_assignment_expression): Adjust caller.\n\t* cp-tree.h (outer_curly_brace_block): New prototype.\n\t* decl.c (outer_curly_brace_block): No longer static.\nfortran/\n\t* scanner.c (skip_free_comments, skip_fixed_comments): Handle tabs.\n\t* parse.c (next_free): Allow tab after !$omp.\n\t(decode_omp_directive): Handle !$omp task, !$omp taskwait\n\tand !$omp end task.\n\t(case_executable): Add ST_OMP_TASKWAIT.\n\t(case_exec_markers): Add ST_OMP_TASK.\n\t(gfc_ascii_statement): Handle ST_OMP_TASK, ST_OMP_END_TASK and\n\tST_OMP_TASKWAIT.\n\t(parse_omp_structured_block, parse_executable): Handle ST_OMP_TASK.\n\t* gfortran.h (gfc_find_sym_in_expr): New prototype.\n\t(gfc_statement): Add ST_OMP_TASK, ST_OMP_END_TASK and ST_OMP_TASKWAIT.\n\t(gfc_omp_clauses): Add OMP_SCHED_AUTO to sched_kind,\n\tOMP_DEFAULT_FIRSTPRIVATE to default_sharing.  Add collapse and\n\tuntied fields.\n\t(gfc_exec_op): Add EXEC_OMP_TASK and EXEC_OMP_TASKWAIT.\n\t* f95-lang.c (LANG_HOOKS_OMP_CLAUSE_COPY_CTOR,\n\tLANG_HOOKS_OMP_CLAUSE_ASSIGN_OP, LANG_HOOKS_OMP_CLAUSE_DTOR,\n\tLANG_HOOKS_OMP_PRIVATE_OUTER_REF): Define.\n\t* trans.h (gfc_omp_clause_default_ctor): Add another argument.\n\t(gfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,\n\tgfc_omp_clause_dtor, gfc_omp_private_outer_ref): New prototypes.\n\t* types.def (BT_ULONGLONG, BT_PTR_ULONGLONG,\n\tBT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR,\n\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n\tBT_FN_VOID_PTR_PTR, BT_PTR_FN_VOID_PTR_PTR,\n\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): New.\n\t(BT_BOOL): Use integer type with BOOL_TYPE_SIZE rather\n\tthan boolean_type_node.\n\t* dump-parse-tree.c (gfc_show_omp_node): Handle EXEC_OMP_TASK,\n\tEXEC_OMP_TASKWAIT, OMP_SCHED_AUTO, OMP_DEFAULT_FIRSTPRIVATE,\n\tuntied and collapse clauses.\n\t(gfc_show_code_node): Handle EXEC_OMP_TASK and EXEC_OMP_TASKWAIT.\n\t* trans.c (gfc_trans_code): Handle EXEC_OMP_TASK and\n\tEXEC_OMP_TASKWAIT.\n\t* st.c (gfc_free_statement): Likewise.\n\t* resolve.c (gfc_resolve_blocks, resolve_code): Likewise.\n\t(find_sym_in_expr): Rename to...\n\t(gfc_find_sym_in_expr): ... this.  No longer static.\n\t(resolve_allocate_expr, resolve_ordinary_assign): Adjust caller.\n\t* match.h (gfc_match_omp_task, gfc_match_omp_taskwait): New\n\tprototypes.\n\t* openmp.c (resolve_omp_clauses): Allow allocatable arrays in\n\tfirstprivate, lastprivate, reduction, copyprivate and copyin\n\tclauses.\n\t(omp_current_do_code): Made static.\n\t(omp_current_do_collapse): New variable.\n\t(gfc_resolve_omp_do_blocks): Compute omp_current_do_collapse,\n\tclear omp_current_do_code and omp_current_do_collapse on return.\n\t(gfc_resolve_do_iterator): Handle collapsed do loops.\n\t(resolve_omp_do): Likewise, diagnose errorneous collapsed do loops.\n\t(OMP_CLAUSE_COLLAPSE, OMP_CLAUSE_UNTIED): Define.\n\t(gfc_match_omp_clauses): Handle default (firstprivate),\n\tschedule (auto), untied and collapse (n) clauses.\n\t(OMP_DO_CLAUSES): Add OMP_CLAUSE_COLLAPSE.\n\t(OMP_TASK_CLAUSES): Define.\n\t(gfc_match_omp_task, gfc_match_omp_taskwait): New functions.\n\t* trans-openmp.c (gfc_omp_private_outer_ref): New function.\n\t(gfc_omp_clause_default_ctor): Add outer argument.  For allocatable\n\tarrays allocate them with the bounds of the outer var if outer\n\tvar is allocated.\n\t(gfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,\n\tgfc_omp_clause_dtor): New functions.\n\t(gfc_trans_omp_array_reduction): If decl is allocatable array,\n\tallocate it with outer var's bounds in OMP_CLAUSE_REDUCTION_INIT\n\tand deallocate it in OMP_CLAUSE_REDUCTION_MERGE.\n\t(gfc_omp_predetermined_sharing): Return OMP_CLAUSE_DEFAULT_SHARED\n\tfor assumed-size arrays.\n\t(gfc_trans_omp_do): Add par_clauses argument.  If dovar is\n\tpresent in lastprivate clause and do loop isn't simple,\n\tset OMP_CLAUSE_LASTPRIVATE_STMT.  If dovar is present in\n\tparallel's lastprivate clause, change it to shared and add\n\tlastprivate clause to OMP_FOR_CLAUSES.  Handle collapsed do loops.\n\t(gfc_trans_omp_directive): Adjust gfc_trans_omp_do callers.\n\t(gfc_trans_omp_parallel_do): Likewise.  Move collapse clause to\n\tOMP_FOR from OMP_PARALLEL.\n\t(gfc_trans_omp_clauses): Handle OMP_SCHED_AUTO,\n\tOMP_DEFAULT_FIRSTPRIVATE, untied and collapse clauses.\n\t(gfc_trans_omp_task, gfc_trans_omp_taskwait): New functions.\n\t(gfc_trans_omp_directive): Handle EXEC_OMP_TASK and\n\tEXEC_OMP_TASKWAIT.\ngcc/testsuite/\n\t* gcc.dg/gomp/collapse-1.c: New test.\n\t* gcc.dg/gomp/nesting-1.c: New test.\n\t* g++.dg/gomp/task-1.C: New test.\n\t* g++.dg/gomp/predetermined-1.C: New test.\n\t* g++.dg/gomp/tls-4.C: New test.\n\t* gfortran.dg/gomp/collapse1.f90: New test.\n\t* gfortran.dg/gomp/sharing-3.f90: New test.\n\t* gcc.dg/gomp/pr27499.c (foo): Remove is unsigned dg-warning.\n\t* g++.dg/gomp/pr27499.C (foo): Likewise.\n\t* g++.dg/gomp/for-16.C (foo): Likewise.\n\t* g++.dg/gomp/tls-3.C: Remove dg-error, add S::s definition.\n\t* g++.dg/gomp/pr34607.C: Adjust dg-error location.\n\t* g++.dg/gomp/for-16.C (foo): Add a new dg-error.\n\t* gcc.dg/gomp/appendix-a/a.35.4.c: Add dg-warning.\n\t* gcc.dg/gomp/appendix-a/a.35.6.c: Likewise.\n\t* gfortran.dg/gomp/appendix-a/a.35.4.f90: Likewise.\n\t* gfortran.dg/gomp/appendix-a/a.35.6.f90: Likewise.\n\t* gfortran.dg/gomp/omp_parse1.f90: Remove !$omp tab test.\n\t* gfortran.dg/gomp/appendix-a/a.33.4.f90: Remove dg-error\n\tabout allocatable array.\n\t* gfortran.dg/gomp/reduction1.f90: Likewise.\nlibgomp/\n\t* configure.ac (LIBGOMP_GNU_SYMBOL_VERSIONING): New AC_DEFINE.\n\tSubstitute also OMP_*LOCK_25*.\n\t* configure: Regenerated.\n\t* config.h.in: Regenerated.\n\t* Makefile.am (libgomp_la_SOURCES): Add loop_ull.c, iter_ull.c,\n\tptrlock.c and task.c.\n\t* Makefile.in: Regenerated.\n\t* testsuite/Makefile.in: Regenerated.\n\t* task.c: New file.\n\t* loop_ull.c: New file.\n\t* iter_ull.c: New file.\n\t* libgomp.h: Include ptrlock.h.\n\t(enum gomp_task_kind): New type.\n\t(struct gomp_team): Add task_lock, task_queue, task_count,\n\ttask_running_count, single_count fields.  Add\n\twork_share_list_free_lock ifndef HAVE_SYNC_BUILTINS.\n\tRemove work_share_lock, generation_mask,\n\toldest_live_gen, num_live_gen and init_work_shares fields, add\n\twork work_share_list_alloc, work_share_list_free and work_share_chunk\n\tfields.  Change work_shares from pointer to pointers into an array.\n\tChange ordered_release field into gomp_sem_t ** from flexible array\n\tmember.  Add implicit_task and initial_work_shares fields.\n\tMove close to the end of the struct.\n\t(struct gomp_team_state): Add single_count, last_work_share,\n\tactive_level and level fields, remove work_share_generation.\n\t(gomp_barrier_handle_tasks): New prototype.\n\t(gomp_finish_task): New inline function.\n\t(struct gomp_work_share): Move chunk_size, end, incr into\n\ttransparent union/struct, add chunk_size_ull, end_ll, incr_ll and\n\tnext_ll fields.  Reshuffle fields.  Add next_alloc,\n\tnext_ws, next_free and inline_ordered_team_ids fields, change\n\tordered_team_ids into pointer from flexible array member.\n\tAdd mode field.  Put lock and next into a different cache line\n\tfrom most of the write-once fields.\n\t(gomp_iter_ull_static_next, gomp_iter_ull_dynamic_next_locked,\n\tgomp_iter_ull_guided_next_locked, gomp_iter_ull_dynamic_next,\n\tgomp_iter_ull_guided_next): New prototypes.\n\t(gomp_new_icv): New prototype.\n\t(struct gomp_thread): Add thread_pool and task fields.\n\t(struct gomp_thread_pool): New type.\n\t(gomp_new_team): New prototype.\n\t(gomp_team_start): Change type of last argument.\n\t(gomp_new_work_share): Removed.\n\t(gomp_init_work_share, gomp_fini_work_share): New prototypes.\n\t(gomp_work_share_init_done): New static inline.\n\t(gomp_throttled_spin_count_var, gomp_available_cpus,\n\tgomp_managed_threads): New extern decls.\n\t(gomp_init_task): New prototype.\n\t(gomp_spin_count_var): New extern var decl.\n\t(LIBGOMP_GNU_SYMBOL_VERSIONING): Undef if no visibility\n\tor no alias support, or if not PIC.\n\t(gomp_init_lock_30, gomp_destroy_lock_30, gomp_set_lock_30,\n\tgomp_unset_lock_30, gomp_test_lock_30, gomp_init_nest_lock_30,\n\tgomp_destroy_nest_lock_30, gomp_set_nest_lock_30,\n\tgomp_unset_nest_lock_30, gomp_test_nest_lock_30, gomp_init_lock_25,\n\tgomp_destroy_lock_25, gomp_set_lock_25, gomp_unset_lock_25,\n\tgomp_test_lock_25, gomp_init_nest_lock_25, gomp_destroy_nest_lock_25,\n\tgomp_set_nest_lock_25, gomp_unset_nest_lock_25,\n\tgomp_test_nest_lock_25): New prototypes.\n\t(omp_lock_symver, strong_alias): Define.\n\t(gomp_remaining_threads_count, gomp_remaining_threads_lock): New\n\tdecls.\n\t(gomp_end_task): New.\n\t(struct gomp_task_icv, gomp_global_icv): New.\n\t(gomp_thread_limit_var, gomp_max_active_levels_var): New.\n\t(struct gomp_task): New.\n\t(gomp_nthreads_var, gomp_dyn_var, gomp_nest_var,\n\tgomp_run_sched_var, gomp_run_sched_chunk): Remove.\n\t(gomp_icv): New.\n\t(gomp_schedule_type): Reorder enum to match\n\tomp_sched_t.\n\t* team.c (struct gomp_thread_start_data): Add thread_pool and task\n\tfields.\n\t(gomp_thread_start): Add gomp_team_barrier_wait call.\n\tFor non-nested case remove clearing of docked thread thr fields.\n\tUse pool fields instead of global gomp_* variables.  Use\n\tgomp_barrier_wait_last when needed.  Initialize ts.active_level.\n\tCreate tasks for each member thread.\n\t(free_team): Only destroy team barrier, task_lock here and free it.\n\t(gomp_free_thread): Free last_team if non-NULL.\n\t(gomp_team_end): Call gomp_team_barrier_wait instead of\n\tgomp_barrier_wait.  For nested case call one extra\n\tgomp_barrier_wait.  Move here some destruction from free_team.\n\tCall free_team on pool->last_team if any, rather than freeing\n\tcurrent team.  Destroy work_share_list_free_lock ifndef\n\tHAVE_SYNC_BUILTINS.\n\t(gomp_new_icv): New function.\n\t(gomp_threads, gomp_threads_size, gomp_threads_used,\n\tgomp_threads_dock): Removed.\n\t(gomp_thread_destructor): New variable.\n\t(gomp_new_thread_pool, gomp_free_pool_helper, gomp_free_thread): New\n\tfunctions.\n\t(gomp_team_start): Create new pool if current thread doesn't have\n\tone.  Use pool fields instead of global gomp_* variables. \n\tInitialize thread_pool field for new threads.  Clear single_count.\n\tChange last argument from ws to team, don't create\n\tnew team, set ts.work_share to &team->work_shares[0] and clear\n\tts.last_work_share.  Don't clear ts.work_share_generation.\n\tIf number of threads changed, adjust atomically gomp_managed_threads.\n\tUse gomp_init_task instead of gomp_new_task,\n\tset thr->task to the corresponding implicit_task array entry.\n\tCreate tasks for each member thread.  Initialize ts.level.\n\t(initialize_team): Call pthread_key_create on\n\tgomp_thread_destructor.\n\t(team_destructor): New function.\n\t(new_team): Removed.\n\t(gomp_new_team): New function.\n\t(free_team): Free gomp_work_share blocks chained through next_alloc,\n\tinstead of freeing work_shares and destroying work_share_lock.\n\t(gomp_team_end): Call gomp_fini_work_share.  If number of threads\n\tchanged, adjust atomically gomp_managed_threads.  Use gomp_end_task.\n\t* barrier.c (GOMP_barrier): Call gomp_team_barrier_wait instead\n\tof gomp_barrier_wait.\n\t* single.c (GOMP_single_copy_start): Call gomp_team_barrier_wait\n\tinstead of gomp_barrier_wait.  Call gomp_work_share_init_done\n\tif gomp_work_share_start returned true.  Don't unlock ws->lock.\n\t(GOMP_single_copy_end): Call gomp_team_barrier_wait instead\n\tof gomp_barrier_wait.\n\t(GOMP_single_start): Rewritten if HAVE_SYNC_BUILTINS.  Call\n\tgomp_work_share_init_done if gomp_work_share_start returned true.\n\tDon't unlock ws->lock.\n\t* work.c: Include stddef.h.\n\t(free_work_share): Use work_share_list_free_lock instead\n\tof atomic chaining ifndef HAVE_SYNC_BUILTINS.  Add team argument.\n\tCall gomp_fini_work_share and then either free ws if orphaned, or\n\tput it into work_share_list_free list of the current team.\n\t(alloc_work_share, gomp_init_work_share, gomp_fini_work_share): New\n\tfunctions.\n\t(gomp_work_share_start, gomp_work_share_end,\n\tgomp_work_share_end_nowait): Rewritten.\n\t* omp_lib.f90.in Change some tabs to spaces to prevent warnings.\n\t(openmp_version): Set to 200805.\n\t(omp_sched_kind, omp_sched_static, omp_sched_dynamic,\n\tomp_sched_guided, omp_sched_auto): New parameters.\n\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n\tomp_set_max_active_levels, omp_get_max_active_levels,\n\tomp_get_level, omp_get_ancestor_thread_num, omp_get_team_size,\n\tomp_get_active_level): New interfaces.\n\t* omp_lib.h.in (openmp_version): Set to 200805.\n\t(omp_sched_kind, omp_sched_static, omp_sched_dynamic,\n\tomp_sched_guided, omp_sched_auto): New parameters.\n\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n\tomp_set_max_active_levels, omp_get_max_active_levels,\n\tomp_get_level, omp_get_ancestor_thread_num, omp_get_team_size,\n\tomp_get_active_level): New externals.\n\t* loop.c: Include limits.h.\n\t(GOMP_loop_runtime_next, GOMP_loop_ordered_runtime_next): Handle\n\tGFS_AUTO.\n\t(GOMP_loop_runtime_start, GOMP_loop_ordered_runtime_start):\n\tLikewise.  Use gomp_icv.\n\t(gomp_loop_static_start, gomp_loop_dynamic_start): Clear\n\tts.static_trip here.\n\t(gomp_loop_static_start, gomp_loop_ordered_static_start): Call\n\tgomp_work_share_init_done after gomp_loop_init.  Don't unlock ws->lock.\n\t(gomp_loop_dynamic_start, gomp_loop_guided_start): Call\n\tgomp_work_share_init_done after gomp_loop_init.  If HAVE_SYNC_BUILTINS,\n\tdon't unlock ws->lock, otherwise lock it.\n\t(gomp_loop_ordered_dynamic_start, gomp_loop_ordered_guided_start): Call\n\tgomp_work_share_init_done after gomp_loop_init.  Lock ws->lock.\n\t(gomp_parallel_loop_start): Call gomp_new_team instead of\n\tgomp_new_work_share.  Call gomp_loop_init on &team->work_shares[0].\n\tAdjust gomp_team_start caller.  Pass 0 as second argument to\n\tgomp_resolve_num_threads.\n\t(gomp_loop_init): For GFS_DYNAMIC, multiply ws->chunk_size by incr.\n\tIf adding ws->chunk_size nthreads + 1 times after end won't\n\toverflow, set ws->mode to 1.\n\t* libgomp_g.h (GOMP_loop_ull_static_start, GOMP_loop_ull_dynamic_start,\n\tGOMP_loop_ull_guided_start, GOMP_loop_ull_runtime_start,\n\tGOMP_loop_ull_ordered_static_start,\n\tGOMP_loop_ull_ordered_dynamic_start,\n\tGOMP_loop_ull_ordered_guided_start,\n\tGOMP_loop_ull_ordered_runtime_start, GOMP_loop_ull_static_next,\n\tGOMP_loop_ull_dynamic_next, GOMP_loop_ull_guided_next,\n\tGOMP_loop_ull_runtime_next, GOMP_loop_ull_ordered_static_next,\n\tGOMP_loop_ull_ordered_dynamic_next, GOMP_loop_ull_ordered_guided_next,\n\tGOMP_loop_ull_ordered_runtime_next, GOMP_task, GOMP_taskwait): New\n\tprototypes.\n\t* libgomp.map: Export lock routines also @@OMP_2.0.\n\t(GOMP_loop_ordered_dynamic_first,\n\tGOMP_loop_ordered_guided_first, GOMP_loop_ordered_runtime_first,\n\tGOMP_loop_ordered_static_first): Remove.\n\t(GOMP_loop_ull_dynamic_next, GOMP_loop_ull_dynamic_start,\n\tGOMP_loop_ull_guided_next, GOMP_loop_ull_guided_start,\n\tGOMP_loop_ull_ordered_dynamic_next,\n\tGOMP_loop_ull_ordered_dynamic_start,\n\tGOMP_loop_ull_ordered_guided_next,\n\tGOMP_loop_ull_ordered_guided_start,\n\tGOMP_loop_ull_ordered_runtime_next,\n\tGOMP_loop_ull_ordered_runtime_start,\n\tGOMP_loop_ull_ordered_static_next,\n\tGOMP_loop_ull_ordered_static_start,\n\tGOMP_loop_ull_runtime_next, GOMP_loop_ull_runtime_start,\n\tGOMP_loop_ull_static_next, GOMP_loop_ull_static_start,\n\tGOMP_task, GOMP_taskwait): Export @@GOMP_2.0.\n\t(omp_set_schedule, omp_get_schedule,\n\tomp_get_thread_limit, omp_set_max_active_levels,\n\tomp_get_max_active_levels, omp_get_level,\n\tomp_get_ancestor_thread_num, omp_get_team_size, omp_get_active_level,\n\tomp_set_schedule_, omp_set_schedule_8_,\n\tomp_get_schedule_, omp_get_schedule_8_, omp_get_thread_limit_,\n\tomp_set_max_active_levels_, omp_set_max_active_levels_8_,\n\tomp_get_max_active_levels_, omp_get_level_,\n\tomp_get_ancestor_thread_num_, omp_get_ancestor_thread_num_8_,\n\tomp_get_team_size_, omp_get_team_size_8_, omp_get_active_level_):\n\tNew exports @@OMP_3.0.\n\t* omp.h.in (omp_sched_t): New type.\n\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n\tomp_set_max_active_levels, omp_get_max_active_levels,\n\tomp_get_level, omp_get_ancestor_thread_num, omp_get_team_size,\n\tomp_get_active_level): New prototypes.\n\t* env.c (gomp_spin_count_var, gomp_throttled_spin_count_var,\n\tgomp_available_cpus, gomp_managed_threads, gomp_max_active_levels_var,\n\tgomp_thread_limit_var, gomp_remaining_threads_count,\n\tgomp_remaining_threads_lock): New variables.\n\t(parse_spincount): New function.\n\t(initialize_env): Call gomp_init_num_threads unconditionally.\n\tInitialize gomp_available_cpus.  Call parse_spincount,\n\tinitialize gomp_{,throttled_}spin_count_var\n\tdepending on presence and value of OMP_WAIT_POLICY and\n\tGOMP_SPINCOUNT env vars.  Handle GOMP_BLOCKTIME env var.\n\tHandle OMP_WAIT_POLICY, OMP_MAX_ACTIVE_LEVELS,\n\tOMP_THREAD_LIMIT, OMP_STACKSIZE env vars.  Handle unit specification\n\tfor GOMP_STACKSIZE.  Initialize gomp_remaining_threads_count and\n\tgomp_remaining_threads_lock if needed.  Use gomp_global_icv.\n\t(gomp_nthreads_var, gomp_dyn_var, gomp_nest_var,\n\tgomp_run_sched_var, gomp_run_sched_chunk): Remove.\n\t(gomp_global_icv): New.\n\t(parse_schedule): Use it.  Parse \"auto\".\n\t(omp_set_num_threads): Use gomp_icv.\n\t(omp_set_dynamic, omp_get_dynamic, omp_set_nested, omp_get_nested):\n\tLikewise.\n\t(omp_get_max_threads): Move from parallel.c.\n\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n\tomp_set_max_active_levels, omp_get_max_active_levels): New functions,\n\tadd ialias.\n\t(parse_stacksize, parse_wait_policy): New functions.\n\t* fortran.c: Rewrite lock wrappers, if symbol versioning provide\n\tboth wrappers for compatibility and new locks.\n\t(omp_set_schedule, omp_get_schedule,\n\tomp_get_thread_limit, omp_set_max_active_levels,\n\tomp_get_max_active_levels, omp_get_level,\n\tomp_get_ancestor_thread_num, omp_get_team_size,\n\tomp_get_active_level): New ialias_redirect.\n\t(omp_set_schedule_, omp_set_schedule_8_,\n\tomp_get_schedule_, omp_get_schedule_8_, omp_get_thread_limit_,\n\tomp_set_max_active_levels_, omp_set_max_active_levels_8_,\n\tomp_get_max_active_levels_, omp_get_level_,\n\tomp_get_ancestor_thread_num_, omp_get_ancestor_thread_num_8_,\n\tomp_get_team_size_, omp_get_team_size_8_, omp_get_active_level_):\n\tNew functions.\n\t* parallel.c: Include limits.h.\n\t(gomp_resolve_num_threads): Add count argument.  Rewritten.\n\t(GOMP_parallel_start): Call gomp_new_team and pass that as last\n\targument to gomp_team_start.  Pass 0 as second argument to\n\tgomp_resolve_num_threads.\n\t(GOMP_parallel_end): Decrease gomp_remaining_threads_count\n\tif gomp_thread_limit_var != ULONG_MAX.\n\t(omp_in_parallel): Implement using ts.active_level.\n\t(omp_get_max_threads): Move to env.c.\n\t(omp_get_level, omp_get_ancestor_thread_num,\n\tomp_get_team_size, omp_get_active_level): New functions,\n\tadd ialias.\n\t* sections.c (GOMP_sections_start): Call gomp_work_share_init_done\n\tafter gomp_sections_init.  If HAVE_SYNC_BUILTINS, call\n\tgomp_iter_dynamic_next instead of the _locked variant and don't take\n\tlock around it, otherwise acquire it before calling\n\tgomp_iter_dynamic_next_locked.\n\t(GOMP_sections_next): If HAVE_SYNC_BUILTINS, call\n\tgomp_iter_dynamic_next instead of the _locked variant and don't take\n\tlock around it.\n\t(GOMP_parallel_sections_start): Call gomp_new_team instead of\n\tgomp_new_work_share.  Call gomp_sections_init on &team->work_shares[0].\n\tAdjust gomp_team_start caller.  Pass count as second argument to\n\tgomp_resolve_num_threads, don't adjust num_threads after the call.\n\tUse gomp_icv.\n\t* iter.c (gomp_iter_dynamic_next_locked): Don't multiply\n\tws->chunk_size by incr.\n\t(gomp_iter_dynamic_next): Likewise.  If ws->mode, use more efficient\n\tcode.\n\t* libgomp_f.h.in (omp_lock_25_arg_t, omp_nest_lock_25_arg_t): New\n\ttypes.\n\t(omp_lock_25_arg, omp_nest_lock_25_arg): New macros.\n\t(omp_check_defines): Check even the compat defines.\n\t* config/linux/ptrlock.c: New file.\n\t* config/linux/ptrlock.h: New file.\n\t* config/linux/wait.h: New file.\n\t* config/posix/ptrlock.c: New file.\n\t* config/posix/ptrlock.h: New file.\n\t* config/linux/bar.h (gomp_team_barrier_wait,\n\tgomp_team_barrier_wait_end, gomp_team_barrier_wake): New prototypes.\n\t(gomp_team_barrier_set_task_pending,\n\tgomp_team_barrier_clear_task_pending,\n\tgomp_team_barrier_set_waiting_for_tasks,\n\tgomp_team_barrier_waiting_for_tasks,\n\tgomp_team_barrier_done): New inlines.\n\t(gomp_barrier_t): Rewritten.\n\t(gomp_barrier_state_t): New typedef.\n\t(gomp_barrier_init, gomp_barrier_reinit, gomp_barrier_destroy,\n\tgomp_barrier_wait_start): Rewritten.\n\t(gomp_barrier_wait_end): Change second argument to\n\tgomp_barrier_state_t.\n\t(gomp_barrier_last_thread, gomp_barrier_wait_last): New static\n\tinlines.\n\t* config/linux/bar.c: Include wait.h instead of libgomp.h and\n\tfutex.h.\n\t(gomp_barrier_wait_end): Rewritten.\n\t(gomp_team_barrier_wait, gomp_team_barrier_wait_end,\n\tgomp_team_barrier_wake, gomp_barrier_wait_last): New functions.\n\t* config/posix/bar.h (gomp_barrier_t): Add generation field.\n\t(gomp_barrier_state_t): New typedef.\n\t(gomp_team_barrier_wait,\n\tgomp_team_barrier_wait_end, gomp_team_barrier_wake): New prototypes.\n\t(gomp_barrier_wait_start): Or all but low 2 bits from generation\n\tinto the return value.  Return gomp_barrier_state_t.\n\t(gomp_team_barrier_set_task_pending,\n\tgomp_team_barrier_clear_task_pending,\n\tgomp_team_barrier_set_waiting_for_tasks,\n\tgomp_team_barrier_waiting_for_tasks,\n\tgomp_team_barrier_done): New inlines.\n\t(gomp_barrier_wait_end): Change second argument to\n\tgomp_barrier_state_t.\n\t(gomp_barrier_last_thread, gomp_barrier_wait_last): New static\n\tinlines.\n\t* config/posix/bar.c (gomp_barrier_init): Clear generation field.\n\t(gomp_barrier_wait_end): Change second argument to\n\tgomp_barrier_state_t. \n\t(gomp_team_barrier_wait, gomp_team_barrier_wait_end,\n\tgomp_team_barrier_wake): New functions.\n\t* config/linux/mutex.c: Include wait.h instead of libgomp.h and\n\tfutex.h.\n\t(gomp_futex_wake, gomp_futex_wait): New variables.\n\t(gomp_mutex_lock_slow): Call do_wait instead of futex_wait.\n\t* config/linux/lock.c: Rewrite to make locks task owned,\n\tfor backwards compatibility provide the old entrypoints\n\tif symbol versioning.  Include wait.h instead of libgomp.h and\n\tfutex.h.\n\t(gomp_set_nest_lock_25): Call do_wait instead of futex_wait.\n\t* config/posix95/lock.c: Rewrite to make locks task owned,\n\tfor backwards compatibility provide the old entrypoints\n\tif symbol versioning.\n\t* config/posix/lock.c: Rewrite to make locks task owned,\n\tfor backwards compatibility provide the old entrypoints\n\tif symbol versioning.\n\t* config/linux/proc.c (gomp_init_num_threads): Use gomp_global_icv.\n\t(get_num_procs, gomp_dynamic_max_threads): Use gomp_icv.\n\t* config/posix/proc.c, config/mingw32/proc.c: Similarly.\n\t* config/linux/powerpc/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n\t(sys_futex0): Return error code.\n\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n\t(cpu_relax, atomic_write_barrier): New static inlines.\n\t* config/linux/alpha/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n\t(cpu_relax, atomic_write_barrier): New static inlines.\n\t* config/linux/x86/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n\t(sys_futex0): Return error code.\n\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n\t(cpu_relax, atomic_write_barrier): New static inlines.\n\t* config/linux/s390/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n\t(sys_futex0): Return error code.\n\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n\t(cpu_relax, atomic_write_barrier): New static inlines.\n\t* config/linux/ia64/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n\t(sys_futex0): Return error code.\n\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n\t(cpu_relax, atomic_write_barrier): New static inlines.\n\t* config/linux/sparc/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n\t(sys_futex0): Return error code.\n\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n\t(cpu_relax, atomic_write_barrier): New static inlines.\n\t* config/linux/sem.c: Include wait.h instead of libgomp.h and\n\tfutex.h.\n\t(gomp_sem_wait_slow): Call do_wait instead of futex_wait.\n\t* config/linux/affinity.c: Assume HAVE_SYNC_BUILTINS.\n\t* config/linux/omp-lock.h (omp_lock_25_t, omp_nest_lock_25_t): New\n\ttypes.\n\t(omp_nest_lock_t): Change owner into void *, add lock field.\n\t* config/posix95/omp-lock.h: Include semaphore.h.\n\t(omp_lock_25_t, omp_nest_lock_25_t): New types.\n\t(omp_lock_t): Use sem_t instead of mutex if semaphores\n\taren't broken.\n\t(omp_nest_lock_t): Likewise.  Change owner to void *.\n\t* config/posix/omp-lock.h: Include semaphore.h.\n\t(omp_lock_25_t, omp_nest_lock_25_t): New types.\n\t(omp_lock_t): Use sem_t instead of mutex if semaphores\n\taren't broken.\n\t(omp_nest_lock_t): Likewise.  Add owner field.\n\n\t* testsuite/libgomp.c/collapse-1.c: New test.\n\t* testsuite/libgomp.c/collapse-2.c: New test.\n\t* testsuite/libgomp.c/collapse-3.c: New test.\n\t* testsuite/libgomp.c/icv-1.c: New test.\n\t* testsuite/libgomp.c/icv-2.c: New test.\n\t* testsuite/libgomp.c/lib-2.c: New test.\n\t* testsuite/libgomp.c/lock-1.c: New test.\n\t* testsuite/libgomp.c/lock-2.c: New test.\n\t* testsuite/libgomp.c/lock-3.c: New test.\n\t* testsuite/libgomp.c/loop-4.c: New test.\n\t* testsuite/libgomp.c/loop-5.c: New test.\n\t* testsuite/libgomp.c/loop-6.c: New test.\n\t* testsuite/libgomp.c/loop-7.c: New test.\n\t* testsuite/libgomp.c/loop-8.c: New test.\n\t* testsuite/libgomp.c/loop-9.c: New test.\n\t* testsuite/libgomp.c/nested-3.c: New test.\n\t* testsuite/libgomp.c/nestedfn-6.c: New test.\n\t* testsuite/libgomp.c/sort-1.c: New test.\n\t* testsuite/libgomp.c/task-1.c: New test.\n\t* testsuite/libgomp.c/task-2.c: New test.\n\t* testsuite/libgomp.c/task-3.c: New test.\n\t* testsuite/libgomp.c/task-4.c: New test.\n\t* testsuite/libgomp.c++/c++.exp: Add libstdc++-v3 build includes\n\tto C++ testsuite default compiler options.\n\t* testsuite/libgomp.c++/collapse-1.C: New test.\n\t* testsuite/libgomp.c++/collapse-2.C: New test.\n\t* testsuite/libgomp.c++/ctor-10.C: New test.\n\t* testsuite/libgomp.c++/for-1.C: New test.\n\t* testsuite/libgomp.c++/for-2.C: New test.\n\t* testsuite/libgomp.c++/for-3.C: New test.\n\t* testsuite/libgomp.c++/for-4.C: New test.\n\t* testsuite/libgomp.c++/for-5.C: New test.\n\t* testsuite/libgomp.c++/loop-8.C: New test.\n\t* testsuite/libgomp.c++/loop-9.C: New test.\n\t* testsuite/libgomp.c++/loop-10.C: New test.\n\t* testsuite/libgomp.c++/task-1.C: New test.\n\t* testsuite/libgomp.c++/task-2.C: New test.\n\t* testsuite/libgomp.c++/task-3.C: New test.\n\t* testsuite/libgomp.c++/task-4.C: New test.\n\t* testsuite/libgomp.c++/task-5.C: New test.\n\t* testsuite/libgomp.c++/task-6.C: New test.\n\t* testsuite/libgomp.fortran/allocatable1.f90: New test.\n\t* testsuite/libgomp.fortran/allocatable2.f90: New test.\n\t* testsuite/libgomp.fortran/allocatable3.f90: New test.\n\t* testsuite/libgomp.fortran/allocatable4.f90: New test.\n\t* testsuite/libgomp.fortran/collapse1.f90: New test.\n\t* testsuite/libgomp.fortran/collapse2.f90: New test.\n\t* testsuite/libgomp.fortran/collapse3.f90: New test.\n\t* testsuite/libgomp.fortran/collapse4.f90: New test.\n\t* testsuite/libgomp.fortran/lastprivate1.f90: New test.\n\t* testsuite/libgomp.fortran/lastprivate2.f90: New test.\n\t* testsuite/libgomp.fortran/lib4.f90: New test.\n\t* testsuite/libgomp.fortran/lock-1.f90: New test.\n\t* testsuite/libgomp.fortran/lock-2.f90: New test.\n\t* testsuite/libgomp.fortran/nested1.f90: New test.\n\t* testsuite/libgomp.fortran/nestedfn4.f90: New test.\n\t* testsuite/libgomp.fortran/strassen.f90: New test.\n\t* testsuite/libgomp.fortran/tabs1.f90: New test.\n\t* testsuite/libgomp.fortran/tabs2.f: New test.\n\t* testsuite/libgomp.fortran/task1.f90: New test.\n\t* testsuite/libgomp.fortran/task2.f90: New test.\n\t* testsuite/libgomp.fortran/vla4.f90: Add dg-warning.\n\t* testsuite/libgomp.fortran/vla5.f90: Likewise.\n\t* testsuite/libgomp.c/pr26943-2.c: Likewise.\n\t* testsuite/libgomp.c/pr26943-3.c: Likewise.\n\t* testsuite/libgomp.c/pr26943-4.c: Likewise.\n\nCo-Authored-By: Jakob Blomer <jakob.blomer@ira.uka.de>\nCo-Authored-By: Richard Henderson <rth@redhat.com>\nCo-Authored-By: Ulrich Drepper <drepper@redhat.com>\n\nFrom-SVN: r136433", "tree": {"sha": "5d5537ea17855b77cca7b9c90a262e584c441592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d5537ea17855b77cca7b9c90a262e584c441592"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a68ab3517348178c71d9adcdefbc81de2d8c7390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a68ab3517348178c71d9adcdefbc81de2d8c7390", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a68ab3517348178c71d9adcdefbc81de2d8c7390", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a68ab3517348178c71d9adcdefbc81de2d8c7390/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4fe74e01a64d983bd068284c2aedfe146514256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fe74e01a64d983bd068284c2aedfe146514256", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4fe74e01a64d983bd068284c2aedfe146514256"}], "stats": {"total": 20144, "additions": 18359, "deletions": 1785}, "files": [{"sha": "ce1eae639916ae579f3e8b771b966e4194dc1679", "filename": "gcc/ChangeLog", "status": "modified", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,3 +1,265 @@\n+2008-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Change _OPENMP value to\n+\t200805.\n+\t* langhooks.h (struct lang_hooks_for_decls): Add omp_finish_clause.\n+\tAdd omp_private_outer_ref hook, add another argument to\n+\tomp_clause_default_ctor hook.\n+\t* langhooks-def.h (LANG_HOOKS_OMP_FINISH_CLAUSE): Define.\n+\t(LANG_HOOKS_OMP_PRIVATE_OUTER_REF): Define.\n+\t(LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR): Change to\n+\thook_tree_tree_tree_tree_null.\n+\t(LANG_HOOKS_DECLS): Add LANG_HOOKS_OMP_FINISH_CLAUSE and\n+\tLANG_HOOKS_OMP_PRIVATE_OUTER_REF.\n+\t* hooks.c (hook_tree_tree_tree_tree_null): New function.\n+\t* hooks.h (hook_tree_tree_tree_tree_null): New prototype.\n+\t* tree.def (OMP_TASK): New tree code.\n+\t* tree.h (OMP_TASK_COPYFN, OMP_TASK_ARG_SIZE, OMP_TASK_ARG_ALIGN,\n+\tOMP_CLAUSE_PRIVATE_OUTER_REF, OMP_CLAUSE_LASTPRIVATE_STMT,\n+\tOMP_CLAUSE_COLLAPSE_ITERVAR, OMP_CLAUSE_COLLAPSE_COUNT,\n+\tOMP_TASKREG_CHECK, OMP_TASKREG_BODY, OMP_TASKREG_CLAUSES,\n+\tOMP_TASKREG_FN, OMP_TASKREG_DATA_ARG, OMP_TASK_BODY,\n+\tOMP_TASK_CLAUSES, OMP_TASK_FN, OMP_TASK_DATA_ARG,\n+\tOMP_CLAUSE_COLLAPSE_EXPR): Define.\n+\t(enum omp_clause_default_kind): Add OMP_CLAUSE_DEFAULT_FIRSTPRIVATE.\n+\t(OMP_DIRECTIVE_P): Add OMP_TASK.\n+\t(OMP_CLAUSE_COLLAPSE, OMP_CLAUSE_UNTIED): New clause codes.\n+\t(OMP_CLAUSE_SCHEDULE_AUTO): New schedule kind.\n+\t* tree.c (omp_clause_code_name): Add OMP_CLAUSE_COLLAPSE\n+\tand OMP_CLAUSE_UNTIED entries.\n+\t(omp_clause_num_ops): Likewise.  Increase OMP_CLAUSE_LASTPRIVATE\n+\tnum_ops to 2.\n+\t(walk_tree_1): Handle OMP_CLAUSE_COLLAPSE and OMP_CLAUSE_UNTIED.\n+\tWalk OMP_CLAUSE_LASTPRIVATE_STMT.\n+\t* tree-pretty-print.c (dump_omp_clause): Handle\n+\tOMP_CLAUSE_SCHEDULE_AUTO, OMP_CLAUSE_UNTIED, OMP_CLAUSE_COLLAPSE,\n+\tOMP_CLAUSE_DEFAULT_FIRSTPRIVATE.\n+\t(dump_generic_node): Handle OMP_TASK and collapsed OMP_FOR loops.\n+\t* c-omp.c (c_finish_omp_for): Allow pointer iterators.  Remove\n+\twarning about unsigned iterators.  Change decl/init/cond/incr\n+\targuments to TREE_VECs, check arguments for all collapsed loops.\n+\t(c_finish_omp_taskwait): New function.\n+\t(c_split_parallel_clauses): Put OMP_CLAUSE_COLLAPSE clause to\n+\tws_clauses.\n+\t* c-parser.c (c_parser_omp_for_loop): Parse collapsed loops.  Call\n+\tdefault_function_array_conversion on init.  Add par_clauses argument.\n+\tIf decl is present in parallel's lastprivate clause, change it to\n+\tshared and add lastprivate clause for decl to OMP_FOR_CLAUSES.\n+\tAdd clauses argument, on success set OMP_FOR_CLAUSES to it.  Look up\n+\tcollapse count in clauses.\n+\t(c_parser_omp_for, c_parser_omp_parallel): Adjust\n+\tc_parser_omp_for_loop callers.\n+\t(OMP_FOR_CLAUSE_MASK): Add 1 << PRAGMA_OMP_CLAUSE_COLLAPSE.\n+\t(c_parser_pragma): Handle PRAGMA_OMP_TASKWAIT.\n+\t(c_parser_omp_clause_name): Handle collapse and untied clauses.\n+\t(c_parser_omp_clause_collapse, c_parser_omp_clause_untied): New\n+\tfunctions.\n+\t(c_parser_omp_clause_schedule): Handle schedule(auto).\n+\tInclude correct location in the error message.\n+\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_COLLAPSE\n+\tand PRAGMA_OMP_CLAUSE_UNTIED.\n+\t(OMP_TASK_CLAUSE_MASK): Define.\n+\t(c_parser_omp_task, c_parser_omp_taskwait): New functions.\n+\t(c_parser_omp_construct): Handle PRAGMA_OMP_TASK.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Handle OMP_CLAUSE_LASTPRIVATE_STMT,\n+\tOMP_CLAUSE_REDUCTION_INIT, OMP_CLAUSE_REDUCTION_MERGE,\n+\tOMP_CLAUSE_COLLAPSE and OMP_CLAUSE_UNTIED.\n+\tDon't handle TREE_STATIC or DECL_EXTERNAL VAR_DECLs in\n+\tOMP_CLAUSE_DECL.\n+\t(conver_nonlocal_reference, convert_local_reference,\n+\tconvert_call_expr): Handle OMP_TASK the same as OMP_PARALLEL.  Use\n+\tOMP_TASKREG_* macros rather than OMP_PARALLEL_*.\n+\t(walk_omp_for): Adjust for OMP_FOR_{INIT,COND,INCR} changes.\n+\t* tree-gimple.c (is_gimple_stmt): Handle OMP_TASK.\n+\t* c-tree.h (c_begin_omp_task, c_finish_omp_task): New prototypes.\n+\t* c-pragma.h (PRAGMA_OMP_TASK, PRAGMA_OMP_TASKWAIT): New.\n+\t(PRAGMA_OMP_CLAUSE_COLLAPSE, PRAGMA_OMP_CLAUSE_UNTIED): New.\n+\t* c-typeck.c (c_begin_omp_task, c_finish_omp_task): New functions.\n+\t(c_finish_omp_clauses): Handle OMP_CLAUSE_COLLAPSE and\n+\tOMP_CLAUSE_UNTIED.\n+\t* c-pragma.c (init_pragma): Init omp task and omp taskwait pragmas.\n+\t* c-common.h (c_finish_omp_taskwait): New prototype.\n+\t* gimple-low.c (lower_stmt): Handle OMP_TASK.\n+\t* tree-parloops.c (create_parallel_loop): Create 1 entry\n+\tvectors for OMP_FOR_{INIT,COND,INCR}.\n+\t* tree-cfg.c (remove_useless_stmts_1): Handle OMP_* containers.\n+\t(make_edges): Handle OMP_TASK.\n+\t* tree-ssa-operands.c (get_expr_operands): Handle collapsed OMP_FOR\n+\tloops, adjust for OMP_FOR_{INIT,COND,INCR} changes.\n+\t* tree-inline.c (estimate_num_insns_1): Handle OMP_TASK.\n+\t* builtin-types.def (BT_PTR_ULONGLONG, BT_PTR_FN_VOID_PTR_PTR,\n+\tBT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR,\n+\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): New.\n+\t* omp-builtins.def (BUILT_IN_GOMP_TASK, BUILT_IN_GOMP_TASKWAIT,\n+\tBUILT_IN_GOMP_LOOP_ULL_STATIC_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_GUIDED_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_START,\n+\tBUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_DYNAMIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_GUIDED_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_RUNTIME_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_NEXT,\n+\tBUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_NEXT): New builtins.\n+\t* gimplify.c (gimplify_omp_for): Allow pointer type for decl,\n+\thandle POINTER_PLUS_EXPR.  If loop counter has been replaced and\n+\toriginal iterator is present in lastprivate clause or if\n+\tcollapse > 1, set OMP_CLAUSE_LASTPRIVATE_STMT.  Handle collapsed\n+\tOMP_FOR loops, adjust for OMP_FOR_{INIT,COND,INCR} changes.\n+\t(gimplify_expr): Handle OMP_SECTIONS_SWITCH and OMP_TASK.\n+\t(enum gimplify_omp_var_data): Add GOVD_PRIVATE_OUTER_REF.\n+\t(omp_notice_variable): Set GOVD_PRIVATE_OUTER_REF if needed,\n+\tif it is set, lookup var in outer contexts too.  Handle\n+\tOMP_CLAUSE_DEFAULT_FIRSTPRIVATE.  Handle vars that are supposed\n+\tto be implicitly determined firstprivate for task regions.\n+\t(gimplify_scan_omp_clauses): Set GOVD_PRIVATE_OUTER_REF if needed,\n+\tif it is set, lookup var in outer contexts too.  Set\n+\tOMP_CLAUSE_PRIVATE_OUTER_REF if GOVD_PRIVATE_OUTER_REF is set.\n+\tHandle OMP_CLAUSE_LASTPRIVATE_STMT, OMP_CLAUSE_COLLAPSE and\n+\tOMP_CLAUSE_UNTIED.  Take region_type as last argument\n+\tinstead of in_parallel and in_combined_parallel.\n+\t(gimplify_omp_parallel, gimplify_omp_for, gimplify_omp_workshare):\n+\tAdjust callers.\n+\t(gimplify_adjust_omp_clauses_1): Set OMP_CLAUSE_PRIVATE_OUTER_REF if\n+\tGOVD_PRIVATE_OUTER_REF is set.  Call omp_finish_clause\n+\tlanghook.\n+\t(new_omp_context): Set default_kind to\n+\tOMP_CLAUSE_DEFAULT_UNSPECIFIED for OMP_TASK regions.\n+\t(omp_region_type): New enum.\n+\t(struct gimplify_omp_ctx): Remove is_parallel and is_combined_parallel\n+\tfields, add region_type.\n+\t(new_omp_context): Take region_type as argument instead of is_parallel\n+\tand is_combined_parallel.\n+\t(gimple_add_tmp_var, omp_firstprivatize_variable, omp_notice_variable,\n+\tomp_is_private, omp_check_private): Adjust ctx->is_parallel and\n+\tctx->is_combined_parallel checks.\n+\t(gimplify_omp_task): New function.\n+\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_COLLAPSE and\n+\tOMP_CLAUSE_UNTIED.\n+\t* omp-low.c (extract_omp_for_data): Use schedule(static)\n+\tfor schedule(auto).  Handle pointer and unsigned iterators.\n+\tCompute fd->iter_type.  Handle POINTER_PLUS_EXPR increments.\n+\tAdd loops argument.  Extract data for collapsed OMP_FOR loops.\n+\t(expand_parallel_call): Assert sched_kind isn't auto,\n+\tmap runtime schedule to index 3.\n+\t(struct omp_for_data_loop): New type.\n+\t(struct omp_for_data): Remove v, n1, n2, step, cond_code fields.\n+\tAdd loop, loops, collapse and iter_type fields.\n+\t(workshare_safe_to_combine_p): Disallow combined for if\n+\titer_type is unsigned long long.  Don't combine collapse > 1 loops\n+\tunless all bounds and steps are constant.  Adjust extract_omp_for_data\n+\tcaller.\n+\t(expand_omp_for_generic): Handle pointer, unsigned and long long\n+\titerators.  Handle collapsed OMP_FOR loops.  Adjust\n+\tfor struct omp_for_data changes.  If libgomp function doesn't return\n+\tboolean_type_node, add comparison of the return value with 0.\n+\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk): Handle\n+\tpointer, unsigned and long long iterators.  Adjust for struct\n+\tomp_for_data changes.\n+\t(expand_omp_for): Assert sched_kind isn't auto, map runtime schedule\n+\tto index 3.  Use GOMP_loop_ull*{start,next} if iter_type is\n+\tunsigned long long.  Allocate loops array, pass it to\n+\textract_omp_for_data.  For collapse > 1 loops use always\n+\texpand_omp_for_generic.\n+\t(omp_context): Add sfield_map and srecord_type fields.\n+\t(is_task_ctx, lookup_sfield): New functions.\n+\t(use_pointer_for_field): Use is_task_ctx helper.  Change first\n+\targument's type from const_tree to tree.  Clarify comment.\n+\tIn OMP_TASK disallow copy-in/out sharing.\n+\t(build_sender_ref): Call lookup_sfield instead of lookup_field.\n+\t(install_var_field): Add mask argument.  Populate both record_type\n+\tand srecord_type if needed.\n+\t(delete_omp_context): Destroy sfield_map, clear DECL_ABSTRACT_ORIGIN\n+\tin srecord_type.\n+\t(fixup_child_record_type): Also remap FIELD_DECL's DECL_SIZE{,_UNIT}\n+\tand DECL_FIELD_OFFSET.\n+\t(scan_sharing_clauses): Adjust install_var_field callers.  For\n+\tfirstprivate clauses on explicit tasks allocate the var by value in\n+\trecord_type unconditionally, rather than by reference.\n+\tHandle OMP_CLAUSE_PRIVATE_OUTER_REF.  Scan OMP_CLAUSE_LASTPRIVATE_STMT.\n+\tUse is_taskreg_ctx instead of is_parallel_ctx.\n+\tHandle OMP_CLAUSE_COLLAPSE and OMP_CLAUSE_UNTIED.\n+\t(create_omp_child_function_name): Add task_copy argument, use\n+\t*_omp_cpyfn* names if it is true.\n+\t(create_omp_child_function): Add task_copy argument, if true create\n+\t*_omp_cpyfn* helper function.\n+\t(scan_omp_parallel): Adjust create_omp_child_function callers.\n+\tRename parallel_nesting_level to taskreg_nesting_level.\n+\t(scan_omp_task): New function.\n+\t(lower_rec_input_clauses): Don't run constructors for firstprivate\n+\texplicit task vars which are initialized by *_omp_cpyfn*.  \n+\tPass outer var ref to omp_clause_default_ctor hook if\n+\tOMP_CLAUSE_PRIVATE_OUTER_REF or OMP_CLAUSE_LASTPRIVATE.\n+\tReplace OMP_CLAUSE_REDUCTION_PLACEHOLDER decls in\n+\tOMP_CLAUSE_REDUCTION_INIT.\n+\t(lower_send_clauses): Clear DECL_ABSTRACT_ORIGIN if in task to\n+\tavoid duplicate setting of fields.  Handle\n+\tOMP_CLAUSE_PRIVATE_OUTER_REF.\n+\t(lower_send_shared_vars): Use srecord_type if non-NULL.  Don't\n+\tcopy-out if TREE_READONLY, only copy-in.\n+\t(expand_task_copyfn): New function.\n+\t(expand_task_call): New function.\n+\t(struct omp_taskcopy_context): New type.\n+\t(task_copyfn_copy_decl, task_copyfn_remap_type, create_task_copyfn):\n+\tNew functions.\n+\t(lower_omp_parallel): Rename to...\n+\t(lower_omp_taskreg): ... this.  Use OMP_TASKREG_* macros where needed.\n+\tCall create_task_copyfn if srecord_type is needed.  Adjust\n+\tsender_decl type.\n+\t(task_shared_vars): New variable.\n+\t(check_omp_nesting_restrictions): Warn if work-sharing,\n+\tbarrier, master or ordered region is closely nested inside OMP_TASK.\n+\tAdd warnings for barrier if closely nested inside of work-sharing,\n+\tordered, or master region.\n+\t(scan_omp_1): Call check_omp_nesting_restrictions even for\n+\tGOMP_barrier calls.  Rename parallel_nesting_level to\n+\ttaskreg_nesting_level.  Handle OMP_TASK.\n+\t(lower_lastprivate_clauses): Even if some lastprivate is found on a\n+\twork-sharing construct, continue looking for them on parent parallel\n+\tconstruct.\n+\t(lower_omp_for_lastprivate): Add lastprivate clauses\n+\tto the beginning of dlist rather than end.  Adjust for struct\n+\tomp_for_data changes.\n+\t(lower_omp_for): Add rec input clauses before OMP_FOR_PRE_BODY,\n+\tnot after it.  Handle collapsed OMP_FOR loops, adjust for\n+\tOMP_FOR_{INIT,COND,INCR} changes, adjust extract_omp_for_data\n+\tcaller.\n+\t(get_ws_args_for): Adjust extract_omp_for_data caller.\n+\t(scan_omp_for): Handle collapsed OMP_FOR\n+\tloops, adjust for OMP_FOR_{INIT,COND,INCR} changes.\n+\t(lower_omp_single_simple): If libgomp function doesn't return\n+\tboolean_type_node, add comparison of the return value with 0.\n+\t(diagnose_sb_1, diagnose_sb_2): Handle collapsed OMP_FOR\n+\tloops, adjust for OMP_FOR_{INIT,COND,INCR} changes.  Handle OMP_TASK.\n+\t(parallel_nesting_level): Rename to...\n+\t(taskreg_nesting_level): ... this.\n+\t(is_taskreg_ctx): New function.\n+\t(build_outer_var_ref, omp_copy_decl): Use is_taskreg_ctx instead\n+\tof is_parallel_ctx.\n+\t(execute_lower_omp): Rename parallel_nesting_level to\n+\ttaskreg_nesting_level.\n+\t(expand_omp_parallel): Rename to...\n+\t(expand_omp_taskreg): ... this.  Use OMP_TASKREG_* macros where needed.\n+\tCall omp_task_call for OMP_TASK regions.\n+\t(expand_omp): Adjust caller, handle OMP_TASK.\n+\t(lower_omp_1): Adjust lower_omp_taskreg caller, handle OMP_TASK.\n+\n+\t* bitmap.c (bitmap_default_obstack_depth): New variable.\n+\t(bitmap_obstack_initialize, bitmap_obstack_release): Do nothing\n+\tif argument is NULL and bitmap_default_obstack is already initialized.\n+\t* ipa-struct-reorg.c (do_reorg_1): Call bitmap_obstack_release\n+\tat the end.\n+\t* matrix-reorg.c (matrix_reorg): Likewise.\n+\n 2008-06-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*indirect_jump): Macroize using P"}, {"sha": "97e60de6b3c1f631ea5be24b6651c0ba8405a929", "filename": "gcc/bitmap.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -119,6 +119,7 @@ register_overhead (bitmap b, int amount)\n /* Global data */\n bitmap_element bitmap_zero_bits;  /* An element of all zero bits.  */\n bitmap_obstack bitmap_default_obstack;    /* The default bitmap obstack.  */\n+static int bitmap_default_obstack_depth;\n static GTY((deletable)) bitmap_element *bitmap_ggc_free; /* Freelist of\n \t\t\t\t\t\t\t    GC'd elements.  */\n \n@@ -302,7 +303,11 @@ void\n bitmap_obstack_initialize (bitmap_obstack *bit_obstack)\n {\n   if (!bit_obstack)\n-    bit_obstack = &bitmap_default_obstack;\n+    {\n+      if (bitmap_default_obstack_depth++)\n+\treturn;\n+      bit_obstack = &bitmap_default_obstack;\n+    }\n \n #if !defined(__GNUC__) || (__GNUC__ < 2)\n #define __alignof__(type) 0\n@@ -323,7 +328,14 @@ void\n bitmap_obstack_release (bitmap_obstack *bit_obstack)\n {\n   if (!bit_obstack)\n-    bit_obstack = &bitmap_default_obstack;\n+    {\n+      if (--bitmap_default_obstack_depth)\n+\t{\n+\t  gcc_assert (bitmap_default_obstack_depth > 0);\n+\t  return;\n+\t}\n+      bit_obstack = &bitmap_default_obstack;\n+    }\n \n   bit_obstack->elements = NULL;\n   bit_obstack->heads = NULL;"}, {"sha": "7d25e5aad6da83e5ad86eb0ef6e6335981614fd6", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+/* Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -121,6 +121,7 @@ DEF_PRIMITIVE_TYPE (BT_I16, builtin_type_for_size (BITS_PER_UNIT*16, 1))\n \n DEF_POINTER_TYPE (BT_PTR_CONST_STRING, BT_CONST_STRING)\n DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n+DEF_POINTER_TYPE (BT_PTR_ULONGLONG, BT_ULONGLONG)\n DEF_POINTER_TYPE (BT_PTR_PTR, BT_PTR)\n \n DEF_FUNCTION_TYPE_0 (BT_FN_VOID, BT_VOID)\n@@ -308,6 +309,10 @@ DEF_FUNCTION_TYPE_2 (BT_FN_I8_VPTR_I8, BT_I8, BT_VOLATILE_PTR, BT_I8)\n DEF_FUNCTION_TYPE_2 (BT_FN_I16_VPTR_I16, BT_I16, BT_VOLATILE_PTR, BT_I16)\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_LONGPTR_LONGPTR,\n \t\t     BT_BOOL, BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR,\n+\t\t     BT_BOOL, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n+\n+DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n DEF_FUNCTION_TYPE_3 (BT_FN_STRING_STRING_CONST_STRING_SIZE,\n \t\t     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE)\n@@ -410,10 +415,21 @@ DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n \t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n \t\t     BT_LONG, BT_LONG, BT_LONG, BT_LONG)\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t     BT_BOOL, BT_UINT)\n+DEF_FUNCTION_TYPE_7 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)"}, {"sha": "82c018b559f55cf644d0d93325fb1b972bf93748", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -995,6 +995,7 @@ extern tree c_finish_omp_ordered (tree);\n extern void c_finish_omp_barrier (void);\n extern tree c_finish_omp_atomic (enum tree_code, tree, tree);\n extern void c_finish_omp_flush (void);\n+extern void c_finish_omp_taskwait (void);\n extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);\n extern void c_split_parallel_clauses (tree, tree *, tree *);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);"}, {"sha": "82bd5c27313e080d7a3605c89de5ea29e4b6584d", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -659,7 +659,7 @@ c_cpp_builtins (cpp_reader *pfile)\n     cpp_define (pfile, \"__SSP__=1\");\n \n   if (flag_openmp)\n-    cpp_define (pfile, \"_OPENMP=200505\");\n+    cpp_define (pfile, \"_OPENMP=200805\");\n \n   builtin_define_type_sizeof (\"__SIZEOF_INT__\", integer_type_node);\n   builtin_define_type_sizeof (\"__SIZEOF_LONG__\", long_integer_type_node);"}, {"sha": "1da71d27b9c83902eb156be71703ce785288458c", "filename": "gcc/c-omp.c", "status": "modified", "additions": 182, "deletions": 133, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,7 +1,7 @@\n /* This file contains routines to construct GNU OpenMP constructs, \n    called from parsing in the C and C++ front ends.\n \n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>,\n \t\t  Diego Novillo <dnovillo@redhat.com>.\n \n@@ -80,6 +80,19 @@ c_finish_omp_barrier (void)\n }\n \n \n+/* Complete a #pragma omp taskwait construct.  */\n+\n+void\n+c_finish_omp_taskwait (void)\n+{\n+  tree x;\n+\n+  x = built_in_decls[BUILT_IN_GOMP_TASKWAIT];\n+  x = build_call_expr (x, 0);\n+  add_stmt (x);\n+}\n+\n+\n /* Complete a #pragma omp atomic construct.  The expression to be \n    implemented atomically is LHS code= RHS.  The value returned is\n    either error_mark_node (if the construct was erroneous) or an\n@@ -197,170 +210,205 @@ check_omp_for_incr_expr (tree exp, tree decl)\n }\n \n /* Validate and emit code for the OpenMP directive #pragma omp for.\n-   INIT, COND, INCR, BODY and PRE_BODY are the five basic elements\n-   of the loop (initialization expression, controlling predicate, increment\n-   expression, body of the loop and statements to go before the loop).\n-   DECL is the iteration variable.  */\n+   DECLV is a vector of iteration variables, for each collapsed loop.\n+   INITV, CONDV and INCRV are vectors containing initialization\n+   expressions, controlling predicates and increment expressions.\n+   BODY is the body of the loop and PRE_BODY statements that go before\n+   the loop.  */\n \n tree\n-c_finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n-\t\t  tree incr, tree body, tree pre_body)\n+c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n+\t\t  tree incrv, tree body, tree pre_body)\n {\n-  location_t elocus = locus;\n+  location_t elocus;\n   bool fail = false;\n+  int i;\n \n-  if (EXPR_HAS_LOCATION (init))\n-    elocus = EXPR_LOCATION (init);\n-\n-  /* Validate the iteration variable.  */\n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (decl)))\n+  gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (initv));\n+  gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (condv));\n+  gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (incrv));\n+  for (i = 0; i < TREE_VEC_LENGTH (declv); i++)\n     {\n-      error (\"%Hinvalid type for iteration variable %qE\", &elocus, decl);\n-      fail = true;\n-    }\n-  if (TYPE_UNSIGNED (TREE_TYPE (decl)))\n-    warning (0, \"%Hiteration variable %qE is unsigned\", &elocus, decl);\n+      tree decl = TREE_VEC_ELT (declv, i);\n+      tree init = TREE_VEC_ELT (initv, i);\n+      tree cond = TREE_VEC_ELT (condv, i);\n+      tree incr = TREE_VEC_ELT (incrv, i);\n+\n+      elocus = locus;\n+      if (EXPR_HAS_LOCATION (init))\n+\telocus = EXPR_LOCATION (init);\n+\n+      /* Validate the iteration variable.  */\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (decl))\n+\t  && TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE)\n+\t{\n+\t  error (\"%Hinvalid type for iteration variable %qE\", &elocus, decl);\n+\t  fail = true;\n+\t}\n \n-  /* In the case of \"for (int i = 0...)\", init will be a decl.  It should\n-     have a DECL_INITIAL that we can turn into an assignment.  */\n-  if (init == decl)\n-    {\n-      elocus = DECL_SOURCE_LOCATION (decl);\n+      /* In the case of \"for (int i = 0...)\", init will be a decl.  It should\n+\t have a DECL_INITIAL that we can turn into an assignment.  */\n+      if (init == decl)\n+\t{\n+\t  elocus = DECL_SOURCE_LOCATION (decl);\n+\n+\t  init = DECL_INITIAL (decl);\n+\t  if (init == NULL)\n+\t    {\n+\t      error (\"%H%qE is not initialized\", &elocus, decl);\n+\t      init = integer_zero_node;\n+\t      fail = true;\n+\t    }\n \n-      init = DECL_INITIAL (decl);\n-      if (init == NULL)\n+\t  init = build_modify_expr (decl, NOP_EXPR, init);\n+\t  SET_EXPR_LOCATION (init, elocus);\n+\t}\n+      gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+      gcc_assert (TREE_OPERAND (init, 0) == decl);\n+\n+      if (cond == NULL_TREE)\n \t{\n-\t  error (\"%H%qE is not initialized\", &elocus, decl);\n-\t  init = integer_zero_node;\n+\t  error (\"%Hmissing controlling predicate\", &elocus);\n \t  fail = true;\n \t}\n+      else\n+\t{\n+\t  bool cond_ok = false;\n \n-      init = build_modify_expr (decl, NOP_EXPR, init);\n-      SET_EXPR_LOCATION (init, elocus);\n-    }\n-  gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n-  gcc_assert (TREE_OPERAND (init, 0) == decl);\n-  \n-  if (cond == NULL_TREE)\n-    {\n-      error (\"%Hmissing controlling predicate\", &elocus);\n-      fail = true;\n-    }\n-  else\n-    {\n-      bool cond_ok = false;\n+\t  if (EXPR_HAS_LOCATION (cond))\n+\t    elocus = EXPR_LOCATION (cond);\n \n-      if (EXPR_HAS_LOCATION (cond))\n-\telocus = EXPR_LOCATION (cond);\n+\t  if (TREE_CODE (cond) == LT_EXPR\n+\t      || TREE_CODE (cond) == LE_EXPR\n+\t      || TREE_CODE (cond) == GT_EXPR\n+\t      || TREE_CODE (cond) == GE_EXPR)\n+\t    {\n+\t      tree op0 = TREE_OPERAND (cond, 0);\n+\t      tree op1 = TREE_OPERAND (cond, 1);\n \n-      if (TREE_CODE (cond) == LT_EXPR\n-\t  || TREE_CODE (cond) == LE_EXPR\n-\t  || TREE_CODE (cond) == GT_EXPR\n-\t  || TREE_CODE (cond) == GE_EXPR)\n-\t{\n-\t  tree op0 = TREE_OPERAND (cond, 0);\n-\t  tree op1 = TREE_OPERAND (cond, 1);\n+\t      /* 2.5.1.  The comparison in the condition is computed in\n+\t\t the type of DECL, otherwise the behavior is undefined.\n \n-\t  /* 2.5.1.  The comparison in the condition is computed in the type\n-\t     of DECL, otherwise the behavior is undefined.\n+\t\t For example:\n+\t\t long n; int i;\n+\t\t i < n;\n \n-\t     For example:\n-\t     long n; int i;\n-\t     i < n;\n+\t\t according to ISO will be evaluated as:\n+\t\t (long)i < n;\n \n-\t     according to ISO will be evaluated as:\n-\t     (long)i < n;\n+\t\t We want to force:\n+\t\t i < (int)n;  */\n+\t      if (TREE_CODE (op0) == NOP_EXPR\n+\t\t  && decl == TREE_OPERAND (op0, 0))\n+\t\t{\n+\t\t  TREE_OPERAND (cond, 0) = TREE_OPERAND (op0, 0);\n+\t\t  TREE_OPERAND (cond, 1)\n+\t\t    = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n+\t\t\t\t   TREE_OPERAND (cond, 1));\n+\t\t}\n+\t      else if (TREE_CODE (op1) == NOP_EXPR\n+\t\t       && decl == TREE_OPERAND (op1, 0))\n+\t\t{\n+\t\t  TREE_OPERAND (cond, 1) = TREE_OPERAND (op1, 0);\n+\t\t  TREE_OPERAND (cond, 0)\n+\t\t    = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n+\t\t\t\t   TREE_OPERAND (cond, 0));\n+\t\t}\n \n-\t     We want to force:\n-\t     i < (int)n;  */\n-\t  if (TREE_CODE (op0) == NOP_EXPR\n-\t      && decl == TREE_OPERAND (op0, 0))\n-\t    {\n-\t      TREE_OPERAND (cond, 0) = TREE_OPERAND (op0, 0);\n-\t      TREE_OPERAND (cond, 1) = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n-\t\t\t\t\t\t    TREE_OPERAND (cond, 1));\n-\t    }\n-\t  else if (TREE_CODE (op1) == NOP_EXPR\n-\t\t   && decl == TREE_OPERAND (op1, 0))\n-\t    {\n-\t      TREE_OPERAND (cond, 1) = TREE_OPERAND (op1, 0);\n-\t      TREE_OPERAND (cond, 0) = fold_build1 (NOP_EXPR, TREE_TYPE (decl),\n-\t\t\t\t\t\t    TREE_OPERAND (cond, 0));\n+\t      if (decl == TREE_OPERAND (cond, 0))\n+\t\tcond_ok = true;\n+\t      else if (decl == TREE_OPERAND (cond, 1))\n+\t\t{\n+\t\t  TREE_SET_CODE (cond,\n+\t\t\t\t swap_tree_comparison (TREE_CODE (cond)));\n+\t\t  TREE_OPERAND (cond, 1) = TREE_OPERAND (cond, 0);\n+\t\t  TREE_OPERAND (cond, 0) = decl;\n+\t\t  cond_ok = true;\n+\t\t}\n \t    }\n \n-\t  if (decl == TREE_OPERAND (cond, 0))\n-\t    cond_ok = true;\n-\t  else if (decl == TREE_OPERAND (cond, 1))\n+\t  if (!cond_ok)\n \t    {\n-\t      TREE_SET_CODE (cond, swap_tree_comparison (TREE_CODE (cond)));\n-\t      TREE_OPERAND (cond, 1) = TREE_OPERAND (cond, 0);\n-\t      TREE_OPERAND (cond, 0) = decl;\n-\t      cond_ok = true;\n+\t      error (\"%Hinvalid controlling predicate\", &elocus);\n+\t      fail = true;\n \t    }\n \t}\n \n-      if (!cond_ok)\n+      if (incr == NULL_TREE)\n \t{\n-\t  error (\"%Hinvalid controlling predicate\", &elocus);\n+\t  error (\"%Hmissing increment expression\", &elocus);\n \t  fail = true;\n \t}\n-    }\n-\n-  if (incr == NULL_TREE)\n-    {\n-      error (\"%Hmissing increment expression\", &elocus);\n-      fail = true;\n-    }\n-  else\n-    {\n-      bool incr_ok = false;\n-\n-      if (EXPR_HAS_LOCATION (incr))\n-\telocus = EXPR_LOCATION (incr);\n-\n-      /* Check all the valid increment expressions: v++, v--, ++v, --v,\n-\t v = v + incr, v = incr + v and v = v - incr.  */\n-      switch (TREE_CODE (incr))\n+      else\n \t{\n-\tcase POSTINCREMENT_EXPR:\n-\tcase PREINCREMENT_EXPR:\n-\tcase POSTDECREMENT_EXPR:\n-\tcase PREDECREMENT_EXPR:\n-\t  incr_ok = (TREE_OPERAND (incr, 0) == decl);\n-\t  break;\n+\t  bool incr_ok = false;\n \n-\tcase MODIFY_EXPR:\n-\t  if (TREE_OPERAND (incr, 0) != decl)\n-\t    break;\n-\t  if (TREE_OPERAND (incr, 1) == decl)\n-\t    break;\n-\t  if (TREE_CODE (TREE_OPERAND (incr, 1)) == PLUS_EXPR\n-\t      && (TREE_OPERAND (TREE_OPERAND (incr, 1), 0) == decl\n-\t\t  || TREE_OPERAND (TREE_OPERAND (incr, 1), 1) == decl))\n-\t    incr_ok = true;\n-\t  else if (TREE_CODE (TREE_OPERAND (incr, 1)) == MINUS_EXPR\n-\t\t   && TREE_OPERAND (TREE_OPERAND (incr, 1), 0) == decl)\n-\t    incr_ok = true;\n-\t  else\n+\t  if (EXPR_HAS_LOCATION (incr))\n+\t    elocus = EXPR_LOCATION (incr);\n+\n+\t  /* Check all the valid increment expressions: v++, v--, ++v, --v,\n+\t     v = v + incr, v = incr + v and v = v - incr.  */\n+\t  switch (TREE_CODE (incr))\n \t    {\n-\t      tree t = check_omp_for_incr_expr (TREE_OPERAND (incr, 1), decl);\n-\t      if (t != error_mark_node)\n+\t    case POSTINCREMENT_EXPR:\n+\t    case PREINCREMENT_EXPR:\n+\t    case POSTDECREMENT_EXPR:\n+\t    case PREDECREMENT_EXPR:\n+\t      if (TREE_OPERAND (incr, 0) != decl)\n+\t\tbreak;\n+\n+\t      incr_ok = true;\n+\t      if (POINTER_TYPE_P (TREE_TYPE (decl)))\n \t\t{\n-\t\t  incr_ok = true;\n-\t\t  t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n+\t\t  tree t = fold_convert (sizetype, TREE_OPERAND (incr, 1));\n+\n+\t\t  if (TREE_CODE (incr) == POSTDECREMENT_EXPR\n+\t\t      || TREE_CODE (incr) == PREDECREMENT_EXPR)\n+\t\t    t = fold_build1 (NEGATE_EXPR, sizetype, t);\n+\t\t  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (decl), decl, t);\n \t\t  incr = build2 (MODIFY_EXPR, void_type_node, decl, t);\n \t\t}\n-\t    }\n-\t  break;\n+\t      break;\n+\n+\t    case MODIFY_EXPR:\n+\t      if (TREE_OPERAND (incr, 0) != decl)\n+\t\tbreak;\n+\t      if (TREE_OPERAND (incr, 1) == decl)\n+\t\tbreak;\n+\t      if (TREE_CODE (TREE_OPERAND (incr, 1)) == PLUS_EXPR\n+\t\t  && (TREE_OPERAND (TREE_OPERAND (incr, 1), 0) == decl\n+\t\t      || TREE_OPERAND (TREE_OPERAND (incr, 1), 1) == decl))\n+\t\tincr_ok = true;\n+\t      else if ((TREE_CODE (TREE_OPERAND (incr, 1)) == MINUS_EXPR\n+\t\t\t|| (TREE_CODE (TREE_OPERAND (incr, 1))\n+\t\t\t    == POINTER_PLUS_EXPR))\n+\t\t       && TREE_OPERAND (TREE_OPERAND (incr, 1), 0) == decl)\n+\t\tincr_ok = true;\n+\t      else\n+\t\t{\n+\t\t  tree t = check_omp_for_incr_expr (TREE_OPERAND (incr, 1),\n+\t\t\t\t\t\t    decl);\n+\t\t  if (t != error_mark_node)\n+\t\t    {\n+\t\t      incr_ok = true;\n+\t\t      t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n+\t\t      incr = build2 (MODIFY_EXPR, void_type_node, decl, t);\n+\t\t    }\n+\t\t}\n+\t      break;\n \n-\tdefault:\n-\t  break;\n-\t}\n-      if (!incr_ok)\n-\t{\n-\t  error (\"%Hinvalid increment expression\", &elocus);\n-\t  fail = true;\n+\t    default:\n+\t      break;\n+\t    }\n+\t  if (!incr_ok)\n+\t    {\n+\t      error (\"%Hinvalid increment expression\", &elocus);\n+\t      fail = true;\n+\t    }\n \t}\n+\n+      TREE_VEC_ELT (initv, i) = init;\n+      TREE_VEC_ELT (incrv, i) = incr;\n     }\n \n   if (fail)\n@@ -370,9 +418,9 @@ c_finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n       tree t = make_node (OMP_FOR);\n \n       TREE_TYPE (t) = void_type_node;\n-      OMP_FOR_INIT (t) = init;\n-      OMP_FOR_COND (t) = cond;\n-      OMP_FOR_INCR (t) = incr;\n+      OMP_FOR_INIT (t) = initv;\n+      OMP_FOR_COND (t) = condv;\n+      OMP_FOR_INCR (t) = incrv;\n       OMP_FOR_BODY (t) = body;\n       OMP_FOR_PRE_BODY (t) = pre_body;\n \n@@ -416,6 +464,7 @@ c_split_parallel_clauses (tree clauses, tree *par_clauses, tree *ws_clauses)\n \n \tcase OMP_CLAUSE_SCHEDULE:\n \tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_COLLAPSE:\n \t  OMP_CLAUSE_CHAIN (clauses) = *ws_clauses;\n \t  *ws_clauses = clauses;\n \t  break;"}, {"sha": "7607a8dfdcfb5c8df4234f983570d8f3c74c5a69", "filename": "gcc/c-parser.c", "status": "modified", "additions": 333, "deletions": 60, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1018,6 +1018,7 @@ static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n static void c_parser_omp_flush (c_parser *);\n+static void c_parser_omp_taskwait (c_parser *);\n \n enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n static bool c_parser_pragma (c_parser *, enum pragma_context);\n@@ -6674,6 +6675,17 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       c_parser_omp_flush (parser);\n       return false;\n \n+    case PRAGMA_OMP_TASKWAIT:\n+      if (context != pragma_compound)\n+\t{\n+\t  if (context == pragma_stmt)\n+\t    c_parser_error (parser, \"%<#pragma omp taskwait%> may only be \"\n+\t\t\t    \"used in compound statements\");\n+\t  goto bad_stmt;\n+\t}\n+      c_parser_omp_taskwait (parser);\n+      return false;\n+\n     case PRAGMA_OMP_THREADPRIVATE:\n       c_parser_omp_threadprivate (parser);\n       return false;\n@@ -6781,7 +6793,9 @@ c_parser_omp_clause_name (c_parser *parser)\n       switch (p[0])\n \t{\n \tcase 'c':\n-\t  if (!strcmp (\"copyin\", p))\n+\t  if (!strcmp (\"collapse\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_COLLAPSE;\n+\t  else if (!strcmp (\"copyin\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYIN;\n           else if (!strcmp (\"copyprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n@@ -6818,6 +6832,10 @@ c_parser_omp_clause_name (c_parser *parser)\n \t  else if (!strcmp (\"shared\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SHARED;\n \t  break;\n+\tcase 'u':\n+\t  if (!strcmp (\"untied\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_UNTIED;\n+\t  break;\n \t}\n     }\n \n@@ -6906,6 +6924,41 @@ c_parser_omp_var_list_parens (c_parser *parser, enum tree_code kind, tree list)\n   return list;\n }\n \n+/* OpenMP 3.0:\n+   collapse ( constant-expression ) */\n+\n+static tree\n+c_parser_omp_clause_collapse (c_parser *parser, tree list)\n+{\n+  tree c, num = error_mark_node;\n+  HOST_WIDE_INT n;\n+  location_t loc;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\");\n+\n+  loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      num = c_parser_expr_no_commas (parser, NULL).value;\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+    }\n+  if (num == error_mark_node)\n+    return list;\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (num))\n+      || !host_integerp (num, 0)\n+      || (n = tree_low_cst (num, 0)) <= 0\n+      || (int) n != n)\n+    {\n+      error (\"%Hcollapse argument needs positive constant integer expression\",\n+\t     &loc);\n+      return list;\n+    }\n+  c = build_omp_clause (OMP_CLAUSE_COLLAPSE);\n+  OMP_CLAUSE_COLLAPSE_EXPR (c) = num;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n /* OpenMP 2.5:\n    copyin ( variable-list ) */\n \n@@ -7164,7 +7217,7 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n    schedule ( schedule-kind , expression )\n \n    schedule-kind:\n-     static | dynamic | guided | runtime\n+     static | dynamic | guided | runtime | auto\n */\n \n static tree\n@@ -7208,6 +7261,8 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n     }\n   else if (c_parser_next_token_is_keyword (parser, RID_STATIC))\n     OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;\n+  else if (c_parser_next_token_is_keyword (parser, RID_AUTO))\n+    OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_AUTO;\n   else\n     goto invalid_kind;\n \n@@ -7223,6 +7278,9 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n       if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n \terror (\"%Hschedule %<runtime%> does not take \"\n \t       \"a %<chunk_size%> parameter\", &here);\n+      else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)\n+\terror (\"%Hschedule %<auto%> does not take \"\n+\t       \"a %<chunk_size%> parameter\", &here);\n       else if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE)\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n       else\n@@ -7253,6 +7311,22 @@ c_parser_omp_clause_shared (c_parser *parser, tree list)\n   return c_parser_omp_var_list_parens (parser, OMP_CLAUSE_SHARED, list);\n }\n \n+/* OpenMP 3.0:\n+   untied */\n+\n+static tree\n+c_parser_omp_clause_untied (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  tree c;\n+\n+  /* FIXME: Should we allow duplicates?  */\n+  check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, \"untied\");\n+\n+  c = build_omp_clause (OMP_CLAUSE_UNTIED);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n /* Parse all OpenMP clauses.  The set clauses allowed by the directive\n    is a bitmask in MASK.  Return the list of clauses found; the result\n    of clause default goes in *pdefault.  */\n@@ -7280,6 +7354,10 @@ c_parser_omp_all_clauses (c_parser *parser, unsigned int mask,\n \n       switch (c_kind)\n \t{\n+\tcase PRAGMA_OMP_CLAUSE_COLLAPSE:\n+\t  clauses = c_parser_omp_clause_collapse (parser, clauses);\n+\t  c_name = \"collapse\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_COPYIN:\n \t  clauses = c_parser_omp_clause_copyin (parser, clauses);\n \t  c_name = \"copyin\";\n@@ -7332,6 +7410,10 @@ c_parser_omp_all_clauses (c_parser *parser, unsigned int mask,\n \t  clauses = c_parser_omp_clause_shared (parser, clauses);\n \t  c_name = \"shared\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_UNTIED:\n+\t  clauses = c_parser_omp_clause_untied (parser, clauses);\n+\t  c_name = \"untied\";\n+\t  break;\n \tdefault:\n \t  c_parser_error (parser, \"expected %<#pragma omp%> clause\");\n \t  goto saw_error;\n@@ -7527,10 +7609,24 @@ c_parser_omp_flush (c_parser *parser)\n    so that we can push a new decl if necessary to make it private.  */\n \n static tree\n-c_parser_omp_for_loop (c_parser *parser)\n+c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n {\n-  tree decl, cond, incr, save_break, save_cont, body, init;\n+  tree decl, cond, incr, save_break, save_cont, body, init, stmt, cl;\n+  tree declv, condv, incrv, initv, for_block = NULL, ret = NULL;\n   location_t loc;\n+  bool fail = false, open_brace_parsed = false;\n+  int i, collapse = 1, nbraces = 0;\n+\n+  for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n+    if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n+      collapse = tree_low_cst (OMP_CLAUSE_COLLAPSE_EXPR (cl), 0);\n+\n+  gcc_assert (collapse >= 1);\n+\n+  declv = make_tree_vec (collapse);\n+  initv = make_tree_vec (collapse);\n+  condv = make_tree_vec (collapse);\n+  incrv = make_tree_vec (collapse);\n \n   if (!c_parser_next_token_is_keyword (parser, RID_FOR))\n     {\n@@ -7540,79 +7636,219 @@ c_parser_omp_for_loop (c_parser *parser)\n   loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-    return NULL;\n-\n-  /* Parse the initialization declaration or expression.  */\n-  if (c_parser_next_token_starts_declspecs (parser))\n+  for (i = 0; i < collapse; i++)\n     {\n-      c_parser_declaration_or_fndef (parser, true, true, true, true);\n-      decl = check_for_loop_decls ();\n-      if (decl == NULL)\n-\tgoto error_init;\n-      if (DECL_INITIAL (decl) == error_mark_node)\n-\tdecl = error_mark_node;\n-      init = decl;\n-    }\n-  else if (c_parser_next_token_is (parser, CPP_NAME)\n-\t   && c_parser_peek_2nd_token (parser)->type == CPP_EQ)\n-    {\n-      decl = c_parser_postfix_expression (parser).value;\n+      int bracecount = 0;\n \n-      c_parser_require (parser, CPP_EQ, \"expected %<=%>\");\n+      if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\tgoto pop_scopes;\n \n-      init = c_parser_expr_no_commas (parser, NULL).value;\n-      init = build_modify_expr (decl, NOP_EXPR, init);\n-      init = c_process_expr_stmt (init);\n+      /* Parse the initialization declaration or expression.  */\n+      if (c_parser_next_token_starts_declspecs (parser))\n+\t{\n+\t  if (i > 0)\n+\t    for_block\n+\t      = tree_cons (NULL, c_begin_compound_stmt (true), for_block);\n+\t  c_parser_declaration_or_fndef (parser, true, true, true, true);\n+\t  decl = check_for_loop_decls ();\n+\t  if (decl == NULL)\n+\t    goto error_init;\n+\t  if (DECL_INITIAL (decl) == error_mark_node)\n+\t    decl = error_mark_node;\n+\t  init = decl;\n+\t}\n+      else if (c_parser_next_token_is (parser, CPP_NAME)\n+\t       && c_parser_peek_2nd_token (parser)->type == CPP_EQ)\n+\t{\n+\t  struct c_expr init_exp;\n+\n+\t  decl = c_parser_postfix_expression (parser).value;\n+\n+\t  c_parser_require (parser, CPP_EQ, \"expected %<=%>\");\n+\n+\t  init_exp = c_parser_expr_no_commas (parser, NULL);\n+\t  init_exp = default_function_array_conversion (init_exp);\n+\t  init = build_modify_expr (decl, NOP_EXPR, init_exp.value);\n+\t  init = c_process_expr_stmt (init);\n \n+\t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t}\n+      else\n+\t{\n+\terror_init:\n+\t  c_parser_error (parser,\n+\t\t\t  \"expected iteration declaration or initialization\");\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t     \"expected %<)%>\");\n+\t  fail = true;\n+\t  goto parse_next;\n+\t}\n+\n+      /* Parse the loop condition.  */\n+      cond = NULL_TREE;\n+      if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n+\t{\n+\t  cond = c_parser_expression_conv (parser).value;\n+\t  cond = c_objc_common_truthvalue_conversion (cond);\n+\t  if (CAN_HAVE_LOCATION_P (cond))\n+\t    SET_EXPR_LOCATION (cond, input_location);\n+\t}\n       c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n-    }\n-  else\n-    goto error_init;\n \n-  /* Parse the loop condition.  */\n-  cond = NULL_TREE;\n-  if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n-    {\n-      cond = c_parser_expression_conv (parser).value;\n-      cond = c_objc_common_truthvalue_conversion (cond);\n-      if (CAN_HAVE_LOCATION_P (cond))\n-\tSET_EXPR_LOCATION (cond, input_location);\n-    }\n-  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+      /* Parse the increment expression.  */\n+      incr = NULL_TREE;\n+      if (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n+\tincr = c_process_expr_stmt (c_parser_expression (parser).value);\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n \n-  /* Parse the increment expression.  */\n-  incr = NULL_TREE;\n-  if (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n-    incr = c_process_expr_stmt (c_parser_expression (parser).value);\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      if (decl == NULL || decl == error_mark_node || init == error_mark_node)\n+\tfail = true;\n+      else\n+\t{\n+\t  TREE_VEC_ELT (declv, i) = decl;\n+\t  TREE_VEC_ELT (initv, i) = init;\n+\t  TREE_VEC_ELT (condv, i) = cond;\n+\t  TREE_VEC_ELT (incrv, i) = incr;\n+\t}\n+\n+    parse_next:\n+      if (i == collapse - 1)\n+\tbreak;\n+\n+      /* FIXME: OpenMP 3.0 draft isn't very clear on what exactly is allowed\n+\t in between the collapsed for loops to be still considered perfectly\n+\t nested.  Hopefully the final version clarifies this.\n+\t For now handle (multiple) {'s and empty statements.  */\n+      do\n+\t{\n+\t  if (c_parser_next_token_is_keyword (parser, RID_FOR))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      break;\n+\t    }\n+\t  else if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      bracecount++;\n+\t    }\n+\t  else if (bracecount\n+\t\t   && c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\t    c_parser_consume_token (parser);\n+\t  else\n+\t    {\n+\t      c_parser_error (parser, \"not enough perfectly nested loops\");\n+\t      if (bracecount)\n+\t\t{\n+\t\t  open_brace_parsed = true;\n+\t\t  bracecount--;\n+\t\t}\n+\t      fail = true;\n+\t      collapse = 0;\n+\t      break;\n+\t    }\n+\t}\n+      while (1);\n+\n+      nbraces += bracecount;\n+    }\n \n- parse_body:\n   save_break = c_break_label;\n   c_break_label = size_one_node;\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n   body = push_stmt_list ();\n \n-  add_stmt (c_parser_c99_block_statement (parser));\n+  if (open_brace_parsed)\n+    {\n+      stmt = c_begin_compound_stmt (true);\n+      c_parser_compound_statement_nostart (parser);\n+      add_stmt (c_end_compound_stmt (stmt, true));\n+    }\n+  else\n+    add_stmt (c_parser_c99_block_statement (parser));\n   if (c_cont_label)\n     add_stmt (build1 (LABEL_EXPR, void_type_node, c_cont_label));\n \n   body = pop_stmt_list (body);\n   c_break_label = save_break;\n   c_cont_label = save_cont;\n \n+  while (nbraces)\n+    {\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  nbraces--;\n+\t}\n+      else if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\tc_parser_consume_token (parser);\n+      else\n+\t{\n+\t  c_parser_error (parser, \"collapsed loops not perfectly nested\");\n+\t  while (nbraces)\n+\t    {\n+\t      stmt = c_begin_compound_stmt (true);\n+\t      add_stmt (body);\n+\t      c_parser_compound_statement_nostart (parser);\n+\t      body = c_end_compound_stmt (stmt, true);\n+\t      nbraces--;\n+\t    }\n+\t  goto pop_scopes;\n+\t}\n+    }\n+\n   /* Only bother calling c_finish_omp_for if we haven't already generated\n      an error from the initialization parsing.  */\n-  if (decl != NULL && decl != error_mark_node && init != error_mark_node)\n-    return c_finish_omp_for (loc, decl, init, cond, incr, body, NULL);\n-  return NULL;\n-\n- error_init:\n-  c_parser_error (parser, \"expected iteration declaration or initialization\");\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n-  decl = init = cond = incr = NULL_TREE;\n-  goto parse_body;\n+  if (!fail)\n+    {\n+      stmt = c_finish_omp_for (loc, declv, initv, condv, incrv, body, NULL);\n+      if (stmt)\n+\t{\n+\t  if (par_clauses != NULL)\n+\t    {\n+\t      tree *c;\n+\t      for (c = par_clauses; *c ; )\n+\t\tif (OMP_CLAUSE_CODE (*c) != OMP_CLAUSE_FIRSTPRIVATE\n+\t\t    && OMP_CLAUSE_CODE (*c) != OMP_CLAUSE_LASTPRIVATE)\n+\t\t  c = &OMP_CLAUSE_CHAIN (*c);\n+\t\telse\n+\t\t  {\n+\t\t    for (i = 0; i < collapse; i++)\n+\t\t      if (TREE_VEC_ELT (declv, i) == OMP_CLAUSE_DECL (*c))\n+\t\t\tbreak;\n+\t\t    if (i == collapse)\n+\t\t      c = &OMP_CLAUSE_CHAIN (*c);\n+\t\t    else if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_FIRSTPRIVATE)\n+\t\t      {\n+\t\t\terror (\"%Hiteration variable %qD should not be firstprivate\",\n+\t\t\t       &loc, OMP_CLAUSE_DECL (*c));\n+\t\t\t*c = OMP_CLAUSE_CHAIN (*c);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t/* Copy lastprivate (decl) clause to OMP_FOR_CLAUSES,\n+\t\t\t   change it to shared (decl) in\n+\t\t\t   OMP_PARALLEL_CLAUSES.  */\n+\t\t\ttree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);\n+\t\t\tOMP_CLAUSE_DECL (l) = OMP_CLAUSE_DECL (*c);\n+\t\t\tOMP_CLAUSE_CHAIN (l) = clauses;\n+\t\t\tclauses = l;\n+\t\t\tOMP_CLAUSE_SET_CODE (*c, OMP_CLAUSE_SHARED);\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t  OMP_FOR_CLAUSES (stmt) = clauses;\n+\t}\n+      ret = stmt;\n+    }\n+pop_scopes:\n+  while (for_block)\n+    {\n+      stmt = c_end_compound_stmt (TREE_VALUE (for_block), true);\n+      add_stmt (stmt);\n+      for_block = TREE_CHAIN (for_block);\n+    }\n+  return ret;\n }\n \n /* OpenMP 2.5:\n@@ -7627,6 +7863,7 @@ c_parser_omp_for_loop (c_parser *parser)\n \t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_ORDERED)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_COLLAPSE)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n@@ -7638,9 +7875,7 @@ c_parser_omp_for (c_parser *parser)\n \t\t\t\t      \"#pragma omp for\");\n \n   block = c_begin_compound_stmt (true);\n-  ret = c_parser_omp_for_loop (parser);\n-  if (ret)\n-    OMP_FOR_CLAUSES (ret) = clauses;\n+  ret = c_parser_omp_for_loop (parser, clauses, NULL);\n   block = c_end_compound_stmt (block, true);\n   add_stmt (block);\n \n@@ -7845,9 +8080,7 @@ c_parser_omp_parallel (c_parser *parser)\n     case PRAGMA_OMP_PARALLEL_FOR:\n       block = c_begin_omp_parallel ();\n       c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n-      stmt = c_parser_omp_for_loop (parser);\n-      if (stmt)\n-\tOMP_FOR_CLAUSES (stmt) = ws_clause;\n+      c_parser_omp_for_loop (parser, ws_clause, &par_clause);\n       stmt = c_finish_omp_parallel (par_clause, block);\n       OMP_PARALLEL_COMBINED (stmt) = 1;\n       break;\n@@ -7894,6 +8127,43 @@ c_parser_omp_single (c_parser *parser)\n   return add_stmt (stmt);\n }\n \n+/* OpenMP 3.0:\n+   # pragma omp task task-clause[optseq] new-line\n+*/\n+\n+#define OMP_TASK_CLAUSE_MASK\t\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_IF)\t\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_UNTIED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_DEFAULT)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_SHARED))\n+\n+static tree\n+c_parser_omp_task (c_parser *parser)\n+{\n+  tree clauses, block;\n+\n+  clauses = c_parser_omp_all_clauses (parser, OMP_TASK_CLAUSE_MASK,\n+\t\t\t\t      \"#pragma omp task\");\n+\n+  block = c_begin_omp_task ();\n+  c_parser_statement (parser);\n+  return c_finish_omp_task (clauses, block);\n+}\n+\n+/* OpenMP 3.0:\n+   # pragma omp taskwait new-line\n+*/\n+\n+static void\n+c_parser_omp_taskwait (c_parser *parser)\n+{\n+  c_parser_consume_pragma (parser);\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  c_finish_omp_taskwait ();\n+}\n \n /* Main entry point to parsing most OpenMP pragmas.  */\n \n@@ -7940,6 +8210,9 @@ c_parser_omp_construct (c_parser *parser)\n     case PRAGMA_OMP_SINGLE:\n       stmt = c_parser_omp_single (parser);\n       break;\n+    case PRAGMA_OMP_TASK:\n+      stmt = c_parser_omp_task (parser);\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "81b9910b41a9687e4685105b98660bfbd574a268", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -896,6 +896,8 @@ static const struct omp_pragma_def omp_pragmas[] = {\n   { \"section\", PRAGMA_OMP_SECTION },\n   { \"sections\", PRAGMA_OMP_SECTIONS },\n   { \"single\", PRAGMA_OMP_SINGLE },\n+  { \"task\", PRAGMA_OMP_TASK },\n+  { \"taskwait\", PRAGMA_OMP_TASKWAIT },\n   { \"threadprivate\", PRAGMA_OMP_THREADPRIVATE }\n };\n "}, {"sha": "188afb8dbaaee26fd02f568f02619a2415a675cc", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -41,6 +41,8 @@ typedef enum pragma_kind {\n   PRAGMA_OMP_SECTION,\n   PRAGMA_OMP_SECTIONS,\n   PRAGMA_OMP_SINGLE,\n+  PRAGMA_OMP_TASK,\n+  PRAGMA_OMP_TASKWAIT,\n   PRAGMA_OMP_THREADPRIVATE,\n \n   PRAGMA_GCC_PCH_PREPROCESS,\n@@ -49,11 +51,12 @@ typedef enum pragma_kind {\n } pragma_kind;\n \n \n-/* All clauses defined by OpenMP 2.5.\n+/* All clauses defined by OpenMP 2.5 and 3.0.\n    Used internally by both C and C++ parsers.  */\n typedef enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n \n+  PRAGMA_OMP_CLAUSE_COLLAPSE,\n   PRAGMA_OMP_CLAUSE_COPYIN,\n   PRAGMA_OMP_CLAUSE_COPYPRIVATE,\n   PRAGMA_OMP_CLAUSE_DEFAULT,\n@@ -66,7 +69,8 @@ typedef enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_PRIVATE,\n   PRAGMA_OMP_CLAUSE_REDUCTION,\n   PRAGMA_OMP_CLAUSE_SCHEDULE,\n-  PRAGMA_OMP_CLAUSE_SHARED\n+  PRAGMA_OMP_CLAUSE_SHARED,\n+  PRAGMA_OMP_CLAUSE_UNTIED\n } pragma_omp_clause;\n \n extern struct cpp_reader* parse_in;"}, {"sha": "14df044437774d558ec68caef4154abedbf88aae", "filename": "gcc/c-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -596,6 +596,8 @@ extern void c_end_vm_scope (unsigned int);\n extern tree c_expr_to_decl (tree, bool *, bool *);\n extern tree c_begin_omp_parallel (void);\n extern tree c_finish_omp_parallel (tree, tree);\n+extern tree c_begin_omp_task (void);\n+extern tree c_finish_omp_task (tree, tree);\n extern tree c_finish_omp_clauses (tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if"}, {"sha": "23880d16a4377c442792405dab0d1b8e0a3eba82", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -8681,6 +8681,8 @@ c_begin_omp_parallel (void)\n   return block;\n }\n \n+/* Generate OMP_PARALLEL, with CLAUSES and BLOCK as its compound statement.  */\n+\n tree\n c_finish_omp_parallel (tree clauses, tree block)\n {\n@@ -8696,6 +8698,36 @@ c_finish_omp_parallel (tree clauses, tree block)\n   return add_stmt (stmt);\n }\n \n+/* Like c_begin_compound_stmt, except force the retention of the BLOCK.  */\n+\n+tree\n+c_begin_omp_task (void)\n+{\n+  tree block;\n+\n+  keep_next_level ();\n+  block = c_begin_compound_stmt (true);\n+\n+  return block;\n+}\n+\n+/* Generate OMP_TASK, with CLAUSES and BLOCK as its compound statement.  */\n+\n+tree\n+c_finish_omp_task (tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = c_end_compound_stmt (block, true);\n+\n+  stmt = make_node (OMP_TASK);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TASK_CLAUSES (stmt) = clauses;\n+  OMP_TASK_BODY (stmt) = block;\n+\n+  return add_stmt (stmt);\n+}\n+\n /* For all elements of CLAUSES, validate them vs OpenMP constraints.\n    Remove any elements from the list that are invalid.  */\n \n@@ -8856,6 +8888,8 @@ c_finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_COLLAPSE:\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n "}, {"sha": "936db240b429eed4f7613e9672bc92c7f0be13dd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,3 +1,70 @@\n+2008-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (cxx_omp_finish_clause, cxx_omp_create_clause_info,\n+\tdependent_omp_for_p, begin_omp_task, finish_omp_task,\n+\tfinish_omp_taskwait): New prototypes.\n+\t(cxx_omp_clause_default_ctor): Add outer argument.\n+\t(finish_omp_for): Add new clauses argument.\n+\t* cp-gimplify.c (cxx_omp_finish_clause): New function.\n+\t(cxx_omp_predetermined_sharing): Moved from semantics.c, rewritten.\n+\t(cxx_omp_clause_default_ctor): Add outer argument.\n+\t(cp_genericize_r): Walk OMP_CLAUSE_LASTPRIVATE_STMT.\n+\t* cp-objcp-common.h (LANG_HOOKS_OMP_FINISH_CLAUSE): Define.\n+\t* parser.c (cp_parser_omp_for_loop): Parse collapsed for loops.\n+\tAdd par_clauses argument.  If decl is present in parallel's\n+\tlastprivate clause, change that clause to shared and add\n+\ta lastprivate clause for decl to OMP_FOR_CLAUSES.\n+\tFix wording of error messages.  Adjust finish_omp_for caller.\n+\tAdd clauses argument.  Parse loops with random access iterators.\n+\t(cp_parser_omp_clause_collapse, cp_parser_omp_clause_untied): New\n+\tfunctions.\n+\t(cp_parser_omp_for, cp_parser_omp_parallel): Adjust\n+\tcp_parser_omp_for_loop callers.\n+\t(cp_parser_omp_for_cond, cp_parser_omp_for_incr): New helper\n+\tfunctions.\n+\t(cp_parser_omp_clause_name): Handle collapse and untied\n+\tclauses.\n+\t(cp_parser_omp_clause_schedule): Handle auto schedule.\n+\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_COLLAPSE\n+\tand PRAGMA_OMP_CLAUSE_UNTIED.\n+\t(OMP_FOR_CLAUSE_MASK): Add PRAGMA_OMP_CLAUSE_COLLAPSE.\n+\t(OMP_TASK_CLAUSE_MASK): Define.\n+\t(cp_parser_omp_task, cp_parser_omp_taskwait): New functions.\n+\t(cp_parser_omp_construct): Handle PRAGMA_OMP_TASK.\n+\t(cp_parser_pragma): Handle PRAGMA_OMP_TASK and\n+\tPRAGMA_OMP_TASKWAIT.\n+\t* pt.c (tsubst_omp_clauses): Handle OMP_CLAUSE_COLLAPSE and\n+\tOMP_CLAUSE_UNTIED.  Handle OMP_CLAUSE_LASTPRIVATE_STMT.\n+\t(tsubst_omp_for_iterator): New function.\n+\t(dependent_omp_for_p): New function.\n+\t(tsubst_expr) <case OMP_FOR>: Use it.  Handle collapsed OMP_FOR\n+\tloops.  Adjust finish_omp_for caller.  Handle loops with random\n+\taccess iterators.  Adjust for OMP_FOR_{INIT,COND,INCR} changes.\n+\t(tsubst_expr): Handle OMP_TASK.\n+\t* semantics.c (cxx_omp_create_clause_info): New function.\n+\t(finish_omp_clauses): Call it.  Handle OMP_CLAUSE_UNTIED and\n+\tOMP_CLAUSE_COLLAPSE.\n+\t(cxx_omp_predetermined_sharing): Removed.\n+\t* semantics.c (finish_omp_for): Allow pointer iterators.  Use\n+\thandle_omp_for_class_iterator and dependent_omp_for_p.  Handle\n+\tcollapsed for loops.  Adjust c_finish_omp_for caller.  Add new\n+\tclauses argument.  Fix check for type dependent cond or incr.\n+\tSet OMP_FOR_CLAUSES to clauses.  Use cp_convert instead of\n+\tfold_convert to convert incr amount to difference_type.  Only\n+\tfold if not in template.  If decl is mentioned in lastprivate\n+\tclause, set OMP_CLAUSE_LASTPRIVATE_STMT.  Handle loops with random\n+\taccess iterators.  Adjust for OMP_FOR_{INIT,COND,INCR}\n+\tchanges.\n+\t(finish_omp_threadprivate): Allow static class members of the\n+\tcurrent class.\n+\t(handle_omp_for_class_iterator, begin_omp_task, finish_omp_task,\n+\tfinish_omp_taskwait): New functions.\n+\n+\t* parser.c (cp_parser_binary_expression): Add prec argument.\n+\t(cp_parser_assignment_expression): Adjust caller.\n+\t* cp-tree.h (outer_curly_brace_block): New prototype.\n+\t* decl.c (outer_curly_brace_block): No longer static.\n+\n 2008-06-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n         PR c++/36404"}, {"sha": "1d54e7cb43ecf69df6e41d66f6f30cf82672f507", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -333,7 +333,7 @@ build_call_a (tree function, int n, tree *argarray)\n   nothrow = ((decl && TREE_NOTHROW (decl))\n \t     || TYPE_NOTHROW_P (TREE_TYPE (TREE_TYPE (function))));\n \n-  if (decl && TREE_THIS_VOLATILE (decl) && cfun)\n+  if (decl && TREE_THIS_VOLATILE (decl) && cfun && cp_function_chain)\n     current_function_returns_abnormally = 1;\n \n   if (decl && TREE_DEPRECATED (decl))"}, {"sha": "c6d64dfbb752dc81e89f9d1170c24f500db83f20", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -694,10 +694,19 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n   else if (TREE_CODE (stmt) == OMP_CLAUSE)\n     switch (OMP_CLAUSE_CODE (stmt))\n       {\n+      case OMP_CLAUSE_LASTPRIVATE:\n+\t/* Don't dereference an invisiref in OpenMP clauses.  */\n+\tif (is_invisiref_parm (OMP_CLAUSE_DECL (stmt)))\n+\t  {\n+\t    *walk_subtrees = 0;\n+\t    if (OMP_CLAUSE_LASTPRIVATE_STMT (stmt))\n+\t      cp_walk_tree (&OMP_CLAUSE_LASTPRIVATE_STMT (stmt),\n+\t\t\t    cp_genericize_r, p_set, NULL);\n+\t  }\n+\tbreak;\n       case OMP_CLAUSE_PRIVATE:\n       case OMP_CLAUSE_SHARED:\n       case OMP_CLAUSE_FIRSTPRIVATE:\n-      case OMP_CLAUSE_LASTPRIVATE:\n       case OMP_CLAUSE_COPYIN:\n       case OMP_CLAUSE_COPYPRIVATE:\n \t/* Don't dereference an invisiref in OpenMP clauses.  */\n@@ -893,7 +902,8 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n    NULL if there's nothing to do.  */\n \n tree\n-cxx_omp_clause_default_ctor (tree clause, tree decl)\n+cxx_omp_clause_default_ctor (tree clause, tree decl,\n+\t\t\t     tree outer ATTRIBUTE_UNUSED)\n {\n   tree info = CP_OMP_CLAUSE_INFO (clause);\n   tree ret = NULL;\n@@ -958,3 +968,100 @@ cxx_omp_privatize_by_reference (const_tree decl)\n {\n   return is_invisiref_parm (decl);\n }\n+\n+/* True if OpenMP sharing attribute of DECL is predetermined.  */\n+\n+enum omp_clause_default_kind\n+cxx_omp_predetermined_sharing (tree decl)\n+{\n+  tree type;\n+\n+  /* Static data members are predetermined as shared.  */\n+  if (TREE_STATIC (decl))\n+    {\n+      tree ctx = CP_DECL_CONTEXT (decl);\n+      if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))\n+\treturn OMP_CLAUSE_DEFAULT_SHARED;\n+    }\n+\n+  type = TREE_TYPE (decl);\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      if (!is_invisiref_parm (decl))\n+\treturn OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+      type = TREE_TYPE (type);\n+\n+      if (TREE_CODE (decl) == RESULT_DECL && DECL_NAME (decl))\n+\t{\n+\t  /* NVR doesn't preserve const qualification of the\n+\t     variable's type.  */\n+\t  tree outer = outer_curly_brace_block (current_function_decl);\n+\t  tree var;\n+\n+\t  if (outer)\n+\t    for (var = BLOCK_VARS (outer); var; var = TREE_CHAIN (var))\n+\t      if (DECL_NAME (decl) == DECL_NAME (var)\n+\t\t  && (TYPE_MAIN_VARIANT (type)\n+\t\t      == TYPE_MAIN_VARIANT (TREE_TYPE (var))))\n+\t\t{\n+\t\t  if (TYPE_READONLY (TREE_TYPE (var)))\n+\t\t    type = TREE_TYPE (var);\n+\t\t  break;\n+\t\t}\n+\t}\n+    }\n+\n+  if (type == error_mark_node)\n+    return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+\n+  /* Variables with const-qualified type having no mutable member\n+     are predetermined shared.  */\n+  if (TYPE_READONLY (type) && !cp_has_mutable_p (type))\n+    return OMP_CLAUSE_DEFAULT_SHARED;\n+\n+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+}\n+\n+/* Finalize an implicitly determined clause.  */\n+\n+void\n+cxx_omp_finish_clause (tree c)\n+{\n+  tree decl, inner_type;\n+  bool make_shared = false;\n+\n+  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)\n+    return;\n+\n+  decl = OMP_CLAUSE_DECL (c);\n+  decl = require_complete_type (decl);\n+  inner_type = TREE_TYPE (decl);\n+  if (decl == error_mark_node)\n+    make_shared = true;\n+  else if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n+    {\n+      if (is_invisiref_parm (decl))\n+\tinner_type = TREE_TYPE (inner_type);\n+      else\n+\t{\n+\t  error (\"%qE implicitly determined as %<firstprivate%> has reference type\",\n+\t\t decl);\n+\t  make_shared = true;\n+\t}\n+    }\n+\n+  /* We're interested in the base element, not arrays.  */\n+  while (TREE_CODE (inner_type) == ARRAY_TYPE)\n+    inner_type = TREE_TYPE (inner_type);\n+\n+  /* Check for special function availability by building a call to one.\n+     Save the results, because later we won't be in the right context\n+     for making these queries.  */\n+  if (!make_shared\n+      && CLASS_TYPE_P (inner_type)\n+      && cxx_omp_create_clause_info (c, inner_type, false, true, false))\n+    make_shared = true;\n+\n+  if (make_shared)\n+    OMP_CLAUSE_CODE (c) = OMP_CLAUSE_SHARED;\n+}"}, {"sha": "1121eb0847949e32e6469940ae36e8a80d22136e", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -141,6 +141,8 @@ extern tree objcp_tsubst_copy_and_build (tree, tree, tsubst_flags_t,\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP cxx_omp_clause_assign_op\n #undef LANG_HOOKS_OMP_CLAUSE_DTOR\n #define LANG_HOOKS_OMP_CLAUSE_DTOR cxx_omp_clause_dtor\n+#undef LANG_HOOKS_OMP_FINISH_CLAUSE\n+#define LANG_HOOKS_OMP_FINISH_CLAUSE cxx_omp_finish_clause\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE cxx_omp_privatize_by_reference\n "}, {"sha": "952020ad0457981cc7511c43318f9a5a680b1f39", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -4235,6 +4235,7 @@ extern void start_preparsed_function\t\t(tree, tree, int);\n extern int start_function\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, tree);\n extern tree begin_function_body\t\t\t(void);\n extern void finish_function_body\t\t(tree);\n+extern tree outer_curly_brace_block\t\t(tree);\n extern tree finish_function\t\t\t(int);\n extern tree start_method\t\t\t(cp_decl_specifier_seq *, const cp_declarator *, tree);\n extern tree finish_method\t\t\t(tree);\n@@ -4468,6 +4469,7 @@ extern bool type_dependent_expression_p\t\t(tree);\n extern bool any_type_dependent_arguments_p      (const_tree);\n extern bool value_dependent_expression_p\t(tree);\n extern bool any_value_dependent_elements_p      (const_tree);\n+extern bool dependent_omp_for_p\t\t\t(tree, tree, tree, tree);\n extern tree resolve_typename_type\t\t(tree, bool);\n extern tree template_for_substitution\t\t(tree);\n extern tree build_non_dependent_expr\t\t(tree);\n@@ -4666,17 +4668,22 @@ extern tree begin_omp_structured_block\t\t(void);\n extern tree finish_omp_structured_block\t\t(tree);\n extern tree begin_omp_parallel\t\t\t(void);\n extern tree finish_omp_parallel\t\t\t(tree, tree);\n+extern tree begin_omp_task\t\t\t(void);\n+extern tree finish_omp_task\t\t\t(tree, tree);\n extern tree finish_omp_for\t\t\t(location_t, tree, tree,\n-\t\t\t\t\t\t tree, tree, tree, tree);\n+\t\t\t\t\t\t tree, tree, tree, tree, tree);\n extern void finish_omp_atomic\t\t\t(enum tree_code, tree, tree);\n extern void finish_omp_barrier\t\t\t(void);\n extern void finish_omp_flush\t\t\t(void);\n+extern void finish_omp_taskwait\t\t\t(void);\n extern enum omp_clause_default_kind cxx_omp_predetermined_sharing (tree);\n-extern tree cxx_omp_clause_default_ctor\t\t(tree, tree);\n+extern tree cxx_omp_clause_default_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_copy_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_assign_op\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n+extern void cxx_omp_finish_clause\t\t(tree);\n extern bool cxx_omp_privatize_by_reference\t(const_tree);\n+extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool, bool);\n extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n                                                  bool);"}, {"sha": "8056518e746b7a440edc132635f01209bcf80448", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -11759,7 +11759,7 @@ finish_function_body (tree compstmt)\n    of curly braces, skipping the artificial block created for constructor\n    initializers.  */\n \n-static tree\n+tree\n outer_curly_brace_block (tree fndecl)\n {\n   tree block = BLOCK_SUBBLOCKS (DECL_INITIAL (fndecl));"}, {"sha": "5ca1bd7e5334dfa49543c3e220f9ca2eb9bebfd1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 598, "deletions": 78, "changes": 676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1611,7 +1611,7 @@ static tree cp_parser_delete_expression\n static tree cp_parser_cast_expression\n   (cp_parser *, bool, bool);\n static tree cp_parser_binary_expression\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, enum cp_parser_prec);\n static tree cp_parser_question_colon_clause\n   (cp_parser *, tree);\n static tree cp_parser_assignment_expression\n@@ -6008,14 +6008,15 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n  : binops_by_token[token->type].prec)\n \n static tree\n-cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n+cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n+\t\t\t     enum cp_parser_prec prec)\n {\n   cp_parser_expression_stack stack;\n   cp_parser_expression_stack_entry *sp = &stack[0];\n   tree lhs, rhs;\n   cp_token *token;\n   enum tree_code tree_type, lhs_type, rhs_type;\n-  enum cp_parser_prec prec = PREC_NOT_OPERATOR, new_prec, lookahead_prec;\n+  enum cp_parser_prec new_prec, lookahead_prec;\n   bool overloaded_p;\n \n   /* Parse the first expression.  */\n@@ -6192,7 +6193,7 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p)\n   else\n     {\n       /* Parse the binary expressions (logical-or-expression).  */\n-      expr = cp_parser_binary_expression (parser, cast_p);\n+      expr = cp_parser_binary_expression (parser, cast_p, PREC_NOT_OPERATOR);\n       /* If the next token is a `?' then we're actually looking at a\n \t conditional-expression.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n@@ -19493,7 +19494,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n       switch (p[0])\n \t{\n \tcase 'c':\n-\t  if (!strcmp (\"copyin\", p))\n+\t  if (!strcmp (\"collapse\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_COLLAPSE;\n+\t  else if (!strcmp (\"copyin\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYIN;\n \t  else if (!strcmp (\"copyprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n@@ -19526,6 +19529,10 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t  else if (!strcmp (\"shared\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SHARED;\n \t  break;\n+\tcase 'u':\n+\t  if (!strcmp (\"untied\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_UNTIED;\n+\t  break;\n \t}\n     }\n \n@@ -19628,6 +19635,47 @@ cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n   return list;\n }\n \n+/* OpenMP 3.0:\n+   collapse ( constant-expression ) */\n+\n+static tree\n+cp_parser_omp_clause_collapse (cp_parser *parser, tree list)\n+{\n+  tree c, num;\n+  location_t loc;\n+  HOST_WIDE_INT n;\n+\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+    return list;\n+\n+  num = cp_parser_constant_expression (parser, false, NULL);\n+\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  if (num == error_mark_node)\n+    return list;\n+  num = fold_non_dependent_expr (num);\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (num))\n+      || !host_integerp (num, 0)\n+      || (n = tree_low_cst (num, 0)) <= 0\n+      || (int) n != n)\n+    {\n+      error (\"%Hcollapse argument needs positive constant integer expression\", &loc);\n+      return list;\n+    }\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\");\n+  c = build_omp_clause (OMP_CLAUSE_COLLAPSE);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  OMP_CLAUSE_COLLAPSE_EXPR (c) = num;\n+\n+  return c;\n+}\n+\n /* OpenMP 2.5:\n    default ( shared | none ) */\n \n@@ -19839,7 +19887,7 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n    schedule ( schedule-kind , expression )\n \n    schedule-kind:\n-     static | dynamic | guided | runtime  */\n+     static | dynamic | guided | runtime | auto  */\n \n static tree\n cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n@@ -19882,6 +19930,8 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n     }\n   else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_STATIC))\n     OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AUTO))\n+    OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_AUTO;\n   else\n     goto invalid_kind;\n   cp_lexer_consume_token (parser->lexer);\n@@ -19897,6 +19947,9 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n \terror (\"schedule %<runtime%> does not take \"\n \t       \"a %<chunk_size%> parameter\");\n+      else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)\n+\terror (\"schedule %<auto%> does not take \"\n+\t       \"a %<chunk_size%> parameter\");\n       else\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n \n@@ -19919,6 +19972,21 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n   return list;\n }\n \n+/* OpenMP 3.0:\n+   untied */\n+\n+static tree\n+cp_parser_omp_clause_untied (cp_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  tree c;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, \"untied\");\n+\n+  c = build_omp_clause (OMP_CLAUSE_UNTIED);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n /* Parse all OpenMP clauses.  The set clauses allowed by the directive\n    is a bitmask in MASK.  Return the list of clauses found; the result\n    of clause default goes in *pdefault.  */\n@@ -19944,6 +20012,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \n       switch (c_kind)\n \t{\n+\tcase PRAGMA_OMP_CLAUSE_COLLAPSE:\n+\t  clauses = cp_parser_omp_clause_collapse (parser, clauses);\n+\t  c_name = \"collapse\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_COPYIN:\n \t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_COPYIN, clauses);\n \t  c_name = \"copyin\";\n@@ -20001,6 +20073,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t\t\t\t\t    clauses);\n \t  c_name = \"shared\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_UNTIED:\n+\t  clauses = cp_parser_omp_clause_untied (parser, clauses);\n+\t  c_name = \"nowait\";\n+\t  break;\n \tdefault:\n \t  cp_parser_error (parser, \"expected %<#pragma omp%> clause\");\n \t  goto saw_error;\n@@ -20210,94 +20286,454 @@ cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n   finish_omp_flush ();\n }\n \n-/* Parse the restricted form of the for statment allowed by OpenMP.  */\n+/* Helper function, to parse omp for increment expression.  */\n \n static tree\n-cp_parser_omp_for_loop (cp_parser *parser)\n+cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n {\n-  tree init, cond, incr, body, decl, pre_body;\n-  location_t loc;\n+  tree lhs = cp_parser_cast_expression (parser, false, false), rhs;\n+  enum tree_code op;\n+  cp_token *token;\n \n-  if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n+  if (lhs != decl)\n     {\n-      cp_parser_error (parser, \"for statement expected\");\n-      return NULL;\n+      cp_parser_skip_to_end_of_statement (parser);\n+      return error_mark_node;\n     }\n-  loc = cp_lexer_consume_token (parser->lexer)->location;\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n-    return NULL;\n \n-  init = decl = NULL;\n-  pre_body = push_stmt_list ();\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+  token = cp_lexer_peek_token (parser->lexer);\n+  op = binops_by_token [token->type].tree_type;\n+  switch (op)\n+    {\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      break;\n+    default:\n+      cp_parser_skip_to_end_of_statement (parser);\n+      return error_mark_node;\n+    }\n+\n+  cp_lexer_consume_token (parser->lexer);\n+  rhs = cp_parser_binary_expression (parser, false,\n+\t\t\t\t     PREC_RELATIONAL_EXPRESSION);\n+  if (rhs == error_mark_node\n+      || cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     {\n-      cp_decl_specifier_seq type_specifiers;\n+      cp_parser_skip_to_end_of_statement (parser);\n+      return error_mark_node;\n+    }\n \n-      /* First, try to parse as an initialized declaration.  See\n-\t cp_parser_condition, from whence the bulk of this is copied.  */\n+  return build2 (op, boolean_type_node, lhs, rhs);\n+}\n \n-      cp_parser_parse_tentatively (parser);\n-      cp_parser_type_specifier_seq (parser, /*is_condition=*/false,\n-\t\t\t\t    &type_specifiers);\n-      if (!cp_parser_error_occurred (parser))\n+/* Helper function, to parse omp for increment expression.  */\n+\n+static tree\n+cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  enum tree_code op;\n+  tree lhs, rhs;\n+  cp_id_kind idk;\n+  bool decl_first;\n+\n+  if (token->type == CPP_PLUS_PLUS || token->type == CPP_MINUS_MINUS)\n+    {\n+      op = (token->type == CPP_PLUS_PLUS\n+\t    ? PREINCREMENT_EXPR : PREDECREMENT_EXPR);\n+      cp_lexer_consume_token (parser->lexer);\n+      lhs = cp_parser_cast_expression (parser, false, false);\n+      if (lhs != decl)\n+\treturn error_mark_node;\n+      return build2 (op, TREE_TYPE (decl), decl, NULL_TREE);\n+    }\n+\n+  lhs = cp_parser_primary_expression (parser, false, false, false, &idk);\n+  if (lhs != decl)\n+    return error_mark_node;\n+\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_PLUS_PLUS || token->type == CPP_MINUS_MINUS)\n+    {\n+      op = (token->type == CPP_PLUS_PLUS\n+\t    ? POSTINCREMENT_EXPR : POSTDECREMENT_EXPR);\n+      cp_lexer_consume_token (parser->lexer);\n+      return build2 (op, TREE_TYPE (decl), decl, NULL_TREE);\n+    }\n+\n+  op = cp_parser_assignment_operator_opt (parser);\n+  if (op == ERROR_MARK)\n+    return error_mark_node;\n+\n+  if (op != NOP_EXPR)\n+    {\n+      rhs = cp_parser_assignment_expression (parser, false);\n+      rhs = build2 (op, TREE_TYPE (decl), decl, rhs);\n+      return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);\n+    }\n+\n+  lhs = cp_parser_binary_expression (parser, false,\n+\t\t\t\t     PREC_ADDITIVE_EXPRESSION);\n+  token = cp_lexer_peek_token (parser->lexer);\n+  decl_first = lhs == decl;\n+  if (decl_first)\n+    lhs = NULL_TREE;\n+  if (token->type != CPP_PLUS\n+      && token->type != CPP_MINUS)\n+    return error_mark_node;\n+\n+  do\n+    {\n+      op = token->type == CPP_PLUS ? PLUS_EXPR : MINUS_EXPR;\n+      cp_lexer_consume_token (parser->lexer);\n+      rhs = cp_parser_binary_expression (parser, false,\n+\t\t\t\t\t PREC_ADDITIVE_EXPRESSION);\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_PLUS || token->type == CPP_MINUS || decl_first)\n \t{\n-\t  tree asm_specification, attributes;\n-\t  cp_declarator *declarator;\n-\n-\t  declarator = cp_parser_declarator (parser,\n-\t\t\t\t\t     CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t     /*ctor_dtor_or_conv_p=*/NULL,\n-\t\t\t\t\t     /*parenthesized_p=*/NULL,\n-\t\t\t\t\t     /*member_p=*/false);\n-\t  attributes = cp_parser_attributes_opt (parser);\n-\t  asm_specification = cp_parser_asm_specification_opt (parser);\n+\t  if (lhs == NULL_TREE)\n+\t    {\n+\t      if (op == PLUS_EXPR)\n+\t\tlhs = rhs;\n+\t      else\n+\t\tlhs = build_x_unary_op (NEGATE_EXPR, rhs, tf_warning_or_error);\n+\t    }\n+\t  else\n+\t    lhs = build_x_binary_op (op, lhs, ERROR_MARK, rhs, ERROR_MARK,\n+\t\t\t\t     NULL, tf_warning_or_error);\n+\t}\n+    }\n+  while (token->type == CPP_PLUS || token->type == CPP_MINUS);\n \n-\t  cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n-\t  if (cp_parser_parse_definitely (parser))\n+  if (!decl_first)\n+    {\n+      if (rhs != decl || op == MINUS_EXPR)\n+\treturn error_mark_node;\n+      rhs = build2 (op, TREE_TYPE (decl), lhs, decl);\n+    }\n+  else\n+    rhs = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, lhs);\n+\n+  return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);\n+}\n+\n+/* Parse the restricted form of the for statment allowed by OpenMP.  */\n+\n+static tree\n+cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n+{\n+  tree init, cond, incr, body, decl, pre_body = NULL_TREE, ret;\n+  tree for_block = NULL_TREE, real_decl, initv, condv, incrv, declv;\n+  tree this_pre_body, cl;\n+  location_t loc_first;\n+  bool collapse_err = false;\n+  int i, collapse = 1, nbraces = 0;\n+\n+  for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n+    if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n+      collapse = tree_low_cst (OMP_CLAUSE_COLLAPSE_EXPR (cl), 0);\n+\n+  gcc_assert (collapse >= 1);\n+\n+  declv = make_tree_vec (collapse);\n+  initv = make_tree_vec (collapse);\n+  condv = make_tree_vec (collapse);\n+  incrv = make_tree_vec (collapse);\n+\n+  loc_first = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  for (i = 0; i < collapse; i++)\n+    {\n+      int bracecount = 0;\n+      bool add_private_clause = false;\n+      location_t loc;\n+\n+      if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n+\t{\n+\t  cp_parser_error (parser, \"for statement expected\");\n+\t  return NULL;\n+\t}\n+      loc = cp_lexer_consume_token (parser->lexer)->location;\n+\n+      if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n+\treturn NULL;\n+\n+      init = decl = real_decl = NULL;\n+      this_pre_body = push_stmt_list ();\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+\t{\n+\t  cp_decl_specifier_seq type_specifiers;\n+\n+\t  /* First, try to parse as an initialized declaration.  See\n+\t     cp_parser_condition, from whence the bulk of this is copied.  */\n+\n+\t  cp_parser_parse_tentatively (parser);\n+\t  cp_parser_type_specifier_seq (parser, /*is_condition=*/false,\n+\t\t\t\t\t&type_specifiers);\n+\t  if (!cp_parser_error_occurred (parser))\n \t    {\n-\t      tree pushed_scope;\n+\t      tree asm_specification, attributes;\n+\t      cp_declarator *declarator;\n+\n+\t      declarator = cp_parser_declarator (parser,\n+\t\t\t\t\t\t CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t\t\t /*parenthesized_p=*/NULL,\n+\t\t\t\t\t\t /*member_p=*/false);\n+\t      attributes = cp_parser_attributes_opt (parser);\n+\t      asm_specification = cp_parser_asm_specification_opt (parser);\n+\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n+\t\tcp_parser_require (parser, CPP_EQ, \"%<=%>\");\n+\t      if (cp_parser_parse_definitely (parser))\n+\t\t{\n+\t\t  tree pushed_scope;\n+\n+\t\t  decl = start_decl (declarator, &type_specifiers,\n+\t\t\t\t     /*initialized_p=*/false, attributes,\n+\t\t\t\t     /*prefix_attributes=*/NULL_TREE,\n+\t\t\t\t     &pushed_scope);\n+\n+\t\t  if (CLASS_TYPE_P (TREE_TYPE (decl))\n+\t\t      || type_dependent_expression_p (decl))\n+\t\t    {\n+\t\t      bool is_parenthesized_init, is_non_constant_init;\n+\n+\t\t      init = cp_parser_initializer (parser,\n+\t\t\t\t\t\t    &is_parenthesized_init,\n+\t\t\t\t\t\t    &is_non_constant_init);\n+\n+\t\t      cp_finish_decl (decl, init, !is_non_constant_init,\n+\t\t\t\t      asm_specification,\n+\t\t\t\t      LOOKUP_ONLYCONVERTING);\n+\t\t      if (CLASS_TYPE_P (TREE_TYPE (decl)))\n+\t\t\t{\n+\t\t\t  for_block\n+\t\t\t    = tree_cons (NULL, this_pre_body, for_block);\n+\t\t\t  init = NULL_TREE;\n+\t\t\t}\n+\t\t      else\n+\t\t\tinit = pop_stmt_list (this_pre_body);\n+\t\t      this_pre_body = NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n+\t\t      init = cp_parser_assignment_expression (parser, false);\n \n-\t      decl = start_decl (declarator, &type_specifiers,\n-\t\t\t\t /*initialized_p=*/false, attributes,\n-\t\t\t\t /*prefix_attributes=*/NULL_TREE,\n-\t\t\t\t &pushed_scope);\n+\t\t      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n+\t\t\tinit = error_mark_node;\n+\t\t      else\n+\t\t\tcp_finish_decl (decl, NULL_TREE,\n+\t\t\t\t\t/*init_const_expr_p=*/false,\n+\t\t\t\t\tasm_specification,\n+\t\t\t\t\tLOOKUP_ONLYCONVERTING);\n+\t\t    }\n \n-\t      init = cp_parser_assignment_expression (parser, false);\n+\t\t  if (pushed_scope)\n+\t\t    pop_scope (pushed_scope);\n+\t\t}\n+\t    }\n+\t  else\n+\t    cp_parser_abort_tentative_parse (parser);\n \n-\t      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n-\t\tinit = error_mark_node;\n+\t  /* If parsing as an initialized declaration failed, try again as\n+\t     a simple expression.  */\n+\t  if (decl == NULL)\n+\t    {\n+\t      cp_id_kind idk;\n+\t      cp_parser_parse_tentatively (parser);\n+\t      decl = cp_parser_primary_expression (parser, false, false,\n+\t\t\t\t\t\t   false, &idk);\n+\t      if (!cp_parser_error_occurred (parser)\n+\t\t  && decl\n+\t\t  && DECL_P (decl)\n+\t\t  && CLASS_TYPE_P (TREE_TYPE (decl)))\n+\t\t{\n+\t\t  tree rhs;\n+\n+\t\t  cp_parser_parse_definitely (parser);\n+\t\t  cp_parser_require (parser, CPP_EQ, \"%<=%>\");\n+\t\t  rhs = cp_parser_assignment_expression (parser, false);\n+\t\t  finish_expr_stmt (build_x_modify_expr (decl, NOP_EXPR,\n+\t\t\t\t\t\t\t rhs,\n+\t\t\t\t\t\t\t tf_warning_or_error));\n+\t\t  add_private_clause = true;\n+\t\t}\n \t      else\n-\t\tcp_finish_decl (decl, NULL_TREE, /*init_const_expr_p=*/false,\n-\t\t\t\tasm_specification, LOOKUP_ONLYCONVERTING);\n+\t\t{\n+\t\t  decl = NULL;\n+\t\t  cp_parser_abort_tentative_parse (parser);\n+\t\t  init = cp_parser_expression (parser, false);\n+\t\t  if (init)\n+\t\t    {\n+\t\t      if (TREE_CODE (init) == MODIFY_EXPR\n+\t\t\t  || TREE_CODE (init) == MODOP_EXPR)\n+\t\t\treal_decl = TREE_OPERAND (init, 0);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+      if (this_pre_body)\n+\t{\n+\t  this_pre_body = pop_stmt_list (this_pre_body);\n+\t  if (pre_body)\n+\t    {\n+\t      tree t = pre_body;\n+\t      pre_body = push_stmt_list ();\n+\t      add_stmt (t);\n+\t      add_stmt (this_pre_body);\n+\t      pre_body = pop_stmt_list (pre_body);\n+\t    }\n+\t  else\n+\t    pre_body = this_pre_body;\n+\t}\n \n-\t      if (pushed_scope)\n-\t\tpop_scope (pushed_scope);\n+      if (decl)\n+\treal_decl = decl;\n+      if (par_clauses != NULL && real_decl != NULL_TREE)\n+\t{\n+\t  tree *c;\n+\t  for (c = par_clauses; *c ; )\n+\t    if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t&& OMP_CLAUSE_DECL (*c) == real_decl)\n+\t      {\n+\t\terror (\"%Hiteration variable %qD should not be firstprivate\",\n+\t\t       &loc, real_decl);\n+\t\t*c = OMP_CLAUSE_CHAIN (*c);\n+\t      }\n+\t    else if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t     && OMP_CLAUSE_DECL (*c) == real_decl)\n+\t      {\n+\t\t/* Add lastprivate (decl) clause to OMP_FOR_CLAUSES,\n+\t\t   change it to shared (decl) in OMP_PARALLEL_CLAUSES.  */\n+\t\ttree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);\n+\t\tOMP_CLAUSE_DECL (l) = real_decl;\n+\t\tOMP_CLAUSE_CHAIN (l) = clauses;\n+\t\tCP_OMP_CLAUSE_INFO (l) = CP_OMP_CLAUSE_INFO (*c);\n+\t\tclauses = l;\n+\t\tOMP_CLAUSE_SET_CODE (*c, OMP_CLAUSE_SHARED);\n+\t\tCP_OMP_CLAUSE_INFO (*c) = NULL;\n+\t\tadd_private_clause = false;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_PRIVATE\n+\t\t    && OMP_CLAUSE_DECL (*c) == real_decl)\n+\t\t  add_private_clause = false;\n+\t\tc = &OMP_CLAUSE_CHAIN (*c);\n+\t      }\n+\t}\n+\n+      if (add_private_clause)\n+\t{\n+\t  tree c;\n+\t  for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+\t    {\n+\t      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t\t  && OMP_CLAUSE_DECL (c) == decl)\n+\t\tbreak;\n+\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t       && OMP_CLAUSE_DECL (c) == decl)\n+\t\terror (\"%Hiteration variable %qD should not be firstprivate\",\n+\t\t       &loc, decl);\n+\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t       && OMP_CLAUSE_DECL (c) == decl)\n+\t\terror (\"%Hiteration variable %qD should not be reduction\",\n+\t\t       &loc, decl);\n+\t    }\n+\t  if (c == NULL)\n+\t    {\n+\t      c = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = decl;\n+\t      c = finish_omp_clauses (c);\n+\t      if (c)\n+\t\t{\n+\t\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t\t  clauses = c;\n+\t\t}\n \t    }\n \t}\n-      else\n-\tcp_parser_abort_tentative_parse (parser);\n \n-      /* If parsing as an initialized declaration failed, try again as\n-\t a simple expression.  */\n-      if (decl == NULL)\n-\tinit = cp_parser_expression (parser, false);\n-    }\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n-  pre_body = pop_stmt_list (pre_body);\n+      cond = NULL;\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+\t{\n+\t  /* If decl is an iterator, preserve LHS and RHS of the relational\n+\t     expr until finish_omp_for.  */\n+\t  if (decl\n+\t      && (type_dependent_expression_p (decl)\n+\t\t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n+\t    cond = cp_parser_omp_for_cond (parser, decl);\n+\t  else\n+\t    cond = cp_parser_condition (parser);\n+\t}\n+      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n \n-  cond = NULL;\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    cond = cp_parser_condition (parser);\n-  cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n+      incr = NULL;\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+\t{\n+\t  /* If decl is an iterator, preserve the operator on decl\n+\t     until finish_omp_for.  */\n+\t  if (decl\n+\t      && (type_dependent_expression_p (decl)\n+\t\t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n+\t    incr = cp_parser_omp_for_incr (parser, decl);\n+\t  else\n+\t    incr = cp_parser_expression (parser, false);\n+\t}\n \n-  incr = NULL;\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-    incr = cp_parser_expression (parser, false);\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+\tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t       /*consume_paren=*/true);\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n-    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n-\t\t\t\t\t   /*or_comma=*/false,\n-\t\t\t\t\t   /*consume_paren=*/true);\n+      TREE_VEC_ELT (declv, i) = decl;\n+      TREE_VEC_ELT (initv, i) = init;\n+      TREE_VEC_ELT (condv, i) = cond;\n+      TREE_VEC_ELT (incrv, i) = incr;\n+\n+      if (i == collapse - 1)\n+\tbreak;\n+\n+      /* FIXME: OpenMP 3.0 draft isn't very clear on what exactly is allowed\n+\t in between the collapsed for loops to be still considered perfectly\n+\t nested.  Hopefully the final version clarifies this.\n+\t For now handle (multiple) {'s and empty statements.  */\n+      cp_parser_parse_tentatively (parser);\n+      do\n+\t{\n+\t  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n+\t    break;\n+\t  else if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      bracecount++;\n+\t    }\n+\t  else if (bracecount\n+\t\t   && cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  else\n+\t    {\n+\t      loc = cp_lexer_peek_token (parser->lexer)->location;\n+\t      error (\"%Hnot enough collapsed for loops\", &loc);\n+\t      collapse_err = true;\n+\t      cp_parser_abort_tentative_parse (parser);\n+\t      declv = NULL_TREE;\n+\t      break;\n+\t    }\n+\t}\n+      while (1);\n+\n+      if (declv)\n+\t{\n+\t  cp_parser_parse_definitely (parser);\n+\t  nbraces += bracecount;\n+\t}\n+    }\n \n   /* Note that we saved the original contents of this flag when we entered\n      the structured block, and so we don't need to re-save it here.  */\n@@ -20309,7 +20745,38 @@ cp_parser_omp_for_loop (cp_parser *parser)\n   cp_parser_statement (parser, NULL_TREE, false, NULL);\n   body = pop_stmt_list (body);\n \n-  return finish_omp_for (loc, decl, init, cond, incr, body, pre_body);\n+  if (declv == NULL_TREE)\n+    ret = NULL_TREE;\n+  else\n+    ret = finish_omp_for (loc_first, declv, initv, condv, incrv, body,\n+\t\t\t  pre_body, clauses);\n+\n+  while (nbraces)\n+    {\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  nbraces--;\n+\t}\n+      else if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\t{\n+\t  if (!collapse_err)\n+\t    error (\"collapsed loops not perfectly nested\");\n+\t  collapse_err = true;\n+\t  cp_parser_statement_seq_opt (parser, NULL);\n+\t  cp_parser_require (parser, CPP_CLOSE_BRACE, \"%<}%>\");\n+\t}\n+    }\n+\n+  while (for_block)\n+    {\n+      add_stmt (pop_stmt_list (TREE_VALUE (for_block)));\n+      for_block = TREE_CHAIN (for_block);\n+    }\n+\n+  return ret;\n }\n \n /* OpenMP 2.5:\n@@ -20323,7 +20790,8 @@ cp_parser_omp_for_loop (cp_parser *parser)\n \t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_ORDERED)\t\t\\\n \t| (1u << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\t\\\n-\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_COLLAPSE))\n \n static tree\n cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok)\n@@ -20337,9 +20805,7 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok)\n   sb = begin_omp_structured_block ();\n   save = cp_parser_begin_omp_structured_block (parser);\n \n-  ret = cp_parser_omp_for_loop (parser);\n-  if (ret)\n-    OMP_FOR_CLAUSES (ret) = clauses;\n+  ret = cp_parser_omp_for_loop (parser, clauses, NULL);\n \n   cp_parser_end_omp_structured_block (parser, save);\n   add_stmt (finish_omp_structured_block (sb));\n@@ -20537,9 +21003,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok)\n \n     case PRAGMA_OMP_PARALLEL_FOR:\n       c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n-      stmt = cp_parser_omp_for_loop (parser);\n-      if (stmt)\n-\tOMP_FOR_CLAUSES (stmt) = ws_clause;\n+      cp_parser_omp_for_loop (parser, ws_clause, &par_clause);\n       break;\n \n     case PRAGMA_OMP_PARALLEL_SECTIONS:\n@@ -20584,6 +21048,43 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok)\n   return add_stmt (stmt);\n }\n \n+/* OpenMP 3.0:\n+   # pragma omp task task-clause[optseq] new-line\n+     structured-block  */\n+\n+#define OMP_TASK_CLAUSE_MASK\t\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_IF)\t\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_UNTIED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_DEFAULT)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_SHARED))\n+\n+static tree\n+cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree clauses, block;\n+  unsigned int save;\n+\n+  clauses = cp_parser_omp_all_clauses (parser, OMP_TASK_CLAUSE_MASK,\n+\t\t\t\t       \"#pragma omp task\", pragma_tok);\n+  block = begin_omp_task ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_end_omp_structured_block (parser, save);\n+  return finish_omp_task (clauses, block);\n+}\n+\n+/* OpenMP 3.0:\n+   # pragma omp taskwait new-line  */\n+\n+static void\n+cp_parser_omp_taskwait (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+  finish_omp_taskwait ();\n+}\n+\n /* OpenMP 2.5:\n    # pragma omp threadprivate (variable-list) */\n \n@@ -20631,6 +21132,9 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n     case PRAGMA_OMP_SINGLE:\n       stmt = cp_parser_omp_single (parser, pragma_tok);\n       break;\n+    case PRAGMA_OMP_TASK:\n+      stmt = cp_parser_omp_task (parser, pragma_tok);\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -20738,6 +21242,21 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t}\n       break;\n \n+    case PRAGMA_OMP_TASKWAIT:\n+      switch (context)\n+\t{\n+\tcase pragma_compound:\n+\t  cp_parser_omp_taskwait (parser, pragma_tok);\n+\t  return false;\n+\tcase pragma_stmt:\n+\t  error (\"%<#pragma omp taskwait%> may only be \"\n+\t\t \"used in compound statements\");\n+\t  break;\n+\tdefault:\n+\t  goto bad_stmt;\n+\t}\n+      break;\n+\n     case PRAGMA_OMP_THREADPRIVATE:\n       cp_parser_omp_threadprivate (parser, pragma_tok);\n       return false;\n@@ -20750,6 +21269,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n     case PRAGMA_OMP_PARALLEL:\n     case PRAGMA_OMP_SECTIONS:\n     case PRAGMA_OMP_SINGLE:\n+    case PRAGMA_OMP_TASK:\n       if (context == pragma_external)\n \tgoto bad_stmt;\n       cp_parser_omp_construct (parser, pragma_tok);"}, {"sha": "f141b74a6fd4594ac9b175f72dcf610e8e812831", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 243, "deletions": 12, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -10214,23 +10214,34 @@ tsubst_omp_clauses (tree clauses, tree args, tsubst_flags_t complain,\n \n       switch (OMP_CLAUSE_CODE (nc))\n \t{\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  if (OMP_CLAUSE_LASTPRIVATE_STMT (oc))\n+\t    {\n+\t      OMP_CLAUSE_LASTPRIVATE_STMT (nc) = push_stmt_list ();\n+\t      tsubst_expr (OMP_CLAUSE_LASTPRIVATE_STMT (oc), args, complain,\n+\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t      OMP_CLAUSE_LASTPRIVATE_STMT (nc)\n+\t\t= pop_stmt_list (OMP_CLAUSE_LASTPRIVATE_STMT (nc));\n+\t    }\n+\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n+\tcase OMP_CLAUSE_COLLAPSE:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n \t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, \n \t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n \t  break;\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_UNTIED:\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -10274,6 +10285,137 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n #undef RECUR\n }\n \n+/* Substitute one OMP_FOR iterator.  */\n+\n+static void\n+tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n+\t\t\t tree condv, tree incrv, tree *clauses,\n+\t\t\t tree args, tsubst_flags_t complain, tree in_decl,\n+\t\t\t bool integral_constant_expression_p)\n+{\n+#define RECUR(NODE)\t\t\t\t\\\n+  tsubst_expr ((NODE), args, complain, in_decl,\t\\\n+\t       integral_constant_expression_p)\n+  tree decl, init, cond, incr;\n+\n+  init = TREE_VEC_ELT (OMP_FOR_INIT (t), i);\n+  gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+  decl = RECUR (TREE_OPERAND (init, 0));\n+  init = TREE_OPERAND (init, 1);\n+  gcc_assert (!type_dependent_expression_p (decl));\n+\n+  if (!CLASS_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      cond = RECUR (TREE_VEC_ELT (OMP_FOR_COND (t), i));\n+      incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n+      if (TREE_CODE (incr) == MODIFY_EXPR)\n+\tincr = build_x_modify_expr (RECUR (TREE_OPERAND (incr, 0)), NOP_EXPR,\n+\t\t\t\t    RECUR (TREE_OPERAND (incr, 1)),\n+\t\t\t\t    complain);\n+      else\n+\tincr = RECUR (incr);\n+      TREE_VEC_ELT (declv, i) = decl;\n+      TREE_VEC_ELT (initv, i) = init;\n+      TREE_VEC_ELT (condv, i) = cond;\n+      TREE_VEC_ELT (incrv, i) = incr;\n+      return;\n+    }\n+\n+  if (init && TREE_CODE (init) != DECL_EXPR)\n+    {\n+      tree c;\n+      for (c = *clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+\t{\n+\t  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t      && OMP_CLAUSE_DECL (c) == decl)\n+\t    break;\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n+\t\t   && OMP_CLAUSE_DECL (c) == decl)\n+\t    error (\"iteration variable %qD should not be firstprivate\", decl);\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n+\t\t   && OMP_CLAUSE_DECL (c) == decl)\n+\t    error (\"iteration variable %qD should not be reduction\", decl);\n+\t}\n+      if (c == NULL)\n+\t{\n+\t  c = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t  OMP_CLAUSE_DECL (c) = decl;\n+\t  c = finish_omp_clauses (c);\n+\t  if (c)\n+\t    {\n+\t      OMP_CLAUSE_CHAIN (c) = *clauses;\n+\t      *clauses = c;\n+\t    }\n+\t}\n+    }\n+  cond = TREE_VEC_ELT (OMP_FOR_COND (t), i);\n+  if (COMPARISON_CLASS_P (cond))\n+    cond = build2 (TREE_CODE (cond), boolean_type_node,\n+\t\t   RECUR (TREE_OPERAND (cond, 0)),\n+\t\t   RECUR (TREE_OPERAND (cond, 1)));\n+  else\n+    cond = RECUR (cond);\n+  incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n+  switch (TREE_CODE (incr))\n+    {\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      incr = build2 (TREE_CODE (incr), TREE_TYPE (decl),\n+\t\t     RECUR (TREE_OPERAND (incr, 0)), NULL_TREE);\n+      break;\n+    case MODIFY_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (incr, 1)) == PLUS_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (incr, 1)) == MINUS_EXPR)\n+\t{\n+\t  tree rhs = TREE_OPERAND (incr, 1);\n+\t  incr = build2 (MODIFY_EXPR, TREE_TYPE (decl),\n+\t\t\t RECUR (TREE_OPERAND (incr, 0)),\n+\t\t\t build2 (TREE_CODE (rhs), TREE_TYPE (decl),\n+\t\t\t\t RECUR (TREE_OPERAND (rhs, 0)),\n+\t\t\t\t RECUR (TREE_OPERAND (rhs, 1))));\n+\t}\n+      else\n+\tincr = RECUR (incr);\n+      break;\n+    case MODOP_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (incr, 1)) == PLUS_EXPR\n+\t  || TREE_CODE (TREE_OPERAND (incr, 1)) == MINUS_EXPR)\n+\t{\n+\t  tree lhs = RECUR (TREE_OPERAND (incr, 0));\n+\t  incr = build2 (MODIFY_EXPR, TREE_TYPE (decl), lhs,\n+\t\t\t build2 (TREE_CODE (TREE_OPERAND (incr, 1)),\n+\t\t\t\t TREE_TYPE (decl), lhs,\n+\t\t\t\t RECUR (TREE_OPERAND (incr, 2))));\n+\t}\n+      else if (TREE_CODE (TREE_OPERAND (incr, 1)) == NOP_EXPR\n+\t       && (TREE_CODE (TREE_OPERAND (incr, 2)) == PLUS_EXPR\n+\t\t   || (TREE_CODE (TREE_OPERAND (incr, 2)) == MINUS_EXPR)))\n+\t{\n+\t  tree rhs = TREE_OPERAND (incr, 2);\n+\t  incr = build2 (MODIFY_EXPR, TREE_TYPE (decl),\n+\t\t\t RECUR (TREE_OPERAND (incr, 0)),\n+\t\t\t build2 (TREE_CODE (rhs), TREE_TYPE (decl),\n+\t\t\t\t RECUR (TREE_OPERAND (rhs, 0)),\n+\t\t\t\t RECUR (TREE_OPERAND (rhs, 1))));\n+\t}\n+      else\n+\tincr = RECUR (incr);\n+      break;\n+    default:\n+      incr = RECUR (incr);\n+      break;\n+    }\n+\n+  TREE_VEC_ELT (declv, i) = decl;\n+  TREE_VEC_ELT (initv, i) = init;\n+  TREE_VEC_ELT (condv, i) = cond;\n+  TREE_VEC_ELT (incrv, i) = incr;\n+#undef RECUR\n+}\n+\n /* Like tsubst_copy for expressions, etc. but also does semantic\n    processing.  */\n \n@@ -10597,21 +10739,55 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t= OMP_PARALLEL_COMBINED (t);\n       break;\n \n+    case OMP_TASK:\n+      tmp = tsubst_omp_clauses (OMP_TASK_CLAUSES (t),\n+\t\t\t\targs, complain, in_decl);\n+      stmt = begin_omp_task ();\n+      RECUR (OMP_TASK_BODY (t));\n+      finish_omp_task (tmp, stmt);\n+      break;\n+\n     case OMP_FOR:\n       {\n-\ttree clauses, decl, init, cond, incr, body, pre_body;\n+\ttree clauses, body, pre_body;\n+\ttree declv, initv, condv, incrv;\n+\tint i;\n \n \tclauses = tsubst_omp_clauses (OMP_FOR_CLAUSES (t),\n \t\t\t\t      args, complain, in_decl);\n-\tinit = OMP_FOR_INIT (t);\n-\tgcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n-\tdecl = RECUR (TREE_OPERAND (init, 0));\n-\tinit = RECUR (TREE_OPERAND (init, 1));\n-\tcond = RECUR (OMP_FOR_COND (t));\n-\tincr = RECUR (OMP_FOR_INCR (t));\n+\tdeclv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\tinitv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\tcondv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\tincrv = make_tree_vec (TREE_VEC_LENGTH (OMP_FOR_INIT (t)));\n+\n+\tfor (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (t)); i++)\n+\t  tsubst_omp_for_iterator (t, i, declv, initv, condv, incrv,\n+\t\t\t\t   &clauses, args, complain, in_decl,\n+\t\t\t\t   integral_constant_expression_p);\n \n \tstmt = begin_omp_structured_block ();\n \n+\tfor (i = 0; i < TREE_VEC_LENGTH (initv); i++)\n+\t  if (TREE_VEC_ELT (initv, i) == NULL\n+\t      || TREE_CODE (TREE_VEC_ELT (initv, i)) != DECL_EXPR)\n+\t    TREE_VEC_ELT (initv, i) = RECUR (TREE_VEC_ELT (initv, i));\n+\t  else if (CLASS_TYPE_P (TREE_TYPE (TREE_VEC_ELT (initv, i))))\n+\t    {\n+\t      tree init = RECUR (TREE_VEC_ELT (initv, i));\n+\t      gcc_assert (init == TREE_VEC_ELT (declv, i));\n+\t      TREE_VEC_ELT (initv, i) = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree decl_expr = TREE_VEC_ELT (initv, i);\n+\t      tree init = DECL_INITIAL (DECL_EXPR_DECL (decl_expr));\n+\t      gcc_assert (init != NULL);\n+\t      TREE_VEC_ELT (initv, i) = RECUR (init);\n+\t      DECL_INITIAL (DECL_EXPR_DECL (decl_expr)) = NULL;\n+\t      RECUR (decl_expr);\n+\t      DECL_INITIAL (DECL_EXPR_DECL (decl_expr)) = init;\n+\t    }\n+\n \tpre_body = push_stmt_list ();\n \tRECUR (OMP_FOR_PRE_BODY (t));\n \tpre_body = pop_stmt_list (pre_body);\n@@ -10620,10 +10796,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \tRECUR (OMP_FOR_BODY (t));\n \tbody = pop_stmt_list (body);\n \n-\tt = finish_omp_for (EXPR_LOCATION (t), decl, init, cond, incr, body,\n-\t\t\t    pre_body);\n-\tif (t)\n-\t  OMP_FOR_CLAUSES (t) = clauses;\n+\tt = finish_omp_for (EXPR_LOCATION (t), declv, initv, condv, incrv,\n+\t\t\t    body, pre_body, clauses);\n \n \tadd_stmt (finish_omp_structured_block (stmt));\n       }\n@@ -16195,6 +16369,63 @@ dependent_template_id_p (tree tmpl, tree args)\n \t  || any_dependent_template_arguments_p (args));\n }\n \n+/* Returns TRUE if OMP_FOR with DECLV, INITV, CONDV and INCRV vectors\n+   is dependent.  */\n+\n+bool\n+dependent_omp_for_p (tree declv, tree initv, tree condv, tree incrv)\n+{\n+  int i;\n+\n+  if (!processing_template_decl)\n+    return false;\n+\n+  for (i = 0; i < TREE_VEC_LENGTH (declv); i++)\n+    {\n+      tree decl = TREE_VEC_ELT (declv, i);\n+      tree init = TREE_VEC_ELT (initv, i);\n+      tree cond = TREE_VEC_ELT (condv, i);\n+      tree incr = TREE_VEC_ELT (incrv, i);\n+\n+      if (type_dependent_expression_p (decl))\n+\treturn true;\n+\n+      if (init && type_dependent_expression_p (init))\n+\treturn true;\n+\n+      if (type_dependent_expression_p (cond))\n+\treturn true;\n+\n+      if (COMPARISON_CLASS_P (cond)\n+\t  && (type_dependent_expression_p (TREE_OPERAND (cond, 0))\n+\t      || type_dependent_expression_p (TREE_OPERAND (cond, 1))))\n+\treturn true;\n+\n+      if (TREE_CODE (incr) == MODOP_EXPR)\n+\t{\n+\t  if (type_dependent_expression_p (TREE_OPERAND (incr, 0))\n+\t      || type_dependent_expression_p (TREE_OPERAND (incr, 2)))\n+\t    return true;\n+\t}\n+      else if (type_dependent_expression_p (incr))\n+\treturn true;\n+      else if (TREE_CODE (incr) == MODIFY_EXPR)\n+\t{\n+\t  if (type_dependent_expression_p (TREE_OPERAND (incr, 0)))\n+\t    return true;\n+\t  else if (BINARY_CLASS_P (TREE_OPERAND (incr, 1)))\n+\t    {\n+\t      tree t = TREE_OPERAND (incr, 1);\n+\t      if (type_dependent_expression_p (TREE_OPERAND (t, 0))\n+\t\t  || type_dependent_expression_p (TREE_OPERAND (t, 1)))\n+\t\treturn true;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* TYPE is a TYPENAME_TYPE.  Returns the ordinary TYPE to which the\n    TYPENAME_TYPE corresponds.  Returns the original TYPENAME_TYPE if\n    no such TYPE can be found.  Note that this function peers inside"}, {"sha": "83d23394cb5baa7f3b31ee2861fe9d9bc9f313cf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 504, "deletions": 187, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -3359,6 +3359,94 @@ omp_clause_info_fndecl (tree t, tree type)\n   return NULL_TREE;\n }\n \n+/* Create CP_OMP_CLAUSE_INFO for clause C.  Returns true if it is invalid.  */\n+\n+bool\n+cxx_omp_create_clause_info (tree c, tree type, bool need_default_ctor,\n+\t\t\t    bool need_copy_ctor, bool need_copy_assignment)\n+{\n+  int save_errorcount = errorcount;\n+  tree info, t;\n+\n+  /* Always allocate 3 elements for simplicity.  These are the\n+     function decls for the ctor, dtor, and assignment op.\n+     This layout is known to the three lang hooks,\n+     cxx_omp_clause_default_init, cxx_omp_clause_copy_init,\n+     and cxx_omp_clause_assign_op.  */\n+  info = make_tree_vec (3);\n+  CP_OMP_CLAUSE_INFO (c) = info;\n+\n+  if (need_default_ctor\n+      || (need_copy_ctor && !TYPE_HAS_TRIVIAL_INIT_REF (type)))\n+    {\n+      if (need_default_ctor)\n+\tt = NULL;\n+      else\n+\t{\n+\t  t = build_int_cst (build_pointer_type (type), 0);\n+\t  t = build1 (INDIRECT_REF, type, t);\n+\t  t = build_tree_list (NULL, t);\n+\t}\n+      t = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t     t, type, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n+\n+      if (targetm.cxx.cdtor_returns_this () || errorcount)\n+\t/* Because constructors and destructors return this,\n+\t   the call will have been cast to \"void\".  Remove the\n+\t   cast here.  We would like to use STRIP_NOPS, but it\n+\t   wouldn't work here because TYPE_MODE (t) and\n+\t   TYPE_MODE (TREE_OPERAND (t, 0)) are different.\n+\t   They are VOIDmode and Pmode, respectively.  */\n+\tif (TREE_CODE (t) == NOP_EXPR)\n+\t  t = TREE_OPERAND (t, 0);\n+\n+      TREE_VEC_ELT (info, 0) = get_callee_fndecl (t);\n+    }\n+\n+  if ((need_default_ctor || need_copy_ctor)\n+      && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+    {\n+      t = build_int_cst (build_pointer_type (type), 0);\n+      t = build1 (INDIRECT_REF, type, t);\n+      t = build_special_member_call (t, complete_dtor_identifier,\n+\t\t\t\t     NULL, type, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n+\n+      if (targetm.cxx.cdtor_returns_this () || errorcount)\n+\t/* Because constructors and destructors return this,\n+\t   the call will have been cast to \"void\".  Remove the\n+\t   cast here.  We would like to use STRIP_NOPS, but it\n+\t   wouldn't work here because TYPE_MODE (t) and\n+\t   TYPE_MODE (TREE_OPERAND (t, 0)) are different.\n+\t   They are VOIDmode and Pmode, respectively.  */\n+\tif (TREE_CODE (t) == NOP_EXPR)\n+\t  t = TREE_OPERAND (t, 0);\n+\n+      TREE_VEC_ELT (info, 1) = omp_clause_info_fndecl (t, type);\n+    }\n+\n+  if (need_copy_assignment && !TYPE_HAS_TRIVIAL_ASSIGN_REF (type))\n+    {\n+      t = build_int_cst (build_pointer_type (type), 0);\n+      t = build1 (INDIRECT_REF, type, t);\n+      t = build_special_member_call (t, ansi_assopname (NOP_EXPR),\n+\t\t\t\t     build_tree_list (NULL, t),\n+\t\t\t\t     type, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n+\n+      /* We'll have called convert_from_reference on the call, which\n+\t may well have added an indirect_ref.  It's unneeded here,\n+\t and in the way, so kill it.  */\n+      if (TREE_CODE (t) == INDIRECT_REF)\n+\tt = TREE_OPERAND (t, 0);\n+\n+      TREE_VEC_ELT (info, 2) = omp_clause_info_fndecl (t, type);\n+    }\n+\n+  return errorcount != save_errorcount;\n+}\n+\n /* For all elements of CLAUSES, validate them vs OpenMP constraints.\n    Remove any elements from the list that are invalid.  */\n \n@@ -3499,6 +3587,8 @@ finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_COLLAPSE:\n \t  break;\n \n \tdefault:\n@@ -3662,93 +3752,10 @@ finish_omp_clauses (tree clauses)\n \t for making these queries.  */\n       if (CLASS_TYPE_P (inner_type)\n \t  && (need_default_ctor || need_copy_ctor || need_copy_assignment)\n-\t  && !type_dependent_expression_p (t))\n-\t{\n-\t  int save_errorcount = errorcount;\n-\t  tree info;\n-\n-\t  /* Always allocate 3 elements for simplicity.  These are the\n-\t     function decls for the ctor, dtor, and assignment op.\n-\t     This layout is known to the three lang hooks,\n-\t     cxx_omp_clause_default_init, cxx_omp_clause_copy_init,\n-\t     and cxx_omp_clause_assign_op.  */\n-\t  info = make_tree_vec (3);\n-\t  CP_OMP_CLAUSE_INFO (c) = info;\n-\n-\t  if (need_default_ctor\n-\t      || (need_copy_ctor\n-\t\t  && !TYPE_HAS_TRIVIAL_INIT_REF (inner_type)))\n-\t    {\n-\t      if (need_default_ctor)\n-\t\tt = NULL;\n-\t      else\n-\t\t{\n-\t\t  t = build_int_cst (build_pointer_type (inner_type), 0);\n-\t\t  t = build1 (INDIRECT_REF, inner_type, t);\n-\t\t  t = build_tree_list (NULL, t);\n-\t\t}\n-\t      t = build_special_member_call (NULL_TREE,\n-\t\t\t\t\t     complete_ctor_identifier,\n-\t\t\t\t\t     t, inner_type, LOOKUP_NORMAL,\n-                                             tf_warning_or_error);\n-\n-\t      if (targetm.cxx.cdtor_returns_this () || errorcount)\n-\t\t/* Because constructors and destructors return this,\n-\t\t   the call will have been cast to \"void\".  Remove the\n-\t\t   cast here.  We would like to use STRIP_NOPS, but it\n-\t\t   wouldn't work here because TYPE_MODE (t) and\n-\t\t   TYPE_MODE (TREE_OPERAND (t, 0)) are different.\n-\t\t   They are VOIDmode and Pmode, respectively.  */\n-\t\tif (TREE_CODE (t) == NOP_EXPR)\n-\t\t  t = TREE_OPERAND (t, 0);\n-\n-\t      TREE_VEC_ELT (info, 0) = get_callee_fndecl (t);\n-\t    }\n-\n-\t  if ((need_default_ctor || need_copy_ctor)\n-\t      && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (inner_type))\n-\t    {\n-\t      t = build_int_cst (build_pointer_type (inner_type), 0);\n-\t      t = build1 (INDIRECT_REF, inner_type, t);\n-\t      t = build_special_member_call (t, complete_dtor_identifier,\n-\t\t\t\t\t     NULL, inner_type, LOOKUP_NORMAL,\n-                                             tf_warning_or_error);\n-\n-\t      if (targetm.cxx.cdtor_returns_this () || errorcount)\n-\t\t/* Because constructors and destructors return this,\n-\t\t   the call will have been cast to \"void\".  Remove the\n-\t\t   cast here.  We would like to use STRIP_NOPS, but it\n-\t\t   wouldn't work here because TYPE_MODE (t) and\n-\t\t   TYPE_MODE (TREE_OPERAND (t, 0)) are different.\n-\t\t   They are VOIDmode and Pmode, respectively.  */\n-\t\tif (TREE_CODE (t) == NOP_EXPR)\n-\t\t  t = TREE_OPERAND (t, 0);\n-\n-\t      TREE_VEC_ELT (info, 1) = omp_clause_info_fndecl (t, inner_type);\n-\t    }\n-\n-\t  if (need_copy_assignment\n-\t      && !TYPE_HAS_TRIVIAL_ASSIGN_REF (inner_type))\n-\t    {\n-\t      t = build_int_cst (build_pointer_type (inner_type), 0);\n-\t      t = build1 (INDIRECT_REF, inner_type, t);\n-\t      t = build_special_member_call (t, ansi_assopname (NOP_EXPR),\n-\t\t\t\t\t     build_tree_list (NULL, t),\n-\t\t\t\t\t     inner_type, LOOKUP_NORMAL,\n-                                             tf_warning_or_error);\n-\n-\t      /* We'll have called convert_from_reference on the call, which\n-\t\t may well have added an indirect_ref.  It's unneeded here,\n-\t\t and in the way, so kill it.  */\n-\t      if (TREE_CODE (t) == INDIRECT_REF)\n-\t\tt = TREE_OPERAND (t, 0);\n-\n-\t      TREE_VEC_ELT (info, 2) = omp_clause_info_fndecl (t, inner_type);\n-\t    }\n-\n-\t  if (errorcount != save_errorcount)\n-\t    remove = true;\n-\t}\n+\t  && !type_dependent_expression_p (t)\n+\t  && cxx_omp_create_clause_info (c, inner_type, need_default_ctor,\n+\t\t\t\t\t need_copy_ctor, need_copy_assignment))\n+\tremove = true;\n \n       if (remove)\n \t*pc = OMP_CLAUSE_CHAIN (c);\n@@ -3787,9 +3794,10 @@ finish_omp_threadprivate (tree vars)\n \terror (\"automatic variable %qE cannot be %<threadprivate%>\", v);\n       else if (! COMPLETE_TYPE_P (TREE_TYPE (v)))\n \terror (\"%<threadprivate%> %qE has incomplete type\", v);\n-      else if (TREE_STATIC (v) && TYPE_P (CP_DECL_CONTEXT (v)))\n-\terror (\"%<threadprivate%> %qE is not file, namespace \"\n-\t       \"or block scope variable\", v);\n+      else if (TREE_STATIC (v) && TYPE_P (CP_DECL_CONTEXT (v))\n+\t       && CP_DECL_CONTEXT (v) != current_class_type)\n+\terror (\"%<threadprivate%> %qE directive not \"\n+\t       \"in %qT definition\", v, CP_DECL_CONTEXT (v));\n       else\n \t{\n \t  /* Allocate a LANG_SPECIFIC structure for V, if needed.  */\n@@ -3855,6 +3863,252 @@ finish_omp_parallel (tree clauses, tree body)\n   return add_stmt (stmt);\n }\n \n+tree\n+begin_omp_task (void)\n+{\n+  keep_next_level (true);\n+  return begin_omp_structured_block ();\n+}\n+\n+tree\n+finish_omp_task (tree clauses, tree body)\n+{\n+  tree stmt;\n+\n+  body = finish_omp_structured_block (body);\n+\n+  stmt = make_node (OMP_TASK);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TASK_CLAUSES (stmt) = clauses;\n+  OMP_TASK_BODY (stmt) = body;\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* Helper function for finish_omp_for.  Convert Ith random access iterator\n+   into integral iterator.  Return FALSE if successful.  */\n+\n+static bool\n+handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n+\t\t\t       tree condv, tree incrv, tree *body,\n+\t\t\t       tree *pre_body, tree clauses)\n+{\n+  tree diff, iter_init, iter_incr = NULL, last;\n+  tree incr_var = NULL, orig_pre_body, orig_body, c;\n+  tree decl = TREE_VEC_ELT (declv, i);\n+  tree init = TREE_VEC_ELT (initv, i);\n+  tree cond = TREE_VEC_ELT (condv, i);\n+  tree incr = TREE_VEC_ELT (incrv, i);\n+  tree iter = decl;\n+  location_t elocus = locus;\n+\n+  if (init && EXPR_HAS_LOCATION (init))\n+    elocus = EXPR_LOCATION (init);\n+\n+  switch (TREE_CODE (cond))\n+    {\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      if (TREE_OPERAND (cond, 0) != iter)\n+\tcond = error_mark_node;\n+      else\n+\t{\n+\t  tree tem = build_x_binary_op (TREE_CODE (cond), iter, ERROR_MARK,\n+\t\t\t\t\tTREE_OPERAND (cond, 1), ERROR_MARK,\n+\t\t\t\t\tNULL, tf_warning_or_error);\n+\t  if (error_operand_p (tem))\n+\t    return true;\n+\t}\n+      break;\n+    default:\n+      cond = error_mark_node;\n+      break;\n+    }\n+  if (cond == error_mark_node)\n+    {\n+      error (\"%Hinvalid controlling predicate\", &elocus);\n+      return true;\n+    }\n+  diff = build_x_binary_op (MINUS_EXPR, TREE_OPERAND (cond, 1),\n+\t\t\t    ERROR_MARK, iter, ERROR_MARK, NULL,\n+\t\t\t    tf_warning_or_error);\n+  if (error_operand_p (diff))\n+    return true;\n+  if (TREE_CODE (TREE_TYPE (diff)) != INTEGER_TYPE)\n+    {\n+      error (\"%Hdifference between %qE and %qD does not have integer type\",\n+\t     &elocus, TREE_OPERAND (cond, 1), iter);\n+      return true;\n+    }\n+\n+  switch (TREE_CODE (incr))\n+    {\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      if (TREE_OPERAND (incr, 0) != iter)\n+\t{\n+\t  incr = error_mark_node;\n+\t  break;\n+\t}\n+      iter_incr = build_x_unary_op (TREE_CODE (incr), iter,\n+\t\t\t\t    tf_warning_or_error);\n+      if (error_operand_p (iter_incr))\n+\treturn true;\n+      else if (TREE_CODE (incr) == PREINCREMENT_EXPR\n+\t       || TREE_CODE (incr) == POSTINCREMENT_EXPR)\n+\tincr = integer_one_node;\n+      else\n+\tincr = integer_minus_one_node;\n+      break;\n+    case MODIFY_EXPR:\n+      if (TREE_OPERAND (incr, 0) != iter)\n+\tincr = error_mark_node;\n+      else if (TREE_CODE (TREE_OPERAND (incr, 1)) == PLUS_EXPR\n+\t       || TREE_CODE (TREE_OPERAND (incr, 1)) == MINUS_EXPR)\n+\t{\n+\t  tree rhs = TREE_OPERAND (incr, 1);\n+\t  if (TREE_OPERAND (rhs, 0) == iter)\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (rhs, 1)))\n+\t\t  != INTEGER_TYPE)\n+\t\tincr = error_mark_node;\n+\t      else\n+\t\t{\n+\t\t  iter_incr = build_x_modify_expr (iter, TREE_CODE (rhs),\n+\t\t\t\t\t\t   TREE_OPERAND (rhs, 1),\n+\t\t\t\t\t\t   tf_warning_or_error);\n+\t\t  if (error_operand_p (iter_incr))\n+\t\t    return true;\n+\t\t  incr = TREE_OPERAND (rhs, 1);\n+\t\t  incr = cp_convert (TREE_TYPE (diff), incr);\n+\t\t  if (TREE_CODE (rhs) == MINUS_EXPR)\n+\t\t    {\n+\t\t      incr = build1 (NEGATE_EXPR, TREE_TYPE (diff), incr);\n+\t\t      incr = fold_if_not_in_template (incr);\n+\t\t    }\n+\t\t  if (TREE_CODE (incr) != INTEGER_CST\n+\t\t      && (TREE_CODE (incr) != NOP_EXPR\n+\t\t\t  || (TREE_CODE (TREE_OPERAND (incr, 0))\n+\t\t\t      != INTEGER_CST)))\n+\t\t    iter_incr = NULL;\n+\t\t}\n+\t    }\n+\t  else if (TREE_OPERAND (rhs, 1) == iter)\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (rhs, 0))) != INTEGER_TYPE\n+\t\t  || TREE_CODE (rhs) != PLUS_EXPR)\n+\t\tincr = error_mark_node;\n+\t      else\n+\t\t{\n+\t\t  iter_incr = build_x_binary_op (PLUS_EXPR,\n+\t\t\t\t\t\t TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t\t ERROR_MARK, iter,\n+\t\t\t\t\t\t ERROR_MARK, NULL,\n+\t\t\t\t\t\t tf_warning_or_error);\n+\t\t  if (error_operand_p (iter_incr))\n+\t\t    return true;\n+\t\t  iter_incr = build_x_modify_expr (iter, NOP_EXPR,\n+\t\t\t\t\t\t   iter_incr,\n+\t\t\t\t\t\t   tf_warning_or_error);\n+\t\t  if (error_operand_p (iter_incr))\n+\t\t    return true;\n+\t\t  incr = TREE_OPERAND (rhs, 0);\n+\t\t  iter_incr = NULL;\n+\t\t}\n+\t    }\n+\t  else\n+\t    incr = error_mark_node;\n+\t}\n+      else\n+\tincr = error_mark_node;\n+      break;\n+    default:\n+      incr = error_mark_node;\n+      break;\n+    }\n+\n+  if (incr == error_mark_node)\n+    {\n+      error (\"%Hinvalid increment expression\", &elocus);\n+      return true;\n+    }\n+\n+  incr = cp_convert (TREE_TYPE (diff), incr);\n+  for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t&& OMP_CLAUSE_DECL (c) == iter)\n+      break;\n+\n+  decl = create_temporary_var (TREE_TYPE (diff));\n+  pushdecl (decl);\n+  add_decl_expr (decl);\n+  last = create_temporary_var (TREE_TYPE (diff));\n+  pushdecl (last);\n+  add_decl_expr (last);\n+  if (c && iter_incr == NULL)\n+    {\n+      incr_var = create_temporary_var (TREE_TYPE (diff));\n+      pushdecl (incr_var);\n+      add_decl_expr (incr_var);\n+    }\n+  gcc_assert (stmts_are_full_exprs_p ());\n+\n+  orig_pre_body = *pre_body;\n+  *pre_body = push_stmt_list ();\n+  if (orig_pre_body)\n+    add_stmt (orig_pre_body);\n+  if (init != NULL)\n+    finish_expr_stmt (build_x_modify_expr (iter, NOP_EXPR, init,\n+\t\t\t\t\t   tf_warning_or_error));\n+  init = build_int_cst (TREE_TYPE (diff), 0);\n+  if (c && iter_incr == NULL)\n+    {\n+      finish_expr_stmt (build_x_modify_expr (incr_var, NOP_EXPR,\n+\t\t\t\t\t     incr, tf_warning_or_error));\n+      incr = incr_var;\n+      iter_incr = build_x_modify_expr (iter, PLUS_EXPR, incr,\n+\t\t\t\t       tf_warning_or_error);\n+    }\n+  finish_expr_stmt (build_x_modify_expr (last, NOP_EXPR, init,\n+\t\t\t\t\t tf_warning_or_error));\n+  *pre_body = pop_stmt_list (*pre_body);\n+\n+  cond = cp_build_binary_op (TREE_CODE (cond), decl, diff,\n+\t\t\t     tf_warning_or_error);\n+  incr = build_modify_expr (decl, PLUS_EXPR, incr);\n+\n+  orig_body = *body;\n+  *body = push_stmt_list ();\n+  iter_init = build2 (MINUS_EXPR, TREE_TYPE (diff), decl, last);\n+  iter_init = build_x_modify_expr (iter, PLUS_EXPR, iter_init,\n+\t\t\t\t   tf_warning_or_error);\n+  iter_init = build1 (NOP_EXPR, void_type_node, iter_init);\n+  finish_expr_stmt (iter_init);\n+  finish_expr_stmt (build_x_modify_expr (last, NOP_EXPR, decl,\n+\t\t\t\t\t tf_warning_or_error));\n+  add_stmt (orig_body);\n+  *body = pop_stmt_list (*body);\n+\n+  if (c)\n+    {\n+      OMP_CLAUSE_LASTPRIVATE_STMT (c) = push_stmt_list ();\n+      finish_expr_stmt (iter_incr);\n+      OMP_CLAUSE_LASTPRIVATE_STMT (c)\n+\t= pop_stmt_list (OMP_CLAUSE_LASTPRIVATE_STMT (c));\n+    }\n+\n+  TREE_VEC_ELT (declv, i) = decl;\n+  TREE_VEC_ELT (initv, i) = init;\n+  TREE_VEC_ELT (condv, i) = cond;\n+  TREE_VEC_ELT (incrv, i) = incr;\n+\n+  return false;\n+}\n+\n /* Build and validate an OMP_FOR statement.  CLAUSES, BODY, COND, INCR\n    are directly for their associated operands in the statement.  DECL\n    and INIT are a combo; if DECL is NULL then INIT ought to be a\n@@ -3863,126 +4117,203 @@ finish_omp_parallel (tree clauses, tree body)\n    sk_omp scope.  */\n \n tree\n-finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n-\t\ttree incr, tree body, tree pre_body)\n+finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n+\t\ttree incrv, tree body, tree pre_body, tree clauses)\n {\n-  tree omp_for = NULL;\n+  tree omp_for = NULL, orig_incr = NULL;\n+  tree decl, init, cond, incr;\n+  location_t elocus;\n+  int i;\n \n-  if (decl == NULL)\n+  gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (initv));\n+  gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (condv));\n+  gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (incrv));\n+  for (i = 0; i < TREE_VEC_LENGTH (declv); i++)\n     {\n-      if (init != NULL)\n-\tswitch (TREE_CODE (init))\n-\t  {\n-\t  case MODIFY_EXPR:\n-\t    decl = TREE_OPERAND (init, 0);\n-\t    init = TREE_OPERAND (init, 1);\n-\t    break;\n-\t  case MODOP_EXPR:\n-\t    if (TREE_CODE (TREE_OPERAND (init, 1)) == NOP_EXPR)\n+      decl = TREE_VEC_ELT (declv, i);\n+      init = TREE_VEC_ELT (initv, i);\n+      cond = TREE_VEC_ELT (condv, i);\n+      incr = TREE_VEC_ELT (incrv, i);\n+      elocus = locus;\n+\n+      if (decl == NULL)\n+\t{\n+\t  if (init != NULL)\n+\t    switch (TREE_CODE (init))\n \t      {\n+\t      case MODIFY_EXPR:\n \t\tdecl = TREE_OPERAND (init, 0);\n-\t\tinit = TREE_OPERAND (init, 2);\n+\t\tinit = TREE_OPERAND (init, 1);\n+\t\tbreak;\n+\t      case MODOP_EXPR:\n+\t\tif (TREE_CODE (TREE_OPERAND (init, 1)) == NOP_EXPR)\n+\t\t  {\n+\t\t    decl = TREE_OPERAND (init, 0);\n+\t\t    init = TREE_OPERAND (init, 2);\n+\t\t  }\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n \t      }\n-\t    break;\n-\t  default:\n-\t    break;\n-\t  }\n \n-      if (decl == NULL)\n-\t{\n-\t  error (\"expected iteration declaration or initialization\");\n-\t  return NULL;\n+\t  if (decl == NULL)\n+\t    {\n+\t      error (\"%Hexpected iteration declaration or initialization\",\n+\t\t     &locus);\n+\t      return NULL;\n+\t    }\n \t}\n-    }\n \n-  if (type_dependent_expression_p (decl)\n-      || type_dependent_expression_p (init)\n-      || (cond && type_dependent_expression_p (cond))\n-      || (incr && type_dependent_expression_p (incr)))\n-    {\n-      tree stmt;\n+      if (init && EXPR_HAS_LOCATION (init))\n+\telocus = EXPR_LOCATION (init);\n \n       if (cond == NULL)\n \t{\n-\t  error (\"%Hmissing controlling predicate\", &locus);\n+\t  error (\"%Hmissing controlling predicate\", &elocus);\n \t  return NULL;\n \t}\n \n       if (incr == NULL)\n \t{\n-\t  error (\"%Hmissing increment expression\", &locus);\n+\t  error (\"%Hmissing increment expression\", &elocus);\n \t  return NULL;\n \t}\n \n+      TREE_VEC_ELT (declv, i) = decl;\n+      TREE_VEC_ELT (initv, i) = init;\n+    }\n+\n+  if (dependent_omp_for_p (declv, initv, condv, incrv))\n+    {\n+      tree stmt;\n+\n       stmt = make_node (OMP_FOR);\n \n-      /* This is really just a place-holder.  We'll be decomposing this\n-\t again and going through the build_modify_expr path below when\n-\t we instantiate the thing.  */\n-      init = build2 (MODIFY_EXPR, void_type_node, decl, init);\n+      for (i = 0; i < TREE_VEC_LENGTH (declv); i++)\n+\t{\n+\t  /* This is really just a place-holder.  We'll be decomposing this\n+\t     again and going through the cp_build_modify_expr path below when\n+\t     we instantiate the thing.  */\n+\t  TREE_VEC_ELT (initv, i)\n+\t    = build2 (MODIFY_EXPR, void_type_node, TREE_VEC_ELT (declv, i),\n+\t\t      TREE_VEC_ELT (initv, i));\n+\t}\n \n       TREE_TYPE (stmt) = void_type_node;\n-      OMP_FOR_INIT (stmt) = init;\n-      OMP_FOR_COND (stmt) = cond;\n-      OMP_FOR_INCR (stmt) = incr;\n+      OMP_FOR_INIT (stmt) = initv;\n+      OMP_FOR_COND (stmt) = condv;\n+      OMP_FOR_INCR (stmt) = incrv;\n       OMP_FOR_BODY (stmt) = body;\n       OMP_FOR_PRE_BODY (stmt) = pre_body;\n+      OMP_FOR_CLAUSES (stmt) = clauses;\n \n       SET_EXPR_LOCATION (stmt, locus);\n       return add_stmt (stmt);\n     }\n \n-  if (!DECL_P (decl))\n-    {\n-      error (\"expected iteration declaration or initialization\");\n-      return NULL;\n-    }\n+  if (processing_template_decl)\n+    orig_incr = make_tree_vec (TREE_VEC_LENGTH (incrv));\n \n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (decl)))\n+  for (i = 0; i < TREE_VEC_LENGTH (declv); )\n     {\n-      location_t elocus = locus;\n-\n-      if (EXPR_HAS_LOCATION (init))\n+      decl = TREE_VEC_ELT (declv, i);\n+      init = TREE_VEC_ELT (initv, i);\n+      cond = TREE_VEC_ELT (condv, i);\n+      incr = TREE_VEC_ELT (incrv, i);\n+      if (orig_incr)\n+\tTREE_VEC_ELT (orig_incr, i) = incr;\n+      elocus = locus;\n+\n+      if (init && EXPR_HAS_LOCATION (init))\n \telocus = EXPR_LOCATION (init);\n-      error (\"%Hinvalid type for iteration variable %qE\", &elocus, decl);\n-      return NULL;\n-    }\n \n-  if (pre_body == NULL || IS_EMPTY_STMT (pre_body))\n-    pre_body = NULL;\n-  else if (! processing_template_decl)\n-    {\n-      add_stmt (pre_body);\n-      pre_body = NULL;\n-    }\n+      if (!DECL_P (decl))\n+\t{\n+\t  error (\"%Hexpected iteration declaration or initialization\",\n+\t\t &elocus);\n+\t  return NULL;\n+\t}\n \n-  if (!processing_template_decl)\n-    init = fold_build_cleanup_point_expr (TREE_TYPE (init), init);\n-  init = cp_build_modify_expr (decl, NOP_EXPR, init, tf_warning_or_error);\n-  if (cond && TREE_SIDE_EFFECTS (cond) && COMPARISON_CLASS_P (cond))\n-    {\n-      int n = TREE_SIDE_EFFECTS (TREE_OPERAND (cond, 1)) != 0;\n-      tree t = TREE_OPERAND (cond, n);\n+      if (incr && TREE_CODE (incr) == MODOP_EXPR)\n+\t{\n+\t  if (orig_incr)\n+\t    TREE_VEC_ELT (orig_incr, i) = incr;\n+\t  incr = cp_build_modify_expr (TREE_OPERAND (incr, 0),\n+\t\t\t\t       TREE_CODE (TREE_OPERAND (incr, 1)),\n+\t\t\t\t       TREE_OPERAND (incr, 2),\n+\t\t\t\t       tf_warning_or_error);\n+\t}\n+\n+      if (CLASS_TYPE_P (TREE_TYPE (decl)))\n+\t{\n+\t  if (handle_omp_for_class_iterator (i, locus, declv, initv, condv,\n+\t\t\t\t\t     incrv, &body, &pre_body, clauses))\n+\t    return NULL;\n+\t  continue;\n+\t}\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (decl))\n+\t  && TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE)\n+\t{\n+\t  error (\"%Hinvalid type for iteration variable %qE\", &elocus, decl);\n+\t  return NULL;\n+\t}\n \n       if (!processing_template_decl)\n-\tTREE_OPERAND (cond, n)\n-\t  = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\tinit = fold_build_cleanup_point_expr (TREE_TYPE (init), init);\n+      init = cp_build_modify_expr (decl, NOP_EXPR, init, tf_warning_or_error);\n+      if (cond && TREE_SIDE_EFFECTS (cond) && COMPARISON_CLASS_P (cond))\n+\t{\n+\t  int n = TREE_SIDE_EFFECTS (TREE_OPERAND (cond, 1)) != 0;\n+\t  tree t = TREE_OPERAND (cond, n);\n+\n+\t  if (!processing_template_decl)\n+\t    TREE_OPERAND (cond, n)\n+\t      = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t}\n+      if (decl == error_mark_node || init == error_mark_node)\n+\treturn NULL;\n+\n+      TREE_VEC_ELT (declv, i) = decl;\n+      TREE_VEC_ELT (initv, i) = init;\n+      TREE_VEC_ELT (condv, i) = cond;\n+      TREE_VEC_ELT (incrv, i) = incr;\n+      i++;\n     }\n-  if (decl != error_mark_node && init != error_mark_node)\n-    omp_for = c_finish_omp_for (locus, decl, init, cond, incr, body, pre_body);\n-  if (omp_for != NULL\n-      && TREE_CODE (OMP_FOR_INCR (omp_for)) == MODIFY_EXPR\n-      && TREE_SIDE_EFFECTS (TREE_OPERAND (OMP_FOR_INCR (omp_for), 1))\n-      && BINARY_CLASS_P (TREE_OPERAND (OMP_FOR_INCR (omp_for), 1)))\n+\n+  if (IS_EMPTY_STMT (pre_body))\n+    pre_body = NULL;\n+\n+  omp_for = c_finish_omp_for (locus, declv, initv, condv, incrv,\n+\t\t\t      body, pre_body);\n+\n+  if (omp_for == NULL)\n+    return NULL;\n+\n+  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INCR (omp_for)); i++)\n     {\n-      tree t = TREE_OPERAND (OMP_FOR_INCR (omp_for), 1);\n-      int n = TREE_SIDE_EFFECTS (TREE_OPERAND (t, 1)) != 0;\n+      tree incr = TREE_VEC_ELT (OMP_FOR_INCR (omp_for), i);\n \n-      if (!processing_template_decl)\n-\tTREE_OPERAND (t, n)\n-\t  = fold_build_cleanup_point_expr (TREE_TYPE (TREE_OPERAND (t, n)),\n-\t\t\t\t\t   TREE_OPERAND (t, n));\n+      if (TREE_CODE (incr) != MODIFY_EXPR)\n+\tcontinue;\n+\n+      if (TREE_SIDE_EFFECTS (TREE_OPERAND (incr, 1))\n+\t  && BINARY_CLASS_P (TREE_OPERAND (incr, 1)))\n+\t{\n+\t  tree t = TREE_OPERAND (incr, 1);\n+\t  int n = TREE_SIDE_EFFECTS (TREE_OPERAND (t, 1)) != 0;\n+\n+\t  if (!processing_template_decl)\n+\t    TREE_OPERAND (t, n)\n+\t      = fold_build_cleanup_point_expr (TREE_TYPE (TREE_OPERAND (t, n)),\n+\t\t\t\t\t       TREE_OPERAND (t, n));\n+\t}\n+\n+      if (orig_incr)\n+\tTREE_VEC_ELT (OMP_FOR_INCR (omp_for), i) = TREE_VEC_ELT (orig_incr, i);\n     }\n+  if (omp_for != NULL)\n+    OMP_FOR_CLAUSES (omp_for) = clauses;\n   return omp_for;\n }\n \n@@ -4039,26 +4370,12 @@ finish_omp_flush (void)\n   finish_expr_stmt (stmt);\n }\n \n-/* True if OpenMP sharing attribute of DECL is predetermined.  */\n-\n-enum omp_clause_default_kind\n-cxx_omp_predetermined_sharing (tree decl)\n+void\n+finish_omp_taskwait (void)\n {\n-  enum omp_clause_default_kind kind;\n-\n-  kind = c_omp_predetermined_sharing (decl);\n-  if (kind != OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n-    return kind;\n-\n-  /* Static data members are predetermined as shared.  */\n-  if (TREE_STATIC (decl))\n-    {\n-      tree ctx = CP_DECL_CONTEXT (decl);\n-      if (TYPE_P (ctx) && MAYBE_CLASS_TYPE_P (ctx))\n-\treturn OMP_CLAUSE_DEFAULT_SHARED;\n-    }\n-\n-  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+  tree fn = built_in_decls[BUILT_IN_GOMP_TASKWAIT];\n+  tree stmt = finish_call_expr (fn, NULL, false, false, tf_warning_or_error);\n+  finish_expr_stmt (stmt);\n }\n \f\n void"}, {"sha": "5df5de5cf749d44c42fe1ebb0aee7ce661577a11", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,3 +1,87 @@\n+2008-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* scanner.c (skip_free_comments, skip_fixed_comments): Handle tabs.\n+\t* parse.c (next_free): Allow tab after !$omp.\n+\t(decode_omp_directive): Handle !$omp task, !$omp taskwait\n+\tand !$omp end task.\n+\t(case_executable): Add ST_OMP_TASKWAIT.\n+\t(case_exec_markers): Add ST_OMP_TASK.\n+\t(gfc_ascii_statement): Handle ST_OMP_TASK, ST_OMP_END_TASK and\n+\tST_OMP_TASKWAIT.\n+\t(parse_omp_structured_block, parse_executable): Handle ST_OMP_TASK.\n+\t* gfortran.h (gfc_find_sym_in_expr): New prototype.\n+\t(gfc_statement): Add ST_OMP_TASK, ST_OMP_END_TASK and ST_OMP_TASKWAIT.\n+\t(gfc_omp_clauses): Add OMP_SCHED_AUTO to sched_kind,\n+\tOMP_DEFAULT_FIRSTPRIVATE to default_sharing.  Add collapse and\n+\tuntied fields.\n+\t(gfc_exec_op): Add EXEC_OMP_TASK and EXEC_OMP_TASKWAIT.\n+\t* f95-lang.c (LANG_HOOKS_OMP_CLAUSE_COPY_CTOR,\n+\tLANG_HOOKS_OMP_CLAUSE_ASSIGN_OP, LANG_HOOKS_OMP_CLAUSE_DTOR,\n+\tLANG_HOOKS_OMP_PRIVATE_OUTER_REF): Define.\n+\t* trans.h (gfc_omp_clause_default_ctor): Add another argument.\n+\t(gfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,\n+\tgfc_omp_clause_dtor, gfc_omp_private_outer_ref): New prototypes.\n+\t* types.def (BT_ULONGLONG, BT_PTR_ULONGLONG,\n+\tBT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR,\n+\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\tBT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\tBT_FN_VOID_PTR_PTR, BT_PTR_FN_VOID_PTR_PTR,\n+\tBT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT): New.\n+\t(BT_BOOL): Use integer type with BOOL_TYPE_SIZE rather\n+\tthan boolean_type_node.\n+\t* dump-parse-tree.c (gfc_show_omp_node): Handle EXEC_OMP_TASK,\n+\tEXEC_OMP_TASKWAIT, OMP_SCHED_AUTO, OMP_DEFAULT_FIRSTPRIVATE,\n+\tuntied and collapse clauses.\n+\t(gfc_show_code_node): Handle EXEC_OMP_TASK and EXEC_OMP_TASKWAIT.\n+\t* trans.c (gfc_trans_code): Handle EXEC_OMP_TASK and\n+\tEXEC_OMP_TASKWAIT.\n+\t* st.c (gfc_free_statement): Likewise.\n+\t* resolve.c (gfc_resolve_blocks, resolve_code): Likewise.\n+\t(find_sym_in_expr): Rename to...\n+\t(gfc_find_sym_in_expr): ... this.  No longer static.\n+\t(resolve_allocate_expr, resolve_ordinary_assign): Adjust caller.\n+\t* match.h (gfc_match_omp_task, gfc_match_omp_taskwait): New\n+\tprototypes.\n+\t* openmp.c (resolve_omp_clauses): Allow allocatable arrays in\n+\tfirstprivate, lastprivate, reduction, copyprivate and copyin\n+\tclauses.\n+\t(omp_current_do_code): Made static.\n+\t(omp_current_do_collapse): New variable.\n+\t(gfc_resolve_omp_do_blocks): Compute omp_current_do_collapse,\n+\tclear omp_current_do_code and omp_current_do_collapse on return.\n+\t(gfc_resolve_do_iterator): Handle collapsed do loops.\n+\t(resolve_omp_do): Likewise, diagnose errorneous collapsed do loops.\n+\t(OMP_CLAUSE_COLLAPSE, OMP_CLAUSE_UNTIED): Define.\n+\t(gfc_match_omp_clauses): Handle default (firstprivate),\n+\tschedule (auto), untied and collapse (n) clauses.\n+\t(OMP_DO_CLAUSES): Add OMP_CLAUSE_COLLAPSE.\n+\t(OMP_TASK_CLAUSES): Define.\n+\t(gfc_match_omp_task, gfc_match_omp_taskwait): New functions.\n+\t* trans-openmp.c (gfc_omp_private_outer_ref): New function.\n+\t(gfc_omp_clause_default_ctor): Add outer argument.  For allocatable\n+\tarrays allocate them with the bounds of the outer var if outer\n+\tvar is allocated.\n+\t(gfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,\n+\tgfc_omp_clause_dtor): New functions.\n+\t(gfc_trans_omp_array_reduction): If decl is allocatable array,\n+\tallocate it with outer var's bounds in OMP_CLAUSE_REDUCTION_INIT\n+\tand deallocate it in OMP_CLAUSE_REDUCTION_MERGE.\n+\t(gfc_omp_predetermined_sharing): Return OMP_CLAUSE_DEFAULT_SHARED\n+\tfor assumed-size arrays.\n+\t(gfc_trans_omp_do): Add par_clauses argument.  If dovar is\n+\tpresent in lastprivate clause and do loop isn't simple,\n+\tset OMP_CLAUSE_LASTPRIVATE_STMT.  If dovar is present in\n+\tparallel's lastprivate clause, change it to shared and add\n+\tlastprivate clause to OMP_FOR_CLAUSES.  Handle collapsed do loops.\n+\t(gfc_trans_omp_directive): Adjust gfc_trans_omp_do callers.\n+\t(gfc_trans_omp_parallel_do): Likewise.  Move collapse clause to\n+\tOMP_FOR from OMP_PARALLEL.\n+\t(gfc_trans_omp_clauses): Handle OMP_SCHED_AUTO,\n+\tOMP_DEFAULT_FIRSTPRIVATE, untied and collapse clauses.\n+\t(gfc_trans_omp_task, gfc_trans_omp_taskwait): New functions.\n+\t(gfc_trans_omp_directive): Handle EXEC_OMP_TASK and\n+\tEXEC_OMP_TASKWAIT.\n+\n 2008-06-04  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/36322"}, {"sha": "80ff5bcecb70b6a5d00aa8b47f1b071a10abbdfb", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -848,6 +848,8 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OMP_PARALLEL_WORKSHARE: name = \"PARALLEL WORKSHARE\"; break;\n     case EXEC_OMP_SECTIONS: name = \"SECTIONS\"; break;\n     case EXEC_OMP_SINGLE: name = \"SINGLE\"; break;\n+    case EXEC_OMP_TASK: name = \"TASK\"; break;\n+    case EXEC_OMP_TASKWAIT: name = \"TASKWAIT\"; break;\n     case EXEC_OMP_WORKSHARE: name = \"WORKSHARE\"; break;\n     default:\n       gcc_unreachable ();\n@@ -863,6 +865,7 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OMP_SINGLE:\n     case EXEC_OMP_WORKSHARE:\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n+    case EXEC_OMP_TASK:\n       omp_clauses = c->ext.omp_clauses;\n       break;\n     case EXEC_OMP_CRITICAL:\n@@ -878,6 +881,7 @@ show_omp_node (int level, gfc_code *c)\n \t}\n       return;\n     case EXEC_OMP_BARRIER:\n+    case EXEC_OMP_TASKWAIT:\n       return;\n     default:\n       break;\n@@ -907,6 +911,7 @@ show_omp_node (int level, gfc_code *c)\n \t    case OMP_SCHED_DYNAMIC: type = \"DYNAMIC\"; break;\n \t    case OMP_SCHED_GUIDED: type = \"GUIDED\"; break;\n \t    case OMP_SCHED_RUNTIME: type = \"RUNTIME\"; break;\n+\t    case OMP_SCHED_AUTO: type = \"AUTO\"; break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -926,14 +931,18 @@ show_omp_node (int level, gfc_code *c)\n \t    case OMP_DEFAULT_NONE: type = \"NONE\"; break;\n \t    case OMP_DEFAULT_PRIVATE: type = \"PRIVATE\"; break;\n \t    case OMP_DEFAULT_SHARED: type = \"SHARED\"; break;\n-\t    case OMP_SCHED_RUNTIME: type = \"RUNTIME\"; break;\n+\t    case OMP_DEFAULT_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n \t  fprintf (dumpfile, \" DEFAULT(%s)\", type);\n \t}\n       if (omp_clauses->ordered)\n \tfputs (\" ORDERED\", dumpfile);\n+      if (omp_clauses->untied)\n+\tfputs (\" UNTIED\", dumpfile);\n+      if (omp_clauses->collapse)\n+\tfprintf (dumpfile, \" COLLAPSE(%d)\", omp_clauses->collapse);\n       for (list_type = 0; list_type < OMP_LIST_NUM; list_type++)\n \tif (omp_clauses->lists[list_type] != NULL\n \t    && list_type != OMP_LIST_COPYPRIVATE)\n@@ -1806,6 +1815,8 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_TASK:\n+    case EXEC_OMP_TASKWAIT:\n     case EXEC_OMP_WORKSHARE:\n       show_omp_node (level, c);\n       break;"}, {"sha": "42ab57a96067fcad69f615c5d5d3eb582cd9c30b", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -115,8 +115,12 @@ static alias_set_type gfc_get_alias_set (tree);\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n #undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n #undef LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR\n+#undef LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\n+#undef LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\n+#undef LANG_HOOKS_OMP_CLAUSE_DTOR\n #undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n #undef LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\n+#undef LANG_HOOKS_OMP_PRIVATE_OUTER_REF\n #undef LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES\n #undef LANG_HOOKS_BUILTIN_FUNCTION\n #undef LANG_HOOKS_GET_ARRAY_DESCR_INFO\n@@ -137,8 +141,12 @@ static alias_set_type gfc_get_alias_set (tree);\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\tgfc_omp_privatize_by_reference\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING\tgfc_omp_predetermined_sharing\n #define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR\tgfc_omp_clause_default_ctor\n+#define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\t\tgfc_omp_clause_copy_ctor\n+#define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\t\tgfc_omp_clause_assign_op\n+#define LANG_HOOKS_OMP_CLAUSE_DTOR\t\tgfc_omp_clause_dtor\n #define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\tgfc_omp_disregard_value_expr\n #define LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\tgfc_omp_private_debug_clause\n+#define LANG_HOOKS_OMP_PRIVATE_OUTER_REF\tgfc_omp_private_outer_ref\n #define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n   gfc_omp_firstprivatize_type_sizes\n #define LANG_HOOKS_BUILTIN_FUNCTION          gfc_builtin_function"}, {"sha": "8665a48c566540388e9f5b69ac452548f4cf9ed8", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -228,7 +228,8 @@ typedef enum\n   ST_OMP_END_WORKSHARE, ST_OMP_DO, ST_OMP_FLUSH, ST_OMP_MASTER, ST_OMP_ORDERED,\n   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n-  ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_PROCEDURE,\n+  ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,\n+  ST_OMP_TASKWAIT, ST_PROCEDURE,\n   ST_GET_FCN_CHARACTERISTICS, ST_NONE\n }\n gfc_statement;\n@@ -927,17 +928,20 @@ typedef struct gfc_omp_clauses\n       OMP_SCHED_STATIC,\n       OMP_SCHED_DYNAMIC,\n       OMP_SCHED_GUIDED,\n-      OMP_SCHED_RUNTIME\n+      OMP_SCHED_RUNTIME,\n+      OMP_SCHED_AUTO\n     } sched_kind;\n   struct gfc_expr *chunk_size;\n   enum\n     {\n       OMP_DEFAULT_UNKNOWN,\n       OMP_DEFAULT_NONE,\n       OMP_DEFAULT_PRIVATE,\n-      OMP_DEFAULT_SHARED\n+      OMP_DEFAULT_SHARED,\n+      OMP_DEFAULT_FIRSTPRIVATE\n     } default_sharing;\n-  bool nowait, ordered;\n+  int collapse;\n+  bool nowait, ordered, untied;\n }\n gfc_omp_clauses;\n \n@@ -1760,7 +1764,7 @@ typedef enum\n   EXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n   EXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,\n   EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n-  EXEC_OMP_END_SINGLE\n+  EXEC_OMP_END_SINGLE, EXEC_OMP_TASK, EXEC_OMP_TASKWAIT\n }\n gfc_exec_op;\n \n@@ -2040,6 +2044,7 @@ bool gfc_post_options (const char **);\n \n /* iresolve.c */\n const char * gfc_get_string (const char *, ...) ATTRIBUTE_PRINTF_1;\n+bool gfc_find_sym_in_expr (gfc_symbol *, gfc_expr *);\n \n /* error.c */\n "}, {"sha": "5ee91fb62dec8aff731c35a6bc09960fbe147dce", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -119,6 +119,8 @@ match gfc_match_omp_parallel_sections (void);\n match gfc_match_omp_parallel_workshare (void);\n match gfc_match_omp_sections (void);\n match gfc_match_omp_single (void);\n+match gfc_match_omp_task (void);\n+match gfc_match_omp_taskwait (void);\n match gfc_match_omp_threadprivate (void);\n match gfc_match_omp_workshare (void);\n match gfc_match_omp_end_nowait (void);"}, {"sha": "28f1cc24dfd4338315eebccf09d6cfa0bd79b830", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 156, "deletions": 22, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -182,6 +182,8 @@ gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n #define OMP_CLAUSE_SCHEDULE\t(1 << 9)\n #define OMP_CLAUSE_DEFAULT\t(1 << 10)\n #define OMP_CLAUSE_ORDERED\t(1 << 11)\n+#define OMP_CLAUSE_COLLAPSE\t(1 << 12)\n+#define OMP_CLAUSE_UNTIED\t(1 << 13)\n \n /* Match OpenMP directive clauses. MASK is a bitmask of\n    clauses that are allowed for a particular directive.  */\n@@ -335,6 +337,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n \t    c->default_sharing = OMP_DEFAULT_PRIVATE;\n \t  else if (gfc_match (\"default ( none )\") == MATCH_YES)\n \t    c->default_sharing = OMP_DEFAULT_NONE;\n+\t  else if (gfc_match (\"default ( firstprivate )\") == MATCH_YES)\n+\t    c->default_sharing = OMP_DEFAULT_FIRSTPRIVATE;\n \t  if (c->default_sharing != OMP_DEFAULT_UNKNOWN)\n \t    continue;\n \t}\n@@ -351,10 +355,13 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n \t    c->sched_kind = OMP_SCHED_GUIDED;\n \t  else if (gfc_match (\"runtime\") == MATCH_YES)\n \t    c->sched_kind = OMP_SCHED_RUNTIME;\n+\t  else if (gfc_match (\"auto\") == MATCH_YES)\n+\t    c->sched_kind = OMP_SCHED_AUTO;\n \t  if (c->sched_kind != OMP_SCHED_NONE)\n \t    {\n \t      match m = MATCH_NO;\n-\t      if (c->sched_kind != OMP_SCHED_RUNTIME)\n+\t      if (c->sched_kind != OMP_SCHED_RUNTIME\n+\t\t  && c->sched_kind != OMP_SCHED_AUTO)\n \t\tm = gfc_match (\" , %e )\", &c->chunk_size);\n \t      if (m != MATCH_YES)\n \t\tm = gfc_match_char (')');\n@@ -372,6 +379,36 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n \t  c->ordered = needs_space = true;\n \t  continue;\n \t}\n+      if ((mask & OMP_CLAUSE_UNTIED) && !c->untied\n+\t  && gfc_match (\"untied\") == MATCH_YES)\n+\t{\n+\t  c->untied = needs_space = true;\n+\t  continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_COLLAPSE) && !c->collapse)\n+\t{\n+\t  gfc_expr *cexpr = NULL;\n+\t  match m = gfc_match (\"collapse ( %e )\", &cexpr);\n+\n+\t  if (m == MATCH_YES)\n+\t    {\n+\t      int collapse;\n+\t      const char *p = gfc_extract_int (cexpr, &collapse);\n+\t      if (p)\n+\t\t{\n+\t\t  gfc_error (p);\n+\t\t  collapse = 1;\n+\t\t}\n+\t      else if (collapse <= 0)\n+\t\t{\n+\t\t  gfc_error (\"COLLAPSE clause argument not constant positive integer at %C\");\n+\t\t  collapse = 1;\n+\t\t}\n+\t      c->collapse = collapse;\n+\t      gfc_free_expr (cexpr);\n+\t      continue;\n+\t    }\n+\t}\n \n       break;\n     }\n@@ -393,10 +430,13 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n #define OMP_DO_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\t\t\\\n-   | OMP_CLAUSE_SCHEDULE | OMP_CLAUSE_ORDERED)\n+   | OMP_CLAUSE_SCHEDULE | OMP_CLAUSE_ORDERED | OMP_CLAUSE_COLLAPSE)\n #define OMP_SECTIONS_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION)\n+#define OMP_TASK_CLAUSES \\\n+  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n+   | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_UNTIED)\n \n match\n gfc_match_omp_parallel (void)\n@@ -410,6 +450,29 @@ gfc_match_omp_parallel (void)\n }\n \n \n+match\n+gfc_match_omp_task (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_TASK_CLAUSES) != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_TASK;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_taskwait (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_TASKWAIT;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_critical (void)\n {\n@@ -809,9 +872,6 @@ resolve_omp_clauses (gfc_code *code)\n \t\tif (!n->sym->attr.threadprivate)\n \t\t  gfc_error (\"Non-THREADPRIVATE object '%s' in COPYIN clause\"\n \t\t\t     \" at %L\", n->sym->name, &code->loc);\n-\t\tif (n->sym->attr.allocatable)\n-\t\t  gfc_error (\"COPYIN clause object '%s' is ALLOCATABLE at %L\",\n-\t\t\t     n->sym->name, &code->loc);\n \t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.derived->attr.alloc_comp)\n \t\t  gfc_error (\"COPYIN clause object '%s' at %L has ALLOCATABLE components\",\n \t\t\t     n->sym->name, &code->loc);\n@@ -823,9 +883,6 @@ resolve_omp_clauses (gfc_code *code)\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n \t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause \"\n \t\t\t     \"at %L\", n->sym->name, &code->loc);\n-\t\tif (n->sym->attr.allocatable)\n-\t\t  gfc_error (\"COPYPRIVATE clause object '%s' is ALLOCATABLE \"\n-\t\t\t     \"at %L\", n->sym->name, &code->loc);\n \t\tif (n->sym->ts.type == BT_DERIVED && n->sym->ts.derived->attr.alloc_comp)\n \t\t  gfc_error (\"COPYPRIVATE clause object '%s' at %L has ALLOCATABLE components\",\n \t\t\t     n->sym->name, &code->loc);\n@@ -856,9 +913,6 @@ resolve_omp_clauses (gfc_code *code)\n \t\t    if (n->sym->attr.pointer)\n \t\t      gfc_error (\"POINTER object '%s' in %s clause at %L\",\n \t\t\t\t n->sym->name, name, &code->loc);\n-\t\t    if (n->sym->attr.allocatable)\n-\t\t      gfc_error (\"%s clause object '%s' is ALLOCATABLE at %L\",\n-\t\t\t\t name, n->sym->name, &code->loc);\n \t\t    /* Variables in REDUCTION-clauses must be of intrinsic type (flagged below).  */\n \t\t    if ((list < OMP_LIST_REDUCTION_FIRST || list > OMP_LIST_REDUCTION_LAST) &&\n \t\t        n->sym->ts.type == BT_DERIVED && n->sym->ts.derived->attr.alloc_comp)\n@@ -1246,15 +1300,34 @@ struct omp_context\n   struct pointer_set_t *private_iterators;\n   struct omp_context *previous;\n } *omp_current_ctx;\n-gfc_code *omp_current_do_code;\n-\n+static gfc_code *omp_current_do_code;\n+static int omp_current_do_collapse;\n \n void\n gfc_resolve_omp_do_blocks (gfc_code *code, gfc_namespace *ns)\n {\n   if (code->block->next && code->block->next->op == EXEC_DO)\n-    omp_current_do_code = code->block->next;\n+    {\n+      int i;\n+      gfc_code *c;\n+\n+      omp_current_do_code = code->block->next;\n+      omp_current_do_collapse = code->ext.omp_clauses->collapse;\n+      for (i = 1, c = omp_current_do_code; i < omp_current_do_collapse; i++)\n+\t{\n+\t  c = c->block;\n+\t  if (c->op != EXEC_DO || c->next == NULL)\n+\t    break;\n+\t  c = c->next;\n+\t  if (c->op != EXEC_DO)\n+\t    break;\n+\t}\n+      if (i < omp_current_do_collapse || omp_current_do_collapse <= 0)\n+\tomp_current_do_collapse = 1;\n+    }\n   gfc_resolve_blocks (code->block, ns);\n+  omp_current_do_collapse = 0;\n+  omp_current_do_code = NULL;\n }\n \n \n@@ -1294,15 +1367,23 @@ void\n gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym)\n {\n   struct omp_context *ctx;\n+  int i = omp_current_do_collapse;\n+  gfc_code *c = omp_current_do_code;\n \n   if (sym->attr.threadprivate)\n     return;\n \n   /* !$omp do and !$omp parallel do iteration variable is predetermined\n      private just in the !$omp do resp. !$omp parallel do construct,\n      with no implications for the outer parallel constructs.  */\n-  if (code == omp_current_do_code)\n-    return;\n+\n+  while (i-- >= 1)\n+    {\n+      if (code == c)\n+\treturn;\n+\n+      c = c->block->next;\n+    }\n \n   for (ctx = omp_current_ctx; ctx; ctx = ctx->previous)\n     {\n@@ -1326,20 +1407,26 @@ gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym)\n static void\n resolve_omp_do (gfc_code *code)\n {\n-  gfc_code *do_code;\n-  int list;\n+  gfc_code *do_code, *c;\n+  int list, i, collapse;\n   gfc_namelist *n;\n   gfc_symbol *dovar;\n \n   if (code->ext.omp_clauses)\n     resolve_omp_clauses (code);\n \n   do_code = code->block->next;\n-  if (do_code->op == EXEC_DO_WHILE)\n-    gfc_error (\"!$OMP DO cannot be a DO WHILE or DO without loop control \"\n-\t       \"at %L\", &do_code->loc);\n-  else\n+  collapse = code->ext.omp_clauses->collapse;\n+  if (collapse <= 0)\n+    collapse = 1;\n+  for (i = 1; i <= collapse; i++)\n     {\n+      if (do_code->op == EXEC_DO_WHILE)\n+\t{\n+\t  gfc_error (\"!$OMP DO cannot be a DO WHILE or DO without loop control \"\n+\t\t     \"at %L\", &do_code->loc);\n+\t  break;\n+\t}\n       gcc_assert (do_code->op == EXEC_DO);\n       if (do_code->ext.iterator->var->ts.type != BT_INTEGER)\n \tgfc_error (\"!$OMP DO iteration variable must be of type integer at %L\",\n@@ -1359,6 +1446,53 @@ resolve_omp_do (gfc_code *code)\n \t\t\t     &do_code->loc);\n \t\t  break;\n \t\t}\n+      if (i > 1)\n+\t{\n+\t  gfc_code *do_code2 = code->block->next;\n+\t  int j;\n+\n+\t  for (j = 1; j < i; j++)\n+\t    {\n+\t      gfc_symbol *ivar = do_code2->ext.iterator->var->symtree->n.sym;\n+\t      if (dovar == ivar\n+\t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->start)\n+\t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->end)\n+\t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->step))\n+\t\t{\n+\t\t  gfc_error (\"!$OMP DO collapsed loops don't form rectangular iteration space at %L\",\n+\t\t\t     &do_code->loc);\n+\t\t  break;\n+\t\t}\n+\t      if (j < i)\n+\t\tbreak;\n+\t      do_code2 = do_code2->block->next;\n+\t    }\n+\t}\n+      if (i == collapse)\n+\tbreak;\n+      for (c = do_code->next; c; c = c->next)\n+\tif (c->op != EXEC_NOP && c->op != EXEC_CONTINUE)\n+\t  {\n+\t    gfc_error (\"collapsed !$OMP DO loops not perfectly nested at %L\",\n+\t\t       &c->loc);\n+\t    break;\n+\t  }\n+      if (c)\n+\tbreak;\n+      do_code = do_code->block;\n+      if (do_code->op != EXEC_DO && do_code->op != EXEC_DO_WHILE)\n+\t{\n+\t  gfc_error (\"not enough DO loops for collapsed !$OMP DO at %L\",\n+\t\t     &code->loc);\n+\t  break;\n+\t}\n+      do_code = do_code->next;\n+      if (do_code->op != EXEC_DO && do_code->op != EXEC_DO_WHILE)\n+\t{\n+\t  gfc_error (\"not enough DO loops for collapsed !$OMP DO at %L\",\n+\t\t     &code->loc);\n+\t  break;\n+\t}\n     }\n }\n "}, {"sha": "c35db2d9cf6745d0cfac26de25681e857b9db7cd", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -515,6 +515,7 @@ decode_omp_directive (void)\n       match (\"end parallel\", gfc_match_omp_eos, ST_OMP_END_PARALLEL);\n       match (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n       match (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n+      match (\"end task\", gfc_match_omp_eos, ST_OMP_END_TASK);\n       match (\"end workshare\", gfc_match_omp_end_nowait,\n \t     ST_OMP_END_WORKSHARE);\n       break;\n@@ -541,6 +542,8 @@ decode_omp_directive (void)\n       match (\"single\", gfc_match_omp_single, ST_OMP_SINGLE);\n       break;\n     case 't':\n+      match (\"task\", gfc_match_omp_task, ST_OMP_TASK);\n+      match (\"taskwait\", gfc_match_omp_taskwait, ST_OMP_TASKWAIT);\n       match (\"threadprivate\", gfc_match_omp_threadprivate,\n \t     ST_OMP_THREADPRIVATE);\n     case 'w':\n@@ -641,7 +644,7 @@ next_free (void)\n \t  for (i = 0; i < 5; i++, c = gfc_next_ascii_char ())\n \t    gcc_assert (c == \"!$omp\"[i]);\n \n-\t  gcc_assert (c == ' ');\n+\t  gcc_assert (c == ' ' || c == '\\t');\n \t  gfc_gobble_whitespace ();\n \t  return decode_omp_directive ();\n \t}\n@@ -870,7 +873,7 @@ next_statement (void)\n   case ST_POINTER_ASSIGNMENT: case ST_EXIT: case ST_CYCLE: \\\n   case ST_ASSIGNMENT: case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n-  case ST_OMP_BARRIER\n+  case ST_OMP_BARRIER: case ST_OMP_TASKWAIT\n \n /* Statements that mark other executable statements.  */\n \n@@ -879,7 +882,8 @@ next_statement (void)\n   case ST_OMP_PARALLEL_SECTIONS: case ST_OMP_SECTIONS: case ST_OMP_ORDERED: \\\n   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \\\n   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \\\n-  case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE\n+  case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE: \\\n+  case ST_OMP_TASK\n \n /* Declaration statements */\n \n@@ -1351,6 +1355,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_END_SINGLE:\n       p = \"!$OMP END SINGLE\";\n       break;\n+    case ST_OMP_END_TASK:\n+      p = \"!$OMP END TASK\";\n+      break;\n     case ST_OMP_END_WORKSHARE:\n       p = \"!$OMP END WORKSHARE\";\n       break;\n@@ -1384,6 +1391,12 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_SINGLE:\n       p = \"!$OMP SINGLE\";\n       break;\n+    case ST_OMP_TASK:\n+      p = \"!$OMP TASK\";\n+      break;\n+    case ST_OMP_TASKWAIT:\n+      p = \"!$OMP TASKWAIT\";\n+      break;\n     case ST_OMP_THREADPRIVATE:\n       p = \"!$OMP THREADPRIVATE\";\n       break;\n@@ -2857,6 +2870,9 @@ parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n     case ST_OMP_SINGLE:\n       omp_end_st = ST_OMP_END_SINGLE;\n       break;\n+    case ST_OMP_TASK:\n+      omp_end_st = ST_OMP_END_TASK;\n+      break;\n     case ST_OMP_WORKSHARE:\n       omp_end_st = ST_OMP_END_WORKSHARE;\n       break;\n@@ -3067,6 +3083,7 @@ parse_executable (gfc_statement st)\n \tcase ST_OMP_CRITICAL:\n \tcase ST_OMP_MASTER:\n \tcase ST_OMP_SINGLE:\n+\tcase ST_OMP_TASK:\n \t  parse_omp_structured_block (st, false);\n \t  break;\n "}, {"sha": "2787e293021d32e0c48cb154e74267b4aa79df6f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -4670,8 +4670,8 @@ sym_in_expr (gfc_expr *e, gfc_symbol *sym, int *f ATTRIBUTE_UNUSED)\n   return false;\n }\n \n-static bool\n-find_sym_in_expr (gfc_symbol *sym, gfc_expr *e)\n+bool\n+gfc_find_sym_in_expr (gfc_symbol *sym, gfc_expr *e)\n {\n   return gfc_traverse_expr (e, sym, sym_in_expr, 0);\n }\n@@ -4868,8 +4868,10 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t  if (sym->ts.type == BT_DERIVED)\n \t    continue;\n \n-\t  if ((ar->start[i] != NULL && find_sym_in_expr (sym, ar->start[i]))\n-\t\t || (ar->end[i] != NULL && find_sym_in_expr (sym, ar->end[i])))\n+\t  if ((ar->start[i] != NULL\n+\t       && gfc_find_sym_in_expr (sym, ar->start[i]))\n+\t      || (ar->end[i] != NULL\n+\t\t  && gfc_find_sym_in_expr (sym, ar->end[i])))\n \t    {\n \t      gfc_error (\"'%s' must not appear an the array specification at \"\n \t\t\t \"%L in the same ALLOCATE statement where it is \"\n@@ -5982,6 +5984,8 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OMP_PARALLEL_WORKSHARE:\n \tcase EXEC_OMP_SECTIONS:\n \tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_TASK:\n+\tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_WORKSHARE:\n \t  break;\n \n@@ -6100,8 +6104,8 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t  {\n \t    for (n = 0; n < ref->u.ar.dimen; n++)\n \t      if (ref->u.ar.dimen_type[n] == DIMEN_VECTOR\n-\t\t    && find_sym_in_expr (lhs->symtree->n.sym,\n-\t\t\t\t\t ref->u.ar.start[n]))\n+\t\t  && gfc_find_sym_in_expr (lhs->symtree->n.sym,\n+\t\t\t\t\t   ref->u.ar.start[n]))\n \t\tref->u.ar.start[n]\n \t\t\t= gfc_get_parentheses (ref->u.ar.start[n]);\n \t  }\n@@ -6176,6 +6180,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_PARALLEL:\n \t    case EXEC_OMP_PARALLEL_DO:\n \t    case EXEC_OMP_PARALLEL_SECTIONS:\n+\t    case EXEC_OMP_TASK:\n \t      omp_workshare_save = omp_workshare_flag;\n \t      omp_workshare_flag = 0;\n \t      gfc_resolve_omp_parallel_blocks (code, ns);\n@@ -6418,6 +6423,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_ORDERED:\n \tcase EXEC_OMP_SECTIONS:\n \tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_WORKSHARE:\n \t  gfc_resolve_omp_directive (code, ns);\n \t  break;\n@@ -6426,6 +6432,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_PARALLEL_DO:\n \tcase EXEC_OMP_PARALLEL_SECTIONS:\n \tcase EXEC_OMP_PARALLEL_WORKSHARE:\n+\tcase EXEC_OMP_TASK:\n \t  omp_workshare_save = omp_workshare_flag;\n \t  omp_workshare_flag = 0;\n \t  gfc_resolve_omp_directive (code, ns);"}, {"sha": "1b0eeca1e6593a59a654731161349ccdc558f6b8", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -702,7 +702,8 @@ skip_free_comments (void)\n \t\t      if (((c = next_char ()) == 'm' || c == 'M')\n \t\t\t  && ((c = next_char ()) == 'p' || c == 'P'))\n \t\t\t{\n-\t\t\t  if ((c = next_char ()) == ' ' || continue_flag)\n+\t\t\t  if ((c = next_char ()) == ' ' || c == '\\t'\n+\t\t\t      || continue_flag)\n \t\t\t    {\n \t\t\t      while (gfc_is_whitespace (c))\n \t\t\t\tc = next_char ();\n@@ -724,7 +725,7 @@ skip_free_comments (void)\n \t\t      next_char ();\n \t\t      c = next_char ();\n \t\t    }\n-\t\t  if (continue_flag || c == ' ')\n+\t\t  if (continue_flag || c == ' ' || c == '\\t')\n \t\t    {\n \t\t      gfc_current_locus = old_loc;\n \t\t      next_char ();\n@@ -820,11 +821,11 @@ skip_fixed_comments (void)\n \t\t\t  c = next_char ();\n \t\t\t  if (c != '\\n'\n \t\t\t      && ((openmp_flag && continue_flag)\n-\t\t\t\t  || c == ' ' || c == '0'))\n+\t\t\t\t  || c == ' ' || c == '\\t' || c == '0'))\n \t\t\t    {\n-\t\t\t      c = next_char ();\n-\t\t\t      while (gfc_is_whitespace (c))\n+\t\t\t      do\n \t\t\t\tc = next_char ();\n+\t\t\t      while (gfc_is_whitespace (c));\n \t\t\t      if (c != '\\n' && c != '!')\n \t\t\t\t{\n \t\t\t\t  /* Canonicalize to *$omp.  */\n@@ -843,14 +844,19 @@ skip_fixed_comments (void)\n \t\t      for (col = 3; col < 6; col++, c = next_char ())\n \t\t\tif (c == ' ')\n \t\t\t  continue;\n+\t\t\telse if (c == '\\t')\n+\t\t\t  {\n+\t\t\t    col = 6;\n+\t\t\t    break;\n+\t\t\t  }\n \t\t\telse if (c < '0' || c > '9')\n \t\t\t  break;\n \t\t\telse\n \t\t\t  digit_seen = 1;\n \n \t\t      if (col == 6 && c != '\\n'\n \t\t\t  && ((continue_flag && !digit_seen)\n-\t\t\t      || c == ' ' || c == '0'))\n+\t\t\t      || c == ' ' || c == '\\t' || c == '0'))\n \t\t\t{\n \t\t\t  gfc_current_locus = start;\n \t\t\t  start.nextc[0] = ' ';"}, {"sha": "abe7b94865c88f421c027ab8bbe26ac5a76946b9", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -171,6 +171,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OMP_PARALLEL_SECTIONS:\n     case EXEC_OMP_SECTIONS:\n     case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_TASK:\n     case EXEC_OMP_WORKSHARE:\n     case EXEC_OMP_PARALLEL_WORKSHARE:\n       gfc_free_omp_clauses (p->ext.omp_clauses);\n@@ -189,6 +190,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OMP_MASTER:\n     case EXEC_OMP_ORDERED:\n     case EXEC_OMP_END_NOWAIT:\n+    case EXEC_OMP_TASKWAIT:\n       break;\n \n     default:"}, {"sha": "6f99800a0147f528a3faa72be365a7ef65e25eb4", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 431, "deletions": 104, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -84,6 +84,17 @@ gfc_omp_predetermined_sharing (tree decl)\n   if (GFC_DECL_CRAY_POINTEE (decl))\n     return OMP_CLAUSE_DEFAULT_PRIVATE;\n \n+  /* Assumed-size arrays are predetermined to inherit sharing\n+     attributes of the associated actual argument, which is shared\n+     for all we care.  */\n+  if (TREE_CODE (decl) == PARM_DECL\n+      && GFC_ARRAY_TYPE_P (TREE_TYPE (decl))\n+      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_UNKNOWN\n+      && GFC_TYPE_ARRAY_UBOUND (TREE_TYPE (decl),\n+\t\t\t\tGFC_TYPE_ARRAY_RANK (TREE_TYPE (decl)) - 1)\n+\t == NULL)\n+    return OMP_CLAUSE_DEFAULT_SHARED;\n+\n   /* COMMON and EQUIVALENCE decls are shared.  They\n      are only referenced through DECL_VALUE_EXPR of the variables\n      contained in them.  If those are privatized, they will not be\n@@ -98,27 +109,179 @@ gfc_omp_predetermined_sharing (tree decl)\n }\n \n \n+/* Return true if DECL in private clause needs\n+   OMP_CLAUSE_PRIVATE_OUTER_REF on the private clause.  */\n+bool\n+gfc_omp_private_outer_ref (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (type)\n+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Return code to initialize DECL with its default constructor, or\n    NULL if there's nothing to do.  */\n \n tree\n-gfc_omp_clause_default_ctor (tree clause ATTRIBUTE_UNUSED, tree decl)\n+gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n {\n-  tree type = TREE_TYPE (decl);\n-  stmtblock_t block;\n+  tree type = TREE_TYPE (decl), rank, size, esize, ptr, cond, then_b, else_b;\n+  stmtblock_t block, cond_block;\n \n-  if (! GFC_DESCRIPTOR_TYPE_P (type))\n+  if (! GFC_DESCRIPTOR_TYPE_P (type)\n+      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n     return NULL;\n \n+  gcc_assert (outer != NULL);\n+  gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_PRIVATE\n+\t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LASTPRIVATE);\n+\n   /* Allocatable arrays in PRIVATE clauses need to be set to\n-     \"not currently allocated\" allocation status.  */\n-  gfc_init_block (&block);\n+     \"not currently allocated\" allocation status if outer\n+     array is \"not currently allocated\", otherwise should be allocated.  */\n+  gfc_start_block (&block);\n+\n+  gfc_init_block (&cond_block);\n+\n+  gfc_add_modify_expr (&cond_block, decl, outer);\n+  rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+  size = gfc_conv_descriptor_ubound (decl, rank);\n+  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n+\t\t      gfc_conv_descriptor_lbound (decl, rank));\n+  size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n+\t\t      gfc_index_one_node);\n+  if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+    size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\tgfc_conv_descriptor_stride (decl, rank));\n+  esize = fold_convert (gfc_array_index_type,\n+\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+  size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n+  ptr = gfc_allocate_array_with_status (&cond_block,\n+\t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n+\t\t\t\t\tsize, NULL);\n+  gfc_conv_descriptor_data_set_tuples (&cond_block, decl, ptr);\n+  then_b = gfc_finish_block (&cond_block);\n+\n+  gfc_init_block (&cond_block);\n+  gfc_conv_descriptor_data_set_tuples (&cond_block, decl, null_pointer_node);\n+  else_b = gfc_finish_block (&cond_block);\n+\n+  cond = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t      fold_convert (pvoid_type_node,\n+\t\t\t\t    gfc_conv_descriptor_data_get (outer)),\n+\t\t      null_pointer_node);\n+  gfc_add_expr_to_block (&block, build3 (COND_EXPR, void_type_node,\n+\t\t\t cond, then_b, else_b));\n \n-  gfc_conv_descriptor_data_set_tuples (&block, decl, null_pointer_node);\n+  return gfc_finish_block (&block);\n+}\n+\n+/* Build and return code for a copy constructor from SRC to DEST.  */\n+\n+tree\n+gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n+{\n+  tree type = TREE_TYPE (dest), ptr, size, esize, rank, call;\n+  stmtblock_t block;\n+\n+  if (! GFC_DESCRIPTOR_TYPE_P (type)\n+      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+    return build_gimple_modify_stmt (dest, src);\n+\n+  gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_FIRSTPRIVATE);\n+\n+  /* Allocatable arrays in FIRSTPRIVATE clauses need to be allocated\n+     and copied from SRC.  */\n+  gfc_start_block (&block);\n+\n+  gfc_add_modify_expr (&block, dest, src);\n+  rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+  size = gfc_conv_descriptor_ubound (dest, rank);\n+  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n+\t\t      gfc_conv_descriptor_lbound (dest, rank));\n+  size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n+\t\t      gfc_index_one_node);\n+  if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+    size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\tgfc_conv_descriptor_stride (dest, rank));\n+  esize = fold_convert (gfc_array_index_type,\n+\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+  size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n+  ptr = gfc_allocate_array_with_status (&block,\n+\t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n+\t\t\t\t\tsize, NULL);\n+  gfc_conv_descriptor_data_set_tuples (&block, dest, ptr);\n+  call = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n+\t\t\t  fold_convert (pvoid_type_node,\n+\t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n+\t\t\t  size);\n+  gfc_add_expr_to_block (&block, fold_convert (void_type_node, call));\n \n   return gfc_finish_block (&block);\n }\n \n+/* Similarly, except use an assignment operator instead.  */\n+\n+tree\n+gfc_omp_clause_assign_op (tree clause ATTRIBUTE_UNUSED, tree dest, tree src)\n+{\n+  tree type = TREE_TYPE (dest), rank, size, esize, call;\n+  stmtblock_t block;\n+\n+  if (! GFC_DESCRIPTOR_TYPE_P (type)\n+      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+    return build_gimple_modify_stmt (dest, src);\n+\n+  /* Handle copying allocatable arrays.  */\n+  gfc_start_block (&block);\n+\n+  rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+  size = gfc_conv_descriptor_ubound (dest, rank);\n+  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n+\t\t      gfc_conv_descriptor_lbound (dest, rank));\n+  size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n+\t\t      gfc_index_one_node);\n+  if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+    size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\tgfc_conv_descriptor_stride (dest, rank));\n+  esize = fold_convert (gfc_array_index_type,\n+\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+  size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n+  call = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n+\t\t\t  fold_convert (pvoid_type_node,\n+\t\t\t\t\tgfc_conv_descriptor_data_get (dest)),\n+\t\t\t  fold_convert (pvoid_type_node,\n+\t\t\t\t\tgfc_conv_descriptor_data_get (src)),\n+\t\t\t  size);\n+  gfc_add_expr_to_block (&block, fold_convert (void_type_node, call));\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+/* Build and return code destructing DECL.  Return NULL if nothing\n+   to be done.  */\n+\n+tree\n+gfc_omp_clause_dtor (tree clause ATTRIBUTE_UNUSED, tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (! GFC_DESCRIPTOR_TYPE_P (type)\n+      || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+    return NULL;\n+\n+  /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n+     to be deallocated if they were allocated.  */\n+  return gfc_trans_dealloc_allocated (decl);\n+}\n+\n \n /* Return true if DECL's DECL_VALUE_EXPR (if any) should be\n    disregarded in OpenMP construct, because it is going to be\n@@ -429,7 +592,39 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n \n   /* Create the init statement list.  */\n   pushlevel (0);\n-  stmt = gfc_trans_assignment (e1, e2, false);\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))\n+      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)\n+    {\n+      /* If decl is an allocatable array, it needs to be allocated\n+\t with the same bounds as the outer var.  */\n+      tree type = TREE_TYPE (decl), rank, size, esize, ptr;\n+      stmtblock_t block;\n+\n+      gfc_start_block (&block);\n+\n+      gfc_add_modify_expr (&block, decl, outer_sym.backend_decl);\n+      rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+      size = gfc_conv_descriptor_ubound (decl, rank);\n+      size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n+\t\t\t  gfc_conv_descriptor_lbound (decl, rank));\n+      size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n+\t\t\t  gfc_index_one_node);\n+      if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+\tsize = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\t    gfc_conv_descriptor_stride (decl, rank));\n+      esize = fold_convert (gfc_array_index_type,\n+\t\t\t    TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+      size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n+      ptr = gfc_allocate_array_with_status (&block,\n+\t\t\t\t\t    build_int_cst (pvoid_type_node, 0),\n+\t\t\t\t\t    size, NULL);\n+      gfc_conv_descriptor_data_set_tuples (&block, decl, ptr);\n+      gfc_add_expr_to_block (&block, gfc_trans_assignment (e1, e2, false));\n+      stmt = gfc_finish_block (&block);\n+    }\n+  else\n+    stmt = gfc_trans_assignment (e1, e2, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n@@ -438,7 +633,20 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n \n   /* Create the merge statement list.  */\n   pushlevel (0);\n-  stmt = gfc_trans_assignment (e3, e4, false);\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))\n+      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)\n+    {\n+      /* If decl is an allocatable array, it needs to be deallocated\n+\t afterwards.  */\n+      stmtblock_t block;\n+\n+      gfc_start_block (&block);\n+      gfc_add_expr_to_block (&block, gfc_trans_assignment (e3, e4, false));\n+      gfc_add_expr_to_block (&block, gfc_trans_dealloc_allocated (decl));\n+      stmt = gfc_finish_block (&block);\n+    }\n+  else\n+    stmt = gfc_trans_assignment (e3, e4, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n@@ -639,6 +847,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \tcase OMP_SCHED_RUNTIME:\n \t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;\n \t  break;\n+\tcase OMP_SCHED_AUTO:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_AUTO;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -659,6 +870,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \tcase OMP_DEFAULT_PRIVATE:\n \t  OMP_CLAUSE_DEFAULT_KIND (c) = OMP_CLAUSE_DEFAULT_PRIVATE;\n \t  break;\n+\tcase OMP_DEFAULT_FIRSTPRIVATE:\n+\t  OMP_CLAUSE_DEFAULT_KIND (c) = OMP_CLAUSE_DEFAULT_FIRSTPRIVATE;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -677,6 +891,19 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n+  if (clauses->untied)\n+    {\n+      c = build_omp_clause (OMP_CLAUSE_UNTIED);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->collapse)\n+    {\n+      c = build_omp_clause (OMP_CLAUSE_COLLAPSE);\n+      OMP_CLAUSE_COLLAPSE_EXPR (c) = build_int_cst (NULL, clauses->collapse);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n   return omp_clauses;\n }\n \n@@ -893,128 +1120,197 @@ gfc_trans_omp_critical (gfc_code *code)\n \n static tree\n gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n-\t\t  gfc_omp_clauses *do_clauses)\n+\t\t  gfc_omp_clauses *do_clauses, tree par_clauses)\n {\n   gfc_se se;\n   tree dovar, stmt, from, to, step, type, init, cond, incr;\n   tree count = NULL_TREE, cycle_label, tmp, omp_clauses;\n   stmtblock_t block;\n   stmtblock_t body;\n-  int simple = 0;\n-  bool dovar_found = false;\n   gfc_omp_clauses *clauses = code->ext.omp_clauses;\n+  gfc_code *outermost;\n+  int i, collapse = clauses->collapse;\n+  tree dovar_init = NULL_TREE;\n \n-  code = code->block->next;\n+  if (collapse <= 0)\n+    collapse = 1;\n+\n+  outermost = code = code->block->next;\n   gcc_assert (code->op == EXEC_DO);\n \n+  init = make_tree_vec (collapse);\n+  cond = make_tree_vec (collapse);\n+  incr = make_tree_vec (collapse);\n+\n   if (pblock == NULL)\n     {\n       gfc_start_block (&block);\n       pblock = &block;\n     }\n \n   omp_clauses = gfc_trans_omp_clauses (pblock, do_clauses, code->loc);\n-  if (clauses)\n-    {\n-      gfc_namelist *n;\n-      for (n = clauses->lists[OMP_LIST_LASTPRIVATE]; n != NULL; n = n->next)\n-\tif (code->ext.iterator->var->symtree->n.sym == n->sym)\n-\t  break;\n-      if (n == NULL)\n-\tfor (n = clauses->lists[OMP_LIST_PRIVATE]; n != NULL; n = n->next)\n-\t  if (code->ext.iterator->var->symtree->n.sym == n->sym)\n-\t    break;\n-      if (n != NULL)\n-\tdovar_found = true;\n-    }\n \n-  /* Evaluate all the expressions in the iterator.  */\n-  gfc_init_se (&se, NULL);\n-  gfc_conv_expr_lhs (&se, code->ext.iterator->var);\n-  gfc_add_block_to_block (pblock, &se.pre);\n-  dovar = se.expr;\n-  type = TREE_TYPE (dovar);\n-  gcc_assert (TREE_CODE (type) == INTEGER_TYPE);\n-\n-  gfc_init_se (&se, NULL);\n-  gfc_conv_expr_val (&se, code->ext.iterator->start);\n-  gfc_add_block_to_block (pblock, &se.pre);\n-  from = gfc_evaluate_now (se.expr, pblock);\n-\n-  gfc_init_se (&se, NULL);\n-  gfc_conv_expr_val (&se, code->ext.iterator->end);\n-  gfc_add_block_to_block (pblock, &se.pre);\n-  to = gfc_evaluate_now (se.expr, pblock);\n-\n-  gfc_init_se (&se, NULL);\n-  gfc_conv_expr_val (&se, code->ext.iterator->step);\n-  gfc_add_block_to_block (pblock, &se.pre);\n-  step = gfc_evaluate_now (se.expr, pblock);\n-\n-  /* Special case simple loops.  */\n-  if (integer_onep (step))\n-    simple = 1;\n-  else if (tree_int_cst_equal (step, integer_minus_one_node))\n-    simple = -1;\n-\n-  /* Loop body.  */\n-  if (simple)\n+  for (i = 0; i < collapse; i++)\n     {\n-      init = build2_v (GIMPLE_MODIFY_STMT, dovar, from);\n-      cond = fold_build2 (simple > 0 ? LE_EXPR : GE_EXPR, boolean_type_node,\n-\t\t\t  dovar, to);\n-      incr = fold_build2 (PLUS_EXPR, type, dovar, step);\n-      incr = fold_build2 (GIMPLE_MODIFY_STMT, type, dovar, incr);\n-      if (pblock != &block)\n+      int simple = 0;\n+      int dovar_found = 0;\n+\n+      if (clauses)\n \t{\n-\t  pushlevel (0);\n-\t  gfc_start_block (&block);\n+\t  gfc_namelist *n;\n+\t  for (n = clauses->lists[OMP_LIST_LASTPRIVATE]; n != NULL;\n+\t       n = n->next)\n+\t    if (code->ext.iterator->var->symtree->n.sym == n->sym)\n+\t      break;\n+\t  if (n != NULL)\n+\t    dovar_found = 1;\n+\t  else if (n == NULL)\n+\t    for (n = clauses->lists[OMP_LIST_PRIVATE]; n != NULL; n = n->next)\n+\t      if (code->ext.iterator->var->symtree->n.sym == n->sym)\n+\t\tbreak;\n+\t  if (n != NULL)\n+\t    dovar_found++;\n \t}\n-      gfc_start_block (&body);\n-    }\n-  else\n-    {\n-      /* STEP is not 1 or -1.  Use:\n-\t for (count = 0; count < (to + step - from) / step; count++)\n-\t   {\n-\t     dovar = from + count * step;\n-\t     body;\n-\t   cycle_label:;\n-\t   }  */\n-      tmp = fold_build2 (MINUS_EXPR, type, step, from);\n-      tmp = fold_build2 (PLUS_EXPR, type, to, tmp);\n-      tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n-      tmp = gfc_evaluate_now (tmp, pblock);\n-      count = gfc_create_var (type, \"count\");\n-      init = build2_v (GIMPLE_MODIFY_STMT, count, build_int_cst (type, 0));\n-      cond = fold_build2 (LT_EXPR, boolean_type_node, count, tmp);\n-      incr = fold_build2 (PLUS_EXPR, type, count, build_int_cst (type, 1));\n-      incr = fold_build2 (GIMPLE_MODIFY_STMT, type, count, incr);\n-\n-      if (pblock != &block)\n+\n+      /* Evaluate all the expressions in the iterator.  */\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_lhs (&se, code->ext.iterator->var);\n+      gfc_add_block_to_block (pblock, &se.pre);\n+      dovar = se.expr;\n+      type = TREE_TYPE (dovar);\n+      gcc_assert (TREE_CODE (type) == INTEGER_TYPE);\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_val (&se, code->ext.iterator->start);\n+      gfc_add_block_to_block (pblock, &se.pre);\n+      from = gfc_evaluate_now (se.expr, pblock);\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_val (&se, code->ext.iterator->end);\n+      gfc_add_block_to_block (pblock, &se.pre);\n+      to = gfc_evaluate_now (se.expr, pblock);\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_val (&se, code->ext.iterator->step);\n+      gfc_add_block_to_block (pblock, &se.pre);\n+      step = gfc_evaluate_now (se.expr, pblock);\n+\n+      /* Special case simple loops.  */\n+      if (integer_onep (step))\n+\tsimple = 1;\n+      else if (tree_int_cst_equal (step, integer_minus_one_node))\n+\tsimple = -1;\n+\n+      /* Loop body.  */\n+      if (simple)\n \t{\n-\t  pushlevel (0);\n-\t  gfc_start_block (&block);\n+\t  TREE_VEC_ELT (init, i) = build2_v (GIMPLE_MODIFY_STMT, dovar, from);\n+\t  TREE_VEC_ELT (cond, i) = fold_build2 (simple > 0 ? LE_EXPR : GE_EXPR,\n+\t\t\t\t\t\tboolean_type_node, dovar, to);\n+\t  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, dovar, step);\n+\t  TREE_VEC_ELT (incr, i) = fold_build2 (GIMPLE_MODIFY_STMT, type, dovar,\n+\t\t\t\t\t\tTREE_VEC_ELT (incr, i));\n+\t}\n+      else\n+\t{\n+\t  /* STEP is not 1 or -1.  Use:\n+\t     for (count = 0; count < (to + step - from) / step; count++)\n+\t       {\n+\t\t dovar = from + count * step;\n+\t\t body;\n+\t       cycle_label:;\n+\t       }  */\n+\t  tmp = fold_build2 (MINUS_EXPR, type, step, from);\n+\t  tmp = fold_build2 (PLUS_EXPR, type, to, tmp);\n+\t  tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n+\t  tmp = gfc_evaluate_now (tmp, pblock);\n+\t  count = gfc_create_var (type, \"count\");\n+\t  TREE_VEC_ELT (init, i) = build2_v (GIMPLE_MODIFY_STMT, count,\n+\t\t\t\t\t     build_int_cst (type, 0));\n+\t  TREE_VEC_ELT (cond, i) = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t\tcount, tmp);\n+\t  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, count,\n+\t\t\t\t\t\tbuild_int_cst (type, 1));\n+\t  TREE_VEC_ELT (incr, i) = fold_build2 (GIMPLE_MODIFY_STMT, type,\n+\t\t\t\t\t\tcount, TREE_VEC_ELT (incr, i));\n+\n+\t  /* Initialize DOVAR.  */\n+\t  tmp = fold_build2 (MULT_EXPR, type, count, step);\n+\t  tmp = fold_build2 (PLUS_EXPR, type, from, tmp);\n+\t  dovar_init = tree_cons (dovar, tmp, dovar_init);\n \t}\n-      gfc_start_block (&body);\n \n-      /* Initialize DOVAR.  */\n-      tmp = fold_build2 (MULT_EXPR, type, count, step);\n-      tmp = fold_build2 (PLUS_EXPR, type, from, tmp);\n-      gfc_add_modify_stmt (&body, dovar, tmp);\n+      if (!dovar_found)\n+\t{\n+\t  tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t  OMP_CLAUSE_DECL (tmp) = dovar;\n+\t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+\t}\n+      else if (dovar_found == 2)\n+\t{\n+\t  tree c = NULL;\n+\n+\t  tmp = NULL;\n+\t  if (!simple)\n+\t    {\n+\t      /* If dovar is lastprivate, but different counter is used,\n+\t\t dovar += step needs to be added to\n+\t\t OMP_CLAUSE_LASTPRIVATE_STMT, otherwise the copied dovar\n+\t\t will have the value on entry of the last loop, rather\n+\t\t than value after iterator increment.  */\n+\t      tmp = gfc_evaluate_now (step, pblock);\n+\t      tmp = fold_build2 (PLUS_EXPR, type, dovar, tmp);\n+\t      tmp = fold_build2 (GIMPLE_MODIFY_STMT, type, dovar, tmp);\n+\t      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t    && OMP_CLAUSE_DECL (c) == dovar)\n+\t\t  {\n+\t\t    OMP_CLAUSE_LASTPRIVATE_STMT (c) = tmp;\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t  if (c == NULL && par_clauses != NULL)\n+\t    {\n+\t      for (c = par_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t    && OMP_CLAUSE_DECL (c) == dovar)\n+\t\t  {\n+\t\t    tree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);\n+\t\t    OMP_CLAUSE_DECL (l) = dovar;\n+\t\t    OMP_CLAUSE_CHAIN (l) = omp_clauses;\n+\t\t    OMP_CLAUSE_LASTPRIVATE_STMT (l) = tmp;\n+\t\t    omp_clauses = l;\n+\t\t    OMP_CLAUSE_SET_CODE (c, OMP_CLAUSE_SHARED);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t  gcc_assert (simple || c != NULL);\n+\t}\n+      if (!simple)\n+\t{\n+\t  tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t  OMP_CLAUSE_DECL (tmp) = count;\n+\t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+\t}\n+\n+      if (i + 1 < collapse)\n+\tcode = code->block->next;\n     }\n \n-  if (!dovar_found)\n+  if (pblock != &block)\n     {\n-      tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n-      OMP_CLAUSE_DECL (tmp) = dovar;\n-      omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+      pushlevel (0);\n+      gfc_start_block (&block);\n     }\n-  if (!simple)\n+\n+  gfc_start_block (&body);\n+\n+  dovar_init = nreverse (dovar_init);\n+  while (dovar_init)\n     {\n-      tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n-      OMP_CLAUSE_DECL (tmp) = count;\n-      omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+      gfc_add_modify_stmt (&body, TREE_PURPOSE (dovar_init),\n+\t\t\t   TREE_VALUE (dovar_init));\n+      dovar_init = TREE_CHAIN (dovar_init);\n     }\n \n   /* Cycle statement is implemented with a goto.  Exit statement must not be\n@@ -1107,9 +1403,11 @@ gfc_trans_omp_parallel_do (gfc_code *code)\n       do_clauses.sched_kind = parallel_clauses.sched_kind;\n       do_clauses.chunk_size = parallel_clauses.chunk_size;\n       do_clauses.ordered = parallel_clauses.ordered;\n+      do_clauses.collapse = parallel_clauses.collapse;\n       parallel_clauses.sched_kind = OMP_SCHED_NONE;\n       parallel_clauses.chunk_size = NULL;\n       parallel_clauses.ordered = false;\n+      parallel_clauses.collapse = 0;\n       omp_clauses = gfc_trans_omp_clauses (&block, &parallel_clauses,\n \t\t\t\t\t   code->loc);\n     }\n@@ -1118,7 +1416,7 @@ gfc_trans_omp_parallel_do (gfc_code *code)\n     pblock = &block;\n   else\n     pushlevel (0);\n-  stmt = gfc_trans_omp_do (code, pblock, &do_clauses);\n+  stmt = gfc_trans_omp_do (code, pblock, &do_clauses, omp_clauses);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n   else\n@@ -1220,6 +1518,31 @@ gfc_trans_omp_single (gfc_code *code, gfc_omp_clauses *clauses)\n   return stmt;\n }\n \n+static tree\n+gfc_trans_omp_task (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, body_stmt, omp_clauses;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  body_stmt = gfc_trans_omp_code (code->block->next, true);\n+  stmt = make_node (OMP_TASK);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TASK_CLAUSES (stmt) = omp_clauses;\n+  OMP_TASK_BODY (stmt) = body_stmt;\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_taskwait (void)\n+{\n+  tree decl = built_in_decls [BUILT_IN_GOMP_TASKWAIT];\n+  return build_call_expr (decl, 0);\n+}\n+\n static tree\n gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n {\n@@ -1239,7 +1562,7 @@ gfc_trans_omp_directive (gfc_code *code)\n     case EXEC_OMP_CRITICAL:\n       return gfc_trans_omp_critical (code);\n     case EXEC_OMP_DO:\n-      return gfc_trans_omp_do (code, NULL, code->ext.omp_clauses);\n+      return gfc_trans_omp_do (code, NULL, code->ext.omp_clauses, NULL);\n     case EXEC_OMP_FLUSH:\n       return gfc_trans_omp_flush ();\n     case EXEC_OMP_MASTER:\n@@ -1258,6 +1581,10 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_sections (code, code->ext.omp_clauses);\n     case EXEC_OMP_SINGLE:\n       return gfc_trans_omp_single (code, code->ext.omp_clauses);\n+    case EXEC_OMP_TASK:\n+      return gfc_trans_omp_task (code);\n+    case EXEC_OMP_TASKWAIT:\n+      return gfc_trans_omp_taskwait ();\n     case EXEC_OMP_WORKSHARE:\n       return gfc_trans_omp_workshare (code, code->ext.omp_clauses);\n     default:"}, {"sha": "51e0cdd6aadf9e45e2cc2392edc03c0167578f46", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1135,6 +1135,8 @@ gfc_trans_code (gfc_code * code)\n \tcase EXEC_OMP_PARALLEL_WORKSHARE:\n \tcase EXEC_OMP_SECTIONS:\n \tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_TASK:\n+\tcase EXEC_OMP_TASKWAIT:\n \tcase EXEC_OMP_WORKSHARE:\n \t  res = gfc_trans_omp_directive (code);\n \t  break;"}, {"sha": "3a07d7127912f102a99032ea547aa980461335a2", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -493,9 +493,13 @@ bool gfc_get_array_descr_info (const_tree, struct array_descr_info *);\n /* In trans-openmp.c */\n bool gfc_omp_privatize_by_reference (const_tree);\n enum omp_clause_default_kind gfc_omp_predetermined_sharing (tree);\n-tree gfc_omp_clause_default_ctor (tree, tree);\n+tree gfc_omp_clause_default_ctor (tree, tree, tree);\n+tree gfc_omp_clause_copy_ctor (tree, tree, tree);\n+tree gfc_omp_clause_assign_op (tree, tree, tree);\n+tree gfc_omp_clause_dtor (tree, tree);\n bool gfc_omp_disregard_value_expr (tree, bool);\n bool gfc_omp_private_debug_clause (tree, bool);\n+bool gfc_omp_private_outer_ref (tree);\n struct gimplify_omp_ctx;\n void gfc_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *, tree);\n "}, {"sha": "5bcdb5261d943ff880e9d7e00cddf06f16a0300f", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -50,10 +50,12 @@ along with GCC; see the file COPYING3.  If not see\n     the type pointed to.  */\n \n DEF_PRIMITIVE_TYPE (BT_VOID, void_type_node)\n-DEF_PRIMITIVE_TYPE (BT_BOOL, boolean_type_node)\n+DEF_PRIMITIVE_TYPE (BT_BOOL,\n+\t\t    (*lang_hooks.types.type_for_size) (BOOL_TYPE_SIZE, 1))\n DEF_PRIMITIVE_TYPE (BT_INT, integer_type_node)\n DEF_PRIMITIVE_TYPE (BT_UINT, unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_LONG, long_integer_type_node)\n+DEF_PRIMITIVE_TYPE (BT_ULONGLONG, long_long_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 1))\n \n DEF_PRIMITIVE_TYPE (BT_I1, builtin_type_for_size (BITS_PER_UNIT*1, 1))\n@@ -70,6 +72,7 @@ DEF_PRIMITIVE_TYPE (BT_VOLATILE_PTR,\n                                             TYPE_QUAL_VOLATILE)))\n \n DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n+DEF_POINTER_TYPE (BT_PTR_ULONGLONG, BT_ULONGLONG)\n DEF_POINTER_TYPE (BT_PTR_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_0 (BT_FN_BOOL, BT_BOOL)\n DEF_FUNCTION_TYPE_0 (BT_FN_PTR, BT_PTR)\n@@ -87,11 +90,16 @@ DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_LONGPTR_LONGPTR,\n                      BT_BOOL, BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR,\n+\t\t     BT_BOOL, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n DEF_FUNCTION_TYPE_2 (BT_FN_I1_VPTR_I1, BT_I1, BT_VOLATILE_PTR, BT_I1)\n DEF_FUNCTION_TYPE_2 (BT_FN_I2_VPTR_I2, BT_I2, BT_VOLATILE_PTR, BT_I2)\n DEF_FUNCTION_TYPE_2 (BT_FN_I4_VPTR_I4, BT_I4, BT_VOLATILE_PTR, BT_I4)\n DEF_FUNCTION_TYPE_2 (BT_FN_I8_VPTR_I8, BT_I8, BT_VOLATILE_PTR, BT_I8)\n DEF_FUNCTION_TYPE_2 (BT_FN_I16_VPTR_I16, BT_I16, BT_VOLATILE_PTR, BT_I16)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTR, BT_VOID, BT_PTR, BT_PTR)\n+\n+DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR_PTR, BT_FN_VOID_PTR_PTR)\n \n DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I1_I1, BT_BOOL, BT_VOLATILE_PTR,\n                      BT_I1, BT_I1)\n@@ -127,9 +135,20 @@ DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n                      BT_LONG, BT_LONG, BT_LONG)\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_ULONGLONG, BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n                      BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n                      BT_LONG, BT_LONG, BT_LONG, BT_LONG)\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT,\n+\t\t     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR,\n+\t\t     BT_PTR_FN_VOID_PTR_PTR, BT_LONG, BT_LONG,\n+\t\t     BT_BOOL, BT_UINT)\n+DEF_FUNCTION_TYPE_7 (BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t     BT_BOOL, BT_BOOL, BT_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_ULONGLONG, BT_ULONGLONG,\n+\t\t     BT_PTR_ULONGLONG, BT_PTR_ULONGLONG)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)"}, {"sha": "99175d5b2f1ca6bf54402d77ec647d9dd5f26a6a", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -277,6 +277,7 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n       break;\n \n     case OMP_PARALLEL:\n+    case OMP_TASK:\n       lower_omp_directive (tsi, data);\n       return;\n "}, {"sha": "0c2e5e244057127fc0f00810dbf57cde16e7db95", "filename": "gcc/gimplify.c", "status": "modified", "additions": 249, "deletions": 101, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -62,19 +62,27 @@ enum gimplify_omp_var_data\n   GOVD_REDUCTION = 64,\n   GOVD_LOCAL = 128,\n   GOVD_DEBUG_PRIVATE = 256,\n+  GOVD_PRIVATE_OUTER_REF = 512,\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LOCAL)\n };\n \n+enum omp_region_type\n+{\n+  ORT_WORKSHARE = 0,\n+  ORT_TASK = 1,\n+  ORT_PARALLEL = 2,\n+  ORT_COMBINED_PARALLEL = 3\n+};\n+\n struct gimplify_omp_ctx\n {\n   struct gimplify_omp_ctx *outer_context;\n   splay_tree variables;\n   struct pointer_set_t *privatized_types;\n   location_t location;\n   enum omp_clause_default_kind default_kind;\n-  bool is_parallel;\n-  bool is_combined_parallel;\n+  enum omp_region_type region_type;\n };\n \n struct gimplify_ctx\n@@ -270,7 +278,7 @@ splay_tree_compare_decl_uid (splay_tree_key xa, splay_tree_key xb)\n /* Create a new omp construct that deals with variable remapping.  */\n \n static struct gimplify_omp_ctx *\n-new_omp_context (bool is_parallel, bool is_combined_parallel)\n+new_omp_context (enum omp_region_type region_type)\n {\n   struct gimplify_omp_ctx *c;\n \n@@ -279,9 +287,11 @@ new_omp_context (bool is_parallel, bool is_combined_parallel)\n   c->variables = splay_tree_new (splay_tree_compare_decl_uid, 0, 0);\n   c->privatized_types = pointer_set_create ();\n   c->location = input_location;\n-  c->is_parallel = is_parallel;\n-  c->is_combined_parallel = is_combined_parallel;\n-  c->default_kind = OMP_CLAUSE_DEFAULT_SHARED;\n+  c->region_type = region_type;\n+  if (region_type != ORT_TASK)\n+    c->default_kind = OMP_CLAUSE_DEFAULT_SHARED;\n+  else\n+    c->default_kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n \n   return c;\n }\n@@ -756,7 +766,7 @@ gimple_add_tmp_var (tree tmp)\n       if (gimplify_omp_ctxp)\n \t{\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n-\t  while (ctx && !ctx->is_parallel)\n+\t  while (ctx && ctx->region_type == ORT_WORKSHARE)\n \t    ctx = ctx->outer_context;\n \t  if (ctx)\n \t    omp_add_variable (ctx, tmp, GOVD_LOCAL | GOVD_SEEN);\n@@ -4711,7 +4721,7 @@ omp_firstprivatize_variable (struct gimplify_omp_ctx *ctx, tree decl)\n \t  else\n \t    return;\n \t}\n-      else if (ctx->is_parallel)\n+      else if (ctx->region_type != ORT_WORKSHARE)\n \tomp_add_variable (ctx, decl, GOVD_FIRSTPRIVATE);\n \n       ctx = ctx->outer_context;\n@@ -4904,8 +4914,9 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n   if (n == NULL)\n     {\n       enum omp_clause_default_kind default_kind, kind;\n+      struct gimplify_omp_ctx *octx;\n \n-      if (!ctx->is_parallel)\n+      if (ctx->region_type == ORT_WORKSHARE)\n \tgoto do_outer;\n \n       /* ??? Some compiler-generated variables (like SAVE_EXPRs) could be\n@@ -4929,10 +4940,47 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \tcase OMP_CLAUSE_DEFAULT_PRIVATE:\n \t  flags |= GOVD_PRIVATE;\n \t  break;\n+\tcase OMP_CLAUSE_DEFAULT_FIRSTPRIVATE:\n+\t  flags |= GOVD_FIRSTPRIVATE;\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n+\t  /* decl will be either GOVD_FIRSTPRIVATE or GOVD_SHARED.  */\n+\t  gcc_assert (ctx->region_type == ORT_TASK);\n+\t  if (ctx->outer_context)\n+\t    omp_notice_variable (ctx->outer_context, decl, in_code);\n+\t  for (octx = ctx->outer_context; octx; octx = octx->outer_context)\n+\t    {\n+\t      splay_tree_node n2;\n+\n+\t      n2 = splay_tree_lookup (octx->variables, (splay_tree_key) decl);\n+\t      if (n2 && (n2->value & GOVD_DATA_SHARE_CLASS) != GOVD_SHARED)\n+\t\t{\n+\t\t  flags |= GOVD_FIRSTPRIVATE;\n+\t\t  break;\n+\t\t}\n+\t      if ((octx->region_type & ORT_PARALLEL) != 0)\n+\t\tbreak;\n+\t    }\n+\t  if (flags & GOVD_FIRSTPRIVATE)\n+\t    break;\n+\t  if (octx == NULL\n+\t      && (TREE_CODE (decl) == PARM_DECL\n+\t\t  || (!is_global_var (decl)\n+\t\t      && DECL_CONTEXT (decl) == current_function_decl)))\n+\t    {\n+\t      flags |= GOVD_FIRSTPRIVATE;\n+\t      break;\n+\t    }\n+\t  flags |= GOVD_SHARED;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n+      if ((flags & GOVD_PRIVATE)\n+\t  && lang_hooks.decls.omp_private_outer_ref (decl))\n+\tflags |= GOVD_PRIVATE_OUTER_REF;\n+\n       omp_add_variable (ctx, decl, flags);\n \n       shared = (flags & GOVD_SHARED) != 0;\n@@ -4952,7 +5000,7 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n  do_outer:\n   /* If the variable is private in the current context, then we don't\n      need to propagate anything to an outer context.  */\n-  if (flags & GOVD_PRIVATE)\n+  if ((flags & GOVD_PRIVATE) && !(flags & GOVD_PRIVATE_OUTER_REF))\n     return ret;\n   if (ctx->outer_context\n       && omp_notice_variable (ctx->outer_context, decl, in_code))\n@@ -4985,7 +5033,7 @@ omp_is_private (struct gimplify_omp_ctx *ctx, tree decl)\n \t}\n       else if ((n->value & GOVD_EXPLICIT) != 0\n \t       && (ctx == gimplify_omp_ctxp\n-\t\t   || (ctx->is_combined_parallel\n+\t\t   || (ctx->region_type == ORT_COMBINED_PARALLEL\n \t\t       && gimplify_omp_ctxp->outer_context == ctx)))\n \t{\n \t  if ((n->value & GOVD_FIRSTPRIVATE) != 0)\n@@ -4998,7 +5046,7 @@ omp_is_private (struct gimplify_omp_ctx *ctx, tree decl)\n       return true;\n     }\n \n-  if (ctx->is_parallel)\n+  if (ctx->region_type != ORT_WORKSHARE)\n     return false;\n   else if (ctx->outer_context)\n     return omp_is_private (ctx->outer_context, decl);\n@@ -5027,21 +5075,21 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl)\n       if (n != NULL)\n \treturn (n->value & GOVD_SHARED) == 0;\n     }\n-  while (!ctx->is_parallel);\n+  while (ctx->region_type == ORT_WORKSHARE);\n   return false;\n }\n \n /* Scan the OpenMP clauses in *LIST_P, installing mappings into a new\n    and previous omp contexts.  */\n \n static void\n-gimplify_scan_omp_clauses (tree *list_p, tree *pre_p, bool in_parallel,\n-\t\t\t   bool in_combined_parallel)\n+gimplify_scan_omp_clauses (tree *list_p, tree *pre_p,\n+\t\t\t   enum omp_region_type region_type)\n {\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n   tree c;\n \n-  ctx = new_omp_context (in_parallel, in_combined_parallel);\n+  ctx = new_omp_context (region_type);\n   outer_ctx = ctx->outer_context;\n \n   while ((c = *list_p) != NULL)\n@@ -5057,7 +5105,13 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p, bool in_parallel,\n \t{\n \tcase OMP_CLAUSE_PRIVATE:\n \t  flags = GOVD_PRIVATE | GOVD_EXPLICIT;\n-\t  notice_outer = false;\n+\t  if (lang_hooks.decls.omp_private_outer_ref (OMP_CLAUSE_DECL (c)))\n+\t    {\n+\t      flags |= GOVD_PRIVATE_OUTER_REF;\n+\t      OMP_CLAUSE_PRIVATE_OUTER_REF (c) = 1;\n+\t    }\n+\t  else\n+\t    notice_outer = false;\n \t  goto do_add;\n \tcase OMP_CLAUSE_SHARED:\n \t  flags = GOVD_SHARED | GOVD_EXPLICIT;\n@@ -5097,6 +5151,23 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p, bool in_parallel,\n \t      pop_gimplify_context (OMP_CLAUSE_REDUCTION_MERGE (c));\n \t      gimplify_omp_ctxp = outer_ctx;\n \t    }\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t\t   && OMP_CLAUSE_LASTPRIVATE_STMT (c))\n+\t    {\n+\t      gimplify_omp_ctxp = ctx;\n+\t      push_gimplify_context ();\n+\t      if (TREE_CODE (OMP_CLAUSE_LASTPRIVATE_STMT (c)) != BIND_EXPR)\n+\t\t{\n+\t\t  tree bind = build3 (BIND_EXPR, void_type_node, NULL,\n+\t\t\t\t      NULL, NULL);\n+\t\t  TREE_SIDE_EFFECTS (bind) = 1;\n+\t\t  BIND_EXPR_BODY (bind) = OMP_CLAUSE_LASTPRIVATE_STMT (c);\n+\t\t  OMP_CLAUSE_LASTPRIVATE_STMT (c) = bind;\n+\t\t}\n+\t      gimplify_stmt (&OMP_CLAUSE_LASTPRIVATE_STMT (c));\n+\t      pop_gimplify_context (OMP_CLAUSE_LASTPRIVATE_STMT (c));\n+\t      gimplify_omp_ctxp = outer_ctx;\n+\t    }\n \t  if (notice_outer)\n \t    goto do_notice;\n \t  break;\n@@ -5113,7 +5184,7 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p, bool in_parallel,\n \t  if (outer_ctx)\n \t    omp_notice_variable (outer_ctx, decl, true);\n \t  if (check_non_private\n-\t      && !in_parallel\n+\t      && region_type == ORT_WORKSHARE\n \t      && omp_check_private (ctx, decl))\n \t    {\n \t      error (\"%s variable %qs is private in outer context\",\n@@ -5137,6 +5208,8 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p, bool in_parallel,\n \n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_COLLAPSE:\n \t  break;\n \n \tcase OMP_CLAUSE_DEFAULT:\n@@ -5215,7 +5288,10 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n   OMP_CLAUSE_CHAIN (clause) = *list_p;\n   if (private_debug)\n     OMP_CLAUSE_PRIVATE_DEBUG (clause) = 1;\n+  else if (code == OMP_CLAUSE_PRIVATE && (flags & GOVD_PRIVATE_OUTER_REF))\n+    OMP_CLAUSE_PRIVATE_OUTER_REF (clause) = 1;\n   *list_p = clause;\n+  lang_hooks.decls.omp_finish_clause (clause);\n \n   return 0;\n }\n@@ -5272,6 +5348,8 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_UNTIED:\n+\tcase OMP_CLAUSE_COLLAPSE:\n \t  break;\n \n \tdefault:\n@@ -5301,8 +5379,10 @@ gimplify_omp_parallel (tree *expr_p, tree *pre_p)\n {\n   tree expr = *expr_p;\n \n-  gimplify_scan_omp_clauses (&OMP_PARALLEL_CLAUSES (expr), pre_p, true,\n-\t\t\t     OMP_PARALLEL_COMBINED (expr));\n+  gimplify_scan_omp_clauses (&OMP_PARALLEL_CLAUSES (expr), pre_p,\n+\t\t\t     OMP_PARALLEL_COMBINED (expr)\n+\t\t\t     ? ORT_COMBINED_PARALLEL\n+\t\t\t     : ORT_PARALLEL);\n \n   push_gimplify_context ();\n \n@@ -5318,124 +5398,187 @@ gimplify_omp_parallel (tree *expr_p, tree *pre_p)\n   return GS_ALL_DONE;\n }\n \n-/* Gimplify the gross structure of an OMP_FOR statement.  */\n+/* Gimplify the contents of an OMP_TASK statement.  This involves\n+   gimplification of the body, as well as scanning the body for used\n+   variables.  We need to do this scan now, because variable-sized\n+   decls will be decomposed during gimplification.  */\n \n static enum gimplify_status\n-gimplify_omp_for (tree *expr_p, tree *pre_p)\n+gimplify_omp_task (tree *expr_p, tree *pre_p)\n {\n-  tree for_stmt, decl, var, t;\n-  enum gimplify_status ret = GS_OK;\n-  tree body, init_decl = NULL_TREE;\n+  tree expr = *expr_p;\n \n-  for_stmt = *expr_p;\n+  gimplify_scan_omp_clauses (&OMP_TASK_CLAUSES (expr), pre_p, ORT_TASK);\n \n-  gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, false, false);\n+  push_gimplify_context ();\n \n-  t = OMP_FOR_INIT (for_stmt);\n-  gcc_assert (TREE_CODE (t) == MODIFY_EXPR\n-\t      || TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n-  decl = GENERIC_TREE_OPERAND (t, 0);\n-  gcc_assert (DECL_P (decl));\n-  gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (decl)));\n+  gimplify_stmt (&OMP_TASK_BODY (expr));\n \n-  /* Make sure the iteration variable is private.  */\n-  if (omp_is_private (gimplify_omp_ctxp, decl))\n-    omp_notice_variable (gimplify_omp_ctxp, decl, true);\n+  if (TREE_CODE (OMP_TASK_BODY (expr)) == BIND_EXPR)\n+    pop_gimplify_context (OMP_TASK_BODY (expr));\n   else\n-    omp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n+    pop_gimplify_context (NULL_TREE);\n \n-  /* If DECL is not a gimple register, create a temporary variable to act as an\n-     iteration counter.  This is valid, since DECL cannot be modified in the\n-     body of the loop.  */\n-  if (!is_gimple_reg (decl))\n-    {\n-      var = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n-      GENERIC_TREE_OPERAND (t, 0) = var;\n+  gimplify_adjust_omp_clauses (&OMP_TASK_CLAUSES (expr));\n \n-      init_decl = build_gimple_modify_stmt (decl, var);\n-      omp_add_variable (gimplify_omp_ctxp, var, GOVD_PRIVATE | GOVD_SEEN);\n-    }\n-  else\n-    var = decl;\n+  return GS_ALL_DONE;\n+}\n+\n+/* Gimplify the gross structure of an OMP_FOR statement.  */\n+\n+static enum gimplify_status\n+gimplify_omp_for (tree *expr_p, tree *pre_p)\n+{\n+  tree for_stmt, decl, var, t, bodylist;\n+  enum gimplify_status ret = GS_OK;\n+  tree body, init_decl = NULL_TREE;\n+  int i;\n+\n+  for_stmt = *expr_p;\n+\n+  gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p,\n+\t\t\t     ORT_WORKSHARE);\n \n   /* If OMP_FOR is re-gimplified, ensure all variables in pre-body\n      are noticed.  */\n   gimplify_stmt (&OMP_FOR_PRE_BODY (for_stmt));\n \n-  ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n-\t\t\t&OMP_FOR_PRE_BODY (for_stmt),\n-\t\t\tNULL, is_gimple_val, fb_rvalue);\n+  bodylist = alloc_stmt_list ();\n+\n+  gcc_assert (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n+\t      == TREE_VEC_LENGTH (OMP_FOR_COND (for_stmt)));\n+  gcc_assert (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt))\n+\t      == TREE_VEC_LENGTH (OMP_FOR_INCR (for_stmt)));\n+  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n+    {\n+      t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n+      gcc_assert (TREE_CODE (t) == MODIFY_EXPR\n+\t\t  || TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+      decl = GENERIC_TREE_OPERAND (t, 0);\n+      gcc_assert (DECL_P (decl));\n+      gcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (decl))\n+\t\t  || POINTER_TYPE_P (TREE_TYPE (decl)));\n+\n+      /* Make sure the iteration variable is private.  */\n+      if (omp_is_private (gimplify_omp_ctxp, decl))\n+\tomp_notice_variable (gimplify_omp_ctxp, decl, true);\n+      else\n+\tomp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n+\n+      /* If DECL is not a gimple register, create a temporary variable to act\n+\t as an iteration counter.  This is valid, since DECL cannot be\n+\t modified in the body of the loop.  */\n+      if (!is_gimple_reg (decl))\n+\t{\n+\t  var = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n+\t  GENERIC_TREE_OPERAND (t, 0) = var;\n \n-  tree_to_gimple_tuple (&OMP_FOR_INIT (for_stmt));\n+\t  init_decl = build_gimple_modify_stmt (decl, var);\n+\t  omp_add_variable (gimplify_omp_ctxp, var, GOVD_PRIVATE | GOVD_SEEN);\n+\t}\n+      else\n+\tvar = decl;\n \n-  t = OMP_FOR_COND (for_stmt);\n-  gcc_assert (COMPARISON_CLASS_P (t));\n-  gcc_assert (GENERIC_TREE_OPERAND (t, 0) == decl);\n-  TREE_OPERAND (t, 0) = var;\n+      ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t    &OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\t    NULL, is_gimple_val, fb_rvalue);\n \n-  ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n-\t\t\t&OMP_FOR_PRE_BODY (for_stmt),\n-\t\t\tNULL, is_gimple_val, fb_rvalue);\n+      tree_to_gimple_tuple (&TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i));\n \n-  tree_to_gimple_tuple (&OMP_FOR_INCR (for_stmt));\n-  t = OMP_FOR_INCR (for_stmt);\n-  switch (TREE_CODE (t))\n-    {\n-    case PREINCREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-      t = build_int_cst (TREE_TYPE (decl), 1);\n-      t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n-      t = build_gimple_modify_stmt (var, t);\n-      OMP_FOR_INCR (for_stmt) = t;\n-      break;\n+      t = TREE_VEC_ELT (OMP_FOR_COND (for_stmt), i);\n+      gcc_assert (COMPARISON_CLASS_P (t));\n+      gcc_assert (GENERIC_TREE_OPERAND (t, 0) == decl);\n+      TREE_OPERAND (t, 0) = var;\n \n-    case PREDECREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      t = build_int_cst (TREE_TYPE (decl), -1);\n-      t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n-      t = build_gimple_modify_stmt (var, t);\n-      OMP_FOR_INCR (for_stmt) = t;\n-      break;\n-      \n-    case GIMPLE_MODIFY_STMT:\n-      gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == decl);\n-      GIMPLE_STMT_OPERAND (t, 0) = var;\n+      ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t    &OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\t    NULL, is_gimple_val, fb_rvalue);\n \n-      t = GIMPLE_STMT_OPERAND (t, 1);\n+      tree_to_gimple_tuple (&TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i));\n+      t = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n       switch (TREE_CODE (t))\n \t{\n-\tcase PLUS_EXPR:\n-\t  if (TREE_OPERAND (t, 1) == decl)\n+\tcase PREINCREMENT_EXPR:\n+\tcase POSTINCREMENT_EXPR:\n+\t  t = build_int_cst (TREE_TYPE (decl), 1);\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n+\t  t = build_gimple_modify_stmt (var, t);\n+\t  TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i) = t;\n+\t  break;\n+\n+\tcase PREDECREMENT_EXPR:\n+\tcase POSTDECREMENT_EXPR:\n+\t  t = build_int_cst (TREE_TYPE (decl), -1);\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n+\t  t = build_gimple_modify_stmt (var, t);\n+\t  TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i) = t;\n+\t  break;\n+\n+\tcase GIMPLE_MODIFY_STMT:\n+\t  gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == decl);\n+\t  GIMPLE_STMT_OPERAND (t, 0) = var;\n+\n+\t  t = GIMPLE_STMT_OPERAND (t, 1);\n+\t  switch (TREE_CODE (t))\n \t    {\n-\t      TREE_OPERAND (t, 1) = TREE_OPERAND (t, 0);\n+\t    case PLUS_EXPR:\n+\t      if (TREE_OPERAND (t, 1) == decl)\n+\t\t{\n+\t\t  TREE_OPERAND (t, 1) = TREE_OPERAND (t, 0);\n+\t\t  TREE_OPERAND (t, 0) = var;\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Fallthru.  */\n+\t    case MINUS_EXPR:\n+\t    case POINTER_PLUS_EXPR:\n+\t      gcc_assert (TREE_OPERAND (t, 0) == decl);\n \t      TREE_OPERAND (t, 0) = var;\n \t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n \n-\t  /* Fallthru.  */\n-\tcase MINUS_EXPR:\n-\t  gcc_assert (TREE_OPERAND (t, 0) == decl);\n-\t  TREE_OPERAND (t, 0) = var;\n+\t  ret |= gimplify_expr (&TREE_OPERAND (t, 1),\n+\t\t\t\t&OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\t\tNULL, is_gimple_val, fb_rvalue);\n \t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n-      ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n-\t\t\t    NULL, is_gimple_val, fb_rvalue);\n-      break;\n+      if (init_decl)\n+\tappend_to_statement_list (init_decl, &bodylist);\n \n-    default:\n-      gcc_unreachable ();\n+      if (var != decl || TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) > 1)\n+\t{\n+\t  tree c;\n+\t  for (c = OMP_FOR_CLAUSES (for_stmt); c ; c = OMP_CLAUSE_CHAIN (c))\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t      && OMP_CLAUSE_DECL (c) == decl\n+\t      && OMP_CLAUSE_LASTPRIVATE_STMT (c) == NULL)\n+\t    {\n+\t      t = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n+\t      gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+\t      gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == var);\n+\t      t = GIMPLE_STMT_OPERAND (t, 1);\n+\t      gcc_assert (TREE_CODE (t) == PLUS_EXPR\n+\t\t\t  || TREE_CODE (t) == MINUS_EXPR\n+\t\t\t  || TREE_CODE (t) == POINTER_PLUS_EXPR);\n+\t      gcc_assert (TREE_OPERAND (t, 0) == var);\n+\t      t = build2 (TREE_CODE (t), TREE_TYPE (decl), decl,\n+\t\t\t  TREE_OPERAND (t, 1));\n+\t      OMP_CLAUSE_LASTPRIVATE_STMT (c)\n+\t\t= build_gimple_modify_stmt (decl, t);\n+\t    }\n+\t}\n     }\n \n   body = OMP_FOR_BODY (for_stmt);\n   gimplify_to_stmt_list (&body);\n-  t = alloc_stmt_list ();\n-  if (init_decl)\n-    append_to_statement_list (init_decl, &t);\n-  append_to_statement_list (body, &t);\n-  OMP_FOR_BODY (for_stmt) = t;\n+  append_to_statement_list (body, &bodylist);\n+  OMP_FOR_BODY (for_stmt) = bodylist;\n   gimplify_adjust_omp_clauses (&OMP_FOR_CLAUSES (for_stmt));\n \n   return ret == GS_ALL_DONE ? GS_ALL_DONE : GS_ERROR;\n@@ -5449,7 +5592,7 @@ gimplify_omp_workshare (tree *expr_p, tree *pre_p)\n {\n   tree stmt = *expr_p;\n \n-  gimplify_scan_omp_clauses (&OMP_CLAUSES (stmt), pre_p, false, false);\n+  gimplify_scan_omp_clauses (&OMP_CLAUSES (stmt), pre_p, ORT_WORKSHARE);\n   gimplify_to_stmt_list (&OMP_BODY (stmt));\n   gimplify_adjust_omp_clauses (&OMP_CLAUSES (stmt));\n \n@@ -6025,6 +6168,10 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = gimplify_omp_parallel (expr_p, pre_p);\n \t  break;\n \n+\tcase OMP_TASK:\n+\t  ret = gimplify_omp_task (expr_p, pre_p);\n+\t  break;\n+\n \tcase OMP_FOR:\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;\n@@ -6048,6 +6195,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tcase OMP_RETURN:\n \tcase OMP_CONTINUE:\n \tcase OMP_ATOMIC_STORE:\n+\tcase OMP_SECTIONS_SWITCH:\n \t  ret = GS_ALL_DONE;\n \t  break;\n "}, {"sha": "50761b69ca551c5fe784afe45ec4224225bd83d4", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -291,6 +291,14 @@ hook_tree_tree_tree_null (tree t0 ATTRIBUTE_UNUSED, tree t1 ATTRIBUTE_UNUSED)\n   return NULL;\n }\n \n+tree\n+hook_tree_tree_tree_tree_null (tree t0 ATTRIBUTE_UNUSED,\n+\t\t\t       tree t1 ATTRIBUTE_UNUSED,\n+\t\t\t       tree t2 ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n+\n /* Generic hook that takes a rtx and returns a NULL string.  */\n const char *\n hook_constcharptr_const_rtx_null (const_rtx r ATTRIBUTE_UNUSED)"}, {"sha": "d6bbc4c2f07fa257f7c8b599e8b4f8dcc4f85ce4", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -63,6 +63,7 @@ extern int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);\n extern int hook_int_void_no_regs (void);\n \n extern tree hook_tree_tree_tree_null (tree, tree);\n+extern tree hook_tree_tree_tree_tree_null (tree, tree, tree);\n extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);\n extern tree hook_tree_tree_tree_bool_null (tree, tree, bool);\n "}, {"sha": "cce9b3f6fc758cefb918b1f82663f8ee7d1b4b29", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -3727,6 +3727,7 @@ do_reorg_1 (void)\n       }\n \n   set_cfun (NULL);\n+  bitmap_obstack_release (NULL);\n }\n \n /* This function creates new global struct variables."}, {"sha": "dd4916caff6fb9e6634eccd5897fd0b80f13230a", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -199,10 +199,12 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING lhd_omp_predetermined_sharing\n #define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR hook_bool_tree_bool_false\n #define LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE hook_bool_tree_bool_false\n-#define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR hook_tree_tree_tree_null\n+#define LANG_HOOKS_OMP_PRIVATE_OUTER_REF hook_bool_tree_false\n+#define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR hook_tree_tree_tree_tree_null\n #define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR lhd_omp_assignment\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP lhd_omp_assignment\n #define LANG_HOOKS_OMP_CLAUSE_DTOR hook_tree_tree_tree_null\n+#define LANG_HOOKS_OMP_FINISH_CLAUSE hook_void_tree\n \n #define LANG_HOOKS_DECLS { \\\n   LANG_HOOKS_GLOBAL_BINDINGS_P, \\\n@@ -216,10 +218,12 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_OMP_PREDETERMINED_SHARING, \\\n   LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR, \\\n   LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE, \\\n+  LANG_HOOKS_OMP_PRIVATE_OUTER_REF, \\\n   LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR, \\\n   LANG_HOOKS_OMP_CLAUSE_COPY_CTOR, \\\n   LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP, \\\n-  LANG_HOOKS_OMP_CLAUSE_DTOR \\\n+  LANG_HOOKS_OMP_CLAUSE_DTOR, \\\n+  LANG_HOOKS_OMP_FINISH_CLAUSE \\\n }\n \n /* The whole thing.  The structure is defined in langhooks.h.  */"}, {"sha": "1f64cf18d52c1f880b5137120ebe4de47dfb7055", "filename": "gcc/langhooks.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,5 +1,5 @@\n /* The lang_hooks data structure.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -197,9 +197,14 @@ struct lang_hooks_for_decls\n      be put into OMP_CLAUSE_PRIVATE_DEBUG.  */\n   bool (*omp_private_debug_clause) (tree, bool);\n \n+  /* Return true if DECL in private clause needs\n+     OMP_CLAUSE_PRIVATE_OUTER_REF on the private clause.  */\n+  bool (*omp_private_outer_ref) (tree);\n+\n   /* Build and return code for a default constructor for DECL in\n-     response to CLAUSE.  Return NULL if nothing to be done.  */\n-  tree (*omp_clause_default_ctor) (tree clause, tree decl);\n+     response to CLAUSE.  OUTER is corresponding outer region's\n+     variable if needed.  Return NULL if nothing to be done.  */\n+  tree (*omp_clause_default_ctor) (tree clause, tree decl, tree outer);\n \n   /* Build and return code for a copy constructor from SRC to DST.  */\n   tree (*omp_clause_copy_ctor) (tree clause, tree dst, tree src);\n@@ -210,6 +215,9 @@ struct lang_hooks_for_decls\n   /* Build and return code destructing DECL.  Return NULL if nothing\n      to be done.  */\n   tree (*omp_clause_dtor) (tree clause, tree decl);\n+\n+  /* Do language specific checking on an implicitly determined clause.  */\n+  void (*omp_finish_clause) (tree clause);\n };\n \n /* Language-specific hooks.  See langhooks-def.h for defaults.  */"}, {"sha": "50ac7e87b0ba7ee6a0c9d32cd70c5815f452e2d6", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -2235,6 +2235,7 @@ matrix_reorg (void)\n \t    free_dominance_info (CDI_POST_DOMINATORS);\n \t    pop_cfun ();\n \t    current_function_decl = temp_fn;\n+\t    bitmap_obstack_release (NULL);\n \n \t    return 0;\n \t  }\n@@ -2249,6 +2250,7 @@ matrix_reorg (void)\n \t    free_dominance_info (CDI_POST_DOMINATORS);\n \t    pop_cfun ();\n \t    current_function_decl = temp_fn;\n+\t    bitmap_obstack_release (NULL);\n \n \t    return 0;\n \t  }\n@@ -2279,6 +2281,7 @@ matrix_reorg (void)\n \tfree_dominance_info (CDI_POST_DOMINATORS);\n \tpop_cfun ();\n \tcurrent_function_decl = temp_fn;\n+\tbitmap_obstack_release (NULL);\n       }\n   htab_traverse (matrices_to_reorg, transform_allocation_sites, NULL);\n   /* Now transform the accesses.  */\n@@ -2299,6 +2302,7 @@ matrix_reorg (void)\n \tfree_dominance_info (CDI_POST_DOMINATORS);\n \tpop_cfun ();\n \tcurrent_function_decl = temp_fn;\n+\tbitmap_obstack_release (NULL);\n       }\n   htab_traverse (matrices_to_reorg, dump_matrix_reorg_analysis, NULL);\n "}, {"sha": "5fd4f9aea75ea97320b0d77d6ba1fe4a51cadcbd", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions and documentation for the\n    OpenMP builtins used in the GNU compiler.\n-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -35,6 +35,8 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_ATOMIC_END, \"GOMP_atomic_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_BARRIER, \"GOMP_barrier\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASKWAIT, \"GOMP_taskwait\",\n+\t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_START, \"GOMP_critical_start\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_CRITICAL_END, \"GOMP_critical_end\",\n@@ -100,6 +102,58 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_GUIDED_NEXT,\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ORDERED_RUNTIME_NEXT,\n \t\t  \"GOMP_loop_ordered_runtime_next\",\n \t\t  BT_FN_BOOL_LONGPTR_LONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_STATIC_START,\n+\t\t  \"GOMP_loop_ull_static_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DYNAMIC_START,\n+\t\t  \"GOMP_loop_ull_dynamic_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_GUIDED_START,\n+\t\t  \"GOMP_loop_ull_guided_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_RUNTIME_START,\n+\t\t  \"GOMP_loop_ull_runtime_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_START,\n+\t\t  \"GOMP_loop_ull_ordered_static_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_START,\n+\t\t  \"GOMP_loop_ull_ordered_dynamic_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_START,\n+\t\t  \"GOMP_loop_ull_ordered_guided_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_START,\n+\t\t  \"GOMP_loop_ull_ordered_runtime_start\",\n+\t\t  BT_FN_BOOL_BOOL_ULL_ULL_ULL_ULLPTR_ULLPTR,\n+\t\t  ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_STATIC_NEXT, \"GOMP_loop_ull_static_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_DYNAMIC_NEXT, \"GOMP_loop_ull_dynamic_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_GUIDED_NEXT, \"GOMP_loop_ull_guided_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_RUNTIME_NEXT, \"GOMP_loop_ull_runtime_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_STATIC_NEXT,\n+\t\t  \"GOMP_loop_ull_ordered_static_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_DYNAMIC_NEXT,\n+\t\t  \"GOMP_loop_ull_ordered_dynamic_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_GUIDED_NEXT,\n+\t\t  \"GOMP_loop_ull_ordered_guided_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_LOOP_ULL_ORDERED_RUNTIME_NEXT,\n+\t\t  \"GOMP_loop_ull_ordered_runtime_next\",\n+\t\t  BT_FN_BOOL_ULONGLONGPTR_ULONGLONGPTR, ATTR_NOTHROW_LIST)\n /* NOTE: Do not change the order of BUILT_IN_GOMP_PARALLEL_LOOP_*_START.\n    They are used in index arithmetic with enum omp_clause_schedule_kind\n    in omp-low.c.  */\n@@ -131,6 +185,9 @@ DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_START, \"GOMP_parallel_start\",\n \t\t  BT_FN_VOID_OMPFN_PTR_UINT, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_PARALLEL_END, \"GOMP_parallel_end\",\n \t\t  BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOMP_BUILTIN (BUILT_IN_GOMP_TASK, \"GOMP_task\",\n+\t\t  BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT,\n+\t\t  ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_START, \"GOMP_sections_start\",\n \t\t  BT_FN_UINT_UINT, ATTR_NOTHROW_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_GOMP_SECTIONS_NEXT, \"GOMP_sections_next\","}, {"sha": "e9223b2afb208747dbc70e75c1a2c039527d596b", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1617, "deletions": 320, "changes": 1937, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "73e4a5e6c2ac4ad16f7e9d3b55dc39da64701d32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,3 +1,27 @@\n+2008-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/gomp/collapse-1.c: New test.\n+\t* gcc.dg/gomp/nesting-1.c: New test.\n+\t* g++.dg/gomp/task-1.C: New test.\n+\t* g++.dg/gomp/predetermined-1.C: New test.\n+\t* g++.dg/gomp/tls-4.C: New test.\n+\t* gfortran.dg/gomp/collapse1.f90: New test.\n+\t* gfortran.dg/gomp/sharing-3.f90: New test.\n+\t* gcc.dg/gomp/pr27499.c (foo): Remove is unsigned dg-warning.\n+\t* g++.dg/gomp/pr27499.C (foo): Likewise.\n+\t* g++.dg/gomp/for-16.C (foo): Likewise.\n+\t* g++.dg/gomp/tls-3.C: Remove dg-error, add S::s definition.\n+\t* g++.dg/gomp/pr34607.C: Adjust dg-error location.\n+\t* g++.dg/gomp/for-16.C (foo): Add a new dg-error.\n+\t* gcc.dg/gomp/appendix-a/a.35.4.c: Add dg-warning.\n+\t* gcc.dg/gomp/appendix-a/a.35.6.c: Likewise.\n+\t* gfortran.dg/gomp/appendix-a/a.35.4.f90: Likewise.\n+\t* gfortran.dg/gomp/appendix-a/a.35.6.f90: Likewise.\n+\t* gfortran.dg/gomp/omp_parse1.f90: Remove !$omp tab test.\n+\t* gfortran.dg/gomp/appendix-a/a.33.4.f90: Remove dg-error\n+\tabout allocatable array.\n+\t* gfortran.dg/gomp/reduction1.f90: Likewise.\n+\n 2008-06-06  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/alias-18.c: XFAIL some sub-tests."}, {"sha": "dbbed8fe505214bbb0b9dd9480edfc6c7a94c00f", "filename": "gcc/testsuite/g++.dg/gomp/for-16.C", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-16.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -4,16 +4,15 @@ template<typename T>\n void foo ()\n {\n #pragma omp for\n-  for (unsigned int i = 0; i < 10; i++); // { dg-warning \"is unsigned\" }\n+  for (unsigned int i = 0; i < 10; i++);\n #pragma omp for\n   for (int j = 0; ; j++); // { dg-error \"missing controlling predicate\" }\n #pragma omp for\n   for (int k = 0; k == 1; k++); // { dg-error \"invalid controlling predicate\" }\n #pragma omp for\n   for (int l = 0; l < 10; ); // { dg-error \"missing increment expression\" }\n #pragma omp for\n-  for (int m = 0; m < 10; m *= 3); // Error here is emitted only during\n-\t\t\t\t   // instantiation\n+  for (int m = 0; m < 10; m *= 3); // { dg-error \"invalid increment expression\" }\n #pragma omp for\n   for (T n = 0; ; n++); // { dg-error \"missing controlling predicate\" }\n #pragma omp for"}, {"sha": "4e0d5b1a5b80389a6a48f24110b634afb9f0a093", "filename": "gcc/testsuite/g++.dg/gomp/pr27499.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr27499.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr27499.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr27499.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -8,6 +8,6 @@ foo (void)\n {\n   unsigned int i;\n #pragma omp for\n-  for (i = 0; i < 64; ++i)\t// { dg-warning \"is unsigned\" }\n+  for (i = 0; i < 64; ++i)\n     bar (i);\n }"}, {"sha": "f032aa45d50f7fc182833d6385c901e98c7f99ca", "filename": "gcc/testsuite/g++.dg/gomp/pr34607.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr34607.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr34607.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr34607.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -13,6 +13,6 @@ foo ()\n     ;\n   T j;\t\t\t\t// { dg-error \"was not declared|expected\" }\n #pragma omp for\n-  for (j = 1; j < 3; j++)\t// { dg-error \"was not declared\" }\n-    ;\t\t\t\t// { dg-error \"expected\" }\n+  for (j = 1; j < 3; j++)\t// { dg-error \"was not declared|expected\" }\n+    ;\n }"}, {"sha": "dd09855de97873405c47c51004f407f0fda92cf2", "filename": "gcc/testsuite/g++.dg/gomp/predetermined-1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpredetermined-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpredetermined-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpredetermined-1.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct A { int i; A (); ~A (); };\n+struct B { int i; };\n+struct C { int i; mutable int j; C (); ~C (); };\n+\n+template <typename T> void bar (const T *);\n+\n+const A a;\n+const C c;\n+\n+const A foo (const A d, const C e)\n+{\n+  const A f;\n+  const B b = { 4 };\n+  A g;\n+  #pragma omp parallel default (none)\n+    bar (&a);\n+  #pragma omp parallel default (none)\n+    bar (&b);\n+  #pragma omp parallel default (none)\t// { dg-error \"enclosing parallel\" }\n+    bar (&c);\t\t\t\t// { dg-error \"not specified\" }\n+  #pragma omp parallel default (none)\n+    bar (&d);\n+  #pragma omp parallel default (none)\t// { dg-error \"enclosing parallel\" }\n+    bar (&e);\t\t\t\t// { dg-error \"not specified\" }\n+  #pragma omp parallel default (none)\n+    bar (&f);\n+  #pragma omp parallel default (none)\t// { dg-error \"enclosing parallel\" }\n+    bar (&g);\t\t\t\t// { dg-error \"not specified\" }\n+  return f;\n+}"}, {"sha": "0000e6f1fa9cd1f47cf7ac6fd88fe39885f9ab40", "filename": "gcc/testsuite/g++.dg/gomp/task-1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftask-1.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp\" }\n+\n+struct A { A (); ~A (); int i; };\n+\n+template <typename T> void bar (T &);\n+\n+const A a;\n+\n+void foo (A &p)\n+{\n+  const A &q = a;\n+#pragma omp task\t// { dg-error \"has reference type\" }\n+  bar (p);\n+#pragma omp task\t// { dg-error \"has reference type\" }\n+  bar (q);\n+}"}, {"sha": "04f6bbea4081a37d9203040e385b3596d997deab", "filename": "gcc/testsuite/g++.dg/gomp/tls-3.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -13,9 +13,11 @@ namespace N\n struct S\n {\n   static int s;\n-#pragma omp thr (s) // { dg-error \"is not file, namespace or block scope\" }\n+#pragma omp thr (s)\n };\n \n+int S::s = 5;\n+\n int\n foo ()\n {"}, {"sha": "e4377c5e4c0d725e42a139a856484368c1a77903", "filename": "gcc/testsuite/g++.dg/gomp/tls-4.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-4.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls_native }\n+\n+#define thr threadprivate\n+\n+struct S\n+{\n+  static int s;\n+};\n+struct T : public S\n+{\n+  static int t;\n+#pragma omp thr (s)\t// { dg-error \"directive not in\" }\n+};\n+\n+#pragma omp thr (T::t)\t// { dg-error \"directive not in\" }"}, {"sha": "d7579e6e7358e7bb7e2e25e8f85889d94921f29f", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.4.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -11,7 +11,7 @@ wrong4 (int n)\n       {\n \twork (i, 0);\n \t/* incorrect nesting of barrier region in a loop region */\n-#pragma omp barrier\n+#pragma omp barrier\t/* { dg-warning \"may not be closely nested\" } */\n \twork (i, 1);\n       }\n   }"}, {"sha": "ac850e5410a5e79dae584c69a2b8cf5f51b990c1", "filename": "gcc/testsuite/gcc.dg/gomp/appendix-a/a.35.6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fappendix-a%2Fa.35.6.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -9,7 +9,7 @@ wrong6 (int n)\n     {\n       work (n, 0);\n /* incorrect nesting of barrier region in a single region */\n-#pragma omp barrier\n+#pragma omp barrier\t/* { dg-warning \"may not be closely nested\" } */\n       work (n, 1);\n     }\n   }"}, {"sha": "89b76bb669cbb0f90a071062cea977404e62748e", "filename": "gcc/testsuite/gcc.dg/gomp/collapse-1.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcollapse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcollapse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcollapse-1.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+int i, j, k;\n+extern int foo (void);\n+\n+void\n+f1 (void)\n+{\n+  #pragma omp for collapse (2)\n+  for (i = 0; i < 5; i++)\n+    ;\t\t\t\t\t/* { dg-error \"not enough perfectly nested\" } */\n+  {\n+    for (j = 0; j < 5; j++)\n+      ;\n+  }\n+}\n+\n+void\n+f2 (void)\n+{\n+  #pragma omp for collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\t{\n+\t  for (j = 0; j < 5; j++)\n+\t    {\n+\t    }\n+\t}\n+      }\n+    }\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma omp for collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      int k = foo ();\t\t\t/* { dg-error \"not enough perfectly nested\" } */\n+      {\n+\t{\n+\t  for (j = 0; j < 5; j++)\n+\t    {\n+\t    }\n+\t}\n+      }\n+    }\n+}\n+\n+void\n+f4 (void)\n+{\n+  #pragma omp for collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\tfor (j = 0; j < 5; j++)\n+\t  ;\n+\tfoo ();\t\t\t\t/* { dg-error \"collapsed loops not perfectly nested before\" } */\n+      }\n+    }\n+}\n+\n+void\n+f5 (void)\n+{\n+  #pragma omp for collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\tfor (j = 0; j < 5; j++)\n+\t  ;\n+      }\n+      foo ();\t\t\t\t/* { dg-error \"collapsed loops not perfectly nested before\" } */\n+    }\n+}\n+\n+void\n+f6 (void)\n+{\n+  #pragma omp for collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\tfor (j = 0; j < 5; j++)\n+\t  ;\n+      }\n+    }\n+  foo ();\n+}"}, {"sha": "6f27b907e6b0cc2ec4a913e74eb8cfb59511ae90", "filename": "gcc/testsuite/gcc.dg/gomp/nesting-1.c", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,198 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+void\n+f1 (void)\n+{\n+  int i, j;\n+  #pragma omp for\n+  for (i = 0; i < 3; i++)\n+    {\n+      #pragma omp for\t\t/* { dg-warning \"may not be closely nested\" } */\n+      for (j = 0; j < 3; j++)\n+\t;\n+      #pragma omp sections\t/* { dg-warning \"may not be closely nested\" } */\n+      {\n+\t;\n+      #pragma omp section\n+\t;\n+      }\n+      #pragma omp single\t/* { dg-warning \"may not be closely nested\" } */\n+\t;\n+    #pragma omp master\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+      #pragma omp barrier\t/* { dg-warning \"may not be closely nested\" } */\n+    }\n+  #pragma omp sections\n+  {\n+    #pragma omp for\t\t/* { dg-warning \"may not be closely nested\" } */\n+    for (j = 0; j < 3; j++)\n+      ;\n+    #pragma omp sections\t/* { dg-warning \"may not be closely nested\" } */\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+    #pragma omp single\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp master\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp section\n+      ;\n+  }\n+  #pragma omp single\n+  {\n+    #pragma omp for\t\t/* { dg-warning \"may not be closely nested\" } */\n+    for (j = 0; j < 3; j++)\n+      ;\n+    #pragma omp sections\t/* { dg-warning \"may not be closely nested\" } */\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+    #pragma omp single\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp master\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp barrier\t\t/* { dg-warning \"may not be closely nested\" } */\n+  }\n+  #pragma omp master\n+  {\n+    #pragma omp for\t\t/* { dg-warning \"may not be closely nested\" } */\n+    for (j = 0; j < 3; j++)\n+      ;\n+    #pragma omp sections\t/* { dg-warning \"may not be closely nested\" } */\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+    #pragma omp single\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp master\n+      ;\n+    #pragma omp barrier\t\t/* { dg-warning \"may not be closely nested\" } */\n+  }\n+  #pragma omp task\n+  {\n+    #pragma omp for\t\t/* { dg-warning \"may not be closely nested\" } */\n+    for (j = 0; j < 3; j++)\n+      ;\n+    #pragma omp sections\t/* { dg-warning \"may not be closely nested\" } */\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+    #pragma omp single\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp master\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp barrier\t\t/* { dg-warning \"may not be closely nested\" } */\n+  }\n+  #pragma omp parallel\n+  {\n+    #pragma omp for\n+    for (j = 0; j < 3; j++)\n+      ;\n+    #pragma omp sections\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+    #pragma omp single\n+      ;\n+    #pragma omp master\n+      ;\n+    #pragma omp barrier\n+  }\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i, j;\n+  #pragma omp ordered\n+  {\n+    #pragma omp for\t\t/* { dg-warning \"may not be closely nested\" } */\n+    for (j = 0; j < 3; j++)\n+      ;\n+    #pragma omp sections\t/* { dg-warning \"may not be closely nested\" } */\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+    #pragma omp single\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+    #pragma omp master\n+      ;\n+    #pragma omp barrier\t\t/* { dg-warning \"may not be closely nested\" } */\n+  }\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma omp critical\n+  {\n+    #pragma omp ordered\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+  }\n+}\n+\n+void\n+f4 (void)\n+{\n+  #pragma omp task\n+  {\n+    #pragma omp ordered\t\t/* { dg-warning \"may not be closely nested\" } */\n+      ;\n+  }\n+}\n+\n+void\n+f5 (void)\n+{\n+  int i;\n+  #pragma omp for\n+  for (i = 0; i < 10; i++)\n+    {\n+      #pragma omp ordered\t\t/* { dg-warning \"must be closely nested\" } */\n+\t;\n+    }\n+  #pragma omp for ordered\n+  for (i = 0; i < 10; i++)\n+    {\n+      #pragma omp ordered\n+\t;\n+    }\n+}\n+\n+void\n+f6 (void)\n+{\n+  #pragma omp critical (foo)\n+    #pragma omp critical (bar)\n+      ;\n+  #pragma omp critical\n+    #pragma omp critical (baz)\n+      ;\n+}\n+\n+void\n+f7 (void)\n+{\n+  #pragma omp critical (foo2)\n+    #pragma omp critical\n+      ;\n+  #pragma omp critical (bar)\n+    #pragma omp critical (bar)\t\t/* { dg-warning \"may not be nested\" } */\n+      ;\n+  #pragma omp critical\n+    #pragma omp critical\t\t/* { dg-warning \"may not be nested\" } */\n+      ;\n+}"}, {"sha": "0de2e0686f15bebd1e98a48a177ff8fa0a7ff297", "filename": "gcc/testsuite/gcc.dg/gomp/pr27499.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr27499.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr27499.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr27499.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -8,6 +8,6 @@ foo (void)\n {\n   unsigned int i;\n #pragma omp parallel for\n-  for (i = 0; i < 64; ++i)\t/* { dg-warning \"is unsigned\" } */\n+  for (i = 0; i < 64; ++i)\n     bar (i);\n }"}, {"sha": "7a9e1840b2445290977571ddb4c5845fd38ced5e", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.33.4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.4.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -4,7 +4,7 @@ SUBROUTINE S(N)\n         REAL, DIMENSION(:), ALLOCATABLE :: A\n         REAL, DIMENSION(:), POINTER :: B\n         ALLOCATE (A(N))\n-!$OMP SINGLE            ! { dg-error \"COPYPRIVATE clause object 'a'\" }\n+!$OMP SINGLE\n             ALLOCATE (B(N))\n         READ (11) A,B\n !$OMP END SINGLE COPYPRIVATE(A,B)"}, {"sha": "f130dd5f480742aeb6f2526492d852055c01009d", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.4.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -8,7 +8,7 @@ SUBROUTINE WRONG4(N)\n           DO I = 1, N\n              CALL WORK(I, 1)\n ! incorrect nesting of barrier region in a loop region\n-!$OMP BARRIER\n+!$OMP BARRIER\t! { dg-warning \"may not be closely nested\" }\n              CALL WORK(I, 2)\n           END DO\n !$OMP END PARALLEL"}, {"sha": "62ba245236b1a96c584f00f3092cb41f0f72804c", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.6.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -6,7 +6,7 @@ SUBROUTINE WRONG6(N)\n !$OMP SINGLE\n            CALL WORK(N,1)\n ! incorrect nesting of barrier region in a single region\n-!$OMP BARRIER\n+!$OMP BARRIER\t! { dg-warning \"may not be closely nested\" }\n             CALL WORK(N,2)\n !$OMP END SINGLE\n !$OMP END PARALLEL"}, {"sha": "f16a780ad9948da5a027e8ee42b5e1655e82f9e5", "filename": "gcc/testsuite/gfortran.dg/gomp/collapse1.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcollapse1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcollapse1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcollapse1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+\n+subroutine collapse1\n+  integer :: i, j, k, a(1:3, 4:6, 5:7)\n+  real :: r\n+  logical :: l\n+  integer, save :: thr\n+  !$omp threadprivate (thr)\n+  l = .false.\n+  a(:, :, :) = 0\n+  !$omp parallel do collapse(4) schedule(static, 4) ! { dg-error \"not enough DO loops for collapsed\" }\n+    do i = 1, 3\n+      do j = 4, 6\n+        do k = 5, 7\n+          a(i, j, k) = i + j + k\n+        end do\n+      end do\n+    end do\n+  !$omp parallel do collapse(2)\n+    do i = 1, 5, 2\n+      do j = i + 1, 7, i\t! { dg-error \"collapsed loops don.t form rectangular iteration space\" }\n+      end do\n+    end do\n+  !$omp parallel do collapse(2) shared(j)\n+    do i = 1, 3\n+      do j = 4, 6\t\t! { dg-error \"iteration variable present on clause other than PRIVATE or LASTPRIVATE\" }\n+      end do\n+    end do\n+  !$omp parallel do collapse(2)\n+    do i = 1, 3\n+      do j = 4, 6\n+      end do\n+      k = 4\n+    end do\n+  !$omp parallel do collapse(2)\n+    do i = 1, 3\n+      do\t\t\t! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+      end do\n+    end do\n+  !$omp parallel do collapse(2)\n+    do i = 1, 3\n+      do r = 4, 6\t\t! { dg-warning \"must be integer\" }\n+      end do\n+    end do\n+end subroutine collapse1\n+\n+subroutine collapse1_2\n+  integer :: i\n+  !$omp parallel do collapse(2)\n+    do i = -6, 6\t\t! { dg-error \"cannot be redefined inside loop beginning\" }\n+      do i = 4, 6\t\t! { dg-error \"collapsed loops don.t form rectangular iteration space|cannot be redefined\" }\n+      end do\n+    end do\n+end subroutine collapse1_2\n+\n+! { dg-error \"iteration variable must be of type integer\" \"integer\" { target *-*-* } 43 }"}, {"sha": "3ab43670762c4740169d928a32d823cde35980b5", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_parse1.f90", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_parse1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_parse1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_parse1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -14,10 +14,6 @@\n !$omp rallel\n call bar\n !$omp end parallel\n-! Non-continuation !$omp must be followed by space, and my reading\n-! doesn't seem to allow tab there.  So such lines should be completely\n-! ignored.\n-!$omp\tstrange  !  { dg-warning \"starts a commented line\" }\n end\n \n ! { dg-final { scan-tree-dump-times \"pragma omp parallel\" 3 \"omplower\" } }"}, {"sha": "9c55d173c11828fc38c33841aaa2799ed34c6f15", "filename": "gcc/testsuite/gfortran.dg/gomp/reduction1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -56,7 +56,7 @@ subroutine foo (ia1)\n !$omp end parallel\n !$omp parallel reduction (*:p1)\t\t! { dg-error \"POINTER object\" }\n !$omp end parallel\n-!$omp parallel reduction (-:aa1)\t! { dg-error \"is ALLOCATABLE\" }\n+!$omp parallel reduction (-:aa1)\n !$omp end parallel\n !$omp parallel reduction (*:ia1)\t! { dg-error \"Assumed size\" }\n !$omp end parallel"}, {"sha": "5c1581454b22f5465ee0812d5bb58ea66ae4649a", "filename": "gcc/testsuite/gfortran.dg/gomp/sharing-3.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-3.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+\n+subroutine foo (vara, varb, varc, vard, n)\n+  integer :: n, vara(n), varb(*), varc(:), vard(6), vare(6)\n+  vare(:) = 0\n+  !$omp parallel default(none) shared(vara, varb, varc, vard, vare)\n+    !$omp master\n+      vara(1) = 1\n+      varb(1) = 1\n+      varc(1) = 1\n+      vard(1) = 1\n+      vare(1) = 1\n+    !$omp end master\n+  !$omp end parallel\n+  !$omp parallel default(none) private(vara, varc, vard, vare)\n+    vara(1) = 1\n+    varc(1) = 1\n+    vard(1) = 1\n+    vare(1) = 1\n+  !$omp end parallel\n+  !$omp parallel default(none) firstprivate(vara, varc, vard, vare)\n+    vara(1) = 1\n+    varc(1) = 1\n+    vard(1) = 1\n+    vare(1) = 1\n+  !$omp end parallel\n+  !$omp parallel default(none)\t! { dg-error \"enclosing parallel\" }\n+    !$omp master\n+      vara(1) = 1\t\t! { dg-error \"not specified\" }\n+      varb(1) = 1\t\t! Assumed-size is predetermined\n+      varc(1) = 1\t\t! { dg-error \"not specified\" \"\" { xfail *-*-* } }\n+      vard(1) = 1\t\t! { dg-error \"not specified\" }\n+      vare(1) = 1\t\t! { dg-error \"not specified\" }\n+    !$omp end master\n+  !$omp end parallel\n+end subroutine foo"}, {"sha": "3034ba339e1e2600fbd2e3f6302e1142064ebde6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -523,6 +523,7 @@ make_edges (void)\n \t      break;\n \n \t    case OMP_PARALLEL:\n+\t    case OMP_TASK:\n \t    case OMP_FOR:\n \t    case OMP_SINGLE:\n \t    case OMP_MASTER:\n@@ -1936,16 +1937,17 @@ remove_useless_stmts_1 (tree *tp, struct rus_data *data)\n       break;\n \n     case OMP_PARALLEL:\n+    case OMP_TASK:\n       /* Make sure the outermost BIND_EXPR in OMP_BODY isn't removed\n \t as useless.  */\n-      remove_useless_stmts_1 (&BIND_EXPR_BODY (OMP_BODY (*tp)), data);\n+      remove_useless_stmts_1 (&BIND_EXPR_BODY (OMP_TASKREG_BODY (*tp)), data);\n       data->last_goto = NULL;\n       break;\n \n     case OMP_SECTIONS:\n     case OMP_SINGLE:\n     case OMP_SECTION:\n-    case OMP_MASTER :\n+    case OMP_MASTER:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n       remove_useless_stmts_1 (&OMP_BODY (*tp), data);"}, {"sha": "8b05f93d5052535d99bfbc3f6e01b5008e698c46", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -322,6 +322,7 @@ is_gimple_stmt (tree t)\n     case OMP_CRITICAL:\n     case OMP_RETURN:\n     case OMP_CONTINUE:\n+    case OMP_TASK:\n     case OMP_ATOMIC_LOAD:\n     case OMP_ATOMIC_STORE:\n       /* These are always void.  */"}, {"sha": "a9ca33b14d4689cbac1e7508ee9847ae61e4e0ef", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -2478,6 +2478,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n       }\n \n     case OMP_PARALLEL:\n+    case OMP_TASK:\n     case OMP_FOR:\n     case OMP_SECTIONS:\n     case OMP_SINGLE:"}, {"sha": "be5e87ca316a668dca5e553cb0f5189e9ad65b38", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 143, "deletions": 50, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -677,6 +677,7 @@ walk_omp_for (walk_tree_fn callback, struct nesting_info *info, tree for_stmt)\n {\n   struct walk_stmt_info wi;\n   tree t, list = NULL, empty;\n+  int i;\n \n   walk_body (callback, info, &OMP_FOR_PRE_BODY (for_stmt));\n \n@@ -687,36 +688,39 @@ walk_omp_for (walk_tree_fn callback, struct nesting_info *info, tree for_stmt)\n   wi.info = info;\n   wi.tsi = tsi_last (list);\n \n-  t = OMP_FOR_INIT (for_stmt);\n-  gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n-  SET_EXPR_LOCUS (empty, EXPR_LOCUS (t));\n-  wi.val_only = false;\n-  walk_tree (&GIMPLE_STMT_OPERAND (t, 0), callback, &wi, NULL);\n-  wi.val_only = true;\n-  wi.is_lhs = false;\n-  walk_tree (&GIMPLE_STMT_OPERAND (t, 1), callback, &wi, NULL);\n-\n-  t = OMP_FOR_COND (for_stmt);\n-  gcc_assert (COMPARISON_CLASS_P (t));\n-  SET_EXPR_LOCUS (empty, EXPR_LOCUS (t));\n-  wi.val_only = false;\n-  walk_tree (&TREE_OPERAND (t, 0), callback, &wi, NULL);\n-  wi.val_only = true;\n-  wi.is_lhs = false;\n-  walk_tree (&TREE_OPERAND (t, 1), callback, &wi, NULL);\n-\n-  t = OMP_FOR_INCR (for_stmt);\n-  gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n-  SET_EXPR_LOCUS (empty, EXPR_LOCUS (t));\n-  wi.val_only = false;\n-  walk_tree (&GIMPLE_STMT_OPERAND (t, 0), callback, &wi, NULL);\n-  t = GIMPLE_STMT_OPERAND (t, 1);\n-  gcc_assert (BINARY_CLASS_P (t));\n-  wi.val_only = false;\n-  walk_tree (&TREE_OPERAND (t, 0), callback, &wi, NULL);\n-  wi.val_only = true;\n-  wi.is_lhs = false;\n-  walk_tree (&TREE_OPERAND (t, 1), callback, &wi, NULL);\n+  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); i++)\n+    {\n+      t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);\n+      gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+      SET_EXPR_LOCUS (empty, EXPR_LOCUS (t));\n+      wi.val_only = false;\n+      walk_tree (&GIMPLE_STMT_OPERAND (t, 0), callback, &wi, NULL);\n+      wi.val_only = true;\n+      wi.is_lhs = false;\n+      walk_tree (&GIMPLE_STMT_OPERAND (t, 1), callback, &wi, NULL);\n+\n+      t = TREE_VEC_ELT (OMP_FOR_COND (for_stmt), i);\n+      gcc_assert (COMPARISON_CLASS_P (t));\n+      SET_EXPR_LOCUS (empty, EXPR_LOCUS (t));\n+      wi.val_only = false;\n+      walk_tree (&TREE_OPERAND (t, 0), callback, &wi, NULL);\n+      wi.val_only = true;\n+      wi.is_lhs = false;\n+      walk_tree (&TREE_OPERAND (t, 1), callback, &wi, NULL);\n+\n+      t = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n+      gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n+      SET_EXPR_LOCUS (empty, EXPR_LOCUS (t));\n+      wi.val_only = false;\n+      walk_tree (&GIMPLE_STMT_OPERAND (t, 0), callback, &wi, NULL);\n+      t = GIMPLE_STMT_OPERAND (t, 1);\n+      gcc_assert (BINARY_CLASS_P (t));\n+      wi.val_only = false;\n+      walk_tree (&TREE_OPERAND (t, 0), callback, &wi, NULL);\n+      wi.val_only = true;\n+      wi.is_lhs = false;\n+      walk_tree (&TREE_OPERAND (t, 1), callback, &wi, NULL);\n+    }\n \n   /* Remove empty statement added above from the end of statement list.  */\n   tsi_delink (&wi.tsi);\n@@ -1100,24 +1104,25 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     case OMP_PARALLEL:\n+    case OMP_TASK:\n       save_suppress = info->suppress_expansion;\n-      if (convert_nonlocal_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))\n+      if (convert_nonlocal_omp_clauses (&OMP_TASKREG_CLAUSES (t), wi))\n \t{\n \t  tree c, decl;\n \t  decl = get_chain_decl (info);\n \t  c = build_omp_clause (OMP_CLAUSE_FIRSTPRIVATE);\n \t  OMP_CLAUSE_DECL (c) = decl;\n-\t  OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (t);\n-\t  OMP_PARALLEL_CLAUSES (t) = c;\n+\t  OMP_CLAUSE_CHAIN (c) = OMP_TASKREG_CLAUSES (t);\n+\t  OMP_TASKREG_CLAUSES (t) = c;\n \t}\n \n       save_local_var_chain = info->new_local_var_chain;\n       info->new_local_var_chain = NULL;\n \n-      walk_body (convert_nonlocal_reference, info, &OMP_PARALLEL_BODY (t));\n+      walk_body (convert_nonlocal_reference, info, &OMP_TASKREG_BODY (t));\n \n       if (info->new_local_var_chain)\n-\tdeclare_vars (info->new_local_var_chain, OMP_PARALLEL_BODY (t), false);\n+\tdeclare_vars (info->new_local_var_chain, OMP_TASKREG_BODY (t), false);\n       info->new_local_var_chain = save_local_var_chain;\n       info->suppress_expansion = save_suppress;\n       break;\n@@ -1161,7 +1166,7 @@ static bool\n convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n {\n   struct nesting_info *info = wi->info;\n-  bool need_chain = false;\n+  bool need_chain = false, need_stmts = false;\n   tree clause, decl;\n   int dummy;\n   bitmap new_suppress;\n@@ -1173,13 +1178,25 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n     {\n       switch (OMP_CLAUSE_CODE (clause))\n \t{\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t    need_stmts = true;\n+\t  goto do_decl_clause;\n+\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  if (OMP_CLAUSE_LASTPRIVATE_STMT (clause))\n+\t    need_stmts = true;\n+\t  goto do_decl_clause;\n+\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n-\tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n+\tdo_decl_clause:\n \t  decl = OMP_CLAUSE_DECL (clause);\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+\t    break;\n \t  if (decl_function_context (decl) != info->context)\n \t    {\n \t      bitmap_set_bit (new_suppress, DECL_UID (decl));\n@@ -1204,6 +1221,8 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_COPYIN:\n+\tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_UNTIED:\n \t  break;\n \n \tdefault:\n@@ -1213,6 +1232,35 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \n   info->suppress_expansion = new_suppress;\n \n+  if (need_stmts)\n+    for (clause = *pclauses; clause ; clause = OMP_CLAUSE_CHAIN (clause))\n+      switch (OMP_CLAUSE_CODE (clause))\n+\t{\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t    {\n+\t      tree old_context\n+\t\t= DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause));\n+\t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t\t= info->context;\n+\t      walk_body (convert_nonlocal_reference, info,\n+\t\t\t &OMP_CLAUSE_REDUCTION_INIT (clause));\n+\t      walk_body (convert_nonlocal_reference, info,\n+\t\t\t &OMP_CLAUSE_REDUCTION_MERGE (clause));\n+\t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t\t= old_context;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  walk_body (convert_nonlocal_reference, info,\n+\t\t     &OMP_CLAUSE_LASTPRIVATE_STMT (clause));\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n   return need_chain;\n }\n \n@@ -1392,24 +1440,25 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     case OMP_PARALLEL:\n+    case OMP_TASK:\n       save_suppress = info->suppress_expansion;\n-      if (convert_local_omp_clauses (&OMP_PARALLEL_CLAUSES (t), wi))\n+      if (convert_local_omp_clauses (&OMP_TASKREG_CLAUSES (t), wi))\n \t{\n \t  tree c;\n \t  (void) get_frame_type (info);\n \t  c = build_omp_clause (OMP_CLAUSE_SHARED);\n \t  OMP_CLAUSE_DECL (c) = info->frame_decl;\n-\t  OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (t);\n-\t  OMP_PARALLEL_CLAUSES (t) = c;\n+\t  OMP_CLAUSE_CHAIN (c) = OMP_TASKREG_CLAUSES (t);\n+\t  OMP_TASKREG_CLAUSES (t) = c;\n \t}\n \n       save_local_var_chain = info->new_local_var_chain;\n       info->new_local_var_chain = NULL;\n \n-      walk_body (convert_local_reference, info, &OMP_PARALLEL_BODY (t));\n+      walk_body (convert_local_reference, info, &OMP_TASKREG_BODY (t));\n \n       if (info->new_local_var_chain)\n-\tdeclare_vars (info->new_local_var_chain, OMP_PARALLEL_BODY (t), false);\n+\tdeclare_vars (info->new_local_var_chain, OMP_TASKREG_BODY (t), false);\n       info->new_local_var_chain = save_local_var_chain;\n       info->suppress_expansion = save_suppress;\n       break;\n@@ -1453,7 +1502,7 @@ static bool\n convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n {\n   struct nesting_info *info = wi->info;\n-  bool need_frame = false;\n+  bool need_frame = false, need_stmts = false;\n   tree clause, decl;\n   int dummy;\n   bitmap new_suppress;\n@@ -1465,13 +1514,25 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n     {\n       switch (OMP_CLAUSE_CODE (clause))\n \t{\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t    need_stmts = true;\n+\t  goto do_decl_clause;\n+\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  if (OMP_CLAUSE_LASTPRIVATE_STMT (clause))\n+\t    need_stmts = true;\n+\t  goto do_decl_clause;\n+\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n-\tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n+\tdo_decl_clause:\n \t  decl = OMP_CLAUSE_DECL (clause);\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+\t    break;\n \t  if (decl_function_context (decl) == info->context\n \t      && !use_pointer_in_frame (decl))\n \t    {\n@@ -1501,6 +1562,8 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n \tcase OMP_CLAUSE_COPYIN:\n+\tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_UNTIED:\n \t  break;\n \n \tdefault:\n@@ -1510,6 +1573,35 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \n   info->suppress_expansion = new_suppress;\n \n+  if (need_stmts)\n+    for (clause = *pclauses; clause ; clause = OMP_CLAUSE_CHAIN (clause))\n+      switch (OMP_CLAUSE_CODE (clause))\n+\t{\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t    {\n+\t      tree old_context\n+\t\t= DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause));\n+\t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t\t= info->context;\n+\t      walk_body (convert_local_reference, info,\n+\t\t\t &OMP_CLAUSE_REDUCTION_INIT (clause));\n+\t      walk_body (convert_local_reference, info,\n+\t\t\t &OMP_CLAUSE_REDUCTION_MERGE (clause));\n+\t      DECL_CONTEXT (OMP_CLAUSE_REDUCTION_PLACEHOLDER (clause))\n+\t\t= old_context;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  walk_body (convert_local_reference, info,\n+\t\t     &OMP_CLAUSE_LASTPRIVATE_STMT (clause));\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n   return need_frame;\n }\n \n@@ -1731,17 +1823,18 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     case OMP_PARALLEL:\n+    case OMP_TASK:\n       save_static_chain_added = info->static_chain_added;\n       info->static_chain_added = 0;\n-      walk_body (convert_call_expr, info, &OMP_PARALLEL_BODY (t));\n+      walk_body (convert_call_expr, info, &OMP_TASKREG_BODY (t));\n       for (i = 0; i < 2; i++)\n \t{\n \t  tree c, decl;\n \t  if ((info->static_chain_added & (1 << i)) == 0)\n \t    continue;\n \t  decl = i ? get_chain_decl (info) : info->frame_decl;\n \t  /* Don't add CHAIN.* or FRAME.* twice.  */\n-\t  for (c = OMP_PARALLEL_CLAUSES (t); c; c = OMP_CLAUSE_CHAIN (c))\n+\t  for (c = OMP_TASKREG_CLAUSES (t); c; c = OMP_CLAUSE_CHAIN (c))\n \t    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n \t\t || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED)\n \t\t&& OMP_CLAUSE_DECL (c) == decl)\n@@ -1751,8 +1844,8 @@ convert_call_expr (tree *tp, int *walk_subtrees, void *data)\n \t      c = build_omp_clause (i ? OMP_CLAUSE_FIRSTPRIVATE\n \t\t\t\t      : OMP_CLAUSE_SHARED);\n \t      OMP_CLAUSE_DECL (c) = decl;\n-\t      OMP_CLAUSE_CHAIN (c) = OMP_PARALLEL_CLAUSES (t);\n-\t      OMP_PARALLEL_CLAUSES (t) = c;\n+\t      OMP_CLAUSE_CHAIN (c) = OMP_TASKREG_CLAUSES (t);\n+\t      OMP_TASKREG_CLAUSES (t) = c;\n \t    }\n \t}\n       info->static_chain_added |= save_static_chain_added;"}, {"sha": "8344093ba6bc4c67a71fec2628495fb2cc6fe783", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1617,13 +1617,16 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   for_stmt = make_node (OMP_FOR);\n   TREE_TYPE (for_stmt) = void_type_node;\n   OMP_FOR_CLAUSES (for_stmt) = t;\n-  OMP_FOR_INIT (for_stmt) = build_gimple_modify_stmt (initvar, cvar_init);\n-  OMP_FOR_COND (for_stmt) = cond;\n-  OMP_FOR_INCR (for_stmt) = build_gimple_modify_stmt (cvar_base,\n-\t\t\t\t\t\t      build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t\t      cvar_base,\n-\t\t\t\t\t\t\t      build_int_cst\n-\t\t\t\t\t\t\t      (type, 1)));\n+  OMP_FOR_INIT (for_stmt) = make_tree_vec (1);\n+  TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), 0)\n+    = build_gimple_modify_stmt (initvar, cvar_init);\n+  OMP_FOR_COND (for_stmt) = make_tree_vec (1);\n+  TREE_VEC_ELT (OMP_FOR_COND (for_stmt), 0) = cond;\n+  OMP_FOR_INCR (for_stmt) = make_tree_vec (2);\n+  TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), 0)\n+    = build_gimple_modify_stmt (cvar_base,\n+\t\t\t\tbuild2 (PLUS_EXPR, type, cvar_base,\n+\t\t\t\t\tbuild_int_cst (type, 1)));\n   OMP_FOR_BODY (for_stmt) = NULL_TREE;\n   OMP_FOR_PRE_BODY (for_stmt) = NULL_TREE;\n "}, {"sha": "2f7de8f1c7d671a7c872b749ab4fe6f9e6570aeb", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -334,19 +334,22 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       pp_string (buffer, \"default(\");\n       switch (OMP_CLAUSE_DEFAULT_KIND (clause))\n \t{\n-      case OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n-\tbreak;\n-      case OMP_CLAUSE_DEFAULT_SHARED:\n-\tpp_string (buffer, \"shared\");\n-\tbreak;\n-      case OMP_CLAUSE_DEFAULT_NONE:\n-\tpp_string (buffer, \"none\");\n-\tbreak;\n-      case OMP_CLAUSE_DEFAULT_PRIVATE:\n-\tpp_string (buffer, \"private\");\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n+\tcase OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULT_SHARED:\n+\t  pp_string (buffer, \"shared\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULT_NONE:\n+\t  pp_string (buffer, \"none\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULT_PRIVATE:\n+\t  pp_string (buffer, \"private\");\n+\t  break;\n+\tcase OMP_CLAUSE_DEFAULT_FIRSTPRIVATE:\n+\t  pp_string (buffer, \"firstprivate\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n       pp_character (buffer, ')');\n       break;\n@@ -367,6 +370,9 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       case OMP_CLAUSE_SCHEDULE_RUNTIME:\n \tpp_string (buffer, \"runtime\");\n \tbreak;\n+      case OMP_CLAUSE_SCHEDULE_AUTO:\n+\tpp_string (buffer, \"auto\");\n+\tbreak;\n       default:\n \tgcc_unreachable ();\n \t}\n@@ -380,6 +386,18 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       pp_character (buffer, ')');\n       break;\n \n+    case OMP_CLAUSE_UNTIED:\n+      pp_string (buffer, \"untied\");\n+      break;\n+\n+    case OMP_CLAUSE_COLLAPSE:\n+      pp_string (buffer, \"collapse(\");\n+      dump_generic_node (buffer,\n+\t\t\t OMP_CLAUSE_COLLAPSE_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_character (buffer, ')');\n+      break;\n+\n     default:\n       /* Should never happen.  */\n       dump_generic_node (buffer, clause, spc, flags, false);\n@@ -1863,12 +1881,41 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       is_expr = false;\n       break;\n \n+    case OMP_TASK:\n+      pp_string (buffer, \"#pragma omp task\");\n+      dump_omp_clauses (buffer, OMP_TASK_CLAUSES (node), spc, flags);\n+      if (OMP_TASK_FN (node))\n+\t{\n+\t  pp_string (buffer, \" [child fn: \");\n+\t  dump_generic_node (buffer, OMP_TASK_FN (node), spc, flags, false);\n+\n+\t  pp_string (buffer, \" (\");\n+\n+\t  if (OMP_TASK_DATA_ARG (node))\n+\t    dump_generic_node (buffer, OMP_TASK_DATA_ARG (node), spc, flags,\n+\t\t\t       false);\n+\t  else\n+\t    pp_string (buffer, \"???\");\n+\n+\t  pp_character (buffer, ')');\n+\t  if (OMP_TASK_COPYFN (node))\n+\t    {\n+\t      pp_string (buffer, \", copy fn: \");\n+\t      dump_generic_node (buffer, OMP_TASK_COPYFN (node), spc,\n+\t\t\t\t flags, false);\n+\t    }\n+\t  pp_character (buffer, ']');\n+\t}\n+      goto dump_omp_body;\n+\n     case OMP_FOR:\n       pp_string (buffer, \"#pragma omp for\");\n       dump_omp_clauses (buffer, OMP_FOR_CLAUSES (node), spc, flags);\n \n       if (!(flags & TDF_SLIM))\n \t{\n+\t  int i;\n+\n \t  if (OMP_FOR_PRE_BODY (node))\n \t    {\n \t      newline_and_indent (buffer, spc + 2);\n@@ -1878,14 +1925,22 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t      dump_generic_node (buffer, OMP_FOR_PRE_BODY (node),\n \t\t  spc, flags, false);\n \t    }\n-\t  newline_and_indent (buffer, spc);\n-\t  pp_string (buffer, \"for (\");\n-\t  dump_generic_node (buffer, OMP_FOR_INIT (node), spc, flags, false);\n-\t  pp_string (buffer, \"; \");\n-\t  dump_generic_node (buffer, OMP_FOR_COND (node), spc, flags, false);\n-\t  pp_string (buffer, \"; \");\n-\t  dump_generic_node (buffer, OMP_FOR_INCR (node), spc, flags, false);\n-\t  pp_string (buffer, \")\");\n+\t  spc -= 2;\n+\t  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (node)); i++)\n+\t    {\n+\t      spc += 2;\n+\t      newline_and_indent (buffer, spc);\n+\t      pp_string (buffer, \"for (\");\n+\t      dump_generic_node (buffer, TREE_VEC_ELT (OMP_FOR_INIT (node), i),\n+\t\t\t\t spc, flags, false);\n+\t      pp_string (buffer, \"; \");\n+\t      dump_generic_node (buffer, TREE_VEC_ELT (OMP_FOR_COND (node), i),\n+\t\t\t\t spc, flags, false);\n+\t      pp_string (buffer, \"; \");\n+\t      dump_generic_node (buffer, TREE_VEC_ELT (OMP_FOR_INCR (node), i),\n+\t\t\t\t spc, flags, false);\n+\t      pp_string (buffer, \")\");\n+\t    }\n \t  if (OMP_FOR_BODY (node))\n \t    {\n \t      newline_and_indent (buffer, spc + 2);\n@@ -1896,6 +1951,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t      newline_and_indent (buffer, spc + 2);\n \t      pp_character (buffer, '}');\n \t    }\n+\t  spc -= 2 * TREE_VEC_LENGTH (OMP_FOR_INIT (node)) - 2;\n \t  if (OMP_FOR_PRE_BODY (node))\n \t    {\n \t      spc -= 4;"}, {"sha": "71fb883f84a4f101bd8a1e47a289efc57a37e916", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -2093,17 +2093,22 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \n     case OMP_FOR:\n       {\n-\ttree init = OMP_FOR_INIT (expr);\n-\ttree cond = OMP_FOR_COND (expr);\n-\ttree incr = OMP_FOR_INCR (expr);\n \ttree c, clauses = OMP_FOR_CLAUSES (stmt);\n+\tint i;\n \n-\tget_expr_operands (stmt, &GIMPLE_STMT_OPERAND (init, 0), opf_def);\n-\tget_expr_operands (stmt, &GIMPLE_STMT_OPERAND (init, 1), opf_use);\n-\tget_expr_operands (stmt, &TREE_OPERAND (cond, 1), opf_use);\n-\tget_expr_operands (stmt,\n-\t                   &TREE_OPERAND (GIMPLE_STMT_OPERAND (incr, 1), 1),\n-\t\t\t   opf_use);\n+\tfor (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (expr)); i++)\n+\t  {\n+\t    tree init = TREE_VEC_ELT (OMP_FOR_INIT (expr), i);\n+\t    tree cond = TREE_VEC_ELT (OMP_FOR_COND (expr), i);\n+\t    tree incr = TREE_VEC_ELT (OMP_FOR_INCR (expr), i);\n+\n+\t    get_expr_operands (stmt, &GIMPLE_STMT_OPERAND (init, 0), opf_def);\n+\t    get_expr_operands (stmt, &GIMPLE_STMT_OPERAND (init, 1), opf_use);\n+\t    get_expr_operands (stmt, &TREE_OPERAND (cond, 1), opf_use);\n+\t    get_expr_operands (stmt,\n+\t\t\t       &TREE_OPERAND (GIMPLE_STMT_OPERAND (incr, 1),\n+\t\t\t\t\t      1), opf_use);\n+\t  }\n \n \tc = find_omp_clause (clauses, OMP_CLAUSE_SCHEDULE);\n \tif (c)"}, {"sha": "8bf2b7718afa065674a5a4fb168a4dd019cf8b0c", "filename": "gcc/tree.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -177,7 +177,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_PRIVATE  */\n   1, /* OMP_CLAUSE_SHARED  */\n   1, /* OMP_CLAUSE_FIRSTPRIVATE  */\n-  1, /* OMP_CLAUSE_LASTPRIVATE  */\n+  2, /* OMP_CLAUSE_LASTPRIVATE  */\n   4, /* OMP_CLAUSE_REDUCTION  */\n   1, /* OMP_CLAUSE_COPYIN  */\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n@@ -186,7 +186,9 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_SCHEDULE  */\n   0, /* OMP_CLAUSE_NOWAIT  */\n   0, /* OMP_CLAUSE_ORDERED  */\n-  0  /* OMP_CLAUSE_DEFAULT  */\n+  0, /* OMP_CLAUSE_DEFAULT  */\n+  3, /* OMP_CLAUSE_COLLAPSE  */\n+  0  /* OMP_CLAUSE_UNTIED   */\n };\n \n const char * const omp_clause_code_name[] =\n@@ -204,7 +206,9 @@ const char * const omp_clause_code_name[] =\n   \"schedule\",\n   \"nowait\",\n   \"ordered\",\n-  \"default\"\n+  \"default\",\n+  \"collapse\",\n+  \"untied\"\n };\n \f\n /* Init tree.c.  */\n@@ -8452,7 +8456,6 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_IF:\n@@ -8464,8 +8467,22 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n+\tcase OMP_CLAUSE_UNTIED:\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  WALK_SUBTREE (OMP_CLAUSE_DECL (*tp));\n+\t  WALK_SUBTREE (OMP_CLAUSE_LASTPRIVATE_STMT (*tp));\n+\t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n+\n+\tcase OMP_CLAUSE_COLLAPSE:\n+\t  {\n+\t    int i;\n+\t    for (i = 0; i < 3; i++)\n+\t      WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, i));\n+\t    WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n+\t  }\n+\n \tcase OMP_CLAUSE_REDUCTION:\n \t  {\n \t    int i;"}, {"sha": "7474f2e68f1e2b370442e6669e0d9f0ab450fb0d", "filename": "gcc/tree.def", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1001,6 +1001,23 @@ DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 7)\n \n DEFTREECODE (OMP_PARALLEL, \"omp_parallel\", tcc_statement, 4)\n \n+/* OpenMP - #pragma omp task [clause1 ... clauseN]\n+   Operand 0: OMP_TASK_BODY: Code to be executed by all threads.\n+   Operand 1: OMP_TASK_CLAUSES: List of clauses.\n+   Operand 2: OMP_TASK_FN: FUNCTION_DECL used when outlining the\n+\t      body of the task region.  Only valid after\n+\t      pass_lower_omp.\n+   Operand 3: OMP_TASK_DATA_ARG: Local variable in the parent\n+\t      function containing data to be shared with the child\n+\t      function.\n+   Operand 4: OMP_TASK_COPYFN: FUNCTION_DECL used for constructing\n+\t      firstprivate variables.\n+   Operand 5: OMP_TASK_ARG_SIZE: Length of the task argument block.\n+   Operand 6: OMP_TASK_ARG_ALIGN: Required alignment of the task\n+\t      argument block.  */\n+\n+DEFTREECODE (OMP_TASK, \"omp_task\", tcc_statement, 7)\n+\n /* OpenMP - #pragma omp for [clause1 ... clauseN]\n    Operand 0: OMP_FOR_BODY: Loop body.\n    Operand 1: OMP_FOR_CLAUSES: List of clauses."}, {"sha": "c3d2abe6978fbae6e626578710762c83406bb2f7", "filename": "gcc/tree.h", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -186,6 +186,7 @@ extern const enum tree_code_class tree_code_type[];\n \n #define OMP_DIRECTIVE_P(NODE)\t\t\t\t\\\n     (TREE_CODE (NODE) == OMP_PARALLEL\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_TASK\t\t\t\\\n      || TREE_CODE (NODE) == OMP_FOR\t\t\t\\\n      || TREE_CODE (NODE) == OMP_SECTIONS\t\t\\\n      || TREE_CODE (NODE) == OMP_SECTIONS_SWITCH\t\t\\\n@@ -315,7 +316,7 @@ enum omp_clause_code\n      Operand 2: OMP_CLAUSE_REDUCTION_MERGE: Stmt-list to merge private var\n                 into the shared one.\n      Operand 3: OMP_CLAUSE_REDUCTION_PLACEHOLDER: A dummy VAR_DECL\n-                placeholder used in OMP_CLAUSE_REDUCTION_MERGE.  */\n+                placeholder used in OMP_CLAUSE_REDUCTION_{INIT,MERGE}.  */\n   OMP_CLAUSE_REDUCTION,\n \n   /* OpenMP clause: copyin (variable_list).  */\n@@ -340,7 +341,13 @@ enum omp_clause_code\n   OMP_CLAUSE_ORDERED,\n \n   /* OpenMP clause: default.  */\n-  OMP_CLAUSE_DEFAULT\n+  OMP_CLAUSE_DEFAULT,\n+\n+  /* OpenMP clause: collapse (constant-integer-expression).  */\n+  OMP_CLAUSE_COLLAPSE,\n+\n+  /* OpenMP clause: untied.  */\n+  OMP_CLAUSE_UNTIED\n };\n \f\n /* The definition of tree nodes fills the next several pages.  */\n@@ -524,6 +531,8 @@ struct gimple_stmt GTY(())\n \n        OMP_PARALLEL_COMBINED in\n            OMP_PARALLEL\n+       OMP_CLAUSE_PRIVATE_OUTER_REF in\n+\t   OMP_CLAUSE_PRIVATE\n \n    protected_flag:\n \n@@ -1796,6 +1805,20 @@ struct tree_constructor GTY(())\n #define OMP_PARALLEL_FN(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 2)\n #define OMP_PARALLEL_DATA_ARG(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 3)\n \n+#define OMP_TASK_BODY(NODE)\t   TREE_OPERAND (OMP_TASK_CHECK (NODE), 0)\n+#define OMP_TASK_CLAUSES(NODE)\t   TREE_OPERAND (OMP_TASK_CHECK (NODE), 1)\n+#define OMP_TASK_FN(NODE)\t   TREE_OPERAND (OMP_TASK_CHECK (NODE), 2)\n+#define OMP_TASK_DATA_ARG(NODE)\t   TREE_OPERAND (OMP_TASK_CHECK (NODE), 3)\n+#define OMP_TASK_COPYFN(NODE)\t   TREE_OPERAND (OMP_TASK_CHECK (NODE), 4)\n+#define OMP_TASK_ARG_SIZE(NODE)\t   TREE_OPERAND (OMP_TASK_CHECK (NODE), 5)\n+#define OMP_TASK_ARG_ALIGN(NODE)   TREE_OPERAND (OMP_TASK_CHECK (NODE), 6)\n+\n+#define OMP_TASKREG_CHECK(NODE)\t  TREE_RANGE_CHECK (NODE, OMP_PARALLEL, OMP_TASK)\n+#define OMP_TASKREG_BODY(NODE)    TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 0)\n+#define OMP_TASKREG_CLAUSES(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 1)\n+#define OMP_TASKREG_FN(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 2)\n+#define OMP_TASKREG_DATA_ARG(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 3)\n+\n #define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 0)\n #define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 1)\n #define OMP_FOR_INIT(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 2)\n@@ -1848,10 +1871,19 @@ struct tree_constructor GTY(())\n #define OMP_CLAUSE_PRIVATE_DEBUG(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE)->base.public_flag)\n \n+/* True on a PRIVATE clause if ctor needs access to outer region's\n+   variable.  */\n+#define OMP_CLAUSE_PRIVATE_OUTER_REF(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_PRIVATE))\n+\n /* True on a LASTPRIVATE clause if a FIRSTPRIVATE clause for the same\n    decl is present in the chain.  */\n #define OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LASTPRIVATE)->base.public_flag)\n+#define OMP_CLAUSE_LASTPRIVATE_STMT(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE,\t\t\t\\\n+\t\t\t\t\t\tOMP_CLAUSE_LASTPRIVATE),\\\n+\t\t      1)\n \n #define OMP_CLAUSE_IF_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF), 0)\n@@ -1860,6 +1892,13 @@ struct tree_constructor GTY(())\n #define OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE), 0)\n \n+#define OMP_CLAUSE_COLLAPSE_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 0)\n+#define OMP_CLAUSE_COLLAPSE_ITERVAR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 1)\n+#define OMP_CLAUSE_COLLAPSE_COUNT(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_COLLAPSE), 2)\n+\n #define OMP_CLAUSE_REDUCTION_CODE(NODE)\t\\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION)->omp_clause.subcode.reduction_code)\n #define OMP_CLAUSE_REDUCTION_INIT(NODE) \\\n@@ -1874,6 +1913,7 @@ enum omp_clause_schedule_kind\n   OMP_CLAUSE_SCHEDULE_STATIC,\n   OMP_CLAUSE_SCHEDULE_DYNAMIC,\n   OMP_CLAUSE_SCHEDULE_GUIDED,\n+  OMP_CLAUSE_SCHEDULE_AUTO,\n   OMP_CLAUSE_SCHEDULE_RUNTIME\n };\n \n@@ -1885,7 +1925,8 @@ enum omp_clause_default_kind\n   OMP_CLAUSE_DEFAULT_UNSPECIFIED,\n   OMP_CLAUSE_DEFAULT_SHARED,\n   OMP_CLAUSE_DEFAULT_NONE,\n-  OMP_CLAUSE_DEFAULT_PRIVATE\n+  OMP_CLAUSE_DEFAULT_PRIVATE,\n+  OMP_CLAUSE_DEFAULT_FIRSTPRIVATE\n };\n \n #define OMP_CLAUSE_DEFAULT_KIND(NODE) \\"}, {"sha": "73a0aa70c0ca5a59a889602882426e86d33f0b37", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,3 +1,470 @@\n+2008-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\t    Ulrich Drepper  <drepper@redhat.com>\n+\t    Jakob Blomer  <jakob.blomer@ira.uka.de>\n+\n+\t* configure.ac (LIBGOMP_GNU_SYMBOL_VERSIONING): New AC_DEFINE.\n+\tSubstitute also OMP_*LOCK_25*.\n+\t* configure: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t* Makefile.am (libgomp_la_SOURCES): Add loop_ull.c, iter_ull.c,\n+\tptrlock.c and task.c.\n+\t* Makefile.in: Regenerated.\n+\t* testsuite/Makefile.in: Regenerated.\n+\t* task.c: New file.\n+\t* loop_ull.c: New file.\n+\t* iter_ull.c: New file.\n+\t* libgomp.h: Include ptrlock.h.\n+\t(enum gomp_task_kind): New type.\n+\t(struct gomp_team): Add task_lock, task_queue, task_count,\n+\ttask_running_count, single_count fields.  Add\n+\twork_share_list_free_lock ifndef HAVE_SYNC_BUILTINS.\n+\tRemove work_share_lock, generation_mask,\n+\toldest_live_gen, num_live_gen and init_work_shares fields, add\n+\twork work_share_list_alloc, work_share_list_free and work_share_chunk\n+\tfields.  Change work_shares from pointer to pointers into an array.\n+\tChange ordered_release field into gomp_sem_t ** from flexible array\n+\tmember.  Add implicit_task and initial_work_shares fields.\n+\tMove close to the end of the struct.\n+\t(struct gomp_team_state): Add single_count, last_work_share,\n+\tactive_level and level fields, remove work_share_generation.\n+\t(gomp_barrier_handle_tasks): New prototype.\n+\t(gomp_finish_task): New inline function.\n+\t(struct gomp_work_share): Move chunk_size, end, incr into\n+\ttransparent union/struct, add chunk_size_ull, end_ll, incr_ll and\n+\tnext_ll fields.  Reshuffle fields.  Add next_alloc,\n+\tnext_ws, next_free and inline_ordered_team_ids fields, change\n+\tordered_team_ids into pointer from flexible array member.\n+\tAdd mode field.  Put lock and next into a different cache line\n+\tfrom most of the write-once fields.\n+\t(gomp_iter_ull_static_next, gomp_iter_ull_dynamic_next_locked,\n+\tgomp_iter_ull_guided_next_locked, gomp_iter_ull_dynamic_next,\n+\tgomp_iter_ull_guided_next): New prototypes.\n+\t(gomp_new_icv): New prototype.\n+\t(struct gomp_thread): Add thread_pool and task fields.\n+\t(struct gomp_thread_pool): New type.\n+\t(gomp_new_team): New prototype.\n+\t(gomp_team_start): Change type of last argument.\n+\t(gomp_new_work_share): Removed.\n+\t(gomp_init_work_share, gomp_fini_work_share): New prototypes.\n+\t(gomp_work_share_init_done): New static inline.\n+\t(gomp_throttled_spin_count_var, gomp_available_cpus,\n+\tgomp_managed_threads): New extern decls.\n+\t(gomp_init_task): New prototype.\n+\t(gomp_spin_count_var): New extern var decl.\n+\t(LIBGOMP_GNU_SYMBOL_VERSIONING): Undef if no visibility\n+\tor no alias support, or if not PIC.\n+\t(gomp_init_lock_30, gomp_destroy_lock_30, gomp_set_lock_30,\n+\tgomp_unset_lock_30, gomp_test_lock_30, gomp_init_nest_lock_30,\n+\tgomp_destroy_nest_lock_30, gomp_set_nest_lock_30,\n+\tgomp_unset_nest_lock_30, gomp_test_nest_lock_30, gomp_init_lock_25,\n+\tgomp_destroy_lock_25, gomp_set_lock_25, gomp_unset_lock_25,\n+\tgomp_test_lock_25, gomp_init_nest_lock_25, gomp_destroy_nest_lock_25,\n+\tgomp_set_nest_lock_25, gomp_unset_nest_lock_25,\n+\tgomp_test_nest_lock_25): New prototypes.\n+\t(omp_lock_symver, strong_alias): Define.\n+\t(gomp_remaining_threads_count, gomp_remaining_threads_lock): New\n+\tdecls.\n+\t(gomp_end_task): New.\n+\t(struct gomp_task_icv, gomp_global_icv): New.\n+\t(gomp_thread_limit_var, gomp_max_active_levels_var): New.\n+\t(struct gomp_task): New.\n+\t(gomp_nthreads_var, gomp_dyn_var, gomp_nest_var,\n+\tgomp_run_sched_var, gomp_run_sched_chunk): Remove.\n+\t(gomp_icv): New.\n+\t(gomp_schedule_type): Reorder enum to match\n+\tomp_sched_t.\n+\t* team.c (struct gomp_thread_start_data): Add thread_pool and task\n+\tfields.\n+\t(gomp_thread_start): Add gomp_team_barrier_wait call.\n+\tFor non-nested case remove clearing of docked thread thr fields.\n+\tUse pool fields instead of global gomp_* variables.  Use\n+\tgomp_barrier_wait_last when needed.  Initialize ts.active_level.\n+\tCreate tasks for each member thread.\n+\t(free_team): Only destroy team barrier, task_lock here and free it.\n+\t(gomp_free_thread): Free last_team if non-NULL.\n+\t(gomp_team_end): Call gomp_team_barrier_wait instead of\n+\tgomp_barrier_wait.  For nested case call one extra\n+\tgomp_barrier_wait.  Move here some destruction from free_team.\n+\tCall free_team on pool->last_team if any, rather than freeing\n+\tcurrent team.  Destroy work_share_list_free_lock ifndef\n+\tHAVE_SYNC_BUILTINS.\n+\t(gomp_new_icv): New function.\n+\t(gomp_threads, gomp_threads_size, gomp_threads_used,\n+\tgomp_threads_dock): Removed.\n+\t(gomp_thread_destructor): New variable.\n+\t(gomp_new_thread_pool, gomp_free_pool_helper, gomp_free_thread): New\n+\tfunctions.\n+\t(gomp_team_start): Create new pool if current thread doesn't have\n+\tone.  Use pool fields instead of global gomp_* variables. \n+\tInitialize thread_pool field for new threads.  Clear single_count.\n+\tChange last argument from ws to team, don't create\n+\tnew team, set ts.work_share to &team->work_shares[0] and clear\n+\tts.last_work_share.  Don't clear ts.work_share_generation.\n+\tIf number of threads changed, adjust atomically gomp_managed_threads.\n+\tUse gomp_init_task instead of gomp_new_task,\n+\tset thr->task to the corresponding implicit_task array entry.\n+\tCreate tasks for each member thread.  Initialize ts.level.\n+\t(initialize_team): Call pthread_key_create on\n+\tgomp_thread_destructor.\n+\t(team_destructor): New function.\n+\t(new_team): Removed.\n+\t(gomp_new_team): New function.\n+\t(free_team): Free gomp_work_share blocks chained through next_alloc,\n+\tinstead of freeing work_shares and destroying work_share_lock.\n+\t(gomp_team_end): Call gomp_fini_work_share.  If number of threads\n+\tchanged, adjust atomically gomp_managed_threads.  Use gomp_end_task.\n+\t* barrier.c (GOMP_barrier): Call gomp_team_barrier_wait instead\n+\tof gomp_barrier_wait.\n+\t* single.c (GOMP_single_copy_start): Call gomp_team_barrier_wait\n+\tinstead of gomp_barrier_wait.  Call gomp_work_share_init_done\n+\tif gomp_work_share_start returned true.  Don't unlock ws->lock.\n+\t(GOMP_single_copy_end): Call gomp_team_barrier_wait instead\n+\tof gomp_barrier_wait.\n+\t(GOMP_single_start): Rewritten if HAVE_SYNC_BUILTINS.  Call\n+\tgomp_work_share_init_done if gomp_work_share_start returned true.\n+\tDon't unlock ws->lock.\n+\t* work.c: Include stddef.h.\n+\t(free_work_share): Use work_share_list_free_lock instead\n+\tof atomic chaining ifndef HAVE_SYNC_BUILTINS.  Add team argument.\n+\tCall gomp_fini_work_share and then either free ws if orphaned, or\n+\tput it into work_share_list_free list of the current team.\n+\t(alloc_work_share, gomp_init_work_share, gomp_fini_work_share): New\n+\tfunctions.\n+\t(gomp_work_share_start, gomp_work_share_end,\n+\tgomp_work_share_end_nowait): Rewritten.\n+\t* omp_lib.f90.in Change some tabs to spaces to prevent warnings.\n+\t(openmp_version): Set to 200805.\n+\t(omp_sched_kind, omp_sched_static, omp_sched_dynamic,\n+\tomp_sched_guided, omp_sched_auto): New parameters.\n+\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n+\tomp_set_max_active_levels, omp_get_max_active_levels,\n+\tomp_get_level, omp_get_ancestor_thread_num, omp_get_team_size,\n+\tomp_get_active_level): New interfaces.\n+\t* omp_lib.h.in (openmp_version): Set to 200805.\n+\t(omp_sched_kind, omp_sched_static, omp_sched_dynamic,\n+\tomp_sched_guided, omp_sched_auto): New parameters.\n+\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n+\tomp_set_max_active_levels, omp_get_max_active_levels,\n+\tomp_get_level, omp_get_ancestor_thread_num, omp_get_team_size,\n+\tomp_get_active_level): New externals.\n+\t* loop.c: Include limits.h.\n+\t(GOMP_loop_runtime_next, GOMP_loop_ordered_runtime_next): Handle\n+\tGFS_AUTO.\n+\t(GOMP_loop_runtime_start, GOMP_loop_ordered_runtime_start):\n+\tLikewise.  Use gomp_icv.\n+\t(gomp_loop_static_start, gomp_loop_dynamic_start): Clear\n+\tts.static_trip here.\n+\t(gomp_loop_static_start, gomp_loop_ordered_static_start): Call\n+\tgomp_work_share_init_done after gomp_loop_init.  Don't unlock ws->lock.\n+\t(gomp_loop_dynamic_start, gomp_loop_guided_start): Call\n+\tgomp_work_share_init_done after gomp_loop_init.  If HAVE_SYNC_BUILTINS,\n+\tdon't unlock ws->lock, otherwise lock it.\n+\t(gomp_loop_ordered_dynamic_start, gomp_loop_ordered_guided_start): Call\n+\tgomp_work_share_init_done after gomp_loop_init.  Lock ws->lock.\n+\t(gomp_parallel_loop_start): Call gomp_new_team instead of\n+\tgomp_new_work_share.  Call gomp_loop_init on &team->work_shares[0].\n+\tAdjust gomp_team_start caller.  Pass 0 as second argument to\n+\tgomp_resolve_num_threads.\n+\t(gomp_loop_init): For GFS_DYNAMIC, multiply ws->chunk_size by incr.\n+\tIf adding ws->chunk_size nthreads + 1 times after end won't\n+\toverflow, set ws->mode to 1.\n+\t* libgomp_g.h (GOMP_loop_ull_static_start, GOMP_loop_ull_dynamic_start,\n+\tGOMP_loop_ull_guided_start, GOMP_loop_ull_runtime_start,\n+\tGOMP_loop_ull_ordered_static_start,\n+\tGOMP_loop_ull_ordered_dynamic_start,\n+\tGOMP_loop_ull_ordered_guided_start,\n+\tGOMP_loop_ull_ordered_runtime_start, GOMP_loop_ull_static_next,\n+\tGOMP_loop_ull_dynamic_next, GOMP_loop_ull_guided_next,\n+\tGOMP_loop_ull_runtime_next, GOMP_loop_ull_ordered_static_next,\n+\tGOMP_loop_ull_ordered_dynamic_next, GOMP_loop_ull_ordered_guided_next,\n+\tGOMP_loop_ull_ordered_runtime_next, GOMP_task, GOMP_taskwait): New\n+\tprototypes.\n+\t* libgomp.map: Export lock routines also @@OMP_2.0.\n+\t(GOMP_loop_ordered_dynamic_first,\n+\tGOMP_loop_ordered_guided_first, GOMP_loop_ordered_runtime_first,\n+\tGOMP_loop_ordered_static_first): Remove.\n+\t(GOMP_loop_ull_dynamic_next, GOMP_loop_ull_dynamic_start,\n+\tGOMP_loop_ull_guided_next, GOMP_loop_ull_guided_start,\n+\tGOMP_loop_ull_ordered_dynamic_next,\n+\tGOMP_loop_ull_ordered_dynamic_start,\n+\tGOMP_loop_ull_ordered_guided_next,\n+\tGOMP_loop_ull_ordered_guided_start,\n+\tGOMP_loop_ull_ordered_runtime_next,\n+\tGOMP_loop_ull_ordered_runtime_start,\n+\tGOMP_loop_ull_ordered_static_next,\n+\tGOMP_loop_ull_ordered_static_start,\n+\tGOMP_loop_ull_runtime_next, GOMP_loop_ull_runtime_start,\n+\tGOMP_loop_ull_static_next, GOMP_loop_ull_static_start,\n+\tGOMP_task, GOMP_taskwait): Export @@GOMP_2.0.\n+\t(omp_set_schedule, omp_get_schedule,\n+\tomp_get_thread_limit, omp_set_max_active_levels,\n+\tomp_get_max_active_levels, omp_get_level,\n+\tomp_get_ancestor_thread_num, omp_get_team_size, omp_get_active_level,\n+\tomp_set_schedule_, omp_set_schedule_8_,\n+\tomp_get_schedule_, omp_get_schedule_8_, omp_get_thread_limit_,\n+\tomp_set_max_active_levels_, omp_set_max_active_levels_8_,\n+\tomp_get_max_active_levels_, omp_get_level_,\n+\tomp_get_ancestor_thread_num_, omp_get_ancestor_thread_num_8_,\n+\tomp_get_team_size_, omp_get_team_size_8_, omp_get_active_level_):\n+\tNew exports @@OMP_3.0.\n+\t* omp.h.in (omp_sched_t): New type.\n+\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n+\tomp_set_max_active_levels, omp_get_max_active_levels,\n+\tomp_get_level, omp_get_ancestor_thread_num, omp_get_team_size,\n+\tomp_get_active_level): New prototypes.\n+\t* env.c (gomp_spin_count_var, gomp_throttled_spin_count_var,\n+\tgomp_available_cpus, gomp_managed_threads, gomp_max_active_levels_var,\n+\tgomp_thread_limit_var, gomp_remaining_threads_count,\n+\tgomp_remaining_threads_lock): New variables.\n+\t(parse_spincount): New function.\n+\t(initialize_env): Call gomp_init_num_threads unconditionally.\n+\tInitialize gomp_available_cpus.  Call parse_spincount,\n+\tinitialize gomp_{,throttled_}spin_count_var\n+\tdepending on presence and value of OMP_WAIT_POLICY and\n+\tGOMP_SPINCOUNT env vars.  Handle GOMP_BLOCKTIME env var.\n+\tHandle OMP_WAIT_POLICY, OMP_MAX_ACTIVE_LEVELS,\n+\tOMP_THREAD_LIMIT, OMP_STACKSIZE env vars.  Handle unit specification\n+\tfor GOMP_STACKSIZE.  Initialize gomp_remaining_threads_count and\n+\tgomp_remaining_threads_lock if needed.  Use gomp_global_icv.\n+\t(gomp_nthreads_var, gomp_dyn_var, gomp_nest_var,\n+\tgomp_run_sched_var, gomp_run_sched_chunk): Remove.\n+\t(gomp_global_icv): New.\n+\t(parse_schedule): Use it.  Parse \"auto\".\n+\t(omp_set_num_threads): Use gomp_icv.\n+\t(omp_set_dynamic, omp_get_dynamic, omp_set_nested, omp_get_nested):\n+\tLikewise.\n+\t(omp_get_max_threads): Move from parallel.c.\n+\t(omp_set_schedule, omp_get_schedule, omp_get_thread_limit,\n+\tomp_set_max_active_levels, omp_get_max_active_levels): New functions,\n+\tadd ialias.\n+\t(parse_stacksize, parse_wait_policy): New functions.\n+\t* fortran.c: Rewrite lock wrappers, if symbol versioning provide\n+\tboth wrappers for compatibility and new locks.\n+\t(omp_set_schedule, omp_get_schedule,\n+\tomp_get_thread_limit, omp_set_max_active_levels,\n+\tomp_get_max_active_levels, omp_get_level,\n+\tomp_get_ancestor_thread_num, omp_get_team_size,\n+\tomp_get_active_level): New ialias_redirect.\n+\t(omp_set_schedule_, omp_set_schedule_8_,\n+\tomp_get_schedule_, omp_get_schedule_8_, omp_get_thread_limit_,\n+\tomp_set_max_active_levels_, omp_set_max_active_levels_8_,\n+\tomp_get_max_active_levels_, omp_get_level_,\n+\tomp_get_ancestor_thread_num_, omp_get_ancestor_thread_num_8_,\n+\tomp_get_team_size_, omp_get_team_size_8_, omp_get_active_level_):\n+\tNew functions.\n+\t* parallel.c: Include limits.h.\n+\t(gomp_resolve_num_threads): Add count argument.  Rewritten.\n+\t(GOMP_parallel_start): Call gomp_new_team and pass that as last\n+\targument to gomp_team_start.  Pass 0 as second argument to\n+\tgomp_resolve_num_threads.\n+\t(GOMP_parallel_end): Decrease gomp_remaining_threads_count\n+\tif gomp_thread_limit_var != ULONG_MAX.\n+\t(omp_in_parallel): Implement using ts.active_level.\n+\t(omp_get_max_threads): Move to env.c.\n+\t(omp_get_level, omp_get_ancestor_thread_num,\n+\tomp_get_team_size, omp_get_active_level): New functions,\n+\tadd ialias.\n+\t* sections.c (GOMP_sections_start): Call gomp_work_share_init_done\n+\tafter gomp_sections_init.  If HAVE_SYNC_BUILTINS, call\n+\tgomp_iter_dynamic_next instead of the _locked variant and don't take\n+\tlock around it, otherwise acquire it before calling\n+\tgomp_iter_dynamic_next_locked.\n+\t(GOMP_sections_next): If HAVE_SYNC_BUILTINS, call\n+\tgomp_iter_dynamic_next instead of the _locked variant and don't take\n+\tlock around it.\n+\t(GOMP_parallel_sections_start): Call gomp_new_team instead of\n+\tgomp_new_work_share.  Call gomp_sections_init on &team->work_shares[0].\n+\tAdjust gomp_team_start caller.  Pass count as second argument to\n+\tgomp_resolve_num_threads, don't adjust num_threads after the call.\n+\tUse gomp_icv.\n+\t* iter.c (gomp_iter_dynamic_next_locked): Don't multiply\n+\tws->chunk_size by incr.\n+\t(gomp_iter_dynamic_next): Likewise.  If ws->mode, use more efficient\n+\tcode.\n+\t* libgomp_f.h.in (omp_lock_25_arg_t, omp_nest_lock_25_arg_t): New\n+\ttypes.\n+\t(omp_lock_25_arg, omp_nest_lock_25_arg): New macros.\n+\t(omp_check_defines): Check even the compat defines.\n+\t* config/linux/ptrlock.c: New file.\n+\t* config/linux/ptrlock.h: New file.\n+\t* config/linux/wait.h: New file.\n+\t* config/posix/ptrlock.c: New file.\n+\t* config/posix/ptrlock.h: New file.\n+\t* config/linux/bar.h (gomp_team_barrier_wait,\n+\tgomp_team_barrier_wait_end, gomp_team_barrier_wake): New prototypes.\n+\t(gomp_team_barrier_set_task_pending,\n+\tgomp_team_barrier_clear_task_pending,\n+\tgomp_team_barrier_set_waiting_for_tasks,\n+\tgomp_team_barrier_waiting_for_tasks,\n+\tgomp_team_barrier_done): New inlines.\n+\t(gomp_barrier_t): Rewritten.\n+\t(gomp_barrier_state_t): New typedef.\n+\t(gomp_barrier_init, gomp_barrier_reinit, gomp_barrier_destroy,\n+\tgomp_barrier_wait_start): Rewritten.\n+\t(gomp_barrier_wait_end): Change second argument to\n+\tgomp_barrier_state_t.\n+\t(gomp_barrier_last_thread, gomp_barrier_wait_last): New static\n+\tinlines.\n+\t* config/linux/bar.c: Include wait.h instead of libgomp.h and\n+\tfutex.h.\n+\t(gomp_barrier_wait_end): Rewritten.\n+\t(gomp_team_barrier_wait, gomp_team_barrier_wait_end,\n+\tgomp_team_barrier_wake, gomp_barrier_wait_last): New functions.\n+\t* config/posix/bar.h (gomp_barrier_t): Add generation field.\n+\t(gomp_barrier_state_t): New typedef.\n+\t(gomp_team_barrier_wait,\n+\tgomp_team_barrier_wait_end, gomp_team_barrier_wake): New prototypes.\n+\t(gomp_barrier_wait_start): Or all but low 2 bits from generation\n+\tinto the return value.  Return gomp_barrier_state_t.\n+\t(gomp_team_barrier_set_task_pending,\n+\tgomp_team_barrier_clear_task_pending,\n+\tgomp_team_barrier_set_waiting_for_tasks,\n+\tgomp_team_barrier_waiting_for_tasks,\n+\tgomp_team_barrier_done): New inlines.\n+\t(gomp_barrier_wait_end): Change second argument to\n+\tgomp_barrier_state_t.\n+\t(gomp_barrier_last_thread, gomp_barrier_wait_last): New static\n+\tinlines.\n+\t* config/posix/bar.c (gomp_barrier_init): Clear generation field.\n+\t(gomp_barrier_wait_end): Change second argument to\n+\tgomp_barrier_state_t. \n+\t(gomp_team_barrier_wait, gomp_team_barrier_wait_end,\n+\tgomp_team_barrier_wake): New functions.\n+\t* config/linux/mutex.c: Include wait.h instead of libgomp.h and\n+\tfutex.h.\n+\t(gomp_futex_wake, gomp_futex_wait): New variables.\n+\t(gomp_mutex_lock_slow): Call do_wait instead of futex_wait.\n+\t* config/linux/lock.c: Rewrite to make locks task owned,\n+\tfor backwards compatibility provide the old entrypoints\n+\tif symbol versioning.  Include wait.h instead of libgomp.h and\n+\tfutex.h.\n+\t(gomp_set_nest_lock_25): Call do_wait instead of futex_wait.\n+\t* config/posix95/lock.c: Rewrite to make locks task owned,\n+\tfor backwards compatibility provide the old entrypoints\n+\tif symbol versioning.\n+\t* config/posix/lock.c: Rewrite to make locks task owned,\n+\tfor backwards compatibility provide the old entrypoints\n+\tif symbol versioning.\n+\t* config/linux/proc.c (gomp_init_num_threads): Use gomp_global_icv.\n+\t(get_num_procs, gomp_dynamic_max_threads): Use gomp_icv.\n+\t* config/posix/proc.c, config/mingw32/proc.c: Similarly.\n+\t* config/linux/powerpc/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n+\t(sys_futex0): Return error code.\n+\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n+\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n+\t(cpu_relax, atomic_write_barrier): New static inlines.\n+\t* config/linux/alpha/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n+\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n+\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n+\t(cpu_relax, atomic_write_barrier): New static inlines.\n+\t* config/linux/x86/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n+\t(sys_futex0): Return error code.\n+\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n+\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n+\t(cpu_relax, atomic_write_barrier): New static inlines.\n+\t* config/linux/s390/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n+\t(sys_futex0): Return error code.\n+\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n+\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n+\t(cpu_relax, atomic_write_barrier): New static inlines.\n+\t* config/linux/ia64/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n+\t(sys_futex0): Return error code.\n+\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n+\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n+\t(cpu_relax, atomic_write_barrier): New static inlines.\n+\t* config/linux/sparc/futex.h (FUTEX_WAIT, FUTEX_WAKE): Remove.\n+\t(sys_futex0): Return error code.\n+\t(futex_wake, futex_wait): If ENOSYS was returned, clear\n+\tFUTEX_PRIVATE_FLAG in gomp_futex_wa{ke,it} and retry.\n+\t(cpu_relax, atomic_write_barrier): New static inlines.\n+\t* config/linux/sem.c: Include wait.h instead of libgomp.h and\n+\tfutex.h.\n+\t(gomp_sem_wait_slow): Call do_wait instead of futex_wait.\n+\t* config/linux/affinity.c: Assume HAVE_SYNC_BUILTINS.\n+\t* config/linux/omp-lock.h (omp_lock_25_t, omp_nest_lock_25_t): New\n+\ttypes.\n+\t(omp_nest_lock_t): Change owner into void *, add lock field.\n+\t* config/posix95/omp-lock.h: Include semaphore.h.\n+\t(omp_lock_25_t, omp_nest_lock_25_t): New types.\n+\t(omp_lock_t): Use sem_t instead of mutex if semaphores\n+\taren't broken.\n+\t(omp_nest_lock_t): Likewise.  Change owner to void *.\n+\t* config/posix/omp-lock.h: Include semaphore.h.\n+\t(omp_lock_25_t, omp_nest_lock_25_t): New types.\n+\t(omp_lock_t): Use sem_t instead of mutex if semaphores\n+\taren't broken.\n+\t(omp_nest_lock_t): Likewise.  Add owner field.\n+\n+2008-06-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c/collapse-1.c: New test.\n+\t* testsuite/libgomp.c/collapse-2.c: New test.\n+\t* testsuite/libgomp.c/collapse-3.c: New test.\n+\t* testsuite/libgomp.c/icv-1.c: New test.\n+\t* testsuite/libgomp.c/icv-2.c: New test.\n+\t* testsuite/libgomp.c/lib-2.c: New test.\n+\t* testsuite/libgomp.c/lock-1.c: New test.\n+\t* testsuite/libgomp.c/lock-2.c: New test.\n+\t* testsuite/libgomp.c/lock-3.c: New test.\n+\t* testsuite/libgomp.c/loop-4.c: New test.\n+\t* testsuite/libgomp.c/loop-5.c: New test.\n+\t* testsuite/libgomp.c/loop-6.c: New test.\n+\t* testsuite/libgomp.c/loop-7.c: New test.\n+\t* testsuite/libgomp.c/loop-8.c: New test.\n+\t* testsuite/libgomp.c/loop-9.c: New test.\n+\t* testsuite/libgomp.c/nested-3.c: New test.\n+\t* testsuite/libgomp.c/nestedfn-6.c: New test.\n+\t* testsuite/libgomp.c/sort-1.c: New test.\n+\t* testsuite/libgomp.c/task-1.c: New test.\n+\t* testsuite/libgomp.c/task-2.c: New test.\n+\t* testsuite/libgomp.c/task-3.c: New test.\n+\t* testsuite/libgomp.c/task-4.c: New test.\n+\t* testsuite/libgomp.c++/c++.exp: Add libstdc++-v3 build includes\n+\tto C++ testsuite default compiler options.\n+\t* testsuite/libgomp.c++/collapse-1.C: New test.\n+\t* testsuite/libgomp.c++/collapse-2.C: New test.\n+\t* testsuite/libgomp.c++/ctor-10.C: New test.\n+\t* testsuite/libgomp.c++/for-1.C: New test.\n+\t* testsuite/libgomp.c++/for-2.C: New test.\n+\t* testsuite/libgomp.c++/for-3.C: New test.\n+\t* testsuite/libgomp.c++/for-4.C: New test.\n+\t* testsuite/libgomp.c++/for-5.C: New test.\n+\t* testsuite/libgomp.c++/loop-8.C: New test.\n+\t* testsuite/libgomp.c++/loop-9.C: New test.\n+\t* testsuite/libgomp.c++/loop-10.C: New test.\n+\t* testsuite/libgomp.c++/task-1.C: New test.\n+\t* testsuite/libgomp.c++/task-2.C: New test.\n+\t* testsuite/libgomp.c++/task-3.C: New test.\n+\t* testsuite/libgomp.c++/task-4.C: New test.\n+\t* testsuite/libgomp.c++/task-5.C: New test.\n+\t* testsuite/libgomp.c++/task-6.C: New test.\n+\t* testsuite/libgomp.fortran/allocatable1.f90: New test.\n+\t* testsuite/libgomp.fortran/allocatable2.f90: New test.\n+\t* testsuite/libgomp.fortran/allocatable3.f90: New test.\n+\t* testsuite/libgomp.fortran/allocatable4.f90: New test.\n+\t* testsuite/libgomp.fortran/collapse1.f90: New test.\n+\t* testsuite/libgomp.fortran/collapse2.f90: New test.\n+\t* testsuite/libgomp.fortran/collapse3.f90: New test.\n+\t* testsuite/libgomp.fortran/collapse4.f90: New test.\n+\t* testsuite/libgomp.fortran/lastprivate1.f90: New test.\n+\t* testsuite/libgomp.fortran/lastprivate2.f90: New test.\n+\t* testsuite/libgomp.fortran/lib4.f90: New test.\n+\t* testsuite/libgomp.fortran/lock-1.f90: New test.\n+\t* testsuite/libgomp.fortran/lock-2.f90: New test.\n+\t* testsuite/libgomp.fortran/nested1.f90: New test.\n+\t* testsuite/libgomp.fortran/nestedfn4.f90: New test.\n+\t* testsuite/libgomp.fortran/strassen.f90: New test.\n+\t* testsuite/libgomp.fortran/tabs1.f90: New test.\n+\t* testsuite/libgomp.fortran/tabs2.f: New test.\n+\t* testsuite/libgomp.fortran/task1.f90: New test.\n+\t* testsuite/libgomp.fortran/task2.f90: New test.\n+\t* testsuite/libgomp.fortran/vla4.f90: Add dg-warning.\n+\t* testsuite/libgomp.fortran/vla5.f90: Likewise.\n+\t* testsuite/libgomp.c/pr26943-2.c: Likewise.\n+\t* testsuite/libgomp.c/pr26943-3.c: Likewise.\n+\t* testsuite/libgomp.c/pr26943-4.c: Likewise.\n+\n 2008-05-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/36308"}, {"sha": "996802a913a7a9b5a7eb2617f8ee54aa886b99c1", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -30,8 +30,9 @@ libgomp_version_info = -version-info $(libtool_VERSION)\n libgomp_la_LDFLAGS = $(libgomp_version_info) $(libgomp_version_script)\n \n libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n-\tloop.c ordered.c parallel.c sections.c single.c team.c work.c \\\n-\tlock.c mutex.c proc.c sem.c bar.c time.c fortran.c affinity.c\n+\titer_ull.c loop.c loop_ull.c ordered.c parallel.c sections.c single.c \\\n+\ttask.c team.c work.c lock.c mutex.c proc.c sem.c bar.c ptrlock.c \\\n+\ttime.c fortran.c affinity.c\n \n nodist_noinst_HEADERS = libgomp_f.h\n nodist_libsubinclude_HEADERS = omp.h"}, {"sha": "8e0f546c6dfdffdfe98295010c527aae77dfee3c", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -83,9 +83,10 @@ toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n libgomp_la_LIBADD =\n am_libgomp_la_OBJECTS = alloc.lo barrier.lo critical.lo env.lo \\\n-\terror.lo iter.lo loop.lo ordered.lo parallel.lo sections.lo \\\n-\tsingle.lo team.lo work.lo lock.lo mutex.lo proc.lo sem.lo \\\n-\tbar.lo time.lo fortran.lo affinity.lo\n+\terror.lo iter.lo iter_ull.lo loop.lo loop_ull.lo ordered.lo \\\n+\tparallel.lo sections.lo single.lo task.lo team.lo work.lo \\\n+\tlock.lo mutex.lo proc.lo sem.lo bar.lo ptrlock.lo time.lo \\\n+\tfortran.lo affinity.lo\n libgomp_la_OBJECTS = $(am_libgomp_la_OBJECTS)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I.\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n@@ -193,9 +194,15 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n NM = @NM@\n OBJEXT = @OBJEXT@\n+OMP_LOCK_25_ALIGN = @OMP_LOCK_25_ALIGN@\n+OMP_LOCK_25_KIND = @OMP_LOCK_25_KIND@\n+OMP_LOCK_25_SIZE = @OMP_LOCK_25_SIZE@\n OMP_LOCK_ALIGN = @OMP_LOCK_ALIGN@\n OMP_LOCK_KIND = @OMP_LOCK_KIND@\n OMP_LOCK_SIZE = @OMP_LOCK_SIZE@\n+OMP_NEST_LOCK_25_ALIGN = @OMP_NEST_LOCK_25_ALIGN@\n+OMP_NEST_LOCK_25_KIND = @OMP_NEST_LOCK_25_KIND@\n+OMP_NEST_LOCK_25_SIZE = @OMP_NEST_LOCK_25_SIZE@\n OMP_NEST_LOCK_ALIGN = @OMP_NEST_LOCK_ALIGN@\n OMP_NEST_LOCK_KIND = @OMP_NEST_LOCK_KIND@\n OMP_NEST_LOCK_SIZE = @OMP_NEST_LOCK_SIZE@\n@@ -289,8 +296,9 @@ nodist_toolexeclib_HEADERS = libgomp.spec\n libgomp_version_info = -version-info $(libtool_VERSION)\n libgomp_la_LDFLAGS = $(libgomp_version_info) $(libgomp_version_script)\n libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n-\tloop.c ordered.c parallel.c sections.c single.c team.c work.c \\\n-\tlock.c mutex.c proc.c sem.c bar.c time.c fortran.c affinity.c\n+\titer_ull.c loop.c loop_ull.c ordered.c parallel.c sections.c single.c \\\n+\ttask.c team.c work.c lock.c mutex.c proc.c sem.c bar.c ptrlock.c \\\n+\ttime.c fortran.c affinity.c\n \n nodist_noinst_HEADERS = libgomp_f.h\n nodist_libsubinclude_HEADERS = omp.h\n@@ -426,15 +434,19 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fortran.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iter_ull.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loop.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/loop_ull.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mutex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ordered.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parallel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ptrlock.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sections.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sem.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/single.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/task.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/team.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/time.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/work.Plo@am__quote@"}, {"sha": "24037aba17b7864bb6baf9e28a68ece0fc58e5b5", "filename": "libgomp/barrier.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fbarrier.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fbarrier.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fbarrier.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -40,5 +40,5 @@ GOMP_barrier (void)\n   if (team == NULL)\n     return;\n \n-  gomp_barrier_wait (&team->barrier);\n+  gomp_team_barrier_wait (&team->barrier);\n }"}, {"sha": "88a616ca1eddd783835de1718102de2c2d7bf2a5", "filename": "libgomp/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -69,6 +69,9 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define to 1 if GNU symbol versioning is used for libgomp. */\n+#undef LIBGOMP_GNU_SYMBOL_VERSIONING\n+\n /* Define to the sub-directory in which libtool stores uninstalled libraries.\n    */\n #undef LT_OBJDIR"}, {"sha": "7b6d6c008d7b477065d488801eb0052a2b785822", "filename": "libgomp/config/linux/affinity.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Faffinity.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -38,9 +38,6 @@\n #ifdef HAVE_PTHREAD_AFFINITY_NP\n \n static unsigned int affinity_counter;\n-#ifndef HAVE_SYNC_BUILTINS\n-static gomp_mutex_t affinity_lock;\n-#endif\n \n void\n gomp_init_affinity (void)\n@@ -76,9 +73,6 @@ gomp_init_affinity (void)\n   CPU_SET (gomp_cpu_affinity[0], &cpuset);\n   pthread_setaffinity_np (pthread_self (), sizeof (cpuset), &cpuset);\n   affinity_counter = 1;\n-#ifndef HAVE_SYNC_BUILTINS\n-  gomp_mutex_init (&affinity_lock);\n-#endif\n }\n \n void\n@@ -87,13 +81,7 @@ gomp_init_thread_affinity (pthread_attr_t *attr)\n   unsigned int cpu;\n   cpu_set_t cpuset;\n \n-#ifdef HAVE_SYNC_BUILTINS\n   cpu = __sync_fetch_and_add (&affinity_counter, 1);\n-#else\n-  gomp_mutex_lock (&affinity_lock);\n-  cpu = affinity_counter++;\n-  gomp_mutex_unlock (&affinity_lock);\n-#endif\n   cpu %= gomp_cpu_affinity_len;\n   CPU_ZERO (&cpuset);\n   CPU_SET (gomp_cpu_affinity[cpu], &cpuset);"}, {"sha": "4f0bda2424c07886b554992aa8ed203d9acd8bc4", "filename": "libgomp/config/linux/alpha/futex.h", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Falpha%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Falpha%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Falpha%2Ffutex.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -30,8 +30,6 @@\n #ifndef SYS_futex\n #define SYS_futex               394\n #endif\n-#define FUTEX_WAIT              0\n-#define FUTEX_WAKE              1\n \n \n static inline void\n@@ -45,14 +43,28 @@ futex_wait (int *addr, int val)\n \n   sc_0 = SYS_futex;\n   sc_16 = (long) addr;\n-  sc_17 = FUTEX_WAIT;\n+  sc_17 = gomp_futex_wait;\n   sc_18 = val;\n   sc_19 = 0;\n   __asm volatile (\"callsys\"\n \t\t  : \"=r\" (sc_0), \"=r\"(sc_19)\n \t\t  : \"0\"(sc_0), \"r\" (sc_16), \"r\"(sc_17), \"r\"(sc_18), \"1\"(sc_19)\n \t\t  : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n \t\t    \"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+  if (__builtin_expect (sc_19, 0) && sc_0 == ENOSYS)\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sc_0 = SYS_futex;\n+      sc_17 &= ~FUTEX_PRIVATE_FLAG;\n+      sc_19 = 0;\n+      __asm volatile (\"callsys\"\n+\t\t      : \"=r\" (sc_0), \"=r\"(sc_19)\n+\t\t      : \"0\"(sc_0), \"r\" (sc_16), \"r\"(sc_17), \"r\"(sc_18),\n+\t\t\t\"1\"(sc_19)\n+\t\t      : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t\t\"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+    }\n }\n \n static inline void\n@@ -66,11 +78,35 @@ futex_wake (int *addr, int count)\n \n   sc_0 = SYS_futex;\n   sc_16 = (long) addr;\n-  sc_17 = FUTEX_WAKE;\n+  sc_17 = gomp_futex_wake;\n   sc_18 = count;\n   __asm volatile (\"callsys\"\n \t\t  : \"=r\" (sc_0), \"=r\"(sc_19)\n \t\t  : \"0\"(sc_0), \"r\" (sc_16), \"r\"(sc_17), \"r\"(sc_18)\n \t\t  : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n \t\t    \"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+  if (__builtin_expect (sc_19, 0) && sc_0 == ENOSYS)\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sc_0 = SYS_futex;\n+      sc_17 &= ~FUTEX_PRIVATE_FLAG;\n+      __asm volatile (\"callsys\"\n+\t\t      : \"=r\" (sc_0), \"=r\"(sc_19)\n+\t\t      : \"0\"(sc_0), \"r\" (sc_16), \"r\"(sc_17), \"r\"(sc_18)\n+\t\t      : \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t\t\"$22\", \"$23\", \"$24\", \"$25\", \"$27\", \"$28\", \"memory\");\n+    }\n+}\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"\" : : : \"memory\");\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+  __asm volatile (\"wmb\" : : : \"memory\");\n }"}, {"sha": "7af36d2c42180408aa7e180f31c413da9660d249", "filename": "libgomp/config/linux/bar.c", "status": "modified", "additions": 76, "deletions": 15, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fbar.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -29,36 +29,97 @@\n    mechanism for libgomp.  This type is private to the library.  This \n    implementation uses atomic instructions and the futex syscall.  */\n \n-#include \"libgomp.h\"\n-#include \"futex.h\"\n #include <limits.h>\n+#include \"wait.h\"\n \n \n void\n-gomp_barrier_wait_end (gomp_barrier_t *bar, bool last)\n+gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n-  if (last)\n+  if (__builtin_expect ((state & 1) != 0, 0))\n     {\n-      bar->generation++;\n-      futex_wake (&bar->generation, INT_MAX);\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      bar->awaited = bar->total;\n+      atomic_write_barrier ();\n+      bar->generation += 4;\n+      futex_wake ((int *) &bar->generation, INT_MAX);\n     }\n   else\n     {\n-      unsigned int generation = bar->generation;\n-\n-      gomp_mutex_unlock (&bar->mutex);\n+      unsigned int generation = state;\n \n       do\n-\tfutex_wait (&bar->generation, generation);\n+\tdo_wait ((int *) &bar->generation, generation);\n       while (bar->generation == generation);\n     }\n+}\n+\n+void\n+gomp_barrier_wait (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n+}\n \n-  if (__sync_add_and_fetch (&bar->arrived, -1) == 0)\n-    gomp_mutex_unlock (&bar->mutex);\n+/* Like gomp_barrier_wait, except that if the encountering thread\n+   is not the last one to hit the barrier, it returns immediately.\n+   The intended usage is that a thread which intends to gomp_barrier_destroy\n+   this barrier calls gomp_barrier_wait, while all other threads\n+   call gomp_barrier_wait_last.  When gomp_barrier_wait returns,\n+   the barrier can be safely destroyed.  */\n+\n+void\n+gomp_barrier_wait_last (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_state_t state = gomp_barrier_wait_start (bar);\n+  if (state & 1)\n+    gomp_barrier_wait_end (bar, state);\n+}\n+\n+void\n+gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n+{\n+  futex_wake ((int *) &bar->generation, count == 0 ? INT_MAX : count);\n+}\n+\n+void\n+gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  unsigned int generation;\n+\n+  if (__builtin_expect ((state & 1) != 0, 0))\n+    {\n+      /* Next time we'll be awaiting TOTAL threads again.  */\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+      bar->awaited = bar->total;\n+      atomic_write_barrier ();\n+      if (__builtin_expect (team->task_count, 0))\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  state &= ~1;\n+\t}\n+      else\n+\t{\n+\t  bar->generation = state + 3;\n+\t  futex_wake ((int *) &bar->generation, INT_MAX);\n+\t  return;\n+\t}\n+    }\n+\n+  generation = state;\n+  do\n+    {\n+      do_wait ((int *) &bar->generation, generation);\n+      if (__builtin_expect (bar->generation & 1, 0))\n+\tgomp_barrier_handle_tasks (state);\n+      if ((bar->generation & 2))\n+\tgeneration |= 2;\n+    }\n+  while (bar->generation != state + 4);\n }\n \n void\n-gomp_barrier_wait (gomp_barrier_t *barrier)\n+gomp_team_barrier_wait (gomp_barrier_t *bar)\n {\n-  gomp_barrier_wait_end (barrier, gomp_barrier_wait_start (barrier));\n+  gomp_team_barrier_wait_end (bar, gomp_barrier_wait_start (bar));\n }"}, {"sha": "85150caf18996ff0bfd4911dbd650f86d373e175", "filename": "libgomp/config/linux/bar.h", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fbar.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -36,40 +36,86 @@\n \n typedef struct\n {\n-  gomp_mutex_t mutex;\n-  unsigned total;\n-  unsigned arrived;\n-  int generation;\n+  /* Make sure total/generation is in a mostly read cacheline, while\n+     awaited in a separate cacheline.  */\n+  unsigned total __attribute__((aligned (64)));\n+  unsigned generation;\n+  unsigned awaited __attribute__((aligned (64)));\n } gomp_barrier_t;\n+typedef unsigned int gomp_barrier_state_t;\n \n static inline void gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n {\n-  gomp_mutex_init (&bar->mutex);\n   bar->total = count;\n-  bar->arrived = 0;\n+  bar->awaited = count;\n   bar->generation = 0;\n }\n \n static inline void gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)\n {\n-  gomp_mutex_lock (&bar->mutex);\n+  __sync_fetch_and_add (&bar->awaited, count - bar->total);\n   bar->total = count;\n-  gomp_mutex_unlock (&bar->mutex);\n }\n \n static inline void gomp_barrier_destroy (gomp_barrier_t *bar)\n {\n-  /* Before destroying, make sure all threads have left the barrier.  */\n-  gomp_mutex_lock (&bar->mutex);\n }\n \n extern void gomp_barrier_wait (gomp_barrier_t *);\n-extern void gomp_barrier_wait_end (gomp_barrier_t *, bool);\n+extern void gomp_barrier_wait_last (gomp_barrier_t *);\n+extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);\n+extern void gomp_team_barrier_wait (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_end (gomp_barrier_t *,\n+\t\t\t\t\tgomp_barrier_state_t);\n+extern void gomp_team_barrier_wake (gomp_barrier_t *, int);\n \n-static inline bool gomp_barrier_wait_start (gomp_barrier_t *bar)\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_start (gomp_barrier_t *bar)\n {\n-  gomp_mutex_lock (&bar->mutex);\n-  return ++bar->arrived == bar->total;\n+  unsigned int ret = bar->generation & ~3;\n+  /* Do we need any barrier here or is __sync_add_and_fetch acting\n+     as the needed LoadLoad barrier already?  */\n+  ret += __sync_add_and_fetch (&bar->awaited, -1) == 0;\n+  return ret;\n+}\n+\n+static inline bool\n+gomp_barrier_last_thread (gomp_barrier_state_t state)\n+{\n+  return state & 1;\n+}\n+\n+/* All the inlines below must be called with team->task_lock\n+   held.  */\n+\n+static inline void\n+gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation |= 1;\n+}\n+\n+static inline void\n+gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation &= ~1;\n+}\n+\n+static inline void\n+gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  bar->generation |= 2;\n+}\n+\n+static inline bool\n+gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  return (bar->generation & 2) != 0;\n+}\n+\n+static inline void\n+gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  bar->generation = (state & ~3) + 4;\n }\n \n #endif /* GOMP_BARRIER_H */"}, {"sha": "35aa4f1fea0f4b1ceb2fad7d5122b6fe48def998", "filename": "libgomp/config/linux/ia64/futex.h", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fia64%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fia64%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fia64%2Ffutex.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -29,23 +29,24 @@\n \n #include <sys/syscall.h>\n \n-#define FUTEX_WAIT\t0\n-#define FUTEX_WAKE\t1\n \n \n-static inline void\n-sys_futex0(int *addr, int op, int val)\n+static inline long\n+sys_futex0(int *addr, long op, int val)\n {\n   register long out0 asm (\"out0\") = (long) addr;\n   register long out1 asm (\"out1\") = op;\n   register long out2 asm (\"out2\") = val;\n   register long out3 asm (\"out3\") = 0;\n+  register long r8 asm (\"r8\");\n+  register long r10 asm (\"r10\");\n   register long r15 asm (\"r15\") = SYS_futex;\n \n   __asm __volatile (\"break 0x100000\"\n-\t: \"=r\"(r15), \"=r\"(out0), \"=r\"(out1), \"=r\"(out2), \"=r\"(out3)\n+\t: \"=r\"(r15), \"=r\"(out0), \"=r\"(out1), \"=r\"(out2), \"=r\"(out3),\n+\t  \"=r\"(r8), \"=r\"(r10)\n \t: \"r\"(r15), \"r\"(out0), \"r\"(out1), \"r\"(out2), \"r\"(out3)\n-        : \"memory\", \"r8\", \"r10\", \"out4\", \"out5\", \"out6\", \"out7\",\n+\t: \"memory\", \"out4\", \"out5\", \"out6\", \"out7\",\n \t  /* Non-stacked integer registers, minus r8, r10, r15.  */\n \t  \"r2\", \"r3\", \"r9\", \"r11\", \"r12\", \"r13\", \"r14\", \"r16\", \"r17\", \"r18\",\n \t  \"r19\", \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\",\n@@ -56,16 +57,41 @@ sys_futex0(int *addr, int op, int val)\n \t  \"f6\", \"f7\", \"f8\", \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\n \t  /* Branch registers.  */\n \t  \"b6\");\n+  return r8 & r10;\n }\n \n static inline void\n futex_wait (int *addr, int val)\n {\n-  sys_futex0 (addr, FUTEX_WAIT, val);\n+  long err = sys_futex0 (addr, gomp_futex_wait, val);\n+  if (__builtin_expect (err == ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wait, val);\n+    }\n }\n \n static inline void\n futex_wake (int *addr, int count)\n {\n-  sys_futex0 (addr, FUTEX_WAKE, count);\n+  long err = sys_futex0 (addr, gomp_futex_wake, count);\n+  if (__builtin_expect (err == ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wake, count);\n+    }\n+}\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"hint @pause\" : : : \"memory\");\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+  __sync_synchronize ();\n }"}, {"sha": "a2e07d320fd5bf44a890f9963234f55b723ef4fc", "filename": "libgomp/config/linux/lock.c", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Flock.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -29,47 +29,109 @@\n    primitives.  This implementation uses atomic instructions and the futex\n    syscall.  */\n \n-#include \"libgomp.h\"\n #include <string.h>\n #include <unistd.h>\n #include <sys/syscall.h>\n-#include \"futex.h\"\n+#include \"wait.h\"\n \n \n /* The internal gomp_mutex_t and the external non-recursive omp_lock_t\n    have the same form.  Re-use it.  */\n \n void\n-omp_init_lock (omp_lock_t *lock)\n+gomp_init_lock_30 (omp_lock_t *lock)\n {\n   gomp_mutex_init (lock);\n }\n \n void\n-omp_destroy_lock (omp_lock_t *lock)\n+gomp_destroy_lock_30 (omp_lock_t *lock)\n {\n   gomp_mutex_destroy (lock);\n }\n \n void\n-omp_set_lock (omp_lock_t *lock)\n+gomp_set_lock_30 (omp_lock_t *lock)\n {\n   gomp_mutex_lock (lock);\n }\n \n void\n-omp_unset_lock (omp_lock_t *lock)\n+gomp_unset_lock_30 (omp_lock_t *lock)\n {\n   gomp_mutex_unlock (lock);\n }\n \n int\n-omp_test_lock (omp_lock_t *lock)\n+gomp_test_lock_30 (omp_lock_t *lock)\n {\n   return __sync_bool_compare_and_swap (lock, 0, 1);\n }\n \n-/* The external recursive omp_nest_lock_t form requires additional work.  */\n+void\n+gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  memset (lock, '\\0', sizeof (*lock));\n+}\n+\n+void\n+gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+}\n+\n+void\n+gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      gomp_mutex_lock (&lock->lock);\n+      lock->owner = me;\n+    }\n+\n+  lock->count++;\n+}\n+\n+void\n+gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  if (--lock->count == 0)\n+    {\n+      lock->owner = NULL;\n+      gomp_mutex_unlock (&lock->lock);\n+    }\n+}\n+\n+int\n+gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner == me)\n+    return ++lock->count;\n+\n+  if (__sync_bool_compare_and_swap (&lock->lock, 0, 1))\n+    {\n+      lock->owner = me;\n+      lock->count = 1;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+#ifdef LIBGOMP_GNU_SYMBOL_VERSIONING\n+/* gomp_mutex_* can be safely locked in one thread and\n+   unlocked in another thread, so the OpenMP 2.5 and OpenMP 3.0\n+   non-nested locks can be the same.  */\n+strong_alias (gomp_init_lock_30, gomp_init_lock_25)\n+strong_alias (gomp_destroy_lock_30, gomp_destroy_lock_25)\n+strong_alias (gomp_set_lock_30, gomp_set_lock_25)\n+strong_alias (gomp_unset_lock_30, gomp_unset_lock_25)\n+strong_alias (gomp_test_lock_30, gomp_test_lock_25)\n+\n+/* The external recursive omp_nest_lock_25_t form requires additional work.  */\n \n /* We need an integer to uniquely identify this thread.  Most generally\n    this is the thread's TID, which ideally we'd get this straight from\n@@ -85,17 +147,17 @@ omp_test_lock (omp_lock_t *lock)\n    always available directly.  Make do with the gomp_thread pointer\n    since it's handy.  */\n \n-#if !defined (HAVE_TLS)\n+# if !defined (HAVE_TLS)\n static inline int gomp_tid (void)\n {\n   return syscall (SYS_gettid);\n }\n-#elif !defined(__LP64__)\n+# elif !defined(__LP64__)\n static inline int gomp_tid (void)\n {\n   return (int) gomp_thread ();\n }\n-#else\n+# else\n static __thread int tid_cache;\n static inline int gomp_tid (void)\n {\n@@ -104,22 +166,22 @@ static inline int gomp_tid (void)\n     tid_cache = tid = syscall (SYS_gettid);\n   return tid;\n }\n-#endif\n+# endif\n \n \n void\n-omp_init_nest_lock (omp_nest_lock_t *lock)\n+gomp_init_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   memset (lock, 0, sizeof (lock));\n }\n \n void\n-omp_destroy_nest_lock (omp_nest_lock_t *lock)\n+gomp_destroy_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n }\n \n void\n-omp_set_nest_lock (omp_nest_lock_t *lock)\n+gomp_set_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   int otid, tid = gomp_tid ();\n \n@@ -137,12 +199,12 @@ omp_set_nest_lock (omp_nest_lock_t *lock)\n \t  return;\n \t}\n \n-      futex_wait (&lock->owner, otid);\n+      do_wait (&lock->owner, otid);\n     }\n }\n \n void\n-omp_unset_nest_lock (omp_nest_lock_t *lock)\n+gomp_unset_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   /* ??? Validate that we own the lock here.  */\n \n@@ -154,7 +216,7 @@ omp_unset_nest_lock (omp_nest_lock_t *lock)\n }\n \n int\n-omp_test_nest_lock (omp_nest_lock_t *lock)\n+gomp_test_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   int otid, tid = gomp_tid ();\n \n@@ -170,6 +232,19 @@ omp_test_nest_lock (omp_nest_lock_t *lock)\n   return 0;\n }\n \n+omp_lock_symver (omp_init_lock)\n+omp_lock_symver (omp_destroy_lock)\n+omp_lock_symver (omp_set_lock)\n+omp_lock_symver (omp_unset_lock)\n+omp_lock_symver (omp_test_lock)\n+omp_lock_symver (omp_init_nest_lock)\n+omp_lock_symver (omp_destroy_nest_lock)\n+omp_lock_symver (omp_set_nest_lock)\n+omp_lock_symver (omp_unset_nest_lock)\n+omp_lock_symver (omp_test_nest_lock)\n+\n+#else\n+\n ialias (omp_init_lock)\n ialias (omp_init_nest_lock)\n ialias (omp_destroy_lock)\n@@ -180,3 +255,5 @@ ialias (omp_unset_lock)\n ialias (omp_unset_nest_lock)\n ialias (omp_test_lock)\n ialias (omp_test_nest_lock)\n+\n+#endif"}, {"sha": "36c362eb27464b5dadb71520e308c94ff22699ea", "filename": "libgomp/config/linux/mutex.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fmutex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fmutex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fmutex.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -29,9 +29,10 @@\n    mechanism for libgomp.  This type is private to the library.  This\n    implementation uses atomic instructions and the futex syscall.  */\n \n-#include \"libgomp.h\"\n-#include \"futex.h\"\n+#include \"wait.h\"\n \n+long int gomp_futex_wake = FUTEX_WAKE | FUTEX_PRIVATE_FLAG;\n+long int gomp_futex_wait = FUTEX_WAIT | FUTEX_PRIVATE_FLAG;\n \n void\n gomp_mutex_lock_slow (gomp_mutex_t *mutex)\n@@ -40,7 +41,7 @@ gomp_mutex_lock_slow (gomp_mutex_t *mutex)\n     {\n       int oldval = __sync_val_compare_and_swap (mutex, 1, 2);\n       if (oldval != 0)\n-        futex_wait (mutex, 2);\n+\tdo_wait (mutex, 2);\n     }\n   while (!__sync_bool_compare_and_swap (mutex, 0, 2));\n }"}, {"sha": "e65aff7fce74145647e575a3deb1a7d86784416a", "filename": "libgomp/config/linux/omp-lock.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fomp-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fomp-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fomp-lock.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -3,8 +3,10 @@\n    structures without polluting the namespace.\n \n    When using the Linux futex primitive, non-recursive locks require\n-   only one int.  Recursive locks require we identify the owning thread\n-   and so require two ints.  */\n+   only one int.  Recursive locks require we identify the owning task\n+   and so require one int and a pointer.  */\n \n typedef int omp_lock_t;\n-typedef struct { int owner, count; } omp_nest_lock_t;\n+typedef struct { int lock, count; void *owner; } omp_nest_lock_t;\n+typedef int omp_lock_25_t;\n+typedef struct { int owner, count; } omp_nest_lock_25_t;"}, {"sha": "c1e0d0f5651901720bb84cf973f391df761a0ce8", "filename": "libgomp/config/linux/powerpc/futex.h", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fpowerpc%2Ffutex.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -28,10 +28,8 @@\n /* Provide target-specific access to the futex system call.  */\n \n #include <sys/syscall.h>\n-#define FUTEX_WAIT\t0\n-#define FUTEX_WAKE\t1\n \n-static inline void\n+static inline long\n sys_futex0 (int *addr, int op, int val)\n {\n   register long int r0  __asm__ (\"r0\");\n@@ -50,21 +48,48 @@ sys_futex0 (int *addr, int op, int val)\n      doesn't.  It doesn't much matter for us.  In the interest of unity,\n      go ahead and clobber it always.  */\n \n-  __asm volatile (\"sc\"\n+  __asm volatile (\"sc; mfcr %0\"\n \t\t  : \"=r\"(r0), \"=r\"(r3), \"=r\"(r4), \"=r\"(r5), \"=r\"(r6)\n \t\t  : \"r\"(r0), \"r\"(r3), \"r\"(r4), \"r\"(r5), \"r\"(r6)\n \t\t  : \"r7\", \"r8\", \"r9\", \"r10\", \"r11\", \"r12\",\n \t\t    \"cr0\", \"ctr\", \"memory\");\n+  if (__builtin_expect (r0 & (1 << 28), 0))\n+    return r3;\n+  return 0;\n }\n \n static inline void\n futex_wait (int *addr, int val)\n {\n-  sys_futex0 (addr, FUTEX_WAIT, val);\n+  long err = sys_futex0 (addr, gomp_futex_wait, val);\n+  if (__builtin_expect (err == ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wait, val);\n+    }\n }\n \n static inline void\n futex_wake (int *addr, int count)\n {\n-  sys_futex0 (addr, FUTEX_WAKE, count);\n+  long err = sys_futex0 (addr, gomp_futex_wake, count);\n+  if (__builtin_expect (err == ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wake, count);\n+    }\n+}\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"\" : : : \"memory\");\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+  __asm volatile (\"eieio\" : : : \"memory\");\n }"}, {"sha": "6a006f24aa3e79da0cd3c52007efe22bda9f1fff", "filename": "libgomp/config/linux/proc.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fproc.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -78,14 +78,14 @@ gomp_init_num_threads (void)\n   if (pthread_getaffinity_np (pthread_self (), sizeof (cpuset), &cpuset) == 0)\n     {\n       /* Count only the CPUs this process can use.  */\n-      gomp_nthreads_var = cpuset_popcount (&cpuset);\n-      if (gomp_nthreads_var == 0)\n-\tgomp_nthreads_var = 1;\n+      gomp_global_icv.nthreads_var = cpuset_popcount (&cpuset);\n+      if (gomp_global_icv.nthreads_var == 0)\n+\tgomp_global_icv.nthreads_var = 1;\n       return;\n     }\n #endif\n #ifdef _SC_NPROCESSORS_ONLN\n-  gomp_nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n+  gomp_global_icv.nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n #endif\n }\n \n@@ -132,7 +132,7 @@ get_num_procs (void)\n #ifdef _SC_NPROCESSORS_ONLN\n   return sysconf (_SC_NPROCESSORS_ONLN);\n #else\n-  return gomp_nthreads_var;\n+  return gomp_icv (false)->nthreads_var;\n #endif\n }\n \n@@ -146,11 +146,11 @@ get_num_procs (void)\n unsigned\n gomp_dynamic_max_threads (void)\n {\n-  unsigned n_onln, loadavg;\n+  unsigned n_onln, loadavg, nthreads_var = gomp_icv (false)->nthreads_var;\n \n   n_onln = get_num_procs ();\n-  if (n_onln > gomp_nthreads_var)\n-    n_onln = gomp_nthreads_var;\n+  if (n_onln > nthreads_var)\n+    n_onln = nthreads_var;\n \n   loadavg = 0;\n #ifdef HAVE_GETLOADAVG"}, {"sha": "8faa1b2287d1c465fcb12f8b6ac5c368927cb327", "filename": "libgomp/config/linux/ptrlock.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fptrlock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fptrlock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fptrlock.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,70 @@\n+/* Copyright (C) 2008 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#include <endian.h>\n+#include <limits.h>\n+#include \"wait.h\"\n+\n+void *\n+gomp_ptrlock_get_slow (gomp_ptrlock_t *ptrlock)\n+{\n+  int *intptr;\n+  __sync_bool_compare_and_swap (ptrlock, 1, 2);\n+\n+  /* futex works on ints, not pointers.\n+     But a valid work share pointer will be at least\n+     8 byte aligned, so it is safe to assume the low\n+     32-bits of the pointer won't contain values 1 or 2.  */\n+  __asm volatile (\"\" : \"=r\" (intptr) : \"0\" (ptrlock));\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+  if (sizeof (*ptrlock) > sizeof (int))\n+    intptr += (sizeof (*ptrlock) / sizeof (int)) - 1;\n+#endif\n+  do\n+    do_wait (intptr, 2);\n+  while (*intptr == 2);\n+  __asm volatile (\"\" : : : \"memory\");\n+  return *ptrlock;\n+}\n+\n+void\n+gomp_ptrlock_set_slow (gomp_ptrlock_t *ptrlock, void *ptr)\n+{\n+  int *intptr;\n+\n+  *ptrlock = ptr;\n+  __asm volatile (\"\" : \"=r\" (intptr) : \"0\" (ptrlock));\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+  if (sizeof (*ptrlock) > sizeof (int))\n+    intptr += (sizeof (*ptrlock) / sizeof (int)) - 1;\n+#endif\n+  futex_wake (intptr, INT_MAX);\n+}"}, {"sha": "bb5441676a475044ea4c5d8c75de1d1a1789a826", "filename": "libgomp/config/linux/ptrlock.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fptrlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fptrlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fptrlock.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,65 @@\n+/* Copyright (C) 2008 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#ifndef GOMP_PTRLOCK_H\n+#define GOMP_PTRLOCK_H 1\n+\n+typedef void *gomp_ptrlock_t;\n+\n+static inline void gomp_ptrlock_init (gomp_ptrlock_t *ptrlock, void *ptr)\n+{\n+  *ptrlock = ptr;\n+}\n+\n+extern void *gomp_ptrlock_get_slow (gomp_ptrlock_t *ptrlock);\n+static inline void *gomp_ptrlock_get (gomp_ptrlock_t *ptrlock)\n+{\n+  if ((uintptr_t) *ptrlock > 2)\n+    return *ptrlock;\n+\n+  if (__sync_bool_compare_and_swap (ptrlock, NULL, (uintptr_t) 1))\n+    return NULL;\n+\n+  return gomp_ptrlock_get_slow (ptrlock);\n+}\n+\n+extern void gomp_ptrlock_set_slow (gomp_ptrlock_t *ptrlock, void *ptr);\n+static inline void gomp_ptrlock_set (gomp_ptrlock_t *ptrlock, void *ptr)\n+{\n+  if (!__sync_bool_compare_and_swap (ptrlock, (uintptr_t) 1, ptr))\n+    gomp_ptrlock_set_slow (ptrlock, ptr);\n+}\n+\n+static inline void gomp_ptrlock_destroy (gomp_ptrlock_t *ptrlock)\n+{\n+}\n+\n+#endif /* GOMP_PTRLOCK_H */"}, {"sha": "3c4e1fc5d2571243fcf337aa4e4b494b48251306", "filename": "libgomp/config/linux/s390/futex.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fs390%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fs390%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fs390%2Ffutex.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -28,10 +28,8 @@\n /* Provide target-specific access to the futex system call.  */\n \n #include <sys/syscall.h>\n-#define FUTEX_WAIT\t0\n-#define FUTEX_WAKE\t1\n \n-static inline void\n+static inline long\n sys_futex0 (int *addr, int op, int val)\n {\n   register long int gpr2  __asm__ (\"2\");\n@@ -49,16 +47,41 @@ sys_futex0 (int *addr, int op, int val)\n \t\t  : \"i\" (SYS_futex),\n \t\t    \"0\" (gpr2), \"d\" (gpr3), \"d\" (gpr4), \"d\" (gpr5)\n \t\t  : \"memory\");\n+  return gpr2;\n }\n \n static inline void\n futex_wait (int *addr, int val)\n {\n-  sys_futex0 (addr, FUTEX_WAIT, val);\n+  long err = sys_futex0 (addr, gomp_futex_wait, val);\n+  if (__builtin_expect (err == -ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wait, val);\n+    }\n }\n \n static inline void\n futex_wake (int *addr, int count)\n {\n-  sys_futex0 (addr, FUTEX_WAKE, count);\n+  long err = sys_futex0 (addr, gomp_futex_wake, count);\n+  if (__builtin_expect (err == -ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wake, count);\n+    }\n+}\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"\" : : : \"memory\");\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+  __sync_synchronize ();\n }"}, {"sha": "5615bc580eeb35078ec71785718ace8f7e91a0b8", "filename": "libgomp/config/linux/sem.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fsem.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -29,8 +29,7 @@\n    mechanism for libgomp.  This type is private to the library.  This \n    implementation uses atomic instructions and the futex syscall.  */\n \n-#include \"libgomp.h\"\n-#include \"futex.h\"\n+#include \"wait.h\"\n \n \n void\n@@ -44,7 +43,7 @@ gomp_sem_wait_slow (gomp_sem_t *sem)\n \t  if (__sync_bool_compare_and_swap (sem, val, val - 1))\n \t    return;\n \t}\n-      futex_wait (sem, -1);\n+      do_wait (sem, -1);\n     }\n }\n "}, {"sha": "b9bc387355fb357df0dd565b40d632e6cddcd0a5", "filename": "libgomp/config/linux/sparc/futex.h", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fsparc%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fsparc%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fsparc%2Ffutex.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -28,10 +28,8 @@\n /* Provide target-specific access to the futex system call.  */\n \n #include <sys/syscall.h>\n-#define FUTEX_WAIT\t0\n-#define FUTEX_WAKE\t1\n \n-static inline void\n+static inline long\n sys_futex0 (int *addr, int op, int val)\n {\n   register long int g1  __asm__ (\"g1\");\n@@ -47,9 +45,9 @@ sys_futex0 (int *addr, int op, int val)\n   o3 = 0;\n \n #ifdef __arch64__\n-# define SYSCALL_STRING \"ta\\t0x6d\"\n+# define SYSCALL_STRING \"ta\\t0x6d; bcs,a,pt %%xcc, 1f; sub %%g0, %%o0, %%o0; 1:\"\n #else\n-# define SYSCALL_STRING \"ta\\t0x10\"\n+# define SYSCALL_STRING \"ta\\t0x10; bcs,a 1f; sub %%g0, %%o0, %%o0; 1:\"\n #endif\n \n   __asm volatile (SYSCALL_STRING\n@@ -65,16 +63,49 @@ sys_futex0 (int *addr, int op, int val)\n \t\t    \"f48\", \"f50\", \"f52\", \"f54\", \"f56\", \"f58\", \"f60\", \"f62\",\n #endif\n \t\t    \"cc\", \"memory\");\n+  return o0;\n }\n \n static inline void\n futex_wait (int *addr, int val)\n {\n-  sys_futex0 (addr, FUTEX_WAIT, val);\n+  long err = sys_futex0 (addr, gomp_futex_wait, val);\n+  if (__builtin_expect (err == ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wait, val);\n+    }\n }\n \n static inline void\n futex_wake (int *addr, int count)\n {\n-  sys_futex0 (addr, FUTEX_WAKE, count);\n+  long err = sys_futex0 (addr, gomp_futex_wake, count);\n+  if (__builtin_expect (err == ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wake, count);\n+    }\n+}\n+\n+static inline void\n+cpu_relax (void)\n+{\n+#if defined __arch64__ || defined  __sparc_v9__\n+  __asm volatile (\"membar #LoadLoad\" : : : \"memory\");\n+#else\n+  __asm volatile (\"\" : : : \"memory\");\n+#endif\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+#if defined __arch64__ || defined __sparc_v9__\n+  __asm volatile (\"membar #StoreStore\" : : : \"memory\");\n+#else\n+  __sync_synchronize ();\n+#endif\n }"}, {"sha": "21f0ab8756cfbb8a3b3baccd811d884ac458c903", "filename": "libgomp/config/linux/wait.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fwait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fwait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fwait.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,68 @@\n+/* Copyright (C) 2008 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#ifndef GOMP_WAIT_H\n+#define GOMP_WAIT_H 1\n+\n+#include \"libgomp.h\"\n+#include <errno.h>\n+\n+#define FUTEX_WAIT\t0\n+#define FUTEX_WAKE\t1\n+#define FUTEX_PRIVATE_FLAG\t128L\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility push(hidden)\n+#endif\n+\n+extern long int gomp_futex_wait, gomp_futex_wake;\n+\n+#include \"futex.h\"\n+\n+static inline void do_wait (int *addr, int val)\n+{\n+  unsigned long long i, count = gomp_spin_count_var;\n+\n+  if (__builtin_expect (gomp_managed_threads > gomp_available_cpus, 0))\n+    count = gomp_throttled_spin_count_var;\n+  for (i = 0; i < count; i++)\n+    if (__builtin_expect (*addr != val, 0))\n+      return;\n+    else\n+      cpu_relax ();\n+  futex_wait (addr, val);\n+}\n+\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# pragma GCC visibility pop\n+#endif\n+\n+#endif /* GOMP_WAIT_H */"}, {"sha": "36af6aad93b633f07b6dda268afeb01319eb59b2", "filename": "libgomp/config/linux/x86/futex.h", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fx86%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Flinux%2Fx86%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fx86%2Ffutex.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -27,9 +27,6 @@\n \n /* Provide target-specific access to the futex system call.  */\n \n-#define FUTEX_WAIT\t0\n-#define FUTEX_WAKE\t1\n-\n #ifdef __LP64__\n # ifndef SYS_futex\n #  define SYS_futex\t202\n@@ -38,14 +35,26 @@\n static inline void\n futex_wait (int *addr, int val)\n {\n-  register long r10 __asm__(\"%r10\") = 0;\n+  register long r10 __asm__(\"%r10\");\n   long res;\n \n+  r10 = 0;\n   __asm volatile (\"syscall\"\n \t\t  : \"=a\" (res)\n-\t\t  : \"0\"(SYS_futex), \"D\" (addr), \"S\"(FUTEX_WAIT),\n-\t\t    \"d\"(val), \"r\"(r10)\n+\t\t  : \"0\" (SYS_futex), \"D\" (addr), \"S\" (gomp_futex_wait),\n+\t\t    \"d\" (val), \"r\" (r10)\n \t\t  : \"r11\", \"rcx\", \"memory\");\n+  if (__builtin_expect (res == -ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      r10 = 0;\n+      __asm volatile (\"syscall\"\n+\t\t      : \"=a\" (res)\n+\t\t      : \"0\" (SYS_futex), \"D\" (addr), \"S\" (gomp_futex_wait),\n+\t\t\t\"d\" (val), \"r\" (r10)\n+\t\t      : \"r11\", \"rcx\", \"memory\");\n+    }\n }\n \n static inline void\n@@ -55,8 +64,19 @@ futex_wake (int *addr, int count)\n \n   __asm volatile (\"syscall\"\n \t\t  : \"=a\" (res)\n-\t\t  : \"0\"(SYS_futex), \"D\" (addr), \"S\"(FUTEX_WAKE), \"d\"(count)\n+\t\t  : \"0\" (SYS_futex), \"D\" (addr), \"S\" (gomp_futex_wake),\n+\t\t    \"d\" (count)\n \t\t  : \"r11\", \"rcx\", \"memory\");\n+  if (__builtin_expect (res == -ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      __asm volatile (\"syscall\"\n+\t\t      : \"=a\" (res)\n+\t\t      : \"0\" (SYS_futex), \"D\" (addr), \"S\" (gomp_futex_wake),\n+\t\t\t\"d\" (count)\n+\t\t      : \"r11\", \"rcx\", \"memory\");\n+    }\n }\n #else\n # ifndef SYS_futex\n@@ -65,7 +85,7 @@ futex_wake (int *addr, int count)\n \n # ifdef __PIC__\n \n-static inline void\n+static inline long\n sys_futex0 (int *addr, int op, int val)\n {\n   long res;\n@@ -77,11 +97,12 @@ sys_futex0 (int *addr, int op, int val)\n \t\t  : \"0\"(SYS_futex), \"r\" (addr), \"c\"(op),\n \t\t    \"d\"(val), \"S\"(0)\n \t\t  : \"memory\");\n+  return res;\n }\n \n # else\n \n-static inline void\n+static inline long\n sys_futex0 (int *addr, int op, int val)\n {\n   long res;\n@@ -91,20 +112,45 @@ sys_futex0 (int *addr, int op, int val)\n \t\t  : \"0\"(SYS_futex), \"b\" (addr), \"c\"(op),\n \t\t    \"d\"(val), \"S\"(0)\n \t\t  : \"memory\");\n+  return res;\n }\n \n # endif /* __PIC__ */\n \n static inline void\n futex_wait (int *addr, int val)\n {\n-  sys_futex0 (addr, FUTEX_WAIT, val);\n+  long res = sys_futex0 (addr, gomp_futex_wait, val);\n+  if (__builtin_expect (res == -ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wait, val);\n+    }\n }\n \n static inline void\n futex_wake (int *addr, int count)\n {\n-  sys_futex0 (addr, FUTEX_WAKE, count);\n+  long res = sys_futex0 (addr, gomp_futex_wake, count);\n+  if (__builtin_expect (res == -ENOSYS, 0))\n+    {\n+      gomp_futex_wait &= ~FUTEX_PRIVATE_FLAG;\n+      gomp_futex_wake &= ~FUTEX_PRIVATE_FLAG;\n+      sys_futex0 (addr, gomp_futex_wake, count);\n+    }\n }\n \n #endif /* __LP64__ */\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"rep; nop\" : : : \"memory\");\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+  __sync_synchronize ();\n+}"}, {"sha": "4532f45f57232ebdc6a2378cc252f691330c6e48", "filename": "libgomp/config/mingw32/proc.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fmingw32%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fmingw32%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fmingw32%2Fproc.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -35,7 +35,7 @@\n #include <windows.h>\n \n /* Count the CPU's currently available to this process.  */\n-static int\n+static unsigned int\n count_avail_process_cpus ()\n {\n   DWORD_PTR process_cpus;\n@@ -59,7 +59,7 @@ count_avail_process_cpus ()\n void\n gomp_init_num_threads (void)\n {\n-  gomp_nthreads_var = count_avail_process_cpus ();\n+  gomp_global_icv.nthreads_var = count_avail_process_cpus ();\n }\n \n /* When OMP_DYNAMIC is set, at thread launch determine the number of\n@@ -69,8 +69,9 @@ gomp_init_num_threads (void)\n unsigned\n gomp_dynamic_max_threads (void)\n {\n-  int n_onln = count_avail_process_cpus ();\n-  return n_onln > gomp_nthreads_var ? gomp_nthreads_var : n_onln;\n+  unsigned int n_onln = count_avail_process_cpus ();\n+  unsigned int nthreads_var = gomp_icv (false)->nthreads_var;\n+  return n_onln > nthreads_var ? nthreads_var : n_onln;\n }\n \n int"}, {"sha": "ff19e9353a3383bfd1eef9b3fc834923d2076f6a", "filename": "libgomp/config/posix/bar.c", "status": "modified", "additions": 73, "deletions": 3, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fbar.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -44,6 +44,7 @@ gomp_barrier_init (gomp_barrier_t *bar, unsigned count)\n   gomp_sem_init (&bar->sem2, 0);\n   bar->total = count;\n   bar->arrived = 0;\n+  bar->generation = 0;\n }\n \n void\n@@ -70,11 +71,11 @@ gomp_barrier_reinit (gomp_barrier_t *bar, unsigned count)\n }\n \n void\n-gomp_barrier_wait_end (gomp_barrier_t *bar, bool last)\n+gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n {\n   unsigned int n;\n \n-  if (last)\n+  if (state & 1)\n     {\n       n = --bar->arrived;\n       if (n > 0)\n@@ -109,3 +110,72 @@ gomp_barrier_wait (gomp_barrier_t *barrier)\n {\n   gomp_barrier_wait_end (barrier, gomp_barrier_wait_start (barrier));\n }\n+\n+void\n+gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  unsigned int n;\n+\n+  if (state & 1)\n+    {\n+      n = --bar->arrived;\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+\n+      if (team->task_count)\n+\t{\n+\t  gomp_barrier_handle_tasks (state);\n+\t  if (n > 0)\n+\t    gomp_sem_wait (&bar->sem2);\n+\t  gomp_mutex_unlock (&bar->mutex1);\n+\t  return;\n+\t}\n+\n+      bar->generation = state + 3;\n+      if (n > 0)\n+\t{\n+\t  do\n+\t    gomp_sem_post (&bar->sem1);\n+\t  while (--n != 0);\n+\t  gomp_sem_wait (&bar->sem2);\n+\t}\n+      gomp_mutex_unlock (&bar->mutex1);\n+    }\n+  else\n+    {\n+      gomp_mutex_unlock (&bar->mutex1);\n+      do\n+\t{\n+\t  gomp_sem_wait (&bar->sem1);\n+\t  if (bar->generation & 1)\n+\t    gomp_barrier_handle_tasks (state);\n+\t}\n+      while (bar->generation != state + 4);\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+      n = __sync_add_and_fetch (&bar->arrived, -1);\n+#else\n+      gomp_mutex_lock (&bar->mutex2);\n+      n = --bar->arrived;\n+      gomp_mutex_unlock (&bar->mutex2);\n+#endif\n+\n+      if (n == 0)\n+\tgomp_sem_post (&bar->sem2);\n+    }\n+}\n+\n+void\n+gomp_team_barrier_wait (gomp_barrier_t *barrier)\n+{\n+  gomp_team_barrier_wait_end (barrier, gomp_barrier_wait_start (barrier));\n+}\n+\n+void\n+gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n+{\n+  if (count == 0)\n+    count = bar->total - 1;\n+  while (count-- > 0)\n+    gomp_sem_post (&bar->sem1);\n+}"}, {"sha": "e4d2e680af2ee38df1326c879d743f61aa25ac9d", "filename": "libgomp/config/posix/bar.h", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fbar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fbar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fbar.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -45,19 +45,74 @@ typedef struct\n   gomp_sem_t sem2;\n   unsigned total;\n   unsigned arrived;\n+  unsigned generation;\n } gomp_barrier_t;\n+typedef unsigned int gomp_barrier_state_t;\n \n extern void gomp_barrier_init (gomp_barrier_t *, unsigned);\n extern void gomp_barrier_reinit (gomp_barrier_t *, unsigned);\n extern void gomp_barrier_destroy (gomp_barrier_t *);\n \n extern void gomp_barrier_wait (gomp_barrier_t *);\n-extern void gomp_barrier_wait_end (gomp_barrier_t *, bool);\n+extern void gomp_barrier_wait_end (gomp_barrier_t *, gomp_barrier_state_t);\n+extern void gomp_team_barrier_wait (gomp_barrier_t *);\n+extern void gomp_team_barrier_wait_end (gomp_barrier_t *,\n+\t\t\t\t\tgomp_barrier_state_t);\n+extern void gomp_team_barrier_wake (gomp_barrier_t *, int);\n \n-static inline bool gomp_barrier_wait_start (gomp_barrier_t *bar)\n+static inline gomp_barrier_state_t\n+gomp_barrier_wait_start (gomp_barrier_t *bar)\n {\n+  unsigned int ret;\n   gomp_mutex_lock (&bar->mutex1);\n-  return ++bar->arrived == bar->total;\n+  ret = bar->generation & ~3;\n+  ret += ++bar->arrived == bar->total;\n+  return ret;\n+}\n+\n+static inline bool\n+gomp_barrier_last_thread (gomp_barrier_state_t state)\n+{\n+  return state & 1;\n+}\n+\n+static inline void\n+gomp_barrier_wait_last (gomp_barrier_t *bar)\n+{\n+  gomp_barrier_wait (bar);\n+}\n+\n+/* All the inlines below must be called with team->task_lock\n+   held.  */\n+\n+static inline void\n+gomp_team_barrier_set_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation |= 1;\n+}\n+\n+static inline void\n+gomp_team_barrier_clear_task_pending (gomp_barrier_t *bar)\n+{\n+  bar->generation &= ~1;\n+}\n+\n+static inline void\n+gomp_team_barrier_set_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  bar->generation |= 2;\n+}\n+\n+static inline bool\n+gomp_team_barrier_waiting_for_tasks (gomp_barrier_t *bar)\n+{\n+  return (bar->generation & 2) != 0;\n+}\n+\n+static inline void\n+gomp_team_barrier_done (gomp_barrier_t *bar, gomp_barrier_state_t state)\n+{\n+  bar->generation = (state & ~3) + 4;\n }\n \n #endif /* GOMP_BARRIER_H */"}, {"sha": "c2868398c664f9b29f06a464a5a8a1456091a648", "filename": "libgomp/config/posix/lock.c", "status": "modified", "additions": 196, "deletions": 11, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Flock.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -42,39 +42,209 @@\n \n #include \"libgomp.h\"\n \n+#ifdef HAVE_BROKEN_POSIX_SEMAPHORES\n+void\n+gomp_init_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_init (lock, NULL);\n+}\n+\n+void\n+gomp_destroy_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_destroy (lock);\n+}\n+\n+void\n+gomp_set_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_lock (lock);\n+}\n+\n+void\n+gomp_unset_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_unlock (lock);\n+}\n+\n+int\n+gomp_test_lock_30 (omp_lock_t *lock)\n+{\n+  return pthread_mutex_trylock (lock) == 0;\n+}\n+\n+void\n+gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  pthread_mutex_init (&lock->lock, NULL);\n+  lock->count = 0;\n+  lock->owner = NULL;\n+}\n+\n+void\n+gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  pthread_mutex_destroy (&lock->lock);\n+}\n+\n+void\n+gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      pthread_mutex_lock (&lock->lock);\n+      lock->owner = me;\n+    }\n+  lock->count++;\n+}\n+\n+void\n+gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  if (--lock->count == 0)\n+    {\n+      lock->owner = NULL;\n+      pthread_mutex_unlock (&lock->lock);\n+    }\n+}\n+\n+int\n+gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      if (pthread_mutex_trylock (&lock->lock) != 0)\n+\treturn 0;\n+      lock->owner = me;\n+    }\n+\n+  return ++lock->count;\n+}\n+\n+#else\n \n void\n-omp_init_lock (omp_lock_t *lock)\n+gomp_init_lock_30 (omp_lock_t *lock)\n+{\n+  sem_init (lock, 0, 1);\n+}\n+\n+void\n+gomp_destroy_lock_30 (omp_lock_t *lock)\n+{\n+  sem_destroy (lock);\n+}\n+\n+void\n+gomp_set_lock_30 (omp_lock_t *lock)\n+{\n+  while (sem_wait (lock) != 0)\n+    ;\n+}\n+\n+void\n+gomp_unset_lock_30 (omp_lock_t *lock)\n+{\n+  sem_post (lock);\n+}\n+\n+int\n+gomp_test_lock_30 (omp_lock_t *lock)\n+{\n+  return sem_trywait (lock) == 0;\n+}\n+\n+void\n+gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  sem_init (&lock->lock, 0, 1);\n+  lock->count = 0;\n+  lock->owner = NULL;\n+}\n+\n+void\n+gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  sem_destroy (&lock->lock);\n+}\n+\n+void\n+gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      while (sem_wait (&lock->lock) != 0)\n+\t;\n+      lock->owner = me;\n+    }\n+  lock->count++;\n+}\n+\n+void\n+gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  if (--lock->count == 0)\n+    {\n+      lock->owner = NULL;\n+      sem_post (&lock->lock);\n+    }\n+}\n+\n+int\n+gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      if (sem_trywait (&lock->lock) != 0)\n+\treturn 0;\n+      lock->owner = me;\n+    }\n+\n+  return ++lock->count;\n+}\n+#endif\n+\n+#ifdef LIBGOMP_GNU_SYMBOL_VERSIONING\n+void\n+gomp_init_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_init (lock, NULL);\n }\n \n void\n-omp_destroy_lock (omp_lock_t *lock)\n+gomp_destroy_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_destroy (lock);\n }\n \n void\n-omp_set_lock (omp_lock_t *lock)\n+gomp_set_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_lock (lock);\n }\n \n void\n-omp_unset_lock (omp_lock_t *lock)\n+gomp_unset_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_unlock (lock);\n }\n \n int\n-omp_test_lock (omp_lock_t *lock)\n+gomp_test_lock_25 (omp_lock_25_t *lock)\n {\n   return pthread_mutex_trylock (lock) == 0;\n }\n \n void\n-omp_init_nest_lock (omp_nest_lock_t *lock)\n+gomp_init_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   pthread_mutexattr_t attr;\n \n@@ -86,33 +256,46 @@ omp_init_nest_lock (omp_nest_lock_t *lock)\n }\n \n void\n-omp_destroy_nest_lock (omp_nest_lock_t *lock)\n+gomp_destroy_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   pthread_mutex_destroy (&lock->lock);\n }\n \n void\n-omp_set_nest_lock (omp_nest_lock_t *lock)\n+gomp_set_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   pthread_mutex_lock (&lock->lock);\n   lock->count++;\n }\n \n void\n-omp_unset_nest_lock (omp_nest_lock_t *lock)\n+gomp_unset_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   lock->count--;\n   pthread_mutex_unlock (&lock->lock);\n }\n \n int\n-omp_test_nest_lock (omp_nest_lock_t *lock)\n+gomp_test_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   if (pthread_mutex_trylock (&lock->lock) == 0)\n     return ++lock->count;\n   return 0;\n }\n \n+omp_lock_symver (omp_init_lock)\n+omp_lock_symver (omp_destroy_lock)\n+omp_lock_symver (omp_set_lock)\n+omp_lock_symver (omp_unset_lock)\n+omp_lock_symver (omp_test_lock)\n+omp_lock_symver (omp_init_nest_lock)\n+omp_lock_symver (omp_destroy_nest_lock)\n+omp_lock_symver (omp_set_nest_lock)\n+omp_lock_symver (omp_unset_nest_lock)\n+omp_lock_symver (omp_test_nest_lock)\n+\n+#else\n+\n ialias (omp_init_lock)\n ialias (omp_init_nest_lock)\n ialias (omp_destroy_lock)\n@@ -123,3 +306,5 @@ ialias (omp_unset_lock)\n ialias (omp_unset_nest_lock)\n ialias (omp_test_lock)\n ialias (omp_test_nest_lock)\n+\n+#endif"}, {"sha": "e51dc271f8ac8015ad753c4d705ae4364b89836f", "filename": "libgomp/config/posix/omp-lock.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fomp-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fomp-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fomp-lock.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -2,10 +2,22 @@\n    alignment of the public OpenMP locks, so that we can export data\n    structures without polluting the namespace.\n \n-   In this default POSIX implementation, we map the two locks to the\n-   same PTHREADS primitive.  */\n+   In this default POSIX implementation, we used to map the two locks to the\n+   same PTHREADS primitive, but for OpenMP 3.0 sem_t needs to be used\n+   instead, as pthread_mutex_unlock should not be called by different\n+   thread than the one that called pthread_mutex_lock.  */\n \n #include <pthread.h>\n+#include <semaphore.h>\n \n+typedef pthread_mutex_t omp_lock_25_t;\n+typedef struct { pthread_mutex_t lock; int count; } omp_nest_lock_25_t;\n+#ifdef HAVE_BROKEN_POSIX_SEMAPHORES\n+/* If we don't have working semaphores, we'll make all explicit tasks\n+   tied to the creating thread.  */\n typedef pthread_mutex_t omp_lock_t;\n-typedef struct { pthread_mutex_t lock; int count; } omp_nest_lock_t;\n+typedef struct { pthread_mutex_t lock; int count; void *owner; } omp_nest_lock_t;\n+#else\n+typedef sem_t omp_lock_t;\n+typedef struct { sem_t lock; int count; void *owner; } omp_nest_lock_t;\n+#endif"}, {"sha": "0c1096fb6b112e578ab28e51916f42bbb6d25be6", "filename": "libgomp/config/posix/proc.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fproc.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -48,7 +48,7 @@ void\n gomp_init_num_threads (void)\n {\n #ifdef _SC_NPROCESSORS_ONLN\n-  gomp_nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n+  gomp_global_icv.nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n #endif\n }\n \n@@ -63,13 +63,14 @@ unsigned\n gomp_dynamic_max_threads (void)\n {\n   unsigned n_onln, loadavg;\n+  unsigned nthreads_var = gomp_icv (false)->nthreads_var;\n \n #ifdef _SC_NPROCESSORS_ONLN\n   n_onln = sysconf (_SC_NPROCESSORS_ONLN);\n-  if (n_onln > gomp_nthreads_var)\n-    n_onln = gomp_nthreads_var;\n+  if (n_onln > nthreads_var)\n+    n_onln = nthreads_var;\n #else\n-  n_onln = gomp_nthreads_var;\n+  n_onln = nthreads_var;\n #endif\n \n   loadavg = 0;\n@@ -96,7 +97,7 @@ omp_get_num_procs (void)\n #ifdef _SC_NPROCESSORS_ONLN\n   return sysconf (_SC_NPROCESSORS_ONLN);\n #else\n-  return gomp_nthreads_var;\n+  return gomp_icv (false)->nthreads_var;\n #endif\n }\n "}, {"sha": "39bb64da0f90aa4acbb6dd9fd2e96bbf90bc6e85", "filename": "libgomp/config/posix/ptrlock.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fptrlock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fptrlock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fptrlock.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1 @@\n+/* Everything is in the header.  */"}, {"sha": "1271ebb227b99ebaaa2ee7c6ed039b6ce4cac24c", "filename": "libgomp/config/posix/ptrlock.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fptrlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix%2Fptrlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix%2Fptrlock.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,69 @@\n+/* Copyright (C) 2008 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This is a Linux specific implementation of a mutex synchronization\n+   mechanism for libgomp.  This type is private to the library.  This\n+   implementation uses atomic instructions and the futex syscall.  */\n+\n+#ifndef GOMP_PTRLOCK_H\n+#define GOMP_PTRLOCK_H 1\n+\n+typedef struct { void *ptr; gomp_mutex_t lock; } gomp_ptrlock_t;\n+\n+static inline void gomp_ptrlock_init (gomp_ptrlock_t *ptrlock, void *ptr)\n+{\n+  ptrlock->ptr = ptr;\n+  gomp_mutex_init (&ptrlock->lock);\n+}\n+\n+static inline void *gomp_ptrlock_get (gomp_ptrlock_t *ptrlock)\n+{\n+  if (ptrlock->ptr != NULL)\n+    return ptrlock->ptr;\n+\n+  gomp_mutex_lock (&ptrlock->lock);\n+  if (ptrlock->ptr != NULL)\n+    {\n+      gomp_mutex_unlock (&ptrlock->lock);\n+      return ptrlock->ptr;\n+    }\n+\n+  return NULL;\n+}\n+\n+static inline void gomp_ptrlock_set (gomp_ptrlock_t *ptrlock, void *ptr)\n+{\n+  ptrlock->ptr = ptr;\n+  gomp_mutex_unlock (&ptrlock->lock);\n+}\n+\n+static inline void gomp_ptrlock_destroy (gomp_ptrlock_t *ptrlock)\n+{\n+  gomp_mutex_destroy (&ptrlock->lock);\n+}\n+\n+#endif /* GOMP_PTRLOCK_H */"}, {"sha": "e27437ead16b1110412fbb3cfa70d2a1e0a4ed4c", "filename": "libgomp/config/posix95/lock.c", "status": "modified", "additions": 199, "deletions": 11, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix95%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix95%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix95%2Flock.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2008 Free Software Foundation, Inc.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n \n@@ -33,53 +33,226 @@\n \n #include \"libgomp.h\"\n \n+#ifdef HAVE_BROKEN_POSIX_SEMAPHORES\n+void\n+gomp_init_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_init (lock, NULL);\n+}\n+\n+void\n+gomp_destroy_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_destroy (lock);\n+}\n+\n+void\n+gomp_set_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_lock (lock);\n+}\n+\n+void\n+gomp_unset_lock_30 (omp_lock_t *lock)\n+{\n+  pthread_mutex_unlock (lock);\n+}\n+\n+int\n+gomp_test_lock_30 (omp_lock_t *lock)\n+{\n+  return pthread_mutex_trylock (lock) == 0;\n+}\n+\n+void\n+gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  pthread_mutex_init (&lock->lock, NULL);\n+  lock->owner = NULL;\n+  lock->count = 0;\n+}\n+\n+void\n+gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  pthread_mutex_destroy (&lock->lock);\n+}\n \n void\n-omp_init_lock (omp_lock_t *lock)\n+gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      pthread_mutex_lock (&lock->lock);\n+      lock->owner = me;\n+    }\n+\n+  lock->count++;\n+}\n+\n+void\n+gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  lock->count--;\n+\n+  if (lock->count == 0)\n+    {\n+      lock->owner = NULL;\n+      pthread_mutex_unlock (&lock->lock);\n+    }\n+}\n+\n+int\n+gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      if (pthread_mutex_trylock (&lock->lock) != 0)\n+\treturn 0;\n+      lock->owner = me;\n+    }\n+\n+  return ++lock->count;\n+}\n+\n+#else\n+\n+void\n+gomp_init_lock_30 (omp_lock_t *lock)\n+{\n+  sem_init (lock, 0, 1);\n+}\n+\n+void\n+gomp_destroy_lock_30 (omp_lock_t *lock)\n+{\n+  sem_destroy (lock);\n+}\n+\n+void\n+gomp_set_lock_30 (omp_lock_t *lock)\n+{\n+  while (sem_wait (lock) != 0)\n+    ;\n+}\n+\n+void\n+gomp_unset_lock_30 (omp_lock_t *lock)\n+{\n+  sem_post (lock);\n+}\n+\n+int\n+gomp_test_lock_30 (omp_lock_t *lock)\n+{\n+  return sem_trywait (lock) == 0;\n+}\n+\n+void\n+gomp_init_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  sem_init (&lock->lock, 0, 1);\n+  lock->count = 0;\n+  lock->owner = NULL;\n+}\n+\n+void\n+gomp_destroy_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  sem_destroy (&lock->lock);\n+}\n+\n+void\n+gomp_set_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      while (sem_wait (&lock->lock) != 0)\n+\t;\n+      lock->owner = me;\n+    }\n+  lock->count++;\n+}\n+\n+void\n+gomp_unset_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  if (--lock->count == 0)\n+    {\n+      lock->owner = NULL;\n+      sem_post (&lock->lock);\n+    }\n+}\n+\n+int\n+gomp_test_nest_lock_30 (omp_nest_lock_t *lock)\n+{\n+  void *me = gomp_icv (true);\n+\n+  if (lock->owner != me)\n+    {\n+      if (sem_trywait (&lock->lock) != 0)\n+\treturn 0;\n+      lock->owner = me;\n+    }\n+\n+  return ++lock->count;\n+}\n+#endif\n+\n+#ifdef LIBGOMP_GNU_SYMBOL_VERSIONING\n+void\n+gomp_init_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_init (lock, NULL);\n }\n \n void\n-omp_destroy_lock (omp_lock_t *lock)\n+gomp_destroy_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_destroy (lock);\n }\n \n void\n-omp_set_lock (omp_lock_t *lock)\n+gomp_set_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_lock (lock);\n }\n \n void\n-omp_unset_lock (omp_lock_t *lock)\n+gomp_unset_lock_25 (omp_lock_25_t *lock)\n {\n   pthread_mutex_unlock (lock);\n }\n \n int\n-omp_test_lock (omp_lock_t *lock)\n+gomp_test_lock_25 (omp_lock_25_t *lock)\n {\n   return pthread_mutex_trylock (lock) == 0;\n }\n \n void\n-omp_init_nest_lock (omp_nest_lock_t *lock)\n+gomp_init_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   pthread_mutex_init (&lock->lock, NULL);\n   lock->owner = (pthread_t) 0;\n   lock->count = 0;\n }\n \n void\n-omp_destroy_nest_lock (omp_nest_lock_t *lock)\n+gomp_destroy_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   pthread_mutex_destroy (&lock->lock);\n }\n \n void\n-omp_set_nest_lock (omp_nest_lock_t *lock)\n+gomp_set_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   pthread_t me = pthread_self ();\n \n@@ -93,7 +266,7 @@ omp_set_nest_lock (omp_nest_lock_t *lock)\n }\n \n void\n-omp_unset_nest_lock (omp_nest_lock_t *lock)\n+gomp_unset_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   lock->count--;\n \n@@ -105,7 +278,7 @@ omp_unset_nest_lock (omp_nest_lock_t *lock)\n }\n \n int\n-omp_test_nest_lock (omp_nest_lock_t *lock)\n+gomp_test_nest_lock_25 (omp_nest_lock_25_t *lock)\n {\n   pthread_t me = pthread_self ();\n \n@@ -119,6 +292,19 @@ omp_test_nest_lock (omp_nest_lock_t *lock)\n   return ++lock->count;\n }\n \n+omp_lock_symver (omp_init_lock)\n+omp_lock_symver (omp_destroy_lock)\n+omp_lock_symver (omp_set_lock)\n+omp_lock_symver (omp_unset_lock)\n+omp_lock_symver (omp_test_lock)\n+omp_lock_symver (omp_init_nest_lock)\n+omp_lock_symver (omp_destroy_nest_lock)\n+omp_lock_symver (omp_set_nest_lock)\n+omp_lock_symver (omp_unset_nest_lock)\n+omp_lock_symver (omp_test_nest_lock)\n+\n+#else\n+\n ialias (omp_init_lock)\n ialias (omp_init_nest_lock)\n ialias (omp_destroy_lock)\n@@ -129,3 +315,5 @@ ialias (omp_unset_lock)\n ialias (omp_unset_nest_lock)\n ialias (omp_test_lock)\n ialias (omp_test_nest_lock)\n+\n+#endif"}, {"sha": "b542ba13192324b34d39b62097eee8af7d716589", "filename": "libgomp/config/posix95/omp-lock.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix95%2Fomp-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfig%2Fposix95%2Fomp-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fposix95%2Fomp-lock.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -6,12 +6,16 @@\n    same PTHREADS primitive.  */\n \n #include <pthread.h>\n+#include <semaphore.h>\n \n+typedef pthread_mutex_t omp_lock_25_t;\n+typedef struct { pthread_mutex_t lock; pthread_t owner; int count; } omp_nest_lock_25_t;\n+#ifdef HAVE_BROKEN_POSIX_SEMAPHORES\n+/* If we don't have working semaphores, we'll make all explicit tasks\n+   tied to the creating thread.  */\n typedef pthread_mutex_t omp_lock_t;\n-\n-typedef struct\n-{\n-  pthread_mutex_t lock;\n-  pthread_t owner;\n-  int count;\n-} omp_nest_lock_t;\n+typedef struct { pthread_mutex_t lock; int count; void *owner; } omp_nest_lock_t;\n+#else\n+typedef sem_t omp_lock_t;\n+typedef struct { sem_t lock; int count; void *owner; } omp_nest_lock_t;\n+#endif"}, {"sha": "f22c8a06c318230c8a07542ca0a5f1c9cee3026c", "filename": "libgomp/configure", "status": "modified", "additions": 1351, "deletions": 13, "changes": 1364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -457,7 +457,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS GENINSRC_TRUE GENINSRC_FALSE build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS AR ac_ct_AR RANLIB ac_ct_RANLIB PERL BUILD_INFO_TRUE BUILD_INFO_FALSE LIBTOOL SED EGREP FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM LN_S lt_ECHO CPP CPPFLAGS enable_shared enable_static MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT FC FCFLAGS LDFLAGS ac_ct_FC libtool_VERSION SECTION_LDFLAGS OPT_LDFLAGS LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE config_path XCFLAGS XLDFLAGS link_gomp USE_FORTRAN_TRUE USE_FORTRAN_FALSE OMP_LOCK_SIZE OMP_LOCK_ALIGN OMP_NEST_LOCK_SIZE OMP_NEST_LOCK_ALIGN OMP_LOCK_KIND OMP_NEST_LOCK_KIND LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS GENINSRC_TRUE GENINSRC_FALSE build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar multi_basedir toolexecdir toolexeclibdir CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS AR ac_ct_AR RANLIB ac_ct_RANLIB PERL BUILD_INFO_TRUE BUILD_INFO_FALSE LIBTOOL SED EGREP FGREP GREP LD DUMPBIN ac_ct_DUMPBIN NM LN_S lt_ECHO CPP CPPFLAGS enable_shared enable_static MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT FC FCFLAGS LDFLAGS ac_ct_FC libtool_VERSION SECTION_LDFLAGS OPT_LDFLAGS LIBGOMP_BUILD_VERSIONED_SHLIB_TRUE LIBGOMP_BUILD_VERSIONED_SHLIB_FALSE config_path XCFLAGS XLDFLAGS link_gomp USE_FORTRAN_TRUE USE_FORTRAN_FALSE OMP_LOCK_SIZE OMP_LOCK_ALIGN OMP_NEST_LOCK_SIZE OMP_NEST_LOCK_ALIGN OMP_LOCK_KIND OMP_NEST_LOCK_KIND OMP_LOCK_25_SIZE OMP_LOCK_25_ALIGN OMP_NEST_LOCK_25_SIZE OMP_NEST_LOCK_25_ALIGN OMP_LOCK_25_KIND OMP_NEST_LOCK_25_KIND LIBOBJS LTLIBOBJS'\n ac_subst_files=''\n \n # Initialize some variables set by options.\n@@ -17988,6 +17988,14 @@ fi\n echo \"$as_me: versioning on shared library symbols is $enable_symvers\" >&6;}\n \n \n+if test $enable_symvers = gnu; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define LIBGOMP_GNU_SYMBOL_VERSIONING 1\n+_ACEOF\n+\n+fi\n+\n # Get target configury.\n . ${srcdir}/configure.tgt\n CFLAGS=\"$save_CFLAGS $XCFLAGS\"\n@@ -18156,7 +18164,7 @@ fi\n save_CFLAGS=\"$CFLAGS\"\n for i in $config_path; do\n   if test -f $srcdir/config/$i/omp-lock.h; then\n-    CFLAGS=\"$CFLAGS -include $srcdir/config/$i/omp-lock.h\"\n+    CFLAGS=\"$CFLAGS -include confdefs.h -include $srcdir/config/$i/omp-lock.h\"\n     break\n   fi\n done\n@@ -19471,20 +19479,1344 @@ rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftes\n fi\n fi\n rm -f conftest.val\n+if test \"$cross_compiling\" = yes; then\n+  # Depending upon the size, compute the lo and hi bounds.\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n \n-# If the lock fits in an integer, then arrange for Fortran to use that\n-# integer.  If it doesn't, then arrange for Fortran to use a pointer.\n-# Except that we don't have a way at present to multi-lib the installed\n-# Fortran modules, so we assume 8 bytes for pointers, regardless of the\n-# actual target.\n-OMP_LOCK_KIND=$OMP_LOCK_SIZE\n-OMP_NEST_LOCK_KIND=$OMP_NEST_LOCK_SIZE\n-if test $OMP_LOCK_SIZE -gt 8 || test $OMP_LOCK_ALIGN -gt $OMP_LOCK_SIZE; then\n-  OMP_LOCK_KIND=8\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_lock_25_t)) >= 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=0 ac_mid=0\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr $ac_mid + 1`\n+\t\t    if test $ac_lo -le $ac_mid; then\n+\t\t      ac_lo= ac_hi=\n+\t\t      break\n+\t\t    fi\n+\t\t    ac_mid=`expr 2 '*' $ac_mid + 1`\n fi\n-if test $OMP_NEST_LOCK_SIZE -gt 8 || test $OMP_NEST_LOCK_ALIGN -gt $OMP_NEST_LOCK_SIZE; then\n-  OMP_NEST_LOCK_KIND=8\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_lock_25_t)) < 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=-1 ac_mid=-1\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_lock_25_t)) >= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_hi=`expr '(' $ac_mid ')' - 1`\n+\t\t       if test $ac_mid -le $ac_hi; then\n+\t\t\t ac_lo= ac_hi=\n+\t\t\t break\n+\t\t       fi\n+\t\t       ac_mid=`expr 2 '*' $ac_mid`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo= ac_hi=\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+# Binary search between lo and hi bounds.\n+while test \"x$ac_lo\" != \"x$ac_hi\"; do\n+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr '(' $ac_mid ')' + 1`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+done\n+case $ac_lo in\n+?*) OMP_LOCK_25_SIZE=$ac_lo;;\n+'') { { echo \"$as_me:$LINENO: error: unsupported system, cannot find sizeof (omp_lock_25_t)\" >&5\n+echo \"$as_me: error: unsupported system, cannot find sizeof (omp_lock_25_t)\" >&2;}\n+   { (exit 1); exit 1; }; } ;;\n+esac\n+else\n+  if test \"$cross_compiling\" = yes; then\n+  { { echo \"$as_me:$LINENO: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&5\n+echo \"$as_me: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+long longval () { return sizeof (omp_lock_25_t); }\n+unsigned long ulongval () { return sizeof (omp_lock_25_t); }\n+#include <stdio.h>\n+#include <stdlib.h>\n+int\n+main ()\n+{\n+\n+  FILE *f = fopen (\"conftest.val\", \"w\");\n+  if (! f)\n+    exit (1);\n+  if ((sizeof (omp_lock_25_t)) < 0)\n+    {\n+      long i = longval ();\n+      if (i != (sizeof (omp_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%ld\\n\", i);\n+    }\n+  else\n+    {\n+      unsigned long i = ulongval ();\n+      if (i != (sizeof (omp_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%lu\\n\", i);\n+    }\n+  exit (ferror (f) || fclose (f) != 0);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  OMP_LOCK_25_SIZE=`cat conftest.val`\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+( exit $ac_status )\n+{ { echo \"$as_me:$LINENO: error: unsupported system, cannot find sizeof (omp_lock_25_t)\" >&5\n+echo \"$as_me: error: unsupported system, cannot find sizeof (omp_lock_25_t)\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+fi\n+rm -f conftest.val\n+if test \"$cross_compiling\" = yes; then\n+  # Depending upon the size, compute the lo and hi bounds.\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_lock_25_t)) >= 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=0 ac_mid=0\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr $ac_mid + 1`\n+\t\t    if test $ac_lo -le $ac_mid; then\n+\t\t      ac_lo= ac_hi=\n+\t\t      break\n+\t\t    fi\n+\t\t    ac_mid=`expr 2 '*' $ac_mid + 1`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_lock_25_t)) < 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=-1 ac_mid=-1\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_lock_25_t)) >= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_hi=`expr '(' $ac_mid ')' - 1`\n+\t\t       if test $ac_mid -le $ac_hi; then\n+\t\t\t ac_lo= ac_hi=\n+\t\t\t break\n+\t\t       fi\n+\t\t       ac_mid=`expr 2 '*' $ac_mid`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo= ac_hi=\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+# Binary search between lo and hi bounds.\n+while test \"x$ac_lo\" != \"x$ac_hi\"; do\n+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr '(' $ac_mid ')' + 1`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+done\n+case $ac_lo in\n+?*) OMP_LOCK_25_ALIGN=$ac_lo;;\n+'')  ;;\n+esac\n+else\n+  if test \"$cross_compiling\" = yes; then\n+  { { echo \"$as_me:$LINENO: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&5\n+echo \"$as_me: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+long longval () { return __alignof (omp_lock_25_t); }\n+unsigned long ulongval () { return __alignof (omp_lock_25_t); }\n+#include <stdio.h>\n+#include <stdlib.h>\n+int\n+main ()\n+{\n+\n+  FILE *f = fopen (\"conftest.val\", \"w\");\n+  if (! f)\n+    exit (1);\n+  if ((__alignof (omp_lock_25_t)) < 0)\n+    {\n+      long i = longval ();\n+      if (i != (__alignof (omp_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%ld\\n\", i);\n+    }\n+  else\n+    {\n+      unsigned long i = ulongval ();\n+      if (i != (__alignof (omp_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%lu\\n\", i);\n+    }\n+  exit (ferror (f) || fclose (f) != 0);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  OMP_LOCK_25_ALIGN=`cat conftest.val`\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+fi\n+rm -f conftest.val\n+if test \"$cross_compiling\" = yes; then\n+  # Depending upon the size, compute the lo and hi bounds.\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_nest_lock_25_t)) >= 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=0 ac_mid=0\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_nest_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr $ac_mid + 1`\n+\t\t    if test $ac_lo -le $ac_mid; then\n+\t\t      ac_lo= ac_hi=\n+\t\t      break\n+\t\t    fi\n+\t\t    ac_mid=`expr 2 '*' $ac_mid + 1`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_nest_lock_25_t)) < 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=-1 ac_mid=-1\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_nest_lock_25_t)) >= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_hi=`expr '(' $ac_mid ')' - 1`\n+\t\t       if test $ac_mid -le $ac_hi; then\n+\t\t\t ac_lo= ac_hi=\n+\t\t\t break\n+\t\t       fi\n+\t\t       ac_mid=`expr 2 '*' $ac_mid`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo= ac_hi=\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+# Binary search between lo and hi bounds.\n+while test \"x$ac_lo\" != \"x$ac_hi\"; do\n+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((sizeof (omp_nest_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr '(' $ac_mid ')' + 1`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+done\n+case $ac_lo in\n+?*) OMP_NEST_LOCK_25_SIZE=$ac_lo;;\n+'')  ;;\n+esac\n+else\n+  if test \"$cross_compiling\" = yes; then\n+  { { echo \"$as_me:$LINENO: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&5\n+echo \"$as_me: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+long longval () { return sizeof (omp_nest_lock_25_t); }\n+unsigned long ulongval () { return sizeof (omp_nest_lock_25_t); }\n+#include <stdio.h>\n+#include <stdlib.h>\n+int\n+main ()\n+{\n+\n+  FILE *f = fopen (\"conftest.val\", \"w\");\n+  if (! f)\n+    exit (1);\n+  if ((sizeof (omp_nest_lock_25_t)) < 0)\n+    {\n+      long i = longval ();\n+      if (i != (sizeof (omp_nest_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%ld\\n\", i);\n+    }\n+  else\n+    {\n+      unsigned long i = ulongval ();\n+      if (i != (sizeof (omp_nest_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%lu\\n\", i);\n+    }\n+  exit (ferror (f) || fclose (f) != 0);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  OMP_NEST_LOCK_25_SIZE=`cat conftest.val`\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+fi\n+rm -f conftest.val\n+if test \"$cross_compiling\" = yes; then\n+  # Depending upon the size, compute the lo and hi bounds.\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_nest_lock_25_t)) >= 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=0 ac_mid=0\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_nest_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr $ac_mid + 1`\n+\t\t    if test $ac_lo -le $ac_mid; then\n+\t\t      ac_lo= ac_hi=\n+\t\t      break\n+\t\t    fi\n+\t\t    ac_mid=`expr 2 '*' $ac_mid + 1`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_nest_lock_25_t)) < 0)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=-1 ac_mid=-1\n+  while :; do\n+    cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_nest_lock_25_t)) >= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_lo=$ac_mid; break\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_hi=`expr '(' $ac_mid ')' - 1`\n+\t\t       if test $ac_mid -le $ac_hi; then\n+\t\t\t ac_lo= ac_hi=\n+\t\t\t break\n+\t\t       fi\n+\t\t       ac_mid=`expr 2 '*' $ac_mid`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo= ac_hi=\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+# Binary search between lo and hi bounds.\n+while test \"x$ac_lo\" != \"x$ac_hi\"; do\n+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !((__alignof (omp_nest_lock_25_t)) <= $ac_mid)];\n+test_array [0] = 0\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_hi=$ac_mid\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_lo=`expr '(' $ac_mid ')' + 1`\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+done\n+case $ac_lo in\n+?*) OMP_NEST_LOCK_25_ALIGN=$ac_lo;;\n+'')  ;;\n+esac\n+else\n+  if test \"$cross_compiling\" = yes; then\n+  { { echo \"$as_me:$LINENO: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&5\n+echo \"$as_me: error: cannot run test program while cross compiling\n+See \\`config.log' for more details.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+long longval () { return __alignof (omp_nest_lock_25_t); }\n+unsigned long ulongval () { return __alignof (omp_nest_lock_25_t); }\n+#include <stdio.h>\n+#include <stdlib.h>\n+int\n+main ()\n+{\n+\n+  FILE *f = fopen (\"conftest.val\", \"w\");\n+  if (! f)\n+    exit (1);\n+  if ((__alignof (omp_nest_lock_25_t)) < 0)\n+    {\n+      long i = longval ();\n+      if (i != (__alignof (omp_nest_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%ld\\n\", i);\n+    }\n+  else\n+    {\n+      unsigned long i = ulongval ();\n+      if (i != (__alignof (omp_nest_lock_25_t)))\n+\texit (1);\n+      fprintf (f, \"%lu\\n\", i);\n+    }\n+  exit (ferror (f) || fclose (f) != 0);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  OMP_NEST_LOCK_25_ALIGN=`cat conftest.val`\n+else\n+  echo \"$as_me: program exited with status $ac_status\" >&5\n+echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+fi\n+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext\n+fi\n+fi\n+rm -f conftest.val\n+\n+# If the lock fits in an integer, then arrange for Fortran to use that\n+# integer.  If it doesn't, then arrange for Fortran to use a pointer.\n+# Except that we don't have a way at present to multi-lib the installed\n+# Fortran modules, so we assume 8 bytes for pointers, regardless of the\n+# actual target.\n+OMP_LOCK_KIND=$OMP_LOCK_SIZE\n+OMP_NEST_LOCK_KIND=$OMP_NEST_LOCK_SIZE\n+if test $OMP_LOCK_SIZE -gt 8 || test $OMP_LOCK_ALIGN -gt $OMP_LOCK_SIZE; then\n+  OMP_LOCK_KIND=8\n+fi\n+if test $OMP_NEST_LOCK_SIZE -gt 8 || test $OMP_NEST_LOCK_ALIGN -gt $OMP_NEST_LOCK_SIZE; then\n+  OMP_NEST_LOCK_KIND=8\n+fi\n+OMP_LOCK_25_KIND=$OMP_LOCK_25_SIZE\n+OMP_NEST_LOCK_25_KIND=$OMP_NEST_LOCK_25_SIZE\n+if test $OMP_LOCK_25_SIZE -gt 8 || test $OMP_LOCK_25_ALIGN -gt $OMP_LOCK_25_SIZE; then\n+  OMP_LOCK_25_KIND=8\n+fi\n+if test $OMP_NEST_LOCK_25_SIZE -gt 8 || test $OMP_NEST_LOCK_25_ALIGN -gt $OMP_NEST_LOCK_25_SIZE; then\n+  OMP_NEST_LOCK_25_KIND=8\n+fi\n+\n+\n+\n+\n+\n+\n \n \n \n@@ -20640,6 +21972,12 @@ s,@OMP_NEST_LOCK_SIZE@,$OMP_NEST_LOCK_SIZE,;t t\n s,@OMP_NEST_LOCK_ALIGN@,$OMP_NEST_LOCK_ALIGN,;t t\n s,@OMP_LOCK_KIND@,$OMP_LOCK_KIND,;t t\n s,@OMP_NEST_LOCK_KIND@,$OMP_NEST_LOCK_KIND,;t t\n+s,@OMP_LOCK_25_SIZE@,$OMP_LOCK_25_SIZE,;t t\n+s,@OMP_LOCK_25_ALIGN@,$OMP_LOCK_25_ALIGN,;t t\n+s,@OMP_NEST_LOCK_25_SIZE@,$OMP_NEST_LOCK_25_SIZE,;t t\n+s,@OMP_NEST_LOCK_25_ALIGN@,$OMP_NEST_LOCK_25_ALIGN,;t t\n+s,@OMP_LOCK_25_KIND@,$OMP_LOCK_25_KIND,;t t\n+s,@OMP_NEST_LOCK_25_KIND@,$OMP_NEST_LOCK_25_KIND,;t t\n s,@LIBOBJS@,$LIBOBJS,;t t\n s,@LTLIBOBJS@,$LTLIBOBJS,;t t\n CEOF"}, {"sha": "12c92340e8cc747953c7fd133af0d0b83a468142", "filename": "libgomp/configure.ac", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -228,6 +228,11 @@ LIBGOMP_CHECK_ATTRIBUTE_DLLEXPORT\n LIBGOMP_CHECK_ATTRIBUTE_ALIAS\n LIBGOMP_ENABLE_SYMVERS\n \n+if test $enable_symvers = gnu; then\n+  AC_DEFINE(LIBGOMP_GNU_SYMBOL_VERSIONING, 1,\n+\t    [Define to 1 if GNU symbol versioning is used for libgomp.])\n+fi\n+\n # Get target configury.\n . ${srcdir}/configure.tgt\n CFLAGS=\"$save_CFLAGS $XCFLAGS\"\n@@ -272,7 +277,7 @@ AM_CONDITIONAL([USE_FORTRAN], [test \"$ac_cv_fc_compiler_gnu\" = yes])\n save_CFLAGS=\"$CFLAGS\"\n for i in $config_path; do\n   if test -f $srcdir/config/$i/omp-lock.h; then\n-    CFLAGS=\"$CFLAGS -include $srcdir/config/$i/omp-lock.h\"\n+    CFLAGS=\"$CFLAGS -include confdefs.h -include $srcdir/config/$i/omp-lock.h\"\n     break\n   fi\n done\n@@ -282,6 +287,11 @@ _AC_COMPUTE_INT([sizeof (omp_lock_t)], [OMP_LOCK_SIZE],,\n _AC_COMPUTE_INT([__alignof (omp_lock_t)], [OMP_LOCK_ALIGN])\n _AC_COMPUTE_INT([sizeof (omp_nest_lock_t)], [OMP_NEST_LOCK_SIZE])\n _AC_COMPUTE_INT([__alignof (omp_nest_lock_t)], [OMP_NEST_LOCK_ALIGN])\n+_AC_COMPUTE_INT([sizeof (omp_lock_25_t)], [OMP_LOCK_25_SIZE],,\n+  [AC_MSG_ERROR([unsupported system, cannot find sizeof (omp_lock_25_t)])])\n+_AC_COMPUTE_INT([__alignof (omp_lock_25_t)], [OMP_LOCK_25_ALIGN])\n+_AC_COMPUTE_INT([sizeof (omp_nest_lock_25_t)], [OMP_NEST_LOCK_25_SIZE])\n+_AC_COMPUTE_INT([__alignof (omp_nest_lock_25_t)], [OMP_NEST_LOCK_25_ALIGN])\n \n # If the lock fits in an integer, then arrange for Fortran to use that\n # integer.  If it doesn't, then arrange for Fortran to use a pointer.\n@@ -296,13 +306,27 @@ fi\n if test $OMP_NEST_LOCK_SIZE -gt 8 || test $OMP_NEST_LOCK_ALIGN -gt $OMP_NEST_LOCK_SIZE; then\n   OMP_NEST_LOCK_KIND=8\n fi\n+OMP_LOCK_25_KIND=$OMP_LOCK_25_SIZE\n+OMP_NEST_LOCK_25_KIND=$OMP_NEST_LOCK_25_SIZE\n+if test $OMP_LOCK_25_SIZE -gt 8 || test $OMP_LOCK_25_ALIGN -gt $OMP_LOCK_25_SIZE; then\n+  OMP_LOCK_25_KIND=8\n+fi\n+if test $OMP_NEST_LOCK_25_SIZE -gt 8 || test $OMP_NEST_LOCK_25_ALIGN -gt $OMP_NEST_LOCK_25_SIZE; then\n+  OMP_NEST_LOCK_25_KIND=8\n+fi\n \n AC_SUBST(OMP_LOCK_SIZE)\n AC_SUBST(OMP_LOCK_ALIGN)\n AC_SUBST(OMP_NEST_LOCK_SIZE)\n AC_SUBST(OMP_NEST_LOCK_ALIGN)\n AC_SUBST(OMP_LOCK_KIND)\n AC_SUBST(OMP_NEST_LOCK_KIND)\n+AC_SUBST(OMP_LOCK_25_SIZE)\n+AC_SUBST(OMP_LOCK_25_ALIGN)\n+AC_SUBST(OMP_NEST_LOCK_25_SIZE)\n+AC_SUBST(OMP_NEST_LOCK_25_ALIGN)\n+AC_SUBST(OMP_LOCK_25_KIND)\n+AC_SUBST(OMP_NEST_LOCK_25_KIND)\n CFLAGS=\"$save_CFLAGS\"\n \n AC_CONFIG_FILES(omp.h omp_lib.h omp_lib.f90 libgomp_f.h)"}, {"sha": "022fb1bb0ad9a19c68ec1c6fa9a8f4ced2c66297", "filename": "libgomp/env.c", "status": "modified", "additions": 316, "deletions": 24, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -13,7 +13,7 @@\n    FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n    more details.\n \n-   You should have received a copy of the GNU Lesser General Public License \n+   You should have received a copy of the GNU Lesser General Public License\n    along with libgomp; see the file COPYING.LIB.  If not, write to the\n    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n    MA 02110-1301, USA.  */\n@@ -48,13 +48,24 @@\n #include <errno.h>\n \n \n-unsigned long gomp_nthreads_var = 1;\n-bool gomp_dyn_var = false;\n-bool gomp_nest_var = false;\n-enum gomp_schedule_type gomp_run_sched_var = GFS_DYNAMIC;\n-unsigned long gomp_run_sched_chunk = 1;\n+struct gomp_task_icv gomp_global_icv = {\n+  .nthreads_var = 1,\n+  .run_sched_var = GFS_DYNAMIC,\n+  .run_sched_modifier = 1,\n+  .dyn_var = false,\n+  .nest_var = false\n+};\n+\n unsigned short *gomp_cpu_affinity;\n size_t gomp_cpu_affinity_len;\n+unsigned long gomp_max_active_levels_var = INT_MAX;\n+unsigned long gomp_thread_limit_var = ULONG_MAX;\n+unsigned long gomp_remaining_threads_count;\n+#ifndef HAVE_SYNC_BUILTINS\n+gomp_mutex_t gomp_remaining_threads_lock;\n+#endif\n+unsigned long gomp_available_cpus = 1, gomp_managed_threads = 1;\n+unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n \n /* Parse the OMP_SCHEDULE environment variable.  */\n \n@@ -72,19 +83,24 @@ parse_schedule (void)\n     ++env;\n   if (strncasecmp (env, \"static\", 6) == 0)\n     {\n-      gomp_run_sched_var = GFS_STATIC;\n+      gomp_global_icv.run_sched_var = GFS_STATIC;\n       env += 6;\n     }\n   else if (strncasecmp (env, \"dynamic\", 7) == 0)\n     {\n-      gomp_run_sched_var = GFS_DYNAMIC;\n+      gomp_global_icv.run_sched_var = GFS_DYNAMIC;\n       env += 7;\n     }\n   else if (strncasecmp (env, \"guided\", 6) == 0)\n     {\n-      gomp_run_sched_var = GFS_GUIDED;\n+      gomp_global_icv.run_sched_var = GFS_GUIDED;\n       env += 6;\n     }\n+  else if (strncasecmp (env, \"auto\", 4) == 0)\n+    {\n+      gomp_global_icv.run_sched_var = GFS_AUTO;\n+      env += 4;\n+    }\n   else\n     goto unknown;\n \n@@ -109,7 +125,10 @@ parse_schedule (void)\n   if (*end != '\\0')\n     goto invalid;\n \n-  gomp_run_sched_chunk = value;\n+  if ((int)value != value)\n+    goto invalid;\n+\n+  gomp_global_icv.run_sched_modifier = value;\n   return;\n \n  unknown:\n@@ -122,7 +141,7 @@ parse_schedule (void)\n   return;\n }\n \n-/* Parse an unsigned long environment varible.  Return true if one was\n+/* Parse an unsigned long environment variable.  Return true if one was\n    present and it was successfully parsed.  */\n \n static bool\n@@ -158,7 +177,141 @@ parse_unsigned_long (const char *name, unsigned long *pvalue)\n   return false;\n }\n \n-/* Parse a boolean value for environment variable NAME and store the \n+/* Parse the OMP_STACKSIZE environment varible.  Return true if one was\n+   present and it was successfully parsed.  */\n+\n+static bool\n+parse_stacksize (const char *name, unsigned long *pvalue)\n+{\n+  char *env, *end;\n+  unsigned long value, shift = 10;\n+\n+  env = getenv (name);\n+  if (env == NULL)\n+    return false;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == '\\0')\n+    goto invalid;\n+\n+  errno = 0;\n+  value = strtoul (env, &end, 10);\n+  if (errno)\n+    goto invalid;\n+\n+  while (isspace ((unsigned char) *end))\n+    ++end;\n+  if (*end != '\\0')\n+    {\n+      switch (tolower (*end))\n+\t{\n+\tcase 'b':\n+\t  shift = 0;\n+\t  break;\n+\tcase 'k':\n+\t  break;\n+\tcase 'm':\n+\t  shift = 20;\n+\t  break;\n+\tcase 'g':\n+\t  shift = 30;\n+\t  break;\n+\tdefault:\n+\t  goto invalid;\n+\t}\n+      ++end;\n+      while (isspace ((unsigned char) *end))\n+\t++end;\n+      if (*end != '\\0')\n+\tgoto invalid;\n+    }\n+\n+  if (((value << shift) >> shift) != value)\n+    goto invalid;\n+\n+  *pvalue = value << shift;\n+  return true;\n+\n+ invalid:\n+  gomp_error (\"Invalid value for environment variable %s\", name);\n+  return false;\n+}\n+\n+/* Parse the GOMP_SPINCOUNT environment varible.  Return true if one was\n+   present and it was successfully parsed.  */\n+\n+static bool\n+parse_spincount (const char *name, unsigned long long *pvalue)\n+{\n+  char *env, *end;\n+  unsigned long long value, mult = 1;\n+\n+  env = getenv (name);\n+  if (env == NULL)\n+    return false;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == '\\0')\n+    goto invalid;\n+\n+  if (strncasecmp (env, \"infinite\", 8) == 0\n+      || strncasecmp (env, \"infinity\", 8) == 0)\n+    {\n+      value = ~0ULL;\n+      end = env + 8;\n+      goto check_tail;\n+    }\n+\n+  errno = 0;\n+  value = strtoull (env, &end, 10);\n+  if (errno)\n+    goto invalid;\n+\n+  while (isspace ((unsigned char) *end))\n+    ++end;\n+  if (*end != '\\0')\n+    {\n+      switch (tolower (*end))\n+\t{\n+\tcase 'k':\n+\t  mult = 1000LL;\n+\t  break;\n+\tcase 'm':\n+\t  mult = 1000LL * 1000LL;\n+\t  break;\n+\tcase 'g':\n+\t  mult = 1000LL * 1000LL * 1000LL;\n+\t  break;\n+\tcase 't':\n+\t  mult = 1000LL * 1000LL * 1000LL * 1000LL;\n+\t  break;\n+\tdefault:\n+\t  goto invalid;\n+\t}\n+      ++end;\n+     check_tail:\n+      while (isspace ((unsigned char) *end))\n+\t++end;\n+      if (*end != '\\0')\n+\tgoto invalid;\n+    }\n+\n+  if (value > ~0ULL / mult)\n+    value = ~0ULL;\n+  else\n+    value *= mult;\n+\n+  *pvalue = value;\n+  return true;\n+\n+ invalid:\n+  gomp_error (\"Invalid value for environment variable %s\", name);\n+  return false;\n+}\n+\n+/* Parse a boolean value for environment variable NAME and store the\n    result in VALUE.  */\n \n static void\n@@ -190,6 +343,41 @@ parse_boolean (const char *name, bool *value)\n     gomp_error (\"Invalid value for environment variable %s\", name);\n }\n \n+/* Parse the OMP_WAIT_POLICY environment variable and store the\n+   result in gomp_active_wait_policy.  */\n+\n+static int\n+parse_wait_policy (void)\n+{\n+  const char *env;\n+  int ret = -1;\n+\n+  env = getenv (\"OMP_WAIT_POLICY\");\n+  if (env == NULL)\n+    return -1;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (strncasecmp (env, \"active\", 6) == 0)\n+    {\n+      ret = 1;\n+      env += 6;\n+    }\n+  else if (strncasecmp (env, \"passive\", 7) == 0)\n+    {\n+      ret = 0;\n+      env += 7;\n+    }\n+  else\n+    env = \"X\";\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (*env == '\\0')\n+    return ret;\n+  gomp_error (\"Invalid value for environment variable OMP_WAIT_POLICY\");\n+  return -1;\n+}\n+\n /* Parse the GOMP_CPU_AFFINITY environment varible.  Return true if one was\n    present and it was successfully parsed.  */\n \n@@ -285,27 +473,61 @@ static void __attribute__((constructor))\n initialize_env (void)\n {\n   unsigned long stacksize;\n+  int wait_policy;\n \n   /* Do a compile time check that mkomp_h.pl did good job.  */\n   omp_check_defines ();\n \n   parse_schedule ();\n-  parse_boolean (\"OMP_DYNAMIC\", &gomp_dyn_var);\n-  parse_boolean (\"OMP_NESTED\", &gomp_nest_var);\n-  if (!parse_unsigned_long (\"OMP_NUM_THREADS\", &gomp_nthreads_var))\n-    gomp_init_num_threads ();\n+  parse_boolean (\"OMP_DYNAMIC\", &gomp_global_icv.dyn_var);\n+  parse_boolean (\"OMP_NESTED\", &gomp_global_icv.nest_var);\n+  parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\", &gomp_max_active_levels_var);\n+  parse_unsigned_long (\"OMP_THREAD_LIMIT\", &gomp_thread_limit_var);\n+  if (gomp_thread_limit_var != ULONG_MAX)\n+    {\n+      gomp_remaining_threads_count = gomp_thread_limit_var - 1;\n+#ifndef HAVE_SYNC_BUILTINS\n+      gomp_mutex_init (&gomp_remaining_threads_lock);\n+#endif\n+    }\n+  gomp_init_num_threads ();\n+  gomp_available_cpus = gomp_global_icv.nthreads_var;\n+  if (!parse_unsigned_long (\"OMP_NUM_THREADS\", &gomp_global_icv.nthreads_var))\n+    gomp_global_icv.nthreads_var = gomp_available_cpus;\n   if (parse_affinity ())\n     gomp_init_affinity ();\n+  wait_policy = parse_wait_policy ();\n+  if (!parse_spincount (\"GOMP_SPINCOUNT\", &gomp_spin_count_var))\n+    {\n+      /* Using a rough estimation of 100000 spins per msec,\n+\t use 5 min blocking for OMP_WAIT_POLICY=active,\n+\t 200 msec blocking when OMP_WAIT_POLICY is not specificed\n+\t and 0 when OMP_WAIT_POLICY=passive.\n+\t Depending on the CPU speed, this can be e.g. 5 times longer\n+\t or 5 times shorter.  */\n+      if (wait_policy > 0)\n+\tgomp_spin_count_var = 30000000000LL;\n+      else if (wait_policy < 0)\n+\tgomp_spin_count_var = 20000000LL;\n+    }\n+  /* gomp_throttled_spin_count_var is used when there are more libgomp\n+     managed threads than available CPUs.  Use very short spinning.  */\n+  if (wait_policy > 0)\n+    gomp_throttled_spin_count_var = 1000LL;\n+  else if (wait_policy < 0)\n+    gomp_throttled_spin_count_var = 100LL;\n+  if (gomp_throttled_spin_count_var > gomp_spin_count_var)\n+    gomp_throttled_spin_count_var = gomp_spin_count_var;\n \n   /* Not strictly environment related, but ordering constructors is tricky.  */\n   pthread_attr_init (&gomp_thread_attr);\n   pthread_attr_setdetachstate (&gomp_thread_attr, PTHREAD_CREATE_DETACHED);\n \n-  if (parse_unsigned_long (\"GOMP_STACKSIZE\", &stacksize))\n+  if (parse_stacksize (\"OMP_STACKSIZE\", &stacksize)\n+      || parse_stacksize (\"GOMP_STACKSIZE\", &stacksize))\n     {\n       int err;\n \n-      stacksize *= 1024;\n       err = pthread_attr_setstacksize (&gomp_thread_attr, stacksize);\n \n #ifdef PTHREAD_STACK_MIN\n@@ -331,35 +553,105 @@ initialize_env (void)\n void\n omp_set_num_threads (int n)\n {\n-  gomp_nthreads_var = (n > 0 ? n : 1);\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->nthreads_var = (n > 0 ? n : 1);\n }\n \n void\n omp_set_dynamic (int val)\n {\n-  gomp_dyn_var = val;\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->dyn_var = val;\n }\n \n int\n omp_get_dynamic (void)\n {\n-  return gomp_dyn_var;\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->dyn_var;\n }\n \n void\n omp_set_nested (int val)\n {\n-  gomp_nest_var = val;\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  icv->nest_var = val;\n }\n \n int\n omp_get_nested (void)\n {\n-  return gomp_nest_var;\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->nest_var;\n+}\n+\n+void\n+omp_set_schedule (omp_sched_t kind, int modifier)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (true);\n+  switch (kind)\n+    {\n+    case omp_sched_static:\n+      if (modifier < 1)\n+\tmodifier = 0;\n+      icv->run_sched_modifier = modifier;\n+      break;\n+    case omp_sched_dynamic:\n+    case omp_sched_guided:\n+      if (modifier < 1)\n+\tmodifier = 1;\n+      icv->run_sched_modifier = modifier;\n+      break;\n+    case omp_sched_auto:\n+      break;\n+    default:\n+      return;\n+    }\n+  icv->run_sched_var = kind;\n+}\n+\n+void\n+omp_get_schedule (omp_sched_t *kind, int *modifier)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  *kind = icv->run_sched_var;\n+  *modifier = icv->run_sched_modifier;\n+}\n+\n+int\n+omp_get_max_threads (void)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  return icv->nthreads_var;\n+}\n+\n+int\n+omp_get_thread_limit (void)\n+{\n+  return gomp_thread_limit_var > INT_MAX ? INT_MAX : gomp_thread_limit_var;\n+}\n+\n+void\n+omp_set_max_active_levels (int max_levels)\n+{\n+  if (max_levels > 0)\n+    gomp_max_active_levels_var = max_levels;\n+}\n+\n+int\n+omp_get_max_active_levels (void)\n+{\n+  return gomp_max_active_levels_var;\n }\n \n ialias (omp_set_dynamic)\n ialias (omp_set_nested)\n ialias (omp_set_num_threads)\n ialias (omp_get_dynamic)\n ialias (omp_get_nested)\n+ialias (omp_set_schedule)\n+ialias (omp_get_schedule)\n+ialias (omp_get_max_threads)\n+ialias (omp_get_thread_limit)\n+ialias (omp_set_max_active_levels)\n+ialias (omp_get_max_active_levels)"}, {"sha": "1e20aea28eef241828edf3a65081f501afaabef0", "filename": "libgomp/fortran.c", "status": "modified", "additions": 236, "deletions": 33, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ffortran.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ffortran.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ffortran.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -33,11 +33,12 @@\n \n #ifdef HAVE_ATTRIBUTE_ALIAS\n /* Use internal aliases if possible.  */\n-#define ULP\tSTR1(__USER_LABEL_PREFIX__)\n-#define STR1(x)\tSTR2(x)\n-#define STR2(x)\t#x\n+# define ULP\t\tSTR1(__USER_LABEL_PREFIX__)\n+# define STR1(x)\tSTR2(x)\n+# define STR2(x)\t#x\n # define ialias_redirect(fn) \\\n   extern __typeof (fn) fn __asm__ (ULP \"gomp_ialias_\" #fn) attribute_hidden;\n+# ifndef LIBGOMP_GNU_SYMBOL_VERSIONING\n ialias_redirect (omp_init_lock)\n ialias_redirect (omp_init_nest_lock)\n ialias_redirect (omp_destroy_lock)\n@@ -48,6 +49,7 @@ ialias_redirect (omp_unset_lock)\n ialias_redirect (omp_unset_nest_lock)\n ialias_redirect (omp_test_lock)\n ialias_redirect (omp_test_nest_lock)\n+# endif\n ialias_redirect (omp_set_dynamic)\n ialias_redirect (omp_set_nested)\n ialias_redirect (omp_set_num_threads)\n@@ -60,70 +62,191 @@ ialias_redirect (omp_get_num_threads)\n ialias_redirect (omp_get_thread_num)\n ialias_redirect (omp_get_wtick)\n ialias_redirect (omp_get_wtime)\n-#endif        \n+ialias_redirect (omp_set_schedule)\n+ialias_redirect (omp_get_schedule)\n+ialias_redirect (omp_get_thread_limit)\n+ialias_redirect (omp_set_max_active_levels)\n+ialias_redirect (omp_get_max_active_levels)\n+ialias_redirect (omp_get_level)\n+ialias_redirect (omp_get_ancestor_thread_num)\n+ialias_redirect (omp_get_team_size)\n+ialias_redirect (omp_get_active_level)\n+#endif\n+\n+#ifndef LIBGOMP_GNU_SYMBOL_VERSIONING\n+# define gomp_init_lock__30 omp_init_lock_\n+# define gomp_destroy_lock__30 omp_destroy_lock_\n+# define gomp_set_lock__30 omp_set_lock_\n+# define gomp_unset_lock__30 omp_unset_lock_\n+# define gomp_test_lock__30 omp_test_lock_\n+# define gomp_init_nest_lock__30 omp_init_nest_lock_\n+# define gomp_destroy_nest_lock__30 omp_destroy_nest_lock_\n+# define gomp_set_nest_lock__30 omp_set_nest_lock_\n+# define gomp_unset_nest_lock__30 omp_unset_nest_lock_\n+# define gomp_test_nest_lock__30 omp_test_nest_lock_\n+#endif\n \n void\n-omp_init_lock_ (omp_lock_arg_t lock)\n+gomp_init_lock__30 (omp_lock_arg_t lock)\n {\n #ifndef OMP_LOCK_DIRECT\n   omp_lock_arg (lock) = malloc (sizeof (omp_lock_t));\n #endif\n-  omp_init_lock (omp_lock_arg (lock));\n+  gomp_init_lock_30 (omp_lock_arg (lock));\n }\n \n void\n-omp_init_nest_lock_ (omp_nest_lock_arg_t lock)\n+gomp_init_nest_lock__30 (omp_nest_lock_arg_t lock)\n {\n #ifndef OMP_NEST_LOCK_DIRECT\n   omp_nest_lock_arg (lock) = malloc (sizeof (omp_nest_lock_t));\n #endif\n-  omp_init_nest_lock (omp_nest_lock_arg (lock));\n+  gomp_init_nest_lock_30 (omp_nest_lock_arg (lock));\n }\n \n void\n-omp_destroy_lock_ (omp_lock_arg_t lock)\n+gomp_destroy_lock__30 (omp_lock_arg_t lock)\n {\n-  omp_destroy_lock (omp_lock_arg (lock));\n+  gomp_destroy_lock_30 (omp_lock_arg (lock));\n #ifndef OMP_LOCK_DIRECT\n   free (omp_lock_arg (lock));\n   omp_lock_arg (lock) = NULL;\n #endif\n }\n \n void\n-omp_destroy_nest_lock_ (omp_nest_lock_arg_t lock)\n+gomp_destroy_nest_lock__30 (omp_nest_lock_arg_t lock)\n {\n-  omp_destroy_nest_lock (omp_nest_lock_arg (lock));\n+  gomp_destroy_nest_lock_30 (omp_nest_lock_arg (lock));\n #ifndef OMP_NEST_LOCK_DIRECT\n   free (omp_nest_lock_arg (lock));\n   omp_nest_lock_arg (lock) = NULL;\n #endif\n }\n \n void\n-omp_set_lock_ (omp_lock_arg_t lock)\n+gomp_set_lock__30 (omp_lock_arg_t lock)\n+{\n+  gomp_set_lock_30 (omp_lock_arg (lock));\n+}\n+\n+void\n+gomp_set_nest_lock__30 (omp_nest_lock_arg_t lock)\n {\n-  omp_set_lock (omp_lock_arg (lock));\n+  gomp_set_nest_lock_30 (omp_nest_lock_arg (lock));\n }\n \n void\n-omp_set_nest_lock_ (omp_nest_lock_arg_t lock)\n+gomp_unset_lock__30 (omp_lock_arg_t lock)\n {\n-  omp_set_nest_lock (omp_nest_lock_arg (lock));\n+  gomp_unset_lock_30 (omp_lock_arg (lock));\n }\n \n void\n-omp_unset_lock_ (omp_lock_arg_t lock)\n+gomp_unset_nest_lock__30 (omp_nest_lock_arg_t lock)\n+{\n+  gomp_unset_nest_lock_30 (omp_nest_lock_arg (lock));\n+}\n+\n+int32_t\n+gomp_test_lock__30 (omp_lock_arg_t lock)\n+{\n+  return gomp_test_lock_30 (omp_lock_arg (lock));\n+}\n+\n+int32_t\n+gomp_test_nest_lock__30 (omp_nest_lock_arg_t lock)\n {\n-  omp_unset_lock (omp_lock_arg (lock));\n+  return gomp_test_nest_lock_30 (omp_nest_lock_arg (lock));\n }\n \n+#ifdef LIBGOMP_GNU_SYMBOL_VERSIONING\n void\n-omp_unset_nest_lock_ (omp_nest_lock_arg_t lock)\n+gomp_init_lock__25 (omp_lock_25_arg_t lock)\n {\n-  omp_unset_nest_lock (omp_nest_lock_arg (lock));\n+#ifndef OMP_LOCK_25_DIRECT\n+  omp_lock_25_arg (lock) = malloc (sizeof (omp_lock_25_t));\n+#endif\n+  gomp_init_lock_25 (omp_lock_25_arg (lock));\n+}\n+\n+void\n+gomp_init_nest_lock__25 (omp_nest_lock_25_arg_t lock)\n+{\n+#ifndef OMP_NEST_LOCK_25_DIRECT\n+  omp_nest_lock_25_arg (lock) = malloc (sizeof (omp_nest_lock_25_t));\n+#endif\n+  gomp_init_nest_lock_25 (omp_nest_lock_25_arg (lock));\n+}\n+\n+void\n+gomp_destroy_lock__25 (omp_lock_25_arg_t lock)\n+{\n+  gomp_destroy_lock_25 (omp_lock_25_arg (lock));\n+#ifndef OMP_LOCK_25_DIRECT\n+  free (omp_lock_25_arg (lock));\n+  omp_lock_25_arg (lock) = NULL;\n+#endif\n+}\n+\n+void\n+gomp_destroy_nest_lock__25 (omp_nest_lock_25_arg_t lock)\n+{\n+  gomp_destroy_nest_lock_25 (omp_nest_lock_25_arg (lock));\n+#ifndef OMP_NEST_LOCK_25_DIRECT\n+  free (omp_nest_lock_25_arg (lock));\n+  omp_nest_lock_25_arg (lock) = NULL;\n+#endif\n }\n \n+void\n+gomp_set_lock__25 (omp_lock_25_arg_t lock)\n+{\n+  gomp_set_lock_25 (omp_lock_25_arg (lock));\n+}\n+\n+void\n+gomp_set_nest_lock__25 (omp_nest_lock_25_arg_t lock)\n+{\n+  gomp_set_nest_lock_25 (omp_nest_lock_25_arg (lock));\n+}\n+\n+void\n+gomp_unset_lock__25 (omp_lock_25_arg_t lock)\n+{\n+  gomp_unset_lock_25 (omp_lock_25_arg (lock));\n+}\n+\n+void\n+gomp_unset_nest_lock__25 (omp_nest_lock_25_arg_t lock)\n+{\n+  gomp_unset_nest_lock_25 (omp_nest_lock_25_arg (lock));\n+}\n+\n+int32_t\n+gomp_test_lock__25 (omp_lock_25_arg_t lock)\n+{\n+  return gomp_test_lock_25 (omp_lock_25_arg (lock));\n+}\n+\n+int32_t\n+gomp_test_nest_lock__25 (omp_nest_lock_25_arg_t lock)\n+{\n+  return gomp_test_nest_lock_25 (omp_nest_lock_25_arg (lock));\n+}\n+\n+omp_lock_symver (omp_init_lock_)\n+omp_lock_symver (omp_destroy_lock_)\n+omp_lock_symver (omp_set_lock_)\n+omp_lock_symver (omp_unset_lock_)\n+omp_lock_symver (omp_test_lock_)\n+omp_lock_symver (omp_init_nest_lock_)\n+omp_lock_symver (omp_destroy_nest_lock_)\n+omp_lock_symver (omp_set_nest_lock_)\n+omp_lock_symver (omp_unset_nest_lock_)\n+omp_lock_symver (omp_test_nest_lock_)\n+#endif\n+\n void\n omp_set_dynamic_ (const int32_t *set)\n {\n@@ -178,12 +301,6 @@ omp_in_parallel_ (void)\n   return omp_in_parallel ();\n }\n \n-int32_t\n-omp_test_lock_ (omp_lock_arg_t lock)\n-{\n-  return omp_test_lock (omp_lock_arg (lock));\n-}\n-\n int32_t\n omp_get_max_threads_ (void)\n {\n@@ -208,12 +325,6 @@ omp_get_thread_num_ (void)\n   return omp_get_thread_num ();\n }\n \n-int32_t\n-omp_test_nest_lock_ (omp_nest_lock_arg_t lock)\n-{\n-  return omp_test_nest_lock (omp_nest_lock_arg (lock));\n-}\n-\n double\n omp_get_wtick_ (void)\n {\n@@ -225,3 +336,95 @@ omp_get_wtime_ (void)\n {\n   return omp_get_wtime ();\n }\n+\n+void\n+omp_set_schedule_ (const int32_t *kind, const int32_t *modifier)\n+{\n+  omp_set_schedule (*kind, *modifier);\n+}\n+\n+void\n+omp_set_schedule_8_ (const int32_t *kind, const int64_t *modifier)\n+{\n+  omp_set_schedule (*kind, *modifier);\n+}\n+\n+void\n+omp_get_schedule_ (int32_t *kind, int32_t *modifier)\n+{\n+  omp_sched_t k;\n+  int m;\n+  omp_get_schedule (&k, &m);\n+  *kind = k;\n+  *modifier = m;\n+}\n+\n+void\n+omp_get_schedule_8_ (int32_t *kind, int64_t *modifier)\n+{\n+  omp_sched_t k;\n+  int m;\n+  omp_get_schedule (&k, &m);\n+  *kind = k;\n+  *modifier = m;\n+}\n+\n+int32_t\n+omp_get_thread_limit_ (void)\n+{\n+  return omp_get_thread_limit ();\n+}\n+\n+void\n+omp_set_max_active_levels_ (const int32_t *levels)\n+{\n+  omp_set_max_active_levels (*levels);\n+}\n+\n+void\n+omp_set_max_active_levels_8_ (const int64_t *levels)\n+{\n+  omp_set_max_active_levels (*levels);\n+}\n+\n+int32_t\n+omp_get_max_active_levels_ (void)\n+{\n+  return omp_get_max_active_levels ();\n+}\n+\n+int32_t\n+omp_get_level_ (void)\n+{\n+  return omp_get_level ();\n+}\n+\n+int32_t\n+omp_get_ancestor_thread_num_ (const int32_t *level)\n+{\n+  return omp_get_ancestor_thread_num (*level);\n+}\n+\n+int32_t\n+omp_get_ancestor_thread_num_8_ (const int64_t *level)\n+{\n+  return omp_get_ancestor_thread_num (*level);\n+}\n+\n+int32_t\n+omp_get_team_size_ (const int32_t *level)\n+{\n+  return omp_get_team_size (*level);\n+}\n+\n+int32_t\n+omp_get_team_size_8_ (const int64_t *level)\n+{\n+  return omp_get_team_size (*level);\n+}\n+\n+int32_t\n+omp_get_active_level_ (void)\n+{\n+  return omp_get_active_level ();\n+}"}, {"sha": "f186058be463c51a67bac23fcb0695f8f73843ad", "filename": "libgomp/iter.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fiter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fiter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fiter.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -154,7 +154,7 @@ gomp_iter_dynamic_next_locked (long *pstart, long *pend)\n   if (start == ws->end)\n     return false;\n \n-  chunk = ws->chunk_size * ws->incr;\n+  chunk = ws->chunk_size;\n   left = ws->end - start;\n   if (ws->incr < 0)\n     {\n@@ -186,11 +186,38 @@ gomp_iter_dynamic_next (long *pstart, long *pend)\n   struct gomp_work_share *ws = thr->ts.work_share;\n   long start, end, nend, chunk, incr;\n \n-  start = ws->next;\n   end = ws->end;\n   incr = ws->incr;\n-  chunk = ws->chunk_size * incr;\n+  chunk = ws->chunk_size;\n+\n+  if (__builtin_expect (ws->mode, 1))\n+    {\n+      long tmp = __sync_fetch_and_add (&ws->next, chunk);\n+      if (incr > 0)\n+\t{\n+\t  if (tmp >= end)\n+\t    return false;\n+\t  nend = tmp + chunk;\n+\t  if (nend > end)\n+\t    nend = end;\n+\t  *pstart = tmp;\n+\t  *pend = nend;\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  if (tmp <= end)\n+\t    return false;\n+\t  nend = tmp + chunk;\n+\t  if (nend < end)\n+\t    nend = end;\n+\t  *pstart = tmp;\n+\t  *pend = nend;\n+\t  return true;\n+\t}\n+    }\n \n+  start = ws->next;\n   while (1)\n     {\n       long left = end - start;"}, {"sha": "d6262dafee5af65320d10d1202fafd0e009e9255", "filename": "libgomp/iter_ull.c", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fiter_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fiter_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fiter_ull.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,344 @@\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file contains routines for managing work-share iteration, both\n+   for loops and sections.  */\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+\n+typedef unsigned long long gomp_ull;\n+\n+/* This function implements the STATIC scheduling method.  The caller should\n+   iterate *pstart <= x < *pend.  Return zero if there are more iterations\n+   to perform; nonzero if not.  Return less than 0 if this thread had\n+   received the absolutely last iteration.  */\n+\n+int\n+gomp_iter_ull_static_next (gomp_ull *pstart, gomp_ull *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  unsigned long nthreads = team ? team->nthreads : 1;\n+\n+  if (thr->ts.static_trip == -1)\n+    return -1;\n+\n+  /* Quick test for degenerate teams and orphaned constructs.  */\n+  if (nthreads == 1)\n+    {\n+      *pstart = ws->next_ull;\n+      *pend = ws->end_ull;\n+      thr->ts.static_trip = -1;\n+      return ws->next_ull == ws->end_ull;\n+    }\n+\n+  /* We interpret chunk_size zero as \"unspecified\", which means that we\n+     should break up the iterations such that each thread makes only one\n+     trip through the outer loop.  */\n+  if (ws->chunk_size_ull == 0)\n+    {\n+      gomp_ull n, q, i, s0, e0, s, e;\n+\n+      if (thr->ts.static_trip > 0)\n+\treturn 1;\n+\n+      /* Compute the total number of iterations.  */\n+      if (__builtin_expect (ws->mode, 0) == 0)\n+\tn = (ws->end_ull - ws->next_ull + ws->incr_ull - 1) / ws->incr_ull;\n+      else\n+\tn = (ws->next_ull - ws->end_ull - ws->incr_ull - 1) / -ws->incr_ull;\n+      i = thr->ts.team_id;\n+\n+      /* Compute the \"zero-based\" start and end points.  That is, as\n+\t if the loop began at zero and incremented by one.  */\n+      q = n / nthreads;\n+      q += (q * nthreads != n);\n+      s0 = q * i;\n+      e0 = s0 + q;\n+      if (e0 > n)\n+\te0 = n;\n+\n+      /* Notice when no iterations allocated for this thread.  */\n+      if (s0 >= e0)\n+\t{\n+\t  thr->ts.static_trip = 1;\n+\t  return 1;\n+\t}\n+\n+      /* Transform these to the actual start and end numbers.  */\n+      s = s0 * ws->incr_ull + ws->next_ull;\n+      e = e0 * ws->incr_ull + ws->next_ull;\n+\n+      *pstart = s;\n+      *pend = e;\n+      thr->ts.static_trip = (e0 == n ? -1 : 1);\n+      return 0;\n+    }\n+  else\n+    {\n+      gomp_ull n, s0, e0, i, c, s, e;\n+\n+      /* Otherwise, each thread gets exactly chunk_size iterations\n+\t (if available) each time through the loop.  */\n+\n+      if (__builtin_expect (ws->mode, 0) == 0)\n+\tn = (ws->end_ull - ws->next_ull + ws->incr_ull - 1) / ws->incr_ull;\n+      else\n+\tn = (ws->next_ull - ws->end_ull - ws->incr_ull - 1) / -ws->incr_ull;\n+      i = thr->ts.team_id;\n+      c = ws->chunk_size_ull;\n+\n+      /* Initial guess is a C sized chunk positioned nthreads iterations\n+\t in, offset by our thread number.  */\n+      s0 = (thr->ts.static_trip * (gomp_ull) nthreads + i) * c;\n+      e0 = s0 + c;\n+\n+      /* Detect overflow.  */\n+      if (s0 >= n)\n+\treturn 1;\n+      if (e0 > n)\n+\te0 = n;\n+\n+      /* Transform these to the actual start and end numbers.  */\n+      s = s0 * ws->incr_ull + ws->next_ull;\n+      e = e0 * ws->incr_ull + ws->next_ull;\n+\n+      *pstart = s;\n+      *pend = e;\n+\n+      if (e0 == n)\n+\tthr->ts.static_trip = -1;\n+      else\n+\tthr->ts.static_trip++;\n+      return 0;\n+    }\n+}\n+\n+\n+/* This function implements the DYNAMIC scheduling method.  Arguments are\n+   as for gomp_iter_ull_static_next.  This function must be called with\n+   ws->lock held.  */\n+\n+bool\n+gomp_iter_ull_dynamic_next_locked (gomp_ull *pstart, gomp_ull *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  gomp_ull start, end, chunk, left;\n+\n+  start = ws->next_ull;\n+  if (start == ws->end_ull)\n+    return false;\n+\n+  chunk = ws->chunk_size_ull;\n+  left = ws->end_ull - start;\n+  if (__builtin_expect (ws->mode & 2, 0))\n+    {\n+      if (chunk < left)\n+\tchunk = left;\n+    }\n+  else\n+    {\n+      if (chunk > left)\n+\tchunk = left;\n+    }\n+  end = start + chunk;\n+\n+  ws->next_ull = end;\n+  *pstart = start;\n+  *pend = end;\n+  return true;\n+}\n+\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+/* Similar, but doesn't require the lock held, and uses compare-and-swap\n+   instead.  Note that the only memory value that changes is ws->next_ull.  */\n+\n+bool\n+gomp_iter_ull_dynamic_next (gomp_ull *pstart, gomp_ull *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  gomp_ull start, end, nend, chunk;\n+\n+  end = ws->end_ull;\n+  chunk = ws->chunk_size_ull;\n+\n+  if (__builtin_expect (ws->mode & 1, 1))\n+    {\n+      gomp_ull tmp = __sync_fetch_and_add (&ws->next_ull, chunk);\n+      if (__builtin_expect (ws->mode & 2, 0) == 0)\n+\t{\n+\t  if (tmp >= end)\n+\t    return false;\n+\t  nend = tmp + chunk;\n+\t  if (nend > end)\n+\t    nend = end;\n+\t  *pstart = tmp;\n+\t  *pend = nend;\n+\t  return true;\n+\t}\n+      else\n+\t{\n+\t  if (tmp <= end)\n+\t    return false;\n+\t  nend = tmp + chunk;\n+\t  if (nend < end)\n+\t    nend = end;\n+\t  *pstart = tmp;\n+\t  *pend = nend;\n+\t  return true;\n+\t}\n+    }\n+\n+  start = ws->next_ull;\n+  while (1)\n+    {\n+      gomp_ull left = end - start;\n+      gomp_ull tmp;\n+\n+      if (start == end)\n+\treturn false;\n+\n+      if (__builtin_expect (ws->mode & 2, 0))\n+\t{\n+\t  if (chunk < left)\n+\t    chunk = left;\n+\t}\n+      else\n+\t{\n+\t  if (chunk > left)\n+\t    chunk = left;\n+\t}\n+      nend = start + chunk;\n+\n+      tmp = __sync_val_compare_and_swap (&ws->next_ull, start, nend);\n+      if (__builtin_expect (tmp == start, 1))\n+\tbreak;\n+\n+      start = tmp;\n+    }\n+\n+  *pstart = start;\n+  *pend = nend;\n+  return true;\n+}\n+#endif /* HAVE_SYNC_BUILTINS */\n+\n+\n+/* This function implements the GUIDED scheduling method.  Arguments are\n+   as for gomp_iter_ull_static_next.  This function must be called with the\n+   work share lock held.  */\n+\n+bool\n+gomp_iter_ull_guided_next_locked (gomp_ull *pstart, gomp_ull *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_team *team = thr->ts.team;\n+  gomp_ull nthreads = team ? team->nthreads : 1;\n+  gomp_ull n, q;\n+  gomp_ull start, end;\n+\n+  if (ws->next_ull == ws->end_ull)\n+    return false;\n+\n+  start = ws->next_ull;\n+  if (__builtin_expect (ws->mode, 0) == 0)\n+    n = (ws->end_ull - start) / ws->incr_ull;\n+  else\n+    n = (start - ws->end_ull) / -ws->incr_ull;\n+  q = (n + nthreads - 1) / nthreads;\n+\n+  if (q < ws->chunk_size_ull)\n+    q = ws->chunk_size_ull;\n+  if (q <= n)\n+    end = start + q * ws->incr_ull;\n+  else\n+    end = ws->end_ull;\n+\n+  ws->next_ull = end;\n+  *pstart = start;\n+  *pend = end;\n+  return true;\n+}\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+/* Similar, but doesn't require the lock held, and uses compare-and-swap\n+   instead.  Note that the only memory value that changes is ws->next_ull.  */\n+\n+bool\n+gomp_iter_ull_guided_next (gomp_ull *pstart, gomp_ull *pend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_work_share *ws = thr->ts.work_share;\n+  struct gomp_team *team = thr->ts.team;\n+  gomp_ull nthreads = team ? team->nthreads : 1;\n+  gomp_ull start, end, nend, incr;\n+  gomp_ull chunk_size;\n+\n+  start = ws->next_ull;\n+  end = ws->end_ull;\n+  incr = ws->incr_ull;\n+  chunk_size = ws->chunk_size_ull;\n+\n+  while (1)\n+    {\n+      gomp_ull n, q;\n+      gomp_ull tmp;\n+\n+      if (start == end)\n+\treturn false;\n+\n+      if (__builtin_expect (ws->mode, 0) == 0)\n+\tn = (end - start) / incr;\n+      else\n+\tn = (start - end) / -incr;\n+      q = (n + nthreads - 1) / nthreads;\n+\n+      if (q < chunk_size)\n+\tq = chunk_size;\n+      if (__builtin_expect (q <= n, 1))\n+\tnend = start + q * incr;\n+      else\n+\tnend = end;\n+\n+      tmp = __sync_val_compare_and_swap (&ws->next_ull, start, nend);\n+      if (__builtin_expect (tmp == start, 1))\n+\tbreak;\n+\n+      start = tmp;\n+    }\n+\n+  *pstart = start;\n+  *pend = nend;\n+  return true;\n+}\n+#endif /* HAVE_SYNC_BUILTINS */"}, {"sha": "66180122c1e81ae3b22fdfa1d7d60d1f1ae2f84f", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 309, "deletions": 78, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -50,17 +50,19 @@\n #include \"sem.h\"\n #include \"mutex.h\"\n #include \"bar.h\"\n+#include \"ptrlock.h\"\n \n \n /* This structure contains the data to control one work-sharing construct,\n    either a LOOP (FOR/DO) or a SECTIONS.  */\n \n enum gomp_schedule_type\n {\n+  GFS_RUNTIME,\n   GFS_STATIC,\n   GFS_DYNAMIC,\n   GFS_GUIDED,\n-  GFS_RUNTIME\n+  GFS_AUTO\n };\n \n struct gomp_work_share\n@@ -70,56 +72,94 @@ struct gomp_work_share\n      If this is a SECTIONS construct, this value will always be DYNAMIC.  */\n   enum gomp_schedule_type sched;\n \n-  /* This is the chunk_size argument to the SCHEDULE clause.  */\n-  long chunk_size;\n+  int mode;\n \n-  /* This is the iteration end point.  If this is a SECTIONS construct, \n-     this is the number of contained sections.  */\n-  long end;\n+  union {\n+    struct {\n+      /* This is the chunk_size argument to the SCHEDULE clause.  */\n+      long chunk_size;\n+\n+      /* This is the iteration end point.  If this is a SECTIONS construct,\n+\t this is the number of contained sections.  */\n+      long end;\n+\n+      /* This is the iteration step.  If this is a SECTIONS construct, this\n+\t is always 1.  */\n+      long incr;\n+    };\n+\n+    struct {\n+      /* The same as above, but for the unsigned long long loop variants.  */\n+      unsigned long long chunk_size_ull;\n+      unsigned long long end_ull;\n+      unsigned long long incr_ull;\n+    };\n+  };\n+\n+  /* This is a circular queue that details which threads will be allowed\n+     into the ordered region and in which order.  When a thread allocates\n+     iterations on which it is going to work, it also registers itself at\n+     the end of the array.  When a thread reaches the ordered region, it\n+     checks to see if it is the one at the head of the queue.  If not, it\n+     blocks on its RELEASE semaphore.  */\n+  unsigned *ordered_team_ids;\n+\n+  /* This is the number of threads that have registered themselves in\n+     the circular queue ordered_team_ids.  */\n+  unsigned ordered_num_used;\n+\n+  /* This is the team_id of the currently acknowledged owner of the ordered\n+     section, or -1u if the ordered section has not been acknowledged by\n+     any thread.  This is distinguished from the thread that is *allowed*\n+     to take the section next.  */\n+  unsigned ordered_owner;\n+\n+  /* This is the index into the circular queue ordered_team_ids of the\n+     current thread that's allowed into the ordered reason.  */\n+  unsigned ordered_cur;\n \n-  /* This is the iteration step.  If this is a SECTIONS construct, this\n-     is always 1.  */\n-  long incr;\n+  /* This is a chain of allocated gomp_work_share blocks, valid only\n+     in the first gomp_work_share struct in the block.  */\n+  struct gomp_work_share *next_alloc;\n+\n+  /* The above fields are written once during workshare initialization,\n+     or related to ordered worksharing.  Make sure the following fields\n+     are in a different cache line.  */\n \n   /* This lock protects the update of the following members.  */\n-  gomp_mutex_t lock;\n+  gomp_mutex_t lock __attribute__((aligned (64)));\n+\n+  /* This is the count of the number of threads that have exited the work\n+     share construct.  If the construct was marked nowait, they have moved on\n+     to other work; otherwise they're blocked on a barrier.  The last member\n+     of the team to exit the work share construct must deallocate it.  */\n+  unsigned threads_completed;\n \n   union {\n     /* This is the next iteration value to be allocated.  In the case of\n        GFS_STATIC loops, this the iteration start point and never changes.  */\n     long next;\n \n+    /* The same, but with unsigned long long type.  */\n+    unsigned long long next_ull;\n+\n     /* This is the returned data structure for SINGLE COPYPRIVATE.  */\n     void *copyprivate;\n   };\n \n-  /* This is the count of the number of threads that have exited the work\n-     share construct.  If the construct was marked nowait, they have moved on\n-     to other work; otherwise they're blocked on a barrier.  The last member\n-     of the team to exit the work share construct must deallocate it.  */\n-  unsigned threads_completed;\n-\n-  /* This is the index into the circular queue ordered_team_ids of the \n-     current thread that's allowed into the ordered reason.  */\n-  unsigned ordered_cur;\n-\n-  /* This is the number of threads that have registered themselves in\n-     the circular queue ordered_team_ids.  */\n-  unsigned ordered_num_used;\n+  union {\n+    /* Link to gomp_work_share struct for next work sharing construct\n+       encountered after this one.  */\n+    gomp_ptrlock_t next_ws;\n \n-  /* This is the team_id of the currently acknoledged owner of the ordered\n-     section, or -1u if the ordered section has not been acknowledged by\n-     any thread.  This is distinguished from the thread that is *allowed*\n-     to take the section next.  */\n-  unsigned ordered_owner;\n+    /* gomp_work_share structs are chained in the free work share cache\n+       through this.  */\n+    struct gomp_work_share *next_free;\n+  };\n \n-  /* This is a circular queue that details which threads will be allowed\n-     into the ordered region and in which order.  When a thread allocates\n-     iterations on which it is going to work, it also registers itself at\n-     the end of the array.  When a thread reaches the ordered region, it\n-     checks to see if it is the one at the head of the queue.  If not, it\n-     blocks on its RELEASE semaphore.  */\n-  unsigned ordered_team_ids[];\n+  /* If only few threads are in the team, ordered_team_ids can point\n+     to this array which fills the padding at the end of this struct.  */\n+  unsigned inline_ordered_team_ids[0];\n };\n \n /* This structure contains all of the thread-local data associated with \n@@ -133,21 +173,30 @@ struct gomp_team_state\n \n   /* This is the work share construct which this thread is currently\n      processing.  Recall that with NOWAIT, not all threads may be \n-     processing the same construct.  This value is NULL when there\n-     is no construct being processed.  */\n+     processing the same construct.  */\n   struct gomp_work_share *work_share;\n \n+  /* This is the previous work share construct or NULL if there wasn't any.\n+     When all threads are done with the current work sharing construct,\n+     the previous one can be freed.  The current one can't, as its\n+     next_ws field is used.  */\n+  struct gomp_work_share *last_work_share;\n+\n   /* This is the ID of this thread within the team.  This value is\n      guaranteed to be between 0 and N-1, where N is the number of\n      threads in the team.  */\n   unsigned team_id;\n \n-  /* The work share \"generation\" is a number that increases by one for\n-     each work share construct encountered in the dynamic flow of the\n-     program.  It is used to find the control data for the work share\n-     when encountering it for the first time.  This particular number\n-     reflects the generation of the work_share member of this struct.  */\n-  unsigned work_share_generation;\n+  /* Nesting level.  */\n+  unsigned level;\n+\n+  /* Active nesting level.  Only active parallel regions are counted.  */\n+  unsigned active_level;\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  /* Number of single stmts encountered.  */\n+  unsigned long single_count;\n+#endif\n \n   /* For GFS_RUNTIME loops that resolved to GFS_STATIC, this is the\n      trip number through the loop.  So first time a particular loop\n@@ -157,48 +206,118 @@ struct gomp_team_state\n   unsigned long static_trip;\n };\n \n-/* This structure describes a \"team\" of threads.  These are the threads\n-   that are spawned by a PARALLEL constructs, as well as the work sharing\n-   constructs that the team encounters.  */\n+/* These are the OpenMP 3.0 Internal Control Variables described in\n+   section 2.3.1.  Those described as having one copy per task are\n+   stored within the structure; those described as having one copy\n+   for the whole program are (naturally) global variables.  */\n \n-struct gomp_team\n+struct gomp_task_icv\n {\n-  /* This lock protects access to the following work shares data structures.  */\n-  gomp_mutex_t work_share_lock;\n+  unsigned long nthreads_var;\n+  enum gomp_schedule_type run_sched_var;\n+  int run_sched_modifier;\n+  bool dyn_var;\n+  bool nest_var;\n+};\n \n-  /* This is a dynamically sized array containing pointers to the control\n-     structs for all \"live\" work share constructs.  Here \"live\" means that\n-     the construct has been encountered by at least one thread, and not\n-     completed by all threads.  */\n-  struct gomp_work_share **work_shares;\n+extern struct gomp_task_icv gomp_global_icv;\n+extern unsigned long gomp_thread_limit_var;\n+extern unsigned long gomp_remaining_threads_count;\n+#ifndef HAVE_SYNC_BUILTINS\n+extern gomp_mutex_t gomp_remaining_threads_lock;\n+#endif\n+extern unsigned long gomp_max_active_levels_var;\n+extern unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n+extern unsigned long gomp_available_cpus, gomp_managed_threads;\n \n-  /* The work_shares array is indexed by \"generation & generation_mask\".\n-     The mask will be 2**N - 1, where 2**N is the size of the array.  */\n-  unsigned generation_mask;\n+enum gomp_task_kind\n+{\n+  GOMP_TASK_IMPLICIT,\n+  GOMP_TASK_IFFALSE,\n+  GOMP_TASK_WAITING,\n+  GOMP_TASK_TIED\n+};\n \n-  /* These two values define the bounds of the elements of the work_shares\n-     array that are currently in use.  */\n-  unsigned oldest_live_gen;\n-  unsigned num_live_gen;\n+/* This structure describes a \"task\" to be run by a thread.  */\n \n+struct gomp_task\n+{\n+  struct gomp_task *parent;\n+  struct gomp_task *children;\n+  struct gomp_task *next_child;\n+  struct gomp_task *prev_child;\n+  struct gomp_task *next_queue;\n+  struct gomp_task *prev_queue;\n+  struct gomp_task_icv icv;\n+  void (*fn) (void *);\n+  void *fn_data;\n+  enum gomp_task_kind kind;\n+  bool in_taskwait;\n+  gomp_sem_t taskwait_sem;\n+};\n+\n+/* This structure describes a \"team\" of threads.  These are the threads\n+   that are spawned by a PARALLEL constructs, as well as the work sharing\n+   constructs that the team encounters.  */\n+\n+struct gomp_team\n+{\n   /* This is the number of threads in the current team.  */\n   unsigned nthreads;\n \n+  /* This is number of gomp_work_share structs that have been allocated\n+     as a block last time.  */\n+  unsigned work_share_chunk;\n+\n   /* This is the saved team state that applied to a master thread before\n      the current thread was created.  */\n   struct gomp_team_state prev_ts;\n \n-  /* This barrier is used for most synchronization of the team.  */\n-  gomp_barrier_t barrier;\n-\n   /* This semaphore should be used by the master thread instead of its\n      \"native\" semaphore in the thread structure.  Required for nested\n      parallels, as the master is a member of two teams.  */\n   gomp_sem_t master_release;\n \n-  /* This array contains pointers to the release semaphore of the threads\n-     in the team.  */\n-  gomp_sem_t *ordered_release[];\n+  /* This points to an array with pointers to the release semaphore\n+     of the threads in the team.  */\n+  gomp_sem_t **ordered_release;\n+\n+  /* List of gomp_work_share structs chained through next_free fields.\n+     This is populated and taken off only by the first thread in the\n+     team encountering a new work sharing construct, in a critical\n+     section.  */\n+  struct gomp_work_share *work_share_list_alloc;\n+\n+  /* List of gomp_work_share structs freed by free_work_share.  New\n+     entries are atomically added to the start of the list, and\n+     alloc_work_share can safely only move all but the first entry\n+     to work_share_list alloc, as free_work_share can happen concurrently\n+     with alloc_work_share.  */\n+  struct gomp_work_share *work_share_list_free;\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  /* Number of simple single regions encountered by threads in this\n+     team.  */\n+  unsigned long single_count;\n+#else\n+  /* Mutex protecting addition of workshares to work_share_list_free.  */\n+  gomp_mutex_t work_share_list_free_lock;\n+#endif\n+\n+  /* This barrier is used for most synchronization of the team.  */\n+  gomp_barrier_t barrier;\n+\n+  /* Initial work shares, to avoid allocating any gomp_work_share\n+     structs in the common case.  */\n+  struct gomp_work_share work_shares[8];\n+\n+  gomp_mutex_t task_lock;\n+  struct gomp_task *task_queue;\n+  int task_count;\n+  int task_running_count;\n+\n+  /* This array contains structures for implicit tasks.  */\n+  struct gomp_task implicit_task[];\n };\n \n /* This structure contains all data that is private to libgomp and is\n@@ -214,8 +333,28 @@ struct gomp_thread\n      is NULL only if the thread is idle.  */\n   struct gomp_team_state ts;\n \n+  /* This is the task that the thread is currently executing.  */\n+  struct gomp_task *task;\n+\n   /* This semaphore is used for ordered loops.  */\n   gomp_sem_t release;\n+\n+  /* user pthread thread pool */\n+  struct gomp_thread_pool *thread_pool;\n+};\n+\n+\n+struct gomp_thread_pool\n+{\n+  /* This array manages threads spawned from the top level, which will\n+     return to the idle loop once the current PARALLEL construct ends.  */\n+  struct gomp_thread **threads;\n+  unsigned threads_size;\n+  unsigned threads_used;\n+  struct gomp_team *last_team;\n+\n+  /* This barrier holds and releases threads waiting in threads.  */\n+  gomp_barrier_t threads_dock;\n };\n \n /* ... and here is that TLS data.  */\n@@ -234,14 +373,20 @@ static inline struct gomp_thread *gomp_thread (void)\n }\n #endif\n \n-/* These are the OpenMP 2.5 internal control variables described in\n-   section 2.3.  At least those that correspond to environment variables.  */\n+extern struct gomp_task_icv *gomp_new_icv (void);\n+\n+/* Here's how to access the current copy of the ICVs.  */\n \n-extern unsigned long gomp_nthreads_var;\n-extern bool gomp_dyn_var;\n-extern bool gomp_nest_var;\n-extern enum gomp_schedule_type gomp_run_sched_var;\n-extern unsigned long gomp_run_sched_chunk;\n+static inline struct gomp_task_icv *gomp_icv (bool write)\n+{\n+  struct gomp_task *task = gomp_thread ()->task;\n+  if (task)\n+    return &task->icv;\n+  else if (write)\n+    return gomp_new_icv ();\n+  else\n+    return &gomp_global_icv;\n+}\n \n /* The attributes to be used during thread creation.  */\n extern pthread_attr_t gomp_thread_attr;\n@@ -286,6 +431,22 @@ extern bool gomp_iter_dynamic_next (long *, long *);\n extern bool gomp_iter_guided_next (long *, long *);\n #endif\n \n+/* iter_ull.c */\n+\n+extern int gomp_iter_ull_static_next (unsigned long long *,\n+\t\t\t\t      unsigned long long *);\n+extern bool gomp_iter_ull_dynamic_next_locked (unsigned long long *,\n+\t\t\t\t\t       unsigned long long *);\n+extern bool gomp_iter_ull_guided_next_locked (unsigned long long *,\n+\t\t\t\t\t      unsigned long long *);\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+extern bool gomp_iter_ull_dynamic_next (unsigned long long *,\n+\t\t\t\t\tunsigned long long *);\n+extern bool gomp_iter_ull_guided_next (unsigned long long *,\n+\t\t\t\t       unsigned long long *);\n+#endif\n+\n /* ordered.c */\n \n extern void gomp_ordered_first (void);\n@@ -297,26 +458,49 @@ extern void gomp_ordered_sync (void);\n \n /* parallel.c */\n \n-extern unsigned gomp_resolve_num_threads (unsigned);\n+extern unsigned gomp_resolve_num_threads (unsigned, unsigned);\n \n /* proc.c (in config/) */\n \n extern void gomp_init_num_threads (void);\n extern unsigned gomp_dynamic_max_threads (void);\n \n+/* task.c */\n+\n+extern void gomp_init_task (struct gomp_task *, struct gomp_task *,\n+\t\t\t    struct gomp_task_icv *);\n+extern void gomp_end_task (void);\n+extern void gomp_barrier_handle_tasks (gomp_barrier_state_t);\n+\n+static void inline\n+gomp_finish_task (struct gomp_task *task)\n+{\n+  gomp_sem_destroy (&task->taskwait_sem);\n+}\n+\n /* team.c */\n \n+extern struct gomp_team *gomp_new_team (unsigned);\n extern void gomp_team_start (void (*) (void *), void *, unsigned,\n-\t\t\t     struct gomp_work_share *);\n+\t\t\t     struct gomp_team *);\n extern void gomp_team_end (void);\n \n /* work.c */\n \n-extern struct gomp_work_share * gomp_new_work_share (bool, unsigned);\n+extern void gomp_init_work_share (struct gomp_work_share *, bool, unsigned);\n+extern void gomp_fini_work_share (struct gomp_work_share *);\n extern bool gomp_work_share_start (bool);\n extern void gomp_work_share_end (void);\n extern void gomp_work_share_end_nowait (void);\n \n+static inline void\n+gomp_work_share_init_done (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  if (__builtin_expect (thr->ts.last_work_share != NULL, 1))\n+    gomp_ptrlock_set (&thr->ts.last_work_share->next_ws, thr->ts.work_share);\n+}\n+\n #ifdef HAVE_ATTRIBUTE_VISIBILITY\n # pragma GCC visibility pop\n #endif\n@@ -329,6 +513,53 @@ extern void gomp_work_share_end_nowait (void);\n #define _LIBGOMP_OMP_LOCK_DEFINED 1\n #include \"omp.h.in\"\n \n+#if !defined (HAVE_ATTRIBUTE_VISIBILITY) \\\n+    || !defined (HAVE_ATTRIBUTE_ALIAS) \\\n+    || !defined (PIC)\n+# undef LIBGOMP_GNU_SYMBOL_VERSIONING\n+#endif\n+\n+#ifdef LIBGOMP_GNU_SYMBOL_VERSIONING\n+extern void gomp_init_lock_30 (omp_lock_t *) __GOMP_NOTHROW;\n+extern void gomp_destroy_lock_30 (omp_lock_t *) __GOMP_NOTHROW;\n+extern void gomp_set_lock_30 (omp_lock_t *) __GOMP_NOTHROW;\n+extern void gomp_unset_lock_30 (omp_lock_t *) __GOMP_NOTHROW;\n+extern int gomp_test_lock_30 (omp_lock_t *) __GOMP_NOTHROW;\n+extern void gomp_init_nest_lock_30 (omp_nest_lock_t *) __GOMP_NOTHROW;\n+extern void gomp_destroy_nest_lock_30 (omp_nest_lock_t *) __GOMP_NOTHROW;\n+extern void gomp_set_nest_lock_30 (omp_nest_lock_t *) __GOMP_NOTHROW;\n+extern void gomp_unset_nest_lock_30 (omp_nest_lock_t *) __GOMP_NOTHROW;\n+extern int gomp_test_nest_lock_30 (omp_nest_lock_t *) __GOMP_NOTHROW;\n+\n+extern void gomp_init_lock_25 (omp_lock_25_t *) __GOMP_NOTHROW;\n+extern void gomp_destroy_lock_25 (omp_lock_25_t *) __GOMP_NOTHROW;\n+extern void gomp_set_lock_25 (omp_lock_25_t *) __GOMP_NOTHROW;\n+extern void gomp_unset_lock_25 (omp_lock_25_t *) __GOMP_NOTHROW;\n+extern int gomp_test_lock_25 (omp_lock_25_t *) __GOMP_NOTHROW;\n+extern void gomp_init_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n+extern void gomp_destroy_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n+extern void gomp_set_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n+extern void gomp_unset_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n+extern int gomp_test_nest_lock_25 (omp_nest_lock_25_t *) __GOMP_NOTHROW;\n+\n+# define strong_alias(fn, al) \\\n+  extern __typeof (fn) al __attribute__ ((alias (#fn)));\n+# define omp_lock_symver(fn) \\\n+  __asm (\".symver g\" #fn \"_30, \" #fn \"@@OMP_3.0\"); \\\n+  __asm (\".symver g\" #fn \"_25, \" #fn \"@OMP_1.0\");\n+#else\n+# define gomp_init_lock_30 omp_init_lock\n+# define gomp_destroy_lock_30 omp_destroy_lock\n+# define gomp_set_lock_30 omp_set_lock\n+# define gomp_unset_lock_30 omp_unset_lock\n+# define gomp_test_lock_30 omp_test_lock\n+# define gomp_init_nest_lock_30 omp_init_nest_lock\n+# define gomp_destroy_nest_lock_30 omp_destroy_nest_lock\n+# define gomp_set_nest_lock_30 omp_set_nest_lock\n+# define gomp_unset_nest_lock_30 omp_unset_nest_lock\n+# define gomp_test_nest_lock_30 omp_test_nest_lock\n+#endif\n+\n #ifdef HAVE_ATTRIBUTE_VISIBILITY\n # define attribute_hidden __attribute__ ((visibility (\"hidden\")))\n #else"}, {"sha": "e6c12fa001906074fd6102eb492ca0e573bb93ae", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -55,6 +55,53 @@ OMP_2.0 {\n \tomp_get_wtime_;\n } OMP_1.0;\n \n+OMP_3.0 {\n+  global:\n+\tomp_set_schedule;\n+\tomp_set_schedule_;\n+\tomp_set_schedule_8_;\n+\tomp_get_schedule;\n+\tomp_get_schedule_;\n+\tomp_get_schedule_8_;\n+\tomp_get_thread_limit;\n+\tomp_get_thread_limit_;\n+\tomp_set_max_active_levels;\n+\tomp_set_max_active_levels_;\n+\tomp_set_max_active_levels_8_;\n+\tomp_get_max_active_levels;\n+\tomp_get_max_active_levels_;\n+\tomp_get_level;\n+\tomp_get_level_;\n+\tomp_get_ancestor_thread_num;\n+\tomp_get_ancestor_thread_num_;\n+\tomp_get_ancestor_thread_num_8_;\n+\tomp_get_team_size;\n+\tomp_get_team_size_;\n+\tomp_get_team_size_8_;\n+\tomp_get_active_level;\n+\tomp_get_active_level_;\n+\tomp_init_lock;\n+\tomp_init_nest_lock;\n+\tomp_destroy_lock;\n+\tomp_destroy_nest_lock;\n+\tomp_set_lock;\n+\tomp_set_nest_lock;\n+\tomp_unset_lock;\n+\tomp_unset_nest_lock;\n+\tomp_test_lock;\n+\tomp_test_nest_lock;\n+\tomp_destroy_lock_;\n+\tomp_destroy_nest_lock_;\n+\tomp_init_lock_;\n+\tomp_init_nest_lock_;\n+\tomp_set_lock_;\n+\tomp_set_nest_lock_;\n+\tomp_test_lock_;\n+\tomp_test_nest_lock_;\n+\tomp_unset_lock_;\n+\tomp_unset_nest_lock_;\n+} OMP_2.0;\n+\n GOMP_1.0 {\n   global:\n \tGOMP_atomic_end;\n@@ -70,16 +117,12 @@ GOMP_1.0 {\n \tGOMP_loop_end_nowait;\n \tGOMP_loop_guided_next;\n \tGOMP_loop_guided_start;\n-\tGOMP_loop_ordered_dynamic_first;\n \tGOMP_loop_ordered_dynamic_next;\n \tGOMP_loop_ordered_dynamic_start;\n-\tGOMP_loop_ordered_guided_first;\n \tGOMP_loop_ordered_guided_next;\n \tGOMP_loop_ordered_guided_start;\n-\tGOMP_loop_ordered_runtime_first;\n \tGOMP_loop_ordered_runtime_next;\n \tGOMP_loop_ordered_runtime_start;\n-\tGOMP_loop_ordered_static_first;\n \tGOMP_loop_ordered_static_next;\n \tGOMP_loop_ordered_static_start;\n \tGOMP_loop_runtime_next;\n@@ -103,3 +146,25 @@ GOMP_1.0 {\n \tGOMP_single_copy_start;\n \tGOMP_single_start;\n };\n+\n+GOMP_2.0 {\n+  global:\n+\tGOMP_task;\n+\tGOMP_taskwait;\n+\tGOMP_loop_ull_dynamic_next;\n+\tGOMP_loop_ull_dynamic_start;\n+\tGOMP_loop_ull_guided_next;\n+\tGOMP_loop_ull_guided_start;\n+\tGOMP_loop_ull_ordered_dynamic_next;\n+\tGOMP_loop_ull_ordered_dynamic_start;\n+\tGOMP_loop_ull_ordered_guided_next;\n+\tGOMP_loop_ull_ordered_guided_start;\n+\tGOMP_loop_ull_ordered_runtime_next;\n+\tGOMP_loop_ull_ordered_runtime_start;\n+\tGOMP_loop_ull_ordered_static_next;\n+\tGOMP_loop_ull_ordered_static_start;\n+\tGOMP_loop_ull_runtime_next;\n+\tGOMP_loop_ull_runtime_start;\n+\tGOMP_loop_ull_static_next;\n+\tGOMP_loop_ull_static_start;\n+} GOMP_1.0;"}, {"sha": "ecd92a8060e6dddeff526ae063afaf478c83710f", "filename": "libgomp/libgomp_f.h.in", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp_f.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp_f.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_f.h.in?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -53,6 +53,26 @@ typedef union { omp_nest_lock_t *lock; uint64_t u; } *omp_nest_lock_arg_t;\n # define omp_nest_lock_arg(arg) ((arg)->lock)\n # endif\n \n+#if (@OMP_LOCK_25_SIZE@ == @OMP_LOCK_25_KIND@) \\\n+    && (@OMP_LOCK_25_ALIGN@ <= @OMP_LOCK_25_SIZE@)\n+# define OMP_LOCK_25_DIRECT\n+typedef omp_lock_25_t *omp_lock_25_arg_t;\n+# define omp_lock_25_arg(arg) (arg)\n+#else\n+typedef union { omp_lock_25_t *lock; uint64_t u; } *omp_lock_25_arg_t;\n+# define omp_lock_25_arg(arg) ((arg)->lock)\n+# endif\n+\n+#if (@OMP_NEST_LOCK_25_SIZE@ == @OMP_NEST_LOCK_25_KIND@) \\\n+    && (@OMP_NEST_LOCK_25_ALIGN@ <= @OMP_NEST_LOCK_25_SIZE@)\n+# define OMP_NEST_LOCK_25_DIRECT\n+typedef omp_nest_lock_25_t *omp_nest_lock_25_arg_t;\n+# define omp_nest_lock_25_arg(arg) (arg)\n+#else\n+typedef union { omp_nest_lock_25_t *lock; uint64_t u; } *omp_nest_lock_25_arg_t;\n+# define omp_nest_lock_25_arg(arg) ((arg)->lock)\n+# endif\n+\n static inline void\n omp_check_defines (void)\n {\n@@ -63,6 +83,14 @@ omp_check_defines (void)\n \t     || @OMP_LOCK_KIND@ != sizeof (*(omp_lock_arg_t) 0)\n \t     || @OMP_NEST_LOCK_KIND@ != sizeof (*(omp_nest_lock_arg_t) 0))\n \t    ? -1 : 1] __attribute__ ((__unused__));\n+  char test2[(@OMP_LOCK_25_SIZE@ != sizeof (omp_lock_25_t)\n+\t     || @OMP_LOCK_25_ALIGN@ != __alignof (omp_lock_25_t)\n+\t     || @OMP_NEST_LOCK_25_SIZE@ != sizeof (omp_nest_lock_25_t)\n+\t     || @OMP_NEST_LOCK_25_ALIGN@ != __alignof (omp_nest_lock_25_t)\n+\t     || @OMP_LOCK_25_KIND@ != sizeof (*(omp_lock_25_arg_t) 0)\n+\t     || @OMP_NEST_LOCK_25_KIND@\n+\t\t!= sizeof (*(omp_nest_lock_25_arg_t) 0))\n+\t    ? -1 : 1] __attribute__ ((__unused__));\n }\n \n #endif /* LIBGOMP_F_H */"}, {"sha": "322fd4f23d12e2b12ecff7460c97a8fb8da005e6", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -83,6 +83,74 @@ extern void GOMP_parallel_loop_runtime_start (void (*)(void *), void *,\n extern void GOMP_loop_end (void);\n extern void GOMP_loop_end_nowait (void);\n \n+/* loop_ull.c */\n+\n+extern bool GOMP_loop_ull_static_start (bool, unsigned long long,\n+\t\t\t\t\tunsigned long long,\n+\t\t\t\t\tunsigned long long,\n+\t\t\t\t\tunsigned long long,\n+\t\t\t\t\tunsigned long long *,\n+\t\t\t\t\tunsigned long long *);\n+extern bool GOMP_loop_ull_dynamic_start (bool, unsigned long long,\n+\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t unsigned long long *);\n+extern bool GOMP_loop_ull_guided_start (bool, unsigned long long,\n+\t\t\t\t\tunsigned long long,\n+\t\t\t\t\tunsigned long long,\n+\t\t\t\t\tunsigned long long,\n+\t\t\t\t\tunsigned long long *,\n+\t\t\t\t\tunsigned long long *);\n+extern bool GOMP_loop_ull_runtime_start (bool, unsigned long long,\n+\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t unsigned long long *);\n+\n+extern bool GOMP_loop_ull_ordered_static_start (bool, unsigned long long,\n+\t\t\t\t\t\tunsigned long long,\n+\t\t\t\t\t\tunsigned long long,\n+\t\t\t\t\t\tunsigned long long,\n+\t\t\t\t\t\tunsigned long long *,\n+\t\t\t\t\t\tunsigned long long *);\n+extern bool GOMP_loop_ull_ordered_dynamic_start (bool, unsigned long long,\n+\t\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t\t unsigned long long *);\n+extern bool GOMP_loop_ull_ordered_guided_start (bool, unsigned long long,\n+\t\t\t\t\t\tunsigned long long,\n+\t\t\t\t\t\tunsigned long long,\n+\t\t\t\t\t\tunsigned long long,\n+\t\t\t\t\t\tunsigned long long *,\n+\t\t\t\t\t\tunsigned long long *);\n+extern bool GOMP_loop_ull_ordered_runtime_start (bool, unsigned long long,\n+\t\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t\t unsigned long long,\n+\t\t\t\t\t\t unsigned long long *,\n+\t\t\t\t\t\t unsigned long long *);\n+\n+extern bool GOMP_loop_ull_static_next (unsigned long long *,\n+\t\t\t\t       unsigned long long *);\n+extern bool GOMP_loop_ull_dynamic_next (unsigned long long *,\n+\t\t\t\t\tunsigned long long *);\n+extern bool GOMP_loop_ull_guided_next (unsigned long long *,\n+\t\t\t\t       unsigned long long *);\n+extern bool GOMP_loop_ull_runtime_next (unsigned long long *,\n+\t\t\t\t\tunsigned long long *);\n+\n+extern bool GOMP_loop_ull_ordered_static_next (unsigned long long *,\n+\t\t\t\t\t       unsigned long long *);\n+extern bool GOMP_loop_ull_ordered_dynamic_next (unsigned long long *,\n+\t\t\t\t\t\tunsigned long long *);\n+extern bool GOMP_loop_ull_ordered_guided_next (unsigned long long *,\n+\t\t\t\t\t       unsigned long long *);\n+extern bool GOMP_loop_ull_ordered_runtime_next (unsigned long long *,\n+\t\t\t\t\t\tunsigned long long *);\n+\n /* ordered.c */\n \n extern void GOMP_ordered_start (void);\n@@ -93,6 +161,12 @@ extern void GOMP_ordered_end (void);\n extern void GOMP_parallel_start (void (*) (void *), void *, unsigned);\n extern void GOMP_parallel_end (void);\n \n+/* team.c */\n+\n+extern void GOMP_task (void (*) (void *), void *, void (*) (void *, void *),\n+\t\t       long, long, bool, unsigned);\n+extern void GOMP_taskwait (void);\n+\n /* sections.c */\n \n extern unsigned GOMP_sections_start (unsigned);"}, {"sha": "1cea334bcbfca3a13c7194e5717add2014f93855", "filename": "libgomp/loop.c", "status": "modified", "additions": 100, "deletions": 30, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -27,8 +27,9 @@\n \n /* This file handles the LOOP (FOR/DO) construct.  */\n \n-#include \"libgomp.h\"\n+#include <limits.h>\n #include <stdlib.h>\n+#include \"libgomp.h\"\n \n \n /* Initialize the given work share construct from the given arguments.  */\n@@ -44,6 +45,39 @@ gomp_loop_init (struct gomp_work_share *ws, long start, long end, long incr,\n \t    ? start : end;\n   ws->incr = incr;\n   ws->next = start;\n+  if (sched == GFS_DYNAMIC)\n+    {\n+      ws->chunk_size *= incr;\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+      {\n+\t/* For dynamic scheduling prepare things to make each iteration\n+\t   faster.  */\n+\tstruct gomp_thread *thr = gomp_thread ();\n+\tstruct gomp_team *team = thr->ts.team;\n+\tlong nthreads = team ? team->nthreads : 1;\n+\n+\tif (__builtin_expect (incr > 0, 1))\n+\t  {\n+\t    /* Cheap overflow protection.  */\n+\t    if (__builtin_expect ((nthreads | ws->chunk_size)\n+\t\t\t\t  >= 1UL << (sizeof (long)\n+\t\t\t\t\t     * __CHAR_BIT__ / 2 - 1), 0))\n+\t      ws->mode = 0;\n+\t    else\n+\t      ws->mode = ws->end < (LONG_MAX\n+\t\t\t\t    - (nthreads + 1) * ws->chunk_size);\n+\t  }\n+\t/* Cheap overflow protection.  */\n+\telse if (__builtin_expect ((nthreads | -ws->chunk_size)\n+\t\t\t\t   >= 1UL << (sizeof (long)\n+\t\t\t\t\t      * __CHAR_BIT__ / 2 - 1), 0))\n+\t  ws->mode = 0;\n+\telse\n+\t  ws->mode = ws->end > (nthreads + 1) * -ws->chunk_size - LONG_MAX;\n+      }\n+#endif\n+    }\n }\n \n /* The *_start routines are called when first encountering a loop construct\n@@ -68,10 +102,13 @@ gomp_loop_static_start (long start, long end, long incr, long chunk_size,\n {\n   struct gomp_thread *thr = gomp_thread ();\n \n+  thr->ts.static_trip = 0;\n   if (gomp_work_share_start (false))\n-    gomp_loop_init (thr->ts.work_share, start, end, incr,\n-\t\t    GFS_STATIC, chunk_size);\n-  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+    {\n+      gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t      GFS_STATIC, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n \n   return !gomp_iter_static_next (istart, iend);\n }\n@@ -84,13 +121,16 @@ gomp_loop_dynamic_start (long start, long end, long incr, long chunk_size,\n   bool ret;\n \n   if (gomp_work_share_start (false))\n-    gomp_loop_init (thr->ts.work_share, start, end, incr,\n-\t\t    GFS_DYNAMIC, chunk_size);\n+    {\n+      gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t      GFS_DYNAMIC, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n \n #ifdef HAVE_SYNC_BUILTINS\n-  gomp_mutex_unlock (&thr->ts.work_share->lock);\n   ret = gomp_iter_dynamic_next (istart, iend);\n #else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n   ret = gomp_iter_dynamic_next_locked (istart, iend);\n   gomp_mutex_unlock (&thr->ts.work_share->lock);\n #endif\n@@ -106,13 +146,16 @@ gomp_loop_guided_start (long start, long end, long incr, long chunk_size,\n   bool ret;\n \n   if (gomp_work_share_start (false))\n-    gomp_loop_init (thr->ts.work_share, start, end, incr,\n-\t\t    GFS_GUIDED, chunk_size);\n+    {\n+      gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t      GFS_GUIDED, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n \n #ifdef HAVE_SYNC_BUILTINS\n-  gomp_mutex_unlock (&thr->ts.work_share->lock);\n   ret = gomp_iter_guided_next (istart, iend);\n #else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n   ret = gomp_iter_guided_next_locked (istart, iend);\n   gomp_mutex_unlock (&thr->ts.work_share->lock);\n #endif\n@@ -124,17 +167,22 @@ bool\n GOMP_loop_runtime_start (long start, long end, long incr,\n \t\t\t long *istart, long *iend)\n {\n-  switch (gomp_run_sched_var)\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  switch (icv->run_sched_var)\n     {\n     case GFS_STATIC:\n-      return gomp_loop_static_start (start, end, incr, gomp_run_sched_chunk,\n+      return gomp_loop_static_start (start, end, incr, icv->run_sched_modifier,\n \t\t\t\t     istart, iend);\n     case GFS_DYNAMIC:\n-      return gomp_loop_dynamic_start (start, end, incr, gomp_run_sched_chunk,\n+      return gomp_loop_dynamic_start (start, end, incr, icv->run_sched_modifier,\n \t\t\t\t      istart, iend);\n     case GFS_GUIDED:\n-      return gomp_loop_guided_start (start, end, incr, gomp_run_sched_chunk,\n+      return gomp_loop_guided_start (start, end, incr, icv->run_sched_modifier,\n \t\t\t\t     istart, iend);\n+    case GFS_AUTO:\n+      /* For now map to schedule(static), later on we could play with feedback\n+\t driven choice.  */\n+      return gomp_loop_static_start (start, end, incr, 0, istart, iend);\n     default:\n       abort ();\n     }\n@@ -149,13 +197,14 @@ gomp_loop_ordered_static_start (long start, long end, long incr,\n {\n   struct gomp_thread *thr = gomp_thread ();\n \n+  thr->ts.static_trip = 0;\n   if (gomp_work_share_start (true))\n     {\n       gomp_loop_init (thr->ts.work_share, start, end, incr,\n \t\t      GFS_STATIC, chunk_size);\n       gomp_ordered_static_init ();\n+      gomp_work_share_init_done ();\n     }\n-  gomp_mutex_unlock (&thr->ts.work_share->lock);\n \n   return !gomp_iter_static_next (istart, iend);\n }\n@@ -168,8 +217,14 @@ gomp_loop_ordered_dynamic_start (long start, long end, long incr,\n   bool ret;\n \n   if (gomp_work_share_start (true))\n-    gomp_loop_init (thr->ts.work_share, start, end, incr,\n-\t\t    GFS_DYNAMIC, chunk_size);\n+    {\n+      gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t      GFS_DYNAMIC, chunk_size);\n+      gomp_mutex_lock (&thr->ts.work_share->lock);\n+      gomp_work_share_init_done ();\n+    }\n+  else\n+    gomp_mutex_lock (&thr->ts.work_share->lock);\n \n   ret = gomp_iter_dynamic_next_locked (istart, iend);\n   if (ret)\n@@ -187,8 +242,14 @@ gomp_loop_ordered_guided_start (long start, long end, long incr,\n   bool ret;\n \n   if (gomp_work_share_start (true))\n-    gomp_loop_init (thr->ts.work_share, start, end, incr,\n-\t\t    GFS_GUIDED, chunk_size);\n+    {\n+      gomp_loop_init (thr->ts.work_share, start, end, incr,\n+\t\t      GFS_GUIDED, chunk_size);\n+      gomp_mutex_lock (&thr->ts.work_share->lock);\n+      gomp_work_share_init_done ();\n+    }\n+  else\n+    gomp_mutex_lock (&thr->ts.work_share->lock);\n \n   ret = gomp_iter_guided_next_locked (istart, iend);\n   if (ret)\n@@ -202,20 +263,26 @@ bool\n GOMP_loop_ordered_runtime_start (long start, long end, long incr,\n \t\t\t\t long *istart, long *iend)\n {\n-  switch (gomp_run_sched_var)\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  switch (icv->run_sched_var)\n     {\n     case GFS_STATIC:\n       return gomp_loop_ordered_static_start (start, end, incr,\n-\t\t\t\t\t     gomp_run_sched_chunk,\n+\t\t\t\t\t     icv->run_sched_modifier,\n \t\t\t\t\t     istart, iend);\n     case GFS_DYNAMIC:\n       return gomp_loop_ordered_dynamic_start (start, end, incr,\n-\t\t\t\t\t      gomp_run_sched_chunk,\n+\t\t\t\t\t      icv->run_sched_modifier,\n \t\t\t\t\t      istart, iend);\n     case GFS_GUIDED:\n       return gomp_loop_ordered_guided_start (start, end, incr,\n-\t\t\t\t\t     gomp_run_sched_chunk,\n+\t\t\t\t\t     icv->run_sched_modifier,\n \t\t\t\t\t     istart, iend);\n+    case GFS_AUTO:\n+      /* For now map to schedule(static), later on we could play with feedback\n+\t driven choice.  */\n+      return gomp_loop_ordered_static_start (start, end, incr,\n+\t\t\t\t\t     0, istart, iend);\n     default:\n       abort ();\n     }\n@@ -279,6 +346,7 @@ GOMP_loop_runtime_next (long *istart, long *iend)\n   switch (thr->ts.work_share->sched)\n     {\n     case GFS_STATIC:\n+    case GFS_AUTO:\n       return gomp_loop_static_next (istart, iend);\n     case GFS_DYNAMIC:\n       return gomp_loop_dynamic_next (istart, iend);\n@@ -356,6 +424,7 @@ GOMP_loop_ordered_runtime_next (long *istart, long *iend)\n   switch (thr->ts.work_share->sched)\n     {\n     case GFS_STATIC:\n+    case GFS_AUTO:\n       return gomp_loop_ordered_static_next (istart, iend);\n     case GFS_DYNAMIC:\n       return gomp_loop_ordered_dynamic_next (istart, iend);\n@@ -375,12 +444,12 @@ gomp_parallel_loop_start (void (*fn) (void *), void *data,\n \t\t\t  long incr, enum gomp_schedule_type sched,\n \t\t\t  long chunk_size)\n {\n-  struct gomp_work_share *ws;\n+  struct gomp_team *team;\n \n-  num_threads = gomp_resolve_num_threads (num_threads);\n-  ws = gomp_new_work_share (false, num_threads);\n-  gomp_loop_init (ws, start, end, incr, sched, chunk_size);\n-  gomp_team_start (fn, data, num_threads, ws);\n+  num_threads = gomp_resolve_num_threads (num_threads, 0);\n+  team = gomp_new_team (num_threads);\n+  gomp_loop_init (&team->work_shares[0], start, end, incr, sched, chunk_size);\n+  gomp_team_start (fn, data, num_threads, team);\n }\n \n void\n@@ -415,8 +484,9 @@ GOMP_parallel_loop_runtime_start (void (*fn) (void *), void *data,\n \t\t\t\t  unsigned num_threads, long start, long end,\n \t\t\t\t  long incr)\n {\n+  struct gomp_task_icv *icv = gomp_icv (false);\n   gomp_parallel_loop_start (fn, data, num_threads, start, end, incr,\n-\t\t\t    gomp_run_sched_var, gomp_run_sched_chunk);\n+\t\t\t    icv->run_sched_var, icv->run_sched_modifier);\n }\n \n /* The GOMP_loop_end* routines are called after the thread is told that"}, {"sha": "7dab05326f9eae9443313071f58d0798d643e86f", "filename": "libgomp/loop_ull.c", "status": "added", "additions": 565, "deletions": 0, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Floop_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Floop_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Floop_ull.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,565 @@\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License\n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file handles the LOOP (FOR/DO) construct.  */\n+\n+#include <limits.h>\n+#include <stdlib.h>\n+#include \"libgomp.h\"\n+\n+typedef unsigned long long gomp_ull;\n+\n+/* Initialize the given work share construct from the given arguments.  */\n+\n+static inline void\n+gomp_loop_ull_init (struct gomp_work_share *ws, bool up, gomp_ull start,\n+\t\t    gomp_ull end, gomp_ull incr, enum gomp_schedule_type sched,\n+\t\t    gomp_ull chunk_size)\n+{\n+  ws->sched = sched;\n+  ws->chunk_size_ull = chunk_size;\n+  /* Canonicalize loops that have zero iterations to ->next == ->end.  */\n+  ws->end_ull = ((up && start > end) || (!up && start < end))\n+\t\t? start : end;\n+  ws->incr_ull = incr;\n+  ws->next_ull = start;\n+  ws->mode = 0;\n+  if (sched == GFS_DYNAMIC)\n+    {\n+      ws->chunk_size_ull *= incr;\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+      {\n+\t/* For dynamic scheduling prepare things to make each iteration\n+\t   faster.  */\n+\tstruct gomp_thread *thr = gomp_thread ();\n+\tstruct gomp_team *team = thr->ts.team;\n+\tlong nthreads = team ? team->nthreads : 1;\n+\n+\tif (__builtin_expect (up, 1))\n+\t  {\n+\t    /* Cheap overflow protection.  */\n+\t    if (__builtin_expect ((nthreads | ws->chunk_size_ull)\n+\t\t\t\t  < 1ULL << (sizeof (gomp_ull)\n+\t\t\t\t\t     * __CHAR_BIT__ / 2 - 1), 1))\n+\t      ws->mode = ws->end_ull < (__LONG_LONG_MAX__ * 2ULL + 1\n+\t\t\t\t\t- (nthreads + 1) * ws->chunk_size_ull);\n+\t  }\n+\t/* Cheap overflow protection.  */\n+\telse if (__builtin_expect ((nthreads | -ws->chunk_size_ull)\n+\t\t\t\t   < 1ULL << (sizeof (gomp_ull)\n+\t\t\t\t\t      * __CHAR_BIT__ / 2 - 1), 1))\n+\t  ws->mode = ws->end_ull > ((nthreads + 1) * -ws->chunk_size_ull\n+\t\t\t\t    - (__LONG_LONG_MAX__ * 2ULL + 1));\n+      }\n+#endif\n+    }\n+  if (!up)\n+    ws->mode |= 2;\n+}\n+\n+/* The *_start routines are called when first encountering a loop construct\n+   that is not bound directly to a parallel construct.  The first thread\n+   that arrives will create the work-share construct; subsequent threads\n+   will see the construct exists and allocate work from it.\n+\n+   START, END, INCR are the bounds of the loop; due to the restrictions of\n+   OpenMP, these values must be the same in every thread.  This is not\n+   verified (nor is it entirely verifiable, since START is not necessarily\n+   retained intact in the work-share data structure).  CHUNK_SIZE is the\n+   scheduling parameter; again this must be identical in all threads.\n+\n+   Returns true if there's any work for this thread to perform.  If so,\n+   *ISTART and *IEND are filled with the bounds of the iteration block\n+   allocated to this thread.  Returns false if all work was assigned to\n+   other threads prior to this thread's arrival.  */\n+\n+static bool\n+gomp_loop_ull_static_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t    gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t    gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  thr->ts.static_trip = 0;\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, up, start, end, incr,\n+\t\t\t  GFS_STATIC, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+  return !gomp_iter_ull_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_ull_dynamic_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t     gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t     gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, up, start, end, incr,\n+\t\t\t  GFS_DYNAMIC, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+  ret = gomp_iter_ull_dynamic_next (istart, iend);\n+#else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_dynamic_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_ull_guided_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t    gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t    gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (false))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, up, start, end, incr,\n+\t\t\t  GFS_GUIDED, chunk_size);\n+      gomp_work_share_init_done ();\n+    }\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+  ret = gomp_iter_ull_guided_next (istart, iend);\n+#else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_guided_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_ull_runtime_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t     gomp_ull incr, gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  switch (icv->run_sched_var)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_ull_static_start (up, start, end, incr,\n+\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_ull_dynamic_start (up, start, end, incr,\n+\t\t\t\t\t  icv->run_sched_modifier,\n+\t\t\t\t\t  istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_ull_guided_start (up, start, end, incr,\n+\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t istart, iend);\n+    case GFS_AUTO:\n+      /* For now map to schedule(static), later on we could play with feedback\n+\t driven choice.  */\n+      return gomp_loop_ull_static_start (up, start, end, incr,\n+\t\t\t\t\t 0, istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* The *_ordered_*_start routines are similar.  The only difference is that\n+   this work-share construct is initialized to expect an ORDERED section.  */\n+\n+static bool\n+gomp_loop_ull_ordered_static_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t\t    gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t\t    gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  thr->ts.static_trip = 0;\n+  if (gomp_work_share_start (true))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, up, start, end, incr,\n+\t\t\t  GFS_STATIC, chunk_size);\n+      gomp_ordered_static_init ();\n+      gomp_work_share_init_done ();\n+    }\n+\n+  return !gomp_iter_ull_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_ull_ordered_dynamic_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t\t     gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t\t     gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (true))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, up, start, end, incr,\n+\t\t\t  GFS_DYNAMIC, chunk_size);\n+      gomp_mutex_lock (&thr->ts.work_share->lock);\n+      gomp_work_share_init_done ();\n+    }\n+  else\n+    gomp_mutex_lock (&thr->ts.work_share->lock);\n+\n+  ret = gomp_iter_ull_dynamic_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_first ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_ull_ordered_guided_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t\t    gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t\t    gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  if (gomp_work_share_start (true))\n+    {\n+      gomp_loop_ull_init (thr->ts.work_share, up, start, end, incr,\n+\t\t\t  GFS_GUIDED, chunk_size);\n+      gomp_mutex_lock (&thr->ts.work_share->lock);\n+      gomp_work_share_init_done ();\n+    }\n+  else\n+    gomp_mutex_lock (&thr->ts.work_share->lock);\n+\n+  ret = gomp_iter_ull_guided_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_first ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_runtime_start (bool up, gomp_ull start, gomp_ull end,\n+\t\t\t\t     gomp_ull incr, gomp_ull *istart,\n+\t\t\t\t     gomp_ull *iend)\n+{\n+  struct gomp_task_icv *icv = gomp_icv (false);\n+  switch (icv->run_sched_var)\n+    {\n+    case GFS_STATIC:\n+      return gomp_loop_ull_ordered_static_start (up, start, end, incr,\n+\t\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t\t istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_ull_ordered_dynamic_start (up, start, end, incr,\n+\t\t\t\t\t\t  icv->run_sched_modifier,\n+\t\t\t\t\t\t  istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_ull_ordered_guided_start (up, start, end, incr,\n+\t\t\t\t\t\t icv->run_sched_modifier,\n+\t\t\t\t\t\t istart, iend);\n+    case GFS_AUTO:\n+      /* For now map to schedule(static), later on we could play with feedback\n+\t driven choice.  */\n+      return gomp_loop_ull_ordered_static_start (up, start, end, incr,\n+\t\t\t\t\t\t 0, istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* The *_next routines are called when the thread completes processing of\n+   the iteration block currently assigned to it.  If the work-share\n+   construct is bound directly to a parallel construct, then the iteration\n+   bounds may have been set up before the parallel.  In which case, this\n+   may be the first iteration for the thread.\n+\n+   Returns true if there is work remaining to be performed; *ISTART and\n+   *IEND are filled with a new iteration block.  Returns false if all work\n+   has been assigned.  */\n+\n+static bool\n+gomp_loop_ull_static_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return !gomp_iter_ull_static_next (istart, iend);\n+}\n+\n+static bool\n+gomp_loop_ull_dynamic_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  bool ret;\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+  ret = gomp_iter_ull_dynamic_next (istart, iend);\n+#else\n+  struct gomp_thread *thr = gomp_thread ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_dynamic_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_ull_guided_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  bool ret;\n+\n+#if defined HAVE_SYNC_BUILTINS && defined __LP64__\n+  ret = gomp_iter_ull_guided_next (istart, iend);\n+#else\n+  struct gomp_thread *thr = gomp_thread ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_guided_next_locked (istart, iend);\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_ull_runtime_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  switch (thr->ts.work_share->sched)\n+    {\n+    case GFS_STATIC:\n+    case GFS_AUTO:\n+      return gomp_loop_ull_static_next (istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_ull_dynamic_next (istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_ull_guided_next (istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* The *_ordered_*_next routines are called when the thread completes\n+   processing of the iteration block currently assigned to it.\n+\n+   Returns true if there is work remaining to be performed; *ISTART and\n+   *IEND are filled with a new iteration block.  Returns false if all work\n+   has been assigned.  */\n+\n+static bool\n+gomp_loop_ull_ordered_static_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  int test;\n+\n+  gomp_ordered_sync ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  test = gomp_iter_ull_static_next (istart, iend);\n+  if (test >= 0)\n+    gomp_ordered_static_next ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return test == 0;\n+}\n+\n+static bool\n+gomp_loop_ull_ordered_dynamic_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  gomp_ordered_sync ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_dynamic_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_next ();\n+  else\n+    gomp_ordered_last ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+static bool\n+gomp_loop_ull_ordered_guided_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  bool ret;\n+\n+  gomp_ordered_sync ();\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n+  ret = gomp_iter_ull_guided_next_locked (istart, iend);\n+  if (ret)\n+    gomp_ordered_next ();\n+  else\n+    gomp_ordered_last ();\n+  gomp_mutex_unlock (&thr->ts.work_share->lock);\n+\n+  return ret;\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_runtime_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+\n+  switch (thr->ts.work_share->sched)\n+    {\n+    case GFS_STATIC:\n+    case GFS_AUTO:\n+      return gomp_loop_ull_ordered_static_next (istart, iend);\n+    case GFS_DYNAMIC:\n+      return gomp_loop_ull_ordered_dynamic_next (istart, iend);\n+    case GFS_GUIDED:\n+      return gomp_loop_ull_ordered_guided_next (istart, iend);\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* We use static functions above so that we're sure that the \"runtime\"\n+   function can defer to the proper routine without interposition.  We\n+   export the static function with a strong alias when possible, or with\n+   a wrapper function otherwise.  */\n+\n+#ifdef HAVE_ATTRIBUTE_ALIAS\n+extern __typeof(gomp_loop_ull_static_start) GOMP_loop_ull_static_start\n+\t__attribute__((alias (\"gomp_loop_ull_static_start\")));\n+extern __typeof(gomp_loop_ull_dynamic_start) GOMP_loop_ull_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_ull_dynamic_start\")));\n+extern __typeof(gomp_loop_ull_guided_start) GOMP_loop_ull_guided_start\n+\t__attribute__((alias (\"gomp_loop_ull_guided_start\")));\n+\n+extern __typeof(gomp_loop_ull_ordered_static_start) GOMP_loop_ull_ordered_static_start\n+\t__attribute__((alias (\"gomp_loop_ull_ordered_static_start\")));\n+extern __typeof(gomp_loop_ull_ordered_dynamic_start) GOMP_loop_ull_ordered_dynamic_start\n+\t__attribute__((alias (\"gomp_loop_ull_ordered_dynamic_start\")));\n+extern __typeof(gomp_loop_ull_ordered_guided_start) GOMP_loop_ull_ordered_guided_start\n+\t__attribute__((alias (\"gomp_loop_ull_ordered_guided_start\")));\n+\n+extern __typeof(gomp_loop_ull_static_next) GOMP_loop_ull_static_next\n+\t__attribute__((alias (\"gomp_loop_ull_static_next\")));\n+extern __typeof(gomp_loop_ull_dynamic_next) GOMP_loop_ull_dynamic_next\n+\t__attribute__((alias (\"gomp_loop_ull_dynamic_next\")));\n+extern __typeof(gomp_loop_ull_guided_next) GOMP_loop_ull_guided_next\n+\t__attribute__((alias (\"gomp_loop_ull_guided_next\")));\n+\n+extern __typeof(gomp_loop_ull_ordered_static_next) GOMP_loop_ull_ordered_static_next\n+\t__attribute__((alias (\"gomp_loop_ull_ordered_static_next\")));\n+extern __typeof(gomp_loop_ull_ordered_dynamic_next) GOMP_loop_ull_ordered_dynamic_next\n+\t__attribute__((alias (\"gomp_loop_ull_ordered_dynamic_next\")));\n+extern __typeof(gomp_loop_ull_ordered_guided_next) GOMP_loop_ull_ordered_guided_next\n+\t__attribute__((alias (\"gomp_loop_ull_ordered_guided_next\")));\n+#else\n+bool\n+GOMP_loop_ull_static_start (gomp_ull start, gomp_ull end, gomp_ull incr, gomp_ull chunk_size,\n+\t\t\tgomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_static_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_dynamic_start (gomp_ull start, gomp_ull end, gomp_ull incr, gomp_ull chunk_size,\n+\t\t\t gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_dynamic_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_guided_start (gomp_ull start, gomp_ull end, gomp_ull incr, gomp_ull chunk_size,\n+\t\t\tgomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_guided_start (start, end, incr, chunk_size, istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_static_start (gomp_ull start, gomp_ull end, gomp_ull incr,\n+\t\t\t\tgomp_ull chunk_size, gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_ordered_static_start (start, end, incr, chunk_size,\n+\t\t\t\t\t istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_dynamic_start (gomp_ull start, gomp_ull end, gomp_ull incr,\n+\t\t\t\t gomp_ull chunk_size, gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_ordered_dynamic_start (start, end, incr, chunk_size,\n+\t\t\t\t\t  istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_guided_start (gomp_ull start, gomp_ull end, gomp_ull incr,\n+\t\t\t\tgomp_ull chunk_size, gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_ordered_guided_start (start, end, incr, chunk_size,\n+\t\t\t\t\t istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_static_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_static_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_dynamic_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_dynamic_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_guided_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_guided_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_static_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_ordered_static_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_dynamic_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_ordered_dynamic_next (istart, iend);\n+}\n+\n+bool\n+GOMP_loop_ull_ordered_guided_next (gomp_ull *istart, gomp_ull *iend)\n+{\n+  return gomp_loop_ull_ordered_guided_next (istart, iend);\n+}\n+#endif"}, {"sha": "d4fe94a2ca77b811337bc0320b37e4c43fdfaee7", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -47,6 +47,14 @@ typedef struct\n } omp_nest_lock_t;\n #endif\n \n+typedef enum omp_sched_t\n+{\n+  omp_sched_static = 1,\n+  omp_sched_dynamic = 2,\n+  omp_sched_guided = 3,\n+  omp_sched_auto = 4\n+} omp_sched_t;\n+\n #ifdef __cplusplus\n extern \"C\" {\n # define __GOMP_NOTHROW throw ()\n@@ -83,6 +91,16 @@ extern int omp_test_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;\n extern double omp_get_wtime (void) __GOMP_NOTHROW;\n extern double omp_get_wtick (void) __GOMP_NOTHROW;\n \n+void omp_set_schedule (omp_sched_t, int) __GOMP_NOTHROW;\n+void omp_get_schedule (omp_sched_t *, int *) __GOMP_NOTHROW;\n+int omp_get_thread_limit (void) __GOMP_NOTHROW;\n+void omp_set_max_active_levels (int) __GOMP_NOTHROW;\n+int omp_get_max_active_levels (void) __GOMP_NOTHROW;\n+int omp_get_level (void) __GOMP_NOTHROW;\n+int omp_get_ancestor_thread_num (int) __GOMP_NOTHROW;\n+int omp_get_team_size (int) __GOMP_NOTHROW;\n+int omp_get_active_level (void) __GOMP_NOTHROW;\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "a31a94567eae2f2594c11441e486991577174799", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-!  Copyright (C) 2005 Free Software Foundation, Inc.\n+!  Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n !  Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n !  This file is part of the GNU OpenMP Library (libgomp).\n@@ -30,11 +30,16 @@\n         integer, parameter :: omp_logical_kind = 4\n         integer, parameter :: omp_lock_kind = @OMP_LOCK_KIND@\n         integer, parameter :: omp_nest_lock_kind = @OMP_NEST_LOCK_KIND@\n+        integer, parameter :: omp_sched_kind = 4\n       end module\n \n       module omp_lib\n         use omp_lib_kinds\n-        integer, parameter :: openmp_version = 200505\n+        integer, parameter :: openmp_version = 200805\n+        integer (omp_sched_kind), parameter :: omp_sched_static = 1\n+        integer (omp_sched_kind), parameter :: omp_sched_dynamic = 2\n+        integer (omp_sched_kind), parameter :: omp_sched_guided = 3\n+        integer (omp_sched_kind), parameter :: omp_sched_auto = 4\n \n         interface\n           subroutine omp_init_lock (lock)\n@@ -196,4 +201,95 @@\n           end function omp_get_wtime\n         end interface\n \n+        interface omp_set_schedule\n+          subroutine omp_set_schedule (kind, modifier)\n+            use omp_lib_kinds\n+            integer (omp_sched_kind), intent (in) :: kind\n+            integer (4), intent (in) :: modifier\n+          end subroutine omp_set_schedule\n+          subroutine omp_set_schedule_8 (kind, modifier)\n+            use omp_lib_kinds\n+            integer (omp_sched_kind), intent (in) :: kind\n+            integer (8), intent (in) :: modifier\n+          end subroutine omp_set_schedule_8\n+         end interface\n+\n+        interface omp_get_schedule\n+          subroutine omp_get_schedule (kind, modifier)\n+            use omp_lib_kinds\n+            integer (omp_sched_kind), intent (out) :: kind\n+            integer (4), intent (out) :: modifier\n+          end subroutine omp_get_schedule\n+          subroutine omp_get_schedule_8 (kind, modifier)\n+            use omp_lib_kinds\n+            integer (omp_sched_kind), intent (out) :: kind\n+            integer (8), intent (out) :: modifier\n+          end subroutine omp_get_schedule_8\n+         end interface\n+\n+        interface\n+          function omp_get_thread_limit ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_thread_limit\n+          end function omp_get_thread_limit\n+        end interface\n+\n+        interface omp_set_max_active_levels\n+          subroutine omp_set_max_active_levels (max_levels)\n+            use omp_lib_kinds\n+            integer (4), intent (in) :: max_levels\n+          end subroutine omp_set_max_active_levels\n+          subroutine omp_set_max_active_levels_8 (max_levels)\n+            use omp_lib_kinds\n+            integer (8), intent (in) :: max_levels\n+          end subroutine omp_set_max_active_levels_8\n+        end interface\n+\n+        interface\n+          function omp_get_max_active_levels ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_max_active_levels\n+          end function omp_get_max_active_levels\n+        end interface\n+\n+        interface\n+          function omp_get_level ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_level\n+          end function omp_get_level\n+        end interface\n+\n+        interface omp_get_ancestor_thread_num\n+          function omp_get_ancestor_thread_num (level)\n+            use omp_lib_kinds\n+            integer (4), intent (in) :: level\n+            integer (omp_integer_kind) :: omp_get_ancestor_thread_num\n+          end function omp_get_ancestor_thread_num\n+          function omp_get_ancestor_thread_num_8 (level)\n+            use omp_lib_kinds\n+            integer (8), intent (in) :: level\n+            integer (omp_integer_kind) :: omp_get_ancestor_thread_num\n+          end function omp_get_ancestor_thread_num_8\n+        end interface\n+\n+        interface omp_get_team_size\n+          function omp_get_team_size (level)\n+            use omp_lib_kinds\n+            integer (4), intent (in) :: level\n+            integer (omp_integer_kind) :: omp_get_team_size\n+          end function omp_get_team_size\n+          function omp_get_team_size_8 (level)\n+            use omp_lib_kinds\n+            integer (8), intent (in) :: level\n+            integer (omp_integer_kind) :: omp_get_team_size\n+          end function omp_get_team_size_8\n+        end interface\n+\n+        interface\n+          function omp_get_active_level ()\n+            use omp_lib_kinds\n+            integer (omp_integer_kind) :: omp_get_active_level\n+          end function omp_get_active_level\n+        end interface\n+\n       end module omp_lib"}, {"sha": "60677f666a167d8c7b5d6c084e40ead890d6c002", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-!  Copyright (C) 2005 Free Software Foundation, Inc.\n+!  Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n !  Contributed by Jakub Jelinek <jakub@redhat.com>.\n \n !  This file is part of the GNU OpenMP Library (libgomp).\n@@ -26,9 +26,16 @@\n !  General Public License.\n \n       integer omp_lock_kind, omp_nest_lock_kind, openmp_version\n+      integer omp_sched_kind, omp_sched_static, omp_sched_dynamic\n+      integer omp_sched_guided, omp_sched_auto\n       parameter (omp_lock_kind = @OMP_LOCK_KIND@)\n       parameter (omp_nest_lock_kind = @OMP_NEST_LOCK_KIND@)\n-      parameter (openmp_version = 200505)\n+      parameter (omp_sched_kind = 4)\n+      parameter (omp_sched_static = 1)\n+      parameter (omp_sched_dynamic = 2)\n+      parameter (omp_sched_guided = 3)\n+      parameter (omp_sched_auto = 4)\n+      parameter (openmp_version = 200805)\n \n       external omp_init_lock, omp_init_nest_lock\n       external omp_destroy_lock, omp_destroy_nest_lock\n@@ -51,3 +58,12 @@\n \n       external omp_get_wtick, omp_get_wtime\n       double precision omp_get_wtick, omp_get_wtime\n+\n+      external omp_set_schedule, omp_get_schedule\n+      external omp_get_thread_limit, omp_set_max_active_levels\n+      external omp_get_max_active_levels, omp_get_level\n+      external omp_get_ancestor_thread_num, omp_get_team_size\n+      external omp_get_active_level\n+      integer*4 omp_get_thread_limit, omp_get_max_active_levels\n+      integer*4 omp_get_level, omp_get_ancestor_thread_num\n+      integer*4 omp_get_team_size, omp_get_active_level"}, {"sha": "3f2a305613893a662e75382713d9ae898855998e", "filename": "libgomp/parallel.c", "status": "modified", "additions": 113, "deletions": 35, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fparallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fparallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fparallel.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -28,52 +28,107 @@\n /* This file handles the (bare) PARALLEL construct.  */\n \n #include \"libgomp.h\"\n+#include <limits.h>\n \n \n /* Determine the number of threads to be launched for a PARALLEL construct.\n-   This algorithm is explicitly described in OpenMP 2.5 section 2.4.1.\n+   This algorithm is explicitly described in OpenMP 3.0 section 2.4.1.\n    SPECIFIED is a combination of the NUM_THREADS clause and the IF clause.\n    If the IF clause is false, SPECIFIED is forced to 1.  When NUM_THREADS\n    is not present, SPECIFIED is 0.  */\n \n unsigned\n-gomp_resolve_num_threads (unsigned specified)\n+gomp_resolve_num_threads (unsigned specified, unsigned count)\n {\n-  /* Early exit for false IF condition or degenerate NUM_THREADS.  */\n+  struct gomp_thread *thread = gomp_thread();\n+  struct gomp_task_icv *icv;\n+  unsigned threads_requested, max_num_threads, num_threads;\n+  unsigned long remaining;\n+\n+  icv = gomp_icv (false);\n+\n   if (specified == 1)\n     return 1;\n-\n-  /* If this is a nested region, and nested regions are disabled, force\n-     this team to use only one thread.  */\n-  if (gomp_thread()->ts.team && !gomp_nest_var)\n+  else if (thread->ts.active_level >= 1 && !icv->nest_var)\n+    return 1;\n+  else if (thread->ts.active_level >= gomp_max_active_levels_var)\n     return 1;\n \n   /* If NUM_THREADS not specified, use nthreads_var.  */\n   if (specified == 0)\n-    specified = gomp_nthreads_var;\n+    threads_requested = icv->nthreads_var;\n+  else\n+    threads_requested = specified;\n+\n+  max_num_threads = threads_requested;\n \n   /* If dynamic threads are enabled, bound the number of threads\n      that we launch.  */\n-  if (gomp_dyn_var)\n+  if (icv->dyn_var)\n     {\n       unsigned dyn = gomp_dynamic_max_threads ();\n-      if (dyn < specified)\n-\treturn dyn;\n+      if (dyn < max_num_threads)\n+\tmax_num_threads = dyn;\n+\n+      /* Optimization for parallel sections.  */\n+      if (count && count < max_num_threads)\n+\tmax_num_threads = count;\n     }\n \n-  return specified;\n+  /* ULONG_MAX stands for infinity.  */\n+  if (__builtin_expect (gomp_thread_limit_var == ULONG_MAX, 1)\n+      || max_num_threads == 1)\n+    return max_num_threads;\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+  do\n+    {\n+      remaining = gomp_remaining_threads_count;\n+      num_threads = max_num_threads;\n+      if (num_threads > remaining)\n+\tnum_threads = remaining + 1;\n+    }\n+  while (__sync_val_compare_and_swap (&gomp_remaining_threads_count,\n+\t\t\t\t      remaining, remaining - num_threads + 1)\n+\t != remaining);\n+#else\n+  gomp_mutex_lock (&gomp_remaining_threads_lock);\n+  num_threads = max_num_threads;\n+  remaining = gomp_remaining_threads_count;\n+  if (num_threads > remaining)\n+    num_threads = remaining + 1;\n+  gomp_remaining_threads_count -= num_threads - 1;\n+  gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+#endif\n+\n+  return num_threads;\n }\n \n void\n GOMP_parallel_start (void (*fn) (void *), void *data, unsigned num_threads)\n {\n-  num_threads = gomp_resolve_num_threads (num_threads);\n-  gomp_team_start (fn, data, num_threads, NULL);\n+  num_threads = gomp_resolve_num_threads (num_threads, 0);\n+  gomp_team_start (fn, data, num_threads, gomp_new_team (num_threads));\n }\n \n void\n GOMP_parallel_end (void)\n {\n+  if (__builtin_expect (gomp_thread_limit_var != ULONG_MAX, 0))\n+    {\n+      struct gomp_thread *thr = gomp_thread ();\n+      struct gomp_team *team = thr->ts.team;\n+      if (team && team->nthreads > 1)\n+\t{\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  __sync_fetch_and_add (&gomp_remaining_threads_count,\n+\t\t\t\t1UL - team->nthreads);\n+#else\n+\t  gomp_mutex_lock (&gomp_remaining_threads_lock);\n+\t  gomp_remaining_threads_count -= team->nthreads - 1;\n+#endif\n+\t}\n+    }\n   gomp_team_end ();\n }\n \n@@ -87,40 +142,63 @@ omp_get_num_threads (void)\n   return team ? team->nthreads : 1;\n }\n \n-/* ??? Does this function need to disregard dyn_var?  I don't see\n-   how else one could get a useable \"maximum\".  */\n-\n int\n-omp_get_max_threads (void)\n+omp_get_thread_num (void)\n {\n-  return gomp_resolve_num_threads (0);\n+  return gomp_thread ()->ts.team_id;\n }\n \n+/* This wasn't right for OpenMP 2.5.  Active region used to be non-zero\n+   when the IF clause doesn't evaluate to false, starting with OpenMP 3.0\n+   it is non-zero with more than one thread in the team.  */\n+\n int\n-omp_get_thread_num (void)\n+omp_in_parallel (void)\n {\n-  return gomp_thread ()->ts.team_id;\n+  return gomp_thread ()->ts.active_level > 0;\n }\n \n-/* ??? This isn't right.  The definition of this function is false if any\n-   of the IF clauses for any of the parallels is false.  Which is not the\n-   same thing as any outer team having more than one thread.  */\n+int\n+omp_get_level (void)\n+{\n+  return gomp_thread ()->ts.level;\n+}\n \n-int omp_in_parallel (void)\n+int\n+omp_get_ancestor_thread_num (int level)\n {\n-  struct gomp_team *team = gomp_thread ()->ts.team;\n+  struct gomp_team_state *ts = &gomp_thread ()->ts;\n+  if (level < 0 || level > ts->level)\n+    return -1;\n+  for (level = ts->level - level; level > 0; --level)\n+    ts = &ts->team->prev_ts;\n+  return ts->team_id;\n+}\n \n-  while (team)\n-    {\n-      if (team->nthreads > 1)\n-\treturn true;\n-      team = team->prev_ts.team;\n-    }\n+int\n+omp_get_team_size (int level)\n+{\n+  struct gomp_team_state *ts = &gomp_thread ()->ts;\n+  if (level < 0 || level > ts->level)\n+    return -1;\n+  for (level = ts->level - level; level > 0; --level)\n+    ts = &ts->team->prev_ts;\n+  if (ts->team == NULL)\n+    return 1;\n+  else\n+    return ts->team->nthreads;\n+}\n \n-  return false;\n+int\n+omp_get_active_level (void)\n+{\n+  return gomp_thread ()->ts.active_level;\n }\n \n ialias (omp_get_num_threads)\n-ialias (omp_get_max_threads)\n ialias (omp_get_thread_num)\n ialias (omp_in_parallel)\n+ialias (omp_get_level)\n+ialias (omp_get_ancestor_thread_num)\n+ialias (omp_get_team_size)\n+ialias (omp_get_active_level)"}, {"sha": "27625efec3e837e6e4f22862ebde2fb44e512c9d", "filename": "libgomp/sections.c", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fsections.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fsections.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsections.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -59,14 +59,24 @@ GOMP_sections_start (unsigned count)\n   long s, e, ret;\n \n   if (gomp_work_share_start (false))\n-    gomp_sections_init (thr->ts.work_share, count);\n+    {\n+      gomp_sections_init (thr->ts.work_share, count);\n+      gomp_work_share_init_done ();\n+    }\n \n+#ifdef HAVE_SYNC_BUILTINS\n+  if (gomp_iter_dynamic_next (&s, &e))\n+    ret = s;\n+  else\n+    ret = 0;\n+#else\n+  gomp_mutex_lock (&thr->ts.work_share->lock);\n   if (gomp_iter_dynamic_next_locked (&s, &e))\n     ret = s;\n   else\n     ret = 0;\n-\n   gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n \n   return ret;\n }\n@@ -83,15 +93,23 @@ GOMP_sections_start (unsigned count)\n unsigned\n GOMP_sections_next (void)\n {\n-  struct gomp_thread *thr = gomp_thread ();\n   long s, e, ret;\n \n+#ifdef HAVE_SYNC_BUILTINS\n+  if (gomp_iter_dynamic_next (&s, &e))\n+    ret = s;\n+  else\n+    ret = 0;\n+#else\n+  struct gomp_thread *thr = gomp_thread ();\n+\n   gomp_mutex_lock (&thr->ts.work_share->lock);\n   if (gomp_iter_dynamic_next_locked (&s, &e))\n     ret = s;\n   else\n     ret = 0;\n   gomp_mutex_unlock (&thr->ts.work_share->lock);\n+#endif\n \n   return ret;\n }\n@@ -103,15 +121,12 @@ void\n GOMP_parallel_sections_start (void (*fn) (void *), void *data,\n \t\t\t      unsigned num_threads, unsigned count)\n {\n-  struct gomp_work_share *ws;\n-\n-  num_threads = gomp_resolve_num_threads (num_threads);\n-  if (gomp_dyn_var && num_threads > count)\n-    num_threads = count;\n+  struct gomp_team *team;\n \n-  ws = gomp_new_work_share (false, num_threads);\n-  gomp_sections_init (ws, count);\n-  gomp_team_start (fn, data, num_threads, ws);\n+  num_threads = gomp_resolve_num_threads (num_threads, count);\n+  team = gomp_new_team (num_threads);\n+  gomp_sections_init (&team->work_shares[0], count);\n+  gomp_team_start (fn, data, num_threads, team);\n }\n \n /* The GOMP_section_end* routines are called after the thread is told"}, {"sha": "16c7fa988a154fdf2e878a7c1f699aa7660ed203", "filename": "libgomp/single.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsingle.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -37,10 +37,24 @@\n bool\n GOMP_single_start (void)\n {\n+#ifdef HAVE_SYNC_BUILTINS\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  unsigned long single_count;\n+\n+  if (__builtin_expect (team == NULL, 0))\n+    return true;\n+\n+  single_count = thr->ts.single_count++;\n+  return __sync_bool_compare_and_swap (&team->single_count, single_count,\n+\t\t\t\t       single_count + 1L);\n+#else\n   bool ret = gomp_work_share_start (false);\n-  gomp_mutex_unlock (&gomp_thread ()->ts.work_share->lock);\n+  if (ret)\n+    gomp_work_share_init_done ();\n   gomp_work_share_end_nowait ();\n   return ret;\n+#endif\n }\n \n /* This routine is called when first encountering a SINGLE construct that\n@@ -57,13 +71,15 @@ GOMP_single_copy_start (void)\n   void *ret;\n \n   first = gomp_work_share_start (false);\n-  gomp_mutex_unlock (&thr->ts.work_share->lock);\n   \n   if (first)\n-    ret = NULL;\n+    {\n+      gomp_work_share_init_done ();\n+      ret = NULL;\n+    }\n   else\n     {\n-      gomp_barrier_wait (&thr->ts.team->barrier);\n+      gomp_team_barrier_wait (&thr->ts.team->barrier);\n \n       ret = thr->ts.work_share->copyprivate;\n       gomp_work_share_end_nowait ();\n@@ -84,7 +100,7 @@ GOMP_single_copy_end (void *data)\n   if (team != NULL)\n     {\n       thr->ts.work_share->copyprivate = data;\n-      gomp_barrier_wait (&team->barrier);\n+      gomp_team_barrier_wait (&team->barrier);\n     }\n \n   gomp_work_share_end_nowait ();"}, {"sha": "903948ceca314631e3f30b81dbb880c7d610f7de", "filename": "libgomp/task.c", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,361 @@\n+/* Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU OpenMP Library (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU Lesser General Public License as published by\n+   the Free Software Foundation; either version 2.1 of the License, or\n+   (at your option) any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for\n+   more details.\n+\n+   You should have received a copy of the GNU Lesser General Public License \n+   along with libgomp; see the file COPYING.LIB.  If not, write to the\n+   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with other files, some\n+   of which are compiled with GCC, to produce an executable, this library\n+   does not by itself cause the resulting executable to be covered by the\n+   GNU General Public License.  This exception does not however invalidate\n+   any other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* This file handles the maintainence of tasks in response to task\n+   creation and termination.  */\n+\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+#include <string.h>\n+\n+\n+/* Create a new task data structure.  */\n+\n+void\n+gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n+\t\tstruct gomp_task_icv *prev_icv)\n+{\n+  task->parent = parent_task;\n+  task->icv = *prev_icv;\n+  task->kind = GOMP_TASK_IMPLICIT;\n+  task->in_taskwait = false;\n+  task->children = NULL;\n+  gomp_sem_init (&task->taskwait_sem, 0);\n+}\n+\n+/* Clean up a task, after completing it.  */\n+\n+void\n+gomp_end_task (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_task *task = thr->task;\n+\n+  gomp_finish_task (task);\n+  thr->task = task->parent;\n+}\n+\n+static inline void\n+gomp_clear_parent (struct gomp_task *children)\n+{\n+  struct gomp_task *task = children;\n+\n+  if (task)\n+    do\n+      {\n+\ttask->parent = NULL;\n+\ttask = task->next_child;\n+      }\n+    while (task != children);\n+}\n+\n+/* Called when encountering an explicit task directive.  If IF_CLAUSE is\n+   false, then we must not delay in executing the task.  If UNTIED is true,\n+   then the task may be executed by any member of the team.  */\n+\n+void\n+GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n+\t   long arg_size, long arg_align, bool if_clause,\n+\t   unsigned flags __attribute__((unused)))\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+\n+#ifdef HAVE_BROKEN_POSIX_SEMAPHORES\n+  /* If pthread_mutex_* is used for omp_*lock*, then each task must be\n+     tied to one thread all the time.  This means UNTIED tasks must be\n+     tied and if CPYFN is non-NULL IF(0) must be forced, as CPYFN\n+     might be running on different thread than FN.  */\n+  if (cpyfn)\n+    if_clause = false;\n+  if (flags & 1)\n+    flags &= ~1;\n+#endif\n+\n+  if (!if_clause || team == NULL\n+      || team->task_count > 64 * team->nthreads)\n+    {\n+      struct gomp_task task;\n+\n+      gomp_init_task (&task, thr->task, gomp_icv (false));\n+      task.kind = GOMP_TASK_IFFALSE;\n+      thr->task = &task;\n+      if (__builtin_expect (cpyfn != NULL, 0))\n+\t{\n+\t  char buf[arg_size + arg_align - 1];\n+\t  char *arg = (char *) (((uintptr_t) buf + arg_align - 1)\n+\t\t\t\t& ~(uintptr_t) (arg_align - 1));\n+\t  cpyfn (arg, data);\n+\t  fn (arg);\n+\t}\n+      else\n+\tfn (data);\n+      if (task.children)\n+\t{\n+\t  gomp_mutex_lock (&team->task_lock);\n+\t  gomp_clear_parent (task.children);\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t}\n+      gomp_end_task ();\n+    }\n+  else\n+    {\n+      struct gomp_task *task;\n+      struct gomp_task *parent = thr->task;\n+      char *arg;\n+      bool do_wake;\n+\n+      task = gomp_malloc (sizeof (*task) + arg_size + arg_align - 1);\n+      arg = (char *) (((uintptr_t) (task + 1) + arg_align - 1)\n+\t\t      & ~(uintptr_t) (arg_align - 1));\n+      gomp_init_task (task, parent, gomp_icv (false));\n+      task->kind = GOMP_TASK_IFFALSE;\n+      thr->task = task;\n+      if (cpyfn)\n+\tcpyfn (arg, data);\n+      else\n+\tmemcpy (arg, data, arg_size);\n+      thr->task = parent;\n+      task->kind = GOMP_TASK_WAITING;\n+      task->fn = fn;\n+      task->fn_data = arg;\n+      gomp_mutex_lock (&team->task_lock);\n+      if (parent->children)\n+\t{\n+\t  task->next_child = parent->children;\n+\t  task->prev_child = parent->children->prev_child;\n+\t  task->next_child->prev_child = task;\n+\t  task->prev_child->next_child = task;\n+\t}\n+      else\n+\t{\n+\t  task->next_child = task;\n+\t  task->prev_child = task;\n+\t}\n+      parent->children = task;\n+      if (team->task_queue)\n+\t{\n+\t  task->next_queue = team->task_queue;\n+\t  task->prev_queue = team->task_queue->prev_queue;\n+\t  task->next_queue->prev_queue = task;\n+\t  task->prev_queue->next_queue = task;\n+\t}\n+      else\n+\t{\n+\t  task->next_queue = task;\n+\t  task->prev_queue = task;\n+\t  team->task_queue = task;\n+\t}\n+      if (team->task_count++ == 0)\n+\tgomp_team_barrier_set_task_pending (&team->barrier);\n+      do_wake = team->task_running_count < team->nthreads;\n+      gomp_mutex_unlock (&team->task_lock);\n+      if (do_wake)\n+\tgomp_team_barrier_wake (&team->barrier, 1);\n+    }\n+}\n+\n+void\n+gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_task *task = thr->task;\n+  struct gomp_task *child_task = NULL;\n+  struct gomp_task *to_free = NULL;\n+\n+  gomp_mutex_lock (&team->task_lock);\n+  if (gomp_barrier_last_thread (state))\n+    {\n+      if (team->task_count == 0)\n+\t{\n+\t  gomp_team_barrier_done (&team->barrier, state);\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t  gomp_team_barrier_wake (&team->barrier, 0);\n+\t  return;\n+\t}\n+      gomp_team_barrier_set_waiting_for_tasks (&team->barrier);\n+    }\n+\n+  while (1)\n+    {\n+      if (team->task_queue != NULL)\n+\t{\n+\t  struct gomp_task *parent;\n+\n+\t  child_task = team->task_queue;\n+\t  parent = child_task->parent;\n+\t  if (parent && parent->children == child_task)\n+\t    parent->children = child_task->next_child;\n+\t  child_task->prev_queue->next_queue = child_task->next_queue;\n+\t  child_task->next_queue->prev_queue = child_task->prev_queue;\n+\t  if (child_task->next_queue != child_task)\n+\t    team->task_queue = child_task->next_queue;\n+\t  else\n+\t    team->task_queue = NULL;\n+\t  child_task->kind = GOMP_TASK_TIED;\n+\t  team->task_running_count++;\n+\t  if (team->task_count == team->task_running_count)\n+\t    gomp_team_barrier_clear_task_pending (&team->barrier);\n+\t}\n+      gomp_mutex_unlock (&team->task_lock);\n+      if (to_free)\n+\t{\n+\t  gomp_finish_task (to_free);\n+\t  free (to_free);\n+\t  to_free = NULL;\n+\t}\n+      if (child_task)\n+\t{\n+\t  thr->task = child_task;\n+\t  child_task->fn (child_task->fn_data);\n+\t  thr->task = task;\n+\t}\n+      else\n+\treturn;\n+      gomp_mutex_lock (&team->task_lock);\n+      if (child_task)\n+\t{\n+\t  struct gomp_task *parent = child_task->parent;\n+\t  if (parent)\n+\t    {\n+\t      child_task->prev_child->next_child = child_task->next_child;\n+\t      child_task->next_child->prev_child = child_task->prev_child;\n+\t      if (parent->children == child_task)\n+\t\t{\n+\t\t  if (child_task->next_child != child_task)\n+\t\t    parent->children = child_task->next_child;\n+\t\t  else\n+\t\t    {\n+\t\t      parent->children = NULL;\n+\t\t      if (parent->in_taskwait)\n+\t\t\tgomp_sem_post (&parent->taskwait_sem);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  gomp_clear_parent (child_task->children);\n+\t  to_free = child_task;\n+\t  child_task = NULL;\n+\t  team->task_running_count--;\n+\t  if (--team->task_count == 0\n+\t      && gomp_team_barrier_waiting_for_tasks (&team->barrier))\n+\t    {\n+\t      gomp_team_barrier_done (&team->barrier, state);\n+\t      gomp_mutex_unlock (&team->task_lock);\n+\t      gomp_team_barrier_wake (&team->barrier, 0);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Called when encountering a taskwait directive.  */\n+\n+void\n+GOMP_taskwait (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_team *team = thr->ts.team;\n+  struct gomp_task *task = thr->task;\n+  struct gomp_task *child_task = NULL;\n+  struct gomp_task *to_free = NULL;\n+\n+  if (task == NULL || task->children == NULL)\n+    return;\n+  gomp_mutex_lock (&team->task_lock);\n+  while (1)\n+    {\n+      if (task->children == NULL)\n+\t{\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t  if (to_free)\n+\t    {\n+\t      gomp_finish_task (to_free);\n+\t      free (to_free);\n+\t    }\n+\t  return;\n+\t}\n+      if (task->children->kind == GOMP_TASK_WAITING)\n+\t{\n+\t  child_task = task->children;\n+\t  task->children = child_task->next_child;\n+\t  child_task->prev_queue->next_queue = child_task->next_queue;\n+\t  child_task->next_queue->prev_queue = child_task->prev_queue;\n+\t  if (team->task_queue == child_task)\n+\t    {\n+\t      if (child_task->next_queue != child_task)\n+\t\tteam->task_queue = child_task->next_queue;\n+\t      else\n+\t\tteam->task_queue = NULL;\n+\t    }\n+\t  child_task->kind = GOMP_TASK_TIED;\n+\t  team->task_running_count++;\n+\t  if (team->task_count == team->task_running_count)\n+\t    gomp_team_barrier_clear_task_pending (&team->barrier);\n+\t}\n+      else\n+\t/* All tasks we are waiting for are already running\n+\t   in other threads.  Wait for them.  */\n+\ttask->in_taskwait = true;\n+      gomp_mutex_unlock (&team->task_lock);\n+      if (to_free)\n+\t{\n+\t  gomp_finish_task (to_free);\n+\t  free (to_free);\n+\t  to_free = NULL;\n+\t}\n+      if (child_task)\n+\t{\n+\t  thr->task = child_task;\n+\t  child_task->fn (child_task->fn_data);\n+\t  thr->task = task;\n+\t}\n+      else\n+\t{\n+\t  gomp_sem_wait (&task->taskwait_sem);\n+\t  task->in_taskwait = false;\n+\t  return;\n+\t}\n+      gomp_mutex_lock (&team->task_lock);\n+      if (child_task)\n+\t{\n+\t  child_task->prev_child->next_child = child_task->next_child;\n+\t  child_task->next_child->prev_child = child_task->prev_child;\n+\t  if (task->children == child_task)\n+\t    {\n+\t      if (child_task->next_child != child_task)\n+\t\ttask->children = child_task->next_child;\n+\t      else\n+\t\ttask->children = NULL;\n+\t    }\n+\t  gomp_clear_parent (child_task->children);\n+\t  to_free = child_task;\n+\t  child_task = NULL;\n+\t  team->task_count--;\n+\t  team->task_running_count--;\n+\t}\n+    }\n+}"}, {"sha": "18b02e72f902b3104da1f06a5d120dd06ae29998", "filename": "libgomp/team.c", "status": "modified", "additions": 268, "deletions": 71, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -32,17 +32,12 @@\n #include <stdlib.h>\n #include <string.h>\n \n-/* This array manages threads spawned from the top level, which will\n-   return to the idle loop once the current PARALLEL construct ends.  */\n-static struct gomp_thread **gomp_threads;\n-static unsigned gomp_threads_size;\n-static unsigned gomp_threads_used;\n-\n /* This attribute contains PTHREAD_CREATE_DETACHED.  */\n pthread_attr_t gomp_thread_attr;\n \n-/* This barrier holds and releases threads waiting in gomp_threads.  */\n-static gomp_barrier_t gomp_threads_dock;\n+/* This key is for the thread destructor.  */\n+pthread_key_t gomp_thread_destructor;\n+\n \n /* This is the libgomp per-thread data structure.  */\n #ifdef HAVE_TLS\n@@ -56,9 +51,11 @@ pthread_key_t gomp_tls_key;\n \n struct gomp_thread_start_data\n {\n-  struct gomp_team_state ts;\n   void (*fn) (void *);\n   void *fn_data;\n+  struct gomp_team_state ts;\n+  struct gomp_task *task;\n+  struct gomp_thread_pool *thread_pool;\n   bool nested;\n };\n \n@@ -71,6 +68,7 @@ gomp_thread_start (void *xdata)\n {\n   struct gomp_thread_start_data *data = xdata;\n   struct gomp_thread *thr;\n+  struct gomp_thread_pool *pool;\n   void (*local_fn) (void *);\n   void *local_data;\n \n@@ -86,43 +84,46 @@ gomp_thread_start (void *xdata)\n   /* Extract what we need from data.  */\n   local_fn = data->fn;\n   local_data = data->fn_data;\n+  thr->thread_pool = data->thread_pool;\n   thr->ts = data->ts;\n+  thr->task = data->task;\n \n   thr->ts.team->ordered_release[thr->ts.team_id] = &thr->release;\n \n+  /* Make thread pool local. */\n+  pool = thr->thread_pool;\n+\n   if (data->nested)\n     {\n-      gomp_barrier_wait (&thr->ts.team->barrier);\n+      struct gomp_team *team = thr->ts.team;\n+      struct gomp_task *task = thr->task;\n+\n+      gomp_barrier_wait (&team->barrier);\n+\n       local_fn (local_data);\n-      gomp_barrier_wait (&thr->ts.team->barrier);\n+      gomp_team_barrier_wait (&team->barrier);\n+      gomp_finish_task (task);\n+      gomp_barrier_wait_last (&team->barrier);\n     }\n   else\n     {\n-      gomp_threads[thr->ts.team_id] = thr;\n+      pool->threads[thr->ts.team_id] = thr;\n \n-      gomp_barrier_wait (&gomp_threads_dock);\n+      gomp_barrier_wait (&pool->threads_dock);\n       do\n \t{\n-\t  struct gomp_team *team;\n+\t  struct gomp_team *team = thr->ts.team;\n+\t  struct gomp_task *task = thr->task;\n \n \t  local_fn (local_data);\n+\t  gomp_team_barrier_wait (&team->barrier);\n+\t  gomp_finish_task (task);\n \n-\t  /* Clear out the team and function data.  This is a debugging\n-\t     signal that we're in fact back in the dock.  */\n-\t  team = thr->ts.team;\n-\t  thr->fn = NULL;\n-\t  thr->data = NULL;\n-\t  thr->ts.team = NULL;\n-\t  thr->ts.work_share = NULL;\n-\t  thr->ts.team_id = 0;\n-\t  thr->ts.work_share_generation = 0;\n-\t  thr->ts.static_trip = 0;\n-\n-\t  gomp_barrier_wait (&team->barrier);\n-\t  gomp_barrier_wait (&gomp_threads_dock);\n+\t  gomp_barrier_wait (&pool->threads_dock);\n \n \t  local_fn = thr->fn;\n \t  local_data = thr->data;\n+\t  thr->fn = NULL;\n \t}\n       while (local_fn);\n     }\n@@ -133,28 +134,43 @@ gomp_thread_start (void *xdata)\n \n /* Create a new team data structure.  */\n \n-static struct gomp_team *\n-new_team (unsigned nthreads, struct gomp_work_share *work_share)\n+struct gomp_team *\n+gomp_new_team (unsigned nthreads)\n {\n   struct gomp_team *team;\n   size_t size;\n+  int i;\n \n-  size = sizeof (*team) + nthreads * sizeof (team->ordered_release[0]);\n+  size = sizeof (*team) + nthreads * (sizeof (team->ordered_release[0])\n+\t\t\t\t      + sizeof (team->implicit_task[0]));\n   team = gomp_malloc (size);\n-  gomp_mutex_init (&team->work_share_lock);\n \n-  team->work_shares = gomp_malloc (4 * sizeof (struct gomp_work_share *));\n-  team->generation_mask = 3;\n-  team->oldest_live_gen = work_share == NULL;\n-  team->num_live_gen = work_share != NULL;\n-  team->work_shares[0] = work_share;\n+  team->work_share_chunk = 8;\n+#ifdef HAVE_SYNC_BUILTINS\n+  team->single_count = 0;\n+#else\n+  gomp_mutex_init (&team->work_share_list_free_lock);\n+#endif\n+  gomp_init_work_share (&team->work_shares[0], false, nthreads);\n+  team->work_shares[0].next_alloc = NULL;\n+  team->work_share_list_free = NULL;\n+  team->work_share_list_alloc = &team->work_shares[1];\n+  for (i = 1; i < 7; i++)\n+    team->work_shares[i].next_free = &team->work_shares[i + 1];\n+  team->work_shares[i].next_free = NULL;\n \n   team->nthreads = nthreads;\n   gomp_barrier_init (&team->barrier, nthreads);\n \n   gomp_sem_init (&team->master_release, 0);\n+  team->ordered_release = (void *) &team->implicit_task[nthreads];\n   team->ordered_release[0] = &team->master_release;\n \n+  gomp_mutex_init (&team->task_lock);\n+  team->task_queue = NULL;\n+  team->task_count = 0;\n+  team->task_running_count = 0;\n+\n   return team;\n }\n \n@@ -164,42 +180,117 @@ new_team (unsigned nthreads, struct gomp_work_share *work_share)\n static void\n free_team (struct gomp_team *team)\n {\n-  free (team->work_shares);\n-  gomp_mutex_destroy (&team->work_share_lock);\n   gomp_barrier_destroy (&team->barrier);\n-  gomp_sem_destroy (&team->master_release);\n+  gomp_mutex_destroy (&team->task_lock);\n   free (team);\n }\n \n+/* Allocate and initialize a thread pool. */\n+\n+static struct gomp_thread_pool *gomp_new_thread_pool (void)\n+{\n+  struct gomp_thread_pool *pool\n+    = gomp_malloc (sizeof(struct gomp_thread_pool));\n+  pool->threads = NULL;\n+  pool->threads_size = 0;\n+  pool->threads_used = 0;\n+  pool->last_team = NULL;\n+  return pool;\n+}\n+\n+static void\n+gomp_free_pool_helper (void *thread_pool)\n+{\n+  struct gomp_thread_pool *pool\n+    = (struct gomp_thread_pool *) thread_pool;\n+  gomp_barrier_wait_last (&pool->threads_dock);\n+  pthread_exit (NULL);\n+}\n+\n+/* Free a thread pool and release its threads. */\n+\n+static void\n+gomp_free_thread (void *arg __attribute__((unused)))\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_thread_pool *pool = thr->thread_pool;\n+  if (pool)\n+    {\n+      if (pool->threads_used > 0)\n+\t{\n+\t  int i;\n+\t  for (i = 1; i < pool->threads_used; i++)\n+\t    {\n+\t      struct gomp_thread *nthr = pool->threads[i];\n+\t      nthr->fn = gomp_free_pool_helper;\n+\t      nthr->data = pool;\n+\t    }\n+\t  /* This barrier undocks threads docked on pool->threads_dock.  */\n+\t  gomp_barrier_wait (&pool->threads_dock);\n+\t  /* And this waits till all threads have called gomp_barrier_wait_last\n+\t     in gomp_free_pool_helper.  */\n+\t  gomp_barrier_wait (&pool->threads_dock);\n+\t  /* Now it is safe to destroy the barrier and free the pool.  */\n+\t  gomp_barrier_destroy (&pool->threads_dock);\n+\t}\n+      free (pool->threads);\n+      if (pool->last_team)\n+\tfree_team (pool->last_team);\n+      free (pool);\n+      thr->thread_pool = NULL;\n+    }\n+  if (thr->task != NULL)\n+    {\n+      struct gomp_task *task = thr->task;\n+      gomp_end_task ();\n+      free (task);\n+    }\n+}\n \n /* Launch a team.  */\n \n void\n gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n-\t\t struct gomp_work_share *work_share)\n+\t\t struct gomp_team *team)\n {\n   struct gomp_thread_start_data *start_data;\n   struct gomp_thread *thr, *nthr;\n-  struct gomp_team *team;\n+  struct gomp_task *task;\n+  struct gomp_task_icv *icv;\n   bool nested;\n+  struct gomp_thread_pool *pool;\n   unsigned i, n, old_threads_used = 0;\n   pthread_attr_t thread_attr, *attr;\n \n   thr = gomp_thread ();\n   nested = thr->ts.team != NULL;\n-\n-  team = new_team (nthreads, work_share);\n+  if (__builtin_expect (thr->thread_pool == NULL, 0))\n+    {\n+      thr->thread_pool = gomp_new_thread_pool ();\n+      pthread_setspecific (gomp_thread_destructor, thr);\n+    }\n+  pool = thr->thread_pool;\n+  task = thr->task;\n+  icv = task ? &task->icv : &gomp_global_icv;\n \n   /* Always save the previous state, even if this isn't a nested team.\n      In particular, we should save any work share state from an outer\n      orphaned work share construct.  */\n   team->prev_ts = thr->ts;\n \n   thr->ts.team = team;\n-  thr->ts.work_share = work_share;\n   thr->ts.team_id = 0;\n-  thr->ts.work_share_generation = 0;\n+  ++thr->ts.level;\n+  if (nthreads > 1)\n+    ++thr->ts.active_level;\n+  thr->ts.work_share = &team->work_shares[0];\n+  thr->ts.last_work_share = NULL;\n+#ifdef HAVE_SYNC_BUILTINS\n+  thr->ts.single_count = 0;\n+#endif\n   thr->ts.static_trip = 0;\n+  thr->task = &team->implicit_task[0];\n+  gomp_init_task (thr->task, task, icv);\n \n   if (nthreads == 1)\n     return;\n@@ -213,38 +304,45 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n      only the initial program thread will modify gomp_threads.  */\n   if (!nested)\n     {\n-      old_threads_used = gomp_threads_used;\n+      old_threads_used = pool->threads_used;\n \n       if (nthreads <= old_threads_used)\n \tn = nthreads;\n       else if (old_threads_used == 0)\n \t{\n \t  n = 0;\n-\t  gomp_barrier_init (&gomp_threads_dock, nthreads);\n+\t  gomp_barrier_init (&pool->threads_dock, nthreads);\n \t}\n       else\n \t{\n \t  n = old_threads_used;\n \n \t  /* Increase the barrier threshold to make sure all new\n \t     threads arrive before the team is released.  */\n-\t  gomp_barrier_reinit (&gomp_threads_dock, nthreads);\n+\t  gomp_barrier_reinit (&pool->threads_dock, nthreads);\n \t}\n \n       /* Not true yet, but soon will be.  We're going to release all\n-\t threads from the dock, and those that aren't part of the \n+\t threads from the dock, and those that aren't part of the\n \t team will exit.  */\n-      gomp_threads_used = nthreads;\n+      pool->threads_used = nthreads;\n \n       /* Release existing idle threads.  */\n       for (; i < n; ++i)\n \t{\n-\t  nthr = gomp_threads[i];\n+\t  nthr = pool->threads[i];\n \t  nthr->ts.team = team;\n-\t  nthr->ts.work_share = work_share;\n+\t  nthr->ts.work_share = &team->work_shares[0];\n+\t  nthr->ts.last_work_share = NULL;\n \t  nthr->ts.team_id = i;\n-\t  nthr->ts.work_share_generation = 0;\n+\t  nthr->ts.level = team->prev_ts.level + 1;\n+\t  nthr->ts.active_level = thr->ts.active_level;\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  nthr->ts.single_count = 0;\n+#endif\n \t  nthr->ts.static_trip = 0;\n+\t  nthr->task = &team->implicit_task[i];\n+\t  gomp_init_task (nthr->task, task, icv);\n \t  nthr->fn = fn;\n \t  nthr->data = data;\n \t  team->ordered_release[i] = &nthr->release;\n@@ -254,20 +352,36 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \tgoto do_release;\n \n       /* If necessary, expand the size of the gomp_threads array.  It is\n-\t expected that changes in the number of threads is rare, thus we\n+\t expected that changes in the number of threads are rare, thus we\n \t make no effort to expand gomp_threads_size geometrically.  */\n-      if (nthreads >= gomp_threads_size)\n+      if (nthreads >= pool->threads_size)\n \t{\n-\t  gomp_threads_size = nthreads + 1;\n-\t  gomp_threads\n-\t    = gomp_realloc (gomp_threads,\n-\t\t\t    gomp_threads_size\n+\t  pool->threads_size = nthreads + 1;\n+\t  pool->threads\n+\t    = gomp_realloc (pool->threads,\n+\t\t\t    pool->threads_size\n \t\t\t    * sizeof (struct gomp_thread_data *));\n \t}\n     }\n \n+  if (__builtin_expect (nthreads > old_threads_used, 0))\n+    {\n+      long diff = (long) nthreads - (long) old_threads_used;\n+\n+      if (old_threads_used == 0)\n+\t--diff;\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+      __sync_fetch_and_add (&gomp_managed_threads, diff);\n+#else\n+      gomp_mutex_lock (&gomp_remaining_threads_lock);\n+      gomp_managed_threads += diff;\n+      gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+#endif\n+    }\n+\n   attr = &gomp_thread_attr;\n-  if (gomp_cpu_affinity != NULL)\n+  if (__builtin_expect (gomp_cpu_affinity != NULL, 0))\n     {\n       size_t stacksize;\n       pthread_attr_init (&thread_attr);\n@@ -286,13 +400,21 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n       pthread_t pt;\n       int err;\n \n+      start_data->fn = fn;\n+      start_data->fn_data = data;\n       start_data->ts.team = team;\n-      start_data->ts.work_share = work_share;\n+      start_data->ts.work_share = &team->work_shares[0];\n+      start_data->ts.last_work_share = NULL;\n       start_data->ts.team_id = i;\n-      start_data->ts.work_share_generation = 0;\n+      start_data->ts.level = team->prev_ts.level + 1;\n+      start_data->ts.active_level = thr->ts.active_level;\n+#ifdef HAVE_SYNC_BUILTINS\n+      start_data->ts.single_count = 0;\n+#endif\n       start_data->ts.static_trip = 0;\n-      start_data->fn = fn;\n-      start_data->fn_data = data;\n+      start_data->task = &team->implicit_task[i];\n+      gomp_init_task (start_data->task, task, icv);\n+      start_data->thread_pool = pool;\n       start_data->nested = nested;\n \n       if (gomp_cpu_affinity != NULL)\n@@ -303,18 +425,30 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \tgomp_fatal (\"Thread creation failed: %s\", strerror (err));\n     }\n \n-  if (gomp_cpu_affinity != NULL)\n+  if (__builtin_expect (gomp_cpu_affinity != NULL, 0))\n     pthread_attr_destroy (&thread_attr);\n \n  do_release:\n-  gomp_barrier_wait (nested ? &team->barrier : &gomp_threads_dock);\n+  gomp_barrier_wait (nested ? &team->barrier : &pool->threads_dock);\n \n   /* Decrease the barrier threshold to match the number of threads\n      that should arrive back at the end of this team.  The extra\n      threads should be exiting.  Note that we arrange for this test\n      to never be true for nested teams.  */\n-  if (nthreads < old_threads_used)\n-    gomp_barrier_reinit (&gomp_threads_dock, nthreads);\n+  if (__builtin_expect (nthreads < old_threads_used, 0))\n+    {\n+      long diff = (long) nthreads - (long) old_threads_used;\n+\n+      gomp_barrier_reinit (&pool->threads_dock, nthreads);\n+\n+#ifdef HAVE_SYNC_BUILTINS\n+      __sync_fetch_and_add (&gomp_managed_threads, diff);\n+#else\n+      gomp_mutex_lock (&gomp_remaining_threads_lock);\n+      gomp_managed_threads += diff;\n+      gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+#endif\n+    }\n }\n \n \n@@ -327,11 +461,52 @@ gomp_team_end (void)\n   struct gomp_thread *thr = gomp_thread ();\n   struct gomp_team *team = thr->ts.team;\n \n-  gomp_barrier_wait (&team->barrier);\n+  /* This barrier handles all pending explicit threads.  */\n+  gomp_team_barrier_wait (&team->barrier);\n+  gomp_fini_work_share (thr->ts.work_share);\n \n+  gomp_end_task ();\n   thr->ts = team->prev_ts;\n \n-  free_team (team);\n+  if (__builtin_expect (thr->ts.team != NULL, 0))\n+    {\n+#ifdef HAVE_SYNC_BUILTINS\n+      __sync_fetch_and_add (&gomp_managed_threads, 1L - team->nthreads);\n+#else\n+      gomp_mutex_lock (&gomp_remaining_threads_lock);\n+      gomp_managed_threads -= team->nthreads - 1L;\n+      gomp_mutex_unlock (&gomp_remaining_threads_lock);\n+#endif\n+      /* This barrier has gomp_barrier_wait_last counterparts\n+\t and ensures the team can be safely destroyed.  */\n+      gomp_barrier_wait (&team->barrier);\n+    }\n+\n+  if (__builtin_expect (team->work_shares[0].next_alloc != NULL, 0))\n+    {\n+      struct gomp_work_share *ws = team->work_shares[0].next_alloc;\n+      do\n+\t{\n+\t  struct gomp_work_share *next_ws = ws->next_alloc;\n+\t  free (ws);\n+\t  ws = next_ws;\n+\t}\n+      while (ws != NULL);\n+    }\n+  gomp_sem_destroy (&team->master_release);\n+#ifndef HAVE_SYNC_BUILTINS\n+  gomp_mutex_destroy (&team->work_share_list_free_lock);\n+#endif\n+\n+  if (__builtin_expect (thr->ts.team != NULL, 0))\n+    free_team (team);\n+  else\n+    {\n+      struct gomp_thread_pool *pool = thr->thread_pool;\n+      if (pool->last_team)\n+\tfree_team (pool->last_team);\n+      pool->last_team = team;\n+    }\n }\n \n \n@@ -349,10 +524,32 @@ initialize_team (void)\n   pthread_setspecific (gomp_tls_key, &initial_thread_tls_data);\n #endif\n \n+  if (pthread_key_create (&gomp_thread_destructor, gomp_free_thread) != 0)\n+    gomp_fatal (\"could not create thread pool destructor.\");\n+\n #ifdef HAVE_TLS\n   thr = &gomp_tls_data;\n #else\n   thr = &initial_thread_tls_data;\n #endif\n   gomp_sem_init (&thr->release, 0);\n }\n+\n+static void __attribute__((destructor))\n+team_destructor (void)\n+{\n+  /* Without this dlclose on libgomp could lead to subsequent\n+     crashes.  */\n+  pthread_key_delete (gomp_thread_destructor);\n+}\n+\n+struct gomp_task_icv *\n+gomp_new_icv (void)\n+{\n+  struct gomp_thread *thr = gomp_thread ();\n+  struct gomp_task *task = gomp_malloc (sizeof (struct gomp_task));\n+  gomp_init_task (task, NULL, &gomp_global_icv);\n+  thr->task = task;\n+  pthread_setspecific (gomp_thread_destructor, thr);\n+  return &task->icv;\n+}"}, {"sha": "ae1806fb2da277f167346e0054903cd592916b87", "filename": "libgomp/testsuite/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.in?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -112,9 +112,15 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n NM = @NM@\n OBJEXT = @OBJEXT@\n+OMP_LOCK_25_ALIGN = @OMP_LOCK_25_ALIGN@\n+OMP_LOCK_25_KIND = @OMP_LOCK_25_KIND@\n+OMP_LOCK_25_SIZE = @OMP_LOCK_25_SIZE@\n OMP_LOCK_ALIGN = @OMP_LOCK_ALIGN@\n OMP_LOCK_KIND = @OMP_LOCK_KIND@\n OMP_LOCK_SIZE = @OMP_LOCK_SIZE@\n+OMP_NEST_LOCK_25_ALIGN = @OMP_NEST_LOCK_25_ALIGN@\n+OMP_NEST_LOCK_25_KIND = @OMP_NEST_LOCK_25_KIND@\n+OMP_NEST_LOCK_25_SIZE = @OMP_NEST_LOCK_25_SIZE@\n OMP_NEST_LOCK_ALIGN = @OMP_NEST_LOCK_ALIGN@\n OMP_NEST_LOCK_KIND = @OMP_NEST_LOCK_KIND@\n OMP_NEST_LOCK_SIZE = @OMP_NEST_LOCK_SIZE@"}, {"sha": "f3f42de66193c9ae8aadf40639e5ef9a1b07d4f2", "filename": "libgomp/testsuite/libgomp.c++/c++.exp", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -31,8 +31,15 @@ if { $lang_test_file_found } {\n     set ld_library_path \"$always_ld_library_path:${blddir}/${lang_library_path}\"\n     set_ld_library_path_env_vars\n \n+    set flags_file \"${blddir}/../libstdc++-v3/scripts/testsuite_flags\"\n+    if { [file exists $flags_file] } {\n+\tset libstdcxx_includes [exec sh $flags_file --build-includes]\n+    } else {\n+\tset libstdcxx_includes \"\"\n+    }\n+\n     # Main loop.\n-    gfortran-dg-runtest $tests \"\"\n+    gfortran-dg-runtest $tests $libstdcxx_includes\n }\n \n # All done."}, {"sha": "132d35cf41d6dd87585326e1b6ed73d50c901208", "filename": "libgomp/testsuite/libgomp.c++/collapse-1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcollapse-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcollapse-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcollapse-1.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+int\n+main ()\n+{\n+  int i, j, k, l = 0;\n+  int a[3][3][3];\n+\n+  memset (a, '\\0', sizeof (a));\n+  #pragma omp parallel for collapse(4 - 1) schedule(static, 4)\n+    for (i = 0; i < 2; i++)\n+      for (j = 0; j < 2; j++)\n+\tfor (k = 0; k < 2; k++)\n+\t  a[i][j][k] = i + j * 4 + k * 16;\n+  #pragma omp parallel\n+    {\n+      #pragma omp for collapse(2) reduction(|:l) private (k)\n+\tfor (i = 0; i < 2; i++)\n+\t  for (j = 0; j < 2; j++)\n+\t    for (k = 0; k < 2; k++)\n+\t      if (a[i][j][k] != i + j * 4 + k * 16)\n+\t\tl = 1;\n+    }\n+  if (l)\n+    abort ();\n+}"}, {"sha": "a42a1f07ffd2a3875018d2e06b73bae360475203", "filename": "libgomp/testsuite/libgomp.c++/collapse-2.C", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcollapse-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcollapse-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcollapse-2.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,371 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () { p = (T *) 0; }\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+void\n+f1 (J<int> x, J<int> y, J<int> z)\n+{\n+  I<int> i, j, k;\n+  int l, f = 0, n = 0, m = 0;\n+#pragma omp parallel shared (i, j, k, l) firstprivate (f) \\\n+\t\t     reduction (+:n, m) num_threads (8)\n+  {\n+  #pragma omp for lastprivate (i, j, k, l) schedule (static, 9) \\\n+\t\t  collapse (4)\n+    for (i = x.begin (); i < x.end (); ++i)\n+      for (j = y.begin (); j <= y.end (); j += 1)\n+\tfor (l = 0; l < 1; l++)\n+\t  for (k = z.begin () + 3; k < z.end () - 3; k++)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((*i + 2) * 12 + (*j + 5) * 4 + (*k - 13)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+  }\n+  if (n || i != x.end () || j != y.end () + 1 || k != z.end () - 3\n+      || m != 72 || l != 1)\n+    abort ();\n+}\n+\n+void\n+f2 (J<int> x, J<int> y, J<int> z)\n+{\n+  int f = 0, n = 0, m = 0;\n+#pragma omp parallel for firstprivate (f) reduction (+:n, m) \\\n+\t\t\t num_threads (8) schedule (static, 9) \\\n+\t\t\t collapse (6 - 2)\n+  for (I<int> i = x.end () - 1; i >= x.begin (); --i)\n+    for (int l = -131; l >= -131; l--)\n+      for (I<int> j = y.end (); j > y.begin () - 1; j -= 1)\n+\t{\n+\t  for (I<int> k = z.end () - 4; k >= z.begin () + 3; k--)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((3 - *i) * 12 + (-3 - *j) * 4 + (16 - *k)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+\t}\n+  if (n || m != 72)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+f3 (J<int> x, J<int> y, J<int> z)\n+{\n+  I<int> i, j, k;\n+  int l, f = 0, n = 0, m = 0;\n+#pragma omp parallel shared (i, j, k, l) firstprivate (f) \\\n+\t\t     reduction (+:n, m) num_threads (8)\n+  {\n+  #pragma omp for lastprivate (i, j, k, l) schedule (static, 9) \\\n+\t\t  collapse (4)\n+    for (i = x.begin (); i < x.end (); ++i)\n+      for (j = y.begin (); j <= y.end (); j += 1)\n+\tfor (k = z.begin () + 3; k < z.end () - 3; k++)\n+\t  for (l = 7; l <= 7; l++)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((*i + 2) * 12 + (*j + 5) * 4 + (*k - 13)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+  }\n+  if (n || i != x.end () || j != y.end () + 1 || k != z.end () - 3\n+      || m != 72 || l != 8)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+f4 (J<int> x, J<int> y, J<int> z)\n+{\n+  int f = 0, n = 0, m = 0;\n+#pragma omp parallel for firstprivate (f) reduction (+:n, m) \\\n+\t\t\t num_threads (8) schedule (static, 9) \\\n+\t\t\t collapse (5 - 2)\n+  for (I<int> i = x.end () - 1; i >= x.begin (); --i)\n+    {\n+      for (I<int> j = y.end (); j > y.begin () - 1; j -= 1)\n+\t{\n+\t  for (I<int> k = z.end () - 4; k >= z.begin () + 3; k--)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((3 - *i) * 12 + (-3 - *j) * 4 + (16 - *k)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+\t}\n+    }\n+  if (n || m != 72)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+f5 (J<int> x, J<int> y, J<int> z)\n+{\n+  I<int> i, j, k;\n+  int f = 0, n = 0, m = 0;\n+#pragma omp parallel shared (i, j, k) firstprivate (f) \\\n+\t\t     reduction (+:n, m) num_threads (8)\n+  {\n+  #pragma omp for lastprivate (i, j, k) schedule (static, 9) \\\n+\t\t  collapse (3)\n+    for (i = x.begin (); i < x.end (); ++i)\n+      for (j = y.begin (); j <= y.end (); j += (T) 1)\n+\t{\n+\t  for (k = z.begin () + 3; k < z.end () - 3; k++)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((*i + 2) * 12 + (*j + 5) * 4 + (*k - 13)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+\t}\n+  }\n+  if (n || i != x.end () || j != y.end () + 1 || k != z.end () - 3\n+      || m != 72)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+f6 (J<int> x, J<int> y, J<int> z)\n+{\n+  int f = 0, n = 0, m = 0;\n+#pragma omp parallel for firstprivate (f) reduction (+:n, m) \\\n+\t\t\t num_threads (8) schedule (static, 9) \\\n+\t\t\t collapse (5 - 2)\n+  for (I<int> i = x.end () - 1; i >= x.begin (); --i)\n+    {\n+      for (I<int> j = y.end (); j > y.begin () - 1; j -= 1)\n+\t{\n+\t  for (I<int> k = z.end () - 4; k >= z.begin () + (T) 3; k--)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((3 - *i) * 12 + (-3 - *j) * 4 + (16 - *k)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+\t}\n+    }\n+  if (n || m != 72)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+f7 (J<T> x, J<T> y, J<T> z)\n+{\n+  I<T> i, j, k, o = y.begin ();\n+  T l, f = 0, n = 0, m = 0;\n+#pragma omp parallel shared (i, j, k, l) firstprivate (f) \\\n+\t\t     reduction (+:n, m) num_threads (8)\n+  {\n+  #pragma omp for lastprivate (i, j, k, l) schedule (static, 9) \\\n+\t\t  collapse (4)\n+    for (i = x.begin (); i < x.end (); ++i)\n+      for (j = y.begin (); j <= y.end (); j += 1)\n+\tfor (l = *o; l <= *o; l = 1 + l)\n+\t  for (k = z.begin () + 3; k < z.end () - 3; k++)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((*i + 2) * 12 + (*j + 5) * 4 + (*k - 13)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+  }\n+  if (n || i != x.end () || j != y.end () + 1 || k != z.end () - 3\n+      || m != 72 || l != *o + 1)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+f8 (J<T> x, J<T> y, J<T> z)\n+{\n+  T f = 0, n = 0, m = 0;\n+#pragma omp parallel for firstprivate (f) reduction (+:n, m) \\\n+\t\t\t num_threads (8) schedule (static, 9) \\\n+\t\t\t collapse (6 - 2)\n+  for (I<T> i = x.end () - 1; i >= x.begin (); --i)\n+    for (T l = 0; l < 1; l++)\n+      for (I<T> j = y.end (); j > y.begin () - 1; j -= 1)\n+\t{\n+\t  for (I<T> k = z.end () - 4; k >= z.begin () + 3; k--)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((3 - *i) * 12 + (-3 - *j) * 4 + (16 - *k)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+\t}\n+  if (n || m != 72)\n+    abort ();\n+}\n+\n+template <typename S, typename T>\n+void\n+f9 (J<T> x, J<T> y, J<T> z)\n+{\n+  S i, j, k, o = y.begin ();\n+  T l, f = 0, n = 0, m = 0;\n+#pragma omp parallel shared (i, j, k, l) firstprivate (f) \\\n+\t\t     reduction (+:n, m) num_threads (8)\n+  {\n+  #pragma omp for lastprivate (i, j, k, l) schedule (static, 9) \\\n+\t\t  collapse (4)\n+    for (i = x.begin (); i < x.end (); ++i)\n+      for (j = y.begin (); j <= y.end (); j += 1)\n+\tfor (l = *o; l <= *o; l = 1 + l)\n+\t  for (k = z.begin () + 3; k < z.end () - 3; k++)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((*i + 2) * 12 + (*j + 5) * 4 + (*k - 13)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+  }\n+  if (n || i != x.end () || j != y.end () + 1 || k != z.end () - 3\n+      || m != 72 || l != *o + 1)\n+    abort ();\n+}\n+\n+template <typename S, typename T>\n+void\n+f10 (J<T> x, J<T> y, J<T> z)\n+{\n+  T f = 0, n = 0, m = 0;\n+#pragma omp parallel for firstprivate (f) reduction (+:n, m) \\\n+\t\t\t num_threads (8) schedule (static, 9) \\\n+\t\t\t collapse (6 - 2)\n+  for (S i = x.end () - 1; i >= x.begin (); --i)\n+    for (T l = 0; l < 1; l++)\n+      for (S j = y.end (); j > y.begin () - 1; j -= 1)\n+\t{\n+\t  for (S k = z.end () - 4; k >= z.begin () + 3; k--)\n+\t    if (omp_get_num_threads () == 8\n+\t\t&& ((3 - *i) * 12 + (-3 - *j) * 4 + (16 - *k)\n+\t\t    != (omp_get_thread_num () * 9 + f++)))\n+\t      n++;\n+\t    else\n+\t      m++;\n+\t}\n+  if (n || m != 72)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  long b[2000];\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i - 1000;\n+      b[i] = i - 1000;\n+    }\n+  J<int> x (&a[998], &a[1004]);\n+  J<int> y (&a[995], &a[997]);\n+  J<int> z (&a[1010], &a[1020]);\n+  f1 (x, y, z);\n+  f2 (x, y, z);\n+  f3 <int> (x, y, z);\n+  f4 <int> (x, y, z);\n+  f5 <int> (x, y, z);\n+  f6 <int> (x, y, z);\n+  f7 <int> (x, y, z);\n+  f8 <int> (x, y, z);\n+  f9 <I<int>, int> (x, y, z);\n+  f10 <I<int>, int> (x, y, z);\n+}"}, {"sha": "f46e45ec4187032f9d201eba1cc20ba9cfdab1fb", "filename": "libgomp/testsuite/libgomp.c++/ctor-10.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-10.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,78 @@\n+// { dg-do run }\n+// { dg-require-effective-target tls_runtime }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+#define N 10\n+#define THR 4\n+\n+struct B\n+{\n+  B();\n+  B(const B &);\n+  ~B();\n+  B& operator=(const B &);\n+  void doit();\n+  static B *base;\n+  static B *threadbase;\n+#pragma omp threadprivate(threadbase)\n+};\n+\n+B *B::base;\n+B *B::threadbase;\n+static unsigned cmask[THR];\n+static unsigned dmask[THR];\n+\n+B::B()\n+{\n+  assert (base == 0);\n+}\n+\n+B::B(const B &b)\n+{\n+  unsigned index = &b - base;\n+  assert (index < N);\n+  cmask[omp_get_thread_num()] |= 1u << index;\n+}\n+\n+B::~B()\n+{\n+  if (threadbase)\n+    {\n+      unsigned index = this - threadbase;\n+      assert (index < N);\n+      dmask[omp_get_thread_num()] |= 1u << index;\n+    }\n+}\n+\n+void foo()\n+{\n+  B b[N];\n+\n+  B::base = b;\n+\n+  #pragma omp parallel firstprivate(b)\n+    {\n+      assert (omp_get_num_threads () == THR);\n+      B::threadbase = b;\n+    }\n+\n+  B::threadbase = 0;\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (THR);\n+  foo();\n+\n+  for (int i = 0; i < THR; ++i)\n+    {\n+      unsigned xmask = (1u << N) - 1;\n+      assert (cmask[i] == xmask);\n+      assert (dmask[i] == xmask);\n+    }\n+\n+  return 0;\n+}"}, {"sha": "1c713464ebe7dca1366ba31e78363689d2640a7e", "filename": "libgomp/testsuite/libgomp.c++/for-1.C", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-1.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,291 @@\n+// { dg-do run }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () {}\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T>\n+void\n+baz (I<T> &i)\n+{\n+  if (*i < 0 || *i >= 2000)\n+    abort ();\n+  results[*i]++;\n+}\n+\n+void\n+f1 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x; i <= y; i += 6)\n+    baz (i);\n+}\n+\n+void\n+f2 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for private(i)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f3 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x; i <= y; i = i + 9 - 8)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f4 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for lastprivate(i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (i);\n+}\n+\n+void\n+f5 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f6 (const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (I<int> i = x + 2000 - 64; i > y + 10; i = i - 12 + 2)\n+    {\n+      I<int> j = i + N;\n+      baz (j);\n+    }\n+}\n+\n+template <int N>\n+void\n+f7 (I<int> i, const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for\n+  for (i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f8 (J<int> j)\n+{\n+  I<int> i;\n+#pragma omp parallel for\n+  for (i = j.begin (); i <= j.end () + N; i += 2)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f9 (const I<T> &x, const I<T> &y)\n+{\n+#pragma omp parallel for\n+  for (I<T> i = x; i <= y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f10 (const I<T> &x, const I<T> &y)\n+{\n+  I<T> i;\n+#pragma omp parallel for\n+  for (i = x; i > y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f11 (const T &x, const T &y)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp for nowait\n+    for (T i = x; i <= y; i += 3)\n+      baz (i);\n+#pragma omp single\n+    {\n+      T j = y + 3;\n+      baz (j);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void\n+f12 (const T &x, const T &y)\n+{\n+  T i;\n+#pragma omp parallel for\n+  for (i = x; i > y; --i)\n+    baz (i);\n+}\n+\n+template <int N>\n+struct K\n+{\n+  template <typename T>\n+  static void\n+  f13 (const T &x, const T &y)\n+  {\n+#pragma omp parallel for\n+    for (T i = x; i <= y + N; i += N)\n+      baz (i);\n+  }\n+};\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  long b[2000];\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i;\n+    }\n+  f1 (&a[10], &a[1990]);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  f2 (&a[0], &a[1999]);\n+  check (i < 1998 && (i & 1) == 0);\n+  f3<char> (&a[20], &a[1837]);\n+  check (i >= 20 && i <= 1837);\n+  f4<int> (&a[0], &a[30]);\n+  check (i > 40 && i <= 2000 - 64);\n+  f5 (&a[0], &a[100]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f6<-10> (&a[10], &a[110]);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f7<6> (I<int> (), &a[12], &a[1800]);\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  f8<121> (J<int> (&a[14], &a[1803]));\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  f9<int, 7> (&a[33], &a[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<int, -7> (&a[1939], &a[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<int> > (&a[16], &a[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<int> > (&a[1761], &a[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<int> > (&a[1], &a[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+  f9<long, 7> (&b[33], &b[1967]);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<long, -7> (&b[1939], &b[17]);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<I<long> > (&b[16], &b[1981]);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<I<long> > (&b[1761], &b[37]);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<I<long> > (&b[1], &b[1935]);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+}"}, {"sha": "98ffa1ae6f00163bf821c1cda2fd377f827e2484", "filename": "libgomp/testsuite/libgomp.c++/for-2.C", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-2.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,182 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(T x, T y) : b (x), e (y) {}\n+  T begin ();\n+  T end ();\n+private:\n+  T b, e;\n+};\n+\n+template <typename T> T J<T>::begin () { return b; }\n+template <typename T> T J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+void\n+baz (int i)\n+{\n+  if (i < 0 || i >= 2000)\n+    abort ();\n+  results[i]++;\n+}\n+\n+void\n+f1 (int x, int y)\n+{\n+#pragma omp parallel for\n+  for (int i = x; i <= y; i += 6)\n+    baz (i);\n+}\n+\n+void\n+f2 (int x, int y)\n+{\n+  int i;\n+#pragma omp parallel for private(i)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f3 (int x, int y)\n+{\n+#pragma omp parallel for\n+  for (int i = x; i <= y; i = i + 9 - 8)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f4 (int x, int y)\n+{\n+  int i;\n+#pragma omp parallel for lastprivate(i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (i);\n+}\n+\n+void\n+f5 (int x, int y)\n+{\n+#pragma omp parallel for\n+  for (int i = x + 2000 - 64; i > y + 10L; i -= 10L)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f6 (int x, int y)\n+{\n+#pragma omp parallel for\n+  for (int i = x + 2000 - 64; i > y + 10L; i = i - 12 + 2L)\n+    baz (i + N);\n+}\n+\n+template <long N>\n+void\n+f7 (int i, int x, int y)\n+{\n+#pragma omp parallel for\n+  for (i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+}\n+\n+template <long N>\n+void\n+f8 (J<int> j)\n+{\n+  int i;\n+#pragma omp parallel for\n+  for (i = j.begin (); i <= j.end () + N; i += 2)\n+    baz (i);\n+}\n+\n+template <typename T, long N>\n+void\n+f9 (T x, T y)\n+{\n+#pragma omp parallel for\n+  for (T i = x; i <= y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T, long N>\n+void\n+f10 (T x, T y)\n+{\n+  T i;\n+#pragma omp parallel for\n+  for (i = x; i > y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f11 (T x, long y)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp for nowait\n+    for (T i = x; i <= y; i += 3L)\n+      baz (i);\n+#pragma omp single\n+    baz (y + 3);\n+  }\n+}\n+\n+template <typename T>\n+void\n+f12 (T x, T y)\n+{\n+  T i;\n+#pragma omp parallel for\n+  for (i = x; i > y; --i)\n+    baz (i);\n+}\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  f1 (10, 1990);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  f2 (0, 1999);\n+  check (i < 1998 && (i & 1) == 0);\n+  f3<char> (20, 1837);\n+  check (i >= 20 && i <= 1837);\n+  f4<int> (0, 30);\n+  check (i > 40 && i <= 2000 - 64);\n+  f5 (0, 100);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f6<-10> (10, 110);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f7<6> (0, 12, 1800);\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  f8<121> (J<int> (14, 1803));\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  f9<int, 7> (33, 1967);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<int, -7> (1939, 17);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<int> (16, 1981);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<int> (1761, 37);\n+  check (i > 37 && i <= 1761);\n+}"}, {"sha": "235f83875ea57135622b2087b6c4c15e0d9e827f", "filename": "libgomp/testsuite/libgomp.c++/for-3.C", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-3.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,239 @@\n+// { dg-do run }\n+\n+#include <vector>\n+#include <cstdlib>\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  typedef typename std::vector<T>::const_iterator const_iterator;\n+  J(const const_iterator &x, const const_iterator &y) : b (x), e (y) {}\n+  const const_iterator &begin ();\n+  const const_iterator &end ();\n+private:\n+  const_iterator b, e;\n+};\n+\n+template <typename T>\n+const typename std::vector<T>::const_iterator &J<T>::begin () { return b; }\n+template <typename T>\n+const typename std::vector<T>::const_iterator &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T>\n+void\n+baz (T &i)\n+{\n+  if (*i < 0 || *i >= 2000)\n+    std::abort ();\n+  results[*i]++;\n+}\n+\n+void\n+f1 (const std::vector<int>::const_iterator &x,\n+    const std::vector<int>::const_iterator &y)\n+{\n+#pragma omp parallel for\n+  for (std::vector<int>::const_iterator i = x; i <= y; i += 6)\n+    baz (i);\n+}\n+\n+void\n+f2 (const std::vector<int>::const_iterator &x,\n+    const std::vector<int>::const_iterator &y)\n+{\n+  std::vector<int>::const_iterator i;\n+#pragma omp parallel for private(i)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f3 (const std::vector<int>::const_iterator &x,\n+    const std::vector<int>::const_iterator &y)\n+{\n+#pragma omp parallel for schedule (dynamic, 6)\n+  for (std::vector<int>::const_iterator i = x; i <= y; i = i + 9 - 8)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f4 (const std::vector<int>::const_iterator &x,\n+    const std::vector<int>::const_iterator &y)\n+{\n+  std::vector<int>::const_iterator i;\n+#pragma omp parallel for lastprivate(i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (i);\n+}\n+\n+void\n+f5 (const std::vector<int>::const_iterator &x,\n+    const std::vector<int>::const_iterator &y)\n+{\n+#pragma omp parallel for schedule (static, 10)\n+  for (std::vector<int>::const_iterator i = x + 2000 - 64; i > y + 10; i -= 10)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f6 (const std::vector<int>::const_iterator &x,\n+    const std::vector<int>::const_iterator &y)\n+{\n+#pragma omp parallel for schedule (runtime)\n+  for (std::vector<int>::const_iterator i = x + 2000 - 64;\n+       i > y + 10; i = i - 12 + 2)\n+    {\n+      std::vector<int>::const_iterator j = i + N;\n+      baz (j);\n+    }\n+}\n+\n+template <int N>\n+void\n+f7 (std::vector<int>::const_iterator i,\n+    const std::vector<int>::const_iterator &x,\n+    const std::vector<int>::const_iterator &y)\n+{\n+#pragma omp parallel for schedule (dynamic, 6)\n+  for (i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f8 (J<int> j)\n+{\n+  std::vector<int>::const_iterator i;\n+#pragma omp parallel for schedule (dynamic, 40)\n+  for (i = j.begin (); i <= j.end () + N; i += 2)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f9 (const typename std::vector<T>::const_iterator &x,\n+    const typename std::vector<T>::const_iterator &y)\n+{\n+#pragma omp parallel for schedule (static, 25)\n+  for (typename std::vector<T>::const_iterator i = x; i <= y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f10 (const typename std::vector<T>::const_iterator &x,\n+     const typename std::vector<T>::const_iterator &y)\n+{\n+  typename std::vector<T>::const_iterator i;\n+#pragma omp parallel for\n+  for (i = x; i > y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f11 (const T &x, const T &y)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp for nowait schedule (static, 2)\n+    for (T i = x; i <= y; i += 3)\n+      baz (i);\n+#pragma omp single\n+    {\n+      T j = y + 3;\n+      baz (j);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void\n+f12 (const T &x, const T &y)\n+{\n+  T i;\n+#pragma omp parallel for schedule (dynamic, 130)\n+  for (i = x; i > y; --i)\n+    baz (i);\n+}\n+\n+template <int N>\n+struct K\n+{\n+  template <typename T>\n+  static void\n+  f13 (const T &x, const T &y)\n+  {\n+#pragma omp parallel for schedule (runtime)\n+    for (T i = x; i <= y + N; i += N)\n+      baz (i);\n+  }\n+};\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  std::abort ();\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      std::abort ()\n+\n+int\n+main ()\n+{\n+  std::vector<int> a(2000);\n+  std::vector<long> b(2000);\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i;\n+    }\n+  f1 (a.begin () + 10, a.begin () + 1990);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  f2 (a.begin () + 0, a.begin () + 1999);\n+  check (i < 1998 && (i & 1) == 0);\n+  f3<char> (a.begin () + 20, a.begin () + 1837);\n+  check (i >= 20 && i <= 1837);\n+  f4<int> (a.begin () + 0, a.begin () + 30);\n+  check (i > 40 && i <= 2000 - 64);\n+  f5 (a.begin () + 0, a.begin () + 100);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f6<-10> (a.begin () + 10, a.begin () + 110);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f7<6> (std::vector<int>::const_iterator (), a.begin () + 12,\n+\t a.begin () + 1800);\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  f8<121> (J<int> (a.begin () + 14, a.begin () + 1803));\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  f9<int, 7> (a.begin () + 33, a.begin () + 1967);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<int, -7> (a.begin () + 1939, a.begin () + 17);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<std::vector<int>::const_iterator > (a.begin () + 16, a.begin () + 1981);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<std::vector<int>::const_iterator > (a.begin () + 1761, a.begin () + 37);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<std::vector<int>::const_iterator > (a.begin () + 1,\n+\t\t\t\t\t\ta.begin () + 1935);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+  f9<long, 7> (b.begin () + 33, b.begin () + 1967);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<long, -7> (b.begin () + 1939, b.begin () + 17);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<std::vector<long>::const_iterator > (b.begin () + 16, b.begin () + 1981);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<std::vector<long>::const_iterator > (b.begin () + 1761, b.begin () + 37);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<std::vector<long>::const_iterator > (b.begin () + 1,\n+\t\t\t\t\t\t b.begin () + 1935);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+}"}, {"sha": "c528ef9d1faabb237e2377215cb81613a9fef93d", "filename": "libgomp/testsuite/libgomp.c++/for-4.C", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-4.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,225 @@\n+// { dg-do run }\n+\n+#include <string>\n+#include <cstdlib>\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  typedef typename std::basic_string<T>::iterator iterator;\n+  J(const iterator &x, const iterator &y) : b (x), e (y) {}\n+  const iterator &begin ();\n+  const iterator &end ();\n+private:\n+  iterator b, e;\n+};\n+\n+template <typename T>\n+const typename std::basic_string<T>::iterator &J<T>::begin () { return b; }\n+template <typename T>\n+const typename std::basic_string<T>::iterator &J<T>::end () { return e; }\n+\n+template <typename T>\n+void\n+baz (T &i)\n+{\n+  if (*i < L'a' || *i >= L'a' + 2000)\n+    std::abort ();\n+  (*i)++;\n+}\n+\n+void\n+f1 (const std::basic_string<wchar_t>::iterator &x,\n+    const std::basic_string<wchar_t>::iterator &y)\n+{\n+#pragma omp parallel for\n+  for (std::basic_string<wchar_t>::iterator i = x; i <= y; i += 6)\n+    baz (i);\n+}\n+\n+void\n+f2 (const std::basic_string<wchar_t>::iterator &x,\n+    const std::basic_string<wchar_t>::iterator &y)\n+{\n+  std::basic_string<wchar_t>::iterator i;\n+#pragma omp parallel for private(i)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f3 (const std::basic_string<wchar_t>::iterator &x,\n+    const std::basic_string<wchar_t>::iterator &y)\n+{\n+#pragma omp parallel for schedule (dynamic, 6)\n+  for (std::basic_string<wchar_t>::iterator i = x; i <= y; i = i + 9 - 8)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f4 (const std::basic_string<wchar_t>::iterator &x,\n+    const std::basic_string<wchar_t>::iterator &y)\n+{\n+  std::basic_string<wchar_t>::iterator i;\n+#pragma omp parallel for lastprivate(i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (i);\n+}\n+\n+void\n+f5 (const std::basic_string<wchar_t>::iterator &x,\n+    const std::basic_string<wchar_t>::iterator &y)\n+{\n+#pragma omp parallel for schedule (static, 10)\n+  for (std::basic_string<wchar_t>::iterator i = x + 2000 - 64;\n+       i > y + 10; i -= 10)\n+    baz (i);\n+}\n+\n+template <int N>\n+void\n+f6 (const std::basic_string<wchar_t>::iterator &x,\n+    const std::basic_string<wchar_t>::iterator &y)\n+{\n+#pragma omp parallel for schedule (runtime)\n+  for (std::basic_string<wchar_t>::iterator i = x + 2000 - 64;\n+       i > y + 10; i = i - 12 + 2)\n+    {\n+      std::basic_string<wchar_t>::iterator j = i + N;\n+      baz (j);\n+    }\n+}\n+\n+template <int N>\n+void\n+f7 (std::basic_string<wchar_t>::iterator i,\n+    const std::basic_string<wchar_t>::iterator &x,\n+    const std::basic_string<wchar_t>::iterator &y)\n+{\n+#pragma omp parallel for schedule (dynamic, 6)\n+  for (i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+}\n+\n+template <wchar_t N>\n+void\n+f8 (J<wchar_t> j)\n+{\n+  std::basic_string<wchar_t>::iterator i;\n+#pragma omp parallel for schedule (dynamic, 40)\n+  for (i = j.begin (); i <= j.end () + N; i += 2)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f9 (const typename std::basic_string<T>::iterator &x,\n+    const typename std::basic_string<T>::iterator &y)\n+{\n+#pragma omp parallel for schedule (static, 25)\n+  for (typename std::basic_string<T>::iterator i = x; i <= y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T, int N>\n+void\n+f10 (const typename std::basic_string<T>::iterator &x,\n+     const typename std::basic_string<T>::iterator &y)\n+{\n+  typename std::basic_string<T>::iterator i;\n+#pragma omp parallel for\n+  for (i = x; i > y; i = i + N)\n+    baz (i);\n+}\n+\n+template <typename T>\n+void\n+f11 (const T &x, const T &y)\n+{\n+#pragma omp parallel\n+  {\n+#pragma omp for nowait schedule (static, 2)\n+    for (T i = x; i <= y; i += 3)\n+      baz (i);\n+#pragma omp single\n+    {\n+      T j = y + 3;\n+      baz (j);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void\n+f12 (const T &x, const T &y)\n+{\n+  T i;\n+#pragma omp parallel for schedule (dynamic, 130)\n+  for (i = x; i > y; --i)\n+    baz (i);\n+}\n+\n+template <int N>\n+struct K\n+{\n+  template <typename T>\n+  static void\n+  f13 (const T &x, const T &y)\n+  {\n+#pragma omp parallel for schedule (runtime)\n+    for (T i = x; i <= y + N; i += N)\n+      baz (i);\n+  }\n+};\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (a[i] != L'a' + i + 1)\t\t\t\\\n+\t  std::abort ();\t\t\t\t\\\n+\ta[i] = L'a' + i;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (a[i] != L'a' + i)\t\t\t\t\\\n+      std::abort ()\n+\n+int\n+main ()\n+{\n+  std::basic_string<wchar_t> a = L\"\";\n+  for (int i = 0; i < 2000; i++)\n+    a += L'a' + i;\n+  f1 (a.begin () + 10, a.begin () + 1990);\n+  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n+  f2 (a.begin () + 0, a.begin () + 1999);\n+  check (i < 1998 && (i & 1) == 0);\n+  f3<char> (a.begin () + 20, a.begin () + 1837);\n+  check (i >= 20 && i <= 1837);\n+  f4<int> (a.begin () + 0, a.begin () + 30);\n+  check (i > 40 && i <= 2000 - 64);\n+  f5 (a.begin () + 0, a.begin () + 100);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f6<-10> (a.begin () + 10, a.begin () + 110);\n+  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n+  f7<6> (std::basic_string<wchar_t>::iterator (), a.begin () + 12,\n+\t a.begin () + 1800);\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  f8<121> (J<wchar_t> (a.begin () + 14, a.begin () + 1803));\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  f9<wchar_t, 7> (a.begin () + 33, a.begin () + 1967);\n+  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n+  f10<wchar_t, -7> (a.begin () + 1939, a.begin () + 17);\n+  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n+  f11<std::basic_string<wchar_t>::iterator > (a.begin () + 16,\n+\t\t\t\t\t      a.begin () + 1981);\n+  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n+  f12<std::basic_string<wchar_t>::iterator > (a.begin () + 1761,\n+\t\t\t\t\t      a.begin () + 37);\n+  check (i > 37 && i <= 1761);\n+  K<5>::f13<std::basic_string<wchar_t>::iterator > (a.begin () + 1,\n+\t\t\t\t\t\t    a.begin () + 1935);\n+  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n+}"}, {"sha": "9b75bf379ceea760c0d0cafe904a28be853875ec", "filename": "libgomp/testsuite/libgomp.c++/for-5.C", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ffor-5.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,303 @@\n+// { dg-do run }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+extern \"C\" void abort ();\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+template <typename T> I<T>::I () : p (0) {}\n+template <typename T> I<T>::~I () { p = (T *) 0; }\n+template <typename T> I<T>::I (T *x) : p (x) {}\n+template <typename T> I<T>::I (const I &x) : p (x.p) {}\n+template <typename T> T &I<T>::operator * () { return *p; }\n+template <typename T> T *I<T>::operator -> () { return p; }\n+template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n+template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n+template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n+template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n+template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n+template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n+template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n+template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n+template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n+template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n+template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n+template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n+template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n+template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n+template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n+template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n+template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n+template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n+template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n+template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n+\n+template <typename T>\n+class J\n+{\n+public:\n+  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n+  const I<T> &begin ();\n+  const I<T> &end ();\n+private:\n+  I<T> b, e;\n+};\n+\n+template <typename T> const I<T> &J<T>::begin () { return b; }\n+template <typename T> const I<T> &J<T>::end () { return e; }\n+\n+int results[2000];\n+\n+template <typename T>\n+void\n+baz (I<T> &i)\n+{\n+  if (*i < 0 || *i >= 2000)\n+    abort ();\n+  results[*i]++;\n+}\n+\n+I<int>\n+f1 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel shared (i)\n+  {\n+  #pragma omp for lastprivate (i) schedule(runtime)\n+    for (i = x; i < y - 1; ++i)\n+      baz (i);\n+  #pragma omp single\n+    i += 3;\n+  }\n+  return I<int> (i);\n+}\n+\n+I<int>\n+f2 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x; i < y - 1; i = 1 - 6 + 7 + i)\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <typename T>\n+I<int>\n+f3 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel\n+  #pragma omp for lastprivate (i)\n+    for (i = x + 1000 - 64; i <= y - 10; i++)\n+      baz (i);\n+  return i;\n+}\n+\n+template <typename T>\n+I<int>\n+f4 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x + 2000 - 64; i > y + 10; --i)\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <typename T>\n+I<int>\n+f5 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x; i > y + T (6); i--)\n+    baz (i);\n+  return i;\n+}\n+\n+template <typename T>\n+I<int>\n+f6 (const I<int> &x, const I<int> &y)\n+{\n+  I<int> i;\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x - T (7); i > y; i -= T (2))\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <int N>\n+I<int>\n+f7 (I<int> i, const I<int> &x, const I<int> &y)\n+{\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x - 10; i <= y + 10; i += N)\n+    baz (i);\n+  return I<int> (i);\n+}\n+\n+template <int N>\n+I<int>\n+f8 (J<int> j)\n+{\n+  I<int> i;\n+#pragma omp parallel shared (i)\n+  #pragma omp for lastprivate (i)\n+    for (i = j.begin (); i <= j.end () + N; i += 2)\n+      baz (i);\n+  return i;\n+}\n+\n+I<int> i9;\n+\n+template <long N>\n+I<int> &\n+f9 (J<int> j)\n+{\n+#pragma omp parallel for lastprivate (i9)\n+  for (i9 = j.begin () + N; i9 <= j.end () - N; i9 = i9 - N)\n+    baz (i9);\n+  return i9;\n+}\n+\n+template <typename T, int N>\n+I<T>\n+f10 (const I<T> &x, const I<T> &y)\n+{\n+  I<T> i;\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x; i > y; i = i + N)\n+    baz (i);\n+  return i;\n+}\n+\n+template <typename T, typename U>\n+T\n+f11 (T i, const T &x, const T &y)\n+{\n+#pragma omp parallel\n+  #pragma omp for lastprivate (i)\n+  for (i = x + U (2); i <= y + U (1); i = U (2) + U (3) + i)\n+    baz (i);\n+  return T (i);\n+}\n+\n+template <typename T>\n+T\n+f12 (const T &x, const T &y)\n+{\n+  T i;\n+#pragma omp parallel for lastprivate (i)\n+  for (i = x; i > y; --i)\n+    baz (i);\n+  return i;\n+}\n+\n+#define check(expr) \\\n+  for (int i = 0; i < 2000; i++)\t\t\t\\\n+    if (expr)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (results[i] != 1)\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\\\n+\tresults[i] = 0;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else if (results[i])\t\t\t\t\\\n+      abort ()\n+\n+int\n+main ()\n+{\n+  int a[2000];\n+  long b[2000];\n+  for (int i = 0; i < 2000; i++)\n+    {\n+      a[i] = i;\n+      b[i] = i;\n+    }\n+  if (*f1 (&a[10], &a[1873]) != 1875)\n+    abort ();\n+  check (i >= 10 && i < 1872);\n+  if (*f2 (&a[0], &a[1998]) != 1998)\n+    abort ();\n+  check (i < 1997 && (i & 1) == 0);\n+  if (*f3<int> (&a[10], &a[1971]) != 1962)\n+    abort ();\n+  check (i >= 946 && i <= 1961);\n+  if (*f4<int> (&a[0], &a[30]) != 40)\n+    abort ();\n+  check (i > 40 && i <= 2000 - 64);\n+  if (*f5<short> (&a[1931], &a[17]) != 23)\n+    abort ();\n+  check (i > 23 && i <= 1931);\n+  if (*f6<long> (&a[1931], &a[17]) != 16)\n+    abort ();\n+  check (i > 17 && i <= 1924 && (i & 1) == 0);\n+  if (*f7<6> (I<int> (), &a[12], &a[1800]) != 1814)\n+    abort ();\n+  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n+  if (*f8<121> (J<int> (&a[14], &a[1803])) != 1926)\n+    abort ();\n+  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n+  if (*f9<-3L> (J<int> (&a[27], &a[1761])) != 1767)\n+    abort ();\n+  check (i >= 24 && i <= 1764 && (i % 3) == 0);\n+  if (*f10<int, -7> (&a[1939], &a[17]) != 14)\n+    abort ();\n+  check (i >= 21 && i <= 1939 && i % 7 == 0);\n+  if (*f11<I<int>, short> (I<int> (), &a[71], &a[1941]) != 1943)\n+    abort ();\n+  check (i >= 73 && i <= 1938 && (i - 73) % 5 == 0);\n+  if (*f12<I<int> > (&a[1761], &a[37]) != 37)\n+    abort ();\n+  check (i > 37 && i <= 1761);\n+  if (*f10<long, -7> (&b[1939], &b[17]) != 14)\n+    abort ();\n+  check (i >= 21 && i <= 1939 && i % 7 == 0);\n+  if (*f11<I<long>, short> (I<long> (), &b[71], &b[1941]) != 1943)\n+    abort ();\n+  check (i >= 73 && i <= 1938 && (i - 73) % 5 == 0);\n+  if (*f12<I<long> > (&b[1761], &b[37]) != 37)\n+    abort ();\n+  check (i > 37 && i <= 1761);\n+}"}, {"sha": "9c0de25d56fc761dc52421a72af06c327b665bb5", "filename": "libgomp/testsuite/libgomp.c++/loop-10.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-10.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,105 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+\n+extern \"C\" void abort (void);\n+\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)\n+#define INT_MAX __INT_MAX__\n+\n+int v;\n+\n+int\n+test1 (void)\n+{\n+  int e = 0, cnt = 0;\n+  long long i;\n+  unsigned long long j;\n+  char buf[6], *p;\n+\n+  #pragma omp for schedule(dynamic,1) collapse(2) nowait\n+  for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      if ((i != LLONG_MAX - 30001\n+\t   && i != LLONG_MAX - 20001\n+\t   && i != LLONG_MAX - 10001)\n+\t  || j != 20)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(guided,1) collapse(2) nowait\n+  for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      if ((i != -LLONG_MAX + 30000\n+\t   && i != -LLONG_MAX + 20000\n+\t   && i != -LLONG_MAX + 10000)\n+\t  || j != ULLONG_MAX - 3)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(static,1) collapse(2) nowait\n+  for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+    for (j = 20; j <= LLONG_MAX - 70 + v; j += LLONG_MAX + 50ULL)\n+      if ((i != LLONG_MAX - 30001\n+\t   && i != LLONG_MAX - 20001\n+\t   && i != LLONG_MAX - 10001)\n+\t  || j != 20)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(static) collapse(2) nowait\n+  for (i = -LLONG_MAX + 30000 + v; i >= -LLONG_MAX + 10000; i -= 10000)\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      if ((i != -LLONG_MAX + 30000\n+\t   && i != -LLONG_MAX + 20000\n+\t   && i != -LLONG_MAX + 10000)\n+\t  || j != ULLONG_MAX - 3)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(runtime) collapse(2) nowait\n+  for (i = 10; i < 30; i++)\n+    for (p = buf; p <= buf + 4; p += 2)\n+      if (i < 10 || i >= 30 || (p != buf && p != buf + 2 && p != buf + 4))\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 60)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  if (2 * sizeof (int) != sizeof (long long))\n+    return 0;\n+  asm volatile (\"\" : \"+r\" (v));\n+  omp_set_schedule (omp_sched_dynamic, 1);\n+  test1 ();\n+  return 0;\n+}"}, {"sha": "bc20c68a16748384d19d5e8dfcbb9e796c704f6f", "filename": "libgomp/testsuite/libgomp.c++/loop-8.C", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-8.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,276 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int\n+test1 ()\n+{\n+  short int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test2 ()\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test3 ()\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test4 ()\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test4 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test4 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test4 ();\n+  return 0;\n+}"}, {"sha": "35daf2276e8cc5d6000a8002185c9025fe7497e6", "filename": "libgomp/testsuite/libgomp.c++/loop-9.C", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-9.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,387 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+\n+extern \"C\" void abort ();\n+\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)\n+#define INT_MAX __INT_MAX__\n+\n+int arr[6 * 5];\n+\n+void\n+set (int loopidx, int idx)\n+{\n+#pragma omp atomic\n+  arr[loopidx * 5 + idx]++;\n+}\n+\n+#define check(var, val, loopidx, idx) \\\n+  if (var == (val)) set (loopidx, idx); else\n+#define test(loopidx, count) \\\n+  for (idx = 0; idx < 5; idx++) \\\n+    if (arr[loopidx * 5 + idx] != idx < count) \\\n+      abort (); \\\n+    else \\\n+      arr[loopidx * 5 + idx] = 0\n+\n+int\n+test1 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test2 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test3 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test4 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test5 ()\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  if (2 * sizeof (int) != sizeof (long long))\n+    return 0;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test5 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test5 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test5 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test5 ();\n+  return 0;\n+}"}, {"sha": "535a8287b0cfb3ecc6ffdd623a83acbaefd8a2a7", "filename": "libgomp/testsuite/libgomp.c++/task-1.C", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-1.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,83 @@\n+extern \"C\" void abort ();\n+\n+int a = 18;\n+\n+void\n+f1 (int i, int j, int k)\n+{\n+  int l = 6, m = 7, n = 8;\n+#pragma omp task private(j, m) shared(k, n)\n+  {\n+    j = 6;\n+    m = 5;\n+    if (++a != 19 || ++i != 9 || j != 6 || ++l != 7 || m != 5 || ++n != 9)\n+      #pragma omp atomic\n+\tk++;\n+  }\n+#pragma omp taskwait\n+  if (a != 19 || i != 8 || j != 26 || k != 0 || l != 6 || m != 7 || n != 9)\n+    abort ();\n+}\n+\n+int v1 = 1, v2 = 2, v5 = 5;\n+int err;\n+\n+void\n+f2 (void)\n+{\n+  int v3 = 3;\n+#pragma omp sections private (v1) firstprivate (v2)\n+  {\n+  #pragma omp section\n+    {\n+      int v4 = 4;\n+      v1 = 7;\n+      #pragma omp task\n+\t{\n+\t  if (++v1 != 8 || ++v2 != 3 || ++v3 != 4 || ++v4 != 5 || ++v5 != 6)\n+\t    err = 1;\n+\t}\n+      #pragma omp taskwait\n+      if (v1 != 7 || v2 != 2 || v3 != 3 || v4 != 4 || v5 != 6)\n+\tabort ();\n+      if (err)\n+\tabort ();\n+    }\n+  }\n+}\n+\n+void\n+f3 (int i, int j, int k)\n+{\n+  int l = 6, m = 7, n = 8;\n+#pragma omp task private(j, m) shared(k, n) untied\n+  {\n+    j = 6;\n+    m = 5;\n+    if (++a != 19 || ++i != 9 || j != 6 || ++l != 7 || m != 5 || ++n != 9)\n+      #pragma omp atomic\n+\tk++;\n+  }\n+#pragma omp taskwait\n+  if (a != 19 || i != 8 || j != 26 || k != 0 || l != 6 || m != 7 || n != 9)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  f1 (8, 26, 0);\n+  f2 ();\n+  a = 18;\n+  f3 (8, 26, 0);\n+  a = 18;\n+#pragma omp parallel num_threads(4)\n+  {\n+    #pragma omp master\n+      {\n+\tf1 (8, 26, 0);\n+\ta = 18;\n+\tf3 (8, 26, 0);\n+      }\n+  }\n+}"}, {"sha": "a198cc721b56d540137679e7831509c06668ef6b", "filename": "libgomp/testsuite/libgomp.c++/task-2.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-2.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,70 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+extern \"C\" void abort ();\n+\n+int l = 5;\n+\n+int\n+foo (int i)\n+{\n+  int j = 7;\n+  const int k = 8;\n+  #pragma omp task firstprivate (i) shared (j, l)\n+  {\n+    #pragma omp critical\n+      {\n+\tj += i;\n+\tl += k;\n+      }\n+  }\n+  i++;\n+  #pragma omp task firstprivate (i) shared (j, l)\n+  {\n+    #pragma omp critical\n+      {\n+\tj += i;\n+\tl += k;\n+      }\n+  }\n+  i++;\n+  #pragma omp task firstprivate (i) shared (j, l)\n+  {\n+    #pragma omp critical\n+      {\n+\tj += i;\n+\tl += k;\n+      }\n+  }\n+  i++;\n+  #pragma omp task firstprivate (i) shared (j, l)\n+  {\n+    #pragma omp critical\n+      {\n+\tj += i;\n+\tl += k;\n+      }\n+  }\n+  i++;\n+  #pragma omp taskwait\n+  return (i != 8 * omp_get_thread_num () + 4\n+\t  || j != 4 * i - 3\n+\t  || k != 8);\n+}\n+\n+int\n+main (void)\n+{\n+  int r = 0;\n+  #pragma omp parallel num_threads (4) reduction(+:r)\n+    if (omp_get_num_threads () != 4)\n+      {\n+\t#pragma omp master\n+\t  l = 133;\n+      }\n+    else if (foo (8 * omp_get_thread_num ()))\n+      r++;\n+  if (r || l != 133)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "e1ecb49654a44d9cb6161c0fb4a32616377ebd1b", "filename": "libgomp/testsuite/libgomp.c++/task-3.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-3.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,90 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+struct A\n+{\n+  A ();\n+  ~A ();\n+  A (const A &);\n+  unsigned long l;\n+};\n+\n+int e;\n+\n+A::A ()\n+{\n+  l = 17;\n+}\n+\n+A::~A ()\n+{\n+  if (l > 30)\n+    #pragma omp atomic\n+      e++;\n+}\n+\n+A::A (const A &r)\n+{\n+  l = r.l;\n+}\n+\n+void\n+check (int i, A &a, int j, A &b)\n+{\n+  if (i != 6 || a.l != 21 || j != 0 || b.l != 23)\n+    #pragma omp atomic\n+      e++;\n+}\n+\n+A b;\n+int j;\n+\n+void\n+foo (int i)\n+{\n+  A a;\n+  a.l = 21;\n+  #pragma omp task firstprivate (i, a, j, b)\n+    check (i, a, j, b);\n+}\n+\n+void\n+bar (int i, A a)\n+{\n+  a.l = 21;\n+  #pragma omp task firstprivate (i, a, j, b)\n+    check (i, a, j, b);\n+}\n+\n+A\n+baz ()\n+{\n+  A a, c;\n+  a.l = 21;\n+  c.l = 23;\n+  #pragma omp task firstprivate (a, c)\n+    check (6, a, 0, c);\n+  return a;\n+}\n+\n+int\n+main ()\n+{\n+  b.l = 23;\n+  foo (6);\n+  bar (6, A ());\n+  baz ();\n+  #pragma omp parallel num_threads (4)\n+    {\n+      #pragma omp single\n+\tfor (int i = 0; i < 64; i++)\n+\t  {\n+\t    foo (6);\n+\t    bar (6, A ());\n+\t    baz ();\n+\t  }\n+    }\n+  if (e)\n+    abort ();\n+}"}, {"sha": "f2e786a2fdd492b19376ab1bc79512ffa62d0253", "filename": "libgomp/testsuite/libgomp.c++/task-4.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-4.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,37 @@\n+#include <omp.h>\n+extern \"C\" void *memset (void *, int, __SIZE_TYPE__);\n+extern \"C\" void abort (void);\n+\n+int e;\n+\n+void\n+baz (int i, int *p, int j, int *q)\n+{\n+  if (p[0] != 1 || p[i] != 3 || q[0] != 2 || q[j] != 4)\n+    #pragma omp atomic\n+      e++;\n+}\n+\n+void\n+foo (int i, int j)\n+{\n+  int p[i + 1];\n+  int q[j + 1];\n+  memset (p, 0, sizeof (p));\n+  memset (q, 0, sizeof (q));\n+  p[0] = 1;\n+  p[i] = 3;\n+  q[0] = 2;\n+  q[j] = 4;\n+  #pragma omp task firstprivate (p, q)\n+    baz (i, p, j, q);\n+}\n+\n+int\n+main ()\n+{\n+  #pragma omp parallel num_threads (4)\n+    foo (5 + omp_get_thread_num (), 7 + omp_get_thread_num ());\n+  if (e)\n+    abort ();\n+}"}, {"sha": "c882bfe1517251e260a850d810cf28a46b9265d1", "filename": "libgomp/testsuite/libgomp.c++/task-5.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-5.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,90 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+struct A\n+{\n+  A ();\n+  ~A ();\n+  A (const A &);\n+  unsigned long l;\n+};\n+\n+int e;\n+\n+A::A ()\n+{\n+  l = 17;\n+}\n+\n+A::~A ()\n+{\n+  if (l > 130)\n+    #pragma omp atomic\n+      e++;\n+}\n+\n+A::A (const A &r)\n+{\n+  l = r.l + 64;\n+}\n+\n+void\n+check (int i, A &a, int j, A &b)\n+{\n+  if (i != 6 || a.l != 21 + 64 || j != 0 || b.l != 23 + 64)\n+    #pragma omp atomic\n+      e++;\n+}\n+\n+A b;\n+int j;\n+\n+void\n+foo (int i)\n+{\n+  A a;\n+  a.l = 21;\n+  #pragma omp task firstprivate (j, b)\n+    check (i, a, j, b);\n+}\n+\n+void\n+bar (int i, A a)\n+{\n+  a.l = 21;\n+  #pragma omp task firstprivate (j, b)\n+    check (i, a, j, b);\n+}\n+\n+A\n+baz ()\n+{\n+  A a, c;\n+  a.l = 21;\n+  c.l = 23;\n+  #pragma omp task firstprivate (a, c)\n+    check (6, a, 0, c);\n+  return a;\n+}\n+\n+int\n+main ()\n+{\n+  b.l = 23;\n+  foo (6);\n+  bar (6, A ());\n+  baz ();\n+  #pragma omp parallel num_threads (4)\n+    {\n+      #pragma omp single\n+\tfor (int i = 0; i < 64; i++)\n+\t  {\n+\t    foo (6);\n+\t    bar (6, A ());\n+\t    baz ();\n+\t  }\n+    }\n+  if (e)\n+    abort ();\n+}"}, {"sha": "cc9072b9d1c2a0df41fd360d41dcf2d016865817", "filename": "libgomp/testsuite/libgomp.c++/task-6.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftask-6.C?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,86 @@\n+extern \"C\" void abort ();\n+\n+int a = 18;\n+\n+template <typename T>\n+void\n+f1 (T i, T j, T k)\n+{\n+  T l = 6, m = 7, n = 8;\n+#pragma omp task private(j, m) shared(k, n)\n+  {\n+    j = 6;\n+    m = 5;\n+    if (++a != 19 || ++i != 9 || j != 6 || ++l != 7 || m != 5 || ++n != 9)\n+      #pragma omp atomic\n+\tk++;\n+  }\n+#pragma omp taskwait\n+  if (a != 19 || i != 8 || j != 26 || k != 0 || l != 6 || m != 7 || n != 9)\n+    abort ();\n+}\n+\n+int v1 = 1, v2 = 2, v5 = 5;\n+int err;\n+\n+template <typename T>\n+void\n+f2 (void)\n+{\n+  T v3 = 3;\n+#pragma omp sections private (v1) firstprivate (v2)\n+  {\n+  #pragma omp section\n+    {\n+      T v4 = 4;\n+      v1 = 7;\n+      #pragma omp task\n+\t{\n+\t  if (++v1 != 8 || ++v2 != 3 || ++v3 != 4 || ++v4 != 5 || ++v5 != 6)\n+\t    err = 1;\n+\t}\n+      #pragma omp taskwait\n+      if (v1 != 7 || v2 != 2 || v3 != 3 || v4 != 4 || v5 != 6)\n+\tabort ();\n+      if (err)\n+\tabort ();\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void\n+f3 (T i, T j, T k)\n+{\n+  T l = 6, m = 7, n = 8;\n+#pragma omp task private(j, m) shared(k, n) untied\n+  {\n+    j = 6;\n+    m = 5;\n+    if (++a != 19 || ++i != 9 || j != 6 || ++l != 7 || m != 5 || ++n != 9)\n+      #pragma omp atomic\n+\tk++;\n+  }\n+#pragma omp taskwait\n+  if (a != 19 || i != 8 || j != 26 || k != 0 || l != 6 || m != 7 || n != 9)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  f1 <int> (8, 26, 0);\n+  f2 <int> ();\n+  a = 18;\n+  f3 <int> (8, 26, 0);\n+  a = 18;\n+#pragma omp parallel num_threads(4)\n+  {\n+    #pragma omp master\n+      {\n+\tf1 <int> (8, 26, 0);\n+\ta = 18;\n+\tf3 <int> (8, 26, 0);\n+      }\n+  }\n+}"}, {"sha": "82becfa7952639a7f9f42c27b7a591e7f62d4d59", "filename": "libgomp/testsuite/libgomp.c/collapse-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-1.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int i, j, k, l = 0;\n+  int a[3][3][3];\n+\n+  memset (a, '\\0', sizeof (a));\n+  #pragma omp parallel for collapse(4 - 1) schedule(static, 4)\n+    for (i = 0; i < 2; i++)\n+      for (j = 0; j < 2; j++)\n+\tfor (k = 0; k < 2; k++)\n+\t  a[i][j][k] = i + j * 4 + k * 16;\n+  #pragma omp parallel\n+    {\n+      #pragma omp for collapse(2) reduction(|:l)\n+\tfor (i = 0; i < 2; i++)\n+\t  for (j = 0; j < 2; j++)\n+\t    for (k = 0; k < 2; k++)\n+\t      if (a[i][j][k] != i + j * 4 + k * 16)\n+\t\tl = 1;\n+    }\n+  if (l)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "b5c77d4614339052f0f6353345d6b31599fd0019", "filename": "libgomp/testsuite/libgomp.c/collapse-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-2.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+#include <omp.h>\n+\n+int\n+main (void)\n+{\n+  int i, j, k, l = 0, f = 0;\n+  int m1 = 4, m2 = -5, m3 = 17;\n+\n+  #pragma omp parallel for num_threads (8) collapse(3) \\\n+\t\t       schedule(static, 9) reduction(+:l) \\\n+\t\t       firstprivate(f)\n+    for (i = -2; i < m1; i++)\n+      for (j = m2; j < -2; j++)\n+\t{\n+\t  for (k = 13; k < m3; k++)\n+\t    {\n+\t      if (omp_get_num_threads () == 8\n+\t\t  && ((i + 2) * 12 + (j + 5) * 4 + (k - 13)\n+\t\t      != (omp_get_thread_num () * 9\n+\t\t\t  + f++)))\n+\t\tl++;\n+\t    }\n+\t}\n+  if (l)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "4674f83f4b67884545cc1280369a80288538298b", "filename": "libgomp/testsuite/libgomp.c/collapse-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fcollapse-3.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -std=gnu99\" } */\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int i2, l = 0;\n+  int a[3][3][3];\n+\n+  memset (a, '\\0', sizeof (a));\n+  #pragma omp parallel for collapse(4 - 1) schedule(static, 4)\n+    for (int i = 0; i < 2; i++)\n+      for (int j = 0; j < 2; j++)\n+\tfor (int k = 0; k < 2; k++)\n+\t  a[i][j][k] = i + j * 4 + k * 16;\n+  #pragma omp parallel\n+    {\n+      #pragma omp for collapse(2) reduction(|:l)\n+\tfor (i2 = 0; i2 < 2; i2++)\n+\t  for (int j = 0; j < 2; j++)\n+\t    for (int k = 0; k < 2; k++)\n+\t      if (a[i2][j][k] != i2 + j * 4 + k * 16)\n+\t\tl = 1;\n+    }\n+  if (l)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "99708f82306bb5f76919a53bed2e79bc9d8adb88", "filename": "libgomp/testsuite/libgomp.c/icv-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ficv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ficv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ficv-1.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,33 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int err = 0;\n+\n+  omp_set_num_threads (4);\n+  if (omp_get_max_threads () != 4)\n+    abort ();\n+  #pragma omp parallel reduction(|: err) num_threads(1)\n+  {\n+    if (omp_get_max_threads () != 4)\n+      err |= 1;\n+    omp_set_num_threads (6);\n+    #pragma omp task if(0) shared(err)\n+    {\n+      if (omp_get_max_threads () != 6)\n+\terr |= 2;\n+      omp_set_num_threads (5);\n+      if (omp_get_max_threads () != 5)\n+\terr |= 4;\n+    }\n+    if (omp_get_max_threads () != 6)\n+      err |= 8;\n+  }\n+  if (err)\n+    abort ();\n+  if (omp_get_max_threads () != 4)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "326f8eb404a9bf8cbc5e20b2ec25d6dbde7e29cc", "filename": "libgomp/testsuite/libgomp.c/icv-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ficv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ficv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ficv-2.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run { target *-*-linux* } } */\n+\n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE 1\n+#endif\n+#include <pthread.h>\n+#include <omp.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+pthread_barrier_t bar;\n+\n+void *tf (void *p)\n+{\n+  int l;\n+  if (p)\n+    omp_set_num_threads (3);\n+  pthread_barrier_wait (&bar);\n+  if (!p)\n+    omp_set_num_threads (6);\n+  pthread_barrier_wait (&bar);\n+  omp_set_dynamic (0);\n+  if (omp_get_max_threads () != (p ? 3 : 6))\n+    abort ();\n+  l = 0;\n+  #pragma omp parallel num_threads (6) reduction (|:l)\n+    {\n+      l |= omp_get_max_threads () != (p ? 3 : 6);\n+      omp_set_num_threads ((p ? 3 : 6) + omp_get_thread_num ());\n+      l |= omp_get_max_threads () != ((p ? 3 : 6) + omp_get_thread_num ());\n+    }\n+  if (l)\n+    abort ();\n+  return NULL;\n+}\n+\n+int\n+main (void)\n+{\n+  pthread_t th;\n+  pthread_barrier_init (&bar, NULL, 2);\n+  pthread_create (&th, NULL, tf, NULL);\n+  tf (\"\");\n+  pthread_join (th, NULL);\n+  return 0;\n+}"}, {"sha": "3a3b3f65517b636040949a3e026282713efee0b8", "filename": "libgomp/testsuite/libgomp.c/lib-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flib-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flib-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Flib-2.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,25 @@\n+#include <stdlib.h>\n+#include <omp.h>\n+\n+int\n+main (void)\n+{\n+  omp_sched_t kind;\n+  int modifier;\n+\n+  omp_set_schedule (omp_sched_static, 32);\n+  omp_get_schedule (&kind, &modifier);\n+  if (kind != omp_sched_static || modifier != 32)\n+    abort ();\n+  omp_set_schedule (omp_sched_guided, 4);\n+  omp_get_schedule (&kind, &modifier);\n+  if (kind != omp_sched_guided || modifier != 4)\n+    abort ();\n+  if (omp_get_thread_limit () < 0)\n+    abort ();\n+  omp_set_max_active_levels (6);\n+  if (omp_get_max_active_levels () != 6)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e09645dbc3f451359c5a6fa951d4378bc6da7e1f", "filename": "libgomp/testsuite/libgomp.c/lock-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-1.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,31 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int l = 0;\n+  omp_nest_lock_t lock;\n+  omp_init_nest_lock (&lock);\n+  if (omp_test_nest_lock (&lock) != 1)\n+    abort ();\n+  if (omp_test_nest_lock (&lock) != 2)\n+    abort ();\n+#pragma omp parallel if (0) reduction (+:l)\n+  {\n+    /* In OpenMP 2.5 this was supposed to return 3,\n+       but in OpenMP 3.0 the parallel region has a different\n+       task and omp_*_lock_t are owned by tasks, not by threads.  */\n+    if (omp_test_nest_lock (&lock) != 0)\n+      l++;\n+  }\n+  if (l)\n+    abort ();\n+  if (omp_test_nest_lock (&lock) != 3)\n+    abort ();\n+  omp_unset_nest_lock (&lock);\n+  omp_unset_nest_lock (&lock);\n+  omp_unset_nest_lock (&lock);\n+  omp_destroy_nest_lock (&lock);\n+  return 0;\n+}"}, {"sha": "9009b12fe5d00be5a662fd5d5cd5b956c6495285", "filename": "libgomp/testsuite/libgomp.c/lock-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-2.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,32 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int l = 0;\n+  omp_nest_lock_t lock;\n+  omp_init_nest_lock (&lock);\n+#pragma omp parallel reduction (+:l) num_threads (1)\n+  {\n+    if (omp_test_nest_lock (&lock) != 1)\n+      l++;\n+    if (omp_test_nest_lock (&lock) != 2)\n+      l++;\n+  #pragma omp task if (0) shared (lock, l)\n+    {\n+      if (omp_test_nest_lock (&lock) != 0)\n+\tl++;\n+    }\n+  #pragma omp taskwait\n+    if (omp_test_nest_lock (&lock) != 3)\n+      l++;\n+    omp_unset_nest_lock (&lock);\n+    omp_unset_nest_lock (&lock);\n+    omp_unset_nest_lock (&lock);\n+  }\n+  if (l)\n+    abort ();\n+  omp_destroy_nest_lock (&lock);\n+  return 0;\n+}"}, {"sha": "1fc83726d18c7369102b0517aa3ebb7de14994ef", "filename": "libgomp/testsuite/libgomp.c/lock-3.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Flock-3.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do run { target *-*-linux* } } */\n+\n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE 1\n+#endif\n+#include <pthread.h>\n+#include <omp.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+pthread_barrier_t bar;\n+omp_nest_lock_t lock;\n+\n+void *tf (void *p)\n+{\n+  int l;\n+  if (p)\n+    {\n+      if (omp_test_nest_lock (&lock) != 1)\n+\tabort ();\n+      if (omp_test_nest_lock (&lock) != 2)\n+\tabort ();\n+    }\n+  pthread_barrier_wait (&bar);\n+  if (!p && omp_test_nest_lock (&lock) != 0)\n+    abort ();\n+  pthread_barrier_wait (&bar);\n+  if (p)\n+    {\n+      if (omp_test_nest_lock (&lock) != 3)\n+\tabort ();\n+      omp_unset_nest_lock (&lock);\n+      omp_unset_nest_lock (&lock);\n+      omp_unset_nest_lock (&lock);\n+    }\n+  pthread_barrier_wait (&bar);\n+  if (!p)\n+    {\n+      if (omp_test_nest_lock (&lock) != 1)\n+\tabort ();\n+      if (omp_test_nest_lock (&lock) != 2)\n+\tabort ();\n+      omp_unset_nest_lock (&lock);\n+      omp_unset_nest_lock (&lock);\n+    }\n+  return NULL;\n+}\n+\n+int\n+main (void)\n+{\n+  pthread_t th;\n+  omp_init_nest_lock (&lock);\n+  pthread_barrier_init (&bar, NULL, 2);\n+  pthread_create (&th, NULL, tf, NULL);\n+  tf (\"\");\n+  pthread_join (th, NULL);\n+  omp_destroy_nest_lock (&lock);\n+  return 0;\n+}"}, {"sha": "bc57c043aad420b0b34cb21653c1347f8a4b397f", "filename": "libgomp/testsuite/libgomp.c/loop-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-4.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  int e = 0;\n+#pragma omp parallel num_threads (4) reduction(+:e)\n+  {\n+    long i;\n+    #pragma omp for schedule(dynamic,1)\n+    for (i = __LONG_MAX__ - 30001; i <= __LONG_MAX__ - 10001; i += 10000)\n+      if (i != __LONG_MAX__ - 30001\n+\t  && i != __LONG_MAX__ - 20001\n+\t  && i != __LONG_MAX__ - 10001)\n+\te = 1;\n+    #pragma omp for schedule(dynamic,1)\n+    for (i = -__LONG_MAX__ + 30000; i >= -__LONG_MAX__ + 10000; i -= 10000)\n+      if (i != -__LONG_MAX__ + 30000\n+\t  && i != -__LONG_MAX__ + 20000\n+\t  && i != -__LONG_MAX__ + 10000)\n+\te = 1;\n+  }\n+  if (e)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "3a5c7cf45560f9fd2063debf999265a51b089dd1", "filename": "libgomp/testsuite/libgomp.c/loop-5.c", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-5.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,276 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int\n+test1 (void)\n+{\n+  short int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test2 (void)\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (static, 3)\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test3 (void)\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (dynamic, 3)\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+test4 (void)\n+{\n+  int buf[64], *p;\n+  int i;\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[10]; p < &buf[54]; p++)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[3]; p <= &buf[63]; p += 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; p < &buf[51]; p = 4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[16]; p <= &buf[40]; p = p + 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[53]; p > &buf[9]; --p)\n+    *p = 5;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 5 * (i >= 10 && i < 54))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[63]; p >= &buf[3]; p -= 2)\n+    p[-2] = 6;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 6 * ((i & 1) && i <= 61))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[48]; p > &buf[15]; p = -4 + p)\n+    p[2] = 7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != 7 * ((i & 3) == 2 && i >= 18 && i < 53))\n+      abort ();\n+  memset (buf, '\\0', sizeof (buf));\n+#pragma omp parallel for schedule (runtime)\n+  for (p = &buf[40]; p >= &buf[16]; p = p - 4ULL)\n+    p[2] = -7;\n+  for (i = 0; i < 64; i++)\n+    if (buf[i] != -7 * ((i & 3) == 2 && i >= 18 && i <= 42))\n+      abort ();\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test4 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test4 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test4 ();\n+  return 0;\n+}"}, {"sha": "9029e181bd245e161b06baaf4882293cfe39eedc", "filename": "libgomp/testsuite/libgomp.c/loop-6.c", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-6.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,387 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+\n+extern void abort (void);\n+\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)\n+#define INT_MAX __INT_MAX__\n+\n+int arr[6 * 5];\n+\n+void\n+set (int loopidx, int idx)\n+{\n+#pragma omp atomic\n+  arr[loopidx * 5 + idx]++;\n+}\n+\n+#define check(var, val, loopidx, idx) \\\n+  if (var == (val)) set (loopidx, idx); else\n+#define test(loopidx, count) \\\n+  for (idx = 0; idx < 5; idx++) \\\n+    if (arr[loopidx * 5 + idx] != idx < count) \\\n+      abort (); \\\n+    else \\\n+      arr[loopidx * 5 + idx] = 0\n+\n+int\n+test1 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(dynamic,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test2 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(guided,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test3 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test4 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(static,1) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+test5 (void)\n+{\n+  int e = 0, idx;\n+\n+#pragma omp parallel reduction(+:e)\n+  {\n+    long long i;\n+    unsigned long long j;\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+      {\n+\tcheck (i, LLONG_MAX - 30001, 0, 0)\n+\tcheck (i, LLONG_MAX - 20001, 0, 1)\n+\tcheck (i, LLONG_MAX - 10001, 0, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+      {\n+\tcheck (i, -LLONG_MAX + 30000, 1, 0)\n+\tcheck (i, -LLONG_MAX + 20000, 1, 1)\n+\tcheck (i, -LLONG_MAX + 10000, 1, 2)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, 20, 2, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      {\n+\tcheck (j, ULLONG_MAX - 3, 3, 0)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (j = LLONG_MAX - 20000ULL; j <= LLONG_MAX + 10000ULL; j += 10000ULL)\n+      {\n+\tcheck (j, LLONG_MAX - 20000ULL, 4, 0)\n+\tcheck (j, LLONG_MAX - 10000ULL, 4, 1)\n+\tcheck (j, LLONG_MAX, 4, 2)\n+\tcheck (j, LLONG_MAX + 10000ULL, 4, 3)\n+\te = 1;\n+      }\n+    #pragma omp for schedule(runtime) nowait\n+    for (i = -3LL * INT_MAX - 20000LL; i <= INT_MAX + 10000LL; i += INT_MAX + 200LL)\n+      {\n+\tcheck (i, -3LL * INT_MAX - 20000LL, 5, 0)\n+\tcheck (i, -2LL * INT_MAX - 20000LL + 200LL, 5, 1)\n+\tcheck (i, -INT_MAX - 20000LL + 400LL, 5, 2)\n+\tcheck (i, -20000LL + 600LL, 5, 3)\n+\tcheck (i, INT_MAX - 20000LL + 800LL, 5, 4)\n+\te = 1;\n+      }\n+  }\n+  if (e)\n+    abort ();\n+  test (0, 3);\n+  test (1, 3);\n+  test (2, 1);\n+  test (3, 1);\n+  test (4, 4);\n+  test (5, 5);\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  if (2 * sizeof (int) != sizeof (long long))\n+    return 0;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  omp_set_schedule (omp_sched_static, 0);\n+  test5 ();\n+  omp_set_schedule (omp_sched_static, 3);\n+  test5 ();\n+  omp_set_schedule (omp_sched_dynamic, 5);\n+  test5 ();\n+  omp_set_schedule (omp_sched_guided, 2);\n+  test5 ();\n+  return 0;\n+}"}, {"sha": "fc97f4a2907d0eb5e8ca7bab1e4b85100def14d1", "filename": "libgomp/testsuite/libgomp.c/loop-7.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-7.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390", "patch": "@@ -0,0 +1,105 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+\n+extern void abort (void);\n+\n+#define LLONG_MAX __LONG_LONG_MAX__\n+#define ULLONG_MAX (LLONG_MAX * 2ULL + 1)\n+#define INT_MAX __INT_MAX__\n+\n+int v;\n+\n+int\n+test1 (void)\n+{\n+  int e = 0, cnt = 0;\n+  long long i;\n+  unsigned long long j;\n+  char buf[6], *p;\n+\n+  #pragma omp for schedule(dynamic,1) collapse(2) nowait\n+  for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+    for (j = 20; j <= LLONG_MAX - 70; j += LLONG_MAX + 50ULL)\n+      if ((i != LLONG_MAX - 30001\n+\t   && i != LLONG_MAX - 20001\n+\t   && i != LLONG_MAX - 10001)\n+\t  || j != 20)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(guided,1) collapse(2) nowait\n+  for (i = -LLONG_MAX + 30000; i >= -LLONG_MAX + 10000; i -= 10000)\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      if ((i != -LLONG_MAX + 30000\n+\t   && i != -LLONG_MAX + 20000\n+\t   && i != -LLONG_MAX + 10000)\n+\t  || j != ULLONG_MAX - 3)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(static,1) collapse(2) nowait\n+  for (i = LLONG_MAX - 30001; i <= LLONG_MAX - 10001; i += 10000)\n+    for (j = 20; j <= LLONG_MAX - 70 + v; j += LLONG_MAX + 50ULL)\n+      if ((i != LLONG_MAX - 30001\n+\t   && i != LLONG_MAX - 20001\n+\t   && i != LLONG_MAX - 10001)\n+\t  || j != 20)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(static) collapse(2) nowait\n+  for (i = -LLONG_MAX + 30000 + v; i >= -LLONG_MAX + 10000; i -= 10000)\n+    for (j = ULLONG_MAX - 3; j >= LLONG_MAX + 70ULL; j -= LLONG_MAX + 50ULL)\n+      if ((i != -LLONG_MAX + 30000\n+\t   && i != -LLONG_MAX + 20000\n+\t   && i != -LLONG_MAX + 10000)\n+\t  || j != ULLONG_MAX - 3)\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 3)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  #pragma omp for schedule(runtime) collapse(2) nowait\n+  for (i = 10; i < 30; i++)\n+    for (p = buf; p <= buf + 4; p += 2)\n+      if (i < 10 || i >= 30 || (p != buf && p != buf + 2 && p != buf + 4))\n+\te = 1;\n+      else\n+\tcnt++;\n+  if (e || cnt != 60)\n+    abort ();\n+  else\n+    cnt = 0;\n+\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  if (2 * sizeof (int) != sizeof (long long))\n+    return 0;\n+  asm volatile (\"\" : \"+r\" (v));\n+  omp_set_schedule (omp_sched_dynamic, 1);\n+  test1 ();\n+  return 0;\n+}"}, {"sha": "25db25c3b431acba01fb40c73b23aa0a317f1732", "filename": "libgomp/testsuite/libgomp.c/loop-8.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-8.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "1f789e12ecbdcb800518f5ab60333e76b408eb40", "filename": "libgomp/testsuite/libgomp.c/loop-9.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-9.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "618600633ac2e89a674654dc5ac30a809d4c42d5", "filename": "libgomp/testsuite/libgomp.c/nested-3.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnested-3.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "c0ace6b3fb85b38a00a4d3b6961ce782444ebcc7", "filename": "libgomp/testsuite/libgomp.c/nestedfn-6.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fnestedfn-6.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "c052e8112885fdeb4a174880081f34cc2ae1662c", "filename": "libgomp/testsuite/libgomp.c/pr26943-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-2.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "dc3d5010da1df1ff0dd1ccccae0f4fd1028007cf", "filename": "libgomp/testsuite/libgomp.c/pr26943-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-3.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "0f1d4197a5f12a7dd6e57ed3cae794bd8365c717", "filename": "libgomp/testsuite/libgomp.c/pr26943-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr26943-4.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "269d69da12c614b6c92b65494fdc41c6269cffde", "filename": "libgomp/testsuite/libgomp.c/sort-1.c", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fsort-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Fsort-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fsort-1.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "66f58a29b87c188d37ca5368fc7f41d63a0c92f7", "filename": "libgomp/testsuite/libgomp.c/task-1.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-1.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "ed6a09c355781ac9af740e49af6d07a564a5e041", "filename": "libgomp/testsuite/libgomp.c/task-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-2.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "5657346bd15877f3e4351996b67f88721775f898", "filename": "libgomp/testsuite/libgomp.c/task-3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-3.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "18435930019154056af3a4111243fcceb3528308", "filename": "libgomp/testsuite/libgomp.c/task-4.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftask-4.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "1efe2abe959b82f8dc26abbef3f6ce23db098a62", "filename": "libgomp/testsuite/libgomp.fortran/allocatable1.f90", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "a37616b04b1c1966016d88439a08839c86585df5", "filename": "libgomp/testsuite/libgomp.fortran/allocatable2.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable2.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "fe3714a2b1ff80134ba08961102b6c0fc89c15c1", "filename": "libgomp/testsuite/libgomp.fortran/allocatable3.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable3.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "996578c94fa2686d7cefc5d70d7fb743fe14ed5b", "filename": "libgomp/testsuite/libgomp.fortran/allocatable4.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocatable4.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "1ecfa0c93650e5733cf55dbcdc7d2cd757b4867f", "filename": "libgomp/testsuite/libgomp.fortran/collapse1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "77e0dee82608a856cf0d1df1e1cc3c356faf8d30", "filename": "libgomp/testsuite/libgomp.fortran/collapse2.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse2.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "eac9eac651bc2faba7b7da6cf6e65dc257c78083", "filename": "libgomp/testsuite/libgomp.fortran/collapse3.f90", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse3.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "f19b0f6c695c671d2d1b193b0ff8cd628b0609ff", "filename": "libgomp/testsuite/libgomp.fortran/collapse4.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcollapse4.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "91bb96ca75ad3ac6f0db8a16f84ffec3caf5b82d", "filename": "libgomp/testsuite/libgomp.fortran/lastprivate1.f90", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flastprivate1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flastprivate1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flastprivate1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "6d7e11eab00e2e06d7bccb59f30d38e88d7b4619", "filename": "libgomp/testsuite/libgomp.fortran/lastprivate2.f90", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flastprivate2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flastprivate2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flastprivate2.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "cbb984574ffa5e1664adc014db1af12bd76554ef", "filename": "libgomp/testsuite/libgomp.fortran/lib4.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib4.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "d7d3e3fd6cc902d4f59c8bdc45aeb91318e2cf22", "filename": "libgomp/testsuite/libgomp.fortran/lock-1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flock-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flock-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flock-1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "9965139b9ba9d716a094a054c0cf38d264e60005", "filename": "libgomp/testsuite/libgomp.fortran/lock-2.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flock-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flock-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flock-2.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "98c4322d0bf3fd8f277553057201e24762386ede", "filename": "libgomp/testsuite/libgomp.fortran/nested1.f90", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnested1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnested1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnested1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "c987bf440b04517350ab180f31dd1cb2aa95fe6e", "filename": "libgomp/testsuite/libgomp.fortran/nestedfn4.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn4.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "b44982665a6ab7984ec5c36ee249d697f0dce7fb", "filename": "libgomp/testsuite/libgomp.fortran/strassen.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fstrassen.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fstrassen.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fstrassen.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "4f3d4f5b435d5daa1749fadb6e04007f7b8af32e", "filename": "libgomp/testsuite/libgomp.fortran/tabs1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftabs1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftabs1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftabs1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "7aed5498d34e467622f3d42a8ccccee881c40148", "filename": "libgomp/testsuite/libgomp.fortran/tabs2.f", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftabs2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftabs2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftabs2.f?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "df57cb8316897a2d766efb9bf2203342b6da83a8", "filename": "libgomp/testsuite/libgomp.fortran/task1.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask1.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "24ffee53ac8b09c96d3c9d533f0528352f74499b", "filename": "libgomp/testsuite/libgomp.fortran/task2.f90", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask2.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "cdd4849b6ad2e46ca162b2b3b8f27a21802d2817", "filename": "libgomp/testsuite/libgomp.fortran/vla4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla4.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "9b611505219c6ab2b4326bb34cf5d140da3fb74d", "filename": "libgomp/testsuite/libgomp.fortran/vla5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla5.f90?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}, {"sha": "b48a5e3244b35ea1d32d72e3d4acb13a69b8c13e", "filename": "libgomp/work.c", "status": "modified", "additions": 144, "deletions": 100, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fwork.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a68ab3517348178c71d9adcdefbc81de2d8c7390/libgomp%2Fwork.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fwork.c?ref=a68ab3517348178c71d9adcdefbc81de2d8c7390"}]}