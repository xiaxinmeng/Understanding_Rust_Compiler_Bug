{"sha": "9488d24206687be80443dafdb2cdfc4ff3aca28c", "node_id": "C_kwDOANBUbNoAKDk0ODhkMjQyMDY2ODdiZTgwNDQzZGFmZGIyY2RmYzRmZjNhY2EyOGM", "commit": {"author": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2021-11-25T17:40:51Z"}, "committer": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2021-11-25T17:43:55Z"}, "message": "libgcc: Split FDE search code from PT_GNU_EH_FRAME lookup\n\nThis allows switching to a different implementation for\nPT_GNU_EH_FRAME lookup in a subsequent commit.\n\nThis moves some of the PT_GNU_EH_FRAME parsing out of the glibc loader\nlock that is implied by dl_iterate_phdr.  However, the FDE is already\nparsed outside the lock before this change, so this does not introduce\nadditional crashes in case of a concurrent dlclose.\n\nlibgcc/ChangeLog:\n\n\t* unwind-dw2-fde-dip.c (struct unw_eh_callback_data): Add hdr.\n\tRemove func, ret.\n\t(find_fde_tail): New function.  Split from\n\t_Unwind_IteratePhdrCallback.  Move the result initialization\n\tfrom _Unwind_Find_FDE.\n\t(_Unwind_Find_FDE): Updated to call find_fde_tail.", "tree": {"sha": "1d811c01fbff03e3c021ad0ce041846e58f7cd48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d811c01fbff03e3c021ad0ce041846e58f7cd48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9488d24206687be80443dafdb2cdfc4ff3aca28c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9488d24206687be80443dafdb2cdfc4ff3aca28c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9488d24206687be80443dafdb2cdfc4ff3aca28c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9488d24206687be80443dafdb2cdfc4ff3aca28c/comments", "author": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bc4cb04127a4805b6228b0a6cbfebdbd61314d2"}], "stats": {"total": 92, "additions": 50, "deletions": 42}, "files": [{"sha": "fbb0fbdebb92d484a32772fba4f60b92120c1196", "filename": "libgcc/unwind-dw2-fde-dip.c", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9488d24206687be80443dafdb2cdfc4ff3aca28c/libgcc%2Funwind-dw2-fde-dip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9488d24206687be80443dafdb2cdfc4ff3aca28c/libgcc%2Funwind-dw2-fde-dip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2-fde-dip.c?ref=9488d24206687be80443dafdb2cdfc4ff3aca28c", "patch": "@@ -113,8 +113,7 @@ struct unw_eh_callback_data\n #if NEED_DBASE_MEMBER\n   void *dbase;\n #endif\n-  void *func;\n-  const fde *ret;\n+  const struct unw_eh_frame_hdr *hdr;\n   int check_cache;\n };\n \n@@ -197,10 +196,6 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n #else\n   _Unwind_Ptr load_base;\n #endif\n-  const unsigned char *p;\n-  const struct unw_eh_frame_hdr *hdr;\n-  _Unwind_Ptr eh_frame;\n-  struct object ob;\n   _Unwind_Ptr pc_low = 0, pc_high = 0;\n \n   struct ext_dl_phdr_info\n@@ -348,10 +343,8 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n     return 0;\n \n   /* Read .eh_frame_hdr header.  */\n-  hdr = (const struct unw_eh_frame_hdr *)\n+  data->hdr = (const struct unw_eh_frame_hdr *)\n     __RELOC_POINTER (p_eh_frame_hdr->p_vaddr, load_base);\n-  if (hdr->version != 1)\n-    return 1;\n \n #ifdef CRT_GET_RFIB_DATA\n # if defined __i386__ || defined __nios2__\n@@ -383,12 +376,30 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n # endif\n #endif\n \n-  _Unwind_Ptr dbase = unw_eh_callback_data_dbase (data);\n+  return 1;\n+}\n+\n+/* Find the FDE for the program counter PC, in a previously located\n+   PT_GNU_EH_FRAME data region.  *BASES is updated if an FDE to return is\n+   found.  */\n+\n+static const fde *\n+find_fde_tail (_Unwind_Ptr pc,\n+\t       const struct unw_eh_frame_hdr *hdr,\n+\t       _Unwind_Ptr dbase,\n+\t       struct dwarf_eh_bases *bases)\n+{\n+  const unsigned char *p = (const unsigned char *) (hdr + 1);\n+  _Unwind_Ptr eh_frame;\n+  struct object ob;\n+\n+  if (hdr->version != 1)\n+    return NULL;\n+\n   p = read_encoded_value_with_base (hdr->eh_frame_ptr_enc,\n \t\t\t\t    base_from_cb_data (hdr->eh_frame_ptr_enc,\n \t\t\t\t\t\t       dbase),\n-\t\t\t\t    (const unsigned char *) (hdr + 1),\n-\t\t\t\t    &eh_frame);\n+\t\t\t\t    p, &eh_frame);\n \n   /* We require here specific table encoding to speed things up.\n      Also, DW_EH_PE_datarel here means using PT_GNU_EH_FRAME start\n@@ -404,7 +415,7 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \t\t\t\t\tp, &fde_count);\n       /* Shouldn't happen.  */\n       if (fde_count == 0)\n-\treturn 1;\n+\treturn NULL;\n       if ((((_Unwind_Ptr) p) & 3) == 0)\n \t{\n \t  struct fde_table {\n@@ -419,19 +430,19 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \t  _Unwind_Ptr range;\n \n \t  mid = fde_count - 1;\n-\t  if (data->pc < table[0].initial_loc + data_base)\n-\t    return 1;\n-\t  else if (data->pc < table[mid].initial_loc + data_base)\n+\t  if (pc < table[0].initial_loc + data_base)\n+\t    return NULL;\n+\t  else if (pc < table[mid].initial_loc + data_base)\n \t    {\n \t      lo = 0;\n \t      hi = mid;\n \n \t      while (lo < hi)\n \t\t{\n \t\t  mid = (lo + hi) / 2;\n-\t\t  if (data->pc < table[mid].initial_loc + data_base)\n+\t\t  if (pc < table[mid].initial_loc + data_base)\n \t\t    hi = mid;\n-\t\t  else if (data->pc >= table[mid + 1].initial_loc + data_base)\n+\t\t  else if (pc >= table[mid + 1].initial_loc + data_base)\n \t\t    lo = mid + 1;\n \t\t  else\n \t\t    break;\n@@ -445,10 +456,16 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \t  f_enc_size = size_of_encoded_value (f_enc);\n \t  read_encoded_value_with_base (f_enc & 0x0f, 0,\n \t\t\t\t\t&f->pc_begin[f_enc_size], &range);\n-\t  if (data->pc < table[mid].initial_loc + data_base + range)\n-\t    data->ret = f;\n-\t  data->func = (void *) (table[mid].initial_loc + data_base);\n-\t  return 1;\n+\t  _Unwind_Ptr func = table[mid].initial_loc + data_base;\n+\t  if (pc < table[mid].initial_loc + data_base + range)\n+\t    {\n+\t      bases->tbase = NULL;\n+\t      bases->dbase = (void *) dbase;\n+\t      bases->func = (void *) func;\n+\t      return f;\n+\t    }\n+\t  else\n+\t    return NULL;\n \t}\n     }\n \n@@ -461,18 +478,20 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n   ob.u.single = (fde *) eh_frame;\n   ob.s.i = 0;\n   ob.s.b.mixed_encoding = 1;  /* Need to assume worst case.  */\n-  data->ret = linear_search_fdes (&ob, (fde *) eh_frame, (void *) data->pc);\n-  if (data->ret != NULL)\n+  const fde *entry = linear_search_fdes (&ob, (fde *) eh_frame, (void *) pc);\n+  if (entry != NULL)\n     {\n       _Unwind_Ptr func;\n-      unsigned int encoding = get_fde_encoding (data->ret);\n+      unsigned int encoding = get_fde_encoding (entry);\n \n       read_encoded_value_with_base (encoding,\n \t\t\t\t    base_from_cb_data (encoding, dbase),\n-\t\t\t\t    data->ret->pc_begin, &func);\n-      data->func = (void *) func;\n+\t\t\t\t    entry->pc_begin, &func);\n+      bases->tbase = NULL;\n+      bases->dbase = (void *) dbase;\n+      bases->func = (void *) func;\n     }\n-  return 1;\n+  return entry;\n }\n \n const fde *\n@@ -489,24 +508,13 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n #if NEED_DBASE_MEMBER\n   data.dbase = NULL;\n #endif\n-  data.func = NULL;\n-  data.ret = NULL;\n   data.check_cache = 1;\n \n-  if (dl_iterate_phdr (_Unwind_IteratePhdrCallback, &data) < 0)\n+  if (dl_iterate_phdr (_Unwind_IteratePhdrCallback, &data) <= 0)\n     return NULL;\n \n-  if (data.ret)\n-    {\n-      bases->tbase = NULL;\n-#if NEED_DBASE_MEMBER\n-      bases->dbase = data.dbase;\n-#else\n-      bases->dbase = NULL;\n-#endif\n-      bases->func = data.func;\n-    }\n-  return data.ret;\n+  _Unwind_Ptr dbase = unw_eh_callback_data_dbase (&data);\n+  return find_fde_tail ((_Unwind_Ptr) pc, data.hdr, dbase, bases);\n }\n \n #else"}]}