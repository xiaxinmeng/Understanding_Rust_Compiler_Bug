{"sha": "3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FkMDY1ZWZlMWFmYjVmM2ZkYjYwYmU3NTQxNmNhOWFmOTRiNjdiMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-01-11T18:50:54Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-01-11T18:50:54Z"}, "message": "gimple.h (gimplify_body): Remove first argument.\n\n\t* gimple.h (gimplify_body): Remove first argument.\n\t* gimplify.c (copy_if_shared): Add DATA argument.  Do not create the\n\tpointer set here, instead just pass DATA to walk_tree.\n\t(unshare_body): Remove BODY_P argument and adjust.  Create the pointer\n\tset here and invoke copy_if_shared on the size trees of DECL_RESULT.\n\t(unvisit_body): Likewise, but with unmark_visited.\n\t(gimplify_body): Remove BODY_P argument and adjust.\n\t(gimplify_function_tree): Adjust call to gimplify_body.\n\t* omp-low.c (finalize_task_copyfn): Likewise.\n\nFrom-SVN: r183104", "tree": {"sha": "d55ae118d14b55279f3b6aacc5630ae86753ef28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d55ae118d14b55279f3b6aacc5630ae86753ef28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/comments", "author": null, "committer": null, "parents": [{"sha": "2cd8b32cb96515850469a49bbba1a3a5a147dbad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cd8b32cb96515850469a49bbba1a3a5a147dbad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cd8b32cb96515850469a49bbba1a3a5a147dbad"}], "stats": {"total": 138, "additions": 99, "deletions": 39}, "files": [{"sha": "16bcd96fcd92d0ad2036fd69754f79ea04018d9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "patch": "@@ -1,3 +1,15 @@\n+2012-01-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimple.h (gimplify_body): Remove first argument.\n+\t* gimplify.c (copy_if_shared): Add DATA argument.  Do not create the\n+\tpointer set here, instead just pass DATA to walk_tree.\n+\t(unshare_body): Remove BODY_P argument and adjust.  Create the pointer\n+\tset here and invoke copy_if_shared on the size trees of DECL_RESULT.\n+\t(unvisit_body): Likewise, but with unmark_visited.\n+\t(gimplify_body): Remove BODY_P argument and adjust.\n+\t(gimplify_function_tree): Adjust call to gimplify_body.\n+\t* omp-low.c (finalize_task_copyfn): Likewise.\n+\n 2012-01-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree.h (build_function_decl_skip_args): Add boolean parameter."}, {"sha": "ec32f2577a36832702bfb5c3727635851f77153f", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "patch": "@@ -1097,7 +1097,7 @@ extern enum gimplify_status gimplify_expr (tree *, gimple_seq *, gimple_seq *,\n extern void gimplify_type_sizes (tree, gimple_seq *);\n extern void gimplify_one_sizepos (tree *, gimple_seq *);\n extern bool gimplify_stmt (tree *, gimple_seq *);\n-extern gimple gimplify_body (tree *, tree, bool);\n+extern gimple gimplify_body (tree, bool);\n extern void push_gimplify_context (struct gimplify_ctx *);\n extern void pop_gimplify_context (gimple);\n extern void gimplify_and_add (tree, gimple_seq *);"}, {"sha": "94b99a1182324a7c538ca1670b101cb75cfe0b16", "filename": "gcc/gimplify.c", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "patch": "@@ -867,9 +867,10 @@ annotate_all_with_location (gimple_seq stmt_p, location_t location)\n   way to go.  */\n \n /* Similar to copy_tree_r but do not copy SAVE_EXPR or TARGET_EXPR nodes.\n-   These nodes model computations that should only be done once.  If we\n-   were to unshare something like SAVE_EXPR(i++), the gimplification\n-   process would create wrong code.  */\n+   These nodes model computations that must be done once.  If we were to\n+   unshare something like SAVE_EXPR(i++), the gimplification process would\n+   create wrong code.  However, if DATA is non-null, it must hold a pointer\n+   set that is used to unshare the subtrees of these nodes.  */\n \n static tree\n mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)\n@@ -909,9 +910,9 @@ mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n-/* Callback for walk_tree to unshare most of the shared trees rooted at\n-   *TP.  If *TP has been visited already (i.e., TREE_VISITED (*TP) == 1),\n-   then *TP is deep copied by calling mostly_copy_tree_r.  */\n+/* Callback for walk_tree to unshare most of the shared trees rooted at *TP.\n+   If *TP has been visited already, then *TP is deeply copied by calling\n+   mostly_copy_tree_r.  DATA is passed to mostly_copy_tree_r unmodified.  */\n \n static tree\n copy_if_shared_r (tree *tp, int *walk_subtrees, void *data)\n@@ -948,34 +949,37 @@ copy_if_shared_r (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n-/* Unshare most of the shared trees rooted at *TP. */\n+/* Unshare most of the shared trees rooted at *TP.  DATA is passed to the\n+   copy_if_shared_r callback unmodified.  */\n \n static inline void\n-copy_if_shared (tree *tp)\n+copy_if_shared (tree *tp, void *data)\n {\n-  /* If the language requires deep unsharing, we need a pointer set to make\n-     sure we don't repeatedly unshare subtrees of unshareable nodes.  */\n-  struct pointer_set_t *visited\n-    = lang_hooks.deep_unsharing ? pointer_set_create () : NULL;\n-  walk_tree (tp, copy_if_shared_r, visited, NULL);\n-  if (visited)\n-    pointer_set_destroy (visited);\n+  walk_tree (tp, copy_if_shared_r, data, NULL);\n }\n \n-/* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the\n-   bodies of any nested functions if we are unsharing the entire body of\n-   FNDECL.  */\n+/* Unshare all the trees in the body of FNDECL, as well as in the bodies of\n+   any nested functions.  */\n \n static void\n-unshare_body (tree *body_p, tree fndecl)\n+unshare_body (tree fndecl)\n {\n   struct cgraph_node *cgn = cgraph_get_node (fndecl);\n+  /* If the language requires deep unsharing, we need a pointer set to make\n+     sure we don't repeatedly unshare subtrees of unshareable nodes.  */\n+  struct pointer_set_t *visited\n+    = lang_hooks.deep_unsharing ? pointer_set_create () : NULL;\n \n-  copy_if_shared (body_p);\n+  copy_if_shared (&DECL_SAVED_TREE (fndecl), visited);\n+  copy_if_shared (&DECL_SIZE (DECL_RESULT (fndecl)), visited);\n+  copy_if_shared (&DECL_SIZE_UNIT (DECL_RESULT (fndecl)), visited);\n \n-  if (cgn && body_p == &DECL_SAVED_TREE (fndecl))\n+  if (visited)\n+    pointer_set_destroy (visited);\n+\n+  if (cgn)\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-      unshare_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n+      unshare_body (cgn->decl);\n }\n \n /* Callback for walk_tree to unmark the visited trees rooted at *TP.\n@@ -1008,15 +1012,17 @@ unmark_visited (tree *tp)\n /* Likewise, but mark all trees as not visited.  */\n \n static void\n-unvisit_body (tree *body_p, tree fndecl)\n+unvisit_body (tree fndecl)\n {\n   struct cgraph_node *cgn = cgraph_get_node (fndecl);\n \n-  unmark_visited (body_p);\n+  unmark_visited (&DECL_SAVED_TREE (fndecl));\n+  unmark_visited (&DECL_SIZE (DECL_RESULT (fndecl)));\n+  unmark_visited (&DECL_SIZE_UNIT (DECL_RESULT (fndecl)));\n \n-  if (cgn && body_p == &DECL_SAVED_TREE (fndecl))\n+  if (cgn)\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-      unvisit_body (&DECL_SAVED_TREE (cgn->decl), cgn->decl);\n+      unvisit_body (cgn->decl);\n }\n \n /* Unconditionally make an unshared copy of EXPR.  This is used when using\n@@ -7938,13 +7944,12 @@ gimplify_one_sizepos (tree *expr_p, gimple_seq *stmt_p)\n     }\n }\n \n-/* Gimplify the body of statements pointed to by BODY_P and return a\n-   GIMPLE_BIND containing the sequence of GIMPLE statements\n-   corresponding to BODY_P.  FNDECL is the function decl containing\n-   *BODY_P.  */\n+/* Gimplify the body of statements of FNDECL and return a GIMPLE_BIND node\n+   containing the sequence of corresponding GIMPLE statements.  If DO_PARMS\n+   is true, also gimplify the parameters.  */\n \n gimple\n-gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n+gimplify_body (tree fndecl, bool do_parms)\n {\n   location_t saved_location = input_location;\n   gimple_seq parm_stmts, seq;\n@@ -7965,8 +7970,8 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n      It would seem we don't have to do this for nested functions because\n      they are supposed to be output and then the outer function gimplified\n      first, but the g++ front end doesn't always do it that way.  */\n-  unshare_body (body_p, fndecl);\n-  unvisit_body (body_p, fndecl);\n+  unshare_body (fndecl);\n+  unvisit_body (fndecl);\n \n   cgn = cgraph_get_node (fndecl);\n   if (cgn && cgn->origin)\n@@ -7977,11 +7982,11 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n \n   /* Resolve callee-copies.  This has to be done before processing\n      the body so that DECL_VALUE_EXPR gets processed correctly.  */\n-  parm_stmts = (do_parms) ? gimplify_parameters () : NULL;\n+  parm_stmts = do_parms ? gimplify_parameters () : NULL;\n \n   /* Gimplify the function's body.  */\n   seq = NULL;\n-  gimplify_stmt (body_p, &seq);\n+  gimplify_stmt (&DECL_SAVED_TREE (fndecl), &seq);\n   outer_bind = gimple_seq_first_stmt (seq);\n   if (!outer_bind)\n     {\n@@ -7997,7 +8002,7 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   else\n     outer_bind = gimple_build_bind (NULL_TREE, seq, NULL);\n \n-  *body_p = NULL_TREE;\n+  DECL_SAVED_TREE (fndecl) = NULL_TREE;\n \n   /* If we had callee-copies statements, insert them at the beginning\n      of the function and clear DECL_VALUE_EXPR_P on the parameters.  */\n@@ -8115,7 +8120,7 @@ gimplify_function_tree (tree fndecl)\n       && !needs_to_live_in_memory (ret))\n     DECL_GIMPLE_REG_P (ret) = 1;\n \n-  bind = gimplify_body (&DECL_SAVED_TREE (fndecl), fndecl, true);\n+  bind = gimplify_body (fndecl, true);\n \n   /* The tree body of the function is no longer needed, replace it\n      with the new GIMPLE body.  */"}, {"sha": "8ab689d015271e8cf9ce48339c902679769e1be3", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "patch": "@@ -1248,7 +1248,7 @@ finalize_task_copyfn (gimple task_stmt)\n   old_fn = current_function_decl;\n   push_cfun (child_cfun);\n   current_function_decl = child_fn;\n-  bind = gimplify_body (&DECL_SAVED_TREE (child_fn), child_fn, false);\n+  bind = gimplify_body (child_fn, false);\n   seq = gimple_seq_alloc ();\n   gimple_seq_add_stmt (&seq, bind);\n   new_seq = maybe_catch_exception (seq);"}, {"sha": "f49cdd90ed476b7b192d75f16b87d60c67486efc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "patch": "@@ -1,3 +1,7 @@\n+2012-01-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/array19.ad[sb]: New test.\n+\n 2012-01-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt23.ad[sb]: New test."}, {"sha": "56b05d6490b6f20fcc450a67efc282aba1b14880", "filename": "gcc/testsuite/gnat.dg/array19.adb", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Ftestsuite%2Fgnat.dg%2Farray19.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Ftestsuite%2Fgnat.dg%2Farray19.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray19.adb?ref=3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "patch": "@@ -0,0 +1,34 @@\n+-- { dg-do compile }\r\n+\r\n+package body Array19 is\r\n+\r\n+   function N return Integer is\r\n+   begin\r\n+      return 1;\r\n+   end;\r\n+\r\n+   type Array_Type is array (1 .. N) of Float;\r\n+\r\n+   type Enum is (One, Two);\r\n+\r\n+   type Rec (D : Enum := Enum'First) is record\r\n+      case D is\r\n+         when One => null;\r\n+         when Two => A : Array_Type;\r\n+      end case;\r\n+   end record;\r\n+\r\n+   procedure Proc is\r\n+\r\n+      R : Rec;\r\n+\r\n+      function F return Array_Type is\r\n+      begin\r\n+         return (others => 0.0);\r\n+      end F;\r\n+\r\n+   begin\r\n+      R.A := F;\r\n+   end;\r\n+\r\n+end Array19;\r"}, {"sha": "48947f590fa6d50d0fa56eb59752c76c4fb2839e", "filename": "gcc/testsuite/gnat.dg/array19.ads", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Ftestsuite%2Fgnat.dg%2Farray19.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad065efe1afb5f3fdb60be75416ca9af94b67b0/gcc%2Ftestsuite%2Fgnat.dg%2Farray19.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray19.ads?ref=3ad065efe1afb5f3fdb60be75416ca9af94b67b0", "patch": "@@ -0,0 +1,5 @@\n+package Array19 is\r\n+\r\n+   procedure Proc;\r\n+\r\n+end Array19;\r"}]}