{"sha": "99425ec329df4fa7d48f34803efd901284267197", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk0MjVlYzMyOWRmNGZhN2Q0OGYzNDgwM2VmZDkwMTI4NDI2NzE5Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-17T09:07:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-17T09:07:50Z"}, "message": "[multiple changes]\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_attr.adb (Eval_Attribute): Ensure that attribute\n\treference is not marked as being a static expression if the\n\tprefix evaluation raises CE.\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_pakd.adb: Move bit packed entity tables to spec.\n\t* exp_pakd.ads: Move bit packed entity tables here from body.\n\t* freeze.adb (Freeze_Array_Type): Check that packed array type\n\tis supported.\n\t* rtsfind.adb (PRE_Id_Table): New table (Entity_Not_Defined):\n\tSpecialize messages using PRE_Id_Table.\n\t* uintp.ads, uintp.adb (UI_Image): New functional form.\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* aspects.ads, aspects.adb: Add Suppress_Initialization aspect.\n\t* einfo.ads, einfo.adb (Suppress_Initialization): Now applies to\n\tE_Variable.\n\t* exp_ch3.adb (Default_Initialize_Object): Handle\n\tSuppress_Initialization.\n\t* exp_prag.adb (Expand_Pragma_Suppress_Initialization): New\n\tprocedure (Expand_N_Pragma): Handle Suppress_Initialization\n\t(Expand_Pragma_Import_Or_Interface): Use Undo_Initialization\n\t(Undo_Initialization): New procedure.\n\t* sem_prag.adb (Analyze_Pragma, case Suppress_Initialization):\n\tThis is now allowed for E_Variable case.\n\t* gnat_rm.texi: Document new aspect Suppress_Initialization\n\tSuppress_Initialization aspect/pragma can apply to variable.\n\t* einfo.ads: Minor reformatting.\n\n2014-10-17  Arnaud Charlet  <charlet@adacore.com>\n\n\t* spark_xrefs.ads: Add documentation pointer to Flow_Computed_Globals.\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* cstand.adb (Create_Standard): Mark Short_Integer as\n\timplementation defined.\n\t* sem_util.adb (Set_Entity_With_Checks): Avoid blow up for\n\tcompiler built with assertions for No_Implementation_Identifiers test.\n\nFrom-SVN: r216379", "tree": {"sha": "00bca1749db1231ff2ecc5320dd9670e131c8d51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00bca1749db1231ff2ecc5320dd9670e131c8d51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99425ec329df4fa7d48f34803efd901284267197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99425ec329df4fa7d48f34803efd901284267197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99425ec329df4fa7d48f34803efd901284267197", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99425ec329df4fa7d48f34803efd901284267197/comments", "author": null, "committer": null, "parents": [{"sha": "99bd87dd981acf6e5cc654a9b39e5863ad5ee850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99bd87dd981acf6e5cc654a9b39e5863ad5ee850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99bd87dd981acf6e5cc654a9b39e5863ad5ee850"}], "stats": {"total": 1149, "additions": 704, "deletions": 445}, "files": [{"sha": "7ae4ea2a0b9293352e511446f9c1e1f026ea746e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -1,3 +1,47 @@\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_attr.adb (Eval_Attribute): Ensure that attribute\n+\treference is not marked as being a static expression if the\n+\tprefix evaluation raises CE.\n+\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_pakd.adb: Move bit packed entity tables to spec.\n+\t* exp_pakd.ads: Move bit packed entity tables here from body.\n+\t* freeze.adb (Freeze_Array_Type): Check that packed array type\n+\tis supported.\n+\t* rtsfind.adb (PRE_Id_Table): New table (Entity_Not_Defined):\n+\tSpecialize messages using PRE_Id_Table.\n+\t* uintp.ads, uintp.adb (UI_Image): New functional form.\n+\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* aspects.ads, aspects.adb: Add Suppress_Initialization aspect.\n+\t* einfo.ads, einfo.adb (Suppress_Initialization): Now applies to\n+\tE_Variable.\n+\t* exp_ch3.adb (Default_Initialize_Object): Handle\n+\tSuppress_Initialization.\n+\t* exp_prag.adb (Expand_Pragma_Suppress_Initialization): New\n+\tprocedure (Expand_N_Pragma): Handle Suppress_Initialization\n+\t(Expand_Pragma_Import_Or_Interface): Use Undo_Initialization\n+\t(Undo_Initialization): New procedure.\n+\t* sem_prag.adb (Analyze_Pragma, case Suppress_Initialization):\n+\tThis is now allowed for E_Variable case.\n+\t* gnat_rm.texi: Document new aspect Suppress_Initialization\n+\tSuppress_Initialization aspect/pragma can apply to variable.\n+\t* einfo.ads: Minor reformatting.\n+\n+2014-10-17  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* spark_xrefs.ads: Add documentation pointer to Flow_Computed_Globals.\n+\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* cstand.adb (Create_Standard): Mark Short_Integer as\n+\timplementation defined.\n+\t* sem_util.adb (Set_Entity_With_Checks): Avoid blow up for\n+\tcompiler built with assertions for No_Implementation_Identifiers test.\n+\n 2014-10-17  Robert Dewar  <dewar@adacore.com>\n \n \t* aspects.ads: Documentation fix, aspect Lock_Free does have a"}, {"sha": "472f95700b3f3ca02c27bec182736b95c559f84b", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -585,6 +585,7 @@ package body Aspects is\n     Aspect_Stream_Size                  => Aspect_Stream_Size,\n     Aspect_Suppress                     => Aspect_Suppress,\n     Aspect_Suppress_Debug_Info          => Aspect_Suppress_Debug_Info,\n+    Aspect_Suppress_Initialization      => Aspect_Suppress_Initialization,\n     Aspect_Synchronization              => Aspect_Synchronization,\n     Aspect_Test_Case                    => Aspect_Test_Case,\n     Aspect_Thread_Local_Storage         => Aspect_Thread_Local_Storage,"}, {"sha": "60b647408893f1fab2b68e132e1f17e3a1cf0c59", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -188,6 +188,7 @@ package Aspects is\n       Aspect_Shared,                        -- GNAT (equivalent to Atomic)\n       Aspect_Simple_Storage_Pool_Type,      -- GNAT\n       Aspect_Suppress_Debug_Info,           -- GNAT\n+      Aspect_Suppress_Initialization,       -- GNAT\n       Aspect_Thread_Local_Storage,          -- GNAT\n       Aspect_Unchecked_Union,\n       Aspect_Universal_Aliasing,            -- GNAT\n@@ -243,6 +244,7 @@ package Aspects is\n       Aspect_Simple_Storage_Pool      => True,\n       Aspect_Simple_Storage_Pool_Type => True,\n       Aspect_Suppress_Debug_Info      => True,\n+      Aspect_Suppress_Initialization  => True,\n       Aspect_Thread_Local_Storage     => True,\n       Aspect_Test_Case                => True,\n       Aspect_Universal_Aliasing       => True,\n@@ -469,6 +471,7 @@ package Aspects is\n       Aspect_Stream_Size                  => Name_Stream_Size,\n       Aspect_Suppress                     => Name_Suppress,\n       Aspect_Suppress_Debug_Info          => Name_Suppress_Debug_Info,\n+      Aspect_Suppress_Initialization      => Name_Suppress_Initialization,\n       Aspect_Thread_Local_Storage         => Name_Thread_Local_Storage,\n       Aspect_Synchronization              => Name_Synchronization,\n       Aspect_Test_Case                    => Name_Test_Case,\n@@ -659,6 +662,7 @@ package Aspects is\n       Aspect_Stream_Size                  => Always_Delay,\n       Aspect_Suppress                     => Always_Delay,\n       Aspect_Suppress_Debug_Info          => Always_Delay,\n+      Aspect_Suppress_Initialization      => Always_Delay,\n       Aspect_Thread_Local_Storage         => Always_Delay,\n       Aspect_Type_Invariant               => Always_Delay,\n       Aspect_Unchecked_Union              => Always_Delay,"}, {"sha": "2032b9b4c035cce17ec92cb86db17de702404cfd", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -735,6 +735,7 @@ package body CStand is\n \n       Build_Signed_Integer_Type\n         (Standard_Short_Integer, Standard_Short_Integer_Size);\n+      Set_Is_Implementation_Defined (Standard_Short_Integer);\n \n       Build_Signed_Integer_Type\n         (Standard_Integer, Standard_Integer_Size);"}, {"sha": "6aa7c48a42954e9815069a4626c67cb84e40aa24", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -3090,7 +3090,7 @@ package body Einfo is\n \n    function Suppress_Initialization (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id));\n+      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Variable);\n       return Flag105 (Id);\n    end Suppress_Initialization;\n \n@@ -5943,7 +5943,7 @@ package body Einfo is\n \n    procedure Set_Suppress_Initialization (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Type (Id));\n+      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Variable);\n       Set_Flag105 (Id, V);\n    end Set_Suppress_Initialization;\n "}, {"sha": "d680c774382b81077843a1c72678691797911685", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -2990,7 +2990,7 @@ package Einfo is\n --       vtable (i.e. the one to be extended by derivation).\n \n --    Is_Tagged_Type (Flag55)\n---       Defined in all entities. Set for an entity for a tagged type.\n+--       Defined in all entities. Set for an entity that is a tagged type.\n \n --    Is_Task_Interface (synthesized)\n --       Defined in types that are interfaces. True if interface is declared as\n@@ -4081,14 +4081,16 @@ package Einfo is\n --       avoid multiple elaboration warnings for the same variable.\n \n --    Suppress_Initialization (Flag105)\n---       Defined in all type and subtype entities. If set for the base type,\n---       then the generation of initialization procedures is suppressed for the\n---       type. Any other implicit initialiation (e.g. from the use of pragma\n---       Initialize_Scalars) is also suppressed if this flag is set either for\n---       the subtype in question, or for the base type. Set by use of pragma\n---       Suppress_Initialization and also for internal entities where we know\n---       that no initialization is required. For example, enumeration image\n---       table entities set it.\n+--       Defined in all variable, type and subtype entities. If set for a base\n+--       type, then the generation of initialization procedures is suppressed\n+--       for the type. Any other implicit initialiation (e.g. from the use of\n+--       pragma Initialize_Scalars) is also suppressed if this flag is set for\n+--       either the subtype in question, or for the base type. For variables,\n+--       this flag suppresses all implicit initialization for the object, even\n+--       if the type would normally require initialization. Set by use of\n+--       pragma Suppress_Initialization and also for internal entities where\n+--       we know that no initialization is required. For example, enumeration\n+--       image table entities set it.\n \n --    Suppress_Style_Checks (Flag165)\n --       Defined in all entities. Suppresses any style checks specifically\n@@ -4481,8 +4483,8 @@ package Einfo is\n       --  is created for the base type, and this is the first named subtype).\n \n       E_Ordinary_Fixed_Point_Type,\n-      --  Ordinary fixed type, used for the anonymous base type of the\n-      --  fixed subtype created by an ordinary fixed point type declaration.\n+      --  Ordinary fixed type, used for the anonymous base type of the fixed\n+      --  subtype created by an ordinary fixed point type declaration.\n \n       E_Ordinary_Fixed_Point_Subtype,\n       --  Ordinary fixed point subtype, created by either an ordinary fixed\n@@ -4603,19 +4605,18 @@ package Einfo is\n       --  A record subtype, created by a record subtype declaration\n \n       E_Record_Type_With_Private,\n-      --  Used for types defined by a private extension declaration, and\n-      --  for tagged private types. Includes the fields for both private\n-      --  types and for record types (with the sole exception of\n-      --  Corresponding_Concurrent_Type which is obviously not needed).\n-      --  This entity is considered to be both a record type and\n-      --  a private type.\n+      --  Used for types defined by a private extension declaration,\n+      --  and for tagged private types. Includes the fields for both\n+      --  private types and for record types (with the sole exception of\n+      --  Corresponding_Concurrent_Type which is obviously not needed). This\n+      --  entity is considered to be both a record type and a private type.\n \n       E_Record_Subtype_With_Private,\n       --  A subtype of a type defined by a private extension declaration\n \n       E_Private_Type,\n-      --  A private type, created by a private type declaration\n-      --  that has neither the keyword limited nor the keyword tagged.\n+      --  A private type, created by a private type declaration that has\n+      --  neither the keyword limited nor the keyword tagged.\n \n       E_Private_Subtype,\n       --  A subtype of a private type, created by a subtype declaration used\n@@ -4662,10 +4663,10 @@ package Einfo is\n       --  The type of an exception created by an exception declaration\n \n       E_Subprogram_Type,\n-      --  This is the designated type of an Access_To_Subprogram. Has type\n-      --  and signature like a subprogram entity, so can appear in calls,\n-      --  which are resolved like regular calls, except that such an entity\n-      --  is not overloadable.\n+      --  This is the designated type of an Access_To_Subprogram. Has type and\n+      --  signature like a subprogram entity, so can appear in calls, which\n+      --  are resolved like regular calls, except that such an entity is not\n+      --  overloadable.\n \n       ---------------------------\n       -- Overloadable Entities --\n@@ -4681,9 +4682,9 @@ package Einfo is\n \n       E_Operator,\n       --  A predefined operator, appearing in Standard, or an implicitly\n-      --  defined concatenation operator created whenever an array is\n-      --  declared. We do not make normal derived operators explicit in\n-      --  the tree, but the concatenation operators are made explicit.\n+      --  defined concatenation operator created whenever an array is declared.\n+      --  We do not make normal derived operators explicit in the tree, but the\n+      --  concatenation operators are made explicit.\n \n       E_Procedure,\n       --  A procedure, created by a procedure declaration or a procedure\n@@ -6238,6 +6239,7 @@ package Einfo is\n    --    OK_To_Rename                        (Flag247)\n    --    Optimize_Alignment_Space            (Flag241)\n    --    Optimize_Alignment_Time             (Flag242)\n+   --    Suppress_Initialization             (Flag105)\n    --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n@@ -8794,12 +8796,12 @@ package Einfo is\n \n    --  END XEINFO INLINES\n \n-   --  The following Inline pragmas are *not* read by xeinfo when building\n-   --  the C version of this interface automatically (so the C version will\n-   --  end up making out of line calls). The pragma scan in xeinfo will be\n-   --  terminated on encountering the END XEINFO INLINES line. We inline\n-   --  things here which are small, but not of the canonical attribute\n-   --  access/set format that can be handled by xeinfo.\n+   --  The following Inline pragmas are *not* read by xeinfo when building the\n+   --  C version of this interface automatically (so the C version will end up\n+   --  making out of line calls). The pragma scan in xeinfo will be terminated\n+   --  on encountering the END XEINFO INLINES line. We inline things here which\n+   --  are small, but not of the canonical attribute access/set format that can\n+   --  be handled by xeinfo.\n \n    pragma Inline (Base_Type);\n    pragma Inline (Is_Base_Type);"}, {"sha": "837e58fd47159f16dc806c554beaaea635b481a3", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -5082,9 +5082,10 @@ package body Exp_Ch3 is\n          --  known to be imported (i.e. whose declaration specifies the Import\n          --  aspect). Note that for objects with a pragma Import, we generate\n          --  initialization here, and then remove it downstream when processing\n-         --  the pragma.\n+         --  the pragma. It is also suppressed for variables for which a pragma\n+         --  Suppress_Initialization has been explicitly given\n \n-         if Is_Imported (Def_Id) then\n+         if Is_Imported (Def_Id) or else Suppress_Initialization (Def_Id) then\n             return;\n          end if;\n "}, {"sha": "21487c0b3f59dedbe80959a185aac584f4a4316e", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 0, "deletions": 360, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -34,7 +34,6 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n-with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n@@ -77,365 +76,6 @@ package body Exp_Pakd is\n    --  right rotate into a left rotate, avoiding the subtract, if the machine\n    --  architecture provides such an instruction.\n \n-   ----------------------------------------------\n-   -- Entity Tables for Packed Access Routines --\n-   ----------------------------------------------\n-\n-   --  For the cases of component size = 3,5-7,9-15,17-31,33-63 we call library\n-   --  routines. This table provides the entity for the proper routine.\n-\n-   type E_Array is array (Int range 01 .. 63) of RE_Id;\n-\n-   --  Array of Bits_nn entities. Note that we do not use library routines\n-   --  for the 8-bit and 16-bit cases, but we still fill in the table, using\n-   --  entries from System.Unsigned, because we also use this table for\n-   --  certain special unchecked conversions in the big-endian case.\n-\n-   Bits_Id : constant E_Array :=\n-     (01 => RE_Bits_1,\n-      02 => RE_Bits_2,\n-      03 => RE_Bits_03,\n-      04 => RE_Bits_4,\n-      05 => RE_Bits_05,\n-      06 => RE_Bits_06,\n-      07 => RE_Bits_07,\n-      08 => RE_Unsigned_8,\n-      09 => RE_Bits_09,\n-      10 => RE_Bits_10,\n-      11 => RE_Bits_11,\n-      12 => RE_Bits_12,\n-      13 => RE_Bits_13,\n-      14 => RE_Bits_14,\n-      15 => RE_Bits_15,\n-      16 => RE_Unsigned_16,\n-      17 => RE_Bits_17,\n-      18 => RE_Bits_18,\n-      19 => RE_Bits_19,\n-      20 => RE_Bits_20,\n-      21 => RE_Bits_21,\n-      22 => RE_Bits_22,\n-      23 => RE_Bits_23,\n-      24 => RE_Bits_24,\n-      25 => RE_Bits_25,\n-      26 => RE_Bits_26,\n-      27 => RE_Bits_27,\n-      28 => RE_Bits_28,\n-      29 => RE_Bits_29,\n-      30 => RE_Bits_30,\n-      31 => RE_Bits_31,\n-      32 => RE_Unsigned_32,\n-      33 => RE_Bits_33,\n-      34 => RE_Bits_34,\n-      35 => RE_Bits_35,\n-      36 => RE_Bits_36,\n-      37 => RE_Bits_37,\n-      38 => RE_Bits_38,\n-      39 => RE_Bits_39,\n-      40 => RE_Bits_40,\n-      41 => RE_Bits_41,\n-      42 => RE_Bits_42,\n-      43 => RE_Bits_43,\n-      44 => RE_Bits_44,\n-      45 => RE_Bits_45,\n-      46 => RE_Bits_46,\n-      47 => RE_Bits_47,\n-      48 => RE_Bits_48,\n-      49 => RE_Bits_49,\n-      50 => RE_Bits_50,\n-      51 => RE_Bits_51,\n-      52 => RE_Bits_52,\n-      53 => RE_Bits_53,\n-      54 => RE_Bits_54,\n-      55 => RE_Bits_55,\n-      56 => RE_Bits_56,\n-      57 => RE_Bits_57,\n-      58 => RE_Bits_58,\n-      59 => RE_Bits_59,\n-      60 => RE_Bits_60,\n-      61 => RE_Bits_61,\n-      62 => RE_Bits_62,\n-      63 => RE_Bits_63);\n-\n-   --  Array of Get routine entities. These are used to obtain an element from\n-   --  a packed array. The N'th entry is used to obtain elements from a packed\n-   --  array whose component size is N. RE_Null is used as a null entry, for\n-   --  the cases where a library routine is not used.\n-\n-   Get_Id : constant E_Array :=\n-     (01 => RE_Null,\n-      02 => RE_Null,\n-      03 => RE_Get_03,\n-      04 => RE_Null,\n-      05 => RE_Get_05,\n-      06 => RE_Get_06,\n-      07 => RE_Get_07,\n-      08 => RE_Null,\n-      09 => RE_Get_09,\n-      10 => RE_Get_10,\n-      11 => RE_Get_11,\n-      12 => RE_Get_12,\n-      13 => RE_Get_13,\n-      14 => RE_Get_14,\n-      15 => RE_Get_15,\n-      16 => RE_Null,\n-      17 => RE_Get_17,\n-      18 => RE_Get_18,\n-      19 => RE_Get_19,\n-      20 => RE_Get_20,\n-      21 => RE_Get_21,\n-      22 => RE_Get_22,\n-      23 => RE_Get_23,\n-      24 => RE_Get_24,\n-      25 => RE_Get_25,\n-      26 => RE_Get_26,\n-      27 => RE_Get_27,\n-      28 => RE_Get_28,\n-      29 => RE_Get_29,\n-      30 => RE_Get_30,\n-      31 => RE_Get_31,\n-      32 => RE_Null,\n-      33 => RE_Get_33,\n-      34 => RE_Get_34,\n-      35 => RE_Get_35,\n-      36 => RE_Get_36,\n-      37 => RE_Get_37,\n-      38 => RE_Get_38,\n-      39 => RE_Get_39,\n-      40 => RE_Get_40,\n-      41 => RE_Get_41,\n-      42 => RE_Get_42,\n-      43 => RE_Get_43,\n-      44 => RE_Get_44,\n-      45 => RE_Get_45,\n-      46 => RE_Get_46,\n-      47 => RE_Get_47,\n-      48 => RE_Get_48,\n-      49 => RE_Get_49,\n-      50 => RE_Get_50,\n-      51 => RE_Get_51,\n-      52 => RE_Get_52,\n-      53 => RE_Get_53,\n-      54 => RE_Get_54,\n-      55 => RE_Get_55,\n-      56 => RE_Get_56,\n-      57 => RE_Get_57,\n-      58 => RE_Get_58,\n-      59 => RE_Get_59,\n-      60 => RE_Get_60,\n-      61 => RE_Get_61,\n-      62 => RE_Get_62,\n-      63 => RE_Get_63);\n-\n-   --  Array of Get routine entities to be used in the case where the packed\n-   --  array is itself a component of a packed structure, and therefore may not\n-   --  be fully aligned. This only affects the even sizes, since for the odd\n-   --  sizes, we do not get any fixed alignment in any case.\n-\n-   GetU_Id : constant E_Array :=\n-     (01 => RE_Null,\n-      02 => RE_Null,\n-      03 => RE_Get_03,\n-      04 => RE_Null,\n-      05 => RE_Get_05,\n-      06 => RE_GetU_06,\n-      07 => RE_Get_07,\n-      08 => RE_Null,\n-      09 => RE_Get_09,\n-      10 => RE_GetU_10,\n-      11 => RE_Get_11,\n-      12 => RE_GetU_12,\n-      13 => RE_Get_13,\n-      14 => RE_GetU_14,\n-      15 => RE_Get_15,\n-      16 => RE_Null,\n-      17 => RE_Get_17,\n-      18 => RE_GetU_18,\n-      19 => RE_Get_19,\n-      20 => RE_GetU_20,\n-      21 => RE_Get_21,\n-      22 => RE_GetU_22,\n-      23 => RE_Get_23,\n-      24 => RE_GetU_24,\n-      25 => RE_Get_25,\n-      26 => RE_GetU_26,\n-      27 => RE_Get_27,\n-      28 => RE_GetU_28,\n-      29 => RE_Get_29,\n-      30 => RE_GetU_30,\n-      31 => RE_Get_31,\n-      32 => RE_Null,\n-      33 => RE_Get_33,\n-      34 => RE_GetU_34,\n-      35 => RE_Get_35,\n-      36 => RE_GetU_36,\n-      37 => RE_Get_37,\n-      38 => RE_GetU_38,\n-      39 => RE_Get_39,\n-      40 => RE_GetU_40,\n-      41 => RE_Get_41,\n-      42 => RE_GetU_42,\n-      43 => RE_Get_43,\n-      44 => RE_GetU_44,\n-      45 => RE_Get_45,\n-      46 => RE_GetU_46,\n-      47 => RE_Get_47,\n-      48 => RE_GetU_48,\n-      49 => RE_Get_49,\n-      50 => RE_GetU_50,\n-      51 => RE_Get_51,\n-      52 => RE_GetU_52,\n-      53 => RE_Get_53,\n-      54 => RE_GetU_54,\n-      55 => RE_Get_55,\n-      56 => RE_GetU_56,\n-      57 => RE_Get_57,\n-      58 => RE_GetU_58,\n-      59 => RE_Get_59,\n-      60 => RE_GetU_60,\n-      61 => RE_Get_61,\n-      62 => RE_GetU_62,\n-      63 => RE_Get_63);\n-\n-   --  Array of Set routine entities. These are used to assign an element of a\n-   --  packed array. The N'th entry is used to assign elements for a packed\n-   --  array whose component size is N. RE_Null is used as a null entry, for\n-   --  the cases where a library routine is not used.\n-\n-   Set_Id : constant E_Array :=\n-     (01 => RE_Null,\n-      02 => RE_Null,\n-      03 => RE_Set_03,\n-      04 => RE_Null,\n-      05 => RE_Set_05,\n-      06 => RE_Set_06,\n-      07 => RE_Set_07,\n-      08 => RE_Null,\n-      09 => RE_Set_09,\n-      10 => RE_Set_10,\n-      11 => RE_Set_11,\n-      12 => RE_Set_12,\n-      13 => RE_Set_13,\n-      14 => RE_Set_14,\n-      15 => RE_Set_15,\n-      16 => RE_Null,\n-      17 => RE_Set_17,\n-      18 => RE_Set_18,\n-      19 => RE_Set_19,\n-      20 => RE_Set_20,\n-      21 => RE_Set_21,\n-      22 => RE_Set_22,\n-      23 => RE_Set_23,\n-      24 => RE_Set_24,\n-      25 => RE_Set_25,\n-      26 => RE_Set_26,\n-      27 => RE_Set_27,\n-      28 => RE_Set_28,\n-      29 => RE_Set_29,\n-      30 => RE_Set_30,\n-      31 => RE_Set_31,\n-      32 => RE_Null,\n-      33 => RE_Set_33,\n-      34 => RE_Set_34,\n-      35 => RE_Set_35,\n-      36 => RE_Set_36,\n-      37 => RE_Set_37,\n-      38 => RE_Set_38,\n-      39 => RE_Set_39,\n-      40 => RE_Set_40,\n-      41 => RE_Set_41,\n-      42 => RE_Set_42,\n-      43 => RE_Set_43,\n-      44 => RE_Set_44,\n-      45 => RE_Set_45,\n-      46 => RE_Set_46,\n-      47 => RE_Set_47,\n-      48 => RE_Set_48,\n-      49 => RE_Set_49,\n-      50 => RE_Set_50,\n-      51 => RE_Set_51,\n-      52 => RE_Set_52,\n-      53 => RE_Set_53,\n-      54 => RE_Set_54,\n-      55 => RE_Set_55,\n-      56 => RE_Set_56,\n-      57 => RE_Set_57,\n-      58 => RE_Set_58,\n-      59 => RE_Set_59,\n-      60 => RE_Set_60,\n-      61 => RE_Set_61,\n-      62 => RE_Set_62,\n-      63 => RE_Set_63);\n-\n-   --  Array of Set routine entities to be used in the case where the packed\n-   --  array is itself a component of a packed structure, and therefore may not\n-   --  be fully aligned. This only affects the even sizes, since for the odd\n-   --  sizes, we do not get any fixed alignment in any case.\n-\n-   SetU_Id : constant E_Array :=\n-     (01 => RE_Null,\n-      02 => RE_Null,\n-      03 => RE_Set_03,\n-      04 => RE_Null,\n-      05 => RE_Set_05,\n-      06 => RE_SetU_06,\n-      07 => RE_Set_07,\n-      08 => RE_Null,\n-      09 => RE_Set_09,\n-      10 => RE_SetU_10,\n-      11 => RE_Set_11,\n-      12 => RE_SetU_12,\n-      13 => RE_Set_13,\n-      14 => RE_SetU_14,\n-      15 => RE_Set_15,\n-      16 => RE_Null,\n-      17 => RE_Set_17,\n-      18 => RE_SetU_18,\n-      19 => RE_Set_19,\n-      20 => RE_SetU_20,\n-      21 => RE_Set_21,\n-      22 => RE_SetU_22,\n-      23 => RE_Set_23,\n-      24 => RE_SetU_24,\n-      25 => RE_Set_25,\n-      26 => RE_SetU_26,\n-      27 => RE_Set_27,\n-      28 => RE_SetU_28,\n-      29 => RE_Set_29,\n-      30 => RE_SetU_30,\n-      31 => RE_Set_31,\n-      32 => RE_Null,\n-      33 => RE_Set_33,\n-      34 => RE_SetU_34,\n-      35 => RE_Set_35,\n-      36 => RE_SetU_36,\n-      37 => RE_Set_37,\n-      38 => RE_SetU_38,\n-      39 => RE_Set_39,\n-      40 => RE_SetU_40,\n-      41 => RE_Set_41,\n-      42 => RE_SetU_42,\n-      43 => RE_Set_43,\n-      44 => RE_SetU_44,\n-      45 => RE_Set_45,\n-      46 => RE_SetU_46,\n-      47 => RE_Set_47,\n-      48 => RE_SetU_48,\n-      49 => RE_Set_49,\n-      50 => RE_SetU_50,\n-      51 => RE_Set_51,\n-      52 => RE_SetU_52,\n-      53 => RE_Set_53,\n-      54 => RE_SetU_54,\n-      55 => RE_Set_55,\n-      56 => RE_SetU_56,\n-      57 => RE_Set_57,\n-      58 => RE_SetU_58,\n-      59 => RE_Set_59,\n-      60 => RE_SetU_60,\n-      61 => RE_Set_61,\n-      62 => RE_SetU_62,\n-      63 => RE_Set_63);\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------"}, {"sha": "80b63247e3cbbe965a11fc1bafd1543fccf45bd1", "filename": "gcc/ada/exp_pakd.ads", "status": "modified", "additions": 363, "deletions": 1, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_pakd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_pakd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.ads?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -25,7 +25,8 @@\n \n --  Expand routines for manipulation of packed arrays\n \n-with Types; use Types;\n+with Rtsfind; use Rtsfind;\n+with Types;   use Types;\n \n package Exp_Pakd is\n \n@@ -203,6 +204,367 @@ package Exp_Pakd is\n    --   and now, we do indeed have the same representation for the memory\n    --   version in the constrained and unconstrained cases.\n \n+   ----------------------------------------------\n+   -- Entity Tables for Packed Access Routines --\n+   ----------------------------------------------\n+\n+   --  For the cases of component size = 3,5-7,9-15,17-31,33-63 we call library\n+   --  routines. These tables provide the entity for the proper routine. They\n+   --  are exposed in the spec to allow checking for the presence of the needed\n+   --  routine when an array is subject to pragma Pack.\n+\n+   type E_Array is array (Int range 01 .. 63) of RE_Id;\n+\n+   --  Array of Bits_nn entities. Note that we do not use library routines\n+   --  for the 8-bit and 16-bit cases, but we still fill in the table, using\n+   --  entries from System.Unsigned, because we also use this table for\n+   --  certain special unchecked conversions in the big-endian case.\n+\n+   Bits_Id : constant E_Array :=\n+     (01 => RE_Bits_1,\n+      02 => RE_Bits_2,\n+      03 => RE_Bits_03,\n+      04 => RE_Bits_4,\n+      05 => RE_Bits_05,\n+      06 => RE_Bits_06,\n+      07 => RE_Bits_07,\n+      08 => RE_Unsigned_8,\n+      09 => RE_Bits_09,\n+      10 => RE_Bits_10,\n+      11 => RE_Bits_11,\n+      12 => RE_Bits_12,\n+      13 => RE_Bits_13,\n+      14 => RE_Bits_14,\n+      15 => RE_Bits_15,\n+      16 => RE_Unsigned_16,\n+      17 => RE_Bits_17,\n+      18 => RE_Bits_18,\n+      19 => RE_Bits_19,\n+      20 => RE_Bits_20,\n+      21 => RE_Bits_21,\n+      22 => RE_Bits_22,\n+      23 => RE_Bits_23,\n+      24 => RE_Bits_24,\n+      25 => RE_Bits_25,\n+      26 => RE_Bits_26,\n+      27 => RE_Bits_27,\n+      28 => RE_Bits_28,\n+      29 => RE_Bits_29,\n+      30 => RE_Bits_30,\n+      31 => RE_Bits_31,\n+      32 => RE_Unsigned_32,\n+      33 => RE_Bits_33,\n+      34 => RE_Bits_34,\n+      35 => RE_Bits_35,\n+      36 => RE_Bits_36,\n+      37 => RE_Bits_37,\n+      38 => RE_Bits_38,\n+      39 => RE_Bits_39,\n+      40 => RE_Bits_40,\n+      41 => RE_Bits_41,\n+      42 => RE_Bits_42,\n+      43 => RE_Bits_43,\n+      44 => RE_Bits_44,\n+      45 => RE_Bits_45,\n+      46 => RE_Bits_46,\n+      47 => RE_Bits_47,\n+      48 => RE_Bits_48,\n+      49 => RE_Bits_49,\n+      50 => RE_Bits_50,\n+      51 => RE_Bits_51,\n+      52 => RE_Bits_52,\n+      53 => RE_Bits_53,\n+      54 => RE_Bits_54,\n+      55 => RE_Bits_55,\n+      56 => RE_Bits_56,\n+      57 => RE_Bits_57,\n+      58 => RE_Bits_58,\n+      59 => RE_Bits_59,\n+      60 => RE_Bits_60,\n+      61 => RE_Bits_61,\n+      62 => RE_Bits_62,\n+      63 => RE_Bits_63);\n+\n+   --  Array of Get routine entities. These are used to obtain an element from\n+   --  a packed array. The N'th entry is used to obtain elements from a packed\n+   --  array whose component size is N. RE_Null is used as a null entry, for\n+   --  the cases where a library routine is not used.\n+\n+   Get_Id : constant E_Array :=\n+     (01 => RE_Null,\n+      02 => RE_Null,\n+      03 => RE_Get_03,\n+      04 => RE_Null,\n+      05 => RE_Get_05,\n+      06 => RE_Get_06,\n+      07 => RE_Get_07,\n+      08 => RE_Null,\n+      09 => RE_Get_09,\n+      10 => RE_Get_10,\n+      11 => RE_Get_11,\n+      12 => RE_Get_12,\n+      13 => RE_Get_13,\n+      14 => RE_Get_14,\n+      15 => RE_Get_15,\n+      16 => RE_Null,\n+      17 => RE_Get_17,\n+      18 => RE_Get_18,\n+      19 => RE_Get_19,\n+      20 => RE_Get_20,\n+      21 => RE_Get_21,\n+      22 => RE_Get_22,\n+      23 => RE_Get_23,\n+      24 => RE_Get_24,\n+      25 => RE_Get_25,\n+      26 => RE_Get_26,\n+      27 => RE_Get_27,\n+      28 => RE_Get_28,\n+      29 => RE_Get_29,\n+      30 => RE_Get_30,\n+      31 => RE_Get_31,\n+      32 => RE_Null,\n+      33 => RE_Get_33,\n+      34 => RE_Get_34,\n+      35 => RE_Get_35,\n+      36 => RE_Get_36,\n+      37 => RE_Get_37,\n+      38 => RE_Get_38,\n+      39 => RE_Get_39,\n+      40 => RE_Get_40,\n+      41 => RE_Get_41,\n+      42 => RE_Get_42,\n+      43 => RE_Get_43,\n+      44 => RE_Get_44,\n+      45 => RE_Get_45,\n+      46 => RE_Get_46,\n+      47 => RE_Get_47,\n+      48 => RE_Get_48,\n+      49 => RE_Get_49,\n+      50 => RE_Get_50,\n+      51 => RE_Get_51,\n+      52 => RE_Get_52,\n+      53 => RE_Get_53,\n+      54 => RE_Get_54,\n+      55 => RE_Get_55,\n+      56 => RE_Get_56,\n+      57 => RE_Get_57,\n+      58 => RE_Get_58,\n+      59 => RE_Get_59,\n+      60 => RE_Get_60,\n+      61 => RE_Get_61,\n+      62 => RE_Get_62,\n+      63 => RE_Get_63);\n+\n+   --  Array of Get routine entities to be used in the case where the packed\n+   --  array is itself a component of a packed structure, and therefore may not\n+   --  be fully aligned. This only affects the even sizes, since for the odd\n+   --  sizes, we do not get any fixed alignment in any case.\n+\n+   GetU_Id : constant E_Array :=\n+     (01 => RE_Null,\n+      02 => RE_Null,\n+      03 => RE_Get_03,\n+      04 => RE_Null,\n+      05 => RE_Get_05,\n+      06 => RE_GetU_06,\n+      07 => RE_Get_07,\n+      08 => RE_Null,\n+      09 => RE_Get_09,\n+      10 => RE_GetU_10,\n+      11 => RE_Get_11,\n+      12 => RE_GetU_12,\n+      13 => RE_Get_13,\n+      14 => RE_GetU_14,\n+      15 => RE_Get_15,\n+      16 => RE_Null,\n+      17 => RE_Get_17,\n+      18 => RE_GetU_18,\n+      19 => RE_Get_19,\n+      20 => RE_GetU_20,\n+      21 => RE_Get_21,\n+      22 => RE_GetU_22,\n+      23 => RE_Get_23,\n+      24 => RE_GetU_24,\n+      25 => RE_Get_25,\n+      26 => RE_GetU_26,\n+      27 => RE_Get_27,\n+      28 => RE_GetU_28,\n+      29 => RE_Get_29,\n+      30 => RE_GetU_30,\n+      31 => RE_Get_31,\n+      32 => RE_Null,\n+      33 => RE_Get_33,\n+      34 => RE_GetU_34,\n+      35 => RE_Get_35,\n+      36 => RE_GetU_36,\n+      37 => RE_Get_37,\n+      38 => RE_GetU_38,\n+      39 => RE_Get_39,\n+      40 => RE_GetU_40,\n+      41 => RE_Get_41,\n+      42 => RE_GetU_42,\n+      43 => RE_Get_43,\n+      44 => RE_GetU_44,\n+      45 => RE_Get_45,\n+      46 => RE_GetU_46,\n+      47 => RE_Get_47,\n+      48 => RE_GetU_48,\n+      49 => RE_Get_49,\n+      50 => RE_GetU_50,\n+      51 => RE_Get_51,\n+      52 => RE_GetU_52,\n+      53 => RE_Get_53,\n+      54 => RE_GetU_54,\n+      55 => RE_Get_55,\n+      56 => RE_GetU_56,\n+      57 => RE_Get_57,\n+      58 => RE_GetU_58,\n+      59 => RE_Get_59,\n+      60 => RE_GetU_60,\n+      61 => RE_Get_61,\n+      62 => RE_GetU_62,\n+      63 => RE_Get_63);\n+\n+   --  Array of Set routine entities. These are used to assign an element of a\n+   --  packed array. The N'th entry is used to assign elements for a packed\n+   --  array whose component size is N. RE_Null is used as a null entry, for\n+   --  the cases where a library routine is not used.\n+\n+   Set_Id : constant E_Array :=\n+     (01 => RE_Null,\n+      02 => RE_Null,\n+      03 => RE_Set_03,\n+      04 => RE_Null,\n+      05 => RE_Set_05,\n+      06 => RE_Set_06,\n+      07 => RE_Set_07,\n+      08 => RE_Null,\n+      09 => RE_Set_09,\n+      10 => RE_Set_10,\n+      11 => RE_Set_11,\n+      12 => RE_Set_12,\n+      13 => RE_Set_13,\n+      14 => RE_Set_14,\n+      15 => RE_Set_15,\n+      16 => RE_Null,\n+      17 => RE_Set_17,\n+      18 => RE_Set_18,\n+      19 => RE_Set_19,\n+      20 => RE_Set_20,\n+      21 => RE_Set_21,\n+      22 => RE_Set_22,\n+      23 => RE_Set_23,\n+      24 => RE_Set_24,\n+      25 => RE_Set_25,\n+      26 => RE_Set_26,\n+      27 => RE_Set_27,\n+      28 => RE_Set_28,\n+      29 => RE_Set_29,\n+      30 => RE_Set_30,\n+      31 => RE_Set_31,\n+      32 => RE_Null,\n+      33 => RE_Set_33,\n+      34 => RE_Set_34,\n+      35 => RE_Set_35,\n+      36 => RE_Set_36,\n+      37 => RE_Set_37,\n+      38 => RE_Set_38,\n+      39 => RE_Set_39,\n+      40 => RE_Set_40,\n+      41 => RE_Set_41,\n+      42 => RE_Set_42,\n+      43 => RE_Set_43,\n+      44 => RE_Set_44,\n+      45 => RE_Set_45,\n+      46 => RE_Set_46,\n+      47 => RE_Set_47,\n+      48 => RE_Set_48,\n+      49 => RE_Set_49,\n+      50 => RE_Set_50,\n+      51 => RE_Set_51,\n+      52 => RE_Set_52,\n+      53 => RE_Set_53,\n+      54 => RE_Set_54,\n+      55 => RE_Set_55,\n+      56 => RE_Set_56,\n+      57 => RE_Set_57,\n+      58 => RE_Set_58,\n+      59 => RE_Set_59,\n+      60 => RE_Set_60,\n+      61 => RE_Set_61,\n+      62 => RE_Set_62,\n+      63 => RE_Set_63);\n+\n+   --  Array of Set routine entities to be used in the case where the packed\n+   --  array is itself a component of a packed structure, and therefore may not\n+   --  be fully aligned. This only affects the even sizes, since for the odd\n+   --  sizes, we do not get any fixed alignment in any case.\n+\n+   SetU_Id : constant E_Array :=\n+     (01 => RE_Null,\n+      02 => RE_Null,\n+      03 => RE_Set_03,\n+      04 => RE_Null,\n+      05 => RE_Set_05,\n+      06 => RE_SetU_06,\n+      07 => RE_Set_07,\n+      08 => RE_Null,\n+      09 => RE_Set_09,\n+      10 => RE_SetU_10,\n+      11 => RE_Set_11,\n+      12 => RE_SetU_12,\n+      13 => RE_Set_13,\n+      14 => RE_SetU_14,\n+      15 => RE_Set_15,\n+      16 => RE_Null,\n+      17 => RE_Set_17,\n+      18 => RE_SetU_18,\n+      19 => RE_Set_19,\n+      20 => RE_SetU_20,\n+      21 => RE_Set_21,\n+      22 => RE_SetU_22,\n+      23 => RE_Set_23,\n+      24 => RE_SetU_24,\n+      25 => RE_Set_25,\n+      26 => RE_SetU_26,\n+      27 => RE_Set_27,\n+      28 => RE_SetU_28,\n+      29 => RE_Set_29,\n+      30 => RE_SetU_30,\n+      31 => RE_Set_31,\n+      32 => RE_Null,\n+      33 => RE_Set_33,\n+      34 => RE_SetU_34,\n+      35 => RE_Set_35,\n+      36 => RE_SetU_36,\n+      37 => RE_Set_37,\n+      38 => RE_SetU_38,\n+      39 => RE_Set_39,\n+      40 => RE_SetU_40,\n+      41 => RE_Set_41,\n+      42 => RE_SetU_42,\n+      43 => RE_Set_43,\n+      44 => RE_SetU_44,\n+      45 => RE_Set_45,\n+      46 => RE_SetU_46,\n+      47 => RE_Set_47,\n+      48 => RE_SetU_48,\n+      49 => RE_Set_49,\n+      50 => RE_SetU_50,\n+      51 => RE_Set_51,\n+      52 => RE_SetU_52,\n+      53 => RE_Set_53,\n+      54 => RE_SetU_54,\n+      55 => RE_Set_55,\n+      56 => RE_SetU_56,\n+      57 => RE_Set_57,\n+      58 => RE_SetU_58,\n+      59 => RE_Set_59,\n+      60 => RE_SetU_60,\n+      61 => RE_Set_61,\n+      62 => RE_SetU_62,\n+      63 => RE_Set_63);\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "f48db6f605f4fa809a5d061117fabd7eaa0c075d", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 62, "deletions": 28, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -71,6 +71,14 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Loop_Variant            (N : Node_Id);\n    procedure Expand_Pragma_Psect_Object            (N : Node_Id);\n    procedure Expand_Pragma_Relative_Deadline       (N : Node_Id);\n+   procedure Expand_Pragma_Suppress_Initialization (N : Node_Id);\n+\n+   procedure Undo_Initialization (Def_Id : Entity_Id; N : Node_Id);\n+   --  This procedure is used to undo initialization already done for Def_Id,\n+   --  which is always an E_Variable, in response to the occurrence of the\n+   --  pragma N, a pragma Interface, Import, or Suppress_Initialization. In all\n+   --  these cases we want no initialization to occur, but we have already done\n+   --  the initialization by the time we see the pragma, so we have to undo it.\n \n    ----------\n    -- Arg1 --\n@@ -836,6 +844,9 @@ package body Exp_Prag is\n             when Pragma_Relative_Deadline =>\n                Expand_Pragma_Relative_Deadline (N);\n \n+            when Pragma_Suppress_Initialization =>\n+               Expand_Pragma_Suppress_Initialization (N);\n+\n             --  All other pragmas need no expander action\n \n             when others => null;\n@@ -1170,7 +1181,6 @@ package body Exp_Prag is\n \n    procedure Expand_Pragma_Import_Or_Interface (N : Node_Id) is\n       Def_Id    : Entity_Id;\n-      Init_Call : Node_Id;\n \n    begin\n       --  In Relaxed_RM_Semantics, support old Ada 83 style:\n@@ -1186,35 +1196,10 @@ package body Exp_Prag is\n          Def_Id := Entity (Arg2 (N));\n       end if;\n \n-      --  Variable case\n+      --  Variable case (we have to undo any initialization already done)\n \n       if Ekind (Def_Id) = E_Variable then\n-\n-         --  When applied to a variable, the default initialization must not be\n-         --  done. As it is already done when the pragma is found, we just get\n-         --  rid of the call the initialization procedure which followed the\n-         --  object declaration. The call is inserted after the declaration,\n-         --  but validity checks may also have been inserted and thus the\n-         --  initialization call does not necessarily appear immediately\n-         --  after the object declaration.\n-\n-         --  We can't use the freezing mechanism for this purpose, since we\n-         --  have to elaborate the initialization expression when it is first\n-         --  seen (so this elaboration cannot be deferred to the freeze point).\n-\n-         --  Find and remove generated initialization call for object, if any\n-\n-         Init_Call := Remove_Init_Call (Def_Id, Rep_Clause => N);\n-\n-         --  Any default initialization expression should be removed (e.g.\n-         --  null defaults for access objects, zero initialization of packed\n-         --  bit arrays). Imported objects aren't allowed to have explicit\n-         --  initialization, so the expression must have been generated by\n-         --  the compiler.\n-\n-         if No (Init_Call) and then Present (Expression (Parent (Def_Id))) then\n-            Set_Expression (Parent (Def_Id), Empty);\n-         end if;\n+         Undo_Initialization (Def_Id, N);\n \n       --  Case of exception with convention C++\n \n@@ -1831,4 +1816,53 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Relative_Deadline;\n \n+   -------------------------------------------\n+   -- Expand_Pragma_Suppress_Initialization --\n+   -------------------------------------------\n+\n+   procedure Expand_Pragma_Suppress_Initialization (N : Node_Id) is\n+      Def_Id : constant Entity_Id  := Entity (Arg1 (N));\n+\n+   begin\n+      --  Variable case (we have to undo any initialization already done)\n+\n+      if Ekind (Def_Id) = E_Variable then\n+         Undo_Initialization (Def_Id, N);\n+      end if;\n+   end Expand_Pragma_Suppress_Initialization;\n+\n+   -------------------------\n+   -- Undo_Initialization --\n+   -------------------------\n+\n+   procedure Undo_Initialization (Def_Id : Entity_Id; N : Node_Id) is\n+      Init_Call : Node_Id;\n+\n+   begin\n+      --  When applied to a variable, the default initialization must not be\n+      --  done. As it is already done when the pragma is found, we just get rid\n+      --  of the call the initialization procedure which followed the object\n+      --  declaration. The call is inserted after the declaration, but validity\n+      --  checks may also have been inserted and thus the initialization call\n+      --  does not necessarily appear immediately after the object declaration.\n+\n+      --  We can't use the freezing mechanism for this purpose, since we have\n+      --  to elaborate the initialization expression when it is first seen (so\n+      --  this elaboration cannot be deferred to the freeze point).\n+\n+      --  Find and remove generated initialization call for object, if any\n+\n+      Init_Call := Remove_Init_Call (Def_Id, Rep_Clause => N);\n+\n+      --  Any default initialization expression should be removed (e.g.\n+      --  null defaults for access objects, zero initialization of packed\n+      --  bit arrays). Imported objects aren't allowed to have explicit\n+      --  initialization, so the expression must have been generated by\n+      --  the compiler.\n+\n+      if No (Init_Call) and then Present (Expression (Parent (Def_Id))) then\n+         Set_Expression (Parent (Def_Id), Empty);\n+      end if;\n+   end Undo_Initialization;\n+\n end Exp_Prag;"}, {"sha": "2eea620a97998334f4c6bd489d336ce74713d240", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -2370,6 +2370,24 @@ package body Freeze is\n                         Set_Has_Non_Standard_Rep (Base_Type (Arr), True);\n                         Set_Is_Bit_Packed_Array  (Base_Type (Arr), True);\n                         Set_Is_Packed            (Base_Type (Arr), True);\n+\n+                        --  Make sure that we have the necessary routines to\n+                        --  implement the packing, and complain now if not.\n+\n+                        declare\n+                           CS : constant Int   := UI_To_Int (Csiz);\n+                           RE : constant RE_Id := Get_Id (CS);\n+\n+                        begin\n+                           if RE /= RE_Null\n+                             and then not RTE_Available (RE)\n+                           then\n+                              Error_Msg_CRT\n+                                (\"packing of \" & UI_Image (Csiz)\n+                                 & \"-bit components\",\n+                                 First_Subtype (Etype (Arr)));\n+                           end if;\n+                        end;\n                      end if;\n                   end;\n                end if;"}, {"sha": "44230c22c3dcd1618252fad491f99a6db53685e5", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -330,6 +330,7 @@ Implementation Defined Aspects\n * Aspect Simple_Storage_Pool_Type::\n * Aspect SPARK_Mode::\n * Aspect Suppress_Debug_Info::\n+* Aspect Suppress_Initialization::\n * Aspect Test_Case::\n * Aspect Thread_Local_Storage::\n * Aspect Universal_Aliasing::\n@@ -7029,13 +7030,16 @@ with this pragma and others compiled in normal mode without it.\n Syntax:\n \n @smallexample @c ada\n-pragma Suppress_Initialization ([Entity =>] subtype_Name);\n+pragma Suppress_Initialization ([Entity =>] variable_or_subtype_Name);\n @end smallexample\n \n @noindent\n-Here subtype_Name is the name introduced by a type declaration\n-or subtype declaration.\n-This pragma suppresses any implicit or explicit initialization\n+Here variable_or_subtype_Name is the name introduced by a type declaration\n+or subtype declaration or the name of a variable introduced by an\n+object declaration.\n+\n+In the case of a type or subtype\n+this pragma suppresses any implicit or explicit initialization\n for all variables of the given type or subtype,\n including initialization resulting from the use of pragmas\n Normalize_Scalars or Initialize_Scalars.\n@@ -7055,6 +7059,10 @@ you will have to use some non-portable mechanism (e.g. address\n overlays or unchecked conversion) to achieve required initialization\n of these fields before accessing any object of the corresponding type.\n \n+For the variable case, implicit initialization for the named variable\n+is suppressed, just as though its subtype had been given in a pragma\n+Suppress_Initialization, as described above.\n+\n @node Pragma Task_Name\n @unnumberedsec Pragma Task_Name\n @findex Task_Name\n@@ -8119,6 +8127,7 @@ or attribute definition clause.\n * Aspect Simple_Storage_Pool_Type::\n * Aspect SPARK_Mode::\n * Aspect Suppress_Debug_Info::\n+* Aspect Suppress_Initialization::\n * Aspect Test_Case::\n * Aspect Thread_Local_Storage::\n * Aspect Universal_Aliasing::\n@@ -8494,6 +8503,12 @@ of a subprogram or package.\n @noindent\n This boolean aspect is equivalent to pragma @code{Suppress_Debug_Info}.\n \n+@node Aspect Suppress_Initialization\n+@unnumberedsec Aspect Suppress_Initialization\n+@findex Suppress_Initialization\n+@noindent\n+This boolean aspect is equivalent to pragma @code{Suppress_Initialization}.\n+\n @node Aspect Test_Case\n @unnumberedsec Aspect Test_Case\n @findex Test_Case"}, {"sha": "7dc74ed4a7a1706a26ca7843ef10bd070d84a631", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 105, "deletions": 3, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -128,6 +128,60 @@ package body Rtsfind is\n    --  The field First_Implicit_With in the unit table record are used to\n    --  avoid creating duplicate with_clauses.\n \n+   ----------------------------------------------\n+   -- Table of Predefined RE_Id Error Messages --\n+   ----------------------------------------------\n+\n+   --  If an attempt is made to load an entity, given an RE_Id value, and the\n+   --  entity is not available in the current configuration, an error message\n+   --  is given (see Entity_Not_Defined below). The general form of such an\n+   --  error message is for example:\n+\n+   --    entity \"System.Pack_43.Bits_43\" not defined\n+\n+   --  The following table defines a set of RE_Id image values for which this\n+   --  error message is specialized and replaced by specific text indicating\n+   --  the exact message to be output. For example, in the case above, for the\n+   --  RE_Id value RE_Bits_43, we do indeed specialize the message, and the\n+   --  above generic message is replaced by:\n+\n+   --    packed component size of 43 is not supported\n+\n+   type CString_Ptr is access constant String;\n+\n+   type PRE_Id_Entry is record\n+      Str : CString_Ptr;\n+      --  Pointer to string with the RE_Id image. The sequence ?? may appear\n+      --  in which case it will match any characters in the RE_Id image value.\n+      --  This is used to avoid the need for dozens of entries for RE_Bits_??.\n+\n+      Msg : CString_Ptr;\n+      --  Pointer to string with the corresponding error text. The sequence\n+      --  ?? may appear, in which case, it is replaced by the corresponding\n+      --  sequence ?? in the Str value (if the first ? is zero, then it is\n+      --  omitted from the message).\n+   end record;\n+\n+   Str1 : aliased constant String := \"RE_BITS_??\";\n+   Str2 : aliased constant String := \"RE_GET_??\";\n+   Str3 : aliased constant String := \"RE_SET_??\";\n+   Str4 : aliased constant String := \"RE_CALL_SIMPLE\";\n+\n+   MsgPack : aliased constant String :=\n+              \"packed component size of ?? is not supported\";\n+   MsgRV   : aliased constant String :=\n+              \"task rendezvous is not supported\";\n+\n+   PRE_Id_Table : constant array (Natural range <>) of PRE_Id_Entry :=\n+                    (1 => (Str1'Access, MsgPack'Access),\n+                     2 => (Str2'Access, MsgPack'Access),\n+                     3 => (Str3'Access, MsgPack'Access),\n+                     4 => (Str4'Access, MsgRV'Access));\n+   --  We will add entries to this table as we find cases where it is a good\n+   --  idea to do so. By no means all the RE_Id values need entries, because\n+   --  the expander often gives clear messages before it makes the Rtsfind\n+   --  call expecting to find the entity.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -141,7 +195,8 @@ package body Rtsfind is\n    procedure Entity_Not_Defined (Id : RE_Id);\n    --  Outputs error messages for an entity that is not defined in the run-time\n    --  library (the form of the error message is tailored for no run time or\n-   --  configurable run time mode as required).\n+   --  configurable run time mode as required). See also table of pre-defined\n+   --  messages for entities above (RE_Id_Messages).\n \n    function Get_Unit_Name (U_Id : RTU_Id) return Unit_Name_Type;\n    --  Retrieves the Unit Name given a unit id represented by its enumeration\n@@ -191,8 +246,7 @@ package body Rtsfind is\n \n    procedure Output_Entity_Name (Id : RE_Id; Msg : String);\n    --  Output continuation error message giving qualified name of entity\n-   --  corresponding to Id, appending the string given by Msg. This call\n-   --  is only effective in All_Errors mode.\n+   --  corresponding to Id, appending the string given by Msg.\n \n    function RE_Chars (E : RE_Id) return Name_Id;\n    --  Given a RE_Id value returns the Chars of the corresponding entity\n@@ -432,6 +486,54 @@ package body Rtsfind is\n          RTE_Error_Msg (\"run-time configuration error\");\n       end if;\n \n+      --  See if this entry is to be found in the PRE_Id table that provides\n+      --  specialized messages for some RE_Id values.\n+\n+      for J in PRE_Id_Table'Range loop\n+         declare\n+            TStr : constant String := PRE_Id_Table (J).Str.all;\n+            RStr : constant String := RE_Id'Image (Id);\n+            TMsg : String          := PRE_Id_Table (J).Msg.all;\n+            LMsg : Natural         := TMsg'Length;\n+\n+         begin\n+            if TStr'Length = RStr'Length then\n+               for J in TStr'Range loop\n+                  if TStr (J) /= RStr (J) and then TStr (J) /= '?' then\n+                     goto Continue;\n+                  end if;\n+               end loop;\n+\n+               for J in TMsg'First .. TMsg'Last - 1 loop\n+                  if TMsg (J) = '?' then\n+                     for K in 1 .. TStr'Last loop\n+                        if TStr (K) = '?' then\n+                           if RStr (K) = '0' then\n+                              TMsg (J) := RStr (K + 1);\n+                              TMsg (J + 1 .. LMsg - 1) := TMsg (J + 2 .. LMsg);\n+                              LMsg := LMsg - 1;\n+                           else\n+                              TMsg (J .. J + 1) := RStr (K .. K + 1);\n+                           end if;\n+\n+                           exit;\n+                        end if;\n+                     end loop;\n+                  end if;\n+               end loop;\n+\n+               RTE_Error_Msg (TMsg (1 .. LMsg));\n+               return;\n+            end if;\n+         end;\n+\n+         <<Continue>> null;\n+      end loop;\n+\n+      --  We did not find an entry in the table, so output the generic entity\n+      --  not found message, where the name of the entity corresponds to the\n+      --  given RE_Id value.\n+\n       Output_Entity_Name (Id, \"not defined\");\n    end Entity_Not_Defined;\n "}, {"sha": "ca1deebf12f8a863e0c10fd1626d93deec6ca4e1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -7553,15 +7553,17 @@ package body Sem_Attr is\n                Static :=\n                  Static and then not Is_Constr_Subt_For_U_Nominal (P_Type);\n                Set_Is_Static_Expression (N, Static);\n-\n             end if;\n \n             while Present (Nod) loop\n                if not Is_Static_Subtype (Etype (Nod)) then\n                   Static := False;\n                   Set_Is_Static_Expression (N, False);\n+\n                elsif not Is_OK_Static_Subtype (Etype (Nod)) then\n                   Set_Raises_Constraint_Error (N);\n+                  Static := False;\n+                  Set_Is_Static_Expression (N, False);\n                end if;\n \n                --  If however the index type is generic, or derived from\n@@ -7591,6 +7593,7 @@ package body Sem_Attr is\n \n       begin\n          E := E1;\n+\n          while Present (E) loop\n \n             --  If expression is not static, then the attribute reference\n@@ -7638,6 +7641,7 @@ package body Sem_Attr is\n          end loop;\n \n          if Raises_Constraint_Error (Prefix (N)) then\n+            Set_Is_Static_Expression (N, False);\n             return;\n          end if;\n       end;"}, {"sha": "32a3cf3a5e13aad4e941a1af9366cd93ea9e7ff0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -19927,8 +19927,9 @@ package body Sem_Prag is\n \n             E := Entity (E_Id);\n \n-            if not Is_Type (E) then\n-               Error_Pragma_Arg (\"pragma% requires type or subtype\", Arg1);\n+            if not Is_Type (E) and then Ekind (E) /= E_Variable then\n+               Error_Pragma_Arg\n+                 (\"pragma% requires variable, type or subtype\", Arg1);\n             end if;\n \n             if Rep_Item_Too_Early (E, N)\n@@ -19953,7 +19954,7 @@ package body Sem_Prag is\n             elsif Is_First_Subtype (E) then\n                Set_Suppress_Initialization (Base_Type (E));\n \n-            --  For other than first subtype, set flag on subtype itself\n+            --  For other than first subtype, set flag on subtype or variable\n \n             else\n                Set_Suppress_Initialization (E);"}, {"sha": "4b00be0f3fcdaea9101d9e5ef218e3354ae9d85d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -16462,8 +16462,9 @@ package body Sem_Util is\n          --  the entities within it).\n \n          if (Is_Implementation_Defined (Val)\n-               or else\n-             Is_Implementation_Defined (Scope (Val)))\n+              or else\n+                (Present (Scope (Val))\n+                  and then Is_Implementation_Defined (Scope (Val))))\n            and then not (Ekind_In (Val, E_Package, E_Generic_Package)\n                           and then Is_Library_Level_Entity (Val))\n          then"}, {"sha": "41719ea3aecb1f9c7ceeb3a84550c58e4124726b", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -187,6 +187,21 @@ package SPARK_Xrefs is\n \n    --    Examples: ??? add examples here\n \n+   --  -------------------------------\n+   --  -- Generated Globals Section --\n+   --  -------------------------------\n+\n+   --  The Generated Globals section is located at the end of the ALI file.\n+\n+   --  All lines introducing information related to the Generated Globals\n+   --  have the string \"GG\" appearing in the beginning. This string (\"GG\")\n+   --  should therefore not be used in the beginning of any line that does\n+   --  not relate to Generated Globals.\n+\n+   --  The processing (reading and writing) of this section happens in\n+   --  package Flow_Computed_Globals (from the SPARK 2014 sources), for\n+   --  further information please refer there.\n+\n    ----------------\n    -- Xref Table --\n    ----------------"}, {"sha": "7a554392a79becc56281c0272534ca47d59667c1", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1662,6 +1662,15 @@ package body Uintp is\n       Image_Out (Input, True, Format);\n    end UI_Image;\n \n+   function UI_Image\n+     (Input  : Uint;\n+      Format : UI_Format := Auto) return String\n+   is\n+   begin\n+      Image_Out (Input, True, Format);\n+      return UI_Image_Buffer (1 .. UI_Image_Length);\n+   end UI_Image;\n+\n    -------------------------\n    -- UI_Is_In_Int_Range --\n    -------------------------"}, {"sha": "1d90524b9a2a5122a1ebea6bd0805e243c28c4ea", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99425ec329df4fa7d48f34803efd901284267197/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=99425ec329df4fa7d48f34803efd901284267197", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -299,10 +299,15 @@ package Uintp is\n    --  followed by the value in UI_Image_Buffer. The form of the value is an\n    --  integer literal in either decimal (no base) or hexadecimal (base 16)\n    --  format. If Hex is True on entry, then hex mode is forced, otherwise\n-   --  UI_Image makes a guess at which output format is more convenient.\n-   --  The value must fit in UI_Image_Buffer. If necessary, the result is an\n-   --  approximation of the proper value, using an exponential format. The\n-   --  image of No_Uint is output as a single question mark.\n+   --  UI_Image makes a guess at which output format is more convenient. The\n+   --  value must fit in UI_Image_Buffer. The actual length of the result is\n+   --  returned in UI_Image_Length. If necessary to meet this requirement, the\n+   --  result is an approximation of the proper value, using an exponential\n+   --  format. The image of No_Uint is output as a single question mark.\n+\n+   function UI_Image (Input : Uint; Format : UI_Format := Auto) return String;\n+   --  Functional form, in which the result is returned as a string. This call\n+   --  also leaves the result in UI_Image_Buffer/Length as described above.\n \n    procedure UI_Write (Input : Uint; Format : UI_Format := Auto);\n    --  Writes a representation of Uint, consisting of a possible minus sign,"}]}