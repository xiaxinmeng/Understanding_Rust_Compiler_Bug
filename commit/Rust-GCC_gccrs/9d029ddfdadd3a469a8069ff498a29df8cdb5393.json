{"sha": "9d029ddfdadd3a469a8069ff498a29df8cdb5393", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQwMjlkZGZkYWRkM2E0NjlhODA2OWZmNDk4YTI5ZGY4Y2RiNTM5Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-23T10:58:57Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-23T10:58:57Z"}, "message": "cp-tree.h (OVL_P): New.\n\n\tgcc/cp\n\t* cp-tree.h (OVL_P): New.\n\t* name-lookup.h (push_local_binding): Delete.\n\t(do_toplevel_using_decl, do_local_using_decl): Rename to ...\n\t(finish_namespace_using_decl, finish_local_using_decl): ... here\n\t* name-lookup.c (add_decl_to_level): Swap args.\n\t(pop_bindings_and_leave_scope): Look inside TREE_LIST.\n\t(diagnose_name_conflict): Check contexts are same for redecl.\n\t(update_local_overload): New.\n\t(compparms_for_decl_and_using): Rename to ...\n\t(matching_fn_p): ... here.\n\t(pushdecl_maybe_friend_1): Adjust add_decl_to_level,\n\tpush_local_bindings call.\n\t(push_local_binding): Make static, replace FLAGS arg with\n\tIS_USING.\n\t(validate_nonmember_using_decl): Use OVL_FIRST.\n\t(do_nonmember_using_decl): Use in/out parameters.  Use\n\tlkp_iterator and simplify.\n\t(do_toplevel_using_decl, do_local_using_decl): Rename to ...\n\t(finish_namespace_using_decl, finish_local_using_decl): ... here.\n\tAdjust.\n\t(lookup_type_current_level): Delete.\n\t* parser.c (cp_parser_using_declaration): Adjust.\n\t* pt.c (tsubst_expr): Adjust.\n\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_add_using_decl): Call\n\tfinish_namespace_using_decl.  Use assert not unreachable.\n\n\tgcc/testsuite/\n\t* g++.dg/lookup/using13.C: Adjust expected error.\n\nFrom-SVN: r248364", "tree": {"sha": "f7cd3c7126e3fea6faa455d363ecf982e14ca211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7cd3c7126e3fea6faa455d363ecf982e14ca211"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d029ddfdadd3a469a8069ff498a29df8cdb5393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d029ddfdadd3a469a8069ff498a29df8cdb5393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d029ddfdadd3a469a8069ff498a29df8cdb5393", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d029ddfdadd3a469a8069ff498a29df8cdb5393/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92fa0f9e09a21f560100dbc1864ed9b576d41d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fa0f9e09a21f560100dbc1864ed9b576d41d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92fa0f9e09a21f560100dbc1864ed9b576d41d0c"}], "stats": {"total": 513, "additions": 266, "deletions": 247}, "files": [{"sha": "aaf39c25cbe968466ae11ffe8d77fce3adcb04f2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -1,3 +1,29 @@\n+2017-05-23  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (OVL_P): New.\n+\t* name-lookup.h (push_local_binding): Delete.\n+\t(do_toplevel_using_decl, do_local_using_decl): Rename to ...\n+\t(finish_namespace_using_decl, finish_local_using_decl): ... here\n+\t* name-lookup.c (add_decl_to_level): Swap args.\n+\t(pop_bindings_and_leave_scope): Look inside TREE_LIST.\n+\t(diagnose_name_conflict): Check contexts are same for redecl.\n+\t(update_local_overload): New.\n+\t(compparms_for_decl_and_using): Rename to ...\n+\t(matching_fn_p): ... here.\n+\t(pushdecl_maybe_friend_1): Adjust add_decl_to_level,\n+\tpush_local_bindings call.\n+\t(push_local_binding): Make static, replace FLAGS arg with\n+\tIS_USING.\n+\t(validate_nonmember_using_decl): Use OVL_FIRST.\n+\t(do_nonmember_using_decl): Use in/out parameters.  Use\n+\tlkp_iterator and simplify.\n+\t(do_toplevel_using_decl, do_local_using_decl): Rename to ...\n+\t(finish_namespace_using_decl, finish_local_using_decl): ... here.\n+\tAdjust.\n+\t(lookup_type_current_level): Delete.\n+\t* parser.c (cp_parser_using_declaration): Adjust.\n+\t* pt.c (tsubst_expr): Adjust.\n+\n 2017-05-22  Nathan Sidwell  <nathan@acm.org>\n \n \t* name-lookup.h (parse_using_directive): Replace with ..."}, {"sha": "8e8e5606c78cdd34b34a75a0898acb405ef45afc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -671,6 +671,11 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n /* The name of the overload set.  */\n #define OVL_NAME(NODE) DECL_NAME (OVL_FIRST (NODE))\n \n+/* Whether this is a set of overloaded functions.  TEMPLATE_DECLS are\n+   always wrapped in an OVERLOAD, so we don't need to check them\n+   here.  */\n+#define OVL_P(NODE) \\\n+  (TREE_CODE (NODE) == FUNCTION_DECL || TREE_CODE (NODE) == OVERLOAD)\n /* Whether this is a single member overload.  */\n #define OVL_SINGLE_P(NODE) \\\n   (TREE_CODE (NODE) != OVERLOAD || !OVL_CHAIN (NODE))"}, {"sha": "c79ded333a0d6cd4191dec06321a16bb6c81de7f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 216, "deletions": 235, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -38,6 +38,7 @@ static cp_binding_level *innermost_nonclass_level (void);\n static void set_identifier_type_value_with_scope (tree id, tree decl,\n \t\t\t\t\t\t  cp_binding_level *b);\n static void set_namespace_binding (tree scope, tree name, tree val);\n+static void push_local_binding (tree, tree, bool);\n \n /* The bindings for a particular name in a particular scope.  */\n \n@@ -58,14 +59,13 @@ static void consider_binding_level (tree name,\n \t\t\t\t    cp_binding_level *lvl,\n \t\t\t\t    bool look_within_fields,\n \t\t\t\t    enum lookup_name_fuzzy_kind kind);\n-static tree lookup_type_current_level (tree);\n static tree push_using_directive (tree);\n static void diagnose_name_conflict (tree, tree);\n \n /* Add DECL to the list of things declared in B.  */\n \n static void\n-add_decl_to_level (tree decl, cp_binding_level *b)\n+add_decl_to_level (cp_binding_level *b, tree decl)\n {\n   /* We used to record virtual tables as if they were ordinary\n      variables, but no longer do so.  */\n@@ -995,7 +995,13 @@ void\n pop_bindings_and_leave_scope (void)\n {\n   for (tree t = get_local_decls (); t; t = DECL_CHAIN (t))\n-    pop_local_binding (DECL_NAME (t), t);\n+    {\n+      tree decl = TREE_CODE (t) == TREE_LIST ? TREE_VALUE (t) : t;\n+      tree name = OVL_NAME (decl);\n+\n+      pop_local_binding (name, decl);\n+    }\n+\n   leave_scope ();\n }\n \n@@ -1179,7 +1185,8 @@ diagnose_name_conflict (tree decl, tree bval)\n       && (TREE_CODE (decl) != TYPE_DECL\n \t  || (DECL_ARTIFICIAL (decl) && DECL_ARTIFICIAL (bval))\n \t  || (!DECL_ARTIFICIAL (decl) && !DECL_ARTIFICIAL (bval)))\n-      && !is_overloaded_fn (decl))\n+      && !DECL_DECLARES_FUNCTION_P (decl)\n+      && CP_DECL_CONTEXT (decl) == CP_DECL_CONTEXT (bval))\n     error (\"redeclaration of %q#D\", decl);\n   else\n     error (\"%q#D conflicts with a previous declaration\", decl);\n@@ -1199,6 +1206,56 @@ supplement_binding (cxx_binding *binding, tree decl)\n   return ret;\n }\n \n+/* Replace BINDING's current value on its scope's name list with\n+   NEWVAL.  */\n+\n+static void\n+update_local_overload (cxx_binding *binding, tree newval)\n+{\n+  tree *d;\n+\n+  for (d = &binding->scope->names; ; d = &TREE_CHAIN (*d))\n+    if (*d == binding->value)\n+      {\n+\t/* Stitch new list node in.  */\n+\t*d = tree_cons (NULL_TREE, NULL_TREE, TREE_CHAIN (*d));\n+\tbreak;\n+      }\n+    else if (TREE_CODE (*d) == TREE_LIST && TREE_VALUE (*d) == binding->value)\n+      break;\n+\n+  TREE_VALUE (*d) = newval;\n+}\n+\n+/* Compares the parameter-type-lists of ONE and TWO and\n+   returns false if they are different.  If the DECLs are template\n+   functions, the return types and the template parameter lists are\n+   compared too (DR 565).  */\n+\n+static bool\n+matching_fn_p (tree one, tree two)\n+{\n+  if (!compparms (TYPE_ARG_TYPES (TREE_TYPE (one)),\n+\t\t  TYPE_ARG_TYPES (TREE_TYPE (two))))\n+    return false;\n+\n+  if (TREE_CODE (one) == TEMPLATE_DECL\n+      && TREE_CODE (two) == TEMPLATE_DECL)\n+    {\n+      /* Compare template parms.  */\n+      if (!comp_template_parms (DECL_TEMPLATE_PARMS (one),\n+\t\t\t\tDECL_TEMPLATE_PARMS (two)))\n+\treturn false;\n+\n+      /* And return type.  */\n+      if (!same_type_p (TREE_TYPE (TREE_TYPE (one)),\n+\t\t\tTREE_TYPE (TREE_TYPE (two))))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Map of identifiers to extern C functions (or LISTS thereof).  */\n \n static GTY(()) hash_map<lang_identifier *, tree> *extern_c_fns;\n@@ -1699,7 +1756,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \t{\n \t  t = push_overloaded_decl (x, PUSH_GLOBAL, is_friend);\n \t  if (t == x)\n-\t    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));\n+\t    add_decl_to_level (NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)), x);\n \t}\n \n       if (DECL_DECLARES_FUNCTION_P (t))\n@@ -1814,7 +1871,7 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n \n \t  if (need_new_binding)\n \t    {\n-\t      push_local_binding (name, x, 0);\n+\t      push_local_binding (name, x, false);\n \t      /* Because push_local_binding will hook X on to the\n \t\t current_binding_level's name list, we don't want to\n \t\t do that again below.  */\n@@ -1881,10 +1938,9 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)\n     }\n \n   if (need_new_binding)\n-    add_decl_to_level (x,\n-\t\t       DECL_NAMESPACE_SCOPE_P (x)\n+    add_decl_to_level (DECL_NAMESPACE_SCOPE_P (x)\n \t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n-\t\t       : current_binding_level);\n+\t\t       : current_binding_level, x);\n \n   return x;\n }\n@@ -1932,12 +1988,11 @@ maybe_push_decl (tree decl)\n }\n \n /* Bind DECL to ID in the current_binding_level, assumed to be a local\n-   binding level.  If PUSH_USING is set in FLAGS, we know that DECL\n-   doesn't really belong to this binding level, that it got here\n-   through a using-declaration.  */\n+   binding level.  If IS_USING is true, DECL got here through a\n+   using-declaration.  */\n \n-void\n-push_local_binding (tree id, tree decl, int flags)\n+static void\n+push_local_binding (tree id, tree decl, bool is_using)\n {\n   cp_binding_level *b;\n \n@@ -1958,15 +2013,14 @@ push_local_binding (tree id, tree decl, int flags)\n     /* Create a new binding.  */\n     push_binding (id, decl, b);\n \n-  if (TREE_CODE (decl) == OVERLOAD || (flags & PUSH_USING))\n-    /* We must put the OVERLOAD into a TREE_LIST since the\n-       TREE_CHAIN of an OVERLOAD is already used.  Similarly for\n-       decls that got here through a using-declaration.  */\n+  if (TREE_CODE (decl) == OVERLOAD || is_using)\n+    /* We must put the OVERLOAD or using into a TREE_LIST since we\n+       cannot use the decl's chain itself.  */\n     decl = build_tree_list (NULL_TREE, decl);\n \n   /* And put DECL on the list of things declared by the current\n      binding level.  */\n-  add_decl_to_level (decl, b);\n+  add_decl_to_level (b, decl);\n }\n \n /* Check to see whether or not DECL is a variable that would have been\n@@ -2840,28 +2894,6 @@ pushdecl_outermost_localscope (tree x)\n   return ret;\n }\n \n-/* Helper function for push_overloaded_decl_1 and do_nonmember_using_decl.\n-   Compares the parameter-type-lists of DECL1 and DECL2 and returns false\n-   if they are different.  If the DECLs are template functions, the return\n-   types and the template parameter lists are compared too (DR 565).  */\n-\n-static bool\n-compparms_for_decl_and_using_decl (tree decl1, tree decl2)\n-{\n-  if (!compparms (TYPE_ARG_TYPES (TREE_TYPE (decl1)),\n-\t\t  TYPE_ARG_TYPES (TREE_TYPE (decl2))))\n-    return false;\n-\n-  if (! DECL_FUNCTION_TEMPLATE_P (decl1)\n-      || ! DECL_FUNCTION_TEMPLATE_P (decl2))\n-    return true;\n-\n-  return (comp_template_parms (DECL_TEMPLATE_PARMS (decl1),\n-\t\t\t       DECL_TEMPLATE_PARMS (decl2))\n-\t  && same_type_p (TREE_TYPE (TREE_TYPE (decl1)),\n-\t\t\t  TREE_TYPE (TREE_TYPE (decl2))));\n-}\n-\n /* DECL is a FUNCTION_DECL for a non-member function, which may have\n    other definitions already in place.  We get around this by making\n    the value of the identifier point to a list of all the things that\n@@ -2918,7 +2950,7 @@ push_overloaded_decl_1 (tree decl, int flags, bool is_friend)\n \n \t      if (TREE_CODE (tmp) == OVERLOAD && OVL_USING_P (tmp)\n \t\t  && !(flags & PUSH_USING)\n-\t\t  && compparms_for_decl_and_using_decl (fn, decl)\n+\t\t  && matching_fn_p (fn, decl)\n \t\t  && ! decls_match (fn, decl))\n \t\tdiagnose_name_conflict (decl, fn);\n \n@@ -3047,10 +3079,7 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n       return NULL_TREE;\n     }\n \n-  if (is_overloaded_fn (decl))\n-    decl = get_first_fn (decl);\n-\n-  gcc_assert (DECL_P (decl));\n+  decl = OVL_FIRST (decl);\n \n   /* Make a USING_DECL.  */\n   tree using_decl = push_using_decl (scope, name);\n@@ -3064,199 +3093,132 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n   return using_decl;\n }\n \n-/* Process local and global using-declarations.  */\n+/* Process a local-scope or namespace-scope using declaration.  SCOPE\n+   is the nominated scope to search for NAME.  VALUE_P and TYPE_P\n+   point to the binding for NAME in the current scope and are\n+   updated.  */\n \n static void\n-do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n-\t\t\t tree *newval, tree *newtype)\n+do_nonmember_using_decl (tree scope, tree name, tree *value_p, tree *type_p)\n {\n-  struct scope_binding decls = EMPTY_SCOPE_BINDING;\n+  struct scope_binding lookup = EMPTY_SCOPE_BINDING;\n \n-  *newval = *newtype = NULL_TREE;\n-  if (!qualified_lookup_using_namespace (name, scope, &decls, 0))\n+  if (!qualified_lookup_using_namespace (name, scope, &lookup, 0))\n     /* Lookup error */\n     return;\n \n-  if (!decls.value && !decls.type)\n+  if (!lookup.value)\n     {\n       error (\"%qD not declared\", name);\n       return;\n     }\n+  else if (TREE_CODE (lookup.value) == TREE_LIST)\n+    {\n+      error (\"reference to %qD is ambiguous\", name);\n+      print_candidates (lookup.value);\n+      lookup.value = NULL_TREE;\n+    }\n+\n+  if (lookup.type && TREE_CODE (lookup.type) == TREE_LIST)\n+    {\n+      error (\"reference to %qD is ambiguous\", name);\n+      print_candidates (lookup.type);\n+      lookup.type = NULL_TREE;\n+    }\n+\n+  tree value = *value_p;\n+  tree type = *type_p;\n \n   /* Shift the old and new bindings around so we're comparing class and\n      enumeration names to each other.  */\n-  if (oldval && DECL_IMPLICIT_TYPEDEF_P (oldval))\n+  if (value && DECL_IMPLICIT_TYPEDEF_P (value))\n     {\n-      oldtype = oldval;\n-      oldval = NULL_TREE;\n+      type = value;\n+      value = NULL_TREE;\n     }\n \n-  if (decls.value && DECL_IMPLICIT_TYPEDEF_P (decls.value))\n+  if (lookup.value && DECL_IMPLICIT_TYPEDEF_P (lookup.value))\n     {\n-      decls.type = decls.value;\n-      decls.value = NULL_TREE;\n+      lookup.type = lookup.value;\n+      lookup.value = NULL_TREE;\n     }\n \n-  if (decls.value)\n+  if (lookup.value && lookup.value != value)\n     {\n       /* Check for using functions.  */\n-      if (is_overloaded_fn (decls.value))\n+      if (OVL_P (lookup.value) && (!value || OVL_P (value)))\n \t{\n-\t  tree tmp, tmp1;\n-\n-\t  if (oldval && !is_overloaded_fn (oldval))\n+\t  for (lkp_iterator usings (lookup.value); usings; ++usings)\n \t    {\n-\t      error (\"%qD is already declared in this scope\", name);\n-\t      oldval = NULL_TREE;\n-\t    }\n-\n-\t  *newval = oldval;\n-\t  for (tmp = decls.value; tmp; tmp = OVL_NEXT (tmp))\n-\t    {\n-\t      tree new_fn = OVL_CURRENT (tmp);\n-\n-\t      /* Don't import functions that haven't been declared.  */\n-\t      if (DECL_ANTICIPATED (new_fn))\n-\t\tcontinue;\n+\t      tree new_fn = *usings;\n \n \t      /* [namespace.udecl]\n \n \t\t If a function declaration in namespace scope or block\n \t\t scope has the same name and the same parameter types as a\n \t\t function introduced by a using declaration the program is\n \t\t ill-formed.  */\n-\t      for (tmp1 = oldval; tmp1; tmp1 = OVL_NEXT (tmp1))\n+\t      bool found = false;\n+\t      for (ovl_iterator old (value); !found && old; ++old)\n \t\t{\n-\t\t  tree old_fn = OVL_CURRENT (tmp1);\n+\t\t  tree old_fn = *old;\n \n \t\t  if (new_fn == old_fn)\n-\t\t    /* The function already exists in the current namespace.  */\n-\t\t    break;\n-\t\t  else if (TREE_CODE (tmp1) == OVERLOAD && OVL_USING_P (tmp1))\n-\t\t    continue; /* this is a using decl */\n-\t\t  else if (compparms_for_decl_and_using_decl (new_fn, old_fn))\n+\t\t    /* The function already exists in the current\n+\t\t       namespace.  */\n+\t\t    found = true;\n+\t\t  else if (old.using_p ())\n+\t\t    continue; /* This is a using decl. */\n+\t\t  else if (DECL_ANTICIPATED (old_fn)\n+\t\t\t   && !DECL_HIDDEN_FRIEND_P (old_fn))\n+\t\t    continue; /* This is an anticipated builtin.  */\n+\t\t  else if (!matching_fn_p (new_fn, old_fn))\n+\t\t    continue; /* Parameters do not match.  */\n+\t\t  else if (decls_match (new_fn, old_fn))\n+\t\t    found = true;\n+\t\t  else\n \t\t    {\n-\t\t      /* There was already a non-using declaration in\n-\t\t\t this scope with the same parameter types. If both\n-\t\t\t are the same extern \"C\" functions, that's ok.  */\n-\t\t      if (DECL_ANTICIPATED (old_fn)\n-\t\t\t  && !DECL_HIDDEN_FRIEND_P (old_fn))\n-\t\t\t/* Ignore anticipated built-ins.  */;\n-\t\t      else if (decls_match (new_fn, old_fn))\n-\t\t\tbreak;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  diagnose_name_conflict (new_fn, old_fn);\n-\t\t\t  break;\n-\t\t\t}\n+\t\t      diagnose_name_conflict (new_fn, old_fn);\n+\t\t      found = true;\n \t\t    }\n \t\t}\n \n-\t      /* If we broke out of the loop, there's no reason to add\n-\t\t this function to the using declarations for this\n-\t\t scope.  */\n-\t      if (tmp1)\n-\t\tcontinue;\n-\n-\t      /* If we are adding to an existing OVERLOAD, then we no\n-\t\t longer know the type of the set of functions.  */\n-\t      if (*newval && TREE_CODE (*newval) == OVERLOAD)\n-\t\tTREE_TYPE (*newval) = unknown_type_node;\n-\t      /* Add this new function to the set.  */\n-\t      *newval = ovl_insert (OVL_CURRENT (tmp), *newval, true);\n+\t      if (!found)\n+\t\t/* Unlike the overload case we don't drop anticipated\n+\t\t   builtins here.  They don't cause a problem, and\n+\t\t   we'd like to match them with a future\n+\t\t   declaration.  */\n+\t\tvalue = ovl_insert (new_fn, value, true);\n \t    }\n \t}\n+      else if (value\n+\t       /* Ignore anticipated builtins.  */\n+\t       && !(TREE_CODE (value) == FUNCTION_DECL\n+\t\t    && DECL_ANTICIPATED (value)\n+\t\t    && !DECL_HIDDEN_FRIEND_P (value))\n+\t       && !decls_match (lookup.value, value))\n+\tdiagnose_name_conflict (lookup.value, value);\n       else\n-\t{\n-\t  /* If we're declaring a non-function and OLDVAL is an anticipated\n-\t     built-in, just pretend it isn't there.  */\n-\t  if (oldval\n-\t      && TREE_CODE (oldval) == FUNCTION_DECL\n-\t      && DECL_ANTICIPATED (oldval)\n-\t      && !DECL_HIDDEN_FRIEND_P (oldval))\n-\t    oldval = NULL_TREE;\n-\n-\t  *newval = decls.value;\n-\t  if (oldval && !decls_match (*newval, oldval))\n-\t    error (\"%qD is already declared in this scope\", name);\n-\t}\n+\tvalue = lookup.value;\n     }\n-  else\n-    *newval = oldval;\n \n-  if (decls.type && TREE_CODE (decls.type) == TREE_LIST)\n+  if (lookup.type && lookup.type != type)\n     {\n-      error (\"reference to %qD is ambiguous\", name);\n-      print_candidates (decls.type);\n-    }\n-  else\n-    {\n-      *newtype = decls.type;\n-      if (oldtype && *newtype && !decls_match (oldtype, *newtype))\n-\terror (\"%qD is already declared in this scope\", name);\n-    }\n-\n-    /* If *newval is empty, shift any class or enumeration name down.  */\n-    if (!*newval)\n-      {\n-\t*newval = *newtype;\n-\t*newtype = NULL_TREE;\n-      }\n-}\n-\n-/* Process a using-declaration at function scope.  */\n-\n-void\n-do_local_using_decl (tree decl, tree scope, tree name)\n-{\n-  tree oldval, oldtype, newval, newtype;\n-  tree orig_decl = decl;\n-\n-  decl = validate_nonmember_using_decl (decl, scope, name);\n-  if (decl == NULL_TREE)\n-    return;\n-\n-  if (building_stmt_list_p ()\n-      && at_function_scope_p ())\n-    add_decl_expr (decl);\n-\n-  oldval = lookup_name_innermost_nonclass_level (name);\n-  oldtype = lookup_type_current_level (name);\n-\n-  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n-\n-  if (newval)\n-    {\n-      if (is_overloaded_fn (newval))\n-\t{\n-\t  tree fn, term;\n-\n-\t  /* We only need to push declarations for those functions\n-\t     that were not already bound in the current level.\n-\t     The old value might be NULL_TREE, it might be a single\n-\t     function, or an OVERLOAD.  */\n-\t  if (oldval && TREE_CODE (oldval) == OVERLOAD)\n-\t    term = OVL_FUNCTION (oldval);\n-\t  else\n-\t    term = oldval;\n-\t  for (fn = newval; fn && OVL_CURRENT (fn) != term;\n-\t       fn = OVL_NEXT (fn))\n-\t    push_overloaded_decl (OVL_CURRENT (fn),\n-\t\t\t\t  PUSH_LOCAL | PUSH_USING,\n-\t\t\t\t  false);\n-\t}\n+      if (type && !decls_match (lookup.type, type))\n+\tdiagnose_name_conflict (lookup.type, type);\n       else\n-\tpush_local_binding (name, newval, PUSH_USING);\n+\ttype = lookup.type;\n     }\n-  if (newtype)\n+\n+  /* If bind->value is empty, shift any class or enumeration name back.  */\n+  if (!value)\n     {\n-      push_local_binding (name, newtype, PUSH_USING);\n-      set_identifier_type_value (name, newtype);\n+      value = type;\n+      type = NULL_TREE;\n     }\n \n-  /* Emit debug info.  */\n-  if (!processing_template_decl)\n-    cp_emit_debug_info_for_using (orig_decl, current_scope());\n+  *value_p = value;\n+  *type_p = type;\n }\n \n /* Returns true if ANCESTOR encloses DESCENDANT, including matching.\n@@ -4337,35 +4299,86 @@ pushdecl_namespace_level (tree x, bool is_friend)\n   return t;\n }\n \n-/* Process a using-declaration not appearing in class or local scope.  */\n+/* Process a using-declaration appearing in namespace scope.  */\n \n void\n-do_toplevel_using_decl (tree decl, tree scope, tree name)\n+finish_namespace_using_decl (tree decl, tree scope, tree name)\n {\n-  tree oldval, oldtype, newval, newtype;\n   tree orig_decl = decl;\n-  cxx_binding *binding;\n \n+  gcc_checking_assert (current_binding_level->kind == sk_namespace);\n   decl = validate_nonmember_using_decl (decl, scope, name);\n   if (decl == NULL_TREE)\n     return;\n \n-  binding = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n+  cxx_binding *binding\n+    = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n+\n+  tree value = binding->value;\n+  tree type = binding->type;\n \n-  oldval = binding->value;\n-  oldtype = binding->type;\n+  do_nonmember_using_decl (scope, name, &value, &type);\n \n-  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n+  /* Copy declarations found.  */\n+  binding->value = value;\n+  binding->type = type;\n \n   /* Emit debug info.  */\n+  gcc_assert (!processing_template_decl);\n   if (!processing_template_decl)\n     cp_emit_debug_info_for_using (orig_decl, current_namespace);\n+}\n \n-  /* Copy declarations found.  */\n-  if (newval)\n-    binding->value = newval;\n-  if (newtype)\n-    binding->type = newtype;\n+/* Process a using-declaration at local scope.  */\n+\n+void\n+finish_local_using_decl (tree decl, tree scope, tree name)\n+{\n+  tree orig_decl = decl;\n+\n+  gcc_checking_assert (current_binding_level->kind != sk_class\n+\t\t       && current_binding_level->kind != sk_namespace);\n+  decl = validate_nonmember_using_decl (decl, scope, name);\n+  if (decl == NULL_TREE)\n+    return;\n+\n+  gcc_assert (building_stmt_list_p ());\n+  if (building_stmt_list_p ()\n+      && at_function_scope_p ())\n+    add_decl_expr (decl);\n+\n+  cxx_binding *binding = find_local_binding (current_binding_level, name);\n+  tree value = binding ? binding->value : NULL_TREE;\n+  tree type = binding ? binding->type : NULL_TREE;\n+\n+  do_nonmember_using_decl (scope, name, &value, &type);\n+\n+  if (!value)\n+    ;\n+  else if (binding && value == binding->value)\n+    ;\n+  else if (binding && binding->value && TREE_CODE (value) == OVERLOAD)\n+    {\n+      update_local_overload (IDENTIFIER_BINDING (name), value);\n+      IDENTIFIER_BINDING (name)->value = value;\n+    }\n+  else\n+    /* Install the new binding.  */\n+    push_local_binding (name, value, true);\n+\n+  if (!type)\n+    ;\n+  else if (binding && type == binding->type)\n+    ;\n+  else\n+    {\n+      push_local_binding (name, type, true);\n+      set_identifier_type_value (name, type);\n+    }\n+\n+  /* Emit debug info.  */\n+  if (!processing_template_decl)\n+    cp_emit_debug_info_for_using (orig_decl, current_scope ());\n }\n \n /* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n@@ -5651,38 +5664,6 @@ is_local_extern (tree decl)\n   return false;\n }\n \n-/* Like lookup_name_innermost_nonclass_level, but for types.  */\n-\n-static tree\n-lookup_type_current_level (tree name)\n-{\n-  tree t = NULL_TREE;\n-\n-  timevar_start (TV_NAME_LOOKUP);\n-  gcc_assert (current_binding_level->kind != sk_namespace);\n-\n-  if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n-      && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n-    {\n-      cp_binding_level *b = current_binding_level;\n-      while (1)\n-\t{\n-\t  if (purpose_member (name, b->type_shadowed))\n-\t    {\n-\t      t = REAL_IDENTIFIER_TYPE_VALUE (name);\n-\t      break;\n-\t    }\n-\t  if (b->kind == sk_cleanup)\n-\t    b = b->level_chain;\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  timevar_stop (TV_NAME_LOOKUP);\n-  return t;\n-}\n-\n /* Add namespace to using_directives. Return NULL_TREE if nothing was\n    changed (i.e. there was already a directive), or the fresh\n    TREE_LIST otherwise.  */"}, {"sha": "85a5b69f96241679d8c1cab1b6c519bd2ed3de96", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -315,7 +315,6 @@ extern tree lookup_name_nonclass (tree);\n extern tree lookup_name_innermost_nonclass_level (tree);\n extern bool is_local_extern (tree);\n extern tree lookup_function_nonclass (tree, vec<tree, va_gc> *, bool);\n-extern void push_local_binding (tree, tree, int);\n extern bool pushdecl_class_level (tree);\n extern tree pushdecl_namespace_level (tree, bool);\n extern bool push_class_level_binding (tree, tree);\n@@ -326,8 +325,6 @@ extern void set_decl_namespace (tree, tree, bool);\n extern void push_decl_namespace (tree);\n extern void pop_decl_namespace (void);\n extern void do_namespace_alias (tree, tree);\n-extern void do_toplevel_using_decl (tree, tree, tree);\n-extern void do_local_using_decl (tree, tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern void do_using_directive (tree);\n extern cp_expr lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n@@ -336,6 +333,8 @@ extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);\n extern void cp_emit_debug_info_for_using (tree, tree);\n \n+extern void finish_namespace_using_decl (tree, tree, tree);\n+extern void finish_local_using_decl (tree, tree, tree);\n extern void finish_namespace_using_directive (tree, tree);\n extern void finish_local_using_directive (tree, tree);\n extern tree pushdecl_outermost_localscope (tree);"}, {"sha": "23d979cc2f63daf3ff4f880e22187bb7dc222817", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -18499,9 +18499,9 @@ cp_parser_using_declaration (cp_parser* parser,\n \t      return false;\n \t    }\n \t  else if (!at_namespace_scope_p ())\n-\t    do_local_using_decl (decl, qscope, identifier);\n+\t    finish_local_using_decl (decl, qscope, identifier);\n \t  else\n-\t    do_toplevel_using_decl (decl, qscope, identifier);\n+\t    finish_namespace_using_decl (decl, qscope, identifier);\n \t}\n     }\n "}, {"sha": "10cac4aa05b10e988e9865670d1fd7718abe8fff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -15696,7 +15696,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n \t      qualified_name_lookup_error (scope, name, decl, input_location);\n \t    else\n-\t      do_local_using_decl (decl, scope, name);\n+\t      finish_local_using_decl (decl, scope, name);\n \t  }\n \telse if (DECL_PACK_P (decl))\n \t  {"}, {"sha": "7b42abc6378ff307010a3d2f406752728f102fb1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -1,3 +1,7 @@\n+2017-05-23  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/lookup/using13.C: Adjust expected error.\n+\n 2017-05-23  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \t* gcc.dg/tree-ssa/builtin-snprintf-warn-3.c: Require ptr32plus."}, {"sha": "26b703d0e7cb3c355d1724c2a011f3eb3960552c", "filename": "gcc/testsuite/g++.dg/lookup/using13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing13.C?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -8,5 +8,5 @@ namespace A { int a; }\n \n namespace C{\n   int a;\n-  using A::a;\t\t// { dg-error \"already declared\" }\n+  using A::a;\t\t// { dg-error \"conflicts with a previous\" }\n }"}, {"sha": "1969873a1fdd5b0adad1fbd7a4a5dee913b0745d", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -1,3 +1,8 @@\n+2017-05-23  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* libcp1plugin.cc (plugin_add_using_decl): Call\n+\tfinish_namespace_using_decl.  Use assert not unreachable.\n+\n 2017-05-11  Nathan Sidwell  <nathan@acm.org>\n \n \t* libcp1plugin.cc (safe_pushdecl_maybe_friend): Call pushdecl."}, {"sha": "7db74c737a0d778624b342b495391579fc59281f", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d029ddfdadd3a469a8069ff498a29df8cdb5393/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d029ddfdadd3a469a8069ff498a29df8cdb5393/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=9d029ddfdadd3a469a8069ff498a29df8cdb5393", "patch": "@@ -1030,13 +1030,12 @@ plugin_add_using_decl (cc1_plugin::connection *,\n \n       finish_member_declaration (decl);\n     }\n-  else if (!at_namespace_scope_p ())\n+  else\n     {\n-      gcc_unreachable ();\n-      do_local_using_decl (target, tcontext, identifier);\n+      /* We can't be at local scope.  */\n+      gcc_assert (at_namespace_scope_p ());\n+      finish_namespace_using_decl (target, tcontext, identifier);\n     }\n-  else\n-    do_toplevel_using_decl (target, tcontext, identifier);\n \n   return 1;\n }"}]}