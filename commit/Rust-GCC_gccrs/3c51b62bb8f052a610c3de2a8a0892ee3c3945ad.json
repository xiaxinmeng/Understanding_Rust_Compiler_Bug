{"sha": "3c51b62bb8f052a610c3de2a8a0892ee3c3945ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M1MWI2MmJiOGYwNTJhNjEwYzNkZTJhOGEwODkyZWUzYzM5NDVhZA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T12:32:32Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T17:48:56Z"}, "message": "rs6000: Parsing built-in input file, part 2 of 3\n\n2021-07-21  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c (parse_args): New function.\n\t(parse_prototype): Implement.", "tree": {"sha": "569ef291360b05bd0a2bf36fd8503be9832f0949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/569ef291360b05bd0a2bf36fd8503be9832f0949"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c51b62bb8f052a610c3de2a8a0892ee3c3945ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c51b62bb8f052a610c3de2a8a0892ee3c3945ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c51b62bb8f052a610c3de2a8a0892ee3c3945ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c51b62bb8f052a610c3de2a8a0892ee3c3945ad/comments", "author": null, "committer": null, "parents": [{"sha": "c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2d777d6f3a17ac07f78bc4c7dc4d1e0ddd566ae"}], "stats": {"total": 145, "additions": 145, "deletions": 0}, "files": [{"sha": "ee32a0db43c8e7353834d9e4ce44788ca0d7b208", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c51b62bb8f052a610c3de2a8a0892ee3c3945ad/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c51b62bb8f052a610c3de2a8a0892ee3c3945ad/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=3c51b62bb8f052a610c3de2a8a0892ee3c3945ad", "patch": "@@ -1072,6 +1072,93 @@ match_type (typeinfo *typedata, int voidok)\n   return 1;\n }\n \n+/* Parse the argument list.  */\n+static parse_codes\n+parse_args (prototype *protoptr)\n+{\n+  typelist **argptr = &protoptr->args;\n+  int *nargs = &protoptr->nargs;\n+  int *restr_opnd = protoptr->restr_opnd;\n+  restriction *restr = protoptr->restr;\n+  char **val1 = protoptr->restr_val1;\n+  char **val2 = protoptr->restr_val2;\n+  int restr_cnt = 0;\n+\n+  int success;\n+  *nargs = 0;\n+\n+  /* Start the argument list.  */\n+  consume_whitespace ();\n+  if (linebuf[pos] != '(')\n+    {\n+      (*diag) (\"missing '(' at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+\n+  do {\n+    consume_whitespace ();\n+    int oldpos = pos;\n+    typelist *argentry = (typelist *) malloc (sizeof (typelist));\n+    memset (argentry, 0, sizeof *argentry);\n+    typeinfo *argtype = &argentry->info;\n+    success = match_type (argtype, VOID_NOTOK);\n+    if (success)\n+      {\n+\tif (argtype->restr)\n+\t  {\n+\t    if (restr_cnt >= MAXRESTROPNDS)\n+\t      {\n+\t\t(*diag) (\"More than two %d operands\\n\", MAXRESTROPNDS);\n+\t\treturn PC_PARSEFAIL;\n+\t      }\n+\t    restr_opnd[restr_cnt] = *nargs + 1;\n+\t    restr[restr_cnt] = argtype->restr;\n+\t    val1[restr_cnt] = argtype->val1;\n+\t    val2[restr_cnt] = argtype->val2;\n+\t    restr_cnt++;\n+\t  }\n+\t(*nargs)++;\n+\t*argptr = argentry;\n+\targptr = &argentry->next;\n+\tconsume_whitespace ();\n+\tif (linebuf[pos] == ',')\n+\t  safe_inc_pos ();\n+\telse if (linebuf[pos] != ')')\n+\t  {\n+\t    (*diag) (\"arg not followed by ',' or ')' at column %d.\\n\",\n+\t\t     pos + 1);\n+\t    return PC_PARSEFAIL;\n+\t  }\n+\n+#ifdef DEBUG\n+\t(*diag) (\"argument type: isvoid = %d, isconst = %d, isvector = %d, \"\n+\t\t \"issigned = %d, isunsigned = %d, isbool = %d, ispixel = %d, \"\n+\t\t \"ispointer = %d, base = %d, restr = %d, val1 = \\\"%s\\\", \"\n+\t\t \"val2 = \\\"%s\\\", pos = %d.\\n\",\n+\t\t argtype->isvoid, argtype->isconst, argtype->isvector,\n+\t\t argtype->issigned, argtype->isunsigned, argtype->isbool,\n+\t\t argtype->ispixel, argtype->ispointer, argtype->base,\n+\t\t argtype->restr, argtype->val1, argtype->val2, pos + 1);\n+#endif\n+      }\n+    else\n+      {\n+\tfree (argentry);\n+\t*argptr = NULL;\n+\tpos = oldpos;\n+\tif (linebuf[pos] != ')')\n+\t  {\n+\t    (*diag) (\"badly terminated arg list at column %d.\\n\", pos + 1);\n+\t    return PC_PARSEFAIL;\n+\t  }\n+\tsafe_inc_pos ();\n+      }\n+  } while (success);\n+\n+  return PC_OK;\n+}\n+\n /* Parse the attribute list.  */\n static parse_codes\n parse_bif_attrs (attrinfo *attrptr)\n@@ -1084,6 +1171,64 @@ parse_bif_attrs (attrinfo *attrptr)\n static parse_codes\n parse_prototype (prototype *protoptr)\n {\n+  typeinfo *ret_type = &protoptr->rettype;\n+  char **bifname = &protoptr->bifname;\n+\n+  /* Get the return type.  */\n+  consume_whitespace ();\n+  int oldpos = pos;\n+  int success = match_type (ret_type, VOID_OK);\n+  if (!success)\n+    {\n+      (*diag) (\"missing or badly formed return type at column %d.\\n\",\n+\t       oldpos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+#ifdef DEBUG\n+  (*diag) (\"return type: isvoid = %d, isconst = %d, isvector = %d, \"\n+\t   \"issigned = %d, isunsigned = %d, isbool = %d, ispixel = %d, \"\n+\t   \"ispointer = %d, base = %d, restr = %d, val1 = \\\"%s\\\", \"\n+\t   \"val2 = \\\"%s\\\", pos = %d.\\n\",\n+\t   ret_type->isvoid, ret_type->isconst, ret_type->isvector,\n+\t   ret_type->issigned, ret_type->isunsigned, ret_type->isbool,\n+\t   ret_type->ispixel, ret_type->ispointer, ret_type->base,\n+\t   ret_type->restr, ret_type->val1, ret_type->val2, pos + 1);\n+#endif\n+\n+  /* Get the bif name.  */\n+  consume_whitespace ();\n+  oldpos = pos;\n+  *bifname = match_identifier ();\n+  if (!*bifname)\n+    {\n+      (*diag) (\"missing function name at column %d.\\n\", oldpos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n+#ifdef DEBUG\n+  (*diag) (\"function name is '%s'.\\n\", *bifname);\n+#endif\n+\n+  /* Process arguments.  */\n+  if (parse_args (protoptr) == PC_PARSEFAIL)\n+    return PC_PARSEFAIL;\n+\n+  /* Process terminating semicolon.  */\n+  consume_whitespace ();\n+  if (linebuf[pos] != ';')\n+    {\n+      (*diag) (\"missing semicolon at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+  safe_inc_pos ();\n+  consume_whitespace ();\n+  if (linebuf[pos] != '\\n')\n+    {\n+      (*diag) (\"garbage at end of line at column %d.\\n\", pos + 1);\n+      return PC_PARSEFAIL;\n+    }\n+\n   return PC_OK;\n }\n "}]}