{"sha": "79c2ffde686279bf867bc890584da1990a42899e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljMmZmZGU2ODYyNzliZjg2N2JjODkwNTg0ZGExOTkwYTQyODk5ZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-12-19T17:41:20Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-19T17:41:20Z"}, "message": "More scheduler infrastructure.\n\nFrom-SVN: r38381", "tree": {"sha": "013277f950b7f201ce69219bf4e5634032099790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/013277f950b7f201ce69219bf4e5634032099790"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79c2ffde686279bf867bc890584da1990a42899e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c2ffde686279bf867bc890584da1990a42899e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c2ffde686279bf867bc890584da1990a42899e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c2ffde686279bf867bc890584da1990a42899e/comments", "author": null, "committer": null, "parents": [{"sha": "288c2c9e631f700809d885eef05a4d3fce212d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/288c2c9e631f700809d885eef05a4d3fce212d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/288c2c9e631f700809d885eef05a4d3fce212d86"}], "stats": {"total": 211, "additions": 156, "deletions": 55}, "files": [{"sha": "76da5ee3ae3a687a94955109bba50b4a1c1fd644", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -1,5 +1,36 @@\n 2000-12-19  Bernd Schmidt  <bernds@redhat.co.uk>\n \n+\t* haifa-sched.c (rm_line_notes): Arguments are now head and tail,\n+\tnot block number.  All callers and prototype changed.\n+\t(set_priorities): Likewise.\n+\t(save_line_notes): Add head and tail arguments; all callers and\n+\tprototype changed.\n+\t(restore_line_notes): Likewise.  Don't crash on insns generated\n+\tduring scheduling.\n+\t(schedule_block): Don't use BLOCK_HEAD/BLOCK_END macros.\n+\tCall MD_SCHED_INIT with additional argument.\n+\tWhen starting a new cycle, emit cycle_display insns if available.\n+\tDon't stop scheduling when encountering a JUMP_INSN, but add another\n+\tcall to schedule_more_p in the inner loop.\n+\tCall MD_SCHED_REORDER2 after scheduling an insn.\n+\tCall MD_SCHED_FINISH once all insns are scheduled.\n+\t(sched_init): Compensate for the fact that get_block_head_tail\n+\tdoesn't include leading notes.\n+\t* sched-deps.c (free_deps): Free vectors here.\n+\t* sched-rgn.c (compute_block_backward_dependencies): Not here.\n+\t(last_was_jump): New static variable.\n+\t(schedule_more_p): Test it.\n+\t(init_ready_list): Initialize it.\n+\t(can_schedule_ready_p): Set it if we have a JUMP_INSN.\n+\n+\t* config/i386/i386.h (MD_SCHED_INIT): Add new arg.\n+\t* config/m32r/m32r.h (MD_SCHED_INIT): Add new arg.\n+\t* config/sparc/sparc.h (MD_SCHED_INIT): Add new arg.\n+\n+\t* md.texi (cycle_display): Document.\n+\t* tm.texi (MD_SCHED_INIT): Document new arg.\n+\t(MD_SCHED_FINISH, MD_SCHED_REORDER2): Document.\n+\n \t* flow.c (ior_reg_cond, nand_reg_cond, not_reg_cond): Rewrite\n \tto use different representation.  All callers changed.\n \t(and_reg_cond): Renamed from nand_reg_cond; caller changed."}, {"sha": "111ea1812de280deb43e0d609a77820550512f2b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -2462,7 +2462,7 @@ while (0)\n #define ISSUE_RATE \\\n   ix86_issue_rate ()\n \n-#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE) \\\n+#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE, MAX_READY) \\\n   ix86_sched_init (DUMP, SCHED_VERBOSE)\n \n #define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\"}, {"sha": "d83e2fed512768622180daa4e09fc5f96aed45d4", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -1554,7 +1554,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n extern int m32r_sched_odd_word_p;\n \n /* Hook to run before scheduling a block of insns.  */\n-#define MD_SCHED_INIT(STREAM, VERBOSE) m32r_sched_init (STREAM, VERBOSE)\n+#define MD_SCHED_INIT(STREAM, VERBOSE, MAX_READY) \\\n+  m32r_sched_init (STREAM, VERBOSE)\n \n /* Hook to reorder the list of ready instructions.  */\n #define MD_SCHED_REORDER(STREAM, VERBOSE, READY, N_READY, CLOCK, CIM) \t\\"}, {"sha": "50ab2ab4a96fbcb72a46eff76b92b306d12d543c", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -2897,7 +2897,7 @@ do {                                                                    \\\n #define ADJUST_COST(INSN,LINK,DEP,COST) \\\n   (COST) = sparc_adjust_cost(INSN, LINK, DEP, COST)\n \n-#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE)\t\t\t\t\\\n+#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE, MAX_READY)\t\t\t\\\n   if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\t\\\n     ultrasparc_sched_init (DUMP, SCHED_VERBOSE)\n "}, {"sha": "32ccf82bcbac56b646d262d53dd8fd503c055ab5", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 59, "deletions": 37, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -1163,23 +1163,17 @@ no_real_insns_p (head, tail)\n   return 1;\n }\n \n-/* Delete line notes from bb. Save them so they can be later restored\n-   (in restore_line_notes ()).  */\n+/* Delete line notes from one block. Save them so they can be later restored\n+   (in restore_line_notes).  HEAD and TAIL are the boundaries of the\n+   block in which notes should be processed.  */\n \n void\n-rm_line_notes (b)\n-     int b;\n+rm_line_notes (head, tail)\n+     rtx head, tail;\n {\n   rtx next_tail;\n-  rtx tail;\n-  rtx head;\n   rtx insn;\n \n-  get_block_head_tail (b, &head, &tail);\n-\n-  if (head == tail && (! INSN_P (head)))\n-    return;\n-\n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n@@ -1203,13 +1197,14 @@ rm_line_notes (b)\n     }\n }\n \n-/* Save line number notes for each insn in block B.  */\n+/* Save line number notes for each insn in block B.  HEAD and TAIL are\n+   the boundaries of the block in which notes should be processed.*/\n \n void\n-save_line_notes (b)\n+save_line_notes (b, head, tail)\n      int b;\n+     rtx head, tail;\n {\n-  rtx head, tail;\n   rtx next_tail;\n \n   /* We must use the true line number for the first insn in the block\n@@ -1220,28 +1215,30 @@ save_line_notes (b)\n   rtx line = line_note_head[b];\n   rtx insn;\n \n-  get_block_head_tail (b, &head, &tail);\n   next_tail = NEXT_INSN (tail);\n \n-  for (insn = BLOCK_HEAD (b); insn != next_tail; insn = NEXT_INSN (insn))\n+  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n       line = insn;\n     else\n       LINE_NOTE (insn) = line;\n }\n \n-/* After block B was scheduled, insert line notes into the insns list.  */\n+/* After block B was scheduled, insert line notes into the insns list.\n+   HEAD and TAIL are the boundaries of the block in which notes should\n+   be processed.*/\n \n void\n-restore_line_notes (b)\n+restore_line_notes (b, head, tail)\n      int b;\n+     rtx head, tail;\n {\n   rtx line, note, prev, new;\n   int added_notes = 0;\n-  rtx head, next_tail, insn;\n+  rtx next_tail, insn;\n \n-  head = BLOCK_HEAD (b);\n-  next_tail = NEXT_INSN (BLOCK_END (b));\n+  head = head;\n+  next_tail = NEXT_INSN (tail);\n \n   /* Determine the current line-number.  We want to know the current\n      line number of the first insn of the block here, in case it is\n@@ -1263,6 +1260,7 @@ restore_line_notes (b)\n      by real instructions all end up at the same address.  I can find no\n      use for line number notes before other notes, so none are emitted.  */\n     else if (GET_CODE (insn) != NOTE\n+\t     && INSN_UID (insn) < old_max_uid\n \t     && (note = LINE_NOTE (insn)) != 0\n \t     && note != line\n \t     && (line == 0\n@@ -1341,7 +1339,7 @@ rm_redundant_line_notes ()\n     fprintf (sched_dump, \";; deleted %d line-number notes\\n\", notes);\n }\n \n-/* Delete notes between head and tail and put them in the chain\n+/* Delete notes between HEAD and TAIL and put them in the chain\n    of notes ended by NOTE_LIST.  */\n \n void\n@@ -1662,7 +1660,7 @@ schedule_block (b, rgn_n_insns)\n       fprintf (sched_dump, \";;   ======================================================\\n\");\n       fprintf (sched_dump,\n \t       \";;   -- basic block %d from %d to %d -- %s reload\\n\",\n-\t       b, INSN_UID (BLOCK_HEAD (b)), INSN_UID (BLOCK_END (b)),\n+\t       b, INSN_UID (head), INSN_UID (tail),\n \t       (reload_completed ? \"after\" : \"before\"));\n       fprintf (sched_dump, \";;   ======================================================\\n\");\n       fprintf (sched_dump, \"\\n\");\n@@ -1682,7 +1680,7 @@ schedule_block (b, rgn_n_insns)\n   (*current_sched_info->init_ready_list) (&ready);\n \n #ifdef MD_SCHED_INIT\n-  MD_SCHED_INIT (sched_dump, sched_verbose);\n+  MD_SCHED_INIT (sched_dump, sched_verbose, ready.veclen);\n #endif\n \n   /* No insns scheduled in this block yet.  */\n@@ -1712,6 +1710,11 @@ schedule_block (b, rgn_n_insns)\n          list.  */\n       queue_to_ready (&ready);\n \n+#ifdef HAVE_cycle_display\n+      if (HAVE_cycle_display)\n+\tlast = emit_insn_after (gen_cycle_display (GEN_INT (clock_var)), last);\n+#endif\n+\n       if (ready.n_ready == 0)\n \tabort ();\n \n@@ -1740,7 +1743,9 @@ schedule_block (b, rgn_n_insns)\n \t}\n \n       /* Issue insns from ready list.  */\n-      while (ready.n_ready != 0 && can_issue_more)\n+      while (ready.n_ready != 0\n+\t     && can_issue_more\n+\t     && (*current_sched_info->schedule_more_p) ())\n \t{\n \t  /* Select and remove the insn from the ready list.  */\n \t  rtx insn = ready_remove_first (&ready);\n@@ -1768,16 +1773,25 @@ schedule_block (b, rgn_n_insns)\n \t  schedule_insn (insn, &ready, clock_var);\n \n \tnext:\n-\t  /* Close this block after scheduling its jump.  */\n-\t  if (GET_CODE (last_scheduled_insn) == JUMP_INSN)\n-\t    break;\n+#ifdef MD_SCHED_REORDER2\n+\t  /* Sort the ready list based on priority.  */\n+\t  if (ready.n_ready > 0)\n+\t    ready_sort (&ready);\n+\t  MD_SCHED_REORDER2 (sched_dump, sched_verbose,\n+\t\t\t     ready.n_ready ? ready_lastpos (&ready) : NULL,\n+\t\t\t     ready.n_ready, clock_var, can_issue_more);\n+#endif\n \t}\n \n       /* Debug info.  */\n       if (sched_verbose)\n \tvisualize_scheduled_insns (clock_var);\n     }\n \n+#ifdef MD_SCHED_FINISH\n+  MD_SCHED_FINISH (sched_dump, sched_verbose);\n+#endif\n+\n   /* Debug info.  */\n   if (sched_verbose)\n     {\n@@ -1833,17 +1847,14 @@ schedule_block (b, rgn_n_insns)\n /* Set_priorities: compute priority of each insn in the block.  */\n \n int\n-set_priorities (b)\n-     int b;\n+set_priorities (head, tail)\n+     rtx head, tail;\n {\n   rtx insn;\n   int n_insn;\n \n-  rtx tail;\n   rtx prev_head;\n-  rtx head;\n \n-  get_block_head_tail (b, &head, &tail);\n   prev_head = PREV_INSN (head);\n \n   if (head == tail && (! INSN_P (head)))\n@@ -1936,12 +1947,23 @@ sched_init (dump_file)\n          determine the correct line number for the first insn of the block.  */\n \n       for (b = 0; b < n_basic_blocks; b++)\n-\tfor (line = BLOCK_HEAD (b); line; line = PREV_INSN (line))\n-\t  if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n+\t{\n+\t  for (line = BLOCK_HEAD (b); line; line = PREV_INSN (line))\n+\t    if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n+\t      {\n+\t\tline_note_head[b] = line;\n+\t\tbreak;\n+\t      }\n+\t  /* Do a forward search as well, since we won't get to see the first\n+\t     notes in a basic block.  */\n+\t  for (line = BLOCK_HEAD (b); line; line = NEXT_INSN (line))\n \t    {\n-\t      line_note_head[b] = line;\n-\t      break;\n+\t      if (INSN_P (line))\n+\t\tbreak;\n+\t      if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n+\t\tline_note_head[b] = line;\n \t    }\n+\t}\n     }\n \n   /* Find units used in this fuction, for visualization.  */"}, {"sha": "5ab116acb7dcd4032fc7a421f6a3e3658d2a53cf", "filename": "gcc/md.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -2858,6 +2858,14 @@ A typical @code{conditional_trap} pattern looks like\n   \"@dots{}\")\n @end smallexample\n \n+@cindex @code{cycle_display} instruction pattern\n+@item @samp{cycle_display}\n+\n+This pattern, if present, will be emitted by the instruction scheduler at\n+the beginning of each new clock cycle.  This can be used for annotating the\n+assembler output with cycle counts.  Operand 0 is a @code{const_int} that\n+holds the clock cycle.\n+\n @end table\n \n @node Pattern Ordering"}, {"sha": "b5f73288997d8c0b80654fcda211b9ce4952fba5", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -1327,6 +1327,9 @@ free_deps (deps)\n       if (deps->reg_last_uses[i])\n \tfree_INSN_LIST_list (&deps->reg_last_uses[i]);\n     }\n+  free (deps->reg_last_clobbers);\n+  free (deps->reg_last_sets);\n+  free (deps->reg_last_uses);\n }\n \n /* If it is profitable to use them, initialize caches for tracking"}, {"sha": "ffa23a157a89a09f41da3cdf54db887f08549eb4", "filename": "gcc/sched-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -252,14 +252,14 @@ extern void free_dependency_caches PARAMS ((void));\n extern void get_block_head_tail PARAMS ((int, rtx *, rtx *));\n extern int no_real_insns_p PARAMS ((rtx, rtx));\n \n-extern void rm_line_notes PARAMS ((int));\n-extern void save_line_notes PARAMS ((int));\n-extern void restore_line_notes PARAMS ((int));\n+extern void rm_line_notes PARAMS ((rtx, rtx));\n+extern void save_line_notes PARAMS ((int, rtx, rtx));\n+extern void restore_line_notes PARAMS ((int, rtx, rtx));\n extern void rm_redundant_line_notes PARAMS ((void));\n extern void rm_other_notes PARAMS ((rtx, rtx));\n \n extern int insn_issue_delay PARAMS ((rtx));\n-extern int set_priorities PARAMS ((int));\n+extern int set_priorities PARAMS ((rtx, rtx));\n \n extern void schedule_block PARAMS ((int, int));\n extern void sched_init PARAMS ((FILE *));"}, {"sha": "9e1bfd920728b2601226071dd42e02d3f89c63f4", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -2032,6 +2032,8 @@ static int sched_target_n_insns;\n static int target_n_insns;\n /* The number of insns from the entire region scheduled so far.  */\n static int sched_n_insns;\n+/* Nonzero if the last scheduled insn was a jump.  */\n+static int last_was_jump;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n static void init_ready_list PARAMS ((struct ready_list *));\n@@ -2046,7 +2048,7 @@ static int rgn_rank PARAMS ((rtx, rtx));\n static int\n schedule_more_p ()\n {\n-  return sched_target_n_insns < target_n_insns;\n+  return ! last_was_jump && sched_target_n_insns < target_n_insns;\n }\n \n /* Add all insns that are initially ready to the ready list READY.  Called\n@@ -2064,6 +2066,7 @@ init_ready_list (ready)\n   target_n_insns = 0;\n   sched_target_n_insns = 0;\n   sched_n_insns = 0;\n+  last_was_jump = 0;\n \n   /* Print debugging information.  */\n   if (sched_verbose >= 5)\n@@ -2155,6 +2158,9 @@ static int\n can_schedule_ready_p (insn)\n      rtx insn;\n {\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    last_was_jump = 1;\n+\n   /* An interblock motion?  */\n   if (INSN_BB (insn) != target_bb)\n     {\n@@ -2589,10 +2595,9 @@ compute_block_backward_dependences (bb)\n   /* Free up the INSN_LISTs.  */\n   free_deps (&tmp_deps);\n \n-  /* Assert that we won't need bb_reg_last_* for this block anymore.  */\n-  free (bb_deps[bb].reg_last_uses);\n-  free (bb_deps[bb].reg_last_sets);\n-  free (bb_deps[bb].reg_last_clobbers);\n+  /* Assert that we won't need bb_reg_last_* for this block anymore.  \n+     The vectors we're zeroing out have just been freed by the call to\n+     free_deps.  */\n   bb_deps[bb].reg_last_uses = 0;\n   bb_deps[bb].reg_last_sets = 0;\n   bb_deps[bb].reg_last_clobbers = 0;\n@@ -2726,7 +2731,12 @@ schedule_region (rgn)\n \n   /* Set priorities.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n-    rgn_n_insns += set_priorities (BB_TO_BLOCK (bb));\n+    {\n+      rtx head, tail;\n+      get_block_head_tail (BB_TO_BLOCK (bb), &head, &tail);\n+\n+      rgn_n_insns += set_priorities (head, tail);\n+    }\n \n   /* Compute interblock info: probabilities, split-edges, dominators, etc.  */\n   if (current_nr_blocks > 1)\n@@ -2788,8 +2798,8 @@ schedule_region (rgn)\n \n       if (write_symbols != NO_DEBUG)\n \t{\n-\t  save_line_notes (b);\n-\t  rm_line_notes (b);\n+\t  save_line_notes (b, head, tail);\n+\t  rm_line_notes (head, tail);\n \t}\n \n       /* rm_other_notes only removes notes which are _inside_ the\n@@ -2855,7 +2865,11 @@ schedule_region (rgn)\n   if (write_symbols != NO_DEBUG)\n     {\n       for (bb = 0; bb < current_nr_blocks; bb++)\n-\trestore_line_notes (BB_TO_BLOCK (bb));\n+\t{\n+\t  rtx head, tail;\n+\t  get_block_head_tail (BB_TO_BLOCK (bb), &head, &tail);\n+\t  restore_line_notes (BB_TO_BLOCK (bb), head, tail);\n+\t}\n     }\n \n   /* Done with this region.  */"}, {"sha": "85923e617005dc2bde75cbe79ad8e525a3a18541", "filename": "gcc/tm.texi", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c2ffde686279bf867bc890584da1990a42899e/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=79c2ffde686279bf867bc890584da1990a42899e", "patch": "@@ -8134,11 +8134,22 @@ A C expression that returns how many instructions can be issued at the\n same time if the machine is a superscalar machine.\n \n @findex MD_SCHED_INIT\n-@item MD_SCHED_INIT (@var{file}, @var{verbose})\n+@item MD_SCHED_INIT (@var{file}, @var{verbose}, @var{max_ready})\n A C statement which is executed by the scheduler at the\n beginning of each block of instructions that are to be scheduled.\n @var{file} is either a null pointer, or a stdio stream to write any\n debug output to.  @var{verbose} is the verbose level provided by\n+@samp{-fsched-verbose-}@var{n}.  @var{max_ready} is the maximum number\n+of insns in the current scheduling region that can be live at the same\n+time.  This can be used to allocate scratch space if it is needed.\n+\n+@findex MD_SCHED_FINISH\n+@item MD_SCHED_FINISH (@var{file}, @var{verbose})\n+A C statement which is executed by the scheduler at the end of each block\n+of instructions that are to be scheduled.  It can be used to perform\n+cleanup of any actions done by the other scheduling macros.\n+@var{file} is either a null pointer, or a stdio stream to write any\n+debug output to.  @var{verbose} is the verbose level provided by\n @samp{-fsched-verbose-}@var{n}.\n \n @findex MD_SCHED_REORDER\n@@ -8155,7 +8166,18 @@ scheduler reads the ready list in reverse order, starting with\n @var{ready}[@var{n_ready}-1] and going to @var{ready}[0].  @var{clock}\n is the timer tick of the scheduler.  @var{can_issue_more} is an output\n parameter that is set to the number of insns that can issue this clock;\n-normally this is just @code{issue_rate}.\n+normally this is just @code{issue_rate}.  See also @samp{MD_SCHED_REORDER2}.\n+\n+@findex MD_SCHED_REORDER2\n+@item MD_SCHED_REORDER2 (@var{file}, @var{verbose}, @var{ready}, @var{n_ready}, @var{clock}, @var{can_issue_more})\n+Like @samp{MD_SCHED_REORDER}, but called at a different time.  While the\n+@samp{MD_SCHED_REORDER} macro is called whenever the scheduler starts a\n+new cycle, this macro is used immediately after @samp{MD_SCHED_VARIABLE_ISSUE}\n+is called; it can reorder the ready list and set @var{can_issue_more} to\n+determine whether there are more insns to be scheduled in the same cycle.\n+Defining this macro can be useful if there are frequent situations where\n+scheduling one insn causes other insns to become ready in the same cycle,\n+these other insns can then be taken into account properly.\n \n @findex MD_SCHED_VARIABLE_ISSUE\n @item MD_SCHED_VARIABLE_ISSUE (@var{file}, @var{verbose}, @var{insn}, @var{more})"}]}