{"sha": "8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI2M2QwZTVjODBkYWIzZTVmZTg0MGY0Y2I4M2FiMGM0OGY2YTBmYQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-08-25T08:20:11Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-08-25T08:20:11Z"}, "message": "cfglayout.c (duplicate_insn_chain): Remove references to NOTE_INSN_LOOP_VTOP and NOTE_INSN_LOOP_CONT.\n\n2004-04-25  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* cfglayout.c (duplicate_insn_chain): Remove references to\n\tNOTE_INSN_LOOP_VTOP and NOTE_INSN_LOOP_CONT.\n\t* cfgloop.h (struct loop): Remove fields vtop, cont and cont_dominator.\n\t* cfgrtl.c (rtl_delete_block): Remove handling of NOTE_INSN_LOOP_CONT.\n\t* final.c (final_scan_insn): Remove references to NOTE_INSN_LOOP_VTOP\n\tand NOTE_INSN_LOOP_CONT.\n\t* insn-notes.def (NOTE_INSN_LOOP_VTOP, NOTE_INSN_LOOP_CONT): Remove.\n\t* jump.c (squeeze_notes): Remove references to NOTE_INSN_LOOP_VTOP\n\tand NOTE_INSN_LOOP_CONT.\n\t* loop.c (scan_loops, find_and_verify_loops, for_each_insn_in_loop,\n\tcheck_dbra_loop, loop_dump_aux): Remove references to removed notes\n\tand fields.\n\t* reorg.c (mostly_true_jump): Do not rely on NOTE_INSN_LOOP_VTOPs.\n\t* unroll.c (unroll_loop, copy_loop_body, loop_iterations): Remove\n\treferences to removed notes and fields.\n\t(subtract_reg_term, ujump_to_loop_cont): Remove.\n\nFrom-SVN: r86542", "tree": {"sha": "cd53bb99b549809d25953645bf0429fe0398dd19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd53bb99b549809d25953645bf0429fe0398dd19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "078e3ffed87d834eef232a5b1a0dd0a4c21ef60e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078e3ffed87d834eef232a5b1a0dd0a4c21ef60e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078e3ffed87d834eef232a5b1a0dd0a4c21ef60e"}], "stats": {"total": 357, "additions": 32, "deletions": 325}, "files": [{"sha": "1c2abb09d3b1def1aff4749b4ce1ee7d1eb016f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -1,6 +1,25 @@\n+2004-04-25  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* cfglayout.c (duplicate_insn_chain): Remove references to\n+\tNOTE_INSN_LOOP_VTOP and NOTE_INSN_LOOP_CONT.\n+\t* cfgloop.h (struct loop): Remove fields vtop, cont and cont_dominator.\n+\t* cfgrtl.c (rtl_delete_block): Remove handling of NOTE_INSN_LOOP_CONT.\n+\t* final.c (final_scan_insn): Remove references to NOTE_INSN_LOOP_VTOP\n+\tand NOTE_INSN_LOOP_CONT.\n+\t* insn-notes.def (NOTE_INSN_LOOP_VTOP, NOTE_INSN_LOOP_CONT): Remove.\n+\t* jump.c (squeeze_notes): Remove references to NOTE_INSN_LOOP_VTOP\n+\tand NOTE_INSN_LOOP_CONT.\n+\t* loop.c (scan_loops, find_and_verify_loops, for_each_insn_in_loop,\n+\tcheck_dbra_loop, loop_dump_aux): Remove references to removed notes\n+\tand fields.\n+\t* reorg.c (mostly_true_jump): Do not rely on NOTE_INSN_LOOP_VTOPs.\n+\t* unroll.c (unroll_loop, copy_loop_body, loop_iterations): Remove\n+\treferences to removed notes and fields.\n+\t(subtract_reg_term, ujump_to_loop_cont): Remove.\n+\n 2004-08-25  Paolo Bonzini  <bonzini@gnu.org>\n \n-\t* doc/invoke.texi: Document that libcpp does not require\n+\t* doc/install.texi: Document that libcpp does not require\n \tAutomake any longer.  Document that Automake 1.9.1 should\n \twork everywhere.\n "}, {"sha": "397180633bc4bf59c534f559152e20abe66e5b2d", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -1039,8 +1039,6 @@ duplicate_insn_chain (rtx from, rtx to)\n \t         in first BB, we may want to copy the block.  */\n \t    case NOTE_INSN_PROLOGUE_END:\n \n-\t    case NOTE_INSN_LOOP_VTOP:\n-\t    case NOTE_INSN_LOOP_CONT:\n \t    case NOTE_INSN_LOOP_BEG:\n \t    case NOTE_INSN_LOOP_END:\n \t      /* Strip down the loop notes - we don't really want to keep"}, {"sha": "3dce20a481c1e7e404af5e65fcf68a7fda11135c", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -135,16 +135,6 @@ struct loop\n   /* The following are currently used by loop.c but they are likely to\n      disappear as loop.c is converted to use the CFG.  */\n \n-  /* Nonzero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n-  rtx vtop;\n-\n-  /* Nonzero if the loop has a NOTE_INSN_LOOP_CONT.\n-     A continue statement will generate a branch to NEXT_INSN (cont).  */\n-  rtx cont;\n-\n-  /* The dominator of cont.  */\n-  rtx cont_dominator;\n-\n   /* The NOTE_INSN_LOOP_BEG.  */\n   rtx start;\n "}, {"sha": "c4cb01214e48b490ae588737b81e56bd4b884dd8", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -376,16 +376,6 @@ rtl_delete_block (basic_block b)\n      and remove the associated NOTE_INSN_EH_REGION_BEG and\n      NOTE_INSN_EH_REGION_END notes.  */\n \n-  /* Get rid of all NOTE_INSN_LOOP_CONTs hanging before the block.  */\n-\n-  for (insn = PREV_INSN (BB_HEAD (b)); insn; insn = PREV_INSN (insn))\n-    {\n-      if (!NOTE_P (insn))\n-\tbreak;\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT)\n-\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-    }\n-\n   insn = BB_HEAD (b);\n \n   if (LABEL_P (insn))"}, {"sha": "fe4eaa67371599306eabd7caf62318b3bba2766e", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -1699,8 +1699,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tcase NOTE_INSN_DELETED:\n \tcase NOTE_INSN_LOOP_BEG:\n \tcase NOTE_INSN_LOOP_END:\n-\tcase NOTE_INSN_LOOP_CONT:\n-\tcase NOTE_INSN_LOOP_VTOP:\n \tcase NOTE_INSN_FUNCTION_END:\n \tcase NOTE_INSN_REPEATED_LINE_NUMBER:\n \tcase NOTE_INSN_EXPECTED_VALUE:"}, {"sha": "95712053c41080ff9e124d4a0d42ebc687926dc7", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -47,11 +47,6 @@ INSN_NOTE (BLOCK_END)\n INSN_NOTE (LOOP_BEG)\n INSN_NOTE (LOOP_END)\n \n-/* Generated at the place in a loop that `continue' jumps to.  */\n-INSN_NOTE (LOOP_CONT)\n-/* Generated at the start of a duplicated exit test.  */\n-INSN_NOTE (LOOP_VTOP)\n-\n /* This note indicates the start of the real body of the function,\n    i.e. the point just after all of the parms have been moved into\n    their homes, etc.  */"}, {"sha": "b84841c1754daa767795b03e029ac8ee91076455", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -246,9 +246,7 @@ squeeze_notes (rtx* startp, rtx* endp)\n \t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP))\n+\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END))\n \t{\n \t  if (insn == start)\n \t    start = next;"}, {"sha": "f28d890f8b9040674f215fffc91a3c423c44e3c1", "filename": "gcc/loop.c", "status": "modified", "additions": 7, "deletions": 84, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -644,8 +644,6 @@ scan_loop (struct loop *loop, int flags)\n      since in that case saving an insn makes more difference\n      and more registers are available.  */\n   int threshold;\n-  /* Nonzero if we are scanning instructions in a sub-loop.  */\n-  int loop_depth = 0;\n   int in_libcall;\n \n   loop->top = 0;\n@@ -738,13 +736,8 @@ scan_loop (struct loop *loop, int flags)\n   insn_count = count_insns_in_loop (loop);\n \n   if (loop_dump_stream)\n-    {\n-      fprintf (loop_dump_stream, \"\\nLoop from %d to %d: %d real insns.\\n\",\n-\t       INSN_UID (loop_start), INSN_UID (loop_end), insn_count);\n-      if (loop->cont)\n-\tfprintf (loop_dump_stream, \"Continue at insn %d.\\n\",\n-\t\t INSN_UID (loop->cont));\n-    }\n+    fprintf (loop_dump_stream, \"\\nLoop from %d to %d: %d real insns.\\n\",\n+\t     INSN_UID (loop_start), INSN_UID (loop_end), insn_count);\n \n   /* Scan through the loop finding insns that are safe to move.\n      Set REGS->ARRAY[I].SET_IN_LOOP negative for the reg I being set, so that\n@@ -1120,18 +1113,6 @@ scan_loop (struct loop *loop, int flags)\n \t\t     && NEXT_INSN (NEXT_INSN (p)) == loop_end\n \t\t     && any_uncondjump_p (p)))\n \tmaybe_never = 1;\n-      else if (NOTE_P (p))\n-\t{\n-\t  /* At the virtual top of a converted loop, insns are again known to\n-\t     be executed: logically, the loop begins here even though the exit\n-\t     code has been duplicated.  */\n-\t  if (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_VTOP && loop_depth == 0)\n-\t    maybe_never = call_passed = 0;\n-\t  else if (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG)\n-\t    loop_depth++;\n-\t  else if (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)\n-\t    loop_depth--;\n-\t}\n     }\n \n   /* If one movable subsumes another, ignore that other.  */\n@@ -2501,7 +2482,7 @@ count_nonfixed_reads (const struct loop *loop, rtx x)\n   return value;\n }\n \f\n-/* Scan a loop setting the elements `cont', `vtop', `loops_enclosed',\n+/* Scan a loop setting the elements `loops_enclosed',\n    `has_call', `has_nonconst_call', `has_volatile', `has_tablejump',\n    `unknown_address_altered', `unknown_constant_address_altered', and\n    `num_mem_sets' in LOOP.  Also, fill in the array `mems' and the\n@@ -2741,14 +2722,6 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t    current_loop = next_loop;\n \t    break;\n \n-\t  case NOTE_INSN_LOOP_CONT:\n-\t    current_loop->cont = insn;\n-\t    break;\n-\n-\t  case NOTE_INSN_LOOP_VTOP:\n-\t    current_loop->vtop = insn;\n-\t    break;\n-\n \t  case NOTE_INSN_LOOP_END:\n \t    if (! current_loop)\n \t      abort ();\n@@ -4276,7 +4249,6 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n   int not_every_iteration = 0;\n   int maybe_multiple = 0;\n   int past_loop_latch = 0;\n-  int loop_depth = 0;\n   rtx p;\n \n   /* If loop_scan_start points to the loop exit test, we have to be wary of\n@@ -4359,24 +4331,6 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n \t    not_every_iteration = 1;\n \t}\n \n-      else if (NOTE_P (p))\n-\t{\n-\t  /* At the virtual top of a converted loop, insns are again known to\n-\t     be executed each iteration: logically, the loop begins here\n-\t     even though the exit code has been duplicated.\n-\n-\t     Insns are also again known to be executed each iteration at\n-\t     the LOOP_CONT note.  */\n-\t  if ((NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_VTOP\n-\t       || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_CONT)\n-\t      && loop_depth == 0)\n-\t    not_every_iteration = 0;\n-\t  else if (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG)\n-\t    loop_depth++;\n-\t  else if (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)\n-\t    loop_depth--;\n-\t}\n-\n       /* Note if we pass a loop latch.  If we do, then we can not clear\n          NOT_EVERY_ITERATION below when we pass the last CODE_LABEL in\n          a loop since a jump before the last CODE_LABEL may have started\n@@ -4402,8 +4356,7 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n       if (not_every_iteration\n \t  && !past_loop_latch\n \t  && LABEL_P (p)\n-\t  && no_labels_between_p (p, loop->end)\n-\t  && loop_insn_first_p (p, loop->cont))\n+\t  && no_labels_between_p (p, loop->end))\n \tnot_every_iteration = 0;\n     }\n }\n@@ -7990,8 +7943,8 @@ check_dbra_loop (struct loop *loop, int insn_count)\n        sequence and see if we've got another comparison sequence.  */\n \n     rtx jump1;\n-    if ((jump1 = prev_nonnote_insn (first_compare)) != loop->cont)\n-      if (JUMP_P (jump1))\n+    if ((jump1 = prev_nonnote_insn (first_compare))\n+\t&& JUMP_P (jump1))\n \treturn 0;\n   }\n \n@@ -8304,17 +8257,6 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \n \t      /* First check if we can do a vanilla loop reversal.  */\n \t      if (initial_value == const0_rtx\n-\t\t  /* If we have a decrement_and_branch_on_count,\n-\t\t     prefer the NE test, since this will allow that\n-\t\t     instruction to be generated.  Note that we must\n-\t\t     use a vanilla loop reversal if the biv is used to\n-\t\t     calculate a giv or has a non-counting use.  */\n-#if ! defined (HAVE_decrement_and_branch_until_zero) \\\n-&& defined (HAVE_decrement_and_branch_on_count)\n-\t\t  && (! (add_val == 1 && loop->vtop\n-\t\t         && (bl->biv_count == 0\n-\t\t\t     || no_use_except_counting)))\n-#endif\n \t\t  && GET_CODE (comparison_value) == CONST_INT\n \t\t     /* Now do postponed overflow checks on COMPARISON_VAL.  */\n \t\t  && ! (((comparison_val - add_val) ^ INTVAL (comparison_value))\n@@ -8326,13 +8268,6 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \t\t  nonneg = 1;\n \t\t  cmp_code = GE;\n \t\t}\n-\t      else if (add_val == 1 && loop->vtop\n-\t\t       && (bl->biv_count == 0\n-\t\t\t   || no_use_except_counting))\n-\t\t{\n-\t\t  add_adjust = 0;\n-\t\t  cmp_code = NE;\n-\t\t}\n \t      else\n \t\treturn 0;\n \n@@ -10731,15 +10666,9 @@ loop_dump_aux (const struct loop *loop, FILE *file,\n   if (loop->start)\n     {\n       fprintf (file,\n-\t       \";;  start %d (%d), cont dom %d (%d), cont %d (%d), vtop %d (%d), end %d (%d)\\n\",\n+\t       \";;  start %d (%d), end %d (%d)\\n\",\n \t       LOOP_BLOCK_NUM (loop->start),\n \t       LOOP_INSN_UID (loop->start),\n-\t       LOOP_BLOCK_NUM (loop->cont),\n-\t       LOOP_INSN_UID (loop->cont),\n-\t       LOOP_BLOCK_NUM (loop->cont),\n-\t       LOOP_INSN_UID (loop->cont),\n-\t       LOOP_BLOCK_NUM (loop->vtop),\n-\t       LOOP_INSN_UID (loop->vtop),\n \t       LOOP_BLOCK_NUM (loop->end),\n \t       LOOP_INSN_UID (loop->end));\n       fprintf (file, \";;  top %d (%d), scan start %d (%d)\\n\",\n@@ -10758,12 +10687,6 @@ loop_dump_aux (const struct loop *loop, FILE *file,\n \t    }\n \t}\n       fputs (\"\\n\", file);\n-\n-      /* This can happen when a marked loop appears as two nested loops,\n-\t say from while (a || b) {}.  The inner loop won't match\n-\t the loop markers but the outer one will.  */\n-      if (LOOP_BLOCK_NUM (loop->cont) != loop->latch->index)\n-\tfprintf (file, \";;  NOTE_INSN_LOOP_CONT not in loop latch\\n\");\n     }\n }\n "}, {"sha": "d464a3239583468d513f0a56d9b280b447b70f3f", "filename": "gcc/reorg.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -999,16 +999,6 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n \t   insn = PREV_INSN (insn))\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \t  return 2;\n-\n-      /* If this is a jump to the test of a loop, it is likely true.  We scan\n-\t forwards from the target label.  If we find a NOTE_INSN_LOOP_VTOP\n-\t before the next real insn, we assume the branch is to the loop branch\n-\t test.  */\n-      for (insn = NEXT_INSN (target_label);\n-\t   insn && NOTE_P (insn);\n-\t   insn = PREV_INSN (insn))\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP)\n-\t  return 1;\n     }\n \n   /* Look at the relative rarities of the fallthrough and destination.  If"}, {"sha": "cef4c6ecca34fe7fa08728a4b471a0ce4e509544", "filename": "gcc/unroll.c", "status": "modified", "additions": 4, "deletions": 198, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=8b63d0e5c80dab3e5fe840f4cb83ab0c48f6a0fa", "patch": "@@ -214,9 +214,7 @@ static int reg_dead_after_loop (const struct loop *, rtx);\n static rtx fold_rtx_mult_add (rtx, rtx, rtx, enum machine_mode);\n static rtx remap_split_bivs (struct loop *, rtx);\n static rtx find_common_reg_term (rtx, rtx);\n-static rtx subtract_reg_term (rtx, rtx);\n static rtx loop_find_equiv_value (const struct loop *, rtx);\n-static rtx ujump_to_loop_cont (rtx, rtx);\n \n /* Try to unroll one loop and split induction variables in the loop.\n \n@@ -297,16 +295,6 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t jump to the loop condition.  Make sure to delete the jump\n \t insn, otherwise the loop body will never execute.  */\n \n-      /* FIXME this actually checks for a jump to the continue point, which\n-\t is not the same as the condition in a for loop.  As a result, this\n-\t optimization fails for most for loops.  We should really use flow\n-\t information rather than instruction pattern matching.  */\n-      rtx ujump = ujump_to_loop_cont (loop->start, loop->cont);\n-\n-      /* If number of iterations is exactly 1, then eliminate the compare and\n-\t branch at the end of the loop since they will never be taken.\n-\t Then return, since no other action is needed here.  */\n-\n       /* If the last instruction is not a BARRIER or a JUMP_INSN, then\n \t don't do anything.  */\n \n@@ -315,34 +303,6 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t  /* Delete the jump insn.  This will delete the barrier also.  */\n \t  last_loop_insn = PREV_INSN (last_loop_insn);\n \t}\n-\n-      if (ujump && JUMP_P (last_loop_insn))\n-\t{\n-#ifdef HAVE_cc0\n-\t  rtx prev = PREV_INSN (last_loop_insn);\n-#endif\n-\t  delete_related_insns (last_loop_insn);\n-#ifdef HAVE_cc0\n-\t  /* The immediately preceding insn may be a compare which must be\n-\t     deleted.  */\n-\t  if (only_sets_cc0_p (prev))\n-\t    delete_related_insns (prev);\n-#endif\n-\n-\t  delete_related_insns (ujump);\n-\n-\t  /* Remove the loop notes since this is no longer a loop.  */\n-\t  if (loop->vtop)\n-\t    delete_related_insns (loop->vtop);\n-\t  if (loop->cont)\n-\t    delete_related_insns (loop->cont);\n-\t  if (loop_start)\n-\t    delete_related_insns (loop_start);\n-\t  if (loop_end)\n-\t    delete_related_insns (loop_end);\n-\n-\t  return;\n-\t}\n     }\n \n   if (loop_info->n_iterations > 0\n@@ -1296,10 +1256,6 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n   if (unroll_type == UNROLL_COMPLETELY)\n     {\n       /* Remove the loop notes since this is no longer a loop.  */\n-      if (loop->vtop)\n-\tdelete_related_insns (loop->vtop);\n-      if (loop->cont)\n-\tdelete_related_insns (loop->cont);\n       if (loop_start)\n \tdelete_related_insns (loop_start);\n       if (loop_end)\n@@ -2221,19 +2177,13 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n \t  break;\n \n \tcase NOTE:\n-\t  /* VTOP and CONT notes are valid only before the loop exit test.\n-\t     If placed anywhere else, loop may generate bad code.  */\n \t  /* BASIC_BLOCK notes exist to stabilize basic block structures with\n \t     the associated rtl.  We do not want to share the structure in\n \t     this new block.  */\n \n \t  if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n-\t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED_LABEL\n-\t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n-\t\t   && ((NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_VTOP\n-\t\t\t&& NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_CONT)\n-\t\t       || (last_iteration\n-\t\t\t   && unroll_type != UNROLL_COMPLETELY)))\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED_LABEL\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n \t    copy = emit_note_copy (insn);\n \t  else\n \t    copy = 0;\n@@ -2272,17 +2222,9 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n     {\n       for (insn = copy_notes_from; insn != loop_end; insn = NEXT_INSN (insn))\n \t{\n-\t  /* VTOP notes are valid only before the loop exit test.\n-\t     If placed anywhere else, loop may generate bad code.\n-\t     Although COPY_NOTES_FROM will be at most one or two (for cc0)\n-\t     instructions before the last insn in the loop, COPY_NOTES_FROM\n-\t     can be a NOTE_INSN_LOOP_CONT note if there is no VTOP note,\n-\t     as in a do .. while loop.  */\n \t  if (NOTE_P (insn)\n-\t      && ((NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n-\t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n-\t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_VTOP\n-\t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_CONT)))\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n \t    emit_note_copy (insn);\n \t}\n     }\n@@ -3177,32 +3119,6 @@ loop_find_equiv_value (const struct loop *loop, rtx reg)\n   return ret;\n }\n \n-/* Return a simplified rtx for the expression OP - REG.\n-\n-   REG must appear in OP, and OP must be a register or the sum of a register\n-   and a second term.\n-\n-   Thus, the return value must be const0_rtx or the second term.\n-\n-   The caller is responsible for verifying that REG appears in OP and OP has\n-   the proper form.  */\n-\n-static rtx\n-subtract_reg_term (rtx op, rtx reg)\n-{\n-  if (op == reg)\n-    return const0_rtx;\n-  if (GET_CODE (op) == PLUS)\n-    {\n-      if (XEXP (op, 0) == reg)\n-\treturn XEXP (op, 1);\n-      else if (XEXP (op, 1) == reg)\n-\treturn XEXP (op, 0);\n-    }\n-  /* OP does not contain REG as a term.  */\n-  abort ();\n-}\n-\n /* Find and return register term common to both expressions OP0 and\n    OP1 or NULL_RTX if no such term exists.  Each expression must be a\n    REG or a PLUS of a REG.  */\n@@ -3258,7 +3174,6 @@ loop_iterations (struct loop *loop)\n   int increment_dir;\n   int unsigned_p, compare_dir, final_larger;\n   rtx last_loop_insn;\n-  rtx reg_term;\n   struct iv_class *bl;\n \n   loop_info->n_iterations = 0;\n@@ -3299,44 +3214,6 @@ loop_iterations (struct loop *loop)\n       return 0;\n     }\n \n-  /* If there are multiple conditionalized loop exit tests, they may jump\n-     back to differing CODE_LABELs.  */\n-  if (loop->top && loop->cont)\n-    {\n-      rtx temp = PREV_INSN (last_loop_insn);\n-\n-      do\n-\t{\n-\t  if (JUMP_P (temp))\n-\t    {\n-\t      /* There are some kinds of jumps we can't deal with easily.  */\n-\t      if (JUMP_LABEL (temp) == 0)\n-\t\t{\n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf\n-\t\t      (loop_dump_stream,\n-\t\t       \"Loop iterations: Jump insn has null JUMP_LABEL.\\n\");\n-\t\t  return 0;\n-\t\t}\n-\n-\t      if (/* Previous unrolling may have generated new insns not\n-\t\t     covered by the uid_luid array.  */\n-\t\t  INSN_UID (JUMP_LABEL (temp)) < max_uid_for_loop\n-\t\t  /* Check if we jump back into the loop body.  */\n-\t\t  && INSN_LUID (JUMP_LABEL (temp)) > INSN_LUID (loop->top)\n-\t\t  && INSN_LUID (JUMP_LABEL (temp)) < INSN_LUID (loop->cont))\n-\t\t{\n-\t\t  if (loop_dump_stream)\n-\t\t    fprintf\n-\t\t      (loop_dump_stream,\n-\t\t       \"Loop iterations: Loop has multiple back edges.\\n\");\n-\t\t  return 0;\n-\t\t}\n-\t    }\n-\t}\n-      while ((temp = PREV_INSN (temp)) != loop->cont);\n-    }\n-\n   /* Find the iteration variable.  If the last insn is a conditional\n      branch, and the insn before tests a register value, make that the\n      iteration variable.  */\n@@ -3650,44 +3527,6 @@ loop_iterations (struct loop *loop)\n \t\t  ? reg1 : gen_rtx_PLUS (GET_MODE (reg1), reg1, const2);\n \t    }\n \t}\n-      else if (loop->vtop && GET_CODE (reg2) == CONST_INT)\n-\t{\n-\t  rtx temp;\n-\n-\t  /* When running the loop optimizer twice, check_dbra_loop\n-\t     further obfuscates reversible loops of the form:\n-\t     for (i = init; i < init + const; i++).  We often end up with\n-\t     final_value = 0, initial_value = temp, temp = temp2 - init,\n-\t     where temp2 = init + const.  If the loop has a vtop we\n-\t     can replace initial_value with const.  */\n-\n-\t  temp = loop_find_equiv_value (loop, reg1);\n-\n-\t  if (GET_CODE (temp) == MINUS && REG_P (XEXP (temp, 0)))\n-\t    {\n-\t      rtx temp2 = loop_find_equiv_value (loop, XEXP (temp, 0));\n-\n-\t      if (GET_CODE (temp2) == PLUS\n-\t\t  && XEXP (temp2, 0) == XEXP (temp, 1))\n-\t\tinitial_value = XEXP (temp2, 1);\n-\t    }\n-\t}\n-    }\n-\n-  /* If have initial_value = reg + const1 and final_value = reg +\n-     const2, then replace initial_value with const1 and final_value\n-     with const2.  This should be safe since we are protected by the\n-     initial comparison before entering the loop if we have a vtop.\n-     For example, a + b < a + c is not equivalent to b < c for all a\n-     when using modulo arithmetic.\n-\n-     ??? Without a vtop we could still perform the optimization if we check\n-     the initial and final values carefully.  */\n-  if (loop->vtop\n-      && (reg_term = find_common_reg_term (initial_value, final_value)))\n-    {\n-      initial_value = subtract_reg_term (initial_value, reg_term);\n-      final_value = subtract_reg_term (final_value, reg_term);\n     }\n \n   loop_info->initial_equiv_value = initial_value;\n@@ -3999,36 +3838,3 @@ set_dominates_use (int regno, int first_uid, int last_uid, rtx copy_start,\n   return 1;\n }\n \n-/* This routine is called when the number of iterations for the unrolled\n-   loop is one.   The goal is to identify a loop that begins with an\n-   unconditional branch to the loop continuation note (or a label just after).\n-   In this case, the unconditional branch that starts the loop needs to be\n-   deleted so that we execute the single iteration.  */\n-\n-static rtx\n-ujump_to_loop_cont (rtx loop_start, rtx loop_cont)\n-{\n-  rtx x, label, label_ref;\n-\n-  /* See if loop start, or the next insn is an unconditional jump.  */\n-  loop_start = next_nonnote_insn (loop_start);\n-\n-  x = pc_set (loop_start);\n-  if (!x)\n-    return NULL_RTX;\n-\n-  label_ref = SET_SRC (x);\n-  if (!label_ref)\n-    return NULL_RTX;\n-\n-  /* Examine insn after loop continuation note.  Return if not a label.  */\n-  label = next_nonnote_insn (loop_cont);\n-  if (label == 0 || !LABEL_P (label))\n-    return NULL_RTX;\n-\n-  /* Return the loop start if the branch label matches the code label.  */\n-  if (CODE_LABEL_NUMBER (label) == CODE_LABEL_NUMBER (XEXP (label_ref, 0)))\n-    return loop_start;\n-  else\n-    return NULL_RTX;\n-}"}]}