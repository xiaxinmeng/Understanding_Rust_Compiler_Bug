{"sha": "17b99c984b69b0b4927af6f81380c855c60475b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiOTljOTg0YjY5YjBiNDkyN2FmNmY4MTM4MGM4NTVjNjA0NzViNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-07-17T17:19:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-17T17:19:21Z"}, "message": "alias.c (record_component_aliases): Do not simplify pointed-to types of ODR types\n\n\t* alias.c (record_component_aliases): Do not simplify pointed-to\n\ttypes of ODR types \n\t* testsuite/g++.dg/lto/alias-4_0.C\n\nFrom-SVN: r273552", "tree": {"sha": "b140eaf828f28635be4c93f04ac03ebcfd6395e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b140eaf828f28635be4c93f04ac03ebcfd6395e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17b99c984b69b0b4927af6f81380c855c60475b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b99c984b69b0b4927af6f81380c855c60475b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17b99c984b69b0b4927af6f81380c855c60475b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b99c984b69b0b4927af6f81380c855c60475b7/comments", "author": null, "committer": null, "parents": [{"sha": "a7dbb77712c20e1e04186d68377875a428b635f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7dbb77712c20e1e04186d68377875a428b635f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7dbb77712c20e1e04186d68377875a428b635f5"}], "stats": {"total": 127, "additions": 86, "deletions": 41}, "files": [{"sha": "26c647f3f46e02a3b5c09d19996e8efdf2789e47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17b99c984b69b0b4927af6f81380c855c60475b7", "patch": "@@ -1,3 +1,8 @@\n+2019-07-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* alias.c (record_component_aliases): Do not simplify pointed-to\n+\ttypes of ODR types \n+\n 2019-07-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*andqi_2_maybe_si): Handle potential"}, {"sha": "2755df729070a8b90743f1a4ae74d86b3cc76cc1", "filename": "gcc/alias.c", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=17b99c984b69b0b4927af6f81380c855c60475b7", "patch": "@@ -1202,47 +1202,52 @@ record_component_aliases (tree type)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      for (field = TYPE_FIELDS (type); field != 0; field = DECL_CHAIN (field))\n-\tif (TREE_CODE (field) == FIELD_DECL && !DECL_NONADDRESSABLE_P (field))\n-\t  {\n-\t    /* LTO type merging does not make any difference between \n-\t       component pointer types.  We may have\n-\n-\t       struct foo {int *a;};\n-\n-\t       as TYPE_CANONICAL of \n-\n-\t       struct bar {float *a;};\n-\n-\t       Because accesses to int * and float * do not alias, we would get\n-\t       false negative when accessing the same memory location by\n-\t       float ** and bar *. We thus record the canonical type as:\n-\n-\t       struct {void *a;};\n-\n-\t       void * is special cased and works as a universal pointer type.\n-\t       Accesses to it conflicts with accesses to any other pointer\n-\t       type.  */\n-\t    tree t = TREE_TYPE (field);\n-\t    if (in_lto_p)\n-\t      {\n-\t\t/* VECTOR_TYPE and ARRAY_TYPE share the alias set with their\n-\t\t   element type and that type has to be normalized to void *,\n-\t\t   too, in the case it is a pointer. */\n-\t\twhile (!canonical_type_used_p (t) && !POINTER_TYPE_P (t))\n-\t\t  {\n-\t\t    gcc_checking_assert (TYPE_STRUCTURAL_EQUALITY_P (t));\n-\t\t    t = TREE_TYPE (t);\n-\t\t  }\n-\t\tif (POINTER_TYPE_P (t))\n-\t\t  t = ptr_type_node;\n-\t\telse if (flag_checking)\n-\t\t  gcc_checking_assert (get_alias_set (t)\n-\t\t\t\t       == get_alias_set (TREE_TYPE (field)));\n-\t      }\n-\n-\t    record_alias_subset (superset, get_alias_set (t));\n-\t  }\n+      {\n+\t/* LTO non-ODR type merging does not make any difference between \n+\t   component pointer types.  We may have\n+\n+\t   struct foo {int *a;};\n+\n+\t   as TYPE_CANONICAL of \n+\n+\t   struct bar {float *a;};\n+\n+\t   Because accesses to int * and float * do not alias, we would get\n+\t   false negative when accessing the same memory location by\n+\t   float ** and bar *. We thus record the canonical type as:\n+\n+\t   struct {void *a;};\n+\n+\t   void * is special cased and works as a universal pointer type.\n+\t   Accesses to it conflicts with accesses to any other pointer\n+\t   type.  */\n+\tbool void_pointers = in_lto_p\n+\t\t\t     && (!odr_type_p (type)\n+\t\t\t\t || !odr_based_tbaa_p (type));\n+\tfor (field = TYPE_FIELDS (type); field != 0; field = DECL_CHAIN (field))\n+\t  if (TREE_CODE (field) == FIELD_DECL && !DECL_NONADDRESSABLE_P (field))\n+\t    {\n+\t      tree t = TREE_TYPE (field);\n+\t      if (void_pointers)\n+\t\t{\n+\t\t  /* VECTOR_TYPE and ARRAY_TYPE share the alias set with their\n+\t\t     element type and that type has to be normalized to void *,\n+\t\t     too, in the case it is a pointer. */\n+\t\t  while (!canonical_type_used_p (t) && !POINTER_TYPE_P (t))\n+\t\t    {\n+\t\t      gcc_checking_assert (TYPE_STRUCTURAL_EQUALITY_P (t));\n+\t\t      t = TREE_TYPE (t);\n+\t\t    }\n+\t\t  if (POINTER_TYPE_P (t))\n+\t\t    t = ptr_type_node;\n+\t\t  else if (flag_checking)\n+\t\t    gcc_checking_assert (get_alias_set (t)\n+\t\t\t\t\t == get_alias_set (TREE_TYPE (field)));\n+\t\t}\n+\n+\t      record_alias_subset (superset, get_alias_set (t));\n+\t    }\n+      }\n       break;\n \n     case COMPLEX_TYPE:"}, {"sha": "d3d710796b8ff7590ece5c979469e3d2deab7125", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17b99c984b69b0b4927af6f81380c855c60475b7", "patch": "@@ -1,3 +1,7 @@\n+2019-07-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/lto/alias-4_0.C\n+\n 2019-07-17  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91178"}, {"sha": "410c3140bafb1223105da57e4d786364c167d072", "filename": "gcc/testsuite/g++.dg/lto/alias-4_0.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-4_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b99c984b69b0b4927af6f81380c855c60475b7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-4_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-4_0.C?ref=17b99c984b69b0b4927af6f81380c855c60475b7", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options { { -O3 -flto -fno-early-inlining } } } */\n+__attribute__ ((used))\n+short *ptr_init, **ptr=&ptr_init;\n+\n+__attribute__ ((used))\n+struct a {\n+  int *aptr;\n+} a, *aptr=&a;\n+\n+void\n+write_ptr ()\n+{\n+  *aptr = a;\n+}\n+\n+__attribute__ ((used))\n+void\n+test ()\n+{\n+  *ptr = (short int *)0;\n+  write_ptr ();\n+  if (!__builtin_constant_p (*ptr == (void *)0))\n+    __builtin_abort ();\n+}\n+int\n+main()\n+{\n+  test ();\n+  return 0;\n+}"}]}