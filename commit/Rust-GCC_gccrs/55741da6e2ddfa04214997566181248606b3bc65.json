{"sha": "55741da6e2ddfa04214997566181248606b3bc65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU3NDFkYTZlMmRkZmEwNDIxNDk5NzU2NjE4MTI0ODYwNmIzYmM2NQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-10-15T15:50:47Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-15T15:50:47Z"}, "message": "2003-10-15  Michael Koch  <konqueror@gmx.de>\n\n\t* java/text/RuleBasedCollator.java\n\t(RuleBasedCollator): Moved around, documentation added.\n\t(compare): Documentation added.\n\t(equals): Likewise.\n\t(getCollationElementIterator): Likewise.\n\t(getCollationKey): Likewise.\n\t(getRules): Likewise.\n\t(hashCode): Likewise.\n\nFrom-SVN: r72528", "tree": {"sha": "004a4cc81b198c6328b23bf22d089710a7bae0da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/004a4cc81b198c6328b23bf22d089710a7bae0da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55741da6e2ddfa04214997566181248606b3bc65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55741da6e2ddfa04214997566181248606b3bc65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55741da6e2ddfa04214997566181248606b3bc65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55741da6e2ddfa04214997566181248606b3bc65/comments", "author": null, "committer": null, "parents": [{"sha": "4d466c425951370af00b295e164682fcd868f380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d466c425951370af00b295e164682fcd868f380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d466c425951370af00b295e164682fcd868f380"}], "stats": {"total": 325, "additions": 207, "deletions": 118}, "files": [{"sha": "5715231caf764162054db2b11b3eb354aebe71ff", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55741da6e2ddfa04214997566181248606b3bc65/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55741da6e2ddfa04214997566181248606b3bc65/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=55741da6e2ddfa04214997566181248606b3bc65", "patch": "@@ -1,3 +1,14 @@\n+2003-10-15  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/text/RuleBasedCollator.java\n+\t(RuleBasedCollator): Moved around, documentation added.\n+\t(compare): Documentation added.\n+\t(equals): Likewise.\n+\t(getCollationElementIterator): Likewise.\n+\t(getCollationKey): Likewise.\n+\t(getRules): Likewise.\n+\t(hashCode): Likewise.\n+\n 2003-10-15  Michael Koch  <konqueror@gmx.de>\n \n \t* java/text/RuleBasedCollator.java"}, {"sha": "c05b45d5049021793688c46893bf4d3005228115", "filename": "libjava/java/text/RuleBasedCollator.java", "status": "modified", "additions": 196, "deletions": 118, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55741da6e2ddfa04214997566181248606b3bc65/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55741da6e2ddfa04214997566181248606b3bc65/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java?ref=55741da6e2ddfa04214997566181248606b3bc65", "patch": "@@ -167,7 +167,139 @@ public class RuleBasedCollator extends Collator\n   // the prefix string.\n   private Hashtable prefixes;\n   \n-  public Object clone ()\n+  /**\n+   * This method initializes a new instance of <code>RuleBasedCollator</code>\n+   * with the specified collation rules.  Note that an application normally\n+   * obtains an instance of <code>RuleBasedCollator</code> by calling the\n+   * <code>getInstance</code> method of <code>Collator</code>.  That method\n+   * automatically loads the proper set of rules for the desired locale.\n+   *\n+   * @param rules The collation rule string.\n+   *\n+   * @exception ParseException If the rule string contains syntax errors.\n+   */\n+  public RuleBasedCollator (String rules) throws ParseException\n+  {\n+    this.rules = rules;\n+    this.frenchAccents = false;\n+\n+    // We keep each rule in order in a vector.  At the end we traverse\n+    // the vector and compute collation values from it.\n+    int insertion_index = 0;\n+    Vector vec = new Vector ();\n+\n+    StringBuffer argument = new StringBuffer ();\n+\n+    int len = rules.length();\n+    for (int index = 0; index < len; ++index)\n+      {\n+\tchar c = rules.charAt(index);\n+\n+\t// Just skip whitespace.\n+\tif (Character.isWhitespace(c))\n+\t  continue;\n+\n+\t// Modifier.\n+\tif (c == '@')\n+\t  {\n+\t    frenchAccents = true;\n+\t    continue;\n+\t  }\n+\n+\t// Check for relation or reset operator.\n+\tif (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))\n+\t  throw new ParseException (\"invalid character\", index);\n+\n+\t++index;\n+\twhile (index < len)\n+\t  {\n+\t    if (! Character.isWhitespace(rules.charAt(index)))\n+\t      break;\n+\t    ++index;\n+\t  }\n+\tif (index == len)\n+\t  throw new ParseException (\"missing argument\", index);\n+\n+\tint save = index;\n+\tindex = text_argument (rules, index, argument);\n+\tif (argument.length() == 0)\n+\t  throw new ParseException (\"invalid character\", save);\n+\tString arg = argument.toString();\n+\tint item_index = vec.indexOf(arg);\n+\tif (c != '&')\n+\t  {\n+\t    // If the argument already appears in the vector, then we\n+\t    // must remove it in order to re-order.\n+\t    if (item_index != -1)\n+\t      {\n+\t\tvec.removeElementAt(item_index);\n+\t\tif (insertion_index >= item_index)\n+\t\t  --insertion_index;\n+\t      }\n+\t    CollationElement r = new CollationElement (arg, c);\n+\t    vec.insertElementAt(r, insertion_index);\n+\t    ++insertion_index;\n+\t  }\n+\telse\n+\t  {\n+\t    // Reset.\n+\t    if (item_index == -1)\n+\t      throw\n+\t\tnew ParseException (\"argument to reset not previously seen\",\n+\t\t\t\t    save);\n+\t    insertion_index = item_index + 1;\n+\t  }\n+\n+\t// Ugly: in this case the resulting INDEX comes from\n+\t// text_argument, which returns the index of the next\n+\t// character we should examine.\n+\t--index;\n+      }\n+\n+    // Now construct a hash table that maps strings onto their\n+    // collation values.\n+    int primary = 0;\n+    int secondary = 0;\n+    int tertiary = 0;\n+    this.map = new Hashtable ();\n+    this.prefixes = new Hashtable ();\n+    Enumeration e = vec.elements();\n+    while (e.hasMoreElements())\n+      {\n+\tCollationElement r = (CollationElement) e.nextElement();\n+\tswitch (r.relation)\n+\t  {\n+\t  case '<':\n+\t    ++primary;\n+\t    secondary = 0;\n+\t    tertiary = 0;\n+\t    break;\n+\t  case ';':\n+\t    ++secondary;\n+\t    tertiary = 0;\n+\t    break;\n+\t  case ',':\n+\t    ++tertiary;\n+\t    break;\n+\t  case '=':\n+\t    break;\n+\t  }\n+\t// This must match CollationElementIterator.\n+\tmap.put(r.key, new Integer (primary << 16\n+\t\t\t\t    | secondary << 8 | tertiary));\n+\n+\t// Make a map of all lookaheads we might need.\n+\tfor (int i = r.key.length() - 1; i >= 1; --i)\n+\t  prefixes.put(r.key.substring(0, i), Boolean.TRUE);\n+      }\n+  }\n+\n+  /**\n+   * This method creates a copy of this object.\n+   *\n+   * @return A copy of this object.\n+   */\n+  public Object clone()\n   {\n     RuleBasedCollator c = (RuleBasedCollator) super.clone ();\n     c.map = (Hashtable) map.clone ();\n@@ -256,6 +388,18 @@ static final int next (CollationElementIterator iter, int strength)\n       }\n   }\n \n+  /**\n+   * This method returns an integer which indicates whether the first\n+   * specified <code>String</code> is less than, greater than, or equal to\n+   * the second.  The value depends not only on the collation rules in\n+   * effect, but also the strength and decomposition settings of this object.\n+   *\n+   * @param s1 The first <code>String</code> to compare.\n+   * @param s2 A second <code>String</code> to compare to the first.\n+   *\n+   * @return A negative integer if s1 &lt; s2, a positive integer\n+   * if s1 &gt; s2, or 0 if s1 == s2.\n+   */\n   public int compare (String source, String target)\n   {\n     CollationElementIterator cs, ct;\n@@ -289,6 +433,15 @@ else if (ot == CollationElementIterator.NULLORDER)\n     return 0;\n   }\n \n+  /**\n+   * This method tests this object for equality against the specified \n+   * object.  This will be true if and only if the specified object is\n+   * another reference to this object.\n+   *\n+   * @param obj The <code>Object</code> to compare against this object.\n+   *\n+   * @return <code>true</code> if the specified object is equal to this object, <code>false</code> otherwise.\n+   */\n   public boolean equals (Object obj)\n   {\n     if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))\n@@ -300,6 +453,15 @@ public boolean equals (Object obj)\n \t    && rules.equals(rbc.rules));\n   }\n \n+  /**\n+   * This method returns an instance for <code>CollationElementIterator</code>\n+   * for the specified <code>String</code> under the collation rules for this\n+   * object.\n+   *\n+   * @param str The <code>String</code> to return the <code>CollationElementIterator</code> instance for.\n+   *\n+   * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.\n+   */\n   public CollationElementIterator getCollationElementIterator (String source)\n   {\n     StringBuffer expand = new StringBuffer (source.length());\n@@ -309,6 +471,15 @@ public CollationElementIterator getCollationElementIterator (String source)\n     return new CollationElementIterator (expand.toString(), this);\n   }\n \n+  /**\n+   * This method returns an instance of <code>CollationElementIterator</code>\n+   * for the <code>String</code> represented by the specified\n+   * <code>CharacterIterator</code>.\n+   *\n+   * @param ci The <code>CharacterIterator</code> with the desired <code>String</code>.\n+   *\n+   * @return A <code>CollationElementIterator</code> for the specified <code>String</code>.\n+   */\n   public CollationElementIterator getCollationElementIterator (CharacterIterator source)\n   {\n     StringBuffer expand = new StringBuffer ();\n@@ -320,18 +491,40 @@ public CollationElementIterator getCollationElementIterator (CharacterIterator s\n     return new CollationElementIterator (expand.toString(), this);\n   }\n \n+  /**\n+   * This method returns an instance of <code>CollationKey</code> for the\n+   * specified <code>String</code>.  The object returned will have a\n+   * more efficient mechanism for its comparison function that could\n+   * provide speed benefits if multiple comparisons are performed, such\n+   * as during a sort.\n+   *\n+   * @param str The <code>String</code> to create a <code>CollationKey</code> for.\n+   *\n+   * @return A <code>CollationKey</code> for the specified <code>String</code>.\n+   */\n   public CollationKey getCollationKey (String source)\n   {\n     return new CollationKey (getCollationElementIterator (source), source,\n \t\t\t     strength);\n   }\n \n-  public String getRules ()\n+  /**\n+   * This method returns a <code>String</code> containing the collation rules\n+   * for this object.\n+   *\n+   * @return The collation rules for this object.\n+   */\n+  public String getRules()\n   {\n     return rules;\n   }\n \n-  public int hashCode ()\n+  /**\n+   * This method returns a hash value for this object.\n+   *\n+   * @return A hash value for this object.\n+   */\n+  public int hashCode()\n   {\n     return (frenchAccents ? 1231 : 1237\n \t    ^ rules.hashCode()\n@@ -369,119 +562,4 @@ else if (is_special (c) || Character.isWhitespace(c))\n     return index;\n   }\n \n-  public RuleBasedCollator (String rules) throws ParseException\n-  {\n-    this.rules = rules;\n-    this.frenchAccents = false;\n-\n-    // We keep each rule in order in a vector.  At the end we traverse\n-    // the vector and compute collation values from it.\n-    int insertion_index = 0;\n-    Vector vec = new Vector ();\n-\n-    StringBuffer argument = new StringBuffer ();\n-\n-    int len = rules.length();\n-    for (int index = 0; index < len; ++index)\n-      {\n-\tchar c = rules.charAt(index);\n-\n-\t// Just skip whitespace.\n-\tif (Character.isWhitespace(c))\n-\t  continue;\n-\n-\t// Modifier.\n-\tif (c == '@')\n-\t  {\n-\t    frenchAccents = true;\n-\t    continue;\n-\t  }\n-\n-\t// Check for relation or reset operator.\n-\tif (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))\n-\t  throw new ParseException (\"invalid character\", index);\n-\n-\t++index;\n-\twhile (index < len)\n-\t  {\n-\t    if (! Character.isWhitespace(rules.charAt(index)))\n-\t      break;\n-\t    ++index;\n-\t  }\n-\tif (index == len)\n-\t  throw new ParseException (\"missing argument\", index);\n-\n-\tint save = index;\n-\tindex = text_argument (rules, index, argument);\n-\tif (argument.length() == 0)\n-\t  throw new ParseException (\"invalid character\", save);\n-\tString arg = argument.toString();\n-\tint item_index = vec.indexOf(arg);\n-\tif (c != '&')\n-\t  {\n-\t    // If the argument already appears in the vector, then we\n-\t    // must remove it in order to re-order.\n-\t    if (item_index != -1)\n-\t      {\n-\t\tvec.removeElementAt(item_index);\n-\t\tif (insertion_index >= item_index)\n-\t\t  --insertion_index;\n-\t      }\n-\t    CollationElement r = new CollationElement (arg, c);\n-\t    vec.insertElementAt(r, insertion_index);\n-\t    ++insertion_index;\n-\t  }\n-\telse\n-\t  {\n-\t    // Reset.\n-\t    if (item_index == -1)\n-\t      throw\n-\t\tnew ParseException (\"argument to reset not previously seen\",\n-\t\t\t\t    save);\n-\t    insertion_index = item_index + 1;\n-\t  }\n-\n-\t// Ugly: in this case the resulting INDEX comes from\n-\t// text_argument, which returns the index of the next\n-\t// character we should examine.\n-\t--index;\n-      }\n-\n-    // Now construct a hash table that maps strings onto their\n-    // collation values.\n-    int primary = 0;\n-    int secondary = 0;\n-    int tertiary = 0;\n-    this.map = new Hashtable ();\n-    this.prefixes = new Hashtable ();\n-    Enumeration e = vec.elements();\n-    while (e.hasMoreElements())\n-      {\n-\tCollationElement r = (CollationElement) e.nextElement();\n-\tswitch (r.relation)\n-\t  {\n-\t  case '<':\n-\t    ++primary;\n-\t    secondary = 0;\n-\t    tertiary = 0;\n-\t    break;\n-\t  case ';':\n-\t    ++secondary;\n-\t    tertiary = 0;\n-\t    break;\n-\t  case ',':\n-\t    ++tertiary;\n-\t    break;\n-\t  case '=':\n-\t    break;\n-\t  }\n-\t// This must match CollationElementIterator.\n-\tmap.put(r.key, new Integer (primary << 16\n-\t\t\t\t    | secondary << 8 | tertiary));\n-\n-\t// Make a map of all lookaheads we might need.\n-\tfor (int i = r.key.length() - 1; i >= 1; --i)\n-\t  prefixes.put(r.key.substring(0, i), Boolean.TRUE);\n-      }\n-  }\n }"}]}