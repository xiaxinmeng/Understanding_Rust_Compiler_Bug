{"sha": "48932682a54f1a4a97fd8fc026f2d816519fdb7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg5MzI2ODJhNTRmMWE0YTk3ZmQ4ZmMwMjZmMmQ4MTY1MTlmZGI3YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-06-01T08:05:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-06-01T08:05:24Z"}, "message": "re PR middle-end/66313 (Unsafe factorization of a*b+a*c)\n\n2017-06-01  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/66313\n\t* fold-const.c (fold_plusminus_mult_expr): If the factored\n\tfactor may be zero use a wrapping type for the inner operation.\n\t* tree-tailcall.c (independent_of_stmt_p): Pass in to_move bitmap\n\tand handle moved defs.\n\t(process_assignment): Properly guard the unary op case.  Return a\n\ttri-state indicating that moving the stmt before the call may allow\n\tto continue.  Pass through to_move.\n\t(find_tail_calls): Handle moving unrelated defs before\n\tthe call.\n\n\t* c-c++-common/ubsan/pr66313.c: New testcase.\n\t* gcc.dg/tree-ssa/loop-15.c: Adjust.\n\nFrom-SVN: r248771", "tree": {"sha": "84cab82818172c6a30cd70ae641506e23050e0b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84cab82818172c6a30cd70ae641506e23050e0b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48932682a54f1a4a97fd8fc026f2d816519fdb7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48932682a54f1a4a97fd8fc026f2d816519fdb7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48932682a54f1a4a97fd8fc026f2d816519fdb7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48932682a54f1a4a97fd8fc026f2d816519fdb7a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58cdd35b95418d0112e8c030d50e63df6a3e6a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58cdd35b95418d0112e8c030d50e63df6a3e6a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58cdd35b95418d0112e8c030d50e63df6a3e6a30"}], "stats": {"total": 179, "additions": 139, "deletions": 40}, "files": [{"sha": "9d80f59ce2b211f3bc74e6f4a4e83cb4ce7e0d1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48932682a54f1a4a97fd8fc026f2d816519fdb7a", "patch": "@@ -1,3 +1,16 @@\n+2017-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/66313\n+\t* fold-const.c (fold_plusminus_mult_expr): If the factored\n+\tfactor may be zero use a wrapping type for the inner operation.\n+\t* tree-tailcall.c (independent_of_stmt_p): Pass in to_move bitmap\n+\tand handle moved defs.\n+\t(process_assignment): Properly guard the unary op case.  Return a\n+\ttri-state indicating that moving the stmt before the call may allow\n+\tto continue.  Pass through to_move.\n+\t(find_tail_calls): Handle moving unrelated defs before\n+\tthe call.\n+\n 2017-05-31  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/80618"}, {"sha": "b0d03c9aaa3a70f12d702acc6672490a28ba3e03", "filename": "gcc/fold-const.c", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=48932682a54f1a4a97fd8fc026f2d816519fdb7a", "patch": "@@ -6933,10 +6933,11 @@ fold_plusminus_mult_expr (location_t loc, enum tree_code code, tree type,\n     }\n   same = NULL_TREE;\n \n-  if (operand_equal_p (arg01, arg11, 0))\n-    same = arg01, alt0 = arg00, alt1 = arg10;\n-  else if (operand_equal_p (arg00, arg10, 0))\n+  /* Prefer factoring a common non-constant.  */\n+  if (operand_equal_p (arg00, arg10, 0))\n     same = arg00, alt0 = arg01, alt1 = arg11;\n+  else if (operand_equal_p (arg01, arg11, 0))\n+    same = arg01, alt0 = arg00, alt1 = arg10;\n   else if (operand_equal_p (arg00, arg11, 0))\n     same = arg00, alt0 = arg01, alt1 = arg10;\n   else if (operand_equal_p (arg01, arg10, 0))\n@@ -6981,14 +6982,36 @@ fold_plusminus_mult_expr (location_t loc, enum tree_code code, tree type,\n \t}\n     }\n \n-  if (same)\n+  if (!same)\n+    return NULL_TREE;\n+\n+  if (! INTEGRAL_TYPE_P (type)\n+      || TYPE_OVERFLOW_WRAPS (type)\n+      /* We are neither factoring zero nor minus one.  */\n+      || TREE_CODE (same) == INTEGER_CST)\n     return fold_build2_loc (loc, MULT_EXPR, type,\n \t\t\tfold_build2_loc (loc, code, type,\n \t\t\t\t     fold_convert_loc (loc, type, alt0),\n \t\t\t\t     fold_convert_loc (loc, type, alt1)),\n \t\t\tfold_convert_loc (loc, type, same));\n \n-  return NULL_TREE;\n+  /* Same may be zero and thus the operation 'code' may overflow.  Likewise\n+     same may be minus one and thus the multiplication may overflow.  Perform\n+     the operations in an unsigned type.  */\n+  tree utype = unsigned_type_for (type);\n+  tree tem = fold_build2_loc (loc, code, utype,\n+\t\t\t      fold_convert_loc (loc, utype, alt0),\n+\t\t\t      fold_convert_loc (loc, utype, alt1));\n+  /* If the sum evaluated to a constant that is not -INF the multiplication\n+     cannot overflow.  */\n+  if (TREE_CODE (tem) == INTEGER_CST\n+      && ! wi::eq_p (tem, wi::min_value (TYPE_PRECISION (utype), SIGNED)))\n+    return fold_build2_loc (loc, MULT_EXPR, type,\n+\t\t\t    fold_convert (type, tem), same);\n+\n+  return fold_convert_loc (loc, type,\n+\t\t\t   fold_build2_loc (loc, MULT_EXPR, utype, tem,\n+\t\t\t\t\t    fold_convert_loc (loc, utype, same)));\n }\n \n /* Subroutine of native_encode_expr.  Encode the INTEGER_CST"}, {"sha": "4795d412d4735fc2d644a2c2ae290a24e55e9c12", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=48932682a54f1a4a97fd8fc026f2d816519fdb7a", "patch": "@@ -1,3 +1,9 @@\n+2017-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/66313\n+\t* c-c++-common/ubsan/pr66313.c: New testcase.\n+\t* gcc.dg/tree-ssa/loop-15.c: Adjust.\n+\n 2017-05-31  Steven Munroe  <munroesj@gcc.gnu.org>\n \n \t* gcc.target/powerpc/bmi2-pdep32-1.c: Add -mcpu=power7 to"}, {"sha": "7fd627dd40fd965d7c849d21224375c75b9f2c07", "filename": "gcc/testsuite/c-c++-common/ubsan/pr66313.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr66313.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr66313.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr66313.c?ref=48932682a54f1a4a97fd8fc026f2d816519fdb7a", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=undefined -fsanitize-undefined-trap-on-error\" } */\n+\n+int __attribute__((noinline,noclone))\n+f(int a, int b, int c)\n+{\n+  return a * b + a * c;\n+}\n+int __attribute__((noinline,noclone))\n+g(int a)\n+{\n+  return a * (__INT_MAX__/2) + a * (__INT_MAX__/2 + 2);\n+}\n+int __attribute__((noinline,noclone))\n+h(int a, int b)\n+{\n+  return a * (__INT_MAX__/2 + 1) + b * (__INT_MAX__/2 + 1);\n+}\n+int main()\n+{\n+  volatile int tem = f(0, __INT_MAX__, __INT_MAX__);\n+  tem = f(-1, __INT_MAX__/2 + 1, __INT_MAX__/2 + 1);\n+  tem = g(-1);\n+  tem = h(-1, -1);\n+  return 0;\n+}"}, {"sha": "dce6ad57a04938a955141cfe1814b861b07866ca", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-15.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-15.c?ref=48932682a54f1a4a97fd8fc026f2d816519fdb7a", "patch": "@@ -19,8 +19,8 @@ int bla(void)\n }\n \n /* Since the loop is removed, there should be no addition.  */\n-/* { dg-final { scan-tree-dump-times \"\\\\+\" 0 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"n_. \\\\* n_.\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\+ \" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"optimized\" } } */\n \n /* The if from the loop header copying remains in the code.  */\n /* { dg-final { scan-tree-dump-times \"if \" 1 \"optimized\" } } */"}, {"sha": "f6cfce5228726fa5672d7b7da6b0205cb99535eb", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 64, "deletions": 33, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48932682a54f1a4a97fd8fc026f2d816519fdb7a/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=48932682a54f1a4a97fd8fc026f2d816519fdb7a", "patch": "@@ -184,7 +184,8 @@ suitable_for_tail_call_opt_p (void)\n    containing the value of EXPR at GSI.  */\n \n static tree\n-independent_of_stmt_p (tree expr, gimple *at, gimple_stmt_iterator gsi)\n+independent_of_stmt_p (tree expr, gimple *at, gimple_stmt_iterator gsi,\n+\t\t       bitmap to_move)\n {\n   basic_block bb, call_bb, at_bb;\n   edge e;\n@@ -196,6 +197,9 @@ independent_of_stmt_p (tree expr, gimple *at, gimple_stmt_iterator gsi)\n   if (TREE_CODE (expr) != SSA_NAME)\n     return NULL_TREE;\n \n+  if (bitmap_bit_p (to_move, SSA_NAME_VERSION (expr)))\n+    return expr;\n+\n   /* Mark the blocks in the chain leading to the end.  */\n   at_bb = gimple_bb (at);\n   call_bb = gimple_bb (gsi_stmt (gsi));\n@@ -250,13 +254,16 @@ independent_of_stmt_p (tree expr, gimple *at, gimple_stmt_iterator gsi)\n   return expr;\n }\n \n+enum par { FAIL, OK, TRY_MOVE };\n+\n /* Simulates the effect of an assignment STMT on the return value of the tail\n    recursive CALL passed in ASS_VAR.  M and A are the multiplicative and the\n    additive factor for the real return value.  */\n \n-static bool\n-process_assignment (gassign *stmt, gimple_stmt_iterator call, tree *m,\n-\t\t    tree *a, tree *ass_var)\n+static par\n+process_assignment (gassign *stmt,\n+\t\t    gimple_stmt_iterator call, tree *m,\n+\t\t    tree *a, tree *ass_var, bitmap to_move)\n {\n   tree op0, op1 = NULL_TREE, non_ass_var = NULL_TREE;\n   tree dest = gimple_assign_lhs (stmt);\n@@ -276,19 +283,19 @@ process_assignment (gassign *stmt, gimple_stmt_iterator call, tree *m,\n       if (gimple_assign_cast_p (stmt))\n \t{\n \t  if (TYPE_MODE (TREE_TYPE (dest)) != TYPE_MODE (TREE_TYPE (src_var)))\n-\t    return false;\n+\t    return FAIL;\n \n \t  /* Even if the type modes are the same, if the precision of the\n \t     type is smaller than mode's precision,\n \t     reduce_to_bit_field_precision would generate additional code.  */\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (dest))\n \t      && (GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (dest)))\n \t\t  > TYPE_PRECISION (TREE_TYPE (dest))))\n-\t    return false;\n+\t    return FAIL;\n \t}\n \n       *ass_var = dest;\n-      return true;\n+      return OK;\n     }\n \n   switch (rhs_class)\n@@ -303,50 +310,53 @@ process_assignment (gassign *stmt, gimple_stmt_iterator call, tree *m,\n       break;\n \n     default:\n-      return false;\n+      return FAIL;\n     }\n \n   /* Accumulator optimizations will reverse the order of operations.\n      We can only do that for floating-point types if we're assuming\n      that addition and multiplication are associative.  */\n   if (!flag_associative_math)\n     if (FLOAT_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n-      return false;\n+      return FAIL;\n \n-  if (rhs_class == GIMPLE_UNARY_RHS)\n+  if (rhs_class == GIMPLE_UNARY_RHS\n+      && op0 == *ass_var)\n     ;\n   else if (op0 == *ass_var\n-\t   && (non_ass_var = independent_of_stmt_p (op1, stmt, call)))\n+\t   && (non_ass_var = independent_of_stmt_p (op1, stmt, call,\n+\t\t\t\t\t\t    to_move)))\n     ;\n   else if (op1 == *ass_var\n-\t   && (non_ass_var = independent_of_stmt_p (op0, stmt, call)))\n+\t   && (non_ass_var = independent_of_stmt_p (op0, stmt, call,\n+\t\t\t\t\t\t    to_move)))\n     ;\n   else\n-    return false;\n+    return TRY_MOVE;\n \n   switch (code)\n     {\n     case PLUS_EXPR:\n       *a = non_ass_var;\n       *ass_var = dest;\n-      return true;\n+      return OK;\n \n     case POINTER_PLUS_EXPR:\n       if (op0 != *ass_var)\n-\treturn false;\n+\treturn FAIL;\n       *a = non_ass_var;\n       *ass_var = dest;\n-      return true;\n+      return OK;\n \n     case MULT_EXPR:\n       *m = non_ass_var;\n       *ass_var = dest;\n-      return true;\n+      return OK;\n \n     case NEGATE_EXPR:\n       *m = build_minus_one_cst (TREE_TYPE (op0));\n       *ass_var = dest;\n-      return true;\n+      return OK;\n \n     case MINUS_EXPR:\n       if (*ass_var == op0)\n@@ -358,12 +368,10 @@ process_assignment (gassign *stmt, gimple_stmt_iterator call, tree *m,\n         }\n \n       *ass_var = dest;\n-      return true;\n-\n-      /* TODO -- Handle POINTER_PLUS_EXPR.  */\n+      return OK;\n \n     default:\n-      return false;\n+      return FAIL;\n     }\n }\n \n@@ -523,6 +531,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n      since we are running after dce.  */\n   m = NULL_TREE;\n   a = NULL_TREE;\n+  auto_bitmap to_move;\n \n   abb = bb;\n   agsi = gsi;\n@@ -540,27 +549,36 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t}\n \n       stmt = gsi_stmt (agsi);\n-\n-      if (gimple_code (stmt) == GIMPLE_LABEL\n-\t  || gimple_code (stmt) == GIMPLE_NOP)\n-\tcontinue;\n-\n       if (gimple_code (stmt) == GIMPLE_RETURN)\n \tbreak;\n \n-      if (gimple_clobber_p (stmt))\n-\tcontinue;\n-\n-      if (is_gimple_debug (stmt))\n+      if (gimple_code (stmt) == GIMPLE_LABEL\n+\t  || gimple_code (stmt) == GIMPLE_NOP\n+\t  || gimple_clobber_p (stmt)\n+\t  || is_gimple_debug (stmt))\n \tcontinue;\n \n       if (gimple_code (stmt) != GIMPLE_ASSIGN)\n \treturn;\n \n       /* This is a gimple assign. */\n-      if (! process_assignment (as_a <gassign *> (stmt), gsi, &tmp_m,\n-\t\t\t\t&tmp_a, &ass_var))\n+      par ret = process_assignment (as_a <gassign *> (stmt), gsi,\n+\t\t\t\t    &tmp_m, &tmp_a, &ass_var, to_move);\n+      if (ret == FAIL)\n \treturn;\n+      else if (ret == TRY_MOVE)\n+\t{\n+\t  if (! tail_recursion)\n+\t    return;\n+\t  for (unsigned opno = 1; opno < gimple_num_ops (stmt); ++opno)\n+\t    {\n+\t      tree op = gimple_op (stmt, opno);\n+\t      if (independent_of_stmt_p (op, stmt, gsi, to_move) != op)\n+\t\treturn;\n+\t    }\n+\t  bitmap_set_bit (to_move, SSA_NAME_VERSION (gimple_assign_lhs (stmt)));\n+\t  continue;\n+\t}\n \n       if (tmp_a)\n \t{\n@@ -601,6 +619,19 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n   if (m && POINTER_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n     return;\n \n+  /* Move queued defs.  */\n+  if (tail_recursion)\n+    {\n+      bitmap_iterator bi;\n+      unsigned i;\n+      EXECUTE_IF_SET_IN_BITMAP (to_move, 0, i, bi)\n+\t{\n+\t  stmt = SSA_NAME_DEF_STMT (ssa_name (i));\n+\t  gimple_stmt_iterator mgsi = gsi_for_stmt (stmt);\n+\t  gsi_move_before (&mgsi, &gsi);\n+\t}\n+    }\n+\n   nw = XNEW (struct tailcall);\n \n   nw->call_gsi = gsi;"}]}