{"sha": "5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVlZWVkNWUxYTllZThlYTlmYmZmMjQ3YzljYzZmZDA5M2ZhNWRjZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-08-06T07:58:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-08-06T07:58:49Z"}, "message": "[multiple changes]\n\n2012-08-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Process_Transient_Objects): Remove obsolete loop\n\tprocessing related to array initialization. The expansion of\n\tloops already contains a mechanism to detect controlled objects\n\tgenerated by expansion and introduce a block around the loop\n\tstatements for finalization purposes.\n\n2012-08-06  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_ch13.adb: Current scope must be within\n\tor same as the scope of the entity while analysing aspect\n\tspecifications at freeze point.\n\n2012-08-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb: Add note about dubious SCO for TERMINATE\n\talternative.\n\t* sem_ch8.adb, exp_ch11.adb: Minor reformatting.\n\n2012-08-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Two_Dim_Packed_Array_Handled): New procedure to\n\ttransform an aggregate for a packed two-dimensional array into\n\ta one-dimensional array of constant values, in order to avoid\n\tthe generation of component-by-component assignments.\n\n2012-08-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* frontend.adb: Do not attempt to process deferred configuration\n\tpragmas if the main unit failed to load, to avoid cascaded\n\tinconsistencies that can lead to a compiler crash.\n\nFrom-SVN: r190161", "tree": {"sha": "c4b0667b7b66db54d5d049e343e45682c37df54a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4b0667b7b66db54d5d049e343e45682c37df54a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/comments", "author": null, "committer": null, "parents": [{"sha": "b5ee491c7bf77f6355ae205dfd5779ac7ed6a00d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ee491c7bf77f6355ae205dfd5779ac7ed6a00d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ee491c7bf77f6355ae205dfd5779ac7ed6a00d"}], "stats": {"total": 316, "additions": 259, "deletions": 57}, "files": [{"sha": "1502371eef3a46953984d27996809dff1fde5d7d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -1,3 +1,36 @@\n+2012-08-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Process_Transient_Objects): Remove obsolete loop\n+\tprocessing related to array initialization. The expansion of\n+\tloops already contains a mechanism to detect controlled objects\n+\tgenerated by expansion and introduce a block around the loop\n+\tstatements for finalization purposes.\n+\n+2012-08-06  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_ch13.adb: Current scope must be within\n+\tor same as the scope of the entity while analysing aspect\n+\tspecifications at freeze point.\n+\n+2012-08-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb: Add note about dubious SCO for TERMINATE\n+\talternative.\n+\t* sem_ch8.adb, exp_ch11.adb: Minor reformatting.\n+\n+2012-08-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Two_Dim_Packed_Array_Handled): New procedure to\n+\ttransform an aggregate for a packed two-dimensional array into\n+\ta one-dimensional array of constant values, in order to avoid\n+\tthe generation of component-by-component assignments.\n+\n+2012-08-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* frontend.adb: Do not attempt to process deferred configuration\n+\tpragmas if the main unit failed to load, to avoid cascaded\n+\tinconsistencies that can lead to a compiler crash.\n+\n 2012-08-06  Vincent Pucci  <pucci@adacore.com>\n \n \t* s-atopri.adb: Minor reformatting."}, {"sha": "850457956e067aa9bf44971940f0f8fdbe66a883", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 204, "deletions": 8, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -275,6 +275,13 @@ package body Exp_Aggr is\n    --  the assignment can be done in place even if bounds are not static,\n    --  by converting it into a loop over the discrete range of the slice.\n \n+   function Two_Dim_Packed_Array_Handled (N : Node_Id) return Boolean;\n+   --  If the type of the aggregate is a two-dimensional bit_packed array\n+   --  it may be transformed into an array of bytes with constant values,\n+   --  and presented to the back-end as a static value. The function returns\n+   --  false if this transformation cannot be performed. THis is similar to,\n+   --  and reuses part of the machinery in Packed_Array_Aggregate_Handled.\n+\n    ------------------\n    -- Aggr_Size_OK --\n    ------------------\n@@ -4781,8 +4788,9 @@ package body Exp_Aggr is\n       if Nkind (N) /= N_Aggregate then\n          return;\n \n-      --  We are also done if the result is an analyzed aggregate\n-      --  This case could use more comments ???\n+      --  We are also done if the result is an analyzed aggregate, indicating\n+      --  that Convert_To_Positional succeeded and reanalyzed the rewritten\n+      --  aggregate.\n \n       elsif Analyzed (N)\n         and then N /= Original_Node (N)\n@@ -5968,7 +5976,7 @@ package body Exp_Aggr is\n    --  The current version of this procedure will handle at compile time\n    --  any array aggregate that meets these conditions:\n \n-   --    One dimensional, bit packed\n+   --    One and two dimensional, bit packed\n    --    Underlying packed type is modular type\n    --    Bounds are within 32-bit Int range\n    --    All bounds and values are static\n@@ -5982,15 +5990,26 @@ package body Exp_Aggr is\n       --  Exception raised if this aggregate cannot be handled\n \n    begin\n-      --  For now, handle only one dimensional bit packed arrays\n+      --  Handle one- or two dimensional bit packed array\n \n       if not Is_Bit_Packed_Array (Typ)\n-        or else Number_Dimensions (Typ) > 1\n-        or else not Is_Modular_Integer_Type (Packed_Array_Type (Typ))\n+        or else Number_Dimensions (Typ) > 2\n       then\n          return False;\n       end if;\n \n+      --  If two-dimensional, check whether it can be folded, and transformed\n+      --  into a one-dimensional aggregate for the Packed_Array_Type of the\n+      --  original type.\n+\n+      if Number_Dimensions (Typ) = 2 then\n+         return Two_Dim_Packed_Array_Handled (N);\n+      end if;\n+\n+      if not Is_Modular_Integer_Type (Packed_Array_Type (Typ)) then\n+         return False;\n+      end if;\n+\n       if not Is_Scalar_Type (Component_Type (Typ))\n         and then Has_Non_Standard_Rep (Component_Type (Typ))\n       then\n@@ -6084,8 +6103,9 @@ package body Exp_Aggr is\n          --  If the aggregate is not fully positional at this stage, then\n          --  convert it to positional form. Either this will fail, in which\n          --  case we can do nothing, or it will succeed, in which case we have\n-         --  succeeded in handling the aggregate, or it will stay an aggregate,\n-         --  in which case we have failed to handle this case.\n+         --  succeeded in handling the aggregate and transforming it into a\n+         --  modular value, or it will stay an aggregate, in which case we\n+         --  have failed to create a packed value for it.\n \n          if Present (Component_Associations (N)) then\n             Convert_To_Positional\n@@ -6351,6 +6371,182 @@ package body Exp_Aggr is\n       end if;\n    end Safe_Slice_Assignment;\n \n+   ----------------------------------\n+   -- Two_Dim_Packed_Array_Handled --\n+   ----------------------------------\n+\n+   function Two_Dim_Packed_Array_Handled (N : Node_Id) return Boolean is\n+      Loc          : constant Source_Ptr := Sloc (N);\n+      Typ          : constant Entity_Id := Etype (N);\n+      Ctyp         : constant Entity_Id := Component_Type (Typ);\n+      Comp_Size    : constant Int := UI_To_Int (Component_Size (Typ));\n+      Packed_Array : constant Entity_Id := Packed_Array_Type (Base_Type (Typ));\n+\n+      One_Comp  : Node_Id;\n+      --  Expression in original aggregate\n+\n+      One_Dim   : Node_Id;\n+      --  one-dimensional subaggregate\n+\n+   begin\n+\n+      --  For now, only deal with tight packing. The boolean case is the\n+      --  most common.\n+\n+      if Comp_Size = 1\n+         or else Comp_Size = 2\n+         or else Comp_Size = 4\n+      then\n+         null;\n+\n+      else\n+         return False;\n+      end if;\n+\n+      Convert_To_Positional\n+        (N, Max_Others_Replicate => 64, Handle_Bit_Packed => True);\n+\n+      --  Verify that all components are static.\n+\n+      if Nkind (N) = N_Aggregate\n+        and then Compile_Time_Known_Aggregate (N)\n+      then\n+         null;\n+\n+      --  The aggregate may have been re-analyzed and converted already.\n+\n+      elsif Nkind (N) /= N_Aggregate then\n+         return True;\n+\n+      --  If component associations remain, the aggregate is not static.\n+\n+      elsif Present (Component_Associations (N)) then\n+         return False;\n+\n+      else\n+         One_Dim := First (Expressions (N));\n+         while Present (One_Dim) loop\n+            if Present (Component_Associations (One_Dim)) then\n+               return False;\n+            end if;\n+\n+            One_Comp := First (Expressions (One_Dim));\n+            while Present (One_Comp) loop\n+               if not Is_OK_Static_Expression (One_Comp) then\n+                  return False;\n+               end if;\n+\n+               Next (One_Comp);\n+            end loop;\n+\n+            Next (One_Dim);\n+         end loop;\n+      end if;\n+\n+      --  Two-dimensional aggregate is now fully positional so pack one\n+      --  dimension to create a static one-dimensional array, and rewrite\n+      --  as an unchecked conversion to the original type.\n+\n+      declare\n+         Byte_Size : constant Int := UI_To_Int (Component_Size (Packed_Array));\n+         --  The packed array type is a byte array\n+\n+         Packed_Num : Int;\n+         --  Number of components accumulated in current byte\n+\n+         Comps : List_Id;\n+         --  Assembled list of packed values for equivalent aggregate\n+\n+         Comp_Val : Uint;\n+         --  integer value of component\n+\n+         Incr  : Int;\n+         --  Step size for packing\n+\n+         Init_Shift : Int;\n+         --  endian-dependent start position for packing\n+\n+         Shift : Int;\n+         --  current insertion position\n+\n+         Val   : Int;\n+         --  component of packed array being assembled.\n+\n+      begin\n+         Comps := New_List;\n+         Val   := 0;\n+         Packed_Num := 0;\n+\n+         --  Account for endianness.  See corresponding comment in\n+         --  Packed_Array_Aggregate_Handled concerning the following.\n+\n+         if Bytes_Big_Endian\n+           xor Debug_Flag_8\n+           xor Reverse_Storage_Order (Base_Type (Typ))\n+         then\n+            Init_Shift := Byte_Size - Comp_Size;\n+            Incr  := -Comp_Size;\n+         else\n+            Init_Shift := 0;\n+            Incr  := +Comp_Size;\n+         end if;\n+\n+         Shift := Init_Shift;\n+         One_Dim := First (Expressions (N));\n+\n+         --  Iterate over each subaggregate\n+\n+         while Present (One_Dim) loop\n+            One_Comp := First (Expressions (One_Dim));\n+\n+            while Present (One_Comp) loop\n+               if Packed_Num = Byte_Size / Comp_Size then\n+\n+                  --  Byte is complete, add to list of expressions\n+\n+                  Append (Make_Integer_Literal (Sloc (One_Dim), Val), Comps);\n+                  Val := 0;\n+                  Shift := Init_Shift;\n+                  Packed_Num := 0;\n+\n+               else\n+                  Comp_Val := Expr_Rep_Value (One_Comp);\n+\n+                  --  Adjust for bias, and strip proper number of bits\n+\n+                  if Has_Biased_Representation (Ctyp) then\n+                     Comp_Val := Comp_Val - Expr_Value (Type_Low_Bound (Ctyp));\n+                  end if;\n+\n+                  Comp_Val := Comp_Val mod Uint_2 ** Comp_Size;\n+                  Val := UI_To_Int (Val + Comp_Val * Uint_2 ** Shift);\n+                  Shift := Shift + Incr;\n+                  One_Comp := Next (One_Comp);\n+                  Packed_Num := Packed_Num + 1;\n+               end if;\n+            end loop;\n+\n+            One_Dim := Next (One_Dim);\n+         end loop;\n+\n+         if Packed_Num > 0 then\n+\n+            --  Add final incomplete byte if present.\n+\n+            Append (Make_Integer_Literal (Sloc (One_Dim), Val), Comps);\n+         end if;\n+\n+         Rewrite (N,\n+             Unchecked_Convert_To (Typ,\n+               Make_Qualified_Expression (Loc,\n+                 Subtype_Mark => New_Occurrence_Of (Packed_Array, Loc),\n+               Expression =>\n+                Make_Aggregate (Loc,  Expressions => Comps))));\n+         Analyze_And_Resolve (N);\n+         return True;\n+      end;\n+   end Two_Dim_Packed_Array_Handled;\n+\n    ---------------------\n    -- Sort_Case_Table --\n    ---------------------"}, {"sha": "56cf190e2a85e24518ba7dfd28cb98bd5c84b283", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -1916,7 +1916,7 @@ package body Exp_Ch11 is\n                begin\n                   if LCN = Statements (P)\n                        or else\n-                     LCN  = SSE.Actions_To_Be_Wrapped_Before\n+                     LCN = SSE.Actions_To_Be_Wrapped_Before\n                        or else\n                      LCN = SSE.Actions_To_Be_Wrapped_After\n                   then"}, {"sha": "6297dc99ccd48a420aefdeb2b2dff76c7fc9b171", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -4585,48 +4585,12 @@ package body Exp_Ch7 is\n                end if;\n \n                Prev_Fin := Fin_Block;\n+            end if;\n \n-            --  When the associated node is an array object, the expander may\n-            --  sometimes generate a loop and create transient objects inside\n-            --  the loop.\n-\n-            elsif Nkind (Related_Node) = N_Object_Declaration\n-              and then Is_Array_Type\n-                         (Base_Type\n-                           (Etype (Defining_Identifier (Related_Node))))\n-              and then Nkind (Stmt) = N_Loop_Statement\n-            then\n-               declare\n-                  Block_HSS : Node_Id := First (Statements (Stmt));\n-\n-               begin\n-                  --  The loop statements may have been wrapped in a block by\n-                  --  Process_Statements_For_Controlled_Objects, inspect the\n-                  --  handled sequence of statements.\n-\n-                  if Nkind (Block_HSS) = N_Block_Statement\n-                    and then No (Next (Block_HSS))\n-                  then\n-                     Block_HSS := Handled_Statement_Sequence (Block_HSS);\n-\n-                     Process_Transient_Objects\n-                       (First_Object => First (Statements (Block_HSS)),\n-                        Last_Object  => Last (Statements (Block_HSS)),\n-                        Related_Node => Related_Node);\n-\n-                  --  Inspect the statements of the loop\n-\n-                  else\n-                     Process_Transient_Objects\n-                       (First_Object => First (Statements (Stmt)),\n-                        Last_Object  => Last (Statements (Stmt)),\n-                        Related_Node => Related_Node);\n-                  end if;\n-               end;\n-\n-            --  Terminate the scan after the last object has been processed\n+            --  Terminate the scan after the last object has been processed to\n+            --  avoid touching unrelated code.\n \n-            elsif Stmt = Last_Object then\n+            if Stmt = Last_Object then\n                exit;\n             end if;\n "}, {"sha": "13d283373d182996d3329f25affb64b7e86ec0b0", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -282,6 +282,7 @@ begin\n    --  a context for their semantic processing.\n \n    if Config_Pragmas /= Error_List\n+     and then not Fatal_Error (Main_Unit)\n      and then Operating_Mode /= Check_Syntax\n    then\n       --  Pragmas that require some semantic activity, such as"}, {"sha": "78ff71bfd3bf427fc73fe9d8752276f4879cf03a", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -1556,6 +1556,12 @@ package body Par_SCO is\n                   P => Triggering_Statement (N));\n \n             when N_Terminate_Alternative =>\n+\n+               --  It is dubious to emit a statement SCO for a TERMINATE\n+               --  alternative, since no code is actually executed if the\n+               --  alternative is selected -- the tasking runtime call just\n+               --  never returns???\n+\n                Extend_Statement_Sequence (N, ' ');\n                Set_Statement_Entry;\n "}, {"sha": "7baaca7cb16753d2bad6214e2f95f20d7c9c2234", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -856,10 +856,11 @@ package body Sem_Ch13 is\n    --  Start of processing for Analyze_Aspects_At_Freeze_Point\n \n    begin\n-      --  Must be declared in current scope. This is need for a generic\n-      --  context.\n+      --  Must be visible in current scope. Note that this is needed for\n+      --  entities that creates their own scope such as protected objects,\n+      --  tasks, etc.\n \n-      if Scope (E) /= Current_Scope then\n+      if not Scope_Within_Or_Same (Current_Scope, Scope (E)) then\n          return;\n       end if;\n \n@@ -2434,11 +2435,12 @@ package body Sem_Ch13 is\n          return;\n \n       --  Must be declared in current scope or in case of an aspect\n-      --  specification, must be the current scope.\n+      --  specification, must be visible in current scope.\n \n       elsif Scope (Ent) /= Current_Scope\n-        and then (not From_Aspect_Specification (N)\n-                   or else Ent /= Current_Scope)\n+        and then\n+          not (From_Aspect_Specification (N)\n+                and then Scope_Within_Or_Same (Current_Scope, Scope (Ent)))\n       then\n          Error_Msg_N (\"entity must be declared in this scope\", Nam);\n          return;"}, {"sha": "b4348c5bdbedcda039634ca221cda87d4414884e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "patch": "@@ -7223,7 +7223,7 @@ package body Sem_Ch8 is\n       --  If the actions to be wrapped are still there they will get lost\n       --  causing incomplete code to be generated. It is better to abort in\n       --  this case (and we do the abort even with assertions off since the\n-      --  penalty is incorrect code generation)\n+      --  penalty is incorrect code generation).\n \n       if SST.Actions_To_Be_Wrapped_Before /= No_List\n            or else"}]}