{"sha": "0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2ODZhYTZmN2FmM2RiMmE3ZmMzYThmOTg4ZDE0ZDRlNzUyODJmNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-01-22T00:42:40Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-01-22T00:42:40Z"}, "message": "re PR c++/25895 (wrong code with ?: and derived class pointers)\n\n\tPR c++/25895\n\t* class.c (build_base_path): Generate a NOP_EXPR instead of a\n\tCOMPONENT_REF if the base and derived classes are at the same\n\taddress.\n\tPR c++/25856\n\t* decl.c (begin_destructor_body): Robustify.\n\tPR c++/25858 \n\t* parser.c (cp_parser_direct_declarator): Robustify.\n\t\n\tPR c++/25895\n\t* g++.dg/inherit/conv2.C: New test.\n\tPR c++/25856\n\t* g++.dg/parse/dtor7.C: New test.\n\tPR c++/25858\n\t* g++.dg/template/crash44.C: New test.\n\nFrom-SVN: r110084", "tree": {"sha": "34bf7e47e301d282bde70b7e5eec5fcaa0d764a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34bf7e47e301d282bde70b7e5eec5fcaa0d764a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/comments", "author": null, "committer": null, "parents": [{"sha": "5826ba2218e090eeb05a7e60bd88305b1dd250a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5826ba2218e090eeb05a7e60bd88305b1dd250a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5826ba2218e090eeb05a7e60bd88305b1dd250a1"}], "stats": {"total": 132, "additions": 102, "deletions": 30}, "files": [{"sha": "ea7355bcccecaba00376ab001a34b6aeef3a9724", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -1,3 +1,16 @@\n+2006-01-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25895\n+\t* class.c (build_base_path): Generate a NOP_EXPR instead of a\n+\tCOMPONENT_REF if the base and derived classes are at the same\n+\taddress.\n+\n+\tPR c++/25856\n+\t* decl.c (begin_destructor_body): Robustify.\n+\n+\tPR c++/25858 \n+\t* parser.c (cp_parser_direct_declarator): Robustify.\n+\t\n 2006-01-20  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* parser.c (cp_lexer_next_token_is_keyword): Simplify."}, {"sha": "6b075cbd0b72a42904428730fb8d1689cf41569e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -289,13 +289,23 @@ build_base_path (enum tree_code code,\n \n   offset = BINFO_OFFSET (binfo);\n   fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n+  target_type = code == PLUS_EXPR ? BINFO_TYPE (binfo) : BINFO_TYPE (d_binfo);\n \n   /* Do we need to look in the vtable for the real offset?  */\n   virtual_access = (v_binfo && fixed_type_p <= 0);\n \n   /* Do we need to check for a null pointer?  */\n-  if (want_pointer && !nonnull && (virtual_access || !integer_zerop (offset)))\n-    null_test = error_mark_node;\n+  if (want_pointer && !nonnull)\n+    {\n+      /* If we know the conversion will not actually change the value\n+\t of EXPR, then we can avoid testing the expression for NULL.\n+\t We have to avoid generating a COMPONENT_REF for a base class\n+\t field, because other parts of the compiler know that such\n+\t expressions are always non-NULL.  */\n+      if (!virtual_access && integer_zerop (offset))\n+\treturn build_nop (build_pointer_type (target_type), expr);\n+      null_test = error_mark_node;\n+    }\n \n   /* Protect against multiple evaluation if necessary.  */\n   if (TREE_SIDE_EFFECTS (expr) && (null_test || virtual_access))\n@@ -376,8 +386,6 @@ build_base_path (enum tree_code code,\n \toffset = v_offset;\n     }\n \n-  target_type = code == PLUS_EXPR ? BINFO_TYPE (binfo) : BINFO_TYPE (d_binfo);\n-\n   target_type = cp_build_qualified_type\n     (target_type, cp_type_quals (TREE_TYPE (TREE_TYPE (expr))));\n   ptr_target_type = build_pointer_type (target_type);"}, {"sha": "3c98d4918f23cdfca8b9f6ea1bce0ef91ba03501", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -10628,18 +10628,23 @@ begin_destructor_body (void)\n {\n   tree compound_stmt;\n \n-  compound_stmt = begin_compound_stmt (0);\n-\n-  /* Make all virtual function table pointers in non-virtual base\n-     classes point to CURRENT_CLASS_TYPE's virtual function\n-     tables.  */\n-  initialize_vtbl_ptrs (current_class_ptr);\n-\n-  finish_compound_stmt (compound_stmt);\n-\n-  /* And insert cleanups for our bases and members so that they\n-     will be properly destroyed if we throw.  */\n-  push_base_cleanups ();\n+  /* If the CURRENT_CLASS_TYPE is incomplete, we will have already\n+     issued an error message.  We still want to try to process the\n+     body of the function, but initialize_vtbl_ptrs will crash if\n+     TYPE_BINFO is NULL.  */\n+  if (COMPLETE_TYPE_P (current_class_type))\n+    {\n+      compound_stmt = begin_compound_stmt (0);\n+      /* Make all virtual function table pointers in non-virtual base\n+\t classes point to CURRENT_CLASS_TYPE's virtual function\n+\t tables.  */\n+      initialize_vtbl_ptrs (current_class_ptr);\n+      finish_compound_stmt (compound_stmt);\n+      \n+      /* And insert cleanups for our bases and members so that they\n+\t will be properly destroyed if we throw.  */\n+      push_base_cleanups ();\n+    }\n }\n \n /* At the end of every destructor we generate code to delete the object if"}, {"sha": "4c09b2fde9bf6e1a71f30595ae1b4823964279e2", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -11479,22 +11479,24 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t      if (TREE_CODE (unqualified_name) == TYPE_DECL)\n \t\t{\n-\t\t  if (qualifying_scope \n-\t\t      && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (unqualified_name)))\n+\t\t  tree name_type = TREE_TYPE (unqualified_name);\n+\t\t  if (class_type && same_type_p (name_type, class_type))\n \t\t    {\n-\t\t      error (\"invalid use of constructor as a template\");\n-\t\t      inform (\"use %<%T::%D%> instead of %<%T::%T%> to name \"\n-\t\t\t      \"the constructor in a qualified name\",\n-\t\t\t      class_type,\n-\t\t\t      DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n-\t\t\t      class_type, class_type);\n-\t\t      declarator = cp_error_declarator;\n-\t\t      break;\n+\t\t      if (qualifying_scope\n+\t\t\t  && CLASSTYPE_USE_TEMPLATE (name_type))\n+\t\t\t{\n+\t\t\t  error (\"invalid use of constructor as a template\");\n+\t\t\t  inform (\"use %<%T::%D%> instead of %<%T::%D%> to \"\n+\t\t\t\t  \"name the constructor in a qualified name\",\n+\t\t\t\t  class_type,\n+\t\t\t\t  DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n+\t\t\t\t  class_type, name_type);\n+\t\t\t  declarator = cp_error_declarator;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      else\n+\t\t\tunqualified_name = constructor_name (class_type);\n \t\t    }\n-\t\t  else if (class_type\n-\t\t\t   && same_type_p (TREE_TYPE (unqualified_name),\n-\t\t\t\t\t   class_type))\n-\t\t    unqualified_name = constructor_name (class_type);\n \t\t  else\n \t\t    {\n \t\t      /* We do not attempt to print the declarator"}, {"sha": "07aa699ca0c60f9ca2163df6e383518603a24610", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -1,3 +1,14 @@\n+2006-01-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25895\n+\t* g++.dg/inherit/conv2.C: New test.\n+\n+\tPR c++/25856\n+\t* g++.dg/parse/dtor7.C: New test.\n+\n+\tPR c++/25858\n+\t* g++.dg/template/crash44.C: New test.\n+\n 2005-01-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25124"}, {"sha": "fd0083825367235496d5fbaca45df3be7406fbee", "filename": "gcc/testsuite/g++.dg/inherit/conv2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fconv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fconv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fconv2.C?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/25895\n+// { dg-do run }\n+\n+class base {\n+public:\n+  base() {}\n+private:\n+  int val_;\n+};\n+\n+class derived : public base {\n+public:\n+  derived() {}\n+};\n+\n+static bool x = true ? (derived*)0 : (base*)0;\n+\n+int main ()\n+{\n+  if (x)\n+    return 1;\n+}"}, {"sha": "3525624e18d3ba28161bc7e050a5de0451741fdb", "filename": "gcc/testsuite/g++.dg/parse/dtor7.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor7.C?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/25856\n+\n+struct A; // { dg-error \"forward\" } \n+A::~A() {} // { dg-error \"undefined\" }"}, {"sha": "d5596c19977a58db547d214dca66cd04ab334cb5", "filename": "gcc/testsuite/g++.dg/template/crash44.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash44.C?ref=0e686aa6f7af3db2a7fc3a8f988d14d4e75282f4", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/25858\n+\n+namespace N {\n+  template<int> struct A {};\n+}\n+\n+struct B N::A<0> {}; // { dg-error \"invalid\" }"}]}