{"sha": "156d7d8dbc8d65d3958486bc4112a7279935e47d", "node_id": "C_kwDOANBUbNoAKDE1NmQ3ZDhkYmM4ZDY1ZDM5NTg0ODZiYzQxMTJhNzI3OTkzNWU0N2Q", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-24T15:32:42Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-25T14:33:07Z"}, "message": "Use infer instead of side-effect for ranges.\n\nRename the files and classes to reflect the term infer rather than side-effect.\n\n\t* Makefile.in (OBJS): Use gimple-range-infer.o.\n\t* gimple-range-cache.cc (ranger_cache::fill_block_cache): Change msg.\n\t(ranger_cache::range_from_dom): Rename var side_effect to infer.\n\t(ranger_cache::apply_inferred_ranges): Rename from apply_side_effects.\n\t* gimple-range-cache.h: Include gimple-range-infer.h.\n\t(class ranger_cache): Adjust prototypes, use infer_range_manager.\n\t* gimple-range-infer.cc: Rename from gimple-range-side-effects.cc.\n\t(gimple_infer_range::*): Rename from stmt_side_effects.\n\t(infer_range_manager::*): Rename from side_effect_manager.\n\t* gimple-range-side-effect.cc: Rename.\n\t* gimple-range-side-effect.h: Rename.\n\t* gimple-range-infer.h: Rename from gimple-range-side-effects.h.\n\t(class gimple_infer_range): Rename from stmt_side_effects.\n\t(class infer_range_manager): Rename from side_effect_manager.\n\t* gimple-range.cc (gimple_ranger::register_inferred_ranges): Rename\n\tfrom register_side_effects.\n\t* gimple-range.h (register_inferred_ranges): Adjust prototype.\n\t* range-op.h: Adjust comment.\n\t* tree-vrp.cc (rvrp_folder::pre_fold_bb): Use register_inferred_ranges.\n\t(rvrp_folder::post_fold_bb): Use register_inferred_ranges.", "tree": {"sha": "0a96fbbaa12e5190dcfe6ef82d0a16373992e4eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a96fbbaa12e5190dcfe6ef82d0a16373992e4eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/156d7d8dbc8d65d3958486bc4112a7279935e47d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156d7d8dbc8d65d3958486bc4112a7279935e47d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/156d7d8dbc8d65d3958486bc4112a7279935e47d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156d7d8dbc8d65d3958486bc4112a7279935e47d/comments", "author": null, "committer": null, "parents": [{"sha": "63f198553d3940495bfaa49da30b2ce93375c916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f198553d3940495bfaa49da30b2ce93375c916", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63f198553d3940495bfaa49da30b2ce93375c916"}], "stats": {"total": 147, "additions": 74, "deletions": 73}, "files": [{"sha": "731d8dd2a693abd2ea660397535eca66187e4877", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -1410,7 +1410,7 @@ OBJS = \\\n \tgimple-range-edge.o \\\n \tgimple-range-fold.o \\\n \tgimple-range-gori.o \\\n-\tgimple-range-side-effect.o \\\n+\tgimple-range-infer.o \\\n \tgimple-range-trace.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-evrp.o \\"}, {"sha": "5d5e2bfd0c3fc843af204da1c4e2849b68ce67a0", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -944,7 +944,7 @@ bool\n ranger_cache::edge_range (irange &r, edge e, tree name, enum rfd_mode mode)\n {\n   exit_range (r, name, e->src, mode);\n-  // If this is not an abnormal edge, check for side effects on exit.\n+  // If this is not an abnormal edge, check for inferred ranges on exit.\n   if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n     m_exit.maybe_adjust_range (r, name, e->src);\n   int_range_max er;\n@@ -1251,12 +1251,12 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t    }\n \n \t  // Regardless of whether we have visited pred or not, if the\n-\t  // pred has side_effects, revisit this block.\n+\t  // pred has inferred ranges, revisit this block.\n \t  // Don't search the DOM tree.\n \t  if (m_exit.has_range_p (name, pred))\n \t    {\n \t      if (DEBUG_RANGE_CACHE)\n-\t\tfprintf (dump_file, \"side effect: update \");\n+\t\tfprintf (dump_file, \"Inferred range: update \");\n \t      m_update->add (node);\n \t    }\n \n@@ -1317,8 +1317,8 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n   basic_block bb;\n   basic_block prev_bb = start_bb;\n \n-  // Track any side effects seen\n-  int_range_max side_effect (TREE_TYPE (name));\n+  // Track any inferred ranges seen.\n+  int_range_max infer (TREE_TYPE (name));\n \n   // Range on entry to the DEF block should not be queried.\n   gcc_checking_assert (start_bb != def_bb);\n@@ -1332,8 +1332,8 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n        bb;\n        prev_bb = bb, bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n-      // Accumulate any block exit side effects.\n-      m_exit.maybe_adjust_range (side_effect, name, bb);\n+      // Accumulate any block exit inferred ranges.\n+      m_exit.maybe_adjust_range (infer, name, bb);\n \n       // This block has an outgoing range.\n       if (m_gori.has_edge_range_p (name, bb))\n@@ -1399,7 +1399,7 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n       if (m_gori.outgoing_edge_range_p (er, e, name, *this))\n \t{\n \t  r.intersect (er);\n-\t  // If this is a normal edge, apply any side effects.\n+\t  // If this is a normal edge, apply any inferred ranges.\n \t  if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n \t    m_exit.maybe_adjust_range (r, name, bb);\n \n@@ -1415,7 +1415,7 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n \n   // Apply non-null if appropriate.\n   if (!has_abnormal_call_or_eh_pred_edge_p (start_bb))\n-    r.intersect (side_effect);\n+    r.intersect (infer);\n \n   if (DEBUG_RANGE_CACHE)\n     {\n@@ -1430,14 +1430,14 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb,\n // any operands on stmt S to nonnull.\n \n void\n-ranger_cache::apply_side_effects (gimple *s)\n+ranger_cache::apply_inferred_ranges (gimple *s)\n {\n   int_range_max r;\n   bool update = true;\n \n   basic_block bb = gimple_bb (s);\n-  stmt_side_effects se(s);\n-  if (se.num () == 0)\n+  gimple_infer_range infer(s);\n+  if (infer.num () == 0)\n     return;\n \n   // Do not update the on-netry cache for block ending stmts.\n@@ -1452,15 +1452,15 @@ ranger_cache::apply_side_effects (gimple *s)\n \tupdate = false;\n     }\n \n-  for (unsigned x = 0; x < se.num (); x++)\n+  for (unsigned x = 0; x < infer.num (); x++)\n     {\n-      tree name = se.name (x);\n-      m_exit.add_range (name, bb, se.range (x));\n+      tree name = infer.name (x);\n+      m_exit.add_range (name, bb, infer.range (x));\n       if (update)\n \t{\n \t  if (!m_on_entry.get_bb_range (r, name, bb))\n \t    exit_range (r, name, bb, RFD_READ_ONLY);\n-\t  if (r.intersect (se.range (x)))\n+\t  if (r.intersect (infer.range (x)))\n \t    m_on_entry.set_bb_range (name, bb, r);\n \t}\n     }"}, {"sha": "d56e56c201cf9c53b65dd96c3994fc4c5c98200a", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_SSA_RANGE_CACHE_H\n \n #include \"gimple-range-gori.h\" \n-#include \"gimple-range-side-effect.h\"\n+#include \"gimple-range-infer.h\"\n \n // This class manages a vector of pointers to ssa_block ranges.  It\n // provides the basis for the \"range on entry\" cache for all\n@@ -87,9 +87,9 @@ class ranger_cache : public range_query\n \n   void propagate_updated_value (tree name, basic_block bb);\n \n-  void apply_side_effects (gimple *s);\n+  void apply_inferred_ranges (gimple *s);\n   gori_compute m_gori;\n-  side_effect_manager m_exit;\n+  infer_range_manager m_exit;\n \n   void dump_bb (FILE *f, basic_block bb);\n   virtual void dump (FILE *f) override;"}, {"sha": "8e25830849f4b25a58b44cc2c1f9a1f87999ef25", "filename": "gcc/gimple-range-infer.cc", "status": "renamed", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -1,4 +1,4 @@\n-/* Gimple range side effect implementation.\n+/* Gimple range inference implementation.\n    Copyright (C) 2022 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod <amacleod@redhat.com>.\n \n@@ -37,7 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n \n // Adapted from infer_nonnull_range_by_dereference and check_loadstore\n // to process nonnull ssa_name OP in S.  DATA contains a pointer to a\n-// stmt side effects instance.\n+// stmt range inference instance.\n \n static bool\n non_null_loadstore (gimple *, tree op, tree, void *data)\n@@ -49,27 +49,27 @@ non_null_loadstore (gimple *, tree op, tree, void *data)\n       if (!targetm.addr_space.zero_address_valid (as))\n \t{\n \t  tree ssa = TREE_OPERAND (op, 0);\n-\t  ((stmt_side_effects *)data)->add_nonzero (ssa);\n+\t  ((gimple_infer_range *)data)->add_nonzero (ssa);\n \t}\n     }\n   return false;\n }\n \n-// Add NAME and RANGE to the the side effect summary.\n+// Add NAME and RANGE to the the range inference summary.\n \n void\n-stmt_side_effects::add_range (tree name, irange &range)\n+gimple_infer_range::add_range (tree name, irange &range)\n {\n   m_names[num_args] = name;\n   m_ranges[num_args] = range;\n   if (num_args < size_limit - 1)\n     num_args++;\n }\n \n-// Add a nonzero range for NAME to the side effect summary.\n+// Add a nonzero range for NAME to the range inference summary.\n \n void\n-stmt_side_effects::add_nonzero (tree name)\n+gimple_infer_range::add_nonzero (tree name)\n {\n   if (!gimple_range_ssa_p (name))\n     return;\n@@ -78,10 +78,10 @@ stmt_side_effects::add_nonzero (tree name)\n   add_range (name, nz);\n }\n \n-// Process S for side effects and fill in the summary list.\n-// This is the routine where new side effects should be added.\n+// Process S for range inference and fill in the summary list.\n+// This is the routine where new inferred ranges should be added.\n \n-stmt_side_effects::stmt_side_effects (gimple *s)\n+gimple_infer_range::gimple_infer_range (gimple *s)\n {\n   num_args = 0;\n \n@@ -120,7 +120,7 @@ stmt_side_effects::stmt_side_effects (gimple *s)\n \n // -------------------------------------------------------------------------\n \n-// This class is an element in list of side effect ranges.\n+// This class is an element in list of infered ranges.\n \n class exit_range\n {\n@@ -134,7 +134,7 @@ class exit_range\n // Otherwise return NULL.\n \n exit_range *\n-side_effect_manager::exit_range_head::find_ptr (tree ssa)\n+infer_range_manager::exit_range_head::find_ptr (tree ssa)\n {\n   // Return NULL if SSA is not in this list.\n   if (!m_names || !bitmap_bit_p (m_names, SSA_NAME_VERSION (ssa)))\n@@ -147,11 +147,11 @@ side_effect_manager::exit_range_head::find_ptr (tree ssa)\n   return NULL;\n }\n \n-// Construct a side effects manager.  DO_SEARCH indicates whether an immediate\n+// Construct a range infer manager.  DO_SEARCH indicates whether an immediate\n // use scan should be made the first time a name is processed.  This is for\n // on-demand clients who may not visit every statement and may miss uses.\n \n-side_effect_manager::side_effect_manager (bool do_search)\n+infer_range_manager::infer_range_manager (bool do_search)\n {\n   bitmap_obstack_initialize (&m_bitmaps);\n   m_on_exit.create (0);\n@@ -168,9 +168,9 @@ side_effect_manager::side_effect_manager (bool do_search)\n   m_nonzero.safe_grow_cleared (num_ssa_names + 1);\n }\n \n-// Destruct a side effects manager.\n+// Destruct a range infer manager.\n \n-side_effect_manager::~side_effect_manager ()\n+infer_range_manager::~infer_range_manager ()\n {\n   m_nonzero.release ();\n   obstack_free (&m_list_obstack, NULL);\n@@ -182,7 +182,7 @@ side_effect_manager::~side_effect_manager ()\n // the cache, creating it if necessary.\n \n const irange&\n-side_effect_manager::get_nonzero (tree name)\n+infer_range_manager::get_nonzero (tree name)\n {\n   unsigned v = SSA_NAME_VERSION (name);\n   if (v >= m_nonzero.length ())\n@@ -195,10 +195,10 @@ side_effect_manager::get_nonzero (tree name)\n   return *(m_nonzero[v]);\n }\n \n-// Return TRUE if NAME has a side effect range in block BB.\n+// Return TRUE if NAME has a range inference in block BB.\n \n bool\n-side_effect_manager::has_range_p (tree name, basic_block bb)\n+infer_range_manager::has_range_p (tree name, basic_block bb)\n {\n   // Check if this is an immediate use search model.\n   if (m_seen && !bitmap_bit_p (m_seen, SSA_NAME_VERSION (name)))\n@@ -213,11 +213,11 @@ side_effect_manager::has_range_p (tree name, basic_block bb)\n   return true;\n }\n \n-// Return TRUE if NAME has a side effect range in block BB, and adjust range R\n+// Return TRUE if NAME has a range inference in block BB, and adjust range R\n // to include it.\n \n bool\n-side_effect_manager::maybe_adjust_range (irange &r, tree name, basic_block bb)\n+infer_range_manager::maybe_adjust_range (irange &r, tree name, basic_block bb)\n {\n   if (!has_range_p (name, bb))\n     return false;\n@@ -227,10 +227,10 @@ side_effect_manager::maybe_adjust_range (irange &r, tree name, basic_block bb)\n   return r.intersect (*(ptr->range));\n }\n \n-// Add range R as a side effect for NAME in block BB.\n+// Add range R as an inferred range for NAME in block BB.\n \n void\n-side_effect_manager::add_range (tree name, basic_block bb, const irange &r)\n+infer_range_manager::add_range (tree name, basic_block bb, const irange &r)\n {\n   if (bb->index >= (int)m_on_exit.length ())\n     m_on_exit.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n@@ -272,18 +272,18 @@ side_effect_manager::add_range (tree name, basic_block bb, const irange &r)\n   m_on_exit[bb->index].head = ptr;\n }\n \n-// Add a non-zero side effect for NAME in block BB.\n+// Add a non-zero inferred range for NAME in block BB.\n \n void\n-side_effect_manager::add_nonzero (tree name, basic_block bb)\n+infer_range_manager::add_nonzero (tree name, basic_block bb)\n {\n   add_range (name, bb, get_nonzero (name));\n }\n \n-// Follow immediate use chains and find all side effects for NAME.\n+// Follow immediate use chains and find all inferred ranges for NAME.\n \n void\n-side_effect_manager::register_all_uses (tree name)\n+infer_range_manager::register_all_uses (tree name)\n {\n   gcc_checking_assert (m_seen);\n \n@@ -296,15 +296,15 @@ side_effect_manager::register_all_uses (tree name)\n   use_operand_p use_p;\n   imm_use_iterator iter;\n \n-  // Loop over each immediate use and see if it has a side effect.\n+  // Loop over each immediate use and see if it has an inferred range.\n   FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n     {\n       gimple *s = USE_STMT (use_p);\n-      stmt_side_effects se (s);\n-      for (unsigned x = 0; x < se.num (); x++)\n+      gimple_infer_range infer (s);\n+      for (unsigned x = 0; x < infer.num (); x++)\n \t{\n-\t  if (name == se.name (x))\n-\t    add_range (name, gimple_bb (s), se.range (x));\n+\t  if (name == infer.name (x))\n+\t    add_range (name, gimple_bb (s), infer.range (x));\n \t}\n     }\n }", "previous_filename": "gcc/gimple-range-side-effect.cc"}, {"sha": "629436753e9ab109cf1d2a0794ecd5f98d2aa766", "filename": "gcc/gimple-range-infer.h", "status": "renamed", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-infer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range-infer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.h?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -1,4 +1,4 @@\n-/* Header file for gimple range side effects.\n+/* Header file for gimple range inference.\n    Copyright (C) 2022 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod <amacleod@redhat.com>.\n \n@@ -21,15 +21,17 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_RANGE_SIDE_H\n #define GCC_GIMPLE_RANGE_SIDE_H\n \n-// This class manages an on-demand summary of side effects for a statement.\n-// It can be instantiated as required and provides a list of side effects.\n+// Inferred ranges are ranges which are applied to use operands as a by product\n+// of executing an operation.\n \n-// New side effects should added in the constructor of this class.\n+// This class manages an on-demand summary of inferred ranges for a statement.\n+// It can be instantiated as required and provides a list of inferred ranges.\n+// New inferred ranges should added in the constructor of this class.\n \n-class stmt_side_effects\n+class gimple_infer_range\n {\n public:\n-  stmt_side_effects (gimple *s);\n+  gimple_infer_range (gimple *s);\n   inline unsigned num () const { return num_args; }\n   inline tree name (unsigned index) const\n     { gcc_checking_assert (index < num_args); return m_names[index]; }\n@@ -45,17 +47,17 @@ class stmt_side_effects\n   inline void bump_index () { if (num_args < size_limit - 1) num_args++; }\n };\n \n-// This class manages a list of side effect ranges for each basic block.\n-// As side effects are seen, they can be registered to a block and later\n+// This class manages a list of inferred ranges for each basic block.\n+// As inferences are made, they can be registered to a block and later\n // queried.  WHen constructed with a TRUE flag, immediate uses chains are\n // followed the first time a name is referenced and block populated if\n-// thre are any side effects.\n+// there are any inferred ranges.\n \n-class side_effect_manager\n+class infer_range_manager\n {\n public:\n-  side_effect_manager (bool do_search);\n-  ~side_effect_manager ();\n+  infer_range_manager (bool do_search);\n+  ~infer_range_manager ();\n   void add_range (tree name, basic_block bb, const irange &r);\n   void add_nonzero (tree name, basic_block bb);\n   bool has_range_p (tree name, basic_block bb);", "previous_filename": "gcc/gimple-range-side-effect.h"}, {"sha": "08a9c01e91a6aaf18506da7de83e4c24941b334f", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -446,12 +446,11 @@ gimple_ranger::fold_stmt (gimple_stmt_iterator *gsi, tree (*valueize) (tree))\n   return ret;\n }\n \n-// Called during dominator walks to register any side effects that take effect\n-// from this point forward.  Current release is only for tracking non-null\n-// within a block.\n+// Called during dominator walks to register any inferred ranges that take\n+// effect from this point forward.  \n \n void\n-gimple_ranger::register_side_effects (gimple *s)\n+gimple_ranger::register_inferred_ranges (gimple *s)\n {\n   // First, export the LHS if it is a new global range.\n   tree lhs = gimple_get_lhs (s);\n@@ -475,7 +474,7 @@ gimple_ranger::register_side_effects (gimple *s)\n \t  fputc ('\\n', dump_file);\n \t}\n     }\n-  m_cache.apply_side_effects (s);\n+  m_cache.apply_inferred_ranges (s);\n }\n \n // This routine will export whatever global ranges are known to GCC"}, {"sha": "c67280dc1d2fdbd9bdeb2b0ee9c2e55e3e8a60fb", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -60,7 +60,7 @@ class gimple_ranger : public range_query\n   void dump_bb (FILE *f, basic_block bb);\n   auto_edge_flag non_executable_edge_flag;\n   bool fold_stmt (gimple_stmt_iterator *gsi, tree (*) (tree));\n-  void register_side_effects (gimple *s);\n+  void register_inferred_ranges (gimple *s);\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n   void prefill_name (irange &r, tree name);"}, {"sha": "300974fbb7872879c182d680433df2931e791d3f", "filename": "gcc/range-op.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -95,7 +95,7 @@ class range_operator\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n-  // Side effect of relation for generic fold_range clients.\n+  // Effect of relation for generic fold_range clients.\n   virtual bool op1_op2_relation_effect (irange &lhs_range, tree type,\n \t\t\t\t\tconst irange &op1_range,\n \t\t\t\t\tconst irange &op2_range,"}, {"sha": "62ae5a967f3eb35a745d18d09f204812a606d323", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156d7d8dbc8d65d3958486bc4112a7279935e47d/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=156d7d8dbc8d65d3958486bc4112a7279935e47d", "patch": "@@ -4304,7 +4304,7 @@ class rvrp_folder : public substitute_and_fold_engine\n     m_pta->enter (bb);\n     for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n \t gsi_next (&gsi))\n-      m_ranger->register_side_effects (gsi.phi ());\n+      m_ranger->register_inferred_ranges (gsi.phi ());\n   }\n \n   void post_fold_bb (basic_block bb) override\n@@ -4322,7 +4322,7 @@ class rvrp_folder : public substitute_and_fold_engine\n     bool ret = m_simplifier.simplify (gsi);\n     if (!ret)\n       ret = m_ranger->fold_stmt (gsi, follow_single_use_edges);\n-    m_ranger->register_side_effects (gsi_stmt (*gsi));\n+    m_ranger->register_inferred_ranges (gsi_stmt (*gsi));\n     return ret;\n   }\n "}]}