{"sha": "3e948d645bc9086eee28407fcc67d05b3450bb78", "node_id": "C_kwDOANBUbNoAKDNlOTQ4ZDY0NWJjOTA4NmVlZTI4NDA3ZmNjNjdkMDViMzQ1MGJiNzg", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-12T20:52:06Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-12T20:52:06Z"}, "message": "c++: tighten TMPL_ARGS_LEVEL macro\n\nThis patch makes TMPL_ARGS_LEVEL verify the level argument is valid when\nthe one-dimensional vector case.  Doing so uncovered a couple of latent\nissues: in try_class_unification, we weren't correctly copying targs\nwhen it's two-dimensional, and in unify_pack_expansion it seems an\ninequality test needs to be reversed.  This patch fixes both issues, and\nin passing makes the former function free the temporary copy of targs.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (TMPL_ARGS_LEVEL): Assert LEVEL is 1 when\n\tTMPL_ARGS_HAVE_MULTIPLE_LEVELS is false.\n\t* pt.cc (try_class_unification): Correctly copy multidimensional\n\ttargs.  Free the copy of targs.\n\t(unify_pack_expansion): Fix level comparison.", "tree": {"sha": "b455149506a401eb0f8438ebdd7e7c93789fdffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b455149506a401eb0f8438ebdd7e7c93789fdffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e948d645bc9086eee28407fcc67d05b3450bb78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e948d645bc9086eee28407fcc67d05b3450bb78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e948d645bc9086eee28407fcc67d05b3450bb78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e948d645bc9086eee28407fcc67d05b3450bb78/comments", "author": null, "committer": null, "parents": [{"sha": "995060aa5eb85a9a6d06c5cf9e87650522ccee3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/995060aa5eb85a9a6d06c5cf9e87650522ccee3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/995060aa5eb85a9a6d06c5cf9e87650522ccee3f"}], "stats": {"total": 31, "additions": 16, "deletions": 15}, "files": [{"sha": "b2df6fc0ad443b45ad1337bb5c64fa5917d8bcfd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e948d645bc9086eee28407fcc67d05b3450bb78/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e948d645bc9086eee28407fcc67d05b3450bb78/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3e948d645bc9086eee28407fcc67d05b3450bb78", "patch": "@@ -3783,7 +3783,8 @@ struct GTY(()) lang_decl {\n    args is level 1, not level 0.  */\n #define TMPL_ARGS_LEVEL(ARGS, LEVEL)\t\t\\\n   (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (ARGS)\t\\\n-   ? TREE_VEC_ELT (ARGS, (LEVEL) - 1) : (ARGS))\n+   ? TREE_VEC_ELT (ARGS, (LEVEL) - 1)\t\t\\\n+   : (gcc_checking_assert ((LEVEL) == 1), (ARGS)))\n \n /* Set the LEVELth level of the template ARGS to VAL.  This macro does\n    not work with single-level argument vectors.  */"}, {"sha": "fa05e9134dfddc966c06395d7b6aae8c5adfa927", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e948d645bc9086eee28407fcc67d05b3450bb78/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e948d645bc9086eee28407fcc67d05b3450bb78/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=3e948d645bc9086eee28407fcc67d05b3450bb78", "patch": "@@ -23398,8 +23398,6 @@ static tree\n try_class_unification (tree tparms, tree targs, tree parm, tree arg,\n \t\t       bool explain_p)\n {\n-  tree copy_of_targs;\n-\n   if (!CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P (arg))\n     return NULL_TREE;\n   else if (TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n@@ -23438,21 +23436,23 @@ try_class_unification (tree tparms, tree targs, tree parm, tree arg,\n      because there are two ways to unify base classes of S<0, 1, 2>\n      with S<I, I, I>.  If we kept the already deduced knowledge, we\n      would reject the possibility I=1.  */\n-  copy_of_targs = make_tree_vec (TREE_VEC_LENGTH (targs));\n+  targs = copy_template_args (targs);\n+  for (tree& targ : tree_vec_range (INNERMOST_TEMPLATE_ARGS (targs)))\n+    targ = NULL_TREE;\n \n+  int err;\n   if (TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-    {\n-      if (unify_bound_ttp_args (tparms, copy_of_targs, parm, arg, explain_p))\n-\treturn NULL_TREE;\n-      return arg;\n-    }\n+    err = unify_bound_ttp_args (tparms, targs, parm, arg, explain_p);\n+  else\n+    err = unify (tparms, targs, CLASSTYPE_TI_ARGS (parm),\n+\t\t CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE, explain_p);\n \n-  /* If unification failed, we're done.  */\n-  if (unify (tparms, copy_of_targs, CLASSTYPE_TI_ARGS (parm),\n-\t     CLASSTYPE_TI_ARGS (arg), UNIFY_ALLOW_NONE, explain_p))\n-    return NULL_TREE;\n+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (targs))\n+    for (tree level : tree_vec_range (targs))\n+      ggc_free (level);\n+  ggc_free (targs);\n \n-  return arg;\n+  return err ? NULL_TREE : arg;\n }\n \n /* Given a template type PARM and a class type ARG, find the unique\n@@ -23649,7 +23649,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n \n       /* Determine the index and level of this parameter pack.  */\n       template_parm_level_and_index (parm_pack, &level, &idx);\n-      if (level < levels)\n+      if (level > levels)\n \tcontinue;\n \n       /* Keep track of the parameter packs and their corresponding"}]}