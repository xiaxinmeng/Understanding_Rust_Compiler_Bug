{"sha": "bc5baac5c37d8da1931043c4bbeffa3ab93a8e91", "node_id": "C_kwDOANBUbNoAKGJjNWJhYWM1YzM3ZDhkYTE5MzEwNDNjNGJiZWZmYTNhYjkzYThlOTE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-29T15:30:42Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-01T13:24:10Z"}, "message": "Add debug counters to back threader.\n\nChasing down stage3 miscomparisons is never fun, and having no way to\ndistinguish between jump threads registered by a particular\npass, is even harder.  This patch adds debug counters for the individual\nback threading passes.  I've left the ethread pass alone, as that one is\nusually benign, but we could easily add it if needed.\n\nThe fact that we can only pass one boolean argument to the passes\ninfrastructure has us do all sorts of gymnastics to differentiate\nbetween the various back threading passes.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* dbgcnt.def: Add debug counter for back_thread[12] and\n\tback_threadfull[12].\n\t* passes.def: Pass \"first\" argument to each back threading pass.\n\t* tree-ssa-threadbackward.c (back_threader::back_threader): Add\n\tfirst argument.\n\t(back_threader::debug_counter): New.\n\t(back_threader::maybe_register_path): Call debug_counter.", "tree": {"sha": "cb0493f55ce0e4fbb03833490df0b38e972afcb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb0493f55ce0e4fbb03833490df0b38e972afcb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e0f56d7af9dd58f74d67f9cb303936ef595cdf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6"}], "stats": {"total": 84, "additions": 73, "deletions": 11}, "files": [{"sha": "3a85665a1d77c3f039f85ea85e6ad23d456b6603", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=bc5baac5c37d8da1931043c4bbeffa3ab93a8e91", "patch": "@@ -144,6 +144,10 @@ echo ubound: $ub\n    Please keep the list sorted in alphabetic order.  */\n DEBUG_COUNTER (asan_use_after_scope)\n DEBUG_COUNTER (auto_inc_dec)\n+DEBUG_COUNTER (back_thread1)\n+DEBUG_COUNTER (back_thread2)\n+DEBUG_COUNTER (back_threadfull1)\n+DEBUG_COUNTER (back_threadfull2)\n DEBUG_COUNTER (ccp)\n DEBUG_COUNTER (cfg_cleanup)\n DEBUG_COUNTER (cprop)"}, {"sha": "0f541454e7f11f85815bfe0be1b951d3ee9bdd56", "filename": "gcc/passes.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=bc5baac5c37d8da1931043c4bbeffa3ab93a8e91", "patch": "@@ -81,7 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  /* After CCP we rewrite no longer addressed locals into SSA\n \t     form if possible.  */\n \t  NEXT_PASS (pass_forwprop);\n-          NEXT_PASS (pass_early_thread_jumps);\n+          NEXT_PASS (pass_early_thread_jumps, /*first=*/true);\n \t  NEXT_PASS (pass_sra_early);\n \t  /* pass_build_ealias is a dummy pass that ensures that we\n \t     execute TODO_rebuild_alias at this point.  */\n@@ -210,7 +210,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_return_slot);\n       NEXT_PASS (pass_fre, true /* may_iterate */);\n       NEXT_PASS (pass_merge_phi);\n-      NEXT_PASS (pass_thread_jumps_full);\n+      NEXT_PASS (pass_thread_jumps_full, /*first=*/true);\n       NEXT_PASS (pass_vrp, true /* warn_array_bounds_p */);\n       NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_dce);\n@@ -233,7 +233,7 @@ along with GCC; see the file COPYING3.  If not see\n \t propagations have already run, but before some more dead code\n \t is removed, and this place fits nicely.  Remember this when\n \t trying to move or duplicate pass_dominator somewhere earlier.  */\n-      NEXT_PASS (pass_thread_jumps);\n+      NEXT_PASS (pass_thread_jumps, /*first=*/true);\n       NEXT_PASS (pass_dominator, true /* may_peel_loop_headers_p */);\n       /* Threading can leave many const/copy propagations in the IL.\n \t Clean them up.  Failure to do so well can lead to false\n@@ -332,10 +332,10 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_fre, false /* may_iterate */);\n       /* After late FRE we rewrite no longer addressed locals into SSA\n          form if possible.  */\n-      NEXT_PASS (pass_thread_jumps);\n+      NEXT_PASS (pass_thread_jumps, /*first=*/false);\n       NEXT_PASS (pass_dominator, false /* may_peel_loop_headers_p */);\n       NEXT_PASS (pass_strlen);\n-      NEXT_PASS (pass_thread_jumps_full);\n+      NEXT_PASS (pass_thread_jumps_full, /*first=*/false);\n       NEXT_PASS (pass_vrp, false /* warn_array_bounds_p */);\n       /* Run CCP to compute alignment and nonzero bits.  */\n       NEXT_PASS (pass_ccp, true /* nonzero_p */);"}, {"sha": "29e9d6a3f90f63730e23cde392ff24932260ea0b", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 64, "deletions": 6, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5baac5c37d8da1931043c4bbeffa3ab93a8e91/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=bc5baac5c37d8da1931043c4bbeffa3ab93a8e91", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfgcleanup.h\"\n #include \"tree-pretty-print.h\"\n #include \"cfghooks.h\"\n+#include \"dbgcnt.h\"\n \n // Path registry for the backwards threader.  After all paths have been\n // registered with register_path(), thread_through_all_blocks() is called\n@@ -80,12 +81,13 @@ class back_threader_profitability\n class back_threader\n {\n public:\n-  back_threader (function *fun, unsigned flags);\n+  back_threader (function *fun, unsigned flags, bool first);\n   ~back_threader ();\n   unsigned thread_blocks ();\n private:\n   void maybe_thread_block (basic_block bb);\n   void find_paths (basic_block bb, tree name);\n+  bool debug_counter ();\n   edge maybe_register_path ();\n   bool find_paths_to_names (basic_block bb, bitmap imports);\n   bool resolve_def (tree name, bitmap interesting, vec<tree> &worklist);\n@@ -120,14 +122,19 @@ class back_threader\n   // VARYING.  Setting to true is more precise but slower.\n   function *m_fun;\n   unsigned m_flags;\n+  // Set to TRUE for the first of each thread[12] pass or the first of\n+  // each threadfull[12] pass.  This is used to differentiate between\n+  // the different threading passes so we can set up debug counters.\n+  bool m_first;\n };\n \n // Used to differentiate unreachable edges, so we may stop the search\n // in a the given direction.\n const edge back_threader::UNREACHABLE_EDGE = (edge) -1;\n \n-back_threader::back_threader (function *fun, unsigned flags)\n-  : m_profit (flags & BT_SPEED)\n+back_threader::back_threader (function *fun, unsigned flags, bool first)\n+  : m_profit (flags & BT_SPEED),\n+    m_first (first)\n {\n   if (flags & BT_SPEED)\n     loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);\n@@ -149,6 +156,36 @@ back_threader::~back_threader ()\n   loop_optimizer_finalize ();\n }\n \n+// A wrapper for the various debug counters for the threading passes.\n+// Returns TRUE if it's OK to register the current threading\n+// candidate.\n+\n+bool\n+back_threader::debug_counter ()\n+{\n+  // The ethread pass is mostly harmless ;-).\n+  if ((m_flags & BT_SPEED) == 0)\n+    return true;\n+\n+  if (m_flags & BT_RESOLVE)\n+    {\n+      if (m_first && !dbg_cnt (back_threadfull1))\n+\treturn false;\n+\n+      if (!m_first && !dbg_cnt (back_threadfull2))\n+\treturn false;\n+    }\n+  else\n+    {\n+      if (m_first && !dbg_cnt (back_thread1))\n+\treturn false;\n+\n+      if (!m_first && !dbg_cnt (back_thread2))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n // Register the current path for jump threading if it's profitable to\n // do so.\n //\n@@ -172,6 +209,9 @@ back_threader::maybe_register_path ()\n \n       if (profitable)\n \t{\n+\t  if (!debug_counter ())\n+\t    return NULL;\n+\n \t  m_registry.register_path (m_path, taken_edge);\n \n \t  if (irreducible)\n@@ -973,15 +1013,21 @@ class pass_early_thread_jumps : public gimple_opt_pass\n   {\n     return new pass_early_thread_jumps (m_ctxt);\n   }\n+  void set_pass_param (unsigned int, bool param) override\n+  {\n+    m_first = param;\n+  }\n   bool gate (function *) override\n   {\n     return flag_thread_jumps;\n   }\n   unsigned int execute (function *fun) override\n   {\n-    back_threader threader (fun, BT_NONE);\n+    back_threader threader (fun, BT_NONE, m_first);\n     return threader.thread_blocks ();\n   }\n+private:\n+  bool m_first;\n };\n \n // Jump threading pass without resolving of unknown SSAs.\n@@ -995,15 +1041,21 @@ class pass_thread_jumps : public gimple_opt_pass\n   {\n     return new pass_thread_jumps (m_ctxt);\n   }\n+  void set_pass_param (unsigned int, bool param) override\n+  {\n+    m_first = param;\n+  }\n   bool gate (function *) override\n   {\n     return flag_thread_jumps && flag_expensive_optimizations;\n   }\n   unsigned int execute (function *fun) override\n   {\n-    back_threader threader (fun, BT_SPEED);\n+    back_threader threader (fun, BT_SPEED, m_first);\n     return threader.thread_blocks ();\n   }\n+private:\n+  bool m_first;\n };\n \n // Jump threading pass that fully resolves unknown SSAs.\n@@ -1017,15 +1069,21 @@ class pass_thread_jumps_full : public gimple_opt_pass\n   {\n     return new pass_thread_jumps_full (m_ctxt);\n   }\n+  void set_pass_param (unsigned int, bool param) override\n+  {\n+    m_first = param;\n+  }\n   bool gate (function *) override\n   {\n     return flag_thread_jumps && flag_expensive_optimizations;\n   }\n   unsigned int execute (function *fun) override\n   {\n-    back_threader threader (fun, BT_SPEED | BT_RESOLVE);\n+    back_threader threader (fun, BT_SPEED | BT_RESOLVE, m_first);\n     return threader.thread_blocks ();\n   }\n+private:\n+  bool m_first;\n };\n \n } // namespace {"}]}