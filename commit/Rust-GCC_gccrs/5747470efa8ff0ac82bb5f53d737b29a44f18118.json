{"sha": "5747470efa8ff0ac82bb5f53d737b29a44f18118", "node_id": "C_kwDOANBUbNoAKDU3NDc0NzBlZmE4ZmYwYWM4MmJiNWY1M2Q3MzdiMjlhNDRmMTgxMTg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:36:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:40:48Z"}, "message": "range-op: Cleanup floating point multiplication and division fold_range [PR107569]\n\nAdmittedly there are many similar spots with the foperator_div case\n(but also with significant differences), so perhaps if foperator_{mult,div}\ninherit from some derived class from range_operator_float and that class\nwould define various smaller helper static? methods, like this\ndiscussed in the PR - contains_zero_p, singleton_nan_p, zero_p,\nthat\n+           bool must_have_signbit_zero = false;\n+           bool must_have_signbit_nonzero = false;\n+           if (real_isneg (&lh_lb) == real_isneg (&lh_ub)\n+               && real_isneg (&rh_lb) == real_isneg (&rh_ub))\n+             {\n+               if (real_isneg (&lh_lb) == real_isneg (&rh_ub))\n+                 must_have_signbit_zero = true;\n+               else\n+                 must_have_signbit_nonzero = true;\n+             }\nreturned as -1/0/1 int, and those set result (based on the above value) to\n[+INF, +INF], [-INF, -INF] or [-INF, +INF]\nor\n[+0, +0], [-0, -0] or [-0, +0]\nor\n[+0, +INF], [-INF, -0] or [-INF, +INF]\nand the\n+    for (int i = 1; i < 4; ++i)\n+      {\n+       if (real_less (&cp[i], &cp[0])\n+           || (real_iszero (&cp[0]) && real_isnegzero (&cp[i])))\n+         std::swap (cp[i], cp[0]);\n+       if (real_less (&cp[4], &cp[i + 4])\n+           || (real_isnegzero (&cp[4]) && real_iszero (&cp[i + 4])))\n+         std::swap (cp[i + 4], cp[4]);\n+      }\nblock, it could be smaller and more readable.\n\n2022-11-12  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/107569\n\t* range-op-float.cc (zero_p, contains_p, singleton_inf_p,\n\tsignbit_known_p, zero_range, inf_range, zero_to_inf_range): New\n\tfunctions.\n\t(foperator_mult_div_base): New class.\n\t(foperator_mult, foperator_div): Derive from that and use\n\tprotected static method from it as well as above new functions\n\tto simplify the code.", "tree": {"sha": "deda4419d16ed0b672b023d354e760e21556501c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deda4419d16ed0b672b023d354e760e21556501c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5747470efa8ff0ac82bb5f53d737b29a44f18118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5747470efa8ff0ac82bb5f53d737b29a44f18118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5747470efa8ff0ac82bb5f53d737b29a44f18118", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5747470efa8ff0ac82bb5f53d737b29a44f18118/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5c4a16dd833aa083f13dd3e78e3ef38afe6ebb"}], "stats": {"total": 353, "additions": 157, "deletions": 196}, "files": [{"sha": "91185c5dc79085a9ea6e98b4373f2cd24d0ab176", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 157, "deletions": 196, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5747470efa8ff0ac82bb5f53d737b29a44f18118/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5747470efa8ff0ac82bb5f53d737b29a44f18118/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=5747470efa8ff0ac82bb5f53d737b29a44f18118", "patch": "@@ -1861,6 +1861,98 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n   return true;\n }\n \n+// True if [lb, ub] is [+-0, +-0].\n+static bool\n+zero_p (const REAL_VALUE_TYPE &lb, const REAL_VALUE_TYPE &ub)\n+{\n+  return real_iszero (&lb) && real_iszero (&ub);\n+}\n+\n+// True if +0 or -0 is in [lb, ub] range.\n+static bool\n+contains_zero_p (const REAL_VALUE_TYPE &lb, const REAL_VALUE_TYPE &ub)\n+{\n+  return (real_compare (LE_EXPR, &lb, &dconst0)\n+\t  && real_compare (GE_EXPR, &ub, &dconst0));\n+}\n+\n+// True if [lb, ub] is [-INF, -INF] or [+INF, +INF].\n+static bool\n+singleton_inf_p (const REAL_VALUE_TYPE &lb, const REAL_VALUE_TYPE &ub)\n+{\n+  return real_isinf (&lb) && real_isinf (&ub, real_isneg (&lb));\n+}\n+\n+// Return -1 if binary op result must have sign bit set,\n+// 1 if binary op result must have sign bit clear,\n+// 0 otherwise.\n+// Sign bit of binary op result is exclusive or of the\n+// operand's sign bits.\n+static int\n+signbit_known_p (const REAL_VALUE_TYPE &lh_lb, const REAL_VALUE_TYPE &lh_ub,\n+\t\t const REAL_VALUE_TYPE &rh_lb, const REAL_VALUE_TYPE &rh_ub)\n+{\n+  if (real_isneg (&lh_lb) == real_isneg (&lh_ub)\n+      && real_isneg (&rh_lb) == real_isneg (&rh_ub))\n+    {\n+      if (real_isneg (&lh_lb) == real_isneg (&rh_ub))\n+\treturn 1;\n+      else\n+\treturn -1;\n+    }\n+  return 0;\n+}\n+\n+// Set [lb, ub] to [-0, -0], [-0, +0] or [+0, +0] depending on\n+// signbit_known.\n+static void\n+zero_range (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, int signbit_known)\n+{\n+  ub = lb = dconst0;\n+  if (signbit_known <= 0)\n+    lb = real_value_negate (&dconst0);\n+  if (signbit_known < 0)\n+    ub = lb;\n+}\n+\n+// Set [lb, ub] to [-INF, -INF], [-INF, +INF] or [+INF, +INF] depending on\n+// signbit_known.\n+static void\n+inf_range (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, int signbit_known)\n+{\n+  if (signbit_known > 0)\n+    ub = lb = dconstinf;\n+  else if (signbit_known < 0)\n+    ub = lb = dconstninf;\n+  else\n+    {\n+      lb = dconstninf;\n+      ub = dconstinf;\n+    }\n+}\n+\n+// Set [lb, ub] to [-INF, -0], [-INF, +INF] or [+0, +INF] depending on\n+// signbit_known.\n+static void\n+zero_to_inf_range (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, int signbit_known)\n+{\n+  if (signbit_known > 0)\n+    {\n+      lb = dconst0;\n+      ub = dconstinf;\n+    }\n+  else if (signbit_known < 0)\n+    {\n+      lb = dconstninf;\n+      ub = real_value_negate (&dconst0);\n+    }\n+  else\n+    {\n+      lb = dconstninf;\n+      ub = dconstinf;\n+    }\n+}\n+\n class foperator_plus : public range_operator_float\n {\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n@@ -1911,7 +2003,32 @@ class foperator_minus : public range_operator_float\n } fop_minus;\n \n \n-class foperator_mult : public range_operator_float\n+class foperator_mult_div_base : public range_operator_float\n+{\n+protected:\n+  // Given CP[0] to CP[3] floating point values rounded to -INF,\n+  // set LB to the smallest of them (treating -0 as smaller to +0).\n+  // Given CP[4] to CP[7] floating point values rounded to +INF,\n+  // set UB to the largest of them (treating -0 as smaller to +0).\n+  static void find_range (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub,\n+\t\t\t  const REAL_VALUE_TYPE (&cp)[8])\n+  {\n+    lb = cp[0];\n+    ub = cp[4];\n+    for (int i = 1; i < 4; ++i)\n+      {\n+\tif (real_less (&cp[i], &lb)\n+\t    || (real_iszero (&lb) && real_isnegzero (&cp[i])))\n+\t  lb = cp[i];\n+\tif (real_less (&ub, &cp[i + 4])\n+\t    || (real_isnegzero (&ub) && real_iszero (&cp[i + 4])))\n+\t  ub = cp[i + 4];\n+      }\n+  }\n+};\n+\n+\n+class foperator_mult : public foperator_mult_div_base\n {\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n \t\ttree type,\n@@ -1934,14 +2051,8 @@ class foperator_mult : public range_operator_float\n     if (!is_square)\n       {\n \t// [+-0, +-0] * [+INF,+INF] (or [-INF,-INF] or swapped is a known NAN.\n-\tif ((real_iszero (&lh_lb)\n-\t     && real_iszero (&lh_ub)\n-\t     && real_isinf (&rh_lb)\n-\t     && real_isinf (&rh_ub, real_isneg (&rh_lb)))\n-\t    || (real_iszero (&rh_lb)\n-\t\t&& real_iszero (&rh_ub)\n-\t\t&& real_isinf (&lh_lb)\n-\t\t&& real_isinf (&lh_ub, real_isneg (&lh_lb))))\n+\tif ((zero_p (lh_lb, lh_ub) && singleton_inf_p (rh_lb, rh_ub))\n+\t    || (zero_p (rh_lb, rh_ub) && singleton_inf_p (lh_lb, lh_ub)))\n \t  {\n \t    real_nan (&lb, \"\", 0, TYPE_MODE (type));\n \t    ub = lb;\n@@ -1951,98 +2062,42 @@ class foperator_mult : public range_operator_float\n \n \t// Otherwise, if one range includes zero and the other ends with +-INF,\n \t// it is a maybe NAN.\n-\tif ((real_compare (LE_EXPR, &lh_lb, &dconst0)\n-\t     && real_compare (GE_EXPR, &lh_ub, &dconst0)\n+\tif ((contains_zero_p (lh_lb, lh_ub)\n \t     && (real_isinf (&rh_lb) || real_isinf (&rh_ub)))\n-\t    || (real_compare (LE_EXPR, &rh_lb, &dconst0)\n-\t\t&& real_compare (GE_EXPR, &rh_ub, &dconst0)\n+\t    || (contains_zero_p (rh_lb, rh_ub)\n \t\t&& (real_isinf (&lh_lb) || real_isinf (&lh_ub))))\n \t  {\n \t    maybe_nan = true;\n \n-\t    bool must_have_signbit_zero = false;\n-\t    bool must_have_signbit_nonzero = false;\n-\t    if (real_isneg (&lh_lb) == real_isneg (&lh_ub)\n-\t\t&& real_isneg (&rh_lb) == real_isneg (&rh_ub))\n-\t      {\n-\t\tif (real_isneg (&lh_lb) == real_isneg (&rh_ub))\n-\t\t  must_have_signbit_zero = true;\n-\t\telse\n-\t\t  must_have_signbit_nonzero = true;\n-\t      }\n+\t    int signbit_known = signbit_known_p (lh_lb, lh_ub, rh_lb, rh_ub);\n \n \t    // If one of the ranges that includes INF is singleton\n \t    // and the other range includes zero, the resulting\n \t    // range is INF and NAN, because the 0 * INF boundary\n \t    // case will be NAN, but already nextafter (0, 1) * INF\n \t    // is INF.\n-\t    if ((real_isinf (&lh_lb)\n-\t\t && real_isinf (&lh_ub, real_isneg (&lh_lb)))\n-\t\t|| (real_isinf (&rh_lb)\n-\t\t    && real_isinf (&rh_ub, real_isneg (&rh_lb))))\n-\t      {\n-\t\t// If all the boundary signs are the same, [+INF, +INF].\n-\t\tif (must_have_signbit_zero)\n-\t\t  ub = lb = dconstinf;\n-\t\t// If the two multiplicands have always different sign,\n-\t\t// [-INF, -INF].\n-\t\telse if (must_have_signbit_nonzero)\n-\t\t  ub = lb = dconstninf;\n-\t\t// Otherwise -> [-INF, +INF] (-INF or +INF).\n-\t\telse\n-\t\t  {\n-\t\t    lb = dconstninf;\n-\t\t    ub = dconstinf;\n-\t\t  }\n-\t\treturn;\n-\t      }\n+\t    if (singleton_inf_p (lh_lb, lh_ub)\n+\t\t|| singleton_inf_p (rh_lb, rh_ub))\n+\t      return inf_range (lb, ub, signbit_known);\n \n \t    // If one of the multiplicands must be zero, the resulting\n \t    // range is +-0 and NAN.\n-\t    if ((real_iszero (&lh_lb) && real_iszero (&lh_ub))\n-\t\t|| (real_iszero (&rh_lb) && real_iszero (&rh_ub)))\n-\t      {\n-\t\tub = lb = dconst0;\n-\t\t// If all the boundary signs are the same, [+0.0, +0.0].\n-\t\tif (must_have_signbit_zero)\n-\t\t  ;\n-\t\t// If divisor and dividend must have different signs,\n-\t\t// [-0.0, -0.0].\n-\t\telse if (must_have_signbit_nonzero)\n-\t\t  ub = lb = real_value_negate (&dconst0);\n-\t\t// Otherwise -> [-0.0, +0.0].\n-\t\telse\n-\t\t  lb = real_value_negate (&dconst0);\n-\t\treturn;\n-\t      }\n+\t    if (zero_p (lh_lb, lh_ub) || zero_p (rh_lb, rh_ub))\n+\t      return zero_range (lb, ub, signbit_known);\n \n \t    // Otherwise one of the multiplicands could be\n \t    // [0.0, nextafter (0.0, 1.0)] and the [DBL_MAX, INF]\n \t    // or similarly with different signs.  0.0 * DBL_MAX\n \t    // is still 0.0, nextafter (0.0, 1.0) * INF is still INF,\n \t    // so if the signs are always the same or always different,\n \t    // result is [+0.0, +INF] or [-INF, -0.0], otherwise VARYING.\n-\t    if (must_have_signbit_zero)\n-\t      {\n-\t\tlb = dconst0;\n-\t\tub = dconstinf;\n-\t      }\n-\t    else if (must_have_signbit_nonzero)\n-\t      {\n-\t\tlb = dconstninf;\n-\t\tub = real_value_negate (&dconst0);\n-\t      }\n-\t    else\n-\t      {\n-\t\tlb = dconstninf;\n-\t\tub = dconstinf;\n-\t      }\n-\t    return;\n+\t    return zero_to_inf_range (lb, ub, signbit_known);\n \t  }\n       }\n \n     REAL_VALUE_TYPE cp[8];\n-    // Do a cross-product.\n+    // Do a cross-product.  At this point none of the multiplications\n+    // should produce a NAN.\n     frange_arithmetic (MULT_EXPR, type, cp[0], lh_lb, rh_lb, dconstninf);\n     frange_arithmetic (MULT_EXPR, type, cp[4], lh_lb, rh_lb, dconstinf);\n     if (is_square)\n@@ -2052,9 +2107,13 @@ class foperator_mult : public range_operator_float\n \t// otherwise min (lh_lb * lh_lb, lh_ub * lh_ub).\n \t// -0.0 rather than 0.0 because VREL_EQ doesn't prove that\n \t// x and y are bitwise equal, just that they compare equal.\n-\tif (real_compare (LE_EXPR, &lh_lb, &dconst0)\n-\t    && real_compare (GE_EXPR, &lh_ub, &dconst0))\n-\t  cp[1] = real_value_negate (&dconst0);\n+\tif (contains_zero_p (lh_lb, lh_ub))\n+\t  {\n+\t    if (real_isneg (&lh_lb) == real_isneg (&lh_ub))\n+\t      cp[1] = dconst0;\n+\t    else\n+\t      cp[1] = real_value_negate (&dconst0);\n+\t  }\n \telse\n \t  cp[1] = cp[0];\n \tcp[2] = cp[0];\n@@ -2071,22 +2130,12 @@ class foperator_mult : public range_operator_float\n     frange_arithmetic (MULT_EXPR, type, cp[3], lh_ub, rh_ub, dconstninf);\n     frange_arithmetic (MULT_EXPR, type, cp[7], lh_ub, rh_ub, dconstinf);\n \n-    for (int i = 1; i < 4; ++i)\n-      {\n-\tif (real_less (&cp[i], &cp[0])\n-\t    || (real_iszero (&cp[0]) && real_isnegzero (&cp[i])))\n-\t  std::swap (cp[i], cp[0]);\n-\tif (real_less (&cp[4], &cp[i + 4])\n-\t    || (real_isnegzero (&cp[4]) && real_iszero (&cp[i + 4])))\n-\t  std::swap (cp[i + 4], cp[4]);\n-      }\n-    lb = cp[0];\n-    ub = cp[4];\n-\n+    find_range (lb, ub, cp);\n   }\n } fop_mult;\n \n-class foperator_div : public range_operator_float\n+\n+class foperator_div : public foperator_mult_div_base\n {\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n \t\ttree type,\n@@ -2097,99 +2146,40 @@ class foperator_div : public range_operator_float\n \t\trelation_kind) const final override\n   {\n     // +-0.0 / +-0.0 or +-INF / +-INF is a known NAN.\n-    if ((real_iszero (&lh_lb)\n-\t && real_iszero (&lh_ub)\n-\t && real_iszero (&rh_lb)\n-\t && real_iszero (&rh_ub))\n-\t|| (real_isinf (&lh_lb)\n-\t    && real_isinf (&lh_ub, real_isneg (&lh_lb))\n-\t    && real_isinf (&rh_lb)\n-\t    && real_isinf (&rh_ub, real_isneg (&rh_lb))))\n+    if ((zero_p (lh_lb, lh_ub) && zero_p (rh_lb, rh_ub))\n+\t|| (singleton_inf_p (lh_lb, lh_ub) || singleton_inf_p (rh_lb, rh_ub)))\n       {\n \treal_nan (&lb, \"\", 0, TYPE_MODE (type));\n \tub = lb;\n \tmaybe_nan = true;\n \treturn;\n       }\n \n-    bool both_maybe_zero = false;\n-    bool both_maybe_inf = false;\n-    bool must_have_signbit_zero = false;\n-    bool must_have_signbit_nonzero = false;\n-\n     // If +-0.0 is in both ranges, it is a maybe NAN.\n-    if (real_compare (LE_EXPR, &lh_lb, &dconst0)\n-\t&& real_compare (GE_EXPR, &lh_ub, &dconst0)\n-\t&& real_compare (LE_EXPR, &rh_lb, &dconst0)\n-\t&& real_compare (GE_EXPR, &rh_ub, &dconst0))\n-      {\n-\tboth_maybe_zero = true;\n-\tmaybe_nan = true;\n-      }\n+    if (contains_zero_p (lh_lb, lh_ub) && contains_zero_p (rh_lb, rh_ub))\n+      maybe_nan = true;\n     // If +-INF is in both ranges, it is a maybe NAN.\n     else if ((real_isinf (&lh_lb) || real_isinf (&lh_ub))\n \t     && (real_isinf (&rh_lb) || real_isinf (&rh_ub)))\n-      {\n-\tboth_maybe_inf = true;\n-\tmaybe_nan = true;\n-      }\n+      maybe_nan = true;\n     else\n       maybe_nan = false;\n \n-    if (real_isneg (&lh_lb) == real_isneg (&lh_ub)\n-\t&& real_isneg (&rh_lb) == real_isneg (&rh_ub))\n-      {\n-\tif (real_isneg (&lh_lb) == real_isneg (&rh_ub))\n-\t  must_have_signbit_zero = true;\n-\telse\n-\t  must_have_signbit_nonzero = true;\n-      }\n+    int signbit_known = signbit_known_p (lh_lb, lh_ub, rh_lb, rh_ub);\n \n     // If dividend must be zero, the range is just +-0\n     // (including if the divisor is +-INF).\n     // If divisor must be +-INF, the range is just +-0\n     // (including if the dividend is zero).\n-    if ((real_iszero (&lh_lb) && real_iszero (&lh_ub))\n-\t|| real_isinf (&rh_lb, false)\n-\t|| real_isinf (&rh_ub, true))\n-      {\n-\tub = lb = dconst0;\n-\t// If all the boundary signs are the same, [+0.0, +0.0].\n-\tif (must_have_signbit_zero)\n-\t  ;\n-\t// If divisor and dividend must have different signs,\n-\t// [-0.0, -0.0].\n-\telse if (must_have_signbit_nonzero)\n-\t  ub = lb = real_value_negate (&dconst0);\n-\t// Otherwise -> [-0.0, +0.0].\n-\telse\n-\t  lb = real_value_negate (&dconst0);\n-\treturn;\n-      }\n+    if (zero_p (lh_lb, lh_ub) || singleton_inf_p (rh_lb, rh_ub))\n+      return zero_range (lb, ub, signbit_known);\n \n     // If divisor must be zero, the range is just +-INF\n     // (including if the dividend is +-INF).\n     // If dividend must be +-INF, the range is just +-INF\n     // (including if the dividend is zero).\n-    if ((real_iszero (&rh_lb) && real_iszero (&rh_ub))\n-\t|| real_isinf (&lh_lb, false)\n-\t|| real_isinf (&lh_ub, true))\n-      {\n-\t// If all the boundary signs are the same, [+INF, +INF].\n-\tif (must_have_signbit_zero)\n-\t  ub = lb = dconstinf;\n-\t// If divisor and dividend must have different signs,\n-\t// [-INF, -INF].\n-\telse if (must_have_signbit_nonzero)\n-\t  ub = lb = dconstninf;\n-\t// Otherwise -> [-INF, +INF] (-INF or +INF).\n-\telse\n-\t  {\n-\t    lb = dconstninf;\n-\t    ub = dconstinf;\n-\t  }\n-\treturn;\n-      }\n+    if (zero_p (rh_lb, rh_ub) || singleton_inf_p (lh_lb, lh_ub))\n+      return inf_range (lb, ub, signbit_known);\n \n     // Otherwise if both operands may be zero, divisor could be\n     // nextafter(0.0, +-1.0) and dividend +-0.0\n@@ -2204,30 +2194,12 @@ class foperator_div : public range_operator_float\n     // signs of divisor and dividend are always the same we have\n     // [+0.0, +INF], if they are always different we have\n     // [-INF, -0.0].  If they vary, VARYING.\n-    if (both_maybe_zero || both_maybe_inf)\n-      {\n-\tif (must_have_signbit_zero)\n-\t  {\n-\t    lb = dconst0;\n-\t    ub = dconstinf;\n-\t  }\n-\telse if (must_have_signbit_nonzero)\n-\t  {\n-\t    lb = dconstninf;\n-\t    ub = real_value_negate (&dconst0);\n-\t  }\n-\telse\n-\t  {\n-\t    lb = dconstninf;\n-\t    ub = dconstinf;\n-\t  }\n-\treturn;\n-      }\n+    if (maybe_nan)\n+      return zero_to_inf_range (lb, ub, signbit_known);\n \n     REAL_VALUE_TYPE cp[8];\n     // Do a cross-division.  At this point none of the divisions should\n     // produce a NAN.\n-    gcc_assert (!maybe_nan);\n     frange_arithmetic (RDIV_EXPR, type, cp[0], lh_lb, rh_lb, dconstninf);\n     frange_arithmetic (RDIV_EXPR, type, cp[1], lh_lb, rh_ub, dconstninf);\n     frange_arithmetic (RDIV_EXPR, type, cp[2], lh_ub, rh_lb, dconstninf);\n@@ -2237,27 +2209,16 @@ class foperator_div : public range_operator_float\n     frange_arithmetic (RDIV_EXPR, type, cp[6], lh_ub, rh_lb, dconstinf);\n     frange_arithmetic (RDIV_EXPR, type, cp[7], lh_ub, rh_ub, dconstinf);\n \n-    for (int i = 1; i < 4; ++i)\n-      {\n-\tif (real_less (&cp[i], &cp[0])\n-\t    || (real_iszero (&cp[0]) && real_isnegzero (&cp[i])))\n-\t  std::swap (cp[i], cp[0]);\n-\tif (real_less (&cp[4], &cp[i + 4])\n-\t    || (real_isnegzero (&cp[4]) && real_iszero (&cp[i + 4])))\n-\t  std::swap (cp[i + 4], cp[4]);\n-      }\n-    lb = cp[0];\n-    ub = cp[4];\n+    find_range (lb, ub, cp);\n \n     // If divisor may be zero (but is not known to be only zero),\n     // and dividend can't be zero, the range can go up to -INF or +INF\n     // depending on the signs.\n-    if (real_compare (LE_EXPR, &rh_lb, &dconst0)\n-\t&& real_compare (GE_EXPR, &rh_ub, &dconst0))\n+    if (contains_zero_p (rh_lb, rh_ub))\n       {\n-\tif (!must_have_signbit_zero)\n+\tif (signbit_known <= 0)\n \t  real_inf (&lb, true);\n-\tif (!must_have_signbit_nonzero)\n+\tif (signbit_known >= 0)\n \t  real_inf (&ub, false);\n       }\n   }"}]}