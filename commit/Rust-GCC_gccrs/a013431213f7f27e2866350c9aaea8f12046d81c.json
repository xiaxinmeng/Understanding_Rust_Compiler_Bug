{"sha": "a013431213f7f27e2866350c9aaea8f12046d81c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxMzQzMTIxM2Y3ZjI3ZTI4NjYzNTBjOWFhZWE4ZjEyMDQ2ZDgxYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-01-16T01:06:33Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-01-16T01:06:33Z"}, "message": "gcse.c (one_cprop_pass): Change function arguments to take both cprop_jumps and bypass_jumps flags...\n\n\n\t* gcse.c (one_cprop_pass): Change function arguments to take both\n\tcprop_jumps and bypass_jumps flags instead of just alter_jumps.\n\t(gcse_main): Update calls to one_cprop_pass, disabling bypassing.\n\t(bypass_jumps): New function to perform separate jump bypassing pass.\n\t* rtl.h (bypass_jumps): Add function prototype.\n\t* timevar.def (TV_BYPASS): New timing variable.\n\t* toplev.c (enum dump_file_index): Add new entry DFI_bypass.\n\t(dump_file): New entry for the bypass RTL dump file.\n\t(rest_of_compilation): Insert new jump bypassing optimization\n\tpass after loop.\n\t* doc/passes.texi: Document new pass.\n\nFrom-SVN: r61374", "tree": {"sha": "2ecda5f756d588f0c8e2d12fbf3426b2b6eb164e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ecda5f756d588f0c8e2d12fbf3426b2b6eb164e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a013431213f7f27e2866350c9aaea8f12046d81c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a013431213f7f27e2866350c9aaea8f12046d81c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a013431213f7f27e2866350c9aaea8f12046d81c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a013431213f7f27e2866350c9aaea8f12046d81c/comments", "author": null, "committer": null, "parents": [{"sha": "6b543e86f4a765f6a0b7be90e393b9a772c22a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b543e86f4a765f6a0b7be90e393b9a772c22a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b543e86f4a765f6a0b7be90e393b9a772c22a52"}], "stats": {"total": 194, "additions": 179, "deletions": 15}, "files": [{"sha": "a98b2b356e865104747830d7be418d8780b83575", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a013431213f7f27e2866350c9aaea8f12046d81c", "patch": "@@ -1,3 +1,17 @@\n+2003-01-15  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcse.c (one_cprop_pass): Change function arguments to take both\n+\tcprop_jumps and bypass_jumps flags instead of just alter_jumps.\n+\t(gcse_main): Update calls to one_cprop_pass, disabling bypassing.\n+\t(bypass_jumps): New function to perform separate jump bypassing pass.\n+\t* rtl.h (bypass_jumps): Add function prototype.\n+\t* timevar.def (TV_BYPASS): New timing variable.\n+\t* toplev.c (enum dump_file_index): Add new entry DFI_bypass.\n+\t(dump_file): New entry for the bypass RTL dump file.\n+\t(rest_of_compilation): Insert new jump bypassing optimization\n+\tpass after loop.\n+\t* doc/passes.texi: Document new pass.\n+\n 2003-01-15  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* som.h (SUPPORTS_WEAK, SUPPORTS_ONE_ONLY, MAKE_DECL_ONE_ONLY,"}, {"sha": "fe0fc2e086b3342f6e8fb28cdff2520de9d0ffee", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=a013431213f7f27e2866350c9aaea8f12046d81c", "patch": "@@ -1,5 +1,5 @@\n-@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2002,\n-@c 1999, 2000, 2001 Free Software Foundation, Inc.\n+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+@c 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -338,6 +338,19 @@ The option @option{-dL} causes a debugging dump of the RTL code after\n this pass.  This dump file's name is made by appending @samp{.loop} to\n the input file name.\n \n+@cindex jump bypassing\n+@item\n+Jump bypassing.  This pass is an aggressive form of GCSE that transforms\n+the control flow graph of a function by propagating constants into\n+conditional branch instructions.\n+\n+The source file for this pass is @file{gcse.c}.\n+\n+@opindex dG\n+The option @option{-dG} causes a debugging dump of the RTL code after\n+this pass.  This dump file's name is made by appending @samp{.bypass}\n+to the input file name.\n+\n @item\n @opindex frerun-cse-after-loop\n If @option{-frerun-cse-after-loop} was enabled, a second common"}, {"sha": "e8976cbe74d1439a9cf55261899097e74c10f3c0", "filename": "gcc/gcse.c", "status": "modified", "additions": 118, "deletions": 11, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=a013431213f7f27e2866350c9aaea8f12046d81c", "patch": "@@ -1,6 +1,6 @@\n /* Global common subexpression elimination/Partial redundancy elimination\n    and global constant/copy propagation for GNU compiler.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -614,7 +614,7 @@ static int load_killed_in_block_p    PARAMS ((basic_block, int, rtx, int));\n static void canon_list_insert        PARAMS ((rtx, rtx, void *));\n static int cprop_insn\t\tPARAMS ((rtx, int));\n static int cprop\t\tPARAMS ((int));\n-static int one_cprop_pass\tPARAMS ((int, int));\n+static int one_cprop_pass\tPARAMS ((int, int, int));\n static bool constprop_register\tPARAMS ((rtx, rtx, rtx, int));\n static struct expr *find_bypass_set PARAMS ((int, int));\n static int bypass_block\t\t    PARAMS ((basic_block, rtx, rtx));\n@@ -819,7 +819,7 @@ gcse_main (f, file)\n \n       /* Don't allow constant propagation to modify jumps\n \t during this pass.  */\n-      changed = one_cprop_pass (pass + 1, 0);\n+      changed = one_cprop_pass (pass + 1, 0, 0);\n \n       if (optimize_size)\n \tchanged |= one_classic_gcse_pass (pass + 1);\n@@ -886,7 +886,7 @@ gcse_main (f, file)\n   max_gcse_regno = max_reg_num ();\n   alloc_gcse_mem (f);\n   /* This time, go ahead and allow cprop to alter jumps.  */\n-  one_cprop_pass (pass + 1, 1);\n+  one_cprop_pass (pass + 1, 1, 0);\n   free_gcse_mem ();\n \n   if (file)\n@@ -4463,20 +4463,22 @@ cprop (alter_jumps)\n }\n \n /* Perform one copy/constant propagation pass.\n-   F is the first insn in the function.\n-   PASS is the pass count.  */\n+   PASS is the pass count.  If CPROP_JUMPS is true, perform constant\n+   propagation into conditional jumps.  If BYPASS_JUMPS is true,\n+   perform conditional jump bypassing optimizations.  */\n \n static int\n-one_cprop_pass (pass, alter_jumps)\n+one_cprop_pass (pass, cprop_jumps, bypass_jumps)\n      int pass;\n-     int alter_jumps;\n+     int cprop_jumps;\n+     int bypass_jumps;\n {\n   int changed = 0;\n \n   const_prop_count = 0;\n   copy_prop_count = 0;\n \n-  local_cprop_pass (alter_jumps);\n+  local_cprop_pass (cprop_jumps);\n \n   alloc_hash_table (max_cuid, &set_hash_table, 1);\n   compute_hash_table (&set_hash_table);\n@@ -4486,8 +4488,8 @@ one_cprop_pass (pass, alter_jumps)\n     {\n       alloc_cprop_mem (last_basic_block, set_hash_table.n_elems);\n       compute_cprop_data ();\n-      changed = cprop (alter_jumps);\n-      if (alter_jumps)\n+      changed = cprop (cprop_jumps);\n+      if (bypass_jumps)\n \tchanged |= bypass_conditional_jumps ();\n       free_cprop_mem ();\n     }\n@@ -7348,4 +7350,109 @@ store_motion ()\n   end_alias_analysis ();\n }\n \n+\f\n+/* Entry point for jump bypassing optimization pass.  */\n+\n+int\n+bypass_jumps (file)\n+     FILE *file;\n+{\n+  int changed;\n+\n+  /* We do not construct an accurate cfg in functions which call\n+     setjmp, so just punt to be safe.  */\n+  if (current_function_calls_setjmp)\n+    return 0;\n+\n+  /* For calling dump_foo fns from gdb.  */\n+  debug_stderr = stderr;\n+  gcse_file = file;\n+\n+  /* Identify the basic block information for this function, including\n+     successors and predecessors.  */\n+  max_gcse_regno = max_reg_num ();\n+\n+  if (file)\n+    dump_flow_info (file);\n+\n+  /* Return if there's nothing to do.  */\n+  if (n_basic_blocks <= 1)\n+    return 0;\n+\n+  /* Trying to perform global optimizations on flow graphs which have\n+     a high connectivity will take a long time and is unlikely to be\n+     particularly useful.\n+\n+     In normal circumstances a cfg should have about twice as many edges\n+     as blocks.  But we do not want to punish small functions which have\n+     a couple switch statements.  So we require a relatively large number\n+     of basic blocks and the ratio of edges to blocks to be high.  */\n+  if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n+    {\n+      if (warn_disabled_optimization)\n+        warning (\"BYPASS disabled: %d > 1000 basic blocks and %d >= 20 edges/basic block\",\n+                 n_basic_blocks, n_edges / n_basic_blocks);\n+      return 0;\n+    }\n+\n+  /* If allocating memory for the cprop bitmap would take up too much\n+     storage it's better just to disable the optimization.  */\n+  if ((n_basic_blocks\n+       * SBITMAP_SET_SIZE (max_gcse_regno)\n+       * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n+    {\n+      if (warn_disabled_optimization)\n+        warning (\"GCSE disabled: %d basic blocks and %d registers\",\n+                 n_basic_blocks, max_gcse_regno);\n+\n+      return 0;\n+    }\n+\n+  /* See what modes support reg/reg copy operations.  */\n+  if (! can_copy_init_p)\n+    {\n+      compute_can_copy ();\n+      can_copy_init_p = 1;\n+    }\n+\n+  gcc_obstack_init (&gcse_obstack);\n+  bytes_used = 0;\n+\n+  /* We need alias.  */\n+  init_alias_analysis ();\n+\n+  /* Record where pseudo-registers are set.  This data is kept accurate\n+     during each pass.  ??? We could also record hard-reg information here\n+     [since it's unchanging], however it is currently done during hash table\n+     computation.\n+\n+     It may be tempting to compute MEM set information here too, but MEM sets\n+     will be subject to code motion one day and thus we need to compute\n+     information about memory sets when we build the hash tables.  */\n+\n+  alloc_reg_set_mem (max_gcse_regno);\n+  compute_sets (get_insns ());\n+\n+  max_gcse_regno = max_reg_num ();\n+  alloc_gcse_mem (get_insns ());\n+  changed = one_cprop_pass (1, 1, 1);\n+  free_gcse_mem ();\n+\n+  if (file)\n+    {\n+      fprintf (file, \"BYPASS of %s: %d basic blocks, \",\n+\t       current_function_name, n_basic_blocks);\n+      fprintf (file, \"%d bytes\\n\\n\", bytes_used);\n+    }\n+\n+  obstack_free (&gcse_obstack, NULL);\n+  free_reg_set_mem ();\n+\n+  /* We are finished with alias.  */\n+  end_alias_analysis ();\n+  allocate_reg_info (max_reg_num (), FALSE, FALSE);\n+\n+  return changed;\n+}\n+\n #include \"gt-gcse.h\""}, {"sha": "2066b77daa0a69a970d0124218fd6698eb9ac508", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a013431213f7f27e2866350c9aaea8f12046d81c", "patch": "@@ -1,6 +1,6 @@\n /* Register Transfer Language (RTL) definitions for GNU C-Compiler\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2086,6 +2086,7 @@ extern rtx expand_mult_highpart\t\tPARAMS ((enum machine_mode, rtx,\n /* In gcse.c */\n #ifdef BUFSIZ\n extern int gcse_main\t\t\tPARAMS ((rtx, FILE *));\n+extern int bypass_jumps\t\t\tPARAMS ((FILE *));\n #endif\n \n /* In global.c */"}, {"sha": "766207e78a6d18fe648c0e3cf96fc71f3532cff4", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=a013431213f7f27e2866350c9aaea8f12046d81c", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions for timing variables used to\n    measure run-time performance of the compiler.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Alex Samuel <samuel@codesourcery.com>\n \n    This file is part of GCC.\n@@ -59,6 +59,7 @@ DEFTIMEVAR (TV_JUMP                  , \"jump\")\n DEFTIMEVAR (TV_CSE                   , \"CSE\")\n DEFTIMEVAR (TV_GCSE                  , \"global CSE\")\n DEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\n+DEFTIMEVAR (TV_BYPASS                , \"bypass jumps\")\n DEFTIMEVAR (TV_TRACER                , \"tracer\")\n DEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\n DEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")"}, {"sha": "b860500a87182f9cef882ae1fdff7abf7805d429", "filename": "gcc/toplev.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a013431213f7f27e2866350c9aaea8f12046d81c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a013431213f7f27e2866350c9aaea8f12046d81c", "patch": "@@ -232,6 +232,7 @@ enum dump_file_index\n   DFI_addressof,\n   DFI_gcse,\n   DFI_loop,\n+  DFI_bypass,\n   DFI_cfg,\n   DFI_bp,\n   DFI_ce1,\n@@ -281,6 +282,7 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"addressof\", 'F', 0, 0, 0 },\n   { \"gcse\",\t'G', 1, 0, 0 },\n   { \"loop\",\t'L', 1, 0, 0 },\n+  { \"bypass\",   'G', 1, 0, 0 }, /* Yes, duplicate enable switch.  */\n   { \"cfg\",\t'f', 1, 0, 0 },\n   { \"bp\",\t'b', 1, 0, 0 },\n   { \"ce1\",\t'C', 1, 0, 0 },\n@@ -2964,6 +2966,32 @@ rest_of_compilation (decl)\n       ggc_collect ();\n     }\n \n+  /* Perform jump bypassing and control flow optimizations.  */\n+  if (optimize > 0 && flag_gcse)\n+    {\n+      timevar_push (TV_BYPASS);\n+      open_dump_file (DFI_bypass, decl);\n+\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      tem = bypass_jumps (rtl_dump_file);\n+\n+      if (tem)\n+        {\n+          rebuild_jump_labels (insns);\n+          cleanup_cfg (CLEANUP_EXPENSIVE);\n+          delete_trivially_dead_insns (insns, max_reg_num ());\n+        }\n+\n+      close_dump_file (DFI_bypass, print_rtl_with_bb, insns);\n+      timevar_pop (TV_BYPASS);\n+\n+      ggc_collect ();\n+\n+#ifdef ENABLE_CHECKING\n+      verify_flow_info ();\n+#endif\n+    }\n+\n   /* Do control and data flow analysis; wrote some of the results to\n      the dump file.  */\n "}]}