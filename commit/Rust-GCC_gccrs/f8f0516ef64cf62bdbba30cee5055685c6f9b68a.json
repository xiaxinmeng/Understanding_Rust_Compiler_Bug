{"sha": "f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhmMDUxNmVmNjRjZjYyYmRiYmEzMGNlZTUwNTU2ODVjNmY5YjY4YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-28T18:48:00Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-28T18:48:00Z"}, "message": "Use rtx subclasses in more places in reorg.c\n\ngcc/\n2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n\n\t* emit-rtl.h (copy_delay_slot_insn): Strengthen return type and\n\tparam from rtx to rtx_insn *.\n\n\t* emit-rtl.c (copy_delay_slot_insn): Likewise.\n\n\t* reorg.c (skip_consecutive_labels): Strengthen return type, param\n\tand local \"insn\" from rtx to rtx_insn *.\n\t(unfilled_slots_base): Strengthen type from rtx * to rtx_insn **.\n\t(unfilled_slots_next): Likewise.\n\t(function_return_label): Strengthen from rtx to rtx_code_label *.\n\t(function_simple_return_label): Likewise.\n\t(first_active_target_insn): Strengthen return type and param from\n\trtx to rtx_insn *.\n\t(find_end_label): Strengthen return type from rtx to\n\trtx_code_label *; strengthen locals as appropriate.\n\t(emit_delay_sequence): Strengthen return type, param \"insn\" and\n\tlocal \"seq_insn\" from rtx to rtx_insn *.  Strengthen param \"list\"\n\tand local \"li\" from rtx to rtx_insn_list *, using methods of\n\trtx_insn_list for clarity and typesafety.\n\t(add_to_delay_list): Strengthen return type and param \"insn\" from\n\trtx to rtx_insn *.  Strengthen param \"delay_list\" from rtx to\n\trtx_insn_list * and use methods of rtx_insn_list.\n\t(delete_from_delay_slot): Strengthen return type, param \"insn\",\n\tlocals \"trial\", \"seq_insn\", \"prev\" from rtx to rtx_insn *.\n\tStrengthen local \"seq\" from rtx to rtx_sequence *, and local\n\t\"delay_list\" from rtx to rtx_insn_list *, using methods of\n\trtx_sequence for clarity and type-safety.\n\t(delete_scheduled_jump): Add checked cast when invoking\n\tdelete_from_delay_slot.  Strengthen local \"trial\" from rtx to\n\trtx_insn *.\n\t(optimize_skip): Strengthen return type and local \"delay_list\"\n\tfrom rtx to rtx_insn_list *.  Strengthen local \"trial\" from rtx to\n\trtx_insn *.\n\t(steal_delay_list_from_target): Strengthen return type, param\n\t\"delay_list\" and local \"new_delay_list\" from rtx to\n\trtx_insn_list *.  Strengthen param \"seq\" from rtx to\n\trtx_sequence *.  Strengthen param \"pnew_thread\" from rtx * to\n\trtx_insn **.\n\tSplit out local \"temp\" into multiple more-tightly scoped locals:\n\tsometimes an rtx_insn_list *, and once a rtx_insn *.  Use methods\n\tof rtx_insn_list and rtx_sequence for clarity and typesafety.\n\tStrengthen locals named \"trial\" from rtx to rtx_insn *.\n\t(steal_delay_list_from_fallthrough): Strengthen return type and\n\tparam \"delay_list\" from rtx to rtx_insn_list *.  Strengthen param\n\t\"seq\" from rtx to rtx_sequence *.  Use methods of rtx_sequence.\n\tStrengthen local \"trial\" from rtx to rtx_insn *.\n\t(try_merge_delay_insns): Strength local \"merged_insns\" from rtx\n\tto rtx_insn_list * and use its methods.  Strengthen local \"pat\"\n\tfrom rtx to rtx_sequence * and use its methods.  Strengthen locals\n\t\"dtrial\" and \"new_rtx\" from rtx to rtx_insn *.\n\t(get_label_before): Strengthen return type and local \"label\" from\n\trtx to rtx_insn *.\n\t(fill_simple_delay_slots): Likewise for locals \"insn\", \"trial\",\n\t\"next_trial\", \"next\", prev\".  Strengthen local \"delay_list\" from\n\trtx to rtx_insn_list *  Strengthen local \"tmp\" from rtx * to\n\trtx_insn **.\n\t(follow_jumps): Strengthen return type, param \"label\" and locals\n\t\"insn\", \"next\", \"value\", \"this_label\" from rtx to rtx_insn *.\n\t(fill_slots_from_thread): Strengthen return type, param\n\t\"delay_list\" from rtx to rtx_insn_list *.  Strengthen params\n\t\"insn\", \"thread\", \"opposite_thread\" and locals \"new_thread\",\n\t\"trial\", \"temp\", \"ninsn\" from rtx to rtx_insn *.  Introduce local\n\t\"sequence\" from a checked cast to rtx_sequence so that we can call\n\tsteal_delay_list_from_target and steal_delay_list_from_fallthrough\n\twith an rtx_sequence *.\n\t(fill_eager_delay_slots): Strengthen locals \"insn\", \"target_label\",\n\t\"insn_at_target\", \"fallthrough_insn\" from rtx to rtx_insn *.\n\tStrengthen local \"delay_list\" from rtx to rtx_insn_list *.\n\t(relax_delay_slots): Strengthen param \"first\" and locals \"insn\",\n\t\"next\", \"trial\", \"delay_insn\", \"target_label\" from rtx to\n\trtx_insn *.  Strengthen local \"pat\" from rtx to rtx_sequence *.\n\tIntroduce a local \"trial_seq\" for PATTERN (trial) of type\n\trtx_sequence *, in both cases using methods of rtx_sequence.\n\t(dbr_schedule): Strengthen param \"first\" and locals \"insn\",\n\t\"next\", \"epilogue_insn\" from rtx to rtx_insn *.\n\nFrom-SVN: r214684", "tree": {"sha": "e98e578ccb788f8337dbe343ce66bb5eadde1a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e98e578ccb788f8337dbe343ce66bb5eadde1a7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0c0c325357ae6b57a5648bdcf1c6af4c0a31572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c0c325357ae6b57a5648bdcf1c6af4c0a31572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c0c325357ae6b57a5648bdcf1c6af4c0a31572"}], "stats": {"total": 389, "additions": 240, "deletions": 149}, "files": [{"sha": "4860446d216dfb67935f26fa2cbdb03c7f28148d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "patch": "@@ -1,3 +1,81 @@\n+2014-08-28  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* emit-rtl.h (copy_delay_slot_insn): Strengthen return type and\n+\tparam from rtx to rtx_insn *.\n+\n+\t* emit-rtl.c (copy_delay_slot_insn): Likewise.\n+\n+\t* reorg.c (skip_consecutive_labels): Strengthen return type, param\n+\tand local \"insn\" from rtx to rtx_insn *.\n+\t(unfilled_slots_base): Strengthen type from rtx * to rtx_insn **.\n+\t(unfilled_slots_next): Likewise.\n+\t(function_return_label): Strengthen from rtx to rtx_code_label *.\n+\t(function_simple_return_label): Likewise.\n+\t(first_active_target_insn): Strengthen return type and param from\n+\trtx to rtx_insn *.\n+\t(find_end_label): Strengthen return type from rtx to\n+\trtx_code_label *; strengthen locals as appropriate.\n+\t(emit_delay_sequence): Strengthen return type, param \"insn\" and\n+\tlocal \"seq_insn\" from rtx to rtx_insn *.  Strengthen param \"list\"\n+\tand local \"li\" from rtx to rtx_insn_list *, using methods of\n+\trtx_insn_list for clarity and typesafety.\n+\t(add_to_delay_list): Strengthen return type and param \"insn\" from\n+\trtx to rtx_insn *.  Strengthen param \"delay_list\" from rtx to\n+\trtx_insn_list * and use methods of rtx_insn_list.\n+\t(delete_from_delay_slot): Strengthen return type, param \"insn\",\n+\tlocals \"trial\", \"seq_insn\", \"prev\" from rtx to rtx_insn *.\n+\tStrengthen local \"seq\" from rtx to rtx_sequence *, and local\n+\t\"delay_list\" from rtx to rtx_insn_list *, using methods of\n+\trtx_sequence for clarity and type-safety.\n+\t(delete_scheduled_jump): Add checked cast when invoking\n+\tdelete_from_delay_slot.  Strengthen local \"trial\" from rtx to\n+\trtx_insn *.\n+\t(optimize_skip): Strengthen return type and local \"delay_list\"\n+\tfrom rtx to rtx_insn_list *.  Strengthen local \"trial\" from rtx to\n+\trtx_insn *.\n+\t(steal_delay_list_from_target): Strengthen return type, param\n+\t\"delay_list\" and local \"new_delay_list\" from rtx to\n+\trtx_insn_list *.  Strengthen param \"seq\" from rtx to\n+\trtx_sequence *.  Strengthen param \"pnew_thread\" from rtx * to\n+\trtx_insn **.\n+\tSplit out local \"temp\" into multiple more-tightly scoped locals:\n+\tsometimes an rtx_insn_list *, and once a rtx_insn *.  Use methods\n+\tof rtx_insn_list and rtx_sequence for clarity and typesafety.\n+\tStrengthen locals named \"trial\" from rtx to rtx_insn *.\n+\t(steal_delay_list_from_fallthrough): Strengthen return type and\n+\tparam \"delay_list\" from rtx to rtx_insn_list *.  Strengthen param\n+\t\"seq\" from rtx to rtx_sequence *.  Use methods of rtx_sequence.\n+\tStrengthen local \"trial\" from rtx to rtx_insn *.\n+\t(try_merge_delay_insns): Strength local \"merged_insns\" from rtx\n+\tto rtx_insn_list * and use its methods.  Strengthen local \"pat\"\n+\tfrom rtx to rtx_sequence * and use its methods.  Strengthen locals\n+\t\"dtrial\" and \"new_rtx\" from rtx to rtx_insn *.\n+\t(get_label_before): Strengthen return type and local \"label\" from\n+\trtx to rtx_insn *.\n+\t(fill_simple_delay_slots): Likewise for locals \"insn\", \"trial\",\n+\t\"next_trial\", \"next\", prev\".  Strengthen local \"delay_list\" from\n+\trtx to rtx_insn_list *  Strengthen local \"tmp\" from rtx * to\n+\trtx_insn **.\n+\t(follow_jumps): Strengthen return type, param \"label\" and locals\n+\t\"insn\", \"next\", \"value\", \"this_label\" from rtx to rtx_insn *.\n+\t(fill_slots_from_thread): Strengthen return type, param\n+\t\"delay_list\" from rtx to rtx_insn_list *.  Strengthen params\n+\t\"insn\", \"thread\", \"opposite_thread\" and locals \"new_thread\",\n+\t\"trial\", \"temp\", \"ninsn\" from rtx to rtx_insn *.  Introduce local\n+\t\"sequence\" from a checked cast to rtx_sequence so that we can call\n+\tsteal_delay_list_from_target and steal_delay_list_from_fallthrough\n+\twith an rtx_sequence *.\n+\t(fill_eager_delay_slots): Strengthen locals \"insn\", \"target_label\",\n+\t\"insn_at_target\", \"fallthrough_insn\" from rtx to rtx_insn *.\n+\tStrengthen local \"delay_list\" from rtx to rtx_insn_list *.\n+\t(relax_delay_slots): Strengthen param \"first\" and locals \"insn\",\n+\t\"next\", \"trial\", \"delay_insn\", \"target_label\" from rtx to\n+\trtx_insn *.  Strengthen local \"pat\" from rtx to rtx_sequence *.\n+\tIntroduce a local \"trial_seq\" for PATTERN (trial) of type\n+\trtx_sequence *, in both cases using methods of rtx_sequence.\n+\t(dbr_schedule): Strengthen param \"first\" and locals \"insn\",\n+\t\"next\", \"epilogue_insn\" from rtx to rtx_insn *.\n+\n 2014-08-28  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/62283"}, {"sha": "2365dc2df1d7df1bb3fa5319de0ef7c9d2591e29", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "patch": "@@ -5603,11 +5603,11 @@ copy_insn (rtx insn)\n /* Return a copy of INSN that can be used in a SEQUENCE delay slot,\n    on that assumption that INSN itself remains in its original place.  */\n \n-rtx\n-copy_delay_slot_insn (rtx insn)\n+rtx_insn *\n+copy_delay_slot_insn (rtx_insn *insn)\n {\n   /* Copy INSN with its rtx_code, all its notes, location etc.  */\n-  insn = copy_rtx (insn);\n+  insn = as_a <rtx_insn *> (copy_rtx (insn));\n   INSN_UID (insn) = cur_insn_uid++;\n   return insn;\n }"}, {"sha": "d0b1bcec31ca832d6bb9027dc71a8b98c0d6c022", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "patch": "@@ -64,7 +64,7 @@ extern rtx gen_blockage (void);\n extern rtvec gen_rtvec (int, ...);\n extern rtx copy_insn_1 (rtx);\n extern rtx copy_insn (rtx);\n-extern rtx copy_delay_slot_insn (rtx);\n+extern rtx_insn *copy_delay_slot_insn (rtx_insn *);\n extern rtx gen_int_mode (HOST_WIDE_INT, enum machine_mode);\n extern rtx_insn *emit_copy_of_insn_after (rtx, rtx);\n extern void set_reg_attrs_from_value (rtx, rtx);"}, {"sha": "4c39c46bfdc3dc87ad9ce42f740968b502524930", "filename": "gcc/reorg.c", "status": "modified", "additions": 158, "deletions": 145, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f0516ef64cf62bdbba30cee5055685c6f9b68a/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=f8f0516ef64cf62bdbba30cee5055685c6f9b68a", "patch": "@@ -142,10 +142,10 @@ along with GCC; see the file COPYING3.  If not see\n /* Return the last label to mark the same position as LABEL.  Return LABEL\n    itself if it is null or any return rtx.  */\n \n-static rtx\n-skip_consecutive_labels (rtx label)\n+static rtx_insn *\n+skip_consecutive_labels (rtx_insn *label)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   if (label && ANY_RETURN_P (label))\n     return label;\n@@ -184,16 +184,16 @@ static rtx *unfilled_firstobj;\n    should be recomputed at each use.  */\n \n #define unfilled_slots_base\t\\\n-  ((rtx *) obstack_base (&unfilled_slots_obstack))\n+  ((rtx_insn **) obstack_base (&unfilled_slots_obstack))\n \n #define unfilled_slots_next\t\\\n-  ((rtx *) obstack_next_free (&unfilled_slots_obstack))\n+  ((rtx_insn **) obstack_next_free (&unfilled_slots_obstack))\n \n /* Points to the label before the end of the function, or before a\n    return insn.  */\n-static rtx function_return_label;\n+static rtx_code_label *function_return_label;\n /* Likewise for a simple_return.  */\n-static rtx function_simple_return_label;\n+static rtx_code_label *function_simple_return_label;\n \n /* Mapping between INSN_UID's and position in the code since INSN_UID's do\n    not always monotonically increase.  */\n@@ -206,14 +206,14 @@ static int stop_search_p (rtx, int);\n static int resource_conflicts_p (struct resources *, struct resources *);\n static int insn_references_resource_p (rtx, struct resources *, bool);\n static int insn_sets_resource_p (rtx, struct resources *, bool);\n-static rtx find_end_label (rtx);\n-static rtx emit_delay_sequence (rtx, rtx, int);\n-static rtx add_to_delay_list (rtx, rtx);\n-static rtx delete_from_delay_slot (rtx);\n+static rtx_code_label *find_end_label (rtx);\n+static rtx_insn *emit_delay_sequence (rtx_insn *, rtx_insn_list *, int);\n+static rtx_insn_list *add_to_delay_list (rtx_insn *, rtx_insn_list *);\n+static rtx_insn *delete_from_delay_slot (rtx_insn *);\n static void delete_scheduled_jump (rtx);\n static void note_delay_statistics (int, int);\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n-static rtx optimize_skip (rtx);\n+static rtx_insn_list *optimize_skip (rtx);\n #endif\n static int get_jump_flags (rtx, rtx);\n static int mostly_true_jump (rtx);\n@@ -222,16 +222,21 @@ static int condition_dominates_p (rtx, rtx);\n static int redirect_with_delay_slots_safe_p (rtx, rtx, rtx);\n static int redirect_with_delay_list_safe_p (rtx, rtx, rtx);\n static int check_annul_list_true_false (int, rtx);\n-static rtx steal_delay_list_from_target (rtx, rtx, rtx, rtx,\n-\t\t\t\t\t struct resources *,\n-\t\t\t\t\t struct resources *,\n-\t\t\t\t\t struct resources *,\n-\t\t\t\t\t int, int *, int *, rtx *);\n-static rtx steal_delay_list_from_fallthrough (rtx, rtx, rtx, rtx,\n-\t\t\t\t\t      struct resources *,\n-\t\t\t\t\t      struct resources *,\n-\t\t\t\t\t      struct resources *,\n-\t\t\t\t\t      int, int *, int *);\n+static rtx_insn_list *steal_delay_list_from_target (rtx, rtx,\n+\t\t\t\t\t\t    rtx_sequence *,\n+\t\t\t\t\t\t    rtx_insn_list *,\n+\t\t\t\t\t\t    struct resources *,\n+\t\t\t\t\t\t    struct resources *,\n+\t\t\t\t\t\t    struct resources *,\n+\t\t\t\t\t\t    int, int *, int *,\n+\t\t\t\t\t\t    rtx_insn **);\n+static rtx_insn_list *steal_delay_list_from_fallthrough (rtx, rtx,\n+\t\t\t\t\t\t\t rtx_sequence *,\n+\t\t\t\t\t\t\t rtx_insn_list *,\n+\t\t\t\t\t\t\t struct resources *,\n+\t\t\t\t\t\t\t struct resources *,\n+\t\t\t\t\t\t\t struct resources *,\n+\t\t\t\t\t\t\t int, int *, int *);\n static void try_merge_delay_insns (rtx, rtx);\n static rtx redundant_insn (rtx, rtx, rtx);\n static int own_thread_p (rtx, rtx, int);\n@@ -241,18 +246,19 @@ static void update_reg_dead_notes (rtx, rtx);\n static void fix_reg_dead_note (rtx, rtx);\n static void update_reg_unused_notes (rtx, rtx);\n static void fill_simple_delay_slots (int);\n-static rtx fill_slots_from_thread (rtx, rtx, rtx, rtx,\n-\t\t\t\t   int, int, int, int,\n-\t\t\t\t   int *, rtx);\n+static rtx_insn_list *fill_slots_from_thread (rtx_insn *, rtx,\n+\t\t\t\t\t      rtx_insn *, rtx_insn *,\n+\t\t\t\t\t      int, int, int, int,\n+\t\t\t\t\t      int *, rtx_insn_list *);\n static void fill_eager_delay_slots (void);\n-static void relax_delay_slots (rtx);\n+static void relax_delay_slots (rtx_insn *);\n static void make_return_insns (rtx);\n \f\n /* A wrapper around next_active_insn which takes care to return ret_rtx\n    unchanged.  */\n \n-static rtx\n-first_active_target_insn (rtx insn)\n+static rtx_insn *\n+first_active_target_insn (rtx_insn *insn)\n {\n   if (ANY_RETURN_P (insn))\n     return insn;\n@@ -382,11 +388,11 @@ insn_sets_resource_p (rtx insn, struct resources *res,\n    KIND is either simple_return_rtx or ret_rtx, indicating which type of\n    return we're looking for.  */\n \n-static rtx\n+static rtx_code_label *\n find_end_label (rtx kind)\n {\n-  rtx insn;\n-  rtx *plabel;\n+  rtx_insn *insn;\n+  rtx_code_label **plabel;\n \n   if (kind == ret_rtx)\n     plabel = &function_return_label;\n@@ -418,8 +424,8 @@ find_end_label (rtx kind)\n       && JUMP_P (PREV_INSN (insn))\n       && PATTERN (PREV_INSN (insn)) == kind)\n     {\n-      rtx temp = PREV_INSN (PREV_INSN (insn));\n-      rtx label = gen_label_rtx ();\n+      rtx_insn *temp = PREV_INSN (PREV_INSN (insn));\n+      rtx_code_label *label = gen_label_rtx ();\n       LABEL_NUSES (label) = 0;\n \n       /* Put the label before any USE insns that may precede the RETURN\n@@ -432,10 +438,10 @@ find_end_label (rtx kind)\n     }\n \n   else if (LABEL_P (insn))\n-    *plabel = insn;\n+    *plabel = as_a <rtx_code_label *> (insn);\n   else\n     {\n-      rtx label = gen_label_rtx ();\n+      rtx_code_label *label = gen_label_rtx ();\n       LABEL_NUSES (label) = 0;\n       /* If the basic block reorder pass moves the return insn to\n \t some other place try to locate it again and put our\n@@ -465,7 +471,7 @@ find_end_label (rtx kind)\n \t       emit the label just before it.  Since we already have\n \t       an epilogue and cannot emit a new RETURN, we cannot\n \t       emit the label at all.  */\n-\t    return NULL_RTX;\n+\t    return NULL;\n #endif /* HAVE_epilogue */\n \n \t  /* Otherwise, make a new label and emit a RETURN and BARRIER,\n@@ -497,15 +503,15 @@ find_end_label (rtx kind)\n /* Put INSN and LIST together in a SEQUENCE rtx of LENGTH, and replace\n    the pattern of INSN with the SEQUENCE.\n \n-   Returns the SEQUENCE that replaces INSN.  */\n+   Returns the insn containing the SEQUENCE that replaces INSN.  */\n \n-static rtx\n-emit_delay_sequence (rtx insn, rtx list, int length)\n+static rtx_insn *\n+emit_delay_sequence (rtx_insn *insn, rtx_insn_list *list, int length)\n {\n   /* Allocate the rtvec to hold the insns and the SEQUENCE.  */\n   rtvec seqv = rtvec_alloc (length + 1);\n   rtx seq = gen_rtx_SEQUENCE (VOIDmode, seqv);\n-  rtx seq_insn = make_insn_raw (seq);\n+  rtx_insn *seq_insn = make_insn_raw (seq);\n \n   /* If DELAY_INSN has a location, use it for SEQ_INSN.  If DELAY_INSN does\n      not have a location, but one of the delayed insns does, we pick up a\n@@ -522,9 +528,9 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n   int i = 1;\n   start_sequence ();\n   XVECEXP (seq, 0, 0) = emit_insn (insn);\n-  for (rtx li = list; li; li = XEXP (li, 1), i++)\n+  for (rtx_insn_list *li = list; li; li = li->next (), i++)\n     {\n-      rtx tem = XEXP (li, 0);\n+      rtx_insn *tem = li->insn ();\n       rtx note, next;\n \n       /* Show that this copy of the insn isn't deleted.  */\n@@ -576,8 +582,8 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n /* Add INSN to DELAY_LIST and return the head of the new list.  The list must\n    be in the order in which the insns are to be executed.  */\n \n-static rtx\n-add_to_delay_list (rtx insn, rtx delay_list)\n+static rtx_insn_list *\n+add_to_delay_list (rtx_insn *insn, rtx_insn_list *delay_list)\n {\n   /* If we have an empty list, just make a new list element.  If\n      INSN has its block number recorded, clear it since we may\n@@ -591,19 +597,20 @@ add_to_delay_list (rtx insn, rtx delay_list)\n \n   /* Otherwise this must be an INSN_LIST.  Add INSN to the end of the\n      list.  */\n-  XEXP (delay_list, 1) = add_to_delay_list (insn, XEXP (delay_list, 1));\n+  XEXP (delay_list, 1) = add_to_delay_list (insn, delay_list->next ());\n \n   return delay_list;\n }\n \f\n /* Delete INSN from the delay slot of the insn that it is in, which may\n    produce an insn with no delay slots.  Return the new insn.  */\n \n-static rtx\n-delete_from_delay_slot (rtx insn)\n+static rtx_insn *\n+delete_from_delay_slot (rtx_insn *insn)\n {\n-  rtx trial, seq_insn, seq, prev;\n-  rtx delay_list = 0;\n+  rtx_insn *trial, *seq_insn, *prev;\n+  rtx_sequence *seq;\n+  rtx_insn_list *delay_list = 0;\n   int i;\n   int had_barrier = 0;\n \n@@ -617,22 +624,22 @@ delete_from_delay_slot (rtx insn)\n     ;\n \n   seq_insn = PREV_INSN (NEXT_INSN (trial));\n-  seq = PATTERN (seq_insn);\n+  seq = as_a <rtx_sequence *> (PATTERN (seq_insn));\n \n   if (NEXT_INSN (seq_insn) && BARRIER_P (NEXT_INSN (seq_insn)))\n     had_barrier = 1;\n \n   /* Create a delay list consisting of all the insns other than the one\n      we are deleting (unless we were the only one).  */\n-  if (XVECLEN (seq, 0) > 2)\n-    for (i = 1; i < XVECLEN (seq, 0); i++)\n-      if (XVECEXP (seq, 0, i) != insn)\n-\tdelay_list = add_to_delay_list (XVECEXP (seq, 0, i), delay_list);\n+  if (seq->len () > 2)\n+    for (i = 1; i < seq->len (); i++)\n+      if (seq->insn (i) != insn)\n+\tdelay_list = add_to_delay_list (seq->insn (i), delay_list);\n \n   /* Delete the old SEQUENCE, re-emit the insn that used to have the delay\n      list, and rebuild the delay list if non-empty.  */\n   prev = PREV_INSN (seq_insn);\n-  trial = XVECEXP (seq, 0, 0);\n+  trial = seq->insn (0);\n   delete_related_insns (seq_insn);\n   add_insn_after (trial, prev, NULL);\n \n@@ -679,14 +686,14 @@ delete_scheduled_jump (rtx insn)\n \t{\n \t  if (! FIND_REG_INC_NOTE (XEXP (note, 0), NULL_RTX)\n \t      && sets_cc0_p (PATTERN (XEXP (note, 0))) == 1)\n-\t    delete_from_delay_slot (XEXP (note, 0));\n+\t    delete_from_delay_slot (as_a <rtx_insn *> (XEXP (note, 0)));\n \t}\n       else\n \t{\n \t  /* The insn setting CC0 is our previous insn, but it may be in\n \t     a delay slot.  It will be the last insn in the delay slot, if\n \t     it is.  */\n-\t  rtx trial = previous_insn (insn);\n+\t  rtx_insn *trial = previous_insn (insn);\n \t  if (NOTE_P (trial))\n \t    trial = prev_nonnote_insn (trial);\n \t  if (sets_cc0_p (PATTERN (trial)) != 1\n@@ -758,12 +765,12 @@ note_delay_statistics (int slots_filled, int index)\n    This should be expanded to skip over N insns, where N is the number\n    of delay slots required.  */\n \n-static rtx\n+static rtx_insn_list *\n optimize_skip (rtx insn)\n {\n-  rtx trial = next_nonnote_insn (insn);\n+  rtx_insn *trial = next_nonnote_insn (insn);\n   rtx next_trial = next_active_insn (trial);\n-  rtx delay_list = 0;\n+  rtx_insn_list *delay_list = 0;\n   int flags;\n \n   flags = get_jump_flags (insn, JUMP_LABEL (insn));\n@@ -796,7 +803,7 @@ optimize_skip (rtx insn)\n \t    return 0;\n \t}\n \n-      delay_list = add_to_delay_list (trial, NULL_RTX);\n+      delay_list = add_to_delay_list (trial, NULL);\n       next_trial = next_active_insn (trial);\n       update_block (trial, trial);\n       delete_related_insns (trial);\n@@ -1077,18 +1084,17 @@ check_annul_list_true_false (int annul_true_p, rtx delay_list)\n    PNEW_THREAD points to a location that is to receive the place at which\n    execution should continue.  */\n \n-static rtx\n-steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n-\t\t\t      rtx delay_list, struct resources *sets,\n+static rtx_insn_list *\n+steal_delay_list_from_target (rtx insn, rtx condition, rtx_sequence *seq,\n+\t\t\t      rtx_insn_list *delay_list, struct resources *sets,\n \t\t\t      struct resources *needed,\n \t\t\t      struct resources *other_needed,\n \t\t\t      int slots_to_fill, int *pslots_filled,\n-\t\t\t      int *pannul_p, rtx *pnew_thread)\n+\t\t\t      int *pannul_p, rtx_insn **pnew_thread)\n {\n-  rtx temp;\n   int slots_remaining = slots_to_fill - *pslots_filled;\n   int total_slots_filled = *pslots_filled;\n-  rtx new_delay_list = 0;\n+  rtx_insn_list *new_delay_list = 0;\n   int must_annul = *pannul_p;\n   int used_annul = 0;\n   int i;\n@@ -1112,32 +1118,32 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n      will effect the direction of the jump in the sequence.  */\n \n   CLEAR_RESOURCE (&cc_set);\n-  for (temp = delay_list; temp; temp = XEXP (temp, 1))\n+  for (rtx_insn_list *temp = delay_list; temp; temp = temp->next ())\n     {\n-      rtx trial = XEXP (temp, 0);\n+      rtx_insn *trial = temp->insn ();\n \n       mark_set_resources (trial, &cc_set, 0, MARK_SRC_DEST_CALL);\n-      if (insn_references_resource_p (XVECEXP (seq , 0, 0), &cc_set, false))\n+      if (insn_references_resource_p (seq->insn (0), &cc_set, false))\n \treturn delay_list;\n     }\n \n   if (XVECLEN (seq, 0) - 1 > slots_remaining\n-      || ! condition_dominates_p (condition, XVECEXP (seq, 0, 0))\n-      || ! single_set (XVECEXP (seq, 0, 0)))\n+      || ! condition_dominates_p (condition, seq->insn (0))\n+      || ! single_set (seq->insn (0)))\n     return delay_list;\n \n #ifdef MD_CAN_REDIRECT_BRANCH\n   /* On some targets, branches with delay slots can have a limited\n      displacement.  Give the back end a chance to tell us we can't do\n      this.  */\n-  if (! MD_CAN_REDIRECT_BRANCH (insn, XVECEXP (seq, 0, 0)))\n+  if (! MD_CAN_REDIRECT_BRANCH (insn, seq->insn (0)))\n     return delay_list;\n #endif\n \n   redundant = XALLOCAVEC (bool, XVECLEN (seq, 0));\n-  for (i = 1; i < XVECLEN (seq, 0); i++)\n+  for (i = 1; i < seq->len (); i++)\n     {\n-      rtx trial = XVECEXP (seq, 0, i);\n+      rtx_insn *trial = seq->insn (i);\n       int flags;\n \n       if (insn_references_resource_p (trial, sets, false)\n@@ -1150,7 +1156,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n #endif\n \t  /* If TRIAL is from the fallthrough code of an annulled branch insn\n \t     in SEQ, we cannot use it.  */\n-\t  || (INSN_ANNULLED_BRANCH_P (XVECEXP (seq, 0, 0))\n+\t  || (INSN_ANNULLED_BRANCH_P (seq->insn (0))\n \t      && ! INSN_FROM_TARGET_P (trial)))\n \treturn delay_list;\n \n@@ -1162,7 +1168,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n \n       /* We will end up re-vectoring this branch, so compute flags\n \t based on jumping to the new label.  */\n-      flags = get_jump_flags (insn, JUMP_LABEL (XVECEXP (seq, 0, 0)));\n+      flags = get_jump_flags (insn, JUMP_LABEL (seq->insn (0)));\n \n       if (! must_annul\n \t  && ((condition == const_true_rtx\n@@ -1178,7 +1184,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n \t{\n \t  if (must_annul)\n \t    used_annul = 1;\n-\t  temp = copy_delay_slot_insn (trial);\n+\t  rtx_insn *temp = copy_delay_slot_insn (trial);\n \t  INSN_FROM_TARGET_P (temp) = 1;\n \t  new_delay_list = add_to_delay_list (temp, new_delay_list);\n \t  total_slots_filled++;\n@@ -1197,7 +1203,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n       update_block (XVECEXP (seq, 0, i), insn);\n \n   /* Show the place to which we will be branching.  */\n-  *pnew_thread = first_active_target_insn (JUMP_LABEL (XVECEXP (seq, 0, 0)));\n+  *pnew_thread = first_active_target_insn (JUMP_LABEL_AS_INSN (seq->insn (0)));\n \n   /* Add any new insns to the delay list and update the count of the\n      number of slots filled.  */\n@@ -1208,8 +1214,8 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n   if (delay_list == 0)\n     return new_delay_list;\n \n-  for (temp = new_delay_list; temp; temp = XEXP (temp, 1))\n-    delay_list = add_to_delay_list (XEXP (temp, 0), delay_list);\n+  for (rtx_insn_list *temp = new_delay_list; temp; temp = temp->next ())\n+    delay_list = add_to_delay_list (temp->insn (), delay_list);\n \n   return delay_list;\n }\n@@ -1219,9 +1225,10 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n    of SEQ is an unconditional branch.  In that case we steal its delay slot\n    for INSN since unconditional branches are much easier to fill.  */\n \n-static rtx\n-steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,\n-\t\t\t\t   rtx delay_list, struct resources *sets,\n+static rtx_insn_list *\n+steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx_sequence *seq,\n+\t\t\t\t   rtx_insn_list *delay_list,\n+\t\t\t\t   struct resources *sets,\n \t\t\t\t   struct resources *needed,\n \t\t\t\t   struct resources *other_needed,\n \t\t\t\t   int slots_to_fill, int *pslots_filled,\n@@ -1237,12 +1244,12 @@ steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,\n   /* We can't do anything if SEQ's delay insn isn't an\n      unconditional branch.  */\n \n-  if (! simplejump_or_return_p (XVECEXP (seq, 0, 0)))\n+  if (! simplejump_or_return_p (seq->insn (0)))\n     return delay_list;\n \n-  for (i = 1; i < XVECLEN (seq, 0); i++)\n+  for (i = 1; i < seq->len (); i++)\n     {\n-      rtx trial = XVECEXP (seq, 0, i);\n+      rtx_insn *trial = seq->insn (i);\n \n       /* If TRIAL sets CC0, stealing it will move it too far from the use\n \t of CC0.  */\n@@ -1309,7 +1316,7 @@ try_merge_delay_insns (rtx insn, rtx thread)\n   int num_slots = XVECLEN (PATTERN (insn), 0);\n   rtx next_to_match = XVECEXP (PATTERN (insn), 0, slot_number);\n   struct resources set, needed;\n-  rtx merged_insns = 0;\n+  rtx_insn_list *merged_insns = 0;\n   int i;\n   int flags;\n \n@@ -1391,16 +1398,16 @@ try_merge_delay_insns (rtx insn, rtx thread)\n       && !(JUMP_P (XVECEXP (PATTERN (trial), 0, 0))\n            && INSN_ANNULLED_BRANCH_P (XVECEXP (PATTERN (trial), 0, 0))))\n     {\n-      rtx pat = PATTERN (trial);\n+      rtx_sequence *pat = as_a <rtx_sequence *> (PATTERN (trial));\n       rtx filled_insn = XVECEXP (pat, 0, 0);\n \n       /* Account for resources set/needed by the filled insn.  */\n       mark_set_resources (filled_insn, &set, 0, MARK_SRC_DEST_CALL);\n       mark_referenced_resources (filled_insn, &needed, true);\n \n-      for (i = 1; i < XVECLEN (pat, 0); i++)\n+      for (i = 1; i < pat->len (); i++)\n \t{\n-\t  rtx dtrial = XVECEXP (pat, 0, i);\n+\t  rtx_insn *dtrial = pat->insn (i);\n \n \t  if (! insn_references_resource_p (dtrial, &set, true)\n \t      && ! insn_sets_resource_p (dtrial, &set, true)\n@@ -1413,7 +1420,7 @@ try_merge_delay_insns (rtx insn, rtx thread)\n \t    {\n \t      if (! annul_p)\n \t\t{\n-\t\t  rtx new_rtx;\n+\t\t  rtx_insn *new_rtx;\n \n \t\t  update_block (dtrial, thread);\n \t\t  new_rtx = delete_from_delay_slot (dtrial);\n@@ -1447,14 +1454,14 @@ try_merge_delay_insns (rtx insn, rtx thread)\n      target.  */\n   if (slot_number == num_slots && annul_p)\n     {\n-      for (; merged_insns; merged_insns = XEXP (merged_insns, 1))\n+      for (; merged_insns; merged_insns = merged_insns->next ())\n \t{\n \t  if (GET_MODE (merged_insns) == SImode)\n \t    {\n-\t      rtx new_rtx;\n+\t      rtx_insn *new_rtx;\n \n \t      update_block (XEXP (merged_insns, 0), thread);\n-\t      new_rtx = delete_from_delay_slot (XEXP (merged_insns, 0));\n+\t      new_rtx = delete_from_delay_slot (merged_insns->insn ());\n \t      if (INSN_DELETED_P (thread))\n \t\tthread = new_rtx;\n \t    }\n@@ -1876,10 +1883,10 @@ static vec <rtx> sibling_labels;\n    typically the former target of the jump that will be redirected to\n    the new label.  */\n \n-static rtx\n+static rtx_insn *\n get_label_before (rtx insn, rtx sibling)\n {\n-  rtx label;\n+  rtx_insn *label;\n \n   /* Find an existing label at this point\n      or make a new one if there is none.  */\n@@ -1918,12 +1925,13 @@ get_label_before (rtx insn, rtx sibling)\n static void\n fill_simple_delay_slots (int non_jumps_p)\n {\n-  rtx insn, pat, trial, next_trial;\n+  rtx_insn *insn, *trial, *next_trial;\n+  rtx pat;\n   int i;\n   int num_unfilled_slots = unfilled_slots_next - unfilled_slots_base;\n   struct resources needed, set;\n   int slots_to_fill, slots_filled;\n-  rtx delay_list;\n+  rtx_insn_list *delay_list;\n \n   for (i = 0; i < num_unfilled_slots; i++)\n     {\n@@ -1993,7 +2001,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  && no_labels_between_p (insn, trial)\n \t  && ! can_throw_internal (trial))\n \t{\n-\t  rtx *tmp;\n+\t  rtx_insn **tmp;\n \t  slots_filled++;\n \t  delay_list = add_to_delay_list (trial, delay_list);\n \n@@ -2012,8 +2020,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  if (*tmp == trial)\n \t    *tmp = 0;\n \t  {\n-\t    rtx next = NEXT_INSN (trial);\n-\t    rtx prev = PREV_INSN (trial);\n+\t    rtx_insn *next = NEXT_INSN (trial);\n+\t    rtx_insn *prev = PREV_INSN (trial);\n \t    if (prev)\n \t      SET_NEXT_INSN (prev) = next;\n \t    if (next)\n@@ -2292,12 +2300,12 @@ fill_simple_delay_slots (int non_jumps_p)\n    If the returned label is obtained by following a crossing jump,\n    set *CROSSING to true, otherwise set it to false.  */\n \n-static rtx\n-follow_jumps (rtx label, rtx jump, bool *crossing)\n+static rtx_insn *\n+follow_jumps (rtx_insn *label, rtx jump, bool *crossing)\n {\n-  rtx insn;\n-  rtx next;\n-  rtx value = label;\n+  rtx_insn *insn;\n+  rtx_insn *next;\n+  rtx_insn *value = label;\n   int depth;\n \n   *crossing = false;\n@@ -2314,7 +2322,7 @@ follow_jumps (rtx label, rtx jump, bool *crossing)\n \t&& BARRIER_P (next));\n        depth++)\n     {\n-      rtx this_label = JUMP_LABEL (insn);\n+      rtx_insn *this_label = JUMP_LABEL_AS_INSN (insn);\n \n       /* If we have found a cycle, make the insn jump to itself.  */\n       if (this_label == label)\n@@ -2362,15 +2370,16 @@ follow_jumps (rtx label, rtx jump, bool *crossing)\n    case, we can only take insns from the head of the thread for our delay\n    slot.  We then adjust the jump to point after the insns we have taken.  */\n \n-static rtx\n-fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n-\t\t\trtx opposite_thread, int likely, int thread_if_true,\n+static rtx_insn_list *\n+fill_slots_from_thread (rtx_insn *insn, rtx condition, rtx_insn *thread,\n+\t\t\trtx_insn *opposite_thread, int likely,\n+\t\t\tint thread_if_true,\n \t\t\tint own_thread, int slots_to_fill,\n-\t\t\tint *pslots_filled, rtx delay_list)\n+\t\t\tint *pslots_filled, rtx_insn_list *delay_list)\n {\n-  rtx new_thread;\n+  rtx_insn *new_thread;\n   struct resources opposite_needed, set, needed;\n-  rtx trial;\n+  rtx_insn *trial;\n   int lose = 0;\n   int must_annul = 0;\n   int flags;\n@@ -2511,7 +2520,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t\t   : check_annul_list_true_false (1, delay_list)\n \t\t     && eligible_for_annul_true (insn, *pslots_filled, trial, flags)))\n \t\t{\n-\t\t  rtx temp;\n+\t\t  rtx_insn *temp;\n \n \t\t  must_annul = 1;\n \t\twinner:\n@@ -2664,12 +2673,13 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       && GET_CODE (PATTERN (trial)) == SEQUENCE\n       && JUMP_P (XVECEXP (PATTERN (trial), 0, 0)))\n     {\n+      rtx_sequence *sequence = as_a <rtx_sequence *> (PATTERN (trial));\n       /* If this is the `true' thread, we will want to follow the jump,\n \t so we can only do this if we have taken everything up to here.  */\n       if (thread_if_true && trial == new_thread)\n \t{\n \t  delay_list\n-\t    = steal_delay_list_from_target (insn, condition, PATTERN (trial),\n+\t    = steal_delay_list_from_target (insn, condition, sequence,\n \t\t\t\t\t    delay_list, &set, &needed,\n \t\t\t\t\t    &opposite_needed, slots_to_fill,\n \t\t\t\t\t    pslots_filled, &must_annul,\n@@ -2682,7 +2692,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       else if (! thread_if_true)\n \tdelay_list\n \t  = steal_delay_list_from_fallthrough (insn, condition,\n-\t\t\t\t\t       PATTERN (trial),\n+\t\t\t\t\t       sequence,\n \t\t\t\t\t       delay_list, &set, &needed,\n \t\t\t\t\t       &opposite_needed, slots_to_fill,\n \t\t\t\t\t       pslots_filled, &must_annul);\n@@ -2724,7 +2734,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t{\n \t  rtx other = XEXP (src, 1);\n \t  rtx new_arith;\n-\t  rtx ninsn;\n+\t  rtx_insn *ninsn;\n \n \t  /* If this is a constant adjustment, use the same code with\n \t     the negated constant.  Otherwise, reverse the sense of the\n@@ -2764,7 +2774,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t  if (thread_if_true)\n \t    INSN_FROM_TARGET_P (ninsn) = 1;\n \n-\t  delay_list = add_to_delay_list (ninsn, NULL_RTX);\n+\t  delay_list = add_to_delay_list (ninsn, NULL);\n \t  (*pslots_filled)++;\n \t}\n     }\n@@ -2786,7 +2796,8 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t  && redirect_with_delay_list_safe_p (insn,\n \t\t\t\t\t      JUMP_LABEL (new_thread),\n \t\t\t\t\t      delay_list))\n-\tnew_thread = follow_jumps (JUMP_LABEL (new_thread), insn, &crossing);\n+\tnew_thread = follow_jumps (JUMP_LABEL_AS_INSN (new_thread), insn,\n+\t\t\t\t   &crossing);\n \n       if (ANY_RETURN_P (new_thread))\n \tlabel = find_end_label (new_thread);\n@@ -2819,15 +2830,15 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n static void\n fill_eager_delay_slots (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   int i;\n   int num_unfilled_slots = unfilled_slots_next - unfilled_slots_base;\n \n   for (i = 0; i < num_unfilled_slots; i++)\n     {\n       rtx condition;\n-      rtx target_label, insn_at_target, fallthrough_insn;\n-      rtx delay_list = 0;\n+      rtx_insn *target_label, *insn_at_target, *fallthrough_insn;\n+      rtx_insn_list *delay_list = 0;\n       int own_target;\n       int own_fallthrough;\n       int prediction, slots_to_fill, slots_filled;\n@@ -2855,7 +2866,7 @@ fill_eager_delay_slots (void)\n \tcontinue;\n \n       slots_filled = 0;\n-      target_label = JUMP_LABEL (insn);\n+      target_label = JUMP_LABEL_AS_INSN (insn);\n       condition = get_branch_condition (insn, target_label);\n \n       if (condition == 0)\n@@ -2899,7 +2910,7 @@ fill_eager_delay_slots (void)\n \t\t we might have found a redundant insn which we deleted\n \t\t from the thread that was filled.  So we have to recompute\n \t\t the next insn at the target.  */\n-\t      target_label = JUMP_LABEL (insn);\n+\t      target_label = JUMP_LABEL_AS_INSN (insn);\n \t      insn_at_target = first_active_target_insn (target_label);\n \n \t      delay_list\n@@ -3137,10 +3148,11 @@ label_before_next_insn (rtx x, rtx scan_limit)\n    threading.  */\n \n static void\n-relax_delay_slots (rtx first)\n+relax_delay_slots (rtx_insn *first)\n {\n-  rtx insn, next, pat;\n-  rtx trial, delay_insn, target_label;\n+  rtx_insn *insn, *next;\n+  rtx_sequence *pat;\n+  rtx_insn *trial, *delay_insn, *target_label;\n \n   /* Look at every JUMP_INSN and see if we can improve it.  */\n   for (insn = first; insn; insn = next)\n@@ -3155,7 +3167,7 @@ relax_delay_slots (rtx first)\n \t group of consecutive labels.  */\n       if (JUMP_P (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n-\t  && !ANY_RETURN_P (target_label = JUMP_LABEL (insn)))\n+\t  && !ANY_RETURN_P (target_label = JUMP_LABEL_AS_INSN (insn)))\n \t{\n \t  target_label\n \t    = skip_consecutive_labels (follow_jumps (target_label, insn,\n@@ -3230,7 +3242,7 @@ relax_delay_slots (rtx first)\n \t  && 0 > mostly_true_jump (other))\n \t{\n \t  rtx other_target = JUMP_LABEL (other);\n-\t  target_label = JUMP_LABEL (insn);\n+\t  target_label = JUMP_LABEL_AS_INSN (insn);\n \n \t  if (invert_jump (other, target_label, 0))\n \t    reorg_redirect_jump (insn, other_target);\n@@ -3240,16 +3252,16 @@ relax_delay_slots (rtx first)\n       if (!NONJUMP_INSN_P (insn) || GET_CODE (PATTERN (insn)) != SEQUENCE)\n \tcontinue;\n \n-      pat = PATTERN (insn);\n-      delay_insn = XVECEXP (pat, 0, 0);\n+      pat = as_a <rtx_sequence *> (PATTERN (insn));\n+      delay_insn = pat->insn (0);\n \n       /* See if the first insn in the delay slot is redundant with some\n \t previous insn.  Remove it from the delay slot if so; then set up\n \t to reprocess this insn.  */\n-      if (redundant_insn (XVECEXP (pat, 0, 1), delay_insn, 0))\n+      if (redundant_insn (pat->insn (1), delay_insn, 0))\n \t{\n-\t  update_block (XVECEXP (pat, 0, 1), insn);\n-\t  delete_from_delay_slot (XVECEXP (pat, 0, 1));\n+\t  update_block (pat->insn (1), insn);\n+\t  delete_from_delay_slot (pat->insn (1));\n \t  next = prev_active_insn (next);\n \t  continue;\n \t}\n@@ -3302,7 +3314,7 @@ relax_delay_slots (rtx first)\n \t  || !(condjump_p (delay_insn) || condjump_in_parallel_p (delay_insn)))\n \tcontinue;\n \n-      target_label = JUMP_LABEL (delay_insn);\n+      target_label = JUMP_LABEL_AS_INSN (delay_insn);\n       if (target_label && ANY_RETURN_P (target_label))\n \tcontinue;\n \n@@ -3360,15 +3372,16 @@ relax_delay_slots (rtx first)\n \t  && simplejump_or_return_p (XVECEXP (PATTERN (trial), 0, 0))\n \t  && redundant_insn (XVECEXP (PATTERN (trial), 0, 1), insn, 0))\n \t{\n-\t  target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));\n+\t  rtx_sequence *trial_seq = as_a <rtx_sequence *> (PATTERN (trial));\n+\t  target_label = JUMP_LABEL_AS_INSN (trial_seq->insn (0));\n \t  if (ANY_RETURN_P (target_label))\n \t    target_label = find_end_label (target_label);\n \t  \n \t  if (target_label\n \t      && redirect_with_delay_slots_safe_p (delay_insn, target_label,\n \t\t\t\t\t\t   insn))\n \t    {\n-\t      update_block (XVECEXP (PATTERN (trial), 0, 1), insn);\n+\t      update_block (trial_seq->insn (1), insn);\n \t      reorg_redirect_jump (delay_insn, target_label);\n \t      next = insn;\n \t      continue;\n@@ -3429,7 +3442,7 @@ relax_delay_slots (rtx first)\n \t  && label_before_next_insn (next, insn) == target_label\n \t  && simplejump_p (insn)\n \t  && XVECLEN (pat, 0) == 2\n-\t  && rtx_equal_p (PATTERN (next), PATTERN (XVECEXP (pat, 0, 1))))\n+\t  && rtx_equal_p (PATTERN (next), PATTERN (pat->insn (1))))\n \t{\n \t  delete_related_insns (insn);\n \t  continue;\n@@ -3488,10 +3501,10 @@ relax_delay_slots (rtx first)\n \n       /* If we own the thread opposite the way this insn branches, see if we\n \t can merge its delay slots with following insns.  */\n-      if (INSN_FROM_TARGET_P (XVECEXP (pat, 0, 1))\n+      if (INSN_FROM_TARGET_P (pat->insn (1))\n \t  && own_thread_p (NEXT_INSN (insn), 0, 1))\n \ttry_merge_delay_insns (insn, next);\n-      else if (! INSN_FROM_TARGET_P (XVECEXP (pat, 0, 1))\n+      else if (! INSN_FROM_TARGET_P (pat->insn (1))\n \t       && own_thread_p (target_label, target_label, 0))\n \ttry_merge_delay_insns (insn, next_active_insn (target_label));\n \n@@ -3649,9 +3662,9 @@ make_return_insns (rtx first)\n /* Try to find insns to place in delay slots.  */\n \n static void\n-dbr_schedule (rtx first)\n+dbr_schedule (rtx_insn *first)\n {\n-  rtx insn, next, epilogue_insn = 0;\n+  rtx_insn *insn, *next, *epilogue_insn = 0;\n   int i;\n   bool need_return_insns;\n \n@@ -3701,15 +3714,15 @@ dbr_schedule (rtx first)\n       if (JUMP_P (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && !ANY_RETURN_P (JUMP_LABEL (insn))\n-\t  && ((target = skip_consecutive_labels (JUMP_LABEL (insn)))\n+\t  && ((target = skip_consecutive_labels (JUMP_LABEL_AS_INSN (insn)))\n \t      != JUMP_LABEL (insn)))\n \tredirect_jump (insn, target, 1);\n     }\n \n   init_resource_info (epilogue_insn);\n \n   /* Show we haven't computed an end-of-function label yet.  */\n-  function_return_label = function_simple_return_label = NULL_RTX;\n+  function_return_label = function_simple_return_label = NULL;\n \n   /* Initialize the statistics for this function.  */\n   memset (num_insns_needing_delays, 0, sizeof num_insns_needing_delays);"}]}