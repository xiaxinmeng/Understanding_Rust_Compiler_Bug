{"sha": "5b8b526e694bca2034af4cdeb8ad15e356446a98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI4YjUyNmU2OTRiY2EyMDM0YWY0Y2RlYjhhZDE1ZTM1NjQ0NmE5OA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-17T19:33:19Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-17T19:33:19Z"}, "message": "In gcc/: 2010-10-17 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * doc/objc.texi (GNU Objective-C runtime API): New section.\n        (Modern GNU Objective-C runtime API): New section.\n        (Traditional GNU Objective-C runtime API): New section.\n        (Executing code before main): Mention that this section is\n        specific to the GNU Objective-C runtime.\n        (Garbage Collection): Same.\n\nIn gcc/testsuite/:\n2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * obj-c++.dg/gnu-api-2-class.mm: New.\n        * obj-c++.dg/gnu-api-2-ivar.mm: New.\n        * obj-c++.dg/gnu-api-2-method.mm: New.\n        * obj-c++.dg/gnu-api-2-objc.mm: New.\n        * obj-c++.dg/gnu-api-2-object.mm: New.\n        * obj-c++.dg/gnu-api-2-property.mm: New.\n        * obj-c++.dg/gnu-api-2-protocol.mm: New.\n        * obj-c++.dg/gnu-api-2-sel.mm: New.\n\n\nIn libobjc/:\n2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc/message.h: Moved initial includes outside of extern \"C\".\n        * objc/runtime.h: Add extern \"C\" for Objective-C++.\n\nFrom-SVN: r165595", "tree": {"sha": "21e63a2c01fdd1ab461d151039afa15a5bfe542e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21e63a2c01fdd1ab461d151039afa15a5bfe542e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b8b526e694bca2034af4cdeb8ad15e356446a98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8b526e694bca2034af4cdeb8ad15e356446a98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b8b526e694bca2034af4cdeb8ad15e356446a98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8b526e694bca2034af4cdeb8ad15e356446a98/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91b90ead334deba8a963afbf1cb6947ca16bf2ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b90ead334deba8a963afbf1cb6947ca16bf2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b90ead334deba8a963afbf1cb6947ca16bf2ff"}], "stats": {"total": 1641, "additions": 1636, "deletions": 5}, "files": [{"sha": "4e9cb738028f617d8e773f5fff2adef83fd66610", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -1,3 +1,12 @@\n+2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* doc/objc.texi (GNU Objective-C runtime API): New section.\n+\t(Modern GNU Objective-C runtime API): New section.\n+\t(Traditional GNU Objective-C runtime API): New section.\n+\t(Executing code before main): Mention that this section is\n+\tspecific to the GNU Objective-C runtime.\n+\t(Garbage Collection): Same.\n+\n 2010-10-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* c-parser.c (c_parser_for_statement): Move initialization of"}, {"sha": "ed5d390a84ea01951ae5d1b9726252451b89380c", "filename": "gcc/doc/objc.texi", "status": "modified", "additions": 120, "deletions": 1, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Fdoc%2Fobjc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Fdoc%2Fobjc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fobjc.texi?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -9,10 +9,11 @@\n @chapter GNU Objective-C features\n \n This document is meant to describe some of the GNU Objective-C\n-features.  It is not intended to teach you Objective-C, there are\n+features.  It is not intended to teach you Objective-C.  There are\n several resources on the Internet that present the language.\n \n @menu\n+* GNU Objective-C runtime API::\n * Executing code before main::\n * Type encoding::\n * Garbage Collection::\n@@ -23,9 +24,124 @@ several resources on the Internet that present the language.\n * Fast enumeration::\n @end menu\n \n+@c =========================================================================\n+@node GNU Objective-C runtime API\n+@section GNU Objective-C runtime API\n+\n+This section is specific for the GNU Objective-C runtime.  If you are\n+using a different runtime, you can skip it.\n+\n+The GNU Objective-C runtime provides an API that allows you to\n+interact with the Objective-C runtime system, querying the live\n+runtime structures and even manipulating them.  This allows you for\n+example to inspect and navigate classes, methods and protocols; to\n+define new classes or new methods, and even to modify existing classes\n+or protocols.\n+\n+If you are using a ``Foundation'' library such as GNUstep-Base, this\n+library will provide you with a rich set of functionality to do most\n+of the inspection tasks, and you probably will only need direct access\n+to the GNU Objective-C runtime API to define new classes or methods.\n+\n+@menu\n+* Modern GNU Objective-C runtime API::\n+* Traditional GNU Objective-C runtime API::\n+@end menu\n+\n+@c =========================================================================\n+@node Modern GNU Objective-C runtime API\n+@subsection Modern GNU Objective-C runtime API\n+\n+The GNU Objective-C runtime provides an API which is similar to the\n+one provided by the ``Objective-C 2.0'' Apple/NeXT Objective-C\n+runtime.  The API is documented in the public header files of the GNU\n+Objective-C runtime:\n+\n+@itemize @bullet\n+\n+@item\n+@file{objc/objc.h}: this is the basic Objective-C header file,\n+defining the basic Objective-C types such as @code{id}, @code{Class}\n+and @code{BOOL}.  You have to include this header to do almost\n+anything with Objective-C.\n+\n+@item\n+@file{objc/runtime.h}: this header declares most of the public runtime\n+API functions allowing you to inspect and manipulate the Objective-C\n+runtime data structures.  These functions are fairly standardized\n+across Objective-C runtimes and are almost identical to the Apple/NeXT\n+Objective-C runtime ones.  It does not declare functions in some\n+specialized areas (constructing and forwarding message invocations,\n+threading) which are in the other headers below.  You have to include\n+@file{objc/objc.h} and @file{objc/runtime.h} to use any of the\n+functions, such as @code{class_getName()}, declared in\n+@file{objc/runtime.h}.\n+\n+@item\n+@file{objc/message.h}: this header declares public functions used to\n+construct, deconstruct and forward message invocations.  Because\n+messaging is done in quite a different way on different runtimes,\n+functions in this header are specific to the GNU Objective-C runtime\n+implementation.\n+\n+@item\n+@file{objc/objc-exception.h}: this header declares some public\n+functions related to Objective-C exceptions.  For example functions in\n+this header allow you to throw an Objective-C exception from plain\n+C/C++ code.\n+\n+@item\n+@file{objc/objc-sync.h}: this header declares some public functions\n+related to the Objective-C @code{@@synchronized()} syntax, allowing\n+you to emulate an Objective-C @code{@@synchronized()} block in plain\n+C/C++ code.\n+\n+@item\n+@file{objc/thr.h}: this header declares a public runtime API threading\n+layer that is only provided by the GNU Objective-C runtime.  It\n+declares functions such as @code{objc_mutex_lock()}, which provide a\n+platform-independent set of threading functions.\n+\n+@end itemize\n+\n+@c =========================================================================\n+@node Traditional GNU Objective-C runtime API\n+@subsection Traditional GNU Objective-C runtime API\n+\n+The GNU Objective-C runtime used to provide a different API, which we\n+call the ``traditional'' GNU Objective-C runtime API.  Functions\n+belonging to this API are easy to recognize because they use a\n+different naming convention, such as @code{class_get_super_class()}\n+(traditional API) instead of @code{class_getSuperclass()} (modern\n+API).  Software using this API includes the file\n+@file{objc/objc-api.h} where it is declared.\n+\n+The traditional API is deprecated but it is still supported in this\n+release of the runtime; you can access it as usual by including\n+@file{objc/objc-api.h}.\n+\n+If you are using the traditional API you are urged to upgrade your\n+software to use the modern API because the traditional API requires\n+access to private runtime internals to do anything serious with it;\n+for this reason, there is no guarantee that future releases of the GNU\n+Objective-C runtime library will be able to provide a fully compatible\n+@file{objc/objc-api.h} as the private runtime internals change.  It is\n+expected that the next release will hide a number of runtime internals\n+making the traditional API nominally supported but fairly useless\n+beyond very simple use cases.\n+\n+Finally, you can not include both @file{objc/objc-api.h} and\n+@file{objc/runtime.h} at the same time.  The traditional and modern\n+APIs unfortunately have some conflicting declarations (such as the one\n+for @code{Method}) and can not be used at the same time.\n+\n+@c =========================================================================\n @node Executing code before main\n @section @code{+load}: Executing code before main\n \n+This section is specific for the GNU Objective-C runtime.  If you are\n+using a different runtime, you can skip it.\n+\n The GNU Objective-C runtime provides a way that allows you to execute\n code before the execution of the program enters the @code{main}\n function.  The code is executed on a per-class and a per-category basis,\n@@ -480,6 +596,9 @@ of Objective-C methods.\n @node Garbage Collection\n @section Garbage Collection\n \n+This section is specific for the GNU Objective-C runtime.  If you are\n+using a different runtime, you can skip it.\n+\n Support for garbage collection with the GNU runtime has been added by\n using a powerful conservative garbage collector, known as the\n Boehm-Demers-Weiser conservative garbage collector."}, {"sha": "7004ca21102d0664dde87ad80fd2863d50353163", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -1,3 +1,14 @@\n+2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* obj-c++.dg/gnu-api-2-class.mm: New.\n+\t* obj-c++.dg/gnu-api-2-ivar.mm: New.\n+\t* obj-c++.dg/gnu-api-2-method.mm: New.\n+\t* obj-c++.dg/gnu-api-2-objc.mm: New.\n+\t* obj-c++.dg/gnu-api-2-object.mm: New.\n+\t* obj-c++.dg/gnu-api-2-property.mm: New.\n+\t* obj-c++.dg/gnu-api-2-protocol.mm: New.\n+\t* obj-c++.dg/gnu-api-2-sel.mm: New.\n+\n 2010-10-17  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* objc.dg/fsf-package-0.m: New."}, {"sha": "d6aa827bc8d976057863da9dc6515aa3d97651f8", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-class.mm", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,441 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'class', covering all functions starting with 'class'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+@interface DifferentClass : MyRootClass\n+- (id) myClass;\n+- (id) self;\n+@end\n+\n+@implementation DifferentClass\n+- (id) myClass { return object_getClass (self); }\n+- (id) self { return self; }\n+@end\n+\n+@interface MySubClass (MySelf)\n+- (id) mySelf;\n+@end\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  std::cout << \"Testing class_addIvar ()...\\n\";\n+  {\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MySubClass\"), \"MySubSubClass\", 0);\n+\n+    if (new_class == Nil)\n+      abort ();\n+    \n+    if (! class_addIvar (new_class, \"variable2_ivar\", sizeof (id),\n+\t\t\t __alignof__ (id), @encode (id)))\n+      abort ();\n+\n+    if (! class_addIvar (new_class, \"variable3_ivar\", sizeof (unsigned char),\n+\t\t\t __alignof__ (unsigned char), @encode (unsigned char)))\n+      abort ();\n+\n+    if (! class_addIvar (new_class, \"variable4_ivar\", sizeof (unsigned long),\n+\t\t\t __alignof__ (unsigned long), @encode (unsigned long)))\n+      abort ();\n+\n+    objc_registerClassPair (new_class);    \n+\n+    {\n+      MySubClass *o = [[objc_getClass (\"MySubSubClass\") alloc] init];\n+      Ivar variable2 = class_getInstanceVariable (objc_getClass (\"MySubSubClass\"), \"variable2_ivar\");\n+      Ivar variable3 = class_getInstanceVariable (objc_getClass (\"MySubSubClass\"), \"variable3_ivar\");\n+      Ivar variable4 = class_getInstanceVariable (objc_getClass (\"MySubSubClass\"), \"variable4_ivar\");\n+\n+      if (variable2 == NULL  || variable3 == NULL  ||  variable4 == NULL)\n+\tabort ();\n+      \n+      if (std::strcmp (ivar_getName (variable2), \"variable2_ivar\") != 0)\n+\tabort ();\n+\n+      if (std::strcmp (ivar_getName (variable3), \"variable3_ivar\") != 0)\n+\tabort ();\n+\n+      if (std::strcmp (ivar_getName (variable4), \"variable4_ivar\") != 0)\n+\tabort ();\n+\n+      {\n+\tunsigned char *var3 = (unsigned char *)((char *)o + ivar_getOffset (variable3));\n+\tunsigned long *var4 = (unsigned long *)((char *)o + ivar_getOffset (variable4));\n+\n+\tobject_setIvar (o, variable2, new_class);\n+\t*var3 = 230;\n+\t*var4 = 89000L;\n+\n+\tif (object_getIvar (o, variable2) != new_class)\n+\t  abort ();\n+\n+\tif (*var3 != 230)\n+\t  abort ();\n+\n+\tif (*var4 != 89000L)\n+\t  abort ();\n+      }\n+    }\n+  }\n+\n+  std::cout << \"Testing class_addMethod ()...\\n\";\n+  {\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MySubClass2\", 0);\n+    Method method1 = class_getInstanceMethod (objc_getClass (\"MySubClass\"), @selector (setVariable:));\n+    Method method2 = class_getInstanceMethod (objc_getClass (\"MySubClass\"), @selector (variable));\n+\n+    if (new_class == Nil)\n+      abort ();\n+    \n+    if (! class_addIvar (new_class, \"variable_ivar\", sizeof (id),\n+\t\t\t __alignof__ (id), @encode (id)))\n+      abort ();\n+\n+    if (! class_addMethod (new_class, @selector (setVariable:), method_getImplementation (method1),\n+\t\t\t   method_getTypeEncoding (method1)))\n+      abort ();\n+\n+    if (! class_addMethod (new_class, @selector (variable), method_getImplementation (method2),\n+\t\t\t   method_getTypeEncoding (method2)))\n+      abort ();\n+\n+    objc_registerClassPair (new_class);    \n+\n+    /* Now, MySubClass2 is basically the same as MySubClass!  We'll\n+       use the variable and setVariable: methods on it.  */\n+    {\n+      MySubClass *o = (MySubClass *)[[objc_getClass (\"MySubClass2\") alloc] init];\n+\n+      [o setVariable: o];\n+\n+      if ([o variable] != o)\n+\tabort ();\n+    }\n+  }\n+\n+  std::cout << \"Testing class_addProtocol ()...\\n\";\n+  {\n+    if (!class_addProtocol (objc_getClass (\"MySubClass\"), @protocol (MySecondProtocol)))\n+      abort ();\n+    \n+    if (!class_conformsToProtocol (objc_getClass (\"MySubClass\"), @protocol (MyProtocol)))\n+      abort ();\n+\n+    if (!class_conformsToProtocol (objc_getClass (\"MySubClass\"), @protocol (MySecondProtocol)))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_conformsToProtocol ()...\\n\";\n+  {\n+    if (class_conformsToProtocol (objc_getClass (\"MyRootClass\"), @protocol (MyProtocol)))\n+      abort ();\n+\n+    if (!class_conformsToProtocol (objc_getClass (\"MySubClass\"), @protocol (MyProtocol)))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_copyIvarList ()...\\n\";\n+  {\n+    unsigned int count;\n+    Ivar * list = class_copyIvarList (objc_getClass (\"MySubClass\"), &count);\n+\n+    if (count != 1)\n+      abort ();\n+\n+    if (std::strcmp (ivar_getName (list[0]), \"variable_ivar\") != 0)\n+      abort ();\n+    \n+    if (list[1] != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_copyMethodList ()...\\n\";\n+  {\n+    unsigned int count;\n+    Method * list = class_copyMethodList (objc_getClass (\"MySubClass\"), &count);\n+\n+    if (count != 2)\n+      abort ();\n+    \n+    if (! ((std::strcmp (sel_getName (method_getName (list[0])), \"variable\") == 0\n+\t    && std::strcmp (sel_getName (method_getName (list[1])), \"setVariable:\") == 0)\n+\t   || (std::strcmp (sel_getName (method_getName (list[0])), \"setVariable:\") == 0\n+\t       && std::strcmp (sel_getName (method_getName (list[1])), \"variable\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  /* TODO: Test new ABI (when available).  */\n+  std::cout << \"Testing class_copyPropertyList ()...\\n\";\n+  {\n+    unsigned int count;\n+    Property * list = class_copyPropertyList (objc_getClass (\"MySubClass\"), &count);\n+\n+    if (count != 0  ||  list != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_copyProtocolList ()...\\n\";\n+  {\n+    unsigned int count;\n+    Protocol ** list = class_copyProtocolList (objc_getClass (\"MySubClass\"), &count);\n+\n+    /* Remember that we added MySecondProtocol in the test above.  */\n+    if (count != 2)\n+      abort ();\n+\n+    if (! ((std::strcmp (protocol_getName (list[0]), \"MyProtocol\") == 0\n+\t    && std::strcmp (protocol_getName (list[1]), \"MySecondProtocol\") == 0)\n+\t   || (std::strcmp (protocol_getName (list[0]), \"MySecondProtocol\") == 0\n+\t       && std::strcmp (protocol_getName (list[1]), \"MyProtocol\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_createInstance ()...\\n\";\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    [object setVariable: object];\n+    if ([object variable] != object)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getClassMethod ()...\\n\";\n+  {\n+    Method method = class_getClassMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t  @selector(alloc));\n+\n+    if (method == NULL)\n+      abort ();\n+\n+    if (std::strcmp (sel_getName (method_getName (method)), \"alloc\") != 0)\n+      abort ();\n+\n+    if (class_getClassMethod (objc_getClass (\"MySubClass\"), \n+\t\t\t      @selector(variable)))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getClassVariable ()...\\n\";\n+  {\n+    if (class_getClassVariable (objc_getClass (\"MySubClass\"), \"variable_ivar\"))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getInstanceMethod ()...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"), \n+\t\t\t\t\t     @selector(variable));\n+\n+    if (method == NULL)\n+      abort ();\n+\n+    if (std::strcmp (sel_getName (method_getName (method)), \"variable\") != 0)\n+      abort ();\n+\n+    if (class_getInstanceMethod (objc_getClass (\"MySubClass\"), \n+\t\t\t\t @selector(alloc)))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getInstanceSize ()...\\n\";\n+  {\n+    if (class_getInstanceSize (objc_getClass (\"MyRootClass\")) != sizeof (struct objc_object))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getInstanceVariable ()...\\n\";\n+  {\n+    Ivar variable = class_getInstanceVariable (objc_getClass (\"MySubClass\"), \"variable_ivar\");\n+\n+    if (variable == NULL)\n+      abort ();\n+\n+    if (std::strcmp (ivar_getName (variable), \"variable_ivar\") != 0)\n+      abort ();\n+\n+    if (class_getInstanceVariable (objc_getClass (\"MySubClass\"), \"variable_ivar_no\"))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getIvarLayout ()...\\n\";\n+  {\n+    if (class_getIvarLayout (objc_getClass (\"MyRootClass\")) != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getMethodImplementation ()...\\n\";\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+    IMP imp = class_getMethodImplementation (objc_getClass (\"MySubClass\"), \n+\t\t\t\t\t     @selector(variable));\n+\n+    if (imp == NULL)\n+      abort ();\n+\n+    [object setVariable: object];\n+\n+    if ((*imp)(object, @selector(variable)) != object)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* std::cout << \"Testing class_getMethodImplementation_stret ()...\\n\"; */\n+\n+  std::cout << \"Testing class_getName ()...\\n\";\n+  {\n+    if (std::strcmp (class_getName (objc_getClass (\"MyRootClass\")),\n+\t\t\"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  /* TODO: Test new ABI (when available).  */\n+  std::cout << \"Testing class_getProperty ()...\\n\";\n+  {\n+    if (class_getProperty (objc_getClass (\"MyRootClass\"), \"property\") != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getSuperclass ()...\\n\";\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+    if (class_getSuperclass (object_getClass (object)) != objc_getClass (\"MyRootClass\"))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_getVersion ()...\\n\";\n+  {\n+    if (class_getVersion (objc_getClass (\"MySubClass\")) != 0)\n+      abort ();\n+  }\n+\n+   std::cout << \"Testing class_getWeakIvarLayout ()...\\n\";\n+  {\n+    if (class_getWeakIvarLayout (objc_getClass (\"MyRootClass\")) != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_isMetaClass ()...\\n\";\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+    if (class_isMetaClass (object_getClass (object)) \n+\t|| ! class_isMetaClass (object_getClass (object_getClass (object))))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing class_replaceMethod ()...\\n\";\n+  {\n+    Method new_method = class_getInstanceMethod (objc_getClass (\"DifferentClass\"),\n+\t\t\t\t\t\t @selector (myClass));\n+    Method old_method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t\t @selector (variable));\n+    const char *new_types = method_getTypeEncoding (new_method);\n+    IMP new_imp = method_getImplementation (new_method);\n+    const char *old_types = method_getTypeEncoding (old_method);\n+    IMP old_imp = class_replaceMethod (objc_getClass (\"MySubClass\"), @selector (variable),\n+\t\t\t\t       method_getImplementation (new_method),\n+\t\t\t\t       method_getTypeEncoding (new_method));\n+    MySubClass *o = [[MySubClass alloc] init];\n+\n+    [o setVariable: o];\n+\n+    /* Try the new method implementation.  */\n+    if ([o variable] != objc_getClass (\"MySubClass\"))\n+      abort ();\n+\n+    /* Put the original method back.  */\n+    class_replaceMethod (objc_getClass (\"MySubClass\"), @selector (variable),\n+\t\t\t old_imp, old_types);\n+\n+    /* Test it's back to what it was.  */\n+    if ([o variable] != o)\n+      abort ();    \n+\n+    {\n+      DifferentClass *o = [[DifferentClass alloc] init];\n+\n+      /* Finally, try adding a new method.  */\n+      class_replaceMethod (objc_getClass (\"DifferentClass\"), @selector (mySelf),\n+\t\t\t   new_imp, new_types);\n+      \n+      if ([(MySubClass*)o mySelf] != objc_getClass (\"DifferentClass\"))\n+\tabort ();\n+    }\n+  }\n+\n+  std::cout << \"Testing class_respondsToSelector ()...\\n\";\n+  {\n+    if (! class_respondsToSelector (objc_getClass (\"MySubClass\"), @selector(setVariable:)))\n+      abort ();\n+\n+    if (class_respondsToSelector (objc_getClass (\"MyRootClass\"), @selector(setVariable:)))\n+      abort ();\n+  }\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* std::cout << \"Testing class_setIvarLayout ()...\\n\"; */\n+\n+  std::cout << \"Testing class_setVersion ()...\\n\";\n+  {\n+    class_setVersion (objc_getClass (\"MySubClass\"), 45);\n+    \n+    if (class_getVersion (objc_getClass (\"MySubClass\")) != 45)\n+      abort ();\n+\n+    class_setVersion (objc_getClass (\"MySubClass\"), 46);\n+\n+    if (class_getVersion (objc_getClass (\"MySubClass\")) != 46)\n+      abort ();\n+  }\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* std::cout << \"Testing class_setWeakIvarLayout ()...\\n\"; */\n+\n+  return (0);\n+}"}, {"sha": "a95cbac7fcc7600388f1e4bb80d7a8bc02c39d5e", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-ivar.mm", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-ivar.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-ivar.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-ivar.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,80 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'ivar', covering all functions starting with 'ivar'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  std::cout << \"Testing ivar_getName () ...\\n\";\n+  {\n+    Ivar ivar = class_getInstanceVariable (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t   \"variable_ivar\");\n+   if (strcmp (ivar_getName (ivar), \"variable_ivar\") != 0)\n+      abort ();\n+\n+   ivar = class_getInstanceVariable (objc_getClass (\"MySubClass\"),\n+\t\t\t\t     \"variable\");\n+   if (ivar != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing ivar_getOffset () ...\\n\";\n+  {\n+    Ivar ivar = class_getInstanceVariable (objc_getClass (\"MyRootClass\"),\n+\t\t\t\t\t   \"isa\");\n+    if (ivar_getOffset (ivar) != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing ivar_getTypeEncoding () ...\\n\";\n+  {\n+    Ivar ivar = class_getInstanceVariable (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t   \"variable_ivar\");\n+    if (strcmp (ivar_getTypeEncoding (ivar), \"@\") != 0)\n+      abort ();\n+  }\n+\n+  return (0);\n+}"}, {"sha": "ea665052660f98d9f4269a4a726c2fa2727afd28", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-method.mm", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-method.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-method.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-method.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,227 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'method', covering all functions starting with 'method'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+- (id) constant;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+- (id) constant { return nil; }\n+@end\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  std::cout <<\"Testing method_copyArgumentType () ...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    char *type = method_copyArgumentType (method, 2);\n+\n+    if (type == NULL  ||  type[0] != '@')\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_copyReturnType () ...\\n\";\n+  {\n+    Method method = class_getClassMethod (objc_getClass (\"MyRootClass\"),\n+\t\t\t\t\t  @selector (alloc));\n+    char *type = method_copyReturnType (method);\n+\n+    /* Check that it returns an object.  */\n+    if (type == NULL  ||  type[0] != '@')\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_exchangeImplementations () ...\\n\";\n+  {\n+    Method method_a = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (variable));\n+    Method method_b = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (constant));\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    /* Check that things work as expected before the swap.  */\n+    [object setVariable: object];\n+\n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+\n+    /* Swap the methods.  */\n+    method_exchangeImplementations (method_a, method_b);\n+\n+    /* Check that behaviour has changed.  */\n+    if ([object variable] != nil  ||  [object constant] != object)\n+      abort ();\n+\n+    /* Swap the methods again.  */\n+    method_exchangeImplementations (method_a, method_b);\n+    \n+    /* Check that behaviour is back to normal.  */\n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_getArgumentType () ...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MyRootClass\"),\n+\t\t\t\t\t     @selector (init));\n+    char type[16];\n+    \n+    method_getArgumentType (method, 1, type, 16);\n+\n+    /* Check the second argument (_cmd), which should be a SEL.  */\n+    if (type[0] != ':')\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_getDescription () ...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (variable));\n+    struct objc_method_description *description = method_getDescription (method);\n+\n+    if (std::strcmp (sel_getName (description->name), \"variable\") != 0)\n+      abort ();\n+\n+    if (method_getDescription (NULL) != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_getImplementation () ...\\n\";\n+  {\n+    typedef void (*set_variable_function) (id receiver, SEL _cmd, id variable);\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    set_variable_function imp;\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    imp = (set_variable_function)(method_getImplementation (method));\n+    \n+    (*imp)(object, @selector (setVariable:), object);\n+\n+    if ([object variable] != object)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_getName () ...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    if (std::strcmp (sel_getName (method_getName (method)), \"setVariable:\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_getNumberOfArguments () ...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    if (method_getNumberOfArguments (method) != 3)\n+      abort ();\n+\n+    method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t      @selector (variable));\n+    if (method_getNumberOfArguments (method) != 2)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_getTypeEncoding () ...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    const char *types = method_getTypeEncoding (method);\n+\n+    /* Check that method type string starts with 'v' (void)  */\n+    if (types == NULL || types[0] != 'v')\n+      abort ();    \n+  }\n+\n+  std::cout << \"Testing method_getReturnType () ...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    char type[16];\n+    \n+    method_getReturnType (method, type, 16);\n+\n+    if (type[0] != 'v')\n+      abort ();\n+\n+    method_getReturnType (NULL, type, 16);\n+\n+    if (type[0] != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing method_setImplementation () ...\\n\";\n+  {\n+    Method method_a = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (variable));\n+    Method method_b = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (constant));\n+    IMP original_imp_a = method_getImplementation (method_a);\n+    IMP original_imp_b = method_getImplementation (method_b);\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    /* Check that things work as expected before the swap.  */\n+    [object setVariable: object];\n+    \n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+    \n+    /* Have 'variable' use the same implementation as 'constant'.  */\n+    if (method_setImplementation (method_a, original_imp_b) != original_imp_a)\n+      abort ();\n+\n+    /* Check that behaviour has changed.  */\n+    if ([object variable] != nil  ||  [object constant] != nil)\n+      abort ();\n+\n+    /* Put the original method back.  */\n+    if (method_setImplementation (method_a, original_imp_a) != original_imp_b)\n+      abort ();\n+    \n+    /* Check that behaviour is back to normal.  */\n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+  }\n+\n+  return (0);\n+}"}, {"sha": "e9bdee8daf38f60f1531fc394cc52dd37afe3783", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-objc.mm", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-objc.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-objc.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-objc.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,242 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'objc', covering all functions starting with 'objc'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  std::cout << \"Testing objc_allocateClassPair ()...\\n\";\n+  {\n+    Class new_root_class = objc_allocateClassPair (Nil, \"MyNewRootClass\", 0);\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MyNewSubClass\", 0);\n+\n+    /* A new root class would obviously need at least an 'isa'\n+       instance variable.  We don't add it so we never actually\n+       instantiate an instance of the class, which wouldn't work.  */\n+\n+    objc_registerClassPair (new_root_class);\n+    objc_registerClassPair (new_class);\n+\n+    if (std::strcmp (class_getName (new_class), \"MyNewSubClass\") != 0)\n+      abort ();\n+\n+    if (class_getSuperclass (new_class) != objc_getClass (\"MyRootClass\"))\n+      abort ();\n+\n+    if (std::strcmp (class_getName (new_root_class), \"MyNewRootClass\") != 0)\n+      abort ();\n+\n+    if (class_getSuperclass (new_root_class) != Nil)\n+      abort ();\n+\n+    {\n+      MySubClass *o = [[objc_getClass (\"MyNewSubClass\") alloc] init];\n+      \n+      if (object_getClass (o) != objc_getClass (\"MyNewSubClass\"))\n+\tabort ();\n+    }\n+  }\n+\n+  std::cout << \"Testing objc_copyProtocolList ()...\\n\";\n+  {\n+    /* Make sure both our two protocols are known to the runtime.  */\n+    id my_protocol = @protocol (MyProtocol);\n+    id my_second_protocol = @protocol (MySecondProtocol);\n+    unsigned int count;\n+    Protocol ** list = objc_copyProtocolList (&count);\n+\n+    if (count != 2)\n+      abort ();\n+\n+    if (! ((std::strcmp (protocol_getName (list[0]), \"MyProtocol\") == 0\n+\t    && std::strcmp (protocol_getName (list[1]), \"MySecondProtocol\") == 0)\n+\t   || (std::strcmp (protocol_getName (list[0]), \"MySecondProtocol\") == 0\n+\t       && std::strcmp (protocol_getName (list[1]), \"MyProtocol\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing objc_disposeClassPair ()...\\n\";\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"), @selector (setVariable:));\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MyNewSubClass\", 0);\n+\n+    /* Add a bit of everything to the class to exercise undoing all these changes.  */\n+\n+    /* Instance variable.  */\n+    class_addIvar (new_class, \"my_variable\", sizeof (float), __alignof__ (float), @encode (float));\n+\n+    /* Instance method.  */\n+    class_addMethod (new_class, @selector (setVariable:), method_getImplementation (method),\n+\t\t     method_getTypeEncoding (method));\n+\n+    /* Class method.  */\n+    class_addMethod (object_getClass (new_class), @selector (setVariable:), method_getImplementation (method),\n+\t\t     method_getTypeEncoding (method));\n+\n+    /* Protocol.  */\n+    class_addProtocol (new_class, @protocol (MyProtocol));\n+\n+    objc_disposeClassPair (new_class);\n+  }\n+\n+  /* This function currently does not exist with the GNU runtime.  */\n+  /* std::cout << \"Testing objc_duplicateClass ()...\\n\"; */\n+\n+  /* TODO - Test it when implemented in the GNU Runtime */\n+  /*  std::cout << \"Testing objc_getAssociatedObject ()...\\n\";  */\n+\n+  std::cout << \"Testing objc_getClass ()...\\n\";\n+  {\n+    if (std::strcmp (class_getName (objc_getClass (\"MySubClass\")),\n+\t\t\t\"MySubClass\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing objc_getClassList ()...\\n\";\n+  {\n+    Class *list;\n+    int i, count, other_count;\n+    count = objc_getClassList (NULL, 0);\n+\n+    /* count most likely will be 5, (MyRootClass, MySubClass,\n+       Protocol, Object, NXConstantString).  */\n+    if (count < 3)\n+      abort ();\n+    \n+    list = (Class *)(malloc (sizeof (Class) * count));\n+    other_count = objc_getClassList (list, count);\n+\n+    if (other_count != count)\n+      abort ();\n+\n+    /* Spot-check: search for class 'MyRootClass' in the list.  */\n+    for (i = 0; i < count; i++)\n+      {\n+\tif (std::strcmp (class_getName (list[i]), \"MyRootClass\") == 0)\n+\t  break;\n+      }\n+    if (i == count)\n+      abort ();\n+\n+    /* Spot-check: search for class 'MySubClass' in the list.  */\n+    for (i = 0; i < count; i++)\n+      {\n+\tif (std::strcmp (class_getName (list[i]), \"MySubClass\") == 0)\n+\t  break;\n+      }\n+    if (i == count)\n+      abort ();\n+\n+    /* Spot-check: search for class 'Protocol' in the list.  */\n+    for (i = 0; i < count; i++)\n+      {\n+\tif (std::strcmp (class_getName (list[i]), \"Protocol\") == 0)\n+\t  break;\n+      }\n+    if (i == count)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* std::cout << \"Testing objc_getFutureClass ()...\\n\"; */\n+\n+  std::cout << \"Testing objc_getMetaClass ()...\\n\";\n+  {\n+    if (! class_isMetaClass (objc_getMetaClass (\"MyRootClass\")))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing objc_getProtocol ()...\\n\";\n+  {\n+    if (! protocol_isEqual (objc_getProtocol (\"MyProtocol\"), @protocol (MyProtocol)))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing objc_getRequiredClass ()...\\n\";\n+  {\n+    if (std::strcmp (class_getName (objc_getRequiredClass (\"MyRootClass\")),\n+\t\t\t\"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing objc_lookupClass ()...\\n\";\n+  {\n+    if (std::strcmp (class_getName (objc_lookupClass (\"MyRootClass\")),\n+\t\t\t\"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* std::cout << \"Testing objc_setFutureClass ()...\\n\"; */\n+\n+  std::cout << \"Testing objc_registerClassPair ()...\\n\";\n+  {\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MySubClass\"), \"MySubSubClass\", 0);\n+\n+    class_addProtocol (new_class, @protocol (MySecondProtocol));\n+    \n+    objc_registerClassPair (new_class);\n+    \n+    if (std::strcmp (class_getName (new_class), \"MySubSubClass\") != 0)\n+      abort ();\n+\n+    if (class_getSuperclass (new_class) != objc_getClass (\"MySubClass\"))\n+      abort ();\n+\n+    if (! class_conformsToProtocol (new_class, @protocol (MySecondProtocol)))\n+      abort ();\n+  }\n+\n+  /* TODO - Test it when implemented in the GNU Runtime */\n+  /*  std::cout << \"Testing objc_removeAssociatedObjects ()...\\n\";  */\n+\n+  /* TODO - Test it when implemented in the GNU Runtime */\n+  /*  std::cout << \"Testing objc_setAssociatedObject ()...\\n\";  */\n+\n+  return (0);\n+}"}, {"sha": "2a544474d375b2a49bb7f40ade4c969c8b9fe0c0", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-object.mm", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-object.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-object.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-object.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,161 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'object', covering all functions starting with 'object'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+@interface MySubSubClass : MySubClass\n+- (id) test;\n+@end\n+\n+@implementation MySubSubClass\n+- (id) test { return self; }\n+@end\n+\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+  \n+  std::cout << \"Testing object_copy () ...\\n\";\n+  {\n+    MySubClass *object_a = [[MySubClass alloc] init];\n+    MySubClass *object_b = object_copy (object_a, 0);\n+\n+    [object_b setVariable: object_a];\n+    if ([object_b variable] != object_a)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing object_dispose () ...\\n\";\n+  {\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    object_dispose (object);\n+  }\n+\n+  std::cout << \"Testing object_getClass () ...\\n\";\n+  {\n+    MyRootClass *o = [[MySubClass alloc] init];\n+\n+    if (object_getClass (o) != objc_getClass (\"MySubClass\"))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing object_getClassName () ...\\n\";\n+  {\n+    MyRootClass *o = [[MyRootClass alloc] init];\n+\n+    if (std::strcmp (object_getClassName (o), \"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing object_getIndexedIvars () ...\\n\";\n+  {\n+    if (object_getIndexedIvars ([[MyRootClass alloc] init]) == NULL)\n+      abort ();\n+  }\n+  \n+  std::cout << \"Testing object_getInstanceVariable () ...\\n\";\n+  {\n+    MySubClass *o = [[MySubClass alloc] init];\n+    id value;\n+\n+    [o setVariable: o];\n+\n+    if (object_getInstanceVariable (o, \"variable_ivar\", (void **)&value) == NULL)\n+      abort ();\n+\n+    if (value != o)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing object_getIvar () ...\\n\";\n+  {\n+    MySubClass *o = [[MySubClass alloc] init];\n+    Ivar ivar = class_getInstanceVariable (objc_getClass (\"MySubClass\"), \"variable_ivar\");\n+\n+    [o setVariable: o];\n+\n+    if (object_getIvar (o, ivar) != o)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing object_setClass () ...\\n\";\n+  {\n+    MySubClass *o = [[MySubClass alloc] init];\n+\n+    object_setClass (o, objc_getClass (\"MySubSubClass\"));\n+\n+    if ([(MySubSubClass *)o test] != o)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing object_setInstanceVariable () ...\\n\";\n+  {\n+    MySubClass *o = [[MySubClass alloc] init];\n+    \n+    [o setVariable: nil];\n+\n+    if (object_setInstanceVariable (o, \"variable_ivar\", (void *)o) == NULL)\n+      abort ();\n+\n+    if ([o variable] != o)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing object_setIvar () ...\\n\";\n+  {\n+    MySubClass *o = [[MySubClass alloc] init];\n+    MySubClass *value = [[MySubClass alloc] init];\n+    Ivar ivar = class_getInstanceVariable (objc_getClass (\"MySubClass\"), \"variable_ivar\");\n+    \n+    [o setVariable: o];\n+\n+    object_setIvar (o, ivar, value);\n+\n+    if ([o variable] != value)\n+      abort ();\n+  }  \n+\n+  return (0);\n+}"}, {"sha": "9907d4438f3bca7a5fd747b2770ebdcf438134f0", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-property.mm", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-property.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-property.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-property.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,65 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'property', covering all functions starting with 'property'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  /* TODO: Test new ABI (when available).  */\n+  std::cout << \"Testing property_getAttributes () ...\\n\";\n+  {\n+    if (property_getAttributes (NULL) != NULL)\n+      abort ();\n+  }\n+\n+  /* TODO: Test new ABI (when available).  */\n+  std::cout << \"Testing property_getName () ...\\n\";\n+  {\n+    if (property_getName (NULL) != NULL)\n+      abort ();\n+  }\n+\n+  return (0);\n+}"}, {"sha": "1db7d7661830c907ef04da491e611346b1d6d7cb", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-protocol.mm", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-protocol.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-protocol.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-protocol.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,160 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'protocol', covering all functions starting with 'protocol'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@protocol MyThirdProtocol <MySecondProtocol>\n+- (id) setAnotherVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  std::cout << \"Testing protocol_conformsToProtocol ()...\\n\";\n+  {\n+    if (!protocol_conformsToProtocol (@protocol (MyProtocol),\n+\t\t\t\t      @protocol (MyProtocol)))\n+      abort ();\n+\n+    if (!protocol_conformsToProtocol (@protocol (MyThirdProtocol),\n+\t\t\t\t      @protocol (MySecondProtocol)))\n+      abort ();\n+\n+    if (protocol_conformsToProtocol (@protocol (MyProtocol),\n+\t\t\t\t     @protocol (MySecondProtocol)))\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing protocol_copyMethodDescriptionList ()...\\n\";\n+  {\n+    unsigned int count;\n+    struct objc_method_description *list;\n+\n+    list = protocol_copyMethodDescriptionList (@protocol (MyThirdProtocol),\n+\t\t\t\t\t       YES, YES, &count);\n+    \n+    if (count != 1)\n+      abort ();\n+\n+    if (std::strcmp (sel_getName (list[0].name), \"setAnotherVariable:\") != 0)\n+      abort ();\n+    \n+    if (list[1].name != NULL  &&  list[1].types != NULL)\n+      abort ();\n+  }\n+\n+  /* TODO: Test new ABI (when available).  */\n+  std::cout << \"Testing protocol_copyPropertyList ()...\\n\";\n+  {\n+    unsigned int count;\n+    Property *list;\n+\n+    list = protocol_copyPropertyList (@protocol (MyProtocol), &count);\n+\n+    if (count != 0  ||  list != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing protocol_copyProtocolList ()...\\n\";\n+  {\n+    unsigned int count;\n+    Protocol **list;\n+\n+    list = protocol_copyProtocolList (@protocol (MyThirdProtocol), &count);\n+    \n+    if (count != 1)\n+      abort ();\n+\n+    if (std::strcmp (protocol_getName (list[0]), \"MySecondProtocol\") != 0)\n+      abort ();\n+    \n+    if (list[1] != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing protocol_getMethodDescription ()...\\n\";\n+  {\n+    struct objc_method_description description;\n+\n+    description = protocol_getMethodDescription (@protocol (MySecondProtocol),\n+\t\t\t\t\t\t @selector (setVariable:),\n+\t\t\t\t\t\t YES, YES);\n+    if (description.name == NULL  &&  description.types == NULL)\n+      abort ();\n+\n+    if (std::strcmp (sel_getName (description.name), \"setVariable:\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing protocol_getName ()...\\n\";\n+  {\n+    if (std::strcmp (protocol_getName (@protocol (MyProtocol)), \"MyProtocol\") != 0)\n+      abort ();\n+  }\n+\n+  /* TODO: Test new ABI (when available).  */\n+  std::cout << \"Testing protocol_getProperty ()...\\n\";\n+  {\n+    Property property;\n+\n+    property = protocol_getProperty (objc_getProtocol (\"MyProtocol\"), \"someProperty\",\n+\t\t\t\t     YES, YES);\n+\n+    if (property != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing protocol_isEqual ()...\\n\";\n+  {\n+    if (!protocol_isEqual (@protocol (MyProtocol),\n+\t\t\t   @protocol (MyProtocol)))\n+      abort ();\n+\n+    if (!protocol_isEqual (@protocol (MyProtocol),\n+\t\t\t   objc_getProtocol (\"MyProtocol\")))\n+      abort ();\n+  }\n+\n+  return (0);\n+}"}, {"sha": "66cf0725c79cc934b06bb7d995339e9654ea7046", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-sel.mm", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-sel.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-sel.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-sel.mm?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -0,0 +1,103 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'sel', covering all functions starting with 'sel'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+@end\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  std::cout << \"Testing sel_getName () ...\\n\";\n+  {\n+    if (std::strcmp (sel_getName (@selector (variable)), \"variable\") != 0)\n+      abort ();\n+\n+    if (std::strcmp (sel_getName (NULL), \"<null selector>\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing sel_getType () ...\\n\";\n+  {\n+    /* Get a selector from a real class, so it has interesting\n+       types.  */\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (variable));\n+    \n+    if (std::strcmp (sel_getType (method_getName (method)), method_getTypeEncoding (method)) != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing sel_getUid () ...\\n\";\n+  {\n+    if (std::strcmp (sel_getName (sel_getUid (\"myMethod\")), \"myMethod\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing sel_isEqual () ...\\n\";\n+  {\n+    if (! sel_isEqual (@selector (setVariable:), @selector (setVariable:)))\n+      abort ();\n+  }\n+  \n+  std::cout << \"Testing sel_registerName () ...\\n\";\n+  {\n+    if (std::strcmp (sel_getName (sel_registerName (\"myMethod\")), \"myMethod\") != 0)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing set_registerTypedName () ...\\n\";\n+  {\n+    const char *types = method_getTypeEncoding (class_getInstanceMethod \n+\t\t\t\t\t\t(objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t\t @selector (variable)));\n+    SEL selector = sel_registerTypedName (\"aMethod\", types);\n+\t    \n+    if (std::strcmp (sel_getName (selector), \"aMethod\") != 0)\n+      abort ();\n+\n+    if (std::strcmp (sel_getType (selector), types) != 0)\n+      abort ();\n+  }\n+\n+  return (0);\n+}"}, {"sha": "3c79186211ba048df34277caa46c86bef2873c1a", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -1,3 +1,8 @@\n+2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc/message.h: Moved initial includes outside of extern \"C\".\n+\t* objc/runtime.h: Add extern \"C\" for Objective-C++.\n+\n 2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* init.c (objc_send_load): Do not wait for NXConstantString to be\n@@ -6,7 +11,7 @@\n \tas is the case for almost all users.\n \t* linking.m (__objc_linking): Do not try to forcefully link in\n \tNXConstantString.\n-\t\n+\n 2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc/runtime.h: Updated comments."}, {"sha": "b87153ea61c386dfcb29ec00ed06aa4edb6eec53", "filename": "libobjc/objc/message.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/libobjc%2Fobjc%2Fmessage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/libobjc%2Fobjc%2Fmessage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fmessage.h?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -26,13 +26,13 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef __objc_message_INCLUDE_GNU\n #define __objc_message_INCLUDE_GNU\n \n+#include \"objc.h\"\n+#include \"objc-decls.h\"\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-#include \"objc.h\"\n-#include \"objc-decls.h\"\n-\n /* This file includes declarations of the messaging functions and\n    types.\n */"}, {"sha": "b37eee2125b3c563a80738e967c1d90f33d8c43b", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8b526e694bca2034af4cdeb8ad15e356446a98/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8b526e694bca2034af4cdeb8ad15e356446a98/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=5b8b526e694bca2034af4cdeb8ad15e356446a98", "patch": "@@ -50,6 +50,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc.h\"\n #include \"objc-decls.h\"\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n /* An 'Ivar' represents an instance variable.  It holds information\n    about the name, type and offset of the instance variable.  */\n typedef struct objc_ivar *Ivar;\n@@ -1042,4 +1046,8 @@ void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n                                      unsigned int *align,\n                                      const char **type);\n \n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n #endif"}]}