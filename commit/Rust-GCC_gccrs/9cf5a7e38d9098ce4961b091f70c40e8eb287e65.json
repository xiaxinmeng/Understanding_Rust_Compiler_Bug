{"sha": "9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNmNWE3ZTM4ZDkwOThjZTQ5NjFiMDkxZjcwYzQwZThlYjI4N2U2NQ==", "commit": {"author": {"name": "Keith Besaw", "email": "kbesaw@us.ibm.com", "date": "2005-05-29T13:14:42Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-05-29T13:14:42Z"}, "message": "tree-ssa-alias.c (new_type_alias): New procedure to create a type memory tag for a pointer with a may-alias set...\n\n2005-05-29  Keith Besaw  <kbesaw@us.ibm.com>\n\n        * tree-ssa-alias.c (new_type_alias): New procedure to\n        create a type memory tag for a pointer with a may-alias\n        set determined from a variable declaration.\n        * tree-flow.h: export declaration of new_type_alias\n        * tree-optimize.c (init_tree_optimization_passes): document\n        that pass_may_alias cannot be called after pass_vectorize.\n        * tree-vect-transform (vect_create_data_ref_ptr): Call\n        new_type_alias when an type memory tag isn't available\n        for a reference.\n        (vectorizable_store): Use copy_virtual_operands to update\n        virtual defs in place (so that loop_version can be called).\n        Call mark_for_renaming for the virtual defs in case peeling\n        is done and virtual uses outside the loop need to be updated.\n\nFrom-SVN: r100322", "tree": {"sha": "e9e4e7917523b632ed676b411c41a27546c3875b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9e4e7917523b632ed676b411c41a27546c3875b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/comments", "author": null, "committer": null, "parents": [{"sha": "6778b96ce1fa7ca57bb6d95fb40e769abd02734b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6778b96ce1fa7ca57bb6d95fb40e769abd02734b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6778b96ce1fa7ca57bb6d95fb40e769abd02734b"}], "stats": {"total": 92, "additions": 74, "deletions": 18}, "files": [{"sha": "b0a3949f6fb270f57fb81baf474fd6ed6294bbeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "patch": "@@ -1,3 +1,19 @@\n+2005-05-29  Keith Besaw  <kbesaw@us.ibm.com>\n+\n+\t* tree-ssa-alias.c (new_type_alias): New procedure to\n+\tcreate a type memory tag for a pointer with a may-alias\n+\tset determined from a variable declaration.\n+\t* tree-flow.h: export declaration of new_type_alias\n+\t* tree-optimize.c (init_tree_optimization_passes): document\n+\tthat pass_may_alias cannot be called after pass_vectorize.\n+\t* tree-vect-transform (vect_create_data_ref_ptr): Call\n+\tnew_type_alias when an type memory tag isn't available\n+\tfor a reference.\n+\t(vectorizable_store): Use copy_virtual_operands to update\n+\tvirtual defs in place (so that loop_version can be called).\n+\tCall mark_for_renaming for the virtual defs in case peeling\n+\tis done and virtual uses outside the loop need to be updated.\n+\n 2005-05-29  Dorit Naishlos  <dorit@il.ibm.com>\n \n \tPR tree-optimization/21639"}, {"sha": "fda3e576892cbdf38621c96973dd848921ecc08b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "patch": "@@ -570,6 +570,7 @@ extern void debug_points_to_info_for (tree);\n extern bool may_be_aliased (tree);\n extern struct ptr_info_def *get_ptr_info (tree);\n extern void add_type_alias (tree, tree);\n+extern void new_type_alias (tree, tree);\n extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *, bool *);\n static inline subvar_t get_subvars_for_var (tree);\n static inline bool ref_contains_array_ref (tree);"}, {"sha": "4d02e5572cc8a61baf7a1b5c8da100a8372ac104", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "patch": "@@ -478,6 +478,9 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_iv_canon);\n   NEXT_PASS (pass_if_conversion);\n   NEXT_PASS (pass_vectorize);\n+  /* NEXT_PASS (pass_may_alias) cannot be done again because the\n+     vectorizer creates alias relations that are not supported by\n+     pass_may_alias.  */\n   NEXT_PASS (pass_lower_vector_ssa);\n   NEXT_PASS (pass_complete_unroll);\n   NEXT_PASS (pass_iv_optimize);"}, {"sha": "f8b992accd6c71e3de7c2029a4296b8e0d133d20", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "patch": "@@ -2776,6 +2776,39 @@ add_type_alias (tree ptr, tree var)\n }\n \n \n+/* Create a type tag for PTR.  Construct the may-alias list of this type tag\n+   so that it has the aliasing of VAR.  */\n+\n+void\n+new_type_alias (tree ptr, tree var)\n+{\n+  var_ann_t p_ann = var_ann (ptr);\n+  tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n+  var_ann_t v_ann = var_ann (var);\n+  tree tag;\n+  subvar_t svars;\n+\n+  gcc_assert (p_ann->type_mem_tag == NULL_TREE);\n+  gcc_assert (v_ann->mem_tag_kind == NOT_A_TAG);\n+  tag = create_memory_tag (tag_type, true);\n+  p_ann->type_mem_tag = tag;\n+\n+  /* Add VAR to the may-alias set of PTR's new type tag.  If VAR has\n+     subvars, add the subvars to the tag instead of the actual var.  */\n+  if (var_can_have_subvars (var)\n+      && (svars = get_subvars_for_var (var)))\n+    {\n+      subvar_t sv;      \n+      for (sv = svars; sv; sv = sv->next)\n+        add_may_alias (tag, sv->var);\n+    }\n+  else\n+    add_may_alias (tag, var);\n+\n+  /* Note, TAG and its set of aliases are not marked for renaming.  */\n+}\n+\n+\n /* This structure is simply used during pushing fields onto the fieldstack\n    to track the offset of the field, since bitpos_of_field gives it relative\n    to its immediate containing type, and we want it relative to the ultimate"}, {"sha": "9be19dc2eb44383181641bbdd64df48e90e0c617", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cf5a7e38d9098ce4961b091f70c40e8eb287e65/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=9cf5a7e38d9098ce4961b091f70c40e8eb287e65", "patch": "@@ -350,16 +350,13 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tag = STMT_VINFO_MEMTAG (stmt_info);\n   gcc_assert (tag);\n \n-  /* If the memory tag of the original reference was not a type tag or\n-     if the pointed-to type of VECT_PTR has an alias set number\n-     different than TAG's, then we need to create a new type tag for\n-     VECT_PTR and add TAG to its alias set.  */\n-  if (var_ann (tag)->mem_tag_kind == NOT_A_TAG\n-      || get_alias_set (tag) != get_alias_set (TREE_TYPE (vect_ptr_type)))\n-    add_type_alias (vect_ptr, tag);\n+  /* If tag is a variable (and NOT_A_TAG) than a new type alias\n+     tag must be created with tag added to its may alias list.  */\n+  if (var_ann (tag)->mem_tag_kind == NOT_A_TAG)\n+    new_type_alias (vect_ptr, tag);\n   else\n     var_ann (vect_ptr)->type_mem_tag = tag;\n-  \n+\n   var_ann (vect_ptr)->subvars = STMT_VINFO_SUBVARS (stmt_info);\n \n   /** (3) Calculate the initial address the vector-pointer, and set\n@@ -896,8 +893,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n-  ssa_op_iter iter;\n   tree def;\n+  ssa_op_iter iter;\n \n   /* Is vectorizable store? */\n \n@@ -955,16 +952,22 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   *vec_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd1);\n   vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n \n-  /* Mark all non-SSA variables in the statement for rewriting.  */\n-  mark_new_vars_to_rename (*vec_stmt);\n-\t    \n-  /* The new vectorized statement will have better aliasing\n-     information, so some of the virtual definitions of the old\n-     statement will likely disappear from the IL.  Mark them to have\n-     their SSA form updated.  */\n+  /* Copy the V_MAY_DEFS representing the aliasing of the original array\n+     element's definition to the vector's definition then update the\n+     defining statement.  The original is being deleted so the same\n+     SSA_NAMEs can be used.  */\n+  copy_virtual_operands (*vec_stmt, stmt);\n+\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n-    mark_sym_for_renaming (SSA_NAME_VAR (def));\n- \n+    {\n+      SSA_NAME_DEF_STMT (def) = *vec_stmt;\n+\n+      /* If this virtual def has a use outside the loop and a loop peel is performed\n+         then the def may be renamed by the peel.  Mark it for renaming so the\n+         later use will also be renamed.  */\n+      mark_sym_for_renaming (SSA_NAME_VAR (def));\n+    }\n+\n   return true;\n }\n "}]}