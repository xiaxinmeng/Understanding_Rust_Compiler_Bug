{"sha": "6ce13072311aaa5194488797f127c2b202d72b25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlMTMwNzIzMTFhYWE1MTk0NDg4Nzk3ZjEyN2MyYjIwMmQ3MmIyNQ==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2016-05-26T09:58:56Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2016-05-26T09:58:56Z"}, "message": "target.c (gomp_device_copy): New function.\n\nlibgomp/\n2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n\n\t* target.c (gomp_device_copy): New function.\n\t(gomp_copy_host2dev): Likewise.\n\t(gomp_copy_dev2host): Likewise.\n\t(gomp_free_device_memory): Likewise.\n\t(gomp_map_vars_existing): Adjust to call gomp_copy_host2dev.\n\t(gomp_map_pointer): Likewise.\n\t(gomp_map_vars): Adjust to call gomp_copy_host2dev, handle\n\tNULL value from alloc_func plugin hook.\n\t(gomp_unmap_tgt): Adjust to call gomp_free_device_memory.\n\t(gomp_copy_from_async): Adjust to call gomp_copy_dev2host.\n\t(gomp_unmap_vars): Likewise.\n\t(gomp_update): Adjust to call gomp_copy_dev2host and\n\tgomp_copy_host2dev functions.\n\t(gomp_unload_image_from_device): Handle false value from\n\tunload_image_func plugin hook.\n\t(gomp_init_device): Handle false value from init_device_func\n\tplugin hook.\n\t(gomp_exit_data): Adjust to call gomp_copy_dev2host.\n\t(omp_target_free): Adjust to call gomp_free_device_memory.\n\t(omp_target_memcpy): Handle return values from host2dev_func,\n\tdev2host_func, and dev2dev_func plugin hooks.\n\t(omp_target_memcpy_rect_worker): Likewise.\n\t(gomp_target_fini): Handle false value from fini_device_func\n\tplugin hook.\n\t* libgomp.h (struct gomp_device_descr): Adjust return type of\n\tinit_device_func, fini_device_func, unload_image_func, free_func,\n\tdev2host_func,host2dev_func, and dev2dev_func plugin hooks to 'bool'.\n\t* oacc-init.c (acc_shutdown_1): Handle false value from\n\tfini_device_func plugin hook.\n\t* oacc-host.c (host_init_device): Change return type to bool.\n\t(host_fini_device): Likewise.\n\t(host_unload_image): Likewise.\n\t(host_free): Likewise.\n\t(host_dev2host): Likewise.\n\t(host_host2dev): Likewise.\n\t* oacc-mem.c (acc_free): Handle plugin hook fatal error case.\n\t(acc_memcpy_to_device): Likewise.\n\t(acc_memcpy_from_device): Likewise.\n\t(delete_copyout): Add libfnname parameter, handle free_func\n\thook fatal error case.\n\t(acc_delete): Adjust delete_copyout call.\n\t(acc_copyout): Likewise.\n\t(update_dev_host): Move gomp_mutex_unlock to after\n\thost2dev/dev2host hook calls.\n\n\t* plugin/plugin-hsa.c (hsa_warn): Adjust 'hsa_error' local variable\n\tto 'hsa_error_msg', for clarity.\n\t(hsa_fatal): Likewise.\n\t(hsa_error): New function.\n\t(init_hsa_context): Change return type to bool, adjust to return\n\tfalse on error.\n\t(GOMP_OFFLOAD_get_num_devices): Adjust to handle init_hsa_context\n\treturn value.\n\t(GOMP_OFFLOAD_init_device): Change return type to bool, adjust to\n\treturn false on error.\n\t(get_agent_info): Adjust to return NULL on error.\n\t(destroy_hsa_program): Change return type to bool, adjust to\n\treturn false on error.\n\t(GOMP_OFFLOAD_load_image): Adjust to return -1 on error.\n\t(destroy_module): Change return type to bool, adjust to\n\treturn false on error.\n\t(GOMP_OFFLOAD_unload_image): Likewise.\n\t(GOMP_OFFLOAD_fini_device): Likewise.\n\t(GOMP_OFFLOAD_alloc): Change to return NULL when called.\n\t(GOMP_OFFLOAD_free): Change to return false when called.\n\t(GOMP_OFFLOAD_dev2host): Likewise.\n\t(GOMP_OFFLOAD_host2dev): Likewise.\n\t(GOMP_OFFLOAD_dev2dev): Likewise.\n\n\t* plugin/plugin-nvptx.c (CUDA_CALL_ERET): New convenience macro.\n\t(CUDA_CALL): Likewise.\n\t(CUDA_CALL_ASSERT): Likewise.\n\t(map_init): Change return type to bool, use CUDA_CALL* macros.\n\t(map_fini): Likewise.\n\t(init_streams_for_device): Change return type to bool, adjust\n\tcall to map_init.\n\t(fini_streams_for_device): Change return type to bool, adjust\n\tcall to map_fini.\n\t(select_stream_for_async): Release stream_lock before calls to\n\tGOMP_PLUGIN_fatal, adjust call to map_init.\n\t(nvptx_init): Use CUDA_CALL* macros.\n\t(nvptx_attach_host_thread_to_device): Change return type to bool,\n\tuse CUDA_CALL* macros.\n\t(nvptx_open_device): Use CUDA_CALL* macros.\n\t(nvptx_close_device): Change return type to bool, use CUDA_CALL*\n\tmacros.\n\t(nvptx_get_num_devices): Use CUDA_CALL* macros.\n\t(link_ptx): Change return type to bool, use CUDA_CALL* macros.\n\t(nvptx_exec): Use CUDA_CALL* macros.\n\t(nvptx_alloc): Use CUDA_CALL* macros.\n\t(nvptx_free): Change return type to bool, use CUDA_CALL* macros.\n\t(nvptx_host2dev): Likewise.\n\t(nvptx_dev2host): Likewise.\n\t(nvptx_wait): Use CUDA_CALL* macros.\n\t(nvptx_wait_async): Likewise.\n\t(nvptx_wait_all): Likewise.\n\t(nvptx_wait_all_async): Likewise.\n\t(nvptx_set_cuda_stream): Adjust order of stream_lock acquire,\n\tuse CUDA_CALL* macros, adjust call to map_fini.\n\t(GOMP_OFFLOAD_init_device): Change return type to bool,\n\tadjust code accordingly.\n\t(GOMP_OFFLOAD_fini_device): Likewise.\n\t(GOMP_OFFLOAD_load_image): Adjust calls to\n\tnvptx_attach_host_thread_to_device/link_ptx to handle errors,\n\tuse CUDA_CALL* macros.\n\t(GOMP_OFFLOAD_unload_image): Change return type to bool, adjust\n\treturn code.\n\t(GOMP_OFFLOAD_alloc): Adjust calls to code to handle error return.\n\t(GOMP_OFFLOAD_free): Change return type to bool, adjust calls to\n\thandle error return.\n\t(GOMP_OFFLOAD_dev2host): Likewise.\n\t(GOMP_OFFLOAD_host2dev): Likewise.\n\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Use CUDA_CALL* macros.\n\t(GOMP_OFFLOAD_openacc_create_thread_data): Likewise.\n\nliboffloadmic/\n2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n\n\t* plugin/libgomp-plugin-intelmic.cpp (offload): Change return type\n\tto bool, adjust return code.\n\t(GOMP_OFFLOAD_init_device): Likewise.\n\t(GOMP_OFFLOAD_fini_device): Likewise.\n\t(get_target_table): Likewise.\n\t(offload_image): Likwise.\n\t(GOMP_OFFLOAD_load_image): Adjust call to offload_image(), change\n\tto return -1 on error.\n\t(GOMP_OFFLOAD_unload_image): Change return type to bool, adjust return\n\tcode.\n\t(GOMP_OFFLOAD_alloc): Likewise.\n\t(GOMP_OFFLOAD_free): Likewise.\n\t(GOMP_OFFLOAD_host2dev): Likewise.\n\t(GOMP_OFFLOAD_dev2host): Likewise.\n\t(GOMP_OFFLOAD_dev2dev): Likewise.\n\nFrom-SVN: r236768", "tree": {"sha": "1788f7eb15481be06ce674ae4ed2f5734bedeb2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1788f7eb15481be06ce674ae4ed2f5734bedeb2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ce13072311aaa5194488797f127c2b202d72b25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce13072311aaa5194488797f127c2b202d72b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce13072311aaa5194488797f127c2b202d72b25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce13072311aaa5194488797f127c2b202d72b25/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1875b9a02d4e9da706729f73691e32ef8ace858f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1875b9a02d4e9da706729f73691e32ef8ace858f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1875b9a02d4e9da706729f73691e32ef8ace858f"}], "stats": {"total": 1425, "additions": 852, "deletions": 573}, "files": [{"sha": "e2496ff5833f3c2baab0c6f27ee29d01bee34158", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -1,3 +1,120 @@\n+2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* target.c (gomp_device_copy): New function.\n+\t(gomp_copy_host2dev): Likewise.\n+\t(gomp_copy_dev2host): Likewise.\n+\t(gomp_free_device_memory): Likewise.\n+\t(gomp_map_vars_existing): Adjust to call gomp_copy_host2dev.\n+\t(gomp_map_pointer): Likewise.\n+\t(gomp_map_vars): Adjust to call gomp_copy_host2dev, handle\n+\tNULL value from alloc_func plugin hook.\n+\t(gomp_unmap_tgt): Adjust to call gomp_free_device_memory.\n+\t(gomp_copy_from_async): Adjust to call gomp_copy_dev2host.\n+\t(gomp_unmap_vars): Likewise.\n+\t(gomp_update): Adjust to call gomp_copy_dev2host and\n+\tgomp_copy_host2dev functions.\n+\t(gomp_unload_image_from_device): Handle false value from\n+\tunload_image_func plugin hook.\n+\t(gomp_init_device): Handle false value from init_device_func\n+\tplugin hook.\n+\t(gomp_exit_data): Adjust to call gomp_copy_dev2host.\n+\t(omp_target_free): Adjust to call gomp_free_device_memory.\n+\t(omp_target_memcpy): Handle return values from host2dev_func,\n+\tdev2host_func, and dev2dev_func plugin hooks.\n+\t(omp_target_memcpy_rect_worker): Likewise.\n+\t(gomp_target_fini): Handle false value from fini_device_func\n+\tplugin hook.\n+\t* libgomp.h (struct gomp_device_descr): Adjust return type of\n+\tinit_device_func, fini_device_func, unload_image_func, free_func,\n+\tdev2host_func,host2dev_func, and dev2dev_func plugin hooks to 'bool'.\n+\t* oacc-init.c (acc_shutdown_1): Handle false value from\n+\tfini_device_func plugin hook.\n+\t* oacc-host.c (host_init_device): Change return type to bool.\n+\t(host_fini_device): Likewise.\n+\t(host_unload_image): Likewise.\n+\t(host_free): Likewise.\n+\t(host_dev2host): Likewise.\n+\t(host_host2dev): Likewise.\n+\t* oacc-mem.c (acc_free): Handle plugin hook fatal error case.\n+\t(acc_memcpy_to_device): Likewise.\n+\t(acc_memcpy_from_device): Likewise.\n+\t(delete_copyout): Add libfnname parameter, handle free_func\n+\thook fatal error case.\n+\t(acc_delete): Adjust delete_copyout call.\n+\t(acc_copyout): Likewise.\n+\t(update_dev_host): Move gomp_mutex_unlock to after\n+\thost2dev/dev2host hook calls.\n+\n+\t* plugin/plugin-hsa.c (hsa_warn): Adjust 'hsa_error' local variable\n+\tto 'hsa_error_msg', for clarity.\n+\t(hsa_fatal): Likewise.\n+\t(hsa_error): New function.\n+\t(init_hsa_context): Change return type to bool, adjust to return\n+\tfalse on error.\n+\t(GOMP_OFFLOAD_get_num_devices): Adjust to handle init_hsa_context\n+\treturn value.\n+\t(GOMP_OFFLOAD_init_device): Change return type to bool, adjust to\n+\treturn false on error.\n+\t(get_agent_info): Adjust to return NULL on error.\n+\t(destroy_hsa_program): Change return type to bool, adjust to\n+\treturn false on error.\n+\t(GOMP_OFFLOAD_load_image): Adjust to return -1 on error.\n+\t(destroy_module): Change return type to bool, adjust to\n+\treturn false on error.\n+\t(GOMP_OFFLOAD_unload_image): Likewise.\n+\t(GOMP_OFFLOAD_fini_device): Likewise.\n+\t(GOMP_OFFLOAD_alloc): Change to return NULL when called.\n+\t(GOMP_OFFLOAD_free): Change to return false when called.\n+\t(GOMP_OFFLOAD_dev2host): Likewise.\n+\t(GOMP_OFFLOAD_host2dev): Likewise.\n+\t(GOMP_OFFLOAD_dev2dev): Likewise.\n+\n+\t* plugin/plugin-nvptx.c (CUDA_CALL_ERET): New convenience macro.\n+\t(CUDA_CALL): Likewise.\n+\t(CUDA_CALL_ASSERT): Likewise.\n+\t(map_init): Change return type to bool, use CUDA_CALL* macros.\n+\t(map_fini): Likewise.\n+\t(init_streams_for_device): Change return type to bool, adjust\n+\tcall to map_init.\n+\t(fini_streams_for_device): Change return type to bool, adjust\n+\tcall to map_fini.\n+\t(select_stream_for_async): Release stream_lock before calls to\n+\tGOMP_PLUGIN_fatal, adjust call to map_init.\n+\t(nvptx_init): Use CUDA_CALL* macros.\n+\t(nvptx_attach_host_thread_to_device): Change return type to bool,\n+\tuse CUDA_CALL* macros.\n+\t(nvptx_open_device): Use CUDA_CALL* macros.\n+\t(nvptx_close_device): Change return type to bool, use CUDA_CALL*\n+\tmacros.\n+\t(nvptx_get_num_devices): Use CUDA_CALL* macros.\n+\t(link_ptx): Change return type to bool, use CUDA_CALL* macros.\n+\t(nvptx_exec): Use CUDA_CALL* macros.\n+\t(nvptx_alloc): Use CUDA_CALL* macros.\n+\t(nvptx_free): Change return type to bool, use CUDA_CALL* macros.\n+\t(nvptx_host2dev): Likewise.\n+\t(nvptx_dev2host): Likewise.\n+\t(nvptx_wait): Use CUDA_CALL* macros.\n+\t(nvptx_wait_async): Likewise.\n+\t(nvptx_wait_all): Likewise.\n+\t(nvptx_wait_all_async): Likewise.\n+\t(nvptx_set_cuda_stream): Adjust order of stream_lock acquire,\n+\tuse CUDA_CALL* macros, adjust call to map_fini.\n+\t(GOMP_OFFLOAD_init_device): Change return type to bool,\n+\tadjust code accordingly.\n+\t(GOMP_OFFLOAD_fini_device): Likewise.\n+\t(GOMP_OFFLOAD_load_image): Adjust calls to\n+\tnvptx_attach_host_thread_to_device/link_ptx to handle errors,\n+\tuse CUDA_CALL* macros.\n+\t(GOMP_OFFLOAD_unload_image): Change return type to bool, adjust\n+\treturn code.\n+\t(GOMP_OFFLOAD_alloc): Adjust calls to code to handle error return.\n+\t(GOMP_OFFLOAD_free): Change return type to bool, adjust calls to\n+\thandle error return.\n+\t(GOMP_OFFLOAD_dev2host): Likewise.\n+\t(GOMP_OFFLOAD_host2dev): Likewise.\n+\t(GOMP_OFFLOAD_openacc_register_async_cleanup): Use CUDA_CALL* macros.\n+\t(GOMP_OFFLOAD_openacc_create_thread_data): Likewise.\n+\n 2016-05-24  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* oacc-mem.c (acc_malloc): Update handling of shared-memory targets."}, {"sha": "f0c048b151bccfb4f82a3074da2c4ee0cb6633d4", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -930,16 +930,16 @@ struct gomp_device_descr\n   unsigned int (*get_caps_func) (void);\n   int (*get_type_func) (void);\n   int (*get_num_devices_func) (void);\n-  void (*init_device_func) (int);\n-  void (*fini_device_func) (int);\n+  bool (*init_device_func) (int);\n+  bool (*fini_device_func) (int);\n   unsigned (*version_func) (void);\n   int (*load_image_func) (int, unsigned, const void *, struct addr_pair **);\n-  void (*unload_image_func) (int, unsigned, const void *);\n+  bool (*unload_image_func) (int, unsigned, const void *);\n   void *(*alloc_func) (int, size_t);\n-  void (*free_func) (int, void *);\n-  void *(*dev2host_func) (int, void *, const void *, size_t);\n-  void *(*host2dev_func) (int, void *, const void *, size_t);\n-  void *(*dev2dev_func) (int, void *, const void *, size_t);\n+  bool (*free_func) (int, void *);\n+  bool (*dev2host_func) (int, void *, const void *, size_t);\n+  bool (*host2dev_func) (int, void *, const void *, size_t);\n+  bool (*dev2dev_func) (int, void *, const void *, size_t);\n   bool (*can_run_func) (void *);\n   void (*run_func) (int, void *, void *, void **);\n   void (*async_run_func) (int, void *, void *, void **, void *);"}, {"sha": "a24899c7f60c5676d827224efac61cdaee908dec", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -60,14 +60,16 @@ host_get_num_devices (void)\n   return 1;\n }\n \n-static void\n+static bool\n host_init_device (int n __attribute__ ((unused)))\n {\n+  return true;\n }\n \n-static void\n+static bool\n host_fini_device (int n __attribute__ ((unused)))\n {\n+  return true;\n }\n \n static unsigned\n@@ -85,11 +87,12 @@ host_load_image (int n __attribute__ ((unused)),\n   return 0;\n }\n \n-static void\n+static bool\n host_unload_image (int n __attribute__ ((unused)),\n \t\t   unsigned v __attribute__ ((unused)),\n \t\t   const void *t __attribute__ ((unused)))\n {\n+  return true;\n }\n \n static void *\n@@ -98,28 +101,29 @@ host_alloc (int n __attribute__ ((unused)), size_t s)\n   return gomp_malloc (s);\n }\n \n-static void\n+static bool\n host_free (int n __attribute__ ((unused)), void *p)\n {\n   free (p);\n+  return true;\n }\n \n-static void *\n+static bool\n host_dev2host (int n __attribute__ ((unused)),\n \t       void *h __attribute__ ((unused)),\n \t       const void *d __attribute__ ((unused)),\n \t       size_t s __attribute__ ((unused)))\n {\n-  return NULL;\n+  return true;\n }\n \n-static void *\n+static bool\n host_host2dev (int n __attribute__ ((unused)),\n \t       void *d __attribute__ ((unused)),\n \t       const void *h __attribute__ ((unused)),\n \t       size_t s __attribute__ ((unused)))\n {\n-  return NULL;\n+  return true;\n }\n \n static void"}, {"sha": "f2325adfb46663570da6da57253fd5557943dfdb", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -300,21 +300,24 @@ acc_shutdown_1 (acc_device_t d)\n \n   gomp_mutex_unlock (&goacc_thread_lock);\n \n-\n   /* Close all the devices of this type that have been opened.  */\n+  bool ret = true;\n   for (i = 0; i < ndevs; i++)\n     {\n       struct gomp_device_descr *acc_dev = &base_dev[i];\n       gomp_mutex_lock (&acc_dev->lock);\n       if (acc_dev->state == GOMP_DEVICE_INITIALIZED)\n         {\n \t  devices_active = true;\n-\t  acc_dev->fini_device_func (acc_dev->target_id);\n+\t  ret &= acc_dev->fini_device_func (acc_dev->target_id);\n \t  acc_dev->state = GOMP_DEVICE_UNINITIALIZED;\n \t}\n       gomp_mutex_unlock (&acc_dev->lock);\n     }\n \n+  if (!ret)\n+    gomp_fatal (\"device finalization failed\");\n+\n   if (!devices_active)\n     gomp_fatal (\"no device initialized\");\n }"}, {"sha": "2aaa0d295cbe3208774fc3efd7cfa03c4d26510f", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -149,7 +149,8 @@ acc_free (void *d)\n   else\n     gomp_mutex_unlock (&acc_dev->lock);\n \n-  acc_dev->free_func (acc_dev->target_id, d);\n+  if (!acc_dev->free_func (acc_dev->target_id, d))\n+    gomp_fatal (\"error in freeing device memory in %s\", __FUNCTION__);\n }\n \n void\n@@ -167,7 +168,8 @@ acc_memcpy_to_device (void *d, void *h, size_t s)\n       return;\n     }\n \n-  thr->dev->host2dev_func (thr->dev->target_id, d, h, s);\n+  if (!thr->dev->host2dev_func (thr->dev->target_id, d, h, s))\n+    gomp_fatal (\"error in %s\", __FUNCTION__);\n }\n \n void\n@@ -185,7 +187,8 @@ acc_memcpy_from_device (void *h, void *d, size_t s)\n       return;\n     }\n \n-  thr->dev->dev2host_func (thr->dev->target_id, h, d, s);\n+  if (!thr->dev->dev2host_func (thr->dev->target_id, h, d, s))\n+    gomp_fatal (\"error in %s\", __FUNCTION__);\n }\n \n /* Return the device pointer that corresponds to host data H.  Or NULL\n@@ -520,7 +523,7 @@ acc_present_or_copyin (void *h, size_t s)\n #define FLAG_COPYOUT (1 << 0)\n \n static void\n-delete_copyout (unsigned f, void *h, size_t s)\n+delete_copyout (unsigned f, void *h, size_t s, const char *libfnname)\n {\n   size_t host_size;\n   splay_tree_key n;\n@@ -563,18 +566,20 @@ delete_copyout (unsigned f, void *h, size_t s)\n \n   acc_unmap_data (h);\n \n-  acc_dev->free_func (acc_dev->target_id, d);\n+  if (!acc_dev->free_func (acc_dev->target_id, d))\n+    gomp_fatal (\"error in freeing device memory in %s\", libfnname);\n }\n \n void\n acc_delete (void *h , size_t s)\n {\n-  delete_copyout (0, h, s);\n+  delete_copyout (0, h, s, __FUNCTION__);\n }\n \n-void acc_copyout (void *h, size_t s)\n+void\n+acc_copyout (void *h, size_t s)\n {\n-  delete_copyout (FLAG_COPYOUT, h, s);\n+  delete_copyout (FLAG_COPYOUT, h, s, __FUNCTION__);\n }\n \n static void\n@@ -604,12 +609,12 @@ update_dev_host (int is_dev, void *h, size_t s)\n   d = (void *) (n->tgt->tgt_start + n->tgt_offset\n \t\t+ (uintptr_t) h - n->host_start);\n \n-  gomp_mutex_unlock (&acc_dev->lock);\n-\n   if (is_dev)\n     acc_dev->host2dev_func (acc_dev->target_id, d, h, s);\n   else\n     acc_dev->dev2host_func (acc_dev->target_id, h, d, s);\n+\n+  gomp_mutex_unlock (&acc_dev->lock);\n }\n \n void"}, {"sha": "bed8555fb90eb3adf4b2607849ac8e2fc9e890ab", "filename": "libgomp/plugin/plugin-hsa.c", "status": "modified", "additions": 176, "deletions": 76, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Fplugin%2Fplugin-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Fplugin%2Fplugin-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-hsa.c?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -175,10 +175,10 @@ hsa_warn (const char *str, hsa_status_t status)\n   if (!debug)\n     return;\n \n-  const char *hsa_error;\n-  hsa_status_string (status, &hsa_error);\n+  const char *hsa_error_msg;\n+  hsa_status_string (status, &hsa_error_msg);\n \n-  fprintf (stderr, \"HSA warning: %s\\nRuntime message: %s\", str, hsa_error);\n+  fprintf (stderr, \"HSA warning: %s\\nRuntime message: %s\", str, hsa_error_msg);\n }\n \n /* Report a fatal error STR together with the HSA error corresponding to STATUS\n@@ -187,10 +187,23 @@ hsa_warn (const char *str, hsa_status_t status)\n static void\n hsa_fatal (const char *str, hsa_status_t status)\n {\n-  const char *hsa_error;\n-  hsa_status_string (status, &hsa_error);\n+  const char *hsa_error_msg;\n+  hsa_status_string (status, &hsa_error_msg);\n   GOMP_PLUGIN_fatal (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n-\t\t     hsa_error);\n+\t\t     hsa_error_msg);\n+}\n+\n+/* Like hsa_fatal, except only report error message, and return FALSE\n+   for propagating error processing to outside of plugin.  */\n+\n+static bool\n+hsa_error (const char *str, hsa_status_t status)\n+{\n+  const char *hsa_error_msg;\n+  hsa_status_string (status, &hsa_error_msg);\n+  GOMP_PLUGIN_error (\"HSA fatal error: %s\\nRuntime message: %s\", str,\n+\t\t     hsa_error_msg);\n+  return false;\n }\n \n struct hsa_kernel_description\n@@ -418,33 +431,38 @@ assign_agent_ids (hsa_agent_t agent, void *data)\n   return HSA_STATUS_SUCCESS;\n }\n \n-/* Initialize hsa_context if it has not already been done.  */\n+/* Initialize hsa_context if it has not already been done.\n+   Return TRUE on success.  */\n \n-static void\n+static bool\n init_hsa_context (void)\n {\n   hsa_status_t status;\n   int agent_index = 0;\n \n   if (hsa_context.initialized)\n-    return;\n+    return true;\n   init_enviroment_variables ();\n   status = hsa_init ();\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Run-time could not be initialized\", status);\n+    return hsa_error (\"Run-time could not be initialized\", status);\n   HSA_DEBUG (\"HSA run-time initialized\\n\");\n   status = hsa_iterate_agents (count_gpu_agents, NULL);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"HSA GPU devices could not be enumerated\", status);\n+    return hsa_error (\"HSA GPU devices could not be enumerated\", status);\n   HSA_DEBUG (\"There are %i HSA GPU devices.\\n\", hsa_context.agent_count);\n \n   hsa_context.agents\n     = GOMP_PLUGIN_malloc_cleared (hsa_context.agent_count\n \t\t\t\t  * sizeof (struct agent_info));\n   status = hsa_iterate_agents (assign_agent_ids, &agent_index);\n   if (agent_index != hsa_context.agent_count)\n-    GOMP_PLUGIN_fatal (\"Failed to assign IDs to all HSA agents\");\n+    {\n+      GOMP_PLUGIN_error (\"Failed to assign IDs to all HSA agents\");\n+      return false;\n+    }\n   hsa_context.initialized = true;\n+  return true;\n }\n \n /* Callback of dispatch queues to report errors.  */\n@@ -492,75 +510,100 @@ get_kernarg_memory_region (hsa_region_t region, void *data)\n int\n GOMP_OFFLOAD_get_num_devices (void)\n {\n-  init_hsa_context ();\n+  if (!init_hsa_context ())\n+    return 0;\n   return hsa_context.agent_count;\n }\n \n /* Part of the libgomp plugin interface.  Initialize agent number N so that it\n-   can be used for computation.  */\n+   can be used for computation.  Return TRUE on success.  */\n \n-void\n+bool\n GOMP_OFFLOAD_init_device (int n)\n {\n-  init_hsa_context ();\n+  if (!init_hsa_context ())\n+    return false;\n   if (n >= hsa_context.agent_count)\n-    GOMP_PLUGIN_fatal (\"Request to initialize non-existing HSA device %i\", n);\n+    {\n+      GOMP_PLUGIN_error (\"Request to initialize non-existing HSA device %i\", n);\n+      return false;\n+    }\n   struct agent_info *agent = &hsa_context.agents[n];\n \n   if (agent->initialized)\n-    return;\n+    return true;\n \n   if (pthread_rwlock_init (&agent->modules_rwlock, NULL))\n-    GOMP_PLUGIN_fatal (\"Failed to initialize an HSA agent rwlock\");\n+    {\n+      GOMP_PLUGIN_error (\"Failed to initialize an HSA agent rwlock\");\n+      return false;\n+    }\n   if (pthread_mutex_init (&agent->prog_mutex, NULL))\n-    GOMP_PLUGIN_fatal (\"Failed to initialize an HSA agent program mutex\");\n+    {\n+      GOMP_PLUGIN_error (\"Failed to initialize an HSA agent program mutex\");\n+      return false;\n+    }\n \n   uint32_t queue_size;\n   hsa_status_t status;\n   status = hsa_agent_get_info (agent->id, HSA_AGENT_INFO_QUEUE_MAX_SIZE,\n \t\t\t       &queue_size);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Error requesting maximum queue size of the HSA agent\", status);\n+    return hsa_error (\"Error requesting maximum queue size of the HSA agent\",\n+\t\t      status);\n   status = hsa_agent_get_info (agent->id, HSA_AGENT_INFO_ISA, &agent->isa);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Error querying the ISA of the agent\", status);\n+    return hsa_error (\"Error querying the ISA of the agent\", status);\n   status = hsa_queue_create (agent->id, queue_size, HSA_QUEUE_TYPE_MULTI,\n \t\t\t     queue_callback, NULL, UINT32_MAX, UINT32_MAX,\n \t\t\t     &agent->command_q);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Error creating command queue\", status);\n+    return hsa_error (\"Error creating command queue\", status);\n \n   status = hsa_queue_create (agent->id, queue_size, HSA_QUEUE_TYPE_MULTI,\n \t\t\t     queue_callback, NULL, UINT32_MAX, UINT32_MAX,\n \t\t\t     &agent->kernel_dispatch_command_q);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Error creating kernel dispatch command queue\", status);\n+    return hsa_error (\"Error creating kernel dispatch command queue\", status);\n \n   agent->kernarg_region.handle = (uint64_t) -1;\n   status = hsa_agent_iterate_regions (agent->id, get_kernarg_memory_region,\n \t\t\t\t      &agent->kernarg_region);\n   if (agent->kernarg_region.handle == (uint64_t) -1)\n-    GOMP_PLUGIN_fatal (\"Could not find suitable memory region for kernel \"\n-\t\t       \"arguments\");\n+    {\n+      GOMP_PLUGIN_error (\"Could not find suitable memory region for kernel \"\n+\t\t\t \"arguments\");\n+      return false;\n+    }\n   HSA_DEBUG (\"HSA agent initialized, queue has id %llu\\n\",\n \t     (long long unsigned) agent->command_q->id);\n   HSA_DEBUG (\"HSA agent initialized, kernel dispatch queue has id %llu\\n\",\n \t     (long long unsigned) agent->kernel_dispatch_command_q->id);\n   agent->initialized = true;\n+  return true;\n }\n \n /* Verify that hsa_context has already been initialized and return the\n-   agent_info structure describing device number N.  */\n+   agent_info structure describing device number N.  Return NULL on error.  */\n \n static struct agent_info *\n get_agent_info (int n)\n {\n   if (!hsa_context.initialized)\n-    GOMP_PLUGIN_fatal (\"Attempt to use uninitialized HSA context.\");\n+    {\n+      GOMP_PLUGIN_error (\"Attempt to use uninitialized HSA context.\");\n+      return NULL;\n+    }\n   if (n >= hsa_context.agent_count)\n-    GOMP_PLUGIN_fatal (\"Request to operate on anon-existing HSA device %i\", n);\n+    {\n+      GOMP_PLUGIN_error (\"Request to operate on anon-existing HSA device %i\", n);\n+      return NULL;\n+    }\n   if (!hsa_context.agents[n].initialized)\n-    GOMP_PLUGIN_fatal (\"Attempt to use an uninitialized HSA agent.\");\n+    {\n+      GOMP_PLUGIN_error (\"Attempt to use an uninitialized HSA agent.\");\n+      return NULL;\n+    }\n   return &hsa_context.agents[n];\n }\n \n@@ -590,21 +633,22 @@ remove_module_from_agent (struct agent_info *agent, struct module_info *module)\n }\n \n /* Free the HSA program in agent and everything associated with it and set\n-   agent->prog_finalized and the initialized flags of all kernels to false.  */\n+   agent->prog_finalized and the initialized flags of all kernels to false.\n+   Return TRUE on success.  */\n \n-static void\n+static bool\n destroy_hsa_program (struct agent_info *agent)\n {\n   if (!agent->prog_finalized || agent->prog_finalized_error)\n-    return;\n+    return true;\n \n   hsa_status_t status;\n \n   HSA_DEBUG (\"Destroying the current HSA program.\\n\");\n \n   status = hsa_executable_destroy (agent->executable);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Could not destroy HSA executable\", status);\n+    return hsa_error (\"Could not destroy HSA executable\", status);\n \n   struct module_info *module;\n   for (module = agent->first_module; module; module = module->next)\n@@ -614,6 +658,7 @@ destroy_hsa_program (struct agent_info *agent)\n \tmodule->kernels[i].initialized = false;\n     }\n   agent->prog_finalized = false;\n+  return true;\n }\n \n /* Part of the libgomp plugin interface.  Load BRIG module described by struct\n@@ -625,9 +670,12 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, void *target_data,\n \t\t\t struct addr_pair **target_table)\n {\n   if (GOMP_VERSION_DEV (version) > GOMP_VERSION_HSA)\n-    GOMP_PLUGIN_fatal (\"Offload data incompatible with HSA plugin\"\n-\t\t       \" (expected %u, received %u)\",\n-\t\t       GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n+    {\n+      GOMP_PLUGIN_error (\"Offload data incompatible with HSA plugin\"\n+\t\t\t \" (expected %u, received %u)\",\n+\t\t\t GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n+      return -1;\n+    }\n \n   struct brig_image_desc *image_desc = (struct brig_image_desc *) target_data;\n   struct agent_info *agent;\n@@ -637,10 +685,17 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, void *target_data,\n   int kernel_count = image_desc->kernel_count;\n \n   agent = get_agent_info (ord);\n+  if (!agent)\n+    return -1;\n+\n   if (pthread_rwlock_wrlock (&agent->modules_rwlock))\n-    GOMP_PLUGIN_fatal (\"Unable to write-lock an HSA agent rwlock\");\n-  if (agent->prog_finalized)\n-    destroy_hsa_program (agent);\n+    {\n+      GOMP_PLUGIN_error (\"Unable to write-lock an HSA agent rwlock\");\n+      return -1;\n+    }\n+  if (agent->prog_finalized\n+      && !destroy_hsa_program (agent))\n+    return -1;\n \n   HSA_DEBUG (\"Encountered %d kernels in an image\\n\", kernel_count);\n   pair = GOMP_PLUGIN_malloc (kernel_count * sizeof (struct addr_pair));\n@@ -668,15 +723,21 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, void *target_data,\n       kernel->dependencies_count = d->kernel_dependencies_count;\n       kernel->dependencies = d->kernel_dependencies;\n       if (pthread_mutex_init (&kernel->init_mutex, NULL))\n-\tGOMP_PLUGIN_fatal (\"Failed to initialize an HSA kernel mutex\");\n+\t{\n+\t  GOMP_PLUGIN_error (\"Failed to initialize an HSA kernel mutex\");\n+\t  return -1;\n+\t}\n \n       kernel++;\n       pair++;\n     }\n \n   add_module_to_agent (agent, module);\n   if (pthread_rwlock_unlock (&agent->modules_rwlock))\n-    GOMP_PLUGIN_fatal (\"Unable to unlock an HSA agent rwlock\");\n+    {\n+      GOMP_PLUGIN_error (\"Unable to unlock an HSA agent rwlock\");\n+      return -1;\n+    }\n   return kernel_count;\n }\n \n@@ -1373,34 +1434,47 @@ GOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,\n }\n \n /* Deinitialize all information associated with MODULE and kernels within\n-   it.  */\n+   it.  Return TRUE on success.  */\n \n-void\n+static bool\n destroy_module (struct module_info *module)\n {\n   int i;\n   for (i = 0; i < module->kernel_count; i++)\n     if (pthread_mutex_destroy (&module->kernels[i].init_mutex))\n-      GOMP_PLUGIN_fatal (\"Failed to destroy an HSA kernel initialization \"\n-\t\t\t \"mutex\");\n+      {\n+\tGOMP_PLUGIN_error (\"Failed to destroy an HSA kernel initialization \"\n+\t\t\t   \"mutex\");\n+\treturn false;\n+      }\n+  return true;\n }\n \n /* Part of the libgomp plugin interface.  Unload BRIG module described by\n-   struct brig_image_desc in TARGET_DATA from agent number N.  */\n+   struct brig_image_desc in TARGET_DATA from agent number N.  Return\n+   TRUE on success.  */\n \n-void\n+bool\n GOMP_OFFLOAD_unload_image (int n, unsigned version, void *target_data)\n {\n   if (GOMP_VERSION_DEV (version) > GOMP_VERSION_HSA)\n-    GOMP_PLUGIN_fatal (\"Offload data incompatible with HSA plugin\"\n-\t\t       \" (expected %u, received %u)\",\n-\t\t       GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n+    {\n+      GOMP_PLUGIN_error (\"Offload data incompatible with HSA plugin\"\n+\t\t\t \" (expected %u, received %u)\",\n+\t\t\t GOMP_VERSION_HSA, GOMP_VERSION_DEV (version));\n+      return false;\n+    }\n \n   struct agent_info *agent;\n   agent = get_agent_info (n);\n-  if (pthread_rwlock_wrlock (&agent->modules_rwlock))\n-    GOMP_PLUGIN_fatal (\"Unable to write-lock an HSA agent rwlock\");\n+  if (!agent)\n+    return false;\n \n+  if (pthread_rwlock_wrlock (&agent->modules_rwlock))\n+    {\n+      GOMP_PLUGIN_error (\"Unable to write-lock an HSA agent rwlock\");\n+      return false;\n+    }\n   struct module_info *module = agent->first_module;\n   while (module)\n     {\n@@ -1409,54 +1483,75 @@ GOMP_OFFLOAD_unload_image (int n, unsigned version, void *target_data)\n       module = module->next;\n     }\n   if (!module)\n-    GOMP_PLUGIN_fatal (\"Attempt to unload an image that has never been \"\n-\t\t       \"loaded before\");\n+    {\n+      GOMP_PLUGIN_error (\"Attempt to unload an image that has never been \"\n+\t\t\t \"loaded before\");\n+      return false;\n+    }\n \n   remove_module_from_agent (agent, module);\n-  destroy_module (module);\n+  if (!destroy_module (module))\n+    return false;\n   free (module);\n-  destroy_hsa_program (agent);\n+  if (!destroy_hsa_program (agent))\n+    return false;\n   if (pthread_rwlock_unlock (&agent->modules_rwlock))\n-    GOMP_PLUGIN_fatal (\"Unable to unlock an HSA agent rwlock\");\n+    {\n+      GOMP_PLUGIN_error (\"Unable to unlock an HSA agent rwlock\");\n+      return false;\n+    }\n+  return true;\n }\n \n /* Part of the libgomp plugin interface.  Deinitialize all information and\n    status associated with agent number N.  We do not attempt any\n    synchronization, assuming the user and libgomp will not attempt\n    deinitialization of a device that is in any way being used at the same\n-   time.  */\n+   time.  Return TRUE on success.  */\n \n-void\n+bool\n GOMP_OFFLOAD_fini_device (int n)\n {\n   struct agent_info *agent = get_agent_info (n);\n+  if (!agent)\n+    return false;\n+\n   if (!agent->initialized)\n-    return;\n+    return true;\n \n   struct module_info *next_module = agent->first_module;\n   while (next_module)\n     {\n       struct module_info *module = next_module;\n       next_module = module->next;\n-      destroy_module (module);\n+      if (!destroy_module (module))\n+\treturn false;\n       free (module);\n     }\n   agent->first_module = NULL;\n-  destroy_hsa_program (agent);\n+  if (!destroy_hsa_program (agent))\n+    return false;\n \n   release_agent_shared_libraries (agent);\n \n   hsa_status_t status = hsa_queue_destroy (agent->command_q);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Error destroying command queue\", status);\n+    return hsa_error (\"Error destroying command queue\", status);\n   status = hsa_queue_destroy (agent->kernel_dispatch_command_q);\n   if (status != HSA_STATUS_SUCCESS)\n-    hsa_fatal (\"Error destroying kernel dispatch command queue\", status);\n+    return hsa_error (\"Error destroying kernel dispatch command queue\", status);\n   if (pthread_mutex_destroy (&agent->prog_mutex))\n-    GOMP_PLUGIN_fatal (\"Failed to destroy an HSA agent program mutex\");\n+    {\n+      GOMP_PLUGIN_error (\"Failed to destroy an HSA agent program mutex\");\n+      return false;\n+    }\n   if (pthread_rwlock_destroy (&agent->modules_rwlock))\n-    GOMP_PLUGIN_fatal (\"Failed to destroy an HSA agent rwlock\");\n+    {\n+      GOMP_PLUGIN_error (\"Failed to destroy an HSA agent rwlock\");\n+      return false;\n+    }\n   agent->initialized = false;\n+  return true;\n }\n \n /* Part of the libgomp plugin interface.  Not implemented as it is not required\n@@ -1465,46 +1560,51 @@ GOMP_OFFLOAD_fini_device (int n)\n void *\n GOMP_OFFLOAD_alloc (int ord, size_t size)\n {\n-  GOMP_PLUGIN_fatal (\"HSA GOMP_OFFLOAD_alloc is not implemented because \"\n+  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_alloc is not implemented because \"\n \t\t     \"it should never be called\");\n+  return NULL;\n }\n \n /* Part of the libgomp plugin interface.  Not implemented as it is not required\n    for HSA.  */\n \n-void\n+bool\n GOMP_OFFLOAD_free (int ord, void *ptr)\n {\n-  GOMP_PLUGIN_fatal (\"HSA GOMP_OFFLOAD_free is not implemented because \"\n+  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_free is not implemented because \"\n \t\t     \"it should never be called\");\n+  return false;\n }\n \n /* Part of the libgomp plugin interface.  Not implemented as it is not required\n    for HSA.  */\n \n-void *\n+bool\n GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n {\n-  GOMP_PLUGIN_fatal (\"HSA GOMP_OFFLOAD_dev2host is not implemented because \"\n+  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_dev2host is not implemented because \"\n \t\t     \"it should never be called\");\n+  return false;\n }\n \n /* Part of the libgomp plugin interface.  Not implemented as it is not required\n    for HSA.  */\n \n-void *\n+bool\n GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n {\n-  GOMP_PLUGIN_fatal (\"HSA GOMP_OFFLOAD_host2dev is not implemented because \"\n+  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_host2dev is not implemented because \"\n \t\t     \"it should never be called\");\n+  return false;\n }\n \n /* Part of the libgomp plugin interface.  Not implemented as it is not required\n    for HSA.  */\n \n-void *\n+bool\n GOMP_OFFLOAD_dev2dev (int ord, void *dst, const void *src, size_t n)\n {\n-  GOMP_PLUGIN_fatal (\"HSA GOMP_OFFLOAD_dev2dev is not implemented because \"\n+  GOMP_PLUGIN_error (\"HSA GOMP_OFFLOAD_dev2dev is not implemented because \"\n \t\t     \"it should never be called\");\n+  return false;\n }"}, {"sha": "2b6a888cbd2d848c5876f8f5da491c9db489c54a", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 281, "deletions": 318, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -63,6 +63,34 @@ cuda_error (CUresult r)\n   return desc;\n }\n \n+/* Convenience macros for the frequently used CUDA library call and\n+   error handling sequence.  This does not capture all the cases we\n+   use in this file, but is common enough.  */\n+\n+#define CUDA_CALL_ERET(ERET, FN, ...)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    unsigned __r = FN (__VA_ARGS__);\t\t\\\n+    if (__r != CUDA_SUCCESS)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tGOMP_PLUGIN_error (#FN \" error: %s\",\t\\\n+\t\t\t   cuda_error (__r));\t\\\n+\treturn ERET;\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define CUDA_CALL(FN, ...)\t\t\t\\\n+  CUDA_CALL_ERET (false, (FN), __VA_ARGS__)\n+\n+#define CUDA_CALL_ASSERT(FN, ...)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    unsigned __r = FN (__VA_ARGS__);\t\t\\\n+    if (__r != CUDA_SUCCESS)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tGOMP_PLUGIN_fatal (#FN \" error: %s\",\t\\\n+\t\t\t   cuda_error (__r));\t\\\n+      }\t\t\t\t\t\t\\\n+  } while (0)\n+\n static unsigned int instantiated_devices = 0;\n static pthread_mutex_t ptx_dev_lock = PTHREAD_MUTEX_INITIALIZER;\n \n@@ -98,24 +126,17 @@ struct map\n   char    mappings[0];\n };\n \n-static void\n+static bool\n map_init (struct ptx_stream *s)\n {\n-  CUresult r;\n-\n   int size = getpagesize ();\n \n   assert (s);\n   assert (!s->d);\n   assert (!s->h);\n \n-  r = cuMemAllocHost (&s->h, size);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemAllocHost error: %s\", cuda_error (r));\n-\n-  r = cuMemHostGetDevicePointer (&s->d, s->h, 0);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemHostGetDevicePointer error: %s\", cuda_error (r));\n+  CUDA_CALL (cuMemAllocHost, &s->h, size);\n+  CUDA_CALL (cuMemHostGetDevicePointer, &s->d, s->h, 0);\n \n   assert (s->h);\n \n@@ -125,16 +146,14 @@ map_init (struct ptx_stream *s)\n \n   assert (s->h_next);\n   assert (s->h_end);\n+  return true;\n }\n \n-static void\n+static bool\n map_fini (struct ptx_stream *s)\n {\n-  CUresult r;\n-\n-  r = cuMemFreeHost (s->h);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_error (\"cuMemFreeHost error: %s\", cuda_error (r));\n+  CUDA_CALL (cuMemFreeHost, s->h);\n+  return true;\n }\n \n static void\n@@ -325,7 +344,7 @@ nvptx_thread (void)\n   return (struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();\n }\n \n-static void\n+static bool\n init_streams_for_device (struct ptx_device *ptx_dev, int concurrency)\n {\n   int i;\n@@ -337,9 +356,10 @@ init_streams_for_device (struct ptx_device *ptx_dev, int concurrency)\n   null_stream->multithreaded = true;\n   null_stream->d = (CUdeviceptr) NULL;\n   null_stream->h = NULL;\n-  map_init (null_stream);\n-  ptx_dev->null_stream = null_stream;\n+  if (!map_init (null_stream))\n+    return false;\n \n+  ptx_dev->null_stream = null_stream;\n   ptx_dev->active_streams = NULL;\n   pthread_mutex_init (&ptx_dev->stream_lock, NULL);\n \n@@ -355,25 +375,35 @@ init_streams_for_device (struct ptx_device *ptx_dev, int concurrency)\n \n   for (i = 0; i < concurrency; i++)\n     ptx_dev->async_streams.arr[i] = NULL;\n+\n+  return true;\n }\n \n-static void\n+static bool\n fini_streams_for_device (struct ptx_device *ptx_dev)\n {\n   free (ptx_dev->async_streams.arr);\n \n+  bool ret = true;\n   while (ptx_dev->active_streams != NULL)\n     {\n       struct ptx_stream *s = ptx_dev->active_streams;\n       ptx_dev->active_streams = ptx_dev->active_streams->next;\n \n-      map_fini (s);\n-      cuStreamDestroy (s->stream);\n+      ret &= map_fini (s);\n+\n+      CUresult r = cuStreamDestroy (s->stream);\n+      if (r != CUDA_SUCCESS)\n+\t{\n+\t  GOMP_PLUGIN_error (\"cuStreamDestroy error: %s\", cuda_error (r));\n+\t  ret = false;\n+\t}\n       free (s);\n     }\n \n-  map_fini (ptx_dev->null_stream);\n+  ret &= map_fini (ptx_dev->null_stream);\n   free (ptx_dev->null_stream);\n+  return ret;\n }\n \n /* Select a stream for (OpenACC-semantics) ASYNC argument for the current\n@@ -447,7 +477,11 @@ select_stream_for_async (int async, pthread_t thread, bool create,\n \t    {\n \t      r = cuStreamCreate (&s->stream, CU_STREAM_DEFAULT);\n \t      if (r != CUDA_SUCCESS)\n-\t\tGOMP_PLUGIN_fatal (\"cuStreamCreate error: %s\", cuda_error (r));\n+\t\t{\n+\t\t  pthread_mutex_unlock (&ptx_dev->stream_lock);\n+\t\t  GOMP_PLUGIN_fatal (\"cuStreamCreate error: %s\",\n+\t\t\t\t     cuda_error (r));\n+\t\t}\n \t    }\n \n \t  /* If CREATE is true, we're going to be queueing some work on this\n@@ -457,7 +491,11 @@ select_stream_for_async (int async, pthread_t thread, bool create,\n \n \t  s->d = (CUdeviceptr) NULL;\n \t  s->h = NULL;\n-\t  map_init (s);\n+\t  if (!map_init (s))\n+\t    {\n+\t      pthread_mutex_unlock (&ptx_dev->stream_lock);\n+\t      GOMP_PLUGIN_fatal (\"map_init fail\");\n+\t    }\n \n \t  s->next = ptx_dev->active_streams;\n \t  ptx_dev->active_streams = s;\n@@ -467,7 +505,11 @@ select_stream_for_async (int async, pthread_t thread, bool create,\n       stream = ptx_dev->async_streams.arr[async];\n     }\n   else if (async < 0)\n-    GOMP_PLUGIN_fatal (\"bad async %d\", async);\n+    {\n+      if (create)\n+\tpthread_mutex_unlock (&ptx_dev->stream_lock);\n+      GOMP_PLUGIN_fatal (\"bad async %d\", async);\n+    }\n \n   if (create)\n     {\n@@ -498,34 +540,25 @@ select_stream_for_async (int async, pthread_t thread, bool create,\n static bool\n nvptx_init (void)\n {\n-  CUresult r;\n   int ndevs;\n \n   if (instantiated_devices != 0)\n     return true;\n \n-  r = cuInit (0);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuInit error: %s\", cuda_error (r));\n-\n+  CUDA_CALL (cuInit, 0);\n   ptx_events = NULL;\n-\n   pthread_mutex_init (&ptx_event_lock, NULL);\n \n-  r = cuDeviceGetCount (&ndevs);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGetCount error: %s\", cuda_error (r));\n-\n+  CUDA_CALL (cuDeviceGetCount, &ndevs);\n   ptx_devices = GOMP_PLUGIN_malloc_cleared (sizeof (struct ptx_device *)\n \t\t\t\t\t    * ndevs);\n-\n   return true;\n }\n \n /* Select the N'th PTX device for the current host thread.  The device must\n    have been previously opened before calling this function.  */\n \n-static void\n+static bool\n nvptx_attach_host_thread_to_device (int n)\n {\n   CUdevice dev;\n@@ -535,34 +568,34 @@ nvptx_attach_host_thread_to_device (int n)\n \n   r = cuCtxGetDevice (&dev);\n   if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)\n-    GOMP_PLUGIN_fatal (\"cuCtxGetDevice error: %s\", cuda_error (r));\n+    {\n+      GOMP_PLUGIN_error (\"cuCtxGetDevice error: %s\", cuda_error (r));\n+      return false;\n+    }\n \n   if (r != CUDA_ERROR_INVALID_CONTEXT && dev == n)\n-    return;\n+    return true;\n   else\n     {\n       CUcontext old_ctx;\n \n       ptx_dev = ptx_devices[n];\n-      assert (ptx_dev);\n+      if (!ptx_dev)\n+\t{\n+\t  GOMP_PLUGIN_error (\"device %d not found\", n);\n+\t  return false;\n+\t}\n \n-      r = cuCtxGetCurrent (&thd_ctx);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuCtxGetCurrent error: %s\", cuda_error (r));\n+      CUDA_CALL (cuCtxGetCurrent, &thd_ctx);\n \n       /* We don't necessarily have a current context (e.g. if it has been\n          destroyed.  Pop it if we do though.  */\n       if (thd_ctx != NULL)\n-\t{\n-\t  r = cuCtxPopCurrent (&old_ctx);\n-\t  if (r != CUDA_SUCCESS)\n-            GOMP_PLUGIN_fatal (\"cuCtxPopCurrent error: %s\", cuda_error (r));\n-\t}\n+\tCUDA_CALL (cuCtxPopCurrent, &old_ctx);\n \n-      r = cuCtxPushCurrent (ptx_dev->ctx);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuCtxPushCurrent error: %s\", cuda_error (r));\n+      CUDA_CALL (cuCtxPushCurrent, ptx_dev->ctx);\n     }\n+  return true;\n }\n \n static struct ptx_device *\n@@ -573,9 +606,7 @@ nvptx_open_device (int n)\n   CUresult r;\n   int async_engines, pi;\n \n-  r = cuDeviceGet (&dev, n);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGet error: %s\", cuda_error (r));\n+  CUDA_CALL_ERET (NULL, cuDeviceGet, &dev, n);\n \n   ptx_dev = GOMP_PLUGIN_malloc (sizeof (struct ptx_device));\n \n@@ -585,60 +616,44 @@ nvptx_open_device (int n)\n \n   r = cuCtxGetDevice (&ctx_dev);\n   if (r != CUDA_SUCCESS && r != CUDA_ERROR_INVALID_CONTEXT)\n-    GOMP_PLUGIN_fatal (\"cuCtxGetDevice error: %s\", cuda_error (r));\n+    {\n+      GOMP_PLUGIN_error (\"cuCtxGetDevice error: %s\", cuda_error (r));\n+      return NULL;\n+    }\n   \n   if (r != CUDA_ERROR_INVALID_CONTEXT && ctx_dev != dev)\n     {\n       /* The current host thread has an active context for a different device.\n          Detach it.  */\n       CUcontext old_ctx;\n-      \n-      r = cuCtxPopCurrent (&old_ctx);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuCtxPopCurrent error: %s\", cuda_error (r));\n+      CUDA_CALL_ERET (NULL, cuCtxPopCurrent, &old_ctx);\n     }\n \n-  r = cuCtxGetCurrent (&ptx_dev->ctx);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuCtxGetCurrent error: %s\", cuda_error (r));\n+  CUDA_CALL_ERET (NULL, cuCtxGetCurrent, &ptx_dev->ctx);\n \n   if (!ptx_dev->ctx)\n-    {\n-      r = cuCtxCreate (&ptx_dev->ctx, CU_CTX_SCHED_AUTO, dev);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuCtxCreate error: %s\", cuda_error (r));\n-    }\n+    CUDA_CALL_ERET (NULL, cuCtxCreate, &ptx_dev->ctx, CU_CTX_SCHED_AUTO, dev);\n   else\n     ptx_dev->ctx_shared = true;\n \n-  r = cuDeviceGetAttribute (&pi, CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, dev);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGetAttribute error: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_GPU_OVERLAP, dev);\n   ptx_dev->overlap = pi;\n \n-  r = cuDeviceGetAttribute (&pi, CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, dev);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGetAttribute error: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, dev);\n   ptx_dev->map = pi;\n \n-  r = cuDeviceGetAttribute (&pi, CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, dev);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGetAttribute error: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS, dev);\n   ptx_dev->concur = pi;\n \n-  r = cuDeviceGetAttribute (&pi, CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, dev);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGetAttribute error: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_COMPUTE_MODE, dev);\n   ptx_dev->mode = pi;\n \n-  r = cuDeviceGetAttribute (&pi, CU_DEVICE_ATTRIBUTE_INTEGRATED, dev);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGetAttribute error: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ERET (NULL, cuDeviceGetAttribute,\n+\t\t  &pi, CU_DEVICE_ATTRIBUTE_INTEGRATED, dev);\n   ptx_dev->mkern = pi;\n \n   r = cuDeviceGetAttribute (&async_engines,\n@@ -649,38 +664,34 @@ nvptx_open_device (int n)\n   ptx_dev->images = NULL;\n   pthread_mutex_init (&ptx_dev->image_lock, NULL);\n \n-  init_streams_for_device (ptx_dev, async_engines);\n+  if (!init_streams_for_device (ptx_dev, async_engines))\n+    return NULL;\n \n   return ptx_dev;\n }\n \n-static void\n+static bool\n nvptx_close_device (struct ptx_device *ptx_dev)\n {\n-  CUresult r;\n-\n   if (!ptx_dev)\n-    return;\n+    return true;\n \n-  fini_streams_for_device (ptx_dev);\n+  if (!fini_streams_for_device (ptx_dev))\n+    return false;\n   \n   pthread_mutex_destroy (&ptx_dev->image_lock);\n \n   if (!ptx_dev->ctx_shared)\n-    {\n-      r = cuCtxDestroy (ptx_dev->ctx);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuCtxDestroy error: %s\", cuda_error (r));\n-    }\n+    CUDA_CALL (cuCtxDestroy, ptx_dev->ctx);\n \n   free (ptx_dev);\n+  return true;\n }\n \n static int\n nvptx_get_num_devices (void)\n {\n   int n;\n-  CUresult r;\n \n   /* PR libgomp/65099: Currently, we only support offloading in 64-bit\n      configurations.  */\n@@ -693,22 +704,19 @@ nvptx_get_num_devices (void)\n      further initialization).  */\n   if (instantiated_devices == 0)\n     {\n-      r = cuInit (0);\n+      CUresult r = cuInit (0);\n       /* This is not an error: e.g. we may have CUDA libraries installed but\n          no devices available.  */\n       if (r != CUDA_SUCCESS)\n         return 0;\n     }\n \n-  r = cuDeviceGetCount (&n);\n-  if (r!= CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuDeviceGetCount error: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ERET (-1, cuDeviceGetCount, &n);\n   return n;\n }\n \n \n-static void\n+static bool\n link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n \t  unsigned num_objs)\n {\n@@ -742,9 +750,7 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n   opts[5] = CU_JIT_LOG_VERBOSE;\n   optvals[5] = (void *) 1;\n \n-  r = cuLinkCreate (6, opts, optvals, &linkstate);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuLinkCreate error: %s\", cuda_error (r));\n+  CUDA_CALL (cuLinkCreate, 6, opts, optvals, &linkstate);\n \n   for (; num_objs--; ptx_objs++)\n     {\n@@ -756,8 +762,9 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n       if (r != CUDA_SUCCESS)\n \t{\n \t  GOMP_PLUGIN_error (\"Link error log %s\\n\", &elog[0]);\n-\t  GOMP_PLUGIN_fatal (\"cuLinkAddData (ptx_code) error: %s\",\n+\t  GOMP_PLUGIN_error (\"cuLinkAddData (ptx_code) error: %s\",\n \t\t\t     cuda_error (r));\n+\t  return false;\n \t}\n     }\n \n@@ -768,15 +775,14 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n   GOMP_PLUGIN_debug (0, \"Link log %s\\n\", &ilog[0]);\n \n   if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuLinkComplete error: %s\", cuda_error (r));\n-\n-  r = cuModuleLoadData (module, linkout);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuModuleLoadData error: %s\", cuda_error (r));\n+    {\n+      GOMP_PLUGIN_error (\"cuLinkComplete error: %s\", cuda_error (r));\n+      return false;\n+    }\n \n-  r = cuLinkDestroy (linkstate);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuLinkDestory error: %s\", cuda_error (r));\n+  CUDA_CALL (cuModuleLoadData, module, linkout);\n+  CUDA_CALL (cuLinkDestroy, linkstate);\n+  return true;\n }\n \n static void\n@@ -923,10 +929,8 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n \n   /* Copy the (device) pointers to arguments to the device (dp and hp might in\n      fact have the same value on a unified-memory system).  */\n-  r = cuMemcpy ((CUdeviceptr)dp, (CUdeviceptr)hp, mapnum * sizeof (void *));\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemcpy failed: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ASSERT (cuMemcpy, (CUdeviceptr) dp, (CUdeviceptr) hp,\n+\t\t    mapnum * sizeof (void *));\n   GOMP_PLUGIN_debug (0, \"  %s: kernel %s: launch\"\n \t\t     \" gangs=%u, workers=%u, vectors=%u\\n\",\n \t\t     __FUNCTION__, targ_fn->launch->fn,\n@@ -939,12 +943,10 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n   // vector length\tntid.x\n \n   kargs[0] = &dp;\n-  r = cuLaunchKernel (function,\n-\t\t      dims[GOMP_DIM_GANG], 1, 1,\n-\t\t      dims[GOMP_DIM_VECTOR], dims[GOMP_DIM_WORKER], 1,\n-\t\t      0, dev_str->stream, kargs, 0);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuLaunchKernel error: %s\", cuda_error (r));\n+  CUDA_CALL_ASSERT (cuLaunchKernel, function,\n+\t\t    dims[GOMP_DIM_GANG], 1, 1,\n+\t\t    dims[GOMP_DIM_VECTOR], dims[GOMP_DIM_WORKER], 1,\n+\t\t    0, dev_str->stream, kargs, 0);\n \n #ifndef DISABLE_ASYNC\n   if (async < acc_async_noval)\n@@ -971,9 +973,7 @@ nvptx_exec (void (*fn), size_t mapnum, void **hostaddrs, void **devaddrs,\n \n       event_gc (true);\n \n-      r = cuEventRecord (*e, dev_str->stream);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuEventRecord error: %s\", cuda_error (r));\n+      CUDA_CALL_ASSERT (cuEventRecord, *e, dev_str->stream);\n \n       event_add (PTX_EVT_KNL, e, (void *)dev_str);\n     }\n@@ -1001,163 +1001,139 @@ static void *\n nvptx_alloc (size_t s)\n {\n   CUdeviceptr d;\n-  CUresult r;\n \n-  r = cuMemAlloc (&d, s);\n-  if (r == CUDA_ERROR_OUT_OF_MEMORY)\n-    return 0;\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemAlloc error: %s\", cuda_error (r));\n-  return (void *)d;\n+  CUDA_CALL_ERET (NULL, cuMemAlloc, &d, s);\n+  return (void *) d;\n }\n \n-static void\n+static bool\n nvptx_free (void *p)\n {\n-  CUresult r;\n   CUdeviceptr pb;\n   size_t ps;\n \n-  r = cuMemGetAddressRange (&pb, &ps, (CUdeviceptr)p);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemGetAddressRange error: %s\", cuda_error (r));\n-\n-  if ((CUdeviceptr)p != pb)\n-    GOMP_PLUGIN_fatal (\"invalid device address\");\n+  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) p);\n+  if ((CUdeviceptr) p != pb)\n+    {\n+      GOMP_PLUGIN_error (\"invalid device address\");\n+      return false;\n+    }\n \n-  r = cuMemFree ((CUdeviceptr)p);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemFree error: %s\", cuda_error (r));\n+  CUDA_CALL (cuMemFree, (CUdeviceptr) p);\n+  return true;\n }\n \n-static void *\n+\n+static bool\n nvptx_host2dev (void *d, const void *h, size_t s)\n {\n-  CUresult r;\n   CUdeviceptr pb;\n   size_t ps;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n \n   if (!s)\n-    return 0;\n-\n+    return true;\n   if (!d)\n-    GOMP_PLUGIN_fatal (\"invalid device address\");\n+    {\n+      GOMP_PLUGIN_error (\"invalid device address\");\n+      return false;\n+    }\n \n-  r = cuMemGetAddressRange (&pb, &ps, (CUdeviceptr)d);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemGetAddressRange error: %s\", cuda_error (r));\n+  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);\n \n   if (!pb)\n-    GOMP_PLUGIN_fatal (\"invalid device address\");\n-\n+    {\n+      GOMP_PLUGIN_error (\"invalid device address\");\n+      return false;\n+    }\n   if (!h)\n-    GOMP_PLUGIN_fatal (\"invalid host address\");\n-\n+    {\n+      GOMP_PLUGIN_error (\"invalid host address\");\n+      return false;\n+    }\n   if (d == h)\n-    GOMP_PLUGIN_fatal (\"invalid host or device address\");\n-\n+    {\n+      GOMP_PLUGIN_error (\"invalid host or device address\");\n+      return false;\n+    }\n   if ((void *)(d + s) > (void *)(pb + ps))\n-    GOMP_PLUGIN_fatal (\"invalid size\");\n+    {\n+      GOMP_PLUGIN_error (\"invalid size\");\n+      return false;\n+    }\n \n #ifndef DISABLE_ASYNC\n   if (nvthd->current_stream != nvthd->ptx_dev->null_stream)\n     {\n-      CUevent *e;\n-\n-      e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n-\n-      r = cuEventCreate (e, CU_EVENT_DISABLE_TIMING);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuEventCreate error: %s\", cuda_error (r));\n-\n+      CUevent *e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n+      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n       event_gc (false);\n-\n-      r = cuMemcpyHtoDAsync ((CUdeviceptr)d, h, s,\n-\t\t\t     nvthd->current_stream->stream);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuMemcpyHtoDAsync error: %s\", cuda_error (r));\n-\n-      r = cuEventRecord (*e, nvthd->current_stream->stream);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuEventRecord error: %s\", cuda_error (r));\n-\n+      CUDA_CALL (cuMemcpyHtoDAsync,\n+\t\t (CUdeviceptr) d, h, s, nvthd->current_stream->stream);\n+      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n       event_add (PTX_EVT_MEM, e, (void *)h);\n     }\n   else\n #endif\n-    {\n-      r = cuMemcpyHtoD ((CUdeviceptr)d, h, s);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuMemcpyHtoD error: %s\", cuda_error (r));\n-    }\n+    CUDA_CALL (cuMemcpyHtoD, (CUdeviceptr) d, h, s);\n \n-  return 0;\n+  return true;\n }\n \n-static void *\n+static bool\n nvptx_dev2host (void *h, const void *d, size_t s)\n {\n-  CUresult r;\n   CUdeviceptr pb;\n   size_t ps;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n \n   if (!s)\n-    return 0;\n-\n+    return true;\n   if (!d)\n-    GOMP_PLUGIN_fatal (\"invalid device address\");\n+    {\n+      GOMP_PLUGIN_error (\"invalid device address\");\n+      return false;\n+    }\n \n-  r = cuMemGetAddressRange (&pb, &ps, (CUdeviceptr)d);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuMemGetAddressRange error: %s\", cuda_error (r));\n+  CUDA_CALL (cuMemGetAddressRange, &pb, &ps, (CUdeviceptr) d);\n \n   if (!pb)\n-    GOMP_PLUGIN_fatal (\"invalid device address\");\n-\n+    {\n+      GOMP_PLUGIN_error (\"invalid device address\");\n+      return false;\n+    }\n   if (!h)\n-    GOMP_PLUGIN_fatal (\"invalid host address\");\n-\n+    {\n+      GOMP_PLUGIN_error (\"invalid host address\");\n+      return false;\n+    }\n   if (d == h)\n-    GOMP_PLUGIN_fatal (\"invalid host or device address\");\n-\n+    {\n+      GOMP_PLUGIN_error (\"invalid host or device address\");\n+      return false;\n+    }\n   if ((void *)(d + s) > (void *)(pb + ps))\n-    GOMP_PLUGIN_fatal (\"invalid size\");\n+    {\n+      GOMP_PLUGIN_error (\"invalid size\");\n+      return false;\n+    }\n \n #ifndef DISABLE_ASYNC\n   if (nvthd->current_stream != nvthd->ptx_dev->null_stream)\n     {\n-      CUevent *e;\n-\n-      e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n-\n-      r = cuEventCreate (e, CU_EVENT_DISABLE_TIMING);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuEventCreate error: %s\\n\", cuda_error (r));\n-\n+      CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n+      CUDA_CALL (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n       event_gc (false);\n-\n-      r = cuMemcpyDtoHAsync (h, (CUdeviceptr)d, s,\n-\t\t\t     nvthd->current_stream->stream);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuMemcpyDtoHAsync error: %s\", cuda_error (r));\n-\n-      r = cuEventRecord (*e, nvthd->current_stream->stream);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuEventRecord error: %s\", cuda_error (r));\n-\n+      CUDA_CALL (cuMemcpyDtoHAsync,\n+\t\t h, (CUdeviceptr) d, s, nvthd->current_stream->stream);\n+      CUDA_CALL (cuEventRecord, *e, nvthd->current_stream->stream);\n       event_add (PTX_EVT_MEM, e, (void *)h);\n     }\n   else\n #endif\n-    {\n-      r = cuMemcpyDtoH (h, (CUdeviceptr)d, s);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuMemcpyDtoH error: %s\", cuda_error (r));\n-    }\n+    CUDA_CALL (cuMemcpyDtoH, h, (CUdeviceptr) d, s);\n \n-  return 0;\n+  return true;\n }\n \n static void\n@@ -1227,25 +1203,20 @@ nvptx_async_test_all (void)\n static void\n nvptx_wait (int async)\n {\n-  CUresult r;\n   struct ptx_stream *s;\n \n   s = select_stream_for_async (async, pthread_self (), false, NULL);\n-\n   if (!s)\n     GOMP_PLUGIN_fatal (\"unknown async %d\", async);\n \n-  r = cuStreamSynchronize (s->stream);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s\", cuda_error (r));\n+  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);\n \n   event_gc (true);\n }\n \n static void\n nvptx_wait_async (int async1, int async2)\n {\n-  CUresult r;\n   CUevent *e;\n   struct ptx_stream *s1, *s2;\n   pthread_t self = pthread_self ();\n@@ -1261,23 +1232,17 @@ nvptx_wait_async (int async1, int async2)\n   if (s1 == s2)\n     GOMP_PLUGIN_fatal (\"identical parameters\");\n \n-  e = (CUevent *)GOMP_PLUGIN_malloc (sizeof (CUevent));\n+  e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n \n-  r = cuEventCreate (e, CU_EVENT_DISABLE_TIMING);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuEventCreate error: %s\", cuda_error (r));\n+  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n \n   event_gc (true);\n \n-  r = cuEventRecord (*e, s1->stream);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuEventRecord error: %s\", cuda_error (r));\n+  CUDA_CALL_ASSERT (cuEventRecord, *e, s1->stream);\n \n   event_add (PTX_EVT_SYNC, e, NULL);\n \n-  r = cuStreamWaitEvent (s2->stream, *e, 0);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuStreamWaitEvent error: %s\", cuda_error (r));\n+  CUDA_CALL_ASSERT (cuStreamWaitEvent, s2->stream, *e, 0);\n }\n \n static void\n@@ -1302,9 +1267,7 @@ nvptx_wait_all (void)\n \t  else if (r != CUDA_ERROR_NOT_READY)\n \t    GOMP_PLUGIN_fatal (\"cuStreamQuery error: %s\", cuda_error (r));\n \n-\t  r = cuStreamSynchronize (s->stream);\n-\t  if (r != CUDA_SUCCESS)\n-\t    GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s\", cuda_error (r));\n+\t  CUDA_CALL_ASSERT (cuStreamSynchronize, s->stream);\n \t}\n     }\n \n@@ -1316,7 +1279,6 @@ nvptx_wait_all (void)\n static void\n nvptx_wait_all_async (int async)\n {\n-  CUresult r;\n   struct ptx_stream *waiting_stream, *other_stream;\n   CUevent *e;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n@@ -1346,20 +1308,14 @@ nvptx_wait_all_async (int async)\n \n       e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n \n-      r = cuEventCreate (e, CU_EVENT_DISABLE_TIMING);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuEventCreate error: %s\", cuda_error (r));\n+      CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n \n       /* Record an event on the waited-for stream.  */\n-      r = cuEventRecord (*e, other_stream->stream);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuEventRecord error: %s\", cuda_error (r));\n+      CUDA_CALL_ASSERT (cuEventRecord, *e, other_stream->stream);\n \n       event_add (PTX_EVT_SYNC, e, NULL);\n \n-      r = cuStreamWaitEvent (waiting_stream->stream, *e, 0);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuStreamWaitEvent error: %s\", cuda_error (r));\n+      CUDA_CALL_ASSERT (cuStreamWaitEvent, waiting_stream->stream, *e, 0);\n    }\n \n   pthread_mutex_unlock (&nvthd->ptx_dev->stream_lock);\n@@ -1408,11 +1364,11 @@ nvptx_set_cuda_stream (int async, void *stream)\n   pthread_t self = pthread_self ();\n   struct nvptx_thread *nvthd = nvptx_thread ();\n \n-  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n-\n   if (async < 0)\n     GOMP_PLUGIN_fatal (\"bad async %d\", async);\n \n+  pthread_mutex_lock (&nvthd->ptx_dev->stream_lock);\n+\n   /* We have a list of active streams and an array mapping async values to\n      entries of that list.  We need to take \"ownership\" of the passed-in stream,\n      and add it to our list, removing the previous entry also (if there was one)\n@@ -1435,8 +1391,11 @@ nvptx_set_cuda_stream (int async, void *stream)\n \t  s->next = s->next->next;\n \t}\n \n-      cuStreamDestroy (oldstream->stream);\n-      map_fini (oldstream);\n+      CUDA_CALL_ASSERT (cuStreamDestroy, oldstream->stream);\n+\n+      if (!map_fini (oldstream))\n+\tGOMP_PLUGIN_fatal (\"error when freeing host memory\");\n+\n       free (oldstream);\n     }\n \n@@ -1473,37 +1432,50 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return nvptx_get_num_devices ();\n }\n \n-void\n+bool\n GOMP_OFFLOAD_init_device (int n)\n {\n+  struct ptx_device *dev;\n+\n   pthread_mutex_lock (&ptx_dev_lock);\n \n   if (!nvptx_init () || ptx_devices[n] != NULL)\n     {\n       pthread_mutex_unlock (&ptx_dev_lock);\n-      return;\n+      return false;\n     }\n \n-  ptx_devices[n] = nvptx_open_device (n);\n-  instantiated_devices++;\n+  dev = nvptx_open_device (n);\n+  if (dev)\n+    {\n+      ptx_devices[n] = dev;\n+      instantiated_devices++;\n+    }\n \n   pthread_mutex_unlock (&ptx_dev_lock);\n+\n+  return dev != NULL;\n }\n \n-void\n+bool\n GOMP_OFFLOAD_fini_device (int n)\n {\n   pthread_mutex_lock (&ptx_dev_lock);\n \n   if (ptx_devices[n] != NULL)\n     {\n-      nvptx_attach_host_thread_to_device (n);\n-      nvptx_close_device (ptx_devices[n]);\n+      if (!nvptx_attach_host_thread_to_device (n)\n+\t  || !nvptx_close_device (ptx_devices[n]))\n+\t{\n+\t  pthread_mutex_unlock (&ptx_dev_lock);\n+\t  return false;\n+\t}\n       ptx_devices[n] = NULL;\n       instantiated_devices--;\n     }\n \n   pthread_mutex_unlock (&ptx_dev_lock);\n+  return true;\n }\n \n /* Return the libgomp version number we're compatible with.  There is\n@@ -1526,25 +1498,25 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   const char *const *var_names;\n   const struct targ_fn_launch *fn_descs;\n   unsigned int fn_entries, var_entries, i, j;\n-  CUresult r;\n   struct targ_fn_descriptor *targ_fns;\n   struct addr_pair *targ_tbl;\n   const nvptx_tdata_t *img_header = (const nvptx_tdata_t *) target_data;\n   struct ptx_image_data *new_image;\n   struct ptx_device *dev;\n \n   if (GOMP_VERSION_DEV (version) > GOMP_VERSION_NVIDIA_PTX)\n-    GOMP_PLUGIN_fatal (\"Offload data incompatible with PTX plugin\"\n-\t\t       \" (expected %u, received %u)\",\n-\t\t       GOMP_VERSION_NVIDIA_PTX, GOMP_VERSION_DEV (version));\n-  \n-  GOMP_OFFLOAD_init_device (ord);\n+    {\n+      GOMP_PLUGIN_error (\"Offload data incompatible with PTX plugin\"\n+\t\t\t \" (expected %u, received %u)\",\n+\t\t\t GOMP_VERSION_NVIDIA_PTX, GOMP_VERSION_DEV (version));\n+      return -1;\n+    }\n \n-  dev = ptx_devices[ord];\n-  \n-  nvptx_attach_host_thread_to_device (ord);\n+  if (!nvptx_attach_host_thread_to_device (ord)\n+      || !link_ptx (&module, img_header->ptx_objs, img_header->ptx_num))\n+    return -1;\n \n-  link_ptx (&module, img_header->ptx_objs, img_header->ptx_num);\n+  dev = ptx_devices[ord];\n \n   /* The mkoffload utility emits a struct of pointers/integers at the\n      start of each offload image.  The array of kernel names and the\n@@ -1576,9 +1548,8 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n     {\n       CUfunction function;\n \n-      r = cuModuleGetFunction (&function, module, fn_descs[i].fn);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuModuleGetFunction error: %s\", cuda_error (r));\n+      CUDA_CALL_ERET (-1, cuModuleGetFunction, &function, module,\n+\t\t      fn_descs[i].fn);\n \n       targ_fns->fn = function;\n       targ_fns->launch = &fn_descs[i];\n@@ -1592,9 +1563,8 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n       CUdeviceptr var;\n       size_t bytes;\n \n-      r = cuModuleGetGlobal (&var, &bytes, module, var_names[j]);\n-      if (r != CUDA_SUCCESS)\n-        GOMP_PLUGIN_fatal (\"cuModuleGetGlobal error: %s\", cuda_error (r));\n+      CUDA_CALL_ERET (-1, cuModuleGetGlobal,\n+\t\t      &var, &bytes, module, var_names[j]);\n \n       targ_tbl->start = (uintptr_t) var;\n       targ_tbl->end = targ_tbl->start + bytes;\n@@ -1606,54 +1576,63 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n /* Unload the program described by TARGET_DATA.  DEV_DATA is the\n    function descriptors allocated by G_O_load_image.  */\n \n-void\n+bool\n GOMP_OFFLOAD_unload_image (int ord, unsigned version, const void *target_data)\n {\n   struct ptx_image_data *image, **prev_p;\n   struct ptx_device *dev = ptx_devices[ord];\n \n   if (GOMP_VERSION_DEV (version) > GOMP_VERSION_NVIDIA_PTX)\n-    return;\n-  \n+    {\n+      GOMP_PLUGIN_error (\"Offload data incompatible with PTX plugin\"\n+\t\t\t \" (expected %u, received %u)\",\n+\t\t\t GOMP_VERSION_NVIDIA_PTX, GOMP_VERSION_DEV (version));\n+      return false;\n+    }\n+\n+  bool ret = true;\n   pthread_mutex_lock (&dev->image_lock);\n   for (prev_p = &dev->images; (image = *prev_p) != 0; prev_p = &image->next)\n     if (image->target_data == target_data)\n       {\n \t*prev_p = image->next;\n-\tcuModuleUnload (image->module);\n+\tif (cuModuleUnload (image->module) != CUDA_SUCCESS)\n+\t  ret = false;\n \tfree (image->fns);\n \tfree (image);\n \tbreak;\n       }\n   pthread_mutex_unlock (&dev->image_lock);\n+  return ret;\n }\n \n void *\n GOMP_OFFLOAD_alloc (int ord, size_t size)\n {\n-  nvptx_attach_host_thread_to_device (ord);\n+  if (!nvptx_attach_host_thread_to_device (ord))\n+    return NULL;\n   return nvptx_alloc (size);\n }\n \n-void\n+bool\n GOMP_OFFLOAD_free (int ord, void *ptr)\n {\n-  nvptx_attach_host_thread_to_device (ord);\n-  nvptx_free (ptr);\n+  return (nvptx_attach_host_thread_to_device (ord)\n+\t  && nvptx_free (ptr));\n }\n \n-void *\n+bool\n GOMP_OFFLOAD_dev2host (int ord, void *dst, const void *src, size_t n)\n {\n-  nvptx_attach_host_thread_to_device (ord);\n-  return nvptx_dev2host (dst, src, n);\n+  return (nvptx_attach_host_thread_to_device (ord)\n+\t  && nvptx_dev2host (dst, src, n));\n }\n \n-void *\n+bool\n GOMP_OFFLOAD_host2dev (int ord, void *dst, const void *src, size_t n)\n {\n-  nvptx_attach_host_thread_to_device (ord);\n-  return nvptx_host2dev (dst, src, n);\n+  return (nvptx_attach_host_thread_to_device (ord)\n+\t  && nvptx_host2dev (dst, src, n));\n }\n \n void (*device_run) (int n, void *fn_ptr, void *vars) = NULL;\n@@ -1669,20 +1648,11 @@ GOMP_OFFLOAD_openacc_parallel (void (*fn) (void *), size_t mapnum,\n void\n GOMP_OFFLOAD_openacc_register_async_cleanup (void *targ_mem_desc)\n {\n-  CUevent *e;\n-  CUresult r;\n   struct nvptx_thread *nvthd = nvptx_thread ();\n+  CUevent *e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n \n-  e = (CUevent *) GOMP_PLUGIN_malloc (sizeof (CUevent));\n-\n-  r = cuEventCreate (e, CU_EVENT_DISABLE_TIMING);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuEventCreate error: %s\", cuda_error (r));\n-\n-  r = cuEventRecord (*e, nvthd->current_stream->stream);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuEventRecord error: %s\", cuda_error (r));\n-\n+  CUDA_CALL_ASSERT (cuEventCreate, e, CU_EVENT_DISABLE_TIMING);\n+  CUDA_CALL_ASSERT (cuEventRecord, *e, nvthd->current_stream->stream);\n   event_add (PTX_EVT_ASYNC_CLEANUP, e, targ_mem_desc);\n }\n \n@@ -1734,25 +1704,18 @@ GOMP_OFFLOAD_openacc_create_thread_data (int ord)\n   struct ptx_device *ptx_dev;\n   struct nvptx_thread *nvthd\n     = GOMP_PLUGIN_malloc (sizeof (struct nvptx_thread));\n-  CUresult r;\n   CUcontext thd_ctx;\n \n   ptx_dev = ptx_devices[ord];\n \n   assert (ptx_dev);\n \n-  r = cuCtxGetCurrent (&thd_ctx);\n-  if (r != CUDA_SUCCESS)\n-    GOMP_PLUGIN_fatal (\"cuCtxGetCurrent error: %s\", cuda_error (r));\n+  CUDA_CALL_ASSERT (cuCtxGetCurrent, &thd_ctx);\n \n   assert (ptx_dev->ctx);\n \n   if (!thd_ctx)\n-    {\n-      r = cuCtxPushCurrent (ptx_dev->ctx);\n-      if (r != CUDA_SUCCESS)\n-\tGOMP_PLUGIN_fatal (\"cuCtxPushCurrent error: %s\", cuda_error (r));\n-    }\n+    CUDA_CALL_ASSERT (cuCtxPushCurrent, ptx_dev->ctx);\n \n   nvthd->current_stream = ptx_dev->null_stream;\n   nvthd->ptx_dev = ptx_dev;"}, {"sha": "5a86fc077e6e7a7e376531b96bb0281cfb6ac0cd", "filename": "libgomp/target.c", "status": "modified", "additions": 151, "deletions": 101, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -162,6 +162,45 @@ gomp_map_0len_lookup (splay_tree mem_map, splay_tree_key key)\n   return n;\n }\n \n+static inline void\n+gomp_device_copy (struct gomp_device_descr *devicep,\n+\t\t  bool (*copy_func) (int, void *, const void *, size_t),\n+\t\t  const char *dst, void *dstaddr,\n+\t\t  const char *src, const void *srcaddr,\n+\t\t  size_t size)\n+{\n+  if (!copy_func (devicep->target_id, dstaddr, srcaddr, size))\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"Copying of %s object [%p..%p) to %s object [%p..%p) failed\",\n+\t\t  src, srcaddr, srcaddr + size, dst, dstaddr, dstaddr + size);\n+    }\n+}\n+\n+static void\n+gomp_copy_host2dev (struct gomp_device_descr *devicep,\n+\t\t    void *d, const void *h, size_t sz)\n+{\n+  gomp_device_copy (devicep, devicep->host2dev_func, \"dev\", d, \"host\", h, sz);\n+}\n+\n+static void\n+gomp_copy_dev2host (struct gomp_device_descr *devicep,\n+\t\t    void *h, const void *d, size_t sz)\n+{\n+  gomp_device_copy (devicep, devicep->dev2host_func, \"host\", h, \"dev\", d, sz);\n+}\n+\n+static void\n+gomp_free_device_memory (struct gomp_device_descr *devicep, void *devptr)\n+{\n+  if (!devicep->free_func (devicep->target_id, devptr))\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"error in freeing device memory block at %p\", devptr);\n+    }\n+}\n+\n /* Handle the case where gomp_map_lookup, splay_tree_lookup or\n    gomp_map_0len_lookup found oldn for newn.\n    Helper function of gomp_map_vars.  */\n@@ -189,11 +228,12 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,\n     }\n \n   if (GOMP_MAP_ALWAYS_TO_P (kind))\n-    devicep->host2dev_func (devicep->target_id,\n-\t\t\t    (void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n-\t\t\t\t      + newn->host_start - oldn->host_start),\n-\t\t\t    (void *) newn->host_start,\n-\t\t\t    newn->host_end - newn->host_start);\n+    gomp_copy_host2dev (devicep,\n+\t\t\t(void *) (oldn->tgt->tgt_start + oldn->tgt_offset\n+\t\t\t\t  + newn->host_start - oldn->host_start),\n+\t\t\t(void *) newn->host_start,\n+\t\t\tnewn->host_end - newn->host_start);\n+\n   if (oldn->refcount != REFCOUNT_INFINITY)\n     oldn->refcount++;\n }\n@@ -218,10 +258,10 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n     {\n       cur_node.tgt_offset = (uintptr_t) NULL;\n       /* FIXME: see comment about coalescing host/dev transfers below.  */\n-      devicep->host2dev_func (devicep->target_id,\n-\t\t\t      (void *) (tgt->tgt_start + target_offset),\n-\t\t\t      (void *) &cur_node.tgt_offset,\n-\t\t\t      sizeof (void *));\n+      gomp_copy_host2dev (devicep,\n+\t\t\t  (void *) (tgt->tgt_start + target_offset),\n+\t\t\t  (void *) &cur_node.tgt_offset,\n+\t\t\t  sizeof (void *));\n       return;\n     }\n   /* Add bias to the pointer value.  */\n@@ -241,10 +281,8 @@ gomp_map_pointer (struct target_mem_desc *tgt, uintptr_t host_ptr,\n      to initialize the pointer with.  */\n   cur_node.tgt_offset -= bias;\n   /* FIXME: see comment about coalescing host/dev transfers below.  */\n-  devicep->host2dev_func (devicep->target_id,\n-\t\t\t  (void *) (tgt->tgt_start + target_offset),\n-\t\t\t  (void *) &cur_node.tgt_offset,\n-\t\t\t  sizeof (void *));\n+  gomp_copy_host2dev (devicep, (void *) (tgt->tgt_start + target_offset),\n+\t\t      (void *) &cur_node.tgt_offset, sizeof (void *));\n }\n \n static void\n@@ -515,6 +553,12 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t memory.  */\n       tgt->to_free = devicep->alloc_func (devicep->target_id,\n \t\t\t\t\t  tgt_size + tgt_align - 1);\n+      if (!tgt->to_free)\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  gomp_fatal (\"device memory allocation fail\");\n+\t}\n+\n       tgt->tgt_start = (uintptr_t) tgt->to_free;\n       tgt->tgt_start = (tgt->tgt_start + tgt_align - 1) & ~(tgt_align - 1);\n       tgt->tgt_end = tgt->tgt_start + tgt_size;\n@@ -554,9 +598,9 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\ttgt_size = (tgt_size + align - 1) & ~(align - 1);\n \t\ttgt->list[i].offset = tgt_size;\n \t\tlen = sizes[i];\n-\t\tdevicep->host2dev_func (devicep->target_id,\n-\t\t\t\t\t(void *) (tgt->tgt_start + tgt_size),\n-\t\t\t\t\t(void *) hostaddrs[i], len);\n+\t\tgomp_copy_host2dev (devicep,\n+\t\t\t\t    (void *) (tgt->tgt_start + tgt_size),\n+\t\t\t\t    (void *) hostaddrs[i], len);\n \t\ttgt_size += len;\n \t\tcontinue;\n \t      case GOMP_MAP_FIRSTPRIVATE_INT:\n@@ -608,13 +652,13 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i - 1);\n \t\tif (cur_node.tgt_offset)\n \t\t  cur_node.tgt_offset -= sizes[i];\n-\t\tdevicep->host2dev_func (devicep->target_id,\n-\t\t\t\t\t(void *) (n->tgt->tgt_start\n-\t\t\t\t\t\t  + n->tgt_offset\n-\t\t\t\t\t\t  + cur_node.host_start\n-\t\t\t\t\t\t  - n->host_start),\n-\t\t\t\t\t(void *) &cur_node.tgt_offset,\n-\t\t\t\t\tsizeof (void *));\n+\t\tgomp_copy_host2dev (devicep,\n+\t\t\t\t    (void *) (n->tgt->tgt_start\n+\t\t\t\t\t      + n->tgt_offset\n+\t\t\t\t\t      + cur_node.host_start\n+\t\t\t\t\t      - n->host_start),\n+\t\t\t\t    (void *) &cur_node.tgt_offset,\n+\t\t\t\t    sizeof (void *));\n \t\tcur_node.tgt_offset = n->tgt->tgt_start + n->tgt_offset\n \t\t\t\t      + cur_node.host_start - n->host_start;\n \t\tcontinue;\n@@ -685,23 +729,23 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t    /* FIXME: Perhaps add some smarts, like if copying\n \t\t       several adjacent fields from host to target, use some\n \t\t       host buffer to avoid sending each var individually.  */\n-\t\t    devicep->host2dev_func (devicep->target_id,\n-\t\t\t\t\t    (void *) (tgt->tgt_start\n-\t\t\t\t\t\t      + k->tgt_offset),\n-\t\t\t\t\t    (void *) k->host_start,\n-\t\t\t\t\t    k->host_end - k->host_start);\n+\t\t    gomp_copy_host2dev (devicep,\n+\t\t\t\t\t(void *) (tgt->tgt_start\n+\t\t\t\t\t\t  + k->tgt_offset),\n+\t\t\t\t\t(void *) k->host_start,\n+\t\t\t\t\tk->host_end - k->host_start);\n \t\t    break;\n \t\t  case GOMP_MAP_POINTER:\n \t\t    gomp_map_pointer (tgt, (uintptr_t) *(void **) k->host_start,\n \t\t\t\t      k->tgt_offset, sizes[i]);\n \t\t    break;\n \t\t  case GOMP_MAP_TO_PSET:\n \t\t    /* FIXME: see above FIXME comment.  */\n-\t\t    devicep->host2dev_func (devicep->target_id,\n-\t\t\t\t\t    (void *) (tgt->tgt_start\n-\t\t\t\t\t\t      + k->tgt_offset),\n-\t\t\t\t\t    (void *) k->host_start,\n-\t\t\t\t\t    k->host_end - k->host_start);\n+\t\t    gomp_copy_host2dev (devicep,\n+\t\t\t\t\t(void *) (tgt->tgt_start\n+\t\t\t\t\t\t  + k->tgt_offset),\n+\t\t\t\t\t(void *) k->host_start,\n+\t\t\t\t\tk->host_end - k->host_start);\n \n \t\t    for (j = i + 1; j < mapnum; j++)\n \t\t      if (!GOMP_MAP_POINTER_P (get_kind (short_mapkind, kinds,\n@@ -748,12 +792,11 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t    break;\n \t\t  case GOMP_MAP_FORCE_DEVICEPTR:\n \t\t    assert (k->host_end - k->host_start == sizeof (void *));\n-\n-\t\t    devicep->host2dev_func (devicep->target_id,\n-\t\t\t\t\t    (void *) (tgt->tgt_start\n-\t\t\t\t\t\t      + k->tgt_offset),\n-\t\t\t\t\t    (void *) k->host_start,\n-\t\t\t\t\t    sizeof (void *));\n+\t\t    gomp_copy_host2dev (devicep,\n+\t\t\t\t\t(void *) (tgt->tgt_start\n+\t\t\t\t\t\t  + k->tgt_offset),\n+\t\t\t\t\t(void *) k->host_start,\n+\t\t\t\t\tsizeof (void *));\n \t\t    break;\n \t\t  default:\n \t\t    gomp_mutex_unlock (&devicep->lock);\n@@ -781,11 +824,9 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t{\n \t  cur_node.tgt_offset = gomp_map_val (tgt, hostaddrs, i);\n \t  /* FIXME: see above FIXME comment.  */\n-\t  devicep->host2dev_func (devicep->target_id,\n-\t\t\t\t  (void *) (tgt->tgt_start\n-\t\t\t\t\t    + i * sizeof (void *)),\n-\t\t\t\t  (void *) &cur_node.tgt_offset,\n-\t\t\t\t  sizeof (void *));\n+\t  gomp_copy_host2dev (devicep,\n+\t\t\t      (void *) (tgt->tgt_start + i * sizeof (void *)),\n+\t\t\t      (void *) &cur_node.tgt_offset, sizeof (void *));\n \t}\n     }\n \n@@ -807,7 +848,7 @@ gomp_unmap_tgt (struct target_mem_desc *tgt)\n {\n   /* Deallocate on target the tgt->tgt_start .. tgt->tgt_end region.  */\n   if (tgt->tgt_end)\n-    tgt->device_descr->free_func (tgt->device_descr->target_id, tgt->to_free);\n+    gomp_free_device_memory (tgt->device_descr, tgt->to_free);\n \n   free (tgt->array);\n   free (tgt);\n@@ -839,9 +880,9 @@ gomp_copy_from_async (struct target_mem_desc *tgt)\n       {\n \tsplay_tree_key k = tgt->list[i].key;\n \tif (tgt->list[i].copy_from)\n-\t  devicep->dev2host_func (devicep->target_id, (void *) k->host_start,\n-\t\t\t\t  (void *) (k->tgt->tgt_start + k->tgt_offset),\n-\t\t\t\t  k->host_end - k->host_start);\n+\t  gomp_copy_dev2host (devicep, (void *) k->host_start,\n+\t\t\t      (void *) (k->tgt->tgt_start + k->tgt_offset),\n+\t\t\t      k->host_end - k->host_start);\n       }\n \n   gomp_mutex_unlock (&devicep->lock);\n@@ -894,11 +935,11 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n \n       if ((do_unmap && do_copyfrom && tgt->list[i].copy_from)\n \t  || tgt->list[i].always_copy_from)\n-\tdevicep->dev2host_func (devicep->target_id,\n-\t\t\t\t(void *) (k->host_start + tgt->list[i].offset),\n-\t\t\t\t(void *) (k->tgt->tgt_start + k->tgt_offset\n-\t\t\t\t\t  + tgt->list[i].offset),\n-\t\t\t\ttgt->list[i].length);\n+\tgomp_copy_dev2host (devicep,\n+\t\t\t    (void *) (k->host_start + tgt->list[i].offset),\n+\t\t\t    (void *) (k->tgt->tgt_start + k->tgt_offset\n+\t\t\t\t      + tgt->list[i].offset),\n+\t\t\t    tgt->list[i].length);\n       if (do_unmap)\n \t{\n \t  splay_tree_remove (&devicep->mem_map, k);\n@@ -961,22 +1002,17 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n \t\t\t    (void *) n->host_start,\n \t\t\t    (void *) n->host_end);\n \t      }\n+\n+\n+\t    void *hostaddr = (void *) cur_node.host_start;\n+\t    void *devaddr = (void *) (n->tgt->tgt_start + n->tgt_offset\n+\t\t\t\t      + cur_node.host_start - n->host_start);\n+\t    size_t size = cur_node.host_end - cur_node.host_start;\n+\n \t    if (GOMP_MAP_COPY_TO_P (kind & typemask))\n-\t      devicep->host2dev_func (devicep->target_id,\n-\t\t\t\t      (void *) (n->tgt->tgt_start\n-\t\t\t\t\t\t+ n->tgt_offset\n-\t\t\t\t\t\t+ cur_node.host_start\n-\t\t\t\t\t\t- n->host_start),\n-\t\t\t\t      (void *) cur_node.host_start,\n-\t\t\t\t      cur_node.host_end - cur_node.host_start);\n+\t      gomp_copy_host2dev (devicep, devaddr, hostaddr, size);\n \t    if (GOMP_MAP_COPY_FROM_P (kind & typemask))\n-\t      devicep->dev2host_func (devicep->target_id,\n-\t\t\t\t      (void *) cur_node.host_start,\n-\t\t\t\t      (void *) (n->tgt->tgt_start\n-\t\t\t\t\t\t+ n->tgt_offset\n-\t\t\t\t\t\t+ cur_node.host_start\n-\t\t\t\t\t\t- n->host_start),\n-\t\t\t\t      cur_node.host_end - cur_node.host_start);\n+\t      gomp_copy_dev2host (devicep, hostaddr, devaddr, size);\n \t  }\n       }\n   gomp_mutex_unlock (&devicep->lock);\n@@ -1114,7 +1150,11 @@ gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n       node = splay_tree_lookup (&devicep->mem_map, &k);\n     }\n \n-  devicep->unload_image_func (devicep->target_id, version, target_data);\n+  if (!devicep->unload_image_func (devicep->target_id, version, target_data))\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"image unload fail\");\n+    }\n \n   /* Remove mappings from splay tree.  */\n   int i;\n@@ -1261,7 +1301,11 @@ attribute_hidden void\n gomp_init_device (struct gomp_device_descr *devicep)\n {\n   int i;\n-  devicep->init_device_func (devicep->target_id);\n+  if (!devicep->init_device_func (devicep->target_id))\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"device initialization failed\");\n+    }\n \n   /* Load to device all images registered by the moment.  */\n   for (i = 0; i < num_offload_images; i++)\n@@ -1765,12 +1809,11 @@ gomp_exit_data (struct gomp_device_descr *devicep, size_t mapnum,\n \n \t  if ((kind == GOMP_MAP_FROM && k->refcount == 0)\n \t      || kind == GOMP_MAP_ALWAYS_FROM)\n-\t    devicep->dev2host_func (devicep->target_id,\n-\t\t\t\t    (void *) cur_node.host_start,\n-\t\t\t\t    (void *) (k->tgt->tgt_start + k->tgt_offset\n-\t\t\t\t\t      + cur_node.host_start\n-\t\t\t\t\t      - k->host_start),\n-\t\t\t\t    cur_node.host_end - cur_node.host_start);\n+\t    gomp_copy_dev2host (devicep, (void *) cur_node.host_start,\n+\t\t\t\t(void *) (k->tgt->tgt_start + k->tgt_offset\n+\t\t\t\t\t  + cur_node.host_start\n+\t\t\t\t\t  - k->host_start),\n+\t\t\t\tcur_node.host_end - cur_node.host_start);\n \t  if (k->refcount == 0)\n \t    {\n \t      splay_tree_remove (&devicep->mem_map, k);\n@@ -2001,7 +2044,7 @@ omp_target_free (void *device_ptr, int device_num)\n     }\n \n   gomp_mutex_lock (&devicep->lock);\n-  devicep->free_func (devicep->target_id, device_ptr);\n+  gomp_free_device_memory (devicep, device_ptr);\n   gomp_mutex_unlock (&devicep->lock);\n }\n \n@@ -2042,6 +2085,7 @@ omp_target_memcpy (void *dst, void *src, size_t length, size_t dst_offset,\n \t\t   size_t src_offset, int dst_device_num, int src_device_num)\n {\n   struct gomp_device_descr *dst_devicep = NULL, *src_devicep = NULL;\n+  bool ret;\n \n   if (dst_device_num != GOMP_DEVICE_HOST_FALLBACK)\n     {\n@@ -2077,29 +2121,29 @@ omp_target_memcpy (void *dst, void *src, size_t length, size_t dst_offset,\n   if (src_devicep == NULL)\n     {\n       gomp_mutex_lock (&dst_devicep->lock);\n-      dst_devicep->host2dev_func (dst_devicep->target_id,\n-\t\t\t\t  (char *) dst + dst_offset,\n-\t\t\t\t  (char *) src + src_offset, length);\n+      ret = dst_devicep->host2dev_func (dst_devicep->target_id,\n+\t\t\t\t\t(char *) dst + dst_offset,\n+\t\t\t\t\t(char *) src + src_offset, length);\n       gomp_mutex_unlock (&dst_devicep->lock);\n-      return 0;\n+      return (ret ? 0 : EINVAL);\n     }\n   if (dst_devicep == NULL)\n     {\n       gomp_mutex_lock (&src_devicep->lock);\n-      src_devicep->dev2host_func (src_devicep->target_id,\n-\t\t\t\t  (char *) dst + dst_offset,\n-\t\t\t\t  (char *) src + src_offset, length);\n+      ret = src_devicep->dev2host_func (src_devicep->target_id,\n+\t\t\t\t\t(char *) dst + dst_offset,\n+\t\t\t\t\t(char *) src + src_offset, length);\n       gomp_mutex_unlock (&src_devicep->lock);\n-      return 0;\n+      return (ret ? 0 : EINVAL);\n     }\n   if (src_devicep == dst_devicep)\n     {\n       gomp_mutex_lock (&src_devicep->lock);\n-      src_devicep->dev2dev_func (src_devicep->target_id,\n-\t\t\t\t (char *) dst + dst_offset,\n-\t\t\t\t (char *) src + src_offset, length);\n+      ret = src_devicep->dev2dev_func (src_devicep->target_id,\n+\t\t\t\t       (char *) dst + dst_offset,\n+\t\t\t\t       (char *) src + src_offset, length);\n       gomp_mutex_unlock (&src_devicep->lock);\n-      return 0;\n+      return (ret ? 0 : EINVAL);\n     }\n   return EINVAL;\n }\n@@ -2126,22 +2170,25 @@ omp_target_memcpy_rect_worker (void *dst, void *src, size_t element_size,\n \t  || __builtin_mul_overflow (element_size, src_offsets[0], &src_off))\n \treturn EINVAL;\n       if (dst_devicep == NULL && src_devicep == NULL)\n-\tmemcpy ((char *) dst + dst_off, (char *) src + src_off, length);\n+\t{\n+\t  memcpy ((char *) dst + dst_off, (char *) src + src_off, length);\n+\t  ret = 1;\n+\t}\n       else if (src_devicep == NULL)\n-\tdst_devicep->host2dev_func (dst_devicep->target_id,\n-\t\t\t\t    (char *) dst + dst_off,\n-\t\t\t\t    (char *) src + src_off, length);\n+\tret = dst_devicep->host2dev_func (dst_devicep->target_id,\n+\t\t\t\t\t  (char *) dst + dst_off,\n+\t\t\t\t\t  (char *) src + src_off, length);\n       else if (dst_devicep == NULL)\n-\tsrc_devicep->dev2host_func (src_devicep->target_id,\n-\t\t\t\t    (char *) dst + dst_off,\n-\t\t\t\t    (char *) src + src_off, length);\n+\tret = src_devicep->dev2host_func (src_devicep->target_id,\n+\t\t\t\t\t  (char *) dst + dst_off,\n+\t\t\t\t\t  (char *) src + src_off, length);\n       else if (src_devicep == dst_devicep)\n-\tsrc_devicep->dev2dev_func (src_devicep->target_id,\n-\t\t\t\t   (char *) dst + dst_off,\n-\t\t\t\t   (char *) src + src_off, length);\n+\tret = src_devicep->dev2dev_func (src_devicep->target_id,\n+\t\t\t\t\t (char *) dst + dst_off,\n+\t\t\t\t\t (char *) src + src_off, length);\n       else\n-\treturn EINVAL;\n-      return 0;\n+\tret = 0;\n+      return ret ? 0 : EINVAL;\n     }\n \n   /* FIXME: it would be nice to have some plugin function to handle\n@@ -2456,14 +2503,17 @@ gomp_target_fini (void)\n   int i;\n   for (i = 0; i < num_devices; i++)\n     {\n+      bool ret = true;\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n       if (devicep->state == GOMP_DEVICE_INITIALIZED)\n \t{\n-\t  devicep->fini_device_func (devicep->target_id);\n+\t  ret = devicep->fini_device_func (devicep->target_id);\n \t  devicep->state = GOMP_DEVICE_FINALIZED;\n \t}\n       gomp_mutex_unlock (&devicep->lock);\n+      if (!ret)\n+\tgomp_fatal (\"device finalization failed\");\n     }\n }\n "}, {"sha": "b866cf13adfb8f71c0081eda88d673743f1a3cf2", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -1,3 +1,21 @@\n+2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* plugin/libgomp-plugin-intelmic.cpp (offload): Change return type\n+\tto bool, adjust return code.\n+\t(GOMP_OFFLOAD_init_device): Likewise.\n+\t(GOMP_OFFLOAD_fini_device): Likewise.\n+\t(get_target_table): Likewise.\n+\t(offload_image): Likwise.\n+\t(GOMP_OFFLOAD_load_image): Adjust call to offload_image(), change\n+\tto return -1 on error.\n+\t(GOMP_OFFLOAD_unload_image): Change return type to bool, adjust return\n+\tcode.\n+\t(GOMP_OFFLOAD_alloc): Likewise.\n+\t(GOMP_OFFLOAD_free): Likewise.\n+\t(GOMP_OFFLOAD_host2dev): Likewise.\n+\t(GOMP_OFFLOAD_dev2host): Likewise.\n+\t(GOMP_OFFLOAD_dev2dev): Likewise.\n+\n 2016-01-20  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_run): Pass extra NULL"}, {"sha": "7983532e0c0b5ce6b9421dd4b8d728d9086ae8aa", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 70, "deletions": 51, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce13072311aaa5194488797f127c2b202d72b25/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce13072311aaa5194488797f127c2b202d72b25/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=6ce13072311aaa5194488797f127c2b202d72b25", "patch": "@@ -205,28 +205,29 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return num_devices;\n }\n \n-static void\n+static bool\n offload (const char *file, uint64_t line, int device, const char *name,\n \t int num_vars, VarDesc *vars, const void **async_data)\n {\n   OFFLOAD ofld = __offload_target_acquire1 (&device, file, line);\n   if (ofld)\n     {\n       if (async_data == NULL)\n-\t__offload_offload1 (ofld, name, 0, num_vars, vars, NULL, 0, NULL, NULL);\n+\treturn __offload_offload1 (ofld, name, 0, num_vars, vars, NULL, 0,\n+\t\t\t\t   NULL, NULL);\n       else\n \t{\n \t  OffloadFlags flags;\n \t  flags.flags = 0;\n \t  flags.bits.omp_async = 1;\n-\t  __offload_offload3 (ofld, name, 0, num_vars, vars, NULL, 0, NULL,\n-\t\t\t      async_data, 0, NULL, flags, NULL);\n+\t  return __offload_offload3 (ofld, name, 0, num_vars, vars, NULL, 0,\n+\t\t\t\t     NULL, async_data, 0, NULL, flags, NULL);\n \t}\n     }\n   else\n     {\n-      fprintf (stderr, \"%s:%d: Offload target acquire failed\\n\", file, line);\n-      exit (1);\n+      GOMP_PLUGIN_error (\"%s:%d: Offload target acquire failed\\n\", file, line);\n+      return false;\n     }\n }\n \n@@ -244,25 +245,26 @@ register_main_image ()\n \n /* liboffloadmic loads and runs offload_target_main on all available devices\n    during a first call to offload ().  */\n-extern \"C\" void\n+extern \"C\" bool\n GOMP_OFFLOAD_init_device (int device)\n {\n   TRACE (\"(device = %d)\", device);\n   pthread_once (&main_image_is_registered, register_main_image);\n-  offload (__FILE__, __LINE__, device, \"__offload_target_init_proc\", 0, NULL,\n-\t   NULL);\n+  return offload (__FILE__, __LINE__, device, \"__offload_target_init_proc\", 0,\n+\t\t  NULL, NULL);\n }\n \n-extern \"C\" void\n+extern \"C\" bool\n GOMP_OFFLOAD_fini_device (int device)\n {\n   TRACE (\"(device = %d)\", device);\n \n   /* liboffloadmic will finalize target processes on all available devices.  */\n   __offload_unregister_image (&main_target_image);\n+  return true;\n }\n \n-static void\n+static bool\n get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n {\n   VarDesc vd1[2] = { vd_tgt2host, vd_tgt2host };\n@@ -271,8 +273,9 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n   vd1[1].ptr = &num_vars;\n   vd1[1].size = sizeof (num_vars);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_table_p1\", 2, vd1,\n-\t   NULL);\n+  if (!offload (__FILE__, __LINE__, device, \"__offload_target_table_p1\", 2,\n+\t\tvd1, NULL))\n+    return false;\n \n   int table_size = num_funcs + 2 * num_vars;\n   if (table_size > 0)\n@@ -284,15 +287,16 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n       vd2.ptr = table;\n       vd2.size = table_size * sizeof (void *);\n \n-      offload (__FILE__, __LINE__, device, \"__offload_target_table_p2\", 1, &vd2,\n-\t       NULL);\n+      return offload (__FILE__, __LINE__, device, \"__offload_target_table_p2\",\n+\t\t      1, &vd2, NULL);\n     }\n+  return true;\n }\n \n /* Offload TARGET_IMAGE to all available devices and fill address_table with\n    corresponding target addresses.  */\n \n-static void\n+static bool\n offload_image (const void *target_image)\n {\n   void *image_start = ((void **) target_image)[0];\n@@ -306,8 +310,8 @@ offload_image (const void *target_image)\n \t\t\t\t\t\t       + image_size);\n   if (!image)\n     {\n-      fprintf (stderr, \"%s: Can't allocate memory\\n\", __FILE__);\n-      exit (1);\n+      GOMP_PLUGIN_error (\"%s: Can't allocate memory\\n\", __FILE__);\n+      return false;\n     }\n \n   image->size = image_size;\n@@ -322,13 +326,14 @@ offload_image (const void *target_image)\n \n   /* Receive tables for target_image from all devices.  */\n   DevAddrVect dev_table;\n+  bool ret = true;\n   for (int dev = 0; dev < num_devices; dev++)\n     {\n       int num_funcs = 0;\n       int num_vars = 0;\n       void **table = NULL;\n \n-      get_target_table (dev, num_funcs, num_vars, table);\n+      ret &= get_target_table (dev, num_funcs, num_vars, table);\n \n       AddrVect curr_dev_table;\n \n@@ -357,6 +362,7 @@ offload_image (const void *target_image)\n \n   address_table->insert (std::make_pair (target_image, dev_table));\n   image_descriptors->insert (std::make_pair (target_image, image));\n+  return ret;\n }\n \n /* Return the libgomp version number we're compatible with.  There is\n@@ -375,35 +381,47 @@ GOMP_OFFLOAD_load_image (int device, const unsigned version,\n   TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n \n   if (GOMP_VERSION_DEV (version) > GOMP_VERSION_INTEL_MIC)\n-    GOMP_PLUGIN_fatal (\"Offload data incompatible with intelmic plugin\"\n-\t\t       \" (expected %u, received %u)\",\n-\t\t       GOMP_VERSION_INTEL_MIC, GOMP_VERSION_DEV (version));\n+    {\n+      GOMP_PLUGIN_error (\"Offload data incompatible with intelmic plugin\"\n+\t\t\t \" (expected %u, received %u)\",\n+\t\t\t GOMP_VERSION_INTEL_MIC, GOMP_VERSION_DEV (version));\n+      return -1;\n+    }\n \n   /* If target_image is already present in address_table, then there is no need\n      to offload it.  */\n   if (address_table->count (target_image) == 0)\n-    offload_image (target_image);\n+    {\n+      /* If fail, return -1 as error code.  */\n+      if (!offload_image (target_image))\n+\treturn -1;\n+    }\n \n   AddrVect *curr_dev_table = &(*address_table)[target_image][device];\n   int table_size = curr_dev_table->size ();\n   addr_pair *table = (addr_pair *) malloc (table_size * sizeof (addr_pair));\n   if (table == NULL)\n     {\n-      fprintf (stderr, \"%s: Can't allocate memory\\n\", __FILE__);\n-      exit (1);\n+      GOMP_PLUGIN_error (\"%s: Can't allocate memory\\n\", __FILE__);\n+      return -1;\n     }\n \n   std::copy (curr_dev_table->begin (), curr_dev_table->end (), table);\n   *result = table;\n   return table_size;\n }\n \n-extern \"C\" void\n+extern \"C\" bool\n GOMP_OFFLOAD_unload_image (int device, unsigned version,\n \t\t\t   const void *target_image)\n {\n   if (GOMP_VERSION_DEV (version) > GOMP_VERSION_INTEL_MIC)\n-    return;\n+    {\n+      GOMP_PLUGIN_error (\"Offload data incompatible with intelmic plugin\"\n+\t\t\t \" (expected %u, received %u)\",\n+\t\t\t GOMP_VERSION_INTEL_MIC, GOMP_VERSION_DEV (version));\n+      return false;\n+    }\n \n   TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n \n@@ -417,6 +435,7 @@ GOMP_OFFLOAD_unload_image (int device, unsigned version,\n       address_table->erase (target_image);\n       image_descriptors->erase (target_image);\n     }\n+  return true;\n }\n \n extern \"C\" void *\n@@ -431,12 +450,14 @@ GOMP_OFFLOAD_alloc (int device, size_t size)\n   vd[1].ptr = &tgt_ptr;\n   vd[1].size = sizeof (void *);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_alloc\", 2, vd, NULL);\n+  if (!offload (__FILE__, __LINE__, device, \"__offload_target_alloc\", 2,\n+\t\tvd, NULL))\n+    return NULL;\n \n   return tgt_ptr;\n }\n \n-extern \"C\" void\n+extern \"C\" bool\n GOMP_OFFLOAD_free (int device, void *tgt_ptr)\n {\n   TRACE (\"(device = %d, tgt_ptr = %p)\", device, tgt_ptr);\n@@ -445,73 +466,72 @@ GOMP_OFFLOAD_free (int device, void *tgt_ptr)\n   vd.ptr = &tgt_ptr;\n   vd.size = sizeof (void *);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_free\", 1, &vd, NULL);\n+  return offload (__FILE__, __LINE__, device, \"__offload_target_free\", 1,\n+\t\t  &vd, NULL);\n }\n \n-extern \"C\" void *\n+extern \"C\" bool\n GOMP_OFFLOAD_host2dev (int device, void *tgt_ptr, const void *host_ptr,\n \t\t       size_t size)\n {\n   TRACE (\"(device = %d, tgt_ptr = %p, host_ptr = %p, size = %d)\",\n \t device, tgt_ptr, host_ptr, size);\n   if (!size)\n-    return tgt_ptr;\n+    return true;\n \n   VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n   vd1[0].ptr = &tgt_ptr;\n   vd1[0].size = sizeof (void *);\n   vd1[1].ptr = &size;\n   vd1[1].size = sizeof (size);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p1\", 2, vd1,\n-\t   NULL);\n+  if (!offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p1\", 2,\n+\t\tvd1, NULL))\n+    return false;\n \n   VarDesc vd2 = vd_host2tgt;\n   vd2.ptr = (void *) host_ptr;\n   vd2.size = size;\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p2\", 1, &vd2,\n-\t   NULL);\n-\n-  return tgt_ptr;\n+  return offload (__FILE__, __LINE__, device, \"__offload_target_host2tgt_p2\", 1,\n+\t\t  &vd2, NULL);\n }\n \n-extern \"C\" void *\n+extern \"C\" bool\n GOMP_OFFLOAD_dev2host (int device, void *host_ptr, const void *tgt_ptr,\n \t\t       size_t size)\n {\n   TRACE (\"(device = %d, host_ptr = %p, tgt_ptr = %p, size = %d)\",\n \t device, host_ptr, tgt_ptr, size);\n   if (!size)\n-    return host_ptr;\n+    return true;\n \n   VarDesc vd1[2] = { vd_host2tgt, vd_host2tgt };\n   vd1[0].ptr = &tgt_ptr;\n   vd1[0].size = sizeof (void *);\n   vd1[1].ptr = &size;\n   vd1[1].size = sizeof (size);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p1\", 2, vd1,\n-\t   NULL);\n+  if (!offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p1\", 2,\n+\t\tvd1, NULL))\n+    return false;\n \n   VarDesc vd2 = vd_tgt2host;\n   vd2.ptr = (void *) host_ptr;\n   vd2.size = size;\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p2\", 1, &vd2,\n-\t   NULL);\n-\n-  return host_ptr;\n+  return offload (__FILE__, __LINE__, device, \"__offload_target_tgt2host_p2\", 1,\n+\t\t  &vd2, NULL);\n }\n \n-extern \"C\" void *\n+extern \"C\" bool\n GOMP_OFFLOAD_dev2dev (int device, void *dst_ptr, const void *src_ptr,\n \t\t      size_t size)\n {\n   TRACE (\"(device = %d, dst_ptr = %p, src_ptr = %p, size = %d)\",\n \t device, dst_ptr, src_ptr, size);\n   if (!size)\n-    return dst_ptr;\n+    return true;\n \n   VarDesc vd[3] = { vd_host2tgt, vd_host2tgt, vd_host2tgt };\n   vd[0].ptr = &dst_ptr;\n@@ -521,9 +541,8 @@ GOMP_OFFLOAD_dev2dev (int device, void *dst_ptr, const void *src_ptr,\n   vd[2].ptr = &size;\n   vd[2].size = sizeof (size);\n \n-  offload (__FILE__, __LINE__, device, \"__offload_target_tgt2tgt\", 3, vd, NULL);\n-\n-  return dst_ptr;\n+  return offload (__FILE__, __LINE__, device, \"__offload_target_tgt2tgt\", 3,\n+\t\t  vd, NULL);\n }\n \n extern \"C\" void"}]}