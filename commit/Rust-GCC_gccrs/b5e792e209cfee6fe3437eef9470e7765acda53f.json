{"sha": "b5e792e209cfee6fe3437eef9470e7765acda53f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlNzkyZTIwOWNmZWU2ZmUzNDM3ZWVmOTQ3MGU3NzY1YWNkYTUzZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-17T13:20:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-17T13:20:48Z"}, "message": "[multiple changes]\n\n2004-05-17  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\tPart of function-at-a-time conversion\n\n\t* misc.c (adjust_decl_rtl): Deleted.\n\t(LANG_HOOKS_PUSHLEVEL, LANG_HOOKS_POPLEVEL, LANG_HOOKS_SET_BLOCK):\n\tDefine.\n\n\t* gigi.h: (adjust_decl_rtl, kept_level_p, set_block): Deleted.\n\t(add_decl_stmt, add_stmt, block_has_vars): New functions.\n\t(gnat_pushlevel, gnat_poplevel): Renamed from pushlevel and poplevel.\n\n\t* decl.c (elaborate_expression, maybe_pad_type): Call add_decl_stmt\n\twhen making a decl.\n\t(gnat_to_gnu_entity): Likewise.\n\tUse add_stmt to update setjmp buffer.\n\tSet TREE_ADDRESSABLE instead of calling put_var_into_stack and\n\tflush_addressof.\n\tNo longer call adjust_decl_rtl.\n\t(DECL_INIT_BY_ASSIGN_P): New macro.\n\t(DECL_STMT_VAR): Likewise.\n\n\t* trans.c (gigi): Call start_block_stmt to make the outermost\n\tBLOCK_STMT.\n\t(gnat_to_code, gnu_to_gnu, tree_transform, process_decls, process_type):\n\tCall start_block_stmt and end_block_stmt temporarily.\n\tUse gnat_expand_stmt instead of expand_expr_stmt.\n\t(add_decl_stmt): New function.\n\t(tree_transform): Call it.\n\t(add_stmt): Also emit initializing assignment for DECL_STMT if needed.\n\t(end_block_stmt): Set type and NULL_STMT.\n\t(gnat_expand_stmt): Make recursize call instead of calling\n\texpand_expr_stmt.\n\t(gnat_expand_stmt, case DECL_STMT): New case.\n\t(set_lineno_from_sloc): Do nothing if global.\n\t(gnu_block_stmt_node, gnu_block_stmt_free_list): New variables.\n\t(start_block_stmt, add_stmt, end_block_stmt): New functions.\n\t(build_block_stmt): Call them.\n\t(gnat_to_code): Don't expand NULL_STMT.\n\t(build_unit_elab): Rename pushlevel and poplevel to gnat_* and change\n\targs.\n\t(tree_transform): Likewise.\n\t(tree_transform, case N_Null_Statement): Return NULL_STMT.\n\t(gnat_expand_stmt, case NULL_STMT): New case.\n\t(gnat_expand_stmt, case IF_STMT): Allow nested IF_STMT to have no\n\tIF_STMT_TRUE.\n\n\t* utils2.c (gnat_mark_addressable, case VAR_DECL): Do not set\n\tTREE_ADDRESSABLE.\n\n\t* utils.c (create_var_decl): Do not call expand_decl or\n\texpand_decl_init.\n\tSet TREE_ADDRESSABLE instead of calling gnat_mark_addressable.\n\tSet DECL_INIT_BY_ASSIGN_P when needed and do not generate MODIFY_EXPR\n\there.\n\t(struct e_stack): Add chain_next to GTY.\n\t(struct binding_level): Deleted.\n\t(struct ada_binding_level): New struct.\n\t(free_block_chain): New.\n\t(global_binding_level, clear_binding_level): Deleted.\n\t(global_bindings_p): Rework to see if no chain.\n\t(kept_level_p, set_block): Deleted.\n\t(gnat_pushlevel): Renamed from pushlevel and extensive reworked to use\n\tnew data structure and work directly on BLOCK node.\n\t(gnat_poplevel): Similarly.\n\t(get_decls): Look at BLOCK_VARS.\n\t(insert_block): Work directly on BLOCK node.\n\t(block_has_var): New function.\n\t(pushdecl): Rework for new binding structures.\n\t(gnat_init_decl_processing): Rename and rework calls to pushlevel and\n\tpoplevel.\n\t(build_subprog_body): Likewise.\n\t(end_subprog_body): Likewise; also set up BLOCK in DECL_INITIAL.\n\n\t* ada-tree.def (DECL_STMT, NULL_STMT): New codes.\n\n\t* ada-tree.h: (DECL_INIT_BY_ASSIGN_P): New macro.\n\t(DECL_STMT_VAR): Likewise.\n\n2004-05-17  Robert Dewar  <dewar@gnat.com>\n\n\t* restrict.ads, restrict.adb (Process_Restriction_Synonym): New\n\tprocedure\n\n\t* sem_prag.adb (Analyze_Pragma, case Restrictions): Cleanup handling\n\tof restriction synonyums by using\n\tRestrict.Process_Restriction_Synonyms.\n\n\t* snames.ads, snames.adb: Add entries for Process_Restriction_Synonym\n\n\t* s-restri.ads (Tasking_Allowed): Correct missing comment\n\n\t* s-rident.ads: Add entries for restriction synonyms\n\n\t* ali.adb: Fix some problems with badly formatted ALI files that can\n\tresult in infinite loops.\n\n\t* s-taprop-lynxos.adb, s-tpopsp-lynxos.adb, s-taprop-tru64.adb,\n\ts-tpopsp-posix-foreign.adb, s-taprop-irix.adb, s-interr-sigaction.adb,\n\ts-taprop-irix-athread.adb, s-taprop-hpux-dce.adb, s-taprop-linux.adb,\n\ts-taprop-dummy.adb, s-interr-dummy.adb, s-taprop-os2.adb,\n\ts-taprop-solaris.adb, s-tpopsp-solaris.adb, s-asthan-vms.adb,\n\ts-inmaop-vms.adb, s-interr-vms.adb, s-taprop-vms.adb,\n\ts-tpopde-vms.adb, s-taprop-mingw.adb, s-interr-vxworks.adb,\n\ts-taprop-vxworks.adb, s-tpopsp-vxworks.adb, s-taprop-posix.adb,\n\ts-tpopsp-posix.adb, s-tratas-default.adb, a-dynpri.adb,\n\ta-tasatt.adb, a-taside.adb, a-taside.ads, exp_attr.adb,\n\texp_ch9.adb, g-thread.adb, rtsfind.ads, sem_attr.adb,\n\ts-interr.adb, s-interr.ads, s-soflin.ads, s-taasde.adb,\n\ts-taasde.ads, s-taenca.adb, s-taenca.ads, s-taprop.ads,\n\ts-tarest.adb, s-tarest.ads, s-tasdeb.adb, s-tasdeb.ads,\n\ts-tasini.adb, s-tasini.ads, s-taskin.adb, s-taskin.ads,\n\ts-tasque.adb, s-tasque.ads, s-tasren.adb, s-tasren.ads,\n\ts-tassta.adb, s-tassta.ads, s-tasuti.adb, s-tasuti.ads,\n\ts-tataat.adb, s-tataat.ads, s-tpinop.adb, s-tpinop.ads,\n\ts-tpoben.adb, s-tpobop.adb, s-tpobop.ads, s-tporft.adb,\n\ts-tposen.adb, s-tposen.ads, s-tratas.adb, s-tratas.ads: Change Task_ID\n\tto Task_Id (minor cleanup).\n\n2004-05-17  Vincent Celier  <celier@gnat.com>\n\n\t* g-os_lib.adb (Normalize_Pathname.Final_Value): Remove trailing\n\tdirectory separator.\n\n\t* prj-proc.adb (Recursive_Process): Inherit attribute Languages from\n\tproject being extended, if Languages is not declared in extending\n\tproject.\n\n2004-05-17  Javier Miranda  <miranda@gnat.com>\n\n\t* sem_ch10.adb (Install_Limited_Withed_Unit): Do not install the\n\tlimited view of a visible sibling.\n\nFrom-SVN: r81935", "tree": {"sha": "2b5692e6b47e044d030ae4b10881296d50e2f101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b5692e6b47e044d030ae4b10881296d50e2f101"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5e792e209cfee6fe3437eef9470e7765acda53f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e792e209cfee6fe3437eef9470e7765acda53f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5e792e209cfee6fe3437eef9470e7765acda53f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e792e209cfee6fe3437eef9470e7765acda53f/comments", "author": null, "committer": null, "parents": [{"sha": "646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646ca712a1d3d4b6642b8d9c3f0d24e463102b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646ca712a1d3d4b6642b8d9c3f0d24e463102b76"}], "stats": {"total": 4061, "additions": 2144, "deletions": 1917}, "files": [{"sha": "c311e987132e820de8f160b43eef1def64c61166", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -1,3 +1,136 @@\n+2004-05-17  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\tPart of function-at-a-time conversion\n+\n+\t* misc.c (adjust_decl_rtl): Deleted.\n+\t(LANG_HOOKS_PUSHLEVEL, LANG_HOOKS_POPLEVEL, LANG_HOOKS_SET_BLOCK):\n+\tDefine.\n+\n+\t* gigi.h: (adjust_decl_rtl, kept_level_p, set_block): Deleted.\n+\t(add_decl_stmt, add_stmt, block_has_vars): New functions.\n+\t(gnat_pushlevel, gnat_poplevel): Renamed from pushlevel and poplevel.\n+\n+\t* decl.c (elaborate_expression, maybe_pad_type): Call add_decl_stmt\n+\twhen making a decl.\n+\t(gnat_to_gnu_entity): Likewise.\n+\tUse add_stmt to update setjmp buffer.\n+\tSet TREE_ADDRESSABLE instead of calling put_var_into_stack and\n+\tflush_addressof.\n+\tNo longer call adjust_decl_rtl.\n+\t(DECL_INIT_BY_ASSIGN_P): New macro.\n+\t(DECL_STMT_VAR): Likewise.\n+\n+\t* trans.c (gigi): Call start_block_stmt to make the outermost\n+\tBLOCK_STMT.\n+\t(gnat_to_code, gnu_to_gnu, tree_transform, process_decls, process_type):\n+\tCall start_block_stmt and end_block_stmt temporarily.\n+\tUse gnat_expand_stmt instead of expand_expr_stmt.\n+\t(add_decl_stmt): New function.\n+\t(tree_transform): Call it.\n+\t(add_stmt): Also emit initializing assignment for DECL_STMT if needed.\n+\t(end_block_stmt): Set type and NULL_STMT.\n+\t(gnat_expand_stmt): Make recursize call instead of calling\n+\texpand_expr_stmt.\n+\t(gnat_expand_stmt, case DECL_STMT): New case.\n+\t(set_lineno_from_sloc): Do nothing if global.\n+\t(gnu_block_stmt_node, gnu_block_stmt_free_list): New variables.\n+\t(start_block_stmt, add_stmt, end_block_stmt): New functions.\n+\t(build_block_stmt): Call them.\n+\t(gnat_to_code): Don't expand NULL_STMT.\n+\t(build_unit_elab): Rename pushlevel and poplevel to gnat_* and change\n+\targs.\n+\t(tree_transform): Likewise.\n+\t(tree_transform, case N_Null_Statement): Return NULL_STMT.\n+\t(gnat_expand_stmt, case NULL_STMT): New case.\n+\t(gnat_expand_stmt, case IF_STMT): Allow nested IF_STMT to have no\n+\tIF_STMT_TRUE.\n+\n+\t* utils2.c (gnat_mark_addressable, case VAR_DECL): Do not set\n+\tTREE_ADDRESSABLE.\n+\n+\t* utils.c (create_var_decl): Do not call expand_decl or\n+\texpand_decl_init.\n+\tSet TREE_ADDRESSABLE instead of calling gnat_mark_addressable.\n+\tSet DECL_INIT_BY_ASSIGN_P when needed and do not generate MODIFY_EXPR\n+\there.\n+\t(struct e_stack): Add chain_next to GTY.\n+\t(struct binding_level): Deleted.\n+\t(struct ada_binding_level): New struct.\n+\t(free_block_chain): New.\n+\t(global_binding_level, clear_binding_level): Deleted.\n+\t(global_bindings_p): Rework to see if no chain.\n+\t(kept_level_p, set_block): Deleted.\n+\t(gnat_pushlevel): Renamed from pushlevel and extensive reworked to use\n+\tnew data structure and work directly on BLOCK node.\n+\t(gnat_poplevel): Similarly.\n+\t(get_decls): Look at BLOCK_VARS.\n+\t(insert_block): Work directly on BLOCK node.\n+\t(block_has_var): New function.\n+\t(pushdecl): Rework for new binding structures.\n+\t(gnat_init_decl_processing): Rename and rework calls to pushlevel and\n+\tpoplevel.\n+\t(build_subprog_body): Likewise.\n+\t(end_subprog_body): Likewise; also set up BLOCK in DECL_INITIAL.\n+\n+\t* ada-tree.def (DECL_STMT, NULL_STMT): New codes.\n+\n+\t* ada-tree.h: (DECL_INIT_BY_ASSIGN_P): New macro.\n+\t(DECL_STMT_VAR): Likewise.\n+\n+2004-05-17  Robert Dewar  <dewar@gnat.com>\n+\n+\t* restrict.ads, restrict.adb (Process_Restriction_Synonym): New\n+\tprocedure\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Restrictions): Cleanup handling\n+\tof restriction synonyums by using\n+\tRestrict.Process_Restriction_Synonyms.\n+\n+\t* snames.ads, snames.adb: Add entries for Process_Restriction_Synonym\n+\n+\t* s-restri.ads (Tasking_Allowed): Correct missing comment\n+\n+\t* s-rident.ads: Add entries for restriction synonyms\n+\n+\t* ali.adb: Fix some problems with badly formatted ALI files that can\n+\tresult in infinite loops.\n+\n+\t* s-taprop-lynxos.adb, s-tpopsp-lynxos.adb, s-taprop-tru64.adb,\n+\ts-tpopsp-posix-foreign.adb, s-taprop-irix.adb, s-interr-sigaction.adb,\n+\ts-taprop-irix-athread.adb, s-taprop-hpux-dce.adb, s-taprop-linux.adb,\n+\ts-taprop-dummy.adb, s-interr-dummy.adb, s-taprop-os2.adb,\n+\ts-taprop-solaris.adb, s-tpopsp-solaris.adb, s-asthan-vms.adb,\n+\ts-inmaop-vms.adb, s-interr-vms.adb, s-taprop-vms.adb,\n+\ts-tpopde-vms.adb, s-taprop-mingw.adb, s-interr-vxworks.adb,\n+\ts-taprop-vxworks.adb, s-tpopsp-vxworks.adb, s-taprop-posix.adb,\n+\ts-tpopsp-posix.adb, s-tratas-default.adb, a-dynpri.adb,\n+\ta-tasatt.adb, a-taside.adb, a-taside.ads, exp_attr.adb,\n+\texp_ch9.adb, g-thread.adb, rtsfind.ads, sem_attr.adb,\n+\ts-interr.adb, s-interr.ads, s-soflin.ads, s-taasde.adb,\n+\ts-taasde.ads, s-taenca.adb, s-taenca.ads, s-taprop.ads,\n+\ts-tarest.adb, s-tarest.ads, s-tasdeb.adb, s-tasdeb.ads,\n+\ts-tasini.adb, s-tasini.ads, s-taskin.adb, s-taskin.ads,\n+\ts-tasque.adb, s-tasque.ads, s-tasren.adb, s-tasren.ads,\n+\ts-tassta.adb, s-tassta.ads, s-tasuti.adb, s-tasuti.ads,\n+\ts-tataat.adb, s-tataat.ads, s-tpinop.adb, s-tpinop.ads,\n+\ts-tpoben.adb, s-tpobop.adb, s-tpobop.ads, s-tporft.adb,\n+\ts-tposen.adb, s-tposen.ads, s-tratas.adb, s-tratas.ads: Change Task_ID\n+\tto Task_Id (minor cleanup).\n+\n+2004-05-17  Vincent Celier  <celier@gnat.com>\n+\n+\t* g-os_lib.adb (Normalize_Pathname.Final_Value): Remove trailing\n+\tdirectory separator.\n+\n+\t* prj-proc.adb (Recursive_Process): Inherit attribute Languages from\n+\tproject being extended, if Languages is not declared in extending\n+\tproject.\n+\n+2004-05-17  Javier Miranda  <miranda@gnat.com>\n+\n+\t* sem_ch10.adb (Install_Limited_Withed_Unit): Do not install the\n+\tlimited view of a visible sibling.\n+\n 2004-05-14  Robert Dewar  <dewar@gnat.com>\n \n \t* gnat_ugn.texi: Minor change to -gnatS documentation"}, {"sha": "3cf82dda8b42e05aac9698d40b16a5901a416d05", "filename": "gcc/ada/a-dynpri.adb", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-dynpri.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-dynpri.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dynpri.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,7 +45,7 @@ with System.Task_Primitives.Operations;\n --           Self\n \n with System.Tasking;\n---  used for Task_ID\n+--  used for Task_Id\n \n with Ada.Exceptions;\n --  used for Raise_Exception\n@@ -68,7 +68,7 @@ package body Ada.Dynamic_Priorities is\n \n    function Convert_Ids is new\n      Unchecked_Conversion\n-       (Task_Identification.Task_Id, System.Tasking.Task_ID);\n+       (Task_Identification.Task_Id, System.Tasking.Task_Id);\n \n    ------------------\n    -- Get_Priority --\n@@ -78,10 +78,9 @@ package body Ada.Dynamic_Priorities is\n \n    function Get_Priority\n      (T : Ada.Task_Identification.Task_Id :=\n-          Ada.Task_Identification.Current_Task)\n-      return System.Any_Priority is\n-\n-      Target : constant Task_ID := Convert_Ids (T);\n+        Ada.Task_Identification.Current_Task) return System.Any_Priority\n+   is\n+      Target : constant Task_Id := Convert_Ids (T);\n       Error_Message : constant String := \"Trying to get the priority of a \";\n \n    begin\n@@ -106,11 +105,11 @@ package body Ada.Dynamic_Priorities is\n \n    procedure Set_Priority\n      (Priority : System.Any_Priority;\n-      T : Ada.Task_Identification.Task_Id :=\n-          Ada.Task_Identification.Current_Task)\n+      T        : Ada.Task_Identification.Task_Id :=\n+                   Ada.Task_Identification.Current_Task)\n    is\n-      Target  : constant Task_ID := Convert_Ids (T);\n-      Self_ID : constant Task_ID := STPO.Self;\n+      Target  : constant Task_Id := Convert_Ids (T);\n+      Self_ID : constant Task_Id := STPO.Self;\n       Error_Message : constant String := \"Trying to set the priority of a \";\n \n    begin\n@@ -142,20 +141,23 @@ package body Ada.Dynamic_Priorities is\n             STPO.Unlock_RTS;\n          end if;\n \n-         STPO.Yield;\n          --  Yield is needed to enforce FIFO task dispatching.\n-         --  LL Set_Priority is made while holding the RTS lock so that\n-         --  it is inheriting high priority until it release all the RTS\n-         --  locks.\n+\n+         --  LL Set_Priority is made while holding the RTS lock so that it\n+         --  is inheriting high priority until it release all the RTS locks.\n+\n          --  If this is used in a system where Ceiling Locking is\n          --  not enforced we may end up getting two Yield effects.\n \n+         STPO.Yield;\n+\n       else\n          Target.New_Base_Priority := Priority;\n          Target.Pending_Priority_Change := True;\n          Target.Pending_Action := True;\n \n          STPO.Wakeup (Target, Target.Common.State);\n+\n          --  If the task is suspended, wake it up to perform the change.\n          --  check for ceiling violations ???\n "}, {"sha": "35801e2896ea88c81790711f4d7e05ddf1886faf", "filename": "gcc/ada/a-tasatt.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -41,7 +41,7 @@\n --  we settled on the present compromise. Things we do not like about\n --  this implementation include:\n \n---  -  It is vulnerable to bad Task_ID values, to the extent of\n+--  -  It is vulnerable to bad Task_Id values, to the extent of\n --     possibly trashing memory and crashing the runtime system.\n \n --  -  It requires dynamic storage allocation for each new attribute value,\n@@ -228,7 +228,7 @@\n \n with Ada.Task_Identification;\n --  used for Task_Id\n---           Null_Task_ID\n+--           Null_Task_Id\n --           Current_Task\n \n with System.Error_Reporting;\n@@ -244,7 +244,7 @@ with System.Task_Primitives.Operations;\n \n with System.Tasking;\n --  used for Access_Address\n---           Task_ID\n+--           Task_Id\n --           Direct_Index_Vector\n --           Direct_Index\n \n@@ -336,8 +336,8 @@ package body Ada.Task_Attributes is\n      (Access_Wrapper, Access_Dummy_Wrapper);\n    --  To store pointer to actual wrapper of attribute node\n \n-   function To_Task_ID is new Unchecked_Conversion\n-     (Task_Identification.Task_Id, Task_ID);\n+   function To_Task_Id is new Unchecked_Conversion\n+     (Task_Identification.Task_Id, Task_Id);\n    --  To access TCB of identified task\n \n    type Local_Deallocator is access procedure (P : in out Access_Node);\n@@ -394,7 +394,7 @@ package body Ada.Task_Attributes is\n      (T    : Task_Identification.Task_Id := Task_Identification.Current_Task)\n       return Attribute_Handle\n    is\n-      TT            : constant Task_ID := To_Task_ID (T);\n+      TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to get the reference of a \";\n \n    begin\n@@ -484,7 +484,7 @@ package body Ada.Task_Attributes is\n    procedure Reinitialize\n      (T : Task_Identification.Task_Id := Task_Identification.Current_Task)\n    is\n-      TT            : constant Task_ID := To_Task_ID (T);\n+      TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to Reinitialize a \";\n \n    begin\n@@ -554,7 +554,7 @@ package body Ada.Task_Attributes is\n      (Val : Attribute;\n       T   : Task_Identification.Task_Id := Task_Identification.Current_Task)\n    is\n-      TT            : constant Task_ID := To_Task_ID (T);\n+      TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to Set the Value of a \";\n \n    begin\n@@ -643,7 +643,7 @@ package body Ada.Task_Attributes is\n      (T : Task_Identification.Task_Id := Task_Identification.Current_Task)\n       return Attribute\n    is\n-      TT            : constant Task_ID := To_Task_ID (T);\n+      TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to get the Value of a \";\n \n    begin\n@@ -782,7 +782,7 @@ begin\n          --  Initialize the attribute, for all tasks.\n \n          declare\n-            C : System.Tasking.Task_ID := System.Tasking.All_Tasks_List;\n+            C : System.Tasking.Task_Id := System.Tasking.All_Tasks_List;\n          begin\n             while C /= null loop\n                C.Direct_Attributes (Local.Index) :="}, {"sha": "bec7cc25c855a470c0897e75cd29f1911fce4255", "filename": "gcc/ada/a-taside.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-taside.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-taside.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taside.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1992-2002 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1992-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,8 +55,8 @@ package body Ada.Task_Identification is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Convert_Ids (T : Task_Id) return System.Tasking.Task_ID;\n-   function Convert_Ids (T : System.Tasking.Task_ID) return Task_Id;\n+   function Convert_Ids (T : Task_Id) return System.Tasking.Task_Id;\n+   function Convert_Ids (T : System.Tasking.Task_Id) return Task_Id;\n    pragma Inline (Convert_Ids);\n    --  Conversion functions between different forms of Task_Id\n \n@@ -87,12 +87,12 @@ package body Ada.Task_Identification is\n    -- Convert_Ids --\n    -----------------\n \n-   function Convert_Ids (T : Task_Id) return System.Tasking.Task_ID is\n+   function Convert_Ids (T : Task_Id) return System.Tasking.Task_Id is\n    begin\n-      return System.Tasking.Task_ID (T);\n+      return System.Tasking.Task_Id (T);\n    end Convert_Ids;\n \n-   function Convert_Ids (T : System.Tasking.Task_ID) return Task_Id is\n+   function Convert_Ids (T : System.Tasking.Task_Id) return Task_Id is\n    begin\n       return Task_Id (T);\n    end Convert_Ids;"}, {"sha": "c76d4db0fa7948c93844a95ffecca4eb1829358a", "filename": "gcc/ada/a-taside.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-taside.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fa-taside.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-taside.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -64,8 +64,8 @@ package Ada.Task_Identification is\n \n private\n \n-   type Task_Id is new System.Tasking.Task_ID;\n+   type Task_Id is new System.Tasking.Task_Id;\n \n-   Null_Task_ID : constant Task_Id := Task_Id (System.Tasking.Null_Task);\n+   Null_Task_Id : constant Task_Id := Task_Id (System.Tasking.Null_Task);\n \n end Ada.Task_Identification;"}, {"sha": "33032f5985162f03173dc93f4e978f6cb227516b", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -86,6 +86,13 @@ DEFTREECODE (GNAT_LOOP_ID, \"gnat_loop_id\", 'x', 0)\n    the expression (such as a MODIFY_EXPR) and discarding its result.  */\n DEFTREECODE (EXPR_STMT, \"expr_stmt\", 's', 1)\n \n+/* This is a null statement.  The intent is for it not to survive very far.  */\n+DEFTREECODE (NULL_STMT, \"null_stmt\", 's', 0)\n+\n+/* This defines the variable in DECL_STMT_VAR and performs any initialization\n+   in DECL_INITIAL.  */\n+DEFTREECODE (DECL_STMT, \"decl_stmt\", 's', 1)\n+\n /* This represents a list of statements.  BLOCK_STMT_LIST is a list\n    statement tree, chained via TREE_CHAIN.  */\n DEFTREECODE (BLOCK_STMT, \"block_stmt\", 's', 1)"}, {"sha": "d2361a5d8589e0989e14bd67174c79830895ff0b", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -238,6 +238,9 @@ struct lang_type GTY(())\n    discriminant.  */\n #define DECL_STUBBED_P(NODE) DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n \n+/* Nonzero in a VAR_DECL if it needs to be initialized by an assignment.  */\n+#define DECL_INIT_BY_ASSIGN_P(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n+\n /* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF\n    is needed to access the object.  */\n #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n@@ -295,6 +298,7 @@ struct lang_type GTY(())\n #define TREE_SLOC(NODE)\t\tTREE_COMPLEXITY (STMT_CHECK (NODE))\n \n #define EXPR_STMT_EXPR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXPR_STMT, 0)\n+#define DECL_STMT_VAR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, DECL_STMT, 0)\n #define BLOCK_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, BLOCK_STMT, 0)\n #define IF_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 0)\n #define IF_STMT_TRUE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 1)"}, {"sha": "28d02cc79ec05555e2b0266a677c6b50abd4eeaa", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -282,6 +282,7 @@ package body ALI is\n          loop\n             if C = CR or else C = LF then\n                Skip_Line;\n+               C := Nextc;\n \n             elsif C = EOF then\n                return;\n@@ -788,6 +789,7 @@ package body ALI is\n                Fatal_Error;\n             else\n                Skip_Line;\n+               C := Nextc;\n             end if;\n          else\n             Fatal_Error;\n@@ -948,6 +950,7 @@ package body ALI is\n                Fatal_Error;\n             else\n                Skip_Line;\n+               C := Nextc;\n             end if;\n          else\n             Fatal_Error;"}, {"sha": "806fd1a56cabfaa297efdfdb10e3a2063a80422c", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -960,6 +960,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = create_var_decl (create_concat_name (gnat_entity, \"ALIGN\"),\n \t\t\t\t NULL_TREE, gnu_new_type, gnu_expr,\n \t\t\t\t 0, 0, 0, 0, 0);\n+\t    add_decl_stmt (gnu_new_var, gnat_entity);\n \n \t    if (gnu_expr != 0)\n \t      expand_expr_stmt\n@@ -1041,18 +1042,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (Present (Address_Clause (gnat_entity)) && used_by_ref)\n \t  DECL_POINTER_ALIAS_SET (gnu_decl) = 0;\n \n+\tadd_decl_stmt (gnu_decl, gnat_entity);\n+\n \tif (definition && DECL_SIZE (gnu_decl) != 0\n \t    && gnu_block_stack != 0\n \t    && TREE_VALUE (gnu_block_stack) != 0\n \t    && (TREE_CODE (DECL_SIZE (gnu_decl)) != INTEGER_CST\n \t\t|| (flag_stack_check && ! STACK_CHECK_BUILTIN\n \t\t    && 0 < compare_tree_int (DECL_SIZE_UNIT (gnu_decl),\n \t\t\t\t\t     STACK_CHECK_MAX_VAR_SIZE))))\n-\t  expand_expr_stmt\n-\t    (build_call_1_expr (update_setjmp_buf_decl,\n-\t\t\t\tbuild_unary_op\n-\t\t\t\t(ADDR_EXPR, NULL_TREE,\n-\t\t\t\t TREE_VALUE (gnu_block_stack))));\n+\t  {\n+\t    tree gnu_stmt\n+\t      = build_nt (EXPR_STMT,\n+\t\t\t  (build_call_1_expr\n+\t\t\t   (update_setjmp_buf_decl,\n+\t\t\t    build_unary_op\n+\t\t\t    (ADDR_EXPR, NULL_TREE,\n+\t\t\t     TREE_VALUE (gnu_block_stack)))));\n+\n+\t    TREE_SLOC (gnu_stmt) = Sloc (gnat_entity);\n+\t    TREE_TYPE (gnu_stmt) = void_type_node;\n+\t    add_stmt (gnu_stmt);\n+\t  }\n \n \t/* If this is a public constant or we're not optimizing and we're not\n \t   making a VAR_DECL for it, make one just for export or debugger\n@@ -1064,21 +1075,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| Address_Taken (gnat_entity)\n \t\t|| Is_Aliased (gnat_entity)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n-\t  SET_DECL_CONST_CORRESPONDING_VAR\n-\t    (gnu_decl,\n-\t     create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n-\t\t\t      gnu_expr, 0, Is_Public (gnat_entity), 0,\n-\t\t\t      static_p, 0));\n+\t  {\n+\t    tree gnu_corr_var\n+\t      = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n+\t\t\t\t gnu_expr, 0, Is_Public (gnat_entity), 0,\n+\t\t\t\t static_p, 0);\n+\n+\t    add_decl_stmt (gnu_corr_var, gnat_entity);\n+\t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n+\t  }\n \n \t/* If this is declared in a block that contains an block with an\n \t   exception handler, we must force this variable in memory to\n \t   suppress an invalid optimization.  */\n \tif (Has_Nested_Block_With_Handler (Scope (gnat_entity))\n \t    && Exception_Mechanism != GCC_ZCX)\n-\t  {\n-\t    gnat_mark_addressable (gnu_decl);\n-\t    flush_addressof (gnu_decl);\n-\t  }\n+\t  TREE_ADDRESSABLE (gnu_decl) = 1;\n \n \t/* Back-annotate the Alignment of the object if not already in the\n \t   tree.  Likewise for Esize if the object is of a constant size.\n@@ -1152,6 +1164,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = create_var_decl (get_entity_name (gnat_literal),\n \t\t\t\t 0, gnu_type, gnu_value, 1, 0, 0, 0, 0);\n \n+\t    add_decl_stmt (gnu_literal, gnat_literal);\n \t    save_gnu_tree (gnat_literal, gnu_literal, 0);\n \t    gnu_literal_list = tree_cons (DECL_NAME (gnu_literal),\n \t\t\t\t\t  gnu_value, gnu_literal_list);\n@@ -3604,6 +3617,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t gnu_address, 0, Is_Public (gnat_entity),\n \t\t\t\t extern_flag, 0, 0);\n \t    DECL_BY_REF_P (gnu_decl) = 1;\n+\t    add_decl_stmt (gnu_decl, gnat_entity);\n \t  }\n \n \telse if (kind == E_Subprogram_Type)\n@@ -3898,6 +3912,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t}\n       else\n \tTREE_TYPE (gnu_decl) = gnu_type;\n+\n+      add_decl_stmt (gnu_decl, gnat_entity);\n     }\n \n   if (IN (kind, Type_Kind) && ! TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n@@ -3959,10 +3975,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       && TREE_CODE (gnu_decl) != FUNCTION_DECL)\n     DECL_IGNORED_P (gnu_decl) = 1;\n \n-  /* If this decl is really indirect, adjust it.  */\n-  if (TREE_CODE (gnu_decl) == VAR_DECL)\n-    adjust_decl_rtl (gnu_decl);\n-\n   /* If we haven't already, associate the ..._DECL node that we just made with\n      the input GNAT entity node. */\n   if (! saved)\n@@ -4534,6 +4546,7 @@ elaborate_expression_1 (Node_Id gnat_expr,\n \t\t\t\t\t       IDENTIFIER_POINTER (gnu_name)),\n \t\t\t   NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, 1,\n \t\t\t   Is_Public (gnat_entity), ! definition, 0, 0);\n+      add_decl_stmt (gnu_decl, gnat_entity);\n     }\n \n   /* We only need to use this variable if we are in global context since GCC\n@@ -4679,14 +4692,9 @@ make_packable_type (tree type)\n    type.  */\n \n static tree\n-maybe_pad_type (tree type,\n-                tree size,\n-                unsigned int align,\n-                Entity_Id gnat_entity,\n-                const char *name_trailer,\n-                int is_user_type,\n-                int definition,\n-                int same_rm_size)\n+maybe_pad_type (tree type, tree size, unsigned int align,\n+                Entity_Id gnat_entity, const char *name_trailer,\n+                int is_user_type, int definition, int same_rm_size)\n {\n   tree orig_size = TYPE_SIZE (type);\n   tree record;\n@@ -4812,9 +4820,13 @@ maybe_pad_type (tree type,\n \t\t\t  0, 0);\n \n       if (size != 0 && TREE_CODE (size) != INTEGER_CST && definition)\n-\tcreate_var_decl (concat_id_with_name (name, \"XVZ\"), NULL_TREE,\n-\t\t\t sizetype, TYPE_SIZE (record), 0, 0, 0, 0,\n-\t\t\t 0);\n+\t{\n+\t  tree gnu_xvz\n+\t    = create_var_decl (concat_id_with_name (name, \"XVZ\"), NULL_TREE,\n+\t\t\t       sizetype, TYPE_SIZE (record), 0, 0, 0, 0, 0);\n+\n+\t  add_decl_stmt (gnu_xvz, gnat_entity);\n+\t}\n     }\n \n   type = record;"}, {"sha": "7b500d5276bd84717fe9e87e0839ae4d1ffd8a30", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -1012,7 +1012,7 @@ package body Exp_Attr is\n       --  Task_Entry_Caller or the Protected_Entry_Caller function.\n \n       when Attribute_Caller => Caller : declare\n-         Id_Kind    : constant Entity_Id := RTE (RO_AT_Task_ID);\n+         Id_Kind    : constant Entity_Id := RTE (RO_AT_Task_Id);\n          Ent        : constant Entity_Id := Entity (Pref);\n          Conctype   : constant Entity_Id := Scope (Ent);\n          Nest_Depth : Integer := 0;\n@@ -1662,7 +1662,7 @@ package body Exp_Attr is\n       --  For a task it returns a reference to the _task_id component of\n       --  corresponding record:\n \n-      --    taskV!(Prefix)._Task_Id, converted to the type Task_ID defined\n+      --    taskV!(Prefix)._Task_Id, converted to the type Task_Id defined\n \n       --  in Ada.Task_Identification.\n \n@@ -1680,7 +1680,7 @@ package body Exp_Attr is\n             Rewrite (N,\n               Unchecked_Convert_To (Id_Kind, Make_Reference (Loc, Pref)));\n          else\n-            Id_Kind := RTE (RO_AT_Task_ID);\n+            Id_Kind := RTE (RO_AT_Task_Id);\n \n             Rewrite (N,\n               Unchecked_Convert_To (Id_Kind, Concurrent_Ref (Pref)));"}, {"sha": "f661c13c0eed53b3a994320b4648cf4a0040356e", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -2794,7 +2794,7 @@ package body Exp_Ch9 is\n                   Decl := Make_Object_Declaration (Loc,\n                      Defining_Identifier => T_Self,\n                      Object_Definition =>\n-                       New_Occurrence_Of (RTE (RO_ST_Task_ID), Loc),\n+                       New_Occurrence_Of (RTE (RO_ST_Task_Id), Loc),\n                      Expression =>\n                        Make_Function_Call (Loc,\n                          Name => New_Reference_To (RTE (RE_Self), Loc)));\n@@ -7223,7 +7223,7 @@ package body Exp_Ch9 is\n           Component_Definition =>\n             Make_Component_Definition (Loc,\n               Aliased_Present    => False,\n-              Subtype_Indication => New_Reference_To (RTE (RO_ST_Task_ID),\n+              Subtype_Indication => New_Reference_To (RTE (RO_ST_Task_Id),\n                                     Loc))));\n \n       --  Add components for entry families"}, {"sha": "9566e21c3d775818b1679853783fccbe681191d7", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -1547,6 +1547,8 @@ package body GNAT.OS_Lib is\n          S1 : String := S;\n          --  We may need to fold S to lower case, so we need a variable\n \n+         Last : Natural;\n+\n       begin\n          --  Interix has the non standard notion of disk drive\n          --  indicated by two '/' followed by a capital letter\n@@ -1566,23 +1568,37 @@ package body GNAT.OS_Lib is\n             begin\n                Result (1) := '/';\n                Result (2 .. Result'Last) := S;\n+               Last := Result'Last;\n \n                if Fold_To_Lower_Case then\n                   System.Case_Util.To_Lower (Result);\n                end if;\n \n-               return Result;\n+               --  Remove trailing directory separator, if any\n+\n+               if Result (Last) = '/' or else\n+                  Result (Last) = Directory_Separator\n+               then\n+                  Last := Last - 1;\n+               end if;\n \n+               return Result (1 .. Last);\n             end;\n \n          else\n-\n             if Fold_To_Lower_Case then\n                System.Case_Util.To_Lower (S1);\n             end if;\n \n-            return S1;\n+            --  Remove trailing directory separator, if any\n+\n+            Last := S1'Last;\n+\n+            if S1 (Last) = '/' or else S1 (Last) = Directory_Separator then\n+               Last := Last - 1;\n+            end if;\n \n+            return S1 (1 .. Last);\n          end if;\n \n       end Final_Value;"}, {"sha": "1642e54f80b5dab5982de5a54bd8abb5f3c26145", "filename": "gcc/ada/g-thread.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fg-thread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fg-thread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-thread.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -53,7 +53,7 @@ package body GNAT.Threads is\n \n    function To_Addr is new Unchecked_Conversion (Task_Id, Address);\n    function To_Id   is new Unchecked_Conversion (Address, Task_Id);\n-   function To_Id   is new Unchecked_Conversion (Address, Tasking.Task_ID);\n+   function To_Id   is new Unchecked_Conversion (Address, Tasking.Task_Id);\n    function To_Tid  is new Unchecked_Conversion\n      (Address, Ada.Task_Identification.Task_Id);\n    function To_Thread is new Unchecked_Conversion (Address, Thread_Id_Ptr);\n@@ -112,7 +112,7 @@ package body GNAT.Threads is\n    -----------------------\n \n    procedure Unregister_Thread is\n-      Self_Id : constant Tasking.Task_ID := Task_Primitives.Operations.Self;\n+      Self_Id : constant Tasking.Task_Id := Task_Primitives.Operations.Self;\n    begin\n       Self_Id.Common.State := Tasking.Terminated;\n       Destroy_TSD (Self_Id.Common.Compiler_Data);\n@@ -125,9 +125,9 @@ package body GNAT.Threads is\n \n    procedure Unregister_Thread_Id (Thread : System.Address) is\n       Thr : constant Thread_Id := To_Thread (Thread).all;\n-      T   : Tasking.Task_ID;\n+      T   : Tasking.Task_Id;\n \n-      use type Tasking.Task_ID;\n+      use type Tasking.Task_Id;\n \n    begin\n       STPO.Lock_RTS;"}, {"sha": "ae1ba2ae3eef71e34201eee05eb06b65547fdfd4", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -36,11 +36,6 @@ extern unsigned int largest_move_alignment;\n \n /* Declare all functions and types used by gigi.  */\n \n-/* See if DECL has an RTL that is indirect via a pseudo-register or a\n-   memory location and replace it with an indirect reference if so.\n-   This improves the debugger's ability to display the value.  */\n-extern void adjust_decl_rtl (tree);\n-\n /* Record the current code position in GNAT_NODE.  */\n extern void record_code_position (Node_Id);\n \n@@ -94,6 +89,13 @@ extern tree gnat_to_gnu_entity (Entity_Id, tree, int);\n    refer to an Ada type.  */\n extern tree gnat_to_gnu_type (Entity_Id);\n \n+/* Add GNU_STMT to the current BLOCK_STMT node.  */\n+extern void add_stmt (tree);\n+\n+/* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n+   Get SLOC from Entity_Id.  */\n+extern void add_decl_stmt (tree, Entity_Id);\n+\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n extern void elaborate_entity (Entity_Id);\n@@ -381,37 +383,17 @@ extern int global_bindings_p (void);\n    is in reverse order (it has to be so for back-end compatibility).  */\n extern tree getdecls (void);\n \n-/* Nonzero if the current level needs to have a BLOCK made.  */\n-extern int kept_level_p (void);\n-\n-/* Enter a new binding level. The input parameter is ignored, but has to be\n-   specified for back-end compatibility.  */\n-extern void pushlevel (int);\n-\n-/* Exit a binding level.\n-   Pop the level off, and restore the state of the identifier-decl mappings\n-   that were in effect when this level was entered.\n-\n-   If KEEP is nonzero, this level had explicit declarations, so\n-   and create a \"block\" (a BLOCK node) for the level\n-   to record its declarations and subblocks for symbol table output.\n-\n-   If FUNCTIONBODY is nonzero, this level is the body of a function,\n-   so create a block as if KEEP were set and also clear out all\n-   label names.\n-\n-   If REVERSE is nonzero, reverse the order of decls before putting\n-   them into the BLOCK.  */\n-extern tree poplevel (int, int, int);\n+/* Enter and exit a new binding level. */\n+extern void gnat_pushlevel (void);\n+extern void gnat_poplevel (void);\n \n /* Insert BLOCK at the end of the list of subblocks of the\n    current binding level.  This is used when a BIND_EXPR is expanded,\n    to handle the BLOCK node inside the BIND_EXPR.  */\n extern void insert_block (tree);\n \n-/* Set the BLOCK node for the innermost scope\n-   (the one we are currently in).  */\n-extern void set_block (tree);\n+/* Return nonzero if the are any variables in the current block.  */\n+extern int block_has_vars (void);\n \n /* Records a ..._DECL node DECL as belonging to the current lexical scope.\n    Returns the ..._DECL node. */"}, {"sha": "f8fe4de4c191711a5fe62481eb34d3681d5947ad", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 6, "deletions": 60, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -121,6 +121,12 @@ static void gnat_adjust_rli\t\t(record_layout_info);\n #define LANG_HOOKS_HONOR_READONLY\ttrue\n #undef LANG_HOOKS_HASH_TYPES\n #define LANG_HOOKS_HASH_TYPES\t\tfalse\n+#undef LANG_HOOKS_PUSHLEVEL\n+#define LANG_HOOKS_PUSHLEVEL\t\tlhd_do_nothing_i\n+#undef LANG_HOOKS_POPLEVEL\n+#define LANG_HOOKS_POPLEVEL\t\tlhd_do_nothing_iii_return_null_tree\n+#undef LANG_HOOKS_SET_BLOCK\n+#define LANG_HOOKS_SET_BLOCK\t\tlhd_do_nothing_t\n #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n #undef LANG_HOOKS_GET_ALIAS_SET\n@@ -698,66 +704,6 @@ gnat_eh_type_covers (tree a, tree b)\n   return (a == b || a == integer_zero_node);\n }\n \f\n-/* See if DECL has an RTL that is indirect via a pseudo-register or a\n-   memory location and replace it with an indirect reference if so.\n-   This improves the debugger's ability to display the value.  */\n-\n-void\n-adjust_decl_rtl (tree decl)\n-{\n-  tree new_type;\n-\n-  /* If this decl is already indirect, don't do anything.  This should\n-     mean that the decl cannot be indirect, but there's no point in\n-     adding an abort to check that.  */\n-  if (TREE_CODE (decl) != CONST_DECL\n-      && ! DECL_BY_REF_P (decl)\n-      && (GET_CODE (DECL_RTL (decl)) == MEM\n-\t  && (GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n-\t      || (GET_CODE (XEXP (DECL_RTL (decl), 0)) == REG\n-\t\t  && (REGNO (XEXP (DECL_RTL (decl), 0))\n-\t\t      > LAST_VIRTUAL_REGISTER))))\n-      /* We can't do this if the reference type's mode is not the same\n-\t as the current mode, which means this may not work on mixed 32/64\n-\t bit systems.  */\n-      && (new_type = build_reference_type (TREE_TYPE (decl))) != 0\n-      && TYPE_MODE (new_type) == GET_MODE (XEXP (DECL_RTL (decl), 0))\n-      /* If this is a PARM_DECL, we can only do it if DECL_INCOMING_RTL\n-\t is also an indirect and of the same mode and if the object is\n-\t readonly, the latter condition because we don't want to upset the\n-\t handling of CICO_LIST.  */\n-      && (TREE_CODE (decl) != PARM_DECL\n-\t  || (GET_CODE (DECL_INCOMING_RTL (decl)) == MEM\n-\t      && (TYPE_MODE (new_type)\n-\t\t  == GET_MODE (XEXP (DECL_INCOMING_RTL (decl), 0)))\n-\t      && TREE_READONLY (decl))))\n-    {\n-      new_type\n-\t= build_qualified_type (new_type,\n-\t\t\t\t(TYPE_QUALS (new_type) | TYPE_QUAL_CONST));\n-\n-      DECL_POINTS_TO_READONLY_P (decl) = TREE_READONLY (decl);\n-      DECL_BY_REF_P (decl) = 1;\n-      SET_DECL_RTL (decl, XEXP (DECL_RTL (decl), 0));\n-      TREE_TYPE (decl) = new_type;\n-      DECL_MODE (decl) = TYPE_MODE (new_type);\n-      DECL_ALIGN (decl) = TYPE_ALIGN (new_type);\n-      DECL_SIZE (decl) = TYPE_SIZE (new_type);\n-\n-      if (TREE_CODE (decl) == PARM_DECL)\n-\tset_decl_incoming_rtl (decl, XEXP (DECL_INCOMING_RTL (decl), 0));\n-\n-      /* If DECL_INITIAL was set, it should be updated to show that\n-\t the decl is initialized to the address of that thing.\n-\t Otherwise, just set it to the address of this decl.\n-\t It needs to be set so that GCC does not think the decl is\n-\t unused.  */\n-      DECL_INITIAL (decl)\n-\t= build1 (ADDR_EXPR, new_type,\n-\t\t  DECL_INITIAL (decl) != 0 ? DECL_INITIAL (decl) : decl);\n-    }\n-}\n-\f\n /* Record the current code position in GNAT_NODE.  */\n \n void"}, {"sha": "9d034a12dc52a58858d7489c41a9cbd40f623c78", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -34,6 +34,7 @@ with Prj.Com;  use Prj.Com;\n with Prj.Err;  use Prj.Err;\n with Prj.Ext;  use Prj.Ext;\n with Prj.Nmsc; use Prj.Nmsc;\n+with Snames;\n \n with GNAT.Case_Util; use GNAT.Case_Util;\n with GNAT.HTable;\n@@ -1847,11 +1848,10 @@ package body Prj.Proc is\n \n       else\n          declare\n-            Processed_Data   : Project_Data := Empty_Project;\n-            Imported         : Project_List := Empty_Project_List;\n-            Declaration_Node : Project_Node_Id := Empty_Node;\n-            Name             : constant Name_Id :=\n-                                 Name_Of (From_Project_Node);\n+            Processed_Data   : Project_Data     := Empty_Project;\n+            Imported         : Project_List     := Empty_Project_List;\n+            Declaration_Node : Project_Node_Id  := Empty_Node;\n+            Name             : constant Name_Id := Name_Of (From_Project_Node);\n \n          begin\n             Project := Processed_Projects.Get (Name);\n@@ -1958,7 +1958,8 @@ package body Prj.Proc is\n \n             --  If it is an extending project, inherit all packages\n             --  from the extended project that are not explicitely defined\n-            --  or renamed.\n+            --  or renamed. Also inherit the languages, if attribute Languages\n+            --  is not explicitely defined.\n \n             if Processed_Data.Extends /= No_Project then\n                Processed_Data := Projects.Table (Project);\n@@ -1971,6 +1972,10 @@ package body Prj.Proc is\n                   Element     : Package_Element;\n                   First       : constant Package_Id :=\n                                   Processed_Data.Decl.Packages;\n+                  Attribute1  : Variable_Id;\n+                  Attribute2  : Variable_Id;\n+                  Attr_Value1 : Variable;\n+                  Attr_Value2  : Variable;\n \n                begin\n                   while Extended_Pkg /= No_Package loop\n@@ -1998,6 +2003,52 @@ package body Prj.Proc is\n \n                      Extended_Pkg := Element.Next;\n                   end loop;\n+\n+                  --  Check if attribute Languages is declared in the\n+                  --  extending project.\n+\n+                  Attribute1 := Processed_Data.Decl.Attributes;\n+                  while Attribute1 /= No_Variable loop\n+                     Attr_Value1 := Variable_Elements.Table (Attribute1);\n+                     exit when Attr_Value1.Name = Snames.Name_Languages;\n+                     Attribute1 := Attr_Value1.Next;\n+                  end loop;\n+\n+                  if Attribute1 = No_Variable or else\n+                     Attr_Value1.Value.Default\n+                  then\n+                     --  Attribute Languages is not declared in the extending\n+                     --  project. Check if it is declared in the project being\n+                     --  extended.\n+\n+                     Attribute2 :=\n+                       Projects.Table (Processed_Data.Extends).Decl.Attributes;\n+\n+                     while Attribute2 /= No_Variable loop\n+                        Attr_Value2 := Variable_Elements.Table (Attribute2);\n+                        exit when Attr_Value2.Name = Snames.Name_Languages;\n+                        Attribute2 := Attr_Value2.Next;\n+                     end loop;\n+\n+                     if Attribute2 /= No_Variable and then\n+                        not Attr_Value2.Value.Default\n+                     then\n+                        --  As attribute Languages is declared in the project\n+                        --  being extended, copy its value for the extending\n+                        --  project.\n+\n+                        if Attribute1 = No_Variable then\n+                           Variable_Elements.Increment_Last;\n+                           Attribute1 := Variable_Elements.Last;\n+                           Attr_Value1.Next := Processed_Data.Decl.Attributes;\n+                           Processed_Data.Decl.Attributes := Attribute1;\n+                        end if;\n+\n+                        Attr_Value1.Name := Snames.Name_Languages;\n+                        Attr_Value1.Value := Attr_Value2.Value;\n+                        Variable_Elements.Table (Attribute1) := Attr_Value1;\n+                     end if;\n+                  end if;\n                end;\n \n                Projects.Table (Project) := Processed_Data;"}, {"sha": "a8336c971dbbdf4e0f3869cd0292134678372196", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -32,6 +32,7 @@ with Fname.UF; use Fname.UF;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Sinput;   use Sinput;\n+with Snames;   use Snames;\n with Uname;    use Uname;\n \n package body Restrict is\n@@ -353,6 +354,36 @@ package body Restrict is\n       return Restrictions.Set (No_Exception_Handlers);\n    end No_Exception_Handlers_Set;\n \n+   ----------------------------------\n+   -- Process_Restriction_Synonyms --\n+   ----------------------------------\n+\n+   --  Note: body of this function must be coordinated with list of\n+   --  renaming declarations in System.Rident.\n+\n+   function Process_Restriction_Synonyms (Id : Name_Id) return Name_Id is\n+   begin\n+      case Id is\n+         when Name_Boolean_Entry_Barriers =>\n+            return Name_Simple_Barriers;\n+\n+         when Name_Max_Entry_Queue_Depth =>\n+            return Name_Max_Entry_Queue_Length;\n+\n+         when Name_No_Dynamic_Interrupts =>\n+            return Name_No_Dynamic_Attachment;\n+\n+         when Name_No_Requeue =>\n+            return Name_No_Requeue_Statements;\n+\n+         when Name_No_Task_Attributes =>\n+            return Name_No_Task_Attributes_Package;\n+\n+         when others =>\n+            return Id;\n+      end case;\n+   end Process_Restriction_Synonyms;\n+\n    ------------------------\n    -- Restricted_Profile --\n    ------------------------"}, {"sha": "0766bb824a7a21a88243780c14235bac0cd0350b", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -200,6 +200,12 @@ package Restrict is\n    --  handlers are present. This function is called by Gigi when it needs to\n    --  expand an AT END clean up identifier with no exception handler.\n \n+   function Process_Restriction_Synonyms (Id : Name_Id) return Name_Id;\n+   --  Id is the name of a restriction. If it is one of synonyms that we\n+   --  allow for historical purposes (for list see System.Rident), then\n+   --  the proper official name is returned. Otherwise the argument is\n+   --  returned unchanged.\n+\n    function Restriction_Active (R : All_Restrictions) return Boolean;\n    pragma Inline (Restriction_Active);\n    --  Determines if a given restriction is active. This call should only be"}, {"sha": "1f8bcab95da77ef53a2cce291fffe54b397ffbfb", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -489,7 +489,7 @@ package Rtsfind is\n \n      RE_Abort_Task,                      -- Ada.Task_Identification\n      RE_Current_Task,                    -- Ada.Task_Identification\n-     RO_AT_Task_ID,                      -- Ada.Task_Identification\n+     RO_AT_Task_Id,                      -- Ada.Task_Identification\n \n      RO_CA_Time,                         -- Ada.Calendar\n \n@@ -1256,7 +1256,7 @@ package Rtsfind is\n \n      RE_Task_Procedure_Access,           -- System.Tasking\n \n-     RO_ST_Task_ID,                      -- System.Tasking\n+     RO_ST_Task_Id,                      -- System.Tasking\n \n      RE_Call_Modes,                      -- System.Tasking\n      RE_Simple_Call,                     -- System.Tasking\n@@ -1561,7 +1561,7 @@ package Rtsfind is\n \n      RE_Abort_Task                       => Ada_Task_Identification,\n      RE_Current_Task                     => Ada_Task_Identification,\n-     RO_AT_Task_ID                       => Ada_Task_Identification,\n+     RO_AT_Task_Id                       => Ada_Task_Identification,\n \n      RO_CA_Time                          => Ada_Calendar,\n      RO_CA_Delay_For                     => Ada_Calendar_Delays,\n@@ -2326,7 +2326,7 @@ package Rtsfind is\n \n      RE_Task_Procedure_Access            => System_Tasking,\n \n-     RO_ST_Task_ID                       => System_Tasking,\n+     RO_ST_Task_Id                       => System_Tasking,\n \n      RE_Call_Modes                       => System_Tasking,\n      RE_Simple_Call                      => System_Tasking,"}, {"sha": "7d66ad822c153272ff82272531778820c38ba7e7", "filename": "gcc/ada/s-asthan-vms.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-asthan-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-asthan-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan-vms.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -79,11 +79,11 @@ package body System.AST_Handling is\n    --  from all other AST tasks.  It is only used by Lock_AST and\n    --  Unlock_AST.\n \n-   procedure Lock_AST (Self_ID : ST.Task_ID);\n+   procedure Lock_AST (Self_ID : ST.Task_Id);\n    --  Locks out other AST tasks. Preceding a section of code by Lock_AST and\n    --  following it by Unlock_AST creates a critical region.\n \n-   procedure Unlock_AST (Self_ID : ST.Task_ID);\n+   procedure Unlock_AST (Self_ID : ST.Task_Id);\n    --  Releases lock previously set by call to Lock_AST.\n    --  All nested locks must be released before other tasks competing for the\n    --  tasking lock are released.\n@@ -92,7 +92,7 @@ package body System.AST_Handling is\n    -- Lock_AST --\n    --------------\n \n-   procedure Lock_AST (Self_ID : ST.Task_ID) is\n+   procedure Lock_AST (Self_ID : ST.Task_Id) is\n    begin\n       STI.Defer_Abort_Nestable (Self_ID);\n       STPO.Write_Lock (AST_Lock'Access, Global_Lock => True);\n@@ -102,7 +102,7 @@ package body System.AST_Handling is\n    -- Unlock_AST --\n    ----------------\n \n-   procedure Unlock_AST (Self_ID : ST.Task_ID) is\n+   procedure Unlock_AST (Self_ID : ST.Task_Id) is\n    begin\n       STPO.Unlock (AST_Lock'Access, Global_Lock => True);\n       STI.Undefer_Abort_Nestable (Self_ID);\n@@ -287,7 +287,7 @@ package body System.AST_Handling is\n    Is_Waiting : array (1 .. Max_AST_Servers) of Boolean := (others => False);\n    --  An array of flags showing which AST server tasks are currently waiting\n \n-   AST_Task_Ids : array (1 .. Max_AST_Servers) of ST.Task_ID;\n+   AST_Task_Ids : array (1 .. Max_AST_Servers) of ST.Task_Id;\n    --  Task Id's of allocated AST server tasks\n \n    task type AST_Server_Task (Num : Natural) is\n@@ -344,7 +344,7 @@ package body System.AST_Handling is\n       Taskid  : ATID.Task_Id;\n       Entryno : Natural;\n       Param   : aliased Long_Integer;\n-      Self_Id : constant ST.Task_ID := ST.Self;\n+      Self_Id : constant ST.Task_Id := ST.Self;\n \n       pragma Volatile (Param);\n \n@@ -421,7 +421,7 @@ package body System.AST_Handling is\n                P : AA := Param'Unrestricted_Access;\n \n                function To_ST_Task_Id is new Ada.Unchecked_Conversion\n-                 (ATID.Task_Id, ST.Task_ID);\n+                 (ATID.Task_Id, ST.Task_Id);\n \n             begin\n                Unlock_AST (Self_Id);\n@@ -546,7 +546,7 @@ package body System.AST_Handling is\n       --  from which we can obtain the task and entry number information.\n \n       function To_Address is new Ada.Unchecked_Conversion\n-        (ST.Task_ID, System.Address);\n+        (ST.Task_Id, System.Address);\n \n    begin\n       System.Machine_Code.Asm"}, {"sha": "044eac7d037ce5b11e234e22008062d6b7e1d950", "filename": "gcc/ada/s-inmaop-vms.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-inmaop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-inmaop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop-vms.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -59,7 +59,7 @@ package body System.Interrupt_Management.Operations is\n    use System.Tasking;\n    use type unsigned_short;\n \n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n    package POP renames System.Task_Primitives.Operations;\n \n    ----------------------------\n@@ -122,7 +122,7 @@ package body System.Interrupt_Management.Operations is\n    function Interrupt_Wait (Mask : access Interrupt_Mask)\n      return Interrupt_ID\n    is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       Iosb    : IO_Status_Block_Type := (0, 0, 0);\n       Status  : Cond_Value_Type;\n "}, {"sha": "0702981ade328301d5e6d5b92e648e554572ce7d", "filename": "gcc/ada/s-interr-dummy.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-dummy.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--             Copyright (C) 1995-2004, Ada Core Technologies               --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,7 +71,7 @@ package body System.Interrupts is\n    -----------------------------\n \n    procedure Bind_Interrupt_To_Entry\n-     (T       : Task_ID;\n+     (T       : Task_Id;\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n@@ -117,7 +117,7 @@ package body System.Interrupts is\n    -- Detach_Interrupt_Entries --\n    ------------------------------\n \n-   procedure Detach_Interrupt_Entries (T : Task_ID) is\n+   procedure Detach_Interrupt_Entries (T : Task_Id) is\n    begin\n       Unimplemented;\n    end Detach_Interrupt_Entries;\n@@ -278,7 +278,7 @@ package body System.Interrupts is\n    ------------------\n \n    function Unblocked_By (Interrupt : Interrupt_ID)\n-     return System.Tasking.Task_ID is\n+     return System.Tasking.Task_Id is\n    begin\n       Unimplemented;\n       return null;"}, {"sha": "7dff527ae80f37c44afbee95f645d31a3983e780", "filename": "gcc/ada/s-interr-sigaction.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-sigaction.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-sigaction.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-sigaction.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -87,13 +87,13 @@ package body System.Interrupts is\n    subtype int is Interfaces.C.int;\n \n    function To_System is new Unchecked_Conversion\n-     (Ada.Task_Identification.Task_Id, Task_ID);\n+     (Ada.Task_Identification.Task_Id, Task_Id);\n \n    type Handler_Kind is (Unknown, Task_Entry, Protected_Procedure);\n \n    type Handler_Desc is record\n       Kind   : Handler_Kind := Unknown;\n-      T      : Task_ID;\n+      T      : Task_Id;\n       E      : Task_Entry_Index;\n       H      : Parameterless_Handler;\n       Static : Boolean := False;\n@@ -106,7 +106,7 @@ package body System.Interrupts is\n    type Server_Task_Access is access Server_Task;\n \n    Attached_Interrupts : array (Interrupt_ID) of Boolean;\n-   Handlers            : array (Interrupt_ID) of Task_ID;\n+   Handlers            : array (Interrupt_ID) of Task_Id;\n    Descriptors         : array (Interrupt_ID) of Handler_Desc;\n    Interrupt_Count     : array (Interrupt_ID) of Integer := (others => 0);\n \n@@ -150,7 +150,7 @@ package body System.Interrupts is\n    function TISR is new Unchecked_Conversion (Handler_Ptr, isr_address);\n \n    procedure Signal_Handler (Sig : Interrupt_ID) is\n-      Handler : Task_ID renames Handlers (Sig);\n+      Handler : Task_Id renames Handlers (Sig);\n    begin\n       if Intr_Attach_Reset and then\n         intr_attach (int (Sig), TISR (Signal_Handler'Access)) = FUNC_ERR\n@@ -215,7 +215,7 @@ package body System.Interrupts is\n    -- Unblocked_By --\n    ------------------\n \n-   function Unblocked_By (Interrupt : Interrupt_ID) return Task_ID is\n+   function Unblocked_By (Interrupt : Interrupt_ID) return Task_Id is\n    begin\n       raise Program_Error;\n       return Null_Task;\n@@ -532,7 +532,7 @@ package body System.Interrupts is\n    -----------------------------\n \n    procedure Bind_Interrupt_To_Entry\n-     (T       : Task_ID;\n+     (T       : Task_Id;\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n@@ -580,7 +580,7 @@ package body System.Interrupts is\n    -- Detach_Interrupt_Entries --\n    ------------------------------\n \n-   procedure Detach_Interrupt_Entries (T : Task_ID) is\n+   procedure Detach_Interrupt_Entries (T : Task_Id) is\n    begin\n       for I in Interrupt_ID loop\n          if not Is_Reserved (I) then\n@@ -631,7 +631,7 @@ package body System.Interrupts is\n \n    task body Server_Task is\n       Desc    : Handler_Desc renames Descriptors (Interrupt);\n-      Self_Id : constant Task_ID := STPO.Self;\n+      Self_Id : constant Task_Id := STPO.Self;\n       Temp    : Parameterless_Handler;\n \n    begin"}, {"sha": "9570c2c83672e9c9a629a3460bf27ae5d6de3ceb", "filename": "gcc/ada/s-interr-vms.adb", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-vms.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -49,7 +49,7 @@\n --  rendezvous.\n \n with Ada.Task_Identification;\n---  used for Task_ID type\n+--  used for Task_Id type\n \n with Ada.Exceptions;\n --  used for Raise_Exception\n@@ -100,7 +100,7 @@ with System.Storage_Elements;\n --           Integer_Address\n \n with System.Tasking;\n---  used for Task_ID\n+--  used for Task_Id\n --           Task_Entry_Index\n --           Null_Task\n --           Self\n@@ -134,7 +134,7 @@ package body System.Interrupts is\n    package IMOP renames System.Interrupt_Management.Operations;\n \n    function To_System is new Unchecked_Conversion\n-     (Ada.Task_Identification.Task_Id, Task_ID);\n+     (Ada.Task_Identification.Task_Id, Task_Id);\n \n    -----------------\n    -- Local Tasks --\n@@ -145,7 +145,7 @@ package body System.Interrupts is\n    --  nizing it.\n \n    task Interrupt_Manager is\n-      entry Detach_Interrupt_Entries (T : Task_ID);\n+      entry Detach_Interrupt_Entries (T : Task_Id);\n \n       entry Initialize (Mask : IMNG.Interrupt_Mask);\n \n@@ -166,7 +166,7 @@ package body System.Interrupts is\n          Static      : Boolean);\n \n       entry Bind_Interrupt_To_Entry\n-        (T         : Task_ID;\n+        (T         : Task_Id;\n          E         : Task_Entry_Index;\n          Interrupt : Interrupt_ID);\n \n@@ -197,7 +197,7 @@ package body System.Interrupts is\n    --------------------------------\n \n    type Entry_Assoc is record\n-      T : Task_ID;\n+      T : Task_Id;\n       E : Task_Entry_Index;\n    end record;\n \n@@ -228,18 +228,18 @@ package body System.Interrupts is\n    pragma Volatile_Components (Ignored);\n    --  True iff the corresponding interrupt is blocked in the process level\n \n-   Last_Unblocker : constant array (Interrupt_ID'Range) of Task_ID :=\n+   Last_Unblocker : constant array (Interrupt_ID'Range) of Task_Id :=\n      (others => Null_Task);\n --  ??? pragma Volatile_Components (Last_Unblocker);\n    --  Holds the ID of the last Task which Unblocked this Interrupt.\n    --  It contains Null_Task if no tasks have ever requested the\n    --  Unblocking operation or the Interrupt is currently Blocked.\n \n-   Server_ID : array (Interrupt_ID'Range) of Task_ID :=\n+   Server_ID : array (Interrupt_ID'Range) of Task_Id :=\n                  (others => Null_Task);\n    pragma Atomic_Components (Server_ID);\n-   --  Holds the Task_ID of the Server_Task for each interrupt.\n-   --  Task_ID is needed to accomplish locking per Interrupt base. Also\n+   --  Holds the Task_Id of the Server_Task for each interrupt.\n+   --  Task_Id is needed to accomplish locking per Interrupt base. Also\n    --  is needed to decide whether to create a new Server_Task.\n \n    --  Type and Head, Tail of the list containing Registered Interrupt\n@@ -523,7 +523,7 @@ package body System.Interrupts is\n    --  already bound.\n \n    procedure Bind_Interrupt_To_Entry\n-     (T       : Task_ID;\n+     (T       : Task_Id;\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n@@ -544,7 +544,7 @@ package body System.Interrupts is\n    -- Detach_Interrupt_Entries --\n    ------------------------------\n \n-   procedure Detach_Interrupt_Entries (T : Task_ID) is\n+   procedure Detach_Interrupt_Entries (T : Task_Id) is\n    begin\n       Interrupt_Manager.Detach_Interrupt_Entries (T);\n    end Detach_Interrupt_Entries;\n@@ -582,7 +582,7 @@ package body System.Interrupts is\n    ------------------\n \n    function Unblocked_By\n-     (Interrupt : Interrupt_ID) return System.Tasking.Task_ID is\n+     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id is\n    begin\n       if Is_Reserved (Interrupt) then\n          Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n@@ -708,7 +708,7 @@ package body System.Interrupts is\n          end if;\n \n          --  Invoke a corresponding Server_Task if not yet created.\n-         --  Place Task_ID info in Server_ID array.\n+         --  Place Task_Id info in Server_ID array.\n \n          if Server_ID (Interrupt) = Null_Task then\n             Access_Hold := new Server_Task (Interrupt);\n@@ -846,7 +846,7 @@ package body System.Interrupts is\n             end Detach_Handler;\n \n             or accept Bind_Interrupt_To_Entry\n-              (T       : Task_ID;\n+              (T       : Task_Id;\n                E       : Task_Entry_Index;\n                Interrupt : Interrupt_ID)\n             do\n@@ -875,7 +875,7 @@ package body System.Interrupts is\n                T.Interrupt_Entry := True;\n \n                --  Invoke a corresponding Server_Task if not yet created.\n-               --  Place Task_ID info in Server_ID array.\n+               --  Place Task_Id info in Server_ID array.\n \n                if Server_ID (Interrupt) = Null_Task then\n \n@@ -888,7 +888,7 @@ package body System.Interrupts is\n                end if;\n             end Bind_Interrupt_To_Entry;\n \n-            or accept Detach_Interrupt_Entries (T : Task_ID)\n+            or accept Detach_Interrupt_Entries (T : Task_Id)\n             do\n                for J in Interrupt_ID'Range loop\n                   if not Is_Reserved (J) then\n@@ -951,9 +951,9 @@ package body System.Interrupts is\n    -----------------\n \n    task body Server_Task is\n-      Self_ID         : constant Task_ID := Self;\n+      Self_ID         : constant Task_Id := Self;\n       Tmp_Handler     : Parameterless_Handler;\n-      Tmp_ID          : Task_ID;\n+      Tmp_ID          : Task_Id;\n       Tmp_Entry_Index : Task_Entry_Index;\n       Intwait_Mask    : aliased IMNG.Interrupt_Mask;\n "}, {"sha": "d0eee62dda37b229820aa266886aa110268b6b08", "filename": "gcc/ada/s-interr-vxworks.adb", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-vxworks.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -72,7 +72,7 @@ with System.OS_Interface; use System.OS_Interface;\n with Interfaces.VxWorks;\n \n with Ada.Task_Identification;\n---  used for Task_ID type\n+--  used for Task_Id type\n \n with Ada.Exceptions;\n --  used for Raise_Exception\n@@ -94,7 +94,7 @@ with System.Storage_Elements;\n --           Integer_Address\n \n with System.Tasking;\n---  used for Task_ID\n+--  used for Task_Id\n --           Task_Entry_Index\n --           Null_Task\n --           Self\n@@ -115,10 +115,10 @@ package body System.Interrupts is\n    package POP renames System.Task_Primitives.Operations;\n \n    function To_Ada is new Unchecked_Conversion\n-     (System.Tasking.Task_ID, Ada.Task_Identification.Task_Id);\n+     (System.Tasking.Task_Id, Ada.Task_Identification.Task_Id);\n \n    function To_System is new Unchecked_Conversion\n-     (Ada.Task_Identification.Task_Id, Task_ID);\n+     (Ada.Task_Identification.Task_Id, Task_Id);\n \n    -----------------\n    -- Local Tasks --\n@@ -129,7 +129,7 @@ package body System.Interrupts is\n    --  nizing it.\n \n    task Interrupt_Manager is\n-      entry Detach_Interrupt_Entries (T : Task_ID);\n+      entry Detach_Interrupt_Entries (T : Task_Id);\n \n       entry Attach_Handler\n         (New_Handler : Parameterless_Handler;\n@@ -148,7 +148,7 @@ package body System.Interrupts is\n          Static    : Boolean);\n \n       entry Bind_Interrupt_To_Entry\n-        (T         : Task_ID;\n+        (T         : Task_Id;\n          E         : Task_Entry_Index;\n          Interrupt : Interrupt_ID);\n \n@@ -168,7 +168,7 @@ package body System.Interrupts is\n    -------------------------------\n \n    type Entry_Assoc is record\n-      T : Task_ID;\n+      T : Task_Id;\n       E : Task_Entry_Index;\n    end record;\n \n@@ -204,11 +204,11 @@ package body System.Interrupts is\n    Registered_Handler_Head : R_Link := null;\n    Registered_Handler_Tail : R_Link := null;\n \n-   Server_ID : array (Interrupt_ID) of System.Tasking.Task_ID :=\n+   Server_ID : array (Interrupt_ID) of System.Tasking.Task_Id :=\n      (others => System.Tasking.Null_Task);\n    pragma Atomic_Components (Server_ID);\n-   --  Holds the Task_ID of the Server_Task for each interrupt / signal.\n-   --  Task_ID is needed to accomplish locking per interrupt base. Also\n+   --  Holds the Task_Id of the Server_Task for each interrupt / signal.\n+   --  Task_Id is needed to accomplish locking per interrupt base. Also\n    --  is needed to determine whether to create a new Server_Task.\n \n    Semaphore_ID_Map : array\n@@ -290,7 +290,7 @@ package body System.Interrupts is\n    --  already bound.\n \n    procedure Bind_Interrupt_To_Entry\n-     (T       : Task_ID;\n+     (T       : Task_Id;\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n@@ -365,7 +365,7 @@ package body System.Interrupts is\n    -- Detach_Interrupt_Entries --\n    ------------------------------\n \n-   procedure Detach_Interrupt_Entries (T : Task_ID) is\n+   procedure Detach_Interrupt_Entries (T : Task_Id) is\n    begin\n       Interrupt_Manager.Detach_Interrupt_Entries (T);\n    end Detach_Interrupt_Entries;\n@@ -727,7 +727,7 @@ package body System.Interrupts is\n    ------------------\n \n    function Unblocked_By\n-     (Interrupt : Interrupt_ID) return System.Tasking.Task_ID is\n+     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id is\n    begin\n       Unimplemented (\"Unblocked_By\");\n       return Null_Task;\n@@ -918,7 +918,7 @@ package body System.Interrupts is\n          end if;\n \n          --  Invoke a corresponding Server_Task if not yet created.\n-         --  Place Task_ID info in Server_ID array.\n+         --  Place Task_Id info in Server_ID array.\n \n          if New_Handler /= null\n            and then\n@@ -992,7 +992,7 @@ package body System.Interrupts is\n                end Detach_Handler;\n             or\n                accept Bind_Interrupt_To_Entry\n-                 (T       : Task_ID;\n+                 (T       : Task_Id;\n                   E       : Task_Entry_Index;\n                   Interrupt : Interrupt_ID)\n                do\n@@ -1017,7 +1017,7 @@ package body System.Interrupts is\n                   T.Interrupt_Entry := True;\n \n                   --  Invoke a corresponding Server_Task if not yet created.\n-                  --  Place Task_ID info in Server_ID array.\n+                  --  Place Task_Id info in Server_ID array.\n \n                   if Server_ID (Interrupt) = Null_Task\n                     or else\n@@ -1034,7 +1034,7 @@ package body System.Interrupts is\n                end Bind_Interrupt_To_Entry;\n \n             or\n-               accept Detach_Interrupt_Entries (T : Task_ID) do\n+               accept Detach_Interrupt_Entries (T : Task_Id) do\n                   for Int in Interrupt_ID'Range loop\n                      if not Is_Reserved (Int) then\n                         if User_Entry (Int).T = T then\n@@ -1079,9 +1079,9 @@ package body System.Interrupts is\n    --  Server task for vectored hardware interrupt handling\n \n    task body Interrupt_Server_Task is\n-      Self_Id         : constant Task_ID := Self;\n+      Self_Id         : constant Task_Id := Self;\n       Tmp_Handler     : Parameterless_Handler;\n-      Tmp_ID          : Task_ID;\n+      Tmp_ID          : Task_Id;\n       Tmp_Entry_Index : Task_Entry_Index;\n       S               : STATUS;\n "}, {"sha": "39860017d7bbc4c288d58e2846006b1f13cb523f", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,7 +55,7 @@\n --  one Server_Task per interrupt.\n \n with Ada.Task_Identification;\n---  used for Task_ID type\n+--  used for Task_Id type\n \n with Ada.Exceptions;\n --  used for Raise_Exception\n@@ -107,7 +107,7 @@ with System.Storage_Elements;\n --           Integer_Address\n \n with System.Tasking;\n---  used for Task_ID\n+--  used for Task_Id\n --           Task_Entry_Index\n --           Null_Task\n --           Self\n@@ -141,7 +141,7 @@ package body System.Interrupts is\n    package IMOP renames System.Interrupt_Management.Operations;\n \n    function To_System is new Unchecked_Conversion\n-     (Ada.Task_Identification.Task_Id, Task_ID);\n+     (Ada.Task_Identification.Task_Id, Task_Id);\n \n    -----------------\n    -- Local Tasks --\n@@ -152,7 +152,7 @@ package body System.Interrupts is\n    --  nizing it.\n \n    task Interrupt_Manager is\n-      entry Detach_Interrupt_Entries (T : Task_ID);\n+      entry Detach_Interrupt_Entries (T : Task_Id);\n \n       entry Initialize (Mask : IMNG.Interrupt_Mask);\n \n@@ -173,7 +173,7 @@ package body System.Interrupts is\n          Static      : in Boolean);\n \n       entry Bind_Interrupt_To_Entry\n-        (T         : Task_ID;\n+        (T         : Task_Id;\n          E         : Task_Entry_Index;\n          Interrupt : Interrupt_ID);\n \n@@ -204,7 +204,7 @@ package body System.Interrupts is\n    -------------------------------\n \n    type Entry_Assoc is record\n-      T : Task_ID;\n+      T : Task_Id;\n       E : Task_Entry_Index;\n    end record;\n \n@@ -235,17 +235,17 @@ package body System.Interrupts is\n    --  True iff the corresponding interrupt is blocked in the process level\n \n    Last_Unblocker :\n-     array (Interrupt_ID'Range) of Task_ID := (others => Null_Task);\n+     array (Interrupt_ID'Range) of Task_Id := (others => Null_Task);\n    pragma Volatile_Components (Last_Unblocker);\n    --  Holds the ID of the last Task which Unblocked this Interrupt.\n    --  It contains Null_Task if no tasks have ever requested the\n    --  Unblocking operation or the Interrupt is currently Blocked.\n \n-   Server_ID : array (Interrupt_ID'Range) of Task_ID :=\n+   Server_ID : array (Interrupt_ID'Range) of Task_Id :=\n                  (others => Null_Task);\n    pragma Atomic_Components (Server_ID);\n-   --  Holds the Task_ID of the Server_Task for each interrupt.\n-   --  Task_ID is needed to accomplish locking per Interrupt base. Also\n+   --  Holds the Task_Id of the Server_Task for each interrupt.\n+   --  Task_Id is needed to accomplish locking per Interrupt base. Also\n    --  is needed to decide whether to create a new Server_Task.\n \n    --  Type and Head, Tail of the list containing Registered Interrupt\n@@ -310,7 +310,7 @@ package body System.Interrupts is\n    --  already bound.\n \n    procedure Bind_Interrupt_To_Entry\n-     (T       : Task_ID;\n+     (T       : Task_Id;\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n@@ -390,7 +390,7 @@ package body System.Interrupts is\n    -- Detach_Interrupt_Entries --\n    ------------------------------\n \n-   procedure Detach_Interrupt_Entries (T : Task_ID) is\n+   procedure Detach_Interrupt_Entries (T : Task_Id) is\n    begin\n       Interrupt_Manager.Detach_Interrupt_Entries (T);\n    end Detach_Interrupt_Entries;\n@@ -681,7 +681,7 @@ package body System.Interrupts is\n    ------------------\n \n    function Unblocked_By\n-     (Interrupt : Interrupt_ID) return System.Tasking.Task_ID\n+     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id\n    is\n    begin\n       if Is_Reserved (Interrupt) then\n@@ -925,7 +925,7 @@ package body System.Interrupts is\n          end if;\n \n          --  Invoke a corresponding Server_Task if not yet created.\n-         --  Place Task_ID info in Server_ID array.\n+         --  Place Task_Id info in Server_ID array.\n \n          if Server_ID (Interrupt) = Null_Task then\n \n@@ -1050,7 +1050,7 @@ package body System.Interrupts is\n \n             or\n                accept Bind_Interrupt_To_Entry\n-                 (T       : Task_ID;\n+                 (T       : Task_Id;\n                   E       : Task_Entry_Index;\n                   Interrupt : Interrupt_ID)\n                do\n@@ -1078,7 +1078,7 @@ package body System.Interrupts is\n                   T.Interrupt_Entry := True;\n \n                   --  Invoke a corresponding Server_Task if not yet created.\n-                  --  Place Task_ID info in Server_ID array.\n+                  --  Place Task_Id info in Server_ID array.\n \n                   if Server_ID (Interrupt) = Null_Task then\n                      --  When a new Server_Task is created, it should have its\n@@ -1096,7 +1096,7 @@ package body System.Interrupts is\n                end Bind_Interrupt_To_Entry;\n \n             or\n-               accept Detach_Interrupt_Entries (T : Task_ID) do\n+               accept Detach_Interrupt_Entries (T : Task_Id) do\n                   for J in Interrupt_ID'Range loop\n                      if not Is_Reserved (J) then\n                         if User_Entry (J).T = T then\n@@ -1249,9 +1249,9 @@ package body System.Interrupts is\n    task body Server_Task is\n       Intwait_Mask    : aliased IMNG.Interrupt_Mask;\n       Ret_Interrupt   : Interrupt_ID;\n-      Self_ID         : constant Task_ID := Self;\n+      Self_ID         : constant Task_Id := Self;\n       Tmp_Handler     : Parameterless_Handler;\n-      Tmp_ID          : Task_ID;\n+      Tmp_ID          : Task_Id;\n       Tmp_Entry_Index : Task_Entry_Index;\n \n    begin"}, {"sha": "8e7362fd0419f9918df511fae1addd3922d3e942", "filename": "gcc/ada/s-interr.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,7 +46,7 @@\n --  tasking implementation to be linked and elaborated.\n \n with System.Tasking;\n---  used for Task_ID\n+--  used for Task_Id\n \n with System.Tasking.Protected_Objects.Entries;\n --  used for Protection_Entries\n@@ -131,11 +131,11 @@ package System.Interrupts is\n    --  already attached will raise a Program_Error.\n \n    procedure Bind_Interrupt_To_Entry\n-     (T       : System.Tasking.Task_ID;\n+     (T       : System.Tasking.Task_Id;\n       E       : System.Tasking.Task_Entry_Index;\n       Int_Ref : System.Address);\n \n-   procedure Detach_Interrupt_Entries (T : System.Tasking.Task_ID);\n+   procedure Detach_Interrupt_Entries (T : System.Tasking.Task_Id);\n    --  This procedure detaches all the Interrupt Entries bound to a task.\n \n    -------------------------------\n@@ -151,7 +151,7 @@ package System.Interrupts is\n \n    function Unblocked_By\n      (Interrupt   : Interrupt_ID)\n-      return System.Tasking.Task_ID;\n+      return System.Tasking.Task_Id;\n    --  It returns the ID of the last Task which Unblocked this Interrupt.\n    --  It returns Null_Task if no tasks have ever requested the\n    --  Unblocking operation or the Interrupt is currently Blocked."}, {"sha": "fc0e3e93776a29941ce9ae37f586a97a1db1d2a0", "filename": "gcc/ada/s-restri.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-restri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-restri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-restri.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -61,7 +61,8 @@ package System.Restrictions is\n    function Tasking_Allowed return Boolean;\n    pragma Inline (Tasking_Allowed);\n    --  Tests to see if tasking operations are allowed by the current\n-   --  restrictions settings. For tasking to be allowed Max_Tasks must\n+   --  restrictions settings. For taskikng to be allowed, No_Tasking\n+   --  must be False, and Max_Tasks must not be set to zero.\n \n end System.Restrictions;\n "}, {"sha": "996b057c192a70b4d2dbf47dda6d3bd463c1bf35", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -152,13 +152,14 @@ package System.Rident is\n \n       Not_A_Restriction_Id);\n \n-   --  Synonyms permitted for historical purposes of compatibility\n-\n-   --   Boolean_Entry_Barriers synonym for Simple_Barriers\n-   --   Max_Entry_Queue_Depth  synonym for Max_Entry_Queue_Length\n-   --   No_Dynamic_Interrupts  synonym for No_Dynamic_Attachment\n-   --   No_Requeue             synonym for No_Requeue_Statements\n-   --   No_Task_Attributes     synonym for No_Task_Attributes_Package\n+   --  Synonyms permitted for historical purposes of compatibility.\n+   --  Must be coordinated with Restrict.Process_Restriction_Synonym.\n+\n+   Boolean_Entry_Barriers : Restriction_Id renames Simple_Barriers;\n+   Max_Entry_Queue_Depth  : Restriction_Id renames Max_Entry_Queue_Length;\n+   No_Dynamic_Interrupts  : Restriction_Id renames No_Dynamic_Attachment;\n+   No_Requeue             : Restriction_Id renames No_Requeue_Statements;\n+   No_Task_Attributes     : Restriction_Id renames No_Task_Attributes_Package;\n \n    subtype All_Restrictions is Restriction_Id range\n      Simple_Barriers .. Max_Storage_At_Blocking;"}, {"sha": "2b74bec1932d89ab5f5c1bb81ea539f86cb4c7ce", "filename": "gcc/ada/s-soflin.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-soflin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-soflin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -221,8 +221,8 @@ package System.Soft_Links is\n \n    function  Get_Exc_Stack_Addr_NT return Address;\n    procedure Set_Exc_Stack_Addr_NT (Self_ID : Address; Addr : Address);\n-   --  Self_ID is a Task_ID, but in the non-tasking case there is no\n-   --  Task_ID type available, so make do with Address.\n+   --  Self_ID is a Task_Id, but in the non-tasking case there is no\n+   --  Task_Id type available, so make do with Address.\n \n    Get_Exc_Stack_Addr : Get_Address_Call := Get_Exc_Stack_Addr_NT'Access;\n    Set_Exc_Stack_Addr : Set_Address_Call2 := Set_Exc_Stack_Addr_NT'Access;"}, {"sha": "4bbc43509da319a9fb062e344f830e005211ec6d", "filename": "gcc/ada/s-taasde.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taasde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taasde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taasde.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2002, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,7 +62,7 @@ with System.OS_Primitives;\n --  used for Max_Sensible_Delay\n \n with Ada.Task_Identification;\n---  used for Task_ID type\n+--  used for Task_Id type\n \n with System.Parameters;\n --  used for Single_Lock\n@@ -86,9 +86,9 @@ package body System.Tasking.Async_Delays is\n    use System.Traces.Tasking;\n \n    function To_System is new Unchecked_Conversion\n-     (Ada.Task_Identification.Task_Id, Task_ID);\n+     (Ada.Task_Identification.Task_Id, Task_Id);\n \n-   Timer_Server_ID : ST.Task_ID;\n+   Timer_Server_ID : ST.Task_Id;\n \n    Timer_Attention : Boolean := False;\n    pragma Atomic (Timer_Attention);\n@@ -214,10 +214,10 @@ package body System.Tasking.Async_Delays is\n      (T : Duration;\n       D : Delay_Block_Access)\n    is\n-      Self_Id : constant Task_ID  := STPO.Self;\n+      Self_Id : constant Task_Id  := STPO.Self;\n       Q       : Delay_Block_Access;\n \n-      use type ST.Task_ID;\n+      use type ST.Task_Id;\n       --  for visibility of operator \"=\"\n \n    begin\n@@ -319,7 +319,7 @@ package body System.Tasking.Async_Delays is\n       Yielded          : Boolean;\n       Now              : Duration;\n       Dequeued         : Delay_Block_Access;\n-      Dequeued_Task    : Task_ID;\n+      Dequeued_Task    : Task_Id;\n \n    begin\n       Timer_Server_ID := STPO.Self;"}, {"sha": "21e24f616ae30e1ade00521bff14680531ee83e1", "filename": "gcc/ada/s-taasde.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taasde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taasde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taasde.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1998-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -117,7 +117,7 @@ package System.Tasking.Async_Delays is\n private\n \n    type Delay_Block is record\n-      Self_Id     : Task_ID;\n+      Self_Id     : Task_Id;\n       --  ID of the calling task\n \n       Level       : ATC_Level_Base;"}, {"sha": "97705c1f834f9682902e3d7b05f0700fa47e3c14", "filename": "gcc/ada/s-taenca.adb", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taenca.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taenca.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taenca.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -113,15 +113,15 @@ package body System.Tasking.Entry_Calls is\n    --  If Single_Lock and server is a PO, take RTS_Lock on exit.\n \n    procedure Unlock_And_Update_Server\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    --  Similar to Unlock_Server, but services entry calls if the\n    --  server is a protected object.\n    --\n    --  If Single_Lock and server is a PO, take RTS_Lock on exit.\n \n    procedure Check_Pending_Actions_For_Entry_Call\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    --  This procedure performs priority change of a queued call and\n    --  dequeuing of an entry call when the call is cancelled.\n@@ -133,7 +133,7 @@ package body System.Tasking.Entry_Calls is\n    --  and to dequeue the call if the call has been aborted.\n \n    procedure Poll_Base_Priority_Change_At_Entry_Call\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    pragma Inline (Poll_Base_Priority_Change_At_Entry_Call);\n    --  A specialized version of Poll_Base_Priority_Change,\n@@ -146,7 +146,7 @@ package body System.Tasking.Entry_Calls is\n    ---------------------\n \n    procedure Check_Exception\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link)\n    is\n       pragma Warnings (Off, Self_ID);\n@@ -174,7 +174,7 @@ package body System.Tasking.Entry_Calls is\n    ------------------------------------------\n \n    procedure Check_Pending_Actions_For_Entry_Call\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link) is\n    begin\n       pragma Assert (Self_ID = Entry_Call.Self);\n@@ -213,7 +213,7 @@ package body System.Tasking.Entry_Calls is\n    -----------------\n \n    procedure Lock_Server (Entry_Call : Entry_Call_Link) is\n-      Test_Task         : Task_ID;\n+      Test_Task         : Task_Id;\n       Test_PO           : Protection_Entries_Access;\n       Ceiling_Violation : Boolean;\n       Failures          : Integer := 0;\n@@ -262,7 +262,7 @@ package body System.Tasking.Entry_Calls is\n \n                if Ceiling_Violation then\n                   declare\n-                     Current_Task      : constant Task_ID := STPO.Self;\n+                     Current_Task      : constant Task_Id := STPO.Self;\n                      Old_Base_Priority : System.Any_Priority;\n \n                   begin\n@@ -315,7 +315,7 @@ package body System.Tasking.Entry_Calls is\n    ---------------------------------------------\n \n    procedure Poll_Base_Priority_Change_At_Entry_Call\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link) is\n    begin\n       if Dynamic_Priority_Support and then Self_ID.Pending_Priority_Change then\n@@ -377,7 +377,7 @@ package body System.Tasking.Entry_Calls is\n    --------------------\n \n    procedure Reset_Priority\n-     (Acceptor               : Task_ID;\n+     (Acceptor               : Task_Id;\n       Acceptor_Prev_Priority : Rendezvous_Priority) is\n    begin\n       pragma Assert (Acceptor = STPO.Self);\n@@ -397,7 +397,7 @@ package body System.Tasking.Entry_Calls is\n \n    procedure Try_To_Cancel_Entry_Call (Succeeded : out Boolean) is\n       Entry_Call : Entry_Call_Link;\n-      Self_ID    : constant Task_ID := STPO.Self;\n+      Self_ID    : constant Task_Id := STPO.Self;\n \n       use type Ada.Exceptions.Exception_Id;\n \n@@ -459,11 +459,11 @@ package body System.Tasking.Entry_Calls is\n    ------------------------------\n \n    procedure Unlock_And_Update_Server\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link)\n    is\n       Called_PO : Protection_Entries_Access;\n-      Caller    : Task_ID;\n+      Caller    : Task_Id;\n \n    begin\n       if Entry_Call.Called_Task /= null then\n@@ -503,7 +503,7 @@ package body System.Tasking.Entry_Calls is\n    -------------------\n \n    procedure Unlock_Server (Entry_Call : Entry_Call_Link) is\n-      Caller    : Task_ID;\n+      Caller    : Task_Id;\n       Called_PO : Protection_Entries_Access;\n \n    begin\n@@ -543,7 +543,7 @@ package body System.Tasking.Entry_Calls is\n    -------------------------\n \n    procedure Wait_For_Completion (Entry_Call : Entry_Call_Link) is\n-      Self_Id : constant Task_ID := Entry_Call.Self;\n+      Self_Id : constant Task_Id := Entry_Call.Self;\n    begin\n       --  If this is a conditional call, it should be cancelled when it\n       --  becomes abortable. This is checked in the loop below.\n@@ -600,7 +600,7 @@ package body System.Tasking.Entry_Calls is\n       Mode        : Delay_Modes;\n       Yielded     : out Boolean)\n    is\n-      Self_Id  : constant Task_ID := Entry_Call.Self;\n+      Self_Id  : constant Task_Id := Entry_Call.Self;\n       Timedout : Boolean := False;\n \n       use type Ada.Exceptions.Exception_Id;\n@@ -699,7 +699,7 @@ package body System.Tasking.Entry_Calls is\n    --------------------------\n \n    procedure Wait_Until_Abortable\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Call    : Entry_Call_Link) is\n    begin\n       pragma Assert (Self_ID.ATC_Nesting_Level > 0);"}, {"sha": "1f81cd9e74677f1c5c43a03f65c70fdb8b1ea2b0", "filename": "gcc/ada/s-taenca.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taenca.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taenca.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taenca.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,7 +59,7 @@ package System.Tasking.Entry_Calls is\n    --  Check_Exception must be called after calling this procedure.\n \n    procedure Wait_Until_Abortable\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Call    : Entry_Call_Link);\n    --  This procedure suspends the calling task until the specified entry\n    --  call is queued abortably or completes.\n@@ -75,15 +75,15 @@ package System.Tasking.Entry_Calls is\n    --  On return, the call is off-queue and the ATC level is reduced by one.\n \n    procedure Reset_Priority\n-     (Acceptor               : Task_ID;\n+     (Acceptor               : Task_Id;\n       Acceptor_Prev_Priority : Rendezvous_Priority);\n    pragma Inline (Reset_Priority);\n    --  Reset the priority of a task completing an accept statement to\n    --  the value it had before the call.\n    --  Acceptor should always be equal to Self.\n \n    procedure Check_Exception\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    pragma Inline (Check_Exception);\n    --  Raise any pending exception from the Entry_Call."}, {"sha": "608d412686e49545c6444fd768dec684e186bd98", "filename": "gcc/ada/s-taprop-dummy.adb", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-dummy.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,7 +42,7 @@ pragma Polling (Off);\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Error_Reporting;\n --  used for Shutdown\n@@ -59,7 +59,7 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard --\n    -----------------\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n    begin\n       null;\n    end Stack_Guard;\n@@ -68,7 +68,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return OSI.Thread_Id (T.Common.LL.Thread);\n    end Get_Thread_Id;\n@@ -77,7 +77,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID is\n+   function Self return Task_Id is\n    begin\n       return Null_Task;\n    end Self;\n@@ -130,7 +130,7 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n    begin\n       null;\n    end Write_Lock;\n@@ -158,7 +158,7 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n    begin\n       null;\n    end Unlock;\n@@ -167,7 +167,7 @@ package body System.Task_Primitives.Operations is\n    -- Sleep --\n    -----------\n \n-   procedure Sleep (Self_ID : Task_ID; Reason  : System.Tasking.Task_States) is\n+   procedure Sleep (Self_ID : Task_Id; Reason  : System.Tasking.Task_States) is\n    begin\n       null;\n    end Sleep;\n@@ -177,7 +177,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -193,7 +193,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Time    : Duration;\n       Mode    : ST.Delay_Modes) is\n    begin\n@@ -222,7 +222,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n    begin\n       null;\n    end Wakeup;\n@@ -232,7 +232,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False) is\n    begin\n@@ -243,7 +243,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return 0;\n    end Get_Priority;\n@@ -252,7 +252,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       null;\n    end Enter_Task;\n@@ -261,7 +261,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -279,7 +279,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       return null;\n    end Register_Foreign_Thread;\n@@ -288,7 +288,7 @@ package body System.Task_Primitives.Operations is\n    --  Initialize_TCB  --\n    ----------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n    begin\n       Succeeded := False;\n    end Initialize_TCB;\n@@ -298,7 +298,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -311,7 +311,7 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n    begin\n       null;\n    end Finalize_TCB;\n@@ -329,7 +329,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n    begin\n       null;\n    end Abort_Task;\n@@ -350,7 +350,7 @@ package body System.Task_Primitives.Operations is\n    --  Dummy versions.  The only currently working versions is for solaris\n    --  (native).\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n    begin\n       return True;\n    end Check_Exit;\n@@ -359,7 +359,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n    begin\n       return True;\n    end Check_No_Locks;\n@@ -368,7 +368,7 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n       return null;\n    end Environment_Task;\n@@ -396,7 +396,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : OSI.Thread_Id)\n       return        Boolean\n    is\n@@ -409,7 +409,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : OSI.Thread_Id)\n       return        Boolean\n    is\n@@ -421,7 +421,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n    begin\n       null;\n    end Initialize;"}, {"sha": "97b3009e67491306a0fb73f7bcf27880dc7d64be", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -65,7 +65,7 @@ with System.Task_Primitives.Interrupt_Operations;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Soft_Links;\n --  used for Defer/Undefer_Abort\n@@ -106,10 +106,10 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Unblocked_Signal_Mask : aliased sigset_t;\n    --  The set of signals that should unblocked in all tasks\n@@ -136,19 +136,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does the executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -161,19 +161,19 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    procedure Abort_Handler (Sig : Signal);\n \n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n \n    -------------------\n    -- Abort_Handler --\n@@ -182,7 +182,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (Sig : Signal) is\n       pragma Unreferenced (Sig);\n \n-      Self_Id : constant Task_ID := Self;\n+      Self_Id : constant Task_Id := Self;\n       Result  : Interfaces.C.int;\n       Old_Set : aliased sigset_t;\n \n@@ -211,7 +211,7 @@ package body System.Task_Primitives.Operations is\n    --  bottom of a thread stack, so nothing is needed.\n    --  ??? Check the comment above\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T, On);\n    begin\n       null;\n@@ -221,7 +221,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id --\n    -------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -230,7 +230,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n@@ -347,7 +347,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -387,7 +387,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -402,7 +402,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason  : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -426,7 +426,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -488,7 +488,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -584,7 +584,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n \n       Result : Interfaces.C.int;\n@@ -622,7 +622,7 @@ package body System.Task_Primitives.Operations is\n    --  scheduling.\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -684,7 +684,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -693,7 +693,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n       Specific.Set (Self_ID);\n@@ -715,7 +715,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -730,7 +730,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -743,7 +743,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Result     : Interfaces.C.int;\n       Cond_Attr  : aliased pthread_condattr_t;\n@@ -797,7 +797,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -861,13 +861,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result  : Interfaces.C.int;\n-      Tmp     : Task_ID := T;\n+      Tmp     : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -902,7 +902,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n    begin\n       --\n       --  Interrupt Server_Tasks may be waiting on an \"event\" flag (signal)\n@@ -921,7 +921,7 @@ package body System.Task_Primitives.Operations is\n    --  Dummy versions.  The only currently working versions is for solaris\n    --  (native).\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n    begin\n       return True;\n@@ -931,7 +931,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n    begin\n       return True;\n@@ -941,9 +941,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -969,7 +969,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -985,7 +985,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1000,7 +1000,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       act       : aliased struct_sigaction;\n       old_act   : aliased struct_sigaction;\n       Tmp_Set   : aliased sigset_t;\n@@ -1021,7 +1021,7 @@ package body System.Task_Primitives.Operations is\n       --           system handler)\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n "}, {"sha": "8c0f95503d80109b28c00439f00ce7201f62c3da", "filename": "gcc/ada/s-taprop-irix-athread.adb", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-irix-athread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-irix-athread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix-athread.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -59,7 +59,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Program_Info;\n --  used for Default_Task_Stack\n@@ -108,8 +108,8 @@ package body System.Task_Primitives.Operations is\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Locking_Policy : Character;\n    pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n@@ -126,9 +126,9 @@ package body System.Task_Primitives.Operations is\n \n    procedure Initialize_Athread_Library;\n \n-   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n+   function To_Task_Id is new Unchecked_Conversion (System.Address, Task_Id);\n \n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n \n    -------------------\n    --  Stack_Guard  --\n@@ -138,7 +138,7 @@ package body System.Task_Primitives.Operations is\n    --  bottom of a thread stack, so nothing is needed.\n    --  ??? Check the comment above\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n       pragma Unreferenced (On);\n    begin\n@@ -149,7 +149,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -158,9 +158,9 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID is\n+   function Self return Task_Id is\n    begin\n-      return To_Task_ID (pthread_get_current_ada_tcb);\n+      return To_Task_Id (pthread_get_current_ada_tcb);\n    end Self;\n \n    ---------------------\n@@ -285,7 +285,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -323,7 +323,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -337,7 +337,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID  : ST.Task_ID;\n+     (Self_ID  : ST.Task_Id;\n       Reason   : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -363,7 +363,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -424,7 +424,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -529,7 +529,7 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Wakeup\n-     (T : ST.Task_ID;\n+     (T : ST.Task_Id;\n       Reason : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -555,7 +555,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -574,7 +574,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -583,7 +583,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -612,7 +612,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -630,7 +630,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       return null;\n    end Register_Foreign_Thread;\n@@ -639,7 +639,7 @@ package body System.Task_Primitives.Operations is\n    --  Initialize_TCB  --\n    ----------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Result    : Interfaces.C.int;\n       Cond_Attr : aliased pthread_condattr_t;\n \n@@ -677,7 +677,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -773,12 +773,12 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n       Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Tmp    : Task_Id := T;\n \n    begin\n       if not Single_Lock then\n@@ -811,7 +811,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       Result :=\n@@ -827,7 +827,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -838,7 +838,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n    begin\n       return True;\n@@ -848,9 +848,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -876,7 +876,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n@@ -892,7 +892,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n@@ -907,9 +907,9 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n       --  Initialize the lock used to synchronize chain of all ATCBs."}, {"sha": "542bf4b5782743943878e0297ec940a8024b820e", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -67,7 +67,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Soft_Links;\n --  used for Defer/Undefer_Abort\n@@ -117,10 +117,10 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Locking_Policy : Character;\n    pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n@@ -138,19 +138,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -163,17 +163,17 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n \n    procedure Abort_Handler (Sig : Signal);\n    --  Signal handler used to implement asynchronous abort.\n@@ -185,7 +185,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (Sig : Signal) is\n       pragma Unreferenced (Sig);\n \n-      T       : constant Task_ID := Self;\n+      T       : constant Task_Id := Self;\n       Result  : Interfaces.C.int;\n       Old_Set : aliased sigset_t;\n \n@@ -219,7 +219,7 @@ package body System.Task_Primitives.Operations is\n    --  The underlying thread system sets a guard page at the\n    --  bottom of a thread stack, so nothing is needed.\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (On);\n       pragma Unreferenced (T);\n    begin\n@@ -230,7 +230,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id --\n    -------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -239,7 +239,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n@@ -370,7 +370,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -409,7 +409,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -424,7 +424,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : ST.Task_ID;\n+     (Self_ID : ST.Task_Id;\n       Reason  : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -450,7 +450,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : Task_States;\n@@ -511,7 +511,7 @@ package body System.Task_Primitives.Operations is\n    --  no locks.\n \n    procedure Timed_Delay\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Time    : Duration;\n       Mode    : ST.Delay_Modes)\n    is\n@@ -608,7 +608,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : ST.Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : ST.Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n       Result : Interfaces.C.int;\n    begin\n@@ -634,7 +634,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -668,7 +668,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -677,7 +677,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n       Result : Interfaces.C.int;\n \n       function To_Int is new Unchecked_Conversion\n@@ -715,7 +715,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -730,7 +730,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -743,7 +743,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Result    : Interfaces.C.int;\n       Cond_Attr : aliased pthread_condattr_t;\n \n@@ -781,7 +781,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -915,13 +915,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result  : Interfaces.C.int;\n-      Tmp     : Task_ID := T;\n+      Tmp     : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -956,7 +956,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -971,7 +971,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -982,7 +982,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -993,9 +993,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -1021,7 +1021,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1037,7 +1037,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1052,7 +1052,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       act     : aliased struct_sigaction;\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n@@ -1072,7 +1072,7 @@ package body System.Task_Primitives.Operations is\n       --           system handler)\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n "}, {"sha": "3af3ad3ef9532448a29ec8b3f32e1aa1ac2535ae", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -62,7 +62,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with Ada.Exceptions;\n --  used for Raise_Exception\n@@ -110,10 +110,10 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Unblocked_Signal_Mask : aliased sigset_t;\n    --  The set of signals that should unblocked in all tasks\n@@ -150,19 +150,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -175,11 +175,11 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n@@ -199,7 +199,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (signo : Signal) is\n       pragma Unreferenced (signo);\n \n-      Self_Id : constant Task_ID := Self;\n+      Self_Id : constant Task_Id := Self;\n       Result  : Interfaces.C.int;\n       Old_Set : aliased sigset_t;\n \n@@ -248,7 +248,7 @@ package body System.Task_Primitives.Operations is\n \n    --  The underlying thread system extends the memory (up to 2MB) when needed\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n       pragma Unreferenced (On);\n \n@@ -260,7 +260,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -269,7 +269,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n@@ -348,7 +348,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       if Priority_Ceiling_Emulation then\n          declare\n-            Self_ID : constant Task_ID := Self;\n+            Self_ID : constant Task_Id := Self;\n \n          begin\n             if Self_ID.Common.LL.Active_Priority > L.Ceiling then\n@@ -390,7 +390,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -419,7 +419,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       if Priority_Ceiling_Emulation then\n          declare\n-            Self_ID : constant Task_ID := Self;\n+            Self_ID : constant Task_Id := Self;\n \n          begin\n             Result := pthread_mutex_unlock (L.L'Access);\n@@ -446,7 +446,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -461,7 +461,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Reason   : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -492,7 +492,7 @@ package body System.Task_Primitives.Operations is\n    --  holding its own ATCB lock.\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -556,7 +556,7 @@ package body System.Task_Primitives.Operations is\n    --  no locks.\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -652,7 +652,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n       Result : Interfaces.C.int;\n    begin\n@@ -678,7 +678,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -722,7 +722,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -731,7 +731,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n \n@@ -754,7 +754,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -769,7 +769,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -782,7 +782,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -826,7 +826,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -890,13 +890,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result  : Interfaces.C.int;\n-      Tmp     : Task_ID := T;\n+      Tmp     : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -931,7 +931,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -946,7 +946,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -957,7 +957,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -968,17 +968,17 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    ------------------\n    -- Suspend_Task --\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n@@ -994,7 +994,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n@@ -1009,7 +1009,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       act     : aliased struct_sigaction;\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n@@ -1030,7 +1030,7 @@ package body System.Task_Primitives.Operations is\n       --           system handler)\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n "}, {"sha": "42f77f75f2954ccc01eb29d2dc4ae9c9ca01a7c3", "filename": "gcc/ada/s-taprop-lynxos.adb", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-lynxos.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -66,7 +66,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Soft_Links;\n --  used for Defer/Undefer_Abort\n@@ -105,10 +105,10 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Locking_Policy : Character;\n    pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n@@ -144,19 +144,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does the current thread have an ATCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -169,11 +169,11 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n@@ -182,7 +182,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (Sig : Signal);\n    --  Signal handler used to implement asynchronous abort.\n \n-   procedure Set_OS_Priority (T : Task_ID; Prio : System.Any_Priority);\n+   procedure Set_OS_Priority (T : Task_Id; Prio : System.Any_Priority);\n    --  This procedure calls the scheduler of the OS to set thread's priority\n \n    -------------------\n@@ -192,7 +192,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (Sig : Signal) is\n       pragma Unreferenced (Sig);\n \n-      T       : constant Task_ID := Self;\n+      T       : constant Task_Id := Self;\n       Result  : Interfaces.C.int;\n       Old_Set : aliased sigset_t;\n \n@@ -226,7 +226,7 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard --\n    -----------------\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n       Guard_Page_Address : Address;\n \n@@ -254,7 +254,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -263,7 +263,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n@@ -349,7 +349,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n       Result : Interfaces.C.int;\n-      T : constant Task_ID := Self;\n+      T : constant Task_Id := Self;\n \n    begin\n       if Locking_Policy = 'C' then\n@@ -386,7 +386,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -410,7 +410,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock (L : access Lock) is\n       Result : Interfaces.C.int;\n-      T : constant Task_ID := Self;\n+      T : constant Task_Id := Self;\n \n    begin\n       Result := pthread_mutex_unlock (L.Mutex'Access);\n@@ -432,7 +432,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -446,7 +446,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason   : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -475,7 +475,7 @@ package body System.Task_Primitives.Operations is\n    --  holding its own ATCB lock.\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : Task_States;\n@@ -554,7 +554,7 @@ package body System.Task_Primitives.Operations is\n    --  the caller is abort-deferred but is holding no locks.\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -672,7 +672,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n       Result : Interfaces.C.int;\n    begin\n@@ -697,7 +697,7 @@ package body System.Task_Primitives.Operations is\n    -- Set_Priority --\n    ------------------\n \n-   procedure Set_OS_Priority (T : Task_ID; Prio : System.Any_Priority) is\n+   procedure Set_OS_Priority (T : Task_Id; Prio : System.Any_Priority) is\n       Result : Interfaces.C.int;\n       Param  : aliased struct_sched_param;\n \n@@ -726,7 +726,7 @@ package body System.Task_Primitives.Operations is\n    --  Comments needed for these declarations ???\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -764,7 +764,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -773,7 +773,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n       Self_ID.Common.LL.LWP := lwp_self;\n@@ -797,7 +797,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -812,7 +812,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -825,7 +825,7 @@ package body System.Task_Primitives.Operations is\n    --  Initialize_TCB  --\n    ----------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Result     : Interfaces.C.int;\n       Cond_Attr  : aliased pthread_condattr_t;\n@@ -885,7 +885,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -970,13 +970,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Tmp    : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -1013,7 +1013,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       Result := pthread_kill (T.Common.LL.Thread,\n@@ -1027,7 +1027,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy versions\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n    begin\n       return True;\n@@ -1037,7 +1037,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n    begin\n       return True;\n@@ -1047,9 +1047,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -1075,7 +1075,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1090,7 +1090,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n       pragma Unreferenced (T);\n@@ -1103,7 +1103,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       act     : aliased struct_sigaction;\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n@@ -1125,7 +1125,7 @@ package body System.Task_Primitives.Operations is\n       --           system handler)\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n "}, {"sha": "7c9c5922bfecebd325d9c35de13fb4d31794da34", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -58,7 +58,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Soft_Links;\n --  used for Defer/Undefer_Abort\n@@ -98,8 +98,8 @@ package body System.Task_Primitives.Operations is\n    -- Local Data --\n    ----------------\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at\n@@ -137,7 +137,7 @@ package body System.Task_Primitives.Operations is\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n@@ -150,7 +150,7 @@ package body System.Task_Primitives.Operations is\n          return TlsGetValue (TlsIndex) /= System.Null_Address;\n       end Is_Valid_Task;\n \n-      procedure Set (Self_Id : Task_ID) is\n+      procedure Set (Self_Id : Task_Id) is\n          Succeeded : BOOL;\n       begin\n          Succeeded := TlsSetValue (TlsIndex, To_Address (Self_Id));\n@@ -163,11 +163,11 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    ----------------------------------\n    -- Condition Variable Functions --\n@@ -346,7 +346,7 @@ package body System.Task_Primitives.Operations is\n    --  bottom of a thread stack, so nothing is needed.\n    --  ??? Check the comment above\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Warnings (Off, T);\n       pragma Warnings (Off, On);\n \n@@ -358,7 +358,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -367,8 +367,8 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID is\n-      Self_Id : constant Task_ID := To_Task_ID (TlsGetValue (TlsIndex));\n+   function Self return Task_Id is\n+      Self_Id : constant Task_Id := To_Task_Id (TlsGetValue (TlsIndex));\n    begin\n       if Self_Id = null then\n          return Register_Foreign_Thread (GetCurrentThread);\n@@ -447,7 +447,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n    begin\n       if not Single_Lock then\n          EnterCriticalSection\n@@ -480,7 +480,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n    begin\n       if not Single_Lock then\n          LeaveCriticalSection\n@@ -493,7 +493,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason  : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -524,7 +524,7 @@ package body System.Task_Primitives.Operations is\n    --  holding its own ATCB lock.\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -585,7 +585,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -659,7 +659,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n \n    begin\n@@ -692,7 +692,7 @@ package body System.Task_Primitives.Operations is\n    --  scheduling.\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -740,7 +740,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -762,7 +762,7 @@ package body System.Task_Primitives.Operations is\n    --  set in System.Task_Primitives.Operations.Create_Task during the\n    --  thread creation.\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n       procedure Init_Float;\n       pragma Import (C, Init_Float, \"__gnat_init_float\");\n       --  Properly initializes the FPU for x86 systems.\n@@ -790,7 +790,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -805,7 +805,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -818,7 +818,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n    begin\n       --  Initialize thread ID to 0, this is needed to detect threads that\n       --  are not yet activated.\n@@ -839,7 +839,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -909,14 +909,14 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n-      Self_ID   : Task_ID := T;\n+   procedure Finalize_TCB (T : Task_Id) is\n+      Self_ID   : Task_Id := T;\n       Result    : DWORD;\n       Succeeded : BOOL;\n       Is_Self   : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -960,7 +960,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n    pragma Unreferenced (T);\n    begin\n       null;\n@@ -970,9 +970,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -997,12 +997,12 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       Discard : BOOL;\n       pragma Unreferenced (Discard);\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       if Time_Slice_Val = 0 or else FIFO_Within_Priorities then\n \n@@ -1053,7 +1053,7 @@ package body System.Task_Primitives.Operations is\n    --  Dummy versions.  The only currently working versions is for solaris\n    --  (native).\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -1064,7 +1064,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -1076,7 +1076,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n@@ -1092,7 +1092,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin"}, {"sha": "a0e1e4b79d693057e6383fecb1aacda323e08b35", "filename": "gcc/ada/s-taprop-os2.adb", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-os2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-os2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-os2.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,7 +57,7 @@ with System.Parameters;\n --  used for Size_Type\n \n with System.Tasking;\n---  used for Task_ID\n+--  used for Task_Id\n \n with System.Parameters;\n --  used for Size_Type\n@@ -121,7 +121,7 @@ package body System.Task_Primitives.Operations is\n    --  own TCB_Ptr without destroying the TCB_Ptr of other threads.\n \n    type Thread_Local_Data is record\n-      Self_ID           : Task_ID;    --  ID of the current thread\n+      Self_ID           : Task_Id;    --  ID of the current thread\n       Lock_Prio_Level   : Lock_Range; --  Nr of priority changes due to locks\n \n       --  ... room for expansion here, if we decide to make access to\n@@ -140,22 +140,22 @@ package body System.Task_Primitives.Operations is\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    function To_PPVOID is new Unchecked_Conversion (PPTLD, PPVOID);\n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n    function To_PFNTHREAD is\n      new Unchecked_Conversion (System.Address, PFNTHREAD);\n \n    function To_MS (D : Duration) return ULONG;\n \n    procedure Set_Temporary_Priority\n-     (T            : in Task_ID;\n+     (T            : in Task_Id;\n       New_Priority : in System.Any_Priority);\n \n    -----------\n@@ -199,7 +199,7 @@ package body System.Task_Primitives.Operations is\n    --  bottom of a thread stack, so nothing is needed.\n    --  ??? Check the comment above\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n       pragma Unreferenced (On);\n \n@@ -211,7 +211,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return OSI.Thread_Id (T.Common.LL.Thread);\n    end Get_Thread_Id;\n@@ -220,8 +220,8 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID is\n-      Self_ID : Task_ID renames Thread_Local_Data_Ptr.Self_ID;\n+   function Self return Task_Id is\n+      Self_ID : Task_Id renames Thread_Local_Data_Ptr.Self_ID;\n    begin\n       --  Check that the thread local data has been initialized.\n \n@@ -287,7 +287,7 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n-      Self_ID      : constant Task_ID := Thread_Local_Data_Ptr.Self_ID;\n+      Self_ID      : constant Task_Id := Thread_Local_Data_Ptr.Self_ID;\n       Old_Priority : constant Any_Priority :=\n                        Self_ID.Common.LL.Current_Priority;\n \n@@ -319,7 +319,7 @@ package body System.Task_Primitives.Operations is\n      (L           : access RTS_Lock;\n       Global_Lock : Boolean := False)\n    is\n-      Self_ID      : Task_ID;\n+      Self_ID      : Task_Id;\n       Old_Priority : Any_Priority;\n \n    begin\n@@ -345,7 +345,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n    begin\n       if not Single_Lock then\n \n@@ -369,7 +369,7 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Unlock (L : access Lock) is\n-      Self_ID      : constant Task_ID := Thread_Local_Data_Ptr.Self_ID;\n+      Self_ID      : constant Task_Id := Thread_Local_Data_Ptr.Self_ID;\n       Old_Priority : constant Any_Priority := L.Owner_Priority;\n \n    begin\n@@ -397,7 +397,7 @@ package body System.Task_Primitives.Operations is\n    end Unlock;\n \n    procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False) is\n-      Self_ID      : Task_ID;\n+      Self_ID      : Task_Id;\n       Old_Priority : Any_Priority;\n \n    begin\n@@ -429,7 +429,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n    begin\n       if not Single_Lock then\n \n@@ -450,7 +450,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason  : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -499,7 +499,7 @@ package body System.Task_Primitives.Operations is\n    --                  Self is locked.\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -586,7 +586,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -679,7 +679,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n \n    begin\n@@ -702,7 +702,7 @@ package body System.Task_Primitives.Operations is\n    ----------------------------\n \n    procedure Set_Temporary_Priority\n-     (T            : Task_ID;\n+     (T            : Task_Id;\n       New_Priority : System.Any_Priority)\n    is\n       use Interfaces.C;\n@@ -743,7 +743,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -758,7 +758,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -767,7 +767,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       --  Initialize thread local data. Must be done first.\n \n@@ -799,7 +799,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -817,7 +817,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       return null;\n    end Register_Foreign_Thread;\n@@ -826,7 +826,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n    begin\n       if DosCreateEventSem (ICS.Null_Ptr,\n         Self_ID.Common.LL.CV'Unchecked_Access, 0, True32) = NO_ERROR\n@@ -883,7 +883,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -970,11 +970,11 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n-      Tmp    : Task_ID := T;\n+   procedure Finalize_TCB (T : Task_Id) is\n+      Tmp    : Task_Id := T;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       Must_Not_Fail (DosCloseEventSem (T.Common.LL.CV));\n@@ -1003,7 +1003,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       pragma Unreferenced (T);\n \n    begin\n@@ -1020,7 +1020,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n    begin\n       return Check_No_Locks (Self_ID);\n    end Check_Exit;\n@@ -1029,7 +1029,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       TLD : constant Access_Thread_Local_Data := Thread_Local_Data_Ptr;\n \n    begin\n@@ -1041,9 +1041,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -1069,7 +1069,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1086,7 +1086,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1102,10 +1102,10 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       Succeeded : Boolean;\n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n       --  Initialize the lock used to synchronize chain of all ATCBs."}, {"sha": "297a9bd2cb2ceb9f296e3ca2da2453f2d743312b", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -71,7 +71,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Soft_Links;\n --  used for Defer/Undefer_Abort\n@@ -111,10 +111,10 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Locking_Policy : Character;\n    pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n@@ -150,19 +150,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -175,11 +175,11 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n@@ -189,7 +189,7 @@ package body System.Task_Primitives.Operations is\n    --  Signal handler used to implement asynchronous abort.\n    --  See also comment before body, below.\n \n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n \n    -------------------\n    -- Abort_Handler --\n@@ -218,7 +218,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (Sig : Signal) is\n       pragma Warnings (Off, Sig);\n \n-      T       : constant Task_ID := Self;\n+      T       : constant Task_Id := Self;\n       Result  : Interfaces.C.int;\n       Old_Set : aliased sigset_t;\n \n@@ -250,7 +250,7 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard --\n    -----------------\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n       Guard_Page_Address : Address;\n \n@@ -278,7 +278,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -287,7 +287,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n@@ -431,7 +431,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -472,7 +472,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -487,7 +487,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason   : System.Tasking.Task_States)\n    is\n       pragma Warnings (Off, Reason);\n@@ -517,7 +517,7 @@ package body System.Task_Primitives.Operations is\n    --  holding its own ATCB lock.\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : Task_States;\n@@ -597,7 +597,7 @@ package body System.Task_Primitives.Operations is\n    --  no locks.\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -709,7 +709,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Warnings (Off, Reason);\n \n       Result : Interfaces.C.int;\n@@ -737,7 +737,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -770,7 +770,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -779,7 +779,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n       Self_ID.Common.LL.LWP := lwp_self;\n@@ -803,7 +803,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -818,7 +818,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -831,7 +831,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Result     : Interfaces.C.int;\n       Cond_Attr  : aliased pthread_condattr_t;\n@@ -907,7 +907,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -994,13 +994,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result  : Interfaces.C.int;\n-      Tmp     : Task_ID := T;\n+      Tmp     : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -1038,7 +1038,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -1053,7 +1053,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Warnings (Off, Self_ID);\n \n    begin\n@@ -1064,7 +1064,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Warnings (Off, Self_ID);\n \n    begin\n@@ -1075,9 +1075,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -1103,7 +1103,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1119,7 +1119,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1134,7 +1134,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       act     : aliased struct_sigaction;\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n@@ -1155,7 +1155,7 @@ package body System.Task_Primitives.Operations is\n       --           system handler)\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n "}, {"sha": "7011fe0568e0b547aa7b3df09a15e2f2e68db36d", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -68,7 +68,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n --           ATCB components and types\n \n with System.Task_Info;\n@@ -107,16 +107,16 @@ package body System.Task_Primitives.Operations is\n    --  The following are logically constants, but need to be initialized\n    --  at run time.\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n-   --  If we use this variable to get the Task_ID, we need the following\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n+   --  If we use this variable to get the Task_Id, we need the following\n    --  ATCB_Key only for non-Ada threads.\n \n    Unblocked_Signal_Mask : aliased sigset_t;\n    --  The set of signals that should unblocked in all tasks\n \n    ATCB_Key : aliased thread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread,\n+   --  Key used to find the Ada Task_Id associated with a thread,\n    --  at least for C threads unknown to the Ada run-time system.\n \n    Single_RTS_Lock : aliased RTS_Lock;\n@@ -213,7 +213,7 @@ package body System.Task_Primitives.Operations is\n    pragma Inline (Record_Wakeup);\n \n    function Check_Wakeup\n-     (T      : Task_ID;\n+     (T      : Task_Id;\n       Reason : Task_States) return Boolean;\n    pragma Inline (Check_Wakeup);\n \n@@ -229,19 +229,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -254,11 +254,11 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    ------------\n    -- Checks --\n@@ -281,7 +281,7 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (Code);\n       pragma Unreferenced (Context);\n \n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       Old_Set : aliased sigset_t;\n \n       Result : Interfaces.C.int;\n@@ -318,7 +318,7 @@ package body System.Task_Primitives.Operations is\n    --  The underlying thread system sets a guard page at the\n    --  bottom of a thread stack, so nothing is needed.\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n       pragma Unreferenced (On);\n \n@@ -330,7 +330,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -339,7 +339,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : ST.Task_ID) is\n+   procedure Initialize (Environment_Task : ST.Task_Id) is\n       act     : aliased struct_sigaction;\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n@@ -429,7 +429,7 @@ package body System.Task_Primitives.Operations is\n    --  Start of processing for Initialize\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  This is done in Enter_Task, but this is too late for the\n       --  Environment Task, since we need to call Self in Check_Locks when\n@@ -557,7 +557,7 @@ package body System.Task_Primitives.Operations is\n \n       if Priority_Ceiling_Emulation and then Locking_Policy = 'C' then\n          declare\n-            Self_Id        : constant Task_ID := Self;\n+            Self_Id        : constant Task_Id := Self;\n             Saved_Priority : System.Any_Priority;\n \n          begin\n@@ -603,7 +603,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -636,7 +636,7 @@ package body System.Task_Primitives.Operations is\n \n       if Priority_Ceiling_Emulation and then Locking_Policy = 'C' then\n          declare\n-            Self_Id : constant Task_ID := Self;\n+            Self_Id : constant Task_Id := Self;\n \n          begin\n             Result := mutex_unlock (L.L'Access);\n@@ -663,7 +663,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -729,14 +729,14 @@ package body System.Task_Primitives.Operations is\n    -- Self ---\n    -----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ------------------\n    -- Set_Priority --\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -789,7 +789,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -798,7 +798,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n       Result    : Interfaces.C.int;\n       Proc      : processorid_t;  --  User processor #\n       Last_Proc : processorid_t;  --  Last processor #\n@@ -846,7 +846,7 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Set (Self_ID);\n \n-      --  We need the above code even if we do direct fetch of Task_ID in Self\n+      --  We need the above code even if we do direct fetch of Task_Id in Self\n       --  for the main task on Sun, x86 Solaris and for gcc 2.7.2.\n \n       Lock_RTS;\n@@ -866,7 +866,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -881,7 +881,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -894,7 +894,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Result : Interfaces.C.int := 0;\n \n    begin\n@@ -936,7 +936,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -1008,13 +1008,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Tmp    : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       T.Common.LL.Thread := To_thread_t (0);\n@@ -1055,7 +1055,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       pragma Assert (T /= Self);\n@@ -1072,7 +1072,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason  : Task_States)\n    is\n       Result : Interfaces.C.int;\n@@ -1178,7 +1178,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -1242,7 +1242,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -1328,7 +1328,7 @@ package body System.Task_Primitives.Operations is\n    ------------\n \n    procedure Wakeup\n-     (T : Task_ID;\n+     (T : Task_Id;\n       Reason : Task_States)\n    is\n       Result : Interfaces.C.int;\n@@ -1350,7 +1350,7 @@ package body System.Task_Primitives.Operations is\n      (L     : Lock_Ptr;\n       Level : Lock_Level) return Boolean\n    is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n \n    begin\n       --  Check that caller is abort-deferred\n@@ -1374,7 +1374,7 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    function Check_Lock (L : Lock_Ptr) return Boolean is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       P       : Lock_Ptr;\n \n    begin\n@@ -1425,7 +1425,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Record_Lock (L : Lock_Ptr) return Boolean is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       P       : Lock_Ptr;\n \n    begin\n@@ -1465,7 +1465,7 @@ package body System.Task_Primitives.Operations is\n    function Check_Sleep (Reason : Task_States) return Boolean is\n       pragma Unreferenced (Reason);\n \n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       P       : Lock_Ptr;\n \n    begin\n@@ -1510,7 +1510,7 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Reason);\n \n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       P       : Lock_Ptr;\n \n    begin\n@@ -1540,10 +1540,10 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Check_Wakeup\n-     (T      : Task_ID;\n+     (T      : Task_Id;\n       Reason : Task_States) return Boolean\n    is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n \n    begin\n       --  Is caller holding T's lock?\n@@ -1566,7 +1566,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Check_Unlock (L : Lock_Ptr) return Boolean is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       P       : Lock_Ptr;\n \n    begin\n@@ -1614,7 +1614,7 @@ package body System.Task_Primitives.Operations is\n    --------------------\n \n    function Check_Finalize_Lock (L : Lock_Ptr) return Boolean is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n \n    begin\n       --  Check that caller is abort-deferred\n@@ -1637,7 +1637,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_Exit --\n    ----------------\n \n-   function Check_Exit (Self_ID : Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : Task_Id) return Boolean is\n    begin\n       --  Check that caller is just holding Global_Task_Lock\n       --  and no other locks\n@@ -1669,7 +1669,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : Task_Id) return Boolean is\n    begin\n       return Self_ID.Common.LL.Locks = null;\n    end Check_No_Locks;\n@@ -1678,9 +1678,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -1706,7 +1706,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin\n@@ -1722,7 +1722,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n    begin"}, {"sha": "ceccef9553a3389b1f57ee098a8ce3c2355d9b69", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -68,7 +68,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n --           ATCB components and types\n \n with System.Soft_Links;\n@@ -108,10 +108,10 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Unblocked_Signal_Mask : aliased sigset_t;\n    --  The set of signals that should unblocked in all tasks\n@@ -139,19 +139,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -164,11 +164,11 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n@@ -184,7 +184,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (Sig : Signal) is\n       pragma Unreferenced (Sig);\n \n-      T       : constant Task_ID := Self;\n+      T       : constant Task_Id := Self;\n       Result  : Interfaces.C.int;\n       Old_Set : aliased sigset_t;\n \n@@ -219,7 +219,7 @@ package body System.Task_Primitives.Operations is\n    --  The underlying thread system sets a guard page at the\n    --  bottom of a thread stack, so nothing is needed.\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n       pragma Unreferenced (On);\n \n@@ -231,7 +231,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -240,7 +240,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n@@ -334,8 +334,8 @@ package body System.Task_Primitives.Operations is\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n       Result         : Interfaces.C.int;\n-      Self_ID        : Task_ID;\n-      All_Tasks_Link : Task_ID;\n+      Self_ID        : Task_Id;\n+      All_Tasks_Link : Task_Id;\n       Current_Prio   : System.Any_Priority;\n \n    begin\n@@ -373,7 +373,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -411,7 +411,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -425,7 +425,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason  : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -455,7 +455,7 @@ package body System.Task_Primitives.Operations is\n    --  holding its own ATCB lock.\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -523,7 +523,7 @@ package body System.Task_Primitives.Operations is\n    --  no locks.\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -621,7 +621,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n       Result : Interfaces.C.int;\n    begin\n@@ -647,7 +647,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -680,7 +680,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -689,7 +689,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n       Specific.Set (Self_ID);\n@@ -711,7 +711,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -726,7 +726,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -739,7 +739,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Result     : Interfaces.C.int;\n       Cond_Attr  : aliased pthread_condattr_t;\n@@ -793,7 +793,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -920,13 +920,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result  : Interfaces.C.int;\n-      Tmp     : Task_ID := T;\n+      Tmp     : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -961,7 +961,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       Result :=\n@@ -977,7 +977,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -988,7 +988,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -999,9 +999,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -1027,7 +1027,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n       pragma Warnings (Off, T);\n@@ -1042,7 +1042,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n       pragma Warnings (Off, T);\n@@ -1056,7 +1056,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       act     : aliased struct_sigaction;\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n@@ -1076,7 +1076,7 @@ package body System.Task_Primitives.Operations is\n       --           system handler)\n \n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n "}, {"sha": "b40274ccca756a68844d23126a17b8327fbaa7ce", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -52,7 +52,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n \n with System.Soft_Links;\n --  used for Defer/Undefer_Abort\n@@ -94,10 +94,10 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n@@ -117,19 +117,19 @@ package body System.Task_Primitives.Operations is\n \n    package Specific is\n \n-      procedure Initialize (Environment_Task : Task_ID);\n+      procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n       --  Initialize various data needed by this package.\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task\n \n@@ -142,26 +142,26 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n+   function To_Task_Id is new Unchecked_Conversion (System.Address, Task_Id);\n \n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n \n    procedure Timer_Sleep_AST (ID : Address);\n    --  Signal the condition variable when AST fires.\n \n    procedure Timer_Sleep_AST (ID : Address) is\n       Result  : Interfaces.C.int;\n-      Self_ID : constant Task_ID := To_Task_ID (ID);\n+      Self_ID : constant Task_Id := To_Task_Id (ID);\n    begin\n       Self_ID.Common.LL.AST_Pending := False;\n       Result := pthread_cond_signal_int_np (Self_ID.Common.LL.CV'Access);\n@@ -176,7 +176,7 @@ package body System.Task_Primitives.Operations is\n    --  bottom of a thread stack, so nothing is needed.\n    --  ??? Check the comment above\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n       pragma Unreferenced (On);\n    begin\n@@ -187,7 +187,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id  --\n    --------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -196,7 +196,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    ---------------------\n    -- Initialize_Lock --\n@@ -297,8 +297,8 @@ package body System.Task_Primitives.Operations is\n    ----------------\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n-      Self_ID        : constant Task_ID := Self;\n-      All_Tasks_Link : constant Task_ID := Self.Common.All_Tasks_Link;\n+      Self_ID        : constant Task_Id := Self;\n+      All_Tasks_Link : constant Task_Id := Self.Common.All_Tasks_Link;\n       Current_Prio   : System.Any_Priority;\n       Result         : Interfaces.C.int;\n \n@@ -335,7 +335,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -373,7 +373,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       if not Single_Lock then\n@@ -387,7 +387,7 @@ package body System.Task_Primitives.Operations is\n    -----------\n \n    procedure Sleep\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Reason  : System.Tasking.Task_States)\n    is\n       pragma Unreferenced (Reason);\n@@ -419,7 +419,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -482,7 +482,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Timed_Delay\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Time    : Duration;\n       Mode    : ST.Delay_Modes)\n    is\n@@ -586,7 +586,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n \n       Result : Interfaces.C.int;\n@@ -614,7 +614,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -652,7 +652,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -661,7 +661,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.LL.Thread := pthread_self;\n \n@@ -684,7 +684,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -699,7 +699,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -712,7 +712,7 @@ package body System.Task_Primitives.Operations is\n    --  Initialize_TCB  --\n    ----------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Mutex_Attr : aliased pthread_mutexattr_t;\n       Result     : Interfaces.C.int;\n       Cond_Attr  : aliased pthread_condattr_t;\n@@ -773,7 +773,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -800,7 +800,7 @@ package body System.Task_Primitives.Operations is\n       --  Since the initial signal mask of a thread is inherited from the\n       --  creator, we need to set our local signal mask mask all signals\n       --  during the creation operation, to make sure the new thread is\n-      --  not disturbed by signals before it has set its own Task_ID.\n+      --  not disturbed by signals before it has set its own Task_Id.\n \n       Result := pthread_attr_init (Attributes'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n@@ -850,13 +850,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result  : Interfaces.C.int;\n-      Tmp     : Task_ID := T;\n+      Tmp     : Task_Id := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n       procedure Free is new Unchecked_Deallocation\n        (Exc_Stack_T, Exc_Stack_Ptr_T);\n@@ -896,7 +896,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n    begin\n       --  Interrupt Server_Tasks may be waiting on an event flag\n \n@@ -911,7 +911,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -922,7 +922,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -933,9 +933,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -961,7 +961,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n       pragma Unreferenced (T);\n@@ -976,7 +976,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id) return Boolean\n    is\n       pragma Unreferenced (T);\n@@ -989,9 +989,9 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n    begin\n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs\n "}, {"sha": "4ed3d8d925b1367caf43cde22338c93827822ee0", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -65,7 +65,7 @@ with System.Parameters;\n \n with System.Tasking;\n --  used for Ada_Task_Control_Block\n---           Task_ID\n+--           Task_Id\n --           ATCB components and types\n \n with Interfaces.C;\n@@ -100,16 +100,16 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased System.Address := System.Null_Address;\n-   --  Key used to find the Ada Task_ID associated with a thread\n+   --  Key used to find the Ada Task_Id associated with a thread\n \n    ATCB_Key_Addr : System.Address := ATCB_Key'Address;\n    pragma Export (Ada, ATCB_Key_Addr, \"__gnat_ATCB_key_addr\");\n    --  Exported to support the temporary AE653 task registration\n    --  implementation. This mechanism is used to minimize impact on other\n    --  targets.\n \n-   Environment_Task_ID : Task_ID;\n-   --  A variable to hold Task_ID for the environment task.\n+   Environment_Task_Id : Task_Id;\n+   --  A variable to hold Task_Id for the environment task.\n \n    Unblocked_Signal_Mask : aliased sigset_t;\n    --  The set of signals that should unblocked in all tasks\n@@ -143,11 +143,11 @@ package body System.Task_Primitives.Operations is\n       pragma Inline (Is_Valid_Task);\n       --  Does executing thread have a TCB?\n \n-      procedure Set (Self_Id : Task_ID);\n+      procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n       --  Set the self id for the current task.\n \n-      function Self return Task_ID;\n+      function Self return Task_Id;\n       pragma Inline (Self);\n       --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -160,11 +160,11 @@ package body System.Task_Primitives.Operations is\n    -- Support for foreign threads --\n    ---------------------------------\n \n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID;\n+   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n    --  Allocate and Initialize a new ATCB for the current Thread.\n \n    function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_ID is separate;\n+     (Thread : Thread_Id) return Task_Id is separate;\n \n    -----------------------\n    -- Local Subprograms --\n@@ -176,7 +176,7 @@ package body System.Task_Primitives.Operations is\n    procedure Install_Signal_Handlers;\n    --  Install the default signal handlers for the current task\n \n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n \n    -------------------\n    -- Abort_Handler --\n@@ -185,7 +185,7 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Handler (signo : Signal) is\n       pragma Unreferenced (signo);\n \n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n       Result  : int;\n       Old_Set : aliased sigset_t;\n \n@@ -217,7 +217,7 @@ package body System.Task_Primitives.Operations is\n    -- Stack_Guard --\n    -----------------\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n       pragma Unreferenced (T);\n       pragma Unreferenced (On);\n \n@@ -231,7 +231,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Thread_Id --\n    -------------------\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n    begin\n       return T.Common.LL.Thread;\n    end Get_Thread_Id;\n@@ -240,7 +240,7 @@ package body System.Task_Primitives.Operations is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames Specific.Self;\n+   function Self return Task_Id renames Specific.Self;\n \n    -----------------------------\n    -- Install_Signal_Handlers --\n@@ -346,7 +346,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock (T : Task_ID) is\n+   procedure Write_Lock (T : Task_Id) is\n       Result : int;\n \n    begin\n@@ -387,7 +387,7 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock (T : Task_ID) is\n+   procedure Unlock (T : Task_Id) is\n       Result : int;\n \n    begin\n@@ -401,7 +401,7 @@ package body System.Task_Primitives.Operations is\n    -- Sleep --\n    -----------\n \n-   procedure Sleep (Self_ID : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Sleep (Self_ID : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n \n       Result : int;\n@@ -445,7 +445,7 @@ package body System.Task_Primitives.Operations is\n    --  holding its own ATCB lock.\n \n    procedure Timed_Sleep\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -562,7 +562,7 @@ package body System.Task_Primitives.Operations is\n    --  we assume the caller is holding no locks.\n \n    procedure Timed_Delay\n-     (Self_ID  : Task_ID;\n+     (Self_ID  : Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes)\n    is\n@@ -701,7 +701,7 @@ package body System.Task_Primitives.Operations is\n    -- Wakeup --\n    ------------\n \n-   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n       pragma Unreferenced (Reason);\n \n       Result : int;\n@@ -736,7 +736,7 @@ package body System.Task_Primitives.Operations is\n    --  with run-till-blocked scheduling.\n \n    procedure Set_Priority\n-     (T                   : Task_ID;\n+     (T                   : Task_Id;\n       Prio                : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False)\n    is\n@@ -785,7 +785,7 @@ package body System.Task_Primitives.Operations is\n    -- Get_Priority --\n    ------------------\n \n-   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   function Get_Priority (T : Task_Id) return System.Any_Priority is\n    begin\n       return T.Common.Current_Priority;\n    end Get_Priority;\n@@ -794,7 +794,7 @@ package body System.Task_Primitives.Operations is\n    -- Enter_Task --\n    ----------------\n \n-   procedure Enter_Task (Self_ID : Task_ID) is\n+   procedure Enter_Task (Self_ID : Task_Id) is\n       procedure Init_Float;\n       pragma Import (C, Init_Float, \"__gnat_init_float\");\n       --  Properly initializes the FPU for PPC/MIPS systems.\n@@ -828,7 +828,7 @@ package body System.Task_Primitives.Operations is\n    -- New_ATCB --\n    --------------\n \n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n    begin\n       return new Ada_Task_Control_Block (Entry_Num);\n    end New_ATCB;\n@@ -843,7 +843,7 @@ package body System.Task_Primitives.Operations is\n    -- Register_Foreign_Thread --\n    -----------------------------\n \n-   function Register_Foreign_Thread return Task_ID is\n+   function Register_Foreign_Thread return Task_Id is\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -856,7 +856,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n    begin\n       Self_ID.Common.LL.CV := semBCreate (SEM_Q_PRIORITY, SEM_EMPTY);\n       Self_ID.Common.LL.Thread := 0;\n@@ -877,7 +877,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    procedure Create_Task\n-     (T          : Task_ID;\n+     (T          : Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n@@ -958,13 +958,13 @@ package body System.Task_Primitives.Operations is\n    -- Finalize_TCB --\n    ------------------\n \n-   procedure Finalize_TCB (T : Task_ID) is\n+   procedure Finalize_TCB (T : Task_Id) is\n       Result  : int;\n-      Tmp     : Task_ID          := T;\n+      Tmp     : Task_Id          := T;\n       Is_Self : constant Boolean := (T = Self);\n \n       procedure Free is new\n-        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    begin\n       if not Single_Lock then\n@@ -1002,7 +1002,7 @@ package body System.Task_Primitives.Operations is\n    -- Abort_Task --\n    ----------------\n \n-   procedure Abort_Task (T : Task_ID) is\n+   procedure Abort_Task (T : Task_Id) is\n       Result : int;\n \n    begin\n@@ -1017,7 +1017,7 @@ package body System.Task_Primitives.Operations is\n \n    --  Dummy version\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -1028,7 +1028,7 @@ package body System.Task_Primitives.Operations is\n    -- Check_No_Locks --\n    --------------------\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n       pragma Unreferenced (Self_ID);\n \n    begin\n@@ -1039,9 +1039,9 @@ package body System.Task_Primitives.Operations is\n    -- Environment_Task --\n    ----------------------\n \n-   function Environment_Task return Task_ID is\n+   function Environment_Task return Task_Id is\n    begin\n-      return Environment_Task_ID;\n+      return Environment_Task_Id;\n    end Environment_Task;\n \n    --------------\n@@ -1067,7 +1067,7 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1086,7 +1086,7 @@ package body System.Task_Primitives.Operations is\n    -----------------\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : Thread_Id)\n       return        Boolean\n    is\n@@ -1104,7 +1104,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       Result : int;\n \n    begin\n@@ -1132,7 +1132,7 @@ package body System.Task_Primitives.Operations is\n          end if;\n       end loop;\n \n-      Environment_Task_ID := Environment_Task;\n+      Environment_Task_Id := Environment_Task;\n \n       --  Initialize the lock used to synchronize chain of all ATCBs.\n "}, {"sha": "dca1c3f8c06100add912413620972693e10594bf", "filename": "gcc/ada/s-taprop.ads", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,7 @@ with System.Parameters;\n --  used for Size_Type\n \n with System.Tasking;\n---  used for Task_ID\n+--  used for Task_Id\n \n with System.OS_Interface;\n --  used for Thread_Id\n@@ -49,27 +49,27 @@ package System.Task_Primitives.Operations is\n    package ST renames System.Tasking;\n    package OSI renames System.OS_Interface;\n \n-   procedure Initialize (Environment_Task : ST.Task_ID);\n+   procedure Initialize (Environment_Task : ST.Task_Id);\n    pragma Inline (Initialize);\n    --  This must be called once, before any other subprograms of this\n    --  package are called.\n \n    procedure Create_Task\n-     (T          : ST.Task_ID;\n+     (T          : ST.Task_Id;\n       Wrapper    : System.Address;\n       Stack_Size : System.Parameters.Size_Type;\n       Priority   : System.Any_Priority;\n       Succeeded  : out Boolean);\n    pragma Inline (Create_Task);\n-   --  Create a new low-level task with ST.Task_ID T and place other needed\n+   --  Create a new low-level task with ST.Task_Id T and place other needed\n    --  information in the ATCB.\n    --\n    --  A new thread of control is created, with a stack of at least Stack_Size\n    --  storage units, and the procedure Wrapper is called by this new thread\n    --  of control. If Stack_Size = Unspecified_Storage_Size, choose a default\n    --  stack size; this may be effectively \"unbounded\" on some systems.\n    --\n-   --  The newly created low-level task is associated with the ST.Task_ID T\n+   --  The newly created low-level task is associated with the ST.Task_Id T\n    --  such that any subsequent call to Self from within the context of the\n    --  low-level task returns T.\n    --\n@@ -80,7 +80,7 @@ package System.Task_Primitives.Operations is\n    --  Succeeded is set to true unless creation of the task failed,\n    --  as it may if there are insufficient resources to create another task.\n \n-   procedure Enter_Task (Self_ID : ST.Task_ID);\n+   procedure Enter_Task (Self_ID : ST.Task_Id);\n    pragma Inline (Enter_Task);\n    --  Initialize data structures specific to the calling task.\n    --  Self must be the ID of the calling task.\n@@ -96,15 +96,15 @@ package System.Task_Primitives.Operations is\n    --  The effects of further calls to operations defined below\n    --  on the task are undefined thereafter.\n \n-   function New_ATCB (Entry_Num : ST.Task_Entry_Index) return ST.Task_ID;\n+   function New_ATCB (Entry_Num : ST.Task_Entry_Index) return ST.Task_Id;\n    pragma Inline (New_ATCB);\n    --  Allocate a new ATCB with the specified number of entries.\n \n-   procedure Initialize_TCB (Self_ID : ST.Task_ID; Succeeded : out Boolean);\n+   procedure Initialize_TCB (Self_ID : ST.Task_Id; Succeeded : out Boolean);\n    pragma Inline (Initialize_TCB);\n    --  Initialize all fields of the TCB\n \n-   procedure Finalize_TCB (T : ST.Task_ID);\n+   procedure Finalize_TCB (T : ST.Task_Id);\n    pragma Inline (Finalize_TCB);\n    --  Finalizes Private_Data of ATCB, and then deallocates it.\n    --  This is also responsible for recovering any storage or other resources\n@@ -113,7 +113,7 @@ package System.Task_Primitives.Operations is\n    --  After it is called there should be no further\n    --  reference to the ATCB that corresponds to T.\n \n-   procedure Abort_Task (T : ST.Task_ID);\n+   procedure Abort_Task (T : ST.Task_Id);\n    pragma Inline (Abort_Task);\n    --  Abort the task specified by T (the target task). This causes\n    --  the target task to asynchronously raise Abort_Signal if\n@@ -128,7 +128,7 @@ package System.Task_Primitives.Operations is\n \n    --  ??? modify GNARL to skip wakeup and always call Abort_Task\n \n-   function Self return ST.Task_ID;\n+   function Self return ST.Task_Id;\n    pragma Inline (Self);\n    --  Return a pointer to the Ada Task Control Block of the calling task.\n \n@@ -172,7 +172,7 @@ package System.Task_Primitives.Operations is\n \n    procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean);\n    procedure Write_Lock (L : access RTS_Lock; Global_Lock : Boolean := False);\n-   procedure Write_Lock (T : ST.Task_ID);\n+   procedure Write_Lock (T : ST.Task_Id);\n    pragma Inline (Write_Lock);\n    --  Lock a lock object for write access. After this operation returns,\n    --  the calling task holds write permission for the lock object. No other\n@@ -188,7 +188,7 @@ package System.Task_Primitives.Operations is\n    --  For the operation on RTS_Lock, Global_Lock should be set to True\n    --  if L is a global lock (Single_RTS_Lock, Global_Task_Lock).\n    --\n-   --  For the operation on ST.Task_ID, the lock is the special lock object\n+   --  For the operation on ST.Task_Id, the lock is the special lock object\n    --  associated with that task's ATCB. This lock has effective ceiling\n    --  priority high enough that it is safe to call by a task with any\n    --  priority in the range System.Priority. It is implicitly initialized\n@@ -212,15 +212,15 @@ package System.Task_Primitives.Operations is\n    --  Write_Lock. This simplifies the implementation, but reduces the level\n    --  of concurrency that can be achieved.\n    --\n-   --  Note that Read_Lock is not defined for RT_Lock and ST.Task_ID.\n+   --  Note that Read_Lock is not defined for RT_Lock and ST.Task_Id.\n    --  That is because (1) so far Read_Lock has always been implemented\n    --  the same as Write_Lock, (2) most lock usage inside the RTS involves\n    --  potential write access, and (3) implementations of priority ceiling\n    --  locking that make a reader-writer distinction have higher overhead.\n \n    procedure Unlock (L : access Lock);\n    procedure Unlock (L : access RTS_Lock; Global_Lock : Boolean := False);\n-   procedure Unlock (T : ST.Task_ID);\n+   procedure Unlock (T : ST.Task_Id);\n    pragma Inline (Unlock);\n    --  Unlock a locked lock object.\n    --\n@@ -295,7 +295,7 @@ package System.Task_Primitives.Operations is\n    --  ones.\n \n    procedure Set_Priority\n-     (T : ST.Task_ID;\n+     (T : ST.Task_Id;\n       Prio : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False);\n    pragma Inline (Set_Priority);\n@@ -311,7 +311,7 @@ package System.Task_Primitives.Operations is\n    --  Loss_Of_Inheritance helps the underlying implementation to do it\n    --  right when the OS doesn't.\n \n-   function Get_Priority (T : ST.Task_ID) return System.Any_Priority;\n+   function Get_Priority (T : ST.Task_Id) return System.Any_Priority;\n    pragma Inline (Get_Priority);\n    --  Returns the priority last set by Set_Priority for this task.\n \n@@ -335,7 +335,7 @@ package System.Task_Primitives.Operations is\n    --  Pending priority changes are handled internally.\n \n    procedure Sleep\n-     (Self_ID : ST.Task_ID;\n+     (Self_ID : ST.Task_Id;\n       Reason  : System.Tasking.Task_States);\n    pragma Inline (Sleep);\n    --  Wait until the current task, T,  is signaled to wake up.\n@@ -358,7 +358,7 @@ package System.Task_Primitives.Operations is\n    --  a Wakeup operation is performed for the same task.\n \n    procedure Timed_Sleep\n-     (Self_ID  : ST.Task_ID;\n+     (Self_ID  : ST.Task_Id;\n       Time     : Duration;\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n@@ -367,34 +367,34 @@ package System.Task_Primitives.Operations is\n    --  Combination of Sleep (above) and Timed_Delay\n \n    procedure Timed_Delay\n-     (Self_ID : ST.Task_ID;\n+     (Self_ID : ST.Task_Id;\n       Time    : Duration;\n       Mode    : ST.Delay_Modes);\n    --  Implement the semantics of the delay statement. It is assumed that\n    --  the caller is not abort-deferred and does not hold any locks.\n \n    procedure Wakeup\n-     (T      : ST.Task_ID;\n+     (T      : ST.Task_Id;\n       Reason : System.Tasking.Task_States);\n    pragma Inline (Wakeup);\n    --  Wake up task T if it is waiting on a Sleep call (of ordinary\n    --  or timed variety), making it ready for execution once again.\n    --  If the task T is not waiting on a Sleep, the operation has no effect.\n \n-   function Environment_Task return ST.Task_ID;\n+   function Environment_Task return ST.Task_Id;\n    pragma Inline (Environment_Task);\n    --  Return the task ID of the environment task\n    --  Consider putting this into a variable visible directly\n    --  by the rest of the runtime system. ???\n \n-   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id;\n+   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id;\n    --  Return the thread id of the specified task\n \n    function Is_Valid_Task return Boolean;\n    pragma Inline (Is_Valid_Task);\n    --  Does the calling thread have an ATCB?\n \n-   function Register_Foreign_Thread return ST.Task_ID;\n+   function Register_Foreign_Thread return ST.Task_Id;\n    --  Allocate and initialize a new ATCB for the current thread\n \n    -----------------------\n@@ -439,7 +439,7 @@ package System.Task_Primitives.Operations is\n    --  the guard page ourselves, and the procedure Stack_Guard is provided\n    --  for this purpose.\n \n-   procedure Stack_Guard (T : ST.Task_ID; On : Boolean);\n+   procedure Stack_Guard (T : ST.Task_Id; On : Boolean);\n    --  Ensure guard page is set if one is needed and the underlying thread\n    --  system does not provide it. The procedure is as follows:\n    --\n@@ -467,16 +467,16 @@ package System.Task_Primitives.Operations is\n    --  These interfaces have been added to assist in debugging the\n    --  tasking runtime system.\n \n-   function Check_Exit (Self_ID : ST.Task_ID) return Boolean;\n+   function Check_Exit (Self_ID : ST.Task_Id) return Boolean;\n    pragma Inline (Check_Exit);\n    --  Check that the current task is holding only Global_Task_Lock.\n \n-   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean;\n+   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean;\n    pragma Inline (Check_No_Locks);\n    --  Check that current task is holding no locks.\n \n    function Suspend_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : OSI.Thread_Id)\n       return        Boolean;\n    --  Suspend a specific task when the underlying thread library provides\n@@ -485,7 +485,7 @@ package System.Task_Primitives.Operations is\n    --  Return True is the operation is successful\n \n    function Resume_Task\n-     (T           : ST.Task_ID;\n+     (T           : ST.Task_Id;\n       Thread_Self : OSI.Thread_Id)\n       return        Boolean;\n    --  Resume a specific task when the underlying thread library provides"}, {"sha": "6b298a812a65fd3c726edf7942e4fc4a7a17e20a", "filename": "gcc/ada/s-tarest.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1999-2002, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1999-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -124,13 +124,13 @@ package body System.Tasking.Restricted.Stages is\n    --  Local Subprograms --\n    ------------------------\n \n-   procedure Task_Wrapper (Self_ID : Task_ID);\n+   procedure Task_Wrapper (Self_ID : Task_Id);\n    --  This is the procedure that is called by the GNULL from the\n    --  new context when a task is created. It waits for activation\n    --  and then calls the task body procedure. When the task body\n    --  procedure completes, it terminates the task.\n \n-   procedure Terminate_Task (Self_ID : Task_ID);\n+   procedure Terminate_Task (Self_ID : Task_Id);\n    --  Terminate the calling task.\n    --  This should only be called by the Task_Wrapper procedure.\n \n@@ -210,8 +210,8 @@ package body System.Tasking.Restricted.Stages is\n    --  of the current thread, since it should be at a fixed offset from the\n    --  stack base.\n \n-   procedure Task_Wrapper (Self_ID : Task_ID) is\n-      ID : Task_ID := Self_ID;\n+   procedure Task_Wrapper (Self_ID : Task_Id) is\n+      ID : Task_Id := Self_ID;\n       pragma Volatile (ID);\n \n       pragma Warnings (Off, ID);\n@@ -288,8 +288,8 @@ package body System.Tasking.Restricted.Stages is\n    procedure Activate_Restricted_Tasks\n      (Chain_Access : Activation_Chain_Access)\n    is\n-      Self_ID       : constant Task_ID := STPO.Self;\n-      C             : Task_ID;\n+      Self_ID       : constant Task_Id := STPO.Self;\n+      C             : Task_Id;\n       Activate_Prio : System.Any_Priority;\n       Success       : Boolean;\n \n@@ -377,8 +377,8 @@ package body System.Tasking.Restricted.Stages is\n    --  activator.\n \n    procedure Complete_Restricted_Activation is\n-      Self_ID   : constant Task_ID := STPO.Self;\n-      Activator : constant Task_ID := Self_ID.Common.Activator;\n+      Self_ID   : constant Task_Id := STPO.Self;\n+      Activator : constant Task_Id := Self_ID.Common.Activator;\n \n    begin\n       if Single_Lock then\n@@ -443,10 +443,10 @@ package body System.Tasking.Restricted.Stages is\n       Elaborated    : Access_Boolean;\n       Chain         : in out Activation_Chain;\n       Task_Image    : String;\n-      Created_Task  : out Task_ID)\n+      Created_Task  : out Task_Id)\n    is\n-      T             : Task_ID;\n-      Self_ID       : constant Task_ID := STPO.Self;\n+      T             : Task_Id;\n+      Self_ID       : constant Task_Id := STPO.Self;\n       Base_Priority : System.Any_Priority;\n       Success       : Boolean;\n \n@@ -516,7 +516,7 @@ package body System.Tasking.Restricted.Stages is\n    --  forever, since none of the dependent tasks are expected to terminate\n \n    procedure Finalize_Global_Tasks is\n-      Self_ID : constant Task_ID := STPO.Self;\n+      Self_ID : constant Task_Id := STPO.Self;\n \n    begin\n       pragma Assert (Self_ID = STPO.Environment_Task);\n@@ -542,7 +542,7 @@ package body System.Tasking.Restricted.Stages is\n    -- Restricted_Terminated --\n    ---------------------------\n \n-   function Restricted_Terminated (T : Task_ID) return Boolean is\n+   function Restricted_Terminated (T : Task_Id) return Boolean is\n    begin\n       return T.Common.State = Terminated;\n    end Restricted_Terminated;\n@@ -551,7 +551,7 @@ package body System.Tasking.Restricted.Stages is\n    -- Terminate_Task --\n    --------------------\n \n-   procedure Terminate_Task (Self_ID : Task_ID) is\n+   procedure Terminate_Task (Self_ID : Task_Id) is\n    begin\n       Self_ID.Common.State := Terminated;\n    end Terminate_Task;"}, {"sha": "c2f5471aec67fb3a326ca04a1880adc8e6f60bc3", "filename": "gcc/ada/s-tarest.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tarest.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tarest.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -131,7 +131,7 @@ package System.Tasking.Restricted.Stages is\n       Elaborated    : Access_Boolean;\n       Chain         : in out Activation_Chain;\n       Task_Image    : String;\n-      Created_Task  : out Task_ID);\n+      Created_Task  : out Task_Id);\n    --  Compiler interface only. Do not call from within the RTS.\n    --  This must be called to create a new task.\n    --\n@@ -189,7 +189,7 @@ package System.Tasking.Restricted.Stages is\n    --  If the current task have not completed activation, this should be done\n    --  now in order to wake up the activator (the environment task).\n \n-   function Restricted_Terminated (T : Task_ID) return Boolean;\n+   function Restricted_Terminated (T : Task_Id) return Boolean;\n    --  Compiler interface only. Do not call from within the RTS.\n    --  This is called by the compiler to implement the 'Terminated attribute.\n    --"}, {"sha": "f85e229dd7012b7cb79f6d33cb3de543bf8594d7", "filename": "gcc/ada/s-tasdeb.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasdeb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasdeb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasdeb.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1997-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,7 +48,7 @@ package body System.Tasking.Debug is\n    package STPO renames System.Task_Primitives.Operations;\n \n    function To_Integer is new\n-     Unchecked_Conversion (Task_ID, System.Address);\n+     Unchecked_Conversion (Task_Id, System.Address);\n \n    type Trace_Flag_Set is array (Character) of Boolean;\n \n@@ -80,7 +80,7 @@ package body System.Tasking.Debug is\n    ----------------\n \n    procedure List_Tasks is\n-      C : Task_ID;\n+      C : Task_Id;\n    begin\n       C := All_Tasks_List;\n \n@@ -103,9 +103,9 @@ package body System.Tasking.Debug is\n    -- Print_Task_Info --\n    ---------------------\n \n-   procedure Print_Task_Info (T : Task_ID) is\n+   procedure Print_Task_Info (T : Task_Id) is\n       Entry_Call : Entry_Call_Link;\n-      Parent     : Task_ID;\n+      Parent     : Task_Id;\n \n    begin\n       if T = null then\n@@ -191,7 +191,7 @@ package body System.Tasking.Debug is\n    ----------------------\n \n    procedure Resume_All_Tasks (Thread_Self : OS_Interface.Thread_Id) is\n-      C     : Task_ID;\n+      C     : Task_Id;\n       Dummy : Boolean;\n       pragma Unreferenced (Dummy);\n \n@@ -230,7 +230,7 @@ package body System.Tasking.Debug is\n    -----------------------\n \n    procedure Suspend_All_Tasks (Thread_Self : OS_Interface.Thread_Id) is\n-      C     : Task_ID;\n+      C     : Task_Id;\n       Dummy : Boolean;\n       pragma Unreferenced (Dummy);\n \n@@ -273,10 +273,10 @@ package body System.Tasking.Debug is\n    -----------\n \n    procedure Trace\n-     (Self_Id  : Task_ID;\n+     (Self_Id  : Task_Id;\n       Msg      : String;\n       Flag     : Character;\n-      Other_Id : Task_ID := null)\n+      Other_Id : Task_Id := null)\n    is\n    begin\n       if Trace_On (Flag) then"}, {"sha": "548df9e269c7db5448ab38133ffce366bf3db371", "filename": "gcc/ada/s-tasdeb.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasdeb.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasdeb.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasdeb.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1997-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,7 +51,7 @@ package System.Tasking.Debug is\n    --  Write information about current task, in hexadecimal, as one line, to\n    --  the standard error file.\n \n-   procedure Print_Task_Info (T : Task_ID);\n+   procedure Print_Task_Info (T : Task_Id);\n    --  Similar to Print_Current_Task, for a given task.\n \n    procedure Set_User_State (Value : Long_Integer);\n@@ -66,7 +66,7 @@ package System.Tasking.Debug is\n    -- General GDB support --\n    -------------------------\n \n-   Known_Tasks : array (0 .. 999) of Task_ID;\n+   Known_Tasks : array (0 .. 999) of Task_Id;\n    --  Global array of tasks read by gdb, and updated by\n    --  Create_Task and Finalize_TCB\n \n@@ -99,10 +99,10 @@ package System.Tasking.Debug is\n    -------------------------------\n \n    procedure Trace\n-     (Self_Id  : Task_ID;\n+     (Self_Id  : Task_Id;\n       Msg      : String;\n       Flag     : Character;\n-      Other_Id : Task_ID := null);\n+      Other_Id : Task_Id := null);\n    --  If traces for Flag are enabled, display on Standard_Error a given\n    --  message for the current task. Other_Id is an optional second task id\n    --  to display."}, {"sha": "d05654ab66f782dd3a95ba9abc8430348b41b71a", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -116,7 +116,7 @@ package body System.Tasking.Initialization is\n    --  Get the exception stack for the current task\n \n    procedure Set_Exc_Stack_Addr (Self_ID : Address; Addr : Address);\n-   --  Self_ID is the Task_ID of the task that gets the exception stack.\n+   --  Self_ID is the Task_Id of the task that gets the exception stack.\n    --  For Self_ID = Null_Address, the current task gets the exception stack.\n \n    function  Get_Machine_State_Addr return Address;\n@@ -143,7 +143,7 @@ package body System.Tasking.Initialization is\n    --  Local Subprograms --\n    ------------------------\n \n-   procedure Do_Pending_Action (Self_ID : Task_ID);\n+   procedure Do_Pending_Action (Self_ID : Task_Id);\n    --  This is introduced to allow more efficient\n    --  in-line expansion of Undefer_Abort.\n \n@@ -171,7 +171,7 @@ package body System.Tasking.Initialization is\n \n    --  Call only with abort deferred and holding Self_ID locked.\n \n-   procedure Change_Base_Priority (T : Task_ID) is\n+   procedure Change_Base_Priority (T : Task_Id) is\n    begin\n       if T.Common.Base_Priority /= T.New_Base_Priority then\n          T.Common.Base_Priority := T.New_Base_Priority;\n@@ -184,7 +184,7 @@ package body System.Tasking.Initialization is\n    ------------------------\n \n    function Check_Abort_Status return Integer is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n    begin\n       if Self_ID /= null and then Self_ID.Deferral_Level = 0\n         and then Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n@@ -199,7 +199,7 @@ package body System.Tasking.Initialization is\n    -- Defer_Abort --\n    -----------------\n \n-   procedure Defer_Abort (Self_ID : Task_ID) is\n+   procedure Defer_Abort (Self_ID : Task_Id) is\n    begin\n       if No_Abort and then not Dynamic_Priority_Support then\n          return;\n@@ -240,7 +240,7 @@ package body System.Tasking.Initialization is\n    -- Defer_Abort_Nestable --\n    --------------------------\n \n-   procedure Defer_Abort_Nestable (Self_ID : Task_ID) is\n+   procedure Defer_Abort_Nestable (Self_ID : Task_Id) is\n    begin\n       if No_Abort and then not Dynamic_Priority_Support then\n          return;\n@@ -261,7 +261,7 @@ package body System.Tasking.Initialization is\n    --------------------\n \n    procedure Defer_Abortion is\n-      Self_ID : Task_ID;\n+      Self_ID : Task_Id;\n \n    begin\n       if No_Abort and then not Dynamic_Priority_Support then\n@@ -278,7 +278,7 @@ package body System.Tasking.Initialization is\n \n    --  Call only when holding no locks\n \n-   procedure Do_Pending_Action (Self_ID : Task_ID) is\n+   procedure Do_Pending_Action (Self_ID : Task_Id) is\n       use type Ada.Exceptions.Exception_Id;\n \n    begin\n@@ -353,7 +353,7 @@ package body System.Tasking.Initialization is\n    --  not make any reference to the ATCB after the lock is released.\n    --  See also comments on Terminate_Task and Unlock.\n \n-   procedure Final_Task_Unlock (Self_ID : Task_ID) is\n+   procedure Final_Task_Unlock (Self_ID : Task_Id) is\n    begin\n       pragma Assert (Self_ID.Global_Task_Lock_Nesting = 1);\n       Unlock (Global_Task_Lock'Access, Global_Lock => True);\n@@ -364,7 +364,7 @@ package body System.Tasking.Initialization is\n    --------------\n \n    procedure Init_RTS is\n-      Self_Id : Task_ID;\n+      Self_Id : Task_Id;\n \n    begin\n       --  Terminate run time (regular vs restricted) specific initialization\n@@ -490,8 +490,8 @@ package body System.Tasking.Initialization is\n    --  for this case is done in Terminate_Task.\n \n    procedure Locked_Abort_To_Level\n-     (Self_ID : Task_ID;\n-      T       : Task_ID;\n+     (Self_ID : Task_Id;\n+      T       : Task_Id;\n       L       : ATC_Level)\n    is\n    begin\n@@ -590,7 +590,7 @@ package body System.Tasking.Initialization is\n    --  In this version, we check if the task is held too because\n    --  doing this only in Do_Pending_Action is not enough.\n \n-   procedure Poll_Base_Priority_Change (Self_ID : Task_ID) is\n+   procedure Poll_Base_Priority_Change (Self_ID : Task_Id) is\n    begin\n       if Dynamic_Priority_Support and then Self_ID.Pending_Priority_Change then\n \n@@ -636,9 +636,9 @@ package body System.Tasking.Initialization is\n    -- Remove_From_All_Tasks_List --\n    --------------------------------\n \n-   procedure Remove_From_All_Tasks_List (T : Task_ID) is\n-      C        : Task_ID;\n-      Previous : Task_ID;\n+   procedure Remove_From_All_Tasks_List (T : Task_Id) is\n+      C        : Task_Id;\n+      Previous : Task_Id;\n \n    begin\n       pragma Debug\n@@ -670,7 +670,7 @@ package body System.Tasking.Initialization is\n    -- Task_Lock --\n    ---------------\n \n-   procedure Task_Lock (Self_ID : Task_ID) is\n+   procedure Task_Lock (Self_ID : Task_Id) is\n    begin\n       Self_ID.Global_Task_Lock_Nesting := Self_ID.Global_Task_Lock_Nesting + 1;\n \n@@ -690,7 +690,7 @@ package body System.Tasking.Initialization is\n    ---------------\n \n    function Task_Name return String is\n-      Self_Id : constant Task_ID := STPO.Self;\n+      Self_Id : constant Task_Id := STPO.Self;\n \n    begin\n       return Self_Id.Common.Task_Image (1 .. Self_Id.Common.Task_Image_Len);\n@@ -700,7 +700,7 @@ package body System.Tasking.Initialization is\n    -- Task_Unlock --\n    -----------------\n \n-   procedure Task_Unlock (Self_ID : Task_ID) is\n+   procedure Task_Unlock (Self_ID : Task_Id) is\n    begin\n       pragma Assert (Self_ID.Global_Task_Lock_Nesting > 0);\n       Self_ID.Global_Task_Lock_Nesting := Self_ID.Global_Task_Lock_Nesting - 1;\n@@ -729,7 +729,7 @@ package body System.Tasking.Initialization is\n    --  The priority change has to occur before abortion. Otherwise, it would\n    --  take effect no earlier than the next abortion completion point.\n \n-   procedure Undefer_Abort (Self_ID : Task_ID) is\n+   procedure Undefer_Abort (Self_ID : Task_Id) is\n    begin\n       if No_Abort and then not Dynamic_Priority_Support then\n          return;\n@@ -765,7 +765,7 @@ package body System.Tasking.Initialization is\n    --  as entry to the scope of a region with a finalizer and entry into the\n    --  body of an accept-procedure.\n \n-   procedure Undefer_Abort_Nestable (Self_ID : Task_ID) is\n+   procedure Undefer_Abort_Nestable (Self_ID : Task_Id) is\n    begin\n       if No_Abort and then not Dynamic_Priority_Support then\n          return;\n@@ -793,7 +793,7 @@ package body System.Tasking.Initialization is\n    --  to reduce overhead due to multiple calls to Self.\n \n    procedure Undefer_Abortion is\n-      Self_ID : Task_ID;\n+      Self_ID : Task_Id;\n \n    begin\n       if No_Abort and then not Dynamic_Priority_Support then\n@@ -823,7 +823,7 @@ package body System.Tasking.Initialization is\n    procedure Update_Exception\n      (X : AE.Exception_Occurrence := Current_Target_Exception)\n    is\n-      Self_Id : constant Task_ID := Self;\n+      Self_Id : constant Task_Id := Self;\n       use Ada.Exceptions;\n \n    begin\n@@ -885,11 +885,11 @@ package body System.Tasking.Initialization is\n    --    if Entry_Call.State >= Was_Abortable.\n \n    procedure Wakeup_Entry_Caller\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link;\n       New_State  : Entry_Call_State)\n    is\n-      Caller : constant Task_ID := Entry_Call.Self;\n+      Caller : constant Task_Id := Entry_Call.Self;\n \n    begin\n       pragma Debug (Debug.Trace\n@@ -951,7 +951,7 @@ package body System.Tasking.Initialization is\n    end Get_Stack_Info;\n \n    procedure Set_Exc_Stack_Addr (Self_ID : Address; Addr : Address) is\n-      Me : Task_ID := To_Task_ID (Self_ID);\n+      Me : Task_Id := To_Task_Id (Self_ID);\n    begin\n       if Me = Null_Task then\n          Me := STPO.Self;\n@@ -989,14 +989,14 @@ package body System.Tasking.Initialization is\n    --  links will be redirected to the real subprogram by elaboration of\n    --  the subprogram body where the real subprogram is declared.\n \n-   procedure Finalize_Attributes (T : Task_ID) is\n+   procedure Finalize_Attributes (T : Task_Id) is\n       pragma Warnings (Off, T);\n \n    begin\n       null;\n    end Finalize_Attributes;\n \n-   procedure Initialize_Attributes (T : Task_ID) is\n+   procedure Initialize_Attributes (T : Task_Id) is\n       pragma Warnings (Off, T);\n \n    begin"}, {"sha": "e44072c4efd7e26d347be972dbd865e80a500e4c", "filename": "gcc/ada/s-tasini.ads", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasini.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasini.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,7 @@\n \n package System.Tasking.Initialization is\n \n-   procedure Remove_From_All_Tasks_List (T : Task_ID);\n+   procedure Remove_From_All_Tasks_List (T : Task_Id);\n    --  Remove T from All_Tasks_List.\n    --  Call this function with RTS_Lock taken.\n \n@@ -49,10 +49,10 @@ package System.Tasking.Initialization is\n    --  by the tasking run-time system.\n    --  So far, the only example is support for Ada.Task_Attributes.\n \n-   type Proc_T is access procedure (T : Task_ID);\n+   type Proc_T is access procedure (T : Task_Id);\n \n-   procedure Finalize_Attributes (T : Task_ID);\n-   procedure Initialize_Attributes (T : Task_ID);\n+   procedure Finalize_Attributes (T : Task_Id);\n+   procedure Initialize_Attributes (T : Task_Id);\n \n    Finalize_Attributes_Link : Proc_T := Finalize_Attributes'Access;\n    --  should be called with abortion deferred and T.L write-locked\n@@ -108,18 +108,18 @@ package System.Tasking.Initialization is\n \n    --  Non-nestable inline versions  --\n \n-   procedure Defer_Abort (Self_ID : Task_ID);\n+   procedure Defer_Abort (Self_ID : Task_Id);\n    pragma Inline (Defer_Abort);\n \n-   procedure Undefer_Abort (Self_ID : Task_ID);\n+   procedure Undefer_Abort (Self_ID : Task_Id);\n    pragma Inline (Undefer_Abort);\n \n    --  Nestable inline versions  --\n \n-   procedure Defer_Abort_Nestable (Self_ID : Task_ID);\n+   procedure Defer_Abort_Nestable (Self_ID : Task_Id);\n    pragma Inline (Defer_Abort_Nestable);\n \n-   procedure Undefer_Abort_Nestable (Self_ID : Task_ID);\n+   procedure Undefer_Abort_Nestable (Self_ID : Task_Id);\n    pragma Inline (Undefer_Abort_Nestable);\n \n    --  NON-INLINE versions without Self_ID for code generated by the\n@@ -139,12 +139,12 @@ package System.Tasking.Initialization is\n    --  Change Base Priority --\n    ---------------------------\n \n-   procedure Change_Base_Priority (T : Task_ID);\n+   procedure Change_Base_Priority (T : Task_Id);\n    --  Change the base priority of T.\n    --  Has to be called with the affected task's ATCB write-locked.\n    --  May temporariliy release the lock.\n \n-   procedure Poll_Base_Priority_Change (Self_ID : Task_ID);\n+   procedure Poll_Base_Priority_Change (Self_ID : Task_Id);\n    --  Has to be called with Self_ID's ATCB write-locked.\n    --  May temporariliy release the lock.\n    pragma Inline (Poll_Base_Priority_Change);\n@@ -153,15 +153,15 @@ package System.Tasking.Initialization is\n    -- Task Lock/Unlock --\n    ----------------------\n \n-   procedure Task_Lock (Self_ID : Task_ID);\n+   procedure Task_Lock (Self_ID : Task_Id);\n    pragma Inline (Task_Lock);\n \n-   procedure Task_Unlock (Self_ID : Task_ID);\n+   procedure Task_Unlock (Self_ID : Task_Id);\n    pragma Inline (Task_Unlock);\n    --  These are versions of Lock_Task and Unlock_Task created for use\n    --  within the GNARL.\n \n-   procedure Final_Task_Unlock (Self_ID : Task_ID);\n+   procedure Final_Task_Unlock (Self_ID : Task_Id);\n    --  This version is only for use in Terminate_Task, when the task\n    --  is relinquishing further rights to its own ATCB.\n    --  There is a very interesting potential race condition there, where\n@@ -171,7 +171,7 @@ package System.Tasking.Initialization is\n    --  See also comments on Terminate_Task and Unlock.\n \n    procedure Wakeup_Entry_Caller\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link;\n       New_State  : Entry_Call_State);\n    pragma Inline (Wakeup_Entry_Caller);\n@@ -195,8 +195,8 @@ package System.Tasking.Initialization is\n    --    if Entry_Call.State >= Was_Abortable.\n \n    procedure Locked_Abort_To_Level\n-     (Self_ID : Task_ID;\n-      T       : Task_ID;\n+     (Self_ID : Task_Id;\n+      T       : Task_Id;\n       L       : ATC_Level);\n    pragma Inline (Locked_Abort_To_Level);\n    --  Abort a task to a specified ATC level."}, {"sha": "f2ee75c0f13687a4caf914e91f3a3200b01e2a2d", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,28 +52,28 @@ package body System.Tasking is\n    package STPO renames System.Task_Primitives.Operations;\n \n    procedure Free is new\n-     Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+     Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n \n    ----------\n    -- Self --\n    ----------\n \n-   function Self return Task_ID renames STPO.Self;\n+   function Self return Task_Id renames STPO.Self;\n \n    ---------------------\n    -- Initialize_ATCB --\n    ---------------------\n \n    procedure Initialize_ATCB\n-     (Self_ID          : Task_ID;\n+     (Self_ID          : Task_Id;\n       Task_Entry_Point : Task_Procedure_Access;\n       Task_Arg         : System.Address;\n-      Parent           : Task_ID;\n+      Parent           : Task_Id;\n       Elaborated       : Access_Boolean;\n       Base_Priority    : System.Any_Priority;\n       Task_Info        : System.Task_Info.Task_Info_Type;\n       Stack_Size       : System.Parameters.Size_Type;\n-      T                : in out Task_ID;\n+      T                : in out Task_Id;\n       Success          : out Boolean) is\n    begin\n       T.Common.State := Unactivated;\n@@ -146,7 +146,7 @@ package body System.Tasking is\n \n begin\n    declare\n-      T             : Task_ID;\n+      T             : Task_Id;\n       Success       : Boolean;\n       Base_Priority : Any_Priority;\n "}, {"sha": "0e08ffd3981f857b907dc9201b2e48db5d0c9a4a", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -109,24 +109,24 @@ package System.Tasking is\n    --    the parent always has a lower serial number than the activator.\n \n    ---------------------------------\n-   -- Task_ID related definitions --\n+   -- Task_Id related definitions --\n    ---------------------------------\n \n    type Ada_Task_Control_Block;\n \n-   type Task_ID is access all Ada_Task_Control_Block;\n+   type Task_Id is access all Ada_Task_Control_Block;\n \n-   Null_Task : constant Task_ID;\n+   Null_Task : constant Task_Id;\n \n-   type Task_List is array (Positive range <>) of Task_ID;\n+   type Task_List is array (Positive range <>) of Task_Id;\n \n-   function Self return Task_ID;\n+   function Self return Task_Id;\n    pragma Inline (Self);\n    --  This is the compiler interface version of this function. Do not call\n    --  from the run-time system.\n \n-   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n-   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+   function To_Task_Id is new Unchecked_Conversion (System.Address, Task_Id);\n+   function To_Address is new Unchecked_Conversion (Task_Id, System.Address);\n \n    -----------------------\n    -- Enumeration types --\n@@ -301,7 +301,7 @@ package System.Tasking is\n    --      async. select statement does not need to lock anything.\n \n    type Restricted_Entry_Call_Record is record\n-      Self : Task_ID;\n+      Self : Task_Id;\n       --  ID of the caller\n \n       Mode : Call_Modes;\n@@ -388,7 +388,7 @@ package System.Tasking is\n       --  and whether it is terminated.\n       --  Protection: Self.L.\n \n-      Parent : Task_ID;\n+      Parent : Task_Id;\n       --  The task on which this task depends.\n       --  See also Master_Level and Master_Within.\n \n@@ -461,15 +461,15 @@ package System.Tasking is\n       --  per-task structures.\n       --  Protection: Only accessed by Self.\n \n-      All_Tasks_Link : Task_ID;\n+      All_Tasks_Link : Task_Id;\n       --  Used to link this task to the list of all tasks in the system.\n       --  Protection: RTS_Lock.\n \n-      Activation_Link : Task_ID;\n+      Activation_Link : Task_Id;\n       --  Used to link this task to a list of tasks to be activated.\n       --  Protection: Only used by Activator.\n \n-      Activator : Task_ID;\n+      Activator : Task_Id;\n       --  The task that created this task, either by declaring it as a task\n       --  object or by executing a task allocator.\n       --  The value is null iff Self has completed activation.\n@@ -542,16 +542,16 @@ package System.Tasking is\n    end record;\n    pragma Suppress_Initialization (Restricted_Ada_Task_Control_Block);\n \n-   Interrupt_Manager_ID : Task_ID;\n+   Interrupt_Manager_ID : Task_Id;\n    --  This task ID is declared here to break circular dependencies.\n-   --  Also declare Interrupt_Manager_ID after Task_ID is known, to avoid\n+   --  Also declare Interrupt_Manager_ID after Task_Id is known, to avoid\n    --  generating unneeded finalization code.\n \n    -----------------------\n    -- List of all Tasks --\n    -----------------------\n \n-   All_Tasks_List : Task_ID;\n+   All_Tasks_List : Task_Id;\n    --  Global linked list of all tasks.\n \n    ------------------------------------------\n@@ -633,7 +633,7 @@ package System.Tasking is\n    ----------------------------------\n \n    type Entry_Call_Record is record\n-      Self  : Task_ID;\n+      Self  : Task_Id;\n       --  ID of the caller\n \n       Mode : Call_Modes;\n@@ -679,7 +679,7 @@ package System.Tasking is\n       --  They are gathered together to allow for compilers that lay records\n       --  out contiguously, to allow for such packing.\n \n-      Called_Task : Task_ID;\n+      Called_Task : Task_Id;\n       pragma Atomic (Called_Task);\n       --  Use for task entry calls.\n       --  The value is null if the call record is not in use.\n@@ -953,25 +953,25 @@ package System.Tasking is\n    ---------------------\n \n    procedure Initialize_ATCB\n-     (Self_ID          : Task_ID;\n+     (Self_ID          : Task_Id;\n       Task_Entry_Point : Task_Procedure_Access;\n       Task_Arg         : System.Address;\n-      Parent           : Task_ID;\n+      Parent           : Task_Id;\n       Elaborated       : Access_Boolean;\n       Base_Priority    : System.Any_Priority;\n       Task_Info        : System.Task_Info.Task_Info_Type;\n       Stack_Size       : System.Parameters.Size_Type;\n-      T                : in out Task_ID;\n+      T                : in out Task_Id;\n       Success          : out Boolean);\n    --  Initialize fields of a TCB and link into global TCB structures\n    --  Call this only with abort deferred and holding RTS_Lock.\n \n private\n \n-   Null_Task : constant Task_ID := null;\n+   Null_Task : constant Task_Id := null;\n \n    type Activation_Chain is record\n-      T_ID : Task_ID;\n+      T_ID : Task_Id;\n    end record;\n    pragma Volatile (Activation_Chain);\n "}, {"sha": "5158b9c40444430de37d7a4b8a54d19040fc37a1", "filename": "gcc/ada/s-tasque.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasque.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasque.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasque.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,7 +60,7 @@ package body System.Tasking.Queuing is\n    Priority_Queuing : constant Boolean := Queuing_Policy = 'P';\n \n    procedure Send_Program_Error\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    --  Raise Program_Error in the caller of the specified entry call\n \n@@ -74,7 +74,7 @@ package body System.Tasking.Queuing is\n    -----------------------------\n \n    procedure Broadcast_Program_Error\n-     (Self_ID      : Task_ID;\n+     (Self_ID      : Task_Id;\n       Object       : Protection_Entries_Access;\n       Pending_Call : Entry_Call_Link;\n       RTS_Locked   : Boolean := False)\n@@ -469,7 +469,7 @@ package body System.Tasking.Queuing is\n    --  queuing policy being used.\n \n    procedure Select_Protected_Entry_Call\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Object  : Protection_Entries_Access;\n       Call    : out Entry_Call_Link)\n    is\n@@ -547,7 +547,7 @@ package body System.Tasking.Queuing is\n    --  being used.\n \n    procedure Select_Task_Entry_Call\n-     (Acceptor         : Task_ID;\n+     (Acceptor         : Task_Id;\n       Open_Accepts     : Accept_List_Access;\n       Call             : out Entry_Call_Link;\n       Selection        : out Select_Index;\n@@ -618,10 +618,10 @@ package body System.Tasking.Queuing is\n    ------------------------\n \n    procedure Send_Program_Error\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link)\n    is\n-      Caller : Task_ID;\n+      Caller : Task_Id;\n    begin\n       Caller := Entry_Call.Self;\n       Entry_Call.Exception_To_Raise := Program_Error'Identity;"}, {"sha": "170a2972373ce2bdf4f75127a33997c0cd927c66", "filename": "gcc/ada/s-tasque.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasque.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasque.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasque.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---         Copyright (C) 1992-2001, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,7 @@ package System.Tasking.Queuing is\n    package POE renames System.Tasking.Protected_Objects.Entries;\n \n    procedure Broadcast_Program_Error\n-     (Self_ID      : Task_ID;\n+     (Self_ID      : Task_Id;\n       Object       : POE.Protection_Entries_Access;\n       Pending_Call : Entry_Call_Link;\n       RTS_Locked   : Boolean := False);\n@@ -71,7 +71,7 @@ package System.Tasking.Queuing is\n    --  Return number of calls on the waiting queue of E\n \n    procedure Select_Task_Entry_Call\n-     (Acceptor         : Task_ID;\n+     (Acceptor         : Task_Id;\n       Open_Accepts     : Accept_List_Access;\n       Call             : out Entry_Call_Link;\n       Selection        : out Select_Index;\n@@ -82,7 +82,7 @@ package System.Tasking.Queuing is\n    --    Open_Alternative will be True if there were any open alternatives\n \n    procedure Select_Protected_Entry_Call\n-     (Self_ID   : Task_ID;\n+     (Self_ID   : Task_Id;\n       Object    : POE.Protection_Entries_Access;\n       Call      : out Entry_Call_Link);\n    --  Select an entry of a protected object"}, {"sha": "75eecc6755ac0b02aabdc4e38bb24076327da293", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -130,10 +130,10 @@ package body System.Tasking.Rendezvous is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Local_Defer_Abort (Self_Id : Task_ID) renames\n+   procedure Local_Defer_Abort (Self_Id : Task_Id) renames\n      System.Tasking.Initialization.Defer_Abort_Nestable;\n \n-   procedure Local_Undefer_Abort (Self_Id : Task_ID) renames\n+   procedure Local_Undefer_Abort (Self_Id : Task_Id) renames\n      System.Tasking.Initialization.Undefer_Abort_Nestable;\n \n    --  Florist defers abort around critical sections that\n@@ -147,12 +147,12 @@ package body System.Tasking.Rendezvous is\n    --  an earlier abort deferral. Thus, for debugging it may be\n    --  wise to modify the above renamings to the non-nestable forms.\n \n-   procedure Boost_Priority (Call : Entry_Call_Link; Acceptor : Task_ID);\n+   procedure Boost_Priority (Call : Entry_Call_Link; Acceptor : Task_Id);\n    pragma Inline (Boost_Priority);\n    --  Call this only with abort deferred and holding lock of Acceptor.\n \n    procedure Call_Synchronous\n-     (Acceptor              : Task_ID;\n+     (Acceptor              : Task_Id;\n       E                     : Task_Entry_Index;\n       Uninterpreted_Data    : System.Address;\n       Mode                  : Call_Modes;\n@@ -163,15 +163,15 @@ package body System.Tasking.Rendezvous is\n \n    procedure Setup_For_Rendezvous_With_Body\n      (Entry_Call : Entry_Call_Link;\n-      Acceptor   : Task_ID);\n+      Acceptor   : Task_Id);\n    pragma Inline (Setup_For_Rendezvous_With_Body);\n    --  Call this only with abort deferred and holding lock of Acceptor.\n    --  When a rendezvous selected (ready for rendezvous) we need to save\n    --  previous caller and adjust the priority. Also we need to make\n    --  this call not Abortable (Cancellable) since the rendezvous has\n    --  already been started.\n \n-   procedure Wait_For_Call (Self_Id : Task_ID);\n+   procedure Wait_For_Call (Self_Id : Task_Id);\n    pragma Inline (Wait_For_Call);\n    --  Call this only with abort deferred and holding lock of Self_Id.\n    --  An accepting task goes into Sleep by calling this routine\n@@ -186,8 +186,8 @@ package body System.Tasking.Rendezvous is\n      (E                  : Task_Entry_Index;\n       Uninterpreted_Data : out System.Address)\n    is\n-      Self_Id      : constant Task_ID := STPO.Self;\n-      Caller       : Task_ID := null;\n+      Self_Id      : constant Task_Id := STPO.Self;\n+      Caller       : Task_Id := null;\n       Open_Accepts : aliased Accept_List (1 .. 1);\n       Entry_Call   : Entry_Call_Link;\n \n@@ -277,8 +277,8 @@ package body System.Tasking.Rendezvous is\n    --------------------\n \n    procedure Accept_Trivial (E : Task_Entry_Index) is\n-      Self_Id      : constant Task_ID := STPO.Self;\n-      Caller       : Task_ID := null;\n+      Self_Id      : constant Task_Id := STPO.Self;\n+      Caller       : Task_Id := null;\n       Open_Accepts : aliased Accept_List (1 .. 1);\n       Entry_Call   : Entry_Call_Link;\n \n@@ -366,8 +366,8 @@ package body System.Tasking.Rendezvous is\n    -- Boost_Priority --\n    --------------------\n \n-   procedure Boost_Priority (Call : Entry_Call_Link; Acceptor : Task_ID) is\n-      Caller        : constant Task_ID := Call.Self;\n+   procedure Boost_Priority (Call : Entry_Call_Link; Acceptor : Task_Id) is\n+      Caller        : constant Task_Id := Call.Self;\n       Caller_Prio   : constant System.Any_Priority := Get_Priority (Caller);\n       Acceptor_Prio : constant System.Any_Priority := Get_Priority (Acceptor);\n \n@@ -386,7 +386,7 @@ package body System.Tasking.Rendezvous is\n    -----------------\n \n    procedure Call_Simple\n-     (Acceptor           : Task_ID;\n+     (Acceptor           : Task_Id;\n       E                  : Task_Entry_Index;\n       Uninterpreted_Data : System.Address)\n    is\n@@ -401,13 +401,13 @@ package body System.Tasking.Rendezvous is\n    ----------------------\n \n    procedure Call_Synchronous\n-     (Acceptor              : Task_ID;\n+     (Acceptor              : Task_Id;\n       E                     : Task_Entry_Index;\n       Uninterpreted_Data    : System.Address;\n       Mode                  : Call_Modes;\n       Rendezvous_Successful : out Boolean)\n    is\n-      Self_Id    : constant Task_ID := STPO.Self;\n+      Self_Id    : constant Task_Id := STPO.Self;\n       Level      : ATC_Level;\n       Entry_Call : Entry_Call_Link;\n \n@@ -490,9 +490,9 @@ package body System.Tasking.Rendezvous is\n    -- Callable --\n    --------------\n \n-   function Callable (T : Task_ID) return Boolean is\n+   function Callable (T : Task_Id) return Boolean is\n       Result  : Boolean;\n-      Self_Id : constant Task_ID := STPO.Self;\n+      Self_Id : constant Task_Id := STPO.Self;\n \n    begin\n       Initialization.Defer_Abort (Self_Id);\n@@ -538,9 +538,9 @@ package body System.Tasking.Rendezvous is\n    procedure Exceptional_Complete_Rendezvous\n      (Ex : Ada.Exceptions.Exception_Id)\n    is\n-      Self_Id    : constant Task_ID := STPO.Self;\n+      Self_Id    : constant Task_Id := STPO.Self;\n       Entry_Call : Entry_Call_Link := Self_Id.Common.Call;\n-      Caller     : Task_ID;\n+      Caller     : Task_Id;\n       Called_PO  : STPE.Protection_Entries_Access;\n \n       Exception_To_Raise : Ada.Exceptions.Exception_Id := Ex;\n@@ -732,7 +732,7 @@ package body System.Tasking.Rendezvous is\n \n    procedure Requeue_Protected_To_Task_Entry\n      (Object     : STPE.Protection_Entries_Access;\n-      Acceptor   : Task_ID;\n+      Acceptor   : Task_Id;\n       E          : Task_Entry_Index;\n       With_Abort : Boolean)\n    is\n@@ -752,11 +752,11 @@ package body System.Tasking.Rendezvous is\n    ------------------------\n \n    procedure Requeue_Task_Entry\n-     (Acceptor   : Task_ID;\n+     (Acceptor   : Task_Id;\n       E          : Task_Entry_Index;\n       With_Abort : Boolean)\n    is\n-      Self_Id    : constant Task_ID := STPO.Self;\n+      Self_Id    : constant Task_Id := STPO.Self;\n       Entry_Call : constant Entry_Call_Link := Self_Id.Common.Call;\n \n    begin\n@@ -778,10 +778,10 @@ package body System.Tasking.Rendezvous is\n       Uninterpreted_Data : out System.Address;\n       Index              : out Select_Index)\n    is\n-      Self_Id          : constant Task_ID := STPO.Self;\n+      Self_Id          : constant Task_Id := STPO.Self;\n       Entry_Call       : Entry_Call_Link;\n       Treatment        : Select_Treatment;\n-      Caller           : Task_ID;\n+      Caller           : Task_Id;\n       Selection        : Select_Index;\n       Open_Alternative : Boolean;\n \n@@ -1035,7 +1035,7 @@ package body System.Tasking.Rendezvous is\n \n    procedure Setup_For_Rendezvous_With_Body\n      (Entry_Call : Entry_Call_Link;\n-      Acceptor   : Task_ID) is\n+      Acceptor   : Task_Id) is\n    begin\n       Entry_Call.Acceptor_Prev_Call := Acceptor.Common.Call;\n       Acceptor.Common.Call := Entry_Call;\n@@ -1052,7 +1052,7 @@ package body System.Tasking.Rendezvous is\n    ----------------\n \n    function Task_Count (E : Task_Entry_Index) return Natural is\n-      Self_Id      : constant Task_ID := STPO.Self;\n+      Self_Id      : constant Task_Id := STPO.Self;\n       Return_Count : Natural;\n \n    begin\n@@ -1079,15 +1079,15 @@ package body System.Tasking.Rendezvous is\n    ----------------------\n \n    function Task_Do_Or_Queue\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean) return Boolean\n    is\n       E             : constant Task_Entry_Index :=\n         Task_Entry_Index (Entry_Call.E);\n       Old_State     : constant Entry_Call_State := Entry_Call.State;\n-      Acceptor      : constant Task_ID := Entry_Call.Called_Task;\n-      Parent        : constant Task_ID := Acceptor.Common.Parent;\n+      Acceptor      : constant Task_Id := Entry_Call.Called_Task;\n+      Parent        : constant Task_Id := Acceptor.Common.Parent;\n       Parent_Locked : Boolean := False;\n       Null_Body     : Boolean;\n \n@@ -1299,13 +1299,13 @@ package body System.Tasking.Rendezvous is\n    ---------------------\n \n    procedure Task_Entry_Call\n-     (Acceptor              : Task_ID;\n+     (Acceptor              : Task_Id;\n       E                     : Task_Entry_Index;\n       Uninterpreted_Data    : System.Address;\n       Mode                  : Call_Modes;\n       Rendezvous_Successful : out Boolean)\n    is\n-      Self_Id    : constant Task_ID := STPO.Self;\n+      Self_Id    : constant Task_Id := STPO.Self;\n       Entry_Call : Entry_Call_Link;\n \n    begin\n@@ -1391,8 +1391,8 @@ package body System.Tasking.Rendezvous is\n    -- Task_Entry_Caller --\n    -----------------------\n \n-   function Task_Entry_Caller (D : Task_Entry_Nesting_Depth) return Task_ID is\n-      Self_Id    : constant Task_ID := STPO.Self;\n+   function Task_Entry_Caller (D : Task_Entry_Nesting_Depth) return Task_Id is\n+      Self_Id    : constant Task_Id := STPO.Self;\n       Entry_Call : Entry_Call_Link;\n \n    begin\n@@ -1418,10 +1418,10 @@ package body System.Tasking.Rendezvous is\n       Mode               : Delay_Modes;\n       Index              : out Select_Index)\n    is\n-      Self_Id          : constant Task_ID := STPO.Self;\n+      Self_Id          : constant Task_Id := STPO.Self;\n       Treatment        : Select_Treatment;\n       Entry_Call       : Entry_Call_Link;\n-      Caller           : Task_ID;\n+      Caller           : Task_Id;\n       Selection        : Select_Index;\n       Open_Alternative : Boolean;\n       Timedout         : Boolean := False;\n@@ -1655,14 +1655,14 @@ package body System.Tasking.Rendezvous is\n    ---------------------------\n \n    procedure Timed_Task_Entry_Call\n-     (Acceptor              : Task_ID;\n+     (Acceptor              : Task_Id;\n       E                     : Task_Entry_Index;\n       Uninterpreted_Data    : System.Address;\n       Timeout               : Duration;\n       Mode                  : Delay_Modes;\n       Rendezvous_Successful : out Boolean)\n    is\n-      Self_Id    : constant Task_ID := STPO.Self;\n+      Self_Id    : constant Task_Id := STPO.Self;\n       Level      : ATC_Level;\n       Entry_Call : Entry_Call_Link;\n       Yielded    : Boolean;\n@@ -1747,7 +1747,7 @@ package body System.Tasking.Rendezvous is\n    -- Wait_For_Call --\n    -------------------\n \n-   procedure Wait_For_Call (Self_Id : Task_ID) is\n+   procedure Wait_For_Call (Self_Id : Task_Id) is\n    begin\n       --  Try to remove calls to Sleep in the loop below by letting the caller\n       --  a chance of getting ready immediately, using Unlock & Yield."}, {"sha": "4b82bb3ff679cd9be01593bdc565cd90addddf5a", "filename": "gcc/ada/s-tasren.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasren.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasren.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,7 +45,7 @@ package System.Tasking.Rendezvous is\n    package STPE renames System.Tasking.Protected_Objects.Entries;\n \n    procedure Task_Entry_Call\n-     (Acceptor              : Task_ID;\n+     (Acceptor              : Task_Id;\n       E                     : Task_Entry_Index;\n       Uninterpreted_Data    : System.Address;\n       Mode                  : Call_Modes;\n@@ -61,7 +61,7 @@ package System.Tasking.Rendezvous is\n    --  Rendezvous_Successful is set to True on return if the call was serviced.\n \n    procedure Timed_Task_Entry_Call\n-     (Acceptor              : Task_ID;\n+     (Acceptor              : Task_Id;\n       E                     : Task_Entry_Index;\n       Uninterpreted_Data    : System.Address;\n       Timeout               : Duration;\n@@ -74,7 +74,7 @@ package System.Tasking.Rendezvous is\n    --  Mode determines whether the delay is relative or absolute.\n \n    procedure Call_Simple\n-     (Acceptor           : Task_ID;\n+     (Acceptor           : Task_Id;\n       E                  : Task_Entry_Index;\n       Uninterpreted_Data : System.Address);\n    --  Simple entry call.\n@@ -100,7 +100,7 @@ package System.Tasking.Rendezvous is\n    --  See Exp_Ch9.Expand_N_Asynchronous_Select for code expansion.\n \n    procedure Requeue_Task_Entry\n-     (Acceptor   : Task_ID;\n+     (Acceptor   : Task_Id;\n       E          : Task_Entry_Index;\n       With_Abort : Boolean);\n    --  Requeue from a task entry to a task entry.\n@@ -136,7 +136,7 @@ package System.Tasking.Rendezvous is\n \n    procedure Requeue_Protected_To_Task_Entry\n      (Object     : STPE.Protection_Entries_Access;\n-      Acceptor   : Task_ID;\n+      Acceptor   : Task_Id;\n       E          : Task_Entry_Index;\n       With_Abort : Boolean);\n    --  Requeue from a protected entry to a task entry.\n@@ -294,15 +294,15 @@ package System.Tasking.Rendezvous is\n    --  Return number of tasks waiting on the entry E (of current task)\n    --  Compiler interface only. Do not call from within the RTS.\n \n-   function Callable (T : Task_ID) return Boolean;\n+   function Callable (T : Task_Id) return Boolean;\n    --  Return T'Callable\n    --  Compiler interface. Do not call from within the RTS, except for body of\n    --  Ada.Task_Identification.\n \n    type Task_Entry_Nesting_Depth is new Task_Entry_Index\n      range 0 .. Max_Task_Entry;\n \n-   function Task_Entry_Caller (D : Task_Entry_Nesting_Depth) return Task_ID;\n+   function Task_Entry_Caller (D : Task_Entry_Nesting_Depth) return Task_Id;\n    --  Return E'Caller. This will only work if called from within an\n    --  accept statement that is handling E, as required by the LRM (C.7.1(14)).\n    --  Compiler interface only. Do not call from within the RTS.\n@@ -318,7 +318,7 @@ package System.Tasking.Rendezvous is\n    --  For internal use only:\n \n    function Task_Do_Or_Queue\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean) return Boolean;\n    --  Call this only with abort deferred and holding no locks, except"}, {"sha": "e3b4c951b3a7962aaf263eb4cda38319a585b335", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -130,40 +130,40 @@ package body System.Tasking.Stages is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_ID);\n+   procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_Id);\n    --  This procedure outputs the task specific message for exception\n    --  tracing purposes.\n \n-   procedure Task_Wrapper (Self_ID : Task_ID);\n+   procedure Task_Wrapper (Self_ID : Task_Id);\n    --  This is the procedure that is called by the GNULL from the\n    --  new context when a task is created. It waits for activation\n    --  and then calls the task body procedure. When the task body\n    --  procedure completes, it terminates the task.\n \n-   procedure Vulnerable_Complete_Task (Self_ID : Task_ID);\n+   procedure Vulnerable_Complete_Task (Self_ID : Task_Id);\n    --  Complete the calling task.\n    --  This procedure must be called with abort deferred.\n    --  It should only be called by Complete_Task and\n    --  Finalizate_Global_Tasks (for the environment task).\n \n-   procedure Vulnerable_Complete_Master (Self_ID : Task_ID);\n+   procedure Vulnerable_Complete_Master (Self_ID : Task_Id);\n    --  Complete the current master of the calling task.\n    --  This procedure must be called with abort deferred.\n    --  It should only be called by Vulnerable_Complete_Task and\n    --  Complete_Master.\n \n-   procedure Vulnerable_Complete_Activation (Self_ID : Task_ID);\n+   procedure Vulnerable_Complete_Activation (Self_ID : Task_Id);\n    --  Signal to Self_ID's activator that Self_ID has\n    --  completed activation.\n    --\n    --  Call this procedure with abort deferred.\n \n-   procedure Abort_Dependents (Self_ID : Task_ID);\n+   procedure Abort_Dependents (Self_ID : Task_Id);\n    --  Abort all the direct dependents of Self at its current master\n    --  nesting level, plus all of their dependents, transitively.\n    --  RTS_Lock should be locked by the caller.\n \n-   procedure Vulnerable_Free_Task (T : Task_ID);\n+   procedure Vulnerable_Free_Task (T : Task_Id);\n    --  Recover all runtime system storage associated with the task T.\n    --  This should only be called after T has terminated and will no\n    --  longer be referenced.\n@@ -181,9 +181,9 @@ package body System.Tasking.Stages is\n    -- Abort_Dependents --\n    ----------------------\n \n-   procedure Abort_Dependents (Self_ID : Task_ID) is\n-      C : Task_ID;\n-      P : Task_ID;\n+   procedure Abort_Dependents (Self_ID : Task_Id) is\n+      C : Task_Id;\n+      P : Task_Id;\n \n    begin\n       C := All_Tasks_List;\n@@ -251,10 +251,10 @@ package body System.Tasking.Stages is\n    --  operation is done in a separate pass over the activation chain.\n \n    procedure Activate_Tasks (Chain_Access : Activation_Chain_Access) is\n-      Self_ID        : constant Task_ID := STPO.Self;\n-      P              : Task_ID;\n-      C              : Task_ID;\n-      Next_C, Last_C : Task_ID;\n+      Self_ID        : constant Task_Id := STPO.Self;\n+      P              : Task_Id;\n+      C              : Task_Id;\n+      Next_C, Last_C : Task_Id;\n       Activate_Prio  : System.Any_Priority;\n       Success        : Boolean;\n       All_Elaborated : Boolean := True;\n@@ -426,7 +426,7 @@ package body System.Tasking.Stages is\n    -------------------------\n \n    procedure Complete_Activation is\n-      Self_ID : constant Task_ID := STPO.Self;\n+      Self_ID : constant Task_Id := STPO.Self;\n    begin\n       Initialization.Defer_Abort_Nestable (Self_ID);\n \n@@ -455,7 +455,7 @@ package body System.Tasking.Stages is\n    ---------------------\n \n    procedure Complete_Master is\n-      Self_ID : constant Task_ID := STPO.Self;\n+      Self_ID : constant Task_Id := STPO.Self;\n \n    begin\n       pragma Assert (Self_ID.Deferral_Level > 0);\n@@ -470,7 +470,7 @@ package body System.Tasking.Stages is\n    --  See comments on Vulnerable_Complete_Task for details\n \n    procedure Complete_Task is\n-      Self_ID  : constant Task_ID := STPO.Self;\n+      Self_ID  : constant Task_Id := STPO.Self;\n    begin\n       pragma Assert (Self_ID.Deferral_Level > 0);\n \n@@ -498,10 +498,10 @@ package body System.Tasking.Stages is\n       Elaborated    : Access_Boolean;\n       Chain         : in out Activation_Chain;\n       Task_Image    : String;\n-      Created_Task  : out Task_ID)\n+      Created_Task  : out Task_Id)\n    is\n-      T, P          : Task_ID;\n-      Self_ID       : constant Task_ID := STPO.Self;\n+      T, P          : Task_Id;\n+      Self_ID       : constant Task_Id := STPO.Self;\n       Success       : Boolean;\n       Base_Priority : System.Any_Priority;\n       Len           : Natural;\n@@ -639,7 +639,7 @@ package body System.Tasking.Stages is\n    ------------------\n \n    procedure Enter_Master is\n-      Self_ID : constant Task_ID := STPO.Self;\n+      Self_ID : constant Task_Id := STPO.Self;\n \n    begin\n       Self_ID.Master_Within := Self_ID.Master_Within + 1;\n@@ -652,10 +652,10 @@ package body System.Tasking.Stages is\n    --  See procedure Close_Entries for the general case.\n \n    procedure Expunge_Unactivated_Tasks (Chain : in out Activation_Chain) is\n-      Self_ID : constant Task_ID := STPO.Self;\n-      C       : Task_ID;\n+      Self_ID : constant Task_Id := STPO.Self;\n+      C       : Task_Id;\n       Call    : Entry_Call_Link;\n-      Temp    : Task_ID;\n+      Temp    : Task_Id;\n \n    begin\n       pragma Debug\n@@ -714,7 +714,7 @@ package body System.Tasking.Stages is\n    --  using the global finalization chain.\n \n    procedure Finalize_Global_Tasks is\n-      Self_ID : constant Task_ID := STPO.Self;\n+      Self_ID : constant Task_Id := STPO.Self;\n       Ignore  : Boolean;\n \n    begin\n@@ -813,8 +813,8 @@ package body System.Tasking.Stages is\n    -- Free_Task --\n    ---------------\n \n-   procedure Free_Task (T : Task_ID) is\n-      Self_Id : constant Task_ID := Self;\n+   procedure Free_Task (T : Task_Id) is\n+      Self_Id : constant Task_Id := Self;\n \n    begin\n       if T.Common.State = Terminated then\n@@ -851,7 +851,7 @@ package body System.Tasking.Stages is\n    --  data. Task finalization is done by Complete_Task, which is called from\n    --  an at-end handler that the compiler generates.\n \n-   procedure Task_Wrapper (Self_ID : Task_ID) is\n+   procedure Task_Wrapper (Self_ID : Task_Id) is\n       use type System.Parameters.Size_Type;\n       use type SSE.Storage_Offset;\n       use System.Standard_Library;\n@@ -973,8 +973,8 @@ package body System.Tasking.Stages is\n    --  overwriting the data of the new task that reused the ATCB! To solve\n    --  this problem, we introduced the new operation Final_Task_Unlock.\n \n-   procedure Terminate_Task (Self_ID : Task_ID) is\n-      Environment_Task : constant Task_ID := STPO.Environment_Task;\n+   procedure Terminate_Task (Self_ID : Task_Id) is\n+      Environment_Task : constant Task_Id := STPO.Environment_Task;\n       Master_of_Task   : Integer;\n \n    begin\n@@ -1045,8 +1045,8 @@ package body System.Tasking.Stages is\n    -- Terminated --\n    ----------------\n \n-   function Terminated (T : Task_ID) return Boolean is\n-      Self_ID : constant Task_ID := STPO.Self;\n+   function Terminated (T : Task_Id) return Boolean is\n+      Self_ID : constant Task_Id := STPO.Self;\n       Result  : Boolean;\n \n    begin\n@@ -1072,7 +1072,7 @@ package body System.Tasking.Stages is\n    -- Trace_Unhandled_Exception_In_Task --\n    ----------------------------------------\n \n-   procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_ID) is\n+   procedure Trace_Unhandled_Exception_In_Task (Self_Id : Task_Id) is\n       procedure To_Stderr (S : String);\n       pragma Import (Ada, To_Stderr, \"__gnat_to_stderr\");\n \n@@ -1081,7 +1081,7 @@ package body System.Tasking.Stages is\n       use System.Standard_Library;\n \n       function To_Address is new\n-        Unchecked_Conversion (Task_ID, System.Address);\n+        Unchecked_Conversion (Task_Id, System.Address);\n \n       function Tailored_Exception_Information\n         (E : Exception_Occurrence) return String;\n@@ -1121,8 +1121,8 @@ package body System.Tasking.Stages is\n    --  ordering policy, since the activated task must be created after the\n    --  activator.\n \n-   procedure Vulnerable_Complete_Activation (Self_ID : Task_ID) is\n-      Activator : constant Task_ID := Self_ID.Common.Activator;\n+   procedure Vulnerable_Complete_Activation (Self_ID : Task_Id) is\n+      Activator : constant Task_Id := Self_ID.Common.Activator;\n \n    begin\n       pragma Debug (Debug.Trace (Self_ID, \"V_Complete_Activation\", 'C'));\n@@ -1175,13 +1175,13 @@ package body System.Tasking.Stages is\n    -- Vulnerable_Complete_Master --\n    --------------------------------\n \n-   procedure Vulnerable_Complete_Master (Self_ID : Task_ID) is\n-      C      : Task_ID;\n-      P      : Task_ID;\n+   procedure Vulnerable_Complete_Master (Self_ID : Task_Id) is\n+      C      : Task_Id;\n+      P      : Task_Id;\n       CM     : constant Master_Level := Self_ID.Master_Within;\n-      T      : aliased Task_ID;\n+      T      : aliased Task_Id;\n \n-      To_Be_Freed : Task_ID;\n+      To_Be_Freed : Task_Id;\n       --  This is a list of ATCBs to be freed, after we have released\n       --  all RTS locks. This is necessary because of the locking order\n       --  rules, since the storage manager uses Global_Task_Lock.\n@@ -1478,7 +1478,7 @@ package body System.Tasking.Stages is\n                --  Be sure to update this value when changing\n                --  Interrupt_Manager specs.\n \n-               type Param_Type is access all Task_ID;\n+               type Param_Type is access all Task_Id;\n \n                Param : aliased Param_Type := T'Access;\n \n@@ -1546,7 +1546,7 @@ package body System.Tasking.Stages is\n    --  to test Self_ID.Common.Activator. That value should only be read and\n    --  modified by Self.\n \n-   procedure Vulnerable_Complete_Task (Self_ID : Task_ID) is\n+   procedure Vulnerable_Complete_Task (Self_ID : Task_Id) is\n    begin\n       pragma Assert (Self_ID.Deferral_Level > 0);\n       pragma Assert (Self_ID = Self);\n@@ -1607,7 +1607,7 @@ package body System.Tasking.Stages is\n    --  It is also called from Unchecked_Deallocation, for objects that\n    --  are or contain tasks.\n \n-   procedure Vulnerable_Free_Task (T : Task_ID) is\n+   procedure Vulnerable_Free_Task (T : Task_Id) is\n    begin\n       pragma Debug (Debug.Trace (Self, \"Vulnerable_Free_Task\", 'C', T));\n "}, {"sha": "ba9ab044c77e9fb691ec512d1caff7ea45807308", "filename": "gcc/ada/s-tassta.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tassta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tassta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -177,7 +177,7 @@ package System.Tasking.Stages is\n       Elaborated    : Access_Boolean;\n       Chain         : in out Activation_Chain;\n       Task_Image    : String;\n-      Created_Task  : out Task_ID);\n+      Created_Task  : out Task_Id);\n    --  Compiler interface only. Do not call from within the RTS.\n    --  This must be called to create a new task.\n    --\n@@ -250,12 +250,12 @@ package System.Tasking.Stages is\n    --  It currently also executes the global finalization list, and then resets\n    --  the \"soft links\".\n \n-   procedure Free_Task (T : Task_ID);\n+   procedure Free_Task (T : Task_Id);\n    --  Recover all runtime system storage associated with the task T, but only\n    --  if T has terminated. Do nothing in the other case. It is called from\n    --  Unchecked_Deallocation, for objects that are or contain tasks.\n \n-   function Terminated (T : Task_ID) return Boolean;\n+   function Terminated (T : Task_Id) return Boolean;\n    --  This is called by the compiler to implement the 'Terminated attribute.\n    --  Though is not required to be so by the ARM, we choose to synchronize\n    --  with the task's ATCB, so that this is more useful for polling the state\n@@ -268,7 +268,7 @@ package System.Tasking.Stages is\n    --  code expansion:\n    --     terminated (t1._task_id)\n \n-   procedure Terminate_Task (Self_ID : Task_ID);\n+   procedure Terminate_Task (Self_ID : Task_Id);\n    --  Terminate the calling task.\n    --  This should only be called by the Task_Wrapper procedure, and to\n    --  deallocate storage associate with foreign tasks."}, {"sha": "47ba6665570da5152f3e0836b4e3e068c52b5ccb", "filename": "gcc/ada/s-tasuti.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasuti.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -92,7 +92,7 @@ package body System.Tasking.Utilities is\n    --    (2) may be called for tasks that have not yet been activated\n    --    (3) always aborts whole task\n \n-   procedure Abort_One_Task (Self_ID : Task_ID; T : Task_ID) is\n+   procedure Abort_One_Task (Self_ID : Task_Id; T : Task_Id) is\n    begin\n       if Parameters.Runtime_Traces then\n          Send_Trace_Info (T_Abort, Self_ID, T);\n@@ -126,9 +126,9 @@ package body System.Tasking.Utilities is\n    --  Abort_Signal special exception.\n \n    procedure Abort_Tasks (Tasks : Task_List) is\n-      Self_Id : constant Task_ID := STPO.Self;\n-      C       : Task_ID;\n-      P       : Task_ID;\n+      Self_Id : constant Task_Id := STPO.Self;\n+      C       : Task_Id;\n+      P       : Task_Id;\n \n    begin\n       Initialization.Defer_Abort_Nestable (Self_Id);\n@@ -178,12 +178,12 @@ package body System.Tasking.Utilities is\n    --  This should only be called by T, unless T is a terminated previously\n    --  unactivated task.\n \n-   procedure Cancel_Queued_Entry_Calls (T : Task_ID) is\n+   procedure Cancel_Queued_Entry_Calls (T : Task_Id) is\n       Next_Entry_Call : Entry_Call_Link;\n       Entry_Call      : Entry_Call_Link;\n-      Self_Id         : constant Task_ID := STPO.Self;\n+      Self_Id         : constant Task_Id := STPO.Self;\n \n-      Caller : Task_ID;\n+      Caller : Task_Id;\n       pragma Unreferenced (Caller);\n       --  Should this be removed ???\n \n@@ -230,7 +230,7 @@ package body System.Tasking.Utilities is\n    --  In any case, reset Self_Id.Aborting, to allow re-raising of\n    --  Abort_Signal.\n \n-   procedure Exit_One_ATC_Level (Self_ID : Task_ID) is\n+   procedure Exit_One_ATC_Level (Self_ID : Task_Id) is\n    begin\n       Self_ID.ATC_Nesting_Level := Self_ID.ATC_Nesting_Level - 1;\n \n@@ -263,9 +263,9 @@ package body System.Tasking.Utilities is\n    ----------------------\n \n    procedure Make_Independent is\n-      Self_Id               : constant Task_ID := STPO.Self;\n-      Environment_Task      : constant Task_ID := STPO.Environment_Task;\n-      Parent                : constant Task_ID := Self_Id.Common.Parent;\n+      Self_Id               : constant Task_Id := STPO.Self;\n+      Environment_Task      : constant Task_Id := STPO.Environment_Task;\n+      Parent                : constant Task_Id := Self_Id.Common.Parent;\n       Parent_Needs_Updating : Boolean := False;\n       Master_of_Task        : Integer;\n \n@@ -347,9 +347,9 @@ package body System.Tasking.Utilities is\n    -- Make_Passive --\n    ------------------\n \n-   procedure Make_Passive (Self_ID : Task_ID; Task_Completed : Boolean) is\n-      C : Task_ID := Self_ID;\n-      P : Task_ID := C.Common.Parent;\n+   procedure Make_Passive (Self_ID : Task_Id; Task_Completed : Boolean) is\n+      C : Task_Id := Self_ID;\n+      P : Task_Id := C.Common.Parent;\n \n       Master_Completion_Phase : Integer;\n "}, {"sha": "8a4708a6c95cbe01fb992a150942a5f86eb6fe0f", "filename": "gcc/ada/s-tasuti.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tasuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasuti.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,7 @@ with Unchecked_Conversion;\n package System.Tasking.Utilities is\n \n    function ATCB_To_Address is new\n-     Unchecked_Conversion (Task_ID, System.Address);\n+     Unchecked_Conversion (Task_Id, System.Address);\n \n    ---------------------------------\n    -- Task_Stage Related routines --\n@@ -76,17 +76,17 @@ package System.Tasking.Utilities is\n    -- Task Abortion related routines --\n    ------------------------------------\n \n-   procedure Cancel_Queued_Entry_Calls (T : Task_ID);\n+   procedure Cancel_Queued_Entry_Calls (T : Task_Id);\n    --  Cancel any entry calls queued on target task.\n    --  Call this while holding T's lock (or RTS_Lock in Single_Lock mode).\n \n-   procedure Exit_One_ATC_Level (Self_ID : Task_ID);\n+   procedure Exit_One_ATC_Level (Self_ID : Task_Id);\n    pragma Inline (Exit_One_ATC_Level);\n    --  Call only with abort deferred and holding lock of Self_ID.\n    --  This is a bit of common code for all entry calls.\n    --  The effect is to exit one level of ATC nesting.\n \n-   procedure Abort_One_Task (Self_ID : Task_ID; T : Task_ID);\n+   procedure Abort_One_Task (Self_ID : Task_Id; T : Task_Id);\n    --  Similar to Locked_Abort_To_Level (Self_ID, T, 0), but:\n    --    (1) caller should be holding no locks\n    --    (2) may be called for tasks that have not yet been activated\n@@ -96,7 +96,7 @@ package System.Tasking.Utilities is\n    --  Abort_Tasks is called to initiate abortion, however, the actual\n    --  abortion is done by abortee by means of Abort_Handler\n \n-   procedure Make_Passive (Self_ID : Task_ID; Task_Completed : Boolean);\n+   procedure Make_Passive (Self_ID : Task_Id; Task_Completed : Boolean);\n    --  Update counts to indicate current task is either terminated\n    --  or accepting on a terminate alternative.\n    --  Call holding no locks except Global_Task_Lock when calling from"}, {"sha": "cabeda73ca7878ba40d740105a42f648fcd629b4", "filename": "gcc/ada/s-tataat.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tataat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tataat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -100,7 +100,7 @@ package body System.Tasking.Task_Attributes is\n          --  Deallocation does finalization, if necessary.\n \n          declare\n-            C : System.Tasking.Task_ID := All_Tasks_List;\n+            C : System.Tasking.Task_Id := All_Tasks_List;\n             P : Access_Node;\n \n          begin\n@@ -158,7 +158,7 @@ package body System.Tasking.Task_Attributes is\n    --  This is to be called just before the ATCB is deallocated.\n    --  It relies on the caller holding T.L write-lock on entry.\n \n-   procedure Finalize_Attributes (T : Task_ID) is\n+   procedure Finalize_Attributes (T : Task_Id) is\n       P : Access_Node;\n       Q : Access_Node := To_Access_Node (T.Indirect_Attributes);\n \n@@ -185,7 +185,7 @@ package body System.Tasking.Task_Attributes is\n \n    --  This is to be called by System.Tasking.Stages.Create_Task.\n \n-   procedure Initialize_Attributes (T : Task_ID) is\n+   procedure Initialize_Attributes (T : Task_Id) is\n       P : Access_Instance;\n    begin\n       Defer_Abortion;"}, {"sha": "d8716cd02e42ba98f6d2d20b735498021720992f", "filename": "gcc/ada/s-tataat.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tataat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tataat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -116,13 +116,13 @@ package System.Tasking.Task_Attributes is\n    --  A linked list of all indirectly access attributes,\n    --  which includes all those that require finalization.\n \n-   procedure Initialize_Attributes (T : Task_ID);\n+   procedure Initialize_Attributes (T : Task_Id);\n    --  Initialize all attributes created via Ada.Task_Attributes for T.\n    --  This must be called by the creator of the task, inside Create_Task,\n    --  via soft-link Initialize_Attributes_Link. On entry, abortion must\n    --  be deferred and the caller must hold no locks\n \n-   procedure Finalize_Attributes (T : Task_ID);\n+   procedure Finalize_Attributes (T : Task_Id);\n    --  Finalize all attributes created via Ada.Task_Attributes for T.\n    --  This is to be called by the task after it is marked as terminated\n    --  (and before it actually dies), inside Vulnerable_Free_Task, via the"}, {"sha": "fa39b65311cbde83a91333ddcb9a1f93e05912ca", "filename": "gcc/ada/s-tpinop.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpinop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpinop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpinop.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1998-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,16 +38,16 @@ package body System.Task_Primitives.Interrupt_Operations is\n    --  this array, but due to elaboration problems, it can't with this\n    --  package directly, so we export this variable for now.\n \n-   Interrupt_ID_Map : array (IM.Interrupt_ID) of ST.Task_ID;\n+   Interrupt_ID_Map : array (IM.Interrupt_ID) of ST.Task_Id;\n    pragma Export (Ada, Interrupt_ID_Map,\n      \"system__task_primitives__interrupt_operations__interrupt_id_map\");\n \n    ----------------------\n    -- Get_Interrupt_ID --\n    ----------------------\n \n-   function Get_Interrupt_ID (T : ST.Task_ID) return IM.Interrupt_ID is\n-      use type ST.Task_ID;\n+   function Get_Interrupt_ID (T : ST.Task_Id) return IM.Interrupt_ID is\n+      use type ST.Task_Id;\n \n    begin\n       for Interrupt in IM.Interrupt_ID loop\n@@ -60,19 +60,19 @@ package body System.Task_Primitives.Interrupt_Operations is\n    end Get_Interrupt_ID;\n \n    -----------------\n-   -- Get_Task_ID --\n+   -- Get_Task_Id --\n    -----------------\n \n-   function Get_Task_ID (Interrupt : IM.Interrupt_ID) return ST.Task_ID is\n+   function Get_Task_Id (Interrupt : IM.Interrupt_ID) return ST.Task_Id is\n    begin\n       return Interrupt_ID_Map (Interrupt);\n-   end Get_Task_ID;\n+   end Get_Task_Id;\n \n    ----------------------\n    -- Set_Interrupt_ID --\n    ----------------------\n \n-   procedure Set_Interrupt_ID (Interrupt : IM.Interrupt_ID; T : ST.Task_ID) is\n+   procedure Set_Interrupt_ID (Interrupt : IM.Interrupt_ID; T : ST.Task_Id) is\n    begin\n       Interrupt_ID_Map (Interrupt) := T;\n    end Set_Interrupt_ID;"}, {"sha": "94c165aaa959653a6dc4372a729d86e9e669c404", "filename": "gcc/ada/s-tpinop.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpinop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpinop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpinop.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---           Copyright (C) 1998-2001 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1998-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,13 +38,13 @@ package System.Task_Primitives.Interrupt_Operations is\n    package IM renames System.Interrupt_Management;\n    package ST renames System.Tasking;\n \n-   procedure Set_Interrupt_ID (Interrupt : IM.Interrupt_ID; T : ST.Task_ID);\n+   procedure Set_Interrupt_ID (Interrupt : IM.Interrupt_ID; T : ST.Task_Id);\n    --  Associate an Interrupt_ID with a task.\n \n-   function Get_Interrupt_ID (T : ST.Task_ID) return IM.Interrupt_ID;\n+   function Get_Interrupt_ID (T : ST.Task_Id) return IM.Interrupt_ID;\n    --  Return the Interrupt_ID associated with a task.\n \n-   function Get_Task_ID (Interrupt : IM.Interrupt_ID) return ST.Task_ID;\n-   --  Return the Task_ID associated with an Interrupt.\n+   function Get_Task_Id (Interrupt : IM.Interrupt_ID) return ST.Task_Id;\n+   --  Return the Task_Id associated with an Interrupt.\n \n end System.Task_Primitives.Interrupt_Operations;"}, {"sha": "a195828c9b29c091200467312d25043db36e450d", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2001, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,9 +81,9 @@ package body System.Tasking.Protected_Objects.Entries is\n \n    procedure Finalize (Object : in out Protection_Entries) is\n       Entry_Call        : Entry_Call_Link;\n-      Caller            : Task_ID;\n+      Caller            : Task_Id;\n       Ceiling_Violation : Boolean;\n-      Self_ID           : constant Task_ID := STPO.Self;\n+      Self_ID           : constant Task_Id := STPO.Self;\n       Old_Base_Priority : System.Any_Priority;\n \n    begin\n@@ -179,7 +179,7 @@ package body System.Tasking.Protected_Objects.Entries is\n       Find_Body_Index   : Find_Body_Index_Access)\n    is\n       Init_Priority : Integer := Ceiling_Priority;\n-      Self_ID       : constant Task_ID := STPO.Self;\n+      Self_ID       : constant Task_Id := STPO.Self;\n \n    begin\n       if Init_Priority = Unspecified_Priority then"}, {"sha": "3535a79ef74792839d1393fa97499031e48fdb8f", "filename": "gcc/ada/s-tpobop.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -120,7 +120,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    --  It returns with the PO's lock still held.\n \n    procedure Requeue_Call\n-     (Self_Id    : Task_ID;\n+     (Self_Id    : Task_Id;\n       Object     : Protection_Entries_Access;\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean);\n@@ -292,7 +292,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    --------------------\n \n    procedure PO_Do_Or_Queue\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Object     : Protection_Entries_Access;\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean)\n@@ -382,12 +382,12 @@ package body System.Tasking.Protected_Objects.Operations is\n    ------------------------\n \n    procedure PO_Service_Entries\n-     (Self_ID       : Task_ID;\n+     (Self_ID       : Task_Id;\n       Object        : Entries.Protection_Entries_Access;\n       Unlock_Object : Boolean := True)\n    is\n       E          : Protected_Entry_Index;\n-      Caller     : Task_ID;\n+      Caller     : Task_Id;\n       Entry_Call : Entry_Call_Link;\n \n    begin\n@@ -519,7 +519,7 @@ package body System.Tasking.Protected_Objects.Operations is\n       Mode                : Call_Modes;\n       Block               : out Communication_Block)\n    is\n-      Self_ID             : constant Task_ID  := STPO.Self;\n+      Self_ID             : constant Task_Id  := STPO.Self;\n       Entry_Call          : Entry_Call_Link;\n       Initially_Abortable : Boolean;\n       Ceiling_Violation   : Boolean;\n@@ -653,7 +653,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    ------------------\n \n    procedure Requeue_Call\n-     (Self_Id    : Task_ID;\n+     (Self_Id    : Task_Id;\n       Object     : Protection_Entries_Access;\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean)\n@@ -739,7 +739,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    ----------------------------\n \n    function Protected_Entry_Caller\n-     (Object : Protection_Entries'Class) return Task_ID is\n+     (Object : Protection_Entries'Class) return Task_Id is\n    begin\n       return Object.Call_In_Progress.Self;\n    end Protected_Entry_Caller;\n@@ -837,7 +837,7 @@ package body System.Tasking.Protected_Objects.Operations is\n       E          : Protected_Entry_Index;\n       With_Abort : Boolean)\n    is\n-      Self_ID    : constant Task_ID := STPO.Self;\n+      Self_ID    : constant Task_Id := STPO.Self;\n       Entry_Call : constant Entry_Call_Link := Self_ID.Common.Call;\n \n    begin\n@@ -859,7 +859,7 @@ package body System.Tasking.Protected_Objects.Operations is\n    ---------------------\n \n    procedure Service_Entries (Object : Protection_Entries_Access) is\n-      Self_ID : constant Task_ID := STPO.Self;\n+      Self_ID : constant Task_Id := STPO.Self;\n    begin\n       PO_Service_Entries (Self_ID, Object);\n    end Service_Entries;\n@@ -878,7 +878,7 @@ package body System.Tasking.Protected_Objects.Operations is\n       Mode                  : Delay_Modes;\n       Entry_Call_Successful : out Boolean)\n    is\n-      Self_Id           : constant Task_ID  := STPO.Self;\n+      Self_Id           : constant Task_Id  := STPO.Self;\n       Entry_Call        : Entry_Call_Link;\n       Ceiling_Violation : Boolean;\n       Yielded           : Boolean;"}, {"sha": "c53e59e0fc571f031c165dafc3d6b49e2a0cc2cb", "filename": "gcc/ada/s-tpobop.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpobop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpobop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -95,7 +95,7 @@ package System.Tasking.Protected_Objects.Operations is\n    pragma Inline (Service_Entries);\n \n    procedure PO_Service_Entries\n-     (Self_ID       : Task_ID;\n+     (Self_ID       : Task_Id;\n       Object        : Entries.Protection_Entries_Access;\n       Unlock_Object : Boolean := True);\n    --  Service all entry queues of the specified object, executing the\n@@ -176,15 +176,15 @@ package System.Tasking.Protected_Objects.Operations is\n    --  Return the number of entry calls to E on Object.\n \n    function Protected_Entry_Caller\n-     (Object : Entries.Protection_Entries'Class) return Task_ID;\n+     (Object : Entries.Protection_Entries'Class) return Task_Id;\n    --  Return value of E'Caller, where E is the protected entry currently\n    --  being handled. This will only work if called from within an entry\n    --  body, as required by the LRM (C.7.1(14)).\n \n    --  For internal use only:\n \n    procedure PO_Do_Or_Queue\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Object     : Entries.Protection_Entries_Access;\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean);\n@@ -194,7 +194,7 @@ package System.Tasking.Protected_Objects.Operations is\n \n private\n    type Communication_Block is record\n-      Self      : Task_ID;\n+      Self      : Task_Id;\n       Enqueued  : Boolean := True;\n       Cancelled : Boolean := False;\n    end record;"}, {"sha": "5fa9a92e21dd031c683071cf03e4cb5871aa743a", "filename": "gcc/ada/s-tpopde-vms.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopde-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopde-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopde-vms.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -70,10 +70,10 @@ package body System.Task_Primitives.Operations.DEC is\n    -----------------------\n \n    function To_Unsigned_Longword is new\n-     Unchecked_Conversion (Task_ID, Unsigned_Longword);\n+     Unchecked_Conversion (Task_Id, Unsigned_Longword);\n \n    function To_Task_Id is new\n-     Unchecked_Conversion (Unsigned_Longword, Task_ID);\n+     Unchecked_Conversion (Unsigned_Longword, Task_Id);\n \n    function To_FAB_RAB is new\n      Unchecked_Conversion (Address, FAB_RAB_Access_Type);\n@@ -84,7 +84,7 @@ package body System.Task_Primitives.Operations.DEC is\n \n    procedure Interrupt_AST_Handler (ID : Address) is\n       Result      : Interfaces.C.int;\n-      AST_Self_ID : constant Task_ID := To_Task_ID (ID);\n+      AST_Self_ID : constant Task_Id := To_Task_Id (ID);\n    begin\n       Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -95,7 +95,7 @@ package body System.Task_Primitives.Operations.DEC is\n    ---------------------\n \n    procedure RMS_AST_Handler (ID : Address) is\n-      AST_Self_ID : constant Task_ID := To_Task_Id (To_FAB_RAB (ID).CTX);\n+      AST_Self_ID : constant Task_Id := To_Task_Id (To_FAB_RAB (ID).CTX);\n       Result      : Interfaces.C.int;\n \n    begin\n@@ -109,7 +109,7 @@ package body System.Task_Primitives.Operations.DEC is\n    ----------\n \n    function Self return Unsigned_Longword is\n-      Self_ID : constant Task_ID := Self;\n+      Self_ID : constant Task_Id := Self;\n    begin\n       Self_ID.Common.LL.AST_Pending := True;\n       return To_Unsigned_Longword (Self);\n@@ -121,7 +121,7 @@ package body System.Task_Primitives.Operations.DEC is\n \n    procedure Starlet_AST_Handler (ID : Address) is\n       Result      : Interfaces.C.int;\n-      AST_Self_ID : constant Task_ID := To_Task_ID (ID);\n+      AST_Self_ID : constant Task_Id := To_Task_Id (ID);\n    begin\n       AST_Self_ID.Common.LL.AST_Pending := False;\n       Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n@@ -133,7 +133,7 @@ package body System.Task_Primitives.Operations.DEC is\n    ----------------\n \n    procedure Task_Synch is\n-      Synch_Self_ID : constant Task_ID := Self;\n+      Synch_Self_ID : constant Task_Id := Self;\n \n    begin\n       if Single_Lock then"}, {"sha": "91bf83ea97398cca5c8c1d57e17f5c575b7b744b", "filename": "gcc/ada/s-tpopsp-lynxos.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-lynxos.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -40,7 +40,7 @@ package body Specific is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       pragma Warnings (Off, Environment_Task);\n       Result : Interfaces.C.int;\n \n@@ -66,7 +66,7 @@ package body Specific is\n    -- Set --\n    ---------\n \n-   procedure Set (Self_Id : Task_ID) is\n+   procedure Set (Self_Id : Task_Id) is\n       Result : Interfaces.C.int;\n \n    begin\n@@ -91,7 +91,7 @@ package body Specific is\n    --  hierarchy, much like the existing implicitly created signal-server\n    --  tasks.\n \n-   function Self return Task_ID is\n+   function Self return Task_Id is\n       Value : aliased System.Address;\n \n       Result : Interfaces.C.int;\n@@ -104,7 +104,7 @@ package body Specific is\n       --  If the key value is Null, then it is a non-Ada task.\n \n       if Value /= System.Null_Address then\n-         return To_Task_ID (Value);\n+         return To_Task_Id (Value);\n       else\n          return Register_Foreign_Thread;\n       end if;"}, {"sha": "7cac3b504d037a7924efecad8f960917a312493b", "filename": "gcc/ada/s-tpopsp-posix-foreign.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-posix-foreign.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-posix-foreign.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-posix-foreign.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -44,7 +44,7 @@ package body Specific is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       pragma Warnings (Off, Environment_Task);\n       Result : Interfaces.C.int;\n \n@@ -66,7 +66,7 @@ package body Specific is\n    -- Set --\n    ---------\n \n-   procedure Set (Self_Id : Task_ID) is\n+   procedure Set (Self_Id : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       Result := pthread_setspecific (ATCB_Key, To_Address (Self_Id));\n@@ -90,7 +90,7 @@ package body Specific is\n    --  hierarchy, much like the existing implicitly created signal-server\n    --  tasks.\n \n-   function Self return Task_ID is\n+   function Self return Task_Id is\n       Result : System.Address;\n \n    begin\n@@ -99,7 +99,7 @@ package body Specific is\n       --  If the key value is Null, then it is a non-Ada task.\n \n       if Result /= System.Null_Address then\n-         return To_Task_ID (Result);\n+         return To_Task_Id (Result);\n       else\n          return Register_Foreign_Thread;\n       end if;"}, {"sha": "6c3e74676d534d9db262b3a95de4b84a26e54f7c", "filename": "gcc/ada/s-tpopsp-posix.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-posix.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -40,7 +40,7 @@ package body Specific is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       pragma Warnings (Off, Environment_Task);\n       Result : Interfaces.C.int;\n    begin\n@@ -61,7 +61,7 @@ package body Specific is\n    -- Set --\n    ---------\n \n-   procedure Set (Self_Id : Task_ID) is\n+   procedure Set (Self_Id : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       Result := pthread_setspecific (ATCB_Key, To_Address (Self_Id));\n@@ -72,9 +72,9 @@ package body Specific is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID is\n+   function Self return Task_Id is\n    begin\n-      return To_Task_ID (pthread_getspecific (ATCB_Key));\n+      return To_Task_Id (pthread_getspecific (ATCB_Key));\n    end Self;\n \n end Specific;"}, {"sha": "eb0fabebd50b2d171a5703259ce4820760985f89", "filename": "gcc/ada/s-tpopsp-solaris.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-solaris.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,7 @@ package body Specific is\n    -- Initialize --\n    ----------------\n \n-   procedure Initialize (Environment_Task : Task_ID) is\n+   procedure Initialize (Environment_Task : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       Result := thr_setspecific (ATCB_Key, To_Address (Environment_Task));\n@@ -64,7 +64,7 @@ package body Specific is\n    -- Set --\n    ---------\n \n-   procedure Set (Self_Id : Task_ID) is\n+   procedure Set (Self_Id : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n       Result := thr_setspecific (ATCB_Key, To_Address (Self_Id));\n@@ -90,7 +90,7 @@ package body Specific is\n    --  master hierarchy, much like the existing implicitly created\n    --  signal-server tasks.\n \n-   function Self return Task_ID is\n+   function Self return Task_Id is\n       Result  : Interfaces.C.int;\n       Self_Id : aliased System.Address;\n    begin\n@@ -100,7 +100,7 @@ package body Specific is\n       if Self_Id = System.Null_Address then\n          return Register_Foreign_Thread;\n       else\n-         return To_Task_ID (Self_Id);\n+         return To_Task_Id (Self_Id);\n       end if;\n    end Self;\n "}, {"sha": "965d1c9bfcbcf52a818bad63d6f31b037ba51cb0", "filename": "gcc/ada/s-tpopsp-vxworks.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tpopsp-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-vxworks.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -50,7 +50,7 @@ package body Specific is\n    -- Set --\n    ---------\n \n-   procedure Set (Self_Id : Task_ID) is\n+   procedure Set (Self_Id : Task_Id) is\n       Result : STATUS;\n \n    begin\n@@ -66,9 +66,9 @@ package body Specific is\n    -- Self --\n    ----------\n \n-   function Self return Task_ID is\n+   function Self return Task_Id is\n    begin\n-      return To_Task_ID (ATCB_Key);\n+      return To_Task_Id (ATCB_Key);\n    end Self;\n \n end Specific;"}, {"sha": "feb922a6ce689d26b2abd53f1eb7bd0c5b3e73f4", "filename": "gcc/ada/s-tporft.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tporft.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tporft.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tporft.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 2002-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,9 +38,9 @@ with System.Soft_Links;\n --  used to initialize TSD for a C thread, in function Self\n \n separate (System.Task_Primitives.Operations)\n-function Register_Foreign_Thread (Thread : Thread_Id) return Task_ID is\n+function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id is\n    Local_ATCB : aliased Ada_Task_Control_Block (0);\n-   Self_Id    : Task_ID;\n+   Self_Id    : Task_Id;\n    Succeeded  : Boolean;\n \n    use type Interfaces.C.unsigned;\n@@ -51,7 +51,7 @@ begin\n    --  immediately, we fake one, so that it is then possible to e.g allocate\n    --  memory (which might require accessing self).\n \n-   --  Record this as the Task_ID for the thread\n+   --  Record this as the Task_Id for the thread\n \n    Local_ATCB.Common.LL.Thread := Thread;\n    Local_ATCB.Common.Current_Priority := System.Priority'First;"}, {"sha": "25a8251b9dc777be7cfc8fbdd10e44454f45352a", "filename": "gcc/ada/s-tposen.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tposen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tposen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -83,7 +83,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    -----------------------\n \n    procedure Send_Program_Error\n-     (Self_Id    : Task_ID;\n+     (Self_Id    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    pragma Inline (Send_Program_Error);\n    --  Raise Program_Error in the caller of the specified entry call\n@@ -93,7 +93,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --------------------------\n \n    procedure Wakeup_Entry_Caller\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link;\n       New_State  : Entry_Call_State);\n    pragma Inline (Wakeup_Entry_Caller);\n@@ -121,7 +121,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --  specified in Wakeup_Time as well.\n \n    procedure Check_Exception\n-     (Self_ID : Task_ID;\n+     (Self_ID : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    pragma Inline (Check_Exception);\n    --  Raise any pending exception from the Entry_Call.\n@@ -130,7 +130,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --  The caller should not be holding any locks, or there will be deadlock.\n \n    procedure PO_Do_Or_Queue\n-     (Self_Id    : Task_ID;\n+     (Self_Id    : Task_Id;\n       Object     : Protection_Entry_Access;\n       Entry_Call : Entry_Call_Link);\n    --  This procedure executes or queues an entry call, depending\n@@ -142,7 +142,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    ---------------------\n \n    procedure Check_Exception\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link)\n    is\n       pragma Warnings (Off, Self_ID);\n@@ -166,10 +166,10 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    ------------------------\n \n    procedure Send_Program_Error\n-     (Self_Id    : Task_ID;\n+     (Self_Id    : Task_Id;\n       Entry_Call : Entry_Call_Link)\n    is\n-      Caller : constant Task_ID := Entry_Call.Self;\n+      Caller : constant Task_Id := Entry_Call.Self;\n    begin\n       Entry_Call.Exception_To_Raise := Program_Error'Identity;\n \n@@ -191,7 +191,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    -------------------------\n \n    procedure Wait_For_Completion (Entry_Call : Entry_Call_Link) is\n-      Self_Id : constant Task_ID := Entry_Call.Self;\n+      Self_Id : constant Task_Id := Entry_Call.Self;\n    begin\n       Self_Id.Common.State := Entry_Caller_Sleep;\n       STPO.Sleep (Self_Id, Entry_Caller_Sleep);\n@@ -207,7 +207,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Wakeup_Time : Duration;\n       Mode        : Delay_Modes)\n    is\n-      Self_Id  : constant Task_ID := Entry_Call.Self;\n+      Self_Id  : constant Task_Id := Entry_Call.Self;\n       Timedout : Boolean;\n       Yielded  : Boolean;\n \n@@ -267,13 +267,13 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --    to complete.\n \n    procedure Wakeup_Entry_Caller\n-     (Self_ID    : Task_ID;\n+     (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link;\n       New_State  : Entry_Call_State)\n    is\n       pragma Warnings (Off, Self_ID);\n \n-      Caller : constant Task_ID := Entry_Call.Self;\n+      Caller : constant Task_Id := Entry_Call.Self;\n \n    begin\n       pragma Assert (New_State = Done or else New_State = Cancelled);\n@@ -377,7 +377,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    --------------------\n \n    procedure PO_Do_Or_Queue\n-     (Self_Id    : Task_ID;\n+     (Self_Id    : Task_Id;\n       Object     : Protection_Entry_Access;\n       Entry_Call : Entry_Call_Link)\n    is\n@@ -460,7 +460,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Uninterpreted_Data : System.Address;\n       Mode               : Call_Modes)\n    is\n-      Self_Id           : constant Task_ID := STPO.Self;\n+      Self_Id           : constant Task_Id := STPO.Self;\n       Entry_Call        : Entry_Call_Record renames Self_Id.Entry_Calls (1);\n       Ceiling_Violation : Boolean;\n \n@@ -506,7 +506,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    -----------------------------------\n \n    function Protected_Single_Entry_Caller\n-     (Object : Protection_Entry) return Task_ID is\n+     (Object : Protection_Entry) return Task_Id is\n    begin\n       return Object.Call_In_Progress.Self;\n    end Protected_Single_Entry_Caller;\n@@ -516,9 +516,9 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n    -------------------\n \n    procedure Service_Entry (Object : Protection_Entry_Access) is\n-      Self_Id       : constant Task_ID := STPO.Self;\n+      Self_Id       : constant Task_Id := STPO.Self;\n       Entry_Call    : constant Entry_Call_Link := Object.Entry_Queue;\n-      Caller        : Task_ID;\n+      Caller        : Task_Id;\n \n    begin\n       if Entry_Call /= null then\n@@ -574,7 +574,7 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       Mode                  : Delay_Modes;\n       Entry_Call_Successful : out Boolean)\n    is\n-      Self_Id           : constant Task_ID  := STPO.Self;\n+      Self_Id           : constant Task_Id  := STPO.Self;\n       Entry_Call        : Entry_Call_Record renames Self_Id.Entry_Calls (1);\n       Ceiling_Violation : Boolean;\n "}, {"sha": "148098f4caed610f8256cc55a82e51d8e1c065d9", "filename": "gcc/ada/s-tposen.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tposen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tposen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tposen.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -270,7 +270,7 @@ package System.Tasking.Protected_Objects.Single_Entry is\n    --  Return the number of entry calls on Object (0 or 1).\n \n    function Protected_Single_Entry_Caller (Object : Protection_Entry)\n-     return Task_ID;\n+     return Task_Id;\n    --  Return value of E'Caller, where E is the protected entry currently\n    --  being handled. This will only work if called from within an\n    --  entry body, as required by the LRM (C.7.1(14))."}, {"sha": "89938c45caa206cefa4b0e92297a21de49cce8bf", "filename": "gcc/ada/s-tratas-default.adb", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tratas-default.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tratas-default.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tratas-default.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---           Copyright (C) 2001-2002 Free Software Foundation, Inc.         --\n+--           Copyright (C) 2001-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -45,15 +45,15 @@ package body System.Traces.Tasking is\n \n    package SSL renames System.Soft_Links;\n \n-   function Extract_Accepts (Task_Name : Task_ID) return String_Trace;\n+   function Extract_Accepts (Task_Name : Task_Id) return String_Trace;\n    --  This function is used to extract data joined with\n    --  W_Select, WT_Select, W_Accept events\n \n    ---------------------\n    -- Send_Trace_Info --\n    ---------------------\n \n-   procedure Send_Trace_Info (Id : Trace_T; Task_Name2 : Task_ID) is\n+   procedure Send_Trace_Info (Id : Trace_T; Task_Name2 : Task_Id) is\n       Task_S  : constant String := SSL.Task_Name.all;\n       Task2_S : constant String :=\n                   Task_Name2.Common.Task_Image\n@@ -101,7 +101,7 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Task_Name2   : Task_ID;\n+      Task_Name2   : Task_Id;\n       Entry_Number : Entry_Index)\n    is\n       Task_S  : constant String := SSL.Task_Name.all;\n@@ -146,8 +146,8 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Task_Name    : Task_ID;\n-      Task_Name2   : Task_ID;\n+      Task_Name    : Task_Id;\n+      Task_Name2   : Task_Id;\n       Entry_Number : Entry_Index)\n    is\n       Task_S  : constant String :=\n@@ -201,8 +201,8 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id         : Trace_T;\n-      Task_Name  : Task_ID;\n-      Task_Name2 : Task_ID)\n+      Task_Name  : Task_Id;\n+      Task_Name2 : Task_Id)\n    is\n       Task_S  : constant String :=\n                   Task_Name.Common.Task_Image\n@@ -226,7 +226,7 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Acceptor     : Task_ID;\n+      Acceptor     : Task_Id;\n       Entry_Number : Entry_Index;\n       Timeout      : Duration)\n    is\n@@ -285,7 +285,7 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id        : Trace_T;\n-      Task_Name : Task_ID;\n+      Task_Name : Task_Id;\n       Number    : Integer)\n    is\n       Task_S    : String := SSL.Task_Name.all;\n@@ -311,7 +311,7 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id        : Trace_T;\n-      Task_Name : Task_ID;\n+      Task_Name : Task_Id;\n       Number    : Integer;\n       Timeout   : Duration)\n    is\n@@ -347,7 +347,7 @@ package body System.Traces.Tasking is\n    --  This function returns a string in which all opened\n    --  Accepts or Selects are given, separated by semi-colons.\n \n-   function Extract_Accepts (Task_Name : Task_ID) return String_Trace is\n+   function Extract_Accepts (Task_Name : Task_Id) return String_Trace is\n       Info_Annex : String_Trace := (ASCII.NUL, others => ' ');\n \n    begin"}, {"sha": "448fbfa49d938f732a1b701815a1605192eeae7a", "filename": "gcc/ada/s-tratas.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tratas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tratas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tratas.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,14 +39,14 @@ package body System.Traces.Tasking is\n    -- Send_Trace_Info --\n    ---------------------\n \n-   procedure Send_Trace_Info (Id : Trace_T; Task_Name2 : ST.Task_ID) is\n+   procedure Send_Trace_Info (Id : Trace_T; Task_Name2 : ST.Task_Id) is\n    begin\n       null;\n    end Send_Trace_Info;\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Task_Name2   : ST.Task_ID;\n+      Task_Name2   : ST.Task_Id;\n       Entry_Number : ST.Entry_Index)\n    is\n    begin\n@@ -55,8 +55,8 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Task_Name    : ST.Task_ID;\n-      Task_Name2   : ST.Task_ID;\n+      Task_Name    : ST.Task_Id;\n+      Task_Name2   : ST.Task_Id;\n       Entry_Number : ST.Entry_Index)\n    is\n    begin\n@@ -65,8 +65,8 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id         : Trace_T;\n-      Task_Name  : ST.Task_ID;\n-      Task_Name2 : ST.Task_ID)\n+      Task_Name  : ST.Task_Id;\n+      Task_Name2 : ST.Task_Id)\n    is\n    begin\n       null;\n@@ -82,7 +82,7 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Acceptor     : ST.Task_ID;\n+      Acceptor     : ST.Task_Id;\n       Entry_Number : ST.Entry_Index;\n       Timeout      : Duration)\n    is\n@@ -101,7 +101,7 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id        : Trace_T;\n-      Task_Name : ST.Task_ID;\n+      Task_Name : ST.Task_Id;\n       Number    : Integer)\n    is\n    begin\n@@ -110,7 +110,7 @@ package body System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id        : Trace_T;\n-      Task_Name : ST.Task_ID;\n+      Task_Name : ST.Task_Id;\n       Number    : Integer;\n       Timeout   : Duration)\n    is"}, {"sha": "c9a1e4a4272f7214ff1c4582142094969703c1f8", "filename": "gcc/ada/s-tratas.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tratas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fs-tratas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tratas.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---             Copyright (C) 2001 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,31 +50,31 @@ package System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id         : Trace_T;\n-      Task_Name2 : ST.Task_ID);\n+      Task_Name2 : ST.Task_Id);\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Task_Name2   : ST.Task_ID;\n+      Task_Name2   : ST.Task_Id;\n       Entry_Number : ST.Entry_Index);\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Task_Name    : ST.Task_ID;\n-      Task_Name2   : ST.Task_ID;\n+      Task_Name    : ST.Task_Id;\n+      Task_Name2   : ST.Task_Id;\n       Entry_Number : ST.Entry_Index);\n \n    procedure Send_Trace_Info\n      (Id         : Trace_T;\n-      Task_Name  : ST.Task_ID;\n-      Task_Name2 : ST.Task_ID);\n+      Task_Name  : ST.Task_Id;\n+      Task_Name2 : ST.Task_Id);\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n       Entry_Number : ST.Entry_Index);\n \n    procedure Send_Trace_Info\n      (Id           : Trace_T;\n-      Acceptor     : ST.Task_ID;\n+      Acceptor     : ST.Task_Id;\n       Entry_Number : ST.Entry_Index;\n       Timeout      : Duration);\n \n@@ -85,12 +85,12 @@ package System.Traces.Tasking is\n \n    procedure Send_Trace_Info\n      (Id         : Trace_T;\n-      Task_Name  : ST.Task_ID;\n+      Task_Name  : ST.Task_Id;\n       Number     : Integer);\n \n    procedure Send_Trace_Info\n      (Id         : Trace_T;\n-      Task_Name  : ST.Task_ID;\n+      Task_Name  : ST.Task_Id;\n       Number     : Integer;\n       Timeout    : Duration);\n end System.Traces.Tasking;"}, {"sha": "031ffa41e94dae8c6d1741baf66234bf52bcc4aa", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -2090,7 +2090,7 @@ package body Sem_Attr is\n             end if;\n          end loop;\n \n-         Set_Etype (N, RTE (RO_AT_Task_ID));\n+         Set_Etype (N, RTE (RO_AT_Task_Id));\n       end Caller;\n \n       -------------\n@@ -2627,7 +2627,7 @@ package body Sem_Attr is\n               and then Is_Task_Type (Designated_Type (Etype (P))))\n          then\n             Resolve (P);\n-            Set_Etype (N, RTE (RO_AT_Task_ID));\n+            Set_Etype (N, RTE (RO_AT_Task_Id));\n \n          else\n             Error_Attr (\"prefix of % attribute must be a task or an \""}, {"sha": "ac065d0edf528e7159a2a1985ebcd8c651ce496c", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -3352,7 +3352,9 @@ package body Sem_Ch10 is\n       --  view because the full view of X supersedes its limited view.\n \n       if Analyzed (Cunit (Unum))\n-        and then Is_Immediately_Visible (P)\n+        and then (Is_Immediately_Visible (P)\n+                   or else (Is_Child_Package\n+                             and then Is_Visible_Child_Unit (P)))\n       then\n          return;\n       end if;"}, {"sha": "5daafd59583f0dcc023752a5d2649c863f346218", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 28, "deletions": 98, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -3250,6 +3250,10 @@ package body Sem_Prag is\n          procedure Set_Warning (R : All_Restrictions);\n          --  If this is a Restriction_Warnings pragma, set warning flag\n \n+         -----------------\n+         -- Set_Warning --\n+         -----------------\n+\n          procedure Set_Warning (R : All_Restrictions) is\n          begin\n             if Prag_Id = Pragma_Restriction_Warnings then\n@@ -3269,119 +3273,45 @@ package body Sem_Prag is\n             Id := Chars (Arg);\n             Expr := Expression (Arg);\n \n-            --  Case of no restriction identifier\n+            --  Case of no restriction identifier present\n \n             if Id = No_Name then\n                if Nkind (Expr) /= N_Identifier then\n                   Error_Pragma_Arg\n                     (\"invalid form for restriction\", Arg);\n+               end if;\n \n-               --  Deal with synonyms. This should be done more cleanly ???\n-\n-               else\n-                  --  Boolean_Entry_Barriers is a synonym of Simple_Barriers\n-\n-                  if Chars (Expr) = Name_Boolean_Entry_Barriers then\n-                     Check_Restriction\n-                       (No_Implementation_Restrictions, Arg);\n-                     Set_Restriction (Simple_Barriers, N);\n-                     Set_Warning (Simple_Barriers);\n-\n-                  --  Max_Entry_Queue_Depth is a synonym of\n-                  --  Max_Entry_Queue_Length\n-\n-                  elsif Chars (Expr) = Name_Max_Entry_Queue_Depth then\n-                     Analyze_And_Resolve (Expr, Any_Integer);\n-\n-                     if not Is_OK_Static_Expression (Expr) then\n-                        Flag_Non_Static_Expr\n-                          (\"value must be static expression!\", Expr);\n-                        raise Pragma_Exit;\n-\n-                     elsif not Is_Integer_Type (Etype (Expr))\n-                       or else Expr_Value (Expr) < 0\n-                     then\n-                        Error_Pragma_Arg\n-                          (\"value must be non-negative integer\", Arg);\n-\n-                     --  Restriction pragma is active\n-\n-                     else\n-                        Val := Expr_Value (Expr);\n-\n-                        if not UI_Is_In_Int_Range (Val) then\n-                           Error_Pragma_Arg\n-                             (\"pragma ignored, value too large?\", Arg);\n-                        else\n-                           Set_Restriction (Max_Entry_Queue_Length, N,\n-                                            Integer (UI_To_Int (Val)));\n-                           Set_Warning (Max_Entry_Queue_Length);\n-                        end if;\n-                     end if;\n-\n-                  --  No_Dynamic_Interrupts is a synonym for\n-                  --  No_Dynamic_Attachment\n-\n-                  elsif Chars (Expr) = Name_No_Dynamic_Interrupts then\n-                     Check_Restriction\n-                       (No_Implementation_Restrictions, Arg);\n-                     Set_Restriction (No_Dynamic_Attachment, N);\n-                     Set_Warning (No_Dynamic_Attachment);\n-\n-                  --  No_Requeue is a synonym for No_Requeue_Statements\n-\n-                  elsif Chars (Expr) = Name_No_Requeue then\n-                     Check_Restriction\n-                       (No_Implementation_Restrictions, Arg);\n-                     Set_Restriction (No_Requeue_Statements, N);\n-                     Set_Warning (No_Requeue_Statements);\n-\n-                  --  No_Task_Attributes is a synonym for\n-                  --  No_Task_Attributes_Package\n-\n-                  elsif Chars (Expr) = Name_No_Task_Attributes then\n-                     Check_Restriction\n-                       (No_Implementation_Restrictions, Arg);\n-                     Set_Restriction (No_Task_Attributes_Package, N);\n-                     Set_Warning (No_Task_Attributes_Package);\n-\n-                  --  Normal processing for all other cases\n-\n-                  else\n-                     R_Id := Get_Restriction_Id (Chars (Expr));\n-\n-                     if R_Id not in All_Boolean_Restrictions then\n-                        Error_Pragma_Arg\n-                          (\"invalid restriction identifier\", Arg);\n+               R_Id :=\n+                 Get_Restriction_Id\n+                   (Process_Restriction_Synonyms (Chars (Expr)));\n \n-                     --  Restriction is active\n+               if R_Id not in All_Boolean_Restrictions then\n+                  Error_Pragma_Arg\n+                    (\"invalid restriction identifier\", Arg);\n+               end if;\n \n-                     else\n-                        if Implementation_Restriction (R_Id) then\n-                           Check_Restriction\n-                             (No_Implementation_Restrictions, Arg);\n-                        end if;\n+               if Implementation_Restriction (R_Id) then\n+                  Check_Restriction\n+                    (No_Implementation_Restrictions, Arg);\n+               end if;\n \n-                        Set_Restriction (R_Id, N);\n-                        Set_Warning (R_Id);\n+               Set_Restriction (R_Id, N);\n+               Set_Warning (R_Id);\n \n-                        --  A very special case that must be processed here:\n-                        --  pragma Restrictions (No_Exceptions) turns off\n-                        --  all run-time checking. This is a bit dubious in\n-                        --  terms of the formal language definition, but it\n-                        --  is what is intended by RM H.4(12).\n+               --  A very special case that must be processed here:\n+               --  pragma Restrictions (No_Exceptions) turns off\n+               --  all run-time checking. This is a bit dubious in\n+               --  terms of the formal language definition, but it\n+               --  is what is intended by RM H.4(12).\n \n-                        if R_Id = No_Exceptions then\n-                           Scope_Suppress := (others => True);\n-                        end if;\n-                     end if;\n-                  end if;\n+               if R_Id = No_Exceptions then\n+                  Scope_Suppress := (others => True);\n                end if;\n \n-               --  Case of restriction identifier present\n+            --  Case of restriction identifier present\n \n             else\n-               R_Id := Get_Restriction_Id (Id);\n+               R_Id := Get_Restriction_Id (Process_Restriction_Synonyms (Id));\n                Analyze_And_Resolve (Expr, Any_Integer);\n \n                if R_Id not in All_Parameter_Restrictions then"}, {"sha": "ca49ae76de4d104760fa3ab2989c3cb10ee71f89", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -342,6 +342,7 @@ package body Snames is\n      \"link_name#\" &\n      \"lowercase#\" &\n      \"max_entry_queue_depth#\" &\n+     \"max_entry_queue_length#\" &\n      \"max_size#\" &\n      \"mechanism#\" &\n      \"mixedcase#\" &\n@@ -352,9 +353,12 @@ package body Snames is\n      \"on#\" &\n      \"parameter_types#\" &\n      \"reference#\" &\n+     \"no_dynamic_attachment#\" &\n      \"no_dynamic_interrupts#\" &\n      \"no_requeue#\" &\n+     \"no_requeue_statements#\" &\n      \"no_task_attributes#\" &\n+     \"no_task_attributes_package#\" &\n      \"restricted#\" &\n      \"result_mechanism#\" &\n      \"result_type#\" &\n@@ -363,6 +367,7 @@ package body Snames is\n      \"secondary_stack_size#\" &\n      \"section#\" &\n      \"semaphore#\" &\n+     \"simple_barriers#\" &\n      \"spec_file_name#\" &\n      \"static#\" &\n      \"stack_size#\" &"}, {"sha": "d4a5ad4dc12c8868da4098624d3143f0864cd3d6", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 348, "deletions": 343, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -540,46 +540,51 @@ package Snames is\n    Name_Link_Name                      : constant Name_Id := N + 282;\n    Name_Lowercase                      : constant Name_Id := N + 283;\n    Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 284;\n-   Name_Max_Size                       : constant Name_Id := N + 285;\n-   Name_Mechanism                      : constant Name_Id := N + 286;\n-   Name_Mixedcase                      : constant Name_Id := N + 287;\n-   Name_Modified_GPL                   : constant Name_Id := N + 288;\n-   Name_Name                           : constant Name_Id := N + 289;\n-   Name_NCA                            : constant Name_Id := N + 290;\n-   Name_No                             : constant Name_Id := N + 291;\n-   Name_On                             : constant Name_Id := N + 292;\n-   Name_Parameter_Types                : constant Name_Id := N + 293;\n-   Name_Reference                      : constant Name_Id := N + 294;\n-   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 295;\n-   Name_No_Requeue                     : constant Name_Id := N + 296;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 297;\n-   Name_Restricted                     : constant Name_Id := N + 298;\n-   Name_Result_Mechanism               : constant Name_Id := N + 299;\n-   Name_Result_Type                    : constant Name_Id := N + 300;\n-   Name_Runtime                        : constant Name_Id := N + 301;\n-   Name_SB                             : constant Name_Id := N + 302;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 303;\n-   Name_Section                        : constant Name_Id := N + 304;\n-   Name_Semaphore                      : constant Name_Id := N + 305;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 306;\n-   Name_Static                         : constant Name_Id := N + 307;\n-   Name_Stack_Size                     : constant Name_Id := N + 308;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 309;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 310;\n-   Name_Task_Type                      : constant Name_Id := N + 311;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 312;\n-   Name_Top_Guard                      : constant Name_Id := N + 313;\n-   Name_UBA                            : constant Name_Id := N + 314;\n-   Name_UBS                            : constant Name_Id := N + 315;\n-   Name_UBSB                           : constant Name_Id := N + 316;\n-   Name_Unit_Name                      : constant Name_Id := N + 317;\n-   Name_Unknown                        : constant Name_Id := N + 318;\n-   Name_Unrestricted                   : constant Name_Id := N + 319;\n-   Name_Uppercase                      : constant Name_Id := N + 320;\n-   Name_User                           : constant Name_Id := N + 321;\n-   Name_VAX_Float                      : constant Name_Id := N + 322;\n-   Name_VMS                            : constant Name_Id := N + 323;\n-   Name_Working_Storage                : constant Name_Id := N + 324;\n+   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 285;\n+   Name_Max_Size                       : constant Name_Id := N + 286;\n+   Name_Mechanism                      : constant Name_Id := N + 287;\n+   Name_Mixedcase                      : constant Name_Id := N + 288;\n+   Name_Modified_GPL                   : constant Name_Id := N + 289;\n+   Name_Name                           : constant Name_Id := N + 290;\n+   Name_NCA                            : constant Name_Id := N + 291;\n+   Name_No                             : constant Name_Id := N + 292;\n+   Name_On                             : constant Name_Id := N + 293;\n+   Name_Parameter_Types                : constant Name_Id := N + 294;\n+   Name_Reference                      : constant Name_Id := N + 295;\n+   Name_No_Dynamic_Attachment          : constant Name_Id := N + 296;\n+   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 297;\n+   Name_No_Requeue                     : constant Name_Id := N + 298;\n+   Name_No_Requeue_Statements          : constant Name_Id := N + 299;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 300;\n+   Name_No_Task_Attributes_Package     : constant Name_Id := N + 301;\n+   Name_Restricted                     : constant Name_Id := N + 302;\n+   Name_Result_Mechanism               : constant Name_Id := N + 303;\n+   Name_Result_Type                    : constant Name_Id := N + 304;\n+   Name_Runtime                        : constant Name_Id := N + 305;\n+   Name_SB                             : constant Name_Id := N + 306;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 307;\n+   Name_Section                        : constant Name_Id := N + 308;\n+   Name_Semaphore                      : constant Name_Id := N + 309;\n+   Name_Simple_Barriers                : constant Name_Id := N + 310;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 311;\n+   Name_Static                         : constant Name_Id := N + 312;\n+   Name_Stack_Size                     : constant Name_Id := N + 313;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 314;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 315;\n+   Name_Task_Type                      : constant Name_Id := N + 316;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 317;\n+   Name_Top_Guard                      : constant Name_Id := N + 318;\n+   Name_UBA                            : constant Name_Id := N + 319;\n+   Name_UBS                            : constant Name_Id := N + 320;\n+   Name_UBSB                           : constant Name_Id := N + 321;\n+   Name_Unit_Name                      : constant Name_Id := N + 322;\n+   Name_Unknown                        : constant Name_Id := N + 323;\n+   Name_Unrestricted                   : constant Name_Id := N + 324;\n+   Name_Uppercase                      : constant Name_Id := N + 325;\n+   Name_User                           : constant Name_Id := N + 326;\n+   Name_VAX_Float                      : constant Name_Id := N + 327;\n+   Name_VMS                            : constant Name_Id := N + 328;\n+   Name_Working_Storage                : constant Name_Id := N + 329;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -593,374 +598,374 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 325;\n-   Name_Abort_Signal                   : constant Name_Id := N + 325;  -- GNAT\n-   Name_Access                         : constant Name_Id := N + 326;\n-   Name_Address                        : constant Name_Id := N + 327;\n-   Name_Address_Size                   : constant Name_Id := N + 328;  -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 329;\n-   Name_Alignment                      : constant Name_Id := N + 330;\n-   Name_Asm_Input                      : constant Name_Id := N + 331;  -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 332;  -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 333;  -- VMS\n-   Name_Bit                            : constant Name_Id := N + 334;  -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 335;\n-   Name_Bit_Position                   : constant Name_Id := N + 336;  -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 337;\n-   Name_Callable                       : constant Name_Id := N + 338;\n-   Name_Caller                         : constant Name_Id := N + 339;\n-   Name_Code_Address                   : constant Name_Id := N + 340;  -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 341;\n-   Name_Compose                        : constant Name_Id := N + 342;\n-   Name_Constrained                    : constant Name_Id := N + 343;\n-   Name_Count                          : constant Name_Id := N + 344;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 345; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 346;\n-   Name_Delta                          : constant Name_Id := N + 347;\n-   Name_Denorm                         : constant Name_Id := N + 348;\n-   Name_Digits                         : constant Name_Id := N + 349;\n-   Name_Elaborated                     : constant Name_Id := N + 350; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 351; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 352; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 353; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 354;\n-   Name_External_Tag                   : constant Name_Id := N + 355;\n-   Name_First                          : constant Name_Id := N + 356;\n-   Name_First_Bit                      : constant Name_Id := N + 357;\n-   Name_Fixed_Value                    : constant Name_Id := N + 358; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 359;\n-   Name_Has_Discriminants              : constant Name_Id := N + 360; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 361;\n-   Name_Img                            : constant Name_Id := N + 362; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 363; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 364; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 365;\n-   Name_Last_Bit                       : constant Name_Id := N + 366;\n-   Name_Leading_Part                   : constant Name_Id := N + 367;\n-   Name_Length                         : constant Name_Id := N + 368;\n-   Name_Machine_Emax                   : constant Name_Id := N + 369;\n-   Name_Machine_Emin                   : constant Name_Id := N + 370;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 371;\n-   Name_Machine_Overflows              : constant Name_Id := N + 372;\n-   Name_Machine_Radix                  : constant Name_Id := N + 373;\n-   Name_Machine_Rounds                 : constant Name_Id := N + 374;\n-   Name_Machine_Size                   : constant Name_Id := N + 375; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 376; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 377;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 378; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 379; -- GNAT\n-   Name_Model_Emin                     : constant Name_Id := N + 380;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 381;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 382;\n-   Name_Model_Small                    : constant Name_Id := N + 383;\n-   Name_Modulus                        : constant Name_Id := N + 384;\n-   Name_Null_Parameter                 : constant Name_Id := N + 385; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 386; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 387;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 388; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 389;\n-   Name_Pos                            : constant Name_Id := N + 390;\n-   Name_Position                       : constant Name_Id := N + 391;\n-   Name_Range                          : constant Name_Id := N + 392;\n-   Name_Range_Length                   : constant Name_Id := N + 393; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 394;\n-   Name_Safe_Emax                      : constant Name_Id := N + 395; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 396;\n-   Name_Safe_Large                     : constant Name_Id := N + 397; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 398;\n-   Name_Safe_Small                     : constant Name_Id := N + 399; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 400;\n-   Name_Scaling                        : constant Name_Id := N + 401;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 402;\n-   Name_Size                           : constant Name_Id := N + 403;\n-   Name_Small                          : constant Name_Id := N + 404;\n-   Name_Storage_Size                   : constant Name_Id := N + 405;\n-   Name_Storage_Unit                   : constant Name_Id := N + 406; -- GNAT\n-   Name_Tag                            : constant Name_Id := N + 407;\n-   Name_Target_Name                    : constant Name_Id := N + 408; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 409;\n-   Name_To_Address                     : constant Name_Id := N + 410; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 411; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 412; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 413;\n-   Name_Unchecked_Access               : constant Name_Id := N + 414;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 415;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 416; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 417; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 418; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 419;\n-   Name_Valid                          : constant Name_Id := N + 420;\n-   Name_Value_Size                     : constant Name_Id := N + 421; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 422;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 423; -- GNAT\n-   Name_Wide_Width                     : constant Name_Id := N + 424;\n-   Name_Width                          : constant Name_Id := N + 425;\n-   Name_Word_Size                      : constant Name_Id := N + 426; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 330;\n+   Name_Abort_Signal                   : constant Name_Id := N + 330;  -- GNAT\n+   Name_Access                         : constant Name_Id := N + 331;\n+   Name_Address                        : constant Name_Id := N + 332;\n+   Name_Address_Size                   : constant Name_Id := N + 333;  -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 334;\n+   Name_Alignment                      : constant Name_Id := N + 335;\n+   Name_Asm_Input                      : constant Name_Id := N + 336;  -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 337;  -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 338;  -- VMS\n+   Name_Bit                            : constant Name_Id := N + 339;  -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 340;\n+   Name_Bit_Position                   : constant Name_Id := N + 341;  -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 342;\n+   Name_Callable                       : constant Name_Id := N + 343;\n+   Name_Caller                         : constant Name_Id := N + 344;\n+   Name_Code_Address                   : constant Name_Id := N + 345;  -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 346;\n+   Name_Compose                        : constant Name_Id := N + 347;\n+   Name_Constrained                    : constant Name_Id := N + 348;\n+   Name_Count                          : constant Name_Id := N + 349;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 350; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 351;\n+   Name_Delta                          : constant Name_Id := N + 352;\n+   Name_Denorm                         : constant Name_Id := N + 353;\n+   Name_Digits                         : constant Name_Id := N + 354;\n+   Name_Elaborated                     : constant Name_Id := N + 355; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 356; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 357; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 358; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 359;\n+   Name_External_Tag                   : constant Name_Id := N + 360;\n+   Name_First                          : constant Name_Id := N + 361;\n+   Name_First_Bit                      : constant Name_Id := N + 362;\n+   Name_Fixed_Value                    : constant Name_Id := N + 363; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 364;\n+   Name_Has_Discriminants              : constant Name_Id := N + 365; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 366;\n+   Name_Img                            : constant Name_Id := N + 367; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 368; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 369; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 370;\n+   Name_Last_Bit                       : constant Name_Id := N + 371;\n+   Name_Leading_Part                   : constant Name_Id := N + 372;\n+   Name_Length                         : constant Name_Id := N + 373;\n+   Name_Machine_Emax                   : constant Name_Id := N + 374;\n+   Name_Machine_Emin                   : constant Name_Id := N + 375;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 376;\n+   Name_Machine_Overflows              : constant Name_Id := N + 377;\n+   Name_Machine_Radix                  : constant Name_Id := N + 378;\n+   Name_Machine_Rounds                 : constant Name_Id := N + 379;\n+   Name_Machine_Size                   : constant Name_Id := N + 380; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 381; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 382;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 383; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 384; -- GNAT\n+   Name_Model_Emin                     : constant Name_Id := N + 385;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 386;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 387;\n+   Name_Model_Small                    : constant Name_Id := N + 388;\n+   Name_Modulus                        : constant Name_Id := N + 389;\n+   Name_Null_Parameter                 : constant Name_Id := N + 390; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 391; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 392;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 393; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 394;\n+   Name_Pos                            : constant Name_Id := N + 395;\n+   Name_Position                       : constant Name_Id := N + 396;\n+   Name_Range                          : constant Name_Id := N + 397;\n+   Name_Range_Length                   : constant Name_Id := N + 398; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 399;\n+   Name_Safe_Emax                      : constant Name_Id := N + 400; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 401;\n+   Name_Safe_Large                     : constant Name_Id := N + 402; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 403;\n+   Name_Safe_Small                     : constant Name_Id := N + 404; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 405;\n+   Name_Scaling                        : constant Name_Id := N + 406;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 407;\n+   Name_Size                           : constant Name_Id := N + 408;\n+   Name_Small                          : constant Name_Id := N + 409;\n+   Name_Storage_Size                   : constant Name_Id := N + 410;\n+   Name_Storage_Unit                   : constant Name_Id := N + 411; -- GNAT\n+   Name_Tag                            : constant Name_Id := N + 412;\n+   Name_Target_Name                    : constant Name_Id := N + 413; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 414;\n+   Name_To_Address                     : constant Name_Id := N + 415; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 416; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 417; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 418;\n+   Name_Unchecked_Access               : constant Name_Id := N + 419;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 420;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 421; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 422; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 423; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 424;\n+   Name_Valid                          : constant Name_Id := N + 425;\n+   Name_Value_Size                     : constant Name_Id := N + 426; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 427;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 428; -- GNAT\n+   Name_Wide_Width                     : constant Name_Id := N + 429;\n+   Name_Width                          : constant Name_Id := N + 430;\n+   Name_Word_Size                      : constant Name_Id := N + 431; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 427;\n-   Name_Adjacent                       : constant Name_Id := N + 427;\n-   Name_Ceiling                        : constant Name_Id := N + 428;\n-   Name_Copy_Sign                      : constant Name_Id := N + 429;\n-   Name_Floor                          : constant Name_Id := N + 430;\n-   Name_Fraction                       : constant Name_Id := N + 431;\n-   Name_Image                          : constant Name_Id := N + 432;\n-   Name_Input                          : constant Name_Id := N + 433;\n-   Name_Machine                        : constant Name_Id := N + 434;\n-   Name_Max                            : constant Name_Id := N + 435;\n-   Name_Min                            : constant Name_Id := N + 436;\n-   Name_Model                          : constant Name_Id := N + 437;\n-   Name_Pred                           : constant Name_Id := N + 438;\n-   Name_Remainder                      : constant Name_Id := N + 439;\n-   Name_Rounding                       : constant Name_Id := N + 440;\n-   Name_Succ                           : constant Name_Id := N + 441;\n-   Name_Truncation                     : constant Name_Id := N + 442;\n-   Name_Value                          : constant Name_Id := N + 443;\n-   Name_Wide_Image                     : constant Name_Id := N + 444;\n-   Name_Wide_Value                     : constant Name_Id := N + 445;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 445;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 432;\n+   Name_Adjacent                       : constant Name_Id := N + 432;\n+   Name_Ceiling                        : constant Name_Id := N + 433;\n+   Name_Copy_Sign                      : constant Name_Id := N + 434;\n+   Name_Floor                          : constant Name_Id := N + 435;\n+   Name_Fraction                       : constant Name_Id := N + 436;\n+   Name_Image                          : constant Name_Id := N + 437;\n+   Name_Input                          : constant Name_Id := N + 438;\n+   Name_Machine                        : constant Name_Id := N + 439;\n+   Name_Max                            : constant Name_Id := N + 440;\n+   Name_Min                            : constant Name_Id := N + 441;\n+   Name_Model                          : constant Name_Id := N + 442;\n+   Name_Pred                           : constant Name_Id := N + 443;\n+   Name_Remainder                      : constant Name_Id := N + 444;\n+   Name_Rounding                       : constant Name_Id := N + 445;\n+   Name_Succ                           : constant Name_Id := N + 446;\n+   Name_Truncation                     : constant Name_Id := N + 447;\n+   Name_Value                          : constant Name_Id := N + 448;\n+   Name_Wide_Image                     : constant Name_Id := N + 449;\n+   Name_Wide_Value                     : constant Name_Id := N + 450;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 450;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 446;\n-   Name_Output                         : constant Name_Id := N + 446;\n-   Name_Read                           : constant Name_Id := N + 447;\n-   Name_Write                          : constant Name_Id := N + 448;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 448;\n+   First_Procedure_Attribute           : constant Name_Id := N + 451;\n+   Name_Output                         : constant Name_Id := N + 451;\n+   Name_Read                           : constant Name_Id := N + 452;\n+   Name_Write                          : constant Name_Id := N + 453;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 453;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 449;\n-   Name_Elab_Body                      : constant Name_Id := N + 449; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 450; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 451;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 454;\n+   Name_Elab_Body                      : constant Name_Id := N + 454; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 455; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 456;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 452;\n-   Name_Base                           : constant Name_Id := N + 452;\n-   Name_Class                          : constant Name_Id := N + 453;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 453;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 453;\n-   Last_Attribute_Name                 : constant Name_Id := N + 453;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 457;\n+   Name_Base                           : constant Name_Id := N + 457;\n+   Name_Class                          : constant Name_Id := N + 458;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 458;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 458;\n+   Last_Attribute_Name                 : constant Name_Id := N + 458;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 454;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 454;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 455;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 455;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 459;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 459;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 460;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 460;\n \n    --  Names of recognized queuing policy identifiers.\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 456;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 456;\n-   Name_Priority_Queuing               : constant Name_Id := N + 457;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 457;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 461;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 461;\n+   Name_Priority_Queuing               : constant Name_Id := N + 462;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 462;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_WIthinn_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 458;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 458;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 458;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 463;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 463;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 463;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 459;\n-   Name_Access_Check                   : constant Name_Id := N + 459;\n-   Name_Accessibility_Check            : constant Name_Id := N + 460;\n-   Name_Discriminant_Check             : constant Name_Id := N + 461;\n-   Name_Division_Check                 : constant Name_Id := N + 462;\n-   Name_Elaboration_Check              : constant Name_Id := N + 463;\n-   Name_Index_Check                    : constant Name_Id := N + 464;\n-   Name_Length_Check                   : constant Name_Id := N + 465;\n-   Name_Overflow_Check                 : constant Name_Id := N + 466;\n-   Name_Range_Check                    : constant Name_Id := N + 467;\n-   Name_Storage_Check                  : constant Name_Id := N + 468;\n-   Name_Tag_Check                      : constant Name_Id := N + 469;\n-   Name_All_Checks                     : constant Name_Id := N + 470;\n-   Last_Check_Name                     : constant Name_Id := N + 470;\n+   First_Check_Name                    : constant Name_Id := N + 464;\n+   Name_Access_Check                   : constant Name_Id := N + 464;\n+   Name_Accessibility_Check            : constant Name_Id := N + 465;\n+   Name_Discriminant_Check             : constant Name_Id := N + 466;\n+   Name_Division_Check                 : constant Name_Id := N + 467;\n+   Name_Elaboration_Check              : constant Name_Id := N + 468;\n+   Name_Index_Check                    : constant Name_Id := N + 469;\n+   Name_Length_Check                   : constant Name_Id := N + 470;\n+   Name_Overflow_Check                 : constant Name_Id := N + 471;\n+   Name_Range_Check                    : constant Name_Id := N + 472;\n+   Name_Storage_Check                  : constant Name_Id := N + 473;\n+   Name_Tag_Check                      : constant Name_Id := N + 474;\n+   Name_All_Checks                     : constant Name_Id := N + 475;\n+   Last_Check_Name                     : constant Name_Id := N + 475;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 471;\n-   Name_Abs                            : constant Name_Id := N + 472;\n-   Name_Accept                         : constant Name_Id := N + 473;\n-   Name_And                            : constant Name_Id := N + 474;\n-   Name_All                            : constant Name_Id := N + 475;\n-   Name_Array                          : constant Name_Id := N + 476;\n-   Name_At                             : constant Name_Id := N + 477;\n-   Name_Begin                          : constant Name_Id := N + 478;\n-   Name_Body                           : constant Name_Id := N + 479;\n-   Name_Case                           : constant Name_Id := N + 480;\n-   Name_Constant                       : constant Name_Id := N + 481;\n-   Name_Declare                        : constant Name_Id := N + 482;\n-   Name_Delay                          : constant Name_Id := N + 483;\n-   Name_Do                             : constant Name_Id := N + 484;\n-   Name_Else                           : constant Name_Id := N + 485;\n-   Name_Elsif                          : constant Name_Id := N + 486;\n-   Name_End                            : constant Name_Id := N + 487;\n-   Name_Entry                          : constant Name_Id := N + 488;\n-   Name_Exception                      : constant Name_Id := N + 489;\n-   Name_Exit                           : constant Name_Id := N + 490;\n-   Name_For                            : constant Name_Id := N + 491;\n-   Name_Function                       : constant Name_Id := N + 492;\n-   Name_Generic                        : constant Name_Id := N + 493;\n-   Name_Goto                           : constant Name_Id := N + 494;\n-   Name_If                             : constant Name_Id := N + 495;\n-   Name_In                             : constant Name_Id := N + 496;\n-   Name_Is                             : constant Name_Id := N + 497;\n-   Name_Limited                        : constant Name_Id := N + 498;\n-   Name_Loop                           : constant Name_Id := N + 499;\n-   Name_Mod                            : constant Name_Id := N + 500;\n-   Name_New                            : constant Name_Id := N + 501;\n-   Name_Not                            : constant Name_Id := N + 502;\n-   Name_Null                           : constant Name_Id := N + 503;\n-   Name_Of                             : constant Name_Id := N + 504;\n-   Name_Or                             : constant Name_Id := N + 505;\n-   Name_Others                         : constant Name_Id := N + 506;\n-   Name_Out                            : constant Name_Id := N + 507;\n-   Name_Package                        : constant Name_Id := N + 508;\n-   Name_Pragma                         : constant Name_Id := N + 509;\n-   Name_Private                        : constant Name_Id := N + 510;\n-   Name_Procedure                      : constant Name_Id := N + 511;\n-   Name_Raise                          : constant Name_Id := N + 512;\n-   Name_Record                         : constant Name_Id := N + 513;\n-   Name_Rem                            : constant Name_Id := N + 514;\n-   Name_Renames                        : constant Name_Id := N + 515;\n-   Name_Return                         : constant Name_Id := N + 516;\n-   Name_Reverse                        : constant Name_Id := N + 517;\n-   Name_Select                         : constant Name_Id := N + 518;\n-   Name_Separate                       : constant Name_Id := N + 519;\n-   Name_Subtype                        : constant Name_Id := N + 520;\n-   Name_Task                           : constant Name_Id := N + 521;\n-   Name_Terminate                      : constant Name_Id := N + 522;\n-   Name_Then                           : constant Name_Id := N + 523;\n-   Name_Type                           : constant Name_Id := N + 524;\n-   Name_Use                            : constant Name_Id := N + 525;\n-   Name_When                           : constant Name_Id := N + 526;\n-   Name_While                          : constant Name_Id := N + 527;\n-   Name_With                           : constant Name_Id := N + 528;\n-   Name_Xor                            : constant Name_Id := N + 529;\n+   Name_Abort                          : constant Name_Id := N + 476;\n+   Name_Abs                            : constant Name_Id := N + 477;\n+   Name_Accept                         : constant Name_Id := N + 478;\n+   Name_And                            : constant Name_Id := N + 479;\n+   Name_All                            : constant Name_Id := N + 480;\n+   Name_Array                          : constant Name_Id := N + 481;\n+   Name_At                             : constant Name_Id := N + 482;\n+   Name_Begin                          : constant Name_Id := N + 483;\n+   Name_Body                           : constant Name_Id := N + 484;\n+   Name_Case                           : constant Name_Id := N + 485;\n+   Name_Constant                       : constant Name_Id := N + 486;\n+   Name_Declare                        : constant Name_Id := N + 487;\n+   Name_Delay                          : constant Name_Id := N + 488;\n+   Name_Do                             : constant Name_Id := N + 489;\n+   Name_Else                           : constant Name_Id := N + 490;\n+   Name_Elsif                          : constant Name_Id := N + 491;\n+   Name_End                            : constant Name_Id := N + 492;\n+   Name_Entry                          : constant Name_Id := N + 493;\n+   Name_Exception                      : constant Name_Id := N + 494;\n+   Name_Exit                           : constant Name_Id := N + 495;\n+   Name_For                            : constant Name_Id := N + 496;\n+   Name_Function                       : constant Name_Id := N + 497;\n+   Name_Generic                        : constant Name_Id := N + 498;\n+   Name_Goto                           : constant Name_Id := N + 499;\n+   Name_If                             : constant Name_Id := N + 500;\n+   Name_In                             : constant Name_Id := N + 501;\n+   Name_Is                             : constant Name_Id := N + 502;\n+   Name_Limited                        : constant Name_Id := N + 503;\n+   Name_Loop                           : constant Name_Id := N + 504;\n+   Name_Mod                            : constant Name_Id := N + 505;\n+   Name_New                            : constant Name_Id := N + 506;\n+   Name_Not                            : constant Name_Id := N + 507;\n+   Name_Null                           : constant Name_Id := N + 508;\n+   Name_Of                             : constant Name_Id := N + 509;\n+   Name_Or                             : constant Name_Id := N + 510;\n+   Name_Others                         : constant Name_Id := N + 511;\n+   Name_Out                            : constant Name_Id := N + 512;\n+   Name_Package                        : constant Name_Id := N + 513;\n+   Name_Pragma                         : constant Name_Id := N + 514;\n+   Name_Private                        : constant Name_Id := N + 515;\n+   Name_Procedure                      : constant Name_Id := N + 516;\n+   Name_Raise                          : constant Name_Id := N + 517;\n+   Name_Record                         : constant Name_Id := N + 518;\n+   Name_Rem                            : constant Name_Id := N + 519;\n+   Name_Renames                        : constant Name_Id := N + 520;\n+   Name_Return                         : constant Name_Id := N + 521;\n+   Name_Reverse                        : constant Name_Id := N + 522;\n+   Name_Select                         : constant Name_Id := N + 523;\n+   Name_Separate                       : constant Name_Id := N + 524;\n+   Name_Subtype                        : constant Name_Id := N + 525;\n+   Name_Task                           : constant Name_Id := N + 526;\n+   Name_Terminate                      : constant Name_Id := N + 527;\n+   Name_Then                           : constant Name_Id := N + 528;\n+   Name_Type                           : constant Name_Id := N + 529;\n+   Name_Use                            : constant Name_Id := N + 530;\n+   Name_When                           : constant Name_Id := N + 531;\n+   Name_While                          : constant Name_Id := N + 532;\n+   Name_With                           : constant Name_Id := N + 533;\n+   Name_Xor                            : constant Name_Id := N + 534;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                : constant Name_Id := N + 530;\n-   Name_Divide                         : constant Name_Id := N + 530;\n-   Name_Enclosing_Entity               : constant Name_Id := N + 531;\n-   Name_Exception_Information          : constant Name_Id := N + 532;\n-   Name_Exception_Message              : constant Name_Id := N + 533;\n-   Name_Exception_Name                 : constant Name_Id := N + 534;\n-   Name_File                           : constant Name_Id := N + 535;\n-   Name_Import_Address                 : constant Name_Id := N + 536;\n-   Name_Import_Largest_Value           : constant Name_Id := N + 537;\n-   Name_Import_Value                   : constant Name_Id := N + 538;\n-   Name_Is_Negative                    : constant Name_Id := N + 539;\n-   Name_Line                           : constant Name_Id := N + 540;\n-   Name_Rotate_Left                    : constant Name_Id := N + 541;\n-   Name_Rotate_Right                   : constant Name_Id := N + 542;\n-   Name_Shift_Left                     : constant Name_Id := N + 543;\n-   Name_Shift_Right                    : constant Name_Id := N + 544;\n-   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 545;\n-   Name_Source_Location                : constant Name_Id := N + 546;\n-   Name_Unchecked_Conversion           : constant Name_Id := N + 547;\n-   Name_Unchecked_Deallocation         : constant Name_Id := N + 548;\n-   Name_To_Pointer                     : constant Name_Id := N + 549;\n-   Last_Intrinsic_Name                 : constant Name_Id := N + 549;\n+   First_Intrinsic_Name                : constant Name_Id := N + 535;\n+   Name_Divide                         : constant Name_Id := N + 535;\n+   Name_Enclosing_Entity               : constant Name_Id := N + 536;\n+   Name_Exception_Information          : constant Name_Id := N + 537;\n+   Name_Exception_Message              : constant Name_Id := N + 538;\n+   Name_Exception_Name                 : constant Name_Id := N + 539;\n+   Name_File                           : constant Name_Id := N + 540;\n+   Name_Import_Address                 : constant Name_Id := N + 541;\n+   Name_Import_Largest_Value           : constant Name_Id := N + 542;\n+   Name_Import_Value                   : constant Name_Id := N + 543;\n+   Name_Is_Negative                    : constant Name_Id := N + 544;\n+   Name_Line                           : constant Name_Id := N + 545;\n+   Name_Rotate_Left                    : constant Name_Id := N + 546;\n+   Name_Rotate_Right                   : constant Name_Id := N + 547;\n+   Name_Shift_Left                     : constant Name_Id := N + 548;\n+   Name_Shift_Right                    : constant Name_Id := N + 549;\n+   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 550;\n+   Name_Source_Location                : constant Name_Id := N + 551;\n+   Name_Unchecked_Conversion           : constant Name_Id := N + 552;\n+   Name_Unchecked_Deallocation         : constant Name_Id := N + 553;\n+   Name_To_Pointer                     : constant Name_Id := N + 554;\n+   Last_Intrinsic_Name                 : constant Name_Id := N + 554;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 550;\n-   Name_Abstract                       : constant Name_Id := N + 550;\n-   Name_Aliased                        : constant Name_Id := N + 551;\n-   Name_Protected                      : constant Name_Id := N + 552;\n-   Name_Until                          : constant Name_Id := N + 553;\n-   Name_Requeue                        : constant Name_Id := N + 554;\n-   Name_Tagged                         : constant Name_Id := N + 555;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 555;\n+   First_95_Reserved_Word              : constant Name_Id := N + 555;\n+   Name_Abstract                       : constant Name_Id := N + 555;\n+   Name_Aliased                        : constant Name_Id := N + 556;\n+   Name_Protected                      : constant Name_Id := N + 557;\n+   Name_Until                          : constant Name_Id := N + 558;\n+   Name_Requeue                        : constant Name_Id := N + 559;\n+   Name_Tagged                         : constant Name_Id := N + 560;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 560;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 556;\n+   Name_Raise_Exception                : constant Name_Id := N + 561;\n \n    --  Additional reserved words in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Binder                         : constant Name_Id := N + 557;\n-   Name_Body_Suffix                    : constant Name_Id := N + 558;\n-   Name_Builder                        : constant Name_Id := N + 559;\n-   Name_Compiler                       : constant Name_Id := N + 560;\n-   Name_Cross_Reference                : constant Name_Id := N + 561;\n-   Name_Default_Switches               : constant Name_Id := N + 562;\n-   Name_Exec_Dir                       : constant Name_Id := N + 563;\n-   Name_Executable                     : constant Name_Id := N + 564;\n-   Name_Executable_Suffix              : constant Name_Id := N + 565;\n-   Name_Extends                        : constant Name_Id := N + 566;\n-   Name_Finder                         : constant Name_Id := N + 567;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 568;\n-   Name_Gnatls                         : constant Name_Id := N + 569;\n-   Name_Gnatstub                       : constant Name_Id := N + 570;\n-   Name_Implementation                 : constant Name_Id := N + 571;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 572;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 573;\n-   Name_Languages                      : constant Name_Id := N + 574;\n-   Name_Library_Dir                    : constant Name_Id := N + 575;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 576;\n-   Name_Library_GCC                    : constant Name_Id := N + 577;\n-   Name_Library_Interface              : constant Name_Id := N + 578;\n-   Name_Library_Kind                   : constant Name_Id := N + 579;\n-   Name_Library_Name                   : constant Name_Id := N + 580;\n-   Name_Library_Options                : constant Name_Id := N + 581;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 582;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 583;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 584;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 585;\n-   Name_Library_Version                : constant Name_Id := N + 586;\n-   Name_Linker                         : constant Name_Id := N + 587;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 588;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 589;\n-   Name_Naming                         : constant Name_Id := N + 590;\n-   Name_Object_Dir                     : constant Name_Id := N + 591;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 592;\n-   Name_Project                        : constant Name_Id := N + 593;\n-   Name_Separate_Suffix                : constant Name_Id := N + 594;\n-   Name_Source_Dirs                    : constant Name_Id := N + 595;\n-   Name_Source_Files                   : constant Name_Id := N + 596;\n-   Name_Source_List_File               : constant Name_Id := N + 597;\n-   Name_Spec                           : constant Name_Id := N + 598;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 599;\n-   Name_Specification                  : constant Name_Id := N + 600;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 601;\n-   Name_Specification_Suffix           : constant Name_Id := N + 602;\n-   Name_Switches                       : constant Name_Id := N + 603;\n+   Name_Binder                         : constant Name_Id := N + 562;\n+   Name_Body_Suffix                    : constant Name_Id := N + 563;\n+   Name_Builder                        : constant Name_Id := N + 564;\n+   Name_Compiler                       : constant Name_Id := N + 565;\n+   Name_Cross_Reference                : constant Name_Id := N + 566;\n+   Name_Default_Switches               : constant Name_Id := N + 567;\n+   Name_Exec_Dir                       : constant Name_Id := N + 568;\n+   Name_Executable                     : constant Name_Id := N + 569;\n+   Name_Executable_Suffix              : constant Name_Id := N + 570;\n+   Name_Extends                        : constant Name_Id := N + 571;\n+   Name_Finder                         : constant Name_Id := N + 572;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 573;\n+   Name_Gnatls                         : constant Name_Id := N + 574;\n+   Name_Gnatstub                       : constant Name_Id := N + 575;\n+   Name_Implementation                 : constant Name_Id := N + 576;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 577;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 578;\n+   Name_Languages                      : constant Name_Id := N + 579;\n+   Name_Library_Dir                    : constant Name_Id := N + 580;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 581;\n+   Name_Library_GCC                    : constant Name_Id := N + 582;\n+   Name_Library_Interface              : constant Name_Id := N + 583;\n+   Name_Library_Kind                   : constant Name_Id := N + 584;\n+   Name_Library_Name                   : constant Name_Id := N + 585;\n+   Name_Library_Options                : constant Name_Id := N + 586;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 587;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 588;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 589;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 590;\n+   Name_Library_Version                : constant Name_Id := N + 591;\n+   Name_Linker                         : constant Name_Id := N + 592;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 593;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 594;\n+   Name_Naming                         : constant Name_Id := N + 595;\n+   Name_Object_Dir                     : constant Name_Id := N + 596;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 597;\n+   Name_Project                        : constant Name_Id := N + 598;\n+   Name_Separate_Suffix                : constant Name_Id := N + 599;\n+   Name_Source_Dirs                    : constant Name_Id := N + 600;\n+   Name_Source_Files                   : constant Name_Id := N + 601;\n+   Name_Source_List_File               : constant Name_Id := N + 602;\n+   Name_Spec                           : constant Name_Id := N + 603;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 604;\n+   Name_Specification                  : constant Name_Id := N + 605;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 606;\n+   Name_Specification_Suffix           : constant Name_Id := N + 607;\n+   Name_Switches                       : constant Name_Id := N + 608;\n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 604;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 609;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 604;\n+   Last_Predefined_Name                : constant Name_Id := N + 609;\n \n    subtype Any_Operator_Name is Name_Id range\n      First_Operator_Name .. Last_Operator_Name;"}, {"sha": "c9286121ee3c6c9846deb66c5ba6c47444e482e6", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 277, "deletions": 72, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -83,6 +83,13 @@ int type_annotate_only;\n    over GC.  */\n tree gnu_block_stack;\n \n+/* The current BLOCK_STMT node.  TREE_CHAIN points to the previous\n+   BLOCK_STMT node.  */\n+static GTY(()) tree gnu_block_stmt_node;\n+\n+/* List of unused BLOCK_STMT nodes.  */\n+static GTY((deletable)) tree gnu_block_stmt_free_list;\n+\n /* List of TREE_LIST nodes representing a stack of exception pointer\n    variables.  TREE_VALUE is the VAR_DECL that stores the address of\n    the raised exception.  Nonzero means we are in an exception\n@@ -105,6 +112,8 @@ static GTY(()) tree gnu_return_label_stack;\n \n static tree tree_transform (Node_Id);\n static rtx first_nondeleted_insn (rtx);\n+static tree start_block_stmt (void);\n+static tree end_block_stmt (void);\n static tree build_block_stmt (List_Id);\n static tree make_expr_stmt_from_rtl (rtx, Node_Id);\n static void elaborate_all_entities (Node_Id);\n@@ -186,6 +195,7 @@ gigi (Node_Id gnat_root,\n   init_dummy_type ();\n   init_code_table ();\n   gnat_compute_largest_alignment ();\n+  start_block_stmt ();\n \n   /* Enable GNAT stack checking method if needed */\n   if (!Stack_Check_Probes_On_Target)\n@@ -237,12 +247,16 @@ gnat_to_code (Node_Id gnat_node)\n   /* Save node number in case error */\n   error_gnat_node = gnat_node;\n \n+  start_block_stmt ();\n   gnu_root = tree_transform (gnat_node);\n+  gnat_expand_stmt (end_block_stmt ());\n \n   /* If we return a statement, generate code for it.  */\n   if (IS_STMT (gnu_root))\n-    expand_expr_stmt (gnu_root);\n-\n+    {\n+      if (TREE_CODE (gnu_root) != NULL_STMT)\n+\tgnat_expand_stmt (gnu_root);\n+    }\n   /* This should just generate code, not return a value.  If it returns\n      a value, something is wrong.  */\n   else if (gnu_root != error_mark_node)\n@@ -275,7 +289,9 @@ gnat_to_gnu (Node_Id gnat_node)\n   /* Save node number in case error */\n   error_gnat_node = gnat_node;\n \n+  start_block_stmt ();\n   gnu_root = tree_transform (gnat_node);\n+  gnat_expand_stmt (end_block_stmt ());\n \n   if (gnu_root == error_mark_node)\n     {\n@@ -808,10 +824,14 @@ tree_transform (Node_Id gnat_node)\n \t    {\n \t      if ((Is_Public (gnat_temp) || global_bindings_p ())\n \t\t  && ! TREE_CONSTANT (gnu_expr))\n-\t\tgnu_expr\n-\t\t  = create_var_decl (create_concat_name (gnat_temp, \"init\"),\n-\t\t\t\t     NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr,\n-\t\t\t\t     0, Is_Public (gnat_temp), 0, 0, 0);\n+\t\t{\n+\t\t  gnu_expr\n+\t\t    = create_var_decl (create_concat_name (gnat_temp, \"init\"),\n+\t\t\t\t       NULL_TREE, TREE_TYPE (gnu_expr),\n+\t\t\t\t       gnu_expr, 0, Is_Public (gnat_temp), 0,\n+\t\t\t\t       0, 0);\n+\t\t  add_decl_stmt (gnu_expr, gnat_temp);\n+\t\t}\n \t      else\n \t\tgnu_expr = maybe_variable (gnu_expr, Expression (gnat_node));\n \n@@ -841,10 +861,8 @@ tree_transform (Node_Id gnat_node)\n \t\t&& (Is_Array_Type (Etype (gnat_temp))\n \t\t    || Is_Record_Type (Etype (gnat_temp))\n \t\t    || Is_Concurrent_Type (Etype (gnat_temp)))))\n-        {\n-          gnu_expr = gnat_to_gnu (Renamed_Object (gnat_temp));\n-          gnat_to_gnu_entity (gnat_temp, gnu_expr, 1);\n-        }\n+\tgnat_to_gnu_entity (gnat_temp,\n+\t\t\t    gnat_to_gnu (Renamed_Object (gnat_temp)), 1);\n       break;\n \n     case N_Implicit_Label_Declaration:\n@@ -2083,6 +2101,7 @@ tree_transform (Node_Id gnat_node)\n       break;\n \n     case N_Null_Statement:\n+      gnu_result = build_nt (NULL_STMT);\n       break;\n \n     case N_Assignment_Statement:\n@@ -2255,7 +2274,7 @@ tree_transform (Node_Id gnat_node)\n \t       variables are declared since we want them to be local to this\n \t       set of statements instead of the block containing the Case\n \t       statement.  */\n-\t    pushlevel (0);\n+\t    gnat_pushlevel ();\n \t    expand_start_bindings (0);\n \t    for (gnat_statement = First (Statements (gnat_when));\n \t\t Present (gnat_statement);\n@@ -2265,8 +2284,8 @@ tree_transform (Node_Id gnat_node)\n \t    /* Communicate to GCC that we are done with the current WHEN,\n \t       i.e. insert a \"break\" statement.  */\n \t    expand_exit_something ();\n-\t    expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-\t    poplevel (kept_level_p (), 1, 0);\n+\t    expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+\t    gnat_poplevel ();\n \t  }\n \n \texpand_end_case (gnu_expr);\n@@ -2334,11 +2353,13 @@ tree_transform (Node_Id gnat_node)\n \n \t    /* Open a new nesting level that will surround the loop to declare\n \t       the loop index variable.  */\n-\t    pushlevel (0);\n+\t    gnat_pushlevel ();\n \t    expand_start_bindings (0);\n \n \t    /* Declare the loop index and set it to its initial value.  */\n+\t    start_block_stmt ();\n \t    gnu_loop_var = gnat_to_gnu_entity (gnat_loop_var, gnu_first, 1);\n+\t    expand_expr_stmt (end_block_stmt ());\n \t    if (DECL_BY_REF_P (gnu_loop_var))\n \t      gnu_loop_var = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t\t     gnu_loop_var);\n@@ -2394,7 +2415,7 @@ tree_transform (Node_Id gnat_node)\n            storage will be released every iteration.  This is needed\n            for stack allocation.  */\n \n-        pushlevel (0);\n+        gnat_pushlevel ();\n         gnu_block_stack\n \t  = tree_cons (gnu_bottom_condition, NULL_TREE, gnu_block_stack);\n         expand_start_bindings (0);\n@@ -2404,8 +2425,8 @@ tree_transform (Node_Id gnat_node)\n \t     gnat_statement = Next (gnat_statement))\n \t  gnat_to_code (gnat_statement);\n \n-        expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-        poplevel (kept_level_p (), 1, 0);\n+        expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+        gnat_poplevel ();\n         gnu_block_stack = TREE_CHAIN (gnu_block_stack);\n \n \tset_lineno (gnat_node, 1);\n@@ -2430,8 +2451,8 @@ tree_transform (Node_Id gnat_node)\n \t    /* Close the nesting level that sourround the loop that was used to\n \t       declare the loop index variable.   */\n \t    set_lineno (gnat_node, 1);\n-\t    expand_end_bindings (NULL_TREE, 1, -1);\n-\t    poplevel (1, 1, 0);\n+\t    expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+\t    gnat_poplevel ();\n \t  }\n \n \tif (enclosing_if_p)\n@@ -2443,13 +2464,15 @@ tree_transform (Node_Id gnat_node)\n       break;\n \n     case N_Block_Statement:\n-      pushlevel (0);\n+      gnat_pushlevel ();\n       gnu_block_stack = tree_cons (NULL_TREE, NULL_TREE, gnu_block_stack);\n       expand_start_bindings (0);\n+      start_block_stmt ();\n       process_decls (Declarations (gnat_node), Empty, Empty, 1, 1);\n+      gnat_expand_stmt (end_block_stmt ());\n       gnat_to_code (Handled_Statement_Sequence (gnat_node));\n-      expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-      poplevel (kept_level_p (), 1, 0);\n+      expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+      gnat_poplevel ();\n       gnu_block_stack = TREE_CHAIN (gnu_block_stack);\n       if (Present (Identifier (gnat_node)))\n \tmark_out_of_scope (Entity (Identifier (gnat_node)));\n@@ -2678,9 +2701,10 @@ tree_transform (Node_Id gnat_node)\n \t   result in having the first line of the subprogram counted twice by\n \t   gcov.  */\n \n-\tpushlevel (0);\n+\tgnat_pushlevel ();\n \tgnu_block_stack = tree_cons (NULL_TREE, NULL_TREE, gnu_block_stack);\n   \texpand_start_bindings (0);\n+\tstart_block_stmt ();\n \n \tgnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n \n@@ -2695,7 +2719,7 @@ tree_transform (Node_Id gnat_node)\n \t      = tree_cons (NULL_TREE,\n \t\t\t   build_decl (LABEL_DECL, NULL_TREE, NULL_TREE),\n \t\t\t   gnu_return_label_stack);\n-\t    pushlevel (0);\n+\t    gnat_pushlevel ();\n \t    expand_start_bindings (0);\n \t  }\n \telse\n@@ -2712,38 +2736,39 @@ tree_transform (Node_Id gnat_node)\n \tfor (gnat_param = First_Formal (gnat_subprog_id);\n \t     Present (gnat_param);\n \t     gnat_param = Next_Formal_With_Extras (gnat_param))\n-\t  if (present_gnu_tree (gnat_param))\n-\t    adjust_decl_rtl (get_gnu_tree (gnat_param));\n-\t  else\n+\t  if (!present_gnu_tree (gnat_param))\n \t    {\n \t      /* Skip any entries that have been already filled in; they\n \t\t must correspond to IN OUT parameters.  */\n-\t    for (; gnu_cico_list != 0 && TREE_VALUE (gnu_cico_list) != 0;\n-\t\t gnu_cico_list = TREE_CHAIN (gnu_cico_list))\n-\t      ;\n-\n-\t    /* Do any needed references for padded types.  */\n-\t    TREE_VALUE (gnu_cico_list)\n-\t      = convert (TREE_TYPE (TREE_PURPOSE (gnu_cico_list)),\n-\t\t\t gnat_to_gnu_entity (gnat_param, NULL_TREE, 1));\n-\t  }\n+\t      for (; gnu_cico_list != 0 && TREE_VALUE (gnu_cico_list) != 0;\n+\t\t   gnu_cico_list = TREE_CHAIN (gnu_cico_list))\n+\t\t;\n+\n+\t      /* Do any needed references for padded types.  */\n+\t      TREE_VALUE (gnu_cico_list)\n+\t\t= convert (TREE_TYPE (TREE_PURPOSE (gnu_cico_list)),\n+\t\t\t   gnat_to_gnu_entity (gnat_param, NULL_TREE, 1));\n+\t    }\n \n+\tgnat_expand_stmt (end_block_stmt());\n+\tstart_block_stmt ();\n \tprocess_decls (Declarations (gnat_node), Empty, Empty, 1, 1);\n+\tgnat_expand_stmt (end_block_stmt ());\n \n \t/* Generate the code of the subprogram itself.  A return statement\n \t   will be present and any OUT parameters will be handled there.  */\n \tgnat_to_code (Handled_Statement_Sequence (gnat_node));\n \n-\texpand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-\tpoplevel (kept_level_p (), 1, 0);\n+\texpand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+\tgnat_poplevel ();\n \tgnu_block_stack = TREE_CHAIN (gnu_block_stack);\n \n \tif (TREE_VALUE (gnu_return_label_stack) != 0)\n \t  {\n \t    tree gnu_retval;\n \n-\t    expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-\t    poplevel (kept_level_p (), 1, 0);\n+\t    expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+\t    gnat_poplevel ();\n \t    expand_label (TREE_VALUE (gnu_return_label_stack));\n \n \t    gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n@@ -3270,8 +3295,10 @@ tree_transform (Node_Id gnat_node)\n \n     case N_Package_Specification:\n \n+      start_block_stmt ();\n       process_decls (Visible_Declarations (gnat_node),\n \t\t     Private_Declarations (gnat_node), Empty, 1, 1);\n+      gnat_expand_stmt (end_block_stmt ());\n       break;\n \n     case N_Package_Body:\n@@ -3280,7 +3307,9 @@ tree_transform (Node_Id gnat_node)\n       if (Ekind (Corresponding_Spec (gnat_node)) == E_Generic_Package)\n \tbreak;\n \n+      start_block_stmt ();\n       process_decls (Declarations (gnat_node), Empty, Empty, 1, 1);\n+      gnat_expand_stmt (end_block_stmt ());\n \n       if (Present (Handled_Statement_Sequence (gnat_node)))\n \t{\n@@ -3334,8 +3363,10 @@ tree_transform (Node_Id gnat_node)\n \t    break;\n \t};\n \n+      start_block_stmt();\n       process_decls (Declarations (Aux_Decls_Node (gnat_node)),\n \t\t     Empty, Empty, 1, 1);\n+      gnat_expand_stmt (end_block_stmt ());\n \n       gnat_to_code (Unit (gnat_node));\n \n@@ -3440,7 +3471,7 @@ tree_transform (Node_Id gnat_node)\n \t/* Make a binding level that we can exit if we need one.  */\n \tif (exitable_binding_for_block)\n \t  {\n-\t    pushlevel (0);\n+\t    gnat_pushlevel ();\n \t    expand_start_bindings (1);\n \t  }\n \n@@ -3457,6 +3488,9 @@ tree_transform (Node_Id gnat_node)\n \t\t\t\t integer_type_node, NULL_TREE, 0, 0, 0, 0,\n \t\t\t\t 0);\n \n+\t    start_block_stmt ();\n+\t    add_decl_stmt (gnu_cleanup_decl, gnat_node);\n+\t    gnat_expand_stmt (end_block_stmt ());\n \t    expand_decl_cleanup (gnu_cleanup_decl, gnu_cleanup_call);\n \t  }\n \n@@ -3487,6 +3521,11 @@ tree_transform (Node_Id gnat_node)\n \t\t\t\t NULL_TREE, 0, 0, 0, 0,\n \t\t\t\t 0);\n \n+\t    start_block_stmt ();\n+\t    add_decl_stmt (gnu_jmpsave_decl, gnat_node);\n+\t    add_decl_stmt (gnu_jmpbuf_decl, gnat_node);\n+\t    gnat_expand_stmt (end_block_stmt ());\n+\n \t    TREE_VALUE (gnu_block_stack) = gnu_jmpbuf_decl;\n \n \t    /* When we exit this block, restore the saved value.  */\n@@ -3509,7 +3548,7 @@ tree_transform (Node_Id gnat_node)\n \t    /* Make a binding level for the exception handling declarations\n \t       and code. Don't assign it an exit label, since this is the\n \t       outer block we want to exit at the end of each handler.  */\n-\t    pushlevel (0);\n+\t    gnat_pushlevel ();\n \t    expand_start_bindings (0);\n \n \t    gnu_except_ptr_stack\n@@ -3520,6 +3559,9 @@ tree_transform (Node_Id gnat_node)\n \t\t\t    build_call_0_expr (get_excptr_decl),\n \t\t\t    0, 0, 0, 0, 0),\n \t\t\t   gnu_except_ptr_stack);\n+\t    start_block_stmt ();\n+\t    add_decl_stmt (TREE_VALUE (gnu_except_ptr_stack), gnat_node);\n+\t    gnat_expand_stmt (end_block_stmt ());\n \n \t    /* Generate code for each handler. The N_Exception_Handler case\n \t       below does the real work. We ignore the dummy exception handler\n@@ -3540,8 +3582,8 @@ tree_transform (Node_Id gnat_node)\n \t    gnu_except_ptr_stack = TREE_CHAIN (gnu_except_ptr_stack);\n \n \t    /* End the binding level dedicated to the exception handlers.  */\n-\t    expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-\t    poplevel (kept_level_p (), 1, 0);\n+\t    expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+\t    gnat_poplevel ();\n \n \t    /* End the \"if\" on setjmp.  Note that we have arranged things so\n \t       control never returns here.  */\n@@ -3566,9 +3608,11 @@ tree_transform (Node_Id gnat_node)\n \n \t/* Generate code and declarations for the prefix of this block,\n \t   if any.  */\n+\tstart_block_stmt ();\n \tif (Present (First_Real_Statement (gnat_node)))\n \t  process_decls (Statements (gnat_node), Empty,\n \t\t\t First_Real_Statement (gnat_node), 1, 1);\n+\tgnat_expand_stmt (end_block_stmt ());\n \n \t/* Generate code for each statement in the block.  */\n \tfor (gnat_temp = (Present (First_Real_Statement (gnat_node))\n@@ -3603,8 +3647,8 @@ tree_transform (Node_Id gnat_node)\n \t/* Close the binding level we made, if any.  */\n \tif (exitable_binding_for_block)\n \t  {\n-\t    expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-\t    poplevel (kept_level_p (), 1, 0);\n+\t    expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+\t    gnat_poplevel ();\n \t  }\n       }\n \n@@ -3766,7 +3810,7 @@ tree_transform (Node_Id gnat_node)\n \n \t  expand_start_catch (gnu_etypes_list);\n \n-\t  pushlevel (0);\n+\t  gnat_pushlevel ();\n \t  expand_start_bindings (0);\n \n \t  {\n@@ -3797,6 +3841,9 @@ tree_transform (Node_Id gnat_node)\n \t\t\t\t ptr_type_node, gnu_current_exc_ptr,\n \t\t\t\t 0, 0, 0, 0, 0);\n \n+\t    start_block_stmt ();\n+\t    add_decl_stmt (gnu_incoming_exc_ptr, gnat_node);\n+\t    gnat_expand_stmt (end_block_stmt ());\n \t    expand_expr_stmt\n \t      (build_call_1_expr (begin_handler_decl, gnu_incoming_exc_ptr));\n \t    expand_decl_cleanup\n@@ -3811,9 +3858,8 @@ tree_transform (Node_Id gnat_node)\n       if (Exception_Mechanism == GCC_ZCX)\n \t{\n \t  /* Tell the back end that we're done with the current handler.  */\n-\t  expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-\t  poplevel (kept_level_p (), 1, 0);\n-\n+\t  expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+\t  gnat_poplevel ();\n \t  expand_end_catch ();\n \t}\n       else\n@@ -3927,7 +3973,9 @@ tree_transform (Node_Id gnat_node)\n \n     case N_Freeze_Entity:\n       process_freeze_entity (gnat_node);\n+      start_block_stmt ();\n       process_decls (Actions (gnat_node), Empty, Empty, 1, 1);\n+      gnat_expand_stmt (end_block_stmt ());\n       break;\n \n     case N_Itype_Reference:\n@@ -4196,6 +4244,136 @@ first_nondeleted_insn (rtx insns)\n   return insns;\n }\n \f\n+/* Push the BLOCK_STMT stack and allocate a new BLOCK_STMT.  */\n+\n+static tree\n+start_block_stmt ()\n+{\n+  tree gnu_block_stmt;\n+\n+  /* First see if we can get one from the free list.  */\n+  if (gnu_block_stmt_free_list)\n+    {\n+      gnu_block_stmt = gnu_block_stmt_free_list;\n+      gnu_block_stmt_free_list = TREE_CHAIN (gnu_block_stmt_free_list);\n+    }\n+  else\n+    {\n+      gnu_block_stmt = make_node (BLOCK_STMT);\n+      TREE_TYPE (gnu_block_stmt) = void_type_node;\n+    }\n+\n+  BLOCK_STMT_LIST (gnu_block_stmt) = 0;\n+  TREE_CHAIN (gnu_block_stmt) = gnu_block_stmt_node;\n+  gnu_block_stmt_node = gnu_block_stmt;\n+\n+  return gnu_block_stmt;\n+}\n+\n+/* Add GNU_STMT to the current BLOCK_STMT node.  We add them backwards\n+   order and the reverse in end_block_stmt.  */\n+\n+void\n+add_stmt (tree gnu_stmt)\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE (gnu_stmt)) != 's')\n+    gigi_abort (340);\n+\n+  if (TREE_CODE (gnu_stmt) != NULL_STMT)\n+    {\n+      TREE_CHAIN (gnu_stmt) = BLOCK_STMT_LIST (gnu_block_stmt_node);\n+      BLOCK_STMT_LIST (gnu_block_stmt_node) = gnu_stmt;\n+    }\n+\n+  /* If this is a DECL_STMT for a variable with DECL_INIT_BY_ASSIGN_P set,\n+     generate the assignment statement too.  */\n+  if (TREE_CODE (gnu_stmt) == DECL_STMT\n+      && TREE_CODE (DECL_STMT_VAR (gnu_stmt)) == VAR_DECL\n+      && DECL_INIT_BY_ASSIGN_P (DECL_STMT_VAR (gnu_stmt)))\n+    {\n+      tree gnu_decl = DECL_STMT_VAR (gnu_stmt);\n+      tree gnu_lhs = gnu_decl;\n+      tree gnu_assign_stmt;\n+\n+      /* If decl has a padded type, convert it to the unpadded type so the\n+\t assignment is done properly.  */\n+      if (TREE_CODE (TREE_TYPE (gnu_lhs)) == RECORD_TYPE\n+\t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_lhs)))\n+\tgnu_lhs\n+\t  = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_lhs))), gnu_lhs);\n+\n+      gnu_assign_stmt\n+\t= build_nt (EXPR_STMT,\n+\t\t    build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t     gnu_lhs, DECL_INITIAL (gnu_decl)));\n+      DECL_INITIAL (gnu_decl) = 0;\n+      DECL_INIT_BY_ASSIGN_P (gnu_decl) = 0;\n+\n+      TREE_SLOC (gnu_assign_stmt) = TREE_SLOC (gnu_stmt);\n+      TREE_TYPE (gnu_assign_stmt) = void_type_node;\n+      add_stmt (gnu_assign_stmt);\n+    }\n+}\n+\n+/* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n+   Get SLOC from Entity_Id.  */\n+\n+void\n+add_decl_stmt (tree gnu_decl, Entity_Id gnat_entity)\n+{\n+  tree gnu_stmt;\n+\n+  /* If this is a variable that Gigi is to ignore, we may have been given\n+     an ERROR_MARK.  So test for it.  We also might have been given a\n+     reference for a renaming.  So only do something for a decl.  */\n+  if (!DECL_P (gnu_decl))\n+    return;\n+\n+  gnu_stmt = build_nt (DECL_STMT, gnu_decl);\n+  TREE_TYPE (gnu_stmt) = void_type_node;\n+  TREE_SLOC (gnu_stmt) = Sloc (gnat_entity);\n+  add_stmt (gnu_stmt);\n+}\n+\n+/* Return the BLOCK_STMT that corresponds to the statement that add_stmt\n+   has been emitting or just a single statement if only one.  */\n+\n+static tree\n+end_block_stmt ()\n+{\n+  tree gnu_block_stmt = gnu_block_stmt_node;\n+  tree gnu_retval = gnu_block_stmt;\n+\n+  gnu_block_stmt_node = TREE_CHAIN (gnu_block_stmt);\n+  TREE_CHAIN (gnu_block_stmt) = 0;\n+\n+  /* If we have only one statement, return it and free this node.  Otherwise,\n+     finish setting up this node and return it.  If we have no statements,\n+     return a NULL_STMT.  */\n+  if (BLOCK_STMT_LIST (gnu_block_stmt) == 0)\n+    {\n+      gnu_retval = build_nt (NULL_STMT);\n+      TREE_TYPE (gnu_retval) = void_type_node;\n+    }\n+  else if (TREE_CHAIN (BLOCK_STMT_LIST (gnu_block_stmt)) == 0)\n+    gnu_retval = BLOCK_STMT_LIST (gnu_block_stmt);\n+  else\n+    {\n+      BLOCK_STMT_LIST (gnu_block_stmt)\n+\t= nreverse (BLOCK_STMT_LIST (gnu_block_stmt));\n+      TREE_SLOC (gnu_block_stmt)\n+\t= TREE_SLOC (BLOCK_STMT_LIST (gnu_block_stmt));\n+    }\n+\n+  if (gnu_retval != gnu_block_stmt)\n+    {\n+      TREE_CHAIN (gnu_block_stmt) = gnu_block_stmt_free_list;\n+      gnu_block_stmt_free_list = gnu_block_stmt;\n+    }\n+\n+  return gnu_retval;\n+}\n+   \n /* Build a BLOCK_STMT from GNAT_LIST, a possibly-empty list of statements.  */\n \n static tree\n@@ -4207,15 +4385,15 @@ build_block_stmt (List_Id gnat_list)\n   if (No (gnat_list) || Is_Empty_List (gnat_list))\n     return NULL_TREE;\n \n+  start_block_stmt ();\n+\n   for (gnat_node = First (gnat_list);\n        Present (gnat_node);\n        gnat_node = Next (gnat_node))\n-    gnu_result = chainon (gnat_to_gnu (gnat_node), gnu_result);\n+    add_stmt (gnat_to_gnu (gnat_node));\n \n-  gnu_result = build_nt (BLOCK_STMT, nreverse (gnu_result));\n-  TREE_SLOC (gnu_result) = TREE_SLOC (BLOCK_STMT_LIST (gnu_result));\n-  TREE_TYPE (gnu_result) = void_type_node;\n-  return gnu_result;\n+  gnu_result = end_block_stmt ();\n+  return TREE_CODE (gnu_result) == NULL_STMT ? NULL_TREE : gnu_result;\n } \n \n /* Build an EXPR_STMT to evaluate INSNS.  Use Sloc from GNAT_NODE.   */\n@@ -4253,31 +4431,52 @@ gnat_expand_stmt (tree gnu_stmt)\n       expand_expr_stmt (EXPR_STMT_EXPR (gnu_stmt));\n       break;\n \n+    case NULL_STMT:\n+      break;\n+\n+    case DECL_STMT:\n+      if (TREE_CODE (DECL_STMT_VAR (gnu_stmt)) == TYPE_DECL)\n+\tforce_type_save_exprs (TREE_TYPE (DECL_STMT_VAR (gnu_stmt)));\n+      else\n+\t{\n+\t  expand_decl (DECL_STMT_VAR (gnu_stmt));\n+\t  if (DECL_CONTEXT (DECL_STMT_VAR (gnu_stmt)))\n+\t    expand_decl_init (DECL_STMT_VAR (gnu_stmt));\n+\n+\t  if (TREE_ADDRESSABLE (DECL_STMT_VAR (gnu_stmt)))\n+\t    {\n+\t      put_var_into_stack (DECL_STMT_VAR (gnu_stmt), true);\n+\t      flush_addressof (DECL_STMT_VAR (gnu_stmt));\n+\t    }\n+\t}\n+      break;\n+\n     case BLOCK_STMT:\n       for (gnu_elmt = BLOCK_STMT_LIST (gnu_stmt); gnu_elmt;\n \t   gnu_elmt = TREE_CHAIN (gnu_elmt))\n-\texpand_expr_stmt (gnu_elmt);\n+\tgnat_expand_stmt (gnu_elmt);\n       break;\n \n     case IF_STMT:\n       expand_start_cond (IF_STMT_COND (gnu_stmt), 0);\n \n       if (IF_STMT_TRUE (gnu_stmt))\n-\texpand_expr_stmt (IF_STMT_TRUE (gnu_stmt));\n+\tgnat_expand_stmt (IF_STMT_TRUE (gnu_stmt));\n \n       for (gnu_elmt = IF_STMT_ELSEIF (gnu_stmt); gnu_elmt;\n \t   gnu_elmt = TREE_CHAIN (gnu_elmt))\n \t{\n \t  expand_start_else ();\n \t  set_lineno_from_sloc (TREE_SLOC (gnu_elmt), 1);\n \t  expand_elseif (IF_STMT_COND (gnu_elmt));\n-\t  expand_expr_stmt (IF_STMT_TRUE (gnu_elmt));\n+\t  if (IF_STMT_TRUE (gnu_elmt))\n+\t    gnat_expand_stmt (IF_STMT_TRUE (gnu_elmt));\n \t}\n \n       if (IF_STMT_ELSE (gnu_stmt))\n \t{\n \t  expand_start_else ();\n-\t  expand_expr_stmt (IF_STMT_ELSE (gnu_stmt));\n+\t  gnat_expand_stmt (IF_STMT_ELSE (gnu_stmt));\n \t}\n \n       expand_end_cond ();\n@@ -4324,8 +4523,8 @@ gnat_expand_stmt (tree gnu_stmt)\n \t  }\n       break;\n \n-    default:\n-      abort ();\n+    default: \n+     abort ();\n     }\n }\n \f\n@@ -4570,11 +4769,8 @@ process_inlined_subprograms (Node_Id gnat_node)\n    correspond to the public and private parts of a package.  */\n \n static void\n-process_decls (List_Id gnat_decls,\n-               List_Id gnat_decls2,\n-               Node_Id gnat_end_list,\n-               int pass1p,\n-               int pass2p)\n+process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n+               Node_Id gnat_end_list, int pass1p, int pass2p)\n {\n   List_Id gnat_decl_array[2];\n   Node_Id gnat_decl;\n@@ -4603,7 +4799,9 @@ process_decls (List_Id gnat_decls,\n \t       freeze node.  */\n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n \t      {\n+\t\tstart_block_stmt ();\n \t\tprocess_freeze_entity (gnat_decl);\n+\t\tgnat_expand_stmt (end_block_stmt ());\n \t\tprocess_decls (Actions (gnat_decl), Empty, Empty, 1, 0);\n \t      }\n \n@@ -4643,7 +4841,7 @@ process_decls (List_Id gnat_decls,\n                   Node_Id gnat_subprog_id =\n                      Defining_Entity (Specification (gnat_decl));\n \n-\t\t    if    (Ekind (gnat_subprog_id) != E_Subprogram_Body\n+\t\t    if (Ekind (gnat_subprog_id) != E_Subprogram_Body\n                         && Ekind (gnat_subprog_id) != E_Generic_Procedure\n \t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Function)\n \t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, 1);\n@@ -4656,7 +4854,11 @@ process_decls (List_Id gnat_decls,\n \t\t;\n \n \t    else\n-\t      gnat_to_code (gnat_decl);\n+\t      {\n+\t\tstart_block_stmt ();\n+\t\tgnat_to_code (gnat_decl);\n+\t\tgnat_expand_stmt (end_block_stmt ());\n+\t      }\n \t  }\n \n   /* Here we elaborate everything we deferred above except for package bodies,\n@@ -5082,6 +5284,7 @@ process_type (Entity_Id gnat_entity)\n     }\n \n   /* Now fully elaborate the type.  */\n+  start_block_stmt ();\n   gnu_new = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 1);\n   if (TREE_CODE (gnu_new) != TYPE_DECL)\n     gigi_abort (324);\n@@ -5112,6 +5315,8 @@ process_type (Entity_Id gnat_entity)\n       update_pointer_to (TYPE_MAIN_VARIANT (TREE_TYPE (gnu_task_old)),\n \t\t\t TREE_TYPE (gnu_new));\n     }\n+\n+  gnat_expand_stmt (end_block_stmt ());\n }\n \f\n /* GNAT_ASSOC is the front of the Component_Associations of an N_Aggregate.\n@@ -5499,7 +5704,7 @@ build_unit_elab (Entity_Id gnat_unit, int body_p, tree gnu_elab_list)\n \n   begin_subprog_body (gnu_decl);\n   set_lineno (gnat_unit, 1);\n-  pushlevel (0);\n+  gnat_pushlevel ();\n   gnu_block_stack = tree_cons (NULL_TREE, NULL_TREE, gnu_block_stack);\n   expand_start_bindings (0);\n \n@@ -5542,8 +5747,8 @@ build_unit_elab (Entity_Id gnat_unit, int body_p, tree gnu_elab_list)\n \tbreak;\n       }\n \n-  expand_end_bindings (NULL_TREE, kept_level_p (), -1);\n-  poplevel (kept_level_p (), 1, 0);\n+  expand_end_bindings (NULL_TREE, block_has_vars (), -1);\n+  gnat_poplevel ();\n   gnu_block_stack = TREE_CHAIN (gnu_block_stack);\n   end_subprog_body ();\n \n@@ -5599,7 +5804,7 @@ set_lineno_from_sloc (Source_Ptr source_location, int write_note_p)\n \t(Debug_Source_Name (Get_Source_File_Index (source_location)))));;\n   input_line = Get_Logical_Line_Number (source_location);\n \n-  if (write_note_p)\n+  if (! global_bindings_p () && write_note_p)\n     emit_line_note (input_location);\n }\n \f"}, {"sha": "ead346f2775594759f74be1103cb1b9f96e8bf70", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 95, "deletions": 209, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -84,7 +84,7 @@ static GTY(()) tree pending_elaborations;\n /* This stack allows us to momentarily switch to generating elaboration\n    lists for an inner context.  */\n \n-struct e_stack GTY(()) {\n+struct e_stack GTY((chain_next (\"%h.next\"))) {\n   struct e_stack *next;\n   tree elab_list;\n };\n@@ -110,36 +110,22 @@ static GTY(()) tree float_types[NUM_MACHINE_MODES];\n \n    Binding contours are used to create GCC tree BLOCK nodes.  */\n \n-struct binding_level GTY(())\n+struct ada_binding_level GTY((chain_next (\"%h.chain\")))\n {\n-  /* A chain of ..._DECL nodes for all variables, constants, functions,\n-     parameters and type declarations.  These ..._DECL nodes are chained\n-     through the TREE_CHAIN field. Note that these ..._DECL nodes are stored\n-     in the reverse of the order supplied to be compatible with the\n-     back-end.  */\n-  tree names;\n-  /* For each level (except the global one), a chain of BLOCK nodes for all\n-     the levels that were entered and exited one level down from this one.  */\n-  tree blocks;\n-  /* The BLOCK node for this level, if one has been preallocated.\n-     If 0, the BLOCK is allocated (if needed) when the level is popped.  */\n-  tree this_block;\n   /* The binding level containing this one (the enclosing binding level). */\n-  struct binding_level *level_chain;\n+  struct ada_binding_level *chain;\n+  /* The BLOCK node for this level.  */\n+  tree block;\n };\n \n /* The binding level currently in effect.  */\n-static GTY(()) struct binding_level *current_binding_level;\n+static GTY(()) struct ada_binding_level *current_binding_level;\n \n-/* A chain of binding_level structures awaiting reuse.  */\n-static GTY((deletable (\"\"))) struct binding_level *free_binding_level;\n+/* A chain of ada_binding_level structures awaiting reuse.  */\n+static GTY((deletable)) struct ada_binding_level *free_binding_level;\n \n-/* The outermost binding level. This binding level is created when the\n-   compiler is started and it will exist through the entire compilation.  */\n-static struct binding_level *global_binding_level;\n-\n-/* Binding level structures are initialized by copying this one.  */\n-static struct binding_level clear_binding_level = {NULL, NULL, NULL, NULL};\n+/* A chain of unused BLOCK nodes. */\n+static GTY((deletable)) tree free_block_chain;\n \n struct language_function GTY(())\n {\n@@ -219,8 +205,7 @@ present_gnu_tree (Entity_Id gnat_entity)\n int\n global_bindings_p (void)\n {\n-  return (force_global != 0 || current_binding_level == global_binding_level\n-\t  ? -1 : 0);\n+  return (force_global != 0 || current_binding_level->chain == 0 ? -1 : 0);\n }\n \n /* Return the list of declarations in the current level. Note that this list\n@@ -229,163 +214,102 @@ global_bindings_p (void)\n tree\n getdecls (void)\n {\n-  return current_binding_level->names;\n-}\n-\n-/* Nonzero if the current level needs to have a BLOCK made.  */\n-\n-int\n-kept_level_p (void)\n-{\n-  return (current_binding_level->names != 0);\n+  return BLOCK_VARS (current_binding_level->block);\n }\n \n-/* Enter a new binding level. The input parameter is ignored, but has to be\n-   specified for back-end compatibility.  */\n+/* Enter a new binding level. */\n \n void\n-pushlevel (int ignore ATTRIBUTE_UNUSED)\n+gnat_pushlevel ()\n {\n-  struct binding_level *newlevel = NULL;\n+  struct ada_binding_level *newlevel = NULL;\n \n   /* Reuse a struct for this binding level, if there is one.  */\n   if (free_binding_level)\n     {\n       newlevel = free_binding_level;\n-      free_binding_level = free_binding_level->level_chain;\n+      free_binding_level = free_binding_level->chain;\n     }\n   else\n     newlevel\n-      = (struct binding_level *) ggc_alloc (sizeof (struct binding_level));\n+      = (struct ada_binding_level *)\n+\tggc_alloc (sizeof (struct ada_binding_level));\n \n-  *newlevel = clear_binding_level;\n+  /* Use a free BLOCK, if any; otherwise, allocate one.  */\n+  if (free_block_chain)\n+    {\n+      newlevel->block = free_block_chain;\n+      free_block_chain = TREE_CHAIN (free_block_chain);\n+      TREE_CHAIN (newlevel->block) = NULL_TREE;\n+    }\n+  else\n+    newlevel->block = make_node (BLOCK);\n+\n+  /* Point the BLOCK we just made to its parent.  */\n+  if (current_binding_level)\n+    BLOCK_SUPERCONTEXT (newlevel->block) = current_binding_level->block;\n+\n+  BLOCK_VARS (newlevel->block) = BLOCK_SUBBLOCKS (newlevel->block) = NULL_TREE;\n \n   /* Add this level to the front of the chain (stack) of levels that are\n      active.  */\n-  newlevel->level_chain = current_binding_level;\n+  newlevel->chain = current_binding_level;\n   current_binding_level = newlevel;\n }\n \n-/* Exit a binding level.\n-   Pop the level off, and restore the state of the identifier-decl mappings\n-   that were in effect when this level was entered.\n-\n-   If KEEP is nonzero, this level had explicit declarations, so\n-   and create a \"block\" (a BLOCK node) for the level\n-   to record its declarations and subblocks for symbol table output.\n+/* Exit a binding level.  */\n \n-   If FUNCTIONBODY is nonzero, this level is the body of a function,\n-   so create a block as if KEEP were set and also clear out all\n-   label names.\n-\n-   If REVERSE is nonzero, reverse the order of decls before putting\n-   them into the BLOCK.  */\n-\n-tree\n-poplevel (int keep, int reverse, int functionbody)\n+void\n+gnat_poplevel ()\n {\n-  /* Points to a GCC BLOCK tree node. This is the BLOCK node construted for the\n-     binding level that we are about to exit and which is returned by this\n-     routine.  */\n-  tree block = NULL_TREE;\n-  tree decl_chain;\n-  tree decl_node;\n-  tree subblock_chain = current_binding_level->blocks;\n-  tree subblock_node;\n-  int block_previously_created;\n-\n-  /* Reverse the list of XXXX_DECL nodes if desired.  Note that the ..._DECL\n-     nodes chained through the `names' field of current_binding_level are in\n-     reverse order except for PARM_DECL node, which are explicitly stored in\n-     the right order.  */\n-  current_binding_level->names\n-    = decl_chain = (reverse) ? nreverse (current_binding_level->names)\n-      : current_binding_level->names;\n+  struct ada_binding_level *level = current_binding_level;\n+  tree block = level->block;\n+  tree decl;\n+\n+  BLOCK_VARS (block) = nreverse (BLOCK_VARS (block));\n+  BLOCK_SUBBLOCKS (block) = nreverse (BLOCK_SUBBLOCKS (block));\n \n   /* Output any nested inline functions within this block which must be\n      compiled because their address is needed. */\n-  for (decl_node = decl_chain; decl_node; decl_node = TREE_CHAIN (decl_node))\n-    if (TREE_CODE (decl_node) == FUNCTION_DECL\n-\t&& ! TREE_ASM_WRITTEN (decl_node) && TREE_ADDRESSABLE (decl_node)\n-\t&& DECL_INITIAL (decl_node) != 0)\n+  for (decl =  BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n+    if (TREE_CODE (decl) == FUNCTION_DECL\n+\t&& ! TREE_ASM_WRITTEN (decl) && TREE_ADDRESSABLE (decl)\n+\t&& DECL_INITIAL (decl) != 0)\n       {\n \tpush_function_context ();\n \t/* ??? This is temporary.  */\n \tggc_push_context ();\n-\toutput_inline_function (decl_node);\n+\toutput_inline_function (decl);\n \tggc_pop_context ();\n \tpop_function_context ();\n       }\n \n-  block = 0;\n-  block_previously_created = (current_binding_level->this_block != 0);\n-  if (block_previously_created)\n-    block = current_binding_level->this_block;\n-  else if (keep || functionbody)\n-    block = make_node (BLOCK);\n-  if (block != 0)\n-    {\n-      BLOCK_VARS (block) = keep ? decl_chain : 0;\n-      BLOCK_SUBBLOCKS (block) = subblock_chain;\n-    }\n-\n-  /* Record the BLOCK node just built as the subblock its enclosing scope.  */\n-  for (subblock_node = subblock_chain; subblock_node;\n-       subblock_node = TREE_CHAIN (subblock_node))\n-    BLOCK_SUPERCONTEXT (subblock_node) = block;\n-\n-  /* Clear out the meanings of the local variables of this level.  */\n-\n-  for (subblock_node = decl_chain; subblock_node;\n-       subblock_node = TREE_CHAIN (subblock_node))\n-    if (DECL_NAME (subblock_node) != 0)\n-      /* If the identifier was used or addressed via a local extern decl,\n-\t don't forget that fact.   */\n-      if (DECL_EXTERNAL (subblock_node))\n-\t{\n-\t  if (TREE_USED (subblock_node))\n-\t    TREE_USED (DECL_NAME (subblock_node)) = 1;\n-\t  if (TREE_ADDRESSABLE (subblock_node))\n-\t    TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (subblock_node)) = 1;\n-\t}\n-\n-  {\n-    /* Pop the current level, and free the structure for reuse.  */\n-    struct binding_level *level = current_binding_level;\n-    current_binding_level = current_binding_level->level_chain;\n-    level->level_chain = free_binding_level;\n-    free_binding_level = level;\n-  }\n-\n-  if (functionbody)\n+  /* If this is a function-level BLOCK don't do anything.  Otherwise, if there\n+     are no variables free the block and merge its subblocks into those of its\n+     parent block. Otherwise, add it to the list of its parent.  */\n+  if (TREE_CODE (BLOCK_SUPERCONTEXT (block)) == FUNCTION_DECL)\n+    ;\n+  else if (BLOCK_VARS (block) == 0)\n     {\n-      /* This is the top level block of a function. The ..._DECL chain stored\n-\t in BLOCK_VARS are the function's parameters (PARM_DECL nodes). Don't\n-\t leave them in the BLOCK because they are found in the FUNCTION_DECL\n-\t instead.  */\n-      DECL_INITIAL (current_function_decl) = block;\n-      BLOCK_VARS (block) = 0;\n+      BLOCK_SUBBLOCKS (level->chain->block)\n+\t= chainon (BLOCK_SUBBLOCKS (block),\n+\t\t   BLOCK_SUBBLOCKS (level->chain->block));\n+      TREE_CHAIN (block) = free_block_chain;\n+      free_block_chain = block;\n     }\n-  else if (block)\n+  else\n     {\n-      if (!block_previously_created)\n-\tcurrent_binding_level->blocks\n-\t  = chainon (current_binding_level->blocks, block);\n+      TREE_CHAIN (block) = BLOCK_SUBBLOCKS (level->chain->block);\n+      BLOCK_SUBBLOCKS (level->chain->block) = block;\n+      TREE_USED (block) = 1;\n     }\n \n-  /* If we did not make a block for the level just exited, any blocks made for\n-     inner levels (since they cannot be recorded as subblocks in that level)\n-     must be carried forward so they will later become subblocks of something\n-     else.  */\n-  else if (subblock_chain)\n-    current_binding_level->blocks\n-      = chainon (current_binding_level->blocks, subblock_chain);\n-  if (block)\n-    TREE_USED (block) = 1;\n-\n-  return block;\n+  /* Free this binding structure.  */\n+  current_binding_level = level->chain;\n+  level->chain = free_binding_level;\n+  free_binding_level = level;\n }\n-\f\n+\n /* Insert BLOCK at the end of the list of subblocks of the\n    current binding level.  This is used when a BIND_EXPR is expanded,\n    to handle the BLOCK node inside the BIND_EXPR.  */\n@@ -394,55 +318,42 @@ void\n insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n-  current_binding_level->blocks\n-    = chainon (current_binding_level->blocks, block);\n+  TREE_CHAIN (block) = BLOCK_SUBBLOCKS (current_binding_level->block);\n+  BLOCK_SUBBLOCKS (current_binding_level->block) = block;\n }\n \n-/* Set the BLOCK node for the innermost scope\n-   (the one we are currently in).  */\n+/* Return nonzero if the current binding has any variables.  This means\n+   it will have a BLOCK node.  */\n \n-void\n-set_block (tree block)\n+int\n+block_has_vars ()\n {\n-  current_binding_level->this_block = block;\n-  current_binding_level->names = chainon (current_binding_level->names,\n-\t\t\t\t\t  BLOCK_VARS (block));\n-  current_binding_level->blocks = chainon (current_binding_level->blocks,\n-\t\t\t\t\t   BLOCK_SUBBLOCKS (block));\n+  return BLOCK_VARS (current_binding_level->block) != 0;\n }\n-\n+\f\n /* Records a ..._DECL node DECL as belonging to the current lexical scope.\n    Returns the ..._DECL node. */\n \n tree\n pushdecl (tree decl)\n {\n-  struct binding_level *b;\n-\n   /* If at top level, there is no context. But PARM_DECLs always go in the\n      level of its function. */\n   if (global_bindings_p () && TREE_CODE (decl) != PARM_DECL)\n-    {\n-      b = global_binding_level;\n-      DECL_CONTEXT (decl) = 0;\n-    }\n+    DECL_CONTEXT (decl) = 0;\n   else\n-    {\n-      b = current_binding_level;\n-      DECL_CONTEXT (decl) = current_function_decl;\n-    }\n+    DECL_CONTEXT (decl) = current_function_decl;\n \n   /* Put the declaration on the list.  The list of declarations is in reverse\n-     order. The list will be reversed later if necessary.  This needs to be\n-     this way for compatibility with the back-end.\n+     order. The list will be reversed later.\n \n      Don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into the list.  They\n      will cause trouble with the debugger and aren't needed anyway.  */\n   if (TREE_CODE (decl) != TYPE_DECL\n       || TREE_CODE (TREE_TYPE (decl)) != UNCONSTRAINED_ARRAY_TYPE)\n     {\n-      TREE_CHAIN (decl) = b->names;\n-      b->names = decl;\n+      TREE_CHAIN (decl) = BLOCK_VARS (current_binding_level->block);\n+      BLOCK_VARS (current_binding_level->block) = decl;\n     }\n \n   /* For the declaration of a type, set its name if it either is not already\n@@ -478,8 +389,7 @@ gnat_init_decl_processing (void)\n   current_function_decl = 0;\n   current_binding_level = 0;\n   free_binding_level = 0;\n-  pushlevel (0);\n-  global_binding_level = current_binding_level;\n+  gnat_pushlevel ();\n \n   build_common_tree_nodes (0);\n \n@@ -1294,15 +1204,9 @@ create_type_decl (tree type_name,\n    it indicates whether to always allocate storage to the variable.   */\n \n tree\n-create_var_decl (tree var_name,\n-                 tree asm_name,\n-                 tree type,\n-                 tree var_init,\n-                 int const_flag,\n-                 int public_flag,\n-                 int extern_flag,\n-                 int static_flag,\n-                 struct attrib *attr_list)\n+create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n+                 int const_flag, int public_flag, int extern_flag,\n+                 int static_flag, struct attrib *attr_list)\n {\n   int init_const\n     = (var_init == 0\n@@ -1321,7 +1225,6 @@ create_var_decl (tree var_name,\n \t\t   && 0 >= compare_tree_int (TYPE_SIZE_UNIT (type),\n \t\t\t\t\t     GET_MODE_SIZE (DCmode)))\n \t\t  ? CONST_DECL : VAR_DECL, var_name, type);\n-  tree assign_init = 0;\n \n   /* If this is external, throw away any initializations unless this is a\n      CONST_DECL (meaning we have a constant); they will be done elsewhere.  If\n@@ -1346,7 +1249,7 @@ create_var_decl (tree var_name,\n \t   && ((TYPE_MAIN_VARIANT (TREE_TYPE (var_init))\n \t\t!= TYPE_MAIN_VARIANT (type))\n \t       || (static_flag && ! init_const)))\n-    assign_init = var_init, var_init = 0;\n+    DECL_INIT_BY_ASSIGN_P (var_decl) = 1;\n \n   DECL_INITIAL  (var_decl) = var_init;\n   TREE_READONLY (var_decl) = const_flag;\n@@ -1369,32 +1272,13 @@ create_var_decl (tree var_name,\n   /* Add this decl to the current binding level and generate any\n      needed code and RTL. */\n   var_decl = pushdecl (var_decl);\n-  expand_decl (var_decl);\n-\n-  if (DECL_CONTEXT (var_decl) != 0)\n-    expand_decl_init (var_decl);\n \n-  /* If this is volatile, force it into memory.  */\n   if (TREE_SIDE_EFFECTS (var_decl))\n-    gnat_mark_addressable (var_decl);\n+    TREE_ADDRESSABLE (var_decl) = 1;\n \n   if (TREE_CODE (var_decl) != CONST_DECL)\n     rest_of_decl_compilation (var_decl, 0, global_bindings_p (), 0);\n \n-  if (assign_init != 0)\n-    {\n-      /* If VAR_DECL has a padded type, convert it to the unpadded\n-\t type so the assignment is done properly.  */\n-      tree lhs = var_decl;\n-\n-      if (TREE_CODE (TREE_TYPE (lhs)) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (TREE_TYPE (lhs)))\n-\tlhs = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (lhs))), lhs);\n-\n-      expand_expr_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, lhs,\n-\t\t\t\t\t assign_init));\n-    }\n-\n   return var_decl;\n }\n \f\n@@ -1859,8 +1743,7 @@ begin_subprog_body (tree subprog_decl)\n   announce_function (subprog_decl);\n \n   /* Make this field nonzero so further routines know that this is not\n-     tentative. error_mark_node is replaced below (in poplevel) with the\n-     adequate BLOCK.  */\n+     tentative. error_mark_node is replaced below with the adequate BLOCK.  */\n   DECL_INITIAL (subprog_decl)  = error_mark_node;\n \n   /* This function exists in static storage. This does not mean `static' in\n@@ -1870,7 +1753,7 @@ begin_subprog_body (tree subprog_decl)\n   /* Enter a new binding level and show that all the parameters belong to\n      this function.  */\n   current_function_decl = subprog_decl;\n-  pushlevel (0);\n+  gnat_pushlevel ();\n \n   for (param_decl = DECL_ARGUMENTS (subprog_decl); param_decl;\n        param_decl = TREE_CHAIN (param_decl))\n@@ -1896,9 +1779,12 @@ end_subprog_body (void)\n   tree decl;\n   tree cico_list;\n \n-  poplevel (1, 0, 1);\n-  BLOCK_SUPERCONTEXT (DECL_INITIAL (current_function_decl))\n-    = current_function_decl;\n+  /* Mark the BLOCK for this level as being for this function and pop the\n+     level.  Since the vars in it are the parameters, clear them.  */\n+  BLOCK_VARS (current_binding_level->block) = 0;\n+  BLOCK_SUPERCONTEXT (current_binding_level->block) = current_function_decl;\n+  DECL_INITIAL (current_function_decl) = current_binding_level->block;\n+  gnat_poplevel ();\n \n   /* Mark the RESULT_DECL as being in this subprogram. */\n   DECL_CONTEXT (DECL_RESULT (current_function_decl)) = current_function_decl;"}, {"sha": "cafbf7d8fb014c7af169facaca56b94bb2e3d576", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e792e209cfee6fe3437eef9470e7765acda53f/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=b5e792e209cfee6fe3437eef9470e7765acda53f", "patch": "@@ -1990,7 +1990,6 @@ gnat_mark_addressable (tree expr_node)\n       case PARM_DECL:\n       case RESULT_DECL:\n \tput_var_into_stack (expr_node, true);\n-\tTREE_ADDRESSABLE (expr_node) = 1;\n \treturn true;\n \n       case FUNCTION_DECL:"}]}