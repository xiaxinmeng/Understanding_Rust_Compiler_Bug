{"sha": "648fe28b9dc62616ded2f6eafe5c945887b68bcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ4ZmUyOGI5ZGM2MjYxNmRlZDJmNmVhZmU1Yzk0NTg4N2I2OGJjYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-03-22T19:23:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-22T19:23:05Z"}, "message": "re PR target/3177 (Invalid sibcall optimisation on ia64)\n\n        PR target/3177\n        * config/ia64/ia64.h (CUMULATIVE_ARGS): Add int_regs.\n        (INIT_CUMULATIVE_ARGS, INIT_CUMULATIVE_INCOMING_ARGS): Update.\n        * config/ia64/ia64.c (ia64_function_arg_advance): Set int_regs.\n        (ia64_expand_prologue): Look at int_regs, not words, for number\n        of incomming int regs.\n\nFrom-SVN: r51180", "tree": {"sha": "239508eee576e0a370dc1c3feb1e8b63a73a1950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/239508eee576e0a370dc1c3feb1e8b63a73a1950"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/648fe28b9dc62616ded2f6eafe5c945887b68bcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648fe28b9dc62616ded2f6eafe5c945887b68bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/648fe28b9dc62616ded2f6eafe5c945887b68bcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648fe28b9dc62616ded2f6eafe5c945887b68bcc/comments", "author": null, "committer": null, "parents": [{"sha": "1813dafd906295f5a6b441490440c548f53123f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1813dafd906295f5a6b441490440c548f53123f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1813dafd906295f5a6b441490440c548f53123f6"}], "stats": {"total": 47, "additions": 40, "deletions": 7}, "files": [{"sha": "4dfc46acee26957ae8c3a322ec56f6c1f9a32ce0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=648fe28b9dc62616ded2f6eafe5c945887b68bcc", "patch": "@@ -1,3 +1,12 @@\n+2002-03-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/3177\n+\t* config/ia64/ia64.h (CUMULATIVE_ARGS): Add int_regs.\n+\t(INIT_CUMULATIVE_ARGS, INIT_CUMULATIVE_INCOMING_ARGS): Update.\n+\t* config/ia64/ia64.c (ia64_function_arg_advance): Set int_regs.\n+\t(ia64_expand_prologue): Look at int_regs, not words, for number\n+\tof incomming int regs.\n+\n 2002-03-22  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* expr.c (expand_expr): A RESULT_DECL is part of a call."}, {"sha": "de0c1c941415a8f696e6ecce193429a64914abe8", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=648fe28b9dc62616ded2f6eafe5c945887b68bcc", "patch": "@@ -2047,7 +2047,7 @@ ia64_expand_prologue ()\n   /* We don't need an alloc instruction if we've used no outputs or locals.  */\n   if (current_frame_info.n_local_regs == 0\n       && current_frame_info.n_output_regs == 0\n-      && current_frame_info.n_input_regs <= current_function_args_info.words)\n+      && current_frame_info.n_input_regs <= current_function_args_info.int_regs)\n     {\n       /* If there is no alloc, but there are input registers used, then we\n \t need a .regstk directive.  */\n@@ -3188,25 +3188,26 @@ ia64_function_arg_advance (cum, mode, type, named)\n      FR registers, then FP values must also go in general registers.  This can\n      happen when we have a SFmode HFA.  */\n   else if (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS)\n-    return;\n+    cum->int_regs = cum->words;\n \n   /* If there is a prototype, then FP values go in a FR register when\n      named, and in a GR registeer when unnamed.  */\n   else if (cum->prototype)\n     {\n       if (! named)\n-\treturn;\n+\tcum->int_regs = cum->words;\n       else\n \t/* ??? Complex types should not reach here.  */\n \tcum->fp_regs += (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n     }\n   /* If there is no prototype, then FP values go in both FR and GR\n      registers.  */\n   else\n-    /* ??? Complex types should not reach here.  */\n-    cum->fp_regs += (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n-\n-  return;\n+    { \n+      /* ??? Complex types should not reach here.  */\n+      cum->fp_regs += (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n+      cum->int_regs = cum->words;\n+    }\n }\n \f\n /* Implement va_start.  */"}, {"sha": "8e3eaeea8bf8695a30cf5afa8589718ba6529e21", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=648fe28b9dc62616ded2f6eafe5c945887b68bcc", "patch": "@@ -1269,6 +1269,7 @@ enum reg_class\n typedef struct ia64_args\n {\n   int words;\t\t\t/* # words of arguments so far  */\n+  int int_regs;\t\t\t/* # GR registers used so far  */\n   int fp_regs;\t\t\t/* # FR registers used so far  */\n   int prototype;\t\t/* whether function prototyped  */\n } CUMULATIVE_ARGS;\n@@ -1279,6 +1280,7 @@ typedef struct ia64_args\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n do {\t\t\t\t\t\t\t\t\t\\\n   (CUM).words = 0;\t\t\t\t\t\t\t\\\n+  (CUM).int_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).fp_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).prototype = ((FNTYPE) && TYPE_ARG_TYPES (FNTYPE)) || (LIBNAME);\t\\\n } while (0)\n@@ -1292,6 +1294,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME) \\\n do {\t\t\t\t\t\t\t\t\t\\\n   (CUM).words = 0;\t\t\t\t\t\t\t\\\n+  (CUM).int_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).fp_regs = 0;\t\t\t\t\t\t\t\\\n   (CUM).prototype = 1;\t\t\t\t\t\t\t\\\n } while (0)"}, {"sha": "d06dd0acd9a4af039eaea7a087ccf3d6fc658772", "filename": "gcc/testsuite/gcc.c-torture/execute/20020321-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020321-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/648fe28b9dc62616ded2f6eafe5c945887b68bcc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020321-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020321-1.c?ref=648fe28b9dc62616ded2f6eafe5c945887b68bcc", "patch": "@@ -0,0 +1,20 @@\n+/* PR 3177 */\n+/* Produced a SIGILL on ia64 with sibcall from F to G.  We hadn't\n+   widened the register window to allow for the fourth outgoing\n+   argument as an \"in\" register.  */\n+\n+float g (void *a, void *b, int e, int c, float d)\n+{\n+  return d;\n+}\n+\n+float f (void *a, void *b, int c, float d)\n+{\n+  return g (a, b, 0, c, d);\n+}\n+\n+int main ()\n+{\n+  f (0, 0, 1, 1);\n+  return 0;\n+}"}]}