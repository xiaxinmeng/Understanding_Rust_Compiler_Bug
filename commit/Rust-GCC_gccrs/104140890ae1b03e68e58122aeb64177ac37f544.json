{"sha": "104140890ae1b03e68e58122aeb64177ac37f544", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA0MTQwODkwYWUxYjAzZTY4ZTU4MTIyYWViNjQxNzdhYzM3ZjU0NA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-10-15T01:40:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-15T01:40:28Z"}, "message": "fold-const.c (fold): Handle more simplifications allowed by IEEE.\n\n        * fold-const.c (fold): Handle more simplifications allowed by IEEE.\n\nCo-Authored-By: Sylvian Pion <Sylvain.Pion@sophia.inria.fr>\n\nFrom-SVN: r29994", "tree": {"sha": "98051cea854c6be3c2455c6759ecb35d74f3abdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98051cea854c6be3c2455c6759ecb35d74f3abdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/104140890ae1b03e68e58122aeb64177ac37f544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104140890ae1b03e68e58122aeb64177ac37f544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/104140890ae1b03e68e58122aeb64177ac37f544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104140890ae1b03e68e58122aeb64177ac37f544/comments", "author": null, "committer": null, "parents": [{"sha": "db7eb3e895d39dad0b52b97deed14220d70480d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7eb3e895d39dad0b52b97deed14220d70480d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db7eb3e895d39dad0b52b97deed14220d70480d6"}], "stats": {"total": 60, "additions": 57, "deletions": 3}, "files": [{"sha": "8eee31bca42e775a0c4fa480dd51b858538337c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104140890ae1b03e68e58122aeb64177ac37f544/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104140890ae1b03e68e58122aeb64177ac37f544/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=104140890ae1b03e68e58122aeb64177ac37f544", "patch": "@@ -1,3 +1,8 @@\n+Thu Oct 14 19:38:42 1999  Jeffrey A Law  (law@cygnus.com)\n+\t\t\t  Sylvian Pion <Sylvain.Pion@sophia.inria.fr>\n+\n+\t* fold-const.c (fold): Handle more simplifications allowed by IEEE.\n+\n Thu Oct 14 17:30:14 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* sparc.md (*): Use {nonimmediate,register}_operand as appropriate"}, {"sha": "e38aabde03c3083dad3f7813bc050ace4abff8d5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104140890ae1b03e68e58122aeb64177ac37f544/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104140890ae1b03e68e58122aeb64177ac37f544/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=104140890ae1b03e68e58122aeb64177ac37f544", "patch": "@@ -4749,6 +4749,9 @@ fold (expr)\n       /* A + (-B) -> A - B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n \treturn fold (build (MINUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n+      /* (-A) + B -> B - A */\n+      if (TREE_CODE (arg0) == NEGATE_EXPR)\n+\treturn fold (build (MINUS_EXPR, type, arg1, TREE_OPERAND (arg0, 0)));\n       else if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n@@ -4867,6 +4870,11 @@ fold (expr)\n \t\t|| flag_fast_math)\n \t       && real_zerop (arg1))\n \treturn non_lvalue (convert (type, arg0));\n+      /* x+(-0) equals x, even for IEEE.  */\n+      else if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (arg1)))\n+\treturn non_lvalue (convert (type, arg0));\n+\n+\n     associate:\n       /* In most languages, can't associate operations on floats\n \t through parentheses.  Rather than remember where the parentheses\n@@ -4989,6 +4997,17 @@ fold (expr)\n       return t;\n \n     case MINUS_EXPR:\n+      /* A - (-B) -> A + B */\n+      if (TREE_CODE (arg1) == NEGATE_EXPR)\n+\treturn fold (build (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n+      /* (-A) - CST -> (-CST) - A   for floating point (what about ints ?)  */\n+      if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == REAL_CST)\n+\treturn\n+\t  fold (build (MINUS_EXPR, type, \n+\t\t       build_real (TREE_TYPE (arg1),\n+\t\t\t\t   REAL_VALUE_NEGATE (TREE_REAL_CST (arg1))),\n+\t\t       TREE_OPERAND (arg0, 0)));\n+\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (! wins && integer_zerop (arg0))\n@@ -5009,9 +5028,6 @@ fold (expr)\n \t\t\t\t\t     TREE_OPERAND (arg1, 0))),\n \t\t\t\tTREE_OPERAND (arg0, 1)));\n \t}\n-      /* Convert A - (-B) to A + B.  */\n-      else if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n \n       else if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t       || flag_fast_math)\n@@ -5037,6 +5053,11 @@ fold (expr)\n       goto associate;\n \n     case MULT_EXPR:\n+      /* (-A) * (-B) -> A * B  */\n+      if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == NEGATE_EXPR)\n+\treturn fold (build (MULT_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t            TREE_OPERAND (arg1, 0)));\n+\n       if (! FLOAT_TYPE_P (type))\n \t{\n \t  if (integer_zerop (arg1))\n@@ -5230,6 +5251,11 @@ fold (expr)\n #endif\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \n+      /* (-A) / (-B) -> A / B  */\n+      if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == NEGATE_EXPR)\n+\treturn fold (build (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t    TREE_OPERAND (arg1, 0)));\n+\n       /* In IEEE floating point, x/1 is not equivalent to x for snans.\n \t However, ANSI says we can drop signals, so we can do this anyway.  */\n       if (real_onep (arg1))\n@@ -5662,6 +5688,29 @@ fold (expr)\n     case GT_EXPR:\n     case LE_EXPR:\n     case GE_EXPR:\n+      if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n+\t{\n+\t  /* (-a) CMP (-b) -> b CMP a  */\n+\t  if (TREE_CODE (arg0) == NEGATE_EXPR\n+\t      && TREE_CODE (arg1) == NEGATE_EXPR)\n+\t    return fold (build (code, type, TREE_OPERAND (arg1, 0),\n+\t\t\t\tTREE_OPERAND (arg0, 0)));\n+\t  /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n+\t  if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == REAL_CST)\n+\t    return\n+\t      fold (build\n+\t\t     (swap_tree_comparison (code), type,\n+\t\t      TREE_OPERAND (arg0, 0),\n+\t\t      build_real (TREE_TYPE (arg1),\n+\t\t\t\t  REAL_VALUE_NEGATE (TREE_REAL_CST (arg1)))));\n+\t  /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n+\t  /* a CMP (-0) -> a CMP 0  */\n+\t  if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (arg1)))\n+\t    return fold (build (code, type, arg0,\n+\t\t\t\tbuild_real (TREE_TYPE (arg1), dconst0)));\n+\t}\n+\n+\n       /* If one arg is a constant integer, put it last.  */\n       if (TREE_CODE (arg0) == INTEGER_CST\n \t  && TREE_CODE (arg1) != INTEGER_CST)"}]}