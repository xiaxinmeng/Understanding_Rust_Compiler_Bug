{"sha": "558798156b41fcbe5ba68b75171708cad135b041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU4Nzk4MTU2YjQxZmNiZTViYTY4Yjc1MTcxNzA4Y2FkMTM1YjA0MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-01T08:56:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-01T08:56:25Z"}, "message": "[C] Avoid aka types that just add tags\n\ndiag-aka-1.c tests that:\n\n  struct T { int i; } T;\n  void *a;\n  T *t = a;\n\nproduces:\n\n  request for implicit conversion from 'void *' to 'T *' {aka 'struct T *'} ...\n\nBut printing an aka for the tag seems a bit redundant when the tag name\nis the same as the typedef name.  It's probably not going to be telling\nthe user anything they don't already know, and can be distracting if \"T\"\nrather than \"struct T\" is the preferred choice for an exported interface.\nThis is even more true if the tag is anonymous; e.g.:\n\n  struct { int i; } T;\n  void *a;\n  T *t = a;\n\ngives:\n\n  request for implicit conversion from 'void *' to 'T *' {aka 'struct <anonymous> *'}\n\nRather than just drop the test above, the patch instead tests for:\n\n  struct T { int i; } *T;\n\nwhere seeing the tag definitely helps.\n\n2019-10-01  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/c/\n\t* c-objc-common.c (useful_aka_type_p): New function.\n\t(print_type): Use it to decide whether an aka type is worth printing.\n\ngcc/testsuite/\n\t* gcc.dg/diag-aka-1.c (T): Turn into a pointer typedef.\n\t(foo): Update accordingly.\n\t* gcc.dg/diag-aka-4.c: New test.\n\nFrom-SVN: r276395", "tree": {"sha": "7e71706fa542a6dc326eaee82cfdf1611bdeaf7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e71706fa542a6dc326eaee82cfdf1611bdeaf7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/558798156b41fcbe5ba68b75171708cad135b041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558798156b41fcbe5ba68b75171708cad135b041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/558798156b41fcbe5ba68b75171708cad135b041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/558798156b41fcbe5ba68b75171708cad135b041/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8209db250f305cc79fd751c3ed056fb9ff551a83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8209db250f305cc79fd751c3ed056fb9ff551a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8209db250f305cc79fd751c3ed056fb9ff551a83"}], "stats": {"total": 156, "additions": 153, "deletions": 3}, "files": [{"sha": "3156e35f39becb95615d436d4424efae07b68e16", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=558798156b41fcbe5ba68b75171708cad135b041", "patch": "@@ -1,3 +1,8 @@\n+2019-10-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-objc-common.c (useful_aka_type_p): New function.\n+\t(print_type): Use it to decide whether an aka type is worth printing.\n+\n 2019-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/88203"}, {"sha": "e1f3b2ee436ccfc53905d1ff361b3ba3b6f2fef7", "filename": "gcc/c/c-objc-common.c", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Fc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Fc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.c?ref=558798156b41fcbe5ba68b75171708cad135b041", "patch": "@@ -62,6 +62,73 @@ c_objc_common_init (void)\n   return c_common_init ();\n }\n \n+/* Return true if it's worth saying that TYPE1 is also known as TYPE2.  */\n+\n+static bool\n+useful_aka_type_p (tree type1, tree type2)\n+{\n+  if (type1 == type2)\n+    return false;\n+\n+  if (type1 == error_mark_node || type2 == error_mark_node)\n+    return false;\n+\n+  if (TREE_CODE (type1) != TREE_CODE (type2))\n+    return true;\n+\n+  if (typedef_variant_p (type1))\n+    {\n+      /* Saying that \"foo\" is also known as \"struct foo\" or\n+\t \"struct <anonymous>\" is unlikely to be useful, since users of\n+\t structure-like types would already know that they're structures.\n+\t The same applies to unions and enums; in general, printing the\n+\t tag is only useful if it has a different name.  */\n+      tree_code code = TREE_CODE (type2);\n+      tree id2 = TYPE_IDENTIFIER (type2);\n+      if ((code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE)\n+\t  && (!id2 || TYPE_IDENTIFIER (type1) == id2))\n+\treturn false;\n+\n+      return true;\n+    }\n+  else\n+    {\n+      switch (TREE_CODE (type1))\n+\t{\n+\tcase POINTER_TYPE:\n+\tcase REFERENCE_TYPE:\n+\t  return useful_aka_type_p (TREE_TYPE (type1), TREE_TYPE (type2));\n+\n+\tcase ARRAY_TYPE:\n+\t  return (useful_aka_type_p (TYPE_DOMAIN (type1), TYPE_DOMAIN (type2))\n+\t\t  || useful_aka_type_p (TREE_TYPE (type1), TREE_TYPE (type2)));\n+\n+\tcase FUNCTION_TYPE:\n+\t  {\n+\t    tree args1 = TYPE_ARG_TYPES (type1);\n+\t    tree args2 = TYPE_ARG_TYPES (type2);\n+\t    while (args1 != args2)\n+\t      {\n+\t\t/* Although this shouldn't happen, it seems to wrong to assert\n+\t\t   for it in a diagnostic routine.  */\n+\t\tif (!args1 || args1 == void_type_node)\n+\t\t  return true;\n+\t\tif (!args2 || args2 == void_type_node)\n+\t\t  return true;\n+\t\tif (useful_aka_type_p (TREE_VALUE (args1), TREE_VALUE (args2)))\n+\t\t  return true;\n+\t\targs1 = TREE_CHAIN (args1);\n+\t\targs2 = TREE_CHAIN (args2);\n+\t      }\n+\t    return useful_aka_type_p (TREE_TYPE (type1), TREE_TYPE (type2));\n+\t  }\n+\n+\tdefault:\n+\t  return true;\n+\t}\n+    }\n+}\n+\n /* Print T to CPP.  */\n \n static void\n@@ -83,7 +150,7 @@ print_type (c_pretty_printer *cpp, tree t, bool *quoted)\n      stripped version.  But sometimes the stripped version looks\n      exactly the same, so we don't want it after all.  To avoid\n      printing it in that case, we play ugly obstack games.  */\n-  if (TYPE_CANONICAL (t) && t != TYPE_CANONICAL (t))\n+  if (TYPE_CANONICAL (t) && useful_aka_type_p (t, TYPE_CANONICAL (t)))\n     {\n       c_pretty_printer cpp2;\n       /* Print the stripped version into a temporary printer.  */"}, {"sha": "891b2bf5e4be14b70b73312280d87acaff4fe10d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=558798156b41fcbe5ba68b75171708cad135b041", "patch": "@@ -1,3 +1,9 @@\n+2019-10-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/diag-aka-1.c (T): Turn into a pointer typedef.\n+\t(foo): Update accordingly.\n+\t* gcc.dg/diag-aka-4.c: New test.\n+\n 2019-10-01  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/diag-aka-3.c: New test."}, {"sha": "3383c1c263bf1dfd57ab941c7766fc4525fd9ef2", "filename": "gcc/testsuite/gcc.dg/diag-aka-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-1.c?ref=558798156b41fcbe5ba68b75171708cad135b041", "patch": "@@ -2,7 +2,7 @@\n /* { dg-options \"-Wc++-compat\" } */\n \n typedef struct A { int i; } B;\n-typedef struct T { int i; } T;\n+typedef struct T { int i; } *T; /* { dg-warning \"using 'T' as both a typedef and a tag is invalid\" } */\n typedef const float TFA;\n typedef TFA TFB;\n typedef TFB TFC;\n@@ -24,6 +24,6 @@ bar (B *b, int *i)\n int\n foo (void *a)\n {\n-  T *t = a; /* { dg-warning \"request for implicit conversion from 'void \\\\*' to 'T \\\\*' {aka 'struct T \\\\*'} not\" } */\n+  T t = a; /* { dg-warning \"request for implicit conversion from 'void \\\\*' to 'T' {aka 'struct T \\\\*'} not\" } */\n   return t->i;\n }"}, {"sha": "cf98dd96a53d6e0f40acda9043cf1eef52db74c1", "filename": "gcc/testsuite/gcc.dg/diag-aka-4.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/558798156b41fcbe5ba68b75171708cad135b041/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-4.c?ref=558798156b41fcbe5ba68b75171708cad135b041", "patch": "@@ -0,0 +1,72 @@\n+typedef struct struct_wrapper { int i; } struct_wrapper;\n+typedef struct { int i; } anon_struct_wrapper;\n+\n+typedef union union_wrapper { int i; } union_wrapper;\n+typedef union { int i; } anon_union_wrapper;\n+\n+typedef enum enum_wrapper { A, B } enum_wrapper;\n+typedef enum { C, D } anon_enum_wrapper;\n+\n+void test_struct_wrapper (struct_wrapper y, int x)\n+{\n+  struct_wrapper *ptr = &x; /* { dg-error {initialization of 'struct_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  const struct_wrapper *const_ptr = &x; /* { dg-error {initialization of 'const struct_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  volatile struct_wrapper *volatile_ptr = &x; /* { dg-error {initialization of 'volatile struct_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  struct_wrapper (*aptr)[10] = &x; /* { dg-error {initialization of 'struct_wrapper \\(\\*\\)\\[10\\]' from incompatible pointer type 'int \\*'} } */\n+  struct_wrapper (*f1)(int) = &x; /* { dg-error {initialization of 'struct_wrapper \\(\\*\\)\\(int\\)' from incompatible pointer type 'int \\*'} } */\n+  int (*f2)(struct_wrapper) = &x; /* { dg-error {initialization of 'int \\(\\*\\)\\(struct_wrapper\\)' from incompatible pointer type 'int \\*'} } */\n+  y = x; /* { dg-error {incompatible types when assigning to type 'struct_wrapper' from type 'int'} } */\n+}\n+\n+void test_anon_struct_wrapper (anon_struct_wrapper y, int x)\n+{\n+  anon_struct_wrapper *ptr = &x; /* { dg-error {initialization of 'anon_struct_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  const anon_struct_wrapper *const_ptr = &x; /* { dg-error {initialization of 'const anon_struct_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  volatile anon_struct_wrapper *volatile_ptr = &x; /* { dg-error {initialization of 'volatile anon_struct_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  anon_struct_wrapper (*aptr)[10] = &x; /* { dg-error {initialization of 'anon_struct_wrapper \\(\\*\\)\\[10\\]' from incompatible pointer type 'int \\*'} } */\n+  anon_struct_wrapper (*f1)(int) = &x; /* { dg-error {initialization of 'anon_struct_wrapper \\(\\*\\)\\(int\\)' from incompatible pointer type 'int \\*'} } */\n+  int (*f2)(anon_struct_wrapper) = &x; /* { dg-error {initialization of 'int \\(\\*\\)\\(anon_struct_wrapper\\)' from incompatible pointer type 'int \\*'} } */\n+  y = x; /* { dg-error {incompatible types when assigning to type 'anon_struct_wrapper' from type 'int'} } */\n+}\n+\n+void test_union_wrapper (union_wrapper y, int x)\n+{\n+  union_wrapper *ptr = &x; /* { dg-error {initialization of 'union_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  const union_wrapper *const_ptr = &x; /* { dg-error {initialization of 'const union_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  volatile union_wrapper *volatile_ptr = &x; /* { dg-error {initialization of 'volatile union_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  union_wrapper (*aptr)[10] = &x; /* { dg-error {initialization of 'union_wrapper \\(\\*\\)\\[10\\]' from incompatible pointer type 'int \\*'} } */\n+  union_wrapper (*f1)(int) = &x; /* { dg-error {initialization of 'union_wrapper \\(\\*\\)\\(int\\)' from incompatible pointer type 'int \\*'} } */\n+  int (*f2)(union_wrapper) = &x; /* { dg-error {initialization of 'int \\(\\*\\)\\(union_wrapper\\)' from incompatible pointer type 'int \\*'} } */\n+  y = x; /* { dg-error {incompatible types when assigning to type 'union_wrapper' from type 'int'} } */\n+}\n+\n+void test_anon_union_wrapper (anon_union_wrapper y, int x)\n+{\n+  anon_union_wrapper *ptr = &x; /* { dg-error {initialization of 'anon_union_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  const anon_union_wrapper *const_ptr = &x; /* { dg-error {initialization of 'const anon_union_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  volatile anon_union_wrapper *volatile_ptr = &x; /* { dg-error {initialization of 'volatile anon_union_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  anon_union_wrapper (*aptr)[10] = &x; /* { dg-error {initialization of 'anon_union_wrapper \\(\\*\\)\\[10\\]' from incompatible pointer type 'int \\*'} } */\n+  anon_union_wrapper (*f1)(int) = &x; /* { dg-error {initialization of 'anon_union_wrapper \\(\\*\\)\\(int\\)' from incompatible pointer type 'int \\*'} } */\n+  int (*f2)(anon_union_wrapper) = &x; /* { dg-error {initialization of 'int \\(\\*\\)\\(anon_union_wrapper\\)' from incompatible pointer type 'int \\*'} } */\n+  y = x; /* { dg-error {incompatible types when assigning to type 'anon_union_wrapper' from type 'int'} } */\n+}\n+\n+void test_enum_wrapper (enum_wrapper y, int x)\n+{\n+  enum_wrapper *ptr = &x; /* { dg-error {initialization of 'enum_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  const enum_wrapper *const_ptr = &x; /* { dg-error {initialization of 'const enum_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  volatile enum_wrapper *volatile_ptr = &x; /* { dg-error {initialization of 'volatile enum_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  enum_wrapper (*aptr)[10] = &x; /* { dg-error {initialization of 'enum_wrapper \\(\\*\\)\\[10\\]' from incompatible pointer type 'int \\*'} } */\n+  enum_wrapper (*f1)(int) = &x; /* { dg-error {initialization of 'enum_wrapper \\(\\*\\)\\(int\\)' from incompatible pointer type 'int \\*'} } */\n+  int (*f2)(enum_wrapper) = &x; /* { dg-error {initialization of 'int \\(\\*\\)\\(enum_wrapper\\)' from incompatible pointer type 'int \\*'} } */\n+}\n+\n+void test_anon_enum_wrapper (anon_enum_wrapper y, int x)\n+{\n+  anon_enum_wrapper *ptr = &x; /* { dg-error {initialization of 'anon_enum_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  const anon_enum_wrapper *const_ptr = &x; /* { dg-error {initialization of 'const anon_enum_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  volatile anon_enum_wrapper *volatile_ptr = &x; /* { dg-error {initialization of 'volatile anon_enum_wrapper \\*' from incompatible pointer type 'int \\*'} } */\n+  anon_enum_wrapper (*aptr)[10] = &x; /* { dg-error {initialization of 'anon_enum_wrapper \\(\\*\\)\\[10\\]' from incompatible pointer type 'int \\*'} } */\n+  anon_enum_wrapper (*f1)(int) = &x; /* { dg-error {initialization of 'anon_enum_wrapper \\(\\*\\)\\(int\\)' from incompatible pointer type 'int \\*'} } */\n+  int (*f2)(anon_enum_wrapper) = &x; /* { dg-error {initialization of 'int \\(\\*\\)\\(anon_enum_wrapper\\)' from incompatible pointer type 'int \\*'} } */\n+}"}]}