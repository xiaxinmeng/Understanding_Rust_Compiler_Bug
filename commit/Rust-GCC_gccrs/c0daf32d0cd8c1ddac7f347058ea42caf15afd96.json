{"sha": "c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBkYWYzMmQwY2Q4YzFkZGFjN2YzNDcwNThlYTQyY2FmMTVhZmQ5Ng==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2016-04-05T16:40:00Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2016-04-05T16:40:00Z"}, "message": "Fix PR c++/70452 (regression in C++ parsing performance)\n\ngcc/cp/ChangeLog:\n\n\tPR c++/70452\n\t* constexpr.c (struct fundef_copy): New struct.\n\t(struct fundef_copies_table_t): New struct.\n\t(fundef_copies_table): New static variable.\n\t(maybe_initialize_fundef_copies_table): New static function.\n\t(get_fundef_copy): New static function.\n\t(save_fundef_copy): New static function.\n\t(cxx_eval_call_expression): Use get_fundef_copy, and\n\tsave_fundef_copy.\n\t(constexpr_call_table): Add \"deletable\" GTY marker.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/70452\n\t* g++.dg/ext/constexpr-vla4.C: New test.\n\nFrom-SVN: r234753", "tree": {"sha": "37e8ab52937bf7489cef7d365c164152b6294e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37e8ab52937bf7489cef7d365c164152b6294e91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/comments", "author": null, "committer": null, "parents": [{"sha": "bf867841b453a347ec0d9dca45758f20949fd89a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf867841b453a347ec0d9dca45758f20949fd89a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf867841b453a347ec0d9dca45758f20949fd89a"}], "stats": {"total": 134, "additions": 129, "deletions": 5}, "files": [{"sha": "77c0b5b20896f1c171244a8a8d38e42828f852a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "patch": "@@ -1,3 +1,16 @@\n+2016-04-05  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\tPR c++/70452\n+\t* constexpr.c (struct fundef_copy): New struct.\n+\t(struct fundef_copies_table_t): New struct.\n+\t(fundef_copies_table): New static variable.\n+\t(maybe_initialize_fundef_copies_table): New static function.\n+\t(get_fundef_copy): New static function.\n+\t(save_fundef_copy): New static function.\n+\t(cxx_eval_call_expression): Use get_fundef_copy, and\n+\tsave_fundef_copy.\n+\t(constexpr_call_table): Add \"deletable\" GTY marker.\n+\n 2016-04-05  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/70452"}, {"sha": "1c2701bbcd4478f5a2601271d20ceeaa496efdc5", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 94, "deletions": 5, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "patch": "@@ -915,7 +915,7 @@ struct constexpr_ctx {\n /* A table of all constexpr calls that have been evaluated by the\n    compiler in this translation unit.  */\n \n-static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n+static GTY ((deletable)) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n static tree cxx_eval_constant_expression (const constexpr_ctx *, tree,\n \t\t\t\t\t  bool, bool *, bool *, tree * = NULL);\n@@ -965,6 +965,78 @@ maybe_initialize_constexpr_call_table (void)\n     constexpr_call_table = hash_table<constexpr_call_hasher>::create_ggc (101);\n }\n \n+/* The representation of a single node in the per-function freelist maintained\n+   by FUNDEF_COPIES_TABLE.  */\n+\n+struct fundef_copy\n+{\n+  tree body;\n+  tree parms;\n+  tree res;\n+  fundef_copy *prev;\n+};\n+\n+/* During constexpr CALL_EXPR evaluation, to avoid issues with sharing when\n+   a function happens to get called recursively, we unshare the callee\n+   function's body and evaluate this unshared copy instead of evaluating the\n+   original body.\n+\n+   FUNDEF_COPIES_TABLE is a per-function freelist of these unshared function\n+   copies.  The underlying data structure of FUNDEF_COPIES_TABLE is a hash_map\n+   that's keyed off of the original FUNCTION_DECL and whose value is the chain\n+   of this function's unused copies awaiting reuse.  */\n+\n+struct fundef_copies_table_t\n+{\n+  hash_map<tree, fundef_copy *> *map;\n+};\n+\n+static GTY((deletable)) fundef_copies_table_t fundef_copies_table;\n+\n+/* Initialize FUNDEF_COPIES_TABLE if it's not initialized.  */\n+\n+static void\n+maybe_initialize_fundef_copies_table ()\n+{\n+  if (fundef_copies_table.map == NULL)\n+    fundef_copies_table.map = hash_map<tree, fundef_copy *>::create_ggc (101);\n+}\n+\n+/* Reuse a copy or create a new unshared copy of the function FUN.\n+   Return this copy.  */\n+\n+static fundef_copy *\n+get_fundef_copy (tree fun)\n+{\n+  maybe_initialize_fundef_copies_table ();\n+\n+  fundef_copy *copy;\n+  fundef_copy **slot = &fundef_copies_table.map->get_or_insert (fun, NULL);\n+  if (*slot == NULL)\n+    {\n+      copy = ggc_alloc<fundef_copy> ();\n+      copy->body = copy_fn (fun, copy->parms, copy->res);\n+      copy->prev = NULL;\n+    }\n+  else\n+    {\n+      copy = *slot;\n+      *slot = (*slot)->prev;\n+    }\n+\n+  return copy;\n+}\n+\n+/* Save the copy COPY of function FUN for later reuse by get_fundef_copy().  */\n+\n+static void\n+save_fundef_copy (tree fun, fundef_copy *copy)\n+{\n+  fundef_copy **slot = &fundef_copies_table.map->get_or_insert (fun, NULL);\n+  copy->prev = *slot;\n+  *slot = copy;\n+}\n+\n /* We have an expression tree T that represents a call, either CALL_EXPR\n    or AGGR_INIT_EXPR.  If the call is lexically to a named function,\n    retrun the _DECL for that function.  */\n@@ -1365,10 +1437,13 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       if (!result || result == error_mark_node)\n \t{\n \t  gcc_assert (DECL_SAVED_TREE (fun));\n-\t  tree parms, res;\n+\t  tree body, parms, res;\n \n-\t  /* Unshare the whole function body.  */\n-\t  tree body = copy_fn (fun, parms, res);\n+\t  /* Reuse or create a new unshared copy of this function's body.  */\n+\t  fundef_copy *copy = get_fundef_copy (fun);\n+\t  body = copy->body;\n+\t  parms = copy->parms;\n+\t  res = copy->res;\n \n \t  /* Associate the bindings with the remapped parms.  */\n \t  tree bound = new_call.bindings;\n@@ -1397,8 +1472,14 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  else\n \t    ctx->values->put (res, NULL_TREE);\n \n+\t  /* Track the callee's evaluated SAVE_EXPRs so that we can forget\n+\t     their values after the call.  */\n+\t  constexpr_ctx ctx_with_save_exprs = *ctx;\n+\t  hash_set<tree> save_exprs;\n+\t  ctx_with_save_exprs.save_exprs = &save_exprs;\n+\n \t  tree jump_target = NULL_TREE;\n-\t  cxx_eval_constant_expression (ctx, body,\n+\t  cxx_eval_constant_expression (&ctx_with_save_exprs, body,\n \t\t\t\t\tlval, non_constant_p, overflow_p,\n \t\t\t\t\t&jump_target);\n \n@@ -1423,6 +1504,11 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t}\n \t    }\n \n+\t  /* Forget the saved values of the callee's SAVE_EXPRs.  */\n+\t  for (hash_set<tree>::iterator iter = save_exprs.begin();\n+\t       iter != save_exprs.end(); ++iter)\n+\t    ctx_with_save_exprs.values->remove (*iter);\n+\n \t  /* Remove the parms/result from the values map.  Is it worth\n \t     bothering to do this when the map itself is only live for\n \t     one constexpr evaluation?  If so, maybe also clear out\n@@ -1432,6 +1518,9 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t    ctx->values->remove (slot);\n \t  for (tree parm = parms; parm; parm = TREE_CHAIN (parm))\n \t    ctx->values->remove (parm);\n+\n+\t  /* Make the unshared function copy we used available for re-use.  */\n+\t  save_fundef_copy (fun, copy);\n \t}\n \n       if (result == error_mark_node)"}, {"sha": "957823d7fe23ee195d36f6cf2c49f53e343067a7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "patch": "@@ -1,3 +1,8 @@\n+2016-04-05  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\tPR c++/70452\n+\t* g++.dg/ext/constexpr-vla4.C: New test.\n+\n 2016-04-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/70510"}, {"sha": "428a8fd5224a4f626c8422a7434c23b4f77bcccd", "filename": "gcc/testsuite/g++.dg/ext/constexpr-vla4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0daf32d0cd8c1ddac7f347058ea42caf15afd96/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconstexpr-vla4.C?ref=c0daf32d0cd8c1ddac7f347058ea42caf15afd96", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/70452\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int\n+foo (int n, bool p)\n+{\n+  __extension__ int a [n] = { 0 };\n+  if (n == 3)\n+    foo (n - 2, false);\n+  if (n == 3)\n+    foo(n - 1, true);\n+  if (p)\n+    return a[1];\n+  return 0;\n+}\n+\n+constexpr int i2 = foo (3, false); // { dg-bogus \"array subscript out of bound\" }"}]}