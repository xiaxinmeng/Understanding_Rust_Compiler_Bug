{"sha": "73b7f58c902bd97688ef3d1391039669a67ab37f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNiN2Y1OGM5MDJiZDk3Njg4ZWYzZDEzOTEwMzk2NjlhNjdhYjM3Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-05-17T17:02:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-05-17T17:02:35Z"}, "message": "Fix queueing related bugs\n\nFrom-SVN: r42206", "tree": {"sha": "2b57672c9cea6ba95fc5715c3da4aa5e6c5f0e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b57672c9cea6ba95fc5715c3da4aa5e6c5f0e5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73b7f58c902bd97688ef3d1391039669a67ab37f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b7f58c902bd97688ef3d1391039669a67ab37f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73b7f58c902bd97688ef3d1391039669a67ab37f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b7f58c902bd97688ef3d1391039669a67ab37f/comments", "author": null, "committer": null, "parents": [{"sha": "7332066bda945c150f7f07b6800673c68114afaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7332066bda945c150f7f07b6800673c68114afaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7332066bda945c150f7f07b6800673c68114afaa"}], "stats": {"total": 20, "additions": 17, "deletions": 3}, "files": [{"sha": "b256242e0ee909b6380289ec9b7f1126be34ea21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b7f58c902bd97688ef3d1391039669a67ab37f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b7f58c902bd97688ef3d1391039669a67ab37f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73b7f58c902bd97688ef3d1391039669a67ab37f", "patch": "@@ -1,3 +1,10 @@\n+2001-05-17  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* expr.c (protect_from_queue): Protect against subsequent calls to\n+\temit_queue.\n+\t(expand_expr, case ADDR_EXPR): Prevent protect_from_queue from being\n+\ttoo clever.\n+\n Thu May 17 18:17:34 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* simplify_rtx.c (simplify_subreg): Fix simplification of nested subregs."}, {"sha": "beafdfdec0f5f24c65fbd3829d6cf21be96665a9", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73b7f58c902bd97688ef3d1391039669a67ab37f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73b7f58c902bd97688ef3d1391039669a67ab37f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=73b7f58c902bd97688ef3d1391039669a67ab37f", "patch": "@@ -396,6 +396,9 @@ protect_from_queue (x, modify)\n \t\t\t\tQUEUED_INSN (y));\n \t      return temp;\n \t    }\n+\t  /* Copy the address into a pseudo, so that the returned value\n+\t     remains correct across calls to emit_queue.  */\n+\t  XEXP (new, 0) = copy_to_reg (XEXP (new, 0));\n \t  return new;\n \t}\n       /* Otherwise, recursively protect the subexpressions of all\n@@ -422,9 +425,11 @@ protect_from_queue (x, modify)\n \t}\n       return x;\n     }\n-  /* If the increment has not happened, use the variable itself.  */\n+  /* If the increment has not happened, use the variable itself.  Copy it\n+     into a new pseudo so that the value remains correct across calls to\n+     emit_queue.  */\n   if (QUEUED_INSN (x) == 0)\n-    return QUEUED_VAR (x);\n+    return copy_to_reg (QUEUED_VAR (x));\n   /* If the increment has happened and a pre-increment copy exists,\n      use that copy.  */\n   if (QUEUED_COPY (x) != 0)\n@@ -8588,7 +8593,9 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (ignore)\n \t    return op0;\n \n-\t  op0 = protect_from_queue (op0, 0);\n+\t  /* Pass 1 for MODIFY, so that protect_from_queue doesn't get\n+\t     clever and returns a REG when given a MEM.  */\n+\t  op0 = protect_from_queue (op0, 1);\n \n \t  /* We would like the object in memory.  If it is a constant, we can\n \t     have it be statically allocated into memory.  For a non-constant,"}]}