{"sha": "74f9986eafd45489ff6563d6bb824ec1ad39cd14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRmOTk4NmVhZmQ0NTQ4OWZmNjU2M2Q2YmI4MjRlYzFhZDM5Y2QxNA==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2018-08-02T18:11:54Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2018-08-02T18:11:54Z"}, "message": "rs6000-string.c (select_block_compare_mode): Move test for word_mode_ok here instead of passing as argument.\n\n2018-07-31  Aaron Sawdey  <acsawdey@linux.ibm.com>\n\n\t* config/rs6000/rs6000-string.c (select_block_compare_mode): Move test\n\tfor word_mode_ok here instead of passing as argument.\n\t(expand_block_compare): Change select_block_compare_mode() call.\n\t(expand_strncmp_gpr_sequence): New function.\n\t(expand_strn_compare): Make use of expand_strncmp_gpr_sequence.\n\nFrom-SVN: r263273", "tree": {"sha": "c10a388cd3cac15d732ba9ca1a017c81456cad6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c10a388cd3cac15d732ba9ca1a017c81456cad6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74f9986eafd45489ff6563d6bb824ec1ad39cd14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74f9986eafd45489ff6563d6bb824ec1ad39cd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74f9986eafd45489ff6563d6bb824ec1ad39cd14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74f9986eafd45489ff6563d6bb824ec1ad39cd14/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1293ed1e19b038da2daf2d8d22ffc434ed75b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1293ed1e19b038da2daf2d8d22ffc434ed75b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1293ed1e19b038da2daf2d8d22ffc434ed75b4f"}], "stats": {"total": 385, "additions": 213, "deletions": 172}, "files": [{"sha": "139b896a231147f836402d79783749d8b0e09a02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f9986eafd45489ff6563d6bb824ec1ad39cd14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f9986eafd45489ff6563d6bb824ec1ad39cd14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74f9986eafd45489ff6563d6bb824ec1ad39cd14", "patch": "@@ -1,3 +1,11 @@\n+2018-08-02  Aaron Sawdey  <acsawdey@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000-string.c (select_block_compare_mode): Move test\n+\tfor word_mode_ok here instead of passing as argument.\n+\t(expand_block_compare): Change select_block_compare_mode() call.\n+\t(expand_strncmp_gpr_sequence): New function.\n+\t(expand_strn_compare): Make use of expand_strncmp_gpr_sequence.\n+\n 2018-08-02  Jeff Law  <law@redhat.com>\n \n \tPR target/86790"}, {"sha": "451e9ed33daeb49112ee056ba13e62cc6f717f05", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 205, "deletions": 172, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74f9986eafd45489ff6563d6bb824ec1ad39cd14/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74f9986eafd45489ff6563d6bb824ec1ad39cd14/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=74f9986eafd45489ff6563d6bb824ec1ad39cd14", "patch": "@@ -238,13 +238,11 @@ do_load_for_compare (rtx reg, rtx mem, machine_mode mode)\n \n    OFFSET is the current read offset from the beginning of the block.\n    BYTES is the number of bytes remaining to be read.\n-   ALIGN is the minimum alignment of the memory blocks being compared in bytes.\n-   WORD_MODE_OK indicates using WORD_MODE is allowed, else SImode is\n-   the largest allowable mode.  */\n+   ALIGN is the minimum alignment of the memory blocks being compared in bytes.  */\n static machine_mode\n select_block_compare_mode (unsigned HOST_WIDE_INT offset,\n \t\t\t   unsigned HOST_WIDE_INT bytes,\n-\t\t\t   unsigned HOST_WIDE_INT align, bool word_mode_ok)\n+\t\t\t   unsigned HOST_WIDE_INT align)\n {\n   /* First see if we can do a whole load unit\n      as that will be more efficient than a larger load + shift.  */\n@@ -257,6 +255,11 @@ select_block_compare_mode (unsigned HOST_WIDE_INT offset,\n   /* The most we can read without potential page crossing.  */\n   unsigned HOST_WIDE_INT maxread = ROUND_UP (bytes, align);\n \n+  /* If we have an LE target without ldbrx and word_mode is DImode,\n+     then we must avoid using word_mode.  */\n+  int word_mode_ok = !(!BYTES_BIG_ENDIAN && !TARGET_LDBRX\n+\t\t       && word_mode == DImode);\n+\n   if (word_mode_ok && bytes >= UNITS_PER_WORD)\n     return word_mode;\n   else if (bytes == GET_MODE_SIZE (SImode))\n@@ -1382,16 +1385,11 @@ expand_block_compare (rtx operands[])\n   else\n     cond = gen_reg_rtx (CCmode);\n \n-  /* If we have an LE target without ldbrx and word_mode is DImode,\n-     then we must avoid using word_mode.  */\n-  int word_mode_ok = !(!BYTES_BIG_ENDIAN && !TARGET_LDBRX\n-\t\t       && word_mode == DImode);\n-\n   /* Strategy phase.  How many ops will this take and should we expand it?  */\n \n   unsigned HOST_WIDE_INT offset = 0;\n   machine_mode load_mode =\n-    select_block_compare_mode (offset, bytes, base_align, word_mode_ok);\n+    select_block_compare_mode (offset, bytes, base_align);\n   unsigned int load_mode_size = GET_MODE_SIZE (load_mode);\n \n   /* We don't want to generate too much code.  The loop code can take\n@@ -1445,8 +1443,7 @@ expand_block_compare (rtx operands[])\n   while (bytes > 0)\n     {\n       unsigned int align = compute_current_alignment (base_align, offset);\n-      load_mode = select_block_compare_mode (offset, bytes,\n-\t\t\t\t\t     align, word_mode_ok);\n+      load_mode = select_block_compare_mode (offset, bytes, align);\n       load_mode_size = GET_MODE_SIZE (load_mode);\n       if (bytes >= load_mode_size)\n \tcmp_bytes = load_mode_size;\n@@ -1698,6 +1695,189 @@ expand_strncmp_align_check (rtx strncmp_label, rtx src_addr, HOST_WIDE_INT bytes\n   LABEL_NUSES (strncmp_label) += 1;\n }\n \n+/* Generate the sequence of compares for strcmp/strncmp using gpr instructions.\n+   BYTES_TO_COMPARE is the number of bytes to be compared.\n+   BASE_ALIGN is the smaller of the alignment of the two strings.\n+   ORIG_SRC1 is the unmodified rtx for the first string.\n+   ORIG_SRC2 is the unmodified rtx for the second string.\n+   TMP_REG_SRC1 is the register for loading the first string.\n+   TMP_REG_SRC2 is the register for loading the second string.\n+   RESULT_REG is the rtx for the result register.\n+   EQUALITY_COMPARE_REST is a flag to indicate we need to make a cleanup call\n+   to strcmp/strncmp if we have equality at the end of the inline comparison.\n+   CLEANUP_LABEL is rtx for a label we generate if we need code to clean up\n+   and generate the final comparison result.\n+   FINAL_MOVE_LABEL is rtx for a label we can branch to when we can just \n+   set the final result.  */\n+static void\n+expand_strncmp_gpr_sequence(unsigned HOST_WIDE_INT bytes_to_compare,\n+\t\t\t    unsigned int base_align,\n+\t\t\t    rtx orig_src1, rtx orig_src2,\n+\t\t\t    rtx tmp_reg_src1, rtx tmp_reg_src2, rtx result_reg,\n+\t\t\t    bool equality_compare_rest, rtx &cleanup_label,\n+\t\t\t    rtx final_move_label)\n+{\n+  unsigned int word_mode_size = GET_MODE_SIZE (word_mode);\n+  machine_mode load_mode;\n+  unsigned int load_mode_size;\n+  unsigned HOST_WIDE_INT cmp_bytes = 0;\n+  unsigned HOST_WIDE_INT offset = 0;\n+  rtx src1_addr = force_reg (Pmode, XEXP (orig_src1, 0));\n+  rtx src2_addr = force_reg (Pmode, XEXP (orig_src2, 0));\n+\n+  while (bytes_to_compare > 0)\n+    {\n+      /* GPR compare sequence:\n+         check each 8B with: ld/ld cmpd bne\n+\t If equal, use rldicr/cmpb to check for zero byte.\n+         cleanup code at end:\n+         cmpb          get byte that differs\n+         cmpb          look for zero byte\n+         orc           combine\n+         cntlzd        get bit of first zero/diff byte\n+         subfic        convert for rldcl use\n+         rldcl rldcl   extract diff/zero byte\n+         subf          subtract for final result\n+\n+         The last compare can branch around the cleanup code if the\n+         result is zero because the strings are exactly equal.  */\n+      \n+      unsigned int align = compute_current_alignment (base_align, offset);\n+      load_mode = select_block_compare_mode (offset, bytes_to_compare, align);\n+      load_mode_size = GET_MODE_SIZE (load_mode);\n+      if (bytes_to_compare >= load_mode_size)\n+\tcmp_bytes = load_mode_size;\n+      else if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n+\t{\n+\t  /* Move this load back so it doesn't go past the end.\n+\t     P8/P9 can do this efficiently.  */\n+\t  unsigned int extra_bytes = load_mode_size - bytes_to_compare;\n+\t  cmp_bytes = bytes_to_compare;\n+\t  if (extra_bytes < offset)\n+\t    {\n+\t      offset -= extra_bytes;\n+\t      cmp_bytes = load_mode_size;\n+\t      bytes_to_compare = cmp_bytes;\n+\t    }\n+\t}\n+      else\n+\t/* P7 and earlier can't do the overlapping load trick fast,\n+\t   so this forces a non-overlapping load and a shift to get\n+\t   rid of the extra bytes.  */\n+\tcmp_bytes = bytes_to_compare;\n+\n+      rtx addr1 = gen_rtx_PLUS (Pmode, src1_addr, GEN_INT (offset));\n+      do_load_for_compare_from_addr (load_mode, tmp_reg_src1, addr1, orig_src1);\n+      rtx addr2 = gen_rtx_PLUS (Pmode, src2_addr, GEN_INT (offset));\n+      do_load_for_compare_from_addr (load_mode, tmp_reg_src2, addr2, orig_src2);\n+\n+      /* We must always left-align the data we read, and\n+\t clear any bytes to the right that are beyond the string.\n+\t Otherwise the cmpb sequence won't produce the correct\n+\t results.  The beginning of the compare will be done\n+\t with word_mode so will not have any extra shifts or\n+\t clear rights.  */\n+\n+      if (load_mode_size < word_mode_size)\n+\t{\n+\t  /* Rotate left first. */\n+\t  rtx sh = GEN_INT (BITS_PER_UNIT * (word_mode_size - load_mode_size));\n+\t  do_rotl3 (tmp_reg_src1, tmp_reg_src1, sh);\n+\t  do_rotl3 (tmp_reg_src2, tmp_reg_src2, sh);\n+\t}\n+\n+      if (cmp_bytes < word_mode_size)\n+\t{\n+\t  /* Now clear right.  This plus the rotate can be\n+\t     turned into a rldicr instruction. */\n+\t  HOST_WIDE_INT mb = BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n+\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n+\t  do_and3 (tmp_reg_src1, tmp_reg_src1, mask);\n+\t  do_and3 (tmp_reg_src2, tmp_reg_src2, mask);\n+\t}\n+\n+      /* Cases to handle.  A and B are chunks of the two strings.\n+\t 1: Not end of comparison:\n+\t A != B: branch to cleanup code to compute result.\n+\t A == B: check for 0 byte, next block if not found.\n+\t 2: End of the inline comparison:\n+\t A != B: branch to cleanup code to compute result.\n+\t A == B: check for 0 byte, call strcmp/strncmp\n+\t 3: compared requested N bytes:\n+\t A == B: branch to result 0.\n+\t A != B: cleanup code to compute result.  */\n+\n+      unsigned HOST_WIDE_INT remain = bytes_to_compare - cmp_bytes;\n+\n+      rtx dst_label;\n+      if (remain > 0 || equality_compare_rest)\n+\t{\n+\t  /* Branch to cleanup code, otherwise fall through to do\n+\t     more compares.  */\n+\t  if (!cleanup_label)\n+\t    cleanup_label = gen_label_rtx ();\n+\t  dst_label = cleanup_label;\n+\t}\n+      else\n+\t/* Branch to end and produce result of 0.  */\n+\tdst_label = final_move_label;\n+\n+      rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n+      rtx cond = gen_reg_rtx (CCmode);\n+\n+      /* Always produce the 0 result, it is needed if\n+\t cmpb finds a 0 byte in this chunk.  */\n+      rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n+      rs6000_emit_dot_insn (result_reg, tmp, 1, cond);\n+\n+      rtx cmp_rtx;\n+      if (remain == 0 && !equality_compare_rest)\n+\tcmp_rtx = gen_rtx_EQ (VOIDmode, cond, const0_rtx);\n+      else\n+\tcmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n+\n+      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n+\t\t\t\t\t lab_ref, pc_rtx);\n+      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+      JUMP_LABEL (j) = dst_label;\n+      LABEL_NUSES (dst_label) += 1;\n+\n+      if (remain > 0 || equality_compare_rest)\n+\t{\n+\t  /* Generate a cmpb to test for a 0 byte and branch\n+\t     to final result if found.  */\n+\t  rtx cmpb_zero = gen_reg_rtx (word_mode);\n+\t  rtx lab_ref_fin = gen_rtx_LABEL_REF (VOIDmode, final_move_label);\n+\t  rtx condz = gen_reg_rtx (CCmode);\n+\t  rtx zero_reg = gen_reg_rtx (word_mode);\n+\t  emit_move_insn (zero_reg, GEN_INT (0));\n+\t  do_cmpb3 (cmpb_zero, tmp_reg_src1, zero_reg);\n+\n+\t  if (cmp_bytes < word_mode_size)\n+\t    {\n+\t      /* Don't want to look at zero bytes past end.  */\n+\t      HOST_WIDE_INT mb =\n+\t\tBITS_PER_UNIT * (word_mode_size - cmp_bytes);\n+\t      rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n+\t      do_and3 (cmpb_zero, cmpb_zero, mask);\n+\t    }\n+\n+\t  emit_move_insn (condz, gen_rtx_COMPARE (CCmode, cmpb_zero, zero_reg));\n+\t  rtx cmpnz_rtx = gen_rtx_NE (VOIDmode, condz, const0_rtx);\n+\t  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmpnz_rtx,\n+\t\t\t\t\t     lab_ref_fin, pc_rtx);\n+\t  rtx j2 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+\t  JUMP_LABEL (j2) = final_move_label;\n+\t  LABEL_NUSES (final_move_label) += 1;\n+\n+\t}\n+\n+      offset += cmp_bytes;\n+      bytes_to_compare -= cmp_bytes;\n+    }\n+\n+}\n+\n /* Generate the final sequence that identifies the differing\n    byte and generates the final result, taking into account\n    zero bytes:\n@@ -1797,7 +1977,7 @@ expand_strn_compare (rtx operands[], int no_length)\n       bytes_rtx = operands[3];\n       align_rtx = operands[4];\n     }\n-  unsigned HOST_WIDE_INT cmp_bytes = 0;\n+\n   rtx src1_addr = force_reg (Pmode, XEXP (orig_src1, 0));\n   rtx src2_addr = force_reg (Pmode, XEXP (orig_src2, 0));\n \n@@ -1822,11 +2002,6 @@ expand_strn_compare (rtx operands[], int no_length)\n \n   gcc_assert (GET_MODE (target) == SImode);\n \n-  /* If we have an LE target without ldbrx and word_mode is DImode,\n-     then we must avoid using word_mode.  */\n-  int word_mode_ok = !(!BYTES_BIG_ENDIAN && !TARGET_LDBRX\n-\t\t       && word_mode == DImode);\n-\n   unsigned int word_mode_size = GET_MODE_SIZE (word_mode);\n \n   unsigned HOST_WIDE_INT offset = 0;\n@@ -1839,7 +2014,7 @@ expand_strn_compare (rtx operands[], int no_length)\n     bytes = UINTVAL (bytes_rtx);\n \n   machine_mode load_mode =\n-    select_block_compare_mode (offset, bytes, base_align, word_mode_ok);\n+    select_block_compare_mode (0, bytes, base_align);\n   unsigned int load_mode_size = GET_MODE_SIZE (load_mode);\n   compare_length = rs6000_string_compare_inline_limit * load_mode_size;\n \n@@ -1867,6 +2042,8 @@ expand_strn_compare (rtx operands[], int no_length)\n   rtx begin_compare_label = NULL;\n   unsigned int required_align = 8;\n \n+  required_align = 8;\n+\n   if (base_align < required_align)\n     {\n       /* Generate code that checks distance to 4k boundary for this case.  */\n@@ -1952,159 +2129,15 @@ expand_strn_compare (rtx operands[], int no_length)\n \n   /* Generate a sequence of GPR or VEC/VSX instructions to compare out\n      to the length specified.  */\n-  unsigned HOST_WIDE_INT bytes_to_compare = compare_length;\n-  while (bytes_to_compare > 0)\n-    {\n-      /* GPR compare sequence:\n-         check each 8B with: ld/ld cmpd bne\n-\t If equal, use rldicr/cmpb to check for zero byte.\n-         cleanup code at end:\n-         cmpb          get byte that differs\n-         cmpb          look for zero byte\n-         orc           combine\n-         cntlzd        get bit of first zero/diff byte\n-         subfic        convert for rldcl use\n-         rldcl rldcl   extract diff/zero byte\n-         subf          subtract for final result\n-\n-         The last compare can branch around the cleanup code if the\n-         result is zero because the strings are exactly equal.  */\n-      \n-      unsigned int align = compute_current_alignment (base_align, offset);\n-      load_mode = select_block_compare_mode (offset, bytes_to_compare,\n-\t\t\t\t\t     align, word_mode_ok);\n-      load_mode_size = GET_MODE_SIZE (load_mode);\n-      if (bytes_to_compare >= load_mode_size)\n-\tcmp_bytes = load_mode_size;\n-      else if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n-\t{\n-\t  /* Move this load back so it doesn't go past the end.\n-\t     P8/P9 can do this efficiently.  */\n-\t  unsigned int extra_bytes = load_mode_size - bytes_to_compare;\n-\t  cmp_bytes = bytes_to_compare;\n-\t  if (extra_bytes < offset)\n-\t    {\n-\t      offset -= extra_bytes;\n-\t      cmp_bytes = load_mode_size;\n-\t      bytes_to_compare = cmp_bytes;\n-\t    }\n-\t}\n-      else\n-\t/* P7 and earlier can't do the overlapping load trick fast,\n-\t   so this forces a non-overlapping load and a shift to get\n-\t   rid of the extra bytes.  */\n-\tcmp_bytes = bytes_to_compare;\n-\n-      rtx addr1 = gen_rtx_PLUS (Pmode, src1_addr, GEN_INT (offset));\n-      do_load_for_compare_from_addr (load_mode, tmp_reg_src1, addr1, orig_src1);\n-      rtx addr2 = gen_rtx_PLUS (Pmode, src2_addr, GEN_INT (offset));\n-      do_load_for_compare_from_addr (load_mode, tmp_reg_src2, addr2, orig_src2);\n-\n-      /* We must always left-align the data we read, and\n-\t clear any bytes to the right that are beyond the string.\n-\t Otherwise the cmpb sequence won't produce the correct\n-\t results.  The beginning of the compare will be done\n-\t with word_mode so will not have any extra shifts or\n-\t clear rights.  */\n-\n-      if (load_mode_size < word_mode_size)\n-\t{\n-\t  /* Rotate left first. */\n-\t  rtx sh = GEN_INT (BITS_PER_UNIT * (word_mode_size - load_mode_size));\n-\t  do_rotl3 (tmp_reg_src1, tmp_reg_src1, sh);\n-\t  do_rotl3 (tmp_reg_src2, tmp_reg_src2, sh);\n-\t}\n-\n-      if (cmp_bytes < word_mode_size)\n-\t{\n-\t  /* Now clear right.  This plus the rotate can be\n-\t     turned into a rldicr instruction. */\n-\t  HOST_WIDE_INT mb = BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n-\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n-\t  do_and3 (tmp_reg_src1, tmp_reg_src1, mask);\n-\t  do_and3 (tmp_reg_src2, tmp_reg_src2, mask);\n-\t}\n-\n-      /* Cases to handle.  A and B are chunks of the two strings.\n-\t 1: Not end of comparison:\n-\t A != B: branch to cleanup code to compute result.\n-\t A == B: check for 0 byte, next block if not found.\n-\t 2: End of the inline comparison:\n-\t A != B: branch to cleanup code to compute result.\n-\t A == B: check for 0 byte, call strcmp/strncmp\n-\t 3: compared requested N bytes:\n-\t A == B: branch to result 0.\n-\t A != B: cleanup code to compute result.  */\n-\n-      unsigned HOST_WIDE_INT remain = bytes_to_compare - cmp_bytes;\n-\n-      rtx dst_label;\n-      if (remain > 0 || equality_compare_rest)\n-\t{\n-\t  /* Branch to cleanup code, otherwise fall through to do\n-\t     more compares.  */\n-\t  if (!cleanup_label)\n-\t    cleanup_label = gen_label_rtx ();\n-\t  dst_label = cleanup_label;\n-\t}\n-      else\n-\t/* Branch to end and produce result of 0.  */\n-\tdst_label = final_move_label;\n-\n-      rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, dst_label);\n-      rtx cond = gen_reg_rtx (CCmode);\n-\n-      /* Always produce the 0 result, it is needed if\n-\t cmpb finds a 0 byte in this chunk.  */\n-      rtx tmp = gen_rtx_MINUS (word_mode, tmp_reg_src1, tmp_reg_src2);\n-      rs6000_emit_dot_insn (result_reg, tmp, 1, cond);\n-\n-      rtx cmp_rtx;\n-      if (remain == 0 && !equality_compare_rest)\n-\tcmp_rtx = gen_rtx_EQ (VOIDmode, cond, const0_rtx);\n-      else\n-\tcmp_rtx = gen_rtx_NE (VOIDmode, cond, const0_rtx);\n-\n-      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx,\n-\t\t\t\t\t lab_ref, pc_rtx);\n-      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n-      JUMP_LABEL (j) = dst_label;\n-      LABEL_NUSES (dst_label) += 1;\n-\n-      if (remain > 0 || equality_compare_rest)\n-\t{\n-\t  /* Generate a cmpb to test for a 0 byte and branch\n-\t     to final result if found.  */\n-\t  rtx cmpb_zero = gen_reg_rtx (word_mode);\n-\t  rtx lab_ref_fin = gen_rtx_LABEL_REF (VOIDmode, final_move_label);\n-\t  rtx condz = gen_reg_rtx (CCmode);\n-\t  rtx zero_reg = gen_reg_rtx (word_mode);\n-\t  emit_move_insn (zero_reg, GEN_INT (0));\n-\t  do_cmpb3 (cmpb_zero, tmp_reg_src1, zero_reg);\n-\n-\t  if (cmp_bytes < word_mode_size)\n-\t    {\n-\t      /* Don't want to look at zero bytes past end.  */\n-\t      HOST_WIDE_INT mb =\n-\t\tBITS_PER_UNIT * (word_mode_size - cmp_bytes);\n-\t      rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n-\t      do_and3 (cmpb_zero, cmpb_zero, mask);\n-\t    }\n-\n-\t  emit_move_insn (condz, gen_rtx_COMPARE (CCmode, cmpb_zero, zero_reg));\n-\t  rtx cmpnz_rtx = gen_rtx_NE (VOIDmode, condz, const0_rtx);\n-\t  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmpnz_rtx,\n-\t\t\t\t\t     lab_ref_fin, pc_rtx);\n-\t  rtx j2 = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n-\t  JUMP_LABEL (j2) = final_move_label;\n-\t  LABEL_NUSES (final_move_label) += 1;\n-\n-\t}\n-\n-      offset += cmp_bytes;\n-      bytes_to_compare -= cmp_bytes;\n-    }\n-\n+  expand_strncmp_gpr_sequence(compare_length, base_align,\n+\t\t\t      orig_src1, orig_src2,\n+\t\t\t      tmp_reg_src1, tmp_reg_src2,\n+\t\t\t      result_reg,\n+\t\t\t      equality_compare_rest,\n+\t\t\t      cleanup_label, final_move_label);\n+\n+  offset = compare_length;\n+  \n   if (equality_compare_rest)\n     {\n       /* Update pointers past what has been compared already.  */"}]}