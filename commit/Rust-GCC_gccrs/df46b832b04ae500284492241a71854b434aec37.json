{"sha": "df46b832b04ae500284492241a71854b434aec37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY0NmI4MzJiMDRhZTUwMDI4NDQ5MjI0MWE3MTg1NGI0MzRhZWMzNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T15:10:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T15:10:30Z"}, "message": "[multiple changes]\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* g-socket.adb: Minor reformatting.\n\n\t* g-socthi-mingw.adb: Minor reformatting\n\n\t* g-sothco.ads: Minor reformatting\n\n\t* exp_ch4.adb:\n\t(Expand_Concatenate_String): Complete rewrite to generate efficient code\n\tinline instead of relying on external library routines.\n\n\t* s-strops.ads, s-sopco5.ads, s-sopco5.adb, s-sopco4.ads, s-sopco4.adb,\n\ts-sopco3.ads, s-sopco3.adb, s-strops.adb: Note that this unit is now\n\tobsolescent\n\n2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb:\n\t(Eval_Attribute): for attributes of array objects that are not strings,\n\tattributes are not static if nominal subtype of object is unconstrained.\n\n2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (New_Overloaded_Entity): If two implicit homonym\n\toperations for a type T in an instance do not override each other,\n\twhen T is derived from a formal private type, the corresponding\n\toperations inherited by a type derived from T outside\n\tof the instance do not override each other either.\n\nFrom-SVN: r145679", "tree": {"sha": "063c7a454bfd413f8e5ececf340c4eb35777f8dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/063c7a454bfd413f8e5ececf340c4eb35777f8dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df46b832b04ae500284492241a71854b434aec37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df46b832b04ae500284492241a71854b434aec37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df46b832b04ae500284492241a71854b434aec37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df46b832b04ae500284492241a71854b434aec37/comments", "author": null, "committer": null, "parents": [{"sha": "3dd9959c810d51dac8ae52ce28212bcac2afc437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dd9959c810d51dac8ae52ce28212bcac2afc437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dd9959c810d51dac8ae52ce28212bcac2afc437"}], "stats": {"total": 690, "additions": 538, "deletions": 152}, "files": [{"sha": "7404808ded2668a782c3225fd4954383ca6945d6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -1,3 +1,33 @@\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-socket.adb: Minor reformatting.\n+\n+\t* g-socthi-mingw.adb: Minor reformatting\n+\n+\t* g-sothco.ads: Minor reformatting\n+\n+\t* exp_ch4.adb:\n+\t(Expand_Concatenate_String): Complete rewrite to generate efficient code\n+\tinline instead of relying on external library routines.\n+\n+\t* s-strops.ads, s-sopco5.ads, s-sopco5.adb, s-sopco4.ads, s-sopco4.adb,\n+\ts-sopco3.ads, s-sopco3.adb, s-strops.adb: Note that this unit is now\n+\tobsolescent\n+\n+2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb:\n+\t(Eval_Attribute): for attributes of array objects that are not strings,\n+\tattributes are not static if nominal subtype of object is unconstrained.\n+\n+2009-04-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (New_Overloaded_Entity): If two implicit homonym\n+\toperations for a type T in an instance do not override each other,\n+\twhen T is derived from a formal private type, the corresponding\n+\toperations inherited by a type derived from T outside\n+\tof the instance do not override each other either.\n+\n 2009-04-07  Robert Dewar  <dewar@adacore.com>\n \n \t(Osint.Fail): Change calling sequence to have one string arg"}, {"sha": "080a1af7b3fc3d1dac483eb50006f097f8327936", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 427, "deletions": 125, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -62,6 +62,7 @@ with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -145,11 +146,9 @@ package body Exp_Ch4 is\n    --  singleton operands into singleton aggregates.\n \n    procedure Expand_Concatenate_String (Cnode : Node_Id; Opnds : List_Id);\n-   --  Routine to expand concatenation of 2-5 operands (in the list Operands)\n-   --  and replace node Cnode with the result of the concatenation. If there\n-   --  are two operands, they can be string or character. If there are more\n-   --  than two operands, then are always of type string (i.e. the caller has\n-   --  already converted character operands to strings in this case).\n+   --  Routine to expand concatenation a sequence of two or more operands (in\n+   --  the list Operands) and replace node Cnode with the result of the\n+   --  concatenation. The operands can be of type String or Character.\n \n    procedure Fixup_Universal_Fixed_Operation (N : Node_Id);\n    --  N is a N_Op_Divide or N_Op_Multiply node whose result is universal\n@@ -2761,74 +2760,440 @@ package body Exp_Ch4 is\n    -------------------------------\n \n    procedure Expand_Concatenate_String (Cnode : Node_Id; Opnds : List_Id) is\n-      Loc   : constant Source_Ptr := Sloc (Cnode);\n-      Opnd1 : constant Node_Id    := First (Opnds);\n-      Opnd2 : constant Node_Id    := Next (Opnd1);\n-      Typ1  : constant Entity_Id  := Base_Type (Etype (Opnd1));\n-      Typ2  : constant Entity_Id  := Base_Type (Etype (Opnd2));\n+      Loc : constant Source_Ptr := Sloc (Cnode);\n \n-      R : RE_Id;\n-      --  RE_Id value for function to be called\n+      N : constant Nat := List_Length (Opnds);\n+      --  Number of concatenation operands including nulls\n+\n+      NN : Nat := 0;\n+      --  Number of operands excluding any known to be null\n+\n+      --  Arrays describing the operands, only the first NN entries of each\n+      --  array are set (NN < N when we exclude known null operands).\n+\n+      Is_Fixed_Length : array (1 .. N) of Boolean;\n+      --  True if length of corresponding operand known at compile time\n+\n+      Operands : array (1 .. N) of Node_Id;\n+      --  Set to the corresponding entry in the Opnds list\n+\n+      Fixed_Length : array (1 .. N) of Uint;\n+      --  Set to length of operand. Entries in this array are set only if\n+      --  the corresponding entry in Is_Fixed_Length is True. Note that the\n+      --  values in this array are always greater than zero, since we exclude\n+      --  any\n+\n+      Fixed_Low_Bound : array (1 .. N) of Uint;\n+      --  Set to lower bound of operand. Entries in this array are set only\n+      --  if the corresponding entry in Is_Fixed_Length are True.\n+\n+      Var_Length : array (1 .. N) of Entity_Id;\n+      --  Set to an entity of type Natural that contains the length of an\n+      --  operand whose length is not known at compile time. Entries in this\n+      --  array are set only if the corresponding entry in Is_Fixed_Length\n+      --  is False.\n+\n+      Aggr_Length : array (0 .. N) of Node_Id;\n+      --  The J'th entry in an expression node that represents the total\n+      --  length of operands 1 through J. It is either an integer literal\n+      --  node, or a reference to a constant entity with the right value,\n+      --  so it is fine to just do a Copy_Node to get an appropriate copy.\n+      --  The extra zero'th entry always is set to zero.\n+\n+      Low_Bound : Node_Id;\n+      --  An tree node representing the low bound of the result. This is either\n+      --  an integer literal node, or an identifier reference to a constant\n+      --  entity initialized to the appropriate value.\n+\n+      Result : Node_Id;\n+      --  Result of the concatenation\n+\n+      Opnd : Node_Id;\n+      Ent  : Entity_Id;\n+      Len  : Uint;\n+      J    : Nat;\n+      Clen : Node_Id;\n+      Set  : Boolean;\n \n    begin\n-      --  In all cases, we build a call to a routine giving the list of\n-      --  arguments as the parameter list to the routine.\n+      Aggr_Length (0) := Make_Integer_Literal (Loc, 0);\n \n-      case List_Length (Opnds) is\n-         when 2 =>\n-            if Typ1 = Standard_Character then\n-               if Typ2 = Standard_Character then\n-                  R := RE_Str_Concat_CC;\n+      --  Go through operands settinn up the above arrays\n \n-               else\n-                  pragma Assert (Typ2 = Standard_String);\n-                  R := RE_Str_Concat_CS;\n+      J := 1;\n+      while J <= N loop\n+         Opnd := Remove_Head (Opnds);\n+         Set_Parent (Opnd, Parent (Cnode));\n+         Set := False;\n+\n+         --  Character or Character literal case\n+\n+         if Base_Type (Etype (Opnd)) = Standard_Character then\n+            NN := NN + 1;\n+            Operands (NN) := Opnd;\n+            Is_Fixed_Length (NN) := True;\n+            Fixed_Length (NN) := Uint_1;\n+            Fixed_Low_Bound (NN) := Uint_1;\n+            Set := True;\n+\n+         --  String literal case\n+\n+         elsif Nkind (Opnd) = N_String_Literal then\n+            Len := UI_From_Int (String_Length (Strval (Opnd)));\n+\n+            if Len = 0 then\n+               goto Continue;\n+            end if;\n+\n+            NN := NN + 1;\n+            Operands (NN) := Opnd;\n+            Is_Fixed_Length (NN) := True;\n+            Fixed_Length (NN) := Len;\n+            Fixed_Low_Bound (NN) := Uint_1;\n+            Set := True;\n+\n+         --  All other cases\n+\n+         else\n+            --  Check constrained case with known bounds\n+\n+            if Is_Constrained (Etype (Opnd)) then\n+               declare\n+                  Opnd_Typ : constant Entity_Id := Etype (Opnd);\n+                  Index    : constant Node_Id   := First_Index (Opnd_Typ);\n+                  Indx_Typ : constant Entity_Id := Etype (Index);\n+                  Lo       : constant Node_Id   := Type_Low_Bound  (Indx_Typ);\n+                  Hi       : constant Node_Id   := Type_High_Bound (Indx_Typ);\n+\n+               begin\n+                  --  Fixed length constrained string type with known at\n+                  --  compile time bounds is last case of fixed length\n+\n+                  if Compile_Time_Known_Value (Lo)\n+                       and then\n+                     Compile_Time_Known_Value (Hi)\n+                  then\n+                     declare\n+                        Loval : constant Uint := Expr_Value (Lo);\n+                        Hival : constant Uint := Expr_Value (Hi);\n+                        Len   : constant Uint :=\n+                                  UI_Max (Hival - Loval + 1, Uint_0);\n+\n+                     begin\n+                        --  Exclude the null length case where the lower bound\n+                        --  is other than 1 because annoyingly we need to keep\n+                        --  such an operand around in case it is the one that\n+                        --  supplies a lower bound to the result.\n+\n+                        if Loval = 1 or Len > 0 then\n+\n+                           --  Skip null case (we know that low bound is 1)\n+\n+                           if Len = 0 then\n+                              goto Continue;\n+                           end if;\n+\n+                           NN := NN + 1;\n+                           Operands (NN) := Opnd;\n+                           Is_Fixed_Length (NN) := True;\n+                           Fixed_Length (NN)    := Len;\n+                           Fixed_Low_Bound (NN) := Expr_Value (Lo);\n+                           Set := True;\n+                        end if;\n+                     end;\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  All cases where the length is not known at compile time, or the\n+            --  special case of an operand which is known to be null but has a\n+            --  lower bound other than 1. Capture length of operand in entity.\n+            --  separate entities\n+\n+            if not Set then\n+               NN := NN + 1;\n+               Operands (NN) := Opnd;\n+               Is_Fixed_Length (NN) := False;\n+\n+               Var_Length (NN) :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_Internal_Name ('L'));\n+\n+               Insert_Action (Cnode,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Var_Length (NN),\n+                   Constant_Present    => True,\n+\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Natural, Loc),\n+\n+                   Expression          =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         =>\n+                         Duplicate_Subexpr (Opnd, Name_Req => True),\n+                       Attribute_Name => Name_Length)),\n+\n+                 Suppress => All_Checks);\n+            end if;\n+         end if;\n+\n+         --  Set next entry in aggregate length array\n+\n+         --  For first entry, make either integer literal for fixed length\n+         --  or a reference to the saved length for variable length\n+\n+         if NN = 1 then\n+            if Is_Fixed_Length (1) then\n+               Aggr_Length (1) :=\n+                 Make_Integer_Literal (Loc,\n+                   Intval => Fixed_Length (1));\n+            else\n+               Aggr_Length (1) :=\n+                 New_Reference_To (Var_Length (1), Loc);\n+            end if;\n+\n+         --  If entry is fixed length and only fixed lengths so far, make\n+         --  appropriate new integer literal adding new length.\n+\n+         elsif Is_Fixed_Length (NN)\n+           and then Nkind (Aggr_Length (NN - 1)) = N_Integer_Literal\n+         then\n+            Aggr_Length (NN) :=\n+              Make_Integer_Literal (Loc,\n+                Intval => Fixed_Length (NN) + Intval (Aggr_Length (NN - 1)));\n+\n+            --  All other cases, construct an addition node for the length and\n+            --  create an entity initialized to this length.\n+\n+         else\n+            Ent :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('L'));\n+\n+            if Is_Fixed_Length (NN) then\n+               Clen := Make_Integer_Literal (Loc, Fixed_Length (NN));\n+            else\n+               Clen := New_Reference_To (Var_Length (NN), Loc);\n+            end if;\n+\n+            Insert_Action (Cnode,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Ent,\n+                Constant_Present    => True,\n+\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Standard_Natural, Loc),\n+\n+                Expression          =>\n+                  Make_Op_Add (Loc,\n+                    Left_Opnd  => New_Copy (Aggr_Length (NN - 1)),\n+                    Right_Opnd => Clen)),\n+\n+              Suppress => All_Checks);\n+\n+            Aggr_Length (NN) :=\n+              Make_Identifier (Loc,\n+                Chars => Chars (Ent));\n+         end if;\n+\n+      <<Continue>>\n+         J := J + 1;\n+      end loop;\n+\n+      --  If we have only null operands, return a null string literal. Note\n+      --  that this means the lower bound is 1, but we retained any known null\n+      --  operands whose lower bound was not 1, so this is legitimate.\n+\n+      if NN = 0 then\n+         Start_String;\n+         Result :=\n+           Make_String_Literal (Loc,\n+             Strval => End_String);\n+         goto Done;\n+      end if;\n+\n+      --  If we have only one non-null operand, return it and we are done.\n+      --  There is one case in which this cannot be done, and that is when\n+      --  the sole operand is of a character type, in which case it must be\n+      --  converted to a string, and the easiest way of doing that is to go\n+      --  through the normal general circuit.\n+\n+      if NN = 1\n+        and then Base_Type (Etype (Operands (1))) /= Standard_Character\n+      then\n+         Result := Operands (1);\n+         goto Done;\n+      end if;\n+\n+      --  Cases where we have a real concatenation\n+\n+      --  Next step is to find the low bound for the result string that we\n+      --  will allocate. Annoyingly this is not simply the low bound of the\n+      --  first argument, because of the darned null string special exception.\n+\n+      --  If the first operand in the list has known length we know that\n+      --  the lower bound of the result is the lower bound of this operand.\n+\n+      if Is_Fixed_Length (1) then\n+         Low_Bound :=\n+           Make_Integer_Literal (Loc,\n+             Intval => Fixed_Low_Bound (1));\n+\n+      --  OK, we don't know the lower bound, we have to build a horrible\n+      --  expression actions node of the form\n+\n+      --     if Cond1'Length /= 0 then\n+      --        Opnd1'First\n+      --     else\n+      --        if Opnd2'Length /= 0 then\n+      --          Opnd2'First\n+      --        else\n+      --           ...\n+\n+      --  The nesting ends either when we hit an operand whose length is known\n+      --  at compile time, or on reaching the last operand, whose low bound we\n+      --  take unconditionally whether or not it is null. It's easiest to do\n+      --  this with a recursive procedure:\n+\n+      else\n+         declare\n+            function Get_Known_Bound (J : Nat) return Node_Id;\n+            --  Returns the lower bound determined by operands J .. NN\n+\n+            ---------------------\n+            -- Get_Known_Bound --\n+            ---------------------\n+\n+            function Get_Known_Bound (J : Nat) return Node_Id is\n+               Lo : Node_Id;\n+\n+            begin\n+               if Is_Fixed_Length (J) then\n+                  return\n+                    Make_Integer_Literal (Loc,\n+                      Intval => Fixed_Low_Bound (J));\n                end if;\n \n-            elsif Typ1 = Standard_String then\n-               if Typ2 = Standard_Character then\n-                  R := RE_Str_Concat_SC;\n+               Lo :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix =>\n+                     Duplicate_Subexpr (Operands (J), Name_Req => True),\n+                   Attribute_Name => Name_First);\n+\n+               if J = NN then\n+                  return Lo;\n \n                else\n-                  pragma Assert (Typ2 = Standard_String);\n-                  R := RE_Str_Concat;\n+                  return\n+                    Make_Conditional_Expression (Loc,\n+                      Expressions => New_List (\n+\n+                        Make_Op_Ne (Loc,\n+                          Left_Opnd  => New_Reference_To (Var_Length (J), Loc),\n+                          Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+\n+                        Lo,\n+                        Get_Known_Bound (J + 1)));\n                end if;\n+            end Get_Known_Bound;\n \n-            --  If we have anything other than Standard_Character or\n-            --  Standard_String, then we must have had a serious error\n-            --  earlier, so we just abandon the attempt at expansion.\n+         begin\n+            Ent :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('L'));\n \n-            else\n-               pragma Assert (Serious_Errors_Detected > 0);\n-               return;\n-            end if;\n+            Insert_Action (Cnode,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Ent,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Standard_Natural, Loc),\n+                Expression          => Get_Known_Bound (1)),\n+              Suppress => All_Checks);\n+\n+            Low_Bound := New_Reference_To (Ent, Loc);\n+         end;\n+      end if;\n \n-         when 3 =>\n-            R := RE_Str_Concat_3;\n+      --  Now we build the result, which is a reference to the string entity\n+      --  we will construct with appropriate bounds.\n \n-         when 4 =>\n-            R := RE_Str_Concat_4;\n+      Ent :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_Internal_Name ('S'));\n \n-         when 5 =>\n-            R := RE_Str_Concat_5;\n+      Insert_Action (Cnode,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Ent,\n \n-         when others =>\n-            R := RE_Null;\n-            raise Program_Error;\n-      end case;\n+          Object_Definition   =>\n+            Make_Subtype_Indication (Loc,\n+              Subtype_Mark => New_Occurrence_Of (Standard_String, Loc),\n+              Constraint   =>\n+                Make_Index_Or_Discriminant_Constraint (Loc,\n+                  Constraints => New_List (\n+                    Make_Range (Loc,\n+                      Low_Bound => New_Copy (Low_Bound),\n+                      High_Bound =>\n+                        Make_Op_Add (Loc,\n+                          Left_Opnd  => New_Copy (Low_Bound),\n+                          Right_Opnd =>\n+                            Make_Op_Subtract (Loc,\n+                              Left_Opnd  => New_Copy (Aggr_Length (NN)),\n+                              Right_Opnd =>\n+                                Make_Integer_Literal (Loc, 1)))))))),\n+\n+        Suppress => All_Checks);\n+\n+      --  Now we will generate the assignments to do the actual concatenation\n+\n+      for J in 1 .. NN loop\n+         declare\n+            Lo : constant Node_Id :=\n+                   Make_Op_Add (Loc,\n+                     Left_Opnd  => New_Copy (Low_Bound),\n+                     Right_Opnd => Aggr_Length (J - 1));\n+\n+            Hi : constant Node_Id :=\n+                   Make_Op_Add (Loc,\n+                     Left_Opnd  => New_Copy (Low_Bound),\n+                     Right_Opnd =>\n+                       Make_Op_Subtract (Loc,\n+                         Left_Opnd  => Aggr_Length (J),\n+                         Right_Opnd => Make_Integer_Literal (Loc, 1)));\n \n-      --  Now generate the appropriate call\n+         begin\n+            if Base_Type (Etype (Operands (J))) = Standard_Character then\n+               Insert_Action (Cnode,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       =>\n+                     Make_Indexed_Component (Loc,\n+                       Prefix      => New_Occurrence_Of (Ent, Loc),\n+                       Expressions => New_List (Lo)),\n+                   Expression => Operands (J)),\n+                 Suppress => All_Checks);\n \n-      Rewrite (Cnode,\n-        Make_Function_Call (Sloc (Cnode),\n-          Name => New_Occurrence_Of (RTE (R), Loc),\n-          Parameter_Associations => Opnds));\n+            else\n+               Insert_Action (Cnode,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       =>\n+                     Make_Slice (Loc,\n+                       Prefix         => New_Occurrence_Of (Ent, Loc),\n+                       Discrete_Range =>\n+                         Make_Range (Loc,\n+                           Low_Bound  => Lo,\n+                           High_Bound => Hi)),\n+                   Expression => Operands (J)),\n+                 Suppress => All_Checks);\n+            end if;\n+         end;\n+      end loop;\n \n-      Analyze_And_Resolve (Cnode, Standard_String);\n+      Result := New_Reference_To (Ent, Loc);\n \n-   exception\n-      when RE_Not_Available =>\n-         return;\n+   <<Done>>\n+      Rewrite (Cnode, Result);\n+      Analyze_And_Resolve (Cnode, Standard_String);\n    end Expand_Concatenate_String;\n \n    ------------------------\n@@ -4540,21 +4905,6 @@ package body Exp_Ch4 is\n    -- Expand_N_Op_Concat --\n    ------------------------\n \n-   Max_Available_String_Operands : Int := -1;\n-   --  This is initialized the first time this routine is called. It records\n-   --  a value of 0,2,3,4,5 depending on what Str_Concat_n procedures are\n-   --  available in the run-time:\n-   --\n-   --    0  None available\n-   --    2  RE_Str_Concat available, RE_Str_Concat_3 not available\n-   --    3  RE_Str_Concat/Concat_3 available, RE_Str_Concat_4 not available\n-   --    4  RE_Str_Concat/Concat_3/4 available, RE_Str_Concat_5 not available\n-   --    5  All routines including RE_Str_Concat_5 available\n-\n-   Char_Concat_Available : Boolean;\n-   --  Records if the routines RE_Str_Concat_CC/CS/SC are available. True if\n-   --  all three are available, False if any one of these is unavailable.\n-\n    procedure Expand_N_Op_Concat (N : Node_Id) is\n       Opnds : List_Id;\n       --  List of operands to be concatenated\n@@ -4573,37 +4923,6 @@ package body Exp_Ch4 is\n       --  Component type of concatenation represented by Cnode\n \n    begin\n-      --  Initialize global variables showing run-time status\n-\n-      if Max_Available_String_Operands < 1 then\n-\n-         --  See what routines are available and set max operand count\n-         --  according to the highest count available in the run-time.\n-\n-         if not RTE_Available (RE_Str_Concat) then\n-            Max_Available_String_Operands := 0;\n-\n-         elsif not RTE_Available (RE_Str_Concat_3) then\n-            Max_Available_String_Operands := 2;\n-\n-         elsif not RTE_Available (RE_Str_Concat_4) then\n-            Max_Available_String_Operands := 3;\n-\n-         elsif not RTE_Available (RE_Str_Concat_5) then\n-            Max_Available_String_Operands := 4;\n-\n-         else\n-            Max_Available_String_Operands := 5;\n-         end if;\n-\n-         Char_Concat_Available :=\n-           RTE_Available (RE_Str_Concat_CC)\n-             and then\n-           RTE_Available (RE_Str_Concat_CS)\n-             and then\n-           RTE_Available (RE_Str_Concat_SC);\n-      end if;\n-\n       --  Ensure validity of both operands\n \n       Binary_Op_Validity_Checks (N);\n@@ -4632,47 +4951,32 @@ package body Exp_Ch4 is\n       --  nodes above, so now we process bottom up, doing the operations. We\n       --  gather a string that is as long as possible up to five operands\n \n-      --  The outer loop runs more than once if there are more than five\n-      --  concatenations of type Standard.String, the most we handle for\n-      --  this case, or if more than one concatenation type is involved.\n+      --  The outer loop runs more than once if more than one concatenation\n+      --  type is involved.\n \n       Outer : loop\n          Opnds := New_List (Left_Opnd (Cnode), Right_Opnd (Cnode));\n          Set_Parent (Opnds, N);\n \n-         --  The inner loop gathers concatenation operands. We gather any\n-         --  number of these in the non-string case, or if no concatenation\n-         --  routines are available for string (since in that case we will\n-         --  treat string like any other non-string case). Otherwise we only\n-         --  gather as many operands as can be handled by the available\n-         --  procedures in the run-time library (normally 5, but may be\n-         --  less for the configurable run-time case).\n+         --  The inner loop gathers concatenation operands\n \n          Inner : while Cnode /= N\n-                   and then (Base_Type (Etype (Cnode)) /= Standard_String\n-                               or else\n-                             Max_Available_String_Operands = 0\n-                               or else\n-                             List_Length (Opnds) <\n-                                               Max_Available_String_Operands)\n                    and then Base_Type (Etype (Cnode)) =\n                             Base_Type (Etype (Parent (Cnode)))\n          loop\n             Cnode := Parent (Cnode);\n             Append (Right_Opnd (Cnode), Opnds);\n          end loop Inner;\n \n-         --  Here we process the collected operands. First we convert singleton\n-         --  operands to singleton aggregates. This is skipped however for the\n-         --  case of two operands of type String since we have special routines\n-         --  for these cases.\n+         --  Here we process the collected operands. First convert singleton\n+         --  operands to singleton aggregates. This is skipped however for\n+         --  the case of operands of type Character/String since the string\n+         --  concatenation routine can handle these special cases.\n \n          Atyp := Base_Type (Etype (Cnode));\n          Ctyp := Base_Type (Component_Type (Etype (Cnode)));\n \n-         if (List_Length (Opnds) > 2 or else Atyp /= Standard_String)\n-           or else not Char_Concat_Available\n-         then\n+         if Atyp /= Standard_String then\n             Opnd := First (Opnds);\n             loop\n                if Base_Type (Etype (Opnd)) = Ctyp then\n@@ -4689,9 +4993,7 @@ package body Exp_Ch4 is\n \n          --  Now call appropriate continuation routine\n \n-         if Atyp = Standard_String\n-           and then Max_Available_String_Operands > 0\n-         then\n+         if Atyp = Standard_String then\n             Expand_Concatenate_String (Cnode, Opnds);\n          else\n             Expand_Concatenate_Other (Cnode, Opnds);"}, {"sha": "d14fae8f44c5ebba5e819b2de9a2e007f5f8f1c8", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -1830,6 +1830,7 @@ package body GNAT.Sockets is\n    procedure Set (Item : in out Socket_Set_Type; Socket : Socket_Type) is\n    begin\n       if Item.Last = No_Socket then\n+\n          --  Uninitialized socket set, make sure it is properly zeroed out\n \n          Reset_Socket_Set (Item.Set'Access);\n@@ -1838,6 +1839,7 @@ package body GNAT.Sockets is\n       elsif Item.Last < Socket then\n          Item.Last := Socket;\n       end if;\n+\n       Insert_Socket_In_Set (Item.Set'Access, C.int (Socket));\n    end Set;\n "}, {"sha": "a85a2572d8f0fac27d1aada0f9be45566baface8", "filename": "gcc/ada/g-socthi-mingw.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fg-socthi-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fg-socthi-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-mingw.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -300,16 +300,16 @@ package body GNAT.Sockets.Thin is\n       Last : aliased C.int;\n \n    begin\n-      --  Asynchronous connection failures are notified in the\n-      --  exception fd set instead of the write fd set. To ensure\n-      --  POSIX compatibility, copy write fd set into exception fd\n-      --  set. Once select() returns, check any socket present in the\n-      --  exception fd set and peek at incoming out-of-band data. If\n-      --  the test is not successful, and the socket is present in\n-      --  the initial write fd set, then move the socket from the\n+      --  Asynchronous connection failures are notified in the exception fd set\n+      --  instead of the write fd set. To ensure POSIX compatibility, copy\n+      --  write fd set into exception fd set. Once select() returns, check any\n+      --  socket present in the exception fd set and peek at incoming\n+      --  out-of-band data. If the test is not successful, and the socket is\n+      --  present in the initial write fd set, then move the socket from the\n       --  exception fd set to the write fd set.\n \n       if Writefds /= No_Fd_Set_Access then\n+\n          --  Add any socket present in write fd set into exception fd set\n \n          declare"}, {"sha": "cb0bc09b86f5b9308f8640fb71761a1b4398c5b7", "filename": "gcc/ada/g-sothco.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fg-sothco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fg-sothco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sothco.ads?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -122,7 +122,7 @@ package GNAT.Sockets.Thin_Common is\n       Sa_Family : Sockaddr_Length_And_Family;\n       --  Address family (and address length on some platforms)\n \n-      Sa_Data   : C.char_array (1 .. 14) := (others => C.nul);\n+      Sa_Data : C.char_array (1 .. 14) := (others => C.nul);\n       --  Family-specific data\n       --  Note that some platforms require that all unused (reserved) bytes\n       --  in addresses be initialized to 0 (e.g. VxWorks).\n@@ -169,14 +169,15 @@ package GNAT.Sockets.Thin_Common is\n       Sin_Family : Sockaddr_Length_And_Family;\n       --  Address family (and address length on some platforms)\n \n-      Sin_Port   : C.unsigned_short;\n+      Sin_Port : C.unsigned_short;\n       --  Port in network byte order\n \n-      Sin_Addr   : In_Addr;\n+      Sin_Addr : In_Addr;\n       --  IPv4 address\n \n-      Sin_Zero   : C.char_array (1 .. 8) := (others => C.nul);\n+      Sin_Zero : C.char_array (1 .. 8) := (others => C.nul);\n       --  Padding\n+      --\n       --  Note that some platforms require that all unused (reserved) bytes\n       --  in addresses be initialized to 0 (e.g. VxWorks).\n    end record;\n@@ -272,8 +273,8 @@ package GNAT.Sockets.Thin_Common is\n    --  value if it is, zero if it is not.\n \n    procedure Last_Socket_In_Set\n-     (Set    : access Fd_Set;\n-      Last   : Int_Access);\n+     (Set  : access Fd_Set;\n+      Last : Int_Access);\n    --  Find the largest socket in the socket set. This is needed for select().\n    --  When Last_Socket_In_Set is called, parameter Last is a maximum value of\n    --  the largest socket. This hint is used to avoid scanning very large"}, {"sha": "da427cb5bcc977223746d0e4a9f08a0b4a340636", "filename": "gcc/ada/s-sopco3.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-sopco3.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -31,6 +31,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "6bff28f3940520386c99f50f9af1b075d5244f29", "filename": "gcc/ada/s-sopco3.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-sopco3.ads?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,10 @@\n \n --  This package contains the function for concatenating three strings\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "3188e75c6f3d6b8e6047e13003f9ad35b8c419cf", "filename": "gcc/ada/s-sopco4.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-sopco4.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -31,6 +31,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "b08bcadea85077218315e67337070706d057eee0", "filename": "gcc/ada/s-sopco4.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-sopco4.ads?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,10 @@\n \n --  This package contains the function for concatenating four strings\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "8ca4cda844376c11ff3a1bc519e8dcfe7a0218cb", "filename": "gcc/ada/s-sopco5.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-sopco5.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -31,6 +31,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "19766311d3fca50a3a1df575278b771eae501eac", "filename": "gcc/ada/s-sopco5.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-sopco5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-sopco5.ads?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,10 @@\n \n --  This package contains the function for concatenating five strings\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "1c9b75f0f7eb36404fe1dbf517cefa011e9143ae", "filename": "gcc/ada/s-strops.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-strops.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-strops.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-strops.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -31,6 +31,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "ca8230d03b9f6a97c33000c73ad3a4819455a677", "filename": "gcc/ada/s-strops.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-strops.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fs-strops.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-strops.ads?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,6 +34,10 @@\n --  This package contains functions for runtime operations on strings\n --  (other than runtime comparison, found in s-strcom.ads).\n \n+--  NOTE: This package is obsolescent. It is no longer used by the compiler\n+--  which now generates concatenation inline. It is retained only because\n+--  it may be used during bootstrapping using old versions of the compiler.\n+\n pragma Warnings (Off);\n pragma Compiler_Unit;\n pragma Warnings (On);"}, {"sha": "bab1802ec3afeb62b1e66e0e94df9bc9aac12fc1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -5258,7 +5258,7 @@ package body Sem_Attr is\n                if Present (AS) and then Is_Constrained (AS) then\n                   P_Entity := AS;\n \n-               --  If we have an unconstrained type, cannot fold\n+               --  If we have an unconstrained type we cannot fold\n \n                else\n                   Check_Expressions;\n@@ -5517,6 +5517,9 @@ package body Sem_Attr is\n          --  an optimization, but it falls out essentially free, so why not.\n          --  Again we compute the variable Static for easy reference later\n          --  (note that no array attributes are static in Ada 83).\n+         --  we also need to set Static properly for subsequent legality checks\n+         --  which might otherwise accept non-static constants in contexts\n+         --  where they are not legal.\n \n          Static := Ada_Version >= Ada_95\n                      and then Statically_Denotes_Entity (P);\n@@ -5526,6 +5529,16 @@ package body Sem_Attr is\n \n          begin\n             N := First_Index (P_Type);\n+\n+            --  The expression is static if the array type is constrained\n+            --  by given bounds, and not by an initial expression. Constant\n+            --  strings are static in any case.\n+\n+            if Root_Type (P_Type) /= Standard_String then\n+               Static :=\n+                 Static and then not Is_Constr_Subt_For_U_Nominal (P_Type);\n+            end if;\n+\n             while Present (N) loop\n                Static := Static and then Is_Static_Subtype (Etype (N));\n "}, {"sha": "0bc6dcee3df4660d604eba55202e08e23c63929b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df46b832b04ae500284492241a71854b434aec37/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=df46b832b04ae500284492241a71854b434aec37", "patch": "@@ -7154,20 +7154,26 @@ package body Sem_Ch6 is\n                --  odd case where both are derived operations declared at the\n                --  same point, both operations should be declared, and in that\n                --  case we bypass the following test and proceed to the next\n-               --  part (this can only occur for certain obscure cases\n-               --  involving homographs in instances and can't occur for\n-               --  dispatching operations ???). Note that the following\n-               --  condition is less than clear. For example, it's not at all\n-               --  clear why there's a test for E_Entry here. ???\n+               --  part. This can only occur for certain obscure cases in\n+               --  instances, when an operation on a type derived from a formal\n+               --  private type does not override a homograph inherited from\n+               --  the actual. In subsequent derivations of such a type, the\n+               --  DT positions of these operations remain distinct, if they\n+               --  have been set.\n \n                if Present (Alias (S))\n                  and then (No (Alias (E))\n+                            or else Is_Abstract_Subprogram (S)\n                             or else Comes_From_Source (E)\n-                            or else Is_Dispatching_Operation (E))\n-                 and then\n-                   (Ekind (E) = E_Entry\n-                     or else Ekind (E) /= E_Enumeration_Literal)\n+                            or else\n+                              (Is_Dispatching_Operation (E)\n+                                and then Present (DTC_Entity (Alias (S)))\n+                                and then Present (DTC_Entity (Alias (E)))\n+                                and then DT_Position (Alias (S))\n+                                   = DT_Position (Alias (E))))\n+                 and then Ekind (E) /= E_Enumeration_Literal\n                then\n+\n                   --  When an derived operation is overloaded it may be due to\n                   --  the fact that the full view of a private extension\n                   --  re-inherits. It has to be dealt with."}]}