{"sha": "fad08d127f63c0deff683d38034863abf5201bb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkMDhkMTI3ZjYzYzBkZWZmNjgzZDM4MDM0ODYzYWJmNTIwMWJiMA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-04-20T15:41:45Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-04-20T15:41:45Z"}, "message": "re PR tree-optimization/56625 (After if-conversion vectorizer doesn't recognize similar loads)\n\n\tPR tree-optimization/56625\n\tPR tree-optimization/69489\n\t* tree-data-ref.h (DR_INNERMOST): New macro.\n\t* tree-if-conv.c (innermost_loop_behavior_hash): New class for\n\thashing struct innermost_loop_behavior.\n\t(ref_DR_map): Remove.\n\t(innermost_DR_map): New map.\n\t(baseref_DR_map): Revise comment.\n\t(hash_memrefs_baserefs_and_store_DRs_read_written_info): Store DR\n\tto innermost_DR_map accroding to its innermost loop behavior.\n\t(ifcvt_memrefs_wont_trap): Get DR from innermost_DR_map according\n\tto its innermost loop behavior.\n\t(if_convertible_loop_p_1): Remove intialization for ref_DR_map.\n\tAdd initialization for innermost_DR_map.  Record memory reference\n\tin DR_BASE_ADDRESS if the reference is compound one or it doesn't\n\thave innermost loop behavior.\n\t(if_convertible_loop_p): Remove release for ref_DR_map.  Release\n\tinnermost_DR_map.\n\n\tgcc/testsuite/ChangeLog\n\tPR tree-optimization/56625\n\tPR tree-optimization/69489\n\t* gcc.dg/vect/pr56625.c: New test.\n\t* gcc.dg/tree-ssa/ifc-pr69489-1.c: New test.\n\nFrom-SVN: r235289", "tree": {"sha": "5fb76629343852155b74e65799acbfe8a3bd9d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fb76629343852155b74e65799acbfe8a3bd9d03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fad08d127f63c0deff683d38034863abf5201bb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad08d127f63c0deff683d38034863abf5201bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad08d127f63c0deff683d38034863abf5201bb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad08d127f63c0deff683d38034863abf5201bb0/comments", "author": null, "committer": null, "parents": [{"sha": "323af7cfa7b64967d997388be9e564de57e46e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/323af7cfa7b64967d997388be9e564de57e46e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/323af7cfa7b64967d997388be9e564de57e46e2b"}], "stats": {"total": 171, "additions": 150, "deletions": 21}, "files": [{"sha": "1f3d66b24de98cb7265425e9573c3f33d4fd37d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fad08d127f63c0deff683d38034863abf5201bb0", "patch": "@@ -1,3 +1,24 @@\n+2016-04-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/56625\n+\tPR tree-optimization/69489\n+\t* tree-data-ref.h (DR_INNERMOST): New macro.\n+\t* tree-if-conv.c (innermost_loop_behavior_hash): New class for\n+\thashing struct innermost_loop_behavior.\n+\t(ref_DR_map): Remove.\n+\t(innermost_DR_map): New map.\n+\t(baseref_DR_map): Revise comment.\n+\t(hash_memrefs_baserefs_and_store_DRs_read_written_info): Store DR\n+\tto innermost_DR_map accroding to its innermost loop behavior.\n+\t(ifcvt_memrefs_wont_trap): Get DR from innermost_DR_map according\n+\tto its innermost loop behavior.\n+\t(if_convertible_loop_p_1): Remove intialization for ref_DR_map.\n+\tAdd initialization for innermost_DR_map.  Record memory reference\n+\tin DR_BASE_ADDRESS if the reference is compound one or it doesn't\n+\thave innermost loop behavior.\n+\t(if_convertible_loop_p): Remove release for ref_DR_map.  Release\n+\tinnermost_DR_map.\n+\n 2016-04-20  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*lea<mode>_general_1): Rename from"}, {"sha": "50d37d21ff060fe5a6f73bb1bc4e25e1807f69d6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fad08d127f63c0deff683d38034863abf5201bb0", "patch": "@@ -1,3 +1,10 @@\n+2016-04-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/56625\n+\tPR tree-optimization/69489\n+\t* gcc.dg/vect/pr56625.c: New test.\n+\t* gcc.dg/tree-ssa/ifc-pr69489-1.c: New test.\n+\n 2016-04-20  Andrew Pinski  <apinski@cavium.com>\n \n \tPR target/64971"}, {"sha": "4131afcbdff099b455f865e13650fbae1d5700dc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ifc-pr69489-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fifc-pr69489-1.c?ref=fad08d127f63c0deff683d38034863abf5201bb0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fdump-tree-ifcvt-stats\" { target *-*-* } } */\n+\n+void foo (int a[], int b[])\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      if (a[i] == 0)\n+\ta[i] = b[i]*4;\n+      else\n+\ta[i] = b[i]*3;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Applying if-conversion\" 1 \"ifcvt\" } } */"}, {"sha": "b903be30adc0fbe35e58ed75c781c37fb4ef0830", "filename": "gcc/testsuite/gcc.dg/vect/pr56625.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr56625.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr56625.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr56625.c?ref=fad08d127f63c0deff683d38034863abf5201bb0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+void foo (int a[], int b[])\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    {\n+      if (a[i] == 0)\n+\ta[i] = b[i]*4;\n+      else\n+\ta[i] = b[i]*3;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "856dd58f3ad20be0c8d8e4f7cefd09d3c83b3450", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=fad08d127f63c0deff683d38034863abf5201bb0", "patch": "@@ -144,6 +144,7 @@ struct data_reference\n #define DR_STEP(DR)                (DR)->innermost.step\n #define DR_PTR_INFO(DR)            (DR)->alias.ptr_info\n #define DR_ALIGNED_TO(DR)          (DR)->innermost.aligned_to\n+#define DR_INNERMOST(DR)           (DR)->innermost\n \n typedef struct data_reference *data_reference_p;\n "}, {"sha": "691811322f71e81c842bbfd63255e7f3f86bf072", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 89, "deletions": 21, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad08d127f63c0deff683d38034863abf5201bb0/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=fad08d127f63c0deff683d38034863abf5201bb0", "patch": "@@ -114,16 +114,68 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"params.h\"\n \n+/* Hash for struct innermost_loop_behavior.  It depends on the user to\n+   free the memory.  */\n+\n+struct innermost_loop_behavior_hash : nofree_ptr_hash <innermost_loop_behavior>\n+{\n+  static inline hashval_t hash (const value_type &);\n+  static inline bool equal (const value_type &,\n+\t\t\t    const compare_type &);\n+};\n+\n+inline hashval_t\n+innermost_loop_behavior_hash::hash (const value_type &e)\n+{\n+  hashval_t hash;\n+\n+  hash = iterative_hash_expr (e->base_address, 0);\n+  hash = iterative_hash_expr (e->offset, hash);\n+  hash = iterative_hash_expr (e->init, hash);\n+  return iterative_hash_expr (e->step, hash);\n+}\n+\n+inline bool\n+innermost_loop_behavior_hash::equal (const value_type &e1,\n+\t\t\t\t     const compare_type &e2)\n+{\n+  if ((e1->base_address && !e2->base_address)\n+      || (!e1->base_address && e2->base_address)\n+      || (!e1->offset && e2->offset)\n+      || (e1->offset && !e2->offset)\n+      || (!e1->init && e2->init)\n+      || (e1->init && !e2->init)\n+      || (!e1->step && e2->step)\n+      || (e1->step && !e2->step))\n+    return false;\n+\n+  if (e1->base_address && e2->base_address\n+      && !operand_equal_p (e1->base_address, e2->base_address, 0))\n+    return false;\n+  if (e1->offset && e2->offset\n+      && !operand_equal_p (e1->offset, e2->offset, 0))\n+    return false;\n+  if (e1->init && e2->init\n+      && !operand_equal_p (e1->init, e2->init, 0))\n+    return false;\n+  if (e1->step && e2->step\n+      && !operand_equal_p (e1->step, e2->step, 0))\n+    return false;\n+\n+  return true;\n+}\n+\n /* List of basic blocks in if-conversion-suitable order.  */\n static basic_block *ifc_bbs;\n \n /* Apply more aggressive (extended) if-conversion if true.  */\n static bool aggressive_if_conv;\n \n-/* Hash table to store references, DR pairs.  */\n-static hash_map<tree_operand_hash, data_reference_p> *ref_DR_map;\n+/* Hash table to store <DR's innermost loop behavior, DR> pairs.  */\n+static hash_map<innermost_loop_behavior_hash,\n+\t\tdata_reference_p> *innermost_DR_map;\n \n-/* Hash table to store base reference, DR pairs.  */\n+/* Hash table to store <base reference, DR> pairs.  */\n static hash_map<tree_operand_hash, data_reference_p> *baseref_DR_map;\n \n /* Structure used to predicate basic blocks.  This is attached to the\n@@ -623,17 +675,12 @@ hash_memrefs_baserefs_and_store_DRs_read_written_info (data_reference_p a)\n {\n \n   data_reference_p *master_dr, *base_master_dr;\n-  tree ref = DR_REF (a);\n   tree base_ref = DR_BASE_OBJECT (a);\n+  innermost_loop_behavior *innermost = &DR_INNERMOST (a);\n   tree ca = bb_predicate (gimple_bb (DR_STMT (a)));\n   bool exist1, exist2;\n \n-  while (TREE_CODE (ref) == COMPONENT_REF\n-\t || TREE_CODE (ref) == IMAGPART_EXPR\n-\t || TREE_CODE (ref) == REALPART_EXPR)\n-    ref = TREE_OPERAND (ref, 0);\n-\n-  master_dr = &ref_DR_map->get_or_insert (ref, &exist1);\n+  master_dr = &innermost_DR_map->get_or_insert (innermost, &exist1);\n   if (!exist1)\n     *master_dr = a;\n \n@@ -695,21 +742,18 @@ ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> drs)\n   data_reference_p *master_dr, *base_master_dr;\n   data_reference_p a = drs[gimple_uid (stmt) - 1];\n \n-  tree ref_base_a = DR_REF (a);\n   tree base = DR_BASE_OBJECT (a);\n+  innermost_loop_behavior *innermost = &DR_INNERMOST (a);\n \n   gcc_assert (DR_STMT (a) == stmt);\n+  gcc_assert (DR_BASE_ADDRESS (a) || DR_OFFSET (a)\n+              || DR_INIT (a) || DR_STEP (a));\n \n-  while (TREE_CODE (ref_base_a) == COMPONENT_REF\n-\t || TREE_CODE (ref_base_a) == IMAGPART_EXPR\n-\t || TREE_CODE (ref_base_a) == REALPART_EXPR)\n-    ref_base_a = TREE_OPERAND (ref_base_a, 0);\n+  master_dr = innermost_DR_map->get (innermost);\n+  gcc_assert (master_dr != NULL);\n \n-  master_dr = ref_DR_map->get (ref_base_a);\n   base_master_dr = baseref_DR_map->get (base);\n \n-  gcc_assert (master_dr != NULL);\n-\n   /* If a is unconditionally written to it doesn't trap.  */\n   if (DR_W_UNCONDITIONALLY (*master_dr))\n     return true;\n@@ -1238,13 +1282,16 @@ if_convertible_loop_p_1 (struct loop *loop,\n \n   data_reference_p dr;\n \n-  ref_DR_map = new hash_map<tree_operand_hash, data_reference_p>;\n+  innermost_DR_map\n+\t  = new hash_map<innermost_loop_behavior_hash, data_reference_p>;\n   baseref_DR_map = new hash_map<tree_operand_hash, data_reference_p>;\n \n   predicate_bbs (loop);\n \n   for (i = 0; refs->iterate (i, &dr); i++)\n     {\n+      tree ref = DR_REF (dr);\n+\n       dr->aux = XNEW (struct ifc_dr);\n       DR_BASE_W_UNCONDITIONALLY (dr) = false;\n       DR_RW_UNCONDITIONALLY (dr) = false;\n@@ -1254,6 +1301,27 @@ if_convertible_loop_p_1 (struct loop *loop,\n       IFC_DR (dr)->base_w_predicate = boolean_false_node;\n       if (gimple_uid (DR_STMT (dr)) == 0)\n \tgimple_set_uid (DR_STMT (dr), i + 1);\n+\n+      /* If DR doesn't have innermost loop behavior or it's a compound\n+         memory reference, we synthesize its innermost loop behavior\n+         for hashing.  */\n+      if (TREE_CODE (ref) == COMPONENT_REF\n+          || TREE_CODE (ref) == IMAGPART_EXPR\n+          || TREE_CODE (ref) == REALPART_EXPR\n+          || !(DR_BASE_ADDRESS (dr) || DR_OFFSET (dr)\n+\t       || DR_INIT (dr) || DR_STEP (dr)))\n+        {\n+          while (TREE_CODE (ref) == COMPONENT_REF\n+\t         || TREE_CODE (ref) == IMAGPART_EXPR\n+\t         || TREE_CODE (ref) == REALPART_EXPR)\n+\t    ref = TREE_OPERAND (ref, 0);\n+\n+          DR_BASE_ADDRESS (dr) = ref;\n+          DR_OFFSET (dr) = NULL;\n+          DR_INIT (dr) = NULL;\n+          DR_STEP (dr) = NULL;\n+          DR_ALIGNED_TO (dr) = NULL;\n+        }\n       hash_memrefs_baserefs_and_store_DRs_read_written_info (dr);\n     }\n \n@@ -1348,8 +1416,8 @@ if_convertible_loop_p (struct loop *loop, bool *any_mask_load_store)\n \n   free_data_refs (refs);\n \n-  delete ref_DR_map;\n-  ref_DR_map = NULL;\n+  delete innermost_DR_map;\n+  innermost_DR_map = NULL;\n \n   delete baseref_DR_map;\n   baseref_DR_map = NULL;"}]}