{"sha": "dfdf6a9440609d8a58c6625b31d34509dd2df838", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkZjZhOTQ0MDYwOWQ4YTU4YzY2MjViMzFkMzQ1MDlkZDJkZjgzOA==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-06-29T22:30:53Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-06-29T22:30:53Z"}, "message": "[multiple changes]\n\n2004-06-29  Frank Ch. Eigler  <fche@redhat.com>\n\n\tSplay tree implementation fork.\n\t* splay-tree.c, splay-tree.h: Copied & modified from libiberty.\n\tUse hard-coded comparison function for uintptr_t.  Remove key/value\n\tdeallocation logic.  Cache last splayed key for consecutive lookups.\n\t* Makefile.am, Makefile.in: Use them, don't link to them.\n\t* mf-runtime.c (__mf_object_tree): Adapt to simpler splay_tree_new.\n\t(__mf_find_objects2): Flip successor/predecessor search sequence.\n\t* ansidecl.h, libiberty.h: Removed dummy files.\n\n\n2004-06-29  Nick Clifton  <nickc@redhat.com>\n\nFrom-SVN: r83879", "tree": {"sha": "5ea0f59fb7a56b8a63681ee82cdcb3dc5e366b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ea0f59fb7a56b8a63681ee82cdcb3dc5e366b6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfdf6a9440609d8a58c6625b31d34509dd2df838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfdf6a9440609d8a58c6625b31d34509dd2df838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfdf6a9440609d8a58c6625b31d34509dd2df838", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfdf6a9440609d8a58c6625b31d34509dd2df838/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef558756f2838de518a99a52caabe931e9af52b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef558756f2838de518a99a52caabe931e9af52b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef558756f2838de518a99a52caabe931e9af52b1"}], "stats": {"total": 700, "additions": 674, "deletions": 26}, "files": [{"sha": "20545cdf9ef3d66873735d8a6b9c828d9b33cb3a", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=dfdf6a9440609d8a58c6625b31d34509dd2df838", "patch": "@@ -1,3 +1,14 @@\n+2004-06-29  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\tSplay tree implementation fork.\n+\t* splay-tree.c, splay-tree.h: Copied & modified from libiberty.\n+\tUse hard-coded comparison function for uintptr_t.  Remove key/value\n+\tdeallocation logic.  Cache last splayed key for consecutive lookups.\n+\t* Makefile.am, Makefile.in: Use them, don't link to them.\n+\t* mf-runtime.c (__mf_object_tree): Adapt to simpler splay_tree_new.\n+\t(__mf_find_objects2): Flip successor/predecessor search sequence.\n+\t* ansidecl.h, libiberty.h: Removed dummy files.\n+\n 2004-06-29  Nick Clifton  <nickc@redhat.com>\n \n \t* configure.ac (AC_CHECK_HEADERS): Add dirent.h"}, {"sha": "457737141b5cb31d1f93bdc5342de15b3007b4a6", "filename": "libmudflap/Makefile.am", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.am?ref=dfdf6a9440609d8a58c6625b31d34509dd2df838", "patch": "@@ -20,14 +20,6 @@ endif\n toolexeclib_LTLIBRARIES = libmudflap.la $(libmudflapth)\n include_HEADERS = mf-runtime.h\n \n-# Copy this out of libiberty's source tree, so it can be built here via libtool\n-splay-tree.c:\n-\trm -f $@\n-\t$(LN_S) $(srcdir)/../libiberty/splay-tree.c $@\n-# Copy this so that top-level include/ does not have to be put into -I path\n-splay-tree.h:\n-\trm -f $@\n-\t$(LN_S) $(srcdir)/../include/splay-tree.h $@\n \n libmudflap_la_SOURCES = \\\n \tmf-runtime.c \\\n@@ -40,7 +32,6 @@ libmudflap_la_DEPENDENCIES = $(libmudflap_la_LIBADD)\n \n clean-local:\n \trm -f pth/*.o pth/*.lo\n-\trm -f splay-tree.c splay-tree.h\n \n pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h splay-tree.c splay-tree.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-runtime.c -o $@"}, {"sha": "75547e50f9ab14cabe973853314f99899035e6f6", "filename": "libmudflap/Makefile.in", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.in?ref=dfdf6a9440609d8a58c6625b31d34509dd2df838", "patch": "@@ -817,20 +817,10 @@ uninstall-info: uninstall-info-recursive\n \tuninstall uninstall-am uninstall-includeHEADERS \\\n \tuninstall-info-am uninstall-toolexeclibLTLIBRARIES\n \n-\n-# Copy this out of libiberty's source tree, so it can be built here via libtool\n-splay-tree.c:\n-\trm -f $@\n-\t$(LN_S) $(srcdir)/../libiberty/splay-tree.c $@\n-# Copy this so that top-level include/ does not have to be put into -I path\n-splay-tree.h:\n-\trm -f $@\n-\t$(LN_S) $(srcdir)/../include/splay-tree.h $@\n mf-runtime.lo: mf-runtime.c splay-tree.c splay-tree.h\n \n clean-local:\n \trm -f pth/*.o pth/*.lo\n-\trm -f splay-tree.c splay-tree.h\n \n pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h splay-tree.c splay-tree.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-runtime.c -o $@"}, {"sha": "26e83d021bdc6f17f28266afbf54aa5bdf87bc95", "filename": "libmudflap/ansidecl.h", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef558756f2838de518a99a52caabe931e9af52b1/libmudflap%2Fansidecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef558756f2838de518a99a52caabe931e9af52b1/libmudflap%2Fansidecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fansidecl.h?ref=ef558756f2838de518a99a52caabe931e9af52b1", "patch": "@@ -1,4 +0,0 @@\n-/* A minimal ansidecl.h file for use by splay-tree only.  */\n-#define PARAMS(X) X\n-#define PTR  void *\n-#define ATTRIBUTE_UNUSED __attribute__((__unused__))"}, {"sha": "2b752576db91b93d22524dba7bc8f2db1b98be87", "filename": "libmudflap/libiberty.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef558756f2838de518a99a52caabe931e9af52b1/libmudflap%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef558756f2838de518a99a52caabe931e9af52b1/libmudflap%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Flibiberty.h?ref=ef558756f2838de518a99a52caabe931e9af52b1", "patch": "@@ -1 +0,0 @@\n-/* Placeholder for splay-tree use only.  */"}, {"sha": "f1cd0a22db765942c84e7d73649ea06dc22d5466", "filename": "libmudflap/mf-runtime.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=dfdf6a9440609d8a58c6625b31d34509dd2df838", "patch": "@@ -610,7 +610,7 @@ __mf_object_tree (int type)\n   static splay_tree trees [__MF_TYPE_MAX+1];\n   assert (type >= 0 && type <= __MF_TYPE_MAX);\n   if (UNLIKELY (trees[type] == NULL))\n-    trees[type] = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+    trees[type] = splay_tree_new ();\n   return trees[type];\n }\n \n@@ -1390,7 +1390,7 @@ __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n         {\n           __mf_object_t *obj;\n               \n-          n = (direction == 0 ? splay_tree_predecessor (t, k) : splay_tree_successor (t, k));\n+          n = (direction == 0 ? splay_tree_successor (t, k) : splay_tree_predecessor (t, k));\n           if (n == NULL) break;\n           obj = (__mf_object_t *) n->value;\n               "}, {"sha": "037baee87d9f96968fc61e955a7ddb5a6becb294", "filename": "libmudflap/splay-tree.c", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fsplay-tree.c?ref=dfdf6a9440609d8a58c6625b31d34509dd2df838", "patch": "@@ -0,0 +1,525 @@\n+/* A splay-tree datatype.  \n+   Copyright (C) 1998, 1999, 2000, 2001, 2004 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+   Adapted for libmudflap from libiberty.\n+\n+This file is part of GNU CC.\n+   \n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* For an easily readable description of splay-trees, see:\n+\n+     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n+     Algorithms.  Harper-Collins, Inc.  1991.  */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include \"splay-tree.h\"\n+\n+static void splay_tree_delete_helper    PARAMS((splay_tree, \n+\t\t\t\t\t\tsplay_tree_node));\n+static void splay_tree_splay            PARAMS((splay_tree,\n+\t\t\t\t\t\tsplay_tree_key));\n+static splay_tree_node splay_tree_splay_helper     \n+                                        PARAMS((splay_tree,\n+\t\t\t\t\t\tsplay_tree_key,\n+\t\t\t\t\t\tsplay_tree_node*,\n+\t\t\t\t\t\tsplay_tree_node*,\n+\t\t\t\t\t\tsplay_tree_node*));\n+static int splay_tree_foreach_helper    PARAMS((splay_tree,\n+\t\t\t\t\t        splay_tree_node,\n+\t\t\t\t\t\tsplay_tree_foreach_fn,\n+\t\t\t\t\t\tvoid*));\n+\n+\n+\n+/* Inline comparison function specialized for libmudflap's key type.  */\n+static inline int\n+compare_uintptr_t (splay_tree_key k1, splay_tree_key k2)\n+{\n+  if ((uintptr_t) k1 < (uintptr_t) k2)\n+    return -1;\n+  else if ((uintptr_t) k1 > (uintptr_t) k2)\n+    return 1;\n+  else \n+    return 0;\n+}\n+\n+\n+\n+/* Deallocate NODE (a member of SP), and all its sub-trees.  */\n+\n+static void \n+splay_tree_delete_helper (sp, node)\n+     splay_tree sp;\n+     splay_tree_node node;\n+{\n+  if (!node)\n+    return;\n+\n+  splay_tree_delete_helper (sp, node->left);\n+  splay_tree_delete_helper (sp, node->right);\n+  (*sp->deallocate) ((char*) node, sp->allocate_data);\n+}\n+\n+/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n+   and grandparent, respectively, of NODE.  */\n+\n+static splay_tree_node\n+splay_tree_splay_helper (sp, key, node, parent, grandparent)\n+     splay_tree sp;\n+     splay_tree_key key;\n+     splay_tree_node *node;\n+     splay_tree_node *parent;\n+     splay_tree_node *grandparent;\n+{\n+  splay_tree_node *next;\n+  splay_tree_node n;\n+  int comparison;\n+  \n+  n = *node;\n+\n+  if (!n)\n+    return *parent;\n+\n+  comparison = compare_uintptr_t (key, n->key);\n+\n+  if (comparison == 0)\n+    /* We've found the target.  */\n+    next = 0;\n+  else if (comparison < 0)\n+    /* The target is to the left.  */\n+    next = &n->left;\n+  else \n+    /* The target is to the right.  */\n+    next = &n->right;\n+\n+  if (next)\n+    {\n+      /* Continue down the tree.  */\n+      n = splay_tree_splay_helper (sp, key, next, node, parent);\n+\n+      /* The recursive call will change the place to which NODE\n+\t points.  */\n+      if (*node != n)\n+\treturn n;\n+    }\n+\n+  if (!parent)\n+    /* NODE is the root.  We are done.  */\n+    return n;\n+\n+  /* First, handle the case where there is no grandparent (i.e.,\n+     *PARENT is the root of the tree.)  */\n+  if (!grandparent) \n+    {\n+      if (n == (*parent)->left)\n+\t{\n+\t  *node = n->right;\n+\t  n->right = *parent;\n+\t}\n+      else\n+\t{\n+\t  *node = n->left;\n+\t  n->left = *parent;\n+\t}\n+      *parent = n;\n+      return n;\n+    }\n+\n+  /* Next handle the cases where both N and *PARENT are left children,\n+     or where both are right children.  */\n+  if (n == (*parent)->left && *parent == (*grandparent)->left)\n+    {\n+      splay_tree_node p = *parent;\n+\n+      (*grandparent)->left = p->right;\n+      p->right = *grandparent;\n+      p->left = n->right;\n+      n->right = p;\n+      *grandparent = n;\n+      return n; \n+    }\n+  else if  (n == (*parent)->right && *parent == (*grandparent)->right)\n+    {\n+      splay_tree_node p = *parent;\n+\n+      (*grandparent)->right = p->left;\n+      p->left = *grandparent;\n+      p->right = n->left;\n+      n->left = p;\n+      *grandparent = n;\n+      return n;\n+    }\n+\n+  /* Finally, deal with the case where N is a left child, but *PARENT\n+     is a right child, or vice versa.  */\n+  if (n == (*parent)->left) \n+    {\n+      (*parent)->left = n->right;\n+      n->right = *parent;\n+      (*grandparent)->right = n->left;\n+      n->left = *grandparent;\n+      *grandparent = n;\n+      return n;\n+    } \n+  else\n+    {\n+      (*parent)->right = n->left;\n+      n->left = *parent;\n+      (*grandparent)->left = n->right;\n+      n->right = *grandparent;\n+      *grandparent = n;\n+      return n;\n+    }\n+}\n+\n+/* Splay SP around KEY.  */\n+\n+static void\n+splay_tree_splay (sp, key)\n+     splay_tree sp;\n+     splay_tree_key key;\n+{\n+  if (sp->root == 0)\n+    return;\n+\n+  /* If we just splayed the tree with the same key, do nothing.  */\n+  if (sp->last_splayed_key_p &&\n+      compare_uintptr_t (sp->last_splayed_key, key) == 0)\n+    return;\n+\n+  splay_tree_splay_helper (sp, key, &sp->root, \n+\t\t\t   /*grandparent=*/0, /*parent=*/0); \n+\n+  /* Cache this splay key. */\n+  sp->last_splayed_key = key;\n+  sp->last_splayed_key_p = 1;\n+}\n+\n+/* Call FN, passing it the DATA, for every node below NODE, all of\n+   which are from SP, following an in-order traversal.  If FN every\n+   returns a non-zero value, the iteration ceases immediately, and the\n+   value is returned.  Otherwise, this function returns 0.  */\n+\n+static int\n+splay_tree_foreach_helper (sp, node, fn, data)\n+     splay_tree sp;\n+     splay_tree_node node;\n+     splay_tree_foreach_fn fn;\n+     void* data;\n+{\n+  int val;\n+\n+  if (!node)\n+    return 0;\n+\n+  val = splay_tree_foreach_helper (sp, node->left, fn, data);\n+  if (val)\n+    return val;\n+\n+  val = (*fn)(node, data);\n+  if (val)\n+    return val;\n+\n+  return splay_tree_foreach_helper (sp, node->right, fn, data);\n+}\n+\n+\n+/* An allocator and deallocator based on xmalloc.  */\n+static void *\n+splay_tree_xmalloc_allocate (size, data)\n+     int size;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  return (void *) xmalloc (size);\n+}\n+\n+static void\n+splay_tree_xmalloc_deallocate (object, data)\n+     void *object;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  free (object);\n+}\n+\n+\n+/* Allocate a new splay tree, using COMPARE_FN to compare nodes,\n+   DELETE_KEY_FN to deallocate keys, and DELETE_VALUE_FN to deallocate\n+   values.  Use xmalloc to allocate the splay tree structure, and any\n+   nodes added.  */\n+\n+splay_tree \n+splay_tree_new ()\n+{\n+  splay_tree_allocate_fn allocate_fn = splay_tree_xmalloc_allocate;\n+  splay_tree_deallocate_fn deallocate_fn = splay_tree_xmalloc_deallocate;\n+  void *allocate_data = NULL;\n+  splay_tree sp = (splay_tree) (*allocate_fn) (sizeof (struct splay_tree_s),\n+                                               allocate_data);\n+  sp->root = 0;\n+  sp->allocate = allocate_fn;\n+  sp->deallocate = deallocate_fn;\n+  sp->allocate_data = allocate_data;\n+  sp->last_splayed_key_p = 0;\n+\n+  return sp;\n+}\n+\n+/* Deallocate SP.  */\n+\n+void \n+splay_tree_delete (sp)\n+     splay_tree sp;\n+{\n+  splay_tree_delete_helper (sp, sp->root);\n+  (*sp->deallocate) ((char*) sp, sp->allocate_data);\n+}\n+\n+/* Insert a new node (associating KEY with DATA) into SP.  If a\n+   previous node with the indicated KEY exists, its data is replaced\n+   with the new value.  Returns the new node.  */\n+\n+splay_tree_node\n+splay_tree_insert (sp, key, value)\n+     splay_tree sp;\n+     splay_tree_key key;\n+     splay_tree_value value;\n+{\n+  int comparison = 0;\n+\n+  splay_tree_splay (sp, key);\n+\n+  if (sp->root)\n+    comparison = compare_uintptr_t (sp->root->key, key);\n+\n+  if (sp->root && comparison == 0)\n+    {\n+      /* If the root of the tree already has the indicated KEY, just\n+\t replace the value with VALUE.  */\n+      sp->root->value = value;\n+    } \n+  else \n+    {\n+      /* Create a new node, and insert it at the root.  */\n+      splay_tree_node node;\n+      \n+      node = ((splay_tree_node)\n+              (*sp->allocate) (sizeof (struct splay_tree_node_s),\n+                               sp->allocate_data));\n+      node->key = key;\n+      node->value = value;\n+      \n+      if (!sp->root)\n+\tnode->left = node->right = 0;\n+      else if (comparison < 0)\n+\t{\n+\t  node->left = sp->root;\n+\t  node->right = node->left->right;\n+\t  node->left->right = 0;\n+\t}\n+      else\n+\t{\n+\t  node->right = sp->root;\n+\t  node->left = node->right->left;\n+\t  node->right->left = 0;\n+\t}\n+\n+      sp->root = node;\n+      sp->last_splayed_key_p = 0;\n+    }\n+\n+  return sp->root;\n+}\n+\n+/* Remove KEY from SP.  It is not an error if it did not exist.  */\n+\n+void\n+splay_tree_remove (sp, key)\n+     splay_tree sp;\n+     splay_tree_key key;\n+{\n+  splay_tree_splay (sp, key);\n+  sp->last_splayed_key_p = 0;\n+\n+  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n+    {\n+      splay_tree_node left, right;\n+\n+      left = sp->root->left;\n+      right = sp->root->right;\n+\n+      /* Delete the root node itself.  */\n+      (*sp->deallocate) (sp->root, sp->allocate_data);\n+\n+      /* One of the children is now the root.  Doesn't matter much\n+\t which, so long as we preserve the properties of the tree.  */\n+      if (left)\n+\t{\n+\t  sp->root = left;\n+\n+\t  /* If there was a right child as well, hang it off the \n+\t     right-most leaf of the left child.  */\n+\t  if (right)\n+\t    {\n+\t      while (left->right)\n+\t\tleft = left->right;\n+\t      left->right = right;\n+\t    }\n+\t}\n+      else\n+\tsp->root = right;\n+    }\n+}\n+\n+/* Lookup KEY in SP, returning VALUE if present, and NULL \n+   otherwise.  */\n+\n+splay_tree_node\n+splay_tree_lookup (sp, key)\n+     splay_tree sp;\n+     splay_tree_key key;\n+{\n+  splay_tree_splay (sp, key);\n+\n+  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n+    return sp->root;\n+  else\n+    return 0;\n+}\n+\n+/* Return the node in SP with the greatest key.  */\n+\n+splay_tree_node\n+splay_tree_max (sp)\n+     splay_tree sp;\n+{\n+  splay_tree_node n = sp->root;\n+\n+  if (!n)\n+    return NULL;\n+\n+  while (n->right)\n+    n = n->right;\n+\n+  return n;\n+}\n+\n+/* Return the node in SP with the smallest key.  */\n+\n+splay_tree_node\n+splay_tree_min (sp)\n+     splay_tree sp;\n+{\n+  splay_tree_node n = sp->root;\n+\n+  if (!n)\n+    return NULL;\n+\n+  while (n->left)\n+    n = n->left;\n+\n+  return n;\n+}\n+\n+/* Return the immediate predecessor KEY, or NULL if there is no\n+   predecessor.  KEY need not be present in the tree.  */\n+\n+splay_tree_node\n+splay_tree_predecessor (sp, key)\n+     splay_tree sp;\n+     splay_tree_key key;\n+{\n+  int comparison;\n+  splay_tree_node node;\n+\n+  /* If the tree is empty, there is certainly no predecessor.  */\n+  if (!sp->root)\n+    return NULL;\n+\n+  /* Splay the tree around KEY.  That will leave either the KEY\n+     itself, its predecessor, or its successor at the root.  */\n+  splay_tree_splay (sp, key);\n+  comparison = compare_uintptr_t (sp->root->key, key);\n+\n+  /* If the predecessor is at the root, just return it.  */\n+  if (comparison < 0)\n+    return sp->root;\n+\n+  /* Otherwise, find the rightmost element of the left subtree.  */\n+  node = sp->root->left;\n+  if (node)\n+    while (node->right)\n+      node = node->right;\n+\n+  return node;\n+}\n+\n+/* Return the immediate successor KEY, or NULL if there is no\n+   successor.  KEY need not be present in the tree.  */\n+\n+splay_tree_node\n+splay_tree_successor (sp, key)\n+     splay_tree sp;\n+     splay_tree_key key;\n+{\n+  int comparison;\n+  splay_tree_node node;\n+\n+  /* If the tree is empty, there is certainly no successor.  */\n+  if (!sp->root)\n+    return NULL;\n+\n+  /* Splay the tree around KEY.  That will leave either the KEY\n+     itself, its predecessor, or its successor at the root.  */\n+  splay_tree_splay (sp, key);\n+  comparison = compare_uintptr_t (sp->root->key, key);\n+\n+  /* If the successor is at the root, just return it.  */\n+  if (comparison > 0)\n+    return sp->root;\n+\n+  /* Otherwise, find the leftmost element of the right subtree.  */\n+  node = sp->root->right;\n+  if (node)\n+    while (node->left)\n+      node = node->left;\n+\n+  return node;\n+}\n+\n+/* Call FN, passing it the DATA, for every node in SP, following an\n+   in-order traversal.  If FN every returns a non-zero value, the\n+   iteration ceases immediately, and the value is returned.\n+   Otherwise, this function returns 0.  */\n+\n+int\n+splay_tree_foreach (sp, fn, data)\n+     splay_tree sp;\n+     splay_tree_foreach_fn fn;\n+     void *data;\n+{\n+  return splay_tree_foreach_helper (sp, sp->root, fn, data);\n+}"}, {"sha": "269394d2109cf94c937f72e21bddea519c275dc9", "filename": "libmudflap/splay-tree.h", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf6a9440609d8a58c6625b31d34509dd2df838/libmudflap%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fsplay-tree.h?ref=dfdf6a9440609d8a58c6625b31d34509dd2df838", "patch": "@@ -0,0 +1,136 @@\n+/* A splay-tree datatype.  \n+   Copyright 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.\n+   Contributed by Mark Mitchell (mark@markmitchell.com).\n+   Adapted for libmudflap from libiberty.\n+\n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* For an easily readable description of splay-trees, see:\n+\n+     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n+     Algorithms.  Harper-Collins, Inc.  1991.  \n+\n+   The major feature of splay trees is that all basic tree operations\n+   are amortized O(log n) time for a tree with n nodes.  */\n+\n+#ifndef _SPLAY_TREE_H\n+#define _SPLAY_TREE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+#define PARAMS(X) X\n+#define PTR  void *\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+\n+#ifndef GTY\n+#define GTY(X)\n+#endif\n+\n+/* Use typedefs for the key and data types to facilitate changing\n+   these types, if necessary.  These types should be sufficiently wide\n+   that any pointer or scalar can be cast to these types, and then\n+   cast back, without loss of precision.  */\n+typedef uintptr_t splay_tree_key;\n+typedef void *splay_tree_value;\n+\n+/* Forward declaration for a node in the tree.  */\n+typedef struct splay_tree_node_s *splay_tree_node;\n+\n+/* The type of a function used to iterate over the tree.  */\n+typedef int (*splay_tree_foreach_fn) PARAMS((splay_tree_node, void*));\n+\n+/* The type of a function used to allocate memory for tree root and\n+   node structures.  The first argument is the number of bytes needed;\n+   the second is a data pointer the splay tree functions pass through\n+   to the allocator.  This function must never return zero.  */\n+typedef PTR (*splay_tree_allocate_fn) PARAMS((int, void *));\n+\n+/* The type of a function used to free memory allocated using the\n+   corresponding splay_tree_allocate_fn.  The first argument is the\n+   memory to be freed; the latter is a data pointer the splay tree\n+   functions pass through to the freer.  */\n+typedef void (*splay_tree_deallocate_fn) PARAMS((void *, void *));\n+\n+/* The nodes in the splay tree.  */\n+struct splay_tree_node_s GTY(())\n+{\n+  /* The key.  */\n+  splay_tree_key GTY ((use_param1)) key;\n+\n+  /* The value.  */\n+  splay_tree_value GTY ((use_param2)) value;\n+\n+  /* The left and right children, respectively.  */\n+  splay_tree_node GTY ((use_params)) left;\n+  splay_tree_node GTY ((use_params)) right;\n+};\n+\n+/* The splay tree itself.  */\n+struct splay_tree_s GTY(())\n+{\n+  /* The root of the tree.  */\n+  splay_tree_node GTY ((use_params)) root;\n+\n+  /* Allocate/free functions, and a data pointer to pass to them.  */\n+  splay_tree_allocate_fn allocate;\n+  splay_tree_deallocate_fn deallocate;\n+  PTR GTY((skip)) allocate_data;\n+\n+  /* The last key value for which the tree has been splayed, but not\n+     since modified.  */\n+  splay_tree_key GTY ((use_param1)) last_splayed_key;\n+  int last_splayed_key_p;\n+};\n+typedef struct splay_tree_s *splay_tree;\n+\n+extern splay_tree splay_tree_new        PARAMS((void));\n+extern void splay_tree_delete           PARAMS((splay_tree));\n+extern splay_tree_node splay_tree_insert          \n+\t\t                        PARAMS((splay_tree,\n+\t\t\t\t\t        splay_tree_key,\n+\t\t\t\t\t        splay_tree_value));\n+extern void splay_tree_remove\t\tPARAMS((splay_tree,\n+\t\t\t\t\t\tsplay_tree_key));\n+extern splay_tree_node splay_tree_lookup   \n+                                        PARAMS((splay_tree,\n+\t\t\t\t\t        splay_tree_key));\n+extern splay_tree_node splay_tree_predecessor\n+                                        PARAMS((splay_tree,\n+\t\t\t\t\t\tsplay_tree_key));\n+extern splay_tree_node splay_tree_successor\n+                                        PARAMS((splay_tree,\n+\t\t\t\t\t\tsplay_tree_key));\n+extern splay_tree_node splay_tree_max\n+                                        PARAMS((splay_tree));\n+extern splay_tree_node splay_tree_min\n+                                        PARAMS((splay_tree));\n+extern int splay_tree_foreach           PARAMS((splay_tree,\n+\t\t\t\t\t        splay_tree_foreach_fn,\n+\t\t\t\t\t        void*));\n+extern int splay_tree_compare_ints      PARAMS((splay_tree_key,\n+\t\t\t\t\t\tsplay_tree_key));\n+extern int splay_tree_compare_pointers  PARAMS((splay_tree_key,\n+\t\t\t\t\t\tsplay_tree_key));\n+\t\t\t\t\t       \n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif /* _SPLAY_TREE_H */"}]}