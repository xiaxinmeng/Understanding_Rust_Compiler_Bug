{"sha": "96b7f495f9269d5448822e4fc28882edb35a58d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZiN2Y0OTVmOTI2OWQ1NDQ4ODIyZTRmYzI4ODgyZWRiMzVhNThkNw==", "commit": {"author": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-07-09T08:11:59Z"}, "committer": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-07-09T08:18:47Z"}, "message": "aarch64: Mitigate SLS for BLR instruction\n\nThis patch introduces the mitigation for Straight Line Speculation past\nthe BLR instruction.\n\nThis mitigation replaces BLR instructions with a BL to a stub which uses\na BR to jump to the original value.  These function stubs are then\nappended with a speculation barrier to ensure no straight line\nspeculation happens after these jumps.\n\nWhen optimising for speed we use a set of stubs for each function since\nthis should help the branch predictor make more accurate predictions\nabout where a stub should branch.\n\nWhen optimising for size we use one set of stubs for all functions.\nThis set of stubs can have human readable names, and we are using\n`__call_indirect_x<N>` for register x<N>.\n\nWhen BTI branch protection is enabled the BLR instruction can jump to a\n`BTI c` instruction using any register, while the BR instruction can\nonly jump to a `BTI c` instruction using the x16 or x17 registers.\nHence, in order to ensure this transformation is safe we mov the value\nof the original register into x16 and use x16 for the BR.\n\nAs an example when optimising for size:\na\n    BLR x0\ninstruction would get transformed to something like\n    BL __call_indirect_x0\nwhere __call_indirect_x0 labels a thunk that contains\n__call_indirect_x0:\n    MOV X16, X0\n    BR X16\n    <speculation barrier>\n\nThe first version of this patch used local symbols specific to a\ncompilation unit to try and avoid relocations.\nThis was mistaken since functions coming from the same compilation unit\ncan still be in different sections, and the assembler will insert\nrelocations at jumps between sections.\n\nOn any relocation the linker is permitted to emit a veneer to handle\njumps between symbols that are very far apart.  The registers x16 and\nx17 may be clobbered by these veneers.\nHence the function stubs cannot rely on the values of x16 and x17 being\nthe same as just before the function stub is called.\n\nSimilar can be said for the hot/cold partitioning of single functions,\nso function-local stubs have the same restriction.\n\nThis updated version of the patch never emits function stubs for x16 and\nx17, and instead forces other registers to be used.\n\nGiven the above, there is now no benefit to local symbols (since they\nare not enough to avoid dealing with linker intricacies).  This patch\nnow uses global symbols with hidden visibility each stored in their own\nCOMDAT section.  This means stubs can be shared between compilation\nunits while still avoiding the PLT indirection.\n\nThis patch also removes the `__call_indirect_x30` stub (and\nfunction-local equivalent) which would simply jump back to the original\nlocation.\n\nThe function-local stubs are emitted to the assembly output file in one\nchunk, which means we need not add the speculation barrier directly\nafter each one.\nThis is because we know for certain that the instructions directly after\nthe BR in all but the last function stub will be from another one of\nthese stubs and hence will not contain a speculation gadget.\nInstead we add a speculation barrier at the end of the sequence of\nstubs.\n\nThe global stubs are emitted in COMDAT/.linkonce sections by\nthemselves so that the linker can remove duplicates from multiple object\nfiles.  This means they are not emitted in one chunk, and each one must\ninclude the speculation barrier.\n\nAnother difference is that since the global stubs are shared across\ncompilation units we do not know that all functions will be targeting an\narchitecture supporting the SB instruction.\nRather than provide multiple stubs for each architecture, we provide a\nstub that will work for all architectures -- using the DSB+ISB barrier.\n\nThis mitigation does not apply for BLR instructions in the following\nplaces:\n- Some accesses to thread-local variables use a code sequence with a BLR\n  instruction.  This code sequence is part of the binary interface between\n  compiler and linker. If this BLR instruction needs to be mitigated, it'd\n  probably be best to do so in the linker. It seems that the code sequence\n  for thread-local variable access is unlikely to lead to a Spectre Revalation\n  Gadget.\n- PLT stubs are produced by the linker and each contain a BLR instruction.\n  It seems that at most only after the last PLT stub a Spectre Revalation\n  Gadget might appear.\n\nTesting:\n  Bootstrap and regtest on AArch64\n    (with BOOT_CFLAGS=\"-mharden-sls=retbr,blr\")\n  Used a temporary hack(1) in gcc-dg.exp to use these options on every\n  test in the testsuite, a slight modification to emit the speculation\n  barrier after every function stub, and a script to check that the\n  output never emitted a BLR, or unmitigated BR or RET instruction.\n  Similar on an aarch64-none-elf cross-compiler.\n\n1) Temporary hack emitted a speculation barrier at the end of every stub\nfunction, and used a script to ensure that:\n  a) Every RET or BR is immediately followed by a speculation barrier.\n  b) No BLR instruction is emitted by compiler.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-protos.h (aarch64_indirect_call_asm):\n\tNew declaration.\n\t* config/aarch64/aarch64.c (aarch64_regno_regclass): Handle new\n\tstub registers class.\n\t(aarch64_class_max_nregs): Likewise.\n\t(aarch64_register_move_cost): Likewise.\n\t(aarch64_sls_shared_thunks): Global array to store stub labels.\n\t(aarch64_sls_emit_function_stub): New.\n\t(aarch64_create_blr_label): New.\n\t(aarch64_sls_emit_blr_function_thunks): New.\n\t(aarch64_sls_emit_shared_blr_thunks): New.\n\t(aarch64_asm_file_end): New.\n\t(aarch64_indirect_call_asm): New.\n\t(TARGET_ASM_FILE_END): Use aarch64_asm_file_end.\n\t(TARGET_ASM_FUNCTION_EPILOGUE): Use\n\taarch64_sls_emit_blr_function_thunks.\n\t* config/aarch64/aarch64.h (STB_REGNUM_P): New.\n\t(enum reg_class): Add STUB_REGS class.\n\t(machine_function): Introduce `call_via` array for\n\tfunction-local stub labels.\n\t* config/aarch64/aarch64.md (*call_insn, *call_value_insn): Use\n\taarch64_indirect_call_asm to emit code when hardening BLR\n\tinstructions.\n\t* config/aarch64/constraints.md (Ucr): New constraint\n\trepresenting registers for indirect calls.  Is GENERAL_REGS\n\tusually, and STUB_REGS when hardening BLR instruction against\n\tSLS.\n\t* config/aarch64/predicates.md (aarch64_general_reg): STUB_REGS class\n\tis also a general register.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/sls-mitigation/sls-miti-blr-bti.c: New test.\n\t* gcc.target/aarch64/sls-mitigation/sls-miti-blr.c: New test.", "tree": {"sha": "64c0b9cf11b60e32e6b70c714395b8e16eff1ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64c0b9cf11b60e32e6b70c714395b8e16eff1ddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96b7f495f9269d5448822e4fc28882edb35a58d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96b7f495f9269d5448822e4fc28882edb35a58d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96b7f495f9269d5448822e4fc28882edb35a58d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96b7f495f9269d5448822e4fc28882edb35a58d7/comments", "author": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be178ecd5ac1fe1510d960ff95c66d0ff831afe1"}], "stats": {"total": 337, "additions": 328, "deletions": 9}, "files": [{"sha": "865ad6744e1e3ce1832b7fa4c6217a21970503bc", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -781,6 +781,7 @@ extern const atomic_ool_names aarch64_ool_ldeor_names;\n tree aarch64_resolve_overloaded_builtin_general (location_t, tree, void *);\n \n const char *aarch64_sls_barrier (int);\n+const char *aarch64_indirect_call_asm (rtx);\n extern bool aarch64_harden_sls_retbr_p (void);\n extern bool aarch64_harden_sls_blr_p (void);\n "}, {"sha": "17dbe673978b5d6cbf9c9ec9cbbcc205465d7e89", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 223, "deletions": 2, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -10608,6 +10608,9 @@ aarch64_label_mentioned_p (rtx x)\n enum reg_class\n aarch64_regno_regclass (unsigned regno)\n {\n+  if (STUB_REGNUM_P (regno))\n+    return STUB_REGS;\n+\n   if (GP_REGNUM_P (regno))\n     return GENERAL_REGS;\n \n@@ -10910,6 +10913,7 @@ aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)\n   unsigned int nregs, vec_flags;\n   switch (regclass)\n     {\n+    case STUB_REGS:\n     case TAILCALL_ADDR_REGS:\n     case POINTER_REGS:\n     case GENERAL_REGS:\n@@ -13149,10 +13153,12 @@ aarch64_register_move_cost (machine_mode mode,\n     = aarch64_tune_params.regmove_cost;\n \n   /* Caller save and pointer regs are equivalent to GENERAL_REGS.  */\n-  if (to == TAILCALL_ADDR_REGS || to == POINTER_REGS)\n+  if (to == TAILCALL_ADDR_REGS || to == POINTER_REGS\n+      || to == STUB_REGS)\n     to = GENERAL_REGS;\n \n-  if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS)\n+  if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS\n+      || from == STUB_REGS)\n     from = GENERAL_REGS;\n \n   /* Make RDFFR very expensive.  In particular, if we know that the FFR\n@@ -22964,6 +22970,215 @@ aarch64_sls_barrier (int mitigation_required)\n     : \"\";\n }\n \n+static GTY (()) tree aarch64_sls_shared_thunks[30];\n+static GTY (()) bool aarch64_sls_shared_thunks_needed = false;\n+const char *indirect_symbol_names[30] = {\n+    \"__call_indirect_x0\",\n+    \"__call_indirect_x1\",\n+    \"__call_indirect_x2\",\n+    \"__call_indirect_x3\",\n+    \"__call_indirect_x4\",\n+    \"__call_indirect_x5\",\n+    \"__call_indirect_x6\",\n+    \"__call_indirect_x7\",\n+    \"__call_indirect_x8\",\n+    \"__call_indirect_x9\",\n+    \"__call_indirect_x10\",\n+    \"__call_indirect_x11\",\n+    \"__call_indirect_x12\",\n+    \"__call_indirect_x13\",\n+    \"__call_indirect_x14\",\n+    \"__call_indirect_x15\",\n+    \"\", /* \"__call_indirect_x16\",  */\n+    \"\", /* \"__call_indirect_x17\",  */\n+    \"__call_indirect_x18\",\n+    \"__call_indirect_x19\",\n+    \"__call_indirect_x20\",\n+    \"__call_indirect_x21\",\n+    \"__call_indirect_x22\",\n+    \"__call_indirect_x23\",\n+    \"__call_indirect_x24\",\n+    \"__call_indirect_x25\",\n+    \"__call_indirect_x26\",\n+    \"__call_indirect_x27\",\n+    \"__call_indirect_x28\",\n+    \"__call_indirect_x29\",\n+};\n+\n+/* Function to create a BLR thunk.  This thunk is used to mitigate straight\n+   line speculation.  Instead of a simple BLR that can be speculated past,\n+   we emit a BL to this thunk, and this thunk contains a BR to the relevant\n+   register.  These thunks have the relevant speculation barries put after\n+   their indirect branch so that speculation is blocked.\n+\n+   We use such a thunk so the speculation barriers are kept off the\n+   architecturally executed path in order to reduce the performance overhead.\n+\n+   When optimizing for size we use stubs shared by the linked object.\n+   When optimizing for performance we emit stubs for each function in the hope\n+   that the branch predictor can better train on jumps specific for a given\n+   function.  */\n+rtx\n+aarch64_sls_create_blr_label (int regnum)\n+{\n+  gcc_assert (STUB_REGNUM_P (regnum));\n+  if (optimize_function_for_size_p (cfun))\n+    {\n+      /* For the thunks shared between different functions in this compilation\n+\t unit we use a named symbol -- this is just for users to more easily\n+\t understand the generated assembly.  */\n+      aarch64_sls_shared_thunks_needed = true;\n+      const char *thunk_name = indirect_symbol_names[regnum];\n+      if (aarch64_sls_shared_thunks[regnum] == NULL)\n+\t{\n+\t  /* Build a decl representing this function stub and record it for\n+\t     later.  We build a decl here so we can use the GCC machinery for\n+\t     handling sections automatically (through `get_named_section` and\n+\t     `make_decl_one_only`).  That saves us a lot of trouble handling\n+\t     the specifics of different output file formats.  */\n+\t  tree decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n+\t\t\t\t  get_identifier (thunk_name),\n+\t\t\t\t  build_function_type_list (void_type_node,\n+\t\t\t\t\t\t\t    NULL_TREE));\n+\t  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,\n+\t\t\t\t\t   NULL_TREE, void_type_node);\n+\t  TREE_PUBLIC (decl) = 1;\n+\t  TREE_STATIC (decl) = 1;\n+\t  DECL_IGNORED_P (decl) = 1;\n+\t  DECL_ARTIFICIAL (decl) = 1;\n+\t  make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));\n+\t  resolve_unique_section (decl, 0, false);\n+\t  aarch64_sls_shared_thunks[regnum] = decl;\n+\t}\n+\n+      return gen_rtx_SYMBOL_REF (Pmode, thunk_name);\n+    }\n+\n+  if (cfun->machine->call_via[regnum] == NULL)\n+    cfun->machine->call_via[regnum]\n+      = gen_rtx_LABEL_REF (Pmode, gen_label_rtx ());\n+  return cfun->machine->call_via[regnum];\n+}\n+\n+/* Helper function for aarch64_sls_emit_blr_function_thunks and\n+   aarch64_sls_emit_shared_blr_thunks below.  */\n+static void\n+aarch64_sls_emit_function_stub (FILE *out_file, int regnum)\n+{\n+  /* Save in x16 and branch to that function so this transformation does\n+     not prevent jumping to `BTI c` instructions.  */\n+  asm_fprintf (out_file, \"\\tmov\\tx16, x%d\\n\", regnum);\n+  asm_fprintf (out_file, \"\\tbr\\tx16\\n\");\n+}\n+\n+/* Emit all BLR stubs for this particular function.\n+   Here we emit all the BLR stubs needed for the current function.  Since we\n+   emit these stubs in a consecutive block we know there will be no speculation\n+   gadgets between each stub, and hence we only emit a speculation barrier at\n+   the end of the stub sequences.\n+\n+   This is called in the TARGET_ASM_FUNCTION_EPILOGUE hook.  */\n+void\n+aarch64_sls_emit_blr_function_thunks (FILE *out_file)\n+{\n+  if (! aarch64_harden_sls_blr_p ())\n+    return;\n+\n+  bool any_functions_emitted = false;\n+  /* We must save and restore the current function section since this assembly\n+     is emitted at the end of the function.  This means it can be emitted *just\n+     after* the cold section of a function.  That cold part would be emitted in\n+     a different section.  That switch would trigger a `.cfi_endproc` directive\n+     to be emitted in the original section and a `.cfi_startproc` directive to\n+     be emitted in the new section.  Switching to the original section without\n+     restoring would mean that the `.cfi_endproc` emitted as a function ends\n+     would happen in a different section -- leaving an unmatched\n+     `.cfi_startproc` in the cold text section and an unmatched `.cfi_endproc`\n+     in the standard text section.  */\n+  section *save_text_section = in_section;\n+  switch_to_section (function_section (current_function_decl));\n+  for (int regnum = 0; regnum < 30; ++regnum)\n+    {\n+      rtx specu_label = cfun->machine->call_via[regnum];\n+      if (specu_label == NULL)\n+\tcontinue;\n+\n+      targetm.asm_out.print_operand (out_file, specu_label, 0);\n+      asm_fprintf (out_file, \":\\n\");\n+      aarch64_sls_emit_function_stub (out_file, regnum);\n+      any_functions_emitted = true;\n+    }\n+  if (any_functions_emitted)\n+    /* Can use the SB if needs be here, since this stub will only be used\n+      by the current function, and hence for the current target.  */\n+    asm_fprintf (out_file, \"\\t%s\\n\", aarch64_sls_barrier (true));\n+  switch_to_section (save_text_section);\n+}\n+\n+/* Emit shared BLR stubs for the current compilation unit.\n+   Over the course of compiling this unit we may have converted some BLR\n+   instructions to a BL to a shared stub function.  This is where we emit those\n+   stub functions.\n+   This function is for the stubs shared between different functions in this\n+   compilation unit.  We share when optimizing for size instead of speed.\n+\n+   This function is called through the TARGET_ASM_FILE_END hook.  */\n+void\n+aarch64_sls_emit_shared_blr_thunks (FILE *out_file)\n+{\n+  if (! aarch64_sls_shared_thunks_needed)\n+    return;\n+\n+  for (int regnum = 0; regnum < 30; ++regnum)\n+    {\n+      tree decl = aarch64_sls_shared_thunks[regnum];\n+      if (!decl)\n+\tcontinue;\n+\n+      const char *name = indirect_symbol_names[regnum];\n+      switch_to_section (get_named_section (decl, NULL, 0));\n+      ASM_OUTPUT_ALIGN (out_file, 2);\n+      targetm.asm_out.globalize_label (out_file, name);\n+      /* Only emits if the compiler is configured for an assembler that can\n+\t handle visibility directives.  */\n+      targetm.asm_out.assemble_visibility (decl, VISIBILITY_HIDDEN);\n+      ASM_OUTPUT_TYPE_DIRECTIVE (out_file, name, \"function\");\n+      ASM_OUTPUT_LABEL (out_file, name);\n+      aarch64_sls_emit_function_stub (out_file, regnum);\n+      /* Use the most conservative target to ensure it can always be used by any\n+\t function in the translation unit.  */\n+      asm_fprintf (out_file, \"\\tdsb\\tsy\\n\\tisb\\n\");\n+      ASM_DECLARE_FUNCTION_SIZE (out_file, name, decl);\n+    }\n+}\n+\n+/* Implement TARGET_ASM_FILE_END.  */\n+void\n+aarch64_asm_file_end ()\n+{\n+  aarch64_sls_emit_shared_blr_thunks (asm_out_file);\n+  /* Since this function will be called for the ASM_FILE_END hook, we ensure\n+     that what would be called otherwise (e.g. `file_end_indicate_exec_stack`\n+     for FreeBSD) still gets called.  */\n+#ifdef TARGET_ASM_FILE_END\n+  TARGET_ASM_FILE_END ();\n+#endif\n+}\n+\n+const char *\n+aarch64_indirect_call_asm (rtx addr)\n+{\n+  gcc_assert (REG_P (addr));\n+  if (aarch64_harden_sls_blr_p ())\n+    {\n+      rtx stub_label = aarch64_sls_create_blr_label (REGNO (addr));\n+      output_asm_insn (\"bl\\t%0\", &stub_label);\n+    }\n+  else\n+   output_asm_insn (\"blr\\t%0\", &addr);\n+  return \"\";\n+}\n+\n /* Target-specific selftests.  */\n \n #if CHECKING_P\n@@ -23514,6 +23729,12 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_MD_ASM_ADJUST\n #define TARGET_MD_ASM_ADJUST arm_md_asm_adjust\n \n+#undef TARGET_ASM_FILE_END\n+#define TARGET_ASM_FILE_END aarch64_asm_file_end\n+\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE aarch64_sls_emit_blr_function_thunks\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-aarch64.h\""}, {"sha": "4534e3717b40b1dfed9d5d62372437051ca3d3b1", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -643,6 +643,16 @@ extern unsigned aarch64_architecture_version;\n #define GP_REGNUM_P(REGNO)\t\t\t\t\t\t\\\n   (((unsigned) (REGNO - R0_REGNUM)) <= (R30_REGNUM - R0_REGNUM))\n \n+/* Registers known to be preserved over a BL instruction.  This consists of the\n+   GENERAL_REGS without x16, x17, and x30.  The x30 register is changed by the\n+   BL instruction itself, while the x16 and x17 registers may be used by\n+   veneers which can be inserted by the linker.  */\n+#define STUB_REGNUM_P(REGNO) \\\n+  (GP_REGNUM_P (REGNO) \\\n+   && (REGNO) != R16_REGNUM \\\n+   && (REGNO) != R17_REGNUM \\\n+   && (REGNO) != R30_REGNUM) \\\n+\n #define FP_REGNUM_P(REGNO)\t\t\t\\\n   (((unsigned) (REGNO - V0_REGNUM)) <= (V31_REGNUM - V0_REGNUM))\n \n@@ -667,6 +677,7 @@ enum reg_class\n {\n   NO_REGS,\n   TAILCALL_ADDR_REGS,\n+  STUB_REGS,\n   GENERAL_REGS,\n   STACK_REG,\n   POINTER_REGS,\n@@ -689,6 +700,7 @@ enum reg_class\n {\t\t\t\t\t\t\\\n   \"NO_REGS\",\t\t\t\t\t\\\n   \"TAILCALL_ADDR_REGS\",\t\t\t\t\\\n+  \"STUB_REGS\",\t\t\t\t\t\\\n   \"GENERAL_REGS\",\t\t\t\t\\\n   \"STACK_REG\",\t\t\t\t\t\\\n   \"POINTER_REGS\",\t\t\t\t\\\n@@ -708,6 +720,7 @@ enum reg_class\n {\t\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n   { 0x00030000, 0x00000000, 0x00000000 },\t/* TAILCALL_ADDR_REGS */\\\n+  { 0x3ffcffff, 0x00000000, 0x00000000 },\t/* STUB_REGS */\t\t\\\n   { 0x7fffffff, 0x00000000, 0x00000003 },\t/* GENERAL_REGS */\t\\\n   { 0x80000000, 0x00000000, 0x00000000 },\t/* STACK_REG */\t\t\\\n   { 0xffffffff, 0x00000000, 0x00000003 },\t/* POINTER_REGS */\t\\\n@@ -879,6 +892,8 @@ typedef struct GTY (()) machine_function\n   struct aarch64_frame frame;\n   /* One entry for each hard register.  */\n   bool reg_is_wrapped_separately[LAST_SAVED_REGNUM];\n+  /* One entry for each general purpose register.  */\n+  rtx call_via[SP_REGNUM];\n   bool label_is_assembled;\n } machine_function;\n #endif"}, {"sha": "d5ca1898c02eed79969bbc61351abd2487f296c6", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -1022,16 +1022,15 @@\n )\n \n (define_insn \"*call_insn\"\n-  [(call (mem:DI (match_operand:DI 0 \"aarch64_call_insn_operand\" \"r, Usf\"))\n+  [(call (mem:DI (match_operand:DI 0 \"aarch64_call_insn_operand\" \"Ucr, Usf\"))\n \t (match_operand 1 \"\" \"\"))\n    (unspec:DI [(match_operand:DI 2 \"const_int_operand\")] UNSPEC_CALLEE_ABI)\n    (clobber (reg:DI LR_REGNUM))]\n   \"\"\n   \"@\n-  blr\\\\t%0\n+  * return aarch64_indirect_call_asm (operands[0]);\n   bl\\\\t%c0\"\n-  [(set_attr \"type\" \"call, call\")]\n-)\n+  [(set_attr \"type\" \"call, call\")])\n \n (define_expand \"call_value\"\n   [(parallel\n@@ -1050,13 +1049,13 @@\n \n (define_insn \"*call_value_insn\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"aarch64_call_insn_operand\" \"r, Usf\"))\n+\t(call (mem:DI (match_operand:DI 1 \"aarch64_call_insn_operand\" \"Ucr, Usf\"))\n \t\t      (match_operand 2 \"\" \"\")))\n    (unspec:DI [(match_operand:DI 3 \"const_int_operand\")] UNSPEC_CALLEE_ABI)\n    (clobber (reg:DI LR_REGNUM))]\n   \"\"\n   \"@\n-  blr\\\\t%1\n+  * return aarch64_indirect_call_asm (operands[1]);\n   bl\\\\t%c1\"\n   [(set_attr \"type\" \"call, call\")]\n )"}, {"sha": "8cc6f50888122b707a087984afc6d5ec354e1e2c", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -24,6 +24,15 @@\n (define_register_constraint \"Ucs\" \"TAILCALL_ADDR_REGS\"\n   \"@internal Registers suitable for an indirect tail call\")\n \n+(define_register_constraint \"Ucr\"\n+    \"aarch64_harden_sls_blr_p () ? STUB_REGS : GENERAL_REGS\"\n+  \"@internal Registers to be used for an indirect call.\n+   This is usually the general registers, but when we are hardening against\n+   Straight Line Speculation we disallow x16, x17, and x30 so we can use\n+   indirection stubs.  These indirection stubs cannot use the above registers\n+   since they will be reached by a BL that may have to go through a linker\n+   veneer.\")\n+\n (define_register_constraint \"w\" \"FP_REGS\"\n   \"Floating point and SIMD vector registers.\")\n "}, {"sha": "1754b1eff9f9bfa1117e03acaf226fde36d53375", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -32,7 +32,8 @@\n \n (define_predicate \"aarch64_general_reg\"\n   (and (match_operand 0 \"register_operand\")\n-       (match_test \"REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS\")))\n+       (match_test \"REGNO_REG_CLASS (REGNO (op)) == STUB_REGS\n+\t\t    || REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS\")))\n \n ;; Return true if OP a (const_int 0) operand.\n (define_predicate \"const0_operand\""}, {"sha": "b1fb754c7b6772ac391d4b751e1542f5eab5133b", "filename": "gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr-bti.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-blr-bti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-blr-bti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-blr-bti.c?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-mharden-sls=blr -mbranch-protection=bti\" } */\n+/*\n+   Ensure that the SLS hardening of BLR leaves no BLR instructions.\n+   Here we also check that there are no BR instructions with anything except an\n+   x16 or x17 register.  This is because a `BTI c` instruction can be branched\n+   to using a BLR instruction using any register, but can only be branched to\n+   with a BR using an x16 or x17 register.\n+  */\n+typedef int (foo) (int, int);\n+typedef void (bar) (int, int);\n+struct sls_testclass {\n+    foo *x;\n+    bar *y;\n+    int left;\n+    int right;\n+};\n+\n+/* We test both RTL patterns for a call which returns a value and a call which\n+   does not.  */\n+int blr_call_value (struct sls_testclass x)\n+{\n+  int retval = x.x(x.left, x.right);\n+  if (retval % 10)\n+    return 100;\n+  return 9;\n+}\n+\n+int blr_call (struct sls_testclass x)\n+{\n+  x.y(x.left, x.right);\n+  if (x.left % 10)\n+    return 100;\n+  return 9;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tblr\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tbr\\tx(?!16|17)} } } */\n+/* { dg-final { scan-assembler {\\tbr\\tx(16|17)} } } */\n+"}, {"sha": "88baffffe541e3a07547f222e80c4621e729a100", "filename": "gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-blr.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-blr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96b7f495f9269d5448822e4fc28882edb35a58d7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-blr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-blr.c?ref=96b7f495f9269d5448822e4fc28882edb35a58d7", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-additional-options \"-mharden-sls=blr -save-temps\" } */\n+/* Ensure that the SLS hardening of BLR leaves no BLR instructions.\n+   We only test that all BLR instructions have been removed, not that the\n+   resulting code makes sense.  */\n+typedef int (foo) (int, int);\n+typedef void (bar) (int, int);\n+struct sls_testclass {\n+    foo *x;\n+    bar *y;\n+    int left;\n+    int right;\n+};\n+\n+/* We test both RTL patterns for a call which returns a value and a call which\n+   does not.  */\n+int blr_call_value (struct sls_testclass x)\n+{\n+  int retval = x.x(x.left, x.right);\n+  if (retval % 10)\n+    return 100;\n+  return 9;\n+}\n+\n+int blr_call (struct sls_testclass x)\n+{\n+  x.y(x.left, x.right);\n+  if (x.left % 10)\n+    return 100;\n+  return 9;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tblr\\t} } } */\n+/* { dg-final { scan-assembler {\\tbr\\tx[0-9][0-9]?} } } */"}]}