{"sha": "7943c4dbb80efe7a39b896852bb5b79b84bbf8bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0M2M0ZGJiODBlZmU3YTM5Yjg5Njg1MmJiNWI3OWI4NGJiZjhiYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-03T10:50:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-27T09:15:48Z"}, "message": "[Ada] Reimplement Ada.Numerics.Big_Numbers.Big_Reals.Float_Conversions\n\ngcc/ada/\n\n\t* libgnat/a-nbnbre.adb: Remove clauses for System.Img_Real and\n\tadd them for System.Unsigned_Types.\n\t(Float_Conversions.To_Big_Real): Reimplement.\n\t(Float_Conversions.From_Big_Real): Likewise.", "tree": {"sha": "7dd6a346c2f7cee09f059d8c343c38bd178e5142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dd6a346c2f7cee09f059d8c343c38bd178e5142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7943c4dbb80efe7a39b896852bb5b79b84bbf8bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7943c4dbb80efe7a39b896852bb5b79b84bbf8bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7943c4dbb80efe7a39b896852bb5b79b84bbf8bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7943c4dbb80efe7a39b896852bb5b79b84bbf8bc/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84c54629c2fb6dae0e7d97a2c57e894899f2b944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c54629c2fb6dae0e7d97a2c57e894899f2b944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84c54629c2fb6dae0e7d97a2c57e894899f2b944"}], "stats": {"total": 177, "additions": 168, "deletions": 9}, "files": [{"sha": "4254b302faff366efcca59c380728f5272d06461", "filename": "gcc/ada/libgnat/a-nbnbre.adb", "status": "modified", "additions": 168, "deletions": 9, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7943c4dbb80efe7a39b896852bb5b79b84bbf8bc/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7943c4dbb80efe7a39b896852bb5b79b84bbf8bc/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb?ref=7943c4dbb80efe7a39b896852bb5b79b84bbf8bc", "patch": "@@ -30,7 +30,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Strings.Text_Output.Utils;\n-with System.Img_Real; use System.Img_Real;\n+with System.Unsigned_Types; use System.Unsigned_Types;\n \n package body Ada.Numerics.Big_Numbers.Big_Reals is\n \n@@ -122,25 +122,184 @@ package body Ada.Numerics.Big_Numbers.Big_Reals is\n       -- To_Big_Real --\n       -----------------\n \n+      --  We get the fractional representation of the floating-point number by\n+      --  multiplying Num'Fraction by 2.0**M, with M the size of the mantissa,\n+      --  which gives zero or a number in the range [2.0**(M-1)..2.0**M), which\n+      --  means that it is an integer N of M bits. The floating-point number is\n+      --  thus equal to N / 2**(M-E) where E is its Num'Exponent.\n+\n       function To_Big_Real (Arg : Num) return Valid_Big_Real is\n-         S : String (1 .. Max_Real_Image_Length);\n-         P : Natural := 0;\n+\n+         package Conv is new\n+           Big_Integers.Unsigned_Conversions (Long_Long_Unsigned);\n+\n+         A : constant Num'Base := abs (Arg);\n+         E : constant Integer  := Num'Exponent (A);\n+         F : constant Num'Base := Num'Fraction (A);\n+         M : constant Natural  := Num'Machine_Mantissa;\n+\n+         N, D : Big_Integer;\n+\n       begin\n-         --  Use Long_Long_Unsigned'Width - 1 digits = 20 which is sufficient\n-         --  for the largest floating point format.\n+         pragma Assert (Num'Machine_Radix = 2);\n+         --  This implementation does not handle radix 16\n+\n+         pragma Assert (M <= 64);\n+         --  This implementation handles only 80-bit IEEE Extended or smaller\n+\n+         N := Conv.To_Big_Integer (Long_Long_Unsigned (F * 2.0**M));\n+\n+         --  If E is smaller than M, the denominator is 2**(M-E)\n+\n+         if E < M then\n+            D := To_Big_Integer (2) ** (M - E);\n+\n+         --  Or else, if E is larger than M, multiply the numerator by 2**(E-M)\n+\n+         elsif E > M then\n+            N := N * To_Big_Integer (2) ** (E - M);\n+            D := To_Big_Integer (1);\n+\n+         --  Otherwise E is equal to M and the result is just N\n+\n+         else\n+            D := To_Big_Integer (1);\n+         end if;\n \n-         Set_Image_Real\n-           (Long_Long_Float (Arg), S, P, Fore => 1, Aft => 20, Exp => 5);\n-         return From_String (S (1 .. P));\n+         return (if Arg >= 0.0 then N / D else -N / D);\n       end To_Big_Real;\n \n       -------------------\n       -- From_Big_Real --\n       -------------------\n \n+      --  We get the (Frac, Exp) representation of the real number by finding\n+      --  the exponent E such that it lies in the range [2.0**(E-1)..2.0**E),\n+      --  multiplying the number by 2.0**(M-E) with M the size of the mantissa,\n+      --  and converting the result to integer N in the range [2**(M-1)..2**M)\n+      --  with rounding to nearest, ties to even, and finally call Num'Compose.\n+      --  This does not apply to the zero, for which we return 0.0 early.\n+\n       function From_Big_Real (Arg : Big_Real) return Num is\n+\n+         package Conv is new\n+           Big_Integers.Unsigned_Conversions (Long_Long_Unsigned);\n+\n+         M    : constant Natural     := Num'Machine_Mantissa;\n+         One  : constant Big_Real    := To_Real (1);\n+         Two  : constant Big_Real    := To_Real (2);\n+         Half : constant Big_Real    := One / Two;\n+         TwoI : constant Big_Integer := To_Big_Integer (2);\n+\n+         function Log2_Estimate (V : Big_Real) return Natural;\n+         --  Return an integer not larger than Log2 (V) for V >= 1.0\n+\n+         function Minus_Log2_Estimate (V : Big_Real) return Natural;\n+         --  Return an integer not larger than -Log2 (V) for V < 1.0\n+\n+         -------------------\n+         -- Log2_Estimate --\n+         -------------------\n+\n+         function Log2_Estimate (V : Big_Real) return Natural is\n+            Log : Natural  := 1;\n+            Pow : Big_Real := Two;\n+\n+         begin\n+            while V >= Pow loop\n+               Pow := Pow * Pow;\n+               Log := Log + Log;\n+            end loop;\n+\n+            return Log / 2;\n+         end Log2_Estimate;\n+\n+         -------------------------\n+         -- Minus_Log2_Estimate --\n+         -------------------------\n+\n+         function Minus_Log2_Estimate (V : Big_Real) return Natural is\n+            Log : Natural  := 1;\n+            Pow : Big_Real := Half;\n+\n+         begin\n+            while V <= Pow loop\n+               Pow := Pow * Pow;\n+               Log := Log + Log;\n+            end loop;\n+\n+            return Log / 2;\n+         end Minus_Log2_Estimate;\n+\n+         --  Local variables\n+\n+         V : Big_Real := abs (Arg);\n+         E : Integer  := 0;\n+         L : Integer;\n+\n+         A, B, Q, X : Big_Integer;\n+         N          : Long_Long_Unsigned;\n+         R          : Num'Base;\n+\n       begin\n-         return Num'Value (To_String (Arg));\n+         pragma Assert (Num'Machine_Radix = 2);\n+         --  This implementation does not handle radix 16\n+\n+         pragma Assert (M <= 64);\n+         --  This implementation handles only 80-bit IEEE Extended or smaller\n+\n+         --  Protect from degenerate case\n+\n+         if Numerator (V) = To_Big_Integer (0) then\n+            return 0.0;\n+         end if;\n+\n+         --  Use a binary search to compute exponent E\n+\n+         while V < Half loop\n+            L := Minus_Log2_Estimate (V);\n+            V := V * (Two ** L);\n+            E := E - L;\n+         end loop;\n+\n+         --  The dissymetry with above is expected since we go below 2\n+\n+         while V >= One loop\n+            L := Log2_Estimate (V) + 1;\n+            V := V / (Two ** L);\n+            E := E + L;\n+         end loop;\n+\n+         --  The multiplication by 2.0**(-E) has already been done in the loops\n+\n+         V := V * To_Big_Real (TwoI ** M);\n+\n+         --  Now go into the integer domain and divide\n+\n+         A := Numerator (V);\n+         B := Denominator (V);\n+\n+         Q := A / B;\n+         N := Conv.From_Big_Integer (Q);\n+\n+         --  Round to nearest, ties to even, by comparing twice the remainder\n+\n+         X := (A - Q * B) * TwoI;\n+\n+         if X > B or else (X = B and then (N mod 2) = 1) then\n+            N := N + 1;\n+\n+            --  If the adjusted quotient overflows the mantissa, scale up\n+\n+            if N = 2**M then\n+               N := 1;\n+               E := E + 1;\n+            end if;\n+         end if;\n+\n+         R := Num'Compose (Num'Base (N), E);\n+\n+         return (if Numerator (Arg) >= To_Big_Integer (0) then R else -R);\n       end From_Big_Real;\n \n    end Float_Conversions;"}]}