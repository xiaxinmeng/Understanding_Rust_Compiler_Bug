{"sha": "b6bbd675eb31f35a014ef560bb661eead09b2a44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZiYmQ2NzVlYjMxZjM1YTAxNGVmNTYwYmI2NjFlZWFkMDliMmE0NA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2006-03-21T17:27:56Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2006-03-21T17:27:56Z"}, "message": "genautomata.c (<struct state>, [...]): New members.\n\n\t* genautomata.c (<struct state>, num_out_arcs, presence_signature):\n\tNew members.\n\t(remove_arc, add_arc): Update num_out_arcs member.\n\t(set_out_arc_insns_equiv_num): Returns nothing instead of number\n\tof out arcs.\n\t(cache_presence): New function.\n\t(compare_states_for_equiv): New function.\n\t(state_is_differed): Don't take number of outargs, adjust callers.\n\tUse new invariant for speeding up.\n\t(init_equiv_class): Create initial classes based on sorted\n\tinput.\n\t(partition_equiv_class): Don't track out_arcs_num.\n\t(evaluate_equiv_classes): Call cache_presence on all states and\n\tsort them.\n\nFrom-SVN: r112252", "tree": {"sha": "1658aad3a2b53d9f3b50fbf5308eb57a90459789", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1658aad3a2b53d9f3b50fbf5308eb57a90459789"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6bbd675eb31f35a014ef560bb661eead09b2a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6bbd675eb31f35a014ef560bb661eead09b2a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6bbd675eb31f35a014ef560bb661eead09b2a44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6bbd675eb31f35a014ef560bb661eead09b2a44/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fae2b46b091f4feb984ac9c51dd543f257d9dc94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae2b46b091f4feb984ac9c51dd543f257d9dc94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fae2b46b091f4feb984ac9c51dd543f257d9dc94"}], "stats": {"total": 150, "additions": 112, "deletions": 38}, "files": [{"sha": "4e910bc13a7e15f5f8cb10dbc37f3a60843b6bde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6bbd675eb31f35a014ef560bb661eead09b2a44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6bbd675eb31f35a014ef560bb661eead09b2a44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6bbd675eb31f35a014ef560bb661eead09b2a44", "patch": "@@ -1,3 +1,20 @@\n+2006-03-21  Michael Matz  <matz@suse.de>\n+\n+\t* genautomata.c (<struct state>, num_out_arcs, presence_signature):\n+\tNew members.\n+\t(remove_arc, add_arc): Update num_out_arcs member.\n+\t(set_out_arc_insns_equiv_num): Returns nothing instead of number\n+\tof out arcs.\n+\t(cache_presence): New function.\n+\t(compare_states_for_equiv): New function.\n+\t(state_is_differed): Don't take number of outargs, adjust callers.\n+\tUse new invariant for speeding up.\n+\t(init_equiv_class): Create initial classes based on sorted\n+\tinput.\n+\t(partition_equiv_class): Don't track out_arcs_num.\n+\t(evaluate_equiv_classes): Call cache_presence on all states and\n+\tsort them.\n+\n 2006-03-21  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin-protos.h (bfin_dsp_memref_p): Declare."}, {"sha": "fd8edebcea84644be6231b21526d513a5295bb4c", "filename": "gcc/genautomata.c", "status": "modified", "additions": 95, "deletions": 38, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6bbd675eb31f35a014ef560bb661eead09b2a44/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6bbd675eb31f35a014ef560bb661eead09b2a44/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=b6bbd675eb31f35a014ef560bb661eead09b2a44", "patch": "@@ -677,6 +677,7 @@ struct state\n   /* The following field value is the first arc output from given\n      state.  */\n   arc_t first_out_arc;\n+  unsigned int num_out_arcs;\n   /* The following field is used to form NDFA.  */\n   char it_was_placed_in_stack_for_NDFA_forming;\n   /* The following field is used to form DFA.  */\n@@ -700,6 +701,7 @@ struct state\n      automaton.  The field value is state corresponding to equivalence\n      class to which given state belongs.  */\n   state_t equiv_class_state;\n+  unsigned int *presence_signature;\n   /* The following field value is the order number of given state.\n      The states in final DFA is enumerated with the aid of the\n      following field.  */\n@@ -3862,6 +3864,7 @@ remove_arc (state_t from_state, arc_t arc)\n     from_state->first_out_arc = arc->next_out_arc;\n   else\n     prev_arc->next_out_arc = arc->next_out_arc;\n+  from_state->num_out_arcs--;\n   free_arc (arc);\n }\n \n@@ -3908,6 +3911,7 @@ add_arc (state_t from_state, state_t to_state, ainsn_t ainsn)\n   ainsn->arc_exists_p = 1;\n   new_arc->next_out_arc = from_state->first_out_arc;\n   from_state->first_out_arc = new_arc;\n+  from_state->num_out_arcs++;\n   new_arc->next_arc_marked_by_insn = NULL;\n   return new_arc;\n }\n@@ -5614,24 +5618,20 @@ add_achieved_state (state_t state)\n    out arcs of STATE by equiv_class_num_1 (if ODD_ITERATION_FLAG has\n    nonzero value) or by equiv_class_num_2 of the destination state.\n    The function returns number of out arcs of STATE.  */\n-static int\n+static void\n set_out_arc_insns_equiv_num (state_t state, int odd_iteration_flag)\n {\n-  int state_out_arcs_num;\n   arc_t arc;\n \n-  state_out_arcs_num = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n       gcc_assert (!arc->insn->insn_reserv_decl->equiv_class_num);\n-      state_out_arcs_num++;\n       arc->insn->insn_reserv_decl->equiv_class_num\n \t= (odd_iteration_flag\n            ? arc->to_state->equiv_class_num_1\n \t   : arc->to_state->equiv_class_num_2);\n       gcc_assert (arc->insn->insn_reserv_decl->equiv_class_num);\n     }\n-  return state_out_arcs_num;\n }\n \n /* The function clears equivalence numbers and alt_states in all insns\n@@ -5666,59 +5666,116 @@ first_cycle_unit_presence (state_t state, int unit_num)\n   return false;\n }\n \n+/* This fills in the presence_signature[] member of STATE.  */\n+static void\n+cache_presence (state_t state)\n+{\n+  int i, num = 0;\n+  unsigned int sz;\n+  sz = (description->query_units_num + sizeof (int) * CHAR_BIT - 1)\n+        / (sizeof (int) * CHAR_BIT);\n+  \n+  state->presence_signature = create_node (sz * sizeof (int));\n+  for (i = 0; i < description->units_num; i++)\n+    if (units_array [i]->query_p)\n+      {\n+\tint presence1_p = first_cycle_unit_presence (state, i);\n+\tstate->presence_signature[num / (sizeof (int) * CHAR_BIT)]\n+\t  |= (!!presence1_p) << (num % (sizeof (int) * CHAR_BIT));\n+\tnum++;\n+      }\n+}\n+\n /* The function returns nonzero value if STATE is not equivalent to\n    ANOTHER_STATE from the same current partition on equivalence\n    classes.  Another state has ANOTHER_STATE_OUT_ARCS_NUM number of\n    output arcs.  Iteration of making equivalence partition is defined\n    by ODD_ITERATION_FLAG.  */\n static int\n state_is_differed (state_t state, state_t another_state,\n-\t\t   int another_state_out_arcs_num, int odd_iteration_flag)\n+\t\t   int odd_iteration_flag)\n {\n   arc_t arc;\n-  int state_out_arcs_num;\n-  int i, presence1_p, presence2_p;\n+  unsigned int sz, si;\n+\n+  gcc_assert (state->num_out_arcs == another_state->num_out_arcs);\n+\n+  sz = (description->query_units_num + sizeof (int) * CHAR_BIT - 1)\n+\t/ (sizeof (int) * CHAR_BIT);\n+\n+  for (si = 0; si < sz; si++)\n+    gcc_assert (state->presence_signature[si]\n+\t\t== another_state->presence_signature[si]);\n \n-  state_out_arcs_num = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n-      state_out_arcs_num++;\n       if ((odd_iteration_flag\n            ? arc->to_state->equiv_class_num_1\n \t   : arc->to_state->equiv_class_num_2)\n           != arc->insn->insn_reserv_decl->equiv_class_num)\n         return 1;\n     }\n-  if (state_out_arcs_num != another_state_out_arcs_num)\n+\n+  return 0;\n+}\n+\n+/* Compares two states pointed to by STATE_PTR_1 and STATE_PTR_2\n+   and return -1, 0 or 1.  This function can be used as predicate for\n+   qsort().  It requires the member presence_signature[] of both\n+   states be filled.  */\n+static int\n+compare_states_for_equiv (const void *state_ptr_1,\n+\t\t\t  const void *state_ptr_2)\n+{\n+  state_t s1 = *(state_t *)state_ptr_1;\n+  state_t s2 = *(state_t *)state_ptr_2;\n+  unsigned int sz, si;\n+  if (s1->num_out_arcs < s2->num_out_arcs)\n+    return -1;\n+  else if (s1->num_out_arcs > s2->num_out_arcs)\n     return 1;\n-  /* Now we are looking at the states with the point of view of query\n-     units.  */\n-  for (i = 0; i < description->units_num; i++)\n-    if (units_array [i]->query_p)\n-      {\n-\tpresence1_p = first_cycle_unit_presence (state, i);\n-\tpresence2_p = first_cycle_unit_presence (another_state, i);\n-\tif ((presence1_p && !presence2_p) || (!presence1_p && presence2_p))\n-\t  return 1;\n-      }\n+\n+  sz = (description->query_units_num + sizeof (int) * CHAR_BIT - 1)\n+\t/ (sizeof (int) * CHAR_BIT);\n+\n+  for (si = 0; si < sz; si++)\n+    if (s1->presence_signature[si] < s2->presence_signature[si])\n+      return -1;\n+    else if (s1->presence_signature[si] > s2->presence_signature[si])\n+      return 1;\n   return 0;\n }\n \n /* The function makes initial partition of STATES on equivalent\n-   classes.  */\n-static state_t\n-init_equiv_class (VEC(state_t,heap) *states)\n+   classes and saves it into *CLASSES.  This function requires the input\n+   to be sorted via compare_states_for_equiv().  */\n+static int\n+init_equiv_class (VEC(state_t,heap) *states, VEC (state_t,heap) **classes)\n {\n   size_t i;\n   state_t prev = 0;\n+  int class_num = 1;\n \n+  *classes = VEC_alloc (state_t,heap, 150);\n   for (i = 0; i < VEC_length (state_t, states); i++)\n     {\n-      VEC_index (state_t, states, i)->equiv_class_num_1 = 1;\n-      VEC_index (state_t, states, i)->next_equiv_class_state = prev;\n-      prev = VEC_index (state_t, states, i);\n+      state_t state = VEC_index (state_t, states, i);\n+      if (prev)\n+        {\n+\t  if (compare_states_for_equiv (&prev, &state) != 0)\n+\t    {\n+\t      VEC_safe_push (state_t,heap, *classes, prev);\n+\t      class_num++;\n+\t      prev = NULL;\n+\t    }\n+        }\n+      state->equiv_class_num_1 = class_num;\n+      state->next_equiv_class_state = prev;\n+      prev = state;\n     }\n-  return prev;\n+  if (prev)\n+    VEC_safe_push (state_t,heap, *classes, prev);\n+  return class_num;\n }\n \n /* The function copies pointers to equivalent states from vla FROM\n@@ -5729,6 +5786,7 @@ copy_equiv_class (VEC(state_t,heap) **to, VEC(state_t,heap) *from)\n   VEC_free (state_t,heap, *to);\n   *to = VEC_copy (state_t,heap, from);\n }\n+\n /* The function processes equivalence class given by its first state,\n    FIRST_STATE, on odd iteration if ODD_ITERATION_FLAG.  If there\n    are not equivalent states, the function partitions the class\n@@ -5746,7 +5804,6 @@ partition_equiv_class (state_t first_state, int odd_iteration_flag,\n   state_t curr_state;\n   state_t prev_state;\n   state_t next_state;\n-  int out_arcs_num;\n \n   partition_p = 0;\n \n@@ -5756,15 +5813,14 @@ partition_equiv_class (state_t first_state, int odd_iteration_flag,\n       if (first_state->next_equiv_class_state != NULL)\n \t{\n \t  /* There are more one states in the class equivalence.  */\n-\t  out_arcs_num = set_out_arc_insns_equiv_num (first_state,\n-\t\t\t\t\t\t      odd_iteration_flag);\n+\t  set_out_arc_insns_equiv_num (first_state, odd_iteration_flag);\n \t  for (prev_state = first_state,\n \t\t curr_state = first_state->next_equiv_class_state;\n \t       curr_state != NULL;\n \t       curr_state = next_state)\n \t    {\n \t      next_state = curr_state->next_equiv_class_state;\n-\t      if (state_is_differed (curr_state, first_state, out_arcs_num,\n+\t      if (state_is_differed (curr_state, first_state, \n \t\t\t\t     odd_iteration_flag))\n \t\t{\n \t\t  /* Remove curr state from the class equivalence.  */\n@@ -5797,7 +5853,6 @@ static void\n evaluate_equiv_classes (automaton_t automaton,\n \t\t\tVEC(state_t,heap) **equiv_classes)\n {\n-  state_t new_equiv_class;\n   int new_equiv_class_num;\n   int odd_iteration_flag;\n   int finish_flag;\n@@ -5806,12 +5861,14 @@ evaluate_equiv_classes (automaton_t automaton,\n \n   all_achieved_states = VEC_alloc (state_t,heap, 1500);\n   pass_states (automaton, add_achieved_state);\n-  new_equiv_class = init_equiv_class (all_achieved_states);\n-  odd_iteration_flag = 0;\n-  new_equiv_class_num = 1;\n+  pass_states (automaton, cache_presence);\n+  qsort (VEC_address (state_t, all_achieved_states),\n+\t VEC_length (state_t, all_achieved_states),\n+         sizeof (state_t), compare_states_for_equiv);\n \n-  next_iteration_classes = VEC_alloc (state_t,heap, 150);\n-  VEC_quick_push (state_t, next_iteration_classes, new_equiv_class);\n+  odd_iteration_flag = 0;\n+  new_equiv_class_num = init_equiv_class (all_achieved_states,\n+  \t\t\t\t\t  &next_iteration_classes);\n \n   do\n     {"}]}