{"sha": "429ad0bb0d3dc77e44f95620341da4938d49168e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5YWQwYmIwZDNkYzc3ZTQ0Zjk1NjIwMzQxZGE0OTM4ZDQ5MTY4ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-15T09:55:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-16T06:28:37Z"}, "message": "tree-optimization/97428 - split SLP groups for loop vectorization\n\nThis enables SLP store group splitting also for loop vectorization.\nFor the existing testcase gcc.dg/vect/vect-complex-5.c this then\ngenerates much better code, likewise for the PR97428 testcase.\n\nBoth of those have a splitting opportunity splitting the group\ninto two equal (vector-sized) halves, still the patch enables\nquite arbitrary splitting since generally the interleaving scheme\nresults in quite awkward code for even small groups.  If any\nproblems surface with this it's easy to restrict the splitting\nto known-good cases.\n\n2020-10-15  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97428\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Split store\n\tgroups also for loop vectorization.\n\n\t* gcc.dg/vect/vect-complex-5.c: Expect to SLP.\n\t* gcc.dg/vect/pr97428.c: Likewise.", "tree": {"sha": "345c1f41c854325692c2a9e1b6b6c8cb40dd8dd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/345c1f41c854325692c2a9e1b6b6c8cb40dd8dd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/429ad0bb0d3dc77e44f95620341da4938d49168e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429ad0bb0d3dc77e44f95620341da4938d49168e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429ad0bb0d3dc77e44f95620341da4938d49168e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429ad0bb0d3dc77e44f95620341da4938d49168e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85d5dc58359ba6f12407861bb50af5e503f89e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b85d5dc58359ba6f12407861bb50af5e503f89e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b85d5dc58359ba6f12407861bb50af5e503f89e4"}], "stats": {"total": 49, "additions": 40, "deletions": 9}, "files": [{"sha": "49d537382564a444cae1fad154b7ffa25e42b73b", "filename": "gcc/testsuite/gcc.dg/vect/pr97428.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ad0bb0d3dc77e44f95620341da4938d49168e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97428.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ad0bb0d3dc77e44f95620341da4938d49168e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97428.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr97428.c?ref=429ad0bb0d3dc77e44f95620341da4938d49168e", "patch": "@@ -40,4 +40,5 @@ void foo_i2(dcmlx4_t dst[], const dcmlx_t src[], int n)\n    load and store groups.  */\n /* { dg-final { scan-tree-dump \"Detected interleaving load of size 8\" \"vect\" } } */\n /* { dg-final { scan-tree-dump \"Detected interleaving store of size 16\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" } } */\n /* { dg-final { scan-tree-dump-not \"gap of 6 elements\" \"vect\" } } */"}, {"sha": "0648637544906e8ac5e2976a5addb08b5aafb650", "filename": "gcc/testsuite/gcc.dg/vect/vect-complex-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ad0bb0d3dc77e44f95620341da4938d49168e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-complex-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ad0bb0d3dc77e44f95620341da4938d49168e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-complex-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-complex-5.c?ref=429ad0bb0d3dc77e44f95620341da4938d49168e", "patch": "@@ -40,4 +40,4 @@ main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" } } */"}, {"sha": "8037b27cddd556a78f19fd800b82414177012d91", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/429ad0bb0d3dc77e44f95620341da4938d49168e/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/429ad0bb0d3dc77e44f95620341da4938d49168e/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=429ad0bb0d3dc77e44f95620341da4938d49168e", "patch": "@@ -2244,20 +2244,20 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       scalar_stmts.release ();\n     }\n \n-  /* For basic block SLP, try to break the group up into multiples of the\n-     vector size.  */\n+  /* Try to break the group up into pieces.  */\n   unsigned HOST_WIDE_INT const_nunits;\n-  if (is_a <bb_vec_info> (vinfo)\n-      && STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n       && DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info))\n       && nunits.is_constant (&const_nunits))\n     {\n-      /* We consider breaking the group only on VF boundaries from the existing\n-\t start.  */\n       for (i = 0; i < group_size; i++)\n-\tif (!matches[i]) break;\n+\tif (!matches[i])\n+\t  break;\n \n-      if (i >= const_nunits && i < group_size)\n+      /* For basic block SLP, try to break the group up into multiples of the\n+\t vector size.  */\n+      if (is_a <bb_vec_info> (vinfo)\n+\t  && (i >= const_nunits && i < group_size))\n \t{\n \t  /* Split into two groups at the first vector boundary before i.  */\n \t  gcc_assert ((const_nunits & (const_nunits - 1)) == 0);\n@@ -2284,6 +2284,36 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t\t\t      rest, max_tree_size);\n \t  return res;\n \t}\n+\n+      /* For loop vectorization split into arbitrary pieces of size > 1.  */\n+      if (is_a <loop_vec_info> (vinfo)\n+\t  && (i > 1 && i < group_size))\n+\t{\n+\t  gcc_assert ((const_nunits & (const_nunits - 1)) == 0);\n+\t  unsigned group1_size = i;\n+\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Splitting SLP group at stmt %u\\n\", i);\n+\n+\t  stmt_vec_info rest = vect_split_slp_store_group (stmt_info,\n+\t\t\t\t\t\t\t   group1_size);\n+\t  /* Loop vectorization cannot handle gaps in stores, make sure\n+\t     the split group appears as strided.  */\n+\t  STMT_VINFO_STRIDED_P (rest) = 1;\n+\t  DR_GROUP_GAP (rest) = 0;\n+\t  STMT_VINFO_STRIDED_P (stmt_info) = 1;\n+\t  DR_GROUP_GAP (stmt_info) = 0;\n+\n+\t  bool res = vect_analyze_slp_instance (vinfo, bst_map, stmt_info,\n+\t\t\t\t\t\tmax_tree_size);\n+\t  if (i + 1 < group_size)\n+\t    res |= vect_analyze_slp_instance (vinfo, bst_map,\n+\t\t\t\t\t      rest, max_tree_size);\n+\n+\t  return res;\n+\t}\n+\n       /* Even though the first vector did not all match, we might be able to SLP\n \t (some) of the remainder.  FORNOW ignore this possibility.  */\n     }"}]}