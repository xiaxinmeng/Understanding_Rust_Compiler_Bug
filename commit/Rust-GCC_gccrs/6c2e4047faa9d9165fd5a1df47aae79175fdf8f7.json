{"sha": "6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMyZTQwNDdmYWE5ZDkxNjVmZDVhMWRmNDdhYWU3OTE3NWZkZjhmNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:13:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:13:49Z"}, "message": "[multiple changes]\n\n2013-04-11  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb (\"=\"): Increment\n\tlock counts before entering loop.\n\t(Find): Ditto.\n\t(Is_Sorted, Merge, Sort): Ditto.\n\t(Reverse_Find): Ditto.\n\t(Splice_Internal): Internal operation to refactor splicing logic.\n\t(Splice): Some logic moved into Splice_Internal.\n\n2013-04-11  Johannes Kanig  <kanig@adacore.com>\n\n\t* adabkend.adb (Scan_Compiler_Arguments): Do not call\n\tSet_Output_Object_File_Name in Alfa_Mode\n\t* gnat1drv.adb (Adjust_Global_Switches): Take Alfa_Mode into account.\n\t* opt.ads: Fix documentation.\n\nFrom-SVN: r197771", "tree": {"sha": "cb0abcc9be745c942ff19a83eb157a597a5baa74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb0abcc9be745c942ff19a83eb157a597a5baa74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/comments", "author": null, "committer": null, "parents": [{"sha": "dff5c591489002baaf73dc8b93dcf22cd53a559e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff5c591489002baaf73dc8b93dcf22cd53a559e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff5c591489002baaf73dc8b93dcf22cd53a559e"}], "stats": {"total": 1363, "additions": 1056, "deletions": 307}, "files": [{"sha": "0d54e5e135c36f757eb53a45f6e962a6be3c5e49", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "patch": "@@ -1,3 +1,20 @@\n+2013-04-11  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb (\"=\"): Increment\n+\tlock counts before entering loop.\n+\t(Find): Ditto.\n+\t(Is_Sorted, Merge, Sort): Ditto.\n+\t(Reverse_Find): Ditto.\n+\t(Splice_Internal): Internal operation to refactor splicing logic.\n+\t(Splice): Some logic moved into Splice_Internal.\n+\n+2013-04-11  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* adabkend.adb (Scan_Compiler_Arguments): Do not call\n+\tSet_Output_Object_File_Name in Alfa_Mode\n+\t* gnat1drv.adb (Adjust_Global_Switches): Take Alfa_Mode into account.\n+\t* opt.ads: Fix documentation.\n+\n 2013-04-11  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_res.adb: Minor code reorganization and comment fixes."}, {"sha": "1c25022301051ffbb3e0f89b366f739fbe9e1577", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 366, "deletions": 66, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -80,6 +80,18 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Before    : Count_Type;\n       New_Node  : Count_Type);\n \n+   procedure Splice_Internal\n+     (Target : in out List;\n+      Before : Count_Type;\n+      Source : in out List);\n+\n+   procedure Splice_Internal\n+     (Target  : in out List;\n+      Before  : Count_Type;\n+      Source  : in out List;\n+      Src_Pos : Count_Type;\n+      Tgt_Pos : out Count_Type);\n+\n    function Vet (Position : Cursor) return Boolean;\n    --  Checks invariants of the cursor and its designated container, as a\n    --  simple way of detecting dangling references (see operation Free for a\n@@ -92,10 +104,19 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n       LN : Node_Array renames Left.Nodes;\n       RN : Node_Array renames Right.Nodes;\n \n-      LI, RI : Count_Type;\n+      LI : Count_Type;\n+      RI : Count_Type;\n+\n+      Result : Boolean;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -106,18 +127,44 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n       LI := Left.First;\n       RI := Right.First;\n+      Result := True;\n       for J in 1 .. Left.Length loop\n          if LN (LI).Element /= RN (RI).Element then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n \n          LI := LN (LI).Next;\n          RI := RN (RI).Next;\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end \"=\";\n \n    --------------\n@@ -570,15 +617,43 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n-      while Node /= 0 loop\n-         if Nodes (Node).Element = Item then\n-            return Cursor'(Container'Unrestricted_Access, Node);\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         Node := Nodes (Node).Next;\n-      end loop;\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Count_Type;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n \n-      return No_Element;\n+         Result := 0;\n+         while Node /= 0 loop\n+            if Nodes (Node).Element = Item then\n+               Result := Node;\n+               exit;\n+            end if;\n+\n+            Node := Nodes (Node).Next;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = 0 then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n+         end if;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Find;\n \n    -----------\n@@ -753,19 +828,41 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       ---------------\n \n       function Is_Sorted (Container : List) return Boolean is\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n          Nodes : Node_Array renames Container.Nodes;\n-         Node  : Count_Type := Container.First;\n+         Node  : Count_Type;\n+\n+         Result : Boolean;\n \n       begin\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Node := Container.First;\n+         Result := True;\n          for J in 2 .. Container.Length loop\n             if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n-               return False;\n+               Result := False;\n+               exit;\n             end if;\n \n             Node := Nodes (Node).Next;\n          end loop;\n \n-         return True;\n+         B := B - 1;\n+         L := L - 1;\n+\n+         return Result;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n       end Is_Sorted;\n \n       -----------\n@@ -776,12 +873,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n         (Target : in out List;\n          Source : in out List)\n       is\n-         LN     : Node_Array renames Target.Nodes;\n-         RN     : Node_Array renames Source.Nodes;\n-         LI, RI : Cursor;\n-\n       begin\n-\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -799,6 +891,14 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n               \"Target and Source denote same non-empty container\";\n          end if;\n \n+         if Target.Length > Count_Type'Last - Source.Length then\n+            raise Constraint_Error with \"new length exceeds maximum\";\n+         end if;\n+\n+         if Target.Length + Source.Length > Target.Capacity then\n+            raise Capacity_Error with \"new length exceeds target capacity\";\n+         end if;\n+\n          if Target.Busy > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors of Target (list is busy)\";\n@@ -809,34 +909,69 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n               \"attempt to tamper with cursors of Source (list is busy)\";\n          end if;\n \n-         LI := First (Target);\n-         RI := First (Source);\n-         while RI.Node /= 0 loop\n-            pragma Assert (RN (RI.Node).Next = 0\n-                             or else not (RN (RN (RI.Node).Next).Element <\n-                                          RN (RI.Node).Element));\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n-            if LI.Node = 0 then\n-               Splice (Target, No_Element, Source);\n-               return;\n-            end if;\n+         declare\n+            TB : Natural renames Target.Busy;\n+            TL : Natural renames Target.Lock;\n \n-            pragma Assert (LN (LI.Node).Next = 0\n-                             or else not (LN (LN (LI.Node).Next).Element <\n-                                          LN (LI.Node).Element));\n+            SB : Natural renames Source.Busy;\n+            SL : Natural renames Source.Lock;\n \n-            if RN (RI.Node).Element < LN (LI.Node).Element then\n-               declare\n-                  RJ : Cursor := RI;\n-               begin\n-                  RI.Node := RN (RI.Node).Next;\n-                  Splice (Target, LI, Source, RJ);\n-               end;\n+            LN : Node_Array renames Target.Nodes;\n+            RN : Node_Array renames Source.Nodes;\n \n-            else\n-               LI.Node := LN (LI.Node).Next;\n-            end if;\n-         end loop;\n+            LI, LJ, RI, RJ : Count_Type;\n+\n+         begin\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            LI := Target.First;\n+            RI := Source.First;\n+            while RI /= 0 loop\n+               pragma Assert (RN (RI).Next = 0\n+                                or else not (RN (RN (RI).Next).Element <\n+                                               RN (RI).Element));\n+\n+               if LI = 0 then\n+                  Splice_Internal (Target, 0, Source);\n+                  exit;\n+               end if;\n+\n+               pragma Assert (LN (LI).Next = 0\n+                                or else not (LN (LN (LI).Next).Element <\n+                                               LN (LI).Element));\n+\n+               if RN (RI).Element < LN (LI).Element then\n+                  RJ := RI;\n+                  RI := RN (RI).Next;\n+                  Splice_Internal (Target, LI, Source, RJ, LJ);\n+\n+               else\n+                  LI := LN (LI).Next;\n+               end if;\n+            end loop;\n+\n+            TB := TB - 1;\n+            TL := TL - 1;\n+\n+            SB := SB - 1;\n+            SL := SL - 1;\n+         exception\n+            when others =>\n+               TB := TB - 1;\n+               TL := TL - 1;\n+\n+               SB := SB - 1;\n+               SL := SL - 1;\n+\n+               raise;\n+         end;\n       end Merge;\n \n       ----------\n@@ -926,7 +1061,27 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n               \"attempt to tamper with cursors (list is busy)\";\n          end if;\n \n-         Sort (Front => 0, Back => 0);\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         declare\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Sort (Front => 0, Back => 0);\n+\n+            B := B - 1;\n+            L := L - 1;\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n \n          pragma Assert (N (Container.First).Prev = 0);\n          pragma Assert (N (Container.Last).Next = 0);\n@@ -1733,15 +1888,43 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n       end if;\n \n-      while Node /= 0 loop\n-         if Container.Nodes (Node).Element = Item then\n-            return Cursor'(Container'Unrestricted_Access, Node);\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         Node := Container.Nodes (Node).Prev;\n-      end loop;\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Count_Type;\n \n-      return No_Element;\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := 0;\n+         while Node /= 0 loop\n+            if Container.Nodes (Node).Element = Item then\n+               Result := Node;\n+               exit;\n+            end if;\n+\n+            Node := Container.Nodes (Node).Prev;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = 0 then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n+         end if;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Reverse_Find;\n \n    ---------------------\n@@ -1800,9 +1983,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      pragma Assert (Source.Nodes (Source.First).Prev = 0);\n-      pragma Assert (Source.Nodes (Source.Last).Next = 0);\n-\n       if Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n@@ -1821,10 +2001,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      while not Is_Empty (Source) loop\n-         Insert (Target, Before, Source.Nodes (Source.First).Element);\n-         Delete_First (Source);\n-      end loop;\n+      Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n    procedure Splice\n@@ -1937,7 +2114,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       Source   : in out List;\n       Position : in out Cursor)\n    is\n-      Target_Position : Cursor;\n+      Target_Position : Count_Type;\n \n    begin\n       if Target'Address = Source'Address then\n@@ -1979,16 +2156,139 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      Insert\n-        (Container => Target,\n-         Before    => Before,\n-         New_Item  => Source.Nodes (Position.Node).Element,\n-         Position  => Target_Position);\n+      Splice_Internal\n+        (Target  => Target,\n+         Before  => Before.Node,\n+         Source  => Source,\n+         Src_Pos => Position.Node,\n+         Tgt_Pos => Target_Position);\n \n-      Delete (Source, Position);\n-      Position := Target_Position;\n+      Position := Cursor'(Target'Unrestricted_Access, Target_Position);\n    end Splice;\n \n+   ---------------------\n+   -- Splice_Internal --\n+   ---------------------\n+\n+   procedure Splice_Internal\n+     (Target : in out List;\n+      Before : Count_Type;\n+      Source : in out List)\n+   is\n+      N : Node_Array renames Source.Nodes;\n+      X : Count_Type;\n+\n+   begin\n+      --  This implements the corresponding Splice operation, after the\n+      --  parameters have been vetted, and corner-cases disposed of.\n+\n+      pragma Assert (Target'Address /= Source'Address);\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First /= 0);\n+      pragma Assert (N (Source.First).Prev = 0);\n+      pragma Assert (Source.Last /= 0);\n+      pragma Assert (N (Source.Last).Next = 0);\n+      pragma Assert (Target.Length <= Count_Type'Last - Source.Length);\n+      pragma Assert (Target.Length + Source.Length <= Target.Capacity);\n+\n+      while Source.Length > 1 loop\n+         --  Copy first element of Source onto Target\n+\n+         Allocate (Target, N (Source.First).Element, New_Node => X);\n+         Insert_Internal (Target, Before => Before, New_Node => X);\n+\n+         --  Unlink the first node from Source\n+\n+         X := Source.First;\n+         pragma Assert (N (N (X).Next).Prev = X);\n+\n+         Source.First := N (X).Next;\n+         N (Source.First).Prev := 0;\n+\n+         Source.Length := Source.Length - 1;\n+\n+         --  Return the Source node to its free store\n+\n+         Free (Source, X);\n+      end loop;\n+\n+      --  Copy first (and only remaining) element of Source onto Target\n+\n+      Allocate (Target, N (Source.First).Element, New_Node => X);\n+      Insert_Internal (Target, Before => Before, New_Node => X);\n+\n+      --  Unlink the node from Source\n+\n+      X := Source.First;\n+      pragma Assert (X = Source.Last);\n+\n+      Source.First := 0;\n+      Source.Last := 0;\n+\n+      Source.Length := 0;\n+\n+      --  Return the Source node to its free store\n+\n+      Free (Source, X);\n+   end Splice_Internal;\n+\n+   procedure Splice_Internal\n+     (Target  : in out List;\n+      Before  : Count_Type;  -- node of Target\n+      Source  : in out List;\n+      Src_Pos : Count_Type;  -- node of Source\n+      Tgt_Pos : out Count_Type)\n+   is\n+      N : Node_Array renames Source.Nodes;\n+\n+   begin\n+      --  This implements the corresponding Splice operation, after the\n+      --  parameters have been vetted, and corner-cases handled.\n+\n+      pragma Assert (Target'Address /= Source'Address);\n+      pragma Assert (Target.Length < Target.Capacity);\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First /= 0);\n+      pragma Assert (N (Source.First).Prev = 0);\n+      pragma Assert (Source.Last /= 0);\n+      pragma Assert (N (Source.Last).Next = 0);\n+      pragma Assert (Src_Pos /= 0);\n+\n+      Allocate (Target, N (Src_Pos).Element, New_Node => Tgt_Pos);\n+      Insert_Internal (Target, Before => Before, New_Node => Tgt_Pos);\n+\n+      if Source.Length = 1 then\n+         pragma Assert (Source.First = Source.Last);\n+         pragma Assert (Src_Pos = Source.First);\n+\n+         Source.First := 0;\n+         Source.Last := 0;\n+\n+      elsif Src_Pos = Source.First then\n+         pragma Assert (N (N (Src_Pos).Next).Prev = Src_Pos);\n+\n+         Source.First := N (Src_Pos).Next;\n+         N (Source.First).Prev := 0;\n+\n+      elsif Src_Pos = Source.Last then\n+         pragma Assert (N (N (Src_Pos).Prev).Next = Src_Pos);\n+\n+         Source.Last := N (Src_Pos).Prev;\n+         N (Source.Last).Next := 0;\n+\n+      else\n+         pragma Assert (Source.Length >= 3);\n+         pragma Assert (N (N (Src_Pos).Next).Prev = Src_Pos);\n+         pragma Assert (N (N (Src_Pos).Prev).Next = Src_Pos);\n+\n+         N (N (Src_Pos).Next).Prev := N (Src_Pos).Prev;\n+         N (N (Src_Pos).Prev).Next := N (Src_Pos).Next;\n+      end if;\n+\n+      Source.Length := Source.Length - 1;\n+      Free (Source, Src_Pos);\n+   end Splice_Internal;\n+\n    ----------\n    -- Swap --\n    ----------"}, {"sha": "2fedd3c3b64a3e62001f30d7c08c55e1448990fe", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 334, "deletions": 119, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,6 +64,17 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Before    : Node_Access;\n       New_Node  : Node_Access);\n \n+   procedure Splice_Internal\n+     (Target : in out List;\n+      Before : Node_Access;\n+      Source : in out List);\n+\n+   procedure Splice_Internal\n+     (Target   : in out List;\n+      Before   : Node_Access;\n+      Source   : in out List;\n+      Position : Node_Access);\n+\n    function Vet (Position : Cursor) return Boolean;\n    --  Checks invariants of the cursor and its designated container, as a\n    --  simple way of detecting dangling references (see operation Free for a\n@@ -76,8 +87,15 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      L : Node_Access := Left.First;\n-      R : Node_Access := Right.First;\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+      L      : Node_Access;\n+      R      : Node_Access;\n+      Result : Boolean;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -88,16 +106,44 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n+      L := Left.First;\n+      R := Right.First;\n+      Result := True;\n       for J in 1 .. Left.Length loop\n          if L.Element /= R.Element then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n \n          L := L.Next;\n          R := R.Next;\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end \"=\";\n \n    ------------\n@@ -508,15 +554,43 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n-      while Node /= null loop\n-         if Node.Element = Item then\n-            return Cursor'(Container'Unrestricted_Access, Node);\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         Node := Node.Next;\n-      end loop;\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Node_Access;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := null;\n+         while Node /= null loop\n+            if Node.Element = Item then\n+               Result := Node;\n+               exit;\n+            end if;\n+\n+            Node := Node.Next;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n \n-      return No_Element;\n+         if Result = null then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n+         end if;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Find;\n \n    -----------\n@@ -606,18 +680,39 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       ---------------\n \n       function Is_Sorted (Container : List) return Boolean is\n-         Node : Node_Access := Container.First;\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Node   : Node_Access;\n+         Result : Boolean;\n \n       begin\n-         for I in 2 .. Container.Length loop\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Node := Container.First;\n+         Result := True;\n+         for Idx in 2 .. Container.Length loop\n             if Node.Next.Element < Node.Element then\n-               return False;\n+               Result := False;\n+               exit;\n             end if;\n \n             Node := Node.Next;\n          end loop;\n \n-         return True;\n+         B := B - 1;\n+         L := L - 1;\n+\n+         return Result;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n       end Is_Sorted;\n \n       -----------\n@@ -628,10 +723,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n         (Target : in out List;\n          Source : in out List)\n       is\n-         LI, RI : Cursor;\n-\n       begin\n-\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -649,6 +741,10 @@ package body Ada.Containers.Doubly_Linked_Lists is\n               \"Target and Source denote same non-empty container\";\n          end if;\n \n+         if Target.Length > Count_Type'Last - Source.Length then\n+            raise Constraint_Error with \"new length exceeds maximum\";\n+         end if;\n+\n          if Target.Busy > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors of Target (list is busy)\";\n@@ -659,35 +755,64 @@ package body Ada.Containers.Doubly_Linked_Lists is\n               \"attempt to tamper with cursors of Source (list is busy)\";\n          end if;\n \n-         LI := First (Target);\n-         RI := First (Source);\n-         while RI.Node /= null loop\n-            pragma Assert (RI.Node.Next = null\n-                             or else not (RI.Node.Next.Element <\n-                                          RI.Node.Element));\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n \n-            if LI.Node = null then\n-               Splice (Target, No_Element, Source);\n-               return;\n-            end if;\n+         declare\n+            TB : Natural renames Target.Busy;\n+            TL : Natural renames Target.Lock;\n \n-            pragma Assert (LI.Node.Next = null\n-                             or else not (LI.Node.Next.Element <\n-                                          LI.Node.Element));\n+            SB : Natural renames Source.Busy;\n+            SL : Natural renames Source.Lock;\n \n-            if RI.Node.Element < LI.Node.Element then\n-               declare\n-                  RJ : Cursor := RI;\n-                  pragma Warnings (Off, RJ);\n-               begin\n-                  RI.Node := RI.Node.Next;\n-                  Splice (Target, LI, Source, RJ);\n-               end;\n+            LI, RI, RJ : Node_Access;\n \n-            else\n-               LI.Node := LI.Node.Next;\n-            end if;\n-         end loop;\n+         begin\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            LI := Target.First;\n+            RI := Source.First;\n+            while RI /= null loop\n+               pragma Assert (RI.Next = null\n+                                or else not (RI.Next.Element < RI.Element));\n+\n+               if LI = null then\n+                  Splice_Internal (Target, null, Source);\n+                  exit;\n+               end if;\n+\n+               pragma Assert (LI.Next = null\n+                                or else not (LI.Next.Element < LI.Element));\n+\n+               if RI.Element < LI.Element then\n+                  RJ := RI;\n+                  RI := RI.Next;\n+                  Splice_Internal (Target, LI, Source, RJ);\n+\n+               else\n+                  LI := LI.Next;\n+               end if;\n+            end loop;\n+\n+            TB := TB - 1;\n+            TL := TL - 1;\n+\n+            SB := SB - 1;\n+            SL := SL - 1;\n+         exception\n+            when others =>\n+               TB := TB - 1;\n+               TL := TL - 1;\n+\n+               SB := SB - 1;\n+               SL := SL - 1;\n+\n+               raise;\n+         end;\n       end Merge;\n \n       ----------\n@@ -773,7 +898,27 @@ package body Ada.Containers.Doubly_Linked_Lists is\n               \"attempt to tamper with cursors (list is busy)\";\n          end if;\n \n-         Sort (Front => null, Back => null);\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         declare\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Sort (Front => null, Back => null);\n+\n+            B := B - 1;\n+            L := L - 1;\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n \n          pragma Assert (Container.First.Prev = null);\n          pragma Assert (Container.Last.Next = null);\n@@ -1533,15 +1678,43 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n       end if;\n \n-      while Node /= null loop\n-         if Node.Element = Item then\n-            return Cursor'(Container'Unrestricted_Access, Node);\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         Node := Node.Prev;\n-      end loop;\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Node_Access;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := null;\n+         while Node /= null loop\n+            if Node.Element = Item then\n+               Result := Node;\n+               exit;\n+            end if;\n \n-      return No_Element;\n+            Node := Node.Prev;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = null then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n+         end if;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Reverse_Find;\n \n    ---------------------\n@@ -1600,9 +1773,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      pragma Assert (Source.First.Prev = null);\n-      pragma Assert (Source.Last.Next = null);\n-\n       if Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n@@ -1617,45 +1787,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      if Target.Length = 0 then\n-         pragma Assert (Target.First = null);\n-         pragma Assert (Target.Last = null);\n-         pragma Assert (Before = No_Element);\n-\n-         Target.First := Source.First;\n-         Target.Last := Source.Last;\n-\n-      elsif Before.Node = null then\n-         pragma Assert (Target.Last.Next = null);\n-\n-         Target.Last.Next := Source.First;\n-         Source.First.Prev := Target.Last;\n-\n-         Target.Last := Source.Last;\n-\n-      elsif Before.Node = Target.First then\n-         pragma Assert (Target.First.Prev = null);\n-\n-         Source.Last.Next := Target.First;\n-         Target.First.Prev := Source.Last;\n-\n-         Target.First := Source.First;\n-\n-      else\n-         pragma Assert (Target.Length >= 2);\n-\n-         Before.Node.Prev.Next := Source.First;\n-         Source.First.Prev := Before.Node.Prev;\n-\n-         Before.Node.Prev := Source.Last;\n-         Source.Last.Next := Before.Node;\n-      end if;\n-\n-      Source.First := null;\n-      Source.Last := null;\n-\n-      Target.Length := Target.Length + Source.Length;\n-      Source.Length := 0;\n+      Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n    procedure Splice\n@@ -1806,10 +1938,95 @@ package body Ada.Containers.Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      if Position.Node = Source.First then\n-         Source.First := Position.Node.Next;\n+      Splice_Internal (Target, Before.Node, Source, Position.Node);\n+      Position.Container := Target'Unchecked_Access;\n+   end Splice;\n+\n+   ---------------------\n+   -- Splice_Internal --\n+   ---------------------\n+\n+   procedure Splice_Internal\n+     (Target : in out List;\n+      Before : Node_Access;\n+      Source : in out List)\n+   is\n+   begin\n+      --  This implements the corresponding Splice operation, after the\n+      --  parameters have been vetted, and corner-cases disposed of.\n+\n+      pragma Assert (Target'Address /= Source'Address);\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First /= null);\n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last /= null);\n+      pragma Assert (Source.Last.Next = null);\n+      pragma Assert (Target.Length <= Count_Type'Last - Source.Length);\n+\n+      if Target.Length = 0 then\n+         pragma Assert (Target.First = null);\n+         pragma Assert (Target.Last = null);\n+         pragma Assert (Before = null);\n+\n+         Target.First := Source.First;\n+         Target.Last := Source.Last;\n+\n+      elsif Before = null then\n+         pragma Assert (Target.Last.Next = null);\n+\n+         Target.Last.Next := Source.First;\n+         Source.First.Prev := Target.Last;\n+\n+         Target.Last := Source.Last;\n+\n+      elsif Before = Target.First then\n+         pragma Assert (Target.First.Prev = null);\n+\n+         Source.Last.Next := Target.First;\n+         Target.First.Prev := Source.Last;\n+\n+         Target.First := Source.First;\n+\n+      else\n+         pragma Assert (Target.Length >= 2);\n+\n+         Before.Prev.Next := Source.First;\n+         Source.First.Prev := Before.Prev;\n+\n+         Before.Prev := Source.Last;\n+         Source.Last.Next := Before;\n+      end if;\n+\n+      Source.First := null;\n+      Source.Last := null;\n+\n+      Target.Length := Target.Length + Source.Length;\n+      Source.Length := 0;\n+   end Splice_Internal;\n+\n+   procedure Splice_Internal\n+     (Target   : in out List;\n+      Before   : Node_Access;  -- node of Target\n+      Source   : in out List;\n+      Position : Node_Access)  -- node of Source\n+   is\n+   begin\n+      --  This implements the corresponding Splice operation, after the\n+      --  parameters have been vetted.\n+\n+      pragma Assert (Target'Address /= Source'Address);\n+      pragma Assert (Target.Length < Count_Type'Last);\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First /= null);\n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last /= null);\n+      pragma Assert (Source.Last.Next = null);\n+      pragma Assert (Position /= null);\n+\n+      if Position = Source.First then\n+         Source.First := Position.Next;\n \n-         if Position.Node = Source.Last then\n+         if Position = Source.Last then\n             pragma Assert (Source.First = null);\n             pragma Assert (Source.Length = 1);\n             Source.Last := null;\n@@ -1818,58 +2035,56 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             Source.First.Prev := null;\n          end if;\n \n-      elsif Position.Node = Source.Last then\n+      elsif Position = Source.Last then\n          pragma Assert (Source.Length >= 2);\n-         Source.Last := Position.Node.Prev;\n+         Source.Last := Position.Prev;\n          Source.Last.Next := null;\n \n       else\n          pragma Assert (Source.Length >= 3);\n-         Position.Node.Prev.Next := Position.Node.Next;\n-         Position.Node.Next.Prev := Position.Node.Prev;\n+         Position.Prev.Next := Position.Next;\n+         Position.Next.Prev := Position.Prev;\n       end if;\n \n       if Target.Length = 0 then\n          pragma Assert (Target.First = null);\n          pragma Assert (Target.Last = null);\n-         pragma Assert (Before = No_Element);\n+         pragma Assert (Before = null);\n \n-         Target.First := Position.Node;\n-         Target.Last := Position.Node;\n+         Target.First := Position;\n+         Target.Last := Position;\n \n          Target.First.Prev := null;\n          Target.Last.Next := null;\n \n-      elsif Before.Node = null then\n+      elsif Before = null then\n          pragma Assert (Target.Last.Next = null);\n-         Target.Last.Next := Position.Node;\n-         Position.Node.Prev := Target.Last;\n+         Target.Last.Next := Position;\n+         Position.Prev := Target.Last;\n \n-         Target.Last := Position.Node;\n+         Target.Last := Position;\n          Target.Last.Next := null;\n \n-      elsif Before.Node = Target.First then\n+      elsif Before = Target.First then\n          pragma Assert (Target.First.Prev = null);\n-         Target.First.Prev := Position.Node;\n-         Position.Node.Next := Target.First;\n+         Target.First.Prev := Position;\n+         Position.Next := Target.First;\n \n-         Target.First := Position.Node;\n+         Target.First := Position;\n          Target.First.Prev := null;\n \n       else\n          pragma Assert (Target.Length >= 2);\n-         Before.Node.Prev.Next := Position.Node;\n-         Position.Node.Prev := Before.Node.Prev;\n+         Before.Prev.Next := Position;\n+         Position.Prev := Before.Prev;\n \n-         Before.Node.Prev := Position.Node;\n-         Position.Node.Next := Before.Node;\n+         Before.Prev := Position;\n+         Position.Next := Before;\n       end if;\n \n       Target.Length := Target.Length + 1;\n       Source.Length := Source.Length - 1;\n-\n-      Position.Container := Target'Unchecked_Access;\n-   end Splice;\n+   end Splice_Internal;\n \n    ----------\n    -- Swap --"}, {"sha": "458df261c0651794ae8c950c249cd0a6269e6a58", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 331, "deletions": 119, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,6 +67,17 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Before    : Node_Access;\n       New_Node  : Node_Access);\n \n+   procedure Splice_Internal\n+     (Target : in out List;\n+      Before : Node_Access;\n+      Source : in out List);\n+\n+   procedure Splice_Internal\n+     (Target   : in out List;\n+      Before   : Node_Access;\n+      Source   : in out List;\n+      Position : Node_Access);\n+\n    function Vet (Position : Cursor) return Boolean;\n    --  Checks invariants of the cursor and its designated container, as a\n    --  simple way of detecting dangling references (see operation Free for a\n@@ -79,8 +90,15 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    ---------\n \n    function \"=\" (Left, Right : List) return Boolean is\n-      L : Node_Access;\n-      R : Node_Access;\n+      BL : Natural renames Left'Unrestricted_Access.Busy;\n+      LL : Natural renames Left'Unrestricted_Access.Lock;\n+\n+      BR : Natural renames Right'Unrestricted_Access.Busy;\n+      LR : Natural renames Right'Unrestricted_Access.Lock;\n+\n+      L      : Node_Access;\n+      R      : Node_Access;\n+      Result : Boolean;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -91,18 +109,44 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return False;\n       end if;\n \n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      BL := BL + 1;\n+      LL := LL + 1;\n+\n+      BR := BR + 1;\n+      LR := LR + 1;\n+\n       L := Left.First;\n       R := Right.First;\n+      Result := True;\n       for J in 1 .. Left.Length loop\n          if L.Element.all /= R.Element.all then\n-            return False;\n+            Result := False;\n+            exit;\n          end if;\n \n          L := L.Next;\n          R := R.Next;\n       end loop;\n \n-      return True;\n+      BL := BL - 1;\n+      LL := LL - 1;\n+\n+      BR := BR - 1;\n+      LR := LR - 1;\n+\n+      return Result;\n+   exception\n+      when others =>\n+         BL := BL - 1;\n+         LL := LL - 1;\n+\n+         BR := BR - 1;\n+         LR := LR - 1;\n+\n+         raise;\n    end \"=\";\n \n    ------------\n@@ -549,15 +593,43 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n-      while Node /= null loop\n-         if Node.Element.all = Item then\n-            return Cursor'(Container'Unrestricted_Access, Node);\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         Node := Node.Next;\n-      end loop;\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Node_Access;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := null;\n+         while Node /= null loop\n+            if Node.Element.all = Item then\n+               Result := Node;\n+               exit;\n+            end if;\n \n-      return No_Element;\n+            Node := Node.Next;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = null then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n+         end if;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Find;\n \n    -----------\n@@ -660,18 +732,39 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       ---------------\n \n       function Is_Sorted (Container : List) return Boolean is\n-         Node : Node_Access := Container.First;\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Node   : Node_Access;\n+         Result : Boolean;\n \n       begin\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Node := Container.First;\n+         Result := True;\n          for I in 2 .. Container.Length loop\n             if Node.Next.Element.all < Node.Element.all then\n-               return False;\n+               Result := False;\n+               exit;\n             end if;\n \n             Node := Node.Next;\n          end loop;\n \n-         return True;\n+         B := B - 1;\n+         L := L - 1;\n+\n+         return Result;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n       end Is_Sorted;\n \n       -----------\n@@ -682,10 +775,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n         (Target : in out List;\n          Source : in out List)\n       is\n-         LI, RI : Cursor;\n-\n       begin\n-\n          --  The semantics of Merge changed slightly per AI05-0021. It was\n          --  originally the case that if Target and Source denoted the same\n          --  container object, then the GNAT implementation of Merge did\n@@ -703,6 +793,10 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n               \"Target and Source denote same non-empty container\";\n          end if;\n \n+         if Target.Length > Count_Type'Last - Source.Length then\n+            raise Constraint_Error with \"new length exceeds maximum\";\n+         end if;\n+\n          if Target.Busy > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors of Target (list is busy)\";\n@@ -713,35 +807,63 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n               \"attempt to tamper with cursors of Source (list is busy)\";\n          end if;\n \n-         LI := First (Target);\n-         RI := First (Source);\n-         while RI.Node /= null loop\n-            pragma Assert (RI.Node.Next = null\n-                             or else not (RI.Node.Next.Element.all <\n-                                          RI.Node.Element.all));\n+         declare\n+            TB : Natural renames Target.Busy;\n+            TL : Natural renames Target.Lock;\n \n-            if LI.Node = null then\n-               Splice (Target, No_Element, Source);\n-               return;\n-            end if;\n+            SB : Natural renames Source.Busy;\n+            SL : Natural renames Source.Lock;\n \n-            pragma Assert (LI.Node.Next = null\n-                             or else not (LI.Node.Next.Element.all <\n-                                          LI.Node.Element.all));\n-\n-            if RI.Node.Element.all < LI.Node.Element.all then\n-               declare\n-                  RJ : Cursor := RI;\n-                  pragma Warnings (Off, RJ);\n-               begin\n-                  RI.Node := RI.Node.Next;\n-                  Splice (Target, LI, Source, RJ);\n-               end;\n-\n-            else\n-               LI.Node := LI.Node.Next;\n-            end if;\n-         end loop;\n+            LI, RI, RJ : Node_Access;\n+\n+         begin\n+            TB := TB + 1;\n+            TL := TL + 1;\n+\n+            SB := SB + 1;\n+            SL := SL + 1;\n+\n+            LI := Target.First;\n+            RI := Source.First;\n+            while RI /= null loop\n+               pragma Assert (RI.Next = null\n+                                or else not (RI.Next.Element.all <\n+                                               RI.Element.all));\n+\n+               if LI = null then\n+                  Splice_Internal (Target, null, Source);\n+                  exit;\n+               end if;\n+\n+               pragma Assert (LI.Next = null\n+                                or else not (LI.Next.Element.all <\n+                                               LI.Element.all));\n+\n+               if RI.Element.all < LI.Element.all then\n+                  RJ := RI;\n+                  RI := RI.Next;\n+                  Splice_Internal (Target, LI, Source, RJ);\n+\n+               else\n+                  LI := LI.Next;\n+               end if;\n+            end loop;\n+\n+            TB := TB - 1;\n+            TL := TL - 1;\n+\n+            SB := SB - 1;\n+            SL := SL - 1;\n+         exception\n+            when others =>\n+               TB := TB - 1;\n+               TL := TL - 1;\n+\n+               SB := SB - 1;\n+               SL := SL - 1;\n+\n+               raise;\n+         end;\n       end Merge;\n \n       ----------\n@@ -825,7 +947,27 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n               \"attempt to tamper with cursors (list is busy)\";\n          end if;\n \n-         Sort (Front => null, Back => null);\n+         --  Per AI05-0022, the container implementation is required to detect\n+         --  element tampering by a generic actual subprogram.\n+\n+         declare\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            Sort (Front => null, Back => null);\n+\n+            B := B - 1;\n+            L := L - 1;\n+         exception\n+            when others =>\n+               B := B - 1;\n+               L := L - 1;\n+               raise;\n+         end;\n \n          pragma Assert (Container.First.Prev = null);\n          pragma Assert (Container.Last.Next = null);\n@@ -1600,15 +1742,43 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n       end if;\n \n-      while Node /= null loop\n-         if Node.Element.all = Item then\n-            return Cursor'(Container'Unrestricted_Access, Node);\n-         end if;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n \n-         Node := Node.Prev;\n-      end loop;\n+      declare\n+         B : Natural renames Container'Unrestricted_Access.Busy;\n+         L : Natural renames Container'Unrestricted_Access.Lock;\n+\n+         Result : Node_Access;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         Result := null;\n+         while Node /= null loop\n+            if Node.Element.all = Item then\n+               Result := Node;\n+               exit;\n+            end if;\n \n-      return No_Element;\n+            Node := Node.Prev;\n+         end loop;\n+\n+         B := B - 1;\n+         L := L - 1;\n+\n+         if Result = null then\n+            return No_Element;\n+         else\n+            return Cursor'(Container'Unrestricted_Access, Result);\n+         end if;\n+      exception\n+         when others =>\n+            B := B - 1;\n+            L := L - 1;\n+            raise;\n+      end;\n    end Reverse_Find;\n \n    ---------------------\n@@ -1673,9 +1843,6 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      pragma Assert (Source.First.Prev = null);\n-      pragma Assert (Source.Last.Next = null);\n-\n       if Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n       end if;\n@@ -1690,44 +1857,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      if Target.Length = 0 then\n-         pragma Assert (Before = No_Element);\n-         pragma Assert (Target.First = null);\n-         pragma Assert (Target.Last = null);\n-\n-         Target.First := Source.First;\n-         Target.Last := Source.Last;\n-\n-      elsif Before.Node = null then\n-         pragma Assert (Target.Last.Next = null);\n-\n-         Target.Last.Next := Source.First;\n-         Source.First.Prev := Target.Last;\n-\n-         Target.Last := Source.Last;\n-\n-      elsif Before.Node = Target.First then\n-         pragma Assert (Target.First.Prev = null);\n-\n-         Source.Last.Next := Target.First;\n-         Target.First.Prev := Source.Last;\n-\n-         Target.First := Source.First;\n-\n-      else\n-         pragma Assert (Target.Length >= 2);\n-         Before.Node.Prev.Next := Source.First;\n-         Source.First.Prev := Before.Node.Prev;\n-\n-         Before.Node.Prev := Source.Last;\n-         Source.Last.Next := Before.Node;\n-      end if;\n-\n-      Source.First := null;\n-      Source.Last := null;\n-\n-      Target.Length := Target.Length + Source.Length;\n-      Source.Length := 0;\n+      Splice_Internal (Target, Before.Node, Source);\n    end Splice;\n \n    procedure Splice\n@@ -1901,10 +2031,94 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      if Position.Node = Source.First then\n-         Source.First := Position.Node.Next;\n+      Splice_Internal (Target, Before.Node, Source, Position.Node);\n+      Position.Container := Target'Unchecked_Access;\n+   end Splice;\n+\n+   ---------------------\n+   -- Splice_Internal --\n+   ---------------------\n+\n+   procedure Splice_Internal\n+     (Target : in out List;\n+      Before : Node_Access;\n+      Source : in out List)\n+   is\n+   begin\n+      --  This implements the corresponding Splice operation, after the\n+      --  parameters have been vetted, and corner-cases disposed of.\n+\n+      pragma Assert (Target'Address /= Source'Address);\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First /= null);\n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last /= null);\n+      pragma Assert (Source.Last.Next = null);\n+      pragma Assert (Target.Length <= Count_Type'Last - Source.Length);\n+\n+      if Target.Length = 0 then\n+         pragma Assert (Before = null);\n+         pragma Assert (Target.First = null);\n+         pragma Assert (Target.Last = null);\n+\n+         Target.First := Source.First;\n+         Target.Last := Source.Last;\n+\n+      elsif Before = null then\n+         pragma Assert (Target.Last.Next = null);\n+\n+         Target.Last.Next := Source.First;\n+         Source.First.Prev := Target.Last;\n+\n+         Target.Last := Source.Last;\n+\n+      elsif Before = Target.First then\n+         pragma Assert (Target.First.Prev = null);\n+\n+         Source.Last.Next := Target.First;\n+         Target.First.Prev := Source.Last;\n+\n+         Target.First := Source.First;\n+\n+      else\n+         pragma Assert (Target.Length >= 2);\n+         Before.Prev.Next := Source.First;\n+         Source.First.Prev := Before.Prev;\n+\n+         Before.Prev := Source.Last;\n+         Source.Last.Next := Before;\n+      end if;\n+\n+      Source.First := null;\n+      Source.Last := null;\n+\n+      Target.Length := Target.Length + Source.Length;\n+      Source.Length := 0;\n+   end Splice_Internal;\n+\n+   procedure Splice_Internal\n+     (Target   : in out List;\n+      Before   : Node_Access;  -- node of Target\n+      Source   : in out List;\n+      Position : Node_Access)  -- node of Source\n+   is\n+   begin\n+      --  This implements the corresponding Splice operation, after the\n+      --  parameters have been vetted.\n+\n+      pragma Assert (Target'Address /= Source'Address);\n+      pragma Assert (Target.Length < Count_Type'Last);\n+      pragma Assert (Source.Length > 0);\n+      pragma Assert (Source.First /= null);\n+      pragma Assert (Source.First.Prev = null);\n+      pragma Assert (Source.Last /= null);\n+      pragma Assert (Source.Last.Next = null);\n+      pragma Assert (Position /= null);\n+\n+      if Position = Source.First then\n+         Source.First := Position.Next;\n \n-         if Position.Node = Source.Last then\n+         if Position = Source.Last then\n             pragma Assert (Source.First = null);\n             pragma Assert (Source.Length = 1);\n             Source.Last := null;\n@@ -1913,58 +2127,56 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n             Source.First.Prev := null;\n          end if;\n \n-      elsif Position.Node = Source.Last then\n+      elsif Position = Source.Last then\n          pragma Assert (Source.Length >= 2);\n-         Source.Last := Position.Node.Prev;\n+         Source.Last := Position.Prev;\n          Source.Last.Next := null;\n \n       else\n          pragma Assert (Source.Length >= 3);\n-         Position.Node.Prev.Next := Position.Node.Next;\n-         Position.Node.Next.Prev := Position.Node.Prev;\n+         Position.Prev.Next := Position.Next;\n+         Position.Next.Prev := Position.Prev;\n       end if;\n \n       if Target.Length = 0 then\n-         pragma Assert (Before = No_Element);\n+         pragma Assert (Before = null);\n          pragma Assert (Target.First = null);\n          pragma Assert (Target.Last = null);\n \n-         Target.First := Position.Node;\n-         Target.Last := Position.Node;\n+         Target.First := Position;\n+         Target.Last := Position;\n \n          Target.First.Prev := null;\n          Target.Last.Next := null;\n \n-      elsif Before.Node = null then\n+      elsif Before = null then\n          pragma Assert (Target.Last.Next = null);\n-         Target.Last.Next := Position.Node;\n-         Position.Node.Prev := Target.Last;\n+         Target.Last.Next := Position;\n+         Position.Prev := Target.Last;\n \n-         Target.Last := Position.Node;\n+         Target.Last := Position;\n          Target.Last.Next := null;\n \n-      elsif Before.Node = Target.First then\n+      elsif Before = Target.First then\n          pragma Assert (Target.First.Prev = null);\n-         Target.First.Prev := Position.Node;\n-         Position.Node.Next := Target.First;\n+         Target.First.Prev := Position;\n+         Position.Next := Target.First;\n \n-         Target.First := Position.Node;\n+         Target.First := Position;\n          Target.First.Prev := null;\n \n       else\n          pragma Assert (Target.Length >= 2);\n-         Before.Node.Prev.Next := Position.Node;\n-         Position.Node.Prev := Before.Node.Prev;\n+         Before.Prev.Next := Position;\n+         Position.Prev := Before.Prev;\n \n-         Before.Node.Prev := Position.Node;\n-         Position.Node.Next := Before.Node;\n+         Before.Prev := Position;\n+         Position.Next := Before;\n       end if;\n \n       Target.Length := Target.Length + 1;\n       Source.Length := Source.Length - 1;\n-\n-      Position.Container := Target'Unchecked_Access;\n-   end Splice;\n+   end Splice_Internal;\n \n    ----------\n    -- Swap --"}, {"sha": "e80876236818d4cde67d382e21e8fce874158abe", "filename": "gcc/ada/adabkend.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fadabkend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fadabkend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadabkend.adb?ref=6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2011, AdaCore                     --\n+--                     Copyright (C) 2001-2013, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -234,6 +234,8 @@ package body Adabkend is\n             then\n                if Is_Switch (Argv) then\n                   Fail (\"Object file name missing after -gnatO\");\n+               elsif Alfa_Mode then\n+                  Output_File_Name_Seen := True;\n                else\n                   Set_Output_Object_File_Name (Argv);\n                   Output_File_Name_Seen := True;"}, {"sha": "69d37ad0f4fc47749496ff6ef96685f616e867f5", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "patch": "@@ -293,7 +293,10 @@ procedure Gnat1drv is\n          Formal_Extensions := True;\n       end if;\n \n-      if Debug_Flag_Dot_FF then\n+      --  Alfa_Mode is activated by default in the gnat2why executable, but\n+      --  can also be activated using the -gnatd.F switch.\n+\n+      if Debug_Flag_Dot_FF or else Alfa_Mode then\n          Alfa_Mode := True;\n \n          --  Set strict standard interpretation of compiler permissions"}, {"sha": "5653c762fe30a9203ee55f2ad3848cf5e4e53e34", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2e4047faa9d9165fd5a1df47aae79175fdf8f7/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=6c2e4047faa9d9165fd5a1df47aae79175fdf8f7", "patch": "@@ -1982,7 +1982,7 @@ package Opt is\n    Alfa_Mode : Boolean := False;\n    --  Specific compiling mode targeting formal verification through the\n    --  generation of Why code for those parts of the input code that belong to\n-   --  the Alfa subset of Ada. Set by debug flag -gnatd.F.\n+   --  the Alfa subset of Ada. Set by the gnat2why executable.\n \n    Frame_Condition_Mode : Boolean := False;\n    --  Specific mode to be used in combination with Alfa_Mode. If set to"}]}