{"sha": "d7edde11e0632bfe5403a123dddf75b82d06964b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlZGRlMTFlMDYzMmJmZTU0MDNhMTIzZGRkZjc1YjgyZDA2OTY0Yg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2015-05-05T15:15:13Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2015-05-05T15:15:13Z"}, "message": "msp430-opts.h (enum msp430_regions): New.\n\n\t* config/msp430/msp430-opts.h (enum msp430_regions): New.\n\t* config/msp430/msp430.c (msp430_override_options): Complain if\n\t-mcode-region or -mdata-region is used on a non MSP430X.\n\t(msp430_section_attr): New function.  Checks lower, upper and\n\teither attributes.\n\t(msp430_attribute_table): Add lower, upper and either.\n\t(gen_prefix): New function.  Generates a prefix for a section\n\tname.\n\t(msp430_select_section): New function - handles the choice of\n\tsection for an object.  Takes into account memory region\n\tattributes and options.\n\t(msp430_function_section): Use gen_prefix.\n\t(TARGET_SECTION_TYPE_FLAGS): Define.\n\t(msp430_section_type_flags): New function.\n\t(TARGET_ASM_UNIQUE_SECTION): Define.\n\t(msp430_unique_section): New function.\n\t(msp430_output_aligned_decl_common): New function.\n\t(msp430_do_not_relax_short_jumps): New function.\n\t* config/msp430/msp430.h (USE_SELECT_SECTION_FOR_FUNCTIONS):\n\tDefine.\n\t(ASM_OUTPUT_ALIGNED_DECL_COMMON): Define.\n\t* config/msp430/msp430-protos.h\n\t(msp430_do_not_relax_short_jumps): New prototype.\n\t(msp430_output_aligned_decl_common): New prototype.\n\t* config/msp430/msp430.md (length): New attribute.\n\t(cbranchhi4_real): If msp430_do_not_relax_short_jumps is true\n\tthen use a long code sequence for short jumps.\n\t* config/msp430/msp430.opt (mcode-region): New.\n\t(mdata-region): New.\n\t* doc/invoke.texi: Document new options.\n\t* doc/extend.texi: Document new attributes.\n\nFrom-SVN: r222810", "tree": {"sha": "37f343ade01b75498c1f85d988d51b25a7413ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37f343ade01b75498c1f85d988d51b25a7413ce2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7edde11e0632bfe5403a123dddf75b82d06964b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7edde11e0632bfe5403a123dddf75b82d06964b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7edde11e0632bfe5403a123dddf75b82d06964b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7edde11e0632bfe5403a123dddf75b82d06964b/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c87b25e6971b0ca7f8d5a28fa8775594d415d263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87b25e6971b0ca7f8d5a28fa8775594d415d263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c87b25e6971b0ca7f8d5a28fa8775594d415d263"}], "stats": {"total": 697, "additions": 593, "deletions": 104}, "files": [{"sha": "d8d673c6c6d68617caa9ad8ce027fa2310e817e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -1,3 +1,37 @@\n+2015-05-05  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/msp430/msp430-opts.h (enum msp430_regions): New.\n+\t* config/msp430/msp430.c (msp430_override_options): Complain if\n+\t-mcode-region or -mdata-region is used on a non MSP430X.\n+\t(msp430_section_attr): New function.  Checks lower, upper and\n+\teither attributes.\n+\t(msp430_attribute_table): Add lower, upper and either.\n+\t(gen_prefix): New function.  Generates a prefix for a section\n+\tname.\n+\t(msp430_select_section): New function - handles the choice of\n+\tsection for an object.  Takes into account memory region\n+\tattributes and options.\n+\t(msp430_function_section): Use gen_prefix.\n+\t(TARGET_SECTION_TYPE_FLAGS): Define.\n+\t(msp430_section_type_flags): New function.\n+\t(TARGET_ASM_UNIQUE_SECTION): Define.\n+\t(msp430_unique_section): New function.\n+\t(msp430_output_aligned_decl_common): New function.\n+\t(msp430_do_not_relax_short_jumps): New function.\n+\t* config/msp430/msp430.h (USE_SELECT_SECTION_FOR_FUNCTIONS):\n+\tDefine.\n+\t(ASM_OUTPUT_ALIGNED_DECL_COMMON): Define.\n+\t* config/msp430/msp430-protos.h\n+\t(msp430_do_not_relax_short_jumps): New prototype.\n+\t(msp430_output_aligned_decl_common): New prototype.\n+\t* config/msp430/msp430.md (length): New attribute.\n+\t(cbranchhi4_real): If msp430_do_not_relax_short_jumps is true\n+\tthen use a long code sequence for short jumps.\n+\t* config/msp430/msp430.opt (mcode-region): New.\n+\t(mdata-region): New.\n+\t* doc/invoke.texi: Document new options.\n+\t* doc/extend.texi: Document new attributes.\n+\n 2015-05-05  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* gcc/config/aarch64-protos.h (struct cpu_branch_cost): New."}, {"sha": "258dccbd29c2753e4ddc9c5d2e3e667676b2d6cb", "filename": "gcc/config/msp430/msp430-opts.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-opts.h?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -29,4 +29,12 @@ enum msp430_hwmult_types\n   F5SERIES\n };\n \n+enum msp430_regions\n+{\n+  ANY,\n+  EITHER,\n+  LOWER,\n+  UPPER\n+};\n+\n #endif"}, {"sha": "b4fd58721f3a867c709aad34c2c941ca1bc8d42c", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -21,6 +21,7 @@\n #ifndef GCC_MSP430_PROTOS_H\n #define GCC_MSP430_PROTOS_H\n \n+bool\tmsp430_do_not_relax_short_jumps (void);\n rtx\tmsp430_eh_return_stackadj_rtx (void);\n void\tmsp430_expand_eh_return (rtx);\n void\tmsp430_expand_epilogue (int);\n@@ -40,6 +41,7 @@ bool    msp430_is_interrupt_func (void);\n const char * msp430x_logical_shift_right (rtx);\n const char * msp430_mcu_name (void);\n bool\tmsp430_modes_tieable_p (machine_mode, machine_mode);\n+void    msp430_output_aligned_decl_common (FILE *, const tree, const char *, unsigned HOST_WIDE_INT, unsigned);\n void\tmsp430_output_labelref (FILE *, const char *);\n void\tmsp430_register_pragmas (void);\n rtx\tmsp430_return_addr_rtx (int);"}, {"sha": "3658dfcc89aa4a2b32d5ef6e21ee1770a077cd22", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 443, "deletions": 97, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -244,6 +244,11 @@ msp430_option_override (void)\n   if (TARGET_LARGE && !msp430x)\n     error (\"-mlarge requires a 430X-compatible -mmcu=\");\n \n+  if (msp430_code_region == UPPER && ! msp430x)\n+    error (\"-mcode-region=upper requires 430X-compatible cpu\");\n+  if (msp430_data_region == UPPER && ! msp430x)\n+    error (\"-mdata-region=upper requires 430X-compatible cpu\");\n+\n   if (flag_exceptions || flag_non_call_exceptions\n       || flag_unwind_tables || flag_asynchronous_unwind_tables)\n     flag_omit_frame_pointer = false;\n@@ -1146,46 +1151,234 @@ msp430_compute_frame_info (void)\n \t\t\t      + cfun->machine->framesize_outgoing);\n }\n \n+/* Attribute Handling.  */\n+\n+const char * const  ATTR_INTR   = \"interrupt\";\n+const char * const  ATTR_WAKEUP = \"wakeup\";\n+const char * const  ATTR_NAKED  = \"naked\";\n+const char * const  ATTR_REENT  = \"reentrant\";\n+const char * const  ATTR_CRIT   = \"critical\";\n+const char * const  ATTR_LOWER  = \"lower\";\n+const char * const  ATTR_UPPER  = \"upper\";\n+const char * const  ATTR_EITHER = \"either\";\n+\n static inline bool\n-is_attr_func (const char * attr)\n+has_attr (const char * attr, tree decl)\n+{\n+  if (decl == NULL_TREE)\n+    return false;\n+  return lookup_attribute (attr, DECL_ATTRIBUTES (decl)) != NULL_TREE;\n+}\n+\n+static bool\n+is_interrupt_func (tree decl = current_function_decl)\n {\n-  return lookup_attribute (attr, DECL_ATTRIBUTES (current_function_decl)) != NULL_TREE;\n+  return has_attr (ATTR_INTR, decl);\n }\n \n /* Returns true if the current function has the \"interrupt\" attribute.  */\n \n bool\n msp430_is_interrupt_func (void)\n {\n-  if (current_function_decl == NULL)\n-    return false;\n-  return is_attr_func (\"interrupt\");\n+  return is_interrupt_func (current_function_decl);\n }\n \n static bool\n-is_wakeup_func (void)\n+is_wakeup_func (tree decl = current_function_decl)\n {\n-  return msp430_is_interrupt_func () && is_attr_func (\"wakeup\");\n+  return is_interrupt_func (decl) && has_attr (ATTR_WAKEUP, decl);\n }\n \n static inline bool\n-is_naked_func (void)\n+is_naked_func (tree decl = current_function_decl)\n {\n-  return is_attr_func (\"naked\");\n+  return has_attr (ATTR_NAKED, decl);\n }\n \n static inline bool\n-is_reentrant_func (void)\n+is_reentrant_func (tree decl = current_function_decl)\n {\n-  return is_attr_func (\"reentrant\");\n+  return has_attr (ATTR_REENT, decl);\n }\n \n static inline bool\n-is_critical_func (void)\n+is_critical_func (tree decl = current_function_decl)\n+{\n+  return has_attr (ATTR_CRIT, decl);\n+}\n+\n+#undef  TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\n+#define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\tmsp430_allocate_stack_slots_for_args\n+\n+static bool\n+msp430_allocate_stack_slots_for_args (void)\n+{\n+  /* Naked functions should not allocate stack slots for arguments.  */\n+  return ! is_naked_func ();\n+}\n+\n+/* Verify MSP430 specific attributes.  */\n+#define TREE_NAME_EQ(NAME, STR) (strcmp (IDENTIFIER_POINTER (NAME), (STR)) == 0)\n+\n+static tree\n+msp430_attr (tree * node,\n+\t     tree   name,\n+\t     tree   args,\n+\t     int    flags ATTRIBUTE_UNUSED,\n+\t     bool * no_add_attrs)\n+{\n+  gcc_assert (DECL_P (* node));\n+\n+  if (args != NULL)\n+    {\n+      gcc_assert (TREE_NAME_EQ (name, ATTR_INTR));\n+\n+      tree value = TREE_VALUE (args);\n+\n+      switch (TREE_CODE (value))\n+\t{\n+\tcase STRING_CST:\n+\t  if (   strcmp (TREE_STRING_POINTER (value), \"reset\")\n+\t      && strcmp (TREE_STRING_POINTER (value), \"nmi\")\n+\t      && strcmp (TREE_STRING_POINTER (value), \"watchdog\"))\n+\t    /* Allow the attribute to be added - the linker script\n+\t       being used may still recognise this name.  */\n+\t    warning (OPT_Wattributes,\n+\t\t     \"unrecognised interrupt vector argument of %qE attribute\",\n+\t\t     name);\n+\t  break;\n+\n+\tcase INTEGER_CST:\n+\t  if (wi::gtu_p (value, 63))\n+\t    /* Allow the attribute to be added - the linker script\n+\t       being used may still recognise this value.  */\n+\t    warning (OPT_Wattributes,\n+\t\t     \"numeric argument of %qE attribute must be in range 0..63\",\n+\t\t     name);\n+\t  break;\n+\n+\tdefault:\n+\t  warning (OPT_Wattributes,\n+\t\t   \"argument of %qE attribute is not a string constant or number\",\n+\t\t   name);\n+\t  *no_add_attrs = true;\n+\t  break;\n+\t}\n+    }\n+\n+  const char * message = NULL;\n+\n+  if (TREE_CODE (* node) != FUNCTION_DECL)\n+    {\n+      message = \"%qE attribute only applies to functions\";\n+    }\n+  else if (TREE_NAME_EQ (name, ATTR_INTR))\n+    {\n+      if (TREE_CODE (TREE_TYPE (* node)) == FUNCTION_TYPE\n+\t  && ! VOID_TYPE_P (TREE_TYPE (TREE_TYPE (* node))))\n+\tmessage = \"interrupt handlers must be void\";\n+    }\n+  else if (TREE_NAME_EQ (name, ATTR_REENT))\n+    {\n+      if (is_naked_func (* node))\n+\tmessage = \"naked functions cannot be reentrant\";\n+      else if (is_critical_func (* node))\n+\tmessage = \"critical functions cannot be reentrant\";\n+    }\n+  else if (TREE_NAME_EQ (name, ATTR_CRIT))\n+    {\n+      if (is_naked_func (* node))\n+\tmessage = \"naked functions cannot be critical\";\n+      else if (is_reentrant_func (* node))\n+\tmessage = \"reentranct functions cannot be critical\";\n+    }\n+  else if (TREE_NAME_EQ (name, ATTR_NAKED))\n+    {\n+      if (is_critical_func (* node))\n+\tmessage = \"critical functions cannot be naked\";\n+      else if (is_reentrant_func (* node))\n+\tmessage = \"reentrant functions cannot be naked\";\n+    }\n+\n+  if (message)\n+    {\n+      warning (OPT_Wattributes, message, name);\n+      * no_add_attrs = true;\n+    }\n+    \n+  return NULL_TREE;\n+}\n+\n+static tree\n+msp430_section_attr (tree * node,\n+\t\t     tree   name,\n+\t\t     tree   args,\n+\t\t     int    flags ATTRIBUTE_UNUSED,\n+\t\t     bool * no_add_attrs ATTRIBUTE_UNUSED)\n {\n-  return is_attr_func (\"critical\");\n+  gcc_assert (DECL_P (* node));\n+  gcc_assert (args == NULL);\n+\n+  const char * message = NULL;\n+\n+  if (TREE_NAME_EQ (name, ATTR_UPPER))\n+    {\n+      if (has_attr (ATTR_LOWER, * node))\n+\tmessage = \"already marked with 'lower' attribute\";\n+      else if (has_attr (ATTR_EITHER, * node))\n+\tmessage = \"already marked with 'either' attribute\";\n+      else if (! msp430x)\n+\tmessage = \"upper attribute needs a 430X cpu\";\n+    }\n+  else if (TREE_NAME_EQ (name, ATTR_LOWER))\n+    {\n+      if (has_attr (ATTR_UPPER, * node))\n+\tmessage = \"already marked with 'upper' attribute\";\n+      else if (has_attr (ATTR_EITHER, * node))\n+\tmessage = \"already marked with 'either' attribute\";\n+    }\n+  else\n+    {\n+      gcc_assert (TREE_NAME_EQ (name, ATTR_EITHER));\n+\n+      if (has_attr (ATTR_LOWER, * node))\n+\tmessage = \"already marked with 'lower' attribute\";\n+      else if (has_attr (ATTR_UPPER, * node))\n+\tmessage = \"already marked with 'upper' attribute\";\n+    }\n+\n+  if (message)\n+    {\n+      warning (OPT_Wattributes, message, name);\n+      * no_add_attrs = true;\n+    }\n+    \n+  return NULL_TREE;\n }\n \n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE\t\tmsp430_attribute_table\n+\n+/* Table of MSP430-specific attributes.  */\n+const struct attribute_spec msp430_attribute_table[] =\n+{\n+  /* Name        min_num_args     type_req,             affects_type_identity\n+                      max_num_args,     fn_type_req\n+                          decl_req               handler.  */\n+  { ATTR_INTR,        0, 1, true,  false, false, msp430_attr, false },\n+  { ATTR_NAKED,       0, 0, true,  false, false, msp430_attr, false },\n+  { ATTR_REENT,       0, 0, true,  false, false, msp430_attr, false },\n+  { ATTR_CRIT,        0, 0, true,  false, false, msp430_attr, false },\n+  { ATTR_WAKEUP,      0, 0, true,  false, false, msp430_attr, false },\n+\n+  { ATTR_LOWER,       0, 0, true,  false, false, msp430_section_attr, false },\n+  { ATTR_UPPER,       0, 0, true,  false, false, msp430_section_attr, false },\n+  { ATTR_EITHER,      0, 0, true,  false, false, msp430_section_attr, false },\n+\n+  { NULL,             0, 0, false, false, false, NULL,        false }\n+};\n+\n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE\tmsp430_start_function\n \n@@ -1260,85 +1453,6 @@ increment_stack (HOST_WIDE_INT amount)\n     }\n }\n \n-/* Verify MSP430 specific attributes.  */\n-\n-static tree\n-msp430_attr (tree * node,\n-\t     tree   name,\n-\t     tree   args,\n-\t     int    flags ATTRIBUTE_UNUSED,\n-\t     bool * no_add_attrs)\n-{\n-  gcc_assert (DECL_P (* node));\n-\n-  if (args != NULL)\n-    {\n-      tree value = TREE_VALUE (args);\n-\n-      switch (TREE_CODE (value))\n-\t{\n-\tcase STRING_CST:\n-\t  if (   strcmp (TREE_STRING_POINTER (value), \"reset\")\n-\t      && strcmp (TREE_STRING_POINTER (value), \"nmi\")\n-\t      && strcmp (TREE_STRING_POINTER (value), \"watchdog\"))\n-\t    /* Allow the attribute to be added - the linker script\n-\t       being used may still recognise this name.  */\n-\t    warning (OPT_Wattributes,\n-\t\t     \"unrecognised interrupt vector argument of %qE attribute\",\n-\t\t     name);\n-\t  break;\n-\n-\tcase INTEGER_CST:\n-\t  if (wi::gtu_p (value, 63))\n-\t    /* Allow the attribute to be added - the linker script\n-\t       being used may still recognise this value.  */\n-\t    warning (OPT_Wattributes,\n-\t\t     \"numeric argument of %qE attribute must be in range 0..63\",\n-\t\t     name);\n-\t  break;\n-\n-\tdefault:\n-\t  warning (OPT_Wattributes,\n-\t\t   \"argument of %qE attribute is not a string constant or number\",\n-\t\t   name);\n-\t  *no_add_attrs = true;\n-\t  break;\n-\t}\n-    }\n-\n-  if (TREE_CODE (* node) != FUNCTION_DECL)\n-    {\n-      warning (OPT_Wattributes,\n-\t       \"%qE attribute only applies to functions\",\n-\t       name);\n-      * no_add_attrs = true;\n-    }\n-\n-  /* FIXME: We ought to check that the interrupt handler\n-     attribute has been applied to a void function.  */\n-  /* FIXME: We should check that reentrant and critical\n-     functions are not naked and that critical functions\n-     are not reentrant.  */\n-\n-  return NULL_TREE;\n-}\n-\n-#undef  TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE\t\tmsp430_attribute_table\n-\n-/* Table of MSP430-specific attributes.  */\n-const struct attribute_spec msp430_attribute_table[] =\n-{\n-  /* Name          min_len  decl_req,    fn_type_req,    affects_type_identity\n-                       max_len,  type_req,        handler.  */\n-  { \"interrupt\",      0, 1, true,  false, false, msp430_attr, false },\n-  { \"naked\",          0, 0, true,  false, false, msp430_attr, false },\n-  { \"reentrant\",      0, 0, true,  false, false, msp430_attr, false },\n-  { \"critical\",       0, 0, true,  false, false, msp430_attr, false },\n-  { \"wakeup\",         0, 0, true,  false, false, msp430_attr, false },\n-  { NULL,             0, 0, false, false, false, NULL,        false }\n-};\n-\n void\n msp430_start_function (FILE *file, const char *name, tree decl)\n {\n@@ -1378,22 +1492,254 @@ msp430_start_function (FILE *file, const char *name, tree decl)\n   ASM_OUTPUT_FUNCTION_LABEL (file, name, decl);\n }\n \n+static const char * const lower_prefix = \".lower\";\n+static const char * const upper_prefix = \".upper\";\n+static const char * const either_prefix = \".either\";\n+\n+/* Generate a prefix for a section name, based upon\n+   the region into which the object should be placed.  */\n+\n+static const char *\n+gen_prefix (tree decl)\n+{\n+  if (DECL_ONE_ONLY (decl))\n+    return NULL;\n+\n+  /* If the user has specified a particular section then do not use any prefix.  */\n+  if (has_attr (\"section\", decl))\n+    return NULL;\n+\n+  /* If the object has __attribute__((lower)) then use the \".lower.\" prefix.  */\n+  if (has_attr (ATTR_LOWER, decl))\n+    return lower_prefix;\n+\n+  /* If we are compiling for the MSP430 then we do not support the upper region.  */\n+  if (! msp430x)\n+    return NULL;\n+\n+  if (has_attr (ATTR_UPPER, decl))\n+    return upper_prefix;\n+\n+  if (has_attr (ATTR_EITHER, decl))\n+    return either_prefix;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (msp430_code_region == LOWER)\n+\treturn lower_prefix;\n+\n+      if (msp430_code_region == UPPER)\n+\treturn upper_prefix;\n+\n+      if (msp430_code_region == EITHER)\n+\treturn either_prefix;\n+    }\n+  else\n+    {\n+      if (msp430_data_region == LOWER)\n+\treturn lower_prefix;\n+\n+      if (msp430_data_region == UPPER)\n+\treturn upper_prefix;\n+\n+      if (msp430_data_region == EITHER)\n+\treturn either_prefix;\n+    }\n+\n+  return NULL;\n+}\n+\n+#undef  TARGET_ASM_SELECT_SECTION\n+#define TARGET_ASM_SELECT_SECTION msp430_select_section\n+\n static section *\n-msp430_function_section (tree decl, enum node_frequency freq, bool startup, bool exit)\n+msp430_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n {\n+  gcc_assert (decl != NULL_TREE);\n+\n+  if (TREE_CODE (decl) == STRING_CST\n+      || TREE_CODE (decl) == CONSTRUCTOR\n+      || TREE_CODE (decl) == INTEGER_CST\n+      || TREE_CODE (decl) == VECTOR_CST\n+      || TREE_CODE (decl) == COMPLEX_CST)\n+    return default_select_section (decl, reloc, align);\n+  \n   /* In large mode we must make sure that interrupt handlers are put into\n      low memory as the vector table only accepts 16-bit addresses.  */\n-  if (TARGET_LARGE\n-      && lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (decl)))\n+  if (TARGET_LARGE && TREE_CODE (decl) == FUNCTION_DECL && is_interrupt_func (decl))\n     return get_section (\".lowtext\", SECTION_CODE | SECTION_WRITE , decl);\n \n-  /* Otherwise, use the default function section.  */\n-  return default_function_section (decl, freq, startup, exit);\n+  const char * prefix = gen_prefix (decl);\n+  if (prefix == NULL)\n+    {\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\treturn text_section;\n+      else\n+\treturn default_select_section (decl, reloc, align);\n+    }\n+  \n+  const char * sec;\n+  switch (categorize_decl_for_section (decl, reloc))\n+    {\n+    case SECCAT_TEXT:   sec = \".text\";   break;\n+    case SECCAT_DATA:   sec = \".data\";   break;\n+    case SECCAT_BSS:    sec = \".bss\";    break;\n+    case SECCAT_RODATA: sec = \".rodata\"; break;\n+\n+    case SECCAT_RODATA_MERGE_STR:\n+    case SECCAT_RODATA_MERGE_STR_INIT:\n+    case SECCAT_RODATA_MERGE_CONST:\n+    case SECCAT_SRODATA:\n+    case SECCAT_DATA_REL:\n+    case SECCAT_DATA_REL_LOCAL:\n+    case SECCAT_DATA_REL_RO:\n+    case SECCAT_DATA_REL_RO_LOCAL:\n+    case SECCAT_SDATA:\n+    case SECCAT_SBSS:\n+    case SECCAT_TDATA:\n+    case SECCAT_TBSS:\n+      return default_select_section (decl, reloc, align);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  \n+  const char * dec_name = DECL_SECTION_NAME (decl);\n+  char * name = ACONCAT ((prefix, sec, dec_name, NULL));\n+\n+  return get_named_section (decl, name, 0);\n }\n \n #undef  TARGET_ASM_FUNCTION_SECTION\n #define TARGET_ASM_FUNCTION_SECTION msp430_function_section\n \n+static section *\n+msp430_function_section (tree decl, enum node_frequency freq, bool startup, bool exit)\n+{\n+  const char * name;\n+\n+  gcc_assert (DECL_SECTION_NAME (decl) != NULL);\n+  name = DECL_SECTION_NAME (decl);\n+\n+  const char * prefix = gen_prefix (decl);\n+  if (prefix == NULL\n+      || strncmp (name, prefix, strlen (prefix)) == 0)\n+    return default_function_section (decl, freq, startup, exit);\n+\n+  name = ACONCAT ((prefix, name, NULL));\n+  return get_named_section (decl, name, 0);\n+}\n+\n+#undef  TARGET_SECTION_TYPE_FLAGS\n+#define TARGET_SECTION_TYPE_FLAGS msp430_section_type_flags\n+\n+unsigned int\n+msp430_section_type_flags (tree decl, const char * name, int reloc)\n+{\n+  if (strncmp (name, lower_prefix, strlen (lower_prefix)) == 0)\n+    name += strlen (lower_prefix);\n+  else if (strncmp (name, upper_prefix, strlen (upper_prefix)) == 0)\n+    name += strlen (upper_prefix);\n+  else if (strncmp (name, either_prefix, strlen (either_prefix)) == 0)\n+    name += strlen (either_prefix);\n+\n+  return default_section_type_flags (decl, name, reloc);\n+}\n+\n+#undef  TARGET_ASM_UNIQUE_SECTION\n+#define TARGET_ASM_UNIQUE_SECTION msp430_unique_section\n+\n+static void\n+msp430_unique_section (tree decl, int reloc)\n+{\n+  gcc_assert (decl != NULL_TREE);\n+\n+  /* In large mode we must make sure that interrupt handlers are put into\n+     low memory as the vector table only accepts 16-bit addresses.  */\n+  if (TARGET_LARGE && TREE_CODE (decl) == FUNCTION_DECL && is_interrupt_func (decl))\n+    {\n+      set_decl_section_name (decl, \".lowtext\");\n+      return;\n+    }\n+\n+  default_unique_section (decl, reloc);\n+\n+  const char * prefix;\n+\n+  if (   TREE_CODE (decl) == STRING_CST\n+      || TREE_CODE (decl) == CONSTRUCTOR\n+      || TREE_CODE (decl) == INTEGER_CST\n+      || TREE_CODE (decl) == VECTOR_CST\n+      || TREE_CODE (decl) == COMPLEX_CST\n+      || (prefix = gen_prefix (decl)) == NULL\n+      )\n+    return;\n+\n+  const char * dec_name = DECL_SECTION_NAME (decl);\n+  char * name = ACONCAT ((prefix, dec_name, NULL));\n+\n+  set_decl_section_name (decl, name);\n+}\n+\n+/* Emit a declaration of a common symbol.\n+   If a data region is in use then put the symbol into the\n+   equivalent .bss section instead.  */\n+\n+void\n+msp430_output_aligned_decl_common (FILE *                 stream,\n+\t\t\t\t   const tree             decl,\n+\t\t\t\t   const char *           name,\n+\t\t\t\t   unsigned HOST_WIDE_INT size,\n+\t\t\t\t   unsigned int           align)\n+{\n+  if (msp430_data_region == ANY)\n+    {\n+      fprintf (stream, COMMON_ASM_OP);\n+      assemble_name (stream, name);\n+      fprintf (stream, \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",\n+\t       size, align / BITS_PER_UNIT);\n+    }\n+  else\n+    {\n+      section * sec;\n+\n+      if (decl)\n+\tsec = msp430_select_section (decl, 0, align);\n+      else\n+\tswitch (msp430_data_region)\n+\t  {\n+\t  case UPPER: sec = get_named_section (NULL, \".upper.bss\", 0); break;\n+\t  case LOWER: sec = get_named_section (NULL, \".lower.bss\", 0); break;\n+\t  case EITHER: sec = get_named_section (NULL, \".either.bss\", 0); break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      gcc_assert (sec != NULL);\n+\n+      switch_to_section (sec);\n+      ASM_OUTPUT_ALIGN (stream, floor_log2 (align / BITS_PER_UNIT));\n+      targetm.asm_out.globalize_label (stream, name);\n+      ASM_WEAKEN_LABEL (stream, name);\n+      ASM_OUTPUT_LABEL (stream, name);\n+      ASM_OUTPUT_SKIP (stream, size ? size : 1);\n+    }\n+}\n+\n+bool\n+msp430_do_not_relax_short_jumps (void)\n+{\n+  /* When placing code into \"either\" low or high memory we do not want the linker\n+     to grow the size of sections, which it can do if it is encounters a branch to\n+     a label that is too far away.  So we tell the cbranch patterns to avoid using\n+     short jumps when there is a chance that the instructions will end up in a low\n+     section.  */\n+  return\n+    msp430_code_region == EITHER\n+    || msp430_code_region == LOWER\n+    || has_attr (ATTR_EITHER, current_function_decl)\n+    || has_attr (ATTR_LOWER, current_function_decl);\n+}\n+\n enum msp430_builtin\n {\n   MSP430_BUILTIN_BIC_SR,"}, {"sha": "73e957274225dc4b99da8704c253146e140de87e", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -404,3 +404,9 @@ typedef struct\n   msp430_start_function ((FILE), (NAME), (DECL))\n \n #define TARGET_HAS_NO_HW_DIVIDE (! TARGET_HWMULT)\n+\n+#undef  USE_SELECT_SECTION_FOR_FUNCTIONS\n+#define USE_SELECT_SECTION_FOR_FUNCTIONS 1\n+\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+  msp430_output_aligned_decl_common ((FILE), (DECL), (NAME), (SIZE), (ALIGN))"}, {"sha": "91742fc38b5ed2d4c0933d3d8d55a9ff63dccd78", "filename": "gcc/config/msp430/msp430.md", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.md?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -58,6 +58,9 @@\n    UNS_DELAY_END\n   ])\n \n+;; This is an approximation.\n+(define_attr \"length\" \"\" (const_int 4))\n+\n (include \"predicates.md\")\n (include \"constraints.md\")\n \n@@ -210,7 +213,7 @@\n   \"\"\n   \"\"\n   )\n-  \n+\n (define_insn_and_split \"movsi_x\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(match_operand:SI 1 \"general_operand\" \"rmi\"))]\n@@ -551,7 +554,7 @@\n   [(set (match_dup 0)\n \t(zero_extend:HI (match_dup 1)))]\n )\n-   \n+\n (define_insn \"zero_extendhipsi2\"\n   [(set (match_operand:PSI                 0 \"msp_nonimmediate_operand\" \"=r,m\")\n \t(zero_extend:PSI (match_operand:HI 1 \"msp_nonimmediate_operand\" \"rm,r\")))]\n@@ -939,14 +942,12 @@\n   \"msp430_expand_epilogue (0); DONE;\"\n   )\n \n-\n (define_insn \"epilogue_helper\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")] UNS_EPILOGUE_HELPER)]\n   \"\"\n   \"BR%Q0\\t#__mspabi_func_epilog_%J0\"\n   )\n \n-\n (define_insn \"prologue_start_marker\"\n   [(unspec_volatile [(const_int 0)] UNS_PROLOGUE_START_MARKER)]\n   \"\"\n@@ -1110,9 +1111,32 @@\n    (clobber (reg:BI CARRY))\n    ]\n   \"\"\n-  \"@\n-   CMP.W\\t%2, %1 { J%0\\t%l3\n-   CMP%X0.W\\t%2, %1 { J%0\\t%l3\"\n+  \"*\n+    /* This is nasty.  If we are splitting code between low and high memory\n+       then we do not want the linker to increase the size of sections by\n+       relaxing out of range jump instructions.  (Since relaxation occurs\n+       after section placement).  So we have to generate pessimal branches\n+       here.  But we only want to do this when really necessary.\n+\n+       FIXME: Do we need code in the other cbranch patterns ?  */\n+    if (msp430_do_not_relax_short_jumps () && get_attr_length (insn) > 6)\n+      {\n+        return which_alternative == 0 ?\n+            \\\"CMP.W\\t%2, %1 { J%r0 1f { BRA #%l3 { 1:\\\" :\n+         \\\"CMP%X0.W\\t%2, %1 { J%r0 1f { BRA #%l3 { 1:\\\";\n+      }\n+\n+    return which_alternative == 0 ?\n+         \\\"CMP.W\\t%2, %1 { J%0\\t%l3\\\" :\n+      \\\"CMP%X0.W\\t%2, %1 { J%0\\t%l3\\\";\n+  \"\n+  [(set (attr \"length\")\n+\t(if_then_else\n+\t  (and (ge (minus (match_dup 3) (pc)) (const_int -510))\n+\t       (le (minus (match_dup 3) (pc)) (const_int 510)))\n+\t  (const_int 6)\n+\t  (const_int 10))\n+\t)]\n   )\n \n (define_insn \"cbranchpsi4_reversed\""}, {"sha": "3fed8799822ededfabb27b33abb4778673bddbc7", "filename": "gcc/config/msp430/msp430.opt", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -57,3 +57,26 @@ Enum(msp430_hwmult_types) String(32bit) Value(LARGE)\n \n EnumValue\n Enum(msp430_hwmult_types) String(f5series) Value(F5SERIES)\n+\n+mcode-region=\n+Target Joined RejectNegative Report ToLower Var(msp430_code_region) Enum(msp430_regions) Init(ANY)\n+Specify whether functions should be placed into low or high memory\n+\n+mdata-region=\n+Target Joined RejectNegative Report ToLower Var(msp430_data_region) Enum(msp430_regions) Init(ANY)\n+Specify whether variables should be placed into low or high memory\n+\n+Enum\n+Name(msp430_regions) Type(enum msp430_regions)\n+\n+EnumValue\n+Enum(msp430_regions) String(none) Value(ANY)\n+\n+EnumValue\n+Enum(msp430_regions) String(either) Value(EITHER)\n+\n+EnumValue\n+Enum(msp430_regions) String(lower) Value(LOWER)\n+\n+EnumValue\n+Enum(msp430_regions) String(upper) Value(UPPER)"}, {"sha": "a5047959113365f75c932910c73a8de18cd980c4", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -3254,6 +3254,38 @@ performing a reloadable link on them.\n At present, a declaration to which @code{weakref} is attached can\n only be @code{static}.\n \n+@item lower\n+@itemx upper\n+@itemx either\n+@cindex lower memory region on the MSP430\n+@cindex upper memory region on the MSP430\n+@cindex either memory region on the MSP430\n+On the MSP430 target these attributes can be used to specify whether\n+the function or variable should be placed into low memory, high\n+memory, or the placement should be left to the linker to decide.  The\n+attributes are only significant if compiling for the MSP430X\n+architecture.\n+\n+The attributes work in conjunction with a linker script that has been\n+augmented to specify where to place sections with a @code{.lower} and\n+a @code{.upper} prefix.  So for example as well as placing the\n+@code{.data} section the script would also specify the placement of a\n+@code{.lower.data} and a @code{.upper.data} section.  The intention\n+being that @code{lower} sections are placed into a small but easier to\n+access memory region and the upper sections are placed into a larger, but\n+slower to access region.\n+\n+The @code{either} attribute is special.  It tells the linker to place\n+the object into the corresponding @code{lower} section if there is\n+room for it.  If there is insufficient room then the object is placed\n+into the corresponding @code{upper} section instead.  Note - the\n+placement algorithm is not very sophisticated.  It will not attempt to\n+find an optimal packing of the @code{lower} sections.  It just makes\n+one pass over the objects and does the best that it can.  Using the\n+@option{-ffunction-sections} and @option{-fdata-sections} command line\n+options can help the packing however, since they produce smaller,\n+easier to pack regions.\n+\n @end table\n \n @c This is the end of the target-independent attribute table"}, {"sha": "debd8eddda0960d0d4400932e701aa46845564db", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7edde11e0632bfe5403a123dddf75b82d06964b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d7edde11e0632bfe5403a123dddf75b82d06964b", "patch": "@@ -827,6 +827,7 @@ Objective-C and Objective-C++ Dialects}.\n \n @emph{MSP430 Options}\n @gccoptlist{-msim -masm-hex -mmcu= -mcpu= -mlarge -msmall -mrelax @gol\n+-mcode-region= -mdata-region= @gol\n -mhwmult= -minrt}\n \n @emph{NDS32 Options}\n@@ -18164,6 +18165,19 @@ initializers or constructors.  This is intended for memory-constrained\n devices.  The compiler includes special symbols in some objects\n that tell the linker and runtime which code fragments are required.\n \n+@item -mcode-region=\n+@itemx -mdata-region=\n+@opindex mcode-region\n+@opindex mdata-region\n+These options tell the compiler where to place functions and data that\n+do not have one of the @code{lower}, @code{upper}, @code{either} or\n+@code{section} attributes.  Possible values are @code{lower},\n+@code{upper}, @code{either} or @code{any}.  The first three behave\n+like the corresponding attribute.  The fourth possible value -\n+@code{any} - is the default.  It leaves placement entirely up to the\n+linker script and how it assigns the standard sections (.text, .data\n+etc) to the memory regions.\n+\n @end table\n \n @node NDS32 Options"}]}