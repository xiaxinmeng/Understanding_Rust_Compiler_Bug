{"sha": "35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwNjhiNDM1ZmI4YzA5ZmZmMmNiYzRlYjhhM2UxZGQ5MDRhYWUwZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-19T00:15:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-19T00:15:47Z"}, "message": "(addrs_ok_for_quad_peep): New function.\n\n(output_prolog): Use liu mnemonic.\n\nFrom-SVN: r8516", "tree": {"sha": "ec8309c869394e8fc2d6d5b201899fa77e689be8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec8309c869394e8fc2d6d5b201899fa77e689be8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e/comments", "author": null, "committer": null, "parents": [{"sha": "d5e4fa5e173ff180b66524db80e4392051dfa479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e4fa5e173ff180b66524db80e4392051dfa479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e4fa5e173ff180b66524db80e4392051dfa479"}], "stats": {"total": 74, "additions": 73, "deletions": 1}, "files": [{"sha": "48952197672723491b17a4bd40aabac35ff27218", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=35068b435fb8c09fff2cbc4eb8a3e1dd904aae0e", "patch": "@@ -719,6 +719,78 @@ includes_rshift_p (shiftop, andop)\n \n   return (INTVAL (andop) & ~ shift_mask) == 0;\n }\n+\n+/* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates\n+   for lfq and stfq insns.\n+\n+   Note reg1 and reg2 *must* be hard registers.  To be sure we will\n+   abort if we are passed pseudo registers.  */\n+\n+int\n+registers_ok_for_quad_peep (reg1, reg2)\n+     rtx reg1, reg2;\n+{\n+  /* We might have been passed a SUBREG.  */\n+  if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n+    return 0;\n+\n+  return (REGNO (reg1) == REGNO (reg2) - 1);\n+}\n+\n+/* Return 1 if addr1 and addr2 are suitable for lfq or stfq insn.  addr1 and\n+   addr2 must be in consecutive memory locations (addr2 == addr1 + 8).  */\n+\n+int\n+addrs_ok_for_quad_peep (addr1, addr2)\n+     register rtx addr1;\n+     register rtx addr2;\n+{\n+  int reg1;\n+  int offset1;\n+\n+  /* Extract an offset (if used) from the first addr.  */\n+  if (GET_CODE (addr1) == PLUS)\n+    {\n+      /* If not a REG, return zero.  */\n+      if (GET_CODE (XEXP (addr1, 0)) != REG)\n+\treturn 0;\n+      else\n+\t{\n+          reg1 = REGNO (XEXP (addr1, 0));\n+\t  /* The offset must be constant!  */\n+\t  if (GET_CODE (XEXP (addr1, 1)) != CONST_INT)\n+            return 0;\n+          offset1 = INTVAL (XEXP (addr1, 1));\n+\t}\n+    }\n+  else if (GET_CODE (addr1) != REG)\n+    return 0;\n+  else\n+    {\n+      reg1 = REGNO (addr1);\n+      /* This was a simple (mem (reg)) expression.  Offset is 0.  */\n+      offset1 = 0;\n+    }\n+\n+  /* Make sure the second address is a (mem (plus (reg) (const_int).  */\n+  if (GET_CODE (addr2) != PLUS)\n+    return 0;\n+\n+  if (GET_CODE (XEXP (addr2, 0)) != REG\n+      || GET_CODE (XEXP (addr2, 1)) != CONST_INT)\n+    return 0;\n+\n+  if (reg1 != REGNO (XEXP (addr2, 0)))\n+    return 0;\n+\n+  /* The offset for the second addr must be 8 more than the first addr.  */\n+  if (INTVAL (XEXP (addr2, 1)) != offset1 + 8)\n+    return 0;\n+\n+  /* All the tests passed.  addr1 and addr2 are valid for lfq or stfq\n+     instructions.  */\n+  return 1;\n+}\n \f\n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n@@ -1502,7 +1574,7 @@ output_prolog (file, size)\n \tasm_fprintf (file, \"\\t{stu|stwu} 1,%d(1)\\n\", - total_size);\n       else\n \t{\n-\t  asm_fprintf (file, \"\\t{cau 0,0,%d|lis 0,%d}\\n\\t{oril|ori} 0,0,%d\\n\",\n+\t  asm_fprintf (file, \"\\t{liu|lis} 0,%d\\n\\t{oril|ori} 0,0,%d\\n\",\n \t\t   (total_size >> 16) & 0xffff, total_size & 0xffff);\n \t  if (TARGET_POWERPC)\n \t    asm_fprintf (file, \"\\tsubf 12,0,1\\n\");"}]}