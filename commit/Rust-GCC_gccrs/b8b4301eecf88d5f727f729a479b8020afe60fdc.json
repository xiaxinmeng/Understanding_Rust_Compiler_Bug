{"sha": "b8b4301eecf88d5f727f729a479b8020afe60fdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhiNDMwMWVlY2Y4OGQ1ZjcyN2Y3MjlhNDc5YjgwMjBhZmU2MGZkYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-09-29T11:56:34Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-09-29T11:56:34Z"}, "message": "[multiple changes]\n\n2010-09-29  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/Makefile.am: Add debug/forward_list.\n\t* include/Makefile.in: Regenerate.\n\n\t* testsuite/util/testsuite_container_traits.h (traits_base):\n\tAdd has_erase_after and hash_insert_after typedefs.\n\t(traits<forward_list<>>): Adjust.\n\t* testsuite/util/exception/safety.h (erase_point, erase_range,\n\tinsert_point): Deal correctly with forward_list.\n\t* include/Makefile.am: Add.\n\n2010-09-29  Fran\u00e7ois Dumont  <francois.cppdevs@free.fr>\n\n\t* src/debug.cc: Add forward_list specific debug messages.\n\t* include/debug/forward_list: New.\n\t* include/debug/formatter.h: Add debug message ids and before begin\n\titerator state.\n\t* include/debug/macros.h (__glibcxx_check_insert_after,\n\t__glibcxx_check_insert_range_after, __glibcxx_check_erase_after,\n\t__glibcxx_check_erase_range_after): Add.\n\t* include/debug/safe_iterator.h (_BeforeBeginHelper): Add.\n\t(_Safe_iterator<>::_M_before_dereferenceable,\n\t_Safe_iterator<>::_M_is_before_begin): Add.\n\t(_Safe_iterator<>::_M_dereferenceable, _Safe_iterator<>::_M_is_end,\n\t_Safe_iterator<>::_M_incrementable): Adjust.\n\t* include/std/forward_list: Include debug/forward when _GLIBCXX_DEBUG\n\tdefined.\n\t* include/bits/forward_list.h, forward_list.tcc: Put in std::__norm\n\twhen debug mode is active.\n\t* testsuite/23_containers/forward_list/capacity/1.cc: Fix to compile\n\teven in debug mode.\n\t* testsuite/23_containers/forward_list/debug/erase_after1.cc,\n\terase_after2.cc, erase_after3.cc, erase_after4.cc, erase_after5.cc,\n\tinsert_after1.cc,erase_after6.cc, erase_after7.cc, insert_after2.cc,\n\terase_after8.cc, insert_after3.cc, erase_after9.cc: New.\n\nFrom-SVN: r164717", "tree": {"sha": "83bdb10f8d357c1745bb3b46f210b83062e71171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83bdb10f8d357c1745bb3b46f210b83062e71171"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8b4301eecf88d5f727f729a479b8020afe60fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b4301eecf88d5f727f729a479b8020afe60fdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8b4301eecf88d5f727f729a479b8020afe60fdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b4301eecf88d5f727f729a479b8020afe60fdc/comments", "author": null, "committer": null, "parents": [{"sha": "38df2baf3f40af1c1af065993cf86e0254b765df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38df2baf3f40af1c1af065993cf86e0254b765df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38df2baf3f40af1c1af065993cf86e0254b765df"}], "stats": {"total": 1463, "additions": 1423, "deletions": 40}, "files": [{"sha": "b2669f188231f26eb9f54b91ccd4d552135a094c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -1,3 +1,40 @@\n+2010-09-29  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/Makefile.am: Add debug/forward_list.\n+\t* include/Makefile.in: Regenerate.\n+\n+\t* testsuite/util/testsuite_container_traits.h (traits_base):\n+\tAdd has_erase_after and hash_insert_after typedefs.\n+\t(traits<forward_list<>>): Adjust.\n+\t* testsuite/util/exception/safety.h (erase_point, erase_range,\n+\tinsert_point): Deal correctly with forward_list.\n+\t* include/Makefile.am: Add.\n+\n+2010-09-29  Fran\u00e7ois Dumont  <francois.cppdevs@free.fr>\n+\n+\t* src/debug.cc: Add forward_list specific debug messages.\n+\t* include/debug/forward_list: New.\n+\t* include/debug/formatter.h: Add debug message ids and before begin\n+\titerator state.\n+\t* include/debug/macros.h (__glibcxx_check_insert_after,\n+\t__glibcxx_check_insert_range_after, __glibcxx_check_erase_after,\n+\t__glibcxx_check_erase_range_after): Add.\n+\t* include/debug/safe_iterator.h (_BeforeBeginHelper): Add.\n+\t(_Safe_iterator<>::_M_before_dereferenceable,\n+\t_Safe_iterator<>::_M_is_before_begin): Add.\n+\t(_Safe_iterator<>::_M_dereferenceable, _Safe_iterator<>::_M_is_end,\n+\t_Safe_iterator<>::_M_incrementable): Adjust.\n+\t* include/std/forward_list: Include debug/forward when _GLIBCXX_DEBUG\n+\tdefined.\n+\t* include/bits/forward_list.h, forward_list.tcc: Put in std::__norm\n+\twhen debug mode is active.\n+\t* testsuite/23_containers/forward_list/capacity/1.cc: Fix to compile\n+\teven in debug mode.\n+\t* testsuite/23_containers/forward_list/debug/erase_after1.cc,\n+\terase_after2.cc, erase_after3.cc, erase_after4.cc, erase_after5.cc,\n+\tinsert_after1.cc,erase_after6.cc, erase_after7.cc, insert_after2.cc,\n+\terase_after8.cc, insert_after3.cc, erase_after9.cc: New\n+\n 2010-09-28  DJ Delorie  <dj@redhat.com>\n \n \t* libsupc++/hash_bytes.cc (_Hash_bytes): Replace \"clength\" with"}, {"sha": "3723f9f2102fc6ef62d3bd10f69ca3fdd65e1582", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -719,6 +719,7 @@ debug_headers = \\\n \t${debug_srcdir}/debug.h \\\n \t${debug_srcdir}/deque \\\n \t${debug_srcdir}/formatter.h \\\n+\t${debug_srcdir}/forward_list \\\n \t${debug_srcdir}/functions.h \\\n \t${debug_srcdir}/list \\\n \t${debug_srcdir}/map \\"}, {"sha": "87f5b8f4397fe6cf31346f91322c0e9b95243f95", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -953,6 +953,7 @@ debug_headers = \\\n \t${debug_srcdir}/debug.h \\\n \t${debug_srcdir}/deque \\\n \t${debug_srcdir}/formatter.h \\\n+\t${debug_srcdir}/forward_list \\\n \t${debug_srcdir}/functions.h \\\n \t${debug_srcdir}/list \\\n \t${debug_srcdir}/map \\"}, {"sha": "5c77f311a535fa235cf1b39fb584e626a8f53f27", "filename": "libstdc++-v3/include/bits/forward_list.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -34,7 +34,7 @@\n #include <memory>\n #include <initializer_list>\n \n-_GLIBCXX_BEGIN_NAMESPACE(std)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   /**\n    *  @brief  A helper basic node class for %forward_list.\n@@ -1289,6 +1289,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t forward_list<_Tp, _Alloc>& __ly)\n     { __lx.swap(__ly); }\n \n-_GLIBCXX_END_NAMESPACE // namespace std\n+_GLIBCXX_END_NESTED_NAMESPACE // namespace std\n \n #endif // _FORWARD_LIST_H"}, {"sha": "caea0596b633192ae243c3df83aba6940629164b", "filename": "libstdc++-v3/include/bits/forward_list.tcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -29,7 +29,7 @@\n #ifndef _FORWARD_LIST_TCC\n #define _FORWARD_LIST_TCC 1\n \n-_GLIBCXX_BEGIN_NAMESPACE(std)\n+_GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \n   template<typename _Tp, typename _Alloc>\n     _Fwd_list_base<_Tp, _Alloc>::\n@@ -491,7 +491,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n           }\n       }\n  \n-_GLIBCXX_END_NAMESPACE // namespace std\n+_GLIBCXX_END_NESTED_NAMESPACE // namespace std\n \n #endif /* _FORWARD_LIST_TCC */\n "}, {"sha": "3aa5a8af04310188c52552cef7ad3433b1501017", "filename": "libstdc++-v3/include/debug/formatter.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -113,7 +113,11 @@ namespace __gnu_debug\n     __msg_output_ostream,\n     // istreambuf_iterator\n     __msg_deref_istreambuf,\n-    __msg_inc_istreambuf\n+    __msg_inc_istreambuf,\n+    // forward_list\n+    __msg_insert_after_end,\n+    __msg_erase_after_bad,\n+    __msg_valid_range2\n   };\n \n   class _Error_formatter\n@@ -135,6 +139,7 @@ namespace __gnu_debug\n       __begin,         // dereferenceable, and at the beginning\n       __middle,        // dereferenceable, not at the beginning\n       __end,           // past-the-end, may be at beginning if sequence empty\n+      __before_begin,  // before begin\n       __last_state\n     };\n \n@@ -234,11 +239,11 @@ namespace __gnu_debug\n \t    _M_variant._M_iterator._M_state = __singular;\n \t  else\n \t    {\n-\t      bool __is_begin = __it._M_is_begin();\n-\t      bool __is_end = __it._M_is_end();\n-\t      if (__is_end)\n+\t      if (__it._M_is_before_begin())\n+\t\t_M_variant._M_iterator._M_state = __before_begin;\n+\t      else if (__it._M_is_end())\n \t\t_M_variant._M_iterator._M_state = __end;\n-\t      else if (__is_begin)\n+\t      else if (__it._M_is_begin())\n \t\t_M_variant._M_iterator._M_state = __begin;\n \t      else\n \t\t_M_variant._M_iterator._M_state = __middle;"}, {"sha": "520ece4a09ce4e38d5d6bbebe33ccabeb139c6c3", "filename": "libstdc++-v3/include/debug/forward_list", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,654 @@\n+// <forward_list> -*- C++ -*-\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file debug/forward_list\n+ *  This file is a GNU debug extension to the Standard C++ Library.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_FORWARD_LIST\n+#define _GLIBCXX_DEBUG_FORWARD_LIST 1\n+\n+#pragma GCC system_header\n+\n+#include <forward_list>\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace std\n+{\n+namespace __debug\n+{\n+  /// Class std::forward_list with safety/checking/debug instrumentation.\n+  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n+    class forward_list\n+    : public _GLIBCXX_STD_D::forward_list<_Tp, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<forward_list<_Tp, _Alloc> >\n+    {\n+      typedef _GLIBCXX_STD_D::forward_list<_Tp, _Alloc> _Base;\n+      typedef __gnu_debug::_Safe_sequence<forward_list> _Safe_base;\n+\n+    public:\n+      typedef typename _Base::reference             reference;\n+      typedef typename _Base::const_reference       const_reference;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+\t\t\t\t\t  forward_list> iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  forward_list> const_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+\n+      typedef _Tp                                   value_type;\n+      typedef _Alloc                                allocator_type;\n+      typedef typename _Base::pointer               pointer;\n+      typedef typename _Base::const_pointer         const_pointer;\n+\n+      // 23.2.3.1 construct/copy/destroy:\n+      explicit\n+      forward_list(const _Alloc& __al = _Alloc())\n+      : _Base(__al) { }\n+\n+      forward_list(const forward_list& __list, const _Alloc& __al)\n+      : _Base(__list, __al)\n+      { }\n+\n+      forward_list(forward_list&& __list, const _Alloc& __al)\n+      : _Base(std::move(__list), __al)\n+      {\n+\tthis->_M_swap(__list);\n+      }\n+\n+      explicit\n+      forward_list(size_type __n)\n+      : _Base(__n)\n+      { }\n+\n+      forward_list(size_type __n, const _Tp& __value,\n+                   const _Alloc& __al = _Alloc())\n+      : _Base(__n, __value, __al)\n+      { }\n+\n+      template<typename _InputIterator>\n+        forward_list(_InputIterator __first, _InputIterator __last,\n+                     const _Alloc& __al = _Alloc())\n+        : _Base(__gnu_debug::__base(__gnu_debug::__check_valid_range(__first,\n+\t\t\t\t\t\t\t\t     __last)),\n+\t\t__gnu_debug::__base(__last), __al)\n+        { }\n+\n+      forward_list(const forward_list& __list)\n+      : _Base(__list)\n+      { }\n+\n+      forward_list(forward_list&& __list)\n+      : _Base(std::move(__list)) { }\n+\n+      forward_list(std::initializer_list<_Tp> __il,\n+                   const _Alloc& __al = _Alloc())\n+      : _Base(__il, __al)\n+      { }\n+\n+      ~forward_list()\n+      { }\n+\n+      forward_list&\n+      operator=(const forward_list& __list)\n+      {\n+\tstatic_cast<_Base&>(*this) = __list;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+\n+      forward_list&\n+      operator=(forward_list&& __list)\n+      {\n+\t// NB: DR 1204.\n+\t// NB: DR 675.\n+\tclear();\n+\tswap(__list);\n+\treturn *this;\n+      }\n+\n+      forward_list&\n+      operator=(std::initializer_list<_Tp> __il)\n+      {\n+\tstatic_cast<_Base&>(*this) = __il;\n+\tthis->_M_invalidate_all();\n+        return *this;\n+      }\n+\n+      template<typename _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::assign(__gnu_debug::__base(__first),\n+\t\t\t__gnu_debug::__base(__last));\n+\t  this->_M_invalidate_all();\n+        }\n+\n+      void\n+      assign(size_type __n, const _Tp& __val)\n+      {\n+\t_Base::assign(__n, __val);\n+\tthis->_M_invalidate_all();\n+      }\n+\n+      void\n+      assign(std::initializer_list<_Tp> __il)\n+      {\n+\t_Base::assign(__il);\n+\tthis->_M_invalidate_all();\n+      }\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+\n+      iterator\n+      before_begin()\n+      { return iterator(_Base::before_begin(), this); }\n+\n+      const_iterator\n+      before_begin() const\n+      { return const_iterator(_Base::before_begin(), this); }\n+\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::cbegin(), this); }\n+\n+      const_iterator\n+      cbefore_begin() const\n+      { return const_iterator(_Base::cbefore_begin(), this); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::cend(), this); }\n+\n+      using _Base::empty;\n+      using _Base::max_size;\n+\n+      // element access:\n+\n+      reference\n+      front()\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+\n+      const_reference\n+      front() const\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+\n+      // modi\ufb01ers:\n+\n+      using _Base::emplace_front;\n+      using _Base::push_front;\n+\n+      void\n+      pop_front()\n+      {\n+\t__glibcxx_check_nonempty();\n+\titerator __victim = begin();\n+\t__victim._M_invalidate();\n+\t_Base::pop_front();\n+      }\n+\n+      template<typename... _Args>\n+\titerator\n+\templace_after(const_iterator __pos, _Args&&... __args)\n+\t{\n+\t  __glibcxx_check_insert_after(__pos);\n+\t  return iterator(_Base::emplace_after(__pos.base(),\n+\t\t\t\t\tstd::forward<_Args>(__args)...),\n+\t\t\t  this);\n+       \t}\n+\n+      iterator\n+      insert_after(const_iterator __pos, const _Tp& __val)\n+      {\n+\t__glibcxx_check_insert_after(__pos);\n+\treturn iterator(_Base::insert_after(__pos.base(), __val), this);\n+      }\n+\n+      iterator\n+      insert_after(const_iterator __pos, _Tp&& __val)\n+      {\n+\t__glibcxx_check_insert_after(__pos);\n+\treturn iterator(_Base::insert_after(__pos.base(), std::move(__val)),\n+\t\t       \tthis);\n+      }\n+\n+      iterator\n+      insert_after(const_iterator __pos, size_type __n, const _Tp& __val)\n+      {\n+\t__glibcxx_check_insert_after(__pos);\n+\treturn iterator(_Base::insert_after(__pos.base(), __n, __val),\n+\t\t       \tthis);\n+      }\n+\n+      template<typename _InputIterator>\n+        iterator\n+        insert_after(const_iterator __pos,\n+                     _InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_insert_range_after(__pos, __first, __last);\n+\t  return iterator(_Base::insert_after(__pos.base(),\n+\t\t\t\t\t      __gnu_debug::__base(__first),\n+\t\t\t\t\t      __gnu_debug::__base(__last)),\n+\t\t\t  this);\n+        }\n+\n+      iterator\n+      insert_after(const_iterator __pos, std::initializer_list<_Tp> __il)\n+      {\n+\t__glibcxx_check_insert_after(__pos);\n+\treturn iterator(_Base::insert_after(__pos.base(), __il), this);\n+      }\n+\n+      void\n+      erase_after(const_iterator __pos)\n+      {\n+\t__glibcxx_check_erase_after(__pos);\n+\tconst_iterator __victim = __pos;\n+\t++__victim;\n+\t__victim._M_invalidate();\n+\t_Base::erase_after(__pos.base());\n+      }\n+\n+      void\n+      erase_after(const_iterator __pos, const_iterator __last)\n+      {\n+\t__glibcxx_check_erase_range_after(__pos, __last);\n+\tfor (const_iterator __victim = std::next(__pos); __victim != __last; )\n+\t  {\n+\t    const_iterator __old = __victim++;\n+\t    __old._M_invalidate();\n+\t  }\n+\t_Base::erase_after(__pos.base(), __last.base());\n+      }\n+\n+      void\n+      swap(forward_list& __list)\n+      {\n+\t_Base::swap(__list);\n+\tthis->_M_swap(__list);\n+      }\n+\n+      void\n+      resize(size_type __sz)\n+      {\n+\tthis->_M_detach_singular();\n+\n+\t// if __sz < size(), invalidate all iterators in [begin+__sz, end()\n+\titerator __victim = begin();\n+\titerator __end = end();\n+\tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n+\t  ++__victim;\n+\n+\twhile (__victim != __end)\n+\t  {\n+\t    iterator __real_victim = __victim++;\n+\t    __real_victim._M_invalidate();\n+\t  }\n+\n+\t__try\n+\t  {\n+\t    _Base::resize(__sz);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    this->_M_revalidate_singular();\n+\t    __throw_exception_again;\n+          }\n+      }\n+\n+      void\n+      resize(size_type __sz, const value_type& __val)\n+      {\n+\tthis->_M_detach_singular();\n+\n+\t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n+\titerator __victim = begin();\n+\titerator __end = end();\n+\tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n+\t  ++__victim;\n+\n+\twhile (__victim != __end)\n+\t  {\n+\t    iterator __real_victim = __victim++;\n+\t    __real_victim._M_invalidate();\n+\t  }\n+\n+\t__try\n+\t  {\n+\t    _Base::resize(__sz, __val);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    this->_M_revalidate_singular();\n+\t    __throw_exception_again;\n+          }\n+      }\n+\n+      void\n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+\n+      // 23.2.3.5 forward_list operations:\n+    private:\n+      void\n+      _M_splice_after(const_iterator __pos, forward_list&& __list,\n+\t\t      const_iterator __before, const_iterator __last)\n+      {\n+\tfor (const_iterator __tmp = std::next(__before); __tmp != __last; )\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(&__list != this || __tmp != __pos,\n+                                  _M_message(__gnu_debug::__msg_splice_overlap)\n+                                  ._M_iterator(__tmp, \"position\")\n+\t\t\t\t  ._M_iterator(__before, \"before\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    const_iterator __victim = __tmp++;\n+\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t    // 250. splicing invalidates iterators\n+\t    this->_M_transfer_iter(__victim);\n+\t  }\n+\n+\t_Base::splice_after(__pos.base(), std::move(__list._M_base()),\n+\t\t\t    __before.base(), __last.base());\n+      }\n+\n+    public:\n+      void\n+      splice_after(const_iterator __pos, forward_list&& __list)\n+      {\n+        __glibcxx_check_insert_after(__pos);\n+\t_GLIBCXX_DEBUG_VERIFY(&__list != this,\n+\t\t\t      _M_message(__gnu_debug::__msg_self_splice)\n+\t\t\t      ._M_sequence(*this, \"this\"));\n+\t_M_splice_after(__pos, std::move(__list),\n+\t\t\t__list.before_begin(), __list.end());\n+      }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list&& __list,\n+\t\t   const_iterator __i)\n+      {\n+\t__glibcxx_check_insert_after(__pos);\n+\t_GLIBCXX_DEBUG_VERIFY(__i._M_before_dereferenceable(),\n+\t\t\t      _M_message(__gnu_debug::__msg_splice_bad)\n+\t\t\t      ._M_iterator(__i, \"__i\"));\n+\t_GLIBCXX_DEBUG_VERIFY(__i._M_attached_to(&__list),\n+\t\t\t      _M_message(__gnu_debug::__msg_splice_other)\n+\t\t\t      ._M_iterator(__i, \"__i\")\n+\t\t\t      ._M_sequence(__list, \"__list\"));\n+\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 250. splicing invalidates iterators\n+\tthis->_M_transfer_iter(__i);\n+\t_Base::splice_after(__pos.base(), std::move(__list._M_base()),\n+\t\t\t    __i.base());\n+      }\n+\n+      void\n+      splice_after(const_iterator __pos, forward_list&& __list,\n+\t\t   const_iterator __before, const_iterator __last)\n+      {\n+        __glibcxx_check_insert_after(__pos);\n+\t__glibcxx_check_valid_range(__before, __last);\n+\t_GLIBCXX_DEBUG_VERIFY(__before._M_attached_to(&__list),\n+\t\t\t      _M_message(__gnu_debug::__msg_splice_other)\n+\t\t\t      ._M_sequence(__list, \"list\")\n+\t\t\t      ._M_iterator(__before, \"before\"));\n+\t_GLIBCXX_DEBUG_VERIFY(__before._M_dereferenceable()\n+\t\t\t      || __before._M_is_before_begin(),\n+\t\t\t      _M_message(__gnu_debug::__msg_valid_range2)\n+\t\t\t      ._M_sequence(__list, \"list\")\n+\t\t\t      ._M_iterator(__before, \"before\")\n+\t\t\t      ._M_iterator(__last, \"last\"));\n+\t_GLIBCXX_DEBUG_VERIFY(__before != __last,\n+\t\t\t      _M_message(__gnu_debug::__msg_valid_range2)\n+\t\t\t      ._M_sequence(__list, \"list\")\n+\t\t\t      ._M_iterator(__before, \"before\")\n+\t\t\t      ._M_iterator(__last, \"last\"));\n+\t_M_splice_after(__pos, std::move(__list), __before, __last);\n+      }\n+\n+      void\n+      remove(const _Tp& __val)\n+      {\n+\titerator __x = before_begin();\n+\titerator __old = __x++;\n+\twhile (__x.base() != _Base::end())\n+\t  {\n+\t    if (*__x == __val)\n+\t      {\n+\t\terase_after(__old);\n+\t\t__x = __old; ++__x;\n+\t      }\n+\t    else\n+\t      __old = __x++;\n+\t  }\n+      }\n+\n+      template<typename _Pred>\n+        void\n+        remove_if(_Pred __pred)\n+\t{\n+\t  iterator __x = before_begin();\n+\t  iterator __old = __x++;\n+\t  while (__x.base() != _Base::end())\n+\t    {\n+\t      if (__pred(*__x))\n+\t\t{\n+\t\t  erase_after(__old);\n+\t\t  __x = std::next(__old);\n+\t\t}\n+\t      else\n+\t\t__old = __x++;\n+\t    }\n+\t}\n+\n+      void\n+      unique()\n+      {\n+\titerator __first = begin();\n+\titerator __last = end();\n+\tif (__first == __last)\n+\t  return;\n+\titerator __next = __first;\n+\twhile (++__next != __last)\n+\t  {\n+\t    if (*__first == *__next)\n+\t      {\n+\t\terase_after(__first);\n+\t\t__next = __first;\n+\t      }\n+\t    else\n+\t      __first = __next;\n+\t  }\n+      }\n+\n+      template<typename _BinPred>\n+        void\n+        unique(_BinPred __binary_pred)\n+\t{\n+\t  iterator __first = begin();\n+\t  iterator __last = end();\n+\t  if (__first == __last)\n+\t    return;\n+\t  iterator __next = __first;\n+\t  while (++__next != __last)\n+\t    {\n+\t      if (__binary_pred(*__first, *__next))\n+\t\t{\n+\t\t  erase_after(__first);\n+\t\t  __next = __first;\n+\t\t}\n+\t      else\n+\t\t__first = __next;\n+\t    }\n+\t}\n+\n+      void\n+      merge(forward_list&& __list)\n+      {\n+\tif (this != &__list)\n+\t{\n+\t  __glibcxx_check_sorted(_Base::begin(), _Base::end());\n+\t  __glibcxx_check_sorted(__list._M_base().begin(),\n+\t\t\t\t __list._M_base().end());\n+\t  for (iterator __tmp = __list.begin(); __tmp != __list.end();)\n+\t    {\n+\t      iterator __victim = __tmp++;\n+\t      this->_M_transfer_iter(__victim);\n+\t    }\n+\t  _Base::merge(std::move(__list._M_base()));\n+\t}\n+      }\n+\n+      template<typename _Comp>\n+        void\n+        merge(forward_list&& __list, _Comp __comp)\n+\t{\n+\t  if (this != &__list)\n+\t  {\n+\t    __glibcxx_check_sorted_pred(_Base::begin(), _Base::end(), __comp);\n+\t    __glibcxx_check_sorted_pred(__list._M_base().begin(),\n+\t\t\t\t\t__list._M_base().end(), __comp);\n+\t    for (iterator __tmp = __list.begin(); __tmp != __list.end();)\n+\t      {\n+\t\titerator __victim = __tmp++;\n+\t\tthis->_M_transfer_iter(__victim);\n+\t      }\n+\t    _Base::merge(std::move(__list._M_base()), __comp);\n+\t  }\n+\t}\n+\n+      using _Base::sort;\n+      using _Base::reverse;\n+\n+      _Base&\n+      _M_base()       { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n+    private:\n+      void\n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    bool\n+    operator==(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    { return __lx._M_base() == __ly._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const forward_list<_Tp, _Alloc>& __lx,\n+              const forward_list<_Tp, _Alloc>& __ly)\n+    { return __lx._M_base() < __ly._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    { return !(__lx == __ly); }\n+\n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const forward_list<_Tp, _Alloc>& __lx,\n+              const forward_list<_Tp, _Alloc>& __ly)\n+    { return (__ly < __lx); }\n+\n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    { return !(__lx < __ly); }\n+\n+  /// Based on operator<\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const forward_list<_Tp, _Alloc>& __lx,\n+               const forward_list<_Tp, _Alloc>& __ly)\n+    { return !(__ly < __lx); }\n+\n+  /// See std::forward_list::swap().\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(forward_list<_Tp, _Alloc>& __lx,\n+\t forward_list<_Tp, _Alloc>& __ly)\n+    { __lx.swap(__ly); }\n+\n+} // namespace __debug\n+} // namespace std\n+\n+namespace __gnu_debug\n+{\n+  template<class _Tp, class _Alloc>\n+    struct _BeforeBeginHelper<std::__debug::forward_list<_Tp, _Alloc> >\n+    {\n+      typedef typename forward_list<_Tp, _Alloc>::const_iterator _It;\n+\n+      static bool\n+      _M_Is(_It __it, const forward_list<_Tp, _Alloc>* __seq)\n+      { return __it == __seq->before_begin(); }\n+    };\n+}\n+\n+#endif"}, {"sha": "1244612118c1d2fc7c3521d0f76393988f7167d5", "filename": "libstdc++-v3/include/debug/macros.h", "status": "modified", "additions": 80, "deletions": 12, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -56,10 +56,10 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__valid_range(_First, _Last),\t\\\n \n /** Verify that we can insert into *this with the iterator _Position.\n  *  Insertion into a container at a specific position requires that\n- *  the iterator be nonsingular (i.e., either dereferenceable or\n- *  past-the-end) and that it reference the sequence we are inserting\n- *  into. Note that this macro is only valid when the container is a\n- *  _Safe_sequence and the iterator is a _Safe_iterator.\n+ *  the iterator be nonsingular, either dereferenceable or past-the-end,\n+ *  and that it reference the sequence we are inserting into. Note that\n+ *  this macro is only valid when the container is a_Safe_sequence and\n+ *  the iterator is a _Safe_iterator.\n */\n #define __glibcxx_check_insert(_Position)\t\t\t\t\\\n _GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n@@ -71,6 +71,20 @@ _GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n \t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n \t\t      ._M_iterator(_Position, #_Position))\n \n+/** Verify that we can insert into *this after the iterator _Position.\n+ *  Insertion into a container after a specific position requires that\n+ *  the iterator be nonsingular, either dereferenceable or before-begin,\n+ *  and that it reference the sequence we are inserting into. Note that\n+ *  this macro is only valid when the container is a_Safe_sequence and\n+ *  the iterator is a _Safe_iterator.\n+*/\n+#define __glibcxx_check_insert_after(_Position)\t\t\t\t\\\n+__glibcxx_check_insert(_Position);\t\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(!_Position._M_is_end(),\t\t\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_insert_after_end)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n /** Verify that we can insert the values in the iterator range\n  *  [_First, _Last) into *this with the iterator _Position.  Insertion\n  *  into a container at a specific position requires that the iterator\n@@ -86,14 +100,24 @@ _GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n */\n #define __glibcxx_check_insert_range(_Position,_First,_Last)\t\t\\\n __glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n-\t\t      _M_message(__gnu_debug::__msg_insert_singular)    \\\n-                      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n-\t\t      _M_message(__gnu_debug::__msg_insert_different)   \\\n-\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position))\n+__glibcxx_check_insert(_Position)\n+\n+/** Verify that we can insert the values in the iterator range\n+ *  [_First, _Last) into *this after the iterator _Position.  Insertion\n+ *  into a container after a specific position requires that the iterator\n+ *  be nonsingular (i.e., either dereferenceable or past-the-end),\n+ *  that it reference the sequence we are inserting into, and that the\n+ *  iterator range [_First, Last) is a valid (possibly empty)\n+ *  range. Note that this macro is only valid when the container is a\n+ *  _Safe_sequence and the iterator is a _Safe_iterator.\n+ *\n+ *  @todo We would like to be able to check for noninterference of\n+ *  _Position and the range [_First, _Last), but that can't (in\n+ *  general) be done.\n+*/\n+#define __glibcxx_check_insert_range_after(_Position,_First,_Last)\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+__glibcxx_check_insert_after(_Position)\n \n /** Verify that we can erase the element referenced by the iterator\n  * _Position. We can erase the element if the _Position iterator is\n@@ -109,6 +133,20 @@ _GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n \t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n \t\t      ._M_iterator(_Position, #_Position))\n \n+/** Verify that we can erase the element after the iterator\n+ * _Position. We can erase the element if the _Position iterator is\n+ * before a dereferenceable one and references this sequence.\n+*/\n+#define __glibcxx_check_erase_after(_Position)\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_before_dereferenceable(),\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_erase_after_bad)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_erase_different)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n /** Verify that we can erase the elements in the iterator range\n  *  [_First, _Last). We can erase the elements if [_First, _Last) is a\n  *  valid iterator range within this sequence.\n@@ -121,6 +159,36 @@ _GLIBCXX_DEBUG_VERIFY(_First._M_attached_to(this),\t\t\t\\\n \t\t      ._M_iterator(_First, #_First)\t\t\t\\\n \t\t      ._M_iterator(_Last, #_Last))\n \n+/** Verify that we can erase the elements in the iterator range\n+ *  (_First, _Last). We can erase the elements if (_First, _Last) is a\n+ *  valid iterator range within this sequence.\n+*/\n+#define __glibcxx_check_erase_range_after(_First,_Last)\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_First._M_can_compare(_Last),\t\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_erase_different)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last));\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_First._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_erase_different)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_First, #_First));\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_First != _Last,\t\t\t\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_valid_range2)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last));\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_First._M_incrementable(),\t\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_valid_range2)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last));\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(!_Last._M_is_before_begin(),\t\t\t\\\n+\t\t      _M_message(__gnu_debug::__msg_valid_range2)\t\\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\t\t\t\\\n+\n // Verify that the subscript _N is less than the container's size.\n #define __glibcxx_check_subscript(_N)\t\t\t\t\t\\\n _GLIBCXX_DEBUG_VERIFY(_N < this->size(),\t\t\t\t\\"}, {"sha": "1d479458817662448f2571a90da31200e0ef019d", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -40,6 +40,19 @@\n \n namespace __gnu_debug\n {\n+  /** Helper struct to deal with sequence offering a before_begin\n+   *  iterator.\n+   **/\n+  template <typename _Sequence>\n+    struct _BeforeBeginHelper\n+    {\n+      typedef typename _Sequence::const_iterator _It;\n+\n+      static bool\n+      _M_Is(_It __it, const _Sequence* __seq)\n+      { return false; }\n+    };\n+\n   /** Iterators that derive from _Safe_iterator_base but that aren't\n    *  _Safe_iterators can be determined singular or non-singular via\n    *  _Safe_iterator_base.\n@@ -343,11 +356,20 @@ namespace __gnu_debug\n       /// Is the iterator dereferenceable?\n       bool\n       _M_dereferenceable() const\n-      { return !this->_M_singular() && !_M_is_end(); }\n+      { return !this->_M_singular() && !_M_is_end() && !_M_is_before_begin(); }\n+\n+      /// Is the iterator before a dereferenceable one?\n+      bool\n+      _M_before_dereferenceable() const\n+      {\n+\t_Self __it = *this;\n+\treturn __it._M_incrementable() && (++__it)._M_dereferenceable();\n+      }\n \n       /// Is the iterator incrementable?\n       bool\n-      _M_incrementable() const { return this->_M_dereferenceable(); }\n+      _M_incrementable() const\n+      { return !this->_M_singular() && !_M_is_end(); }\n \n       // Is the iterator decrementable?\n       bool\n@@ -398,11 +420,16 @@ namespace __gnu_debug\n \n       /// Is this iterator equal to the sequence's begin() iterator?\n       bool _M_is_begin() const\n-      {\treturn *this == static_cast<const _Sequence*>(_M_sequence)->begin(); }\n+      { return *this == _M_get_sequence()->begin(); }\n \n       /// Is this iterator equal to the sequence's end() iterator?\n       bool _M_is_end() const\n-      {\treturn *this == static_cast<const _Sequence*>(_M_sequence)->end(); }\n+      { return *this == _M_get_sequence()->end(); }\n+\n+      /// Is this iterator equal to the sequence's before_begin() iterator if\n+      /// any?\n+      bool _M_is_before_begin() const\n+      { return _BeforeBeginHelper<_Sequence>::_M_Is(*this, _M_get_sequence()); }\n     };\n \n   template<typename _IteratorL, typename _IteratorR, typename _Sequence>"}, {"sha": "322235203e781b5ff9abc7a6807df3320542755b", "filename": "libstdc++-v3/include/std/forward_list", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fforward_list?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -42,6 +42,10 @@\n # include <bits/forward_list.tcc>\n #endif\n \n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/forward_list>\n+#endif\n+\n #endif // __GXX_EXPERIMENTAL_CXX0X__\n \n #endif // _GLIBCXX_FORWARD_LIST"}, {"sha": "3deb527568bed77b5370d9507a3ed009ef6d1b11", "filename": "libstdc++-v3/src/debug.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -1,6 +1,6 @@\n // Debugging mode support code -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -105,7 +105,12 @@ namespace __gnu_debug\n     \"attempt to output via an ostream_iterator with no associated stream\",\n     \"attempt to dereference an end-of-stream istreambuf_iterator\"\n     \" (this is a GNU extension)\",\n-    \"attempt to increment an end-of-stream istreambuf_iterator\"\n+    \"attempt to increment an end-of-stream istreambuf_iterator\",\n+    \"attempt to insert into container after an end iterator\",\n+    \"attempt to erase from container after a %2.state; iterator not followed\"\n+    \" by a dereferenceable one\",\n+    \"function requires a valid iterator range (%1.name;, %2.name;)\"\n+    \", %1.name; shall not be equal to %2.name;\"\n   };\n \n   void\n@@ -325,7 +330,8 @@ namespace __gnu_debug\n \t\t\"singular\",\n \t\t\"dereferenceable (start-of-sequence)\",\n \t\t\"dereferenceable\",\n-\t\t\"past-the-end\"\n+\t\t\"past-the-end\",\n+\t\t\"before begin\"\n \t      };\n \t    __formatter->_M_print_word(__state_names[_M_variant.\n \t\t\t\t\t\t     _M_iterator._M_state]);"}, {"sha": "5bb9fb98b40d2c36c0fd3f5b2ec138c1687cbf97", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/capacity/1.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcapacity%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcapacity%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcapacity%2F1.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -38,8 +38,14 @@ test01()\n   fld.resize(0);\n   VERIFY(fld.empty() == true);\n \n+#ifndef _GLIBCXX_DEBUG\n+  using std::_Fwd_list_node;\n+#else\n+  using std::_GLIBCXX_STD_D::_Fwd_list_node;\n+#endif\n+\n   VERIFY( (fld.max_size()\n-\t   == std::allocator<std::_Fwd_list_node<double> >().max_size()) );\n+\t   == std::allocator<_Fwd_list_node<double> >().max_size()) );\n }\n \n int"}, {"sha": "f2cd59370a2574302b47f7d2c84a7de844486885", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after1.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after1.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::forward_list<int> fl1{1, 2, 3};\n+\n+  auto it = fl1.begin();\n+  VERIFY( *it == 1 );\n+\n+  fl1.erase_after(fl1.before_begin());\n+\n+  VERIFY( *it == 1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6e2433595051ef9b28a3630f9bc272d467b16bff", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after2.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after2.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  fl1.erase_after(fl1.end());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "70a0a3456884224178d6dded250b440d11e5b125", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after3.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after3.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1};\n+  fl1.erase_after(fl1.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9e4b3d49933a993eeafe05d976f3ab9fe0634c05", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after4.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after4.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{1, 2, 3};\n+\n+  fl1.erase_after(fl1.before_begin(), fl2.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6aabbea6085877eff97ecaa180795aeac6c572d8", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after5.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after5.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{1, 2, 3};\n+\n+  fl1.erase_after(fl2.before_begin(), fl2.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "29c418a08ddd9d1249ef7bbb239019134bf02c91", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after6.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after6.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+\n+  fl1.erase_after(fl1.before_begin(), fl1.before_begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9390827c0866e97c12857b11875076a0e61c7a8b", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after7.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after7.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+\n+  fl1.erase_after(fl1.end(), fl1.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "77dcb750eb766e68626e0331c6acb89b432c68d2", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after8.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after8.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+\n+  fl1.erase_after(fl1.begin(), fl1.before_begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "42fe2023423c2f2901e8e9654426ce6f36cf2a54", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/erase_after9.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after9.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after9.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Ferase_after9.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+\n+  auto it = fl1.begin();\n+  ++it;\n+  fl1.erase_after(it, fl1.begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "08d49a54ab3686d81d7d7c3d5bbf5ca3f88a8928", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/insert_after1.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after1.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{1, 2, 3};\n+\n+  fl1.insert_after(fl1.before_begin(), fl2.before_begin(), fl2.end());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "db9fd5e093c0a3afcf2fb949f8f440a752b72441", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/insert_after2.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after2.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+  std::forward_list<int> fl2{0};\n+\n+  fl1.insert_after(fl1.before_begin(), fl2.begin(), fl2.before_begin());\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4ad698f3c9579940957706e7d63cb97809b943f5", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/debug/insert_after3.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fdebug%2Finsert_after3.cc?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-debug-mode \"\" }\n+// { dg-do run { xfail *-*-* } }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1{1, 2, 3};\n+\n+  fl1.insert_after(fl1.end(), 4);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "202352dec8cbb0b0ad83a83edb2415fb94f579df", "filename": "libstdc++-v3/testsuite/util/exception/safety.h", "status": "modified", "additions": 125, "deletions": 9, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Fexception%2Fsafety.h?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -347,8 +347,14 @@ namespace __gnu_test\n \t  _F_erase_range(&container_type::erase) { }\n       };\n \n-    template<typename _Tp, bool = traits<_Tp>::has_erase::value>\n-      struct erase_point : public erase_base<_Tp>\n+    template<typename _Tp,\n+\t     bool = traits<_Tp>::has_erase::value,\n+\t     bool = traits<_Tp>::has_erase_after::value>\n+      struct erase_point;\n+\n+    // Specialization for most containers.\n+    template<typename _Tp>\n+      struct erase_point<_Tp, true, false> : public erase_base<_Tp>\n       {\n \tusing erase_base<_Tp>::_F_erase_point;\n \n@@ -374,17 +380,51 @@ namespace __gnu_test\n \t}\n       };\n \n+    // Specialization for forward_list.\n+    template<typename _Tp>\n+      struct erase_point<_Tp, false, true> : public erase_base<_Tp>\n+      {\n+\tusing erase_base<_Tp>::_F_erase_point;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      // NB: Should be equivalent to size() member function, but\n+\t      // computed with begin() and end().\n+\t      const size_type sz = std::distance(__container.begin(),\n+\t\t\t\t\t\t __container.end());\n+\n+\t      // NB: Lowest common denominator: use forward iterator operations.\n+\t      auto i = __container.before_begin();\n+\t      std::advance(i, generate(sz));\n+\n+\t      // Makes it easier to think of this as __container.erase(i)\n+\t      (__container.*_F_erase_point)(i);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n     // Specialization, empty.\n     template<typename _Tp>\n-      struct erase_point<_Tp, false>\n+      struct erase_point<_Tp, false, false>\n       {\n \tvoid\n \toperator()(_Tp&) { }\n       };\n \n \n-    template<typename _Tp, bool = traits<_Tp>::has_erase::value>\n-      struct erase_range : public erase_base<_Tp>\n+    template<typename _Tp,\n+\t     bool = traits<_Tp>::has_erase::value,\n+\t     bool = traits<_Tp>::has_erase_after::value>\n+      struct erase_range;\n+\n+    // Specialization for most containers.\n+    template<typename _Tp>\n+      struct erase_range<_Tp, true, false> : public erase_base<_Tp>\n       {\n \tusing erase_base<_Tp>::_F_erase_range;\n \n@@ -410,9 +450,37 @@ namespace __gnu_test\n \t}\n       };\n \n+    // Specialization for forward_list.\n+    template<typename _Tp>\n+      struct erase_range<_Tp, false, true> : public erase_base<_Tp>\n+      {\n+\tusing erase_base<_Tp>::_F_erase_range;\n+\n+\tvoid\n+\toperator()(_Tp& __container)\n+\t{\n+\t  try\n+\t    {\n+\t      const size_type sz = std::distance(__container.begin(),\n+\t\t\t\t\t\t __container.end());\n+\t      size_type s1 = generate(sz);\n+\t      size_type s2 = generate(sz);\n+\t      auto i1 = __container.before_begin();\n+\t      auto i2 = __container.before_begin();\n+\t      std::advance(i1, std::min(s1, s2));\n+\t      std::advance(i2, std::max(s1, s2));\n+\n+\t      // Makes it easier to think of this as __container.erase(i1, i2).\n+\t      (__container.*_F_erase_range)(i1, i2);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+      };\n+\n     // Specialization, empty.\n     template<typename _Tp>\n-      struct erase_range<_Tp, false>\n+      struct erase_range<_Tp, false, false>\n       {\n \tvoid\n \toperator()(_Tp&) { }\n@@ -677,8 +745,14 @@ namespace __gnu_test\n \tinsert_base() : _F_insert_point(&container_type::insert) { }\n       };\n \n-    template<typename _Tp, bool = traits<_Tp>::has_insert::value>\n-      struct insert_point : public insert_base<_Tp>\n+    template<typename _Tp,\n+\t     bool = traits<_Tp>::has_insert::value,\n+\t     bool = traits<_Tp>::has_insert_after::value>\n+      struct insert_point;\n+\n+    // Specialization for most containers.\n+    template<typename _Tp>\n+      struct insert_point<_Tp, true, false> : public insert_base<_Tp>\n       {\n \ttypedef _Tp \t\t\t\t       \tcontainer_type;\n \ttypedef typename container_type::value_type \tvalue_type;\n@@ -718,9 +792,51 @@ namespace __gnu_test\n  \t}\n       };\n \n+    // Specialization for forward_list.\n+    template<typename _Tp>\n+      struct insert_point<_Tp, false, true> : public insert_base<_Tp>\n+      {\n+\ttypedef _Tp \t\t\t\t       \tcontainer_type;\n+\ttypedef typename container_type::value_type \tvalue_type;\n+\tusing insert_base<_Tp>::_F_insert_point;\n+\n+\tvoid\n+\toperator()(_Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.before_begin();\n+\t      std::advance(i, s);\n+\t      (__test.*_F_insert_point)(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+\t}\n+\n+\t// Assumes containers start out equivalent.\n+\tvoid\n+\toperator()(_Tp& __control, _Tp& __test)\n+\t{\n+\t  try\n+\t    {\n+\t      const value_type cv = generate_unique<value_type>();\n+\t      const size_type sz = std::distance(__test.begin(), __test.end());\n+\t      size_type s = generate(sz);\n+\t      auto i = __test.before_begin();\n+\t      std::advance(i, s);\n+\t      (__test.*_F_insert_point)(i, cv);\n+\t    }\n+\t  catch(const __gnu_cxx::forced_error&)\n+\t    { throw; }\n+ \t}\n+      };\n+\n     // Specialization, empty.\n     template<typename _Tp>\n-      struct insert_point<_Tp, false>\n+      struct insert_point<_Tp, false, false>\n       {\n \tvoid\n \toperator()(_Tp&) { }"}, {"sha": "4d8ff997ae8d77fd7e7d5e77eb58464a6b257d51", "filename": "libstdc++-v3/testsuite/util/testsuite_container_traits.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b4301eecf88d5f727f729a479b8020afe60fdc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_container_traits.h?ref=b8b4301eecf88d5f727f729a479b8020afe60fdc", "patch": "@@ -39,8 +39,10 @@ namespace __gnu_test\n     typedef std::false_type\tis_mapped;\n \n     typedef std::false_type\thas_erase;\n+    typedef std::false_type\thas_erase_after;\n     typedef std::false_type\thas_throwing_erase;\n     typedef std::false_type\thas_insert;\n+    typedef std::false_type\thas_insert_after;\n     typedef std::false_type\thas_push_pop;\n     typedef std::false_type\thas_size_type_constructor;\n   };\n@@ -78,8 +80,8 @@ namespace __gnu_test\n       typedef std::true_type\tis_container;\n       typedef std::true_type\tis_allocator_aware;\n \n-      typedef std::true_type\thas_erase;\n-      typedef std::true_type\thas_insert;\n+      typedef std::true_type\thas_erase_after;\n+      typedef std::true_type\thas_insert_after;\n       typedef std::true_type\thas_push_pop;\n       typedef std::true_type\thas_size_type_constructor;\n     };"}]}