{"sha": "da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGExZjM5ZTQ3NWJmMjQzM2UyY2UxMjc3YzEwMTVhZDRhYjMyOTFlMw==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2007-02-03T01:23:05Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2007-02-03T01:23:05Z"}, "message": "xtensa.c (smalloffset_mem_p): Use BASE_REG_P.\n\n\t* config/xtensa/xtensa.c (smalloffset_mem_p): Use BASE_REG_P.\n\t(xtensa_legitimate_address_p): New.\n\t(xtensa_legitimize_address): New.\n\t(xtensa_output_addr_const_extra): New.\n\t* config/xtensa/xtensa.h (REG_OK_STRICT_FLAG): Define.\n\t(BASE_REG_P): New.\n\t(REG_OK_FOR_BASE_P): Use BASE_REG_P.\n\t(GO_IF_LEGITIMATE_ADDRESS): Move code to xtensa_legitimate_address_p.\n\t(LEGITIMIZE_ADDRESS): Move code to xtensa_legitimize_address.\n\t(OUTPUT_ADDR_CONST_EXTRA): Move code to xtensa_output_addr_const_extra.\n\t* config/xtensa/xtensa-protos.h (xtensa_legitimate_address_p): New.\n\t(xtensa_legitimize_address): New.\n\t(xtensa_output_addr_const_extra): New.\n\nFrom-SVN: r121533", "tree": {"sha": "e49c050263858cb0da4d9f2ece61923906bdbf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e49c050263858cb0da4d9f2ece61923906bdbf02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/comments", "author": null, "committer": null, "parents": [{"sha": "2e6524ba30702e1134eec27f8c68ddd7083fc87d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6524ba30702e1134eec27f8c68ddd7083fc87d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6524ba30702e1134eec27f8c68ddd7083fc87d"}], "stats": {"total": 269, "additions": 154, "deletions": 115}, "files": [{"sha": "73626e6e689ae2a4a6b12547edc7342dbf6958ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "patch": "@@ -1,3 +1,19 @@\n+2007-02-02  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa.c (smalloffset_mem_p): Use BASE_REG_P.\n+\t(xtensa_legitimate_address_p): New.\n+\t(xtensa_legitimize_address): New.\n+\t(xtensa_output_addr_const_extra): New.\n+\t* config/xtensa/xtensa.h (REG_OK_STRICT_FLAG): Define.\n+\t(BASE_REG_P): New.\n+\t(REG_OK_FOR_BASE_P): Use BASE_REG_P.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Move code to xtensa_legitimate_address_p.\n+\t(LEGITIMIZE_ADDRESS): Move code to xtensa_legitimize_address.\n+\t(OUTPUT_ADDR_CONST_EXTRA): Move code to xtensa_output_addr_const_extra.\n+\t* config/xtensa/xtensa-protos.h (xtensa_legitimate_address_p): New.\n+\t(xtensa_legitimize_address): New.\n+\t(xtensa_output_addr_const_extra): New.\n+\n 2007-02-02  Steve Ellcey  <sje@cup.hp.com>\n \n \t* config/ia64/ia64.c (ia64_print_operand): Fix compare strings."}, {"sha": "f6cca7ac9754570aa327e0bd93f3029786fe39ee", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes of target machine for GNU compiler for Xtensa.\n-   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n This file is part of GCC.\n@@ -52,6 +52,8 @@ extern char *xtensa_emit_branch (bool, bool, rtx *);\n extern char *xtensa_emit_bit_branch (bool, bool, rtx *);\n extern char *xtensa_emit_movcc (bool, bool, bool, rtx *);\n extern char *xtensa_emit_call (int, rtx *);\n+extern bool xtensa_legitimate_address_p (enum machine_mode, rtx, bool);\n+extern rtx xtensa_legitimize_address (rtx, rtx, enum machine_mode);\n \n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, int);\n@@ -60,6 +62,7 @@ extern void xtensa_va_start (tree, rtx);\n \n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n+extern bool xtensa_output_addr_const_extra (FILE *, rtx);\n extern void xtensa_output_literal (FILE *, rtx, enum machine_mode, int);\n extern rtx xtensa_return_addr (int, rtx);\n extern enum reg_class xtensa_preferred_reload_class (rtx, enum reg_class, int);"}, {"sha": "6269f1feef2d44e6dffc2eb444afb86d655733f8", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "patch": "@@ -1,5 +1,6 @@\n /* Subroutines for insn-output.c for Tensilica's Xtensa architecture.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n This file is part of GCC.\n@@ -397,7 +398,7 @@ smalloffset_mem_p (rtx op)\n     {\n       rtx addr = XEXP (op, 0);\n       if (GET_CODE (addr) == REG)\n-\treturn REG_OK_FOR_BASE_P (addr);\n+\treturn BASE_REG_P (addr, 0);\n       if (GET_CODE (addr) == PLUS)\n \t{\n \t  rtx offset = XEXP (addr, 0);\n@@ -686,7 +687,8 @@ xtensa_expand_conditional_branch (rtx *operands, enum rtx_code test_code)\n \n     case CMP_SF:\n       if (!TARGET_HARD_FLOAT)\n-\tfatal_insn (\"bad test\", gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));\n+\tfatal_insn (\"bad test\", gen_rtx_fmt_ee (test_code, VOIDmode,\n+\t\t\t\t\t\tcmp0, cmp1));\n       invert = FALSE;\n       cmp = gen_float_relational (test_code, cmp0, cmp1);\n       break;\n@@ -1370,6 +1372,92 @@ xtensa_emit_call (int callop, rtx *operands)\n }\n \n \n+bool\n+xtensa_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n+{\n+  /* Allow constant pool addresses.  */\n+  if (mode != BLKmode && GET_MODE_SIZE (mode) >= UNITS_PER_WORD\n+      && ! TARGET_CONST16 && constantpool_address_p (addr))\n+    return true;\n+\n+  while (GET_CODE (addr) == SUBREG)\n+    addr = SUBREG_REG (addr);\n+\n+  /* Allow base registers.  */\n+  if (GET_CODE (addr) == REG && BASE_REG_P (addr, strict))\n+    return true;\n+\n+  /* Check for \"register + offset\" addressing.  */\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx xplus0 = XEXP (addr, 0);\n+      rtx xplus1 = XEXP (addr, 1);\n+      enum rtx_code code0;\n+      enum rtx_code code1;\n+\n+      while (GET_CODE (xplus0) == SUBREG)\n+\txplus0 = SUBREG_REG (xplus0);\n+      code0 = GET_CODE (xplus0);\n+\n+      while (GET_CODE (xplus1) == SUBREG)\n+\txplus1 = SUBREG_REG (xplus1);\n+      code1 = GET_CODE (xplus1);\n+\n+      /* Swap operands if necessary so the register is first.  */\n+      if (code0 != REG && code1 == REG)\n+\t{\n+\t  xplus0 = XEXP (addr, 1);\n+\t  xplus1 = XEXP (addr, 0);\n+\t  code0 = GET_CODE (xplus0);\n+\t  code1 = GET_CODE (xplus1);\n+\t}\n+\n+      if (code0 == REG && BASE_REG_P (xplus0, strict)\n+\t  && code1 == CONST_INT\n+\t  && xtensa_mem_offset (INTVAL (xplus1), mode))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+\n+rtx\n+xtensa_legitimize_address (rtx x,\n+\t\t\t   rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode)\n+{\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      rtx plus0 = XEXP (x, 0);\n+      rtx plus1 = XEXP (x, 1);\n+\n+      if (GET_CODE (plus0) != REG && GET_CODE (plus1) == REG)\n+\t{\n+\t  plus0 = XEXP (x, 1);\n+\t  plus1 = XEXP (x, 0);\n+\t}\n+\n+      /* Try to split up the offset to use an ADDMI instruction.  */\n+      if (GET_CODE (plus0) == REG\n+\t  && GET_CODE (plus1) == CONST_INT\n+\t  && !xtensa_mem_offset (INTVAL (plus1), mode)\n+\t  && !xtensa_simm8 (INTVAL (plus1))\n+\t  && xtensa_mem_offset (INTVAL (plus1) & 0xff, mode)\n+\t  && xtensa_simm8x256 (INTVAL (plus1) & ~0xff))\n+\t{\n+\t  rtx temp = gen_reg_rtx (Pmode);\n+\t  rtx addmi_offset = GEN_INT (INTVAL (plus1) & ~0xff);\n+\t  emit_insn (gen_rtx_SET (Pmode, temp,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, plus0, addmi_offset)));\n+\t  return gen_rtx_PLUS (Pmode, temp, GEN_INT (INTVAL (plus1) & 0xff));\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+\n /* Return the debugger register number to use for 'regno'.  */\n \n int\n@@ -1820,6 +1908,29 @@ print_operand_address (FILE *file, rtx addr)\n }\n \n \n+bool\n+xtensa_output_addr_const_extra (FILE *fp, rtx x)\n+{\n+  if (GET_CODE (x) == UNSPEC && XVECLEN (x, 0) == 1)\n+    {\n+      switch (XINT (x, 1))\n+\t{\n+\tcase UNSPEC_PLT:\n+\t  if (flag_pic)\n+\t    {\n+\t      output_addr_const (fp, XVECEXP (x, 0, 0));\n+\t      fputs (\"@PLT\", fp);\n+\t      return true;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return false;\n+}\n+\n+\n void\n xtensa_output_literal (FILE *file, rtx x, enum machine_mode mode, int labelno)\n {"}, {"sha": "11c4184a6d71db02b93de3b291beea4f2b61289a", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 20, "deletions": 111, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da1f39e475bf2433e2ce1277c1015ad4ab3291e3/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=da1f39e475bf2433e2ce1277c1015ad4ab3291e3", "patch": "@@ -1,5 +1,6 @@\n /* Definitions of Tensilica's Xtensa target machine for GNU compiler.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n This file is part of GCC.\n@@ -825,92 +826,36 @@ typedef struct xtensa_args\n /* Addressing modes, and classification of registers for them.  */\n \n /* C expressions which are nonzero if register number NUM is suitable\n-   for use as a base or index register in operand addresses.  It may\n-   be either a suitable hard register or a pseudo register that has\n-   been allocated such a hard register. The difference between an\n-   index register and a base register is that the index register may\n-   be scaled.  */\n+   for use as a base or index register in operand addresses.  */\n \n+#define REGNO_OK_FOR_INDEX_P(NUM) 0\n #define REGNO_OK_FOR_BASE_P(NUM) \\\n   (GP_REG_P (NUM) || GP_REG_P ((unsigned) reg_renumber[NUM]))\n \n-#define REGNO_OK_FOR_INDEX_P(NUM) 0\n-\n /* C expressions that are nonzero if X (assumed to be a `reg' RTX) is\n-   valid for use as a base or index register.  For hard registers, it\n-   should always accept those which the hardware permits and reject\n-   the others.  Whether the macro accepts or rejects pseudo registers\n-   must be controlled by `REG_OK_STRICT'.  This usually requires two\n-   variant definitions, of which `REG_OK_STRICT' controls the one\n-   actually used. The difference between an index register and a base\n-   register is that the index register may be scaled.  */\n+   valid for use as a base or index register.  */\n \n #ifdef REG_OK_STRICT\n+#define REG_OK_STRICT_FLAG 1\n+#else\n+#define REG_OK_STRICT_FLAG 0\n+#endif\n \n-#define REG_OK_FOR_INDEX_P(X) 0\n-#define REG_OK_FOR_BASE_P(X) \\\n-  REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#else /* !REG_OK_STRICT */\n+#define BASE_REG_P(X, STRICT)\t\t\t\t\t\t\\\n+  ((!(STRICT) && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\t\t\\\n+   || REGNO_OK_FOR_BASE_P (REGNO (X)))\n \n #define REG_OK_FOR_INDEX_P(X) 0\n-#define REG_OK_FOR_BASE_P(X) \\\n-  ((REGNO (X) >= FIRST_PSEUDO_REGISTER) || (GP_REG_P (REGNO (X))))\n-\n-#endif /* !REG_OK_STRICT */\n+#define REG_OK_FOR_BASE_P(X) BASE_REG_P (X, REG_OK_STRICT_FLAG)\n \n /* Maximum number of registers that can appear in a valid memory address.  */\n #define MAX_REGS_PER_ADDRESS 1\n \n /* Identify valid Xtensa addresses.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, ADDR, LABEL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    rtx xinsn = (ADDR);\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* allow constant pool addresses */\t\t\t\t\t\\\n-    if ((MODE) != BLKmode && GET_MODE_SIZE (MODE) >= UNITS_PER_WORD\t\\\n-\t&& !TARGET_CONST16 && constantpool_address_p (xinsn))\t\t\\\n-      goto LABEL;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    while (GET_CODE (xinsn) == SUBREG)\t\t\t\t\t\\\n-      xinsn = SUBREG_REG (xinsn);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* allow base registers */\t\t\t\t\t\t\\\n-    if (GET_CODE (xinsn) == REG && REG_OK_FOR_BASE_P (xinsn))\t\t\\\n+    if (xtensa_legitimate_address_p (MODE, ADDR, REG_OK_STRICT_FLAG))\t\\\n       goto LABEL;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* check for \"register + offset\" addressing */\t\t\t\\\n-    if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\trtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\t\\\n-\trtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\t\\\n-\tenum rtx_code code0;\t\t\t\t\t\t\\\n-\tenum rtx_code code1;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\twhile (GET_CODE (xplus0) == SUBREG)\t\t\t\t\\\n-\t  xplus0 = SUBREG_REG (xplus0);\t\t\t\t\t\\\n-\tcode0 = GET_CODE (xplus0);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\twhile (GET_CODE (xplus1) == SUBREG)\t\t\t\t\\\n-\t  xplus1 = SUBREG_REG (xplus1);\t\t\t\t\t\\\n-\tcode1 = GET_CODE (xplus1);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t/* swap operands if necessary so the register is first */\t\\\n-\tif (code0 != REG && code1 == REG)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    xplus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n-\t    xplus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n-\t    code0 = GET_CODE (xplus0);\t\t\t\t\t\\\n-\t    code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tif (code0 == REG && REG_OK_FOR_BASE_P (xplus0)\t\t\t\\\n-\t    && code1 == CONST_INT\t\t\t\t\t\\\n-\t    && xtensa_mem_offset (INTVAL (xplus1), (MODE)))\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* A C expression that is 1 if the RTX X is a constant which is a\n@@ -934,36 +879,13 @@ typedef struct xtensa_args\n    && GET_CODE (X) != LABEL_REF\t\t\t\t\t\t\\\n    && GET_CODE (X) != CONST)\n \n-/* Tell GCC how to use ADDMI to generate addresses.  */\n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    rtx xinsn = (X);\t\t\t\t\t\t\t\\\n-    if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\\\n-      { \t\t\t\t\t\t\t\t\\\n-\trtx plus0 = XEXP (xinsn, 0);\t\t\t\t\t\\\n-\trtx plus1 = XEXP (xinsn, 1);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (plus0) != REG && GET_CODE (plus1) == REG)\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    plus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n-\t    plus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (plus0) == REG\t\t\t\t\t\\\n-\t    && GET_CODE (plus1) == CONST_INT\t\t\t\t\\\n-\t    && !xtensa_mem_offset (INTVAL (plus1), MODE)\t\t\\\n-\t    && !xtensa_simm8 (INTVAL (plus1))\t\t\t\t\\\n-\t    && xtensa_mem_offset (INTVAL (plus1) & 0xff, MODE)\t\t\\\n-\t    && xtensa_simm8x256 (INTVAL (plus1) & ~0xff))\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    rtx temp = gen_reg_rtx (Pmode);\t\t\t\t\\\n-\t    emit_insn (gen_rtx_SET (Pmode, temp,\t\t\t\\\n-\t\t\t\tgen_rtx_PLUS (Pmode, plus0,\t\t\\\n-\t\t\t\t\t GEN_INT (INTVAL (plus1) & ~0xff)))); \\\n-\t    (X) = gen_rtx_PLUS (Pmode, temp,\t\t\t\t\\\n-\t\t\t   GEN_INT (INTVAL (plus1) & 0xff));\t\t\\\n-\t    goto WIN;\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n+    rtx new_x = xtensa_legitimize_address (X, OLDX, MODE);\t\t\\\n+    if (new_x)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tX = new_x;\t\t\t\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n@@ -1066,20 +988,7 @@ typedef struct xtensa_args\n    constants.  Used for PIC-specific UNSPECs.  */\n #define OUTPUT_ADDR_CONST_EXTRA(STREAM, X, FAIL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    if (flag_pic && GET_CODE (X) == UNSPEC && XVECLEN ((X), 0) == 1)\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tswitch (XINT ((X), 1))\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t  case UNSPEC_PLT:\t\t\t\t\t\t\\\n-\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n-\t    fputs (\"@PLT\", (STREAM));\t\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\t\\\n-\t  default:\t\t\t\t\t\t\t\\\n-\t    goto FAIL;\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n+    if (xtensa_output_addr_const_extra (STREAM, X) == FALSE)\t\t\\\n       goto FAIL;\t\t\t\t\t\t\t\\\n   } while (0)\n "}]}