{"sha": "ec1e9f7c14b1fab314544d07709ba32a58323d9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMxZTlmN2MxNGIxZmFiMzE0NTQ0ZDA3NzA5YmEzMmE1ODMyM2Q5Yg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-03-01T18:12:39Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-03-01T18:12:39Z"}, "message": "Grrr, stupid patch program\n\nFrom-SVN: r95751", "tree": {"sha": "96be997f29c67d0caea620d54fe2032f59733c8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96be997f29c67d0caea620d54fe2032f59733c8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec1e9f7c14b1fab314544d07709ba32a58323d9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1e9f7c14b1fab314544d07709ba32a58323d9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec1e9f7c14b1fab314544d07709ba32a58323d9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1e9f7c14b1fab314544d07709ba32a58323d9b/comments", "author": null, "committer": null, "parents": [{"sha": "fa55525216546e41650f27058aecb62a2456613a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa55525216546e41650f27058aecb62a2456613a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa55525216546e41650f27058aecb62a2456613a"}], "stats": {"total": 570, "additions": 570, "deletions": 0}, "files": [{"sha": "d1ac56a1afe798ff7784479a0cef4099da6fcad3", "filename": "gcc/tree-ssa-sink.c", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec1e9f7c14b1fab314544d07709ba32a58323d9b/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec1e9f7c14b1fab314544d07709ba32a58323d9b/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=ec1e9f7c14b1fab314544d07709ba32a58323d9b", "patch": "@@ -0,0 +1,570 @@\n+/* Code sinking for trees\n+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dan@dberlin.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"fibheap.h\"\n+#include \"hashtab.h\"\n+#include \"tree-iterator.h\"\n+#include \"real.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+#include \"bitmap.h\"\n+#include \"langhooks.h\"\n+#include \"cfgloop.h\"\n+\n+/* TODO:\n+   1. Sinking store only using scalar promotion (IE without moving the RHS):\n+\n+   *q = p;\n+   p = p + 1;\n+   if (something)\n+     *q = <not p>;\n+   else\n+     y = *q;\n+\n+   \n+   should become\n+   sinktemp = p;\n+   p = p + 1;\n+   if (something)\n+     *q = <not p>;\n+   else\n+   {\n+     *q = sinktemp;\n+     y = *q\n+   }\n+   Store copy propagation will take care of the store elimination above.\n+     \n+\n+   2. Sinking using Partial Dead Code Elimination.  */\n+\n+\n+static struct\n+{  \n+  /* The number of statements sunk down the flowgraph by code sinking. */\n+  int sunk;\n+  \n+} sink_stats;\n+\n+\n+/* Given a PHI, and one of it's arguments (DEF), find the edge for\n+   that argument and return it.  If the argument occurs twice in the PHI node,\n+   we return NULL.  */\n+\n+static basic_block\n+find_bb_for_arg (tree phi, tree def)\n+{\n+  int i;\n+  bool foundone = false;\n+  basic_block result = NULL;\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    if (PHI_ARG_DEF (phi, i) == def)\n+      {\n+\tif (foundone)\n+\t  return NULL;\n+\tfoundone = true;\n+\tresult = PHI_ARG_EDGE (phi, i)->src;\n+      }\n+  return result;\n+}\n+\n+/* When the first immediate use is in a statement, then return true if all\n+   immediate uses in IMM are in the same statement.\n+   We could also do the case where  the first immediate use is in a phi node,\n+   and all the other uses are in phis in the same basic block, but this\n+   requires some expensive checking later (you have to make sure no def/vdef\n+   in the statement occurs for multiple edges in the various phi nodes it's\n+   used in, so that you only have one place you can sink it to. */\n+\n+static bool\n+all_immediate_uses_same_place (dataflow_t imm)\n+{\n+  int i;\n+  tree firstuse;\n+\n+  if (imm == NULL || num_immediate_uses (imm) < 2)\n+    return true;\n+  firstuse = immediate_use (imm, 0);\n+\n+  for (i = 1; i < num_immediate_uses (imm); i++)\n+    {\n+      tree immuse = immediate_use (imm, i);\n+      if (immuse != firstuse)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Some global stores don't necessarily have V_MAY_DEF's of global variables,\n+   but we still must avoid moving them around.  */\n+\n+bool\n+is_hidden_global_store (tree stmt)\n+{\n+  stmt_ann_t ann = stmt_ann (stmt);\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+    \n+  /* Check virtual definitions.  If we get here, the only virtual\n+     definitions we should see are those generated by assignment\n+     statements.  */\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  if (NUM_V_MAY_DEFS (v_may_defs) > 0 || NUM_V_MUST_DEFS (v_must_defs) > 0)\n+    {\n+      tree lhs;\n+\n+      gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+\n+      /* Note that we must not check the individual virtual operands\n+\t here.  In particular, if this is an aliased store, we could\n+\t end up with something like the following (SSA notation\n+\t redacted for brevity):\n+\n+\t \tfoo (int *p, int i)\n+\t\t{\n+\t\t  int x;\n+\t\t  p_1 = (i_2 > 3) ? &x : p;\n+\n+\t\t  # x_4 = V_MAY_DEF <x_3>\n+\t\t  *p_1 = 5;\n+\n+\t\t  return 2;\n+\t\t}\n+\n+\t Notice that the store to '*p_1' should be preserved, if we\n+\t were to check the virtual definitions in that store, we would\n+\t not mark it needed.  This is because 'x' is not a global\n+\t variable.\n+\n+\t Therefore, we check the base address of the LHS.  If the\n+\t address is a pointer, we check if its name tag or type tag is\n+\t a global variable.  Otherwise, we check if the base variable\n+\t is a global.  */\n+      lhs = TREE_OPERAND (stmt, 0);\n+      if (REFERENCE_CLASS_P (lhs))\n+\tlhs = get_base_address (lhs);\n+\n+      if (lhs == NULL_TREE)\n+\t{\n+\t  /* If LHS is NULL, it means that we couldn't get the base\n+\t     address of the reference.  In which case, we should not\n+\t     move this store.  */\n+\t  return true;\n+\t}\n+      else if (DECL_P (lhs))\n+\t{\n+\t  /* If the store is to a global symbol, we need to keep it.  */\n+\t  if (is_global_var (lhs))\n+\t    return true;\n+\n+\t}\n+      else if (INDIRECT_REF_P (lhs))\n+\t{\n+\t  tree ptr = TREE_OPERAND (lhs, 0);\n+\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\t  tree nmt = (pi) ? pi->name_mem_tag : NULL_TREE;\n+\t  tree tmt = var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+\n+\t  /* If either the name tag or the type tag for PTR is a\n+\t     global variable, then the store is necessary.  */\n+\t  if ((nmt && is_global_var (nmt))\n+\t      || (tmt && is_global_var (tmt)))\n+\t    {\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n+/* Find the nearest common dominator of all of the immediate uses in IMM.  */\n+\n+static basic_block\n+nearest_common_dominator_of_uses (dataflow_t imm)\n+{  \n+  bitmap blocks = BITMAP_ALLOC (NULL);\n+  basic_block commondom;\n+  int i;\n+  unsigned int j;\n+  bitmap_iterator bi;\n+  bitmap_clear (blocks);\n+  for (i = 0; i < num_immediate_uses (imm); i++)\n+    {\n+      tree usestmt = immediate_use (imm, i);\n+      basic_block useblock;\n+      if (TREE_CODE (usestmt) == PHI_NODE)\n+\t{\n+\t  int j;\n+\t  for (j = 0; j < PHI_NUM_ARGS (usestmt); j++)\n+\t    {\n+\t      useblock = PHI_ARG_EDGE (usestmt, j)->src;\n+\t      /* Short circuit. Nothing dominates the entry block.  */\n+\t      if (useblock == ENTRY_BLOCK_PTR)\n+\t\t{\n+\t\t  BITMAP_FREE (blocks);\n+\t\t  return NULL;\n+\t\t}\n+\t      bitmap_set_bit (blocks, useblock->index);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  useblock = bb_for_stmt (usestmt);\n+\n+\t  /* Short circuit. Nothing dominates the entry block.  */\n+\t  if (useblock == ENTRY_BLOCK_PTR)\n+\t    {\n+\t      BITMAP_FREE (blocks);\n+\t      return NULL;\n+\t    }\n+\t  bitmap_set_bit (blocks, useblock->index);\n+\t}\n+    }\n+  commondom = BASIC_BLOCK (bitmap_first_set_bit (blocks));\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, j, bi)\n+    commondom = nearest_common_dominator (CDI_DOMINATORS, commondom, \n+\t\t\t\t\t  BASIC_BLOCK (j));\n+  BITMAP_FREE (blocks);\n+  return commondom;\n+}\n+\n+/* Given a statement (STMT) and the basic block it is currently in (FROMBB), \n+   determine the location to sink the statement to, if any.\n+   Return the basic block to sink it to, or NULL if we should not sink\n+   it. */\n+\n+static tree\n+statement_sink_location (tree stmt, basic_block frombb)\n+{\n+  dataflow_t imm = get_immediate_uses (stmt);\n+  tree use, def;\n+  basic_block sinkbb;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n+  stmt_ann_t ann;\n+  tree rhs;\n+\n+  if (imm == NULL)\n+    return NULL;\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return NULL;\n+  rhs = TREE_OPERAND (stmt, 1);\n+\n+  /* There are a few classes of things we can't or don't move, some because we\n+     don't have code to handle it, some because it's not profitable and some\n+     because it's not legal. \n+  \n+     We can't sink things that may be global stores, at least not without\n+     calculating a lot more information, because we may cause it to no longer\n+     be seen by an external routine that needs it depending on where it gets\n+     moved to.  \n+      \n+     We don't want to sink loads from memory.\n+\n+     We can't sink statements that end basic blocks without splitting the\n+     incoming edge for the sink location to place it there.\n+\n+     We can't sink statements that have volatile operands.  \n+\n+     We don't want to sink dead code, so anything with 0 immediate uses is not\n+     sunk.  \n+\n+  */\n+  ann = stmt_ann (stmt);\n+  if (NUM_VUSES (STMT_VUSE_OPS (stmt)) != 0\n+      || stmt_ends_bb_p (stmt)\n+      || TREE_SIDE_EFFECTS (rhs)\n+      || TREE_CODE (rhs) == EXC_PTR_EXPR\n+      || TREE_CODE (rhs) == FILTER_EXPR\n+      || is_hidden_global_store (stmt)\n+      || ann->has_volatile_ops\n+      || num_immediate_uses (imm) == 0)\n+    return NULL;\n+  \n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n+    {\n+      tree def = DEF_FROM_PTR (def_p);\n+      if (is_global_var (SSA_NAME_VAR (def))\n+\t  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def))\n+\treturn NULL;\n+    }\n+    \n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use))\n+\treturn NULL;\n+    }\n+  \n+  /* If all the immediate uses are not in the same place, find the nearest\n+     common dominator of all the immediate uses.  For PHI nodes, we have to\n+     find the nearest common dominator of all of the predecessor blocks, since\n+     that is where insertion would have to take place.  */\n+  if (!all_immediate_uses_same_place (imm))\n+    {\n+      basic_block commondom = nearest_common_dominator_of_uses (imm);\n+     \n+      if (commondom == frombb)\n+\treturn NULL;\n+\n+      /* Our common dominator has to be dominated by frombb in order to be a\n+\t trivially safe place to put this statement, since it has multiple\n+\t uses.  */     \n+      if (!dominated_by_p (CDI_DOMINATORS, commondom, frombb))\n+\treturn NULL;\n+      \n+      /* It doesn't make sense to move to a dominator that post-dominates\n+\t frombb, because it means we've just moved it into a path that always\n+\t executes if frombb executes, instead of reducing the number of\n+\t executions .  */\n+      if (dominated_by_p (CDI_POST_DOMINATORS, frombb, commondom))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Not moving store, common dominator post-dominates from block.\\n\");\n+\t  return NULL;\n+\t}\n+\n+      if (commondom == frombb || commondom->loop_depth > frombb->loop_depth)\n+\treturn NULL;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Common dominator of all uses is %d\\n\",\n+\t\t   commondom->index);\n+\t}\n+      return first_stmt (commondom);\n+    }\n+\n+  use = immediate_use (imm, 0);\n+  if (TREE_CODE (use) != PHI_NODE)\n+    {\n+      sinkbb = bb_for_stmt (use);\n+      if (sinkbb == frombb || sinkbb->loop_depth > frombb->loop_depth\n+\t  || sinkbb->loop_father != frombb->loop_father)\n+\treturn NULL;      \n+      return use;\n+    }\n+\n+  /* Note that at this point, all uses must be in the same statement, so it\n+     doesn't matter which def op we choose.  */\n+  if (STMT_DEF_OPS (stmt) == NULL)\n+    {\n+      if (STMT_V_MAY_DEF_OPS (stmt) != NULL)\n+\tdef = V_MAY_DEF_RESULT (STMT_V_MAY_DEF_OPS (stmt), 0);\n+      else if (STMT_V_MUST_DEF_OPS (stmt) != NULL)\n+\tdef = V_MUST_DEF_RESULT (STMT_V_MUST_DEF_OPS (stmt), 0);\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else\n+    def = DEF_OP (STMT_DEF_OPS (stmt), 0);\n+  \n+  sinkbb = find_bb_for_arg (use, def);\n+  if (!sinkbb)\n+    return NULL;\n+\n+  /* This will happen when you have\n+     a_3 = PHI <a_13, a_26>\n+       \n+     a_26 = V_MAY_DEF <a_3> \n+\n+     If the use is a phi, and is in the same bb as the def, \n+     we can't sink it.  */\n+\n+  if (bb_for_stmt (use) == frombb)\n+    return NULL;\n+  if (sinkbb == frombb || sinkbb->loop_depth > frombb->loop_depth\n+      || sinkbb->loop_father != frombb->loop_father)\n+    return NULL;\n+\n+  return first_stmt (sinkbb);\n+}\n+\n+/* Perform code sinking on BB */\n+\n+static void\n+sink_code_in_bb (basic_block bb)\n+{\n+  basic_block son;\n+  block_stmt_iterator bsi;\n+  edge_iterator ei;\n+  edge e;\n+  \n+  /* If this block doesn't dominate anything, there can't be any place to sink\n+     the statements to.  */\n+  if (first_dom_son (CDI_DOMINATORS, bb) == NULL)\n+    goto earlyout;\n+\n+  /* We can't move things across abnormal edges, so don't try.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_ABNORMAL)\n+      goto earlyout;\n+\n+  for (bsi = bsi_last (bb); !bsi_end_p (bsi);)\n+    {\n+      tree stmt = bsi_stmt (bsi);\t\n+      block_stmt_iterator tobsi;\n+      tree sinkstmt;\n+      get_stmt_operands (stmt);\n+      \n+      sinkstmt = statement_sink_location (stmt, bb);\n+      if (!sinkstmt)\n+\t{\n+\t  if (!bsi_end_p (bsi))\n+\t    bsi_prev (&bsi);\n+\t  continue;\n+\t}      \n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Sinking \");\n+\t  print_generic_expr (dump_file, stmt, TDF_VOPS);\n+\t  fprintf (dump_file, \" from bb %d to bb %d\\n\",\n+\t\t   bb->index, bb_for_stmt (sinkstmt)->index);\n+\t}\n+      tobsi = bsi_for_stmt (sinkstmt);\n+      /* Find the first non-label.  */\n+      while (!bsi_end_p (tobsi)\n+             && TREE_CODE (bsi_stmt (tobsi)) == LABEL_EXPR)\n+        bsi_next (&tobsi);\n+      \n+      /* If this is the end of the basic block, we need to insert at the end\n+         of the basic block.  */\n+      if (bsi_end_p (tobsi))\n+\tbsi_move_to_bb_end (&bsi, bb_for_stmt (sinkstmt));\n+      else\n+\tbsi_move_before (&bsi, &tobsi);\n+\n+      sink_stats.sunk++;\n+      if (!bsi_end_p (bsi))\n+\tbsi_prev (&bsi);\n+      \n+    }\n+ earlyout:\n+  for (son = first_dom_son (CDI_POST_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_POST_DOMINATORS, son))\n+    {\n+      sink_code_in_bb (son);\n+    }\n+}  \n+\n+/* Perform code sinking.\n+   This moves code down the flowgraph when we know it would be\n+   profitable to do so, or it wouldn't increase the number of\n+   executions of the statement.\n+\n+   IE given\n+   \n+   a_1 = b + c;\n+   if (<something>)\n+   {\n+   }\n+   else\n+   {\n+     foo (&b, &c);\n+     a_5 = b + c;\n+   }\n+   a_6 = PHI (a_5, a_1);\n+   USE a_6.\n+\n+   we'll transform this into:\n+\n+   if (<something>)\n+   {\n+      a_1 = b + c;\n+   }\n+   else\n+   {\n+      foo (&b, &c);\n+      a_5 = b + c;\n+   }\n+   a_6 = PHI (a_5, a_1);\n+   USE a_6.\n+\n+   Note that this reduces the number of computations of a = b + c to 1\n+   when we take the else edge, instead of 2.\n+*/\n+static void\n+execute_sink_code (void)\n+{\n+  struct loops *loops = loop_optimizer_init (dump_file);\n+  connect_infinite_loops_to_exit ();\n+  memset (&sink_stats, 0, sizeof (sink_stats));\n+  calculate_dominance_info (CDI_DOMINATORS | CDI_POST_DOMINATORS);\n+  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, NULL);\n+  sink_code_in_bb (EXIT_BLOCK_PTR); \n+  if (dump_file && (dump_flags & TDF_STATS))\n+    fprintf (dump_file, \"Sunk statements:%d\\n\", sink_stats.sunk);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  remove_fake_exit_edges ();\n+  free_df ();\n+  loop_optimizer_finalize (loops, dump_file);\n+}\n+\n+/* Gate and execute functions for PRE.  */\n+\n+static void\n+do_sink (void)\n+{\n+  execute_sink_code ();\n+}\n+\n+static bool\n+gate_sink (void)\n+{\n+  return flag_tree_sink != 0;\n+}\n+\n+struct tree_opt_pass pass_sink_code =\n+{\n+  \"sink\",\t\t\t\t/* name */\n+  gate_sink,\t\t\t\t/* gate */\n+  do_sink,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_SINK,\t\t\t\t/* tv_id */\n+  PROP_no_crit_edges | PROP_cfg\n+    | PROP_ssa | PROP_alias,\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_rename_vars | TODO_dump_func | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}]}