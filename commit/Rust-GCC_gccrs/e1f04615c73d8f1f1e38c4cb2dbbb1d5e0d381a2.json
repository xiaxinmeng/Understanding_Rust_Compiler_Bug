{"sha": "e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmMDQ2MTVjNzNkOGYxZjFlMzhjNGNiMmRiYmIxZDVlMGQzODFhMg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-06T17:20:42Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-06T17:20:42Z"}, "message": "fold-const.c (fold_range_test): Take decomposed arguments code, type, op0, and op1 instead of t.\n\n\t* fold-const.c (fold_range_test): Take decomposed arguments\n\tcode, type, op0, and op1 instead of t.\n\t(fold_binary): Update a call to fold_range_test.\n\nFrom-SVN: r95977", "tree": {"sha": "4371ab7690a0334e9452c2f0971899d9aa264ea1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4371ab7690a0334e9452c2f0971899d9aa264ea1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2/comments", "author": null, "committer": null, "parents": [{"sha": "a103aa92fde856407a611547889daa0220147ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a103aa92fde856407a611547889daa0220147ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a103aa92fde856407a611547889daa0220147ca9"}], "stats": {"total": 37, "additions": 20, "deletions": 17}, "files": [{"sha": "2a1da3c9af591013300239688e6034041596a9ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2", "patch": "@@ -10,6 +10,10 @@\n \targuments code, type, op0, and op1 instead of t.\n \t(fold_binary): Update a call to optimize_minmax_comparison.\n \n+\t* fold-const.c (fold_range_test): Take decomposed arguments\n+\tcode, type, op0, and op1 instead of t.\n+\t(fold_binary): Update a call to fold_range_test.\n+\n 2005-03-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* fold-const.c (fold_binary): Avoid directly using the original"}, {"sha": "a82dbe381f7a275ad5c92e7ce311d62c57ea41bf", "filename": "gcc/fold-const.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e1f04615c73d8f1f1e38c4cb2dbbb1d5e0d381a2", "patch": "@@ -113,7 +113,7 @@ static tree make_range (tree, int *, tree *, tree *);\n static tree build_range_check (tree, tree, int, tree, tree);\n static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,\n \t\t\t tree);\n-static tree fold_range_test (tree);\n+static tree fold_range_test (enum tree_code, tree, tree, tree);\n static tree fold_cond_expr_with_comparison (tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n static tree fold_truthop (enum tree_code, tree, tree, tree);\n@@ -4414,14 +4414,14 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n    merge it into some range test.  Return the new tree if so.  */\n \n static tree\n-fold_range_test (tree exp)\n+fold_range_test (enum tree_code code, tree type, tree op0, tree op1)\n {\n-  int or_op = (TREE_CODE (exp) == TRUTH_ORIF_EXPR\n-\t       || TREE_CODE (exp) == TRUTH_OR_EXPR);\n+  int or_op = (code == TRUTH_ORIF_EXPR\n+\t       || code == TRUTH_OR_EXPR);\n   int in0_p, in1_p, in_p;\n   tree low0, low1, low, high0, high1, high;\n-  tree lhs = make_range (TREE_OPERAND (exp, 0), &in0_p, &low0, &high0);\n-  tree rhs = make_range (TREE_OPERAND (exp, 1), &in1_p, &low1, &high1);\n+  tree lhs = make_range (op0, &in0_p, &low0, &high0);\n+  tree rhs = make_range (op1, &in1_p, &low1, &high1);\n   tree tem;\n \n   /* If this is an OR operation, invert both sides; we will invert\n@@ -4436,7 +4436,7 @@ fold_range_test (tree exp)\n   if ((lhs == 0 || rhs == 0 || operand_equal_p (lhs, rhs, 0))\n       && merge_ranges (&in_p, &low, &high, in0_p, low0, high0,\n \t\t       in1_p, low1, high1)\n-      && 0 != (tem = (build_range_check (TREE_TYPE (exp),\n+      && 0 != (tem = (build_range_check (type,\n \t\t\t\t\t lhs != 0 ? lhs\n \t\t\t\t\t : rhs != 0 ? rhs : integer_zero_node,\n \t\t\t\t\t in_p, low, high))))\n@@ -4447,33 +4447,32 @@ fold_range_test (tree exp)\n      is the same, make a non-short-circuit operation.  */\n   else if (LOGICAL_OP_NON_SHORT_CIRCUIT\n \t   && lhs != 0 && rhs != 0\n-\t   && (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n-\t       || TREE_CODE (exp) == TRUTH_ORIF_EXPR)\n+\t   && (code == TRUTH_ANDIF_EXPR\n+\t       || code == TRUTH_ORIF_EXPR)\n \t   && operand_equal_p (lhs, rhs, 0))\n     {\n       /* If simple enough, just rewrite.  Otherwise, make a SAVE_EXPR\n \t unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in\n \t which cases we can't do this.  */\n       if (simple_operand_p (lhs))\n-\treturn build2 (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n+\treturn build2 (code == TRUTH_ANDIF_EXPR\n \t\t       ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n-\t\t       TREE_TYPE (exp), TREE_OPERAND (exp, 0),\n-\t\t       TREE_OPERAND (exp, 1));\n+\t\t       type, op0, op1);\n \n       else if (lang_hooks.decls.global_bindings_p () == 0\n \t       && ! CONTAINS_PLACEHOLDER_P (lhs))\n \t{\n \t  tree common = save_expr (lhs);\n \n-\t  if (0 != (lhs = build_range_check (TREE_TYPE (exp), common,\n+\t  if (0 != (lhs = build_range_check (type, common,\n \t\t\t\t\t     or_op ? ! in0_p : in0_p,\n \t\t\t\t\t     low0, high0))\n-\t      && (0 != (rhs = build_range_check (TREE_TYPE (exp), common,\n+\t      && (0 != (rhs = build_range_check (type, common,\n \t\t\t\t\t\t or_op ? ! in1_p : in1_p,\n \t\t\t\t\t\t low1, high1))))\n-\t    return build2 (TREE_CODE (exp) == TRUTH_ANDIF_EXPR\n+\t    return build2 (code == TRUTH_ANDIF_EXPR\n \t\t\t   ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n-\t\t\t   TREE_TYPE (exp), lhs, rhs);\n+\t\t\t   type, lhs, rhs);\n \t}\n     }\n \n@@ -8619,7 +8618,7 @@ fold_binary (tree expr)\n \t}\n \n       /* See if we can build a range comparison.  */\n-      if (0 != (tem = fold_range_test (t)))\n+      if (0 != (tem = fold_range_test (code, type, op0, op1)))\n \treturn tem;\n \n       /* Check for the possibility of merging component references.  If our"}]}