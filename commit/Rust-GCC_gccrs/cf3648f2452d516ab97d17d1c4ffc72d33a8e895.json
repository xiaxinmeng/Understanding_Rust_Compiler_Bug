{"sha": "cf3648f2452d516ab97d17d1c4ffc72d33a8e895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YzNjQ4ZjI0NTJkNTE2YWI5N2QxN2QxYzRmZmM3MmQzM2E4ZTg5NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-02-14T23:46:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-02-14T23:46:25Z"}, "message": "ipa-inline-analysis.c (growth_data): Add uninlinable field.\n\n\t* ipa-inline-analysis.c (growth_data): Add uninlinable field.\n\t(do_estimate_growth_1): Record if any uninlinable edge was seen.\n\t(estimate_growth): Handle uninlinable edges correctly.\n\t(check_callers): New.\n\t(growth_likely_positive): Handle aliases correctly.\n\nFrom-SVN: r220710", "tree": {"sha": "9c7aa0714bc6b9ef01b297da87d244c4e46afd7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c7aa0714bc6b9ef01b297da87d244c4e46afd7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf3648f2452d516ab97d17d1c4ffc72d33a8e895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3648f2452d516ab97d17d1c4ffc72d33a8e895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf3648f2452d516ab97d17d1c4ffc72d33a8e895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3648f2452d516ab97d17d1c4ffc72d33a8e895/comments", "author": null, "committer": null, "parents": [{"sha": "31de760604065cf4dae5de8828321c86b15bf3c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31de760604065cf4dae5de8828321c86b15bf3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31de760604065cf4dae5de8828321c86b15bf3c9"}], "stats": {"total": 55, "additions": 50, "deletions": 5}, "files": [{"sha": "79ba74d1b74c53416633071b9af43913ee993df0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3648f2452d516ab97d17d1c4ffc72d33a8e895/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3648f2452d516ab97d17d1c4ffc72d33a8e895/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf3648f2452d516ab97d17d1c4ffc72d33a8e895", "patch": "@@ -1,3 +1,11 @@\n+2015-02-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (growth_data): Add uninlinable field.\n+\t(do_estimate_growth_1): Record if any uninlinable edge was seen.\n+\t(estimate_growth): Handle uninlinable edges correctly.\n+\t(check_callers): New.\n+\t(growth_likely_positive): Handle aliases correctly.\n+\n 2015-02-14  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-chkp.c: Use iterate_direct_aliases."}, {"sha": "ea03f101816ba38081a49b27909f7abaffef0eeb", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3648f2452d516ab97d17d1c4ffc72d33a8e895/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3648f2452d516ab97d17d1c4ffc72d33a8e895/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=cf3648f2452d516ab97d17d1c4ffc72d33a8e895", "patch": "@@ -3901,6 +3901,7 @@ struct growth_data\n {\n   struct cgraph_node *node;\n   bool self_recursive;\n+  bool uninlinable;\n   int growth;\n };\n \n@@ -3917,6 +3918,12 @@ do_estimate_growth_1 (struct cgraph_node *node, void *data)\n     {\n       gcc_checking_assert (e->inline_failed);\n \n+      if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+\t{\n+\t  d->uninlinable = true;\n+          continue;\n+\t}\n+\n       if (e->caller == d->node\n \t  || (e->caller->global.inlined_to\n \t      && e->caller->global.inlined_to == d->node))\n@@ -3932,18 +3939,18 @@ do_estimate_growth_1 (struct cgraph_node *node, void *data)\n int\n estimate_growth (struct cgraph_node *node)\n {\n-  struct growth_data d = { node, 0, false };\n+  struct growth_data d = { node, false, false, 0 };\n   struct inline_summary *info = inline_summaries->get (node);\n \n-  node->call_for_symbol_thunks_and_aliases (do_estimate_growth_1, &d, true);\n+  node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true);\n \n   /* For self recursive functions the growth estimation really should be\n      infinity.  We don't want to return very large values because the growth\n      plays various roles in badness computation fractions.  Be sure to not\n      return zero or negative growths. */\n   if (d.self_recursive)\n     d.growth = d.growth < info->size ? info->size : d.growth;\n-  else if (DECL_EXTERNAL (node->decl))\n+  else if (DECL_EXTERNAL (node->decl) || d.uninlinable)\n     ;\n   else\n     {\n@@ -3962,14 +3969,37 @@ estimate_growth (struct cgraph_node *node)\n   return d.growth;\n }\n \n+/* Verify if there are fewer than MAX_CALLERS.  */\n+\n+static bool\n+check_callers (cgraph_node *node, int *max_callers)\n+{\n+  ipa_ref *ref;\n+\n+  for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n+    {\n+      (*max_callers)--;\n+      if (!*max_callers\n+\t  || cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+\treturn true;\n+    }\n+\n+  FOR_EACH_ALIAS (node, ref)\n+    if (check_callers (dyn_cast <cgraph_node *> (ref->referring), max_callers))\n+      return true;\n+\n+  return false;\n+}\n+\n \n /* Make cheap estimation if growth of NODE is likely positive knowing\n    EDGE_GROWTH of one particular edge. \n    We assume that most of other edges will have similar growth\n    and skip computation if there are too many callers.  */\n \n bool\n-growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUSED)\n+growth_likely_positive (struct cgraph_node *node,\n+\t\t        int edge_growth)\n {\n   int max_callers;\n   struct cgraph_edge *e;\n@@ -4000,9 +4030,16 @@ growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUS\n   for (e = node->callers; e; e = e->next_caller)\n     {\n       max_callers--;\n-      if (!max_callers)\n+      if (!max_callers\n+\t  || cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n \treturn true;\n     }\n+\n+  ipa_ref *ref;\n+  FOR_EACH_ALIAS (node, ref)\n+    if (check_callers (dyn_cast <cgraph_node *> (ref->referring), &max_callers))\n+      return true;\n+\n   return estimate_growth (node) > 0;\n }\n "}]}