{"sha": "d177606965244f0165a9859919e848d187dcfd38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE3NzYwNjk2NTI0NGYwMTY1YTk4NTk5MTllODQ4ZDE4N2RjZmQzOA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2003-07-10T03:25:32Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2003-07-10T03:25:32Z"}, "message": "[multiple changes]\n\n2003-06-16  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.c (mn10300_unspec_int_label_counter):\nMoved from...\n* config/mn10300/mn10300.md (GOTaddr2picreg): ... here.\n* config/mn10300/mn10300.h: GTY-declare it.\n2003-06-11  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.c (mn10300_encode_section_info): Fix\nprototype.  Use incoming RTL argument.\n2002-12-12  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.md (int_label): Move C statements...\n(GOTaddr2picreg): ... here.\n2002-08-15  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.h (ENCODE_SECTION_INFO): Move...\n* config/mn10300/mn10300.c (mn10300_encode_section_info):\n... here.  New function.(TARGET_ENCODE_SECTION_INFO): Define to it.\n2001-11-04  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.md (builtin_setjmp_receiver): Fix typo in\npattern name.\n(mn10300_loadPC): Define as insn splittable after reload.\n2001-05-13  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/mn10300.h (JUMP_TABLES_IN_TEXT_SECTION): Let them\nbe defined in .rodata even in PIC, now that the assembler\nsupports that.\n2001-05-09  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300.h (GOT_SYMBOL_NAME): Don't let the\nsymbol take an underscore prefix.\n2001-04-14  Alexandre Oliva  <aoliva@redhat.com>\n* config/mn10300/mn10300-protos.h (legitimate_pic_operand_p,\nlegitimize_pic_address): Declare.\n* config/mn10300/mn10300.h (CONDITIONAL_REGISTER_USAGE): Mark\nthe PIC register as fixed.\n(EXTRA_CONSTRAINT): Match UNSPEC_PLT and UNSPEC_PIC for 'S'.\n(GO_IF_LEGITIMATE_ADDRESS): Require legitimate_pic_operand for\nPIC.\n(LEGITIMATE_PIC_OPERAND_P): Define.\n(PIC_OFFSET_TABLE_REGNUM): Define.\n(GOT_SYMBOL_NAME): Define.\n(SYMBOLIC_CONST_P): Define.\n(ENCODE_SECTION_INFO): Use SYMBOL_REF_FLAG to mark local\nsymbols.\n(MN10300_GLOBAL_P): Test it.\n(OUTPUT_ADDR_CONST_EXTRA): Handle PIC-related unspecs.\n(JUMP_TABLES_IN_TEXT_SECTION): Enable for PIC.\n* config/mn10300/mn10300.c (print_operand): Handle unspec.\n(expand_prologue): Set PIC register.\n(call_address_operand): Don't match SYMBOL_REFs in PIC.\n(legitimize_address): Call legitimize_pic_address.\n(legitimize_pic_address): New fn.\n(legitimate_pic_operand_p): New fn.\n* config/mn10300/mn10300.md (PIC_REG, SP_REG): New constants.\n(UNSPEC_INT_LABEL, UNSPEC_PIC, UNSPEC_GOT, UNSPEC_GOTOFF,\nUNSPEC_PLT): New constants.\n(pop_pic_reg): New insn.\n(movsi): Adjust non-PIC addresses.\n(builtin_setjmp_receiver): Restore the PIC register.\n(casesi): New insn.\n(call): Adjust non-PIC addresses.\n(int_label, GOTaddr2picreg): New expands.\n(am33_loadPC): New insn.\n(mn10300_loadPC): New expand.\n(call_next_insn): New insn.\n(add_GOT_to_pic_reg): New expand.\n(symGOT2reg, symGOT2reg_i): New expands.\n(symGOTOFF2reg, symGOTOFF2reg_i): New expands.\n(sym2PIC, sym2PLT): New expands.\n\nFrom-SVN: r69169", "tree": {"sha": "2431eaa1b2838fc78a056c559e1d707256745663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2431eaa1b2838fc78a056c559e1d707256745663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d177606965244f0165a9859919e848d187dcfd38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d177606965244f0165a9859919e848d187dcfd38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d177606965244f0165a9859919e848d187dcfd38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d177606965244f0165a9859919e848d187dcfd38/comments", "author": null, "committer": null, "parents": [{"sha": "e7f042e4cd23abecdab4c92a79b096054d6b8e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f042e4cd23abecdab4c92a79b096054d6b8e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f042e4cd23abecdab4c92a79b096054d6b8e7a"}], "stats": {"total": 499, "additions": 498, "deletions": 1}, "files": [{"sha": "3e07a5b95619d5cb0e2eee72ced00d08640d2e9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d177606965244f0165a9859919e848d187dcfd38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d177606965244f0165a9859919e848d187dcfd38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d177606965244f0165a9859919e848d187dcfd38", "patch": "@@ -1,3 +1,72 @@\n+2003-07-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t2003-06-16  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.c (mn10300_unspec_int_label_counter):\n+\tMoved from...\n+\t* config/mn10300/mn10300.md (GOTaddr2picreg): ... here.\n+\t* config/mn10300/mn10300.h: GTY-declare it.\n+\t2003-06-11  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.c (mn10300_encode_section_info): Fix\n+\tprototype.  Use incoming RTL argument.\n+\t2002-12-12  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.md (int_label): Move C statements...\n+\t(GOTaddr2picreg): ... here.\n+\t2002-08-15  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.h (ENCODE_SECTION_INFO): Move...\n+\t* config/mn10300/mn10300.c (mn10300_encode_section_info):\n+\t... here.  New function.\n+\t(TARGET_ENCODE_SECTION_INFO): Define to it.\n+\t2001-11-04  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.md (builtin_setjmp_receiver): Fix typo in\n+\tpattern name.\n+\t(mn10300_loadPC): Define as insn splittable after reload.\n+\t2001-05-13  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/mn10300.h (JUMP_TABLES_IN_TEXT_SECTION): Let them\n+\tbe defined in .rodata even in PIC, now that the assembler\n+\tsupports that.\n+\t2001-05-09  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300.h (GOT_SYMBOL_NAME): Don't let the\n+\tsymbol take an underscore prefix.\n+\t2001-04-14  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/mn10300/mn10300-protos.h (legitimate_pic_operand_p,\n+\tlegitimize_pic_address): Declare.\n+\t* config/mn10300/mn10300.h (CONDITIONAL_REGISTER_USAGE): Mark\n+\tthe PIC register as fixed.\n+\t(EXTRA_CONSTRAINT): Match UNSPEC_PLT and UNSPEC_PIC for 'S'.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Require legitimate_pic_operand for\n+\tPIC.\n+\t(LEGITIMATE_PIC_OPERAND_P): Define.\n+\t(PIC_OFFSET_TABLE_REGNUM): Define.\n+\t(GOT_SYMBOL_NAME): Define.\n+\t(SYMBOLIC_CONST_P): Define.\n+\t(ENCODE_SECTION_INFO): Use SYMBOL_REF_FLAG to mark local\n+\tsymbols.\n+\t(MN10300_GLOBAL_P): Test it.\n+\t(OUTPUT_ADDR_CONST_EXTRA): Handle PIC-related unspecs.\n+\t(JUMP_TABLES_IN_TEXT_SECTION): Enable for PIC.\n+\t* config/mn10300/mn10300.c (print_operand): Handle unspec.\n+\t(expand_prologue): Set PIC register.\n+\t(call_address_operand): Don't match SYMBOL_REFs in PIC.\n+\t(legitimize_address): Call legitimize_pic_address.\n+\t(legitimize_pic_address): New fn.\n+\t(legitimate_pic_operand_p): New fn.\n+\t* config/mn10300/mn10300.md (PIC_REG, SP_REG): New constants.\n+\t(UNSPEC_INT_LABEL, UNSPEC_PIC, UNSPEC_GOT, UNSPEC_GOTOFF,\n+\tUNSPEC_PLT): New constants.\n+\t(pop_pic_reg): New insn.\n+\t(movsi): Adjust non-PIC addresses.\n+\t(builtin_setjmp_receiver): Restore the PIC register.\n+\t(casesi): New insn.\n+\t(call): Adjust non-PIC addresses.\n+\t(int_label, GOTaddr2picreg): New expands.\n+\t(am33_loadPC): New insn.\n+\t(mn10300_loadPC): New expand.\n+\t(call_next_insn): New insn.\n+\t(add_GOT_to_pic_reg): New expand.\n+\t(symGOT2reg, symGOT2reg_i): New expands.\n+\t(symGOTOFF2reg, symGOTOFF2reg_i): New expands.\n+\t(sym2PIC, sym2PLT): New expands.\n+\n 2003-07-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mn10300/mn10300.h (PREDICATE_CODES): Define."}, {"sha": "74154d92494b693b65a4185f29feaf62d0bde389", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=d177606965244f0165a9859919e848d187dcfd38", "patch": "@@ -26,6 +26,8 @@ extern void mn10300_va_start PARAMS ((tree, rtx));\n #endif /* TREE_CODE */\n \n extern struct rtx_def *legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+extern rtx legitimize_pic_address   (rtx, rtx);\n+extern int legitimate_pic_operand_p (rtx);\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern void mn10300_print_reg_list PARAMS ((FILE *, int));"}, {"sha": "e4ef4bffe8bef56ebd4f2425d2ef2f0d59f5dc40", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=d177606965244f0165a9859919e848d187dcfd38", "patch": "@@ -44,6 +44,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n+/* This is used by GOTaddr2picreg to uniquely identify\n+   UNSPEC_INT_LABELs.  */\n+int mn10300_unspec_int_label_counter;\n+\n /* The size of the callee register save area.  Right now we save everything\n    on entry since it costs us nothing in code size.  It does cost us from a\n    speed standpoint, so we want to optimize this sooner or later.  */\n@@ -75,6 +79,10 @@ static void mn10300_file_start PARAMS ((void));\n #undef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n \n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO mn10300_encode_section_info\n+\n+static void mn10300_encode_section_info (tree, rtx, int);\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n static void\n@@ -410,6 +418,7 @@ print_operand (file, x, code)\n \t  case CONST:\n \t  case LABEL_REF:\n \t  case CODE_LABEL:\n+\t  case UNSPEC:\n \t    print_operand_address (file, x);\n \t    break;\n \t  default:\n@@ -881,6 +890,24 @@ expand_prologue ()\n     emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t   stack_pointer_rtx,\n \t\t\t   GEN_INT (-size)));\n+  if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+    {\n+      rtx insn = get_last_insn ();\n+      rtx last = emit_insn (gen_GOTaddr2picreg ());\n+\n+      /* Mark these insns as possibly dead.  Sometimes, flow2 may\n+\t delete all uses of the PIC register.  In this case, let it\n+\t delete the initialization too.  */\n+      do\n+\t{\n+\t  insn = NEXT_INSN (insn);\n+\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n+\t\t\t\t\t\tconst0_rtx,\n+\t\t\t\t\t\tREG_NOTES (insn));\n+\t}\n+      while (insn != last);\n+    }\n }\n \n void\n@@ -1269,6 +1296,9 @@ call_address_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n+  if (flag_pic)\n+    return (EXTRA_CONSTRAINT (op, 'S') || GET_CODE (op) == REG);\n+\n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n }\n \n@@ -1756,6 +1786,9 @@ legitimize_address (x, oldx, mode)\n      rtx oldx ATTRIBUTE_UNUSED;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n+  if (flag_pic && ! legitimate_pic_operand_p (x))\n+    x = legitimize_pic_address (oldx, NULL_RTX);\n+\n   /* Uh-oh.  We might have an address for x[n-100000].  This needs\n      special handling to avoid creating an indexed memory address\n      with x-100000 as the base.  */\n@@ -1786,6 +1819,75 @@ legitimize_address (x, oldx, mode)\n   return x;\n }\n \n+/* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n+   @GOTOFF in `reg'. */\n+rtx\n+legitimize_pic_address (orig, reg)\n+     rtx orig;\n+     rtx reg;\n+{\n+  if (GET_CODE (orig) == LABEL_REF\n+      || (GET_CODE (orig) == SYMBOL_REF\n+\t  && (CONSTANT_POOL_ADDRESS_P (orig)\n+\t      || ! MN10300_GLOBAL_P (orig))))\n+    {\n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+\n+      emit_insn (gen_symGOTOFF2reg (reg, orig));\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      if (reg == 0)\n+\treg = gen_reg_rtx (Pmode);\n+\n+      emit_insn (gen_symGOT2reg (reg, orig));\n+      return reg;\n+    }\n+  return orig;\n+}\n+\n+/* Return zero if X references a SYMBOL_REF or LABEL_REF whose symbol\n+   isn't protected by a PIC unspec; non-zero otherwise.  */\n+int\n+legitimate_pic_operand_p (x)\n+     rtx x;\n+{\n+  register const char *fmt;\n+  register int i;\n+\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    return 0;\n+\n+  if (GET_CODE (x) == UNSPEC\n+      && (XINT (x, 1) == UNSPEC_PIC\n+\t  || XINT (x, 1) == UNSPEC_GOT\n+\t  || XINT (x, 1) == UNSPEC_GOTOFF\n+\t  || XINT (x, 1) == UNSPEC_PLT))\n+      return 1;\n+\n+  if (GET_CODE (x) == QUEUED)\n+    return legitimate_pic_operand_p (QUEUED_VAR (x));\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (! legitimate_pic_operand_p (XVECEXP (x, i, j)))\n+\t      return 0;\n+\t}\n+      else if (fmt[i] == 'e' && ! legitimate_pic_operand_p (XEXP (x, i)))\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n static int\n mn10300_address_cost_1 (x, unsig)\n      rtx x;\n@@ -1973,3 +2075,23 @@ mn10300_wide_const_load_uses_clr (operands)\n \n   return val[0] == 0 || val[1] == 0;\n }\n+/* If using PIC, mark a SYMBOL_REF for a non-global symbol so that we\n+   may access it using GOTOFF instead of GOT.  */\n+\n+static void\n+mn10300_encode_section_info (decl, rtl, first)\n+     tree decl;\n+     rtx rtl;\n+     int first;\n+{\n+  rtx symbol;\n+\n+  if (GET_CODE (rtl) != MEM)\n+    return;\n+  symbol = XEXP (rtl, 0);\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return;\n+\n+  if (flag_pic)\n+    SYMBOL_REF_FLAG (symbol) = (*targetm.binds_local_p) (decl);\n+}"}, {"sha": "2432a38a1ce8e9e789fb05b92f1eebcf9a5152aa", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=d177606965244f0165a9859919e848d187dcfd38", "patch": "@@ -46,6 +46,8 @@ Boston, MA 02111-1307, USA.  */\n \n extern int target_flags;\n \n+extern GTY(()) int mn10300_unspec_int_label_counter;\n+\n /* Macros used in the machine description to test the flags.  */\n \n /* Macro to define tables used to set the flags.\n@@ -212,6 +214,8 @@ extern int target_flags;\n            i++) \t\t\t\t\\\n \tfixed_regs[i] = call_used_regs[i] = 1;\t\\\n     }\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -735,6 +739,9 @@ struct cum_arg {int nbytes; };\n #define EXTRA_CONSTRAINT(OP, C) \\\n  ((C) == 'R' ? OK_FOR_R (OP) \\\n   : (C) == 'Q' ? OK_FOR_Q (OP) \\\n+  : (C) == 'S' && flag_pic \\\n+  ? GET_CODE (OP) == UNSPEC && (XINT (OP, 1) == UNSPEC_PLT \\\n+\t\t\t\t|| XINT (OP, 1) == UNSPEC_PIC) \\\n   : (C) == 'S' ? GET_CODE (OP) == SYMBOL_REF \\\n   : (C) == 'T' ? OK_FOR_T (OP) \\\n   : 0)\n@@ -775,7 +782,8 @@ struct cum_arg {int nbytes; };\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)    \t\\\n {\t\t\t\t\t\t\t\\\n-  if (CONSTANT_ADDRESS_P (X))\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P (X)\t\t\t\t\\\n+      && (! flag_pic || legitimate_pic_operand_p (X)))\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n   if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n@@ -797,6 +805,8 @@ struct cum_arg {int nbytes; };\n \t{\t\t\t\t\t\t\\\n \t  if (GET_CODE (index) == CONST_INT)\t\t\\\n \t    goto ADDR;\t\t\t\t\t\\\n+\t  if (GET_CODE (index) == CONST)\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n }\n@@ -833,6 +843,60 @@ struct cum_arg {int nbytes; };\n \n #define LEGITIMATE_CONSTANT_P(X) 1\n \n+/* Zero if this needs fixing up to become PIC.  */\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) (legitimate_pic_operand_p (X))\n+\n+/* Register to hold the addressing base for\n+   position independent code access to data items.  */\n+#define PIC_OFFSET_TABLE_REGNUM\tPIC_REG\n+\n+/* The name of the pseudo-symbol representing the Global Offset Table.  */\n+#define GOT_SYMBOL_NAME \"*_GLOBAL_OFFSET_TABLE_\"\n+\n+#define SYMBOLIC_CONST_P(X)\t\\\n+((GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF)\t\\\n+  && ! LEGITIMATE_PIC_OPERAND_P (X))\n+\n+/* Non-global SYMBOL_REFs have SYMBOL_REF_FLAG enabled.  */\n+#define MN10300_GLOBAL_P(X) (! SYMBOL_REF_FLAG (X))\n+\n+/* Recognize machine-specific patterns that may appear within\n+   constants.  Used for PIC-specific UNSPECs.  */\n+#define OUTPUT_ADDR_CONST_EXTRA(STREAM, X, FAIL) \\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (X) == UNSPEC && XVECLEN ((X), 0) == 1)\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tswitch (XINT ((X), 1))\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_INT_LABEL:\t\t\t\t\t\\\n+\t    asm_fprintf ((STREAM), \".%LLIL%d\",\t\t\t\t\\\n+ \t\t\t INTVAL (XVECEXP ((X), 0, 0)));\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_PIC:\t\t\t\t\t\t\\\n+\t    /* GLOBAL_OFFSET_TABLE or local symbols, no suffix.  */\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_GOT:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@GOT\", (STREAM));\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_GOTOFF:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@GOTOFF\", (STREAM));\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_PLT:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@PLT\", (STREAM));\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  default:\t\t\t\t\t\t\t\\\n+\t    goto FAIL;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      goto FAIL;\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "27a40ef37204c4564539de0302c0cdb0d64cd1fe", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d177606965244f0165a9859919e848d187dcfd38/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=d177606965244f0165a9859919e848d187dcfd38", "patch": "@@ -37,6 +37,17 @@\n ;; clobber - value of cc is unknown\n (define_attr \"cc\" \"none,none_0hit,set_znv,set_zn,compare,clobber,invert\"\n   (const_string \"clobber\"))\n+\n+(define_constants [\n+  (PIC_REG\t6)\n+  (SP_REG\t9)\n+\n+  (UNSPEC_INT_LABEL\t0)\n+  (UNSPEC_PIC\t\t1)\n+  (UNSPEC_GOT\t\t2)\n+  (UNSPEC_GOTOFF\t3)\n+  (UNSPEC_PLT\t\t4)\n+])\n \f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS\n@@ -269,6 +280,12 @@\n   DONE;\n }\")\n \n+(define_insn \"pop_pic_reg\"\n+  [(set (reg:SI PIC_REG)\n+\t(mem:SI (post_inc:SI (reg:SI SP_REG))))]\n+  \"reload_completed\"\n+  \"movm (sp),[a2]\")\n+\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n@@ -279,6 +296,33 @@\n   if (!register_operand (operand1, SImode)\n       && !register_operand (operand0, SImode))\n     operands[1] = copy_to_mode_reg (SImode, operand1);\n+  if (flag_pic)\n+    {\n+      rtx temp;\n+      if (SYMBOLIC_CONST_P (operands[1]))\n+\t{\n+\t  if (GET_CODE (operands[0]) == MEM)\n+\t    operands[1] = force_reg (Pmode, operands[1]);\n+\t  else\n+\t    {\n+\t      temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t      operands[1] = legitimize_pic_address (operands[1], temp);\n+\t    }\n+\t}\n+      else if (GET_CODE (operands[1]) == CONST\n+\t       && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+\t       && SYMBOLIC_CONST_P (XEXP (XEXP (operands[1], 0), 0)))\n+\t{\n+\t  temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t  temp = legitimize_pic_address (XEXP (XEXP (operands[1], 0), 0),\n+\t\t\t\t\t temp);\n+\t  operands[1] = expand_binop (SImode, add_optab, temp,\n+\t\t\t\t      XEXP (XEXP (operands[1], 0), 1),\n+\t\t\t\t      no_new_pseudos ? temp\n+\t\t\t\t      : gen_reg_rtx (Pmode),\n+\t\t\t\t      0, OPTAB_LIB_WIDEN);\n+\t}\n+    }\n }\")\n \n (define_insn \"\"\n@@ -1666,6 +1710,43 @@\n   \"jmp (%0)\"\n   [(set_attr \"cc\" \"none\")])\n \n+(define_expand \"builtin_setjmp_receiver\"\n+  [(match_operand 0 \"\" \"\")]\n+  \"flag_pic\"\n+  \"\n+{\n+  if (flag_pic)\n+    emit_insn (gen_GOTaddr2picreg ());\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"casesi\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")\n+   (match_operand:SI 1 \"immediate_operand\" \"\")\n+   (match_operand:SI 2 \"immediate_operand\" \"\")\n+   (match_operand 3 \"\" \"\") (match_operand 4 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx table = gen_reg_rtx (SImode);\n+  rtx index = gen_reg_rtx (SImode);\n+  rtx addr = gen_reg_rtx (Pmode);\n+\n+  emit_move_insn (table, gen_rtx_LABEL_REF (VOIDmode, operands[3]));\n+  emit_move_insn (index, plus_constant (operands[0], - INTVAL (operands[1])));\n+  emit_insn (gen_cmpsi (index, operands[2]));\n+  emit_jump_insn (gen_bgtu (operands[4]));\n+  emit_move_insn (index, gen_rtx_ASHIFT (SImode, index, GEN_INT (2)));\n+  emit_move_insn (addr, gen_rtx_MEM (SImode,\n+\t\t\t\t     gen_rtx_PLUS (SImode, table, index)));\n+  if (flag_pic)\n+    emit_move_insn (addr, gen_rtx_PLUS (SImode, addr, table));\n+\n+  emit_jump_insn (gen_tablejump (addr, operands[3]));\n+  DONE;\n+}\")\n+\n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n@@ -1681,6 +1762,20 @@\n   \"\"\n   \"\n {\n+  if (flag_pic && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+    {\n+      if (MN10300_GLOBAL_P (XEXP (operands[0], 0)))\n+\t{\n+\t  /* The PLT code won't run on AM30, but then, there's no\n+\t     shared library support for AM30 either, so we just assume\n+\t     the linker is going to adjust all @PLT relocs to the\n+\t     actual symbols.  */\n+\t  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+\t  XEXP (operands[0], 0) = gen_sym2PLT (XEXP (operands[0], 0));\n+\t}\n+      else\n+\tXEXP (operands[0], 0) = gen_sym2PIC (XEXP (operands[0], 0));\n+    }\n   if (! call_address_operand (XEXP (operands[0], 0), VOIDmode))\n     XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));\n   emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));\n@@ -1710,6 +1805,20 @@\n   \"\"\n   \"\n {\n+  if (flag_pic && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n+    {\n+      if (MN10300_GLOBAL_P (XEXP (operands[1], 0)))\n+\t{\n+\t  /* The PLT code won't run on AM30, but then, there's no\n+\t     shared library support for AM30 either, so we just assume\n+\t     the linker is going to adjust all @PLT relocs to the\n+\t     actual symbols.  */\n+\t  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+\t  XEXP (operands[1], 0) = gen_sym2PLT (XEXP (operands[1], 0));\n+\t}\n+      else\n+\tXEXP (operands[1], 0) = gen_sym2PIC (XEXP (operands[1], 0));\n+    }\n   if (! call_address_operand (XEXP (operands[1], 0), VOIDmode))\n     XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));\n   emit_call_insn (gen_call_value_internal (operands[0],\n@@ -2402,3 +2511,134 @@\n   \"add %0,%0\\;bcc %1\"\n   [(set_attr \"cc\" \"clobber\")])\n \n+(define_expand \"int_label\"\n+  [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_INT_LABEL)]\n+  \"\" \"\")\n+\n+(define_expand \"GOTaddr2picreg\"\n+  [(match_dup 0)]\n+  \"\" \"\n+{\n+  /* It would be nice to be able to have int_label keep track of the\n+     counter and all, but if we add C code to it, we'll get an insn\n+     back, and we just want the pattern.  */\n+  operands[0] = gen_int_label (GEN_INT (mn10300_unspec_int_label_counter++));\n+  if (TARGET_AM33)\n+    emit_insn (gen_am33_loadPC (operands[0]));\n+  else\n+    emit_insn (gen_mn10300_loadPC (operands[0]));\n+  emit_insn (gen_add_GOT_to_pic_reg (operands[0]));\n+  DONE;\n+}\n+\")\n+\n+(define_insn \"am33_loadPC\"\n+  [(parallel\n+    [(set (reg:SI PIC_REG) (pc))\n+     (use (match_operand 0 \"\" \"\"))])]\n+  \"TARGET_AM33\"\n+  \"%0:\\;mov pc,a2\")\n+\n+\n+(define_insn_and_split \"mn10300_loadPC\"\n+  [(parallel\n+    [(set (reg:SI PIC_REG) (pc))\n+     (use (match_operand 0 \"\" \"\"))])]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(match_operand 0 \"\" \"\")]\n+  \"\n+{\n+  rtx sp_reg = gen_rtx_REG (SImode, SP_REG);\n+  int need_stack_space = (get_frame_size () == 0\n+\t\t\t  && current_function_outgoing_args_size == 0);\n+\n+  if (need_stack_space)\n+    emit_move_insn (sp_reg, plus_constant (sp_reg, -4));\n+\n+  emit_insn (gen_call_next_insn (operands[0]));\n+\n+  if (need_stack_space)\n+    emit_insn (gen_pop_pic_reg ());\n+  else\n+    emit_move_insn (pic_offset_table_rtx, gen_rtx_MEM (SImode, sp_reg));\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"call_next_insn\"\n+  [(parallel\n+    [(set (mem:SI (reg:SI SP_REG)) (pc))\n+     (use (match_operand 0 \"\" \"\"))])]\n+  \"reload_completed\"\n+  \"calls %0\\;%0:\")\n+\n+(define_expand \"add_GOT_to_pic_reg\"\n+  [(set (reg:SI PIC_REG)\n+\t(plus:SI\n+\t (reg:SI PIC_REG)\n+\t (const\n+\t  (unspec [(minus:SI\n+\t\t    (match_dup 1)\n+\t\t    (const (minus:SI\n+\t\t\t    (const (match_operand:SI 0 \"\" \"\"))\n+\t\t\t    (pc))))\n+\t\t  ] UNSPEC_PIC))))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\n+}\")\n+\n+(define_expand \"symGOT2reg\"\n+  [(match_operand:SI 0 \"\" \"\")\n+   (match_operand:SI 1 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx insn = emit_insn (gen_symGOT2reg_i (operands[0], operands[1]));\n+\n+  RTX_UNCHANGING_P (SET_SRC (PATTERN (insn))) = 1;\n+\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\tREG_NOTES (insn));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"symGOT2reg_i\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(mem:SI (plus:SI (reg:SI PIC_REG)\n+\t\t\t (const (unspec [(match_operand:SI 1 \"\" \"\")]\n+\t\t\t\t\tUNSPEC_GOT)))))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"symGOTOFF2reg\"\n+  [(match_operand:SI 0 \"\" \"\") (match_operand:SI 1 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx insn = emit_insn (gen_symGOTOFF2reg_i (operands[0], operands[1]));\n+\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\tREG_NOTES (insn));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"symGOTOFF2reg_i\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(const (unspec [(match_operand:SI 1 \"\" \"\")] UNSPEC_GOTOFF)))\n+  (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI PIC_REG)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"sym2PIC\"\n+  [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_PIC)]\n+  \"\" \"\")\n+\n+(define_expand \"sym2PLT\"\n+  [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_PLT)]\n+  \"\" \"\")"}]}