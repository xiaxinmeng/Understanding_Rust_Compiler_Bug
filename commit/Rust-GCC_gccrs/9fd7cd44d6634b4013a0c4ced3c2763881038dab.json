{"sha": "9fd7cd44d6634b4013a0c4ced3c2763881038dab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZkN2NkNDRkNjYzNGI0MDEzYTBjNGNlZDNjMjc2Mzg4MTAzOGRhYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-10-11T09:52:35Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-11T09:52:35Z"}, "message": "utils.c (type_unsigned_for_rm): New predicate.\n\n\t* gcc-interface/utils.c (type_unsigned_for_rm): New predicate.\n\t(make_type_from_size): Use it.\n\t(unchecked_convert): Likewise.  Do not skip the extension step if the\n\tsource type is not integral.\n\nFrom-SVN: r240975", "tree": {"sha": "490989cf792d8522e167b83368abc2cb1eaf3af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/490989cf792d8522e167b83368abc2cb1eaf3af5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fd7cd44d6634b4013a0c4ced3c2763881038dab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd7cd44d6634b4013a0c4ced3c2763881038dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fd7cd44d6634b4013a0c4ced3c2763881038dab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd7cd44d6634b4013a0c4ced3c2763881038dab/comments", "author": null, "committer": null, "parents": [{"sha": "78f6129427265bd7ff088eda0a325210cb9051a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78f6129427265bd7ff088eda0a325210cb9051a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78f6129427265bd7ff088eda0a325210cb9051a2"}], "stats": {"total": 213, "additions": 189, "deletions": 24}, "files": [{"sha": "7022201405b0c4aff6f600b60aba27003e2a570c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9fd7cd44d6634b4013a0c4ced3c2763881038dab", "patch": "@@ -1,3 +1,10 @@\n+2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (type_unsigned_for_rm): New predicate.\n+\t(make_type_from_size): Use it.\n+\t(unchecked_convert): Likewise.  Do not skip the extension step if the\n+\tsource type is not integral.\n+\n 2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n             Tristan Gingold  <gingold@adacore.com>\n "}, {"sha": "221b0b5171388dba4f080656156e34c9eca6f84f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=9fd7cd44d6634b4013a0c4ced3c2763881038dab", "patch": "@@ -1070,6 +1070,25 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n   return new_type;\n }\n \n+/* Return true if TYPE has an unsigned representation.  This needs to be used\n+   when the representation of types whose precision is not equal to their size\n+   is manipulated based on the RM size.  */\n+\n+static inline bool\n+type_unsigned_for_rm (tree type)\n+{\n+  /* This is the common case.  */\n+  if (TYPE_UNSIGNED (type))\n+    return true;\n+\n+  /* See the E_Signed_Integer_Subtype case of gnat_to_gnu_entity.  */\n+  if (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n+      && tree_int_cst_sgn (TYPE_MIN_VALUE (type)) >= 0)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n    If TYPE is the best type, return it.  Otherwise, make a new type.  We\n    only support new integral and pointer types.  FOR_BIASED is true if\n@@ -1113,10 +1132,7 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n       /* The type should be an unsigned type if the original type is unsigned\n \t or if the lower bound is constant and non-negative or if the type is\n \t biased, see E_Signed_Integer_Subtype case of gnat_to_gnu_entity.  */\n-      if (TYPE_UNSIGNED (type)\n-\t  || (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n-\t      && tree_int_cst_sgn (TYPE_MIN_VALUE (type)) >= 0)\n-\t  || biased_p)\n+      if (type_unsigned_for_rm (type) || biased_p)\n \tnew_type = make_unsigned_type (size);\n       else\n \tnew_type = make_signed_type (size);\n@@ -4913,7 +4929,12 @@ can_fold_for_view_convert_p (tree expr)\n \n    we expect the 8 bits at Vbits'Address to always contain Value, while\n    their original location depends on the endianness, at Value'Address\n-   on a little-endian architecture but not on a big-endian one.  */\n+   on a little-endian architecture but not on a big-endian one.\n+\n+   One pitfall is that we cannot use TYPE_UNSIGNED directly to decide how\n+   the bits between the precision and the size are filled, because of the\n+   trick used in the E_Signed_Integer_Subtype case of gnat_to_gnu_entity.\n+   So we use the special predicate type_unsigned_for_rm above.  */\n \n tree\n unchecked_convert (tree type, tree expr, bool notrunc_p)\n@@ -4991,7 +5012,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \tTYPE_REVERSE_STORAGE_ORDER (rec_type)\n \t  = TYPE_REVERSE_STORAGE_ORDER (etype);\n \n-      if (TYPE_UNSIGNED (type))\n+      if (type_unsigned_for_rm (type))\n \tfield_type = make_unsigned_type (prec);\n       else\n \tfield_type = make_signed_type (prec);\n@@ -5030,7 +5051,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \tTYPE_REVERSE_STORAGE_ORDER (rec_type)\n \t  = TYPE_REVERSE_STORAGE_ORDER (type);\n \n-      if (TYPE_UNSIGNED (etype))\n+      if (type_unsigned_for_rm (etype))\n \tfield_type = make_unsigned_type (prec);\n       else\n \tfield_type = make_signed_type (prec);\n@@ -5131,31 +5152,26 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \texpr = build1 (VIEW_CONVERT_EXPR, type, expr);\n     }\n \n-  /* If the result is an integral type whose precision is not equal to its\n-     size, sign- or zero-extend the result.  We need not do this if the input\n-     is an integral type of the same precision and signedness or if the output\n-     is a biased type or if both the input and output are unsigned, or if the\n-     lower bound is constant and non-negative, see E_Signed_Integer_Subtype\n-     case of gnat_to_gnu_entity.  */\n+  /* If the result is a non-biased integral type whose precision is not equal\n+     to its size, sign- or zero-extend the result.  But we need not do this\n+     if the input is also an integral type and both are unsigned or both are\n+     signed and have the same precision.  */\n   if (!notrunc_p\n       && INTEGRAL_TYPE_P (type)\n+      && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n       && TYPE_RM_SIZE (type)\n       && tree_int_cst_compare (TYPE_RM_SIZE (type), TYPE_SIZE (type)) < 0\n       && !(INTEGRAL_TYPE_P (etype)\n-\t   && TYPE_UNSIGNED (type) == TYPE_UNSIGNED (etype)\n-\t   && tree_int_cst_compare (TYPE_RM_SIZE (type),\n-\t\t\t\t    TYPE_RM_SIZE (etype)\n-\t\t\t\t    ? TYPE_RM_SIZE (etype)\n-\t\t\t\t    : TYPE_SIZE (etype)) == 0)\n-      && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n-      && !((TYPE_UNSIGNED (type)\n-\t    || (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n-\t\t&& tree_int_cst_sgn (TYPE_MIN_VALUE (type)) >= 0))\n-\t   && TYPE_UNSIGNED (etype)))\n+\t   && type_unsigned_for_rm (type) == type_unsigned_for_rm (etype)\n+\t   && (type_unsigned_for_rm (type)\n+\t       || tree_int_cst_compare (TYPE_RM_SIZE (type),\n+\t\t\t\t\tTYPE_RM_SIZE (etype)\n+\t\t\t\t\t? TYPE_RM_SIZE (etype)\n+\t\t\t\t\t: TYPE_SIZE (etype)) == 0)))\n     {\n       tree base_type\n \t= gnat_type_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n-\t\t\t      TYPE_UNSIGNED (type));\n+\t\t\t      type_unsigned_for_rm (type));\n       tree shift_expr\n \t= convert (base_type,\n \t\t   size_binop (MINUS_EXPR,"}, {"sha": "4ceb8480cb0fbd86cb60002aaf008c9f043b7725", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fd7cd44d6634b4013a0c4ced3c2763881038dab", "patch": "@@ -1,3 +1,9 @@\n+2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/unchecked_convert10.adb: New test.\n+\t* gnat.dg/unchecked_convert11.adb: Likewise.\n+\t* gnat.dg/unchecked_convert12.adb: Likewise.\n+\n 2016-10-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.target/sparc/cbcond-1.c: New test."}, {"sha": "13b24c1e6ac5830827211b93ca79900016592380", "filename": "gcc/testsuite/gnat.dg/unchecked_convert10.adb", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert10.adb?ref=9fd7cd44d6634b4013a0c4ced3c2763881038dab", "patch": "@@ -0,0 +1,42 @@\n+-- { dg-do run }\n+\n+with Unchecked_Conversion;\n+\n+procedure Unchecked_Convert10 is\n+\n+  subtype Unsigned_Type is Integer range 2_034 .. 2_164;\n+\n+  subtype Signed_Type is Integer range -2048 .. 2047; \n+\n+  function To_Signed_Type is\n+     new Unchecked_Conversion (Source => Unsigned_Type, Target => Signed_Type);\n+\n+  function To_Unsigned_Type is\n+     new Unchecked_Conversion (Source => Signed_Type, Target => Unsigned_Type);\n+\n+  Data : Unsigned_Type;\n+  Temp : Signed_Type;\n+\n+begin\n+\n+  Data := 2100;\n+  Temp := To_Signed_Type (Data);\n+  if Temp /= -1996 then\n+    raise Program_Error;\n+  end if;\n+  Data := To_Unsigned_Type (Temp);\n+  if Data /= 2100 then\n+    raise Program_Error;\n+  end if;\n+\n+  Data := 2047;\n+  Temp := To_Signed_Type (Data);\n+  if Temp /= 2047 then\n+    raise Program_Error;\n+  end if;\n+  Data := To_Unsigned_Type (Temp);\n+  if Data /= 2047 then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "ad98a8814260ad24441cafbf7bb87414a079c558", "filename": "gcc/testsuite/gnat.dg/unchecked_convert11.adb", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert11.adb?ref=9fd7cd44d6634b4013a0c4ced3c2763881038dab", "patch": "@@ -0,0 +1,47 @@\n+-- { dg-do run }\n+\n+with Unchecked_Conversion;\n+\n+procedure Unchecked_Convert11 is\n+\n+  subtype Unsigned_Type is Integer range 2_034 .. 2_164;\n+\n+  subtype Signed_Type is Integer range -2048 .. 2047; \n+\n+  type Rec is record\n+    S : Signed_Type;\n+  end record;\n+  pragma Pack (Rec);\n+\n+  function To_Signed_Type is\n+     new Unchecked_Conversion (Source => Unsigned_Type, Target => Rec);\n+\n+  function To_Unsigned_Type is\n+     new Unchecked_Conversion (Source => Rec, Target => Unsigned_Type);\n+\n+  Data : Unsigned_Type;\n+  Temp : Rec;\n+\n+begin\n+\n+  Data := 2100;\n+  Temp := To_Signed_Type (Data);\n+  if Temp.S /= -1996 then\n+    raise Program_Error;\n+  end if;\n+  Data := To_Unsigned_Type (Temp);\n+  if Data /= 2100 then\n+    raise Program_Error;\n+  end if;\n+\n+  Data := 2047;\n+  Temp := To_Signed_Type (Data);\n+  if Temp.S /= 2047 then\n+    raise Program_Error;\n+  end if;\n+  Data := To_Unsigned_Type (Temp);\n+  if Data /= 2047 then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}, {"sha": "6a7ad22cd0c849b94dbdd0cd679d3a833da8a966", "filename": "gcc/testsuite/gnat.dg/unchecked_convert12.adb", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fd7cd44d6634b4013a0c4ced3c2763881038dab/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Funchecked_convert12.adb?ref=9fd7cd44d6634b4013a0c4ced3c2763881038dab", "patch": "@@ -0,0 +1,47 @@\n+-- { dg-do run }\n+\n+with Unchecked_Conversion;\n+\n+procedure Unchecked_Convert12 is\n+\n+  subtype Unsigned_Type is Integer range 2_034 .. 2_164;\n+\n+  subtype Signed_Type is Integer range -2048 .. 2047; \n+\n+  type Rec is record\n+    S : Unsigned_Type;\n+  end record;\n+  pragma Pack (Rec);\n+\n+  function To_Signed_Type is\n+     new Unchecked_Conversion (Source => Rec, Target => Signed_Type);\n+\n+  function To_Unsigned_Type is\n+    new Unchecked_Conversion (Source => Signed_Type, Target => Rec);\n+\n+  Data : Signed_Type;\n+  Temp : Rec;\n+\n+begin\n+\n+  Data := -1996;\n+  Temp := To_Unsigned_Type (Data);\n+  if Temp.S /= 2100 then\n+    raise Program_Error;\n+  end if;\n+  Data := To_Signed_Type (Temp);\n+  if Data /= -1996 then\n+    raise Program_Error;\n+  end if;\n+\n+  Data := 2047;\n+  Temp := To_Unsigned_Type (Data);\n+  if Temp.S /= 2047 then\n+    raise Program_Error;\n+  end if;\n+  Data := To_Signed_Type (Temp);\n+  if Data /= 2047 then\n+    raise Program_Error;\n+  end if;\n+\n+end;"}]}