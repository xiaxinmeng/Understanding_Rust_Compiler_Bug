{"sha": "c8fda30f0cc084626af70dea607fc081f67d95f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhmZGEzMGYwY2MwODQ2MjZhZjcwZGVhNjA3ZmMwODFmNjdkOTVmMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-10-29T12:00:54Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-10-29T12:00:54Z"}, "message": "GCOV: introduce --json-format.\n\n2018-10-29  Martin Liska  <mliska@suse.cz>\n\n\t* Makefile.in: Make dependency to json.o.\n\t* doc/gcov.texi: Document new JSON format, remove\n\told intermediate format documentation.\n\t* gcov.c (struct function_info): Come up with m_name and\n\tm_demangled_name.\n\t(function_info::function_info): Initialize it.\n\t(function_info::~function_info): Release it.\n\t(main): Rename flag_intermediate_format to flag_json_format.\n\t(print_usage): Describe --json-format.\n\t(process_args): Set flag_json_format.\n\t(output_intermediate_line): Remove.\n\t(output_intermediate_json_line): Likewise.\n\t(get_gcov_intermediate_filename): Return new extension\n\t\".gcov.json.gz\".\n\t(output_intermediate_file): Implement JSON emission.\n\t(output_json_intermediate_file): Implement JSON emission.\n\t(generate_results): Use ::get_name for function name.\n\tHandle JSON output file.\n\t(read_graph_file): Use ::get_name instead of cplus_demangle.\n\t(read_count_file): Likewise.\n\t(solve_flow_graph): Likewise.\n\t(add_line_counts): Likewise.\n\t(accumulate_line_counts): Use new flag_json_format.\n\t(output_function_details): Use ::get_name instead of cplus_demangle.\n\t(output_lines): Likewise.\n\t* json.cc (test_writing_literals): Add new tests.\n\t* json.h (class literal): Add new boolean constructor.\n2018-10-29  Martin Liska  <mliska@suse.cz>\n\n\t* g++.dg/gcov/gcov-8.C: Do not check intermediate format.\n\t* lib/gcov.exp: Remove legacy verify-intermediate.\n\nFrom-SVN: r265587", "tree": {"sha": "0712a4f4a8835243bcd37abe2d4cdd6c0470e151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0712a4f4a8835243bcd37abe2d4cdd6c0470e151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8fda30f0cc084626af70dea607fc081f67d95f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8fda30f0cc084626af70dea607fc081f67d95f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8fda30f0cc084626af70dea607fc081f67d95f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8fda30f0cc084626af70dea607fc081f67d95f1/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4eb0305b8581368fb5f9ed88dd501e13d1cdd3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4eb0305b8581368fb5f9ed88dd501e13d1cdd3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4eb0305b8581368fb5f9ed88dd501e13d1cdd3e"}], "stats": {"total": 560, "additions": 329, "deletions": 231}, "files": [{"sha": "165ae049dba28858585a2353f69aa9f93914cfe0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -1,3 +1,33 @@\n+2018-10-29  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: Make dependency to json.o.\n+\t* doc/gcov.texi: Document new JSON format, remove\n+\told intermediate format documentation.\n+\t* gcov.c (struct function_info): Come up with m_name and\n+\tm_demangled_name.\n+\t(function_info::function_info): Initialize it.\n+\t(function_info::~function_info): Release it.\n+\t(main): Rename flag_intermediate_format to flag_json_format.\n+\t(print_usage): Describe --json-format.\n+\t(process_args): Set flag_json_format.\n+\t(output_intermediate_line): Remove.\n+\t(output_intermediate_json_line): Likewise.\n+\t(get_gcov_intermediate_filename): Return new extension\n+\t\".gcov.json.gz\".\n+\t(output_intermediate_file): Implement JSON emission.\n+\t(output_json_intermediate_file): Implement JSON emission.\n+\t(generate_results): Use ::get_name for function name.\n+\tHandle JSON output file.\n+\t(read_graph_file): Use ::get_name instead of cplus_demangle.\n+\t(read_count_file): Likewise.\n+\t(solve_flow_graph): Likewise.\n+\t(add_line_counts): Likewise.\n+\t(accumulate_line_counts): Use new flag_json_format.\n+\t(output_function_details): Use ::get_name instead of cplus_demangle.\n+\t(output_lines): Likewise.\n+\t* json.cc (test_writing_literals): Add new tests.\n+\t* json.h (class literal): Add new boolean constructor.\n+\n 2018-10-29  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/87701"}, {"sha": "719a516c356d21a285aa4f65fb6ca7608e19481a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -2899,10 +2899,13 @@ s-iov: build/gcov-iov$(build_exeext) $(BASEVER) $(DEVPHASE)\n \t$(SHELL) $(srcdir)/../move-if-change tmp-gcov-iov.h gcov-iov.h\n \t$(STAMP) s-iov\n \n-GCOV_OBJS = gcov.o\n+# gcov.o needs $(ZLIBINC) added to the include flags.\n+CFLAGS-gcov.o += $(ZLIBINC)\n+\n+GCOV_OBJS = gcov.o json.o\n gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) \\\n-\t\thash-table.o ggc-none.o $(LIBS) -o $@\n+\t\thash-table.o ggc-none.o $(LIBS) $(ZLIB) -o $@\n GCOV_DUMP_OBJS = gcov-dump.o\n gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) \\"}, {"sha": "8046fd78e358371a4f1d4b8fd67cf450b2f1554e", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 128, "deletions": 65, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -124,7 +124,7 @@ gcov [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]\n      [@option{-c}|@option{--branch-counts}]\n      [@option{-d}|@option{--display-progress}]\n      [@option{-f}|@option{--function-summaries}]\n-     [@option{-i}|@option{--intermediate-format}]\n+     [@option{-i}|@option{--json-format}]\n      [@option{-j}|@option{--human-readable}]\n      [@option{-k}|@option{--use-colors}]\n      [@option{-l}|@option{--long-file-names}]\n@@ -181,79 +181,142 @@ Display help about using @command{gcov} (on the standard output), and\n exit without doing any further processing.\n \n @item -i\n-@itemx --intermediate-format\n-Output gcov file in an easy-to-parse intermediate text format that can\n-be used by @command{lcov} or other tools. The output is a single\n-@file{.gcov} file per @file{.gcda} file. No source code is required.\n+@itemx --json-format\n+Output gcov file in an easy-to-parse JSON intermediate format\n+which does not require source code for generation.  The JSON\n+file is compressed with gzip compression algorithm\n+and the files have @file{.gcov.json.gz} extension.\n \n-The format of the intermediate @file{.gcov} file is plain text with\n-one entry per line\n+Structure of the JSON is following:\n \n @smallexample\n-version:@var{gcc_version}\n-cwd:@var{working_directory}\n-file:@var{source_file_name}\n-function:@var{start_line_number},@var{end_line_number},@var{execution_count},@var{function_name}\n-lcount:@var{line number},@var{execution_count},@var{has_unexecuted_block}\n-branch:@var{line_number},@var{branch_coverage_type}\n-\n-Where the @var{branch_coverage_type} is\n-   notexec (Branch not executed)\n-   taken (Branch executed and taken)\n-   nottaken (Branch executed, but not taken)\n+@{\n+  \"current_working_directory\": @var{current_working_directory},\n+  \"format_version\": @var{format_version},\n+  \"gcc_version\": @var{gcc_version}\n+  \"files\": [@var{file}]\n+@}\n @end smallexample\n \n-There can be multiple @var{file} entries in an intermediate gcov\n-file. All entries following a @var{file} pertain to that source file\n-until the next @var{file} entry.  If there are multiple functions that\n-start on a single line, then corresponding lcount is repeated multiple\n-times.\n+Fields of the root element have following semantics:\n \n-Here is a sample when @option{-i} is used in conjunction with @option{-b} option:\n+@itemize @bullet\n+@item\n+@var{current_working_directory}: working directory where\n+a compilation unit was compiled\n+\n+@item\n+@var{format_version}: semantic version of the format\n+\n+@item\n+@var{gcc_version}: version of the GCC compiler\n+@end itemize\n+\n+Each @var{file} has the following form:\n+\n+@smallexample\n+@{\n+  \"file\": @var{file_name},\n+  \"functions\": [@var{function}],\n+  \"lines\": [@var{line}]\n+@}\n+@end smallexample\n+\n+Fields of the @var{file} element have following semantics:\n+\n+@itemize @bullet\n+@item\n+@var{file_name}: name of the source file\n+@end itemize\n+\n+Each @var{function} has the following form:\n+\n+@smallexample\n+@{\n+  \"blocks\": @var{blocks},\n+  \"blocks_executed\": @var{blocks_executed},\n+  \"demangled_name\": \"@var{demangled_name},\n+  \"end_line\": @var{end_line},\n+  \"execution_count\": @var{execution_count},\n+  \"name\": @var{name},\n+  \"start_line\": @var{start_line}\n+@}\n+@end smallexample\n+\n+Fields of the @var{function} element have following semantics:\n+\n+@itemize @bullet\n+@item\n+@var{blocks}: number of blocks that are in the function\n+\n+@item\n+@var{blocks_executed}: number of executed blocks of the function\n+\n+@item\n+@var{demangled_name}: demangled name of the function\n+\n+@item\n+@var{end_line}: line in the source file where the function ends\n+\n+@item\n+@var{execution_count}: number of executions of the function\n+\n+@item\n+@var{name}: name of the function\n+\n+@item\n+@var{start_line}: line in the source file where the function begins\n+@end itemize\n+\n+Each @var{line} has the following form:\n+\n+@smallexample\n+@{\n+  \"branches\": [@var{branch}],\n+  \"count\": @var{count},\n+  \"line_number\": @var{line_number},\n+  \"unexecuted_block\": @var{unexecuted_block}\n+@}\n+@end smallexample\n+\n+Branches are present only with @var{-b} option.\n+Fields of the @var{line} element have following semantics:\n+\n+@itemize @bullet\n+@item\n+@var{count}: number of executions of the line\n+\n+@item\n+@var{line_number}: line number\n+\n+@item\n+@var{unexecuted_block}: flag whether the line contains an unexecuted block\n+(not all statements on the line are executed)\n+@end itemize\n+\n+Each @var{branch} has the following form:\n \n @smallexample\n-version: 8.1.0 20180103\n-cwd:/home/gcc/testcase\n-file:tmp.cpp\n-function:7,7,0,_ZN3FooIcEC2Ev\n-function:7,7,1,_ZN3FooIiEC2Ev\n-function:8,8,0,_ZN3FooIcE3incEv\n-function:8,8,2,_ZN3FooIiE3incEv\n-function:18,37,1,main\n-lcount:7,0,1\n-lcount:7,1,0\n-lcount:8,0,1\n-lcount:8,2,0\n-lcount:18,1,0\n-lcount:21,1,0\n-branch:21,taken\n-branch:21,nottaken\n-lcount:23,1,0\n-branch:23,taken\n-branch:23,nottaken\n-lcount:24,1,0\n-branch:24,taken\n-branch:24,nottaken\n-lcount:25,1,0\n-lcount:27,11,0\n-branch:27,taken\n-branch:27,taken\n-lcount:28,10,0\n-lcount:30,1,1\n-branch:30,nottaken\n-branch:30,taken\n-lcount:32,1,0\n-branch:32,nottaken\n-branch:32,taken\n-lcount:33,0,1\n-branch:33,notexec\n-branch:33,notexec\n-lcount:35,1,0\n-branch:35,taken\n-branch:35,nottaken\n-lcount:36,1,0\n+@{\n+  \"count\": @var{count},\n+  \"fallthrough\": @var{fallthrough},\n+  \"throw\": @var{throw}\n+@}\n @end smallexample\n \n+Fields of the @var{branch} element have following semantics:\n+\n+@itemize @bullet\n+@item\n+@var{count}: number of executions of the branch\n+\n+@item\n+@var{fallthrough}: true when the branch is a fall through branch\n+\n+@item\n+@var{throw}: true when the branch is an exceptional branch\n+@end itemize\n+\n @item -j\n @itemx --human-readable\n Write counts in human readable format (like 24.6k).\n@@ -842,7 +905,7 @@ some summary information.\n \n It is not recommended to access the coverage files directly.\n Consumers should use the intermediate format that is provided\n-by @command{gcov} tool via @option{--intermediate-format} option.\n+by @command{gcov} tool via @option{--json-format} option.\n \n @node Cross-profiling\n @section Data File Relocation to Support Cross-Profiling"}, {"sha": "26d352ce7f123ab98da8d3e40914eefad666c1e9", "filename": "gcc/gcov.c", "status": "modified", "additions": 154, "deletions": 106, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -44,7 +44,10 @@ along with Gcov; see the file COPYING3.  If not see\n #include \"version.h\"\n #include \"demangle.h\"\n #include \"color-macros.h\"\n+#include \"pretty-print.h\"\n+#include \"json.h\"\n \n+#include <zlib.h>\n #include <getopt.h>\n \n #include \"md5.h\"\n@@ -221,6 +224,10 @@ line_info::has_block (block_info *needle)\n   return std::find (blocks.begin (), blocks.end (), needle) != blocks.end ();\n }\n \n+/* Output demangled function names.  */\n+\n+static int flag_demangled_names = 0;\n+\n /* Describes a single function. Contains an array of basic blocks.  */\n \n struct function_info\n@@ -241,8 +248,8 @@ struct function_info\n   }\n \n   /* Name of function.  */\n-  char *name;\n-  char *demangled_name;\n+  char *m_name;\n+  char *m_demangled_name;\n   unsigned ident;\n   unsigned lineno_checksum;\n   unsigned cfg_checksum;\n@@ -284,6 +291,32 @@ struct function_info\n \n   /* Next function.  */\n   struct function_info *next;\n+\n+  /*  Get demangled name of a function.  The demangled name\n+      is converted when it is used for the first time.  */\n+  char *get_demangled_name ()\n+  {\n+    if (m_demangled_name == NULL)\n+      {\n+\tm_demangled_name = cplus_demangle (m_name, DMGL_PARAMS);\n+\tif (!m_demangled_name)\n+\t  m_demangled_name = m_name;\n+      }\n+\n+    return m_demangled_name;\n+  }\n+\n+  /* Get name of the function based on flag_demangled_names.  */\n+  char *get_name ()\n+  {\n+    return flag_demangled_names ? get_demangled_name () : m_name;\n+  }\n+\n+  /* Return number of basic blocks (without entry and exit block).  */\n+  unsigned get_block_count ()\n+  {\n+    return blocks.size () - 2;\n+  }\n };\n \n /* Function info comparer that will sort functions according to starting\n@@ -477,13 +510,9 @@ static int flag_use_stdout = 0;\n \n static int flag_display_progress = 0;\n \n-/* Output *.gcov file in intermediate format used by 'lcov'.  */\n+/* Output *.gcov file in JSON intermediate format used by consumers.  */\n \n-static int flag_intermediate_format = 0;\n-\n-/* Output demangled function names.  */\n-\n-static int flag_demangled_names = 0;\n+static int flag_json_format = 0;\n \n /* For included files, make the gcov output file name include the name\n    of the input source file.  For example, if x.h is included in a.c,\n@@ -576,7 +605,7 @@ static char *mangle_name (const char *, char *);\n static void release_structures (void);\n extern int main (int, char **);\n \n-function_info::function_info (): name (NULL), demangled_name (NULL),\n+function_info::function_info (): m_name (NULL), m_demangled_name (NULL),\n   ident (0), lineno_checksum (0), cfg_checksum (0), has_catch (0),\n   artificial (0), is_group (0),\n   blocks (), blocks_executed (0), counts (),\n@@ -596,9 +625,9 @@ function_info::~function_info ()\n \t  free (arc);\n \t}\n     }\n-  if (flag_demangled_names && demangled_name != name)\n-    free (demangled_name);\n-  free (name);\n+  if (m_demangled_name != m_name)\n+    free (m_demangled_name);\n+  free (m_name);\n }\n \n bool function_info::group_line_p (unsigned n, unsigned src_idx)\n@@ -807,7 +836,7 @@ main (int argc, char **argv)\n \t\targc - first_arg);\n       process_file (argv[argno]);\n \n-      if (flag_intermediate_format || argno == argc - 1)\n+      if (flag_json_format || argno == argc - 1)\n \t{\n \t  process_all_functions ();\n \t  generate_results (argv[argno]);\n@@ -836,7 +865,7 @@ print_usage (int error_p)\n   fnotice (file, \"  -d, --display-progress          Display progress information\\n\");\n   fnotice (file, \"  -f, --function-summaries        Output summaries for each function\\n\");\n   fnotice (file, \"  -h, --help                      Print this help, then exit\\n\");\n-  fnotice (file, \"  -i, --intermediate-format       Output .gcov file in intermediate text format\\n\");\n+  fnotice (file, \"  -i, --json-format\t\t    Output JSON intermediate format into .gcov.json.gz file\\n\");\n   fnotice (file, \"  -j, --human-readable            Output human readable numbers\\n\");\n   fnotice (file, \"  -k, --use-colors                Emit colored output\\n\");\n   fnotice (file, \"  -l, --long-file-names           Use long output file names for included\\n\\\n@@ -881,7 +910,7 @@ static const struct option options[] =\n   { \"all-blocks\",           no_argument,       NULL, 'a' },\n   { \"branch-probabilities\", no_argument,       NULL, 'b' },\n   { \"branch-counts\",        no_argument,       NULL, 'c' },\n-  { \"intermediate-format\",  no_argument,       NULL, 'i' },\n+  { \"json-format\",\t    no_argument,       NULL, 'i' },\n   { \"human-readable\",\t    no_argument,       NULL, 'j' },\n   { \"no-output\",            no_argument,       NULL, 'n' },\n   { \"long-file-names\",      no_argument,       NULL, 'l' },\n@@ -963,12 +992,12 @@ process_args (int argc, char **argv)\n \t  flag_unconditional = 1;\n \t  break;\n \tcase 'i':\n-          flag_intermediate_format = 1;\n-          flag_gcov_file = 1;\n-          break;\n-        case 'd':\n-          flag_display_progress = 1;\n-          break;\n+\t  flag_json_format = 1;\n+\t  flag_gcov_file = 1;\n+\t  break;\n+\tcase 'd':\n+\t  flag_display_progress = 1;\n+\t  break;\n \tcase 'x':\n \t  flag_hash_filenames = 1;\n \t  break;\n@@ -990,17 +1019,23 @@ process_args (int argc, char **argv)\n   return optind;\n }\n \n-/* Output intermediate LINE sitting on LINE_NUM to output file F.  */\n+/* Output intermediate LINE sitting on LINE_NUM to JSON OBJECT.  */\n \n static void\n-output_intermediate_line (FILE *f, line_info *line, unsigned line_num)\n+output_intermediate_json_line (json::array *object,\n+\t\t\t       line_info *line, unsigned line_num)\n {\n   if (!line->exists)\n     return;\n \n-  fprintf (f, \"lcount:%u,%s,%d\\n\", line_num,\n-\t   format_gcov (line->count, 0, -1),\n-\t   line->has_unexecuted_block);\n+  json::object *lineo = new json::object ();\n+  lineo->set (\"line_number\", new json::number (line_num));\n+  lineo->set (\"count\", new json::number (line->count));\n+  lineo->set (\"unexecuted_block\",\n+\t      new json::literal (line->has_unexecuted_block));\n+\n+  json::array *branches = new json::array ();\n+  lineo->set (\"branches\", branches);\n \n   vector<arc_info *>::const_iterator it;\n   if (flag_branches)\n@@ -1009,21 +1044,16 @@ output_intermediate_line (FILE *f, line_info *line, unsigned line_num)\n       {\n \tif (!(*it)->is_unconditional && !(*it)->is_call_non_return)\n \t  {\n-\t    const char *branch_type;\n-\t    /* branch:<line_num>,<branch_coverage_infoype>\n-\t       branch_coverage_infoype\n-\t       : notexec (Branch not executed)\n-\t       : taken (Branch executed and taken)\n-\t       : nottaken (Branch executed, but not taken)\n-\t       */\n-\t    if ((*it)->src->count)\n-\t\t branch_type\n-\t\t\t= ((*it)->count > 0) ? \"taken\" : \"nottaken\";\n-\t    else\n-\t      branch_type = \"notexec\";\n-\t    fprintf (f, \"branch:%d,%s\\n\", line_num, branch_type);\n+\t    json::object *branch = new json::object ();\n+\t    branch->set (\"count\", new json::number ((*it)->count));\n+\t    branch->set (\"throw\", new json::literal ((*it)->is_throw));\n+\t    branch->set (\"fallthrough\",\n+\t\t\t new json::literal ((*it)->fall_through));\n+\t    branches->append (branch);\n \t  }\n       }\n+\n+  object->append (lineo);\n }\n \n /* Get the name of the gcov file.  The return value must be free'd.\n@@ -1038,7 +1068,7 @@ output_intermediate_line (FILE *f, line_info *line, unsigned line_num)\n static char *\n get_gcov_intermediate_filename (const char *file_name)\n {\n-  const char *gcov = \".gcov\";\n+  const char *gcov = \".gcov.json.gz\";\n   char *result;\n   const char *cptr;\n \n@@ -1051,34 +1081,44 @@ get_gcov_intermediate_filename (const char *file_name)\n   return result;\n }\n \n-/* Output the result in intermediate format used by 'lcov'.\n-\n-The intermediate format contains a single file named 'foo.cc.gcov',\n-with no source code included.\n-\n-The default gcov outputs multiple files: 'foo.cc.gcov',\n-'iostream.gcov', 'ios_base.h.gcov', etc. with source code\n-included. Instead the intermediate format here outputs only a single\n-file 'foo.cc.gcov' similar to the above example. */\n+/* Output the result in JSON intermediate format.\n+   Source info SRC is dumped into JSON_FILES which is JSON array.  */\n \n static void\n-output_intermediate_file (FILE *gcov_file, source_info *src)\n+output_json_intermediate_file (json::array *json_files, source_info *src)\n {\n-  fprintf (gcov_file, \"version:%s\\n\", version_string);\n-  fprintf (gcov_file, \"file:%s\\n\", src->name);    /* source file name */\n-  fprintf (gcov_file, \"cwd:%s\\n\", bbg_cwd);\n+  json::object *root = new json::object ();\n+  json_files->append (root);\n+\n+  root->set (\"file\", new json::string (src->name));\n+\n+  json::array *functions = new json::array ();\n+  root->set (\"functions\", functions);\n \n   std::sort (src->functions.begin (), src->functions.end (),\n \t     function_line_start_cmp ());\n   for (vector<function_info *>::iterator it = src->functions.begin ();\n        it != src->functions.end (); it++)\n     {\n-      /* function:<name>,<line_number>,<execution_count> */\n-      fprintf (gcov_file, \"function:%d,%d,%s,%s\\n\", (*it)->start_line,\n-\t       (*it)->end_line, format_gcov ((*it)->blocks[0].count, 0, -1),\n-\t       flag_demangled_names ? (*it)->demangled_name : (*it)->name);\n+      json::object *function = new json::object ();\n+      function->set (\"name\", new json::string ((*it)->m_name));\n+      function->set (\"demangled_name\",\n+\t\t     new json::string ((*it)->get_demangled_name ()));\n+      function->set (\"start_line\", new json::number ((*it)->start_line));\n+      function->set (\"end_line\", new json::number ((*it)->end_line));\n+      function->set (\"blocks\",\n+\t\t     new json::number ((*it)->get_block_count ()));\n+      function->set (\"blocks_executed\",\n+\t\t     new json::number ((*it)->blocks_executed));\n+      function->set (\"execution_count\",\n+\t\t     new json::number ((*it)->blocks[0].count));\n+\n+      functions->append (function);\n     }\n \n+  json::array *lineso = new json::array ();\n+  root->set (\"lines\", lineso);\n+\n   for (unsigned line_num = 1; line_num <= src->lines.size (); line_num++)\n     {\n       vector<function_info *> fns = src->get_functions_at_location (line_num);\n@@ -1091,13 +1131,13 @@ output_intermediate_file (FILE *gcov_file, source_info *src)\n \t  for (unsigned i = 0; i < lines.size (); i++)\n \t    {\n \t      line_info *line = &lines[i];\n-\t      output_intermediate_line (gcov_file, line, line_num + i);\n+\t      output_intermediate_json_line (lineso, line, line_num + i);\n \t    }\n \t}\n \n       /* Follow with lines associated with the source file.  */\n       if (line_num < src->lines.size ())\n-\toutput_intermediate_line (gcov_file, &src->lines[line_num], line_num);\n+\toutput_intermediate_json_line (lineso, &src->lines[line_num], line_num);\n     }\n }\n \n@@ -1301,8 +1341,7 @@ output_gcov_file (const char *file_name, source_info *src)\n static void\n generate_results (const char *file_name)\n {\n-  FILE *gcov_intermediate_file = NULL;\n-  char *gcov_intermediate_filename = NULL;\n+  char *gcov_intermediate_filename;\n \n   for (vector<function_info *>::iterator it = functions.begin ();\n        it != functions.end (); it++)\n@@ -1311,7 +1350,7 @@ generate_results (const char *file_name)\n       coverage_info coverage;\n \n       memset (&coverage, 0, sizeof (coverage));\n-      coverage.name = flag_demangled_names ? fn->demangled_name : fn->name;\n+      coverage.name = fn->get_name ();\n       add_line_counts (flag_function_summary ? &coverage : NULL, fn);\n       if (flag_function_summary)\n \t{\n@@ -1333,18 +1372,15 @@ generate_results (const char *file_name)\n \tfile_name = canonicalize_name (file_name);\n     }\n \n-  if (flag_gcov_file && flag_intermediate_format && !flag_use_stdout)\n-    {\n-      /* Open the intermediate file.  */\n-      gcov_intermediate_filename = get_gcov_intermediate_filename (file_name);\n-      gcov_intermediate_file = fopen (gcov_intermediate_filename, \"w\");\n-      if (!gcov_intermediate_file)\n-\t{\n-\t  fnotice (stderr, \"Cannot open intermediate output file %s\\n\",\n-\t\t   gcov_intermediate_filename);\n-\t  return;\n-\t}\n-    }\n+  gcov_intermediate_filename = get_gcov_intermediate_filename (file_name);\n+\n+  json::object *root = new json::object ();\n+  root->set (\"format_version\", new json::string (\"1\"));\n+  root->set (\"gcc_version\", new json::string (version_string));\n+  root->set (\"current_working_directory\", new json::string (bbg_cwd));\n+\n+  json::array *json_files = new json::array ();\n+  root->set (\"files\", json_files);\n \n   for (vector<source_info>::iterator it = sources.begin ();\n        it != sources.end (); it++)\n@@ -1372,11 +1408,8 @@ generate_results (const char *file_name)\n       total_executed += src->coverage.lines_executed;\n       if (flag_gcov_file)\n \t{\n-\t  if (flag_intermediate_format)\n-\t    /* Output the intermediate format without requiring source\n-\t       files.  This outputs a section to a *single* file.  */\n-\t    output_intermediate_file ((flag_use_stdout\n-\t\t\t\t       ? stdout : gcov_intermediate_file), src);\n+\t  if (flag_json_format)\n+\t    output_json_intermediate_file (json_files, src);\n \t  else\n \t    {\n \t      if (flag_use_stdout)\n@@ -1393,11 +1426,35 @@ generate_results (const char *file_name)\n \t}\n     }\n \n-  if (flag_gcov_file && flag_intermediate_format && !flag_use_stdout)\n+  if (flag_gcov_file && flag_json_format)\n     {\n-      /* Now we've finished writing the intermediate file.  */\n-      fclose (gcov_intermediate_file);\n-      XDELETEVEC (gcov_intermediate_filename);\n+      if (flag_use_stdout)\n+\t{\n+\t  root->dump (stdout);\n+\t  printf (\"\\n\");\n+\t}\n+      else\n+\t{\n+\t  pretty_printer pp;\n+\t  root->print (&pp);\n+\t  pp_formatted_text (&pp);\n+\n+\t  gzFile output = gzopen (gcov_intermediate_filename, \"w\");\n+\t  if (output == NULL)\n+\t    {\n+\t      fnotice (stderr, \"Cannot open JSON output file %s\\n\",\n+\t\t       gcov_intermediate_filename);\n+\t      return;\n+\t    }\n+\n+\t  if (gzputs (output, pp_formatted_text (&pp)) == EOF\n+\t      || gzclose (output))\n+\t    {\n+\t      fnotice (stderr, \"Error writing JSON output file %s\\n\",\n+\t\t       gcov_intermediate_filename);\n+\t      return;\n+\t    }\n+\t}\n     }\n \n   if (!file_name)\n@@ -1634,13 +1691,7 @@ read_graph_file (void)\n \n \t  fn = new function_info ();\n \t  functions.push_back (fn);\n-\t  fn->name = function_name;\n-\t  if (flag_demangled_names)\n-\t    {\n-\t      fn->demangled_name = cplus_demangle (fn->name, DMGL_PARAMS);\n-\t      if (!fn->demangled_name)\n-\t\tfn->demangled_name = fn->name;\n-\t    }\n+\t  fn->m_name = function_name;\n \t  fn->ident = ident;\n \t  fn->lineno_checksum = lineno_checksum;\n \t  fn->cfg_checksum = cfg_checksum;\n@@ -1656,7 +1707,7 @@ read_graph_file (void)\n \t{\n \t  if (!fn->blocks.empty ())\n \t    fnotice (stderr, \"%s:already seen blocks for '%s'\\n\",\n-\t\t     bbg_file_name, fn->name);\n+\t\t     bbg_file_name, fn->get_name ());\n \t  else\n \t    fn->blocks.resize (gcov_read_unsigned ());\n \t}\n@@ -1862,7 +1913,7 @@ read_count_file (void)\n \t    {\n \t    mismatch:;\n \t      fnotice (stderr, \"%s:profile mismatch for '%s'\\n\",\n-\t\t       da_file_name, fn->name);\n+\t\t       da_file_name, fn->get_name ());\n \t      goto cleanup;\n \t    }\n \t}\n@@ -1927,20 +1978,20 @@ solve_flow_graph (function_info *fn)\n \n   if (fn->blocks.size () < 2)\n     fnotice (stderr, \"%s:'%s' lacks entry and/or exit blocks\\n\",\n-\t     bbg_file_name, fn->name);\n+\t     bbg_file_name, fn->get_name ());\n   else\n     {\n       if (fn->blocks[ENTRY_BLOCK].num_pred)\n \tfnotice (stderr, \"%s:'%s' has arcs to entry block\\n\",\n-\t\t bbg_file_name, fn->name);\n+\t\t bbg_file_name, fn->get_name ());\n       else\n \t/* We can't deduce the entry block counts from the lack of\n \t   predecessors.  */\n \tfn->blocks[ENTRY_BLOCK].num_pred = ~(unsigned)0;\n \n       if (fn->blocks[EXIT_BLOCK].num_succ)\n \tfnotice (stderr, \"%s:'%s' has arcs from exit block\\n\",\n-\t\t bbg_file_name, fn->name);\n+\t\t bbg_file_name, fn->get_name ());\n       else\n \t/* Likewise, we can't deduce exit block counts from the lack\n \t   of its successors.  */\n@@ -2149,7 +2200,7 @@ solve_flow_graph (function_info *fn)\n     if (!fn->blocks[i].count_valid)\n       {\n \tfnotice (stderr, \"%s:graph is unsolvable for '%s'\\n\",\n-\t\t bbg_file_name, fn->name);\n+\t\t bbg_file_name, fn->get_name ());\n \tbreak;\n       }\n }\n@@ -2553,7 +2604,8 @@ add_line_counts (coverage_info *coverage, function_info *fn)\n     }\n \n   if (!has_any_line)\n-    fnotice (stderr, \"%s:no lines for '%s'\\n\", bbg_file_name, fn->name);\n+    fnotice (stderr, \"%s:no lines for '%s'\\n\", bbg_file_name,\n+\t     fn->get_name ());\n }\n \n /* Accumulate info for LINE that belongs to SRC source file.  If ADD_COVERAGE\n@@ -2633,7 +2685,7 @@ accumulate_line_counts (source_info *src)\n \n   /* If not using intermediate mode, sum lines of group functions and\n      add them to lines that live in a source file.  */\n-  if (!flag_intermediate_format)\n+  if (!flag_json_format)\n     for (vector<function_info *>::iterator it = src->functions.begin ();\n \t it != src->functions.end (); it++)\n       {\n@@ -2895,7 +2947,7 @@ output_line_details (FILE *f, const line_info *line, unsigned line_num)\n /* Output detail statistics about function FN to file F.  */\n \n static void\n-output_function_details (FILE *f, const function_info *fn)\n+output_function_details (FILE *f, function_info *fn)\n {\n   if (!flag_branches)\n     return;\n@@ -2908,15 +2960,13 @@ output_function_details (FILE *f, const function_info *fn)\n     if (arc->fake)\n       return_count -= arc->count;\n \n-  fprintf (f, \"function %s\",\n-\t   flag_demangled_names ? fn->demangled_name : fn->name);\n+  fprintf (f, \"function %s\", fn->get_name ());\n   fprintf (f, \" called %s\",\n \t   format_gcov (called_count, 0, -1));\n   fprintf (f, \" returned %s\",\n \t   format_gcov (return_count, called_count, 0));\n   fprintf (f, \" blocks executed %s\",\n-\t   format_gcov (fn->blocks_executed, fn->blocks.size () - 2,\n-\t\t\t0));\n+\t   format_gcov (fn->blocks_executed, fn->get_block_count (), 0));\n   fprintf (f, \"\\n\");\n }\n \n@@ -3028,9 +3078,7 @@ output_lines (FILE *gcov_file, const source_info *src)\n \n \t      fprintf (gcov_file, FN_SEPARATOR);\n \n-\t      string fn_name\n-\t\t= flag_demangled_names ? fn->demangled_name : fn->name;\n-\n+\t      string fn_name = fn->get_name ();\n \t      if (flag_use_colors)\n \t\t{\n \t\t  fn_name.insert (0, SGR_SEQ (COLOR_FG_CYAN));"}, {"sha": "a0c439560e974fa85016e067244b9f3b20591b28", "filename": "gcc/json.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fjson.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fjson.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjson.cc?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -296,6 +296,9 @@ test_writing_literals ()\n   assert_print_eq (literal (JSON_TRUE), \"true\");\n   assert_print_eq (literal (JSON_FALSE), \"false\");\n   assert_print_eq (literal (JSON_NULL), \"null\");\n+\n+  assert_print_eq (literal (true), \"true\");\n+  assert_print_eq (literal (false), \"false\");\n }\n \n /* Run all of the selftests within this file.  */"}, {"sha": "e99141e71e15cace81757d367bc0830db4afaec2", "filename": "gcc/json.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fjson.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Fjson.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjson.h?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -154,6 +154,9 @@ class literal : public value\n  public:\n   literal (enum kind kind) : m_kind (kind) {}\n \n+  /* Construct literal for a boolean value.  */\n+  literal (bool value): m_kind (value ? JSON_TRUE : JSON_FALSE) {}\n+\n   enum kind get_kind () const FINAL OVERRIDE { return m_kind; }\n   void print (pretty_printer *pp) const FINAL OVERRIDE;\n "}, {"sha": "5584b886f1dcd52e46809e61e95fad3fdc325198", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -1,3 +1,8 @@\n+2018-10-29  Martin Liska  <mliska@suse.cz>\n+\n+\t* g++.dg/gcov/gcov-8.C: Do not check intermediate format.\n+\t* lib/gcov.exp: Remove legacy verify-intermediate.\n+\n 2018-10-28  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* gcc.dg/gimplefe-30.c: New test."}, {"sha": "1c97c35d8c1e3d2aad97d124d3be8865b56d0338", "filename": "gcc/testsuite/g++.dg/gcov/gcov-8.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-8.C?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -1,5 +1,3 @@\n-/* Verify that intermediate coverage format can be generated for simple code. */\n-\n /* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n /* { dg-do run { target native } } */\n \n@@ -32,4 +30,4 @@ int main()\n   foo();\n }\n \n-/* { dg-final { run-gcov intermediate { -i -b gcov-8.C } } } */\n+/* { dg-final { run-gcov { -b gcov-8.C } } } */"}, {"sha": "a7b8c0a1ef45d4dafc0b5e491727754a14df0171", "filename": "gcc/testsuite/lib/gcov.exp", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8fda30f0cc084626af70dea607fc081f67d95f1/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcov.exp?ref=c8fda30f0cc084626af70dea607fc081f67d95f1", "patch": "@@ -83,61 +83,6 @@ proc verify-lines { testname testcase file } {\n }\n \n \n-#\n-# verify-intermediate -- check that intermediate file has certain lines\n-#\n-# TESTNAME is the name of the test, including unique flags.\n-# TESTCASE is the name of the test.\n-# FILE is the name of the gcov output file.\n-#\n-# Checks are very loose, they are based on certain tags being present\n-# in the output. They do not check for exact expected execution\n-# counts. For that the regular gcov format should be checked.\n-#\n-proc verify-intermediate { testname testcase file } {\n-    set failed 0\n-    set srcfile 0\n-    set function 0\n-    set lcount 0\n-    set branch 0\n-    set fd [open $file r]\n-    while { [gets $fd line] >= 0 } {\n-\tif [regexp \"^file:\" $line] {\n-\t    incr srcfile\n-\t}\n-\tif [regexp \"^function:(\\[0-9\\]+),(\\[0-9\\]+),.*\" $line] {\n-\t    incr function\n-\t}\n-\tif [regexp \"^lcount:(\\[0-9\\]+),(\\[0-9\\]+),(\\[01\\])\" $line] {\n-\t    incr lcount\n-\t}\n-\tif [regexp \"^branch:(\\[0-9\\]+),(taken|nottaken|notexec)\" $line] {\n-\t    incr branch\n-\t}\n-    }\n-\n-    # We should see at least one tag of each type\n-    if {$srcfile == 0} {\n-\tfail \"$testname expected 'file:' tag not found\"\n-\tincr failed\n-    }\n-    if {$function == 0} {\n-\tfail \"$testname expected 'function:' tag not found\"\n-\tincr failed\n-    }\n-    if {$lcount == 0} {\n-\tfail \"$testname expected 'lcount:' tag not found\"\n-\tincr failed\n-    }\n-    if {$branch == 0} {\n-\tfail \"$testname expected 'branch:' tag not found\"\n-\tincr failed\n-    }\n-    close $fd\n-    return $failed\n-}\n-\n-\n #\n # verify-branches -- check that branch percentages are as expected\n #"}]}