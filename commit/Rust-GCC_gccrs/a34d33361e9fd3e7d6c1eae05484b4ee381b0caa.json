{"sha": "a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM0ZDMzMzYxZTlmZDNlN2Q2YzFlYWUwNTQ4NGI0ZWUzODFiMGNhYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-01T08:29:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-01T08:29:50Z"}, "message": "call.c (add_template_candidates_real): Remove length parameter from fn_type_unification call.\n\n\t* call.c (add_template_candidates_real): Remove length parameter\n\tfrom fn_type_unification call.\n\t* class.c (resolve_address_of_overloaded_function): Likewise\n\t* cp-tree.h (fn_type_unification): Remove length parameter.\n\t* pt.c (get_bindings_overload): Remove.\n\t(get_bindings_real): Rename to ...\n\t(get_bindings): ... here.  Remove length and strict\n\tparameters. Change return type flag to boolean.  Remove original\n\tforwarding function.\n\t(determine_specialization): Adjust get_bindings call.\n\t(fn_type_unification): Remove length parameter.  Adjust.\n\t(type_unification_real): Remove length parameter.  Adjust.\n\t(resolve_overloaded_unification): Adjust get_bindings call.\n\t(try_one_overload): Simplify confusing cascaded if control flow.\n\t(unify): Remove length paramter from type_unification_real call.\n\t(most_specialized_instantiation): Adjust get_bindings calls.\n\t(most_specialized): Likewise.\n\nFrom-SVN: r97379", "tree": {"sha": "786304f7491132f451b00dd2f37be9afeba859b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/786304f7491132f451b00dd2f37be9afeba859b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/comments", "author": null, "committer": null, "parents": [{"sha": "40ce6bf64841651b0d9dc4a686246b4a828a613a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40ce6bf64841651b0d9dc4a686246b4a828a613a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40ce6bf64841651b0d9dc4a686246b4a828a613a"}], "stats": {"total": 161, "additions": 65, "deletions": 96}, "files": [{"sha": "4065f17469377b142c470ee1b16587e956743724", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "patch": "@@ -1,3 +1,23 @@\n+2005-04-01  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (add_template_candidates_real): Remove length parameter\n+\tfrom fn_type_unification call.\n+\t* class.c (resolve_address_of_overloaded_function): Likewise\n+\t* cp-tree.h (fn_type_unification): Remove length parameter.\n+\t* pt.c (get_bindings_overload): Remove.\n+\t(get_bindings_real): Rename to ...\n+\t(get_bindings): ... here.  Remove length and strict\n+\tparameters. Change return type flag to boolean.  Remove original\n+\tforwarding function.\n+\t(determine_specialization): Adjust get_bindings call.\n+\t(fn_type_unification): Remove length parameter.  Adjust.\n+\t(type_unification_real): Remove length parameter.  Adjust.\n+\t(resolve_overloaded_unification): Adjust get_bindings call.\n+\t(try_one_overload): Simplify confusing cascaded if control flow.\n+\t(unify): Remove length paramter from type_unification_real call.\n+\t(most_specialized_instantiation): Adjust get_bindings calls.\n+\t(most_specialized): Likewise.\n+\n 2005-03-31  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/19203, implement DR 214"}, {"sha": "7dbb4d644f11ac8633656b2f74279dd0db104e19", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "patch": "@@ -2187,7 +2187,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n \n   i = fn_type_unification (tmpl, explicit_targs, targs,\n \t\t\t   args_without_in_chrg,\n-\t\t\t   return_type, strict, -1);\n+\t\t\t   return_type, strict);\n \n   if (i != 0)\n     return NULL;"}, {"sha": "df0587e677af8acce6749213d2cd11ec98da0076", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "patch": "@@ -5733,7 +5733,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  targs = make_tree_vec (DECL_NTPARMS (fn));\n \t  if (fn_type_unification (fn, explicit_targs, targs,\n \t\t\t\t   target_arg_types, target_ret_type,\n-\t\t\t\t   DEDUCE_EXACT, -1) != 0)\n+\t\t\t\t   DEDUCE_EXACT))\n \t    /* Argument deduction failed.  */\n \t    continue;\n "}, {"sha": "b83b5dc422dcefda3de433ea7048c4075bb48736", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "patch": "@@ -3995,7 +3995,7 @@ extern int uses_template_parms\t\t\t(tree);\n extern int uses_template_parms_level\t\t(tree, int);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n-extern int fn_type_unification                  (tree, tree, tree, tree, tree, unification_kind_t, int);\n+extern int fn_type_unification                  (tree, tree, tree, tree, tree, unification_kind_t);\n extern void mark_decl_instantiated\t\t(tree, int);\n extern int more_specialized_fn\t\t\t(tree, tree, int);\n extern void mark_class_instantiated\t\t(tree, int);"}, {"sha": "f92ce90a7f0fad2c65f47274c3d8f2ed45b06936", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 42, "deletions": 93, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a34d33361e9fd3e7d6c1eae05484b4ee381b0caa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a34d33361e9fd3e7d6c1eae05484b4ee381b0caa", "patch": "@@ -108,13 +108,12 @@ static tree add_outermost_template_args (tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*); \n static int  type_unification_real (tree, tree, tree, tree,\n-\t\t\t\t   int, unification_kind_t, int, int);\n+\t\t\t\t   int, unification_kind_t, int);\n static void note_template_header (int);\n static tree convert_nontype_argument_function (tree, tree);\n static tree convert_nontype_argument (tree, tree);\n static tree convert_template_argument (tree, tree, tree,\n \t\t\t\t       tsubst_flags_t, int, tree);\n-static tree get_bindings_overload (tree, tree, tree);\n static int for_each_template_parm (tree, tree_fn_t, void*,\n \t\t\t\t   struct pointer_set_t*);\n static tree build_template_parm_index (int, int, int, tree, tree);\n@@ -128,8 +127,7 @@ static int template_parm_this_level_p (tree, void *);\n static tree tsubst_friend_function (tree, tree);\n static tree tsubst_friend_class (tree, tree);\n static int can_complete_type_without_circularity (tree);\n-static tree get_bindings (tree, tree, tree);\n-static tree get_bindings_real (tree, tree, tree, int, int, int);\n+static tree get_bindings (tree, tree, tree, bool);\n static int template_decl_level (tree);\n static int check_cv_quals_for_unify (int, tree, tree);\n static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);\n@@ -1433,7 +1431,7 @@ determine_specialization (tree template_id,\n  \n \t  /* See whether this function might be a specialization of this\n \t     template.  */\n-\t  targs = get_bindings (fn, decl, explicit_targs);\n+\t  targs = get_bindings (fn, decl, explicit_targs, /*check_ret=*/true);\n \n \t  if (!targs)\n \t    /* We cannot deduce template arguments that when used to\n@@ -1532,7 +1530,7 @@ determine_specialization (tree template_id,\n      tree tmpl = most_specialized (templates, decl, explicit_targs);\n      if (tmpl && tmpl != error_mark_node)\n        {\n-\t targs = get_bindings (tmpl, decl, explicit_targs);\n+\t targs = get_bindings (tmpl, decl, explicit_targs, /*check_ret=*/true);\n \t templates = tree_cons (targs, tmpl, NULL_TREE);\n        }\n     }\n@@ -9062,22 +9060,15 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n      We are deducing arguments when doing an explicit instantiation\n      as in [temp.explicit], when determining an explicit specialization\n      as in [temp.expl.spec], or when taking the address of a function\n-     template, as in [temp.deduct.funcaddr]. \n-\n-   LEN is the number of parms to consider before returning success, or -1\n-   for all.  This is used in partial ordering to avoid comparing parms for\n-   which no actual argument was passed, since they are not considered in\n-   overload resolution (and are explicitly excluded from consideration in\n-   partial ordering in [temp.func.order]/6).  */\n+     template, as in [temp.deduct.funcaddr].  */\n \n int\n fn_type_unification (tree fn, \n                      tree explicit_targs, \n                      tree targs, \n                      tree args, \n                      tree return_type,\n-\t\t     unification_kind_t strict, \n-                     int len)\n+\t\t     unification_kind_t strict)\n {\n   tree parms;\n   tree fntype;\n@@ -9148,8 +9139,6 @@ fn_type_unification (tree fn,\n       /* We've been given a return type to match, prepend it.  */\n       parms = tree_cons (NULL_TREE, TREE_TYPE (fntype), parms);\n       args = tree_cons (NULL_TREE, return_type, args);\n-      if (len >= 0)\n-\t++len;\n     }\n \n   /* We allow incomplete unification without an error message here\n@@ -9158,7 +9147,7 @@ fn_type_unification (tree fn,\n      event.  */\n   result = type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n \t\t\t\t  targs, parms, args, /*subr=*/0,\n-\t\t\t\t  strict, /*allow_incomplete*/1, len);\n+\t\t\t\t  strict, /*allow_incomplete*/1);\n \n   if (result == 0) \n     /* All is well so far.  Now, check:\n@@ -9275,16 +9264,14 @@ type_unification_real (tree tparms,\n                        tree xargs, \n                        int subr,\n \t\t       unification_kind_t strict, \n-                       int allow_incomplete, \n-                       int xlen)\n+                       int allow_incomplete)\n {\n   tree parm, arg;\n   int i;\n   int ntparms = TREE_VEC_LENGTH (tparms);\n   int sub_strict;\n   int saw_undeduced = 0;\n   tree parms, args;\n-  int len;\n \n   gcc_assert (TREE_CODE (tparms) == TREE_VEC);\n   gcc_assert (xparms == NULL_TREE || TREE_CODE (xparms) == TREE_LIST);\n@@ -9310,18 +9297,12 @@ type_unification_real (tree tparms,\n       gcc_unreachable ();\n     }\n \n-  if (xlen == 0)\n-    return 0;\n-\n  again:\n   parms = xparms;\n   args = xargs;\n-  len = xlen;\n \n-  while (parms\n-\t && parms != void_list_node\n-\t && args\n-\t && args != void_list_node)\n+  while (parms && parms != void_list_node\n+\t && args && args != void_list_node)\n     {\n       parm = TREE_VALUE (parms);\n       parms = TREE_CHAIN (parms);\n@@ -9393,25 +9374,20 @@ type_unification_real (tree tparms,\n         if (unify (tparms, targs, parm, arg, arg_strict))\n           return 1;\n       }\n-\n-      /* Are we done with the interesting parms?  */\n-      if (--len == 0)\n-\tgoto done;\n     }\n+  \n   /* Fail if we've reached the end of the parm list, and more args\n      are present, and the parm list isn't variadic.  */\n   if (args && args != void_list_node && parms == void_list_node)\n     return 1;\n   /* Fail if parms are left and they don't have default values.  */\n-  if (parms\n-      && parms != void_list_node\n+  if (parms && parms != void_list_node\n       && TREE_PURPOSE (parms) == NULL_TREE)\n     return 1;\n \n- done:\n   if (!subr)\n     for (i = 0; i < ntparms; i++)\n-      if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n+      if (!TREE_VEC_ELT (targs, i))\n \t{\n \t  tree tparm = TREE_VALUE (TREE_VEC_ELT (tparms, i));\n \n@@ -9428,6 +9404,7 @@ type_unification_real (tree tparms,\n \t    error (\"incomplete type unification\");\n \t  return 2;\n \t}\n+  \n   return 0;\n }\n \n@@ -9485,8 +9462,8 @@ resolve_overloaded_unification (tree tparms,\n \t  if (TREE_CODE (fn) != TEMPLATE_DECL)\n \t    continue;\n \n-\t  subargs = get_bindings_overload (fn, DECL_TEMPLATE_RESULT (fn),\n-\t\t\t\t\t   expl_subargs);\n+\t  subargs = get_bindings (fn, DECL_TEMPLATE_RESULT (fn),\n+\t\t\t\t  expl_subargs, /*check_ret=*/false);\n \t  if (subargs)\n \t    {\n \t      elem = tsubst (TREE_TYPE (fn), subargs, tf_none, NULL_TREE);\n@@ -9583,17 +9560,14 @@ try_one_overload (tree tparms,\n       tree elt = TREE_VEC_ELT (tempargs, i);\n       tree oldelt = TREE_VEC_ELT (orig_targs, i);\n \n-      if (elt == NULL_TREE)\n-\tcontinue;\n+      if (!elt)\n+\t/*NOP*/;\n       else if (uses_template_parms (elt))\n-\t{\n-\t  /* Since we're unifying against ourselves, we will fill in template\n-\t     args used in the function parm list with our own template parms.\n-\t     Discard them.  */\n-\t  TREE_VEC_ELT (tempargs, i) = NULL_TREE;\n-\t  continue;\n-\t}\n-      else if (oldelt && ! template_args_equal (oldelt, elt))\n+\t/* Since we're unifying against ourselves, we will fill in\n+\t   template args used in the function parm list with our own\n+\t   template parms.  Discard them.  */\n+\tTREE_VEC_ELT (tempargs, i) = NULL_TREE;\n+      else if (oldelt && !template_args_equal (oldelt, elt))\n \treturn 0;\n     }\n \n@@ -10254,7 +10228,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \treturn 1;\n       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t\t    TYPE_ARG_TYPES (arg), 1, \n-\t\t\t\t    DEDUCE_EXACT, 0, -1);\n+\t\t\t\t    DEDUCE_EXACT, 0);\n \n     case OFFSET_TYPE:\n       /* Unify a pointer to member with a pointer to member function, which\n@@ -10585,23 +10559,17 @@ more_specialized_class (tree pat1, tree pat2, tree full_args)\n \n /* Return the template arguments that will produce the function signature\n    DECL from the function template FN, with the explicit template\n-   arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is 1, the return type must\n+   arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is true, the return type must\n    also match.  Return NULL_TREE if no satisfactory arguments could be\n-   found.  DEDUCE and LEN are passed through to fn_type_unification.  */\n+   found.  */\n    \n static tree\n-get_bindings_real (tree fn, \n-                   tree decl, \n-                   tree explicit_args, \n-                   int check_rettype, \n-                   int deduce, \n-                   int len)\n+get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n {\n   int ntparms = DECL_NTPARMS (fn);\n   tree targs = make_tree_vec (ntparms);\n   tree decl_type;\n   tree decl_arg_types;\n-  int i;\n \n   /* Substitute the explicit template arguments into the type of DECL.\n      The call to fn_type_unification will handle substitution into the\n@@ -10635,35 +10603,16 @@ get_bindings_real (tree fn,\n   if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n     decl_arg_types = TREE_CHAIN (decl_arg_types);\n \n-  i = fn_type_unification (fn, explicit_args, targs, \n+  if (fn_type_unification (fn, explicit_args, targs, \n \t\t\t   decl_arg_types,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n \t                    ? TREE_TYPE (decl_type) : NULL_TREE),\n-\t\t\t   deduce, len);\n-\n-  if (i != 0)\n+\t\t\t   DEDUCE_EXACT))\n     return NULL_TREE;\n \n   return targs;\n }\n \n-/* For most uses, we want to check the return type.  */\n-\n-static tree \n-get_bindings (tree fn, tree decl, tree explicit_args)\n-{\n-  return get_bindings_real (fn, decl, explicit_args, 1, DEDUCE_EXACT, -1);\n-}\n-\n-/* But for resolve_overloaded_unification, we only care about the parameter\n-   types.  */\n-\n-static tree\n-get_bindings_overload (tree fn, tree decl, tree explicit_args)\n-{\n-  return get_bindings_real (fn, decl, explicit_args, 0, DEDUCE_EXACT, -1);\n-}\n-\n /* Return the innermost template arguments that, when applied to a\n    template specialization whose innermost template parameters are\n    TPARMS, and whose specialization arguments are PARMS, yield the\n@@ -10721,14 +10670,14 @@ most_specialized_instantiation (tree instantiations)\n     {\n       int fate = 0;\n       \n-      if (get_bindings_real (TREE_VALUE (champ),\n-\t\t\t     DECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n-\t\t\t     NULL_TREE, 0, DEDUCE_EXACT, -1))\n+      if (get_bindings (TREE_VALUE (champ),\n+\t\t\tDECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n+\t\t\tNULL_TREE, /*check_ret=*/false))\n \tfate--;\n \n-      if (get_bindings_real (TREE_VALUE (fn),\n-\t\t\t     DECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n-\t\t\t     NULL_TREE, 0, DEDUCE_EXACT, -1))\n+      if (get_bindings (TREE_VALUE (fn),\n+\t\t\tDECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n+\t\t\tNULL_TREE, /*check_ret=*/false))\n \tfate++;\n       \n       if (fate != 1)\n@@ -10745,12 +10694,12 @@ most_specialized_instantiation (tree instantiations)\n     /* Now verify that champ is better than everything earlier in the\n        instantiation list.  */\n     for (fn = instantiations; fn != champ; fn = TREE_CHAIN (fn))\n-      if (get_bindings_real (TREE_VALUE (champ),\n-\t\t\t     DECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n-\t\t\t     NULL_TREE, 0, DEDUCE_EXACT, -1)\n-\t  || !get_bindings_real (TREE_VALUE (fn),\n-\t\t\t\t DECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n-\t\t\t\t NULL_TREE, 0, DEDUCE_EXACT, -1))\n+      if (get_bindings (TREE_VALUE (champ),\n+\t\t\tDECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n+\t\t\tNULL_TREE, /*check_ret=*/false)\n+\t  || !get_bindings (TREE_VALUE (fn),\n+\t\t\t    DECL_TEMPLATE_RESULT (TREE_VALUE (champ)),\n+\t\t\t    NULL_TREE, /*check_ret=*/false))\n \t{\n \t  champ = NULL_TREE;\n \t  break;\n@@ -10778,7 +10727,7 @@ most_specialized (tree fns, tree decl, tree explicit_args)\n     {\n       tree candidate = TREE_VALUE (fn);\n \n-      args = get_bindings (candidate, decl, explicit_args);\n+      args = get_bindings (candidate, decl, explicit_args, /*check_ret=*/true);\n       if (args)\n \tcandidates = tree_cons (NULL_TREE, candidate, candidates);\n     }"}]}