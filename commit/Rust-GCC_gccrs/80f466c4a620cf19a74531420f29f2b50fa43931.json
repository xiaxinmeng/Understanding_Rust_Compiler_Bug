{"sha": "80f466c4a620cf19a74531420f29f2b50fa43931", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBmNDY2YzRhNjIwY2YxOWE3NDUzMTQyMGYyOWYyYjUwZmE0MzkzMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-10-03T00:35:43Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-10-03T00:35:43Z"}, "message": "lra-constraints.c (process_alt_operand): Calculate scratch_p and use it.\n\n2013-10-02  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* lra-constraints.c (process_alt_operand): Calculate scratch_p and\n\tuse it.  Use smaller increase for scratch.  Don't increase reject\n\tfor early clobber scratch.\n\t* lra-eliminations.c (eliminate_regs_in_insn): Remove all insns\n\tsetting eliminated regs except setting fp from hfp.\n\t(lra_eliminate): Check lra_insn_recog_data on NULL.\n\nFrom-SVN: r203147", "tree": {"sha": "c383cf177580793322fe352bf3ad89392c51b481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c383cf177580793322fe352bf3ad89392c51b481"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80f466c4a620cf19a74531420f29f2b50fa43931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f466c4a620cf19a74531420f29f2b50fa43931", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80f466c4a620cf19a74531420f29f2b50fa43931", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80f466c4a620cf19a74531420f29f2b50fa43931/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7cfbb5a278b3eeda907d08de62a67d0fa4ba087c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfbb5a278b3eeda907d08de62a67d0fa4ba087c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cfbb5a278b3eeda907d08de62a67d0fa4ba087c"}], "stats": {"total": 165, "additions": 91, "deletions": 74}, "files": [{"sha": "01c4bfc173369c5a9eff376d12dc82198ae9be3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f466c4a620cf19a74531420f29f2b50fa43931/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f466c4a620cf19a74531420f29f2b50fa43931/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80f466c4a620cf19a74531420f29f2b50fa43931", "patch": "@@ -1,3 +1,12 @@\n+2013-10-02  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* lra-constraints.c (process_alt_operand): Calculate scratch_p and\n+\tuse it.  Use smaller increase for scratch.  Don't increase reject\n+\tfor early clobber scratch.\n+\t* lra-eliminations.c (eliminate_regs_in_insn): Remove all insns\n+\tsetting eliminated regs except setting fp from hfp.\n+\t(lra_eliminate): Check lra_insn_recog_data on NULL.\n+\n 2013-10-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/58587"}, {"sha": "783df16cd35307eef047204879c0088e945aa36b", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f466c4a620cf19a74531420f29f2b50fa43931/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f466c4a620cf19a74531420f29f2b50fa43931/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=80f466c4a620cf19a74531420f29f2b50fa43931", "patch": "@@ -1453,6 +1453,7 @@ process_alt_operands (int only_alternative)\n \t  HARD_REG_SET this_alternative_set, this_costly_alternative_set;\n \t  bool this_alternative_match_win, this_alternative_win;\n \t  bool this_alternative_offmemok;\n+\t  bool scratch_p;\n \t  enum machine_mode mode;\n \n \t  opalt_num = nalt * n_operands + nop;\n@@ -1858,6 +1859,8 @@ process_alt_operands (int only_alternative)\n \t    }\n \t  while ((p += len), c);\n \n+\t  scratch_p = (operand_reg[nop] != NULL_RTX\n+\t\t       && lra_former_scratch_p (REGNO (operand_reg[nop])));\n \t  /* Record which operands fit this alternative.  */\n \t  if (win)\n \t    {\n@@ -1878,14 +1881,17 @@ process_alt_operands (int only_alternative)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      /* Prefer won reg to spilled pseudo under other equal\n-\t\t\t conditions.  */\n-\t\t      if (lra_dump_file != NULL)\n-\t\t\tfprintf\n-\t\t\t  (lra_dump_file,\n-\t\t\t   \"            %d Non pseudo reload: reject++\\n\",\n-\t\t\t   nop);\n-\t\t      reject++;\n+\t\t      /* Prefer won reg to spilled pseudo under other\n+\t\t\t equal conditions for possibe inheritance.  */\n+\t\t      if (! scratch_p)\n+\t\t\t{\n+\t\t\t  if (lra_dump_file != NULL)\n+\t\t\t    fprintf\n+\t\t\t      (lra_dump_file,\n+\t\t\t       \"            %d Non pseudo reload: reject++\\n\",\n+\t\t\t       nop);\n+\t\t\t  reject++;\n+\t\t\t}\n \t\t      if (in_class_p (operand_reg[nop],\n \t\t\t\t      this_costly_alternative, NULL))\n \t\t\t{\n@@ -1904,13 +1910,13 @@ process_alt_operands (int only_alternative)\n \t\t     insns are generated for the scratches.  So it\n \t\t     might cost something but probably less than old\n \t\t     reload pass believes.  */\n-\t\t  if (lra_former_scratch_p (REGNO (operand_reg[nop])))\n+\t\t  if (scratch_p)\n \t\t    {\n \t\t      if (lra_dump_file != NULL)\n \t\t\tfprintf (lra_dump_file,\n-\t\t\t\t \"            %d Scratch win: reject+=3\\n\",\n+\t\t\t\t \"            %d Scratch win: reject+=2\\n\",\n \t\t\t\t nop);\n-\t\t      reject += 3;\n+\t\t      reject += 2;\n \t\t    }\n \t\t}\n \t    }\n@@ -2124,7 +2130,7 @@ process_alt_operands (int only_alternative)\n \t\t}\n \t    }\n \n-\t  if (early_clobber_p)\n+\t  if (early_clobber_p && ! scratch_p)\n \t    {\n \t      if (lra_dump_file != NULL)\n \t\tfprintf (lra_dump_file,"}, {"sha": "2eddb9dd85a2a530547e7e361313ef44bba43833", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 64, "deletions": 62, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80f466c4a620cf19a74531420f29f2b50fa43931/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80f466c4a620cf19a74531420f29f2b50fa43931/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=80f466c4a620cf19a74531420f29f2b50fa43931", "patch": "@@ -809,69 +809,69 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n   if (old_set != 0 && REG_P (SET_DEST (old_set))\n       && (ep = get_elimination (SET_DEST (old_set))) != NULL)\n     {\n-      bool delete_p = replace_p;\n-\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->from_rtx == SET_DEST (old_set) && ep->can_eliminate)\n+\t  {\n+\t    bool delete_p = replace_p;\n+\t    \n #ifdef HARD_FRAME_POINTER_REGNUM\n-      /* If this is setting the frame pointer register to the hardware\n-\t frame pointer register and this is an elimination that will\n-\t be done (tested above), this insn is really adjusting the\n-\t frame pointer downward to compensate for the adjustment done\n-\t before a nonlocal goto.  */\n-      if (ep->from == FRAME_POINTER_REGNUM\n-\t  && ep->to == HARD_FRAME_POINTER_REGNUM)\n-\t{\n-\t  rtx src = SET_SRC (old_set);\n-\t  rtx off = remove_reg_equal_offset_note (insn, ep->to_rtx);\n-\n-\t  if (replace_p)\n-\t    {\n-\t      SET_DEST (old_set) = ep->to_rtx;\n-\t      lra_update_insn_recog_data (insn);\n-\t      return;\n-\t    }\n-\t  else if (off != NULL_RTX\n-\t\t   || src == ep->to_rtx\n-\t\t   || (GET_CODE (src) == PLUS\n-\t\t       && XEXP (src, 1) == ep->to_rtx\n-\t\t       && CONST_INT_P (XEXP (src, 1))))\n-\t    {\n-\t      HOST_WIDE_INT offset = (off != NULL_RTX\n-\t\t\t\t      ? INTVAL (off)\n-\t\t\t\t      : src == ep->to_rtx\n-\t\t\t\t      ? 0 : INTVAL (XEXP (src, 1)));\n-\t      \n-\t      offset -= (ep->offset - ep->previous_offset);\n-\t      src = plus_constant (Pmode, ep->to_rtx, offset);\n-\t      \n-\t      /* First see if this insn remains valid when we make\n-\t\t the change.  If not, keep the INSN_CODE the same\n-\t\t and let the constraint pass fit it up.  */\n-\t      validate_change (insn, &SET_SRC (old_set), src, 1);\n-\t      validate_change (insn, &SET_DEST (old_set),\n-\t\t\t       ep->from_rtx, 1);\n-\t      if (! apply_change_group ())\n-\t\t{\n-\t\t  SET_SRC (old_set) = src;\n-\t\t  SET_DEST (old_set) = ep->from_rtx;\n-\t\t}\n-\t      lra_update_insn_recog_data (insn);\n-\t      /* Add offset note for future updates.  */\n-\t      add_reg_note (insn, REG_EQUAL, src);\n-\t      return;\n-\t    }\n-\n-\n-\t  /* We can't delete this insn, but needn't process it\n-\t     since it won't be used unless something changes.  */\n-\t  delete_p = false;\n-\t}\n+\t    if (ep->from == FRAME_POINTER_REGNUM\n+\t\t&& ep->to == HARD_FRAME_POINTER_REGNUM)\n+\t      /* If this is setting the frame pointer register to the\n+\t\t hardware frame pointer register and this is an\n+\t\t elimination that will be done (tested above), this\n+\t\t insn is really adjusting the frame pointer downward\n+\t\t to compensate for the adjustment done before a\n+\t\t nonlocal goto.  */\n+\t      {\n+\t\trtx src = SET_SRC (old_set);\n+\t\trtx off = remove_reg_equal_offset_note (insn, ep->to_rtx);\n+\t\t\n+\t\tif (off != NULL_RTX\n+\t\t    || src == ep->to_rtx\n+\t\t    || (GET_CODE (src) == PLUS\n+\t\t\t&& XEXP (src, 0) == ep->to_rtx\n+\t\t\t&& CONST_INT_P (XEXP (src, 1))))\n+\t\t  {\n+\t\t    HOST_WIDE_INT offset;\n+\t\t    \n+\t\t    if (replace_p)\n+\t\t      {\n+\t\t\tSET_DEST (old_set) = ep->to_rtx;\n+\t\t\tlra_update_insn_recog_data (insn);\n+\t\t\treturn;\n+\t\t      }\n+\t\t    offset = (off != NULL_RTX ? INTVAL (off)\n+\t\t\t      : src == ep->to_rtx ? 0 : INTVAL (XEXP (src, 1)));\n+\t\t    offset -= (ep->offset - ep->previous_offset);\n+\t\t    src = plus_constant (Pmode, ep->to_rtx, offset);\n+\t\t    \n+\t\t    /* First see if this insn remains valid when we\n+\t\t       make the change.  If not, keep the INSN_CODE\n+\t\t       the same and let the constraint pass fit it\n+\t\t       up.  */\n+\t\t    validate_change (insn, &SET_SRC (old_set), src, 1);\n+\t\t    validate_change (insn, &SET_DEST (old_set),\n+\t\t\t\t     ep->from_rtx, 1);\n+\t\t    if (! apply_change_group ())\n+\t\t      {\n+\t\t\tSET_SRC (old_set) = src;\n+\t\t\tSET_DEST (old_set) = ep->from_rtx;\n+\t\t      }\n+\t\t    lra_update_insn_recog_data (insn);\n+\t\t    /* Add offset note for future updates.  */\n+\t\t    add_reg_note (insn, REG_EQUAL, src);\n+\t\t    return;\n+\t\t  }\n+\t      }\n #endif\n-\n-      /* This insn isn't serving a useful purpose.  We delete it\n-\t when REPLACE is set.  */\n-      if (delete_p)\n-\tlra_delete_dead_insn (insn);\n-      return;\n+\t    \n+\t    /* This insn isn't serving a useful purpose.  We delete it\n+\t       when REPLACE is set.  */\n+\t    if (delete_p)\n+\t      lra_delete_dead_insn (insn);\n+\t    return;\n+\t  }\n     }\n \n   /* We allow one special case which happens to work on all machines we\n@@ -1318,7 +1318,9 @@ lra_eliminate (bool final_p)\n \t\t   \"Updating elimination of equiv for reg %d\\n\", i);\n       }\n   EXECUTE_IF_SET_IN_BITMAP (&insns_with_changed_offsets, 0, uid, bi)\n-    process_insn_for_elimination (lra_insn_recog_data[uid]->insn, final_p);\n+    /* A dead insn can be deleted in process_insn_for_elimination.  */\n+    if (lra_insn_recog_data[uid] != NULL)\n+      process_insn_for_elimination (lra_insn_recog_data[uid]->insn, final_p);\n   bitmap_clear (&insns_with_changed_offsets);\n \n lra_eliminate_done:"}]}