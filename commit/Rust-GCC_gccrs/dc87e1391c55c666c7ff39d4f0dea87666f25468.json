{"sha": "dc87e1391c55c666c7ff39d4f0dea87666f25468", "node_id": "C_kwDOANBUbNoAKGRjODdlMTM5MWM1NWM2NjZjN2ZmMzlkNGYwZGVhODc2NjZmMjU0Njg", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-10T10:07:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-10T11:21:41Z"}, "message": "tree-optimization/108724 - vectorized code getting piecewise expanded\n\nThis fixes an oversight to when removing the hard limits on using\ngeneric vectors for the vectorizer to enable both SLP and BB\nvectorization to use those.  The vectorizer relies on vector lowering\nto expand plus, minus and negate to bit operations but vector\nlowering has a hard limit on the minimum number of elements per\nwork item.  Vectorizer costs for the testcase at hand work out\nto vectorize a loop with just two work items per vector and that\ncauses element wise expansion and spilling.\n\nThe fix for now is to re-instantiate the hard limit, matching what\nvector lowering does.  For the future the way to go is to emit the\nlowered sequence directly from the vectorizer instead.\n\n\tPR tree-optimization/108724\n\t* tree-vect-stmts.cc (vectorizable_operation): Avoid\n\tusing word_mode vectors when vector lowering will\n\tdecompose them to elementwise operations.\n\n\t* gcc.target/i386/pr108724.c: New testcase.", "tree": {"sha": "38e33d8ef90915dfaf3e9ec58344e3dd0c395a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38e33d8ef90915dfaf3e9ec58344e3dd0c395a3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc87e1391c55c666c7ff39d4f0dea87666f25468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc87e1391c55c666c7ff39d4f0dea87666f25468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc87e1391c55c666c7ff39d4f0dea87666f25468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc87e1391c55c666c7ff39d4f0dea87666f25468/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a37a4a3cbfaecb6c7666109353bb4d5c97b0702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a37a4a3cbfaecb6c7666109353bb4d5c97b0702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a37a4a3cbfaecb6c7666109353bb4d5c97b0702"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "c4e0e918610238ff2e6339f1a2504eee717f5254", "filename": "gcc/testsuite/gcc.target/i386/pr108724.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc87e1391c55c666c7ff39d4f0dea87666f25468/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108724.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc87e1391c55c666c7ff39d4f0dea87666f25468/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108724.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108724.c?ref=dc87e1391c55c666c7ff39d4f0dea87666f25468", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -mno-sse\" } */\n+\n+int a[16], b[16], c[16];\n+void foo()\n+{\n+  for (int i = 0; i < 16; i++) {\n+    a[i] = b[i] + c[i];\n+  }\n+}\n+\n+/* When this is vectorized this shouldn't be expanded piecewise again\n+   which will result in spilling for the upper half access.  */\n+\n+/* { dg-final { scan-assembler-not \"\\\\\\[er\\\\\\]sp\" } } */"}, {"sha": "09b5af603d271b1d0dd6394bc179186000d69e34", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc87e1391c55c666c7ff39d4f0dea87666f25468/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc87e1391c55c666c7ff39d4f0dea87666f25468/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=dc87e1391c55c666c7ff39d4f0dea87666f25468", "patch": "@@ -6315,6 +6315,20 @@ vectorizable_operation (vec_info *vinfo,\n       return false;\n     }\n \n+  /* ???  We should instead expand the operations here, instead of\n+     relying on vector lowering which has this hard cap on the number\n+     of vector elements below it performs elementwise operations.  */\n+  if (using_emulated_vectors_p\n+      && (code == PLUS_EXPR || code == MINUS_EXPR || code == NEGATE_EXPR)\n+      && ((BITS_PER_WORD / vector_element_bits (vectype)) < 4\n+\t  || maybe_lt (nunits_out, 4U)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf (MSG_NOTE, \"not using word mode for +- and less than \"\n+\t\t     \"four vector elements\\n\");\n+      return false;\n+    }\n+\n   int reduc_idx = STMT_VINFO_REDUC_IDX (stmt_info);\n   vec_loop_masks *masks = (loop_vinfo ? &LOOP_VINFO_MASKS (loop_vinfo) : NULL);\n   internal_fn cond_fn = get_conditional_internal_fn (code);"}]}