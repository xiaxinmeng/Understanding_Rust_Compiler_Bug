{"sha": "6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIxNjEyNTdmOWY4YzdhMjZiN2QxMTllYmMzMmNiYmM1NGQyZTUwOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-22T19:44:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-23T21:49:44Z"}, "message": "c++: Improve CTAD for aggregates [PR93976]\n\nP2082R1 adjusted the rules for class template argument deduction for an\naggregate to better handle arrays and pack expansions.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/93976\n\tImplement C++20 P2082R1, Fixing CTAD for aggregates.\n\t* cp-tree.h (TPARMS_PRIMARY_TEMPLATE): Split out from...\n\t(DECL_PRIMARY_TEMPLATE): ...here.\n\t(builtin_guide_p): Declare.\n\t* decl.c (reshape_init_class): Handle bases of a template.\n\t(reshape_init_r): An array with dependent bound takes a single\n\tinitializer.\n\t* pt.c (tsubst_default_argument): Shortcut {}.\n\t(unify_pack_expansion): Allow omitted arguments to trailing pack.\n\t(builtin_guide_p): New.\n\t(collect_ctor_idx_types): Give a trailing pack a {} default\n\targument.  Handle arrays better.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/class-deduction-aggr3.C: New test.\n\t* g++.dg/cpp2a/class-deduction-aggr4.C: New test.", "tree": {"sha": "7a4ecad39891e6b19eb3978fc96e543c2655e492", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a4ecad39891e6b19eb3978fc96e543c2655e492"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f609029c7078fbd29e2f842074e2b99ea099096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f609029c7078fbd29e2f842074e2b99ea099096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f609029c7078fbd29e2f842074e2b99ea099096"}], "stats": {"total": 186, "additions": 171, "deletions": 15}, "files": [{"sha": "78e8ca4150a2f502bed5ef571adb907e5b6bb17e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "patch": "@@ -4815,8 +4815,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    templates are primary, too.  */\n \n /* Returns the primary template corresponding to these parameters.  */\n+#define TPARMS_PRIMARY_TEMPLATE(NODE) (TREE_TYPE (NODE))\n+\n #define DECL_PRIMARY_TEMPLATE(NODE) \\\n-  (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)))\n+  (TPARMS_PRIMARY_TEMPLATE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)))\n \n /* Returns nonzero if NODE is a primary template.  */\n #define PRIMARY_TEMPLATE_P(NODE) (DECL_PRIMARY_TEMPLATE (NODE) == (NODE))\n@@ -7024,6 +7026,7 @@ extern bool dguide_name_p\t\t\t(tree);\n extern bool deduction_guide_p\t\t\t(const_tree);\n extern bool copy_guide_p\t\t\t(const_tree);\n extern bool template_guide_p\t\t\t(const_tree);\n+extern bool builtin_guide_p\t\t\t(const_tree);\n extern void store_explicit_specifier\t\t(tree, tree);\n extern tree add_outermost_template_args\t\t(tree, tree);\n "}, {"sha": "3afad5ca80505971e58ae130c9618965c563ad2d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "patch": "@@ -6153,7 +6153,22 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n \n   /* The initializer for a class is always a CONSTRUCTOR.  */\n   new_init = build_constructor (init_list_type_node, NULL);\n-  field = next_initializable_field (TYPE_FIELDS (type));\n+\n+  int binfo_idx = -1;\n+  tree binfo = TYPE_BINFO (type);\n+  tree base_binfo = NULL_TREE;\n+  if (cxx_dialect >= cxx17 && uses_template_parms (type))\n+    {\n+      /* We get here from maybe_aggr_guide for C++20 class template argument\n+\t deduction.  In this case we need to look through the binfo because a\n+\t template doesn't have base fields.  */\n+      binfo_idx = 0;\n+      BINFO_BASE_ITERATE (binfo, binfo_idx, base_binfo);\n+    }\n+  if (base_binfo)\n+    field = base_binfo;\n+  else\n+    field = next_initializable_field (TYPE_FIELDS (type));\n \n   if (!field)\n     {\n@@ -6171,6 +6186,9 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n       return new_init;\n     }\n \n+  /* For C++20 CTAD, handle pack expansions in the base list.  */\n+  tree last_was_pack_expansion = NULL_TREE;\n+\n   /* Loop through the initializable fields, gathering initializers.  */\n   while (d->cur != d->end)\n     {\n@@ -6218,6 +6236,13 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n       if (!field)\n \tbreak;\n \n+      last_was_pack_expansion = (PACK_EXPANSION_P (TREE_TYPE (field))\n+\t\t\t\t ? field : NULL_TREE);\n+      if (last_was_pack_expansion)\n+\t/* Each non-trailing aggregate element that is a pack expansion is\n+\t   assumed to correspond to no elements of the initializer list.  */\n+\tgoto continue_;\n+\n       field_init = reshape_init_r (TREE_TYPE (field), d,\n \t\t\t\t   /*first_initializer_p=*/NULL_TREE,\n \t\t\t\t   complain);\n@@ -6243,7 +6268,27 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,\n       if (TREE_CODE (type) == UNION_TYPE)\n \tbreak;\n \n-      field = next_initializable_field (DECL_CHAIN (field));\n+    continue_:\n+      if (base_binfo)\n+\t{\n+\t  BINFO_BASE_ITERATE (binfo, ++binfo_idx, base_binfo);\n+\t  if (base_binfo)\n+\t    field = base_binfo;\n+\t  else\n+\t    field = next_initializable_field (TYPE_FIELDS (type));\n+\t}\n+      else\n+\tfield = next_initializable_field (DECL_CHAIN (field));\n+    }\n+\n+  /* A trailing aggregate element that is a pack expansion is assumed to\n+     correspond to all remaining elements of the initializer list (if any).  */\n+  if (last_was_pack_expansion)\n+    {\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init),\n+\t\t\t      last_was_pack_expansion, d->cur->value);\n+      while (d->cur != d->end)\n+\td->cur++;\n     }\n \n   return new_init;\n@@ -6319,7 +6364,11 @@ reshape_init_r (tree type, reshape_iter *d, tree first_initializer_p,\n \n   /* A non-aggregate type is always initialized with a single\n      initializer.  */\n-  if (!CP_AGGREGATE_TYPE_P (type))\n+  if (!CP_AGGREGATE_TYPE_P (type)\n+      /* As is an array with dependent bound.  */\n+      || (cxx_dialect >= cxx20\n+\t  && TREE_CODE (type) == ARRAY_TYPE\n+\t  && uses_template_parms (TYPE_DOMAIN (type))))\n     {\n       /* It is invalid to initialize a non-aggregate type with a\n \t brace-enclosed initializer before C++0x."}, {"sha": "53a64c3a15e4be0a2d78cce0d72edf02229e668e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "patch": "@@ -13406,6 +13406,11 @@ tsubst_default_argument (tree fn, int parmnum, tree type, tree arg,\n   if (TREE_CODE (arg) == DEFERRED_PARSE)\n     return arg;\n \n+  /* Shortcut {}.  */\n+  if (BRACE_ENCLOSED_INITIALIZER_P (arg)\n+      && CONSTRUCTOR_NELTS (arg) == 0)\n+    return arg;\n+\n   tree parm = FUNCTION_FIRST_USER_PARM (fn);\n   parm = chain_index (parmnum, parm);\n   tree parmtype = TREE_TYPE (parm);\n@@ -22769,7 +22774,15 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n \t{\n \t  tree bad_old_arg = NULL_TREE, bad_new_arg = NULL_TREE;\n \t  tree old_args = ARGUMENT_PACK_ARGS (old_pack);\n-\n+\t  temp_override<int> ovl (TREE_VEC_LENGTH (old_args));\n+\t  /* During template argument deduction for the aggregate deduction\n+\t     candidate, the number of elements in a trailing parameter pack\n+\t     is only deduced from the number of remaining function\n+\t     arguments if it is not otherwise deduced.  */\n+\t  if (cxx_dialect >= cxx20\n+\t      && TREE_VEC_LENGTH (new_args) < TREE_VEC_LENGTH (old_args)\n+\t      && builtin_guide_p (TPARMS_PRIMARY_TEMPLATE (tparms)))\n+\t    TREE_VEC_LENGTH (old_args) = TREE_VEC_LENGTH (new_args);\n \t  if (!comp_template_args (old_args, new_args,\n \t\t\t\t   &bad_old_arg, &bad_new_arg))\n \t    /* Inconsistent unification of this parameter pack.  */\n@@ -27982,6 +27995,23 @@ template_guide_p (const_tree fn)\n   return false;\n }\n \n+/* True if FN is an aggregate initialization guide or the copy deduction\n+   guide.  */\n+\n+bool\n+builtin_guide_p (const_tree fn)\n+{\n+  if (!deduction_guide_p (fn))\n+    return false;\n+  if (!DECL_ARTIFICIAL (fn))\n+    /* Explicitly declared.  */\n+    return false;\n+  if (DECL_ABSTRACT_ORIGIN (fn))\n+    /* Derived from a constructor.  */\n+    return false;\n+  return true;\n+}\n+\n /* OLDDECL is a _DECL for a template parameter.  Return a similar parameter at\n    LEVEL:INDEX, using tsubst_args and complain for substitution into non-type\n    template parameter types.  Note that the handling of template template\n@@ -28293,22 +28323,43 @@ build_deduction_guide (tree type, tree ctor, tree outer_args, tsubst_flags_t com\n /* Add to LIST the member types for the reshaped initializer CTOR.  */\n \n static tree\n-collect_ctor_idx_types (tree ctor, tree list)\n+collect_ctor_idx_types (tree ctor, tree list, tree elt = NULL_TREE)\n {\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (ctor);\n   tree idx, val; unsigned i;\n   FOR_EACH_CONSTRUCTOR_ELT (v, i, idx, val)\n     {\n+      tree ftype = elt ? elt : finish_decltype_type (idx, true, tf_none);\n       if (BRACE_ENCLOSED_INITIALIZER_P (val)\n-\t  && CONSTRUCTOR_NELTS (val))\n-\tif (tree subidx = CONSTRUCTOR_ELT (val, 0)->index)\n-\t  if (TREE_CODE (subidx) == FIELD_DECL)\n-\t    {\n-\t      list = collect_ctor_idx_types (val, list);\n-\t      continue;\n-\t    }\n-      tree ftype = finish_decltype_type (idx, true, tf_none);\n-      list = tree_cons (NULL_TREE, ftype, list);\n+\t  && CONSTRUCTOR_NELTS (val)\n+\t  /* As in reshape_init_r, a non-aggregate or array-of-dependent-bound\n+\t     type gets a single initializer.  */\n+\t  && CP_AGGREGATE_TYPE_P (ftype)\n+\t  && !(TREE_CODE (ftype) == ARRAY_TYPE\n+\t       && uses_template_parms (TYPE_DOMAIN (ftype))))\n+\t{\n+\t  tree subelt = NULL_TREE;\n+\t  if (TREE_CODE (ftype) == ARRAY_TYPE)\n+\t    subelt = TREE_TYPE (ftype);\n+\t  list = collect_ctor_idx_types (val, list, subelt);\n+\t  continue;\n+\t}\n+      tree arg = NULL_TREE;\n+      if (i == v->length() - 1\n+\t  && PACK_EXPANSION_P (ftype))\n+\t/* Give the trailing pack expansion parameter a default argument to\n+\t   match aggregate initialization behavior, even if we deduce the\n+\t   length of the pack separately to more than we have initializers. */\n+\targ = build_constructor (init_list_type_node, NULL);\n+      /* if ei is of array type and xi is a braced-init-list or string literal,\n+\t Ti is an rvalue reference to the declared type of ei */\n+      STRIP_ANY_LOCATION_WRAPPER (val);\n+      if (TREE_CODE (ftype) == ARRAY_TYPE\n+\t  && (BRACE_ENCLOSED_INITIALIZER_P (val)\n+\t      || TREE_CODE (val) == STRING_CST))\n+\tftype = (cp_build_reference_type\n+\t\t (ftype, BRACE_ENCLOSED_INITIALIZER_P (val)));\n+      list = tree_cons (arg, ftype, list);\n     }\n \n   return list;"}, {"sha": "13d7ec9b57d433505f381701270c3d2b240451d2", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr3.C?ref=6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "patch": "@@ -0,0 +1,24 @@\n+// Pack expansion testcases from P2082R1\n+// { dg-do compile { target c++20 } }\n+\n+template<typename U, typename... T>\n+struct C2 : T... {\n+  U a;\n+  static constexpr int len = sizeof...(T);\n+};\n+C2 c2 = {\n+\t []{ return 1; },\n+};\n+static_assert (c2.len == 0);\n+\n+template <typename... T>\n+struct Types {};\n+template <typename... T>\n+struct F : Types<T...>, T... {};\n+struct X {};\n+struct Y {};\n+struct Z {};\n+struct W { operator Y(); };\n+F f1 = {Types<X, Y, Z>{}, {}, {}}; // OK, F<X, Y, Z> deduced\n+F f2 = {Types<X, Y, Z>{}, X{}, Y{}}; // OK, F<X, Y, Z> deduced\n+F f3 = {Types<X, Y, Z>{}, X{}, W{}}; // { dg-error \"\" } conflicting types deduced; operator Y not considered"}, {"sha": "0debbb2443f85185313c9eb0821df9528b13f0ec", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr4.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b161257f9f8c7a26b7d119ebc32cbbc54d2e508/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr4.C?ref=6b161257f9f8c7a26b7d119ebc32cbbc54d2e508", "patch": "@@ -0,0 +1,29 @@\n+// Other testcases from P2082R1\n+// { dg-do compile { target c++20 } }\n+\n+template <typename T>\n+struct X {};\n+int main() {\n+  X<int> x1;\n+  X x2 {x1};\n+}\n+\n+template <typename T, int N>\n+struct A {\n+  T array[N];\n+};\n+A a1 = {{1, 2, 3}}; // should deduce A<int, 3>\n+A a2 = {\"meow\"}; // should deduce A<const char, 5>\n+\n+template <typename T>\n+struct B {\n+  T array[2];\n+};\n+B b = {0, 1};\n+\n+template<typename... T>\n+struct C : T... {};\n+C c = {\n+       []{ return 1; },\n+       []{ return 2; }\n+};"}]}