{"sha": "81f7282f978588f883d8363e8cd5e69d090bc331", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFmNzI4MmY5Nzg1ODhmODgzZDgzNjNlOGNkNWU2OWQwOTBiYzMzMQ==", "commit": {"author": {"name": "Scott Gilbertson", "email": "scottg@mantatest.com", "date": "2003-08-25T19:02:29Z"}, "committer": {"name": "Scott Gilbertson", "email": "sgilbertson@gcc.gnu.org", "date": "2003-08-25T19:02:29Z"}, "message": "Makefile.am: added gnu/awt/xlib/XOffScreenImage.java.\n\n\t* Makefile.am: added gnu/awt/xlib/XOffScreenImage.java.\n\t* Makefile.in: re-generated.\n\t* gnu/awt/j2d/IntegerGraphicsState.java\n\t(ScreenCoupledImage): new interface.\n\t(drawImage): detect ScreenCoupledImage instances.\n\t* gnu/awt/xlib/XCanvasPeer.java (createImage) implemented.\n\t* gnu/awt/xlib/XEventLoop.java\n\t(createEvent): re-formatted, and rearranged to avoid null pointer.\n\t* gnu/awt/xlib/XGraphics.java\n\t(drawImage): added XOffScreenImage handling.\n\t* gnu/awt/xlib/XOffScreenImage.java: new file.\n\t* gnu/gcj/xlib/Drawable.java (getDepth): new native method.\n\t* gnu/gcj/xlib/GC.java (copyArea): new native method.\n\t* gnu/gcj/xlib/XAnyEvent.java\n\t(TYPE_KEY_PRESS): new constant.\n\t(TYPE_KEY_RELEASE): new constant.\n\t(TYPE_MOTION_NOTIFY): new constant.\n\t(TYPE_ENTER_NOTIFY): new constant.\n\t(TYPE_LEAVE_NOTIFY): new constant.\n\t(TYPE_FOCUS_IN): new constant.\n\t(TYPE_FOCUS_OUT): new constant.\n\t(TYPE_KEYMAP_NOTIFY): new constant.\n\t(TYPE_GRAPHICS_EXPOSE): new constant.\n\t(TYPE_NO_EXPOSE): new constant.\n\t(TYPE_VISIBILITY_NOTIFY): new constant.\n\t(TYPE_CREATE_NOTIFY): new constant.\n\t(TYPE_DESTROY_NOTIFY): new constant.\n\t(TYPE_MAP_REQUEST): new constant.\n\t(TYPE_CONFIGURE_REQUEST): new constant.\n\t(TYPE_GRAVITY_NOTIFY): new constant.\n\t(TYPE_RESIZE_REQUEST): new constant.\n\t(TYPE_CIRCULATE_NOTIFY): new constant.\n\t(TYPE_CIRCULATE_REQUEST): new constant.\n\t(TYPE_PROPERTY_NOTIFY): new constant.\n\t(TYPE_SELECTION_CLEAR): new constant.\n\t(TYPE_SELECTION_REQUEST): new constant.\n\t(TYPE_SELECTION_NOTIFY): new constant.\n\t(TYPE_COLORMAP_NOTIFY): new constant.\n\t(TYPE_MAPPING_NOTIFY): new constant.\n\t* gnu/gcj/xlib/natDrawable.cc (getDepth): new method.\n\t* gnu/gcj/xlib/natGC.cc (copyArea): new method\n\t* java/awt/Component.java (createImage): changed to use peer method.\n\nFrom-SVN: r70776", "tree": {"sha": "cf8eb4ec21e611ee7dbea198fd5f8dce39ee903d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf8eb4ec21e611ee7dbea198fd5f8dce39ee903d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81f7282f978588f883d8363e8cd5e69d090bc331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f7282f978588f883d8363e8cd5e69d090bc331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81f7282f978588f883d8363e8cd5e69d090bc331", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f7282f978588f883d8363e8cd5e69d090bc331/comments", "author": null, "committer": null, "parents": [{"sha": "1281fe11033eebaaa8a4fbc70770eca204c9c504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1281fe11033eebaaa8a4fbc70770eca204c9c504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1281fe11033eebaaa8a4fbc70770eca204c9c504"}], "stats": {"total": 550, "additions": 442, "deletions": 108}, "files": [{"sha": "17b2fe548454dac530c067b850314ae39fb74be0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -1,3 +1,47 @@\n+2003-08-25  Scott Gilbertson  <scottg@mantatest.com>\n+\t* Makefile.am: added gnu/awt/xlib/XOffScreenImage.java.\n+\t* Makefile.in: re-generated.\n+\t* gnu/awt/j2d/IntegerGraphicsState.java\n+\t(ScreenCoupledImage): new interface.\n+\t(drawImage): detect ScreenCoupledImage instances.\n+\t* gnu/awt/xlib/XCanvasPeer.java (createImage) implemented.\n+\t* gnu/awt/xlib/XEventLoop.java\n+\t(createEvent): re-formatted, and rearranged to avoid null pointer.\n+\t* gnu/awt/xlib/XGraphics.java\n+\t(drawImage): added XOffScreenImage handling.\n+\t* gnu/awt/xlib/XOffScreenImage.java: new file.\n+\t* gnu/gcj/xlib/Drawable.java (getDepth): new native method.\n+\t* gnu/gcj/xlib/GC.java (copyArea): new native method.\n+\t* gnu/gcj/xlib/XAnyEvent.java\n+\t(TYPE_KEY_PRESS): new constant.\n+\t(TYPE_KEY_RELEASE): new constant.\n+\t(TYPE_MOTION_NOTIFY): new constant.\n+\t(TYPE_ENTER_NOTIFY): new constant.\n+\t(TYPE_LEAVE_NOTIFY): new constant.\n+\t(TYPE_FOCUS_IN): new constant.\n+\t(TYPE_FOCUS_OUT): new constant.\n+\t(TYPE_KEYMAP_NOTIFY): new constant.\n+\t(TYPE_GRAPHICS_EXPOSE): new constant.\n+\t(TYPE_NO_EXPOSE): new constant.\n+\t(TYPE_VISIBILITY_NOTIFY): new constant.\n+\t(TYPE_CREATE_NOTIFY): new constant.\n+\t(TYPE_DESTROY_NOTIFY): new constant.\n+\t(TYPE_MAP_REQUEST): new constant.\n+\t(TYPE_CONFIGURE_REQUEST): new constant.\n+\t(TYPE_GRAVITY_NOTIFY): new constant.\n+\t(TYPE_RESIZE_REQUEST): new constant.\n+\t(TYPE_CIRCULATE_NOTIFY): new constant.\n+\t(TYPE_CIRCULATE_REQUEST): new constant.\n+\t(TYPE_PROPERTY_NOTIFY): new constant.\n+\t(TYPE_SELECTION_CLEAR): new constant.\n+\t(TYPE_SELECTION_REQUEST): new constant.\n+\t(TYPE_SELECTION_NOTIFY): new constant.\n+\t(TYPE_COLORMAP_NOTIFY): new constant.\n+\t(TYPE_MAPPING_NOTIFY): new constant.\n+\t* gnu/gcj/xlib/natDrawable.cc (getDepth): new method.\n+\t* gnu/gcj/xlib/natGC.cc (copyArea): new method\n+\t* java/awt/Component.java (createImage): changed to use peer method.\n+\n 2003-08-22  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* gnu/java/awt/peer/gtk/GdkGraphics.java (drawString): Pass font"}, {"sha": "8dfc5ab33a03d0d3bff4c6fae69673558678c25f", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -2651,6 +2651,7 @@ gnu/awt/xlib/XFontMetrics.java \\\n gnu/awt/xlib/XFramePeer.java \\\n gnu/awt/xlib/XGraphics.java \\\n gnu/awt/xlib/XGraphicsConfiguration.java \\\n+gnu/awt/xlib/XOffScreenImage.java \\\n gnu/awt/xlib/XPanelPeer.java \\\n gnu/awt/xlib/XToolkit.java\n "}, {"sha": "344bd757c381da9baa2b39e8625ee73947ea0c1f", "filename": "libjava/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -2416,6 +2416,7 @@ gnu/awt/xlib/XFontMetrics.java \\\n gnu/awt/xlib/XFramePeer.java \\\n gnu/awt/xlib/XGraphics.java \\\n gnu/awt/xlib/XGraphicsConfiguration.java \\\n+gnu/awt/xlib/XOffScreenImage.java \\\n gnu/awt/xlib/XPanelPeer.java \\\n gnu/awt/xlib/XToolkit.java\n \n@@ -2710,10 +2711,11 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/awt/xlib/XFontMetrics.P .deps/gnu/awt/xlib/XFramePeer.P \\\n .deps/gnu/awt/xlib/XGraphics.P \\\n .deps/gnu/awt/xlib/XGraphicsConfiguration.P \\\n-.deps/gnu/awt/xlib/XPanelPeer.P .deps/gnu/awt/xlib/XToolkit.P \\\n-.deps/gnu/classpath/Configuration.P .deps/gnu/gcj/Core.P \\\n-.deps/gnu/gcj/RawData.P .deps/gnu/gcj/convert/BytesToUnicode.P \\\n-.deps/gnu/gcj/convert/Convert.P .deps/gnu/gcj/convert/IOConverter.P \\\n+.deps/gnu/awt/xlib/XOffScreenImage.P .deps/gnu/awt/xlib/XPanelPeer.P \\\n+.deps/gnu/awt/xlib/XToolkit.P .deps/gnu/classpath/Configuration.P \\\n+.deps/gnu/gcj/Core.P .deps/gnu/gcj/RawData.P \\\n+.deps/gnu/gcj/convert/BytesToUnicode.P .deps/gnu/gcj/convert/Convert.P \\\n+.deps/gnu/gcj/convert/IOConverter.P \\\n .deps/gnu/gcj/convert/Input_8859_1.P \\\n .deps/gnu/gcj/convert/Input_ASCII.P \\\n .deps/gnu/gcj/convert/Input_EUCJIS.P \\"}, {"sha": "4eb4c6182b12c94b6a38471c6181636b5d5e30e3", "filename": "libjava/gnu/awt/j2d/IntegerGraphicsState.java", "status": "modified", "additions": 76, "deletions": 57, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fj2d%2FIntegerGraphicsState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fj2d%2FIntegerGraphicsState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fj2d%2FIntegerGraphicsState.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -44,6 +44,19 @@ public class IntegerGraphicsState extends AbstractGraphicsState\n   DirectRasterGraphics directGfx;\n   Shape clip;\n   \n+  /** Interface for images which are coupled to a GraphicsConfiguration,\n+   * as is typically the case for an off-screen buffer used in\n+   * double-buffering.  Any image which implements this interface is\n+   * rendered directly by DirectRasterGraphics (i.e. by directGfx.drawImage)\n+   */\n+  public interface ScreenCoupledImage\n+  {\n+    /** Get the GraphicsConfiguration to which this image is coupled\n+     * @return the GraphicsConfiguration\n+     */\n+    GraphicsConfiguration getGraphicsConfiguration ();\n+  }\n+  \n   public IntegerGraphicsState(DirectRasterGraphics directGfx)\n   {\n     this.directGfx = directGfx;\n@@ -245,66 +258,72 @@ public boolean drawImage(Image image, int x, int y,\n     x += tx;\n     y += ty;\n     \n+    if (image instanceof ScreenCoupledImage)\n+    {\n+      GraphicsConfiguration config\n+        = ((ScreenCoupledImage)image).getGraphicsConfiguration ();\n+      if (config == frontend.config)\n+        return directGfx.drawImage (image, x, y, observer);\n+    }\n     if (image instanceof BufferedImage)\n+    {\n+      BufferedImage bImage = (BufferedImage) image;\n+      // FIXME: eliminate? ScreenCoupledImage is probably more efficient\n+      Object config = bImage.getProperty (\"java.awt.GraphicsConfiguration\");\n+      if (config == frontend.config)\n+        return directGfx.drawImage (image, x, y, observer);\n+      \n+      int width = image.getWidth (null);\n+      int height = image.getHeight (null);\n+      \n+      Rectangle bounds = new Rectangle (x, y, width, height);\n+      \n+      MappedRaster mr = directGfx.mapRaster (bounds);\n+      \n+      // manipulate raster here...\n+      ColorModel colorModel = mr.getColorModel ();\n+      WritableRaster raster = mr.getRaster ();\n+      \n+      int xEnd = x + width;\n+      int yEnd = y + height;\n+      \n+      // FIXME: Use the following code only as a fallback. It's SLOW!\n+      \n+      Object rgbElem = null;\n+      for (int yy=0; yy<height; yy++)\n       {\n-\tBufferedImage bImage = (BufferedImage) image;\n-\tObject config =\n-\t  bImage.getProperty(\"java.awt.GraphicsConfiguration\");\n-\t\n-\tif (config == frontend.config)\n-\t  return directGfx.drawImage(image, x, y, observer);\n-\t\n-\tint width = image.getWidth(null);\n-\tint height = image.getHeight(null);\t\n-\t\n-\tRectangle bounds = new Rectangle(x, y, width, height);\n-\t\n-\tMappedRaster mr = directGfx.mapRaster(bounds);\n-\t\n-\t// manipulate raster here...\n-\tColorModel colorModel = mr.getColorModel();\n-\tWritableRaster raster = mr.getRaster();\n-\t\n-\tint xEnd = x + width;\n-\tint yEnd = y + height;\n-\t\n-\t// FIXME: Use the following code only as a fallback. It's SLOW!\n-\n-\tObject rgbElem = null;\n-\tfor (int yy=0; yy<height; yy++)\n-\t  {\n-\t    for (int xx=0; xx<width; xx++)\n-\t      {\n-\t\tint srgb = bImage.getRGB(xx, yy);\n-\t\tint sa = ((srgb >>> 24) & 0xff) + 1;\n-\t\tint sr = ((srgb >>> 16) & 0xff) + 1;\n-\t\tint sg = ((srgb >>> 8) & 0xff) + 1;\n-\t\tint sb = (srgb & 0xff) + 1;\n-\t\t\n-\t\trgbElem = raster.getDataElements(xx+x, yy+y, rgbElem);\n-\t\tint drgb = colorModel.getRGB(rgbElem);\n-\t\tint dr = ((drgb >>> 16) & 0xff) + 1;\n-\t\tint dg = ((drgb >>> 8) & 0xff) + 1;\n-\t\tint db = (drgb & 0xff) + 1;\t\t    \n-\t\tint da = 256 - sa;\n-\t\t\n-\t\tdr = ((sr*sa + dr*da) >>> 8) - 1;\n-\t\tdg = ((sg*sa + dg*da) >>> 8) - 1;\n-\t\tdb = ((sb*sa + db*da) >>> 8) - 1;\n-\t\t\n-\t\tdrgb = (dr<<16) | (dg<<8) | db;\n-\t\t\n-\t\trgbElem = colorModel.getDataElements(drgb, rgbElem);\n-\t\t\n-\t\traster.setDataElements(xx+x, yy+y, rgbElem);\n-\t      }\n-\t  }\n-\tdirectGfx.unmapRaster(mr);\n-\treturn true;\n-\t\n+        for (int xx=0; xx<width; xx++)\n+        {\n+          int srgb = bImage.getRGB (xx, yy);\n+          int sa = ((srgb >>> 24) & 0xff) + 1;\n+          int sr = ((srgb >>> 16) & 0xff) + 1;\n+          int sg = ((srgb >>> 8) & 0xff) + 1;\n+          int sb = (srgb & 0xff) + 1;\n+          \n+          rgbElem = raster.getDataElements (xx+x, yy+y, rgbElem);\n+          int drgb = colorModel.getRGB (rgbElem);\n+          int dr = ((drgb >>> 16) & 0xff) + 1;\n+          int dg = ((drgb >>> 8) & 0xff) + 1;\n+          int db = (drgb & 0xff) + 1;\n+          int da = 256 - sa;\n+          \n+          dr = ((sr*sa + dr*da) >>> 8) - 1;\n+          dg = ((sg*sa + dg*da) >>> 8) - 1;\n+          db = ((sb*sa + db*da) >>> 8) - 1;\n+          \n+          drgb = (dr<<16) | (dg<<8) | db;\n+          \n+          rgbElem = colorModel.getDataElements (drgb, rgbElem);\n+          \n+          raster.setDataElements (xx+x, yy+y, rgbElem);\n+        }\n       }\n-    throw new UnsupportedOperationException(\"drawing image \" + image +\n-\t\t\t\t\t    \"not implemented\");\n+      directGfx.unmapRaster (mr);\n+      return true;\n+      \n+    }\n+    throw new UnsupportedOperationException (\"drawing image \" + image +\n+    \"not implemented\");\n   }\n   \n "}, {"sha": "6ecf7bf3296e03d77a727dd9c671041cea020e02", "filename": "libjava/gnu/awt/xlib/XCanvasPeer.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -214,7 +214,7 @@ public Image createImage(ImageProducer prod)\n   }\n   public Image createImage(int width, int height)\n   {\n-    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+    return new XOffScreenImage (config, window, width, height);\n   }\n   public void dispose()\n   {"}, {"sha": "5f5026b0cdb79c5821923a29f007966254c5595c", "filename": "libjava/gnu/awt/xlib/XEventLoop.java", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -118,57 +118,66 @@ since XFlush() will not be called before after the\n    * AWT event.\n    */\n     \n-  AWTEvent createEvent()\n+  AWTEvent createEvent ()\n   {\n+    int type = anyEvent.getType ();\n+    // Ignore some events without further processing\n+    switch (type)\n+    {\n+      // ignore \"no expose\" events, which are generated whenever a  pixmap\n+      // is copied to copied to a window which is entirely unobscured\n+      case XAnyEvent.TYPE_NO_EXPOSE:\n+      case XAnyEvent.TYPE_UNMAP_NOTIFY:     // ignore for now\n+      case XAnyEvent.TYPE_MAP_NOTIFY:       // ignore for now\n+      case XAnyEvent.TYPE_REPARENT_NOTIFY:  // ignore for now\n+        return null;\n+      default:\n+        break;  // continue processing events not in ignore list\n+    }\n     /* avoid attempting to get client data before client data has\n        been set. */\n     Object peer;\n     synchronized (this)\n-      {\n-\tpeer = anyEvent.getWindow().getClientData();\n-      }\n-\t    \n+    {\n+      peer = anyEvent.getWindow ().getClientData ();\n+    }\n+    \n     Component source = null;\n-\n+    \n     // Try to identify source component\n-\t\n+    \n     if (peer instanceof XCanvasPeer)\n-      {\n-\tsource = ((XCanvasPeer) peer).getComponent();\n-      }\n-\t\n+    {\n+      source = ((XCanvasPeer) peer).getComponent ();\n+    }\n+    \n     if (source == null)\n-      {\n-\tString msg = \"unable to locate source for event (\" +\n-\t  anyEvent + \")\";\n-\tthrow new RuntimeException(msg);\n-      }\n-\n+    {\n+      String msg = \"unable to locate source for event (\" +\n+      anyEvent + \"): peer=\" + peer;\n+      throw new RuntimeException (msg);\n+    }\n+    \n     /* if a mapping from anyEvent to AWTEvent is possible, construct a\n        new AWTEvent and return it. */\n-\t\n-    int type = anyEvent.getType();\n+    \n     switch (type)\n-      {\n+    {\n       case XAnyEvent.TYPE_EXPOSE:\n-\treturn createPaintEvent(source);\n+        return createPaintEvent (source);\n       case XAnyEvent.TYPE_BUTTON_PRESS:\n       case XAnyEvent.TYPE_BUTTON_RELEASE:\n-\treturn createMouseEvent(type, source);\n-      case XAnyEvent.TYPE_UNMAP_NOTIFY:\n-      case XAnyEvent.TYPE_MAP_NOTIFY:\n-      case XAnyEvent.TYPE_REPARENT_NOTIFY:\n-\treturn null; // ignore for now\n+        return createMouseEvent (type, source);\n       case XAnyEvent.TYPE_CONFIGURE_NOTIFY:\n-\tconfigureNotify(peer);\n-\treturn null;\n-\n+        configureNotify (peer);\n+        return null;\n+        \n       default:\n-\tString msg = \"Do no know how to handle event (\" + anyEvent + \")\";\n-\tthrow new RuntimeException(msg);\n-      }\n+        String msg = \"Do no know how to handle event (\" + anyEvent + \")\";\n+        throw new RuntimeException (msg);\n+    }\n   }\n-    \n+  \n   AWTEvent createPaintEvent(Component src)\n   {\n     XExposeEvent expose = new XExposeEvent(anyEvent);"}, {"sha": "e27b0a18e8b0523edf4999681c10a5de1ea29ff0", "filename": "libjava/gnu/awt/xlib/XGraphics.java", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -20,6 +20,7 @@\n import gnu.gcj.xlib.Drawable;\n import gnu.gcj.xlib.Window;\n import gnu.gcj.xlib.Drawable;\n+import gnu.gcj.xlib.Pixmap;\n import gnu.gcj.xlib.Visual;\n import gnu.awt.j2d.DirectRasterGraphics;\n import gnu.awt.j2d.MappedRaster;\n@@ -199,6 +200,16 @@ public void drawString(String str, int x, int y)\n   public boolean drawImage(Image img, int x, int y,\n \t\t\t   ImageObserver observer)\n   {\n+    if (img instanceof XOffScreenImage)\n+    {\n+      // FIXME: have to enforce clip, or is it OK as-is?\n+      XGraphicsConfiguration.XOffScreenImage offScreenImage\n+        = ((XGraphicsConfiguration.XOffScreenImage)img);\n+      Pixmap pixmap = offScreenImage.getPixmap ();\n+      context.copyArea (pixmap, 0, 0, x, y,\n+        offScreenImage.getWidth (), offScreenImage.getHeight ());\n+      return true;\n+    }\n     if (clipBounds == null)\n       return false; // ***FIXME***\n "}, {"sha": "71791c1be5f4fddc5dbb922d1812c7755e51ab52", "filename": "libjava/gnu/awt/xlib/XOffScreenImage.java", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXOffScreenImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fawt%2Fxlib%2FXOffScreenImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXOffScreenImage.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -0,0 +1,175 @@\n+/* Copyright (C) 2000, 2003  Free Software Foundation\n+ \n+   This file is part of libgcj.\n+ \n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.Image;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.ImageProducer;\n+import java.util.Hashtable;\n+import gnu.awt.j2d.DirectRasterGraphics;\n+import gnu.awt.j2d.Graphics2DImpl;\n+import gnu.awt.j2d.IntegerGraphicsState;\n+import gnu.gcj.xlib.Drawable;\n+import gnu.gcj.xlib.Pixmap;\n+import gnu.gcj.xlib.Screen;\n+import gnu.gcj.xlib.Visual;\n+\n+/** Image class for xlib off-screen buffers.\n+ * The image is stored in a server-side pixmap for best performance.\n+ * This class supports getGraphics, so you can draw on the pixmap, and is\n+ * specially handled when doing drawImage, so that the image copy is done\n+ * entirely in the X server.\n+ * This class does not support rasterization, for which you'd need an XImage.\n+ *\n+ * @author  scott gilbertson <scottg@mantatest.com> <sgilbertson@cogeco.ca>\n+ */\n+public class XOffScreenImage extends Image \n+                             implements IntegerGraphicsState.ScreenCoupledImage\n+{\n+  private Pixmap pixmap;\n+  private XGraphicsConfiguration config;\n+  private int width;\n+  private int height;\n+  \n+  /** Create a new XOffScreenImage\n+   * @param config Graphics configuration, to compare against on-screen \n+   *               components and to create the appropriate Graphics\n+   * @param drawable The drawable with which the image is compatible\n+   * @param width The width of the image\n+   * @param height The height of the image\n+   */\n+  XOffScreenImage (XGraphicsConfiguration config, Drawable drawable, int width, int height)\n+  {\n+    this.config = config;\n+    this.width = width;\n+    this.height = height;\n+    pixmap = new Pixmap (drawable, width, height, drawable.getDepth ());\n+  }\n+  \n+  /** Get the pixmap which contains this image\n+   * @return The pixmap\n+   */\n+  public Pixmap getPixmap ()\n+  {\n+    return pixmap;\n+  }\n+  \n+  /** Flushes (that is, destroys) any resources used for this image.  This\n+   * includes the actual image data.\n+   */\n+  public void flush ()\n+  {\n+    // FIXME: should dispose pixmap\n+    pixmap = null;\n+  }\n+  \n+  /** Returns a graphics context object for drawing an off-screen object.\n+   * This method is only valid for off-screen objects.\n+   *\n+   * @return a graphics context object for an off-screen object\n+   * @see Graphics#createImage(int, int)\n+   */\n+  public Graphics getGraphics ()\n+  {\n+    DirectRasterGraphics gfxDevice = new XGraphics (pixmap, config);\n+    IntegerGraphicsState igState = new IntegerGraphicsState (gfxDevice);\n+    Graphics2DImpl gfx2d = new Graphics2DImpl (config);\n+    gfx2d.setState (igState);\n+    return gfx2d;\n+  }\n+  \n+  /** Returns the height of the image, or -1 if it is unknown.  If the\n+   * image height is unknown, the observer object will be notified when\n+   * the value is known.\n+   *\n+   * @param observer the image observer for this object\n+   * @return the height in pixels\n+   * @see #getWidth(ImageObserver)\n+   */\n+  public int getHeight (ImageObserver observer)\n+  {\n+    return height;\n+  }\n+  \n+  /** Returns the height of the image, or -1 if it is unknown.  If the\n+   * image height is unknown, the observer object will be notified when\n+   * the value is known.\n+   *\n+   * @return the height in pixels\n+   * @see #getWidth()\n+   */\n+  public int getHeight ()\n+  {\n+    return height;\n+  }\n+  \n+  /** Returns the image producer object for this object. The producer is the\n+   * object which generates pixels for this image.\n+   *\n+   * @return the image producer for this object\n+   */\n+  public ImageProducer getSource ()\n+  {\n+    throw new UnsupportedOperationException (\"getSource not supported\");\n+  }\n+  \n+  /** Returns the width of the image, or -1 if it is unknown.  If the\n+   * image width is unknown, the observer object will be notified when\n+   * the value is known.\n+   *\n+   * @param observer the image observer for this object\n+   * @return the width in pixels\n+   * @see #getHeight(ImageObserver)\n+   */\n+  public int getWidth (ImageObserver observer)\n+  {\n+    return width;\n+  }\n+  \n+  /** Returns the width of the image, or -1 if it is unknown.  If the\n+   * image width is unknown, the observer object will be notified when\n+   * the value is known.\n+   *\n+   * @return the width in pixels\n+   * @see #getHeight()\n+   */\n+  public int getWidth ()\n+  {\n+    return width;\n+  }\n+\n+  /** This method requests a named property for an object.  The value of the\n+   * property is returned. The value <code>UndefinedProperty</code> is\n+   * returned if there is no property with the specified name.  The value\n+   * <code>null</code> is returned if the properties for the object are\n+   * not yet known.  In this case, the specified image observer is notified\n+   * when the properties are known.\n+   *\n+   * @param name the requested property name\n+   * @param observer the image observer for this object\n+   * @return the named property, if available\n+   * @see #UndefinedProperty\n+   */\n+  public Object getProperty (String name, ImageObserver observer)\n+  {\n+    return null;\n+  }\n+  \n+  /** Get the GraphicsConfiguration to which this image is coupled\n+   * @return the GraphicsConfiguration\n+   */\n+  public GraphicsConfiguration getGraphicsConfiguration ()\n+  {\n+    return config;\n+  }\n+}"}, {"sha": "fa12ba2b3feffb9e347044144f02a56b62c2dc7d", "filename": "libjava/gnu/gcj/xlib/Drawable.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FDrawable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FDrawable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FDrawable.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -79,6 +79,8 @@ private native boolean copyIntoXImageImpl(XImage destinationImage,\n \n   public native Rectangle getBounds(Rectangle rv);\n   \n+  public native int getDepth ();\n+  \n   private static final String MSG_XGETSUBIMAGE_FAILED =\n     \"XGetSubImage() failed.\";\n "}, {"sha": "24cd3bd1f53f997c57186cb353ab060cd54337cf", "filename": "libjava/gnu/gcj/xlib/GC.java", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FGC.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FGC.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FGC.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -138,6 +138,11 @@ public native void putImage(XImage image,\n \t\t\t      int destX, int destY,\n \t\t\t      int width, int height);\n \n+  public native void copyArea (Drawable source,\n+                               int srcX, int srcY,\n+                               int destX, int destY,\n+                               int width, int height);\n+  \n   public Drawable getDrawable()\n   {\n     return target;"}, {"sha": "df1ad782d794a64e3b57e82ac1a24024e10edb01", "filename": "libjava/gnu/gcj/xlib/XAnyEvent.java", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FXAnyEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FXAnyEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXAnyEvent.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -19,14 +19,40 @@\n public final class XAnyEvent\n {\n   // Must match the definitions in X.h:\n-  public static final int TYPE_BUTTON_PRESS     =  4,\n-                          TYPE_BUTTON_RELEASE   =  5,\n-\t                  TYPE_EXPOSE           = 12,\n-\t                  TYPE_UNMAP_NOTIFY     = 18,\n-\t                  TYPE_MAP_NOTIFY       = 19,\n-\t                  TYPE_REPARENT_NOTIFY  = 21,\n-\t                  TYPE_CONFIGURE_NOTIFY = 22,\n-\t                  TYPE_CLIENT_MESSAGE   = 33;\n+  public static final int \n+                      TYPE_KEY_PRESS          =  2,\n+                      TYPE_KEY_RELEASE        =  3,\n+                      TYPE_BUTTON_PRESS       =  4,\n+                      TYPE_BUTTON_RELEASE     =  5,\n+                      TYPE_MOTION_NOTIFY      =  6,\n+                      TYPE_ENTER_NOTIFY       =  7,\n+                      TYPE_LEAVE_NOTIFY       =  8,\n+                      TYPE_FOCUS_IN           =  9,\n+                      TYPE_FOCUS_OUT          = 10,\n+                      TYPE_KEYMAP_NOTIFY      = 11,\n+                      TYPE_EXPOSE             = 12,\n+                      TYPE_GRAPHICS_EXPOSE    = 13,\n+                      TYPE_NO_EXPOSE          = 14,\n+                      TYPE_VISIBILITY_NOTIFY  = 15,\n+                      TYPE_CREATE_NOTIFY      = 16,\n+                      TYPE_DESTROY_NOTIFY     = 17,\n+                      TYPE_UNMAP_NOTIFY       = 18,\n+                      TYPE_MAP_NOTIFY         = 19,\n+                      TYPE_MAP_REQUEST        = 20,\n+                      TYPE_REPARENT_NOTIFY    = 21,\n+                      TYPE_CONFIGURE_NOTIFY   = 22,\n+                      TYPE_CONFIGURE_REQUEST  = 23,\n+                      TYPE_GRAVITY_NOTIFY     = 24,\n+                      TYPE_RESIZE_REQUEST     = 25,\n+                      TYPE_CIRCULATE_NOTIFY   = 26,\n+                      TYPE_CIRCULATE_REQUEST  = 27,\n+                      TYPE_PROPERTY_NOTIFY    = 28,\n+                      TYPE_SELECTION_CLEAR    = 29,\n+                      TYPE_SELECTION_REQUEST  = 30,\n+                      TYPE_SELECTION_NOTIFY   = 31,\n+                      TYPE_COLORMAP_NOTIFY    = 32,\n+                      TYPE_CLIENT_MESSAGE     = 33,\n+                      TYPE_MAPPING_NOTIFY     = 34;\n     \n   // Must match the definitions in X.h:\n   public final static long MASK_SUBSTRUCTURE_NOTIFY   = 1L<<19,"}, {"sha": "87c9d3572b28ec33adb172525e320d0d68ba2e5b", "filename": "libjava/gnu/gcj/xlib/natDrawable.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDrawable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDrawable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDrawable.cc?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -43,6 +43,26 @@ jboolean gnu::gcj::xlib::Drawable::copyIntoXImageImpl(XImage* image,\n   return true;\n }\n \n+jint gnu::gcj::xlib::Drawable::getDepth ()\n+{\n+  ::Display* dpy = (::Display*) (getDisplay ()->display);\n+  ::Window root;\n+  int x, y;\n+  unsigned int w, h, bw, depth;\n+\n+  Status status = XGetGeometry (dpy, getXID(), &root,\n+\t\t\t        &x, &y, &w, &h,\n+\t\t\t        &bw, &depth);\n+  switch (status)\n+  {\n+    case BadDrawable:\n+      throw new XException (display, status);\n+    default:\n+      ; // All OK, NOP.\n+  }\n+  return (jint)depth;\n+}\n+\n java::awt::Rectangle*\n gnu::gcj::xlib::Drawable::getBounds(java::awt::Rectangle* rv)\n {"}, {"sha": "17bcbe67b5aa602ea95e721047cd61c85a153df2", "filename": "libjava/gnu/gcj/xlib/natGC.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatGC.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatGC.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatGC.cc?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -237,3 +237,18 @@ void gnu::gcj::xlib::GC::updateClip()\n \t\t     ordering);\n   // no fast fail\n }\n+\n+void gnu::gcj::xlib::GC::copyArea (gnu::gcj::xlib::Drawable * source, \n+\t\t\t\t  jint srcX, jint srcY,\n+\t\t\t\t  jint destX, jint destY,\n+\t\t\t\t  jint width, jint height)\n+{\n+  Display* display = target->getDisplay ();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID ();\n+  ::GC gc = (::GC) structure;\n+  ::Drawable srcXID = source->getXID ();\n+\n+  XCopyArea (dpy, srcXID, drawableXID, gc, srcX, srcY, width, height,\n+    destX, destY);\n+}"}, {"sha": "11663a7d1227a3fc2c8a3e499488c2cb6f7dea92", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f7282f978588f883d8363e8cd5e69d090bc331/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=81f7282f978588f883d8363e8cd5e69d090bc331", "patch": "@@ -1866,12 +1866,17 @@ public Image createImage(ImageProducer producer)\n    * @param height the height of the image\n    * @return the requested image, or null if it is not supported\n    */\n-  public Image createImage(int width, int height)\n+  public Image createImage (int width, int height)\n   {\n-    if (GraphicsEnvironment.isHeadless())\n-      return null;\n-    GraphicsConfiguration config = getGraphicsConfiguration();\n-    return config == null ? null : config.createCompatibleImage(width, height);\n+    Image returnValue = null;\n+    if (!GraphicsEnvironment.isHeadless ())\n+    {\n+      if (isLightweight () && parent != null)\n+        returnValue = parent.createImage (width, height);\n+      else if (peer != null)\n+        returnValue = peer.createImage (width, height);\n+    }\n+    return returnValue;\n   }\n \n   /**"}]}