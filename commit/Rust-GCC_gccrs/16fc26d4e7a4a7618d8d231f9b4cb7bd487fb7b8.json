{"sha": "16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "node_id": "C_kwDOANBUbNoAKDE2ZmMyNmQ0ZTdhNGE3NjE4ZDhkMjMxZjliNGNiN2JkNDg3ZmI3Yjg", "commit": {"author": {"name": "Lulu Cheng", "email": "chenglulu@loongson.cn", "date": "2022-07-21T03:04:08Z"}, "committer": {"name": "Lulu Cheng", "email": "chenglulu@loongson.cn", "date": "2022-07-26T06:30:18Z"}, "message": "LoongArch: Support split symbol.\n\nAdd compilation option '-mexplicit-relocs', and if enable '-mexplicit-relocs'\nthe symbolic address load instruction 'la.*' will be split into two instructions.\nThis compilation option enabled by default.\n\ngcc/ChangeLog:\n\n\t* common/config/loongarch/loongarch-common.cc:\n\tEnable '-fsection-anchors' when O1 and more advanced optimization.\n\t* config/loongarch/genopts/loongarch.opt.in: Add new option\n\t'-mexplicit-relocs', and enable by default.\n\t* config/loongarch/loongarch-protos.h (loongarch_split_move_insn_p):\n\tDelete function declaration.\n\t(loongarch_split_move_insn): Delete function declaration.\n\t(loongarch_split_symbol_type): Add function declaration.\n\t* config/loongarch/loongarch.cc (enum loongarch_address_type):\n\tAdd new address type 'ADDRESS_LO_SUM'.\n\t(loongarch_classify_symbolic_expression): New function definitions.\n\tClassify the base of symbolic expression X, given that X appears in\n\tcontext CONTEXT.\n\t(loongarch_symbol_insns): Add a judgment condition TARGET_EXPLICIT_RELOCS.\n\t(loongarch_split_symbol_type): New function definitions.\n\tDetermines whether the symbol load should be split into two instructions.\n\t(loongarch_valid_lo_sum_p): New function definitions.\n\tReturn true if a LO_SUM can address a value of mode MODE when the LO_SUM\n\tsymbol has type SYMBOL_TYPE.\n\t(loongarch_classify_address): Add handling of 'LO_SUM'.\n\t(loongarch_address_insns): Add handling of 'ADDRESS_LO_SUM'.\n\t(loongarch_signed_immediate_p): Sort code.\n\t(loongarch_12bit_offset_address_p): Return true if address type is ADDRESS_LO_SUM.\n\t(loongarch_const_insns): Add handling of 'HIGH'.\n\t(loongarch_split_move_insn_p): Add the static attribute to the function.\n\t(loongarch_emit_set): New function definitions.\n\t(loongarch_call_tls_get_addr): Add symbol handling when defining TARGET_EXPLICIT_RELOCS.\n\t(loongarch_legitimize_tls_address): Add symbol handling when defining the\n\tTARGET_EXPLICIT_RELOCS macro.\n\t(loongarch_split_symbol): New function definitions. Split symbol.\n\t(loongarch_legitimize_address): Add codes see if the address can split into a high part\n\tand a LO_SUM.\n\t(loongarch_legitimize_const_move): Add codes split moves of symbolic constants into\n\thigh and low.\n\t(loongarch_split_move_insn): Delete function definitions.\n\t(loongarch_output_move): Add support for HIGH and LO_SUM.\n\t(loongarch_print_operand_reloc): New function definitions.\n\tPrint symbolic operand OP, which is part of a HIGH or LO_SUM in context CONTEXT.\n\t(loongarch_memmodel_needs_release_fence): Sort code.\n\t(loongarch_print_operand): Rearrange alphabetical order and add H and L to support HIGH\n\tand LOW output.\n\t(loongarch_print_operand_address): Add handling of 'ADDRESS_LO_SUM'.\n\t(TARGET_MIN_ANCHOR_OFFSET): Define macro to -IMM_REACH/2.\n\t(TARGET_MAX_ANCHOR_OFFSET): Define macro to IMM_REACH/2-1.\n\t* config/loongarch/loongarch.md (movti): Delete the template.\n\t(*movti): Delete the template.\n\t(movtf): Delete the template.\n\t(*movtf): Delete the template.\n\t(*low<mode>): New template of normal symbol low address.\n\t(@tls_low<mode>): New template of tls symbol low address.\n\t(@ld_from_got<mode>): New template load address from got table.\n\t(@ori_l_lo12<mode>): New template.\n\t* config/loongarch/loongarch.opt: Update from loongarch.opt.in.\n\t* config/loongarch/predicates.md: Add support for symbol_type HIGH.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/loongarch/func-call-1.c: Add build option '-mno-explicit-relocs'.\n\t* gcc.target/loongarch/func-call-2.c: Add build option '-mno-explicit-relocs'.\n\t* gcc.target/loongarch/func-call-3.c: Add build option '-mno-explicit-relocs'.\n\t* gcc.target/loongarch/func-call-4.c: Add build option '-mno-explicit-relocs'.\n\t* gcc.target/loongarch/func-call-5.c: New test.\n\t* gcc.target/loongarch/func-call-6.c: New test.\n\t* gcc.target/loongarch/func-call-7.c: New test.\n\t* gcc.target/loongarch/func-call-8.c: New test.\n\t* gcc.target/loongarch/relocs-symbol-noaddend.c: New test.", "tree": {"sha": "00114b0f1542c6b35b5bb66f316140e0734702ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00114b0f1542c6b35b5bb66f316140e0734702ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/comments", "author": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5e401fb1452d6a9504e23d76d072a89fd2ba379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e401fb1452d6a9504e23d76d072a89fd2ba379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e401fb1452d6a9504e23d76d072a89fd2ba379"}], "stats": {"total": 730, "additions": 614, "deletions": 116}, "files": [{"sha": "f8b4660fabf7213b1e9b1b6ebb5b204d1b9bac8a", "filename": "gcc/common/config/loongarch/loongarch-common.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fcommon%2Fconfig%2Floongarch%2Floongarch-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fcommon%2Fconfig%2Floongarch%2Floongarch-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Floongarch%2Floongarch-common.cc?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n static const struct default_options loongarch_option_optimization_table[] =\n {\n   { OPT_LEVELS_ALL, OPT_fasynchronous_unwind_tables, NULL, 1 },\n+  { OPT_LEVELS_1_PLUS, OPT_fsection_anchors, NULL, 1 },\n   { OPT_LEVELS_NONE, 0, NULL, 0 }\n };\n "}, {"sha": "6f39500935d5561ccd0e9436968d276fbd3ecabb", "filename": "gcc/config/loongarch/genopts/loongarch.opt.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Fgenopts%2Floongarch.opt.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Fgenopts%2Floongarch.opt.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fgenopts%2Floongarch.opt.in?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -154,6 +154,10 @@ mmax-inline-memcpy-size=\n Target Joined RejectNegative UInteger Var(loongarch_max_inline_memcpy_size) Init(1024)\n -mmax-inline-memcpy-size=SIZE\tSet the max size of memcpy to inline, default is 1024.\n \n+mexplicit-relocs\n+Target Var(TARGET_EXPLICIT_RELOCS) Init(1)\n+Use %reloc() assembly operators.\n+\n ; The code model option names for -mcmodel.\n Enum\n Name(cmodel) Type(int)"}, {"sha": "cadaad7519c6f8759a0e7254327089f63df155ba", "filename": "gcc/config/loongarch/loongarch-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -77,8 +77,6 @@ extern rtx loongarch_legitimize_call_address (rtx);\n extern rtx loongarch_subword (rtx, bool);\n extern bool loongarch_split_move_p (rtx, rtx);\n extern void loongarch_split_move (rtx, rtx, rtx);\n-extern bool loongarch_split_move_insn_p (rtx, rtx);\n-extern void loongarch_split_move_insn (rtx, rtx, rtx);\n extern const char *loongarch_output_move (rtx, rtx);\n extern bool loongarch_cfun_has_cprestore_slot_p (void);\n #ifdef RTX_CODE\n@@ -160,6 +158,7 @@ extern rtx loongarch_expand_thread_pointer (rtx);\n extern bool loongarch_eh_uses (unsigned int);\n extern bool loongarch_epilogue_uses (unsigned int);\n extern bool loongarch_load_store_bonding_p (rtx *, machine_mode, bool);\n+extern bool loongarch_split_symbol_type (enum loongarch_symbol_type);\n \n typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);\n "}, {"sha": "79687340dfdc6794d1829320c5082ebcdf63815b", "filename": "gcc/config/loongarch/loongarch.cc", "status": "modified", "additions": 371, "deletions": 41, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.cc?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -100,6 +100,10 @@ along with GCC; see the file COPYING3.  If not see\n    ADDRESS_REG_REG\n        A base register indexed by (optionally scaled) register.\n \n+   ADDRESS_LO_SUM\n+       A LO_SUM rtx.  The first operand is a valid base register and the second\n+       operand is a symbolic address.\n+\n    ADDRESS_CONST_INT\n        A signed 16-bit constant address.\n \n@@ -109,6 +113,7 @@ enum loongarch_address_type\n {\n   ADDRESS_REG,\n   ADDRESS_REG_REG,\n+  ADDRESS_LO_SUM,\n   ADDRESS_CONST_INT,\n   ADDRESS_SYMBOLIC\n };\n@@ -1641,6 +1646,21 @@ loongarch_classify_symbol (const_rtx x)\n   return SYMBOL_PCREL;\n }\n \n+/* Classify the base of symbolic expression X, given that X appears in\n+   context CONTEXT.  */\n+\n+static enum loongarch_symbol_type\n+loongarch_classify_symbolic_expression (rtx x)\n+{\n+  rtx offset;\n+\n+  split_const (x, &x, &offset);\n+  if (UNSPEC_ADDRESS_P (x))\n+    return UNSPEC_ADDRESS_TYPE (x);\n+\n+  return loongarch_classify_symbol (x);\n+}\n+\n /* Return true if X is a symbolic constant.  If it is,\n    store the type of the symbol in *SYMBOL_TYPE.  */\n \n@@ -1696,7 +1716,7 @@ loongarch_symbol_insns (enum loongarch_symbol_type type, machine_mode mode)\n     case SYMBOL_GOT_DISP:\n       /* The constant will have to be loaded from the GOT before it\n \t is used in an address.  */\n-      if (mode != MAX_MACHINE_MODE)\n+      if (!TARGET_EXPLICIT_RELOCS && mode != MAX_MACHINE_MODE)\n \treturn 0;\n \n       return 3;\n@@ -1814,6 +1834,84 @@ loongarch_valid_offset_p (rtx x, machine_mode mode)\n   return true;\n }\n \n+/* Should a symbol of type SYMBOL_TYPE should be split in two?  */\n+\n+bool\n+loongarch_split_symbol_type (enum loongarch_symbol_type symbol_type)\n+{\n+  switch (symbol_type)\n+    {\n+    case SYMBOL_PCREL:\n+    case SYMBOL_GOT_DISP:\n+    case SYMBOL_TLS_IE:\n+    case SYMBOL_TLS_LE:\n+    case SYMBOL_TLSGD:\n+    case SYMBOL_TLSLDM:\n+      return true;\n+\n+    case SYMBOL_TLS:\n+      return false;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return true if a LO_SUM can address a value of mode MODE when the\n+   LO_SUM symbol has type SYMBOL_TYPE.  */\n+\n+static bool\n+loongarch_valid_lo_sum_p (enum loongarch_symbol_type symbol_type,\n+\t\t\t  machine_mode mode, rtx x)\n+{\n+  int align, size;\n+\n+  /* Check that symbols of type SYMBOL_TYPE can be used to access values\n+     of mode MODE.  */\n+  if (loongarch_symbol_insns (symbol_type, mode) == 0)\n+    return false;\n+\n+  /* Check that there is a known low-part relocation.  */\n+  if (!loongarch_split_symbol_type (symbol_type))\n+    return false;\n+\n+  /* We can't tell size or alignment when we have BLKmode, so try extracing a\n+     decl from the symbol if possible.  */\n+  if (mode == BLKmode)\n+    {\n+      rtx offset;\n+\n+      /* Extract the symbol from the LO_SUM operand, if any.  */\n+      split_const (x, &x, &offset);\n+\n+      /* Might be a CODE_LABEL.  We can compute align but not size for that,\n+\t so don't bother trying to handle it.  */\n+      if (!SYMBOL_REF_P (x))\n+\treturn false;\n+\n+      /* Use worst case assumptions if we don't have a SYMBOL_REF_DECL.  */\n+      align = (SYMBOL_REF_DECL (x)\n+\t       ? DECL_ALIGN (SYMBOL_REF_DECL (x))\n+\t       : 1);\n+      size = (SYMBOL_REF_DECL (x) && DECL_SIZE (SYMBOL_REF_DECL (x))\n+\t      ? tree_to_uhwi (DECL_SIZE (SYMBOL_REF_DECL (x)))\n+\t      : 2*BITS_PER_WORD);\n+    }\n+  else\n+    {\n+      align = GET_MODE_ALIGNMENT (mode);\n+      size = GET_MODE_BITSIZE (mode);\n+    }\n+\n+  /* We may need to split multiword moves, so make sure that each word\n+     can be accessed without inducing a carry.  */\n+  if (size > BITS_PER_WORD\n+      && (!TARGET_STRICT_ALIGN || size > align))\n+    return false;\n+\n+  return true;\n+}\n+\n static bool\n loongarch_valid_index_p (struct loongarch_address_info *info, rtx x,\n \t\t\t  machine_mode mode, bool strict_p)\n@@ -1880,6 +1978,26 @@ loongarch_classify_address (struct loongarch_address_info *info, rtx x,\n       info->offset = XEXP (x, 1);\n       return (loongarch_valid_base_register_p (info->reg, mode, strict_p)\n \t      && loongarch_valid_offset_p (info->offset, mode));\n+\n+    case LO_SUM:\n+      info->type = ADDRESS_LO_SUM;\n+      info->reg = XEXP (x, 0);\n+      info->offset = XEXP (x, 1);\n+      /* We have to trust the creator of the LO_SUM to do something vaguely\n+\t sane.  Target-independent code that creates a LO_SUM should also\n+\t create and verify the matching HIGH.  Target-independent code that\n+\t adds an offset to a LO_SUM must prove that the offset will not\n+\t induce a carry.  Failure to do either of these things would be\n+\t a bug, and we are not required to check for it here.  The MIPS\n+\t backend itself should only create LO_SUMs for valid symbolic\n+\t constants, with the high part being either a HIGH or a copy\n+\t of _gp. */\n+      info->symbol_type\n+\t= loongarch_classify_symbolic_expression (info->offset);\n+      return (loongarch_valid_base_register_p (info->reg, mode, strict_p)\n+\t      && loongarch_valid_lo_sum_p (info->symbol_type, mode,\n+\t\t\t\t\t   info->offset));\n+\n     default:\n       return false;\n     }\n@@ -1940,6 +2058,9 @@ loongarch_address_insns (rtx x, machine_mode mode, bool might_split_p)\n       case ADDRESS_CONST_INT:\n \treturn factor;\n \n+      case ADDRESS_LO_SUM:\n+\treturn factor + 1;\n+\n       case ADDRESS_SYMBOLIC:\n \treturn factor * loongarch_symbol_insns (addr.symbol_type, mode);\n       }\n@@ -1967,7 +2088,8 @@ loongarch_signed_immediate_p (unsigned HOST_WIDE_INT x, int bits,\n   return loongarch_unsigned_immediate_p (x, bits, shift);\n }\n \n-/* Return true if X is a legitimate address with a 12-bit offset.\n+/* Return true if X is a legitimate address with a 12-bit offset\n+   or addr.type is ADDRESS_LO_SUM.\n    MODE is the mode of the value being accessed.  */\n \n bool\n@@ -1976,9 +2098,10 @@ loongarch_12bit_offset_address_p (rtx x, machine_mode mode)\n   struct loongarch_address_info addr;\n \n   return (loongarch_classify_address (&addr, x, mode, false)\n-\t  && addr.type == ADDRESS_REG\n-\t  && CONST_INT_P (addr.offset)\n-\t  && LARCH_12BIT_OFFSET_P (INTVAL (addr.offset)));\n+\t  && ((addr.type == ADDRESS_REG\n+\t       && CONST_INT_P (addr.offset)\n+\t       && LARCH_12BIT_OFFSET_P (INTVAL (addr.offset)))\n+\t      || addr.type == ADDRESS_LO_SUM));\n }\n \n /* Return true if X is a legitimate address with a 14-bit offset shifted 2.\n@@ -2020,6 +2143,14 @@ loongarch_const_insns (rtx x)\n \n   switch (GET_CODE (x))\n     {\n+    case HIGH:\n+      if (!loongarch_symbolic_constant_p (XEXP (x, 0), &symbol_type)\n+\t  || !loongarch_split_symbol_type (symbol_type))\n+\treturn 0;\n+\n+      /* This is simply a PCALAU12I.  */\n+      return 1;\n+\n     case CONST_INT:\n       return loongarch_integer_cost (INTVAL (x));\n \n@@ -2080,6 +2211,8 @@ loongarch_split_const_insns (rtx x)\n   return low + high;\n }\n \n+static bool loongarch_split_move_insn_p (rtx dest, rtx src);\n+\n /* Return the number of instructions needed to implement INSN,\n    given that it loads from or stores to MEM.  */\n \n@@ -2197,6 +2330,15 @@ loongarch_unspec_address (rtx address, enum loongarch_symbol_type symbol_type)\n   return loongarch_unspec_address_offset (base, offset, symbol_type);\n }\n \n+/* Emit an instruction of the form (set TARGET SRC).  */\n+\n+static rtx\n+loongarch_emit_set (rtx target, rtx src)\n+{\n+  emit_insn (gen_rtx_SET (target, src));\n+  return target;\n+}\n+\n /* If OP is an UNSPEC address, return the address to which it refers,\n    otherwise return OP itself.  */\n \n@@ -2278,6 +2420,7 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)\n {\n   rtx loc, a0;\n   rtx_insn *insn;\n+  rtx tmp = gen_reg_rtx (Pmode);\n \n   a0 = gen_rtx_REG (Pmode, GP_ARG_FIRST);\n \n@@ -2288,12 +2431,22 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)\n \n   start_sequence ();\n \n-  if (type == SYMBOL_TLSLDM)\n-    emit_insn (loongarch_got_load_tls_ld (a0, loc));\n-  else if (type == SYMBOL_TLSGD)\n-    emit_insn (loongarch_got_load_tls_gd (a0, loc));\n+  if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      /* Split tls symbol to high and low.  */\n+      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (loc));\n+      high = loongarch_force_temporary (tmp, high);\n+      emit_insn (gen_tls_low (Pmode, a0, high, loc));\n+    }\n   else\n-    gcc_unreachable ();\n+    {\n+      if (type == SYMBOL_TLSLDM)\n+\temit_insn (loongarch_got_load_tls_ld (a0, loc));\n+      else if (type == SYMBOL_TLSGD)\n+\temit_insn (loongarch_got_load_tls_gd (a0, loc));\n+      else\n+\tgcc_unreachable ();\n+    }\n \n   insn = emit_call_insn (gen_call_value_internal (v0, loongarch_tls_symbol,\n \t\t\t\t\t\t  const0_rtx));\n@@ -2308,12 +2461,12 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)\n \n /* Generate the code to access LOC, a thread-local SYMBOL_REF, and return\n    its address.  The return value will be both a valid address and a valid\n-   SET_SRC.  */\n+   SET_SRC (either a REG or a LO_SUM).  */\n \n static rtx\n loongarch_legitimize_tls_address (rtx loc)\n {\n-  rtx dest, tp, tmp;\n+  rtx dest, tp, tmp, tmp1, tmp2, tmp3;\n   enum tls_model model = SYMBOL_REF_TLS_MODEL (loc);\n   rtx_insn *insn;\n \n@@ -2334,21 +2487,45 @@ loongarch_legitimize_tls_address (rtx loc)\n       break;\n \n     case TLS_MODEL_INITIAL_EXEC:\n-      /* la.tls.ie; tp-relative add.  */\n-      tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);\n-      tmp = gen_reg_rtx (Pmode);\n-      emit_insn (loongarch_got_load_tls_ie (tmp, loc));\n-      dest = gen_reg_rtx (Pmode);\n-      emit_insn (gen_add3_insn (dest, tmp, tp));\n+\t{\n+\t  /* la.tls.ie; tp-relative add.  */\n+\t  tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);\n+\t  tmp1 = gen_reg_rtx (Pmode);\n+\t  dest = gen_reg_rtx (Pmode);\n+\t  if (TARGET_EXPLICIT_RELOCS)\n+\t    {\n+\t      tmp2 = loongarch_unspec_address (loc, SYMBOL_TLS_IE);\n+\t      tmp3 = gen_reg_rtx (Pmode);\n+\t      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (tmp2));\n+\t      high = loongarch_force_temporary (tmp3, high);\n+\t      emit_insn (gen_ld_from_got (Pmode, tmp1, high, tmp2));\n+\t    }\n+\t  else\n+\t    emit_insn (loongarch_got_load_tls_ie (tmp1, loc));\n+\t  emit_insn (gen_add3_insn (dest, tmp1, tp));\n+\t}\n       break;\n \n     case TLS_MODEL_LOCAL_EXEC:\n-      /* la.tls.le; tp-relative add.  */\n-      tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);\n-      tmp = gen_reg_rtx (Pmode);\n-      emit_insn (loongarch_got_load_tls_le (tmp, loc));\n-      dest = gen_reg_rtx (Pmode);\n-      emit_insn (gen_add3_insn (dest, tmp, tp));\n+\t{\n+\t  /* la.tls.le; tp-relative add.  */\n+\t  tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);\n+\t  tmp1 = gen_reg_rtx (Pmode);\n+\t  dest = gen_reg_rtx (Pmode);\n+\n+\t  if (TARGET_EXPLICIT_RELOCS)\n+\t    {\n+\t      tmp2 = loongarch_unspec_address (loc, SYMBOL_TLS_LE);\n+\t      tmp3 = gen_reg_rtx (Pmode);\n+\t      rtx high = gen_rtx_HIGH (Pmode, copy_rtx (tmp2));\n+\t      high = loongarch_force_temporary (tmp3, high);\n+\t      emit_insn (gen_ori_l_lo12 (Pmode, tmp1, high, tmp2));\n+\t    }\n+\t  else\n+\t    emit_insn (loongarch_got_load_tls_le (tmp1, loc));\n+\t  emit_insn (gen_add3_insn (dest, tmp1, tp));\n+\n+\t}\n       break;\n \n     default:\n@@ -2397,6 +2574,68 @@ loongarch_force_address (rtx x, machine_mode mode)\n   return x;\n }\n \n+/* If MODE is MAX_MACHINE_MODE, ADDR appears as a move operand, otherwise\n+   it appears in a MEM of that mode.  Return true if ADDR is a legitimate\n+   constant in that context and can be split into high and low parts.\n+   If so, and if LOW_OUT is nonnull, emit the high part and store the\n+   low part in *LOW_OUT.  Leave *LOW_OUT unchanged otherwise.\n+\n+   Return false if build with '-mno-explicit-relocs'.\n+\n+   TEMP is as for loongarch_force_temporary and is used to load the high\n+   part into a register.\n+\n+   When MODE is MAX_MACHINE_MODE, the low part is guaranteed to be\n+   a legitimize SET_SRC for an .md pattern, otherwise the low part\n+   is guaranteed to be a legitimate address for mode MODE.  */\n+\n+bool\n+loongarch_split_symbol (rtx temp, rtx addr, machine_mode mode, rtx *low_out)\n+{\n+  enum loongarch_symbol_type symbol_type;\n+  rtx high;\n+\n+  /* If build with '-mno-explicit-relocs', don't split symbol.  */\n+  if (!TARGET_EXPLICIT_RELOCS)\n+    return false;\n+\n+  if ((GET_CODE (addr) == HIGH && mode == MAX_MACHINE_MODE)\n+      || !loongarch_symbolic_constant_p (addr, &symbol_type)\n+      || loongarch_symbol_insns (symbol_type, mode) == 0\n+      || !loongarch_split_symbol_type (symbol_type))\n+    return false;\n+\n+  if (temp == NULL)\n+    temp = gen_reg_rtx (Pmode);\n+\n+  /* Get the 12-31 bits of the address.  */\n+  high = gen_rtx_HIGH (Pmode, copy_rtx (addr));\n+  high = loongarch_force_temporary (temp, high);\n+\n+  if (low_out)\n+    switch (symbol_type)\n+      {\n+      case SYMBOL_PCREL:\n+\t*low_out = gen_rtx_LO_SUM (Pmode, high, addr);\n+\tbreak;\n+\n+      case SYMBOL_GOT_DISP:\n+\t/* SYMBOL_GOT_DISP symbols are loaded from the GOT.  */\n+\t{\n+\t  rtx low = gen_rtx_LO_SUM (Pmode, high, addr);\n+\t  rtx mem = gen_rtx_MEM (Pmode, low);\n+\t  *low_out = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, mem),\n+\t\t\t\t     UNSPEC_LOAD_FROM_GOT);\n+\t  break;\n+\t}\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  return true;\n+}\n+\n /* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n    be legitimized in a way that the generic machinery might not expect,\n    return a new address, otherwise return NULL.  MODE is the mode of\n@@ -2412,6 +2651,10 @@ loongarch_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   if (loongarch_tls_symbol_p (x))\n     return loongarch_legitimize_tls_address (x);\n \n+  /* See if the address can split into a high part and a LO_SUM.  */\n+  if (loongarch_split_symbol (NULL, x, mode, &addr))\n+    return loongarch_force_address (addr, mode);\n+\n   /* Handle BASE + OFFSET using loongarch_add_offset.  */\n   loongarch_split_plus (x, &base, &offset);\n   if (offset != 0)\n@@ -2499,6 +2742,13 @@ loongarch_legitimize_const_move (machine_mode mode, rtx dest, rtx src)\n       return;\n     }\n \n+  /* Split moves of symbolic constants into high and low.  */\n+  if (loongarch_split_symbol (dest, src, MAX_MACHINE_MODE, &src))\n+    {\n+      loongarch_emit_set (dest, src);\n+      return;\n+    }\n+\n   /* Generate the appropriate access sequences for TLS symbols.  */\n   if (loongarch_tls_symbol_p (src))\n     {\n@@ -3241,21 +3491,12 @@ loongarch_split_move (rtx dest, rtx src, rtx insn_)\n \n /* Return true if a move from SRC to DEST in INSN should be split.  */\n \n-bool\n+static bool\n loongarch_split_move_insn_p (rtx dest, rtx src)\n {\n   return loongarch_split_move_p (dest, src);\n }\n \n-/* Split a move from SRC to DEST in INSN, given that\n-   loongarch_split_move_insn_p holds.  */\n-\n-void\n-loongarch_split_move_insn (rtx dest, rtx src, rtx insn)\n-{\n-  loongarch_split_move (dest, src, insn);\n-}\n-\n /* Implement TARGET_CONSTANT_ALIGNMENT.  */\n \n static HOST_WIDE_INT\n@@ -3369,13 +3610,16 @@ loongarch_output_move (rtx dest, rtx src)\n \t    case 2:\n \t      return \"st.h\\t%z1,%0\";\n \t    case 4:\n-\t      /* Matching address type with a 12bit offset.  */\n-\t      if (const_arith_operand (offset, Pmode))\n+\t      /* Matching address type with a 12bit offset and\n+\t\t ADDRESS_LO_SUM.  */\n+\t      if (const_arith_operand (offset, Pmode)\n+\t\t  || GET_CODE (offset) == LO_SUM)\n \t\treturn \"st.w\\t%z1,%0\";\n \t      else\n \t\treturn \"stptr.w\\t%z1,%0\";\n \t    case 8:\n-\t      if (const_arith_operand (offset, Pmode))\n+\t      if (const_arith_operand (offset, Pmode)\n+\t\t  || GET_CODE (offset) == LO_SUM)\n \t\treturn \"st.d\\t%z1,%0\";\n \t      else\n \t\treturn \"stptr.d\\t%z1,%0\";\n@@ -3408,13 +3652,16 @@ loongarch_output_move (rtx dest, rtx src)\n \t    case 2:\n \t      return \"ld.hu\\t%0,%1\";\n \t    case 4:\n-\t      /* Matching address type with a 12bit offset.  */\n-\t      if (const_arith_operand (offset, Pmode))\n+\t      /* Matching address type with a 12bit offset and\n+\t\t ADDRESS_LO_SUM.  */\n+\t      if (const_arith_operand (offset, Pmode)\n+\t\t  || GET_CODE (offset) == LO_SUM)\n \t\treturn \"ld.w\\t%0,%1\";\n \t      else\n \t\treturn \"ldptr.w\\t%0,%1\";\n \t    case 8:\n-\t      if (const_arith_operand (offset, Pmode))\n+\t      if (const_arith_operand (offset, Pmode)\n+\t\t  || GET_CODE (offset) == LO_SUM)\n \t\treturn \"ld.d\\t%0,%1\";\n \t      else\n \t\treturn \"ldptr.d\\t%0,%1\";\n@@ -3423,6 +3670,21 @@ loongarch_output_move (rtx dest, rtx src)\n \t    }\n \t}\n \n+      if (src_code == HIGH)\n+\t{\n+\t  rtx offset, x;\n+\t  split_const (XEXP (src, 0), &x, &offset);\n+\t  enum loongarch_symbol_type type = SYMBOL_PCREL;\n+\n+\t  if (UNSPEC_ADDRESS_P (x))\n+\t     type = UNSPEC_ADDRESS_TYPE (x);\n+\n+\t  if (type == SYMBOL_TLS_LE)\n+\t    return \"lu12i.w\\t%0,%h1\";\n+\t  else\n+\t    return \"pcalau12i\\t%0,%h1\";\n+\t}\n+\n       if (src_code == CONST_INT)\n \t{\n \t  if (LU12I_INT (src))\n@@ -3438,7 +3700,8 @@ loongarch_output_move (rtx dest, rtx src)\n \t}\n     }\n \n-  if (dest_code == REG && symbolic_operand (src, VOIDmode))\n+  if (!TARGET_EXPLICIT_RELOCS\n+      && dest_code == REG && symbolic_operand (src, VOIDmode))\n     {\n       if (loongarch_classify_symbol (src) == SYMBOL_PCREL)\n \treturn \"la.local\\t%0,%1\";\n@@ -4307,6 +4570,49 @@ loongarch_memmodel_needs_release_fence (enum memmodel model)\n     }\n }\n \n+/* Print symbolic operand OP, which is part of a HIGH or LO_SUM\n+   in context CONTEXT.  HI_RELOC indicates a high-part reloc.  */\n+\n+static void\n+loongarch_print_operand_reloc (FILE *file, rtx op, bool hi_reloc)\n+{\n+  const char *reloc;\n+\n+  switch (loongarch_classify_symbolic_expression (op))\n+    {\n+    case SYMBOL_PCREL:\n+      reloc = hi_reloc ? \"%pc_hi20\" : \"%pc_lo12\";\n+      break;\n+\n+    case SYMBOL_GOT_DISP:\n+      reloc = hi_reloc ? \"%got_pc_hi20\" : \"%got_pc_lo12\";\n+      break;\n+\n+    case SYMBOL_TLS_IE:\n+      reloc = hi_reloc ? \"%ie_pc_hi20\" : \"%ie_pc_lo12\";\n+      break;\n+\n+    case SYMBOL_TLS_LE:\n+      reloc = hi_reloc ? \"%le_hi20\" : \"%le_lo12\";\n+      break;\n+\n+    case SYMBOL_TLSGD:\n+      reloc = hi_reloc ? \"%gd_pc_hi20\" : \"%got_pc_lo12\";\n+      break;\n+\n+    case SYMBOL_TLSLDM:\n+      reloc = hi_reloc ? \"%ld_pc_hi20\" : \"%got_pc_lo12\";\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  fprintf (file, \"%s(\", reloc);\n+  output_addr_const (file, loongarch_strip_unspec_address (op));\n+  fputc (')', file);\n+}\n+\n /* Implement TARGET_PRINT_OPERAND.  The LoongArch-specific operand codes are:\n \n    'A'\tPrint a _DB suffix if the memory model requires a release.\n@@ -4315,7 +4621,10 @@ loongarch_memmodel_needs_release_fence (enum memmodel model)\n    'd'\tPrint CONST_INT OP in decimal.\n    'F'\tPrint the FPU branch condition for comparison OP.\n    'G'\tPrint a DBAR insn if the memory model requires a release.\n+   'H'  Print address 52-61bit relocation associated with OP.\n+   'h'  Print the high-part relocation associated with OP.\n    'i'\tPrint i if the operand is not a register.\n+   'L'  Print the low-part relocation associated with OP.\n    'm'\tPrint one less than CONST_INT OP in decimal.\n    'N'\tPrint the inverse of the integer branch condition for comparison OP.\n    'T'\tPrint 'f' for (eq:CC ...), 't' for (ne:CC ...),\n@@ -4372,11 +4681,21 @@ loongarch_print_operand (FILE *file, rtx op, int letter)\n \tfputs (\"dbar\\t0\", file);\n       break;\n \n+    case 'h':\n+      if (code == HIGH)\n+\top = XEXP (op, 0);\n+      loongarch_print_operand_reloc (file, op, true /* hi_reloc */);\n+      break;\n+\n     case 'i':\n       if (code != REG)\n \tfputs (\"i\", file);\n       break;\n \n+    case 'L':\n+      loongarch_print_operand_reloc (file, op, false /* lo_reloc */);\n+      break;\n+\n     case 'm':\n       if (CONST_INT_P (op))\n \tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op) - 1);\n@@ -4517,6 +4836,11 @@ loongarch_print_operand_address (FILE *file, machine_mode /* mode  */, rtx x)\n \t\t\t\treg_names[REGNO (addr.offset)]);\n \treturn;\n \n+      case ADDRESS_LO_SUM:\n+\tfprintf (file, \"%s,\", reg_names[REGNO (addr.reg)]);\n+\tloongarch_print_operand_reloc (file, addr.offset, false /* hi_reloc */);\n+\treturn;\n+\n       case ADDRESS_CONST_INT:\n \tfprintf (file, \"%s,\", reg_names[GP_REG_FIRST]);\n \toutput_addr_const (file, x);\n@@ -5891,6 +6215,12 @@ loongarch_starting_frame_offset (void)\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT loongarch_trampoline_init\n \n+#undef TARGET_MIN_ANCHOR_OFFSET\n+#define TARGET_MIN_ANCHOR_OFFSET (-IMM_REACH/2)\n+\n+#undef TARGET_MAX_ANCHOR_OFFSET\n+#define TARGET_MAX_ANCHOR_OFFSET (IMM_REACH/2-1)\n+\n #undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n #define TARGET_ATOMIC_ASSIGN_EXPAND_FENV loongarch_atomic_assign_expand_fenv\n "}, {"sha": "6b6df22a5f128869c9d75978e826e1e69ed4339a", "filename": "gcc/config/loongarch/loongarch.md", "status": "modified", "additions": 55, "deletions": 67, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.md?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -57,6 +57,10 @@\n   ;; CRC\n   UNSPEC_CRC\n   UNSPEC_CRCC\n+\n+  UNSPEC_LOAD_FROM_GOT\n+  UNSPEC_ORI_L_LO12\n+  UNSPEC_TLS_LOW\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -1743,73 +1747,6 @@\n   [(set_attr \"move_type\" \"move,load,store\")\n    (set_attr \"mode\" \"DF\")])\n \n-\n-;; 128-bit integer moves\n-\n-(define_expand \"movti\"\n-  [(set (match_operand:TI 0)\n-\t(match_operand:TI 1))]\n-  \"TARGET_64BIT\"\n-{\n-  if (loongarch_legitimize_move (TImode, operands[0], operands[1]))\n-    DONE;\n-})\n-\n-(define_insn \"*movti\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n-\t(match_operand:TI 1 \"move_operand\" \"r,i,m,rJ\"))]\n-  \"TARGET_64BIT\n-   && (register_operand (operands[0], TImode)\n-       || reg_or_0_operand (operands[1], TImode))\"\n-  { return loongarch_output_move (operands[0], operands[1]); }\n-  [(set_attr \"move_type\" \"move,const,load,store\")\n-   (set (attr \"mode\")\n-    (if_then_else (eq_attr \"move_type\" \"imul\")\n-\t\t      (const_string \"SI\")\n-\t\t      (const_string \"TI\")))])\n-\n-;; 128-bit floating point moves\n-\n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0)\n-\t(match_operand:TF 1))]\n-  \"TARGET_64BIT\"\n-{\n-  if (loongarch_legitimize_move (TFmode, operands[0], operands[1]))\n-    DONE;\n-})\n-\n-;; This pattern handles both hard- and soft-float cases.\n-(define_insn \"*movtf\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,r,m,f,r,f,m\")\n-\t(match_operand:TF 1 \"move_operand\" \"rG,m,rG,rG,f,m,f\"))]\n-  \"TARGET_64BIT\n-   && (register_operand (operands[0], TFmode)\n-       || reg_or_0_operand (operands[1], TFmode))\"\n-  \"#\"\n-  [(set_attr \"move_type\" \"move,load,store,mgtf,mftg,fpload,fpstore\")\n-   (set_attr \"mode\" \"TF\")])\n-\n-(define_split\n-  [(set (match_operand:MOVE64 0 \"nonimmediate_operand\")\n-\t(match_operand:MOVE64 1 \"move_operand\"))]\n-  \"reload_completed && loongarch_split_move_insn_p (operands[0], operands[1])\"\n-  [(const_int 0)]\n-{\n-  loongarch_split_move_insn (operands[0], operands[1], curr_insn);\n-  DONE;\n-})\n-\n-(define_split\n-  [(set (match_operand:MOVE128 0 \"nonimmediate_operand\")\n-\t(match_operand:MOVE128 1 \"move_operand\"))]\n-  \"reload_completed && loongarch_split_move_insn_p (operands[0], operands[1])\"\n-  [(const_int 0)]\n-{\n-  loongarch_split_move_insn (operands[0], operands[1], curr_insn);\n-  DONE;\n-})\n-\n ;; Emit a doubleword move in which exactly one of the operands is\n ;; a floating-point register.  We can't just emit two normal moves\n ;; because of the constraints imposed by the FPU register model;\n@@ -1938,6 +1875,57 @@\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"DI\")])\n \n+;; Instructions for adding the low 12 bits of an address to a register.\n+;; Operand 2 is the address: loongarch_print_operand works out which relocation\n+;; should be applied.\n+\n+(define_insn \"*low<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+ (lo_sum:P (match_operand:P 1 \"register_operand\" \" r\")\n+     (match_operand:P 2 \"symbolic_operand\" \"\")))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"addi.<d>\\t%0,%1,%L2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@tls_low<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(mem:P (lo_sum:P (match_operand:P 1 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:P 2 \"symbolic_operand\" \"\")))]\n+\tUNSPEC_TLS_LOW))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"addi.<d>\\t%0,%1,%L2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; Instructions for loading address from GOT entry.\n+;; operands[1] is pc plus the high half of the address difference with the got\n+;; entry;\n+;; operands[2] is low 12 bits for low 12 bit of the address difference with the\n+;; got entry.\n+;; loongarch_print_operand works out which relocation should be applied.\n+\n+(define_insn \"@ld_from_got<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(mem:P (lo_sum:P\n+\t\t\t\t(match_operand:P 1 \"register_operand\" \"r\")\n+\t\t\t\t(match_operand:P 2 \"symbolic_operand\")))]\n+\tUNSPEC_LOAD_FROM_GOT))]\n+  \"TARGET_EXPLICIT_RELOCS\"\n+  \"ld.<d>\\t%0,%1,%L2\"\n+  [(set_attr \"type\" \"move\")]\n+)\n+\n+(define_insn \"@ori_l_lo12<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:P 2 \"symbolic_operand\")]\n+\tUNSPEC_ORI_L_LO12))]\n+  \"\"\n+  \"ori\\t%0,%1,%L2\"\n+  [(set_attr \"type\" \"move\")]\n+)\n+\n ;; Convert floating-point numbers to integers\n (define_insn \"frint_<fmt>\"\n   [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")"}, {"sha": "7a8c5b444185c83fcc1bb6e333c83a7d416b877f", "filename": "gcc/config/loongarch/loongarch.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Floongarch.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.opt?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -161,6 +161,10 @@ mmax-inline-memcpy-size=\n Target Joined RejectNegative UInteger Var(loongarch_max_inline_memcpy_size) Init(1024)\n -mmax-inline-memcpy-size=SIZE\tSet the max size of memcpy to inline, default is 1024.\n \n+mexplicit-relocs\n+Target Var(TARGET_EXPLICIT_RELOCS) Init(1)\n+Use %reloc() assembly operators.\n+\n ; The code model option names for -mcmodel.\n Enum\n Name(cmodel) Type(int)"}, {"sha": "cd3528c7c97f0aa0a09be90228c5dda1fc820f1b", "filename": "gcc/config/loongarch/predicates.md", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fpredicates.md?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -110,6 +110,10 @@\n (define_predicate \"const_call_insn_operand\"\n   (match_code \"const,symbol_ref,label_ref\")\n {\n+  /* Split symbol to high and low if return false.\n+     If defined TARGET_CMODEL_LARGE, all symbol would be splited,\n+     else if offset is not zero, the symbol would be splited.  */\n+\n   enum loongarch_symbol_type symbol_type;\n   loongarch_symbolic_constant_p (op, &symbol_type);\n \n@@ -125,7 +129,7 @@\n       return 1;\n \n     case SYMBOL_GOT_DISP:\n-      if (!flag_plt)\n+      if (TARGET_CMODEL_LARGE || !flag_plt)\n \treturn false;\n       else\n \treturn 1;\n@@ -213,7 +217,19 @@\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      return loongarch_symbolic_constant_p (op, &symbol_type);\n+      return (loongarch_symbolic_constant_p (op, &symbol_type)\n+\t      && (!TARGET_EXPLICIT_RELOCS\n+\t\t  || !loongarch_split_symbol_type (symbol_type)));\n+\n+    case HIGH:\n+      /* '-mno-explicit-relocs' don't generate high/low pairs.  */\n+      if (!TARGET_EXPLICIT_RELOCS)\n+\treturn false;\n+\n+      op = XEXP (op, 0);\n+      return (loongarch_symbolic_constant_p (op, &symbol_type)\n+\t      && loongarch_split_symbol_type (symbol_type));\n+\n     default:\n       return true;\n     }"}, {"sha": "01b8ea23fb943ec826aae77cc7daf1b35f792c78", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-1.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mabi=lp64d -O0 -fpic -fplt\" } */\n+/* { dg-options \"-mabi=lp64d -O0 -fpic -fplt -mno-explicit-relocs\" } */\n /* { dg-final { scan-assembler \"test:.*bl\\t%plt\\\\(g\\\\)\\n\" } } */\n /* { dg-final { scan-assembler \"test1:.*bl\\t%plt\\\\(f\\\\)\\n\" } } */\n /* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */"}, {"sha": "4565baaec9ec2f13d12b39f9a49ba5614811bb8d", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-2.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fplt\" } */\n+/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fplt -mno-explicit-relocs\" } */\n /* { dg-final { scan-assembler \"test:.*bl\\t%plt\\\\(g\\\\)\\n\" } } */\n /* { dg-final { scan-assembler \"test1:.*bl\\tf\\n\" } } */\n /* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */"}, {"sha": "4f669a029e77b2d0874ded23d6001adb1a8f2848", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-3.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mabi=lp64d -O0 -fpic -fno-plt\" } */\n+/* { dg-options \"-mabi=lp64d -O0 -fpic -fno-plt -mno-explicit-relocs\" } */\n /* { dg-final { scan-assembler \"test:.*la\\.global\\t.*g\\n\\tjirl\" } } */\n /* { dg-final { scan-assembler \"test1:.*la\\.global\\t.*f\\n\\tjirl\" } } */\n /* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */"}, {"sha": "943adb6403f86412bfe27ccb45d330b1234547db", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-4.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fno-plt\" } */\n+/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fno-plt -mno-explicit-relocs\" } */\n /* { dg-final { scan-assembler \"test:.*la\\.global\\t.*g\\n\\tjirl\" } } */\n /* { dg-final { scan-assembler \"test1:.*bl\\tf\\n\" } } */\n /* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */"}, {"sha": "2c2a1c8a1b6f11e2f5b84904244aeba82bd2b629", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-5.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-5.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fpic -fplt -mexplicit-relocs\" } */\n+/* { dg-final { scan-assembler \"test:.*bl\\t%plt\\\\(g\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"test1:.*bl\\t%plt\\\\(f\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+extern void g (void);\n+\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}, {"sha": "4b0e4266ec8aec37d7a25d95c98832d804639aaa", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-6.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-6.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fplt -mexplicit-relocs\" } */\n+/* { dg-final { scan-assembler \"test:.*bl\\t%plt\\\\(g\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"test1:.*bl\\tf\\n\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+extern void g (void);\n+\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}, {"sha": "51792711f7259bf0486b187388a9a85201b2eb60", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-7.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-7.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fpic -fno-plt -mexplicit-relocs\" } */\n+/* { dg-final { scan-assembler \"test:.*pcalau12i\\t.*%got_pc_hi20\\\\(g\\\\)\\n\\tld\\.d\\t.*%got_pc_lo12\\\\(g\\\\)\\n\\tjirl\" } } */\n+/* { dg-final { scan-assembler \"test1:.*pcalau12i\\t.*%got_pc_hi20\\\\(f\\\\)\\n\\tld\\.d\\t.*%got_pc_lo12\\\\(f\\\\)\\n\\tjirl\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+\n+extern void g (void);\n+\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}, {"sha": "330140d883ded5b36537bc4404db79ba5c89bc6f", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-8.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-8.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fno-plt -mexplicit-relocs\" } */\n+/* { dg-final { scan-assembler \"test:.*pcalau12i\\t.*%got_pc_hi20\\\\(g\\\\)\\n\\tld\\.d\\t.*%got_pc_lo12\\\\(g\\\\)\\n\\tjirl\" } } */\n+/* { dg-final { scan-assembler \"test1:.*bl\\tf\\n\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+extern void g (void);\n+\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}, {"sha": "bfcc9bc338ff86ae1984016479baf810024a6557", "filename": "gcc/testsuite/gcc.target/loongarch/relocs-symbol-noaddend.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Frelocs-symbol-noaddend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Frelocs-symbol-noaddend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Frelocs-symbol-noaddend.c?ref=16fc26d4e7a4a7618d8d231f9b4cb7bd487fb7b8", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -mexplicit-relocs -fno-pic -O2\" } */\n+/* { dg-final { scan-assembler \"pcalau12i.*%pc_hi20\\\\(\\.LANCHOR0\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"addi\\.d.*%pc_lo12\\\\(\\.LANCHOR0\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"ldptr.d\\t\\\\\\$r4,.*,0\\n\" } } */\n+/* { dg-final { scan-assembler \"ld.d\\t\\\\\\$r5,.*,8\\n\" } } */\n+/* { dg-final { scan-assembler-not  \"\\.LANCHOR0+8\" } } */\n+\n+\n+struct S\n+{\n+  char *a;\n+  unsigned short int b;\n+};\n+\n+struct S s1;\n+\n+void test(struct S);\n+void test1(void)\n+{\n+  test(s1);\n+}\n+"}]}