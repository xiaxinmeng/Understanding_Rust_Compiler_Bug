{"sha": "7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M4MjEwNmZmOTU0ODYzNGM4NWZhN2NkN2YxY2MzYTkwNmZkNmVmYQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@kss-loka.si", "date": "2004-12-08T06:50:58Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2004-12-08T06:50:58Z"}, "message": "i386-protos.h (ix86_split_fp_branch): New rtx argument.\n\n        * config/i386/i386-protos.h (ix86_split_fp_branch): New rtx\n        argument.\n\n        * config/i386/i386.c (output_fp_compare): Fix is_sse condition.\n        Use EFLAGS_P only when fcomi insn should be used. Fix handling\n        of eflags_p variable. Change alt table accordingly. For non-fcomi\n        compare insn always use trailing fnstsw insn. Fix intmode\n        calculation for ficom insn.\n        (ix86_split_fp_branch): Add \"rtx pushed\" as new parameter. Call\n        ix86_free_from_memory when \"pushed\" is specified.\n        (ix86_expand_branch): Change call to ix86_split_fp_branch.\n\n        * config/i386/i386.md (*cmpfp_0_sf, *cmpfp_0_df, *cmpfp_0_xf):\n        Change eflags_p parameter in call to output_fp_compare.\n        (*cmpfp_2_sf, *cmpfp_2_df, *cmpfp_2_xf): Remove.\n        (*cmpfp_2_sf_1, *cmpfp_2_df_1, *cmpfp_2_xf_1): Rename to\n        *cmpfp_2_sf, *cmpfp_2_df, *cmpfp_2_xf.  Change eflags_p\n        parameter in call to output_fp_compare.\n        (*cmpfp_2_u): Remove.\n        (*cmpfp_2_u_1): Rename to *cmpfp_2_u. Change eflags_p parameter\n        in call to output_fp_compare.\n        (*ficom_1): Remove insn definition and corresponding define_split.\n        (*cmpfp_si): New insn definition.\n        (*fp_jcc_8): New insn definition. Add new splitters for\n        \"memory_operand\" and \"register_operand\".\n        (define_split): Add new parameter in call to ix86_split_fp_branch.\n\n        config/i386/predicates.md (float_operator): New predicate.\n\nFrom-SVN: r91856", "tree": {"sha": "e48bafdbb500e4727cafc2120e27bae69a7c2c4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e48bafdbb500e4727cafc2120e27bae69a7c2c4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/comments", "author": null, "committer": null, "parents": [{"sha": "ac1b13f457ad72970d58b53ef88b45ddab522d41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1b13f457ad72970d58b53ef88b45ddab522d41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1b13f457ad72970d58b53ef88b45ddab522d41"}], "stats": {"total": 304, "additions": 162, "deletions": 142}, "files": [{"sha": "7b526cc1fa4a3c05a8def47ba44d99e02e847167", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "patch": "@@ -1,3 +1,34 @@\n+2004-12-07  Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* config/i386/i386-protos.h (ix86_split_fp_branch): New rtx\n+\targument.\n+\n+\t* config/i386/i386.c (output_fp_compare): Fix is_sse condition.\n+\tUse EFLAGS_P only when fcomi insn should be used. Fix handling\n+\tof eflags_p variable. Change alt table accordingly. For non-fcomi\n+\tcompare insn always use trailing fnstsw insn. Fix intmode\n+\tcalculation for ficom insn.\n+\t(ix86_split_fp_branch): Add \"rtx pushed\" as new parameter. Call\n+\tix86_free_from_memory when \"pushed\" is specified.\n+\t(ix86_expand_branch): Change call to ix86_split_fp_branch.\n+\n+\t* config/i386/i386.md (*cmpfp_0_sf, *cmpfp_0_df, *cmpfp_0_xf):\n+\tChange eflags_p parameter in call to output_fp_compare.\n+\t(*cmpfp_2_sf, *cmpfp_2_df, *cmpfp_2_xf): Remove.\n+\t(*cmpfp_2_sf_1, *cmpfp_2_df_1, *cmpfp_2_xf_1): Rename to\n+\t*cmpfp_2_sf, *cmpfp_2_df, *cmpfp_2_xf. \tChange eflags_p\n+\tparameter in call to output_fp_compare.\n+\t(*cmpfp_2_u): Remove.\n+\t(*cmpfp_2_u_1): Rename to *cmpfp_2_u. Change eflags_p parameter\n+\tin call to output_fp_compare.\n+\t(*ficom_1): Remove insn definition and corresponding define_split.\n+\t(*cmpfp_si): New insn definition.\n+\t(*fp_jcc_8): New insn definition. Add new splitters for\n+\t\"memory_operand\" and \"register_operand\".\n+\t(define_split): Add new parameter in call to ix86_split_fp_branch.\n+\n+\tconfig/i386/predicates.md (float_operator): New predicate.\n+\n 2004-12-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-common.c (verify_tree): Don't check code length if we know"}, {"sha": "c79acd033ca9d0592f7c051c6245ae22051f8c0b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "patch": "@@ -165,7 +165,8 @@ extern rtx ix86_va_arg (tree, tree);\n \n extern rtx ix86_force_to_memory (enum machine_mode, rtx);\n extern void ix86_free_from_memory (enum machine_mode);\n-extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx, rtx, rtx, rtx);\n+extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n+\t\t\t\t  rtx, rtx, rtx, rtx);\n extern int ix86_hard_regno_mode_ok (int, enum machine_mode);\n extern int ix86_register_move_cost (enum machine_mode, enum reg_class,\n \t\t\t\t    enum reg_class);"}, {"sha": "2bd53bc862f8ba4d7a4c41542489fa4e4175832a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "patch": "@@ -7208,25 +7208,24 @@ output_fix_trunc (rtx insn, rtx *operands)\n }\n \n /* Output code for INSN to compare OPERANDS.  EFLAGS_P is 1 when fcomi\n-   should be used and 2 when fnstsw should be used.  UNORDERED_P is true\n-   when fucom should be used.  */\n+   should be used.  UNORDERED_P is true when fucom should be used.  */\n \n const char *\n output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n {\n   int stack_top_dies;\n   rtx cmp_op0, cmp_op1;\n-  int is_sse = SSE_REG_P (operands[0]) | SSE_REG_P (operands[1]);\n+  int is_sse = SSE_REG_P (operands[0]) || SSE_REG_P (operands[1]);\n \n-  if (eflags_p == 2)\n+  if (eflags_p)\n     {\n-      cmp_op0 = operands[1];\n-      cmp_op1 = operands[2];\n+      cmp_op0 = operands[0];\n+      cmp_op1 = operands[1];\n     }\n   else\n     {\n-      cmp_op0 = operands[0];\n-      cmp_op1 = operands[1];\n+      cmp_op0 = operands[1];\n+      cmp_op1 = operands[2];\n     }\n \n   if (is_sse)\n@@ -7268,7 +7267,7 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n \t is also a stack register that dies, then this must be a\n \t `fcompp' float compare */\n \n-      if (eflags_p == 1)\n+      if (eflags_p)\n \t{\n \t  /* There is no double popping fcomi variant.  Fortunately,\n \t     eflags is immune from the fstp's cc clobbering.  */\n@@ -7280,35 +7279,25 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n \t}\n       else\n \t{\n-\t  if (eflags_p == 2)\n-\t    {\n-\t      if (unordered_p)\n-\t\treturn \"fucompp\\n\\tfnstsw\\t%0\";\n-\t      else\n-\t\treturn \"fcompp\\n\\tfnstsw\\t%0\";\n-\t    }\n+\t  if (unordered_p)\n+\t    return \"fucompp\\n\\tfnstsw\\t%0\";\n \t  else\n-\t    {\n-\t      if (unordered_p)\n-\t\treturn \"fucompp\";\n-\t      else\n-\t\treturn \"fcompp\";\n-\t    }\n+\t    return \"fcompp\\n\\tfnstsw\\t%0\";\n \t}\n     }\n   else\n     {\n       /* Encoded here as eflags_p | intmode | unordered_p | stack_top_dies.  */\n \n-      static const char * const alt[24] =\n+      static const char * const alt[16] =\n       {\n-\t\"fcom%z1\\t%y1\",\n-\t\"fcomp%z1\\t%y1\",\n-\t\"fucom%z1\\t%y1\",\n-\t\"fucomp%z1\\t%y1\",\n+\t\"fcom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"fcomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"fucom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"fucomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n \n-\t\"ficom%z1\\t%y1\",\n-\t\"ficomp%z1\\t%y1\",\n+\t\"ficom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n+\t\"ficomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n \tNULL,\n \tNULL,\n \n@@ -7320,28 +7309,18 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n \tNULL,\n \tNULL,\n \tNULL,\n-\tNULL,\n-\n-\t\"fcom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fcomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fucom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"fucomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\n-\t\"ficom%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\t\"ficomp%z2\\t%y2\\n\\tfnstsw\\t%0\",\n-\tNULL,\n \tNULL\n       };\n \n       int mask;\n       const char *ret;\n \n       mask  = eflags_p << 3;\n-      mask |= (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT) << 2;\n+      mask |= (GET_MODE_CLASS (GET_MODE (cmp_op1)) == MODE_INT) << 2;\n       mask |= unordered_p << 1;\n       mask |= stack_top_dies;\n \n-      if (mask >= 24)\n+      if (mask >= 16)\n \tabort ();\n       ret = alt[mask];\n       if (ret == NULL)\n@@ -8458,7 +8437,7 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t  {\n \t    ix86_split_fp_branch (code, ix86_compare_op0, ix86_compare_op1,\n \t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t\t  pc_rtx, NULL_RTX);\n+\t\t\t\t  pc_rtx, NULL_RTX, NULL_RTX);\n \t  }\n \telse\n \t  {\n@@ -8606,7 +8585,7 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n /* Split branch based on floating point condition.  */\n void\n ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n-\t\t      rtx target1, rtx target2, rtx tmp)\n+\t\t      rtx target1, rtx target2, rtx tmp, rtx pushed)\n {\n   rtx second, bypass;\n   rtx label = NULL_RTX;\n@@ -8625,6 +8604,10 @@ ix86_split_fp_branch (enum rtx_code code, rtx op1, rtx op2,\n   condition = ix86_expand_fp_compare (code, op1, op2,\n \t\t\t\t      tmp, &second, &bypass);\n \n+  /* Remove pushed operand from stack.  */\n+  if (pushed)\n+    ix86_free_from_memory (GET_MODE (pushed));\n+\n   if (split_branch_probability >= 0)\n     {\n       /* Distribute the probabilities across the jumps."}, {"sha": "84b97e86805ec8976c0499e359ab833d717d6174", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "patch": "@@ -797,6 +797,9 @@\n ;; CCFPmode\tcompare with exceptions\n ;; CCFPUmode\tcompare with no exceptions\n \n+;; We may not use \"#\" to split and emit these, since the REG_DEAD notes\n+;; used to manage the reg stack popping would not be preserved.\n+\n (define_insn \"*cmpfp_0_sf\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n@@ -805,7 +808,7 @@\n \t     (match_operand:SF 2 \"const0_operand\" \"X\"))]\n \tUNSPEC_FNSTSW))]\n   \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 2, 0);\"\n+  \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"SF\")])\n \n@@ -817,7 +820,7 @@\n \t     (match_operand:DF 2 \"const0_operand\" \"X\"))]\n \tUNSPEC_FNSTSW))]\n   \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 2, 0);\"\n+  \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"DF\")])\n \n@@ -829,98 +832,47 @@\n \t     (match_operand:XF 2 \"const0_operand\" \"X\"))]\n \tUNSPEC_FNSTSW))]\n   \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 2, 0);\"\n+  \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"XF\")])\n \n-;; We may not use \"#\" to split and emit these, since the REG_DEAD notes\n-;; used to manage the reg stack popping would not be preserved.\n-\n-(define_insn \"*cmpfp_2_sf\"\n-  [(set (reg:CCFP FPSR_REG)\n-\t(compare:CCFP\n-\t  (match_operand:SF 0 \"register_operand\" \"f\")\n-\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 0, 0);\"\n-  [(set_attr \"type\" \"fcmp\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-(define_insn \"*cmpfp_2_sf_1\"\n+(define_insn \"*cmpfp_sf\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n \t  [(compare:CCFP\n \t     (match_operand:SF 1 \"register_operand\" \"f\")\n \t     (match_operand:SF 2 \"nonimmediate_operand\" \"fm\"))]\n \t  UNSPEC_FNSTSW))]\n   \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 2, 0);\"\n-  [(set_attr \"type\" \"fcmp\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-(define_insn \"*cmpfp_2_df\"\n-  [(set (reg:CCFP FPSR_REG)\n-\t(compare:CCFP\n-\t  (match_operand:DF 0 \"register_operand\" \"f\")\n-\t  (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_80387\"\n   \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"fcmp\")\n-   (set_attr \"mode\" \"DF\")])\n+   (set_attr \"mode\" \"SF\")])\n \n-(define_insn \"*cmpfp_2_df_1\"\n+(define_insn \"*cmpfp_df\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n \t  [(compare:CCFP\n \t     (match_operand:DF 1 \"register_operand\" \"f\")\n \t     (match_operand:DF 2 \"nonimmediate_operand\" \"fm\"))]\n \t  UNSPEC_FNSTSW))]\n   \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 2, 0);\"\n+  \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"*cmpfp_2_xf\"\n-  [(set (reg:CCFP FPSR_REG)\n-\t(compare:CCFP\n-\t  (match_operand:XF 0 \"register_operand\" \"f\")\n-\t  (match_operand:XF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 0, 0);\"\n-  [(set_attr \"type\" \"fcmp\")\n-   (set_attr \"mode\" \"XF\")])\n-\n-(define_insn \"*cmpfp_2_xf_1\"\n+(define_insn \"*cmpfp_xf\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n \t  [(compare:CCFP\n \t     (match_operand:XF 1 \"register_operand\" \"f\")\n \t     (match_operand:XF 2 \"register_operand\" \"f\"))]\n \t  UNSPEC_FNSTSW))]\n   \"TARGET_80387\"\n-  \"* return output_fp_compare (insn, operands, 2, 0);\"\n+  \"* return output_fp_compare (insn, operands, 0, 0);\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"XF\")])\n \n-(define_insn \"*cmpfp_2u\"\n-  [(set (reg:CCFPU FPSR_REG)\n-\t(compare:CCFPU\n-\t  (match_operand 0 \"register_operand\" \"f\")\n-\t  (match_operand 1 \"register_operand\" \"f\")))]\n-  \"TARGET_80387\n-   && FLOAT_MODE_P (GET_MODE (operands[0]))\n-   && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n-  \"* return output_fp_compare (insn, operands, 0, 1);\"\n-  [(set_attr \"type\" \"fcmp\")\n-   (set (attr \"mode\")\n-     (cond [(match_operand:SF 1 \"\" \"\")\n-\t      (const_string \"SF\")\n-\t    (match_operand:DF 1 \"\" \"\")\n-\t      (const_string \"DF\")\n-\t   ]\n-\t   (const_string \"XF\")))])\n-\n-(define_insn \"*cmpfp_2u_1\"\n+(define_insn \"*cmpfp_u\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n \t  [(compare:CCFPU\n@@ -930,7 +882,7 @@\n   \"TARGET_80387\n    && FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n-  \"* return output_fp_compare (insn, operands, 2, 1);\"\n+  \"* return output_fp_compare (insn, operands, 0, 1);\"\n   [(set_attr \"type\" \"multi\")\n    (set (attr \"mode\")\n      (cond [(match_operand:SF 1 \"\" \"\")\n@@ -940,40 +892,21 @@\n \t   ]\n \t   (const_string \"XF\")))])\n \n-;; Patterns to match the SImode-in-memory ficom instructions.\n-;;\n-;; %%% Play games with accepting gp registers, as otherwise we have to\n-;; force them to memory during rtl generation, which is no good.  We\n-;; can get rid of this once we teach reload to do memory input reloads \n-;; via pushes.\n-\n-(define_insn \"*ficom_1\"\n-  [(set (reg:CCFP FPSR_REG)\n-\t(compare:CCFP\n-\t  (match_operand 0 \"register_operand\" \"f,f\")\n-\t  (float (match_operand:SI 1 \"nonimmediate_operand\" \"m,?r\"))))]\n-  \"0 && TARGET_80387 && FLOAT_MODE_P (GET_MODE (operands[0]))\n-   && GET_MODE (XEXP (SET_SRC (PATTERN (insn)), 1)) == GET_MODE (operands[0])\"\n-  \"#\")\n-\n-;; Split the not-really-implemented gp register case into a\n-;; push-op-pop sequence.\n-;;\n-;; %%% This is most efficient, but am I gonna get in trouble\n-;; for separating cc0_setter and cc0_user?\n-\n-(define_split\n-  [(set (reg:CCFP FPSR_REG)\n-\t(compare:CCFP\n-\t  (match_operand:SF 0 \"register_operand\" \"\")\n-\t  (float (match_operand:SI 1 \"register_operand\" \"\"))))]\n-  \"0 && TARGET_80387 && reload_completed\"\n-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG))) (match_dup 1))\n-   (set (reg:CCFP FPSR_REG) (compare:CCFP (match_dup 0) (match_dup 2)))\n-   (parallel [(set (match_dup 1) (mem:SI (reg:SI SP_REG)))\n-              (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int 4)))])]\n-  \"operands[2] = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n-   operands[2] = gen_rtx_FLOAT (GET_MODE (operands[0]), operands[2]);\")\n+(define_insn \"*cmpfp_si\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(unspec:HI\n+\t  [(compare:CCFP\n+\t     (match_operand 1 \"register_operand\" \"f\")\n+\t     (match_operator 3 \"float_operator\"\n+\t       [(match_operand:SI 2 \"memory_operand\" \"m\")]))]\n+\t  UNSPEC_FNSTSW))]\n+  \"TARGET_80387 && TARGET_USE_FIOP\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && (GET_MODE (operands [3]) == GET_MODE (operands[1]))\"\n+  \"* return output_fp_compare (insn, operands, 0, 0);\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"fp_int_src\" \"true\")\n+   (set_attr \"mode\" \"SI\")])\n \n ;; FP compares, step 2\n ;; Move the fpsw to ax.\n@@ -13298,6 +13231,30 @@\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n+;; The order of operands in *fp_jcc_8 is forced by combine in\n+;; simplify_comparison () function. Float operator is treated as RTX_OBJ\n+;; with a precedence over other operators and is always put in the first\n+;; place. Swap condition and operands to match ficom instruction.\n+\n+(define_insn \"*fp_jcc_8\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operator 1 \"float_operator\"\n+\t\t\t   [(match_operand:SI 2 \"nonimmediate_operand\" \"m,?r\")])\n+\t\t\t   (match_operand 3 \"register_operand\" \"f,f\")])\n+\t  (label_ref (match_operand 4 \"\" \"\"))\n+\t  (pc)))\n+   (clobber (reg:CCFP FPSR_REG))\n+   (clobber (reg:CCFP FLAGS_REG))\n+   (clobber (match_scratch:HI 5 \"=a,a\"))]\n+  \"TARGET_80387 && TARGET_USE_FIOP\n+   && FLOAT_MODE_P (GET_MODE (operands[3]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[3])\n+   && !ix86_use_fcomi_compare (swap_condition (GET_CODE (operands[0])))\n+   && ix86_fp_compare_mode (swap_condition (GET_CODE (operands[0]))) == CCFPmode\n+   && ix86_fp_jump_nontrivial_p (swap_condition (GET_CODE (operands[0])))\"\n+  \"#\")\n+\n (define_split\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n@@ -13311,7 +13268,7 @@\n   [(const_int 0)]\n {\n   ix86_split_fp_branch (GET_CODE (operands[0]), operands[1], operands[2],\n-\t                operands[3], operands[4], NULL_RTX);\n+\t                operands[3], operands[4], NULL_RTX, NULL_RTX);\n   DONE;\n })\n \n@@ -13329,7 +13286,51 @@\n   [(const_int 0)]\n {\n   ix86_split_fp_branch (GET_CODE (operands[0]), operands[1], operands[2],\n-\t     \t\toperands[3], operands[4], operands[5]);\n+\t     \t\toperands[3], operands[4], operands[5], NULL_RTX);\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operator 1 \"float_operator\"\n+\t\t\t   [(match_operand:SI 2 \"memory_operand\" \"\")])\n+\t\t\t   (match_operand 3 \"register_operand\" \"\")])\n+\t  (match_operand 4 \"\" \"\")\n+\t  (match_operand 5 \"\" \"\")))\n+   (clobber (reg:CCFP FPSR_REG))\n+   (clobber (reg:CCFP FLAGS_REG))\n+   (clobber (match_scratch:HI 6 \"=a\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  operands[7] = gen_rtx_FLOAT (GET_MODE (operands[1]), operands[2]);\n+  ix86_split_fp_branch (swap_condition (GET_CODE (operands[0])),\n+\t\t\toperands[3], operands[7],\n+\t\t\toperands[4], operands[5], operands[6], NULL_RTX);\n+  DONE;\n+})\n+\n+;; %%% Kill this when reload knows how to do it.\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operator 1 \"float_operator\"\n+\t\t\t   [(match_operand:SI 2 \"register_operand\" \"\")])\n+\t\t\t   (match_operand 3 \"register_operand\" \"\")])\n+\t  (match_operand 4 \"\" \"\")\n+\t  (match_operand 5 \"\" \"\")))\n+   (clobber (reg:CCFP FPSR_REG))\n+   (clobber (reg:CCFP FLAGS_REG))\n+   (clobber (match_scratch:HI 6 \"=a\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  operands[7] = ix86_force_to_memory (GET_MODE (operands[2]), operands[2]);\n+  operands[7] = gen_rtx_FLOAT (GET_MODE (operands[1]), operands[7]);\n+  ix86_split_fp_branch (swap_condition (GET_CODE (operands[0])),\n+\t\t\toperands[3], operands[7],\n+\t\t\toperands[4], operands[5], operands[6], operands[2]);\n   DONE;\n })\n \f"}, {"sha": "9154aea8c62080776b84535f31e0ed71d51f7305", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82106ff9548634c85fa7cd7f1cc3a906fd6efa/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=7c82106ff9548634c85fa7cd7f1cc3a906fd6efa", "patch": "@@ -795,6 +795,10 @@\n (define_predicate \"div_operator\"\n   (match_code \"div\"))\n \n+;; Return true if this is a float extend operation.\n+(define_predicate \"float_operator\"\n+  (match_code \"float\"))\n+\n ;; Return true for ARITHMETIC_P.\n (define_predicate \"arith_or_logical_operator\"\n   (match_code \"PLUS,MULT,AND,IOR,XOR,SMIN,SMAX,UMIN,UMAX,COMPARE,MINUS,DIV,"}]}