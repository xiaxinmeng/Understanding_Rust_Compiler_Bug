{"sha": "76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZiYjNjNTBkZDQzYTVmODdkNGY5NDljZjBkMDk3OTE0NDU2MmU2Yw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-08-18T09:14:05Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-08-18T09:15:47Z"}, "message": "Fortran/OpenMP: Add memory routines existing for C/C++\n\nThis patch adds the Fortran interface for omp_alloc/omp_free\nand the omp_target_* memory routines, which were added in\nOpenMP 5.0 for C/C++ but only OpenMP 5.1 added them for Fortran.\n\nThose functions use BIND(C), i.e. on the libgomp side, the same\ninterface as for C/C++ is used.\n\nNote: By using BIND(C) in omp_lib.h, files including this file\nno longer compiler with -std=f95 but require at least -std=f2003.\n\nlibgomp/ChangeLog:\n\n\t* omp_lib.f90.in (omp_alloc, omp_free, omp_target_alloc,\n\tomp_target_free. omp_target_is_present, omp_target_memcpy,\n\tomp_target_memcpy_rect, omp_target_associate_ptr,\n\tomp_target_disassociate_ptr): Add interface.\n\t* omp_lib.h.in (omp_alloc, omp_free, omp_target_alloc,\n\tomp_target_free. omp_target_is_present, omp_target_memcpy,\n\tomp_target_memcpy_rect, omp_target_associate_ptr,\n\tomp_target_disassociate_ptr): Add interface.\n\t* testsuite/libgomp.fortran/alloc-1.F90: Remove local\n\tinterface block for omp_alloc + omp_free.\n\t* testsuite/libgomp.fortran/alloc-4.f90: Likewise.\n\t* testsuite/libgomp.fortran/refcount-1.f90: New test.\n\t* testsuite/libgomp.fortran/target-12.f90: New test.", "tree": {"sha": "8d3557f862c38bdb634b9936e6d1d0a7e41b4596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d3557f862c38bdb634b9936e6d1d0a7e41b4596"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5079b7781a2c506dcdfb241347d74c7891268225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5079b7781a2c506dcdfb241347d74c7891268225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5079b7781a2c506dcdfb241347d74c7891268225"}], "stats": {"total": 431, "additions": 399, "deletions": 32}, "files": [{"sha": "a36a562612358ab136730ead71cf8f338be39362", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "patch": "@@ -670,6 +670,100 @@\n           end subroutine omp_display_env_8\n         end interface\n \n+        interface\n+          function omp_alloc (size, allocator) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_size_t\n+            import :: omp_allocator_handle_kind\n+            type(c_ptr) :: omp_alloc\n+            integer(c_size_t), value :: size\n+            integer(omp_allocator_handle_kind), value :: allocator\n+          end function omp_alloc\n+        end interface\n+\n+        interface\n+          subroutine omp_free(ptr, allocator) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr\n+            import :: omp_allocator_handle_kind\n+            type(c_ptr), value :: ptr\n+            integer(omp_allocator_handle_kind), value :: allocator\n+          end subroutine\n+        end interface\n+\n+        interface\n+          function omp_target_alloc (size, device_num) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_size_t, c_int\n+            type(c_ptr) :: omp_target_alloc\n+            integer(c_size_t), value :: size\n+            integer(c_int), value :: device_num\n+          end function omp_target_alloc\n+        end interface\n+\n+        interface\n+          subroutine omp_target_free (device_ptr, device_num) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_int\n+            type(c_ptr), value :: device_ptr\n+            integer(c_int), value :: device_num\n+          end subroutine omp_target_free\n+        end interface\n+\n+        interface\n+          function omp_target_is_present (ptr, device_num) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_int\n+            integer(c_int) :: omp_target_is_present\n+            type(c_ptr), value :: ptr\n+            integer(c_int), value :: device_num\n+          end function omp_target_is_present\n+        end interface\n+\n+        interface\n+          function omp_target_memcpy (dst, src, length, dst_offset, &\n+                                      src_offset, dst_device_num, &\n+                                      src_device_num) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+            integer(c_int) :: omp_target_memcpy\n+            type(c_ptr), value :: dst, src\n+            integer(c_size_t), value :: length, dst_offset, src_offset\n+            integer(c_int), value :: dst_device_num, src_device_num\n+          end function omp_target_memcpy\n+        end interface\n+\n+        interface\n+          function omp_target_memcpy_rect (dst,src,element_size, num_dims, &\n+                                           volume, dst_offsets, src_offsets, &\n+                                           dst_dimensions, src_dimensions, &\n+                                           dst_device_num, src_device_num) &\n+              bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+            integer(c_int) :: omp_target_memcpy_rect\n+            type(c_ptr), value :: dst, src\n+            integer(c_size_t), value :: element_size\n+            integer(c_int), value :: num_dims, dst_device_num, src_device_num\n+            integer(c_size_t), intent(in) :: volume(*), dst_offsets(*),  &\n+                                             src_offsets(*), dst_dimensions(*), &\n+                                             src_dimensions(*)\n+          end function omp_target_memcpy_rect\n+        end interface\n+\n+        interface\n+          function omp_target_associate_ptr (host_ptr, device_ptr, size, &\n+                                             device_offset, device_num) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_size_t, c_int\n+            integer(c_int) :: omp_target_associate_ptr\n+            type(c_ptr), value :: host_ptr, device_ptr\n+            integer(c_size_t), value :: size, device_offset\n+            integer(c_int), value :: device_num\n+          end function omp_target_associate_ptr\n+        end interface\n+\n+        interface\n+          function omp_target_disassociate_ptr (ptr, device_num) bind(c)\n+            use, intrinsic :: iso_c_binding, only : c_ptr, c_int\n+            integer(c_int) :: omp_target_disassociate_ptr\n+            type(c_ptr), value :: ptr\n+            integer(c_int), value :: device_num\n+          end function omp_target_disassociate_ptr\n+        end interface\n+\n #if _OPENMP >= 201811\n !GCC$ ATTRIBUTES DEPRECATED :: omp_get_nested, omp_set_nested\n #endif"}, {"sha": "1c2eacba5548ca3502c6064cc1f936507b91e54b", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "patch": "@@ -271,3 +271,100 @@\n       integer (omp_allocator_handle_kind) omp_get_default_allocator\n \n       external omp_display_env\n+\n+      interface\n+        function omp_alloc (size, allocator) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_size_t\n+          use, intrinsic :: omp_lib_kinds\n+          type(c_ptr) :: omp_alloc\n+          integer(c_size_t), value :: size\n+          integer(omp_allocator_handle_kind), value :: allocator\n+        end function omp_alloc\n+      end interface\n+\n+      interface\n+        subroutine omp_free(ptr, allocator) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr\n+          use, intrinsic :: omp_lib_kinds\n+          type(c_ptr), value :: ptr\n+          integer(omp_allocator_handle_kind), value :: allocator\n+        end subroutine\n+      end interface\n+\n+      interface\n+        function omp_target_alloc (size, device_num) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_size_t, c_int\n+          type(c_ptr) :: omp_target_alloc\n+          integer(c_size_t), value :: size\n+          integer(c_int), value :: device_num\n+        end function omp_target_alloc\n+      end interface\n+\n+      interface\n+        subroutine omp_target_free (device_ptr, device_num) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_int\n+          type(c_ptr), value :: device_ptr\n+          integer(c_int), value :: device_num\n+        end subroutine omp_target_free\n+      end interface\n+\n+      interface\n+        function omp_target_is_present (ptr, device_num) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_int\n+          integer(c_int) :: omp_target_is_present\n+          type(c_ptr), value :: ptr\n+          integer(c_int), value :: device_num\n+        end function omp_target_is_present\n+      end interface\n+\n+      interface\n+        function omp_target_memcpy (dst, src, length, dst_offset,          &\n+     &                              src_offset, dst_device_num,            &\n+     &                              src_device_num) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+          integer(c_int) :: omp_target_memcpy\n+          type(c_ptr), value :: dst, src\n+          integer(c_size_t), value :: length, dst_offset, src_offset\n+          integer(c_int), value :: dst_device_num, src_device_num\n+        end function omp_target_memcpy\n+      end interface\n+\n+      interface\n+        function omp_target_memcpy_rect (dst,src,element_size, num_dims,   &\n+     &                                   volume, dst_offsets,              &\n+     &                                   src_offsets, dst_dimensions,      &\n+     &                                   src_dimensions, dst_device_num,   &\n+     &                                   src_device_num) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_int, c_size_t\n+          integer(c_int) :: omp_target_memcpy_rect\n+          type(c_ptr), value :: dst, src\n+          integer(c_size_t), value :: element_size\n+          integer(c_int), value :: num_dims\n+          integer(c_int), value :: dst_device_num, src_device_num\n+          integer(c_size_t), intent(in) :: volume(*), dst_offsets(*)\n+          integer(c_size_t), intent(in) :: src_offsets(*)\n+          integer(c_size_t), intent(in) :: dst_dimensions(*)\n+          integer(c_size_t), intent(in) :: src_dimensions(*)\n+        end function omp_target_memcpy_rect\n+      end interface\n+\n+      interface\n+        function omp_target_associate_ptr (host_ptr, device_ptr, size,     &\n+     &                                     device_offset, device_num)      &\n+     &      bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_size_t, c_int\n+          integer(c_int) :: omp_target_associate_ptr\n+          type(c_ptr), value :: host_ptr, device_ptr\n+          integer(c_size_t), value :: size, device_offset\n+          integer(c_int), value :: device_num\n+        end function omp_target_associate_ptr\n+      end interface\n+\n+      interface\n+        function omp_target_disassociate_ptr (ptr, device_num) bind(c)\n+          use, intrinsic :: iso_c_binding, only : c_ptr, c_int\n+          integer(c_int) :: omp_target_disassociate_ptr\n+          type(c_ptr), value :: ptr\n+          integer(c_int), value :: device_num\n+        end function omp_target_disassociate_ptr\n+      end interface"}, {"sha": "e636583198473e4cb56d69a640fc75ff41da9fa3", "filename": "libgomp/testsuite/libgomp.fortran/alloc-1.F90", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-1.F90?ref=76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "patch": "@@ -36,22 +36,6 @@ program main\n \n         type (omp_alloctrait), allocatable :: traits(:), traits5(:)\n \n-        interface\n-          ! omp_alloc + omp_free part of OpenMP for C/C++\n-          ! but not (yet) in the OpenMP spec for Fortran\n-          type(c_ptr) function omp_alloc (size, handle) bind(C)\n-            import\n-            integer (c_size_t), value :: size\n-            integer (omp_allocator_handle_kind), value :: handle\n-          end function\n-\n-          subroutine omp_free (ptr, handle) bind(C)\n-            import\n-            type (c_ptr), value :: ptr\n-            integer (omp_allocator_handle_kind), value :: handle\n-          end subroutine\n-        end interface\n-\n         type(c_ptr), volatile :: cp, cq, cr\n         integer :: i\n         integer(c_intptr_t) :: intptr"}, {"sha": "87b6adda645cbd8a1e6e979aacaee243d6a23f84", "filename": "libgomp/testsuite/libgomp.fortran/alloc-4.f90", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Falloc-4.f90?ref=76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "patch": "@@ -3,22 +3,6 @@ program main\n   use ISO_C_Binding\n   implicit none (external, type)\n \n-  interface\n-    ! omp_alloc + omp_free part of OpenMP for C/C++\n-    ! but not (yet) in the OpenMP spec for Fortran\n-    type(c_ptr) function omp_alloc (size, handle) bind(C)\n-      import\n-      integer (c_size_t), value :: size\n-      integer (omp_allocator_handle_kind), value :: handle\n-    end function\n-\n-    subroutine omp_free (ptr, handle) bind(C)\n-      import\n-      type (c_ptr), value :: ptr\n-      integer (omp_allocator_handle_kind), value :: handle\n-    end subroutine\n-  end interface\n-\n   type (omp_alloctrait) :: traits(3)\n   integer (omp_allocator_handle_kind) :: a\n "}, {"sha": "e3b9d04af8138a53ccbfff5033aa3e115c8dc591", "filename": "libgomp/testsuite/libgomp.fortran/refcount-1.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frefcount-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frefcount-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frefcount-1.f90?ref=76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "patch": "@@ -0,0 +1,61 @@\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none (type, external)\n+\n+  integer :: d, id\n+  integer(kind=1), target :: a(4)\n+  integer(kind=1), pointer :: p, q\n+\n+  d = omp_get_default_device ()\n+  id = omp_get_initial_device ()\n+\n+  if (d < 0 .or. d >= omp_get_num_devices ()) &\n+    d = id\n+\n+  a = transfer (int(z'cdcdcdcd'), mold=a)\n+\n+  !$omp target enter data map (to:a)\n+\n+  a = transfer (int(z'abababab'), mold=a)\n+  p => a(1)\n+  q => a(3)\n+\n+  !$omp target enter data map (alloc:p, q)\n+\n+  if (d /= id) then\n+    if (omp_target_is_present (c_loc(a), d) == 0) &\n+      stop 1\n+    if (omp_target_is_present (c_loc(p), d) == 0) &\n+      stop 2\n+    if (omp_target_is_present (c_loc(q), d) == 0) &\n+      stop 3\n+  end if\n+\n+  !$omp target exit data map (release:a)\n+\n+    if (d /= id) then\n+      if (omp_target_is_present (c_loc(a), d) == 0) &\n+        stop 4\n+      if (omp_target_is_present (c_loc(p), d) == 0) &\n+        stop 5\n+      if (omp_target_is_present (c_loc(q), d) == 0) &\n+        stop 6\n+    end if\n+\n+  !$omp target exit data map (from:q)\n+\n+    if (d /= id) then\n+      if (omp_target_is_present (c_loc(a), d) /= 0) &\n+        stop 7\n+      if (omp_target_is_present (c_loc(p), d) /= 0) &\n+        stop 8\n+      if (omp_target_is_present (c_loc(q), d) /= 0) &\n+        stop 9\n+\n+      if (q /= int(z'cd', kind=1)) &\n+        stop 10\n+      if (p /= int(z'ab', kind=1)) &\n+        stop 11\n+    end if\n+end program main"}, {"sha": "17c78f18f9b6fd3af5e5f1749d27ab689b692178", "filename": "libgomp/testsuite/libgomp.fortran/target-12.f90", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bb3c50dd43a5f87d4f949cf0d0979144562e6c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-12.f90?ref=76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "patch": "@@ -0,0 +1,147 @@\n+program main\n+  use omp_lib\n+  use iso_c_binding\n+  implicit none (external, type)\n+  integer :: d, id, i, j, k, l\n+  logical :: err\n+  integer, target :: q(0:127)\n+  type(c_ptr) :: p\n+\n+  integer(kind=c_size_t) :: volume(0:2)\n+  integer(kind=c_size_t) :: dst_offsets(0:2)\n+  integer(kind=c_size_t) :: src_offsets(0:2)\n+  integer(kind=c_size_t) :: dst_dimensions(0:2)\n+  integer(kind=c_size_t) :: src_dimensions(0:2)\n+  integer(kind=c_size_t) :: empty(1:0)\n+\n+  err = .false.\n+  d = omp_get_default_device ()\n+  id = omp_get_initial_device ()\n+\n+  if (d < 0 .or. d >= omp_get_num_devices ()) &\n+    d = id\n+\n+  q = [(i, i = 0, 127)]\n+  p = omp_target_alloc (130 * c_sizeof (q), d)\n+  if (.not. c_associated (p)) &\n+    stop 0  ! okay\n+\n+  if (omp_target_memcpy_rect (C_NULL_PTR, C_NULL_PTR, 0_c_size_t, 0, &\n+                              empty, empty, empty, empty,  empty, d, id) < 3 &\n+      .or. omp_target_memcpy_rect (C_NULL_PTR, C_NULL_PTR, 0_c_size_t, 0, &\n+                                   empty, empty, empty, empty, empty, &\n+                                   id, d) < 3 &\n+      .or. omp_target_memcpy_rect (C_NULL_PTR, C_NULL_PTR, 0_c_size_t, 0, &\n+                                   empty, empty, empty, empty, empty, &\n+                                   id, id) < 3) &\n+    stop 1\n+\n+  if (omp_target_associate_ptr (c_loc (q), p, 128 * c_sizeof (q(0)), &\n+                                c_sizeof (q(0)), d) == 0) then\n+    volume = [ 128, 0, 0 ]\n+    dst_offsets = [ 0, 0, 0 ]\n+    src_offsets = [ 1, 0, 0 ]\n+    dst_dimensions = [ 128, 0, 0 ]\n+    src_dimensions = [ 128, 0, 0 ]\n+\n+\n+    if (omp_target_associate_ptr (c_loc (q), p, 128 * sizeof (q(0)), &\n+                                  sizeof (q(0)), d) /= 0) &\n+      stop 2\n+\n+    if (omp_target_is_present (c_loc (q), d) /= 1 &\n+        .or. omp_target_is_present (c_loc (q(32)), d) /= 1 &\n+        .or. omp_target_is_present (c_loc (q(127)), d) /= 1) &\n+      stop 3\n+\n+    if (omp_target_memcpy (p, c_loc (q), 128 * sizeof (q(0)), sizeof (q(0)), &\n+                           0_c_size_t, d, id) /= 0) &\n+      stop 4\n+\n+    i = 0\n+    if (d >= 0) i = d\n+    !$omp target if (d >= 0) device (i) map(alloc:q(0:31)) map(from:err)\n+      err = .false.\n+      do j = 0, 127\n+        if (q(j) /= j) then\n+          err = .true.\n+        else\n+          q(j) = q(j) + 4\n+        end if\n+      end do\n+    !$omp end target\n+\n+    if (err) &\n+      stop 5\n+\n+    if (omp_target_memcpy_rect (c_loc (q), p, sizeof (q(0)), 1, volume, &\n+                                dst_offsets, src_offsets, dst_dimensions, &\n+                                src_dimensions, id, d) /= 0) &\n+      stop 6\n+\n+    do i = 0, 127\n+      if (q(i) /= i + 4) &\n+        stop 7\n+    end do\n+\n+    volume(2) = 2\n+    volume(1) = 3\n+    volume(0) = 6\n+    dst_offsets(2) = 1\n+    dst_offsets(1) = 0\n+    dst_offsets(0) = 0\n+    src_offsets(2) = 1\n+    src_offsets(1) = 0\n+    src_offsets(0) = 3\n+    dst_dimensions(2) = 2\n+    dst_dimensions(1) = 3\n+    dst_dimensions(0) = 6\n+    src_dimensions(2) = 3\n+    src_dimensions(1) = 4\n+    src_dimensions(0) = 6\n+\n+    if (omp_target_memcpy_rect (p, c_loc (q), sizeof (q(0)), 3, volume, &\n+                                dst_offsets, src_offsets, dst_dimensions, &\n+                                src_dimensions, d, id) /= 0) &\n+      stop 8\n+\n+    i = 0\n+    if (d >= 0) i = d\n+    !$omp target if (d >= 0) device (i) map(alloc:q(1:32)) map(from:err)\n+      err = .false.\n+      do j = 0, 5\n+        do k = 0, 2\n+          do l = 0, 1\n+            if (q(j * 6 + k * 2 + l) /= 3 * 12 + 4 + 1 + l + k * 3 + j * 12) &\n+              err = .true.\n+          end do\n+        end do\n+      end do\n+    !$omp end target\n+\n+    if (err) &\n+      stop 9\n+ \n+    if (omp_target_memcpy (p, p, 10 * sizeof (q(1)), 51 * sizeof (q(1)), &\n+                           111 * sizeof (q(1)), d, d) /= 0) &\n+      stop 10\n+\n+    i = 0\n+    if (d >= 0) i = d\n+    !$omp target if (d >= 0) device (i) map(alloc:q(0:31)) map(from:err)\n+      err = .false.\n+      do j = 1, 9\n+        if (q(50+j) /= q(110 + j)) & \n+          err = .true.\n+      end do\n+    !$omp end target\n+\n+    if (err) &\n+      stop 11\n+\n+    if (omp_target_disassociate_ptr (c_loc (q), d) /= 0) &\n+      stop 12\n+  end if\n+\n+  call omp_target_free (p, d)\n+end program main"}]}