{"sha": "cf5f6f140926446028b057b4f894b30c1cec57db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y1ZjZmMTQwOTI2NDQ2MDI4YjA1N2I0Zjg5NGIzMGMxY2VjNTdkYg==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1994-02-04T16:29:24Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1994-02-04T16:29:24Z"}, "message": "Made -mshort-data- unsigned.  Copy MEM_IN_STRUCT_P for block move cases.\n\nFrom-SVN: r6481", "tree": {"sha": "0dcbeaaf398f61f7f865f46ad67f06e3c2175b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dcbeaaf398f61f7f865f46ad67f06e3c2175b34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf5f6f140926446028b057b4f894b30c1cec57db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5f6f140926446028b057b4f894b30c1cec57db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf5f6f140926446028b057b4f894b30c1cec57db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5f6f140926446028b057b4f894b30c1cec57db/comments", "author": null, "committer": null, "parents": [{"sha": "2d257716a91a58e3c957060f281a73eae4528adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d257716a91a58e3c957060f281a73eae4528adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d257716a91a58e3c957060f281a73eae4528adf"}], "stats": {"total": 48, "additions": 32, "deletions": 16}, "files": [{"sha": "766dfcad87209188d4ce112c6f97822230b5305d", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5f6f140926446028b057b4f894b30c1cec57db/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5f6f140926446028b057b4f894b30c1cec57db/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=cf5f6f140926446028b057b4f894b30c1cec57db", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@mcc.com)\n    Enhanced by Michael Meissner (meissner@osf.org)\n-   Version 2 port by Tom Wood (Tom_Wood@NeXT.com)\n+   Version 2 port by Tom Wood (twood@pets.sps.mot.com)\n \n This file is part of GNU CC.\n \n@@ -47,27 +47,26 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.3.3.2 12/16/92 08:26:06\";\n-static char tm_sccs_id [] = TM_SCCS_ID;\n+static char out_rcs_id[] = \"$What: <@(#) m88k.c,v\t1.8> $\";\n+static char tm_rcs_id [] = TM_RCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n char *m88k_short_data;\n char *m88k_version;\n char m88k_volatile_code;\n \n-int m88k_gp_threshold;\n+unsigned m88k_gp_threshold = 0;\n int m88k_prologue_done\t= 0;\t/* Ln directives can now be emitted */\n int m88k_function_number = 0;\t/* Counter unique to each function */\n int m88k_fp_offset\t= 0;\t/* offset of frame pointer if used */\n int m88k_stack_size\t= 0;\t/* size of allocated stack (including frame) */\n int m88k_case_index;\n-int m88k_version_0300;\t\t/* Version is at least 03.00 */\n \n rtx m88k_compare_reg;\t\t/* cmp output pseudo register */\n rtx m88k_compare_op0;\t\t/* cmpsi operand 0 */\n rtx m88k_compare_op1;\t\t/* cmpsi operand 1 */\n \n-enum attr_cpu m88k_cpu;\t\t/* target cpu */\n+enum processor_type m88k_cpu;\t/* target cpu */\n \f\n /* Determine what instructions are needed to manufacture the integer VALUE\n    in the given MODE.  */\n@@ -356,7 +355,7 @@ legitimize_address (pic, orig, reg, scratch)\n \n \t  if (GET_CODE (addr) == CONST_INT)\n \t    {\n-\t      if (SMALL_INT (addr))\n+\t      if (ADD_INT (addr))\n \t\treturn plus_constant_for_output (base, INTVAL (addr));\n \t      else if (! reload_in_progress && ! reload_completed)\n \t\taddr = force_reg (Pmode, addr);\n@@ -491,9 +490,9 @@ expand_block_move (dest_mem, src_mem, operands)\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n   int target = (int) m88k_cpu;\n \n-  assert (CPU_M88100 == 0);\n-  assert (CPU_M88110 == 1);\n-  assert (CPU_M88000 == 2);\n+  assert (PROCESSOR_M88100 == 0);\n+  assert (PROCESSOR_M88110 == 1);\n+  assert (PROCESSOR_M88000 == 2);\n \n   if (constp && bytes <= 0)\n     return;\n@@ -590,7 +589,7 @@ block_move_loop (dest, dest_mem, src, src_mem, size, align)\n \t\t\t\toffset_rtx));\n   RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n   MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n-  MEM_IN_STRUCT_P (value_rtx) = 1;\n+  MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n \n   emit_insn (gen_call_movstrsi_loop\n \t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n@@ -647,7 +646,7 @@ block_move_no_loop (dest, dest_mem, src, src_mem, size, align)\n \t\t\t\toffset_rtx));\n   RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n   MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n-  MEM_IN_STRUCT_P (value_rtx) = 1;\n+  MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n \n   value_reg = ((((most - (size - remainder)) / align) & 1) == 0\n \t       ? (align == 8 ? 6 : 5) : 4);\n@@ -720,7 +719,7 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n \t\t\t\t   gen_rtx (CONST_INT, SImode, offset_ld)));\n \t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n \t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n-\t  MEM_IN_STRUCT_P (srcp) = 1;\n+\t  MEM_IN_STRUCT_P (srcp) = MEM_IN_STRUCT_P (src_mem);\n \t  emit_insn (gen_rtx (SET, VOIDmode, temp[next], srcp));\n \t  offset_ld += amount[next];\n \t  active[next] = TRUE;\n@@ -735,7 +734,7 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n \t\t\t\t   gen_rtx (CONST_INT, SImode, offset_st)));\n \t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dest_mem);\n \t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dest_mem);\n-\t  MEM_IN_STRUCT_P (dstp) = 1;\n+\t  MEM_IN_STRUCT_P (dstp) = MEM_IN_STRUCT_P (dest_mem);\n \t  emit_insn (gen_rtx (SET, VOIDmode, dstp, temp[phase]));\n \t  offset_st += amount[phase];\n \t}\n@@ -1553,7 +1552,7 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n \n   ASM_FIRST_LINE (file);\n   if (TARGET_88110\n-      && m88k_version != 0 && strcmp (m88k_version, \"04.00\") >= 0)\n+      && TARGET_SVR4)\n     fprintf (file, \"\\t%s\\n\", REQUIRES_88110_ASM_OP);\n   output_file_directive (file, main_input_filename);\n   /* Switch to the data section so that the coffsem symbol and the\n@@ -2608,7 +2607,7 @@ m88k_builtin_saveregs (arglist)\n \t change_address (addr, Pmode,\n \t\t\t plus_constant (XEXP (addr, 0),\n \t\t\t\t\tfixed * UNITS_PER_WORD)),\n-\t 8 - fixed, (8 - fixed) * UNITS_PER_WORD);\n+\t 8 - fixed, UNITS_PER_WORD * (8 - fixed));\n \n   /* Return the address of the va_list constructor, but don't put it in a\n      register.  This fails when not optimizing and produces worse code when\n@@ -3071,3 +3070,20 @@ print_operand_address (file, addr)\n \t  output_addr_const (file, addr);\n     }\n }\n+\n+/* Return true if X is an address which needs a temporary register when \n+   reloaded while generating PIC code.  */\n+\n+int\n+pic_address_needs_scratch (x)\n+     rtx x;\n+{\n+  /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && ! ADD_INT (XEXP (XEXP (x, 0), 1)))\n+    return 1;\n+\n+  return 0;\n+}"}]}