{"sha": "105ebae827e8010966ddbd0f9ec8d877556565a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1ZWJhZTgyN2U4MDEwOTY2ZGRiZDBmOWVjOGQ4Nzc1NTY1NjVhMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2006-08-11T19:01:45Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-08-11T19:01:45Z"}, "message": "re PR rtl-optimization/23454 (ICE in invert_exp_1, at jump.c:1719)\n\n\tPR rtl-optimization/23454\n\t* reorg.c (relax_delay_slots): Update comment.\n\nFrom-SVN: r116088", "tree": {"sha": "8bbc42670a63b0e73732b6709a797d2a1c9b26a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bbc42670a63b0e73732b6709a797d2a1c9b26a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/105ebae827e8010966ddbd0f9ec8d877556565a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105ebae827e8010966ddbd0f9ec8d877556565a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105ebae827e8010966ddbd0f9ec8d877556565a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105ebae827e8010966ddbd0f9ec8d877556565a3/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e571cd5ac1c1257066fa52c4ad19534777a371a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e571cd5ac1c1257066fa52c4ad19534777a371a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e571cd5ac1c1257066fa52c4ad19534777a371a"}], "stats": {"total": 125, "additions": 120, "deletions": 5}, "files": [{"sha": "f90de87e9bc3bea7debd9e1bbbad1bb9d4f332c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=105ebae827e8010966ddbd0f9ec8d877556565a3", "patch": "@@ -1,3 +1,8 @@\n+2006-08-11  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR rtl-optimization/23454\n+\t* reorg.c (relax_delay_slots): Update comment.\n+\n 2006-08-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/28651"}, {"sha": "42ecda0db4cba7bf94fed5473de225b6a04f711a", "filename": "gcc/reorg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=105ebae827e8010966ddbd0f9ec8d877556565a3", "patch": "@@ -3327,11 +3327,11 @@ relax_delay_slots (rtx first)\n \t  continue;\n \t}\n \n-      /* See if this jump (with its delay slots) branches around another\n-\t jump (without delay slots).  If so, invert this jump and point\n-\t it to the target of the second jump.  We cannot do this for\n-\t annulled jumps, though.  Again, don't convert a jump to a RETURN\n-\t here.  */\n+      /* See if this jump (with its delay slots) conditionally branches\n+\t around an unconditional jump (without delay slots).  If so, invert\n+\t this jump and point it to the target of the second jump.  We cannot\n+\t do this for annulled jumps, though.  Again, don't convert a jump to\n+\t a RETURN here.  */\n       if (! INSN_ANNULLED_BRANCH_P (delay_insn)\n \t  && any_condjump_p (delay_insn)\n \t  && next && JUMP_P (next)"}, {"sha": "07bd03df1685a67f3558e21dce67f32b72432526", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=105ebae827e8010966ddbd0f9ec8d877556565a3", "patch": "@@ -1,3 +1,7 @@\n+2006-08-11  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* g++.dg/opt/pr23454-2.C: New test.\n+\n 2006-08-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/28651"}, {"sha": "bd5e9e99b14615c40e0569acad9b5e6e3b7d3ae9", "filename": "gcc/testsuite/g++.dg/opt/pr23454-2.C", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr23454-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105ebae827e8010966ddbd0f9ec8d877556565a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr23454-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr23454-2.C?ref=105ebae827e8010966ddbd0f9ec8d877556565a3", "patch": "@@ -0,0 +1,106 @@\n+/* PR rtl-optimization/23454 */\n+/* Submitted by Matthias Klose <doko@debian.org> */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+typedef unsigned long long int ulonglong;\n+typedef long long int longlong;\n+typedef unsigned int uint32;\n+typedef unsigned int uint;\n+typedef unsigned long int ulong;\n+\n+class Item {\n+public:\n+  bool null_value;\n+  virtual longlong val_int()=0;\n+};\n+\n+typedef struct st_tree_element {\n+  struct st_tree_element *left,*right;\n+  uint32 count;\n+} TREE_ELEMENT;\n+\n+typedef struct st_tree {\n+  uint offset_to_key,elements_in_tree,size_of_element,memory_limit,allocated;\n+  void *custom_arg;\n+  bool with_delete;\n+  uint flag;\n+} TREE;\n+\n+class field_info\n+{\n+public:\n+  ulong treemem, tree_elements, empty, nulls, min_length, max_length;\n+  uint room_in_tree;\n+  bool found;\n+  TREE tree;\n+  Item *item;\n+};\n+\n+class field_ulonglong: public field_info\n+{\n+  ulonglong min_arg, max_arg;\n+  ulonglong sum, sum_sqr;\n+  void add();\n+};\n+\n+extern char *longlong10_to_str(longlong val,char *dst,int radix);\n+extern void delete_tree(TREE*);\n+extern TREE_ELEMENT *tree_insert(TREE *tree,void *custom_arg);\n+\n+static int compare_ulonglong(const ulonglong *s, const ulonglong *t)\n+{\n+  return ((*s < *t) ? -1 : *s > *t ? 1 : 0);\n+}\n+\n+void field_ulonglong::add()\n+{\n+  char buff[(255*3 +1)];\n+  longlong num = item->val_int();\n+  uint length = (uint) (longlong10_to_str(num, buff, 10) - buff);\n+  TREE_ELEMENT *element;\n+\n+  if (item->null_value)\n+  {\n+    nulls++;\n+    return;\n+  }\n+  if (num == 0)\n+    empty++;\n+\n+  if (room_in_tree)\n+  {\n+    if (!(element = tree_insert(&tree, tree.custom_arg)))\n+    {\n+      room_in_tree = 0;\n+      delete_tree(&tree);\n+    }\n+    else if (element->count == 1)\n+    {\n+      room_in_tree = 0;\n+      delete_tree(&tree);\n+    }\n+  }\n+\n+  if (!found)\n+  {\n+    found = 1;\n+    min_arg = max_arg = sum = num;\n+    sum_sqr = num * num;\n+    min_length = max_length = length;\n+  }\n+  else if (num != 0)\n+  {\n+    sum += num;\n+    sum_sqr += num * num;\n+    if (length < min_length)\n+      min_length = length;\n+    if (length > max_length)\n+      max_length = length;\n+    if (compare_ulonglong((ulonglong*) &num, &min_arg) < 0)\n+      min_arg = num;\n+    if (compare_ulonglong((ulonglong*) &num, &max_arg) > 0)\n+      max_arg = num;\n+  }\n+}"}]}