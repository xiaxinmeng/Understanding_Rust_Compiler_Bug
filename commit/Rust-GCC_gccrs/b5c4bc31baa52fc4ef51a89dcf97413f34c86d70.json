{"sha": "b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjNGJjMzFiYWE1MmZjNGVmNTFhODlkY2Y5NzQxM2YzNGM4NmQ3MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-12-22T19:42:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-12-22T19:42:31Z"}, "message": "Give EH_ELSE access to __builtin_eh_pointer\n\nThe must-not-throw wrapper for protect_cleanup_actions gets in\nthe way of being able to access __builtin_eh_pointer without\nconfusion as the identit of the exception to which we are\nreferring (b_eh_p has no usable argument up to this point).\n\nSince EH_ELSE never comes from user derived code, let's drop\nthe c++ specific wrapping.\n\n\t* tree-eh.c (honor_protect_cleanup_actions): Do not wrap\n\teh_else in a must-not-throw; set ehp_region for it too.\n\nFrom-SVN: r231908", "tree": {"sha": "927d28dc4e38d092d69634d784469cfb7fa7aa5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/927d28dc4e38d092d69634d784469cfb7fa7aa5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70/comments", "author": null, "committer": null, "parents": [{"sha": "7c11b0fef088480510a74f0f43015776c40be047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c11b0fef088480510a74f0f43015776c40be047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c11b0fef088480510a74f0f43015776c40be047"}], "stats": {"total": 100, "additions": 52, "deletions": 48}, "files": [{"sha": "473119a629f458adcf6797d8562454bddd8278d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "patch": "@@ -33,6 +33,9 @@\n \t(ipa_tm_scan_calls_transaction): ... not here.\n \t(ipa_uninstrument_transaction): Remove.\n \n+\t* tree-eh.c (honor_protect_cleanup_actions): Do not wrap eh_else\n+\tin a must-not-throw; set ehp_region for it too.\n+\n 2015-12-22  Peter Bergner  <bergner@vnet.ibm.com>\n \n \tPR target/68772"}, {"sha": "5552fc178abd737e714c21d9478f4f4515bef7ca", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "patch": "@@ -986,64 +986,65 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n \t\t\t       struct leh_state *this_state,\n \t\t\t       struct leh_tf_state *tf)\n {\n-  tree protect_cleanup_actions;\n-  gimple_stmt_iterator gsi;\n-  bool finally_may_fallthru;\n-  gimple_seq finally;\n-  gimple *x;\n-  geh_mnt *eh_mnt;\n-  gtry *try_stmt;\n-  geh_else *eh_else;\n-\n-  /* First check for nothing to do.  */\n-  if (lang_hooks.eh_protect_cleanup_actions == NULL)\n-    return;\n-  protect_cleanup_actions = lang_hooks.eh_protect_cleanup_actions ();\n-  if (protect_cleanup_actions == NULL)\n-    return;\n-\n-  finally = gimple_try_cleanup (tf->top_p);\n-  eh_else = get_eh_else (finally);\n+  gimple_seq finally = gimple_try_cleanup (tf->top_p);\n \n-  /* Duplicate the FINALLY block.  Only need to do this for try-finally,\n-     and not for cleanups.  If we've got an EH_ELSE, extract it now.  */\n-  if (eh_else)\n+  /* EH_ELSE doesn't come from user code; only compiler generated stuff.\n+     It does need to be handled here, so as to separate the (different)\n+     EH path from the normal path.  But we should not attempt to wrap\n+     it with a must-not-throw node (which indeed gets in the way).  */\n+  if (geh_else *eh_else = get_eh_else (finally))\n     {\n-      finally = gimple_eh_else_e_body (eh_else);\n       gimple_try_set_cleanup (tf->top_p, gimple_eh_else_n_body (eh_else));\n+      finally = gimple_eh_else_e_body (eh_else);\n+\n+      /* Let the ELSE see the exception that's being processed.  */\n+      eh_region save_ehp = this_state->ehp_region;\n+      this_state->ehp_region = this_state->cur_region;\n+      lower_eh_constructs_1 (this_state, &finally);\n+      this_state->ehp_region = save_ehp;\n     }\n-  else if (this_state)\n-    finally = lower_try_finally_dup_block (finally, outer_state,\n-\tgimple_location (tf->try_finally_expr));\n-  finally_may_fallthru = gimple_seq_may_fallthru (finally);\n-\n-  /* If this cleanup consists of a TRY_CATCH_EXPR with TRY_CATCH_IS_CLEANUP\n-     set, the handler of the TRY_CATCH_EXPR is another cleanup which ought\n-     to be in an enclosing scope, but needs to be implemented at this level\n-     to avoid a nesting violation (see wrap_temporary_cleanups in\n-     cp/decl.c).  Since it's logically at an outer level, we should call\n-     terminate before we get to it, so strip it away before adding the\n-     MUST_NOT_THROW filter.  */\n-  gsi = gsi_start (finally);\n-  x = gsi_stmt (gsi);\n-  if (gimple_code (x) == GIMPLE_TRY\n-      && gimple_try_kind (x) == GIMPLE_TRY_CATCH\n-      && gimple_try_catch_is_cleanup (x))\n+  else\n     {\n-      gsi_insert_seq_before (&gsi, gimple_try_eval (x), GSI_SAME_STMT);\n-      gsi_remove (&gsi, false);\n-    }\n+      /* First check for nothing to do.  */\n+      if (lang_hooks.eh_protect_cleanup_actions == NULL)\n+\treturn;\n+      tree actions = lang_hooks.eh_protect_cleanup_actions ();\n+      if (actions == NULL)\n+\treturn;\n+\n+      if (this_state)\n+\tfinally = lower_try_finally_dup_block (finally, outer_state,\n+\t  gimple_location (tf->try_finally_expr));\n+\n+      /* If this cleanup consists of a TRY_CATCH_EXPR with TRY_CATCH_IS_CLEANUP\n+\t set, the handler of the TRY_CATCH_EXPR is another cleanup which ought\n+\t to be in an enclosing scope, but needs to be implemented at this level\n+\t to avoid a nesting violation (see wrap_temporary_cleanups in\n+\t cp/decl.c).  Since it's logically at an outer level, we should call\n+\t terminate before we get to it, so strip it away before adding the\n+\t MUST_NOT_THROW filter.  */\n+      gimple_stmt_iterator gsi = gsi_start (finally);\n+      gimple *x = gsi_stmt (gsi);\n+      if (gimple_code (x) == GIMPLE_TRY\n+\t  && gimple_try_kind (x) == GIMPLE_TRY_CATCH\n+\t  && gimple_try_catch_is_cleanup (x))\n+\t{\n+\t  gsi_insert_seq_before (&gsi, gimple_try_eval (x), GSI_SAME_STMT);\n+\t  gsi_remove (&gsi, false);\n+\t}\n \n-  /* Wrap the block with protect_cleanup_actions as the action.  */\n-  eh_mnt = gimple_build_eh_must_not_throw (protect_cleanup_actions);\n-  try_stmt = gimple_build_try (finally, gimple_seq_alloc_with_stmt (eh_mnt),\n-\t\t\t       GIMPLE_TRY_CATCH);\n-  finally = lower_eh_must_not_throw (outer_state, try_stmt);\n+      /* Wrap the block with protect_cleanup_actions as the action.  */\n+      geh_mnt *eh_mnt = gimple_build_eh_must_not_throw (actions);\n+      gtry *try_stmt = gimple_build_try (finally,\n+\t\t\t\t\t gimple_seq_alloc_with_stmt (eh_mnt),\n+\t\t\t\t\t GIMPLE_TRY_CATCH);\n+      finally = lower_eh_must_not_throw (outer_state, try_stmt);\n+    }\n \n   /* Drop all of this into the exception sequence.  */\n   emit_post_landing_pad (&eh_seq, tf->region);\n   gimple_seq_add_seq (&eh_seq, finally);\n-  if (finally_may_fallthru)\n+  if (gimple_seq_may_fallthru (finally))\n     emit_resx (&eh_seq, tf->region);\n \n   /* Having now been handled, EH isn't to be considered with"}]}