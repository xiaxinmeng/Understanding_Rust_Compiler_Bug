{"sha": "d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJkNGIzNTU2ZDRmOGI3YzMyZGU4MDlmMDIzYWM4NzZjZDhjYWU4Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T13:23:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T13:23:52Z"}, "message": "[multiple changes]\n\n2011-11-21  Tristan Gingold  <gingold@adacore.com>\n\n\t* env.c: Remove unused declaration.\n\n2011-11-21  Pascal Obry  <obry@adacore.com>\n\n\t* s-os_lib.ads: Minor style fix.\n\n2011-11-21  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.c (__gnat_dup2): When fd are stdout, stdin or stderr and\n\tidentical, do nothing on Windows XP.\n\n2011-11-21  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch3.adb (Constrain_Index, Process_Range_Expr_In_Decl):\n\tUse Full_Expander_Active instead of Expander_Active to control\n\tthe forced evaluation of expressions for the sake of generating\n\tchecks.\n\n2011-11-21  Thomas Quinot  <quinot@adacore.com>\n\n\t* init.c: On FreeBSD, stack checking failures may raise SIGBUS.\n\n2011-11-21  Tristan Gingold  <gingold@adacore.com>\n\n\t* sysdep.c (mode_read_text, mode_write_text, mode_append_text,\n\tmode_read_binary, mode_write_binary, mode_append_binary,\n\tmode_read_text_plus, mode_write_text_plus, mode_append_text_plus,\n\tmode_read_binary_plus, mode_write_binary_plus,\n\tmode_append_binary_plus): Remove unused declarations.\n\n2011-11-21  Yannick Moy  <moy@adacore.com>\n\n\t* gnat_rm.texi: Minor rewording.\n\n2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_imgv.adb (Expand_Width_Attribute): Emit\n\tan error message rather than a warning when pragma Discard_Names\n\tprevents the computation of 'Width. Do not emit an error through\n\tthe use of RE_Null.\n\n2011-11-21  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Allocator): Add\n\timplicit type conversion when the type of the allocator is an\n\tinterface. Done to force generation of displacement of the \"this\"\n\tpointer when required.\n\n2011-11-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sinfo.ads, sinfo.adb: Corresponding_Spec applies to expression\n\tfunctions, and is set when the expression is a completion of a\n\tprevious declaration.\n\t* sem_ch6.adb (Analyze_Expression_Function): To determine properly\n\twhether an expression function completes a previous declaration,\n\tuse Find_Corresponding_Spec, as when analyzing a subprogram body.\n\n2011-11-21  Steve Baird  <baird@adacore.com>\n\n\t* sem_util.adb (Deepest_Type_Access_Level): Improve comment.\n\t(Type_Access_Level): Improve comment.\n\nFrom-SVN: r181575", "tree": {"sha": "9b0dcdac8dae1e481bd247ca6ee57115b2baef80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b0dcdac8dae1e481bd247ca6ee57115b2baef80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/comments", "author": null, "committer": null, "parents": [{"sha": "08ef33f5eb7a65662d296670845600ed57fb6015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ef33f5eb7a65662d296670845600ed57fb6015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08ef33f5eb7a65662d296670845600ed57fb6015"}], "stats": {"total": 273, "additions": 157, "deletions": 116}, "files": [{"sha": "8549dd1d2643b7486840b26cbc4b83cd5f0ad665", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -1,3 +1,67 @@\n+2011-11-21  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* env.c: Remove unused declaration.\n+\n+2011-11-21  Pascal Obry  <obry@adacore.com>\n+\n+\t* s-os_lib.ads: Minor style fix.\n+\n+2011-11-21  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c (__gnat_dup2): When fd are stdout, stdin or stderr and\n+\tidentical, do nothing on Windows XP.\n+\n+2011-11-21  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch3.adb (Constrain_Index, Process_Range_Expr_In_Decl):\n+\tUse Full_Expander_Active instead of Expander_Active to control\n+\tthe forced evaluation of expressions for the sake of generating\n+\tchecks.\n+\n+2011-11-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* init.c: On FreeBSD, stack checking failures may raise SIGBUS.\n+\n+2011-11-21  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* sysdep.c (mode_read_text, mode_write_text, mode_append_text,\n+\tmode_read_binary, mode_write_binary, mode_append_binary,\n+\tmode_read_text_plus, mode_write_text_plus, mode_append_text_plus,\n+\tmode_read_binary_plus, mode_write_binary_plus,\n+\tmode_append_binary_plus): Remove unused declarations.\n+\n+2011-11-21  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat_rm.texi: Minor rewording.\n+\n+2011-11-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_imgv.adb (Expand_Width_Attribute): Emit\n+\tan error message rather than a warning when pragma Discard_Names\n+\tprevents the computation of 'Width. Do not emit an error through\n+\tthe use of RE_Null.\n+\n+2011-11-21  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.adb (Make_Build_In_Place_Call_In_Allocator): Add\n+\timplicit type conversion when the type of the allocator is an\n+\tinterface. Done to force generation of displacement of the \"this\"\n+\tpointer when required.\n+\n+2011-11-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sinfo.ads, sinfo.adb: Corresponding_Spec applies to expression\n+\tfunctions, and is set when the expression is a completion of a\n+\tprevious declaration.\n+\t* sem_ch6.adb (Analyze_Expression_Function): To determine properly\n+\twhether an expression function completes a previous declaration,\n+\tuse Find_Corresponding_Spec, as when analyzing a subprogram body.\n+\n+2011-11-21  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_util.adb (Deepest_Type_Access_Level): Improve comment.\n+\t(Type_Access_Level): Improve comment.\n+\n 2011-11-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Makefile.in (INCLUDES_FOR_SUBDIR): Add $(fsrcdir) by"}, {"sha": "dde334295754b63c9f311694c787175df698d388", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -2449,6 +2449,14 @@ __gnat_dup2 (int oldfd, int newfd)\n   /* Not supported on VxWorks 5.x, but supported on VxWorks 6.0 when using\n      RTPs.  */\n   return -1;\n+#elif defined (_WIN32)\n+  /* Special case when oldfd and newfd are identical and are the standard\n+     input, output or error as this makes Windows XP hangs. Note that we\n+     do that only for standard file descriptors that are known to be valid. */\n+  if (oldfd == newfd && newfd >= 0 && newfd <= 2)\n+    return newfd;\n+  else\n+    return dup2 (oldfd, newfd);\n #else\n   return dup2 (oldfd, newfd);\n #endif"}, {"sha": "31c878e77954c0004f54e8fb19c5d1d933dd4f41", "filename": "gcc/ada/env.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fenv.c?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -110,8 +110,6 @@ __gnat_getenv (char *name, int *len, char **value)\n \n #ifdef VMS\n \n-static char *to_host_path_spec (char *);\n-\n typedef struct _ile3\n {\n   unsigned short len, code;"}, {"sha": "93396525ddec14ff3c8e52ee6e2c57b18e8d195c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -7805,6 +7805,15 @@ package body Exp_Ch6 is\n       --  to the object created by the allocator).\n \n       Rewrite (Allocator, Make_Reference (Loc, Relocate_Node (Function_Call)));\n+\n+      --  Ada 2005 (AI-251): If the type of the allocator is an interface then\n+      --  generate an implicit conversion to force displacement of the \"this\"\n+      --  pointer.\n+\n+      if Is_Interface (Designated_Type (Acc_Type)) then\n+         Rewrite (Allocator, Convert_To (Acc_Type, Relocate_Node (Allocator)));\n+      end if;\n+\n       Analyze_And_Resolve (Allocator, Acc_Type);\n    end Make_Build_In_Place_Call_In_Allocator;\n "}, {"sha": "1c46950a952e7fd9d6a53de5b8896099716e6fd7", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -1156,31 +1156,27 @@ package body Exp_Imgv is\n       else\n          pragma Assert (Is_Enumeration_Type (Rtyp));\n \n-         if Discard_Names (Rtyp) then\n+         --  Whenever pragma Discard_Names is in effect, it suppresses the\n+         --  generation of string literals for enumeration types. Since the\n+         --  literals are required to evaluate the 'Width of an enumeration\n+         --  type, emit an error.\n+\n+         --  ??? This is fine for configurable runtimes, but dubious in the\n+         --  general case. For now keep both error messages until this issue\n+         --  has been verified with the ARG.\n \n-            --  Emit a detailed warning in configurable run-time mode because\n-            --  loading RE_Null does not give a precise indication of the real\n-            --  issue.\n+         if Discard_Names (Rtyp) then\n+            Error_Msg_Name_1 := Attribute_Name (N);\n \n-            if Configurable_Run_Time_Mode\n-              and then not Has_Warnings_Off (Rtyp)\n-            then\n-               Error_Msg_Name_1 := Attribute_Name (N);\n-               Error_Msg_N (\"?attribute % not supported in configurable \" &\n+            if Configurable_Run_Time_Mode then\n+               Error_Msg_N (\"attribute % not supported in configurable \" &\n                             \"run-time mode\", N);\n+            else\n+               Error_Msg_N (\"attribute % not supported when pragma \" &\n+                            \"Discard_Names is in effect\", N);\n             end if;\n \n-            --  This is a configurable run-time, or else a restriction is in\n-            --  effect. In either case the attribute cannot be supported. Force\n-            --  a load error from Rtsfind to generate an appropriate message,\n-            --  as is done with other ZFP violations.\n-\n-            declare\n-               Discard : constant Entity_Id := RTE (RE_Null);\n-               pragma Unreferenced (Discard);\n-            begin\n-               return;\n-            end;\n+            return;\n          end if;\n \n          Ttyp := Component_Type (Etype (Lit_Indexes (Rtyp)));"}, {"sha": "ffe4358fb4076466e6286d226de02d6dd3a068d7", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -6372,12 +6372,11 @@ refer to the value of the prefix on entry. So for\n example if you have an argument of a record type X called Arg1,\n you can refer to Arg1.Field'Old which yields the value of\n Arg1.Field on entry. The implementation simply involves generating\n-an object declaration which captures the value on entry. Any\n-prefix is allowed except one of a limited type (since limited\n-types cannot be copied to capture their values) or an expression\n-which references a local variable\n-(since local variables do not exist at subprogram entry time).\n-\n+an object declaration which captures the value on entry.\n+The prefix must denote an object of a nonlimited type (since limited types\n+cannot be copied to capture their values) and it must not reference a local\n+variable (since local variables do not exist at subprogram entry time). Note\n+that the variable introduced by a quantified expression is a local variable.\n The following example shows the use of 'Old to implement\n a test of a postcondition:\n "}, {"sha": "cc6c1d2c50bf8932297a0de1ab1321c99dbf81ad", "filename": "gcc/ada/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -1808,8 +1808,8 @@ __gnat_error_handler (int sig,\n       break;\n \n     case SIGBUS:\n-      exception = &constraint_error;\n-      msg = \"SIGBUS\";\n+      exception = &storage_error;\n+      msg = \"SIGBUS: possible stack overflow\";\n       break;\n \n     default:"}, {"sha": "3599261498c06cce5974243fe407e1d238616576", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -174,7 +174,7 @@ package System.OS_Lib is\n    --  File descriptors for standard input output files\n \n    Invalid_FD : constant File_Descriptor := -1;\n-   --  File descriptor returned when error in opening/creating file;\n+   --  File descriptor returned when error in opening/creating file\n \n    type Mode is (Binary, Text);\n    for Mode'Size use Integer'Size;"}, {"sha": "16147713712c8af275b4960f6f300e9ae088e8c6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -11786,7 +11786,7 @@ package body Sem_Ch3 is\n          --  needed, since checks may cause duplication of the expressions\n          --  which must not be reevaluated.\n \n-         if Expander_Active then\n+         if Full_Expander_Active then\n             Force_Evaluation (Low_Bound (R));\n             Force_Evaluation (High_Bound (R));\n          end if;\n@@ -18326,7 +18326,7 @@ package body Sem_Ch3 is\n             --  if needed, before applying checks, since checks may cause\n             --  duplication of the expression without forcing evaluation.\n \n-            if Expander_Active then\n+            if Full_Expander_Active then\n                Force_Evaluation (Lo);\n                Force_Evaluation (Hi);\n             end if;\n@@ -18436,7 +18436,7 @@ package body Sem_Ch3 is\n \n       --  Case of other than an explicit N_Range node\n \n-      elsif Expander_Active then\n+      elsif Full_Expander_Active then\n          Get_Index_Bounds (R, Lo, Hi);\n          Force_Evaluation (Lo);\n          Force_Evaluation (Hi);"}, {"sha": "25ee63ec29f6310110a671d6c8fb1b1d9af0f48d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -268,16 +268,22 @@ package body Sem_Ch6 is\n    procedure Analyze_Expression_Function (N : Node_Id) is\n       Loc      : constant Source_Ptr := Sloc (N);\n       LocX     : constant Source_Ptr := Sloc (Expression (N));\n-      Def_Id   : constant Entity_Id  := Defining_Entity (Specification (N));\n       Expr     : constant Node_Id    := Expression (N);\n-      New_Body : Node_Id;\n-      New_Decl : Node_Id;\n+      Spec     : constant Node_Id    := Specification (N);\n+\n+      Def_Id   :  Entity_Id;\n+      pragma Unreferenced (Def_Id);\n \n-      Prev : constant Entity_Id := Current_Entity_In_Scope (Def_Id);\n+      Prev     :  Entity_Id;\n       --  If the expression is a completion, Prev is the entity whose\n-      --  declaration is completed.\n+      --  declaration is completed. Def_Id is needed to analyze the spec.\n+\n+      New_Body : Node_Id;\n+      New_Decl : Node_Id;\n+      New_Spec : Node_Id;\n \n    begin\n+\n       --  This is one of the occasions on which we transform the tree during\n       --  semantic analysis. If this is a completion, transform the expression\n       --  function into an equivalent subprogram body, and analyze it.\n@@ -286,10 +292,22 @@ package body Sem_Ch6 is\n       --  determine whether this is possible.\n \n       Inline_Processing_Required := True;\n+      New_Spec := Copy_Separate_Tree (Spec);\n+      Prev     := Current_Entity_In_Scope (Defining_Entity (Spec));\n+\n+      --  If there are previous overloadable entities with the same name,\n+      --  check whether any of them is completed by the expression function.\n+\n+      if Present (Prev)\n+        and then Is_Overloadable (Prev)\n+      then\n+         Def_Id   := Analyze_Subprogram_Specification (Spec);\n+         Prev     := Find_Corresponding_Spec (N);\n+      end if;\n \n       New_Body :=\n         Make_Subprogram_Body (Loc,\n-          Specification              => Copy_Separate_Tree (Specification (N)),\n+          Specification              => New_Spec,\n           Declarations               => Empty_List,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (LocX,\n@@ -307,13 +325,15 @@ package body Sem_Ch6 is\n \n          Insert_After (N, New_Body);\n          Rewrite (N, Make_Null_Statement (Loc));\n+         Set_Has_Completion (Prev, False);\n          Analyze (N);\n          Analyze (New_Body);\n          Set_Is_Inlined (Prev);\n \n       elsif Present (Prev)\n         and then Comes_From_Source (Prev)\n       then\n+         Set_Has_Completion (Prev, False);\n          Rewrite (N, New_Body);\n          Analyze (N);\n \n@@ -333,8 +353,7 @@ package body Sem_Ch6 is\n \n       else\n          New_Decl :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification => Specification (N));\n+           Make_Subprogram_Declaration (Loc, Specification => Spec);\n \n          Rewrite (N, New_Decl);\n          Analyze (N);"}, {"sha": "edf1fecbfe6243cef06c962fb6b7b8b263531cb6", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -2437,7 +2437,8 @@ package body Sem_Util is\n                          (Defining_Identifier\n                            (Associated_Node_For_Itype (Typ))));\n \n-      --  For generic formal type, return Int'Last (infinite) (why ???)\n+      --  For generic formal type, return Int'Last (infinite).\n+      --  See comment preceding Is_Generic_Type call in Type_Access_Level.\n \n       elsif Is_Generic_Type (Root_Type (Typ)) then\n          return UI_From_Int (Int'Last);\n@@ -12719,7 +12720,20 @@ package body Sem_Util is\n          end if;\n       end if;\n \n-      --  Return library level for a generic formal type (why???)\n+      --  Return library level for a generic formal type. This is done because\n+      --  RM(10.3.2) says that \"The statically deeper relationship does not\n+      --  apply to ... a descendant of a generic formal type\". Rather than\n+      --  checking at each point where a static accessibility check is\n+      --  performed to see if we are dealing with a formal type, this rule is\n+      --  implemented by having Type_Access_Level and Deepest_Type_Access_Level\n+      --  return extreme values for a formal type; Deepest_Type_Access_Level\n+      --  returns Int'Last. By calling the appropriate function from among the\n+      --  two, we ensure that the static accessibility check will pass if we\n+      --  happen to run into a formal type. More specifically, we should call\n+      --  Deepest_Type_Access_Level instead of Type_Access_Level whenever the\n+      --  call occurs as part of a static accessibility check and the error\n+      --  case is the case where the type's level is too shallow (as opposed\n+      --  to too deep).\n \n       if Is_Generic_Type (Root_Type (Btyp)) then\n          return Scope_Depth (Standard_Standard);"}, {"sha": "22b44e56f27378802000ccb55fbc6763899ff10e", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -657,6 +657,7 @@ package body Sinfo is\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Expression_Function\n         or else NT (N).Nkind = N_Package_Body\n         or else NT (N).Nkind = N_Protected_Body\n         or else NT (N).Nkind = N_Subprogram_Body\n@@ -3729,6 +3730,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Expression_Function\n         or else NT (N).Nkind = N_Package_Body\n         or else NT (N).Nkind = N_Protected_Body\n         or else NT (N).Nkind = N_Subprogram_Body"}, {"sha": "cfa8a11b5927b2ff580f96b7688e88e9e55a66ed", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -760,6 +760,8 @@ package Sinfo is\n    --    renaming declaration when it is a Renaming_As_Body. The field is Empty\n    --    if there is no corresponding spec, as in the case of a subprogram body\n    --    that serves as its own spec.\n+   --    In Ada2012, Corresponding_Spec is set on expression functions that\n+   --    complete a subprogram declaration.\n \n    --  Corresponding_Stub (Node3-Sem)\n    --    This field is present in an N_Subunit node. It holds the node in\n@@ -4607,6 +4609,7 @@ package Sinfo is\n       --  Sloc points to FUNCTION\n       --  Specification (Node1)\n       --  Expression (Node3)\n+      --  Corresponding_Spec (Node5-Sem)\n \n       -----------------------------------\n       -- 6.4  Procedure Call Statement --"}, {"sha": "a4456f56a2490a47b6f7143a66ca137f3e37aea7", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 1, "deletions": 72, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d4b3556d4f8b7c32de809f023ac876cd8cae82/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=d2d4b3556d4f8b7c32de809f023ac876cd8cae82", "patch": "@@ -80,54 +80,6 @@ extern struct tm *localtime_r(const time_t *, struct tm *);\n #endif\n \n /*\n-   mode_read_text\n-   open text file for reading\n-   rt for DOS and Windows NT, r for Unix\n-\n-   mode_write_text\n-   truncate to zero length or create text file for writing\n-   wt for DOS and Windows NT, w for Unix\n-\n-   mode_append_text\n-   append; open or create text file for writing at end-of-file\n-   at for DOS and Windows NT, a for Unix\n-\n-   mode_read_binary\n-   open binary file for reading\n-   rb for DOS and Windows NT, r for Unix\n-\n-   mode_write_binary\n-   truncate to zero length or create binary file for writing\n-   wb for DOS and Windows NT, w for Unix\n-\n-   mode_append_binary\n-   append; open or create binary file for writing at end-of-file\n-   ab for DOS and Windows NT, a for Unix\n-\n-   mode_read_text_plus\n-   open text file for update (reading and writing)\n-   r+t for DOS and Windows NT, r+ for Unix\n-\n-   mode_write_text_plus\n-   truncate to zero length or create text file for update\n-   w+t for DOS and Windows NT, w+ for Unix\n-\n-   mode_append_text_plus\n-   append; open or create text file for update, writing at end-of-file\n-   a+t for DOS and Windows NT, a+ for Unix\n-\n-   mode_read_binary_plus\n-   open binary file for update (reading and writing)\n-   r+b for DOS and Windows NT, r+ for Unix\n-\n-   mode_write_binary_plus\n-   truncate to zero length or create binary file for update\n-   w+b for DOS and Windows NT, w+ for Unix\n-\n-   mode_append_binary_plus\n-   append; open or create binary file for update, writing at end-of-file\n-   a+b for DOS and Windows NT, a+ for Unix\n-\n    Notes:\n \n    (1) Opening a file with read mode fails if the file does not exist or\n@@ -169,18 +121,7 @@ extern struct tm *localtime_r(const time_t *, struct tm *);\n */\n \n #if defined(WINNT)\n-static const char *mode_read_text = \"rt\";\n-static const char *mode_write_text = \"wt\";\n-static const char *mode_append_text = \"at\";\n-static const char *mode_read_binary = \"rb\";\n-static const char *mode_write_binary = \"wb\";\n-static const char *mode_append_binary = \"ab\";\n-static const char *mode_read_text_plus = \"r+t\";\n-static const char *mode_write_text_plus = \"w+t\";\n-static const char *mode_append_text_plus = \"a+t\";\n-static const char *mode_read_binary_plus = \"r+b\";\n-static const char *mode_write_binary_plus = \"w+b\";\n-static const char *mode_append_binary_plus = \"a+b\";\n+\n const char __gnat_text_translation_required = 1;\n \n void\n@@ -261,18 +202,6 @@ __gnat_get_stack_bounds (void **base, void **limit)\n \n #else\n \n-static const char *mode_read_text = \"r\";\n-static const char *mode_write_text = \"w\";\n-static const char *mode_append_text = \"a\";\n-static const char *mode_read_binary = \"r\";\n-static const char *mode_write_binary = \"w\";\n-static const char *mode_append_binary = \"a\";\n-static const char *mode_read_text_plus = \"r+\";\n-static const char *mode_write_text_plus = \"w+\";\n-static const char *mode_append_text_plus = \"a+\";\n-static const char *mode_read_binary_plus = \"r+\";\n-static const char *mode_write_binary_plus = \"w+\";\n-static const char *mode_append_binary_plus = \"a+\";\n const char __gnat_text_translation_required = 0;\n \n /* These functions do nothing in non-DOS systems. */"}]}