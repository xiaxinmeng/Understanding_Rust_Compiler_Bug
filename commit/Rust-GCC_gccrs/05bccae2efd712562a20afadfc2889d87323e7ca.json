{"sha": "05bccae2efd712562a20afadfc2889d87323e7ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDViY2NhZTJlZmQ3MTI1NjJhMjBhZmFkZmMyODg5ZDg3MzIzZTdjYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-07T11:41:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-07T11:41:32Z"}, "message": "tree.h (INT_CST_LT, [...]): Remove unneeded casts.\n\n\t* tree.h (INT_CST_LT, INT_CST_LT_UNSIGNED): Remove unneeded casts.\n\t(struct tree_int_cst): int_cst_low is now unsigned HOST_WIDE_INT.\n\t(attribute_hash_list, type_hash_canon): hashcode is now unsigned.\n\t(type_hash_lookup, type_hash_add, type_hash_list): Likewise.\n\t(min_precision): Result is unsignd.\n\t(add_double, neg_double, mul_double): Low word is unsigned.\n\t(lshift_double, rshift_double, lrotate_double): Likewise.\n\t(rrotate_double, div_and_round_double): Likewise.\n\t(tree_floor_log2, compare_tree_int): New functions.\n\t(preserve_rtl_expr_temps): New declaration.\n\t* c-common.c (declare_hidden_char_array): Use compare_tree_int.\n\t(decl_attributes): Use tree_log2 to find alignment.\n\tCheck for TREE_INT_CST_HIGH for format args.\n\t(min_precision): Now unsigned.\n\tUse tree_floor_log2.\n\t(truthvalue_conversion): Delete long-disabled code.\n\t* c-decl.c (finish_struct): Clean up tests on field width.\n\t(finish_function): Use compare_tree_int.\n\t* c-pragma.c (handle_pragma_token): Use tree_log2 for alignment.\n\t* c-typeck.c (comptypes): Use tree_int_cst_equal.\n\t(default_conversion, digest_init): Use compare_tree_int.\n\t(build_binary_op): Use integer_all_onesp and compare_tree_int.\n\tFix type errors in forming masks.\n\t* calls.c (initialize_argument_information): Use compare_tree_int.\n\t* dbxout.c (dbxout_type): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n\t* except.c (expand_eh_region_start_tree): Use compare_tree_int.\n\t* expr.c (is_zeros_p, case INTEGER_CST): Use integer_zerop.\n\t(store_field): Use compare_tree_int.\n\t(expand_expr, case CONSTRUCTOR): Use TYPE_SIZE_UNIT.\n\t(expand_expr, case ARRAY_REF): Use compare_tree_int.\n\t(do_jump, case BIT_AND_EXPR): Use tree_floor_log2.\n\t(do_store_flag): Use compare_tree_int.\n\t* fold-const.c (encode, decode): Low part is always unsigned.\n\t(force_fit_type, add_double, neg_double, mul_double): Likewise.\n\t(lshift_double, rshift_double, lrotate_double): Likewise.\n\t(rrotate_double, div_and_round_double, int_const_binop): Likewise.\n\t(fold_convert): Use compare_tree_int.\n\t(operand_equal_p, case INTEGER_CST): Use tree_int_cst_equal.\n\t(invert_truthvalue, case INTEGER_CST): Likewise.\n\t(fold): Use compare_tree_int; add casts for unsigned TREE_INT_CST_LOW.\n\t* mkdeps.c (deps_dummy_targets): Make I unsigned.\n\t* rtl.h (add_double, neg_double, mul_double): Low words are unsigned.\n\t(lshift_double, rshift_double, lrotate_double, rrotate_double):\n\tLikewise.\n\t* stmt.c (expand_decl): Use compare_tree_int and mode_for_size_tree.\n\t(expand_end_case): Use compare_tree_int.\n\t(estimate_case_costs): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n\t* stor-layout.c (mode_for_size_tree): Use compare_tree_int.\n\t(layout_decl): Likewise.\n\t(layout_record, layout_union): Make sizes unsigned.\n\t(layout_type, case VOID_TYPE): TYPE_SIZE must be bitsizetype.\n\t(layout_type, case QUAL_UNION_TYPE): Use compare_tree_int.\n\t* tree.c (struct type_hash): hashcode is unsigned.\n\t(build_type_attribute_variant, type_hash_list): Likewise.\n\t(type_hash_lookup, type_hash_add, type_hash_canon): Likewise.\n\t(attribute_hash_list, build_array_type, build_method_type): Likewise.\n\t(build_complex_type): Likewise.\n\t(real_value_from_int_cst): Remove unneeded casts.\n\t(integer_all_onesp): Add casts.\n\t(tree_floor_log2, compare_tree_int): New functions.\n\t(build_index_type): Use tree_int_cst_sgn.\n\t* varasm.c (assemble_variable): Use compare_tree_int.\n\t* ch/actions.c (chill_convert_for_assignment): INDEX is unsigned\n\tHOST_WIDE_INT.\n\t* ch/ch-tree.h (DECL_NESTING_LEVEL): Use TREE_INT_CST_HIGH\n\tsince unsigned.\n\t* ch/except.c (chill_handle_on_labels): ALTERNATIVE is unsigned.\n\tUse compare_tree_int.\n\t(expand_goto_except_cleanup): Likewise.\n\t* cp/class.c (dfs_modify_vtables): I is now unsigned.\n\t(check_bitfield_decl): Use tree_int_cst_sgn and compare_tree_int.\n\t(build_base_field): Add casts of TREE_INT_CST_LOW to HOST_WIDE_INT.\n\t* cp/error.c (dump_expr): Cast TREE_INT_CST_HIGH to unsigned.\n\t* cp/init.c (build_vec_init): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n\t* cp/method.c (build_overload_int): Cast TREE_INT_CST_HIGH to unsigned.\n\t* cp/typeck.c (build_binary_op, case TRUNC_DIV_EXPR):\n\tCall integer_all_onesp.\n\t* cp/typeck2.c (process_init_constructor): Use compare_tree_int.\n\t* f/com.c (ffecom_f2c_set_lio_code_): Use compare_tree_int.\n\t(ffecom_sym_transform_, ffecom_transform_common_): Likewise.\n\t(ffecom_transform_equiv_): Likewise.\n\t* java/decl.c (emit_init_test_initialization): Mark KEY as unused.\n\t* java/expr.c (build_newarray): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n\t(build_anewarray): Likewise.\n\t* java/parse.y (patch_newarray): Likewise.\n\t* java/parse.c: Regenerated.\n\nFrom-SVN: r32383", "tree": {"sha": "eedf389b906e1f6d1fda0e405c46b8b47fb6d064", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eedf389b906e1f6d1fda0e405c46b8b47fb6d064"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05bccae2efd712562a20afadfc2889d87323e7ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05bccae2efd712562a20afadfc2889d87323e7ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05bccae2efd712562a20afadfc2889d87323e7ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05bccae2efd712562a20afadfc2889d87323e7ca/comments", "author": null, "committer": null, "parents": [{"sha": "ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddf0fc6c9f1eb8747c9cf6b69e48f11f779632d2"}], "stats": {"total": 1453, "additions": 823, "deletions": 630}, "files": [{"sha": "0b560ca479c02086589ee400903756e7e6129ea5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1,3 +1,68 @@\n+Mon Mar  6 15:22:29 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree.h (INT_CST_LT, INT_CST_LT_UNSIGNED): Remove unneeded casts.\n+\t(struct tree_int_cst): int_cst_low is now unsigned HOST_WIDE_INT.\n+\t(attribute_hash_list, type_hash_canon): hashcode is now unsigned.\n+\t(type_hash_lookup, type_hash_add, type_hash_list): Likewise.\n+\t(min_precision): Result is unsignd.\n+\t(add_double, neg_double, mul_double): Low word is unsigned.\n+\t(lshift_double, rshift_double, lrotate_double): Likewise.\n+\t(rrotate_double, div_and_round_double): Likewise.\n+\t(tree_floor_log2, compare_tree_int): New functions.\n+\t(preserve_rtl_expr_temps): New declaration.\n+\t* c-common.c (declare_hidden_char_array): Use compare_tree_int.\n+\t(decl_attributes): Use tree_log2 to find alignment.\n+\tCheck for TREE_INT_CST_HIGH for format args.\n+\t(min_precision): Now unsigned.\n+\tUse tree_floor_log2.\n+\t(truthvalue_conversion): Delete long-disabled code.\n+\t* c-decl.c (finish_struct): Clean up tests on field width.\n+\t(finish_function): Use compare_tree_int.\n+\t* c-pragma.c (handle_pragma_token): Use tree_log2 for alignment.\n+\t* c-typeck.c (comptypes): Use tree_int_cst_equal.\n+\t(default_conversion, digest_init): Use compare_tree_int.\n+\t(build_binary_op): Use integer_all_onesp and compare_tree_int.\n+\tFix type errors in forming masks.\n+\t* calls.c (initialize_argument_information): Use compare_tree_int.\n+\t* dbxout.c (dbxout_type): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n+\t* except.c (expand_eh_region_start_tree): Use compare_tree_int.\n+\t* expr.c (is_zeros_p, case INTEGER_CST): Use integer_zerop.\n+\t(store_field): Use compare_tree_int.\n+\t(expand_expr, case CONSTRUCTOR): Use TYPE_SIZE_UNIT.\n+\t(expand_expr, case ARRAY_REF): Use compare_tree_int.\n+\t(do_jump, case BIT_AND_EXPR): Use tree_floor_log2.\n+\t(do_store_flag): Use compare_tree_int.\n+\t* fold-const.c (encode, decode): Low part is always unsigned.\n+\t(force_fit_type, add_double, neg_double, mul_double): Likewise.\n+\t(lshift_double, rshift_double, lrotate_double): Likewise.\n+\t(rrotate_double, div_and_round_double, int_const_binop): Likewise.\n+\t(fold_convert): Use compare_tree_int.\n+\t(operand_equal_p, case INTEGER_CST): Use tree_int_cst_equal.\n+\t(invert_truthvalue, case INTEGER_CST): Likewise.\n+\t(fold): Use compare_tree_int; add casts for unsigned TREE_INT_CST_LOW.\n+\t* mkdeps.c (deps_dummy_targets): Make I unsigned.\n+\t* rtl.h (add_double, neg_double, mul_double): Low words are unsigned.\n+\t(lshift_double, rshift_double, lrotate_double, rrotate_double):\n+\tLikewise.\n+\t* stmt.c (expand_decl): Use compare_tree_int and mode_for_size_tree.\n+\t(expand_end_case): Use compare_tree_int.\n+\t(estimate_case_costs): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n+\t* stor-layout.c (mode_for_size_tree): Use compare_tree_int.\n+\t(layout_decl): Likewise.\n+\t(layout_record, layout_union): Make sizes unsigned.\n+\t(layout_type, case VOID_TYPE): TYPE_SIZE must be bitsizetype.\n+\t(layout_type, case QUAL_UNION_TYPE): Use compare_tree_int.\n+\t* tree.c (struct type_hash): hashcode is unsigned.\n+\t(build_type_attribute_variant, type_hash_list): Likewise.\n+\t(type_hash_lookup, type_hash_add, type_hash_canon): Likewise.\n+\t(attribute_hash_list, build_array_type, build_method_type): Likewise.\n+\t(build_complex_type): Likewise.\n+\t(real_value_from_int_cst): Remove unneeded casts.\n+\t(integer_all_onesp): Add casts.\n+\t(tree_floor_log2, compare_tree_int): New functions.\n+\t(build_index_type): Use tree_int_cst_sgn.\n+\t* varasm.c (assemble_variable): Use compare_tree_int.\n+\n 2000-03-06  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* cpphash.c (collect_expansion): Also catch ## at start of macro."}, {"sha": "35e2b02011524e0883eed2c19fbf6b5ea814363b", "filename": "gcc/c-common.c", "status": "modified", "additions": 38, "deletions": 55, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -282,16 +282,17 @@ declare_hidden_char_array (name, value)\n      const char *name, *value;\n {\n   tree decl, type, init;\n-  int vlen;\n+  unsigned int vlen;\n \n   /* If the default size of char arrays isn't big enough for the name,\n      or if we want to give warnings for large objects, make a bigger one.  */\n   vlen = strlen (value) + 1;\n   type = char_array_type_node;\n-  if (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) < vlen\n+  if (compare_tree_int (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), vlen) < 0\n       || warn_larger_than)\n     type = build_array_type (char_type_node,\n \t\t\t     build_index_type (build_int_2 (vlen, 0)));\n+\n   decl = build_decl (VAR_DECL, get_identifier (name), type);\n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n@@ -775,7 +776,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    tree align_expr\n \t      = (args ? TREE_VALUE (args)\n \t\t : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-\t    int align;\n+\t    int i;\n \n \t    /* Strip any NOPs of any kind.  */\n \t    while (TREE_CODE (align_expr) == NOP_EXPR\n@@ -789,18 +790,18 @@ decl_attributes (node, attributes, prefix_attributes)\n \t\tcontinue;\n \t      }\n \n-\t    align = TREE_INT_CST_LOW (align_expr) * BITS_PER_UNIT;\n-\n-\t    if (exact_log2 (align) == -1)\n+\t    if ((i = tree_log2 (align_expr)) == -1)\n \t      error (\"requested alignment is not a power of 2\");\n+\t    else if (i > HOST_BITS_PER_INT - 2)\n+\t      error (\"requested alignment is too large\");\n \t    else if (is_type)\n-\t      TYPE_ALIGN (type) = align;\n+\t      TYPE_ALIGN (type) = (1 << i) * BITS_PER_UNIT;\n \t    else if (TREE_CODE (decl) != VAR_DECL\n \t\t     && TREE_CODE (decl) != FIELD_DECL)\n \t      error_with_decl (decl,\n \t\t\t       \"alignment may not be specified for `%s'\");\n \t    else\n-\t      DECL_ALIGN (decl) = align;\n+\t      DECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;\n \t  }\n \t  break;\n \n@@ -810,11 +811,10 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n \t    tree first_arg_num_expr\n \t      = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n-\t    int format_num;\n-\t    int first_arg_num;\n+\t    unsigned HOST_WIDE_INT format_num, first_arg_num;\n \t    enum format_type format_type;\n \t    tree argument;\n-\t    int arg_num;\n+\t    unsigned int arg_num;\n \n \t    if (TREE_CODE (decl) != FUNCTION_DECL)\n \t      {\n@@ -859,9 +859,11 @@ decl_attributes (node, attributes, prefix_attributes)\n \t      first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n \n \t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n-\t\t|| TREE_CODE (first_arg_num_expr) != INTEGER_CST)\n+\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0\n+\t\t|| TREE_CODE (first_arg_num_expr) != INTEGER_CST\n+\t\t|| TREE_INT_CST_HIGH (first_arg_num_expr) != 0)\n \t      {\n-\t\terror (\"format string has non-constant operand number\");\n+\t\terror (\"format string has invalid operand number\");\n \t\tcontinue;\n \t      }\n \n@@ -879,12 +881,10 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    argument = TYPE_ARG_TYPES (type);\n \t    if (argument)\n \t      {\n-\t\tfor (arg_num = 1; ; ++arg_num)\n-\t\t  {\n-\t\t    if (argument == 0 || arg_num == format_num)\n-\t\t      break;\n-\t\t    argument = TREE_CHAIN (argument);\n-\t\t  }\n+\t\tfor (arg_num = 1; argument != 0 && arg_num != format_num;\n+\t\t     ++arg_num, argument = TREE_CHAIN (argument))\n+\t\t  ;\n+\n \t\tif (! argument\n \t\t    || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n@@ -893,17 +893,19 @@ decl_attributes (node, attributes, prefix_attributes)\n \t\t    error (\"format string arg not a string type\");\n \t\t    continue;\n \t\t  }\n-\t\tif (first_arg_num != 0)\n+\n+\t\telse if (first_arg_num != 0)\n \t\t  {\n \t\t    /* Verify that first_arg_num points to the last arg,\n \t\t       the ...  */\n \t\t    while (argument)\n \t\t      arg_num++, argument = TREE_CHAIN (argument);\n-\t\t  if (arg_num != first_arg_num)\n-\t\t    {\n-\t\t      error (\"args to be formatted is not ...\");\n-\t\t      continue;\n-\t\t    }\n+\n+\t\t    if (arg_num != first_arg_num)\n+\t\t      {\n+\t\t\terror (\"args to be formatted is not '...'\");\n+\t\t\tcontinue;\n+\t\t      }\n \t\t  }\n \t      }\n \n@@ -916,7 +918,8 @@ decl_attributes (node, attributes, prefix_attributes)\n \tcase A_FORMAT_ARG:\n \t  {\n \t    tree format_num_expr = TREE_VALUE (args);\n-\t    int format_num, arg_num;\n+\t    unsigned HOST_WIDE_INT format_num;\n+\t    unsigned int arg_num;\n \t    tree argument;\n \n \t    if (TREE_CODE (decl) != FUNCTION_DECL)\n@@ -933,9 +936,10 @@ decl_attributes (node, attributes, prefix_attributes)\n \t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n \t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n \n-\t    if (TREE_CODE (format_num_expr) != INTEGER_CST)\n+\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n+\t\t|| TREE_INT_CST_HIGH (format_num_expr) != 0)\n \t      {\n-\t\terror (\"format string has non-constant operand number\");\n+\t\terror (\"format string has invalid operand number\");\n \t\tcontinue;\n \t      }\n \n@@ -947,12 +951,10 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    argument = TYPE_ARG_TYPES (type);\n \t    if (argument)\n \t      {\n-\t\tfor (arg_num = 1; ; ++arg_num)\n-\t\t  {\n-\t\t    if (argument == 0 || arg_num == format_num)\n-\t\t      break;\n-\t\t    argument = TREE_CHAIN (argument);\n-\t\t  }\n+\t\tfor (arg_num = 1; argument != 0 && arg_num != format_num;\n+\t\t     ++arg_num, argument = TREE_CHAIN (argument))\n+\t\t  ;\n+\n \t\tif (! argument\n \t\t    || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n@@ -2407,7 +2409,7 @@ signed_or_unsigned_type (unsignedp, type)\n /* Return the minimum number of bits needed to represent VALUE in a\n    signed or unsigned type, UNSIGNEDP says which.  */\n \n-int\n+unsigned int\n min_precision (value, unsignedp)\n      tree value;\n      int unsignedp;\n@@ -2427,10 +2429,8 @@ min_precision (value, unsignedp)\n \n   if (integer_zerop (value))\n     log = 0;\n-  else if (TREE_INT_CST_HIGH (value) != 0)\n-    log = HOST_BITS_PER_WIDE_INT + floor_log2 (TREE_INT_CST_HIGH (value));\n   else\n-    log = floor_log2 (TREE_INT_CST_LOW (value));\n+    log = tree_floor_log2 (value);\n \n   return log + 1 + ! unsignedp;\n }\n@@ -2888,24 +2888,7 @@ truthvalue_conversion (expr)\n \n   switch (TREE_CODE (expr))\n     {\n-      /* It is simpler and generates better code to have only TRUTH_*_EXPR\n-\t or comparison expressions as truth values at this level.  */\n-#if 0\n-    case COMPONENT_REF:\n-      /* A one-bit unsigned bit-field is already acceptable.  */\n-      if (1 == TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (expr, 1)))\n-\t  && TREE_UNSIGNED (TREE_OPERAND (expr, 1)))\n-\treturn expr;\n-      break;\n-#endif\n-\n     case EQ_EXPR:\n-      /* It is simpler and generates better code to have only TRUTH_*_EXPR\n-\t or comparison expressions as truth values at this level.  */\n-#if 0\n-      if (integer_zerop (TREE_OPERAND (expr, 1)))\n-\treturn build_unary_op (TRUTH_NOT_EXPR, TREE_OPERAND (expr, 0), 0);\n-#endif\n     case NE_EXPR: case LE_EXPR: case GE_EXPR: case LT_EXPR: case GT_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:"}, {"sha": "6b5d295a2fa3e8a4baefad8284dc5f1af688c81e", "filename": "gcc/c-decl.c", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -5182,57 +5182,50 @@ finish_struct (t, fieldlist, attributes)\n \t\t   == TYPE_PRECISION (integer_type_node))))\n \tpedwarn_with_decl (x, \"bit-field `%s' type invalid in ANSI C\");\n \n-      /* Detect and ignore out of range field width.  */\n+      /* Detect and ignore out of range field width and process valid\n+\t field widths.  */\n       if (DECL_INITIAL (x))\n \t{\n \t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n-\t    {\n-\t      DECL_INITIAL (x) = NULL;\n-\t      error_with_decl (x, \"negative width in bit-field `%s'\");\n-\t    }\n-\t  else if (TREE_INT_CST_HIGH (DECL_INITIAL (x)) != 0\n-\t\t   || (TREE_INT_CST_LOW (DECL_INITIAL (x))\n-\t\t       > TYPE_PRECISION (TREE_TYPE (x))))\n-\t    {\n-\t      DECL_INITIAL (x) = NULL;\n-\t      pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n-\t    }\n+\t    error_with_decl (x, \"negative width in bit-field `%s'\");\n+\t  else if (0 < compare_tree_int (DECL_INITIAL (x), \n+\t\t\t\t\t TYPE_PRECISION (TREE_TYPE (x))))\n+\t    pedwarn_with_decl (x, \"width of `%s' exceeds its type\");\n \t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n+\t    error_with_decl (x, \"zero width for bit-field `%s'\");\n+\t  else\n \t    {\n-\t      error_with_decl (x, \"zero width for bit-field `%s'\");\n-\t      DECL_INITIAL (x) = NULL;\n-\t    }\n-\t}\n-\n-      /* Process valid field width.  */\n-      if (DECL_INITIAL (x))\n-\t{\n-\t  register int width = TREE_INT_CST_LOW (DECL_INITIAL (x));\n-\n-\t  if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n-\t      && (width < min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t TREE_UNSIGNED (TREE_TYPE (x)))\n-\t\t  || width < min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t    TREE_UNSIGNED (TREE_TYPE (x)))))\n-\t    warning_with_decl (x, \"`%s' is narrower than values of its type\");\n-\n-\t  DECL_SIZE (x) = bitsize_int (width);\n-\t  DECL_BIT_FIELD (x) = DECL_C_BIT_FIELD (x) = 1;\n-\t  DECL_INITIAL (x) = NULL;\n-\n-\t  if (width == 0)\n-\t    {\n-\t      /* field size 0 => force desired amount of alignment.  */\n+\t      /* The test above has assured us that TREE_INT_CST_HIGH is 0.  */\n+\t      unsigned HOST_WIDE_INT width\n+\t\t= TREE_INT_CST_LOW (DECL_INITIAL (x));\n+\n+\t      if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n+\t\t  && (width < min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n+\t\t\t\t\t     TREE_UNSIGNED (TREE_TYPE (x)))\n+\t\t      || (width\n+\t\t\t  < min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n+\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))))))\n+\t\twarning_with_decl (x,\n+\t\t\t\t   \"`%s' is narrower than values of its type\");\n+\n+\t      DECL_SIZE (x) = bitsize_int (width);\n+\t      DECL_BIT_FIELD (x) = DECL_C_BIT_FIELD (x) = 1;\n+\n+\t      if (width == 0)\n+\t\t{\n+\t\t  /* field size 0 => force desired amount of alignment.  */\n #ifdef EMPTY_FIELD_BOUNDARY\n-\t      DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n+\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n #endif\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t      if (PCC_BITFIELD_TYPE_MATTERS)\n-\t\tDECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t      TYPE_ALIGN (TREE_TYPE (x)));\n+\t\t  if (PCC_BITFIELD_TYPE_MATTERS)\n+\t\t    DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n+\t\t\t\t\t  TYPE_ALIGN (TREE_TYPE (x)));\n #endif\n+\t\t}\n \t    }\n \t}\n+\n       else if (TREE_TYPE (x) != error_mark_node)\n \t{\n \t  unsigned int min_align = (DECL_PACKED (x) ? BITS_PER_UNIT\n@@ -5242,9 +5235,9 @@ finish_struct (t, fieldlist, attributes)\n \t     fields which require only BITS_PER_UNIT alignment.  */\n \t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), min_align);\n \t}\n-    }\n \n-  /* Now DECL_INITIAL is null on all members.  */\n+      DECL_INITIAL (x) = 0;\n+    }\n \n   /* Delete all duplicate fields from the fieldlist */\n   for (x = fieldlist; x && TREE_CHAIN (x);)\n@@ -6489,34 +6482,36 @@ finish_function (nested)\n \n   if (warn_larger_than && !DECL_EXTERNAL (fndecl) && TREE_TYPE (fndecl))\n     {\n-      register tree ret_type = TREE_TYPE (TREE_TYPE (fndecl));\n+      tree ret_type = TREE_TYPE (TREE_TYPE (fndecl));\n \n-      if (ret_type)\n+      if (ret_type && TREE_CODE (TYPE_SIZE_UNIT (ret_type)) == INTEGER_CST\n+\t  && 0 < compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n+\t\t\t\t   larger_than_size))\n \t{\n-\t  register tree ret_type_size = TYPE_SIZE (ret_type);\n+\t  unsigned int size_as_int\n+\t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));\n \n-\t  if (TREE_CODE (ret_type_size) == INTEGER_CST)\n-\t    {\n-\t      unsigned units\n-\t\t= TREE_INT_CST_LOW (ret_type_size) / BITS_PER_UNIT;\n-\n-\t      if (units > larger_than_size)\n-\t\twarning_with_decl (fndecl,\n-\t\t\t\t   \"size of return value of `%s' is %u bytes\",\n-\t\t\t\t   units);\n-\t    }\n+\t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n+\t    warning_with_decl (fndecl,\n+\t\t\t       \"size of return value of `%s' is %u bytes\",\n+\t\t\t       size_as_int);\n+\t  else\n+\t    warning_with_decl (fndecl,\n+\t\t       \"size of return value of `%s' is larger than %d bytes\",\n+\t\t\t       larger_than_size);\n \t}\n     }\n \n   if (DECL_SAVED_INSNS (fndecl) == 0 && ! nested)\n     {\n-      /* Stop pointing to the local nodes about to be freed.  */\n-      /* But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition.  */\n-      /* For a nested function, this is done in pop_c_function_context.  */\n-      /* If rest_of_compilation set this to 0, leave it 0.  */\n+      /* Stop pointing to the local nodes about to be freed. \n+\t But DECL_INITIAL must remain nonzero so we know this\n+\t was an actual function definition. \n+\t For a nested function, this is done in pop_c_function_context.\n+\t If rest_of_compilation set this to 0, leave it 0.  */\n       if (DECL_INITIAL (fndecl) != 0)\n \tDECL_INITIAL (fndecl) = error_mark_node;\n+\n       DECL_ARGUMENTS (fndecl) = 0;\n     }\n "}, {"sha": "6597ffc28959535866cf1c104cb8c899f9df7d8a", "filename": "gcc/c-lex.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -406,6 +406,7 @@ yyprint (file, yychar, yylval)\n \f\n /* Iff C is a carriage return, warn about it - if appropriate -\n    and return nonzero.  */\n+\n static int\n whitespace_cr (c)\n      int c;"}, {"sha": "c85e6bf081cc3a6817de64dc0daeb6d41a719ab8", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -163,25 +163,25 @@ pop_alignment (id)\n    it needs to be preserved.\n \n    If STRING is non-NULL, then the return value will be ignored, and there\n-   will be futher calls to handle_pragma_token() in order to handle the rest of\n+   will be futher calls to handle_pragma_token in order to handle the rest of\n    the line containing the #pragma directive.  If STRING is NULL, the entire\n-   line has now been presented to handle_pragma_token() and the return value\n+   line has now been presented to handle_pragma_token and the return value\n    should be zero if the pragma flawed in some way, or if the pragma was not\n    recognised, and non-zero if it was successfully handled.  */\n \n int\n handle_pragma_token (string, token)\n-     const char * string;\n+     const char *string;\n      tree token;\n {\n   static enum pragma_state state = ps_start;\n   static enum pragma_state type;\n #ifdef HANDLE_PRAGMA_WEAK\n-  static char * name;\n-  static char * value;\n+  static char *name;\n+  static char *value;\n #endif\n #if defined(HANDLE_PRAGMA_PACK) || defined(HANDLE_PRAGMA_PACK_PUSH_POP)\n-  static int align;\n+  static unsigned int align;\n #endif\n   static tree id;\n \n@@ -353,15 +353,15 @@ handle_pragma_token (string, token)\n       break;\n \n     handle_align:\n-      align = TREE_INT_CST_LOW (token);\n-      switch (align)\n+      switch (tree_log2 (token))\n \t{\n+\tcase 0:\n \tcase 1:\n \tcase 2:\n+\tcase 3:\n \tcase 4:\n-\tcase 8:\n-\tcase 16:\n \t  state = ps_align;\n+\t  align = 1 << tree_log2 (token);\n \t  break;\n \n \tdefault:"}, {"sha": "2cac8875ca5573c978239ae2ee994afccb0ed8a3", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 51, "deletions": 64, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -514,15 +514,10 @@ comptypes (type1, type2)\n \t    || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST)\n \t  break;\n \n-\tif (! ((TREE_INT_CST_LOW (TYPE_MIN_VALUE (d1))\n-\t\t  == TREE_INT_CST_LOW (TYPE_MIN_VALUE (d2)))\n-\t\t && (TREE_INT_CST_HIGH (TYPE_MIN_VALUE (d1))\n-\t\t     == TREE_INT_CST_HIGH (TYPE_MIN_VALUE (d2)))\n-\t\t && (TREE_INT_CST_LOW (TYPE_MAX_VALUE (d1))\n-\t\t     == TREE_INT_CST_LOW (TYPE_MAX_VALUE (d2)))\n-\t\t && (TREE_INT_CST_HIGH (TYPE_MAX_VALUE (d1))\n-\t\t     == TREE_INT_CST_HIGH (TYPE_MAX_VALUE (d2)))))\n-\t   val = 0;\n+\tif (! tree_int_cst_equal (TYPE_MIN_VALUE (d1), TYPE_MIN_VALUE (d2))\n+\t    || ! tree_int_cst_equal (TYPE_MAX_VALUE (d1), TYPE_MAX_VALUE (d2)))\n+\t  val = 0;\n+\n         break;\n       }\n \n@@ -884,8 +879,9 @@ default_conversion (exp)\n     }\n \n   /* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as\n-     an lvalue.  */\n-  /* Do not use STRIP_NOPS here!  It will remove conversions from pointer\n+     an lvalue. \n+\n+     Do not use STRIP_NOPS here!  It will remove conversions from pointer\n      to integer and cause infinite recursion.  */\n   while (TREE_CODE (exp) == NON_LVALUE_EXPR\n \t || (TREE_CODE (exp) == NOP_EXPR\n@@ -902,26 +898,19 @@ default_conversion (exp)\n \t\t\t      || (TYPE_PRECISION (type)\n \t\t\t\t  >= TYPE_PRECISION (integer_type_node)))\n \t\t\t     && TREE_UNSIGNED (type)));\n+\n       return convert (type, exp);\n     }\n \n   if (TREE_CODE (exp) == COMPONENT_REF\n-      && DECL_C_BIT_FIELD (TREE_OPERAND (exp, 1)))\n-    {\n-      tree width = DECL_SIZE (TREE_OPERAND (exp, 1));\n-      HOST_WIDE_INT low = TREE_INT_CST_LOW (width);\n-\n+      && DECL_C_BIT_FIELD (TREE_OPERAND (exp, 1))\n       /* If it's thinner than an int, promote it like a\n \t C_PROMOTING_INTEGER_TYPE_P, otherwise leave it alone.  */\n-\n-      if (low < TYPE_PRECISION (integer_type_node))\n-\t{\n-\t  if (flag_traditional && TREE_UNSIGNED (type))\n-\t    return convert (unsigned_type_node, exp);\n-\t  else\n-\t    return convert (integer_type_node, exp);\n-\t}\n-    }\n+      && 0 > compare_tree_int (DECL_SIZE (TREE_OPERAND (exp, 1)),\n+\t\t\t       TYPE_PRECISION (integer_type_node)))\n+    return convert (flag_traditional && TREE_UNSIGNED (type)\n+\t\t    ? unsigned_type_node : integer_type_node,\n+\t\t    exp);\n \n   if (C_PROMOTING_INTEGER_TYPE_P (type))\n     {\n@@ -931,11 +920,14 @@ default_conversion (exp)\n \t  && (flag_traditional\n \t      || TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)))\n \treturn convert (unsigned_type_node, exp);\n+\n       return convert (integer_type_node, exp);\n     }\n+\n   if (flag_traditional && !flag_allow_single_precision\n       && TYPE_MAIN_VARIANT (type) == float_type_node)\n     return convert (double_type_node, exp);\n+\n   if (code == VOID_TYPE)\n     {\n       error (\"void value not ignored as it ought to be\");\n@@ -1914,17 +1906,14 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n \t  else\n-\t    {\n-\t      /* Although it would be tempting to shorten always here, that\n-\t\t loses on some targets, since the modulo instruction is\n-\t\t undefined if the quotient can't be represented in the\n-\t\t computation mode.  We shorten only if unsigned or if\n-\t\t dividing by something we know != -1.  */\n-\t      shorten = (TREE_UNSIGNED (TREE_TYPE (orig_op0))\n-\t\t\t || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t     && (TREE_INT_CST_LOW (op1) != -1\n-\t\t\t\t || TREE_INT_CST_HIGH (op1) != -1)));\n-\t    }\n+\t    /* Although it would be tempting to shorten always here, that\n+\t       loses on some targets, since the modulo instruction is\n+\t       undefined if the quotient can't be represented in the\n+\t       computation mode.  We shorten only if unsigned or if\n+\t       dividing by something we know != -1.  */\n+\t    shorten = (TREE_UNSIGNED (TREE_TYPE (orig_op0))\n+\t\t       || (TREE_CODE (op1) == INTEGER_CST\n+\t\t\t   && ! integer_all_onesp (op1)));\n \t  common = 1;\n \t}\n       break;\n@@ -1970,8 +1959,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t     only if unsigned or if dividing by something we know != -1.  */\n \t  shorten = (TREE_UNSIGNED (TREE_TYPE (orig_op0))\n \t\t     || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t && (TREE_INT_CST_LOW (op1) != -1\n-\t\t\t     || TREE_INT_CST_HIGH (op1) != -1)));\n+\t\t\t && ! integer_all_onesp (op1)));\n \t  common = 1;\n \t}\n       break;\n@@ -2009,14 +1997,14 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\twarning (\"right shift count is negative\");\n \t      else\n \t\t{\n-\t\t  if (TREE_INT_CST_LOW (op1) | TREE_INT_CST_HIGH (op1))\n+\t\t  if (! integer_zerop (op1))\n \t\t    short_shift = 1;\n-\t\t  if (TREE_INT_CST_HIGH (op1) != 0\n-\t\t      || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n-\t\t\t  >= TYPE_PRECISION (type0)))\n+\n+\t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\t    warning (\"right shift count >= width of type\");\n \t\t}\n \t    }\n+\n \t  /* Use the type of the value to be shifted.\n \t     This is what most traditional C compilers do.  */\n \t  result_type = type0;\n@@ -2039,11 +2027,11 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t    {\n \t      if (tree_int_cst_sgn (op1) < 0)\n \t\twarning (\"left shift count is negative\");\n-\t      else if (TREE_INT_CST_HIGH (op1) != 0\n-\t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n-\t\t\t   >= TYPE_PRECISION (type0)))\n+\n+\t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\twarning (\"left shift count >= width of type\");\n \t    }\n+\n \t  /* Use the type of the value to be shifted.\n \t     This is what most traditional C compilers do.  */\n \t  result_type = type0;\n@@ -2067,11 +2055,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t    {\n \t      if (tree_int_cst_sgn (op1) < 0)\n \t\twarning (\"shift count is negative\");\n-\t      else if (TREE_INT_CST_HIGH (op1) != 0\n-\t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n-\t\t\t   >= TYPE_PRECISION (type0)))\n+\t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n \t\twarning (\"shift count >= width of type\");\n \t    }\n+\n \t  /* Use the type of the value to be shifted.\n \t     This is what most traditional C compilers do.  */\n \t  result_type = type0;\n@@ -2343,8 +2330,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  if (TYPE_PRECISION (TREE_TYPE (arg0)) < TYPE_PRECISION (result_type)\n \t      /* We can shorten only if the shift count is less than the\n \t\t number of bits in the smaller type size.  */\n-\t      && TREE_INT_CST_HIGH (op1) == 0\n-\t      && TYPE_PRECISION (TREE_TYPE (arg0)) > TREE_INT_CST_LOW (op1)\n+\t      && compare_tree_int (op1, TYPE_PRECISION (TREE_TYPE (arg0))) < 0\n \t      /* If arg is sign-extended and then unsigned-shifted,\n \t\t we can simulate this with a signed shift in arg's type\n \t\t only if the extended result is at least twice as wide\n@@ -2354,7 +2340,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\t it never happens because available widths are 2**N.  */\n \t      && (!TREE_UNSIGNED (final_type)\n \t\t  || unsigned_arg\n-\t\t  || 2 * TYPE_PRECISION (TREE_TYPE (arg0)) <= TYPE_PRECISION (result_type)))\n+\t\t  || (2 * TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t      <= TYPE_PRECISION (result_type))))\n \t    {\n \t      /* Do an unsigned shift if the operand was zero-extended.  */\n \t      result_type\n@@ -2469,7 +2456,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\t      || TREE_CODE (primop1) == INTEGER_CST)\n \t\t    {\n \t\t      tree primop;\n-\t\t      long constant, mask;\n+\t\t      HOST_WIDE_INT constant, mask;\n \t\t      int unsignedp, bits;\n \n \t\t      if (TREE_CODE (primop0) == INTEGER_CST)\n@@ -2487,9 +2474,9 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \n \t\t      bits = TYPE_PRECISION (TREE_TYPE (primop));\n \t\t      if (bits < TYPE_PRECISION (result_type)\n-\t\t\t  && bits < HOST_BITS_PER_LONG && unsignedp)\n+\t\t\t  && bits < HOST_BITS_PER_WIDE_INT && unsignedp)\n \t\t\t{\n-\t\t\t  mask = (~0L) << bits;\n+\t\t\t  mask = (~ (HOST_WIDE_INT) 0) << bits;\n \t\t\t  if ((mask & constant) != mask)\n \t\t\t    warning (\"comparison of promoted ~unsigned with constant\");\n \t\t\t}\n@@ -4566,19 +4553,19 @@ digest_init (type, init, require_constant, constructor_constant)\n \n \t  TREE_TYPE (inside_init) = type;\n \t  if (TYPE_DOMAIN (type) != 0\n-\t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n-\t    {\n-\t      register int size = TREE_INT_CST_LOW (TYPE_SIZE (type));\n-\t      size = (size + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+\t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n \t      /* Subtract 1 (or sizeof (wchar_t))\n \t\t because it's ok to ignore the terminating null char\n \t\t that is counted in the length of the constant.  */\n-\t      if (size < TREE_STRING_LENGTH (inside_init)\n-\t\t  - (TYPE_PRECISION (typ1) != TYPE_PRECISION (char_type_node)\n-\t\t     ? TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT\n-\t\t     : 1))\n-\t\tpedwarn_init (\"initializer-string for array of chars is too long\");\n-\t    }\n+\t      && 0 > compare_tree_int (TYPE_SIZE_UNIT (type),\n+\t\t\t\t       TREE_STRING_LENGTH (inside_init)\n+\t\t\t\t       - ((TYPE_PRECISION (typ1)\n+\t\t\t\t\t   != TYPE_PRECISION (char_type_node))\n+\t\t\t\t\t  ? (TYPE_PRECISION (wchar_type_node)\n+\t\t\t\t\t     / BITS_PER_UNIT)\n+\t\t\t\t\t  : 1)))\n+\t    pedwarn_init (\"initializer-string for array of chars is too long\");\n+\n \t  return inside_init;\n \t}\n     }"}, {"sha": "df891fce4d8675dadadc578cad6e079d9b425c8b", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1040,9 +1040,8 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t      if (TYPE_SIZE (type) == 0\n \t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n \t\t  || (flag_stack_check && ! STACK_CHECK_BUILTIN\n-\t\t      && (TREE_INT_CST_HIGH (TYPE_SIZE (type)) != 0\n-\t\t\t  || (TREE_INT_CST_LOW (TYPE_SIZE (type))\n-\t\t\t      > STACK_CHECK_MAX_VAR_SIZE * BITS_PER_UNIT))))\n+\t\t      && (0 < compare_tree_int (TYPE_SIZE_UNIT (type),\n+\t\t\t\t\t\tSTACK_CHECK_MAX_VAR_SIZE))))\n \t\t{\n \t\t  /* This is a variable-sized object.  Make space on the stack\n \t\t     for it.  */"}, {"sha": "360fcc12a591d63ab0d36cfad0ff3fb15dd51697", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1,3 +1,12 @@\n+Mon Mar  6 17:52:48 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* actions.c (chill_convert_for_assignment): INDEX is unsigned\n+\tHOST_WIDE_INT.\n+\t* ch-tree.h (DECL_NESTING_LEVEL): Use TREE_INT_CST_HIGH since unsigned.\n+\t* except.c (chill_handle_on_labels): ALTERNATIVE is unsigned.\n+\tUse compare_tree_int.\n+\t(expand_goto_except_cleanup): Likewise.\n+\n 2000-03-01  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n \n \t* decl.c (current_function_decl): Move to toplev.c."}, {"sha": "d7b10e602703ad1d4ae309b3dc425d4152f0e311", "filename": "gcc/ch/actions.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2Factions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2Factions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Factions.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -567,7 +567,7 @@ chill_convert_for_assignment (type, expr, place)\n     {\n       tree domain_min = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n       tree new_list = NULL_TREE;\n-      long index;\n+      unsigned HOST_WIDE_INT index;\n       tree element;\n \n       for (element = TREE_OPERAND (result, 1);\n@@ -587,7 +587,7 @@ chill_convert_for_assignment (type, expr, place)\n \t\t\t\t new_list);\n \t\t  break;\n \t\tcase RANGE_EXPR:\n-\t\t  for (index  = TREE_INT_CST_LOW (TREE_OPERAND (purpose, 0));\n+\t\t  for (index = TREE_INT_CST_LOW (TREE_OPERAND (purpose, 0));\n \t\t       index <= TREE_INT_CST_LOW (TREE_OPERAND (purpose, 1));\n \t\t       index++)\n \t\t    new_list = tree_cons (NULL_TREE,"}, {"sha": "0483a1ddb613d10c43ea8a8be82f46458f231ea5", "filename": "gcc/ch/ch-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2Fch-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2Fch-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fch-tree.h?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -79,7 +79,7 @@ struct lang_identifier\n    Predefined declarations have level -1; the global scope is level 0.\n  */\n #define DECL_NESTING_LEVEL(DECL) \\\n-   ((DECL)->decl.vindex ? TREE_INT_CST_LOW((DECL)->decl.vindex) : -1)\n+   ((DECL)->decl.vindex ? TREE_INT_CST_HIGH((DECL)->decl.vindex) : -1)\n \n /* Nesting of things that can have an ON-unit attached. */\n extern int action_nesting_level;"}, {"sha": "22abd048dda6dce88c6db1999d5db1914062ef33", "filename": "gcc/ch/except.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fch%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fexcept.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -500,7 +500,7 @@ void\n chill_handle_on_labels (labels)\n      tree labels;\n {\n-  int alternative = ++current_handler->prev_on_alternative;\n+  unsigned int alternative = ++current_handler->prev_on_alternative;\n   if (pass == 1)\n     {\n       tree handler_number = build_int_2 (alternative, 0);\n@@ -510,9 +510,13 @@ chill_handle_on_labels (labels)\n   else\n     {\n       /* Find handler_number saved in pass 1. */\n-      tree tmp = current_handler->on_alt_list;\n-      while (TREE_INT_CST_LOW (TREE_PURPOSE (tmp)) != alternative)\n-\ttmp = TREE_CHAIN (tmp);\n+      tree tmp;\n+\n+      for (tmp = current_handler->on_alt_list;\n+\t   compare_tree_int (TREE_PURPOSE (tmp), alternative) != 0;\n+\t   tmp = TREE_CHAIN (tmp))\n+\t;\n+\n       if (expand_exit_needed)\n \texpand_exit_something (), expand_exit_needed = 0;\n       chill_handle_case_label (TREE_PURPOSE (tmp),\n@@ -618,7 +622,7 @@ expand_goto_except_cleanup (label_level)\n   tree last = NULL_TREE;\n   for ( ; list != NULL_TREE; list = TREE_CHAIN (list))\n     {\n-      if (TREE_INT_CST_LOW (TREE_PURPOSE (list)) > label_level)\n+      if (compare_tree_int (TREE_PURPOSE (list), label_level) > 0)\n \tlast = list;\n       else\n \tbreak;"}, {"sha": "e6f17ead128991c89b91a8b075af69c94d0c9f0a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -5,6 +5,16 @@\n \n Mon Mar  6 08:46:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* class.c (dfs_modify_vtables): I is now unsigned.\n+\t(check_bitfield_decl): Use tree_int_cst_sgn and compare_tree_int.\n+\t(build_base_field): Add casts of TREE_INT_CST_LOW to HOST_WIDE_INT.\n+\t* error.c (dump_expr): Cast TREE_INT_CST_HIGH to unsigned.\n+\t* init.c (build_vec_init): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n+\t* method.c (build_overload_int): Cast TREE_INT_CST_HIGH to unsigned.\n+\t* typeck.c (build_binary_op, case TRUNC_DIV_EXPR):\n+\tCall integer_all_onesp.\n+\t* typeck2.c (process_init_constructor): Use compare_tree_int.\n+\n \t* lang-specs.h (as): Don't call if -syntax-only.\n \n 2000-03-06  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "d19172ac98b5ab0c404b7672bed9310d0e100eee", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -3108,7 +3108,7 @@ dfs_modify_vtables (binfo, data)\n \t  tree overrider;\n \t  tree vindex;\n \t  tree delta;\n-\t  HOST_WIDE_INT i;\n+\t  unsigned HOST_WIDE_INT i;\n \n \t  /* Find the function which originally caused this vtable\n \t     entry to be present.  */\n@@ -3627,7 +3627,6 @@ check_bitfield_decl (field)\n   if (DECL_INITIAL (field))\n     {\n       tree w = DECL_INITIAL (field);\n-      register int width = 0;\n \n       /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n       STRIP_NOPS (w);\n@@ -3644,19 +3643,19 @@ check_bitfield_decl (field)\n \t\t       field);\n \t  DECL_INITIAL (field) = NULL_TREE;\n \t}\n-      else if (width = TREE_INT_CST_LOW (w),\n-\t       width < 0)\n+      else if (tree_int_cst_sgn (w) < 0)\n \t{\n \t  DECL_INITIAL (field) = NULL;\n \t  cp_error_at (\"negative width in bit-field `%D'\", field);\n \t}\n-      else if (width == 0 && DECL_NAME (field) != 0)\n+      else if (integer_zerop (w) && DECL_NAME (field) != 0)\n \t{\n \t  DECL_INITIAL (field) = NULL;\n \t  cp_error_at (\"zero width for bit-field `%D'\", field);\n \t}\n-      else if (width\n-\t       > TYPE_PRECISION (long_long_unsigned_type_node))\n+      else if (0 < compare_tree_int (w,\n+\t\t\t\t     TYPE_PRECISION\n+\t\t\t\t     (long_long_unsigned_type_node)))\n \t{\n \t  /* The backend will dump if you try to use something too\n \t     big; avoid that.  */\n@@ -3665,25 +3664,28 @@ check_bitfield_decl (field)\n \t\t TYPE_PRECISION (long_long_unsigned_type_node));\n \t  cp_error_at (\"  in declaration of `%D'\", field);\n \t}\n-      else if (width > TYPE_PRECISION (type)\n+      else if (compare_tree_int (w, TYPE_PRECISION (type)) > 0\n \t       && TREE_CODE (type) != ENUMERAL_TYPE\n \t       && TREE_CODE (type) != BOOLEAN_TYPE)\n \tcp_warning_at (\"width of `%D' exceeds its type\", field);\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t       && ((min_precision (TYPE_MIN_VALUE (type),\n-\t\t\t\t   TREE_UNSIGNED (type)) > width)\n-\t\t   || (min_precision (TYPE_MAX_VALUE (type),\n-\t\t\t\t      TREE_UNSIGNED (type)) > width)))\n+\t       && (0 > compare_tree_int (w,\n+\t\t\t\t\t min_precision (TYPE_MIN_VALUE (type),\n+\t\t\t\t\t\t\tTREE_UNSIGNED (type)))\n+\t\t   ||  0 > compare_tree_int (w,\n+\t\t\t\t\t     min_precision\n+\t\t\t\t\t     (TYPE_MAX_VALUE (type),\n+\t\t\t\t\t      TREE_UNSIGNED (type)))))\n \tcp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n \t\t       field, type);\n \n       if (DECL_INITIAL (field))\n \t{\n \t  DECL_INITIAL (field) = NULL_TREE;\n-\t  DECL_SIZE (field) = bitsize_int (width);\n+\t  DECL_SIZE (field) = bitsize_int (TREE_INT_CST_LOW (w));\n \t  DECL_BIT_FIELD (field) = 1;\n \n-\t  if (width == 0)\n+\t  if (integer_zerop (w))\n \t    {\n #ifdef EMPTY_FIELD_BOUNDARY\n \t      DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n@@ -4164,10 +4166,11 @@ build_base_field (t, binfo, empty_p, saw_empty_p, base_align)\n \t here.  */\n       *base_align = MAX (*base_align, DECL_ALIGN (decl));\n       DECL_SIZE (decl)\n-\t= size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n+\t= size_int (MAX ((HOST_WIDE_INT) TREE_INT_CST_LOW (DECL_SIZE (decl)),\n \t\t\t (int) (*base_align)));\n       DECL_SIZE_UNIT (decl)\n-\t= size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE_UNIT (decl)),\n+\t= size_int (MAX (((HOST_WIDE_INT) TREE_INT_CST_LOW\n+\t\t\t  (DECL_SIZE_UNIT (decl))),\n \t\t\t (int) *base_align / BITS_PER_UNIT));\n     }\n "}, {"sha": "0a263847fcb418859cfba188008ff6548d3e2e85", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1490,11 +1490,12 @@ dump_expr (t, flags)\n \t    dump_char (TREE_INT_CST_LOW (t));\n \t    OB_PUTC ('\\'');\n \t  }\n-\telse if (TREE_INT_CST_HIGH (t)\n+\telse if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (t)\n \t\t != (TREE_INT_CST_LOW (t) >> (HOST_BITS_PER_WIDE_INT - 1)))\n \t  {\n \t    tree val = t;\n-\t    if (TREE_INT_CST_HIGH (val) < 0)\n+\n+\t    if (tree_int_cst_sgn (val) < 0)\n \t      {\n \t\tOB_PUTC ('-');\n \t\tval = build_int_2 (~TREE_INT_CST_LOW (val),"}, {"sha": "a2e0d2208e221fe1da2d30b33b152d27503aaa17", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -2873,8 +2873,9 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \n   if (from_array\n       || (TYPE_NEEDS_CONSTRUCTING (type)\n-\t  && !(TREE_CODE (maxindex) == INTEGER_CST\n-\t       && num_initialized_elts == TREE_INT_CST_LOW (maxindex) + 1)))\n+\t  && ! (TREE_CODE (maxindex) == INTEGER_CST\n+\t\t&& (num_initialized_elts\n+\t\t    == (HOST_WIDE_INT) TREE_INT_CST_LOW (maxindex) + 1))))\n     {\n       /* If the ITERATOR is equal to -1, then we don't have to loop;\n \t we've already initialized all the elements.  */"}, {"sha": "4a41e5ab80b269717485f49fc1cbb0bcfb4340fb", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -600,16 +600,16 @@ build_overload_int (value, flags)\n   /* If the high-order word is not merely a sign-extension of the\n      low-order word, we must use a special output routine that can\n      deal with this.  */\n-  if (TREE_INT_CST_HIGH (value)\n+  if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (value)\n       != (TREE_INT_CST_LOW (value) >> (HOST_BITS_PER_WIDE_INT - 1)))\n     {\n       multiple_words_p = 1;\n       /* And there is certainly going to be more than one digit.  */\n       multiple_digits_p = 1;\n     }\n   else \n-    multiple_digits_p = (TREE_INT_CST_LOW (value) > 9\n-\t\t\t || TREE_INT_CST_LOW (value) < -9);\n+    multiple_digits_p = ((HOST_WIDE_INT) TREE_INT_CST_LOW (value) > 9\n+\t\t\t || (HOST_WIDE_INT) TREE_INT_CST_LOW (value) < -9);\n \n   /* If necessary, add a leading underscore.  */\n   if (multiple_digits_p && (flags & mf_use_underscores_around_value))"}, {"sha": "a47b088a44e2093d3d6d0f1482678590fe3f202b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -3436,8 +3436,8 @@ build_binary_op (code, orig_op0, orig_op1)\n \t    shorten = ((TREE_CODE (op0) == NOP_EXPR\n \t\t\t&& TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n \t\t       || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t   && (TREE_INT_CST_LOW (op1) != -1\n-\t\t\t       || TREE_INT_CST_HIGH (op1) != -1)));\n+\t\t\t   && ! integer_all_onesp (op1)));\n+\n \t  common = 1;\n \t}\n       break;\n@@ -3491,8 +3491,7 @@ build_binary_op (code, orig_op0, orig_op1)\n \t  shorten = ((TREE_CODE (op0) == NOP_EXPR\n \t\t      && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n \t\t     || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t && (TREE_INT_CST_LOW (op1) != -1\n-\t\t\t     || TREE_INT_CST_HIGH (op1) != -1)));\n+\t\t\t && ! integer_all_onesp (op1)));\n \t  common = 1;\n \t}\n       break;"}, {"sha": "9c1a33e95c3ad6d38715bab25d2c3f2147f45a44", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -754,7 +754,7 @@ process_init_constructor (type, init, elts)\n \t    {\n \t      if (TREE_PURPOSE (tail)\n \t\t  && (TREE_CODE (TREE_PURPOSE (tail)) != INTEGER_CST\n-\t\t      || TREE_INT_CST_LOW (TREE_PURPOSE (tail)) != i))\n+\t\t      || compare_tree_int (TREE_PURPOSE (tail), i) != 0))\n \t\tsorry (\"non-trivial labeled initializers\");\n \n \t      if (TREE_VALUE (tail) != 0)\n@@ -1305,19 +1305,19 @@ enum_name_string (value, type)\n      tree type;\n {\n   register tree values = TYPE_VALUES (type);\n-  register HOST_WIDE_INT intval = TREE_INT_CST_LOW (value);\n \n   my_friendly_assert (TREE_CODE (type) == ENUMERAL_TYPE, 324);\n-  while (values\n-\t && TREE_INT_CST_LOW (TREE_VALUE (values)) != intval)\n+\n+  while (values && ! tree_int_cst_equal (TREE_VALUE (values), value))\n     values = TREE_CHAIN (values);\n+\n   if (values == NULL_TREE)\n     {\n-      char *buf = (char *)oballoc (16 + TYPE_NAME_LENGTH (type));\n+      char *buf = (char *) oballoc (16 + TYPE_NAME_LENGTH (type));\n \n       /* Value must have been cast.  */\n       sprintf (buf, \"(enum %s)%ld\",\n-\t       TYPE_NAME_STRING (type), (long) intval);\n+\t       TYPE_NAME_STRING (type), (long) TREE_INT_CST_LOW (value));\n       return buf;\n     }\n   return IDENTIFIER_POINTER (TREE_PURPOSE (values));"}, {"sha": "4c84c31184dd031100d4ce7907c6faa51a64e7a0", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1508,7 +1508,7 @@ dbxout_type (type, full, show_arg_types)\n \t    fprintf (asmfile, HOST_WIDE_INT_PRINT_UNSIGNED,\n \t\t     TREE_INT_CST_LOW (TREE_VALUE (tem)));\n \t  else if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == -1\n-\t\t   && TREE_INT_CST_LOW (TREE_VALUE (tem)) < 0)\n+\t\t   && (HOST_WIDE_INT) TREE_INT_CST_LOW (TREE_VALUE (tem)) < 0)\n \t    fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n \t\t     TREE_INT_CST_LOW (TREE_VALUE (tem)));\n \t  else"}, {"sha": "405a53f24cb4faf32a1f809fa550b1424ce99658", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1414,8 +1414,7 @@ expand_eh_region_start_tree (decl, cleanup)\n \n \t  /* is the second argument 2?  */\n \t  && TREE_CODE (TREE_VALUE (args)) == INTEGER_CST\n-\t  && TREE_INT_CST_LOW (TREE_VALUE (args)) == 2\n-\t  && TREE_INT_CST_HIGH (TREE_VALUE (args)) == 0\n+\t  && compare_tree_int (TREE_VALUE (args), 2) == 0\n \n \t  /* Make sure there are no other arguments.  */\n \t  && TREE_CHAIN (args) == NULL_TREE)"}, {"sha": "321abd798316f8e3fe0debaa65ab2fff26fd38ab", "filename": "gcc/expr.c", "status": "modified", "additions": 69, "deletions": 68, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -3979,7 +3979,7 @@ is_zeros_p (exp)\n       return is_zeros_p (TREE_OPERAND (exp, 0));\n \n     case INTEGER_CST:\n-      return TREE_INT_CST_LOW (exp) == 0 && TREE_INT_CST_HIGH (exp) == 0;\n+      return integer_zerop (exp);\n \n     case COMPLEX_CST:\n       return\n@@ -4317,14 +4317,15 @@ store_constructor (exp, target, align, cleared, size)\n \t\t{\n \t\t  tree lo_index = TREE_OPERAND (index, 0);\n \t\t  tree hi_index = TREE_OPERAND (index, 1);\n+\n \t\t  if (TREE_CODE (lo_index) != INTEGER_CST\n \t\t      || TREE_CODE (hi_index) != INTEGER_CST)\n \t\t    {\n \t\t      need_to_clear = 1;\n \t\t      break;\n \t\t    }\n-\t\t  this_node_count = TREE_INT_CST_LOW (hi_index)\n-\t\t    - TREE_INT_CST_LOW (lo_index) + 1;\n+\t\t  this_node_count = (TREE_INT_CST_LOW (hi_index)\n+\t\t\t\t     - TREE_INT_CST_LOW (lo_index) + 1);\n \t\t}\n \t      else\n \t\tthis_node_count = 1;\n@@ -4594,8 +4595,8 @@ store_constructor (exp, target, align, cleared, size)\n \t\t  ? nbits != 1\n \t\t  : (TREE_CODE (TREE_VALUE (elt)) != INTEGER_CST\n \t\t     || TREE_CODE (TREE_PURPOSE (elt)) != INTEGER_CST\n-\t\t     || (TREE_INT_CST_LOW (TREE_VALUE (elt))\n-\t\t\t - TREE_INT_CST_LOW (TREE_PURPOSE (elt)) + 1\n+\t\t     || ((HOST_WIDE_INT) TREE_INT_CST_LOW (TREE_VALUE (elt))\n+\t\t\t - (HOST_WIDE_INT) TREE_INT_CST_LOW (TREE_PURPOSE (elt)) + 1\n \t\t\t != nbits))))\n \t    clear_storage (target, expr_size (exp),\n \t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n@@ -4777,10 +4778,9 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n       /* If the RHS and field are a constant size and the size of the\n \t RHS isn't the same size as the bitfield, we must use bitfield\n \t operations.  */\n-      || ((bitsize >= 0\n-\t   && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST)\n-\t  && (TREE_INT_CST_HIGH (TYPE_SIZE (TREE_TYPE (exp))) != 0\n-\t      || TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))) != bitsize)))\n+      || (bitsize >= 0\n+\t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST\n+\t  && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) != 0))\n     {\n       rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n@@ -6008,8 +6008,7 @@ expand_expr (exp, target, tmode, modifier)\n \n     case INTEGER_CST:\n       return immed_double_const (TREE_INT_CST_LOW (exp),\n-\t\t\t\t TREE_INT_CST_HIGH (exp),\n-\t\t\t\t mode);\n+\t\t\t\t TREE_INT_CST_HIGH (exp), mode);\n \n     case CONST_DECL:\n       return expand_expr (DECL_INITIAL (exp), target, VOIDmode,\n@@ -6333,9 +6332,10 @@ expand_expr (exp, target, tmode, modifier)\n \t\t&& ((mode == BLKmode\n \t\t     && ! (target != 0 && safe_from_p (target, exp, 1)))\n \t\t    || TREE_ADDRESSABLE (exp)\n-\t\t    || (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t\t\t&& (!MOVE_BY_PIECES_P \n-                             (TREE_INT_CST_LOW (TYPE_SIZE (type))/BITS_PER_UNIT,\n+\t\t    || (TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST\n+\t\t\t&& TREE_INT_CST_HIGH (TYPE_SIZE_UNIT (type)) == 0\n+\t\t\t&& (! MOVE_BY_PIECES_P \n+\t\t\t    (TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type)),\n \t\t\t     TYPE_ALIGN (type) / BITS_PER_UNIT))\n \t\t\t&& ! mostly_zeros_p (exp))))\n \t       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))\n@@ -6385,18 +6385,17 @@ expand_expr (exp, target, tmode, modifier)\n \ttree exp2;\n \ttree index;\n  \ttree string = string_constant (exp1, &index);\n- \tint i;\n  \n \t/* Try to optimize reads from const strings.  */\n  \tif (string\n  \t    && TREE_CODE (string) == STRING_CST\n  \t    && TREE_CODE (index) == INTEGER_CST\n- \t    && !TREE_INT_CST_HIGH (index)\n- \t    && (i = TREE_INT_CST_LOW (index)) < TREE_STRING_LENGTH (string)\n+\t    && compare_tree_int (index, TREE_STRING_LENGTH (string)) < 0\n  \t    && GET_MODE_CLASS (mode) == MODE_INT\n  \t    && GET_MODE_SIZE (mode) == 1\n \t    && modifier != EXPAND_MEMORY_USE_WO)\n- \t  return GEN_INT (TREE_STRING_POINTER (string)[i]);\n+ \t  return\n+\t    GEN_INT (TREE_STRING_POINTER (string)[TREE_INT_CST_LOW (index)]);\n \n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n@@ -6481,31 +6480,33 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (TREE_CODE (array) == STRING_CST\n \t    && TREE_CODE (index) == INTEGER_CST\n-\t    && !TREE_INT_CST_HIGH (index)\n-\t    && (i = TREE_INT_CST_LOW (index)) < TREE_STRING_LENGTH (array)\n+\t    && compare_tree_int (index, TREE_STRING_LENGTH (array)) < 0\n \t    && GET_MODE_CLASS (mode) == MODE_INT\n \t    && GET_MODE_SIZE (mode) == 1)\n-\t  return GEN_INT (TREE_STRING_POINTER (array)[i]);\n+\t  return\n+\t    GEN_INT (TREE_STRING_POINTER (array)[TREE_INT_CST_LOW (index)]);\n \n \t/* If this is a constant index into a constant array,\n \t   just get the value from the array.  Handle both the cases when\n \t   we have an explicit constructor and when our operand is a variable\n \t   that was declared const.  */\n \n-\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array))\n+\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n+\t    && TREE_CODE (index) == INTEGER_CST\n+\t    && 0 > compare_tree_int (index, \n+\t\t\t\t     list_length (CONSTRUCTOR_ELTS\n+\t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))))\n \t  {\n-\t    if (TREE_CODE (index) == INTEGER_CST\n-\t\t&& TREE_INT_CST_HIGH (index) == 0)\n-\t      {\n-\t\ttree elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n-\n-\t\ti = TREE_INT_CST_LOW (index);\n-\t\twhile (elem && i--)\n-\t\t  elem = TREE_CHAIN (elem);\n-\t\tif (elem)\n-\t\t  return expand_expr (fold (TREE_VALUE (elem)), target,\n-\t\t\t\t      tmode, ro_modifier);\n-\t      }\n+\t    tree elem;\n+\n+\t    for (elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n+\t\t i = TREE_INT_CST_LOW (index);\n+\t\t elem != 0 && i != 0; i--, elem = TREE_CHAIN (elem))\n+\t      ;\n+\n+\t    if (elem)\n+\t      return expand_expr (fold (TREE_VALUE (elem)), target,\n+\t\t\t\t  tmode, ro_modifier);\n \t  }\n \t  \n \telse if (optimize >= 1\n@@ -6517,22 +6518,22 @@ expand_expr (exp, target, tmode, modifier)\n \t      {\n \t\ttree init = DECL_INITIAL (array);\n \n-\t\ti = TREE_INT_CST_LOW (index);\n \t\tif (TREE_CODE (init) == CONSTRUCTOR)\n \t\t  {\n \t\t    tree elem = CONSTRUCTOR_ELTS (init);\n \n-\t\t    while (elem\n-\t\t\t   && !tree_int_cst_equal (TREE_PURPOSE (elem), index))\n-\t\t      elem = TREE_CHAIN (elem);\n+\t\t    for (elem = CONSTRUCTOR_ELTS (init);\n+\t\t\t ! tree_int_cst_equal (TREE_PURPOSE (elem), index);\n+\t\t\t elem = TREE_CHAIN (elem))\n+\t\t      ;\n+\n \t\t    if (elem)\n \t\t      return expand_expr (fold (TREE_VALUE (elem)), target,\n \t\t\t\t\t  tmode, ro_modifier);\n \t\t  }\n \t\telse if (TREE_CODE (init) == STRING_CST\n-\t\t\t && TREE_INT_CST_HIGH (index) == 0\n-\t\t\t && (TREE_INT_CST_LOW (index)\n-\t\t\t     < TREE_STRING_LENGTH (init)))\n+\t\t\t && 0 > compare_tree_int (index,\n+\t\t\t\t\t\t  TREE_STRING_LENGTH (init)))\n \t\t  return (GEN_INT\n \t\t\t  (TREE_STRING_POINTER\n \t\t\t   (init)[TREE_INT_CST_LOW (index)]));\n@@ -6763,10 +6764,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t    || ((bitsize >= 0\n \t\t\t && (TREE_CODE (TYPE_SIZE (TREE_TYPE (exp)))\n \t\t\t     == INTEGER_CST)\n-\t\t\t && ((TREE_INT_CST_HIGH (TYPE_SIZE (TREE_TYPE (exp)))\n-\t\t\t      != 0)\n-\t\t\t     || (TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp)))\n-\t\t\t\t != bitsize))))))\n+\t\t\t && 0 != compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)),\n+\t\t\t\t\t\t   bitsize)))))\n \t    || (modifier != EXPAND_CONST_ADDRESS\n \t\t&& modifier != EXPAND_INITIALIZER\n \t\t&& mode == BLKmode\n@@ -8153,8 +8152,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t|| TREE_CODE (rhs) == BIT_AND_EXPR)\n \t    && TREE_OPERAND (rhs, 0) == lhs\n \t    && TREE_CODE (TREE_OPERAND (rhs, 1)) == COMPONENT_REF\n-\t    && TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (lhs, 1))) == 1\n-\t    && TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (TREE_OPERAND (rhs, 1), 1))) == 1)\n+\t    && integer_onep (DECL_SIZE (TREE_OPERAND (lhs, 1)))\n+\t    && integer_onep (DECL_SIZE (TREE_OPERAND (TREE_OPERAND (rhs, 1), 1))))\n \t  {\n \t    rtx label = gen_label_rtx ();\n \n@@ -8539,20 +8538,20 @@ expand_expr_unaligned (exp, palign)\n \t   we have an explicit constructor and when our operand is a variable\n \t   that was declared const.  */\n \n-\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array))\n+\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n+\t    && 0 > compare_tree_int (index, \n+\t\t\t\t     list_length (CONSTRUCTOR_ELTS\n+\t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))))\n \t  {\n-\t    if (TREE_CODE (index) == INTEGER_CST\n-\t\t&& TREE_INT_CST_HIGH (index) == 0)\n-\t      {\n-\t\ttree elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n-\n-\t\ti = TREE_INT_CST_LOW (index);\n-\t\twhile (elem && i--)\n-\t\t  elem = TREE_CHAIN (elem);\n-\t\tif (elem)\n-\t\t  return expand_expr_unaligned (fold (TREE_VALUE (elem)),\n-\t\t\t\t\t\tpalign);\n-\t      }\n+\t    tree elem;\n+\n+\t    for (elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n+\t\t i = TREE_INT_CST_LOW (index);\n+\t\t elem != 0 && i != 0; i--, elem = TREE_CHAIN (elem))\n+\t      ;\n+\n+\t    if (elem)\n+\t      return expand_expr_unaligned (fold (TREE_VALUE (elem)), palign);\n \t  }\n \t  \n \telse if (optimize >= 1\n@@ -8564,14 +8563,15 @@ expand_expr_unaligned (exp, palign)\n \t      {\n \t\ttree init = DECL_INITIAL (array);\n \n-\t\ti = TREE_INT_CST_LOW (index);\n \t\tif (TREE_CODE (init) == CONSTRUCTOR)\n \t\t  {\n-\t\t    tree elem = CONSTRUCTOR_ELTS (init);\n+\t\t    tree elem;\n+\n+\t\t    for (elem = CONSTRUCTOR_ELTS (init);\n+\t\t\t ! tree_int_cst_equal (TREE_PURPOSE (elem), index);\n+\t\t\t elem = TREE_CHAIN (elem))\n+\t\t      ;\n \n-\t\t    while (elem\n-\t\t\t   && !tree_int_cst_equal (TREE_PURPOSE (elem), index))\n-\t\t      elem = TREE_CHAIN (elem);\n \t\t    if (elem)\n \t\t      return expand_expr_unaligned (fold (TREE_VALUE (elem)),\n \t\t\t\t\t\t    palign);\n@@ -9289,7 +9289,7 @@ do_jump (exp, if_false_label, if_true_label)\n       if (! SLOW_BYTE_ACCESS\n \t  && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n \t  && TYPE_PRECISION (TREE_TYPE (exp)) <= HOST_BITS_PER_WIDE_INT\n-\t  && (i = floor_log2 (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))) >= 0\n+\t  && (i = tree_floor_log2 (TREE_OPERAND (exp, 1))) >= 0\n \t  && (mode = mode_for_size (i + 1, MODE_INT, 0)) != BLKmode\n \t  && (type = type_for_mode (mode, 1)) != 0\n \t  && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n@@ -10204,8 +10204,9 @@ do_store_flag (exp, target, mode, only_cheap)\n       if (TREE_CODE (inner) == RSHIFT_EXPR\n \t  && TREE_CODE (TREE_OPERAND (inner, 1)) == INTEGER_CST\n \t  && TREE_INT_CST_HIGH (TREE_OPERAND (inner, 1)) == 0\n-\t  && (bitnum + TREE_INT_CST_LOW (TREE_OPERAND (inner, 1))\n-\t      < TYPE_PRECISION (type)))\n+\t  && bitnum < TYPE_PRECISION (type)\n+\t  && 0 > compare_tree_int (TREE_OPERAND (inner, 1),\n+\t\t\t\t   bitnum - TYPE_PRECISION (type)))\n \t{\n \t  bitnum += TREE_INT_CST_LOW (TREE_OPERAND (inner, 1));\n \t  inner = TREE_OPERAND (inner, 0);"}, {"sha": "815b83f6b414c38c40495695c0e3391c057e6648", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1,3 +1,9 @@\n+Mon Mar  6 18:05:19 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* com.c (ffecom_f2c_set_lio_code_): Use compare_tree_int.\n+\t(ffecom_sym_transform_, ffecom_transform_common_): Likewise.\n+\t(ffecom_transform_equiv_): Likewise.\n+\n Mon Mar  6 13:01:19 2000  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* ansify.c (die_unless): Don't use ANSI string concatenation."}, {"sha": "a13853d2ba0f9d369ec069b4f8dfceaab396387e", "filename": "gcc/f/com.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -6043,8 +6043,8 @@ ffecom_f2c_set_lio_code_ (ffeinfoBasictype bt, int size,\n   tree t;\n \n   for (j = 0; ((size_t) j) < ARRAY_SIZE (ffecom_tree_type[0]); ++j)\n-    if (((t = ffecom_tree_type[bt][j]) != NULL_TREE)\n-\t&& (TREE_INT_CST_LOW (TYPE_SIZE (t)) == size))\n+    if ((t = ffecom_tree_type[bt][j]) != NULL_TREE\n+\t&& compare_tree_int (TYPE_SIZE (t), size) == 0)\n       {\n \tassert (code != -1);\n \tffecom_f2c_typecode_[bt][j] = code;\n@@ -7757,9 +7757,8 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\tif (st != NULL && DECL_SIZE (t) != error_mark_node)\n \t\t  {\n \t\t    assert (TREE_CODE (DECL_SIZE_UNIT (t)) == INTEGER_CST);\n-\t\t    assert (TREE_INT_CST_HIGH (DECL_SIZE_UNIT (t)) == 0);\n-\t\t    assert (TREE_INT_CST_LOW (DECL_SIZE_UNIT (t))\n-\t\t\t    == ffestorag_size (st));\n+\t\t    assert (0 == compare_tree_int (DECL_SIZE_UNIT (t),\n+\t\t\t\t\t\t   ffestorag_size (st)));\n \t\t  }\n \n \t\tresume_momentary (yes);\n@@ -8817,9 +8816,9 @@ ffecom_transform_common_ (ffesymbol s)\n     {\n       assert (DECL_SIZE_UNIT (cbt) != NULL_TREE);\n       assert (TREE_CODE (DECL_SIZE_UNIT (cbt)) == INTEGER_CST);\n-      assert (TREE_INT_CST_HIGH (DECL_SIZE_UNIT (cbt)) == 0);\n-      assert (TREE_INT_CST_LOW (DECL_SIZE_UNIT (cbt))\n-\t      == ffeglobal_common_size (g) + ffeglobal_common_pad (g));\n+      assert (0 == compare_tree_int (DECL_SIZE_UNIT (cbt),\n+\t\t\t\t     (ffeglobal_common_size (g)\n+\t\t\t\t      + ffeglobal_common_pad (g))));\n     }\n \n   ffeglobal_set_hook (g, cbt);\n@@ -8951,9 +8950,9 @@ ffecom_transform_equiv_ (ffestorag eqst)\n \n   {\n     assert (TREE_CODE (DECL_SIZE_UNIT (eqt)) == INTEGER_CST);\n-    assert (TREE_INT_CST_HIGH (DECL_SIZE_UNIT (eqt)) == 0);\n-    assert (TREE_INT_CST_LOW (DECL_SIZE_UNIT (eqt))\n-\t    == ffestorag_size (eqst) + ffestorag_modulo (eqst));\n+    assert (0 == compare_tree_int (DECL_SIZE_UNIT (eqt),\n+\t\t\t\t   (ffestorag_size (eqst)\n+\t\t\t\t    + ffestorag_modulo (eqst))));\n   }\n \n   ffestorag_set_hook (eqst, eqt);"}, {"sha": "d24a7d1435f1a8affe2c91170c8b5f49afb60751", "filename": "gcc/fold-const.c", "status": "modified", "additions": 209, "deletions": 176, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -54,13 +54,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n \n static void encode\t\tPARAMS ((HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT));\n+\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT));\n static void decode\t\tPARAMS ((HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *, HOST_WIDE_INT *));\n-int div_and_round_double\tPARAMS ((enum tree_code, int, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT *,\n-\t\t\t\t\t HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n \t\t\t\t\t HOST_WIDE_INT *));\n static tree negate_expr\t\tPARAMS ((tree));\n static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n@@ -136,7 +133,8 @@ static int count_cond\t\tPARAMS ((tree, int));\n static void\n encode (words, low, hi)\n      HOST_WIDE_INT *words;\n-     HOST_WIDE_INT low, hi;\n+     unsigned HOST_WIDE_INT low;\n+     HOST_WIDE_INT hi;\n {\n   words[0] = LOWPART (low);\n   words[1] = HIGHPART (low);\n@@ -151,7 +149,8 @@ encode (words, low, hi)\n static void\n decode (words, low, hi)\n      HOST_WIDE_INT *words;\n-     HOST_WIDE_INT *low, *hi;\n+     unsigned HOST_WIDE_INT *low;\n+     HOST_WIDE_INT *hi;\n {\n   *low = words[0] + words[1] * BASE;\n   *hi = words[2] + words[3] * BASE;\n@@ -172,8 +171,9 @@ force_fit_type (t, overflow)\n      tree t;\n      int overflow;\n {\n-  HOST_WIDE_INT low, high;\n-  register int prec;\n+  unsigned HOST_WIDE_INT low;\n+  HOST_WIDE_INT high;\n+  unsigned int prec;\n \n   if (TREE_CODE (t) == REAL_CST)\n     {\n@@ -206,7 +206,7 @@ force_fit_type (t, overflow)\n     {\n       TREE_INT_CST_HIGH (t) = 0;\n       if (prec < HOST_BITS_PER_WIDE_INT)\n-\tTREE_INT_CST_LOW (t) &= ~((HOST_WIDE_INT) (-1) << prec);\n+\tTREE_INT_CST_LOW (t) &= ~((unsigned HOST_WIDE_INT) (-1) << prec);\n     }\n \n   /* Unsigned types do not suffer sign extension or overflow.  */\n@@ -216,9 +216,11 @@ force_fit_type (t, overflow)\n   /* If the value's sign bit is set, extend the sign.  */\n   if (prec != 2 * HOST_BITS_PER_WIDE_INT\n       && (prec > HOST_BITS_PER_WIDE_INT\n-\t  ? (TREE_INT_CST_HIGH (t)\n-\t     & ((HOST_WIDE_INT) 1 << (prec - HOST_BITS_PER_WIDE_INT - 1)))\n-\t  : TREE_INT_CST_LOW (t) & ((HOST_WIDE_INT) 1 << (prec - 1))))\n+\t  ? 0 != (TREE_INT_CST_HIGH (t)\n+\t\t  & ((HOST_WIDE_INT) 1\n+\t\t     << (prec - HOST_BITS_PER_WIDE_INT - 1)))\n+\t  : 0 != (TREE_INT_CST_LOW (t)\n+\t\t  & ((unsigned HOST_WIDE_INT) 1 << (prec - 1)))))\n     {\n       /* Value is negative:\n \t set to 1 all the bits that are outside this type's precision.  */\n@@ -229,7 +231,7 @@ force_fit_type (t, overflow)\n \t{\n \t  TREE_INT_CST_HIGH (t) = -1;\n \t  if (prec < HOST_BITS_PER_WIDE_INT)\n-\t    TREE_INT_CST_LOW (t) |= ((HOST_WIDE_INT) (-1) << prec);\n+\t    TREE_INT_CST_LOW (t) |= ((unsigned HOST_WIDE_INT) (-1) << prec);\n \t}\n     }\n \n@@ -246,13 +248,16 @@ force_fit_type (t, overflow)\n \n int\n add_double (l1, h1, l2, h2, lv, hv)\n-     HOST_WIDE_INT l1, h1, l2, h2;\n-     HOST_WIDE_INT *lv, *hv;\n+     unsigned HOST_WIDE_INT l1, l2;\n+     HOST_WIDE_INT h1, h2;\n+     unsigned HOST_WIDE_INT *lv;\n+     HOST_WIDE_INT *hv;\n {\n-  HOST_WIDE_INT l, h;\n+  unsigned HOST_WIDE_INT l;\n+  HOST_WIDE_INT h;\n \n   l = l1 + l2;\n-  h = h1 + h2 + ((unsigned HOST_WIDE_INT) l < (unsigned HOST_WIDE_INT) l1);\n+  h = h1 + h2 + (l < l1);\n \n   *lv = l;\n   *hv = h;\n@@ -266,8 +271,10 @@ add_double (l1, h1, l2, h2, lv, hv)\n \n int\n neg_double (l1, h1, lv, hv)\n-     HOST_WIDE_INT l1, h1;\n-     HOST_WIDE_INT *lv, *hv;\n+     unsigned HOST_WIDE_INT l1;\n+     HOST_WIDE_INT h1;\n+     unsigned HOST_WIDE_INT *lv;\n+     HOST_WIDE_INT *hv;\n {\n   if (l1 == 0)\n     {\n@@ -291,15 +298,18 @@ neg_double (l1, h1, lv, hv)\n \n int\n mul_double (l1, h1, l2, h2, lv, hv)\n-     HOST_WIDE_INT l1, h1, l2, h2;\n-     HOST_WIDE_INT *lv, *hv;\n+     unsigned HOST_WIDE_INT l1, l2;\n+     HOST_WIDE_INT h1, h2;\n+     unsigned HOST_WIDE_INT *lv;\n+     HOST_WIDE_INT *hv;\n {\n   HOST_WIDE_INT arg1[4];\n   HOST_WIDE_INT arg2[4];\n   HOST_WIDE_INT prod[4 * 2];\n   register unsigned HOST_WIDE_INT carry;\n   register int i, j, k;\n-  HOST_WIDE_INT toplow, tophigh, neglow, neghigh;\n+  unsigned HOST_WIDE_INT toplow, neglow;\n+  HOST_WIDE_INT tophigh, neghigh;\n \n   encode (arg1, l1, h1);\n   encode (arg2, l2, h2);\n@@ -348,9 +358,11 @@ mul_double (l1, h1, l2, h2, lv, hv)\n \n void\n lshift_double (l1, h1, count, prec, lv, hv, arith)\n-     HOST_WIDE_INT l1, h1, count;\n-     int prec;\n-     HOST_WIDE_INT *lv, *hv;\n+     unsigned HOST_WIDE_INT l1;\n+     HOST_WIDE_INT h1, count;\n+     unsigned int prec;\n+     unsigned HOST_WIDE_INT *lv;\n+     HOST_WIDE_INT *hv;\n      int arith;\n {\n   if (count < 0)\n@@ -373,14 +385,14 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n     }\n   else if (count >= HOST_BITS_PER_WIDE_INT)\n     {\n-      *hv = (unsigned HOST_WIDE_INT) l1 << (count - HOST_BITS_PER_WIDE_INT);\n+      *hv = l1 << (count - HOST_BITS_PER_WIDE_INT);\n       *lv = 0;\n     }\n   else\n     {\n       *hv = (((unsigned HOST_WIDE_INT) h1 << count)\n-\t     | ((unsigned HOST_WIDE_INT) l1 >> (HOST_BITS_PER_WIDE_INT - count - 1) >> 1));\n-      *lv = (unsigned HOST_WIDE_INT) l1 << count;\n+\t     | (l1 >> (HOST_BITS_PER_WIDE_INT - count - 1) >> 1));\n+      *lv = l1 << count;\n     }\n }\n \n@@ -391,12 +403,15 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n \n void\n rshift_double (l1, h1, count, prec, lv, hv, arith)\n-     HOST_WIDE_INT l1, h1, count;\n-     int prec ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT *lv, *hv;\n+     unsigned HOST_WIDE_INT l1;\n+     HOST_WIDE_INT h1, count;\n+     unsigned int prec ATTRIBUTE_UNUSED;\n+     unsigned HOST_WIDE_INT *lv;\n+     HOST_WIDE_INT *hv;\n      int arith;\n {\n   unsigned HOST_WIDE_INT signmask;\n+\n   signmask = (arith\n \t      ? -((unsigned HOST_WIDE_INT) h1 >> (HOST_BITS_PER_WIDE_INT - 1))\n \t      : 0);\n@@ -421,7 +436,7 @@ rshift_double (l1, h1, count, prec, lv, hv, arith)\n     }\n   else\n     {\n-      *lv = (((unsigned HOST_WIDE_INT) l1 >> count)\n+      *lv = ((l1 >> count)\n \t     | ((unsigned HOST_WIDE_INT) h1 << (HOST_BITS_PER_WIDE_INT - count - 1) << 1));\n       *hv = ((signmask << (HOST_BITS_PER_WIDE_INT - count))\n \t     | ((unsigned HOST_WIDE_INT) h1 >> count));\n@@ -435,11 +450,14 @@ rshift_double (l1, h1, count, prec, lv, hv, arith)\n \n void\n lrotate_double (l1, h1, count, prec, lv, hv)\n-     HOST_WIDE_INT l1, h1, count;\n-     int prec;\n-     HOST_WIDE_INT *lv, *hv;\n+     unsigned HOST_WIDE_INT l1;\n+     HOST_WIDE_INT h1, count;\n+     unsigned int prec;\n+     unsigned HOST_WIDE_INT *lv;\n+     HOST_WIDE_INT *hv;\n {\n-  HOST_WIDE_INT s1l, s1h, s2l, s2h;\n+  unsigned HOST_WIDE_INT s1l, s2l;\n+  HOST_WIDE_INT s1h, s2h;\n \n   count %= prec;\n   if (count < 0)\n@@ -457,11 +475,14 @@ lrotate_double (l1, h1, count, prec, lv, hv)\n \n void\n rrotate_double (l1, h1, count, prec, lv, hv)\n-     HOST_WIDE_INT l1, h1, count;\n-     int prec;\n-     HOST_WIDE_INT *lv, *hv;\n+     unsigned HOST_WIDE_INT l1;\n+     HOST_WIDE_INT h1, count;\n+     unsigned int prec;\n+     unsigned HOST_WIDE_INT *lv;\n+     HOST_WIDE_INT *hv;\n {\n-  HOST_WIDE_INT s1l, s1h, s2l, s2h;\n+  unsigned HOST_WIDE_INT s1l, s2l;\n+  HOST_WIDE_INT s1h, s2h;\n \n   count %= prec;\n   if (count < 0)\n@@ -488,23 +509,26 @@ div_and_round_double (code, uns,\n \t\t      lquo, hquo, lrem, hrem)\n      enum tree_code code;\n      int uns;\n-     HOST_WIDE_INT lnum_orig, hnum_orig; /* num == numerator == dividend */\n-     HOST_WIDE_INT lden_orig, hden_orig; /* den == denominator == divisor */\n-     HOST_WIDE_INT *lquo, *hquo, *lrem, *hrem;\n+     unsigned HOST_WIDE_INT lnum_orig; /* num == numerator == dividend */\n+     HOST_WIDE_INT hnum_orig;\n+     unsigned HOST_WIDE_INT lden_orig; /* den == denominator == divisor */\n+     HOST_WIDE_INT hden_orig;\n+     unsigned HOST_WIDE_INT *lquo, *lrem;\n+     HOST_WIDE_INT *hquo, *hrem;\n {\n   int quo_neg = 0;\n   HOST_WIDE_INT num[4 + 1];\t/* extra element for scaling.  */\n   HOST_WIDE_INT den[4], quo[4];\n   register int i, j;\n   unsigned HOST_WIDE_INT work;\n-  register unsigned HOST_WIDE_INT carry = 0;\n-  HOST_WIDE_INT lnum = lnum_orig;\n+  unsigned HOST_WIDE_INT carry = 0;\n+  unsigned HOST_WIDE_INT lnum = lnum_orig;\n   HOST_WIDE_INT hnum = hnum_orig;\n-  HOST_WIDE_INT lden = lden_orig;\n+  unsigned HOST_WIDE_INT lden = lden_orig;\n   HOST_WIDE_INT hden = hden_orig;\n   int overflow = 0;\n \n-  if ((hden == 0) && (lden == 0))\n+  if (hden == 0 && lden == 0)\n     overflow = 1, lden = 1;\n \n   /* calculate quotient sign and convert operands to unsigned.  */\n@@ -514,7 +538,8 @@ div_and_round_double (code, uns,\n \t{\n \t  quo_neg = ~ quo_neg;\n \t  /* (minimum integer) / (-1) is the only overflow case.  */\n-\t  if (neg_double (lnum, hnum, &lnum, &hnum) && (lden & hden) == -1)\n+\t  if (neg_double (lnum, hnum, &lnum, &hnum)\n+\t      && ((HOST_WIDE_INT) lden & hden) == -1)\n \t    overflow = 1;\n \t}\n       if (hden < 0) \n@@ -528,7 +553,7 @@ div_and_round_double (code, uns,\n     {\t\t\t\t/* single precision */\n       *hquo = *hrem = 0;\n       /* This unsigned division rounds toward zero.  */\n-      *lquo = lnum / (unsigned HOST_WIDE_INT) lden;\n+      *lquo = lnum / lden;\n       goto finish_up;\n     }\n \n@@ -550,106 +575,113 @@ div_and_round_double (code, uns,\n   encode (den, lden, hden);\n \n   /* Special code for when the divisor < BASE.  */\n-  if (hden == 0 && lden < (HOST_WIDE_INT) BASE)\n+  if (hden == 0 && lden < (unsigned HOST_WIDE_INT) BASE)\n     {\n       /* hnum != 0 already checked.  */\n       for (i = 4 - 1; i >= 0; i--)\n \t{\n \t  work = num[i] + carry * BASE;\n-\t  quo[i] = work / (unsigned HOST_WIDE_INT) lden;\n-\t  carry = work % (unsigned HOST_WIDE_INT) lden;\n+\t  quo[i] = work / lden;\n+\t  carry = work % lden;\n \t}\n     }\n   else\n     {\n       /* Full double precision division,\n \t with thanks to Don Knuth's \"Seminumerical Algorithms\".  */\n-    int num_hi_sig, den_hi_sig;\n-    unsigned HOST_WIDE_INT quo_est, scale;\n-\n-    /* Find the highest non-zero divisor digit.  */\n-    for (i = 4 - 1; ; i--)\n-      if (den[i] != 0) {\n-\tden_hi_sig = i;\n-\tbreak;\n-      }\n-\n-    /* Insure that the first digit of the divisor is at least BASE/2.\n-       This is required by the quotient digit estimation algorithm.  */\n-\n-    scale = BASE / (den[den_hi_sig] + 1);\n-    if (scale > 1) {\t\t/* scale divisor and dividend */\n-      carry = 0;\n-      for (i = 0; i <= 4 - 1; i++) {\n-\twork = (num[i] * scale) + carry;\n-\tnum[i] = LOWPART (work);\n-\tcarry = HIGHPART (work);\n-      } num[4] = carry;\n-      carry = 0;\n-      for (i = 0; i <= 4 - 1; i++) {\n-\twork = (den[i] * scale) + carry;\n-\tden[i] = LOWPART (work);\n-\tcarry = HIGHPART (work);\n-\tif (den[i] != 0) den_hi_sig = i;\n-      }\n-    }\n+      int num_hi_sig, den_hi_sig;\n+      unsigned HOST_WIDE_INT quo_est, scale;\n \n-    num_hi_sig = 4;\n+      /* Find the highest non-zero divisor digit.  */\n+      for (i = 4 - 1; ; i--)\n+\tif (den[i] != 0) {\n+\t  den_hi_sig = i;\n+\t  break;\n+\t}\n \n-    /* Main loop */\n-    for (i = num_hi_sig - den_hi_sig - 1; i >= 0; i--) {\n-      /* guess the next quotient digit, quo_est, by dividing the first\n-\t two remaining dividend digits by the high order quotient digit.\n-\t quo_est is never low and is at most 2 high.  */\n-      unsigned HOST_WIDE_INT tmp;\n+      /* Insure that the first digit of the divisor is at least BASE/2.\n+\t This is required by the quotient digit estimation algorithm.  */\n \n-      num_hi_sig = i + den_hi_sig + 1;\n-      work = num[num_hi_sig] * BASE + num[num_hi_sig - 1];\n-      if (num[num_hi_sig] != den[den_hi_sig])\n-\tquo_est = work / den[den_hi_sig];\n-      else\n-\tquo_est = BASE - 1;\n+      scale = BASE / (den[den_hi_sig] + 1);\n+      if (scale > 1)\n+\t{\t\t/* scale divisor and dividend */\n+\t  carry = 0;\n+\t  for (i = 0; i <= 4 - 1; i++)\n+\t    {\n+\t      work = (num[i] * scale) + carry;\n+\t      num[i] = LOWPART (work);\n+\t      carry = HIGHPART (work);\n+\t    }\n \n-      /* refine quo_est so it's usually correct, and at most one high.   */\n-      tmp = work - quo_est * den[den_hi_sig];\n-      if (tmp < BASE\n-\t  && den[den_hi_sig - 1] * quo_est > (tmp * BASE + num[num_hi_sig - 2]))\n-\tquo_est--;\n+\t  num[4] = carry;\n+\t  carry = 0;\n+\t  for (i = 0; i <= 4 - 1; i++)\n+\t    {\n+\t      work = (den[i] * scale) + carry;\n+\t      den[i] = LOWPART (work);\n+\t      carry = HIGHPART (work);\n+\t      if (den[i] != 0) den_hi_sig = i;\n+\t    }\n+\t}\n \n-      /* Try QUO_EST as the quotient digit, by multiplying the\n-         divisor by QUO_EST and subtracting from the remaining dividend.\n-\t Keep in mind that QUO_EST is the I - 1st digit.  */\n+      num_hi_sig = 4;\n \n-      carry = 0;\n-      for (j = 0; j <= den_hi_sig; j++)\n+      /* Main loop */\n+      for (i = num_hi_sig - den_hi_sig - 1; i >= 0; i--)\n \t{\n-\t  work = quo_est * den[j] + carry;\n-\t  carry = HIGHPART (work);\n-\t  work = num[i + j] - LOWPART (work);\n-\t  num[i + j] = LOWPART (work);\n-\t  carry += HIGHPART (work) != 0;\n-\t}\n+\t  /* Guess the next quotient digit, quo_est, by dividing the first\n+\t     two remaining dividend digits by the high order quotient digit.\n+\t     quo_est is never low and is at most 2 high.  */\n+\t  unsigned HOST_WIDE_INT tmp;\n+\n+\t  num_hi_sig = i + den_hi_sig + 1;\n+\t  work = num[num_hi_sig] * BASE + num[num_hi_sig - 1];\n+\t  if (num[num_hi_sig] != den[den_hi_sig])\n+\t    quo_est = work / den[den_hi_sig];\n+\t  else\n+\t    quo_est = BASE - 1;\n \n-      /* if quo_est was high by one, then num[i] went negative and\n-\t we need to correct things.  */\n+\t  /* Refine quo_est so it's usually correct, and at most one high.   */\n+\t  tmp = work - quo_est * den[den_hi_sig];\n+\t  if (tmp < BASE\n+\t      && (den[den_hi_sig - 1] * quo_est\n+\t\t  > (tmp * BASE + num[num_hi_sig - 2])))\n+\t    quo_est--;\n \n-      if (num[num_hi_sig] < carry)\n-\t{\n-\t  quo_est--;\n-\t  carry = 0;\t\t/* add divisor back in */\n+\t  /* Try QUO_EST as the quotient digit, by multiplying the\n+\t     divisor by QUO_EST and subtracting from the remaining dividend.\n+\t     Keep in mind that QUO_EST is the I - 1st digit.  */\n+\n+\t  carry = 0;\n \t  for (j = 0; j <= den_hi_sig; j++)\n \t    {\n-\t      work = num[i + j] + den[j] + carry;\n+\t      work = quo_est * den[j] + carry;\n \t      carry = HIGHPART (work);\n+\t      work = num[i + j] - LOWPART (work);\n \t      num[i + j] = LOWPART (work);\n+\t      carry += HIGHPART (work) != 0;\n \t    }\n-\t  num [num_hi_sig] += carry;\n-\t}\n \n-      /* store the quotient digit.  */\n-      quo[i] = quo_est;\n+\t  /* If quo_est was high by one, then num[i] went negative and\n+\t     we need to correct things.  */\n+\t  if (num[num_hi_sig] < carry)\n+\t    {\n+\t      quo_est--;\n+\t      carry = 0;\t\t/* add divisor back in */\n+\t      for (j = 0; j <= den_hi_sig; j++)\n+\t\t{\n+\t\t  work = num[i + j] + den[j] + carry;\n+\t\t  carry = HIGHPART (work);\n+\t\t  num[i + j] = LOWPART (work);\n+\t\t}\n+\n+\t      num [num_hi_sig] += carry;\n+\t    }\n+\n+\t  /* Store the quotient digit.  */\n+\t  quo[i] = quo_est;\n+\t}\n     }\n-  }\n \n   decode (quo, lquo, hquo);\n \n@@ -678,7 +710,8 @@ div_and_round_double (code, uns,\n \t  add_double (*lquo, *hquo, (HOST_WIDE_INT) -1, (HOST_WIDE_INT)  -1,\n \t\t      lquo, hquo);\n \t}\n-      else return overflow;\n+      else\n+\treturn overflow;\n       break;\n \n     case CEIL_DIV_EXPR:\n@@ -688,28 +721,33 @@ div_and_round_double (code, uns,\n \t  add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n \t\t      lquo, hquo);\n \t}\n-      else return overflow;\n+      else\n+\treturn overflow;\n       break;\n     \n     case ROUND_DIV_EXPR:\n     case ROUND_MOD_EXPR:\t/* round to closest integer */\n       {\n-\tHOST_WIDE_INT labs_rem = *lrem, habs_rem = *hrem;\n-\tHOST_WIDE_INT labs_den = lden, habs_den = hden, ltwice, htwice;\n-\n-\t/* get absolute values */\n-\tif (*hrem < 0) neg_double (*lrem, *hrem, &labs_rem, &habs_rem);\n-\tif (hden < 0) neg_double (lden, hden, &labs_den, &habs_den);\n-\n-\t/* if (2 * abs (lrem) >= abs (lden)) */\n+\tunsigned HOST_WIDE_INT labs_rem = *lrem;\n+\tHOST_WIDE_INT habs_rem = *hrem;\n+\tunsigned HOST_WIDE_INT labs_den = lden, ltwice;\n+\tHOST_WIDE_INT habs_den = hden, htwice;\n+\n+\t/* Get absolute values */\n+\tif (*hrem < 0)\n+\t  neg_double (*lrem, *hrem, &labs_rem, &habs_rem);\n+\tif (hden < 0)\n+\t  neg_double (lden, hden, &labs_den, &habs_den);\n+\n+\t/* If (2 * abs (lrem) >= abs (lden)) */\n \tmul_double ((HOST_WIDE_INT) 2, (HOST_WIDE_INT) 0,\n \t\t    labs_rem, habs_rem, &ltwice, &htwice);\n+\n \tif (((unsigned HOST_WIDE_INT) habs_den\n \t     < (unsigned HOST_WIDE_INT) htwice)\n \t    || (((unsigned HOST_WIDE_INT) habs_den\n \t\t == (unsigned HOST_WIDE_INT) htwice)\n-\t\t&& ((HOST_WIDE_INT unsigned) labs_den\n-\t\t    < (unsigned HOST_WIDE_INT) ltwice)))\n+\t\t&& (labs_den < ltwice)))\n \t  {\n \t    if (*hquo < 0)\n \t      /* quo = quo - 1;  */\n@@ -720,7 +758,8 @@ div_and_round_double (code, uns,\n \t      add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n \t\t\t  lquo, hquo);\n \t  }\n-\telse return overflow;\n+\telse\n+\t  return overflow;\n       }\n       break;\n \n@@ -1412,9 +1451,12 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n      register tree arg1, arg2;\n      int notrunc, forsize;\n {\n-  HOST_WIDE_INT int1l, int1h, int2l, int2h;\n-  HOST_WIDE_INT low, hi;\n-  HOST_WIDE_INT garbagel, garbageh;\n+  unsigned HOST_WIDE_INT int1l, int2l;\n+  HOST_WIDE_INT int1h, int2h;\n+  unsigned HOST_WIDE_INT low;\n+  HOST_WIDE_INT hi;\n+  unsigned HOST_WIDE_INT garbagel;\n+  HOST_WIDE_INT garbageh;\n   register tree t;\n   int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n   int overflow = 0;\n@@ -1482,13 +1524,14 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n     case FLOOR_DIV_EXPR: case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       /* This is a shortcut for a common special case.  */\n-      if (int2h == 0 && int2l > 0\n+      if (int2h == 0 && (HOST_WIDE_INT) int2l > 0\n \t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n \t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n-\t  && int1h == 0 && int1l >= 0)\n+\t  && int1h == 0 && (HOST_WIDE_INT) int1l >= 0)\n \t{\n \t  if (code == CEIL_DIV_EXPR)\n \t    int1l += int2l - 1;\n+\n \t  low = int1l / int2l, hi = 0;\n \t  break;\n \t}\n@@ -1515,10 +1558,10 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n       /* This is a shortcut for a common special case.  */\n-      if (int2h == 0 && int2l > 0\n+      if (int2h == 0 && (HOST_WIDE_INT) int2l > 0\n \t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n \t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n-\t  && int1h == 0 && int1l >= 0)\n+\t  && int1h == 0 && (HOST_WIDE_INT) int1l >= 0)\n \t{\n \t  if (code == CEIL_MOD_EXPR)\n \t    int1l += int2l - 1;\n@@ -1541,13 +1584,10 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n \t\t< (unsigned HOST_WIDE_INT) int2h)\n \t       || (((unsigned HOST_WIDE_INT) int1h\n \t\t    == (unsigned HOST_WIDE_INT) int2h)\n-\t\t   && ((unsigned HOST_WIDE_INT) int1l\n-\t\t       < (unsigned HOST_WIDE_INT) int2l)));\n+\t\t   && int1l < int2l));\n       else\n-\tlow = ((int1h < int2h)\n-\t       || ((int1h == int2h)\n-\t\t   && ((unsigned HOST_WIDE_INT) int1l\n-\t\t       < (unsigned HOST_WIDE_INT) int2l)));\n+\tlow = (int1h < int2h\n+\t       || (int1h == int2h && int1l < int2l));\n \n       if (low == (code == MIN_EXPR))\n \tlow = int1l, hi = int1h;\n@@ -1559,7 +1599,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n       abort ();\n     }\n \n-  if (forsize && hi == 0 && low >= 0 && low < 1000)\n+  if (forsize && hi == 0 && low < 1000)\n     return size_int_type_wide (low, TREE_TYPE (arg1));\n   else\n     {\n@@ -1981,9 +2021,7 @@ fold_convert (t, arg1)\n \t  /* If we are trying to make a sizetype for a small integer, use\n \t     size_int to pick up cached types to reduce duplicate nodes.  */\n \t  if (TREE_CODE (type) == INTEGER_CST && TYPE_IS_SIZETYPE (type)\n-\t      && TREE_INT_CST_HIGH (arg1) == 0\n-\t      && TREE_INT_CST_LOW (arg1) >= 0\n-\t      && TREE_INT_CST_LOW (arg1) < 1000)\n+\t      && compare_tree_int (arg1, 1000) < 0)\n \t    return size_int_type_wide (TREE_INT_CST_LOW (arg1), type);\n \n \t  /* Given an integer constant, make new constant with new type,\n@@ -2280,8 +2318,7 @@ operand_equal_p (arg0, arg1, only_const)\n       case INTEGER_CST:\n \treturn (! TREE_CONSTANT_OVERFLOW (arg0)\n \t\t&& ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t\t&& TREE_INT_CST_LOW (arg0) == TREE_INT_CST_LOW (arg1)\n-\t\t&& TREE_INT_CST_HIGH (arg0) == TREE_INT_CST_HIGH (arg1));\n+\t\t&& tree_int_cst_equal (arg0, arg1));\n \n       case REAL_CST:\n \treturn (! TREE_CONSTANT_OVERFLOW (arg0)\n@@ -2691,8 +2728,7 @@ invert_truthvalue (arg)\n   switch (code)\n     {\n     case INTEGER_CST:\n-      return convert (type, build_int_2 (TREE_INT_CST_LOW (arg) == 0\n-\t\t\t\t\t && TREE_INT_CST_HIGH (arg) == 0, 0));\n+      return convert (type, build_int_2 (integer_zerop (arg), 0));\n \n     case TRUTH_AND_EXPR:\n       return build (TRUTH_OR_EXPR, type,\n@@ -5100,10 +5136,9 @@ fold (expr)\n \t  /* Fold an expression like: \"foo\"[2] */\n \t  if (TREE_CODE (arg0) == STRING_CST\n \t      && TREE_CODE (arg1) == INTEGER_CST\n-\t      && !TREE_INT_CST_HIGH (arg1)\n-\t      && (i = TREE_INT_CST_LOW (arg1)) < TREE_STRING_LENGTH (arg0))\n+\t      && compare_tree_int (arg1, TREE_STRING_LENGTH (arg0)) < 0)\n \t    {\n-\t      t = build_int_2 (TREE_STRING_POINTER (arg0)[i], 0);\n+\t      t = build_int_2 (TREE_STRING_POINTER (arg0)[TREE_INT_CST_LOW (arg))], 0);\n \t      TREE_TYPE (t) = TREE_TYPE (TREE_TYPE (arg0));\n \t      force_fit_type (t, 0);\n \t    }\n@@ -5391,9 +5426,10 @@ fold (expr)\n \t        STRIP_NOPS (tree110);\n \t        STRIP_NOPS (tree111);\n \t        if (TREE_CODE (tree110) == INTEGER_CST\n-\t\t    && TREE_INT_CST_HIGH (tree110) == 0\n-\t\t    && (TREE_INT_CST_LOW (tree110)\n-\t\t        == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t\t    && 0 == compare_tree_int (tree110,\n+\t\t\t\t\t      TYPE_PRECISION\n+\t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree01, tree111, 0))\n \t\t  return build ((code0 == LSHIFT_EXPR \n \t\t\t         ? LROTATE_EXPR \n@@ -5408,9 +5444,10 @@ fold (expr)\n \t        STRIP_NOPS (tree010);\n \t        STRIP_NOPS (tree011);\n \t        if (TREE_CODE (tree010) == INTEGER_CST\n-\t\t    && TREE_INT_CST_HIGH (tree010) == 0\n-\t\t    && (TREE_INT_CST_LOW (tree010)\n-\t\t        == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n+\t\t    && 0 == compare_tree_int (tree010,\n+\t\t\t\t\t      TYPE_PRECISION\n+\t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree11, tree011, 0))\n \t\t  return build ((code0 != LSHIFT_EXPR \n \t\t\t         ? LROTATE_EXPR \n@@ -5831,7 +5868,7 @@ fold (expr)\n \t  && TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1)) == 0\n \t  && ((TREE_INT_CST_LOW (arg1)\n \t       + TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)))\n-\t      == GET_MODE_BITSIZE (TYPE_MODE (type))))\n+\t      == (unsigned int) GET_MODE_BITSIZE (TYPE_MODE (type))))\n \treturn TREE_OPERAND (arg0, 0);\n \n       goto binary;\n@@ -6414,7 +6451,7 @@ fold (expr)\n \t  {\n \t    if (TREE_INT_CST_HIGH (arg1) == 0\n \t\t&& (TREE_INT_CST_LOW (arg1)\n-\t\t    == ((HOST_WIDE_INT) 1 << (width - 1)) - 1)\n+\t\t    == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n \t\t&& ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n \t      switch (TREE_CODE (t))\n \t\t{\n@@ -6440,7 +6477,7 @@ fold (expr)\n \n \t    else if (TREE_INT_CST_HIGH (arg1) == -1\n \t\t     && (- TREE_INT_CST_LOW (arg1)\n-\t\t\t == ((HOST_WIDE_INT) 1 << (width - 1)))\n+\t\t\t == ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n \t\t     && ! TREE_UNSIGNED (TREE_TYPE (arg1)))\n \t      switch (TREE_CODE (t))\n \t\t{\n@@ -6466,7 +6503,7 @@ fold (expr)\n \n \t    else if (TREE_INT_CST_HIGH (arg1) == 0\n \t\t      && (TREE_INT_CST_LOW (arg1)\n-\t\t\t  == ((HOST_WIDE_INT) 1 << (width - 1)) - 1)\n+\t\t\t  == ((unsigned HOST_WIDE_INT) 1 << (width - 1)) - 1)\n \t\t      && TREE_UNSIGNED (TREE_TYPE (arg1)))\n \t      \n \t      switch (TREE_CODE (t))\n@@ -6663,11 +6700,7 @@ fold (expr)\n       if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n \t  if (code == EQ_EXPR)\n-\t    t1 = build_int_2 ((TREE_INT_CST_LOW (arg0)\n-\t\t\t       == TREE_INT_CST_LOW (arg1))\n-\t\t\t      && (TREE_INT_CST_HIGH (arg0)\n-\t\t\t\t  == TREE_INT_CST_HIGH (arg1)),\n-\t\t\t      0);\n+\t    t1 = build_int_2 (tree_int_cst_equal (arg0, arg1), 0);\n \t  else\n \t    t1 = build_int_2 ((TREE_UNSIGNED (TREE_TYPE (arg0))\n \t\t\t       ? INT_CST_LT_UNSIGNED (arg0, arg1)"}, {"sha": "1620c530ac39ee4ed211d00c8d4d0055abd157da", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1,3 +1,11 @@\n+Mon Mar  6 18:07:07 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (emit_init_test_initialization): Mark KEY as unused.\n+\t* expr.c (build_newarray): Cast TREE_INT_CST_LOW to HOST_WIDE_INT.\n+\t(build_anewarray): Likewise.\n+\t* parse.y (patch_newarray): Likewise.\n+\t* parse.c: Regenerated.\n+\n 2000-03-06  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* decl.c (init_decl_processing): Added new class fields `depth',"}, {"sha": "13d2dd733738fbb79f06ec7cdecee0d770f893f3", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1,6 +1,5 @@\n /* Process declarations and variables for the GNU compiler for the\n    Java(TM) language.\n-\n    Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -1634,7 +1633,7 @@ build_result_decl (fndecl)\n static boolean\n emit_init_test_initialization (entry, key)\n   struct hash_entry *entry;\n-  hash_table_key key;\n+  hash_table_key key ATTRIBUTE_UNUSED;\n {\n   struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n   expand_decl (ite->init_test_decl);"}, {"sha": "4db334d2a3a1e6f6b967745ad74fab3157ad6486", "filename": "gcc/java/expr.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -786,10 +786,11 @@ build_newarray (atype_value, length)\n      int atype_value;\n      tree length;\n {\n-  tree type = build_java_array_type (decode_newarray_type (atype_value),\n-\t\t\t\t     TREE_CODE (length) == INTEGER_CST\n-\t\t\t\t     ? TREE_INT_CST_LOW (length)\n-\t\t\t\t     : -1);\n+  tree type\n+    = build_java_array_type (decode_newarray_type (atype_value),\n+\t\t\t     TREE_CODE (length) == INTEGER_CST\n+\t\t\t     ? (HOST_WIDE_INT) TREE_INT_CST_LOW (length) : -1);\n+\n   return build (CALL_EXPR, promote_type (type),\n \t\tbuild_address_of (soft_newarray_node),\n \t\ttree_cons (NULL_TREE, \n@@ -806,10 +807,11 @@ build_anewarray (class_type, length)\n     tree class_type;\n     tree length;\n {\n-  tree type = build_java_array_type (class_type,\n-\t\t\t\t     TREE_CODE (length) == INTEGER_CST\n-\t\t\t\t     ? TREE_INT_CST_LOW (length)\n-\t\t\t\t     : -1);\n+  tree type\n+    = build_java_array_type (class_type,\n+\t\t\t     TREE_CODE (length) == INTEGER_CST\n+\t\t\t     ? (HOST_WIDE_INT) TREE_INT_CST_LOW (length) : -1);\n+\n   return build (CALL_EXPR, promote_type (type),\n \t\tbuild_address_of (soft_anewarray_node),\n \t\ttree_cons (NULL_TREE, length,"}, {"sha": "2361f3da33256ec39bca35e6eb040ed89e72eb82", "filename": "gcc/java/parse.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -13431,9 +13431,11 @@ patch_newarray (node)\n   for (cdim = dims; cdim; cdim = TREE_CHAIN (cdim))\n     {\n       type = array_type;\n-      array_type = build_java_array_type (type,\n-\t\t\t\t\t  TREE_CODE (cdim) == INTEGER_CST ?\n-\t\t\t\t\t  TREE_INT_CST_LOW (cdim) : -1);\n+      array_type\n+\t= build_java_array_type (type,\n+\t\t\t\t TREE_CODE (cdim) == INTEGER_CST\n+\t\t\t\t ? (HOST_WIDE_INT) TREE_INT_CST_LOW (cdim)\n+\t\t\t\t : -1);\n       array_type = promote_type (array_type);\n     }\n   dims = nreverse (dims);"}, {"sha": "1fb2175bfa4c32b2b42729e91c0d9f6489402273", "filename": "gcc/java/parse.y", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -10824,9 +10824,11 @@ patch_newarray (node)\n   for (cdim = dims; cdim; cdim = TREE_CHAIN (cdim))\n     {\n       type = array_type;\n-      array_type = build_java_array_type (type,\n-\t\t\t\t\t  TREE_CODE (cdim) == INTEGER_CST ?\n-\t\t\t\t\t  TREE_INT_CST_LOW (cdim) : -1);\n+      array_type\n+\t= build_java_array_type (type,\n+\t\t\t\t TREE_CODE (cdim) == INTEGER_CST\n+\t\t\t\t ? (HOST_WIDE_INT) TREE_INT_CST_LOW (cdim)\n+\t\t\t\t : -1);\n       array_type = promote_type (array_type);\n     }\n   dims = nreverse (dims);"}, {"sha": "b4b125761d0b7ae6a776986a99ca3f71f92d0d9c", "filename": "gcc/mkdeps.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -102,10 +102,12 @@ munge (filename)\n /* Given a pathname, calculate the non-directory part.  This always\n    knows how to handle Unix-style pathnames, and understands VMS and\n    DOS paths on those systems.  */\n+\n /* Find the base name of a (partial) pathname FNAME.\n    Returns a pointer into the string passed in.\n    Accepts Unix (/-separated) paths on all systems,\n    DOS and VMS paths on those systems.  */\n+\n static const char *\n base_name (fname)\n      const char *fname;\n@@ -149,8 +151,10 @@ deps_free (d)\n      struct deps *d;\n {\n   unsigned int i;\n+\n   for (i = 0; i < d->ntargets; i++)\n     free ((PTR) d->targetv[i]);\n+\n   for (i = 0; i < d->ndeps; i++)\n     free ((PTR) d->depv[i]);\n \n@@ -172,6 +176,7 @@ deps_add_target (d, t)\n       d->targetv = xrealloc (d->targetv,\n \t\t\t     d->targets_size * sizeof (const char *));\n     }\n+\n   d->targetv[d->ntargets++] = t;\n }\n \n@@ -267,7 +272,7 @@ deps_dummy_targets (d, fp)\n      const struct deps *d;\n      FILE *fp;\n {\n-  int i;\n+  unsigned int i;\n \n   for (i = 1; i < d->ndeps; i++)\n     {"}, {"sha": "4d1b4559d517884518d1d57482f673d466c9016c", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -112,7 +112,7 @@ print_node_brief (file, prefix, node, indent)\n \t{\n \t  fprintf (file, \"-\");\n \t  fprintf (file, HOST_WIDE_INT_PRINT_UNSIGNED,\n-\t\t -TREE_INT_CST_LOW (node));\n+\t\t   -TREE_INT_CST_LOW (node));\n \t}\n       else\n \tfprintf (file, HOST_WIDE_INT_PRINT_DOUBLE_HEX,"}, {"sha": "52f81521c932d492cc0279ae671bd0e39734be34", "filename": "gcc/rtl.h", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1620,26 +1620,34 @@ extern void reg_to_stack\t\tPARAMS ((rtx, FILE *));\n #endif\n \n /* In fold-const.c */\n-extern int add_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int neg_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int mul_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern void lshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n-\t\t\t\t\tHOST_WIDE_INT *, int));\n-extern void rshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT, int,\n-\t\t\t\t\tHOST_WIDE_INT *, HOST_WIDE_INT *, int));\n-extern void lrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n-\t\t\t\t\tHOST_WIDE_INT *));\n-extern void rrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT, int, HOST_WIDE_INT *,\n-\t\t\t\t\tHOST_WIDE_INT *));\n+extern int add_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern int neg_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern int mul_double\t\tPARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern void lshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *, int));\n+extern void rshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *, int));\n+extern void lrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern void rrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n \n /* In calls.c */\n extern void emit_library_call\t\tPARAMS ((rtx, int, enum machine_mode,"}, {"sha": "9be159dbc9233bdc082009a70ddb9749d1b9067b", "filename": "gcc/stmt.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -3801,9 +3801,8 @@ expand_decl (decl)\n \n   else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST\n \t   && ! (flag_stack_check && ! STACK_CHECK_BUILTIN\n-\t\t && (TREE_INT_CST_HIGH (DECL_SIZE_UNIT (decl)) != 0\n-\t\t     || (TREE_INT_CST_LOW (DECL_SIZE_UNIT (decl))\n-\t\t\t > STACK_CHECK_MAX_VAR_SIZE))))\n+\t\t && 0 < compare_tree_int (DECL_SIZE_UNIT (decl),\n+\t\t\t\t\t  STACK_CHECK_MAX_VAR_SIZE)))\n     {\n       /* Variable of fixed size that goes on the stack.  */\n       rtx oldaddr = 0;\n@@ -4212,8 +4211,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n          change the element's mode to the appropriate one for its size.  */\n       if (mode == BLKmode && DECL_MODE (decl) != BLKmode)\n \tDECL_MODE (decl_elt) = mode\n-\t  = mode_for_size (TREE_INT_CST_LOW (DECL_SIZE (decl_elt)),\n-\t\t\t   MODE_INT, 1);\n+\t  = mode_for_size_tree (DECL_SIZE (decl_elt), MODE_INT, 1);\n \n       /* (SUBREG (MEM ...)) at RTL generation time is invalid, so we\n          instead create a new MEM rtx with the proper mode.  */\n@@ -4962,8 +4960,8 @@ all_cases_count (type, spareness)\n \t{\n \t  if (TREE_CODE (TYPE_MIN_VALUE (type)) != INTEGER_CST\n \t      || TREE_CODE (TREE_VALUE (t)) != INTEGER_CST\n-\t      || TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) + count\n-\t      != TREE_INT_CST_LOW (TREE_VALUE (t)))\n+\t      || (TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) + count\n+\t\t  != TREE_INT_CST_LOW (TREE_VALUE (t))))\n \t    *spareness = 1;\n \t  count++;\n \t}\n@@ -5402,10 +5400,8 @@ expand_end_case (orig_index)\n #endif /* HAVE_casesi */\n #endif /* CASE_VALUES_THRESHOLD */\n \n-      else if (TREE_INT_CST_HIGH (range) != 0\n-\t       || count < (unsigned int) CASE_VALUES_THRESHOLD\n-\t       || ((unsigned HOST_WIDE_INT) (TREE_INT_CST_LOW (range))\n-\t\t   > 10 * count)\n+      else if (count < CASE_VALUES_THRESHOLD\n+\t       || compare_tree_int (range, 10 * count) > 0\n #ifndef ASM_OUTPUT_ADDR_DIFF_ELT\n \t       || flag_pic\n #endif\n@@ -5768,7 +5764,8 @@ estimate_case_costs (node)\n       if ((INT_CST_LT (n->low, min_ascii)) || INT_CST_LT (max_ascii, n->high))\n \treturn 0;\n \n-      for (i = TREE_INT_CST_LOW (n->low); i <= TREE_INT_CST_LOW (n->high); i++)\n+      for (i = (HOST_WIDE_INT) TREE_INT_CST_LOW (n->low);\n+\t   i <= (HOST_WIDE_INT) TREE_INT_CST_LOW (n->high); i++)\n \tif (cost_table[i] < 0)\n \t  return 0;\n     }"}, {"sha": "d4bd2e8586aacd127843a835a23b5df4de912ed8", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -177,14 +177,10 @@ mode_for_size_tree (size, class, limit)\n      int limit;\n {\n   if (TREE_CODE (size) != INTEGER_CST\n-      || TREE_INT_CST_HIGH (size) != 0\n-      /* If the low-order part is so high as to appear negative, we can't\n-\t find a mode for that many bits.  */\n-      || TREE_INT_CST_LOW (size) < 0\n       /* What we really want to say here is that the size can fit in a\n \t host integer, but we know there's no way we'd find a mode for\n \t this many bits, so there's no point in doing the precise test.  */\n-      || TREE_INT_CST_LOW (size) > 1000)\n+      || compare_tree_int (size, 1000) > 0)\n     return BLKmode;\n   else\n     return mode_for_size (TREE_INT_CST_LOW (size), class, limit);\n@@ -236,7 +232,7 @@ int_mode_for_mode (mode)\n \n     case MODE_CC:\n     default:\n-      abort();\n+      abort ();\n     }\n \n   return mode;\n@@ -391,13 +387,11 @@ layout_decl (decl, known_align)\n       tree size = DECL_SIZE_UNIT (decl);\n \n       if (size != 0 && TREE_CODE (size) == INTEGER_CST\n-\t  && (TREE_INT_CST_HIGH (size) != 0\n-\t      || TREE_INT_CST_LOW (size) > larger_than_size))\n+\t  && compare_tree_int (size, larger_than_size) > 0)\n \t{\n-\t  int size_as_int = TREE_INT_CST_LOW (size);\n+\t  unsigned int size_as_int = TREE_INT_CST_LOW (size);\n \n-\t  if (size_as_int == TREE_INT_CST_LOW (size)\n-\t      && TREE_INT_CST_HIGH (size) == 0)\n+\t  if (compare_tree_int (size, size_as_int) == 0)\n \t    warning_with_decl (decl, \"size of `%s' is %d bytes\", size_as_int);\n \t  else\n \t    warning_with_decl (decl, \"size of `%s' is larger than %d bytes\",\n@@ -432,7 +426,7 @@ layout_record (rec)\n      and VAR_SIZE is a tree expression.\n      If VAR_SIZE is null, the size is just CONST_SIZE.\n      Naturally we try to avoid using VAR_SIZE.  */\n-  HOST_WIDE_INT const_size = 0;\n+  unsigned HOST_WIDE_INT const_size = 0;\n   tree var_size = 0;\n   /* Once we start using VAR_SIZE, this is the maximum alignment\n      that we know VAR_SIZE has.  */\n@@ -581,7 +575,7 @@ layout_record (rec)\n \t{\n \t  unsigned int type_align = TYPE_ALIGN (type);\n \t  register tree dsize = DECL_SIZE (field);\n-\t  int field_size = TREE_INT_CST_LOW (dsize);\n+\t  unsigned int field_size = TREE_INT_CST_LOW (dsize);\n \n \t  /* A bit field may not span more units of alignment of its type\n \t     than its type itself.  Advance to next boundary if necessary.  */\n@@ -778,7 +772,7 @@ layout_union (rec)\n   /* The size of the union, based on the fields scanned so far,\n      is max (CONST_SIZE, VAR_SIZE).\n      VAR_SIZE may be null; then CONST_SIZE by itself is the size.  */\n-  register HOST_WIDE_INT const_size = 0;\n+  unsigned HOST_WIDE_INT const_size = 0;\n   register tree var_size = 0;\n \n #ifdef STRUCTURE_SIZE_BOUNDARY\n@@ -946,7 +940,7 @@ layout_type (type)\n       break;\n \n     case VOID_TYPE:\n-      TYPE_SIZE (type) = size_zero_node;\n+      TYPE_SIZE (type) = bitsize_int (0);\n       TYPE_SIZE_UNIT (type) = size_zero_node;\n       TYPE_ALIGN (type) = 1;\n       TYPE_MODE (type) = VOIDmode;\n@@ -1113,7 +1107,7 @@ layout_type (type)\n \t     Unless the member is BLKmode only because it isn't aligned.  */\n \t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t    {\n-\t      int bitpos;\n+\t      unsigned HOST_WIDE_INT bitpos;\n \n \t      if (TREE_CODE (field) != FIELD_DECL\n \t\t  || TREE_CODE (TREE_TYPE (field)) == ERROR_MARK)\n@@ -1195,8 +1189,7 @@ layout_type (type)\n \t     then stick with BLKmode.  */\n \t  && (! STRICT_ALIGNMENT\n \t      || TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n-\t      || ((int) TYPE_ALIGN (type)\n-\t\t  >= TREE_INT_CST_LOW (TYPE_SIZE (type)))))\n+\t      || compare_tree_int (TYPE_SIZE (type), TYPE_ALIGN (type)) <= 0))\n \t{\n \t  tree field;\n "}, {"sha": "b03d5701ad25f8a6b2d824f9a0b95cd967a59e25", "filename": "gcc/tree.c", "status": "modified", "additions": 102, "deletions": 30, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -258,7 +258,7 @@ int (*lang_get_alias_set) PARAMS ((tree));\n struct type_hash\n {\n   struct type_hash *next;\t/* Next structure in the bucket.  */\n-  int hashcode;\t\t\t/* Hash code of this type.  */\n+  unsigned int hashcode;\t/* Hash code of this type.  */\n   tree type;\t\t\t/* The type recorded here.  */\n };\n \n@@ -1446,7 +1446,7 @@ real_value_from_int_cst (type, i)\n       e = ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n \t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n       d *= e;\n-      e = (double) (unsigned HOST_WIDE_INT) (~ TREE_INT_CST_LOW (i));\n+      e = (double) (~ TREE_INT_CST_LOW (i));\n       d += e;\n       d = (- d - 1.0);\n     }\n@@ -1458,7 +1458,7 @@ real_value_from_int_cst (type, i)\n       e = ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n \t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n       d *= e;\n-      e = (double) (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (i);\n+      e = (double) TREE_INT_CST_LOW (i);\n       d += e;\n     }\n #endif /* not REAL_ARITHMETIC */\n@@ -1671,14 +1671,16 @@ integer_all_onesp (expr)\n \n   uns = TREE_UNSIGNED (TREE_TYPE (expr));\n   if (!uns)\n-    return TREE_INT_CST_LOW (expr) == -1 && TREE_INT_CST_HIGH (expr) == -1;\n+    return (TREE_INT_CST_LOW (expr) == ~ (unsigned HOST_WIDE_INT) 0\n+\t    && TREE_INT_CST_HIGH (expr) == -1);\n \n   /* Note that using TYPE_PRECISION here is wrong.  We care about the\n      actual bits, not the (arbitrary) range of the type.  */\n   prec = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (expr)));\n   if (prec >= HOST_BITS_PER_WIDE_INT)\n     {\n-      int high_value, shift_amount;\n+      HOST_WIDE_INT high_value;\n+      int shift_amount;\n \n       shift_amount = prec - HOST_BITS_PER_WIDE_INT;\n \n@@ -1692,11 +1694,11 @@ integer_all_onesp (expr)\n       else\n \thigh_value = ((HOST_WIDE_INT) 1 << shift_amount) - 1;\n \n-      return TREE_INT_CST_LOW (expr) == -1\n-\t&& TREE_INT_CST_HIGH (expr) == high_value;\n+      return (TREE_INT_CST_LOW (expr) == ~ (unsigned HOST_WIDE_INT) 0\n+\t      && TREE_INT_CST_HIGH (expr) == high_value);\n     }\n   else\n-    return TREE_INT_CST_LOW (expr) == ((HOST_WIDE_INT) 1 << prec) - 1;\n+    return TREE_INT_CST_LOW (expr) == ((unsigned HOST_WIDE_INT) 1 << prec) - 1;\n }\n \n /* Return 1 if EXPR is an integer constant that is a power of 2 (i.e., has only\n@@ -1784,6 +1786,46 @@ tree_log2 (expr)\n \t  :  exact_log2 (low));\n }\n \n+/* Similar, but return the largest integer Y such that 2 ** Y is less\n+   than or equal to EXPR.  */\n+\n+int\n+tree_floor_log2 (expr)\n+     tree expr;\n+{\n+  int prec;\n+  HOST_WIDE_INT high, low;\n+\n+  STRIP_NOPS (expr);\n+\n+  if (TREE_CODE (expr) == COMPLEX_CST)\n+    return tree_log2 (TREE_REALPART (expr));\n+\n+  prec = (POINTER_TYPE_P (TREE_TYPE (expr))\n+\t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n+\n+  high = TREE_INT_CST_HIGH (expr);\n+  low = TREE_INT_CST_LOW (expr);\n+\n+  /* First clear all bits that are beyond the type's precision in case\n+     we've been sign extended.  Ignore if type's precision hasn't been set\n+     since what we are doing is setting it.  */\n+\n+  if (prec == 2 * HOST_BITS_PER_WIDE_INT || prec == 0)\n+    ;\n+  else if (prec > HOST_BITS_PER_WIDE_INT)\n+    high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n+  else\n+    {\n+      high = 0;\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\tlow &= ~((HOST_WIDE_INT) (-1) << prec);\n+    }\n+\n+  return (high != 0 ? HOST_BITS_PER_WIDE_INT + floor_log2 (high)\n+\t  : floor_log2 (low));\n+}\n+\n /* Return 1 if EXPR is the real constant zero.  */\n \n int\n@@ -3422,7 +3464,7 @@ build_type_attribute_variant (ttype, attribute)\n {\n   if ( ! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n     {\n-      register int hashcode;\n+      unsigned int hashcode;\n       tree ntype;\n \n       push_obstacks (TYPE_OBSTACK (ttype), TYPE_OBSTACK (ttype));\n@@ -3437,9 +3479,9 @@ build_type_attribute_variant (ttype, attribute)\n       TYPE_NEXT_VARIANT (ntype) = 0;\n       set_type_quals (ntype, TYPE_UNQUALIFIED);\n \n-      hashcode = TYPE_HASH (TREE_CODE (ntype))\n-\t\t + TYPE_HASH (TREE_TYPE (ntype))\n-\t\t + attribute_hash_list (attribute);\n+      hashcode = (TYPE_HASH (TREE_CODE (ntype))\n+\t\t  + TYPE_HASH (TREE_TYPE (ntype))\n+\t\t  + attribute_hash_list (attribute));\n \n       switch (TREE_CODE (ntype))\n         {\n@@ -3799,11 +3841,11 @@ build_type_copy (type)\n    with types in the TREE_VALUE slots), by adding the hash codes\n    of the individual types.  */\n \n-int\n+unsigned int\n type_hash_list (list)\n      tree list;\n {\n-  register int hashcode;\n+  unsigned int hashcode;\n   register tree tail;\n \n   for (hashcode = 0, tail = list; tail; tail = TREE_CHAIN (tail))\n@@ -3817,7 +3859,7 @@ type_hash_list (list)\n \n tree\n type_hash_lookup (hashcode, type)\n-     int hashcode;\n+     unsigned int hashcode;\n      tree type;\n {\n   register struct type_hash *h;\n@@ -3857,7 +3899,7 @@ type_hash_lookup (hashcode, type)\n \n void\n type_hash_add (hashcode, type)\n-     int hashcode;\n+     unsigned int hashcode;\n      tree type;\n {\n   register struct type_hash *h;\n@@ -3885,7 +3927,7 @@ int debug_no_type_hash = 0;\n \n tree\n type_hash_canon (hashcode, type)\n-     int hashcode;\n+     unsigned int hashcode;\n      tree type;\n {\n   tree t1;\n@@ -3932,11 +3974,11 @@ mark_type_hash (arg)\n    with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),\n    by adding the hash codes of the individual attributes.  */\n \n-int\n+unsigned int\n attribute_hash_list (list)\n      tree list;\n {\n-  register int hashcode;\n+  unsigned int hashcode;\n   register tree tail;\n \n   for (hashcode = 0, tail = list; tail; tail = TREE_CHAIN (tail))\n@@ -4255,6 +4297,27 @@ simple_cst_equal (t1, t2)\n       return -1;\n     }\n }\n+\n+/* Compare the value of T, an INTEGER_CST, with U, an unsigned integer value.\n+   Return -1, 0, or 1 if the value of T is less than, equal to, or greater\n+   than U, respectively.  */\n+\n+int\n+compare_tree_int (t, u)\n+     tree t;\n+     unsigned int u;\n+{\n+  if (tree_int_cst_sgn (t) < 0)\n+    return -1;\n+  else if (TREE_INT_CST_HIGH (t) != 0)\n+    return 1;\n+  else if (TREE_INT_CST_LOW (t) == u)\n+    return 0;\n+  else if (TREE_INT_CST_LOW (t) < u)\n+    return -1;\n+  else\n+    return 1;\n+}\n \f\n /* Constructors for pointer, array and function types.\n    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are\n@@ -4348,14 +4411,16 @@ build_index_type (maxval)\n   TYPE_ALIGN (itype) = TYPE_ALIGN (sizetype);\n   if (TREE_CODE (maxval) == INTEGER_CST)\n     {\n-      int maxint = (int) TREE_INT_CST_LOW (maxval);\n+      int maxint = TREE_INT_CST_LOW (maxval);\n+\n       /* If the domain should be empty, make sure the maxval\n \t remains -1 and is not spoiled by truncation.  */\n-      if (INT_CST_LT (maxval, integer_zero_node))\n+      if (tree_int_cst_sgn (maxval) < 0)\n \t{\n \t  TYPE_MAX_VALUE (itype) = build_int_2 (-1, -1);\n \t  TREE_TYPE (TYPE_MAX_VALUE (itype)) = sizetype;\n \t}\n+\n       return type_hash_canon (maxint < 0 ? ~maxint : maxint, itype);\n     }\n   else\n@@ -4396,9 +4461,10 @@ build_range_type (type, lowval, highval)\n       if (highval && TREE_CODE (highval) == INTEGER_CST)\n \thighint = TREE_INT_CST_LOW (highval);\n       else\n-\thighint = (~(unsigned HOST_WIDE_INT)0) >> 1;\n+\thighint = (~(unsigned HOST_WIDE_INT) 0) >> 1;\n \n       maxint = (int) (highint - lowint);\n+\n       return type_hash_canon (maxint < 0 ? ~maxint : maxint, itype);\n     }\n   else\n@@ -4454,7 +4520,7 @@ build_array_type (elt_type, index_type)\n      tree elt_type, index_type;\n {\n   register tree t;\n-  int hashcode;\n+  unsigned int hashcode;\n \n   if (TREE_CODE (elt_type) == FUNCTION_TYPE)\n     {\n@@ -4511,7 +4577,7 @@ build_function_type (value_type, arg_types)\n      tree value_type, arg_types;\n {\n   register tree t;\n-  int hashcode;\n+  unsigned int hashcode;\n \n   if (TREE_CODE (value_type) == FUNCTION_TYPE)\n     {\n@@ -4543,7 +4609,7 @@ build_method_type (basetype, type)\n      tree basetype, type;\n {\n   register tree t;\n-  int hashcode;\n+  unsigned int hashcode;\n \n   /* Make a node of the sort we want.  */\n   t = make_node (METHOD_TYPE);\n@@ -4580,7 +4646,7 @@ build_offset_type (basetype, type)\n      tree basetype, type;\n {\n   register tree t;\n-  int hashcode;\n+  unsigned int hashcode;\n \n   /* Make a node of the sort we want.  */\n   t = make_node (OFFSET_TYPE);\n@@ -4605,7 +4671,7 @@ build_complex_type (component_type)\n      tree component_type;\n {\n   register tree t;\n-  int hashcode;\n+  unsigned int hashcode;\n \n   /* Make a node of the sort we want.  */\n   t = make_node (COMPLEX_TYPE);\n@@ -4740,7 +4806,9 @@ get_unwidened (op, for_type)\n       /* Don't crash if field not laid out yet.  */\n       && DECL_SIZE (TREE_OPERAND (op, 1)) != 0)\n     {\n-      unsigned innerprec = TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));\n+      unsigned int innerprec\n+\t= TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));\n+\n       type = type_for_size (innerprec, TREE_UNSIGNED (TREE_OPERAND (op, 1)));\n \n       /* We can get this structure field in the narrowest type it fits in.\n@@ -4822,7 +4890,9 @@ get_narrower (op, unsignedp_ptr)\n       /* Since type_for_size always gives an integer type.  */\n       && TREE_CODE (TREE_TYPE (op)) != REAL_TYPE)\n     {\n-      unsigned innerprec = TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));\n+      unsigned int innerprec\n+\t= TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));\n+\n       tree type = type_for_size (innerprec, TREE_UNSIGNED (op));\n \n       /* We can get this structure field in a narrower type that fits it,\n@@ -5221,6 +5291,7 @@ get_set_constructor_bits (init, buffer, bit_size)\n \t    = TREE_INT_CST_LOW (TREE_PURPOSE (vals)) - domain_min;\n \t  HOST_WIDE_INT hi_index\n \t    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;\n+\n \t  if (lo_index < 0 || lo_index >= bit_size\n \t    || hi_index < 0 || hi_index >= bit_size)\n \t    abort ();\n@@ -5428,6 +5499,7 @@ void\n build_common_tree_nodes_2 (short_double)\n      int short_double;\n {\n+  /* Define these next since types below may used them.  */\n   integer_zero_node = build_int_2 (0, 0);\n   TREE_TYPE (integer_zero_node) = integer_type_node;\n   integer_one_node = build_int_2 (1, 0);\n@@ -5439,7 +5511,7 @@ build_common_tree_nodes_2 (short_double)\n   TREE_TYPE (size_one_node) = sizetype;\n \n   void_type_node = make_node (VOID_TYPE);\n-  layout_type (void_type_node);\t/* Uses size_zero_node */\n+  layout_type (void_type_node);\n \n   /* We are not going to have real types in C with less than byte alignment,\n      so we might as well not have any types that claim to have it.  */"}, {"sha": "549ab44b3b8e04e971539ae567867dc1947858f8", "filename": "gcc/tree.h", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -630,23 +630,21 @@ extern void tree_class_check_failed PARAMS ((const tree, char,\n #define INT_CST_LT(A, B)  \\\n (TREE_INT_CST_HIGH (A) < TREE_INT_CST_HIGH (B)\t\t\t\\\n  || (TREE_INT_CST_HIGH (A) == TREE_INT_CST_HIGH (B)\t\t\\\n-     && ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (A)\t\t\\\n-\t < (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (B))))\n+     && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n \n #define INT_CST_LT_UNSIGNED(A, B)  \\\n (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n   < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n  || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n-      == (unsigned HOST_WIDE_INT ) TREE_INT_CST_HIGH (B)) \\\n-     && (((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (A)\t\\\n-\t  < (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (B)))))\n+      == (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B)) \\\n+     && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n \n struct tree_int_cst\n {\n   char common[sizeof (struct tree_common)];\n   struct rtx_def *rtl;\t/* acts as link to register transfer language\n \t\t\t   (rtl) info */\n-  HOST_WIDE_INT int_cst_low;\n+  unsigned HOST_WIDE_INT int_cst_low;\n   HOST_WIDE_INT int_cst_high;\n };\n \n@@ -1698,7 +1696,7 @@ extern tree array_type_nelts\t\tPARAMS ((tree));\n extern tree value_member\t\tPARAMS ((tree, tree));\n extern tree purpose_member\t\tPARAMS ((tree, tree));\n extern tree binfo_member\t\tPARAMS ((tree, tree));\n-extern int attribute_hash_list\t\tPARAMS ((tree));\n+extern unsigned int attribute_hash_list\tPARAMS ((tree));\n extern int attribute_list_equal\t\tPARAMS ((tree, tree));\n extern int attribute_list_contained\tPARAMS ((tree, tree));\n extern int tree_int_cst_equal\t\tPARAMS ((tree, tree));\n@@ -1787,7 +1785,7 @@ extern void layout_type\t\t\tPARAMS ((tree));\n    How the hash code is computed is up to the caller, as long as any two\n    callers that could hash identical-looking type nodes agree.  */\n \n-extern tree type_hash_canon\t\tPARAMS ((int, tree));\n+extern tree type_hash_canon\t\tPARAMS ((unsigned int, tree));\n \n /* Given a VAR_DECL, PARM_DECL, RESULT_DECL or FIELD_DECL node,\n    calculates the DECL_SIZE, DECL_SIZE_UNIT, DECL_ALIGN and DECL_MODE\n@@ -2218,26 +2216,34 @@ extern int stmt_loop_nest_empty\t\t\tPARAMS ((void));\n extern tree fold\t\tPARAMS ((tree));\n \n extern int force_fit_type\tPARAMS ((tree, int));\n-extern int add_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int neg_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern int mul_double\t\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *));\n-extern void lshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, int, HOST_WIDE_INT *,\n-\t\t\t\t       HOST_WIDE_INT *, int));\n-extern void rshift_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, int,\n-\t\t\t\t       HOST_WIDE_INT *, HOST_WIDE_INT *, int));\n-extern void lrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, int, HOST_WIDE_INT *,\n-\t\t\t\t       HOST_WIDE_INT *));\n-extern void rrotate_double\tPARAMS ((HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, int, HOST_WIDE_INT *,\n-\t\t\t\t       HOST_WIDE_INT *));\n+extern int add_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern int neg_double\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern int mul_double\t\tPARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern void lshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *, int));\n+extern void rshift_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *, int));\n+extern void lrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n+extern void rrotate_double\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, unsigned int,\n+\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t HOST_WIDE_INT *));\n extern int operand_equal_p\tPARAMS ((tree, tree, int));\n extern tree invert_truthvalue\tPARAMS ((tree));\n \n@@ -2394,19 +2400,21 @@ extern tree get_file_function_name\tPARAMS ((int));\n extern void set_identifier_size\t\tPARAMS ((int));\n extern int int_fits_type_p\t\tPARAMS ((tree, tree));\n extern int tree_log2\t\t\tPARAMS ((tree));\n+extern int tree_floor_log2\t\tPARAMS ((tree));\n extern void preserve_initializer\tPARAMS ((void));\n extern void preserve_data\t\tPARAMS ((void));\n extern int object_permanent_p\t\tPARAMS ((tree));\n extern int type_precision\t\tPARAMS ((tree));\n extern int simple_cst_equal\t\tPARAMS ((tree, tree));\n+extern int compare_tree_int\t\tPARAMS ((tree, unsigned int));\n extern int type_list_equal\t\tPARAMS ((tree, tree));\n extern int chain_member\t\t\tPARAMS ((tree, tree));\n extern int chain_member_purpose\t\tPARAMS ((tree, tree));\n extern int chain_member_value\t\tPARAMS ((tree, tree));\n extern tree listify\t\t\tPARAMS ((tree));\n-extern tree type_hash_lookup\t\tPARAMS ((int, tree));\n-extern void type_hash_add\t\tPARAMS ((int, tree));\n-extern int type_hash_list\t\tPARAMS ((tree));\n+extern tree type_hash_lookup\t\tPARAMS ((unsigned int, tree));\n+extern void type_hash_add\t\tPARAMS ((unsigned int, tree));\n+extern unsigned int type_hash_list\tPARAMS ((tree));\n extern int simple_cst_list_equal\tPARAMS ((tree, tree));\n extern void debug_obstack\t\tPARAMS ((char *));\n extern void rtl_in_current_obstack\tPARAMS ((void));\n@@ -2449,6 +2457,7 @@ extern void free_temp_slots\t\tPARAMS ((void));\n extern void pop_temp_slots\t\tPARAMS ((void));\n extern void push_temp_slots\t\tPARAMS ((void));\n extern void preserve_temp_slots\t\tPARAMS ((struct rtx_def *));\n+extern void preserve_rtl_expr_temps\tPARAMS ((tree));\n extern int aggregate_value_p\t\tPARAMS ((tree));\n extern tree reorder_blocks\t\tPARAMS ((tree,\n \t\t\t\t\t\tstruct rtx_def *));\n@@ -2505,7 +2514,7 @@ extern void print_lang_statistics\tPARAMS ((void));\n \n /* In c-common.c */\n extern tree truthvalue_conversion\tPARAMS ((tree));\n-extern int min_precision\t\tPARAMS ((tree, int));\n+extern unsigned int min_precision\tPARAMS ((tree, int));\n extern void split_specs_attrs\t\tPARAMS ((tree, tree *, tree *));\n \n /* In c-decl.c */\n@@ -2537,12 +2546,14 @@ extern void variable_section\t\tPARAMS ((tree, int));\n \n /* In fold-const.c */\n extern int div_and_round_double\t\tPARAMS ((enum tree_code, int,\n-\t\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t\t\tHOST_WIDE_INT *,\n-\t\t\t\t\t\tHOST_WIDE_INT *,\n-\t\t\t\t\t\tHOST_WIDE_INT *,\n-\t\t\t\t\t\tHOST_WIDE_INT *));\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t HOST_WIDE_INT,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t HOST_WIDE_INT,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t\t HOST_WIDE_INT *,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t\t HOST_WIDE_INT *));\n \n /* In stmt.c */\n extern void emit_nop\t\t\tPARAMS ((void));"}, {"sha": "b90322084a7ab646ea76378978cd2302f85c539b", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05bccae2efd712562a20afadfc2889d87323e7ca/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=05bccae2efd712562a20afadfc2889d87323e7ca", "patch": "@@ -1424,16 +1424,15 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \n   if (! dont_output_data)\n     {\n-      int size;\n+      unsigned int size;\n \n       if (TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST)\n \tgoto finish;\n \n       size_tree = DECL_SIZE_UNIT (decl);\n       size = TREE_INT_CST_LOW (size_tree);\n \n-      if (TREE_INT_CST_HIGH (size_tree) != 0\n-\t  || size != TREE_INT_CST_LOW (size_tree))\n+      if (compare_tree_int (size_tree, size) != 0)\n \t{\n \t  error_with_decl (decl, \"size of variable `%s' is too large\");\n \t  goto finish;"}]}