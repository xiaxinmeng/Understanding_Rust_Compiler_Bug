{"sha": "2aad5d68c457d1ba465074be3781860af205fd0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFhZDVkNjhjNDU3ZDFiYTQ2NTA3NGJlMzc4MTg2MGFmMjA1ZmQwZA==", "commit": {"author": {"name": "Dan Nicolaescu", "email": "dann@ics.uci.edu", "date": "2001-12-16T02:26:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-16T02:26:58Z"}, "message": "sparc.c (mems_ok_for_ldd_peep): Rename from addrs_ok_for_ldd_peep_withmem...\n\n        * config/sparc/sparc.c (mems_ok_for_ldd_peep): Rename from\n        addrs_ok_for_ldd_peep_withmem; take MEMs as parameters, not\n        addrs; eliminate restriction of only using fp and sp as base\n        registers.\n        * config/sparc/sparc-protos.h: Update.\n        * config/sparc/sparc.md (movdi): Use TARGET_V9 not TARGET_ARCH64.\n        (*cmp_cc_set, *cmp_ccx_set64, *movdi_zero): New insns derived\n        from old define_peepholes.\n        Convert all the ldd/std peepholes to peephole2.\n\nFrom-SVN: r48059", "tree": {"sha": "9f411006b9b7f87081fc8ba542ba8b87b2604ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f411006b9b7f87081fc8ba542ba8b87b2604ce4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aad5d68c457d1ba465074be3781860af205fd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aad5d68c457d1ba465074be3781860af205fd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aad5d68c457d1ba465074be3781860af205fd0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aad5d68c457d1ba465074be3781860af205fd0d/comments", "author": null, "committer": null, "parents": [{"sha": "4023fb284388c170db87fcf01ecceced50dac8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4023fb284388c170db87fcf01ecceced50dac8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4023fb284388c170db87fcf01ecceced50dac8aa"}], "stats": {"total": 236, "additions": 153, "deletions": 83}, "files": [{"sha": "9cd09b9dd4ef6c8d05670194f2fda26c9a1f11fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2aad5d68c457d1ba465074be3781860af205fd0d", "patch": "@@ -1,3 +1,15 @@\n+2001-12-15  Dan Nicolaescu  <dann@ics.uci.edu>\n+\n+        * config/sparc/sparc.c (mems_ok_for_ldd_peep): Rename from\n+\taddrs_ok_for_ldd_peep_withmem; take MEMs as parameters, not\n+        addrs; eliminate restriction of only using fp and sp as base\n+        registers. \n+        * config/sparc/sparc-protos.h: Update.\n+        * config/sparc/sparc.md (movdi): Use TARGET_V9 not TARGET_ARCH64.\n+        (*cmp_cc_set, *cmp_ccx_set64, *movdi_zero): New insns derived\n+        from old define_peepholes.\n+        Convert all the ldd/std peepholes to peephole2.\n+\n 2001-12-15  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* s390.md (prologue, epilogue, *return_si, *return_di): New."}, {"sha": "7e0e1fcad9b9b4decf623506cfd1ce0bb233de6d", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=2aad5d68c457d1ba465074be3781860af205fd0d", "patch": "@@ -92,7 +92,7 @@ extern char *output_v9branch PARAMS ((rtx, int, int, int, int, int, rtx));\n extern void emit_v9_brxx_insn PARAMS ((enum rtx_code, rtx, rtx));\n extern void output_double_int PARAMS ((FILE *, rtx));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern int addrs_ok_for_ldd_peep PARAMS ((rtx, rtx));\n+extern int mems_ok_for_ldd_peep PARAMS ((rtx, rtx));\n extern int arith_double_4096_operand PARAMS ((rtx, enum machine_mode));\n extern int arith_4096_operand PARAMS ((rtx, enum machine_mode));\n extern int zero_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "48906d46bf4e9b689e52992d21169300e36db2e3", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=2aad5d68c457d1ba465074be3781860af205fd0d", "patch": "@@ -5646,27 +5646,28 @@ registers_ok_for_ldd_peep (reg1, reg2)\n   return (REGNO (reg1) == REGNO (reg2) - 1);\n }\n \n-/* Return 1 if addr1 and addr2 are suitable for use in an ldd or \n-   std insn.\n-\n-   This can only happen when addr1 and addr2 are consecutive memory\n-   locations (addr1 + 4 == addr2).  addr1 must also be aligned on a \n-   64 bit boundary (addr1 % 8 == 0).  \n-\n-   We know %sp and %fp are kept aligned on a 64 bit boundary.  Other\n-   registers are assumed to *never* be properly aligned and are \n-   rejected.\n-\n-   Knowing %sp and %fp are kept aligned on a 64 bit boundary, we \n-   need only check that the offset for addr1 % 8 == 0.  */\n+/* Return 1 if the addresses in mem1 and mem2 are suitable for use in\n+   an ldd or std insn. \n+      \n+   This can only happen when addr1 and addr2, the addresses in mem1\n+   and mem2, are consecutive memory locations (addr1 + 4 == addr2).\n+   addr1 must also be aligned on a 64-bit boundary.  */\n \n int\n-addrs_ok_for_ldd_peep (addr1, addr2)\n-      rtx addr1, addr2;\n+mems_ok_for_ldd_peep (mem1, mem2)\n+      rtx mem1, mem2;\n {\n+  rtx addr1, addr2;\n   unsigned int reg1;\n   int offset1;\n \n+  addr1 = XEXP (mem1, 0);\n+  addr2 = XEXP (mem2, 0);\n+\n+  /* mem1 should be aligned on a 64-bit boundary */\n+  if (MEM_ALIGN (mem1) < 64)\n+    return 0;\n+  \n   /* Extract a register number and offset (if used) from the first addr.  */\n   if (GET_CODE (addr1) == PLUS)\n     {\n@@ -5699,11 +5700,6 @@ addrs_ok_for_ldd_peep (addr1, addr2)\n       || GET_CODE (XEXP (addr2, 1)) != CONST_INT)\n     return 0;\n \n-  /* Only %fp and %sp are allowed.  Additionally both addresses must\n-     use the same register.  */\n-  if (reg1 != FRAME_POINTER_REGNUM && reg1 != STACK_POINTER_REGNUM)\n-    return 0;\n-\n   if (reg1 != REGNO (XEXP (addr2, 0)))\n     return 0;\n "}, {"sha": "dde4156f7b66c6e1945ecec4fe1bfb3832626ee2", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 124, "deletions": 62, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aad5d68c457d1ba465074be3781860af205fd0d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=2aad5d68c457d1ba465074be3781860af205fd0d", "patch": "@@ -2383,7 +2383,7 @@\n \t The const zero case is more complex, on v9\n \t we can always perform it.  */\n       if (register_operand (operands[1], DImode)\n-\t  || (TARGET_ARCH64\n+\t  || (TARGET_V9\n               && (operands[1] == const0_rtx)))\n         goto movdi_is_ok;\n \n@@ -2444,6 +2444,13 @@\n   ;\n }\")\n \n+(define_insn \"*movdi_zero\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+\t(const_int 0))]\n+  \"TARGET_V9\"\n+  \"stx\\\\t%%g0, %0\"\n+  [(set_attr \"type\" \"store\")])\n+\n ;; Be careful, fmovd does not exist when !arch64.\n ;; We match MEM moves directly when we have correct even\n ;; numbered registers, but fall into splits otherwise.\n@@ -7212,6 +7219,26 @@\n   \"TARGET_ARCH64\"\n   \"xnorcc\\\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmp_cc_set\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (reg:CC 100)\n+\t(compare:CC (match_dup 1)\n+\t\t    (const_int 0)))]\n+  \"\"\n+  \"orcc\\\\t%1, 0, %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*cmp_ccx_set64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"register_operand\" \"r\"))\n+   (set (reg:CCX 100)\n+\t(compare:CCX (match_dup 1)\n+\t\t     (const_int 0)))]\n+  \"TARGET_ARCH64\"\n+  \"orcc\\\\t%1, 0, %0\"\n+   [(set_attr \"type\" \"compare\")])\n \f\n ;; Floating point arithmetic instructions.\n \n@@ -8871,144 +8898,179 @@\n ;; The conditions in which we do this are very restricted and are \n ;; explained in the code for {registers,memory}_ok_for_ldd functions.\n \n-(define_peephole\n+(define_peephole2\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n       (const_int 0))\n    (set (match_operand:SI 1 \"memory_operand\" \"\")\n       (const_int 0))]\n   \"TARGET_V9\n    && ! MEM_VOLATILE_P (operands[0])\n    && ! MEM_VOLATILE_P (operands[1])\n-   && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[1], 0))\"\n-  \"stx\\\\t%%g0, %0\")\n+   && mems_ok_for_ldd_peep (operands[0], operands[1])\"\n+  [(set (match_dup 0)\n+       (const_int 0))]\n+  \"operands[0] = change_address (operands[0], DImode, NULL);\")\n \n-(define_peephole\n+(define_peephole2\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n       (const_int 0))\n    (set (match_operand:SI 1 \"memory_operand\" \"\")\n       (const_int 0))]\n   \"TARGET_V9\n    && ! MEM_VOLATILE_P (operands[0])\n    && ! MEM_VOLATILE_P (operands[1])\n-   && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[0], 0))\"\n-  \"stx\\\\t%%g0, %1\")\n+   && mems_ok_for_ldd_peep (operands[1], operands[0])\"\n+  [(set (match_dup 1)\n+       (const_int 0))]\n+  \"operands[1] = change_address (operands[1], DImode, NULL);\")\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (match_operand:SI 1 \"memory_operand\" \"\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=rf\")\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && ! MEM_VOLATILE_P (operands[1])\n    && ! MEM_VOLATILE_P (operands[3])\n-   && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[3], 0))\" \n-  \"ldd\\\\t%1, %0\")\n+   && mems_ok_for_ldd_peep (operands[1], operands[3])\" \n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[1] = change_address (operands[1], DImode, NULL);\n+   operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\")\n \n-(define_peephole\n+(define_peephole2\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n-        (match_operand:SI 1 \"register_operand\" \"rf\"))\n+        (match_operand:SI 1 \"register_operand\" \"\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n-        (match_operand:SI 3 \"register_operand\" \"rf\"))]\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n    && ! MEM_VOLATILE_P (operands[0])\n    && ! MEM_VOLATILE_P (operands[2])\n-   && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n-  \"std\\\\t%1, %0\")\n- \n-(define_peephole\n-  [(set (match_operand:SF 0 \"register_operand\" \"=fr\")\n+   && mems_ok_for_ldd_peep (operands[0], operands[2])\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[0] = change_address (operands[0], DImode, NULL);\n+   operands[1] = gen_rtx_REG (DImode, REGNO (operands[1]));\")\n+\n+(define_peephole2\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n         (match_operand:SF 1 \"memory_operand\" \"\"))\n-   (set (match_operand:SF 2 \"register_operand\" \"=fr\")\n+   (set (match_operand:SF 2 \"register_operand\" \"\")\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && ! MEM_VOLATILE_P (operands[1])\n    && ! MEM_VOLATILE_P (operands[3])\n-   && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[3], 0))\"\n-  \"ldd\\\\t%1, %0\")\n+   && mems_ok_for_ldd_peep (operands[1], operands[3])\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[1] = change_address (operands[1], DFmode, NULL);\n+   operands[0] = gen_rtx_REG (DFmode, REGNO (operands[0]));\")\n \n-(define_peephole\n+(define_peephole2\n   [(set (match_operand:SF 0 \"memory_operand\" \"\")\n-        (match_operand:SF 1 \"register_operand\" \"fr\"))\n+        (match_operand:SF 1 \"register_operand\" \"\"))\n    (set (match_operand:SF 2 \"memory_operand\" \"\")\n-        (match_operand:SF 3 \"register_operand\" \"fr\"))]\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n   && ! MEM_VOLATILE_P (operands[0])\n   && ! MEM_VOLATILE_P (operands[2])\n-  && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n-  \"std\\\\t%1, %0\")\n+  && mems_ok_for_ldd_peep (operands[0], operands[2])\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[0] = change_address (operands[0], DFmode, NULL);\n+   operands[1] = gen_rtx_REG (DFmode, REGNO (operands[1]));\")\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (match_operand:SI 1 \"memory_operand\" \"\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=rf\")\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n   && ! MEM_VOLATILE_P (operands[3])\n   && ! MEM_VOLATILE_P (operands[1])\n-  && addrs_ok_for_ldd_peep (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n-  \"ldd\\\\t%3, %2\")\n+  && mems_ok_for_ldd_peep (operands[3], operands[1])\"\n+  [(set (match_dup 2)\n+\t(match_dup 3))]\n+   \"operands[3] = change_address (operands[3], DImode, NULL);\n+    operands[2] = gen_rtx_REG (DImode, REGNO (operands[2]));\")\n \n-(define_peephole\n+(define_peephole2\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n-        (match_operand:SI 1 \"register_operand\" \"rf\"))\n+        (match_operand:SI 1 \"register_operand\" \"\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n-        (match_operand:SI 3 \"register_operand\" \"rf\"))]\n+        (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n   && ! MEM_VOLATILE_P (operands[2])\n   && ! MEM_VOLATILE_P (operands[0])\n-  && addrs_ok_for_ldd_peep (XEXP (operands[2], 0), XEXP (operands[0], 0))\" \n-  \"std\\\\t%3, %2\")\n+  && mems_ok_for_ldd_peep (operands[2], operands[0])\" \n+  [(set (match_dup 2)\n+\t(match_dup 3))]\n+  \"operands[2] = change_address (operands[2], DImode, NULL);\n+   operands[3] = gen_rtx_REG (DImode, REGNO (operands[3]));\n+   \")\n  \n-(define_peephole\n-  [(set (match_operand:SF 0 \"register_operand\" \"=fr\")\n+(define_peephole2\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n         (match_operand:SF 1 \"memory_operand\" \"\"))\n-   (set (match_operand:SF 2 \"register_operand\" \"=fr\")\n+   (set (match_operand:SF 2 \"register_operand\" \"\")\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n   && ! MEM_VOLATILE_P (operands[3])\n   && ! MEM_VOLATILE_P (operands[1])\n-  && addrs_ok_for_ldd_peep (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n-  \"ldd\\\\t%3, %2\")\n+  && mems_ok_for_ldd_peep (operands[3], operands[1])\"\n+  [(set (match_dup 2)\n+\t(match_dup 3))]\n+  \"operands[3] = change_address (operands[3], DFmode, NULL);\n+   operands[2] = gen_rtx_REG (DFmode, REGNO (operands[2]));\")\n \n-(define_peephole\n+(define_peephole2\n   [(set (match_operand:SF 0 \"memory_operand\" \"\")\n-        (match_operand:SF 1 \"register_operand\" \"fr\"))\n+        (match_operand:SF 1 \"register_operand\" \"\"))\n    (set (match_operand:SF 2 \"memory_operand\" \"\")\n-        (match_operand:SF 3 \"register_operand\" \"fr\"))]\n+        (match_operand:SF 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n   && ! MEM_VOLATILE_P (operands[2])\n   && ! MEM_VOLATILE_P (operands[0])\n-  && addrs_ok_for_ldd_peep (XEXP (operands[2], 0), XEXP (operands[0], 0))\"\n-  \"std\\\\t%3, %2\")\n+  && mems_ok_for_ldd_peep (operands[2], operands[0])\"\n+  [(set (match_dup 2)\n+\t(match_dup 3))]\n+  \"operands[2] = change_address (operands[2], DFmode, NULL);\n+   operands[3] = gen_rtx_REG (DFmode, REGNO (operands[3]));\")\n  \n ;; Optimize the case of following a reg-reg move with a test\n ;; of reg just moved.  Don't allow floating point regs for operand 0 or 1.\n ;; This can result from a float to fix conversion.\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n    (set (reg:CC 100)\n-\t(compare:CC (match_operand:SI 2 \"register_operand\" \"r\")\n+\t(compare:CC (match_operand:SI 2 \"register_operand\" \"\")\n \t\t    (const_int 0)))]\n   \"(rtx_equal_p (operands[2], operands[0])\n     || rtx_equal_p (operands[2], operands[1]))\n-   && ! FP_REG_P (operands[0])\n-   && ! FP_REG_P (operands[1])\"\n-  \"orcc\\\\t%1, 0, %0\")\n+    && ! SPARC_FP_REG_P (REGNO (operands[0]))\n+    && ! SPARC_FP_REG_P (REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (set (reg:CC 100)\n+\t\t   (compare:CC (match_dup 1) (const_int 0)))])]\n+  \"\")\n \n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))\n+(define_peephole2\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"register_operand\" \"\"))\n    (set (reg:CCX 100)\n-\t(compare:CCX (match_operand:DI 2 \"register_operand\" \"r\")\n+\t(compare:CCX (match_operand:DI 2 \"register_operand\" \"\")\n \t\t    (const_int 0)))]\n   \"TARGET_ARCH64\n    && (rtx_equal_p (operands[2], operands[0])\n        || rtx_equal_p (operands[2], operands[1]))\n-   && ! FP_REG_P (operands[0])\n-   && ! FP_REG_P (operands[1])\"\n-  \"orcc\\\\t%1, 0, %0\")\n+   && ! SPARC_FP_REG_P (REGNO (operands[0]))\n+   && ! SPARC_FP_REG_P (REGNO (operands[1]))\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (set (reg:CCX 100)\n+\t\t   (compare:CC (match_dup 1) (const_int 0)))])]\n+  \"\")\n \n ;; Return peepholes.  First the \"normal\" ones.\n ;; These are necessary to catch insns ending up in the epilogue delay list."}]}