{"sha": "25af8512559873d4b6e67d27a07f504a585b6037", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVhZjg1MTI1NTk4NzNkNGI2ZTY3ZDI3YTA3ZjUwNGE1ODViNjAzNw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-10-05T02:48:47Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-10-05T02:48:47Z"}, "message": "Make-lang.in (cp/decl.o, cp/tree.o): Depend on tree-inline.h.\n\n* Make-lang.in (cp/decl.o, cp/tree.o): Depend on tree-inline.h.\n(cp/pt.o, cp/semantics.o, cp/optimize.o): Likewise.\n* cp-tree.h (lang_decl): Moved inlined_fns to tree_decl.\n(TREE_READONLY_DECL_P, DECL_INLINED_FNS): Moved to ../tree.h.\n(flag_inline_trees): Moved declaration to ../tree-inline.h.\n(walk_tree): Moved declaration to ../tree-inline.h.\n(walk_tree_without_duplicates, copy_tree_r): Likewise.\n(remap_save_expr): Likewise.\n* decl.c: Include tree-inline.h.\n(lang_mark_tree): Don't mark inlined_fns.\n* decl2.c (flag_inline_trees): Moved defn to ../tree-inline.c.\n* optimize.c: Include tree-inline.h.\n(optimize_inline_calls): Move declaration to ../tree.h, as\nnon-static.\n(remap_decl): Use language-independent constructs and hooks.\n(remap_block, copy_body_r, declare_return_variable): Likewise.\n(inlinable_function_p): Likewise.  Don't test for\nDECL_LANG_SPECIFIC before DECL_INLINED_FNS as inlined_fns is\nno longer language-specific.\n(optimize_inline_calls): Likewise.  Make it non-static.  Moved\ncall of dump_function to...\n(optimize_function): Here...\n(clone_body): New function, extracted from...\n(maybe_clone_body): ... here.  Build decl_map locally and pass\nit on to clone_body.\n* pt.c, semantics.c: Include tree-inline.h.\n* tree.c: Likewise.\n(cp_walk_subtrees): New language-specific hook for tree inlining.\n(cp_cannot_inline_tree_fn, cp_add_pending_fn_decls,\ncp_is_overload_p, cp_auto_var_in_fn_p,\ncp_copy_res_decl_for_inlining): Likewise.\n(walk_tree): Move language-specific constructs into...\n(cp_walk_subtrees): this new function.\n(copy_tree_r): Use language-independent constructs and hooks.\n(init_tree): Initialize tree inlining hooks.\n(remap_save_expr): Adjust prototype so that the declaration\ndoes not require the definition of splay_tree.\n\nFrom-SVN: r46020", "tree": {"sha": "8512628500ca03ba513e5684fba6a6a044156017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8512628500ca03ba513e5684fba6a6a044156017"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25af8512559873d4b6e67d27a07f504a585b6037", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25af8512559873d4b6e67d27a07f504a585b6037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25af8512559873d4b6e67d27a07f504a585b6037", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25af8512559873d4b6e67d27a07f504a585b6037/comments", "author": null, "committer": null, "parents": [{"sha": "ffb0e73a97aacc285d5cb176af65359b3329739b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb0e73a97aacc285d5cb176af65359b3329739b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb0e73a97aacc285d5cb176af65359b3329739b"}], "stats": {"total": 575, "additions": 385, "deletions": 190}, "files": [{"sha": "2926e129494cac990f990a024f442dc23ef95c62", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -1,3 +1,43 @@\n+2001-10-04  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* Make-lang.in (cp/decl.o, cp/tree.o): Depend on tree-inline.h.\n+\t(cp/pt.o, cp/semantics.o, cp/optimize.o): Likewise.\n+\t* cp-tree.h (lang_decl): Moved inlined_fns to tree_decl.\n+\t(TREE_READONLY_DECL_P, DECL_INLINED_FNS): Moved to ../tree.h.\n+\t(flag_inline_trees): Moved declaration to ../tree-inline.h.\n+\t(walk_tree): Moved declaration to ../tree-inline.h.\n+\t(walk_tree_without_duplicates, copy_tree_r): Likewise.\n+\t(remap_save_expr): Likewise.\n+\t* decl.c: Include tree-inline.h.\n+\t(lang_mark_tree): Don't mark inlined_fns.\n+\t* decl2.c (flag_inline_trees): Moved defn to ../tree-inline.c.\n+\t* optimize.c: Include tree-inline.h.\n+\t(optimize_inline_calls): Move declaration to ../tree.h, as\n+\tnon-static.\n+\t(remap_decl): Use language-independent constructs and hooks.\n+\t(remap_block, copy_body_r, declare_return_variable): Likewise.\n+\t(inlinable_function_p): Likewise.  Don't test for\n+\tDECL_LANG_SPECIFIC before DECL_INLINED_FNS as inlined_fns is\n+\tno longer language-specific.\n+\t(optimize_inline_calls): Likewise.  Make it non-static.  Moved\n+\tcall of dump_function to...\n+\t(optimize_function): Here...\n+\t(clone_body): New function, extracted from...\n+\t(maybe_clone_body): ... here.  Build decl_map locally and pass\n+\tit on to clone_body.\n+\t* pt.c, semantics.c: Include tree-inline.h.\n+\t* tree.c: Likewise.\n+\t(cp_walk_subtrees): New language-specific hook for tree inlining.\n+\t(cp_cannot_inline_tree_fn, cp_add_pending_fn_decls,\n+\tcp_is_overload_p, cp_auto_var_in_fn_p,\n+\tcp_copy_res_decl_for_inlining): Likewise.\n+\t(walk_tree): Move language-specific constructs into...\n+\t(cp_walk_subtrees): this new function.\n+\t(copy_tree_r): Use language-independent constructs and hooks.\n+\t(init_tree): Initialize tree inlining hooks.\n+\t(remap_save_expr): Adjust prototype so that the declaration\n+\tdoes not require the definition of splay_tree.\n+\n 2001-10-03  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* rtti.c (get_tinfo_decl): Call typeinfo_in_lib_p with the type used"}, {"sha": "65a16063eb6692be140c26ca39c13bef97031ad0", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -243,7 +243,7 @@ cp/lex.o: cp/lex.c $(CXX_TREE_H) cp/parse.h flags.h cp/lex.h c-pragma.h \\\n   $(TM_P_H)\n cp/decl.o: cp/decl.c $(CXX_TREE_H) flags.h cp/lex.h cp/decl.h stack.h \\\n   output.h $(EXPR_H) except.h toplev.h hash.h $(GGC_H) $(RTL_H) \\\n-  cp/operators.def $(TM_P_H)\n+  cp/operators.def $(TM_P_H) tree-inline.h\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(GGC_H) $(RTL_H)\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) flags.h toplev.h output.h $(TM_P_H) \\\n@@ -261,7 +261,7 @@ cp/method.o: cp/method.c $(CXX_TREE_H) toplev.h $(GGC_H) $(RTL_H) $(EXPR_H) \\\n cp/cvt.o: cp/cvt.c $(CXX_TREE_H) cp/decl.h flags.h toplev.h convert.h\n cp/search.o: cp/search.c $(CXX_TREE_H) stack.h flags.h toplev.h $(RTL_H)\n cp/tree.o: cp/tree.c $(CXX_TREE_H) flags.h toplev.h $(GGC_H) $(RTL_H) \\\n-  insn-config.h integrate.h\n+  insn-config.h integrate.h tree-inline.h\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(SYSTEM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) flags.h toplev.h\n cp/except.o: cp/except.c $(CXX_TREE_H) flags.h $(RTL_H) except.h toplev.h \\\n@@ -270,14 +270,15 @@ cp/expr.o: cp/expr.c $(CXX_TREE_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n cp/xref.o: cp/xref.c $(CXX_TREE_H) input.h toplev.h\n cp/pt.o: cp/pt.c $(CXX_TREE_H) cp/decl.h cp/parse.h cp/lex.h toplev.h \\\n-  $(GGC_H) $(RTL_H) except.h\n+  $(GGC_H) $(RTL_H) except.h tree-inline.h\n cp/error.o: cp/error.c $(CXX_TREE_H) toplev.h diagnostic.h flags.h real.h\n cp/repo.o: cp/repo.c $(CXX_TREE_H) toplev.h $(GGC_H) diagnostic.h\n cp/semantics.o: cp/semantics.c $(CXX_TREE_H) cp/lex.h except.h toplev.h \\\n-  flags.h $(GGC_H) debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H)\n+  flags.h $(GGC_H) debug.h output.h $(RTL_H) $(TIMEVAR_H) $(EXPR_H) \\\n+  tree-inline.h\n cp/dump.o: cp/dump.c $(CXX_TREE_H) c-dump.h\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) rtl.h integrate.h insn-config.h \\\n-  input.h $(PARAMS_H) debug.h\n+  input.h $(PARAMS_H) debug.h tree-inline.h\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) toplev.h\n \n cp/parse.o: cp/parse.c $(CXX_TREE_H) flags.h cp/lex.h except.h output.h \\"}, {"sha": "98e747da6ff12e64c1bbf0c2ee30cc2d131b952b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -1758,10 +1758,6 @@ struct lang_decl\n   /* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n   tree cloned_function;\n \n-  /* In a FUNCTION_DECL, these are function data which is to be kept\n-     as long as FUNCTION_DECL is kept.  */\n-  tree inlined_fns;\n-\n   union\n   {\n     tree sorted_fields;\n@@ -1778,10 +1774,6 @@ struct lang_decl\n \n #define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.id.str)\n \n-/* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n-#define TREE_READONLY_DECL_P(NODE) \\\n-  (TREE_READONLY (NODE) && DECL_P (NODE))\n-\n /* DECL_NEEDED_P holds of a declaration when we need to emit its\n    definition.  This is true when the back-end tells us that\n    the symbol has been referenced in the generated code.  If, however,\n@@ -1888,10 +1880,6 @@ struct lang_decl\n #define DECL_CLONED_FUNCTION(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->cloned_function)\n \n-/* List of FUNCION_DECLs inlined into this function's body.  */\n-#define DECL_INLINED_FNS(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->inlined_fns)\n-\n /* Nonzero if NODE has DECL_DISCRIMINATOR and not DECL_ACCESS.  */\n #define DECL_DISCRIMINATOR_P(NODE)\t\\\n   (TREE_CODE (NODE) == VAR_DECL\t\t\\\n@@ -3262,13 +3250,6 @@ extern int flag_implicit_templates;\n \n extern int flag_weak;\n \n-/* 0 if we should not perform inlining.\n-   1 if we should expand functions calls inline at the tree level.  \n-   2 if we should consider *all* functions to be inline \n-   candidates.  */\n-\n-extern int flag_inline_trees;\n-\n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n extern int at_eof;\n@@ -4197,18 +4178,9 @@ extern void debug_binfo\t\t\t\tPARAMS ((tree));\n extern tree build_dummy_object\t\t\tPARAMS ((tree));\n extern tree maybe_dummy_object\t\t\tPARAMS ((tree, tree *));\n extern int is_dummy_object\t\t\tPARAMS ((tree));\n-extern tree walk_tree                           PARAMS ((tree *,\n-\t\t\t\t\t\t\t walk_tree_fn,\n-\t\t\t\t\t\t\t void *,\n-\t\t\t\t\t\t\t htab_t));\n-extern tree walk_tree_without_duplicates        PARAMS ((tree *,\n-\t\t\t\t\t\t\t walk_tree_fn,\n-\t\t\t\t\t\t\t void *));\n-extern tree copy_tree_r                         PARAMS ((tree *, int *, void *));\n extern const struct attribute_spec cp_attribute_table[];\n extern tree make_ptrmem_cst                     PARAMS ((tree, tree));\n extern tree cp_build_qualified_type_real        PARAMS ((tree, int, int));\n-extern void remap_save_expr                     PARAMS ((tree *, splay_tree, tree, int *));\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n extern tree build_shared_int_cst                PARAMS ((int));"}, {"sha": "0dfd8d65d324ce0c360c17dbac5c3309480ba21f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"flags.h\"\n #include \"cp-tree.h\"\n+#include \"tree-inline.h\"\n #include \"decl.h\"\n #include \"lex.h\"\n #include \"output.h\"\n@@ -14479,7 +14480,6 @@ lang_mark_tree (t)\n \t      ggc_mark_tree (ld->befriending_classes);\n \t      ggc_mark_tree (ld->context);\n \t      ggc_mark_tree (ld->cloned_function);\n-\t      ggc_mark_tree (ld->inlined_fns);\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tggc_mark_tree (ld->u.sorted_fields);\n \t      else if (TREE_CODE (t) == FUNCTION_DECL"}, {"sha": "0ab9299244ed403c57da3898943acc42f0348ebb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -378,13 +378,6 @@ int flag_weak = 1;\n \n int flag_use_cxa_atexit;\n \n-/* 0 if we should not perform inlining.\n-   1 if we should expand functions calls inline at the tree level.  \n-   2 if we should consider *all* functions to be inline \n-   candidates.  */\n-\n-int flag_inline_trees = 0;\n-\n /* Maximum template instantiation depth.  This limit is rather\n    arbitrary, but it exists to limit the time it takes to notice\n    infinite template instantiations.  */"}, {"sha": "bbc555bf6a9b25cbb910e6c383bb281670ac1f47", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 97, "deletions": 116, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -33,6 +33,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"hashtab.h\"\n #include \"debug.h\"\n+#include \"tree-inline.h\"\n \n /* To Do:\n \n@@ -99,7 +100,6 @@ static int inlinable_function_p PARAMS ((tree, inline_data *));\n static tree remap_decl PARAMS ((tree, inline_data *));\n static void remap_block PARAMS ((tree, tree, inline_data *));\n static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n-static void optimize_inline_calls PARAMS ((tree));\n static tree calls_setjmp_r PARAMS ((tree *, int *, void *));\n static void update_cloned_parm PARAMS ((tree, tree));\n static void dump_function PARAMS ((enum tree_dump_index, tree));\n@@ -121,7 +121,7 @@ remap_decl (decl, id)\n \n   /* We only remap local variables in the current function.  */\n   fn = VARRAY_TOP_TREE (id->fns);\n-  if (!nonstatic_local_decl_p (decl) || DECL_CONTEXT (decl) != fn)\n+  if (! LANG_AUTO_VAR_IN_FN_P (decl, fn))\n     return NULL_TREE;\n \n   /* See if we have remapped this declaration.  */\n@@ -151,8 +151,8 @@ remap_decl (decl, id)\n \t\t     copy_body_r, id, NULL);\n \t}\n \n-      if (!DECL_NAME (t) && TREE_TYPE (t)\n-\t  && ANON_AGGR_TYPE_P (TREE_TYPE ((t))))\n+      if (! DECL_NAME (t) && TREE_TYPE (t)\n+\t  && LANG_ANON_AGGR_TYPE_P (TREE_TYPE (t)))\n \t{\n \t  /* For a VAR_DECL of anonymous type, we must also copy the\n \t     member VAR_DECLS here and rechain the\n@@ -165,7 +165,8 @@ remap_decl (decl, id)\n \t    {\n \t      tree member = remap_decl (TREE_VALUE (src), id);\n \n-\t      my_friendly_assert (!TREE_PURPOSE (src), 20010529);\n+\t      if (TREE_PURPOSE (src))\n+\t\tabort ();\n \t      members = tree_cons (NULL, member, members);\n \t    }\n \t  DECL_ANON_UNION_ELEMS (t) = nreverse (members);\n@@ -277,7 +278,8 @@ remap_block (scope_stmt, decls, id)\n       /* Find this block in the table of remapped things.  */\n       n = splay_tree_lookup (id->decl_map,\n \t\t\t     (splay_tree_key) SCOPE_STMT_BLOCK (scope_stmt));\n-      my_friendly_assert (n != NULL, 19991203);\n+      if (! n)\n+\tabort ();\n       SCOPE_STMT_BLOCK (scope_stmt) = (tree) n->value;\n     }\n }\n@@ -322,12 +324,14 @@ copy_body_r (tp, walk_subtrees, data)\n   id = (inline_data *) data;\n   fn = VARRAY_TOP_TREE (id->fns);\n \n+#if 0\n   /* All automatic variables should have a DECL_CONTEXT indicating\n      what function they come from.  */\n   if ((TREE_CODE (*tp) == VAR_DECL || TREE_CODE (*tp) == LABEL_DECL)\n       && DECL_NAMESPACE_SCOPE_P (*tp))\n-    my_friendly_assert (DECL_EXTERNAL (*tp) || TREE_STATIC (*tp),\n-\t\t\t19991113);\n+    if (! DECL_EXTERNAL (*tp) && ! TREE_STATIC (*tp))\n+      abort ();\n+#endif\n \n   /* If this is a RETURN_STMT, change it into an EXPR_STMT and a\n      GOTO_STMT with the RET_LABEL as its target.  */\n@@ -359,26 +363,29 @@ copy_body_r (tp, walk_subtrees, data)\n      variables.  We don't want to copy static variables; there's only\n      one of those, no matter how many times we inline the containing\n      function.  */\n-  else if (nonstatic_local_decl_p (*tp) && DECL_CONTEXT (*tp) == fn)\n+  else if (LANG_AUTO_VAR_IN_FN_P (*tp, fn))\n     {\n       tree new_decl;\n \n       /* Remap the declaration.  */\n       new_decl = remap_decl (*tp, id);\n-      my_friendly_assert (new_decl != NULL_TREE, 19991203);\n+      if (! new_decl)\n+\tabort ();\n       /* Replace this variable with the copy.  */\n       STRIP_TYPE_NOPS (new_decl);\n       *tp = new_decl;\n     }\n+#if 0\n   else if (nonstatic_local_decl_p (*tp)\n \t   && DECL_CONTEXT (*tp) != VARRAY_TREE (id->fns, 0))\n-    my_friendly_abort (0);\n+    abort ();\n+#endif\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n     remap_save_expr (tp, id->decl_map, VARRAY_TREE (id->fns, 0),\n \t\t     walk_subtrees);\n   else if (TREE_CODE (*tp) == UNSAVE_EXPR)\n     /* UNSAVE_EXPRs should not be generated until expansion time.  */\n-    my_friendly_abort (19991113);\n+    abort ();\n   /* For a SCOPE_STMT, we must copy the associated block so that we\n      can write out debugging information for the inlined variables.  */\n   else if (TREE_CODE (*tp) == SCOPE_STMT && !id->in_target_cleanup_p)\n@@ -398,8 +405,7 @@ copy_body_r (tp, walk_subtrees, data)\n \t}\n       else if (TREE_CODE (*tp) == MODIFY_EXPR\n \t       && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n-\t       && nonstatic_local_decl_p (TREE_OPERAND (*tp, 0))\n-\t       && DECL_CONTEXT (TREE_OPERAND (*tp, 0)) == fn)\n+\t       && LANG_AUTO_VAR_IN_FN_P (TREE_OPERAND (*tp, 0), fn))\n \t{\n \t  /* Some assignments VAR = VAR; don't generate any rtl code\n \t     and thus don't count as variable modification.  Avoid\n@@ -561,7 +567,7 @@ declare_return_variable (id, use_stmt)\n   tree fn = VARRAY_TOP_TREE (id->fns);\n   tree result = DECL_RESULT (fn);\n   tree var;\n-  int aggregate_return_p;\n+  int need_return_decl = 1;\n \n   /* We don't need to do anything for functions that don't return\n      anything.  */\n@@ -571,29 +577,9 @@ declare_return_variable (id, use_stmt)\n       return NULL_TREE;\n     }\n \n-  /* Figure out whether or not FN returns an aggregate.  */\n-  aggregate_return_p = IS_AGGR_TYPE (TREE_TYPE (result));\n-\n-  /* If FN returns an aggregate then the caller will always create the\n-     temporary (using a TARGET_EXPR) and the call will be the\n-     initializing expression for the TARGET_EXPR.  If we were just to\n-     create a new VAR_DECL here, then the result of this function\n-     would be copied (bitwise) into the variable initialized by the\n-     TARGET_EXPR.  That's incorrect, so we must transform any\n-     references to the RESULT into references to the target.  */\n-  if (aggregate_return_p)\n-    {\n-      my_friendly_assert (VARRAY_ACTIVE_SIZE (id->target_exprs) != 0,\n-\t\t\t  20000430);\n-      var = TREE_OPERAND (VARRAY_TOP_TREE (id->target_exprs), 0);\n-      my_friendly_assert\n-\t(same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (var),\n-\t\t\t\t\t\t    TREE_TYPE (result)),\n-\t 20000430);\n-    }\n-  /* Otherwise, make an appropriate copy.  */\n-  else\n-    var = copy_decl_for_inlining (result, fn, VARRAY_TREE (id->fns, 0));\n+  var = LANG_COPY_RES_DECL_FOR_INLINING (result, fn, VARRAY_TREE (id->fns, 0),\n+\t\t\t\t\t id->decl_map, &need_return_decl,\n+\t\t\t\t\t &id->target_exprs);\n \n   /* Register the VAR_DECL as the equivalent for the RESULT_DECL; that\n      way, when the RESULT_DECL is encountered, it will be\n@@ -602,29 +588,12 @@ declare_return_variable (id, use_stmt)\n \t\t     (splay_tree_key) result,\n \t\t     (splay_tree_value) var);\n \n-  if (DECL_SAVED_FUNCTION_DATA (fn))\n-    {\n-      tree nrv = DECL_SAVED_FUNCTION_DATA (fn)->x_return_value;\n-      if (nrv)\n-\t{\n-\t  /* We have a named return value; copy the name and source\n-\t     position so we can get reasonable debugging information, and\n-\t     register the return variable as its equivalent.  */\n-\t  DECL_NAME (var) = DECL_NAME (nrv);\n-\t  DECL_SOURCE_FILE (var) = DECL_SOURCE_FILE (nrv);\n-\t  DECL_SOURCE_LINE (var) = DECL_SOURCE_LINE (nrv);\n-\t  splay_tree_insert (id->decl_map,\n-\t\t\t     (splay_tree_key) nrv,\n-\t\t\t     (splay_tree_value) var);\n-\t}\n-    }\n-\n   /* Build the USE_STMT.  */\n   *use_stmt = build_stmt (EXPR_STMT, var);\n \n   /* Build the declaration statement if FN does not return an\n      aggregate.  */\n-  if (!aggregate_return_p)\n+  if (need_return_decl)\n     return build_stmt (DECL_STMT, var);\n   /* If FN does return an aggregate, there's no need to declare the\n      return variable; we're using a variable in our caller's frame.  */\n@@ -656,12 +625,11 @@ inlinable_function_p (fn, id)\n      it.  */\n   else if (!DECL_INLINE (fn))\n     ;\n-  /* We can't inline varargs functions.  */\n-  else if (varargs_function_p (fn))\n-    ;\n-  /* We can't inline functions that are too big.\n-   * Only allow a single function to eat up half of our budget. */\n-  else if (DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 2)\n+  /* We can't inline functions that are too big.  Only allow a single\n+     function to eat up half of our budget.  Make special allowance\n+     for extern inline functions, though.  */\n+  else if (! LANG_DISREGARD_INLINE_LIMITS (fn)\n+\t   && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 2)\n     ;\n   /* All is well.  We can inline this function.  Traditionally, GCC\n      has refused to inline functions using alloca, or functions whose\n@@ -675,27 +643,26 @@ inlinable_function_p (fn, id)\n \n   /* Even if this function is not itself too big to inline, it might\n      be that we've done so much inlining already that we don't want to\n-     risk too much inlining any more and thus halve the acceptable size. */\n-  if ((DECL_NUM_STMTS (fn) + id->inlined_stmts) * INSNS_PER_STMT\n-      > MAX_INLINE_INSNS\n+     risk too much inlining any more and thus halve the acceptable\n+     size.  */\n+  if (! LANG_DISREGARD_INLINE_LIMITS (fn)\n+      && ((DECL_NUM_STMTS (fn) + id->inlined_stmts) * INSNS_PER_STMT\n+\t  > MAX_INLINE_INSNS)\n       && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 4)\n     inlinable = 0;\n \n-  /* We can inline a template instantiation only if it's fully\n-     instantiated.  */\n-  if (inlinable\n-      && DECL_TEMPLATE_INFO (fn)\n-      && TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (fn)))\n-    {\n-      fn = instantiate_decl (fn, /*defer_ok=*/0);\n-      inlinable = !TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (fn));\n-    }\n-\n+  if (inlinable && LANG_CANNOT_INLINE_TREE_FN (&fn))\n+    inlinable = 0;\n+  \n   /* If we don't have the function body available, we can't inline\n      it.  */\n   if (!DECL_SAVED_TREE (fn))\n     inlinable = 0;\n \n+  /* Check again, language hooks may have modified it.  */\n+  if (! inlinable || DECL_UNINLINABLE (fn))\n+    return 0;\n+\n   /* Don't do recursive inlining, either.  We don't record this in\n      DECL_UNINLINABLE; we may be able to inline this function later.  */\n   if (inlinable)\n@@ -706,7 +673,7 @@ inlinable_function_p (fn, id)\n \tif (VARRAY_TREE (id->fns, i) == fn)\n \t  return 0;\n \n-      if (inlinable && DECL_LANG_SPECIFIC (fn) && DECL_INLINED_FNS (fn))\n+      if (inlinable && DECL_INLINED_FNS (fn))\n \t{\n \t  int j;\n \t  tree inlined_fns = DECL_INLINED_FNS (fn);\n@@ -808,7 +775,7 @@ expand_call_inline (tp, walk_subtrees, data)\n      for the return statements within the function to jump to.  The\n      type of the statement expression is the return type of the\n      function call.  */\n-  expr = build_min (STMT_EXPR, TREE_TYPE (TREE_TYPE (fn)), NULL_TREE);\n+  expr = build1 (STMT_EXPR, TREE_TYPE (TREE_TYPE (fn)), NULL_TREE);\n \n   /* Local declarations will be replaced by their equivalents in this\n      map.  */\n@@ -832,7 +799,7 @@ expand_call_inline (tp, walk_subtrees, data)\n \n   /* Record the function we are about to inline if optimize_function\n      has not been called on it yet and we don't have it in the list.  */\n-  if (DECL_LANG_SPECIFIC (fn) && !DECL_INLINED_FNS (fn))\n+  if (! DECL_INLINED_FNS (fn))\n     {\n       int i;\n \n@@ -878,9 +845,9 @@ expand_call_inline (tp, walk_subtrees, data)\n   /* Close the block for the parameters.  */\n   scope_stmt = build_stmt (SCOPE_STMT, DECL_INITIAL (fn));\n   SCOPE_NO_CLEANUPS_P (scope_stmt) = 1;\n-  my_friendly_assert (DECL_INITIAL (fn)\n-\t\t      && TREE_CODE (DECL_INITIAL (fn)) == BLOCK,\n-\t\t      19991203);\n+  if (! DECL_INITIAL (fn)\n+      || TREE_CODE (DECL_INITIAL (fn)) != BLOCK)\n+    abort ();\n   remap_block (scope_stmt, NULL_TREE, id);\n   STMT_EXPR_STMT (expr)\n     = chainon (STMT_EXPR_STMT (expr), scope_stmt);\n@@ -957,13 +924,12 @@ expand_calls_inline (tp, id)\n \n /* Expand calls to inline functions in the body of FN.  */\n \n-static void\n+void\n optimize_inline_calls (fn)\n      tree fn;\n {\n   inline_data id;\n   tree prev_fn;\n-  struct saved_scope *s;\n   \n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n@@ -978,12 +944,8 @@ optimize_inline_calls (fn)\n       VARRAY_PUSH_TREE (id.fns, current_function_decl);\n       prev_fn = current_function_decl;\n     }\n-  for (s = scope_chain; s; s = s->prev)\n-    if (s->function_decl && s->function_decl != prev_fn)\n-      {\n-\tVARRAY_PUSH_TREE (id.fns, s->function_decl);\n-\tprev_fn = s->function_decl;\n-      }\n+\n+  prev_fn = LANG_ADD_PENDING_FN_DECLS (&id.fns, prev_fn);\n   \n   /* Create the stack of TARGET_EXPRs.  */\n   VARRAY_TREE_INIT (id.target_exprs, 32, \"target_exprs\");\n@@ -1014,8 +976,6 @@ optimize_inline_calls (fn)\n       DECL_INLINED_FNS (fn) = ifn;\n     }\n   VARRAY_FREE (id.inlined_fns);\n-  \n-  dump_function (TDI_inlined, fn);\n }\n \n /* Optimize the body of FN. */\n@@ -1043,7 +1003,11 @@ optimize_function (fn)\n          optimization, (c) virtual functions are rarely inlineable,\n          and (d) ASM_OUTPUT_MI_THUNK is there to DTRT anyway.  */\n       && !DECL_THUNK_P (fn))\n-    optimize_inline_calls (fn);\n+    {\n+      optimize_inline_calls (fn);\n+\n+      dump_function (TDI_inlined, fn);\n+    }\n   \n   /* Undo the call to ggc_push_context above.  */\n   --function_depth;\n@@ -1106,6 +1070,38 @@ update_cloned_parm (parm, cloned_parm)\n   DECL_SOURCE_LINE (cloned_parm) = DECL_SOURCE_LINE (parm);\n }\n \n+/* FN is a function that has a complete body, and CLONE is a function\n+   whose body is to be set to a copy of FN, mapping argument\n+   declarations according to the ARG_MAP splay_tree.  */\n+\n+void\n+clone_body (clone, fn, arg_map)\n+     tree clone, fn;\n+     void *arg_map;\n+{\n+  inline_data id;\n+\n+  /* Clone the body, as if we were making an inline call.  But, remap\n+     the parameters in the callee to the parameters of caller.  If\n+     there's an in-charge parameter, map it to an appropriate\n+     constant.  */\n+  memset (&id, 0, sizeof (id));\n+  VARRAY_TREE_INIT (id.fns, 2, \"fns\");\n+  VARRAY_PUSH_TREE (id.fns, clone);\n+  VARRAY_PUSH_TREE (id.fns, fn);\n+  id.decl_map = (splay_tree)arg_map;\n+\n+  /* Cloning is treated slightly differently from inlining.  Set\n+     CLONING_P so that it's clear which operation we're performing.  */\n+  id.cloning_p = true;\n+\n+  /* Actually copy the body.  */\n+  TREE_CHAIN (DECL_SAVED_TREE (clone)) = copy_body (&id);\n+\n+  /* Clean up.  */\n+  VARRAY_FREE (id.fns);\n+}\n+\n /* FN is a function that has a complete body.  Clone the body as\n    necessary.  Returns non-zero if there's no longer any need to\n    process the main body.  */\n@@ -1114,7 +1110,6 @@ int\n maybe_clone_body (fn)\n      tree fn;\n {\n-  inline_data id;\n   tree clone;\n   int first = 1;\n \n@@ -1135,6 +1130,7 @@ maybe_clone_body (fn)\n       tree parm;\n       tree clone_parm;\n       int parmno;\n+      splay_tree decl_map;\n \n       /* Update CLONE's source position information to match FN's.  */\n       DECL_SOURCE_FILE (clone) = DECL_SOURCE_FILE (fn);\n@@ -1178,22 +1174,8 @@ maybe_clone_body (fn)\n       push_to_top_level ();\n       start_function (NULL_TREE, clone, NULL_TREE, SF_PRE_PARSED);\n \n-      /* Just clone the body, as if we were making an inline call.\n-\t But, remap the parameters in the callee to the parameters of\n-\t caller.  If there's an in-charge parameter, map it to an\n-\t appropriate constant.  */\n-      memset (&id, 0, sizeof (id));\n-      VARRAY_TREE_INIT (id.fns, 2, \"fns\");\n-      VARRAY_PUSH_TREE (id.fns, clone);\n-      VARRAY_PUSH_TREE (id.fns, fn);\n-\n-      /* Cloning is treated slightly differently from inlining.  Set\n-\t CLONING_P so that its clear which operation we're performing.  */\n-      id.cloning_p = true;\n-\n       /* Remap the parameters.  */\n-      id.decl_map = splay_tree_new (splay_tree_compare_pointers,\n-\t\t\t\t    NULL, NULL);\n+      decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n       for (parmno = 0,\n \t     parm = DECL_ARGUMENTS (fn),\n \t     clone_parm = DECL_ARGUMENTS (clone);\n@@ -1206,7 +1188,7 @@ maybe_clone_body (fn)\n \t    {\n \t      tree in_charge;\n \t      in_charge = in_charge_arg_for_name (DECL_NAME (clone));\n-\t      splay_tree_insert (id.decl_map,\n+\t      splay_tree_insert (decl_map,\n \t\t\t\t (splay_tree_key) parm,\n \t\t\t\t (splay_tree_value) in_charge);\n \t    }\n@@ -1219,15 +1201,15 @@ maybe_clone_body (fn)\n \t      if (DECL_HAS_VTT_PARM_P (clone))\n \t\t{\n \t\t  DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n-\t\t  splay_tree_insert (id.decl_map,\n+\t\t  splay_tree_insert (decl_map,\n \t\t\t\t     (splay_tree_key) parm,\n \t\t\t\t     (splay_tree_value) clone_parm);\n \t\t  clone_parm = TREE_CHAIN (clone_parm);\n \t\t}\n \t      /* Otherwise, map the VTT parameter to `NULL'.  */\n \t      else\n \t\t{\n-\t\t  splay_tree_insert (id.decl_map,\n+\t\t  splay_tree_insert (decl_map,\n \t\t\t\t     (splay_tree_key) parm,\n \t\t\t\t     (splay_tree_value) null_pointer_node);\n \t\t}\n@@ -1236,23 +1218,22 @@ maybe_clone_body (fn)\n \t     function.  */\n \t  else\n \t    {\n-\t      splay_tree_insert (id.decl_map,\n+\t      splay_tree_insert (decl_map,\n \t\t\t\t (splay_tree_key) parm,\n \t\t\t\t (splay_tree_value) clone_parm);\n \t      clone_parm = TREE_CHAIN (clone_parm);\n \t    }\n \t}\n \n-      /* Actually copy the body.  */\n-      TREE_CHAIN (DECL_SAVED_TREE (clone)) = copy_body (&id);\n+      /* Clone the body.  */\n+      clone_body (clone, fn, decl_map);\n \n       /* There are as many statements in the clone as in the\n \t original.  */\n       DECL_NUM_STMTS (clone) = DECL_NUM_STMTS (fn);\n \n       /* Clean up.  */\n-      splay_tree_delete (id.decl_map);\n-      VARRAY_FREE (id.fns);\n+      splay_tree_delete (decl_map);\n \n       /* Now, expand this function into RTL, if appropriate.  */\n       finish_function (0);"}, {"sha": "e29a738d361491e61e60eea7353219eb9b8375ee", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -29,10 +29,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"obstack.h\"\n-\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"cp-tree.h\"\n+#include \"tree-inline.h\"\n #include \"decl.h\"\n #include \"parse.h\"\n #include \"lex.h\""}, {"sha": "ec7b968f0462dde2155352e6d2f8f8bcd6636cdd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -28,6 +28,7 @@\n #include \"system.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n+#include \"tree-inline.h\"\n #include \"except.h\"\n #include \"lex.h\"\n #include \"toplev.h\""}, {"sha": "ec51eaa7e4157a193db939904a42f35ecb5fe1d2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 239, "deletions": 32, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25af8512559873d4b6e67d27a07f504a585b6037/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=25af8512559873d4b6e67d27a07f504a585b6037", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"insn-config.h\"\n #include \"integrate.h\"\n+#include \"tree-inline.h\"\n \n static tree bot_manip PARAMS ((tree *, int *, void *));\n static tree bot_replace PARAMS ((tree *, int *, void *));\n@@ -49,6 +50,12 @@ static tree count_trees_r PARAMS ((tree *, int *, void *));\n static tree verify_stmt_tree_r PARAMS ((tree *, int *, void *));\n static tree find_tree_r PARAMS ((tree *, int *, void *));\n extern int cp_statement_code_p PARAMS ((enum tree_code));\n+static treeopt_walk_subtrees_type cp_walk_subtrees;\n+static treeopt_cannot_inline_tree_fn_type cp_cannot_inline_tree_fn;\n+static treeopt_add_pending_fn_decls_type cp_add_pending_fn_decls;\n+static treeopt_tree_chain_matters_p_type cp_is_overload_p;\n+static treeopt_auto_var_in_fn_p_type cp_auto_var_in_fn_p;\n+static treeopt_copy_res_decl_for_inlining_type cp_copy_res_decl_for_inlining;\n \n static tree handle_java_interface_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree handle_com_interface_attribute PARAMS ((tree *, tree, tree, int, bool *));\n@@ -1154,12 +1161,13 @@ bind_template_template_parm (t, newargs)\n    once.  */\n \n tree \n-walk_tree (tp, func, data, htab)\n+walk_tree (tp, func, data, htab_)\n      tree *tp;\n      walk_tree_fn func;\n      void *data;\n-     htab_t htab;\n+     void *htab_;\n {\n+  htab_t htab = (htab_t) htab_;\n   enum tree_code code;\n   int walk_subtrees;\n   tree result;\n@@ -1204,7 +1212,8 @@ walk_tree (tp, func, data, htab)\n      interesting below this point in the tree.  */\n   if (!walk_subtrees)\n     {\n-      if (statement_code_p (code) || code == TREE_LIST || code == OVERLOAD)\n+      if (statement_code_p (code) || code == TREE_LIST\n+\t  || LANG_TREE_CHAIN_MATTERS_P (*tp))\n \t/* But we still need to check our siblings.  */\n \treturn walk_tree (&TREE_CHAIN (*tp), func, data, htab);\n       else\n@@ -1268,6 +1277,10 @@ walk_tree (tp, func, data, htab)\n       return NULL_TREE;\n     }\n \n+  result = LANG_WALK_SUBTREES (tp, &walk_subtrees, func, data, htab);\n+  if (result || ! walk_subtrees)\n+    return result;\n+\n   /* Not one of the easy cases.  We must explicitly go through the\n      children.  */\n   switch (code)\n@@ -1277,47 +1290,29 @@ walk_tree (tp, func, data, htab)\n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n-    case DEFAULT_ARG:\n-    case TEMPLATE_TEMPLATE_PARM:\n-    case BOUND_TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_PARM_INDEX:\n-    case TEMPLATE_TYPE_PARM:\n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n     case VOID_TYPE:\n     case BOOLEAN_TYPE:\n-    case TYPENAME_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-    case TYPEOF_TYPE:\n     case BLOCK:\n+    case RECORD_TYPE:\n       /* None of thse have subtrees other than those already walked\n          above.  */\n       break;\n \n-    case PTRMEM_CST:\n-      WALK_SUBTREE (TREE_TYPE (*tp));\n-      break;\n-\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       WALK_SUBTREE (TREE_TYPE (*tp));\n       break;\n \n     case TREE_LIST:\n-      /* A BASELINK_P's TREE_PURPOSE is a BINFO, and hence circular.  */\n-      if (!BASELINK_P (*tp))\n-        WALK_SUBTREE (TREE_PURPOSE (*tp));\n       WALK_SUBTREE (TREE_VALUE (*tp));\n       WALK_SUBTREE (TREE_CHAIN (*tp));\n       break;\n \n-    case OVERLOAD:\n-      WALK_SUBTREE (OVL_FUNCTION (*tp));\n-      WALK_SUBTREE (OVL_CHAIN (*tp));\n-      break;\n-\n     case TREE_VEC:\n       {\n \tint len = TREE_VEC_LENGTH (*tp);\n@@ -1365,13 +1360,8 @@ walk_tree (tp, func, data, htab)\n       WALK_SUBTREE (TYPE_OFFSET_BASETYPE (*tp));\n       break;\n \n-    case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (*tp))\n-\tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE (*tp));\n-      break;\n-\n     default:\n-      my_friendly_abort (19990803);\n+      abort ();\n     }\n \n   /* We didn't find what we were looking for.  */\n@@ -1539,7 +1529,7 @@ copy_tree_r (tp, walk_subtrees, data)\n       || TREE_CODE_CLASS (code) == 's'\n       || code == TREE_LIST\n       || code == TREE_VEC\n-      || code == OVERLOAD)\n+      || LANG_TREE_CHAIN_MATTERS_P (*tp))\n     {\n       /* Because the chain gets clobbered when we make a copy, we save it\n \t here.  */\n@@ -1550,7 +1540,8 @@ copy_tree_r (tp, walk_subtrees, data)\n \n       /* Now, restore the chain, if appropriate.  That will cause\n \t walk_tree to walk into the chain as well.  */\n-      if (code == PARM_DECL || code == TREE_LIST || code == OVERLOAD\n+      if (code == PARM_DECL || code == TREE_LIST\n+\t  || LANG_TREE_CHAIN_MATTERS_P (*tp)\n \t  || statement_code_p (code))\n \tTREE_CHAIN (*tp) = chain;\n \n@@ -2344,12 +2335,227 @@ make_ptrmem_cst (type, member)\n   return ptrmem_cst;\n }\n \n+/* Apply FUNC to all language-specific sub-trees of TP in a pre-order\n+   traversal.  Called from walk_tree().  */\n+\n+static tree \n+cp_walk_subtrees (tp, walk_subtrees_p, func, data, htab)\n+     tree *tp;\n+     int *walk_subtrees_p;\n+     walk_tree_fn func;\n+     void *data;\n+     void *htab;\n+{\n+  enum tree_code code = TREE_CODE (*tp);\n+  tree result;\n+  \n+#define WALK_SUBTREE(NODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result = walk_tree (&(NODE), func, data, htab);\t\\\n+      if (result)\t\t\t\t\t\\\n+\treturn result;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+  /* Not one of the easy cases.  We must explicitly go through the\n+     children.  */\n+  switch (code)\n+    {\n+    case DEFAULT_ARG:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+    case TEMPLATE_TYPE_PARM:\n+    case TYPENAME_TYPE:\n+    case TYPEOF_TYPE:\n+      /* None of thse have subtrees other than those already walked\n+         above.  */\n+      *walk_subtrees_p = 0;\n+      break;\n+\n+    case PTRMEM_CST:\n+      WALK_SUBTREE (TREE_TYPE (*tp));\n+      *walk_subtrees_p = 0;\n+      break;\n+\n+    case TREE_LIST:\n+      /* A BASELINK_P's TREE_PURPOSE is a BINFO, and hence circular.  */\n+      if (!BASELINK_P (*tp))\n+        WALK_SUBTREE (TREE_PURPOSE (*tp));\n+      break;\n+\n+    case OVERLOAD:\n+      WALK_SUBTREE (OVL_FUNCTION (*tp));\n+      WALK_SUBTREE (OVL_CHAIN (*tp));\n+      *walk_subtrees_p = 0;\n+      break;\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (*tp))\n+\tWALK_SUBTREE (TYPE_PTRMEMFUNC_FN_TYPE (*tp));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* We didn't find what we were looking for.  */\n+  return NULL_TREE;\n+\n+#undef WALK_SUBTREE\n+}\n+\n+/* Decide whether there are language-specific reasons to not inline a\n+   function as a tree.  */\n+\n+static int\n+cp_cannot_inline_tree_fn (fnp)\n+     tree *fnp;\n+{\n+  tree fn = *fnp;\n+\n+  /* We can inline a template instantiation only if it's fully\n+     instantiated.  */\n+  if (DECL_TEMPLATE_INFO (fn)\n+      && TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (fn)))\n+    {\n+      fn = *fnp = instantiate_decl (fn, /*defer_ok=*/0);\n+      return TI_PENDING_TEMPLATE_FLAG (DECL_TEMPLATE_INFO (fn));\n+    }\n+\n+  if (varargs_function_p (fn))\n+    {\n+      DECL_UNINLINABLE (fn) = 1;\n+      return 1;\n+    }\n+\n+  if (! function_attribute_inlinable_p (fn))\n+    {\n+      DECL_UNINLINABLE (fn) = 1;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Add any pending functions other than the current function (already\n+   handled by the caller), that thus cannot be inlined, to FNS_P, then\n+   return the latest function added to the array, PREV_FN.  */\n+\n+static tree\n+cp_add_pending_fn_decls (fns_p, prev_fn)\n+     void *fns_p;\n+     tree prev_fn;\n+{\n+  varray_type *fnsp = (varray_type *)fns_p;\n+  struct saved_scope *s;\n+\n+  for (s = scope_chain; s; s = s->prev)\n+    if (s->function_decl && s->function_decl != prev_fn)\n+      {\n+\tVARRAY_PUSH_TREE (*fnsp, s->function_decl);\n+\tprev_fn = s->function_decl;\n+      }\n+\n+  return prev_fn;\n+}\n+\n+/* Determine whether a tree node is an OVERLOAD node.  Used to decide\n+   whether to copy a node or to preserve its chain when inlining a\n+   function.  */\n+\n+static int\n+cp_is_overload_p (t)\n+     tree t;\n+{\n+  return TREE_CODE (t) == OVERLOAD;\n+}\n+\n+/* Determine whether VAR is a declaration of an automatic variable in\n+   function FN.  */\n+\n+static int\n+cp_auto_var_in_fn_p (var, fn)\n+     tree var, fn;\n+{\n+  return (DECL_P (var) && DECL_CONTEXT (var) == fn\n+\t  && nonstatic_local_decl_p (var));\n+}\n+\n+/* Tell whether a declaration is needed for the RESULT of a function\n+   FN being inlined into CALLER or if the top node of target_exprs is\n+   to be used.  */\n+\n+static tree\n+cp_copy_res_decl_for_inlining (result, fn, caller, decl_map_,\n+\t\t\t       need_decl, target_exprs)\n+     tree result, fn, caller;\n+     void *decl_map_;\n+     int *need_decl;\n+     void *target_exprs;\n+{\n+  splay_tree decl_map = (splay_tree)decl_map_;\n+  varray_type *texps = (varray_type *)target_exprs;\n+  tree var;\n+  int aggregate_return_p;\n+\n+  /* Figure out whether or not FN returns an aggregate.  */\n+  aggregate_return_p = IS_AGGR_TYPE (TREE_TYPE (result));\n+  *need_decl = ! aggregate_return_p;\n+\n+  /* If FN returns an aggregate then the caller will always create the\n+     temporary (using a TARGET_EXPR) and the call will be the\n+     initializing expression for the TARGET_EXPR.  If we were just to\n+     create a new VAR_DECL here, then the result of this function\n+     would be copied (bitwise) into the variable initialized by the\n+     TARGET_EXPR.  That's incorrect, so we must transform any\n+     references to the RESULT into references to the target.  */\n+  if (aggregate_return_p)\n+    {\n+      if (VARRAY_ACTIVE_SIZE (*texps) == 0)\n+\tabort ();\n+      var = TREE_OPERAND (VARRAY_TOP_TREE (*texps), 0);\n+      if (! same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (var),\n+\t\t\t\t\t\t       TREE_TYPE (result)))\n+\tabort ();\n+    }\n+  /* Otherwise, make an appropriate copy.  */\n+  else\n+    var = copy_decl_for_inlining (result, fn, caller);\n+\n+  if (DECL_SAVED_FUNCTION_DATA (fn))\n+    {\n+      tree nrv = DECL_SAVED_FUNCTION_DATA (fn)->x_return_value;\n+      if (nrv)\n+\t{\n+\t  /* We have a named return value; copy the name and source\n+\t     position so we can get reasonable debugging information, and\n+\t     register the return variable as its equivalent.  */\n+\t  DECL_NAME (var) = DECL_NAME (nrv);\n+\t  DECL_SOURCE_FILE (var) = DECL_SOURCE_FILE (nrv);\n+\t  DECL_SOURCE_LINE (var) = DECL_SOURCE_LINE (nrv);\n+\t  splay_tree_insert (decl_map,\n+\t\t\t     (splay_tree_key) nrv,\n+\t\t\t     (splay_tree_value) var);\n+\t}\n+    }\n+\n+  return var;\n+}\n+\n /* Initialize tree.c.  */\n \n void\n init_tree ()\n {\n   make_lang_type_fn = cp_make_lang_type;\n+  lang_walk_subtrees = cp_walk_subtrees;\n+  lang_cannot_inline_tree_fn = cp_cannot_inline_tree_fn;\n+  lang_add_pending_fn_decls = cp_add_pending_fn_decls;\n+  lang_tree_chain_matters_p = cp_is_overload_p;\n+  lang_auto_var_in_fn_p = cp_auto_var_in_fn_p;\n+  lang_copy_res_decl_for_inlining = cp_copy_res_decl_for_inlining;\n   lang_unsave = cp_unsave;\n   lang_statement_code_p = cp_statement_code_p;\n   lang_set_decl_assembler_name = mangle_decl;\n@@ -2365,12 +2571,13 @@ init_tree ()\n    ST.  FN is the function into which the copy will be placed.  */\n \n void\n-remap_save_expr (tp, st, fn, walk_subtrees)\n+remap_save_expr (tp, st_, fn, walk_subtrees)\n      tree *tp;\n-     splay_tree st;\n+     void *st_;\n      tree fn;\n      int *walk_subtrees;\n {\n+  splay_tree st = (splay_tree) st_;\n   splay_tree_node n;\n \n   /* See if we already encountered this SAVE_EXPR.  */"}]}