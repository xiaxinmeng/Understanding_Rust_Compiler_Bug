{"sha": "f30990b2eefb22de76b53184f33cf87ef0a59425", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMwOTkwYjJlZWZiMjJkZTc2YjUzMTg0ZjMzY2Y4N2VmMGE1OTQyNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-05-10T22:40:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-05-10T22:40:37Z"}, "message": "read-rtl.c (struct macro_traverse_data): Define.\n\n\t* read-rtl.c (struct macro_traverse_data): Define.\n\t(map_attr_string): New static function, broken out of\n\tapply_macro_to_string.\n\t(mode_attr_index, apply_mode_maps): New static functions.\n\t(apply_macro_to_string): Call map_attr_string.\n\t(apply_macro_to_rtx): Add mode_maps and infile parameters.  Change\n\tall callers.\n\t(apply_macro_traverse): Expect data to point to a struct\n\tmacro_traverse_data.\n\t(read_rtx): Add mode_maps local variable.  Use mode_traverse_data\n\tto pass data through htab_traverse.\n\t(read_rtx_1): Add mode_maps parameter.  Change all callers.\n\tHandle mode names which are attribute strings.\n\t* doc/md.texi (Substitutions): Rename from String Substitutions.\n\tChange references.  Document using attributes as modes.\n\nFrom-SVN: r99548", "tree": {"sha": "3c192eb398beefd572075f215cd4eb5cbfb5515b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c192eb398beefd572075f215cd4eb5cbfb5515b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f30990b2eefb22de76b53184f33cf87ef0a59425", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30990b2eefb22de76b53184f33cf87ef0a59425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f30990b2eefb22de76b53184f33cf87ef0a59425", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f30990b2eefb22de76b53184f33cf87ef0a59425/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5deaef19e6360dc228e4b11cac2070fabdb036f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5deaef19e6360dc228e4b11cac2070fabdb036f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5deaef19e6360dc228e4b11cac2070fabdb036f4"}], "stats": {"total": 253, "additions": 204, "deletions": 49}, "files": [{"sha": "8a1827fc99dd1dbb6ba69a206215d923f6457fce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30990b2eefb22de76b53184f33cf87ef0a59425/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30990b2eefb22de76b53184f33cf87ef0a59425/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f30990b2eefb22de76b53184f33cf87ef0a59425", "patch": "@@ -1,3 +1,21 @@\n+2005-05-10  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* read-rtl.c (struct macro_traverse_data): Define.\n+\t(map_attr_string): New static function, broken out of\n+\tapply_macro_to_string.\n+\t(mode_attr_index, apply_mode_maps): New static functions.\n+\t(apply_macro_to_string): Call map_attr_string.\n+\t(apply_macro_to_rtx): Add mode_maps and infile parameters.  Change\n+\tall callers.\n+\t(apply_macro_traverse): Expect data to point to a struct\n+\tmacro_traverse_data.\n+\t(read_rtx): Add mode_maps local variable.  Use mode_traverse_data\n+\tto pass data through htab_traverse.\n+\t(read_rtx_1): Add mode_maps parameter.  Change all callers.\n+\tHandle mode names which are attribute strings.\n+\t* doc/md.texi (Substitutions): Rename from String Substitutions.\n+\tChange references.  Document using attributes as modes.\n+\n 2005-05-10  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-cfg.c (tree_duplicate_sese_region): Update profile."}, {"sha": "4feab32698e94f47f4ef787b9b5987aaf9f4bdcd", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30990b2eefb22de76b53184f33cf87ef0a59425/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30990b2eefb22de76b53184f33cf87ef0a59425/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f30990b2eefb22de76b53184f33cf87ef0a59425", "patch": "@@ -6718,7 +6718,7 @@ rtx-based construct, such as a @code{define_insn},\n \n @menu\n * Defining Mode Macros:: Defining a new mode macro.\n-* String Substitutions:: Combining mode macros with string substitutions\n+* Substitutions::\t Combining mode macros with substitutions\n * Examples::             Examples\n @end menu\n \n@@ -6764,14 +6764,15 @@ but that the @code{:SI} expansion has no such constraint.\n \n Macros are applied in the order they are defined.  This can be\n significant if two macros are used in a construct that requires\n-string substitutions.  @xref{String Substitutions}.\n+substitutions.  @xref{Substitutions}.\n \n-@node String Substitutions\n-@subsubsection String Substitution in Mode Macros\n+@node Substitutions\n+@subsubsection Substitution in Mode Macros\n @findex define_mode_attr\n \n If an @file{.md} file construct uses mode macros, each version of the\n-construct will often need slightly different strings.  For example:\n+construct will often need slightly different strings or modes.  For\n+example:\n \n @itemize @bullet\n @item\n@@ -6782,6 +6783,11 @@ appropriate mode name for @var{m}.\n @item\n When a @code{define_insn} defines several instruction patterns,\n each instruction will often use a different assembler mnemonic.\n+\n+@item\n+When a @code{define_insn} requires operands with different modes,\n+using a macro for one of the operand modes usually requires a specific\n+mode for the other operand(s).\n @end itemize\n \n GCC supports such variations through a system of ``mode attributes''.\n@@ -6796,12 +6802,12 @@ upper case.  You can define other attributes using:\n where @var{name} is the name of the attribute and @var{valuei}\n is the value associated with @var{modei}.\n \n-When GCC replaces some @var{:macro} with @var{:mode}, it will\n-scan each string in the pattern for sequences of the form\n-@code{<@var{macro}:@var{attr}>}, where @var{attr} is the name of\n-a mode attribute.  If the attribute is defined for @var{mode}, the\n-whole @code{<...>} sequence will be replaced by the appropriate\n-attribute value.\n+When GCC replaces some @var{:macro} with @var{:mode}, it will scan\n+each string and mode in the pattern for sequences of the form\n+@code{<@var{macro}:@var{attr}>}, where @var{attr} is the name of a\n+mode attribute.  If the attribute is defined for @var{mode}, the whole\n+@code{<...>} sequence will be replaced by the appropriate attribute\n+value.\n \n For example, suppose an @file{.md} file has:\n \n@@ -6815,6 +6821,15 @@ If one of the patterns that uses @code{:P} contains the string\n will use @code{\"lw\\t%0,%1\"} and the @code{DI} version will use\n @code{\"ld\\t%0,%1\"}.\n \n+Here is an example of using an attribute for a mode:\n+\n+@smallexample\n+(define_mode_macro LONG [SI DI])\n+(define_mode_attr SHORT [(SI \"HI\") (DI \"SI\")])\n+(define_insn ...\n+  (sign_extend:LONG (match_operand:<LONG:SHORT> ...)) ...)\n+@end smallexample\n+\n The @code{@var{macro}:} prefix may be omitted, in which case the\n substitution will be attempted for every macro expansion.\n "}, {"sha": "23db85bdc31dce66490ea21daaad6945c89549f2", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 160, "deletions": 38, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f30990b2eefb22de76b53184f33cf87ef0a59425/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f30990b2eefb22de76b53184f33cf87ef0a59425/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=f30990b2eefb22de76b53184f33cf87ef0a59425", "patch": "@@ -87,6 +87,17 @@ struct ptr_loc {\n   int lineno;\n };\n \n+/* A structure used to pass data from read_rtx to apply_macro_traverse\n+   via htab_traverse.  */\n+struct macro_traverse_data {\n+  /* Instruction queue.  */\n+  rtx queue;\n+  /* Attributes seen for modes.  */\n+  struct map_value *mode_maps;\n+  /* Input file.  */\n+  FILE *infile;\n+};\n+\n /* If CODE is the number of a code macro, return a real rtx code that\n    has the same format.  Return CODE otherwise.  */\n #define BELLWETHER_CODE(CODE) \\\n@@ -102,7 +113,8 @@ static int find_code (const char *, FILE *);\n static bool uses_code_macro_p (rtx, int);\n static void apply_code_macro (rtx, int);\n static const char *apply_macro_to_string (const char *, struct mapping *, int);\n-static rtx apply_macro_to_rtx (rtx, struct mapping *, int);\n+static rtx apply_macro_to_rtx (rtx, struct mapping *, int,\n+\t\t\t       struct map_value *, FILE *);\n static bool uses_macro_p (rtx, struct mapping *);\n static const char *add_condition_to_string (const char *, const char *);\n static void add_condition_to_rtx (rtx, const char *);\n@@ -128,7 +140,7 @@ static void validate_const_int (FILE *, const char *);\n static int find_macro (struct macro_group *, const char *, FILE *);\n static struct mapping *read_mapping (struct macro_group *, htab_t, FILE *);\n static void check_code_macro (struct mapping *, FILE *);\n-static rtx read_rtx_1 (FILE *);\n+static rtx read_rtx_1 (FILE *, struct map_value **);\n \n /* The mode and code macro structures.  */\n static struct macro_group modes, codes;\n@@ -258,15 +270,123 @@ apply_code_macro (rtx x, int code)\n   PUT_CODE (x, code);\n }\n \n+/* Map a code or mode attribute string P to the underlying string for\n+   MACRO and VALUE.  */\n+\n+static struct map_value *\n+map_attr_string (const char *p, struct mapping *macro, int value)\n+{\n+  const char *attr;\n+  struct mapping *m;\n+  struct map_value *v;\n+\n+  /* If there's a \"macro:\" prefix, check whether the macro name matches.\n+     Set ATTR to the start of the attribute name.  */\n+  attr = strchr (p, ':');\n+  if (attr == 0)\n+    attr = p;\n+  else\n+    {\n+      if (strncmp (p, macro->name, attr - p) != 0\n+\t  || macro->name[attr - p] != 0)\n+\treturn 0;\n+      attr++;\n+    }\n+\n+  /* Find the attribute specification.  */\n+  m = (struct mapping *) htab_find (macro->group->attrs, &attr);\n+  if (m == 0)\n+    return 0;\n+\n+  /* Find the attribute value for VALUE.  */\n+  for (v = m->values; v != 0; v = v->next)\n+    if (v->number == value)\n+      break;\n+\n+  return v;\n+}\n+\n+/* Given an attribute string used as a machine mode, return an index\n+   to store in the machine mode to be translated by\n+   apply_macro_to_rtx.  */\n+\n+static unsigned int\n+mode_attr_index (struct map_value **mode_maps, const char *string,\n+\t\t FILE *infile)\n+{\n+  char *p;\n+  char *attr;\n+  struct map_value *mv;\n+\n+  /* Copy the attribute string into permanent storage, without the\n+     angle brackets around it.  */\n+  obstack_grow (&string_obstack, string + 1, strlen (string) - 2);\n+  p = (char *) obstack_finish (&string_obstack);\n+\n+  /* Make sure the attribute is defined as either a code attribute or\n+     a mode attribute.  */\n+  attr = strchr (p, ':');\n+  if (attr == 0)\n+    attr = p;\n+  else\n+    ++attr;\n+\n+  if (!htab_find (modes.attrs, &attr) && !htab_find (codes.attrs, &attr))\n+    fatal_with_file_and_line (infile,\n+\t\t\t      \"undefined attribute '%s' used for mode\",\n+\t\t\t      p);\n+\n+  mv = XNEW (struct map_value);\n+  mv->number = *mode_maps == 0 ? 0 : (*mode_maps)->number + 1;\n+  mv->string = p;\n+  mv->next = *mode_maps;\n+  *mode_maps = mv;\n+\n+  /* We return a code which we can map back into this string: the\n+     number of machine modes + the number of mode macros + the index\n+     we just used.  */\n+  return MAX_MACHINE_MODE + htab_elements (modes.macros) + mv->number;\n+}\n+\n+/* Apply MODE_MAPS to the top level of X.  */\n+\n+static void\n+apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *macro,\n+\t\t int value, FILE *infile)\n+{\n+  unsigned int offset;\n+  int indx;\n+  struct map_value *pm;\n+\n+  offset = MAX_MACHINE_MODE + htab_elements (modes.macros);\n+  if (GET_MODE (x) < offset)\n+    return;\n+\n+  indx = GET_MODE (x) - offset;\n+  for (pm = mode_maps; pm; pm = pm->next)\n+    {\n+      if (pm->number == indx)\n+\t{\n+\t  struct map_value *v;\n+\n+\t  v = map_attr_string (pm->string, macro, value);\n+\t  if (v)\n+\t    {\n+\t      PUT_MODE (x, find_mode (v->string, infile));\n+\t      return;\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Given that MACRO is being expanded as VALUE, apply the appropriate\n    string substitutions to STRING.  Return the new string if any changes\n    were needed, otherwise return STRING itself.  */\n \n static const char *\n apply_macro_to_string (const char *string, struct mapping *macro, int value)\n {\n-  char *base, *copy, *p, *attr, *start, *end;\n-  struct mapping *m;\n+  char *base, *copy, *p, *start, *end;\n   struct map_value *v;\n \n   if (string == 0)\n@@ -277,30 +397,9 @@ apply_macro_to_string (const char *string, struct mapping *macro, int value)\n     {\n       p = start + 1;\n \n-      /* If there's a \"macro:\" prefix, check whether the macro name matches.\n-\t Set ATTR to the start of the attribute name.  */\n-      attr = strchr (p, ':');\n-      if (attr == 0 || attr > end)\n-\tattr = p;\n-      else\n-\t{\n-\t  if (strncmp (p, macro->name, attr - p) != 0\n-\t      || macro->name[attr - p] != 0)\n-\t    continue;\n-\t  attr++;\n-\t}\n-\n-      /* Find the attribute specification.  */\n       *end = 0;\n-      m = (struct mapping *) htab_find (macro->group->attrs, &attr);\n+      v = map_attr_string (p, macro, value);\n       *end = '>';\n-      if (m == 0)\n-\tcontinue;\n-\n-      /* Find the attribute value for VALUE.  */\n-      for (v = m->values; v != 0; v = v->next)\n-\tif (v->number == value)\n-\t  break;\n       if (v == 0)\n \tcontinue;\n \n@@ -324,7 +423,8 @@ apply_macro_to_string (const char *string, struct mapping *macro, int value)\n    replaced by VALUE.  */\n \n static rtx\n-apply_macro_to_rtx (rtx original, struct mapping *macro, int value)\n+apply_macro_to_rtx (rtx original, struct mapping *macro, int value,\n+\t\t    struct map_value *mode_maps, FILE *infile)\n {\n   struct macro_group *group;\n   const char *format_ptr;\n@@ -345,6 +445,9 @@ apply_macro_to_rtx (rtx original, struct mapping *macro, int value)\n   if (group->uses_macro_p (x, macro->index + group->num_builtins))\n     group->apply_macro (x, value);\n \n+  if (mode_maps)\n+    apply_mode_maps (x, mode_maps, macro, value, infile);\n+\n   /* Change each string and recursively change each rtx.  */\n   format_ptr = GET_RTX_FORMAT (bellwether_code);\n   for (i = 0; format_ptr[i] != 0; i++)\n@@ -360,7 +463,8 @@ apply_macro_to_rtx (rtx original, struct mapping *macro, int value)\n \tbreak;\n \n       case 'e':\n-\tXEXP (x, i) = apply_macro_to_rtx (XEXP (x, i), macro, value);\n+\tXEXP (x, i) = apply_macro_to_rtx (XEXP (x, i), macro, value,\n+\t\t\t\t\t  mode_maps, infile);\n \tbreak;\n \n       case 'V':\n@@ -370,7 +474,8 @@ apply_macro_to_rtx (rtx original, struct mapping *macro, int value)\n \t    XVEC (x, i) = rtvec_alloc (XVECLEN (original, i));\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      XVECEXP (x, i, j) = apply_macro_to_rtx (XVECEXP (original, i, j),\n-\t\t\t\t\t\t      macro, value);\n+\t\t\t\t\t\t      macro, value, mode_maps,\n+\t\t\t\t\t\t      infile);\n \t  }\n \tbreak;\n \n@@ -467,18 +572,20 @@ add_condition_to_rtx (rtx x, const char *extra)\n static int\n apply_macro_traverse (void **slot, void *data)\n {\n+  struct macro_traverse_data *mtd = (struct macro_traverse_data *) data;\n   struct mapping *macro;\n   struct map_value *v;\n   rtx elem, new_elem, original, x;\n \n   macro = (struct mapping *) *slot;\n-  for (elem = (rtx) data; elem != 0; elem = XEXP (elem, 1))\n+  for (elem = mtd->queue; elem != 0; elem = XEXP (elem, 1))\n     if (uses_macro_p (XEXP (elem, 0), macro))\n       {\n \toriginal = XEXP (elem, 0);\n \tfor (v = macro->values; v != 0; v = v->next)\n \t  {\n-\t    x = apply_macro_to_rtx (original, macro, v->number);\n+\t    x = apply_macro_to_rtx (original, macro, v->number,\n+\t\t\t\t    mtd->mode_maps, mtd->infile);\n \t    add_condition_to_rtx (x, v->string);\n \t    if (v != macro->values)\n \t      {\n@@ -1238,18 +1345,25 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n \n   if (queue_next == 0)\n     {\n+      struct map_value *mode_maps;\n+      struct macro_traverse_data mtd;\n+\n       c = read_skip_spaces (infile);\n       if (c == EOF)\n \treturn false;\n       ungetc (c, infile);\n \n       queue_next = queue_head;\n       queue_lineno = read_rtx_lineno;\n-      XEXP (queue_next, 0) = read_rtx_1 (infile);\n+      mode_maps = 0;\n+      XEXP (queue_next, 0) = read_rtx_1 (infile, &mode_maps);\n       XEXP (queue_next, 1) = 0;\n \n-      htab_traverse (modes.macros, apply_macro_traverse, queue_next);\n-      htab_traverse (codes.macros, apply_macro_traverse, queue_next);\n+      mtd.queue = queue_next;\n+      mtd.mode_maps = mode_maps;\n+      mtd.infile = infile;\n+      htab_traverse (modes.macros, apply_macro_traverse, &mtd);\n+      htab_traverse (codes.macros, apply_macro_traverse, &mtd);\n     }\n \n   *x = XEXP (queue_next, 0);\n@@ -1263,7 +1377,7 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n    doesn't apply any macros.  */\n \n static rtx\n-read_rtx_1 (FILE *infile)\n+read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n {\n   int i;\n   RTX_CODE real_code, bellwether_code;\n@@ -1337,8 +1451,16 @@ read_rtx_1 (FILE *infile)\n   i = read_skip_spaces (infile);\n   if (i == ':')\n     {\n+      unsigned int mode;\n+\n       read_name (tmp_char, infile);\n-      PUT_MODE (return_rtx, find_macro (&modes, tmp_char, infile));\n+      if (tmp_char[0] != '<' || tmp_char[strlen (tmp_char) - 1] != '>')\n+\tmode = find_macro (&modes, tmp_char, infile);\n+      else\n+\tmode = mode_attr_index (mode_maps, tmp_char, infile);\n+      PUT_MODE (return_rtx, mode);\n+      if (GET_MODE (return_rtx) != mode)\n+\tfatal_with_file_and_line (infile, \"mode too large\");\n     }\n   else\n     ungetc (i, infile);\n@@ -1353,7 +1475,7 @@ read_rtx_1 (FILE *infile)\n \n       case 'e':\n       case 'u':\n-\tXEXP (return_rtx, i) = read_rtx_1 (infile);\n+\tXEXP (return_rtx, i) = read_rtx_1 (infile, mode_maps);\n \tbreak;\n \n       case 'V':\n@@ -1385,7 +1507,7 @@ read_rtx_1 (FILE *infile)\n \t    {\n \t      ungetc (c, infile);\n \t      list_counter++;\n-\t      obstack_ptr_grow (&vector_stack, read_rtx_1 (infile));\n+\t      obstack_ptr_grow (&vector_stack, read_rtx_1 (infile, mode_maps));\n \t    }\n \t  if (list_counter > 0)\n \t    {"}]}