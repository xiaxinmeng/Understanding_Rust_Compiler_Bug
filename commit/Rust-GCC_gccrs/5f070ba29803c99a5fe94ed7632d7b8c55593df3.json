{"sha": "5f070ba29803c99a5fe94ed7632d7b8c55593df3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYwNzBiYTI5ODAzYzk5YTVmZTk0ZWQ3NjMyZDdiOGM1NTU5M2RmMw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-03-26T18:39:49Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-03-26T19:12:12Z"}, "message": "libstdc++: Add PRNG fallback to std::random_device\n\nThis makes std::random_device usable on VxWorks when running on older\nx86 hardware. Since the r10-728 fix for PR libstdc++/85494 the library\nwill use the new code unconditionally on x86, but the cpuid checks for\nRDSEED and RDRAND can fail at runtime, depending on the hardware where\nthe code is executing. If the OS does not provide /dev/urandom then this\nmeans the std::random_device constructor always fails. In previous\nreleases if /dev/urandom is unavailable then std::mt19937 was used\nunconditionally.\n\nThis patch adds a fallback for the case where the runtime cpuid checks\nfor x86 hardware instructions fail, and no /dev/urandom is available.\nWhen this happens a std::linear_congruential_engine object will be used,\nwith a seed based on hashing the engine's address and the current time.\nDistinct std::random_device objects will use different seeds, unless an\nobject is created and destroyed and a new object created at the same\nmemory location within the clock tick. This is not great, but is better\nthan always throwing from the constructor, and better than always using\nstd::mt19937 with the same seed (as GCC 9 and earlier do).\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++11/random.cc (USE_LCG): Define when a pseudo-random\n\tfallback is needed.\n\t[USE_LCG] (bad_seed, construct_lcg_at, destroy_lcg_at, __lcg):\n\tNew helper functions and callback.\n\t(random_device::_M_init): Add 'prng' and 'all' enumerators.\n\tReplace switch with fallthrough with a series of 'if' statements.\n\t[USE_LCG]: Construct an lcg_type engine and use __lcg when cpuid\n\tchecks fail.\n\t(random_device::_M_init_pretr1) [USE_MT19937]: Accept \"prng\"\n\ttoken.\n\t(random_device::_M_getval): Check for callback unconditionally\n\tand always pass _M_file pointer.\n\t* testsuite/26_numerics/random/random_device/85494.cc: Remove\n\teffective-target check. Use new random_device_available helper.\n\t* testsuite/26_numerics/random/random_device/94087.cc: Likewise.\n\t* testsuite/26_numerics/random/random_device/cons/default-cow.cc:\n\tRemove effective-target check.\n\t* testsuite/26_numerics/random/random_device/cons/default.cc:\n\tLikewise.\n\t* testsuite/26_numerics/random/random_device/cons/token.cc: Use\n\tnew random_device_available helper. Test \"prng\" token.\n\t* testsuite/util/testsuite_random.h (random_device_available):\n\tNew helper function.", "tree": {"sha": "bb20e6206dec86fe9df7b07dc55366f3f7c36044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb20e6206dec86fe9df7b07dc55366f3f7c36044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f070ba29803c99a5fe94ed7632d7b8c55593df3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f070ba29803c99a5fe94ed7632d7b8c55593df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f070ba29803c99a5fe94ed7632d7b8c55593df3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f070ba29803c99a5fe94ed7632d7b8c55593df3/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d82797420c2238e31a7a25fe6db6bd05cd37224d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82797420c2238e31a7a25fe6db6bd05cd37224d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d82797420c2238e31a7a25fe6db6bd05cd37224d"}], "stats": {"total": 317, "additions": 189, "deletions": 128}, "files": [{"sha": "44b9f30e4a9930bfb6c25b114a98bd558f939c99", "filename": "libstdc++-v3/src/c++11/random.cc", "status": "modified", "additions": 158, "deletions": 94, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Frandom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Frandom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Frandom.cc?ref=5f070ba29803c99a5fe94ed7632d7b8c55593df3", "patch": "@@ -66,14 +66,23 @@\n # include <stdlib.h>\n #endif\n \n-#if defined USE_RDRAND || defined USE_RDSEED \\\n-  || defined _GLIBCXX_USE_CRT_RAND_S || defined _GLIBCXX_USE_DEV_RANDOM\n+#if defined _GLIBCXX_USE_CRT_RAND_S || defined _GLIBCXX_USE_DEV_RANDOM\n+// The OS provides a source of randomness we can use.\n # pragma GCC poison _M_mt\n+#elif defined USE_RDRAND || defined USE_RDSEED\n+// Hardware instructions might be available, but use cpuid checks at runtime.\n+# pragma GCC poison _M_mt\n+// If the runtime cpuid checks fail we'll use a linear congruential engine.\n+# define USE_LCG 1\n #else\n // Use the mt19937 member of the union, as in previous GCC releases.\n # define USE_MT19937 1\n #endif\n \n+#ifdef USE_LCG\n+# include <chrono>\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n   namespace\n@@ -136,6 +145,53 @@ namespace std _GLIBCXX_VISIBILITY(default)\n       return val;\n     }\n #endif\n+\n+#ifdef USE_LCG\n+    // TODO: use this to seed std::mt19937 engine too.\n+    unsigned\n+    bad_seed(void* p) noexcept\n+    {\n+      // Poor quality seed based on hash of the current time and the address\n+      // of the object being seeded. Better than using the same default seed\n+      // for every object though.\n+      const uint64_t bits[] = {\n+\t(uint64_t) chrono::system_clock::now().time_since_epoch().count(),\n+\t(uint64_t) reinterpret_cast<uintptr_t>(p)\n+      };\n+      auto bytes = reinterpret_cast<const unsigned char*>(bits);\n+      // 32-bit FNV-1a hash\n+      uint32_t h = 2166136261u;\n+      for (unsigned i = 0; i < sizeof(bits); ++i)\n+\t{\n+\t  h ^= *bytes++;\n+\t  h *= 16777619u;\n+\t}\n+      return h;\n+    }\n+\n+    // Same as std::minstd_rand0 but using unsigned not uint_fast32_t.\n+    using lcg_type\n+      = linear_congruential_engine<unsigned, 16807UL, 0UL, 2147483647UL>;\n+\n+    inline lcg_type*\n+    construct_lcg_at(void* addr) noexcept\n+    {\n+      return ::new(addr) lcg_type(bad_seed(addr));\n+    }\n+\n+    inline void\n+    destroy_lcg_at(void* addr) noexcept\n+    {\n+      static_cast<lcg_type*>(addr)->~lcg_type();\n+    }\n+\n+    unsigned int\n+    __lcg(void* ptr) noexcept\n+    {\n+      auto& lcg = *static_cast<lcg_type*>(ptr);\n+      return lcg();\n+    }\n+#endif\n   }\n \n   void\n@@ -152,25 +208,16 @@ namespace std _GLIBCXX_VISIBILITY(default)\n     _M_fd = -1;\n \n     const char* fname [[gnu::unused]] = nullptr;\n-    bool default_token [[gnu::unused]] = false;\n \n-    enum { rand_s, rdseed, rdrand, device_file } which;\n+    enum {\n+\trand_s = 1, rdseed = 2, rdrand = 4, device_file = 8, prng = 16,\n+\tany = 0xffff\n+    } which;\n \n     if (token == \"default\")\n       {\n-\tdefault_token = true;\n+\twhich = any;\n \tfname = \"/dev/urandom\";\n-#if defined _GLIBCXX_USE_CRT_RAND_S\n-\twhich = rand_s;\n-#elif defined USE_RDSEED\n-\twhich = rdseed;\n-#elif defined USE_RDRAND\n-\twhich = rdrand;\n-#elif defined _GLIBCXX_USE_DEV_RANDOM\n-\twhich = device_file;\n-#else\n-# error \"either define USE_MT19937 above or set the default device here\"\n-#endif\n       }\n #ifdef USE_RDSEED\n     else if (token == \"rdseed\")\n@@ -191,99 +238,104 @@ namespace std _GLIBCXX_VISIBILITY(default)\n \twhich = device_file;\n       }\n #endif // _GLIBCXX_USE_DEV_RANDOM\n+#ifdef USE_LCG\n+    else if (token == \"prng\")\n+      which = prng;\n+#endif\n     else\n       std::__throw_runtime_error(\n \t  __N(\"random_device::random_device(const std::string&):\"\n \t      \" unsupported token\"));\n \n-    switch (which)\n-    {\n #ifdef _GLIBCXX_USE_CRT_RAND_S\n-      case rand_s:\n-      {\n-\t_M_func = &__winxp_rand_s;\n-\treturn;\n-      }\n+    if (which & rand_s)\n+    {\n+      _M_func = &__winxp_rand_s;\n+      return;\n+    }\n #endif // _GLIBCXX_USE_CRT_RAND_S\n+\n #ifdef USE_RDSEED\n-      case rdseed:\n-      {\n-\tunsigned int eax, ebx, ecx, edx;\n-\t// Check availability of cpuid and, for now at least, also the\n-\t// CPU signature for Intel and AMD.\n-\tif (__get_cpuid_max(0, &ebx) > 0\n-\t    && (ebx == signature_INTEL_ebx || ebx == signature_AMD_ebx))\n-\t  {\n-\t    // CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18]\n-\t    __cpuid_count(7, 0, eax, ebx, ecx, edx);\n-\t    if (ebx & bit_RDSEED)\n-\t      {\n+    if (which & rdseed)\n+    {\n+      unsigned int eax, ebx, ecx, edx;\n+      // Check availability of cpuid and, for now at least, also the\n+      // CPU signature for Intel and AMD.\n+      if (__get_cpuid_max(0, &ebx) > 0\n+\t  && (ebx == signature_INTEL_ebx || ebx == signature_AMD_ebx))\n+\t{\n+\t  // CPUID.(EAX=07H, ECX=0H):EBX.RDSEED[bit 18]\n+\t  __cpuid_count(7, 0, eax, ebx, ecx, edx);\n+\t  if (ebx & bit_RDSEED)\n+\t    {\n #ifdef USE_RDRAND\n-\t\t// CPUID.01H:ECX.RDRAND[bit 30]\n-\t\t__cpuid(1, eax, ebx, ecx, edx);\n-\t\tif (ecx & bit_RDRND)\n-\t\t  {\n-\t\t    _M_func = &__x86_rdseed_rdrand;\n-\t\t    return;\n-\t\t  }\n+\t      // CPUID.01H:ECX.RDRAND[bit 30]\n+\t      __cpuid(1, eax, ebx, ecx, edx);\n+\t      if (ecx & bit_RDRND)\n+\t\t{\n+\t\t  _M_func = &__x86_rdseed_rdrand;\n+\t\t  return;\n+\t\t}\n #endif\n-\t\t_M_func = &__x86_rdseed;\n-\t\treturn;\n-\t      }\n-\t  }\n-\t// If rdseed was explicitly requested then we're done here.\n-\tif (!default_token)\n-\t  break;\n-\t// Otherwise fall through to try the next available option.\n-\t[[gnu::fallthrough]];\n-      }\n+\t      _M_func = &__x86_rdseed;\n+\t      return;\n+\t    }\n+\t}\n+    }\n #endif // USE_RDSEED\n+\n #ifdef USE_RDRAND\n-      case rdrand:\n-      {\n-\tunsigned int eax, ebx, ecx, edx;\n-\t// Check availability of cpuid and, for now at least, also the\n-\t// CPU signature for Intel and AMD.\n-\tif (__get_cpuid_max(0, &ebx) > 0\n-\t    && (ebx == signature_INTEL_ebx || ebx == signature_AMD_ebx))\n-\t  {\n-\t    // CPUID.01H:ECX.RDRAND[bit 30]\n-\t    __cpuid(1, eax, ebx, ecx, edx);\n-\t    if (ecx & bit_RDRND)\n-\t      {\n-\t\t_M_func = &__x86_rdrand;\n-\t\treturn;\n-\t      }\n-\t  }\n-\t// If rdrand was explicitly requested then we're done here.\n-\tif (!default_token)\n-\t  break;\n-\t// Otherwise fall through to try the next available option.\n-\t[[gnu::fallthrough]];\n-      }\n+    if (which & rdrand)\n+    {\n+      unsigned int eax, ebx, ecx, edx;\n+      // Check availability of cpuid and, for now at least, also the\n+      // CPU signature for Intel and AMD.\n+      if (__get_cpuid_max(0, &ebx) > 0\n+\t  && (ebx == signature_INTEL_ebx || ebx == signature_AMD_ebx))\n+\t{\n+\t  // CPUID.01H:ECX.RDRAND[bit 30]\n+\t  __cpuid(1, eax, ebx, ecx, edx);\n+\t  if (ecx & bit_RDRND)\n+\t    {\n+\t      _M_func = &__x86_rdrand;\n+\t      return;\n+\t    }\n+\t}\n+    }\n #endif // USE_RDRAND\n+\n #ifdef _GLIBCXX_USE_DEV_RANDOM\n-      case device_file:\n-      {\n+    if (which & device_file)\n+    {\n #ifdef USE_POSIX_FILE_IO\n-\t_M_fd = ::open(fname, O_RDONLY);\n-\tif (_M_fd != -1)\n-\t  {\n-\t    // Set _M_file to non-null so that _M_fini() will do clean up.\n-\t    _M_file = &_M_fd;\n-\t    return;\n-\t  }\n-#else // USE_POSIX_FILE_IO\n-\t_M_file = static_cast<void*>(std::fopen(fname, \"rb\"));\n-\tif (_M_file)\n+      _M_fd = ::open(fname, O_RDONLY);\n+      if (_M_fd != -1)\n+\t{\n+\t  // Set _M_file to non-null so that _M_fini() will do clean up.\n+\t  _M_file = &_M_fd;\n \t  return;\n+\t}\n+#else // USE_POSIX_FILE_IO\n+      _M_file = static_cast<void*>(std::fopen(fname, \"rb\"));\n+      if (_M_file)\n+\treturn;\n #endif // USE_POSIX_FILE_IO\n-\t[[gnu::fallthrough]];\n-      }\n+    }\n #endif // _GLIBCXX_USE_DEV_RANDOM\n-      default:\n-      { }\n+\n+#ifdef USE_LCG\n+    // Either \"prng\" was requested explicitly, or \"default\" was requested\n+    // but nothing above worked, use a PRNG.\n+    if (which & prng)\n+    {\n+      static_assert(sizeof(lcg_type) <= sizeof(_M_fd), \"\");\n+      static_assert(alignof(lcg_type) <= alignof(_M_fd), \"\");\n+      _M_file = construct_lcg_at(&_M_fd);\n+      _M_func = &__lcg;\n+      return;\n     }\n+#endif\n+\n     std::__throw_runtime_error(\n \t__N(\"random_device::random_device(const std::string&):\"\n \t    \" device not available\"));\n@@ -297,7 +349,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n   {\n #ifdef USE_MT19937\n     unsigned long seed = 5489UL;\n-    if (token != \"default\" && token != \"mt19937\")\n+    if (token != \"default\" && token != \"mt19937\" && token != \"prng\")\n       {\n \tconst char* nptr = token.c_str();\n \tchar* endptr;\n@@ -335,6 +387,14 @@ namespace std _GLIBCXX_VISIBILITY(default)\n     if (!_M_file)\n       return;\n \n+#if USE_LCG\n+    if (_M_func == &__lcg)\n+      {\n+\tdestroy_lcg_at(_M_file);\n+\treturn;\n+      }\n+#endif\n+\n #ifdef USE_POSIX_FILE_IO\n     ::close(_M_fd);\n     _M_fd = -1;\n@@ -351,10 +411,8 @@ namespace std _GLIBCXX_VISIBILITY(default)\n     return _M_mt();\n #else\n \n-#if defined USE_RDRAND || defined USE_RDSEED || defined _GLIBCXX_USE_CRT_RAND_S\n     if (_M_func)\n-      return _M_func(nullptr);\n-#endif\n+      return _M_func(_M_file);\n \n     result_type ret;\n     void* p = &ret;\n@@ -430,5 +488,11 @@ namespace std _GLIBCXX_VISIBILITY(default)\n     0x9d2c5680UL, 15,\n     0xefc60000UL, 18, 1812433253UL>;\n #endif // USE_MT19937\n+\n+#ifdef USE_LCG\n+  template class\n+    linear_congruential_engine<unsigned, 16807UL, 0UL, 2147483647UL>;\n+  template struct __detail::_Mod<unsigned, 2147483647UL, 16807UL, 0UL>;\n+#endif\n }\n #endif // _GLIBCXX_USE_C99_STDINT_TR1"}, {"sha": "80cb912b58799fae517f1280ba23e65caf339c56", "filename": "libstdc++-v3/testsuite/26_numerics/random/random_device/85494.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2F85494.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2F85494.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2F85494.cc?ref=5f070ba29803c99a5fe94ed7632d7b8c55593df3", "patch": "@@ -16,14 +16,21 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do run { target c++11 } }\n-// { dg-require-effective-target random_device }\n \n #include <random>\n #include <testsuite_hooks.h>\n+#include <testsuite_random.h>\n \n void\n test01()\n {\n+  if (__gnu_test::random_device_available(\"mt19937\"))\n+  {\n+    // std::random_device uses a Mersenne Twister with default seed,\n+    // and the test below will fail.  No point trying to test it.\n+    return;\n+  }\n+\n   unsigned v1[3], v2[3];\n   std::random_device d1, d2;\n   for (auto& v : v1)"}, {"sha": "7ff672e7024ae9888ef61bebdf9b8458dcfd6a1f", "filename": "libstdc++-v3/testsuite/26_numerics/random/random_device/94087.cc", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2F94087.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2F94087.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2F94087.cc?ref=5f070ba29803c99a5fe94ed7632d7b8c55593df3", "patch": "@@ -25,18 +25,9 @@\n #include <memory>\n #include <thread>\n #include <cstdio>\n+#include <testsuite_random.h>\n \n-bool\n-random_device_available(const char* token) noexcept\n-{\n-  try {\n-    std::random_device dev(token);\n-    return true;\n-  } catch (...) {\n-    std::printf(\"random_device(\\\"%s\\\") not available\\n\", token);\n-    return false;\n-  }\n-}\n+using __gnu_test::random_device_available;\n \n void read_random_device(const char* token, int iterations)\n {\n@@ -59,5 +50,7 @@ int main() {\n       for (auto& w : workers)\n \tw.join();\n     }\n+    else\n+      std::printf(\"random_device(\\\"%s\\\") not available\\n\", dev);\n   }\n }"}, {"sha": "489a0a0965f0411c383b176ba33985b8e60a8e73", "filename": "libstdc++-v3/testsuite/26_numerics/random/random_device/cons/default-cow.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Fdefault-cow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Fdefault-cow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Fdefault-cow.cc?ref=5f070ba29803c99a5fe94ed7632d7b8c55593df3", "patch": "@@ -1,6 +1,5 @@\n // { dg-options \"-D_GLIBCXX_USE_CXX11_ABI=0\" }\n // { dg-do run { target c++11 } }\n-// { dg-require-effective-target random_device }\n // { dg-require-cstdint \"\" }\n //\n // Copyright (C) 2019-2021 Free Software Foundation, Inc."}, {"sha": "79e044ece42ab2126265df82423407d051c07ec3", "filename": "libstdc++-v3/testsuite/26_numerics/random/random_device/cons/default.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Fdefault.cc?ref=5f070ba29803c99a5fe94ed7632d7b8c55593df3", "patch": "@@ -1,5 +1,4 @@\n // { dg-do run { target c++11 } }\n-// { dg-require-effective-target random_device }\n // { dg-require-cstdint \"\" }\n //\n // 2008-11-24  Edward M. Smith-Rowland <3dw4rd@verizon.net>"}, {"sha": "aeb7403e8301f227917c46693d50177aba1cd0c7", "filename": "libstdc++-v3/testsuite/26_numerics/random/random_device/cons/token.cc", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Ftoken.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Ftoken.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Frandom%2Frandom_device%2Fcons%2Ftoken.cc?ref=5f070ba29803c99a5fe94ed7632d7b8c55593df3", "patch": "@@ -25,6 +25,7 @@\n #include <random>\n #include <stdexcept>\n #include <testsuite_hooks.h>\n+#include <testsuite_random.h>\n \n void\n test01()\n@@ -50,41 +51,27 @@ test03()\n {\n   // At least one of these tokens should be valid.\n   const std::string tokens[] = {\n-    \"rdseed\", \"rdrand\", \"rand_s\", \"/dev/urandom\", \"/dev/random\", \"mt19937\"\n+    \"rdseed\", \"rdrand\", \"rand_s\", \"/dev/urandom\", \"/dev/random\", \"mt19937\",\n+    \"prng\"\n   };\n   int count = 0;\n   for (const std::string& token : tokens)\n   {\n-    try\n-    {\n-      std::random_device x(token);\n+    if (__gnu_test::random_device_available(token))\n       ++count;\n-    }\n-    catch (const std::runtime_error&)\n-    {\n-    }\n   }\n   VERIFY( count != 0 );\n }\n \n void\n test04()\n {\n-  bool can_use_mt19937 = true;\n-  std::random_device::result_type xval;\n-  try\n+  if (__gnu_test::random_device_available(\"mt19937\"))\n   {\n     std::random_device x(\"mt19937\");\n-    xval = x();\n-  }\n-  catch (const std::runtime_error&)\n-  {\n-    can_use_mt19937 = false;\n-  }\n+    std::random_device::result_type xval = x();\n \n-  // If \"mt19937\" is a valid token then numeric seeds should be too.\n-  if (can_use_mt19937)\n-  {\n+    // If \"mt19937\" is a valid token then numeric seeds should be too.\n     std::random_device x1(\"0\");\n     std::random_device x2(\"1234\");\n     std::random_device x3(\"0xc0fefe\");"}, {"sha": "8fba2688bc06d49b0cb776dbd5919e0576bcf2b4", "filename": "libstdc++-v3/testsuite/util/testsuite_random.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_random.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f070ba29803c99a5fe94ed7632d7b8c55593df3/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_random.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_random.h?ref=5f070ba29803c99a5fe94ed7632d7b8c55593df3", "patch": "@@ -197,6 +197,18 @@ namespace __gnu_test\n   }\n #endif\n \n+  // Check whether TOKEN can construct a std::random_device successfully.\n+  inline bool\n+  random_device_available(const std::string& token) noexcept\n+  {\n+    try {\n+      std::random_device dev(token);\n+      return true;\n+    } catch (...) {\n+      return false;\n+    }\n+  }\n+\n } // namespace __gnu_test\n \n #endif // #ifndef _GLIBCXX_TESTSUITE_RANDOM_H"}]}