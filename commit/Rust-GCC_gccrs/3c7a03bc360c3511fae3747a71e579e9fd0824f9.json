{"sha": "3c7a03bc360c3511fae3747a71e579e9fd0824f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M3YTAzYmMzNjBjMzUxMWZhZTM3NDdhNzFlNTc5ZTlmZDA4MjRmOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-02-07T11:56:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-02-07T11:57:18Z"}, "message": "middle-end/93519 - avoid folding stmts in obviously unreachable code\n\nThe inliner folds stmts delayed, the following arranges things so\nto not fold stmts that are obviously not reachable to avoid warnings\nfrom those code regions.\n\n2020-02-07  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/93519\n\t* tree-inline.c (fold_marked_statements): Do a PRE walk,\n\tskipping unreachable regions.\n\t(optimize_inline_calls): Skip folding stmts when we didn't\n\tinline.\n\n\t* gcc.dg/Wrestrict-21.c: New testcase.", "tree": {"sha": "80486aaaa38e31f6a148bf0e524ce795e12ad5b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80486aaaa38e31f6a148bf0e524ce795e12ad5b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c7a03bc360c3511fae3747a71e579e9fd0824f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c7a03bc360c3511fae3747a71e579e9fd0824f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c7a03bc360c3511fae3747a71e579e9fd0824f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c7a03bc360c3511fae3747a71e579e9fd0824f9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5713834e4b99e4c4c99eef15698a497f091b7dc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5713834e4b99e4c4c99eef15698a497f091b7dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5713834e4b99e4c4c99eef15698a497f091b7dc4"}], "stats": {"total": 223, "additions": 144, "deletions": 79}, "files": [{"sha": "d5d29f5e5d4404086f9894def612cdb5f9f5403e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c7a03bc360c3511fae3747a71e579e9fd0824f9", "patch": "@@ -1,3 +1,11 @@\n+2020-02-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/93519\n+\t* tree-inline.c (fold_marked_statements): Do a PRE walk,\n+\tskipping unreachable regions.\n+\t(optimize_inline_calls): Skip folding stmts when we didn't\n+\tinline.\n+\n 2020-02-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/85667"}, {"sha": "69f7223318089710dfc894763c64362acb743666", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c7a03bc360c3511fae3747a71e579e9fd0824f9", "patch": "@@ -1,3 +1,8 @@\n+2020-02-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/93519\n+\t* gcc.dg/Wrestrict-21.c: New testcase.\n+\n 2020-02-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/85667"}, {"sha": "e300663758e42dea470cba6437a78e4177ae65f1", "filename": "gcc/testsuite/gcc.dg/Wrestrict-21.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-21.c?ref=3c7a03bc360c3511fae3747a71e579e9fd0824f9", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wrestrict\" } */\n+\n+static char *\n+str_numth(char *dest, char *num, int type)\n+{\n+  if (dest != num)\n+    __builtin_strcpy(dest, num); /* { dg-bogus \"is the same\" } */\n+  __builtin_strcat(dest, \"foo\");\n+  return dest;\n+}\n+\n+void\n+DCH_to_char(char *in, char *out, int collid)\n+{\n+  char *s = out;\n+  str_numth(s, s, 42);\n+}"}, {"sha": "23941dade5552a068e734d31e4bde6d2468c1746", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 113, "deletions": 79, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c7a03bc360c3511fae3747a71e579e9fd0824f9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3c7a03bc360c3511fae3747a71e579e9fd0824f9", "patch": "@@ -5261,86 +5261,117 @@ static void\n fold_marked_statements (int first, hash_set<gimple *> *statements)\n {\n   auto_bitmap to_purge;\n-  for (; first < last_basic_block_for_fn (cfun); first++)\n-    if (BASIC_BLOCK_FOR_FN (cfun, first))\n-      {\n-        gimple_stmt_iterator gsi;\n \n-\tfor (gsi = gsi_start_bb (BASIC_BLOCK_FOR_FN (cfun, first));\n-\t     !gsi_end_p (gsi);\n-\t     gsi_next (&gsi))\n-\t  if (statements->contains (gsi_stmt (gsi)))\n-\t    {\n-\t      gimple *old_stmt = gsi_stmt (gsi);\n-\t      tree old_decl\n-\t\t= is_gimple_call (old_stmt) ? gimple_call_fndecl (old_stmt) : 0;\n+  auto_vec<edge, 20> stack (n_basic_blocks_for_fn (cfun) + 2);\n+  auto_sbitmap visited (last_basic_block_for_fn (cfun));\n+  bitmap_clear (visited);\n \n-\t      if (old_decl && fndecl_built_in_p (old_decl))\n-\t\t{\n-\t\t  /* Folding builtins can create multiple instructions,\n-\t\t     we need to look at all of them.  */\n-\t\t  gimple_stmt_iterator i2 = gsi;\n-\t\t  gsi_prev (&i2);\n-\t\t  if (fold_stmt (&gsi))\n-\t\t    {\n-\t\t      gimple *new_stmt;\n-\t\t      /* If a builtin at the end of a bb folded into nothing,\n-\t\t\t the following loop won't work.  */\n-\t\t      if (gsi_end_p (gsi))\n-\t\t\t{\n-\t\t\t  cgraph_update_edges_for_call_stmt (old_stmt,\n-\t\t\t\t\t\t\t     old_decl, NULL);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      if (gsi_end_p (i2))\n-\t\t\ti2 = gsi_start_bb (BASIC_BLOCK_FOR_FN (cfun, first));\n-\t\t      else\n+  stack.quick_push (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n+  while (!stack.is_empty ())\n+    {\n+      /* Look at the edge on the top of the stack.  */\n+      edge e = stack.pop ();\n+      basic_block dest = e->dest;\n+\n+      if (dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t  || bitmap_bit_p (visited, dest->index))\n+\tcontinue;\n+\n+      bitmap_set_bit (visited, dest->index);\n+\n+      if (dest->index >= first)\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (dest);\n+\t     !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    if (!statements->contains (gsi_stmt (gsi)))\n+\t      continue;\n+\n+\t    gimple *old_stmt = gsi_stmt (gsi);\n+\t    tree old_decl = (is_gimple_call (old_stmt)\n+\t\t\t     ? gimple_call_fndecl (old_stmt) : 0);\n+\t    if (old_decl && fndecl_built_in_p (old_decl))\n+\t      {\n+\t\t/* Folding builtins can create multiple instructions,\n+\t\t   we need to look at all of them.  */\n+\t\tgimple_stmt_iterator i2 = gsi;\n+\t\tgsi_prev (&i2);\n+\t\tif (fold_stmt (&gsi))\n+\t\t  {\n+\t\t    gimple *new_stmt;\n+\t\t    /* If a builtin at the end of a bb folded into nothing,\n+\t\t       the following loop won't work.  */\n+\t\t    if (gsi_end_p (gsi))\n+\t\t      {\n+\t\t\tcgraph_update_edges_for_call_stmt (old_stmt,\n+\t\t\t\t\t\t\t   old_decl, NULL);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    if (gsi_end_p (i2))\n+\t\t      i2 = gsi_start_bb (dest);\n+\t\t    else\n+\t\t      gsi_next (&i2);\n+\t\t    while (1)\n+\t\t      {\n+\t\t\tnew_stmt = gsi_stmt (i2);\n+\t\t\tupdate_stmt (new_stmt);\n+\t\t\tcgraph_update_edges_for_call_stmt (old_stmt, old_decl,\n+\t\t\t\t\t\t\t   new_stmt);\n+\n+\t\t\tif (new_stmt == gsi_stmt (gsi))\n+\t\t\t  {\n+\t\t\t    /* It is okay to check only for the very last\n+\t\t\t       of these statements.  If it is a throwing\n+\t\t\t       statement nothing will change.  If it isn't\n+\t\t\t       this can remove EH edges.  If that weren't\n+\t\t\t       correct then because some intermediate stmts\n+\t\t\t       throw, but not the last one.  That would mean\n+\t\t\t       we'd have to split the block, which we can't\n+\t\t\t       here and we'd loose anyway.  And as builtins\n+\t\t\t       probably never throw, this all\n+\t\t\t       is mood anyway.  */\n+\t\t\t    if (maybe_clean_or_replace_eh_stmt (old_stmt,\n+\t\t\t\t\t\t\t\tnew_stmt))\n+\t\t\t      bitmap_set_bit (to_purge, dest->index);\n+\t\t\t    break;\n+\t\t\t  }\n \t\t\tgsi_next (&i2);\n-\t\t      while (1)\n-\t\t\t{\n-\t\t\t  new_stmt = gsi_stmt (i2);\n-\t\t\t  update_stmt (new_stmt);\n-\t\t\t  cgraph_update_edges_for_call_stmt (old_stmt, old_decl,\n-\t\t\t\t\t\t\t     new_stmt);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else if (fold_stmt (&gsi))\n+\t      {\n+\t\t/* Re-read the statement from GSI as fold_stmt() may\n+\t\t   have changed it.  */\n+\t\tgimple *new_stmt = gsi_stmt (gsi);\n+\t\tupdate_stmt (new_stmt);\n+\n+\t\tif (is_gimple_call (old_stmt)\n+\t\t    || is_gimple_call (new_stmt))\n+\t\t  cgraph_update_edges_for_call_stmt (old_stmt, old_decl,\n+\t\t\t\t\t\t     new_stmt);\n+\n+\t\tif (maybe_clean_or_replace_eh_stmt (old_stmt, new_stmt))\n+\t\t  bitmap_set_bit (to_purge, dest->index);\n+\t      }\n+\t  }\n \n-\t\t\t  if (new_stmt == gsi_stmt (gsi))\n-\t\t\t    {\n-\t\t\t      /* It is okay to check only for the very last\n-\t\t\t\t of these statements.  If it is a throwing\n-\t\t\t\t statement nothing will change.  If it isn't\n-\t\t\t\t this can remove EH edges.  If that weren't\n-\t\t\t\t correct then because some intermediate stmts\n-\t\t\t\t throw, but not the last one.  That would mean\n-\t\t\t\t we'd have to split the block, which we can't\n-\t\t\t\t here and we'd loose anyway.  And as builtins\n-\t\t\t\t probably never throw, this all\n-\t\t\t\t is mood anyway.  */\n-\t\t\t      if (maybe_clean_or_replace_eh_stmt (old_stmt,\n-\t\t\t\t\t\t\t\t  new_stmt))\n-\t\t\t\tbitmap_set_bit (to_purge, first);\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t  gsi_next (&i2);\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      else if (fold_stmt (&gsi))\n-\t\t{\n-\t\t  /* Re-read the statement from GSI as fold_stmt() may\n-\t\t     have changed it.  */\n-\t\t  gimple *new_stmt = gsi_stmt (gsi);\n-\t\t  update_stmt (new_stmt);\n-\n-\t\t  if (is_gimple_call (old_stmt)\n-\t\t      || is_gimple_call (new_stmt))\n-\t\t    cgraph_update_edges_for_call_stmt (old_stmt, old_decl,\n-\t\t\t\t\t\t       new_stmt);\n-\n-\t\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, new_stmt))\n-\t\t    bitmap_set_bit (to_purge, first);\n-\t\t}\n+      if (EDGE_COUNT (dest->succs) > 0)\n+\t{\n+\t  /* Avoid warnings emitted from folding statements that\n+\t     became unreachable because of inlined function parameter\n+\t     propagation.  */\n+\t  e = find_taken_edge (dest, NULL_TREE);\n+\t  if (e)\n+\t    stack.quick_push (e);\n+\t  else\n+\t    {\n+\t      edge_iterator ei;\n+\t      FOR_EACH_EDGE (e, ei, dest->succs)\n+\t\tstack.safe_push (e);\n \t    }\n-      }\n+\t}\n+    }\n+\n   gimple_purge_all_dead_eh_edges (to_purge);\n }\n \n@@ -5404,6 +5435,13 @@ optimize_inline_calls (tree fn)\n \tgcc_assert (e->inline_failed);\n     }\n \n+  /* If we didn't inline into the function there is nothing to do.  */\n+  if (!inlined_p)\n+    {\n+      delete id.statements_to_fold;\n+      return 0;\n+    }\n+\n   /* Fold queued statements.  */\n   update_max_bb_count ();\n   fold_marked_statements (last, id.statements_to_fold);\n@@ -5426,10 +5464,6 @@ optimize_inline_calls (tree fn)\n \n   gcc_assert (!id.debug_stmts.exists ());\n \n-  /* If we didn't inline into the function there is nothing to do.  */\n-  if (!inlined_p)\n-    return 0;\n-\n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (fn);\n "}]}