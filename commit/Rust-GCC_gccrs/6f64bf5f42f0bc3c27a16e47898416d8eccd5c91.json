{"sha": "6f64bf5f42f0bc3c27a16e47898416d8eccd5c91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY2NGJmNWY0MmYwYmMzYzI3YTE2ZTQ3ODk4NDE2ZDhlY2NkNWM5MQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-25T14:16:13Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-25T14:16:13Z"}, "message": "(SPARC_{V9,ARCH64}): Default value is 0.\n\n(*): Replace SPARCV9 with SPARC_{V9,ARCH64}.\n(MASK_CPUS): Define.\n({MASK,TARGET}_ENV32): Delete.\n({MASK,TARGET}_ARCH64,TARGET_ARCH32): Define.\n(TARGET_SWITCHES): Reset cpu flags first for each variant.\n(CONDITIONAL_REGISTER_USAGE): If 32 bit v9 system, unfix g1-g4,\nfix g5, and make %f48-%f80 call used.\n\nFrom-SVN: r11100", "tree": {"sha": "624593682c9fd46632aefddf4f9959e0b06f97ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/624593682c9fd46632aefddf4f9959e0b06f97ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91/comments", "author": null, "committer": null, "parents": [{"sha": "a9e27770e111957652027b62e387997fe86166d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e27770e111957652027b62e387997fe86166d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9e27770e111957652027b62e387997fe86166d3"}], "stats": {"total": 285, "additions": 165, "deletions": 120}, "files": [{"sha": "0ee0112b03c74c71c1eebb88d98d059d963c2530", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 165, "deletions": 120, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f64bf5f42f0bc3c27a16e47898416d8eccd5c91/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=6f64bf5f42f0bc3c27a16e47898416d8eccd5c91", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for Sun SPARC.\n-   Copyright (C) 1987, 88, 89, 92, 94, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92, 94, 95, 1996 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n    64 bit SPARC V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n    at Cygnus Support.\n@@ -26,23 +26,38 @@ Boston, MA 02111-1307, USA.  */\n \n /* Sparc64 support has been added by trying to allow for a day when one\n    compiler can handle both v8 and v9.  There are a few cases where this\n-   isn't doable, but keep them to a minimum!  Two macros are used to help out:\n-   TARGET_V9 is used to select (at runtime) !v9-ness or v9-ness.\n-   SPARCV9 is defined when compiling for sparc64 only.\n-   In places where it is possible to choose between the two at runtime, use\n-   TARGET_V9.  In places where it is currently not possible to select\n-   between the two at runtime use SPARCV9.  Again, keep uses of SPARCV9 to a\n-   minimum.  No attempt is made to support both v8 and v9 in the v9 compiler.\n+   isn't doable, but keep them to a minimum!\n+\n+   TARGET_V9 is used to select at runtime the sparc64 chip.\n+   TARGET_ARCH64 is used to select at runtime a 64 bit environment.\n+   SPARC_V9 is defined as 0 or 1 (so it may be used inside and outside\n+   #define's), and says whether the cpu is a sparc64 chip (which may be\n+   running in a 32 or 64 bit environment).\n+   SPARC_ARCH64 is defined as 0 for a 32 bit environment and 1 for a 64 bit\n+   environment.\n+\n+   In places where it is possible to choose at runtime, use TARGET_V9 and\n+   TARGET_ARCH64.  In places where it is currently not possible to select\n+   between the two at runtime use SPARC_{V9,ARCH64}.  Again, keep uses of\n+   SPARC_{V9,ARCH64} to a minimum.  No attempt is made to support both v8\n+   and v9 in the v9 compiler.\n \n    If a combination v8/v9 compiler is too slow, it should always be possible\n-   to #define TARGET_V9 as 0 (and potentially other v9-only options), and\n-   #undef SPARCV9.  */\n+   to #define TARGET_{V9,ARCH64} as 0 (and potentially other v9-only\n+   options), and #define SPARC_{V9,ARCH64} as 0.\n+   I measured the difference once and it was around 10%.  /dje 960120\n+*/\n \n+#ifndef SPARC_V9\n+#define SPARC_V9 0\n+#endif\n+#ifndef SPARC_ARCH64\n+#define SPARC_ARCH64 0\n+#endif\n+\n+/* ??? Delete and use `TARGET_ARCH64' instead.  */\n /* What architecture we're compiling for.  This must coincide with the\n-   `arch_type' attribute in the .md file.  The names were chosen to avoid\n-   potential misunderstandings with the various 32 bit flavors (v7, v8, etc.):\n-   if we used ARCH_V9 then we'd want to use something like ARCH_V8 but that\n-   could be misleading and ARCH_NOTV9 sounds klunky.  */\n+   `arch_type' attribute in the .md file.  */\n enum arch_type { ARCH_32BIT, ARCH_64BIT };\n extern enum arch_type sparc_arch_type;\n \n@@ -51,7 +66,7 @@ extern enum arch_type sparc_arch_type;\n /* ??? The GCC_NEW_VARARGS macro is now obsolete, because gcc always uses\n    the right varags.h file when bootstrapping.  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n #define CPP_PREDEFINES \\\n   \"-Dsparc -Dsun -Dunix -D__sparc_v9__ \\\n    -Asystem(unix) -Asystem(bsd) -Acpu(sparc64) -Amachine(sparc64)\"\n@@ -76,7 +91,7 @@ extern enum arch_type sparc_arch_type;\n \n /* Define macros to distinguish architectures.  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n #define CPP_SPEC \"\\\n %{mint64:-D__INT_MAX__=9223372036854775807LL -D__LONG_MAX__=9223372036854775807LL} \\\n %{mlong64:-D__LONG_MAX__=9223372036854775807LL} \\\n@@ -96,7 +111,7 @@ extern enum arch_type sparc_arch_type;\n \n #define CC1_SPEC \"%{sun4:} %{target:}\"\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n #define PTRDIFF_TYPE \"long long int\"\n #define SIZE_TYPE \"long long unsigned int\"\n #else\n@@ -172,22 +187,33 @@ extern int target_flags;\n #define MASK_UNALIGNED_DOUBLES 4\n #define TARGET_UNALIGNED_DOUBLES (target_flags & MASK_UNALIGNED_DOUBLES)\n \n-/* ??? Bits 0x18 are currently unused.  */\n-\n-/* Nonzero means we should schedule code for the TMS390Z55 SuperSparc chip.  */\n-#define MASK_SUPERSPARC 0x20\n-#define TARGET_SUPERSPARC (target_flags & MASK_SUPERSPARC)\n-\n /* Nonzero means that we should generate code for a v8 sparc.  */\n-#define MASK_V8 0x40\n+#define MASK_V8 0x8\n #define TARGET_V8 (target_flags & MASK_V8)\n \n /* Nonzero means that we should generate code for a sparclite.\n    This enables the sparclite specific instructions, but does not affect\n    whether FPU instructions are emitted.  */\n-#define MASK_SPARCLITE 0x80\n+#define MASK_SPARCLITE 0x10\n #define TARGET_SPARCLITE (target_flags & MASK_SPARCLITE)\n \n+/* Nonzero means we should schedule code for the TMS390Z55 SuperSparc chip.  */\n+#define MASK_SUPERSPARC 0x20\n+#define TARGET_SUPERSPARC (target_flags & MASK_SUPERSPARC)\n+\n+/* Nonzero if we're compiling for v9 sparc.\n+   Note that v9's can run in 32 bit mode so this doesn't necessarily mean\n+   the word size is 64.  It does mean that the extra fp regs are available\n+   as are the new instructions.  */\n+#define MASK_V9 0x40\n+#define TARGET_V9 (target_flags & MASK_V9)\n+\n+/* ??? Bit 0x80 currently unused.  */\n+\n+/* Mask of all CPU selection flags.\n+   ??? Migrate to -mcpu=?  */\n+#define MASK_CPUS (MASK_V8 + MASK_SPARCLITE + MASK_SUPERSPARC + MASK_V9)\n+\n /* Nonzero means that we should generate code using a flat register window\n    model, i.e. no save/restore instructions are generated, in the most\n    efficient manner.  This code is not compatible with normal sparc code.  */\n@@ -218,9 +244,7 @@ extern int target_flags;\n #define MASK_HARD_QUAD 0x800\n #define TARGET_HARD_QUAD (target_flags & MASK_HARD_QUAD)\n \n-/* Nonzero if we're compiling for 64 bit sparc.  */\n-#define MASK_V9 0x1000\n-#define TARGET_V9 (target_flags & MASK_V9)\n+/* Bit 0x1000 is unused.  */\n \n /* Nonzero if ints are 64 bits.\n    This automatically implies longs are 64 bits too.\n@@ -239,21 +263,23 @@ extern int target_flags;\n #define MASK_PTR64 0x8000\n #define TARGET_PTR64 (target_flags & MASK_PTR64)\n \n-/* Nonzero if we are generating code to be tested in a 32 bit environment.\n+/* Nonzero if generating code to run in a 64 bit environment.  */\n+#define MASK_ARCH64 0x10000\n+#define TARGET_ARCH64 (target_flags & MASK_ARCH64)\n+\n+/* Nonzero if generating code to run in a 32 bit environment.\n    Hence, we assume the upper 32 bits of symbolic addresses are zero, and\n    avoid generating %uhi and %ulo terms.\n    Pointers are still 64 bits though!  This option is for v9 only.  */\n-/* ??? This option is deprecated.  Try to use -mmedlow.  */\n-#define MASK_ENV32 0x10000\n-#define TARGET_ENV32 (target_flags & MASK_ENV32)\n+#define TARGET_ARCH32 (! TARGET_ARCH64)\n \n-/* Memory models.\n-   Two memory models are supported:\n+/* SPARC64 memory models.\n    TARGET_MEDLOW: 32 bit address space, top 32 bits = 0\n                   (pointers still 64 bits)\n-   TARGET_MEDANY: 32 bit address space, data segment loaded anywhere\n-                  (use %g4 as offset).\n-   TARGET_FULLANY: not supported yet.\n+   TARGET_MEDANY: 64 bit address space, data segment restricted to 4G, but\n+                  can be loaded anywhere (use %g4 as offset).\n+   TARGET_FULLANY: 64 bit address space, no restrictions.\n+                   This option is not fully supported yet.\n    These options are for v9 only.  All mask values are nonzero so the v8\n    compiler can assume this stuff won't interfere.  */\n #define MASK_MEDLOW 0x20000\n@@ -292,15 +318,19 @@ extern int target_flags;\n     {\"no-epilogue\", -MASK_EPILOGUE},\t\\\n     {\"unaligned-doubles\", MASK_UNALIGNED_DOUBLES}, \\\n     {\"no-unaligned-doubles\", -MASK_UNALIGNED_DOUBLES}, \\\n-    {\"supersparc\", MASK_SUPERSPARC+MASK_V8},\t\\\n-    {\"cypress\", -MASK_SUPERSPARC-MASK_V8},\t\\\n+    {\"supersparc\", -MASK_CPUS},\t\t\\\n+    {\"supersparc\", MASK_SUPERSPARC+MASK_V8}, \\\n+    {\"cypress\", -MASK_CPUS},\t\t\\\n+    {\"v8\", -MASK_CPUS},\t\t\t\\\n     {\"v8\", MASK_V8},\t\t\t\\\n-    {\"no-v8\", -MASK_V8},\t\t\\\n+    {\"no-v8\", -MASK_CPUS},\t\t\\\n+    {\"sparclite\", -MASK_CPUS},\t\t\\\n     {\"sparclite\", MASK_SPARCLITE},\t\\\n-    {\"no-sparclite\", -MASK_SPARCLITE},\t\\\n+    {\"no-sparclite\", -MASK_CPUS},\t\\\n+    {\"f930\", -MASK_FPU-MASK_CPUS},\t\\\n     {\"f930\", MASK_SPARCLITE},\t\t\\\n-    {\"f930\", -MASK_FPU},\t\t\\\n-    {\"f934\", MASK_SPARCLITE},\t\t\\\n+    {\"f934\", -MASK_CPUS},\t\t\\\n+    {\"f934\", MASK_FPU+MASK_SPARCLITE},\t\\\n     {\"flat\", MASK_FRW+MASK_FLAT},\t\\\n     {\"no-flat\", -(MASK_FRW+MASK_FLAT)},\t\\\n     {\"app-regs\", MASK_APP_REGS},\t\\\n@@ -317,10 +347,11 @@ extern int target_flags;\n #define SUBTARGET_SWITCHES\n \n /* ??? Until we support a combination v8/v9 compiler, the v9 specific options\n-   are only defined for the v9 compiler.  */\n-#ifdef SPARCV9\n+   are only defined for the v9 compiler (in a true 64 bit environment).  */\n+#if SPARC_ARCH64\n #define V9_SWITCHES \\\n-/*  {\"v9\", MASK_V9}, */\t\t\t\\\n+/*  {\"arch32\", -MASK_ARCH64}, */\t\\\n+/*  {\"arch64\", MASK_ARCH64}, */\t\t\\\n     {\"int64\", MASK_INT64+MASK_LONG64},\t\\\n     {\"int32\", -MASK_INT64},\t\t\\\n     {\"int32\", MASK_LONG64},\t\t\\\n@@ -334,7 +365,9 @@ extern int target_flags;\n     {\"medlow\", -MASK_CODE_MODEL},\t\\\n     {\"medlow\", MASK_MEDLOW},\t\t\\\n     {\"medany\", -MASK_CODE_MODEL},\t\\\n-    {\"medany\", MASK_MEDANY},\n+    {\"medany\", MASK_MEDANY},\t\t\\\n+    {\"fullany\", -MASK_CODE_MODEL},\t\\\n+    {\"fullany\", MASK_FULLANY},\n #else\n #define V9_SWITCHES\n #endif\n@@ -366,11 +399,11 @@ extern int target_flags;\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD\t\t(TARGET_V9 ? 64 : 32)\n+#define BITS_PER_WORD\t\t(TARGET_ARCH64 ? 64 : 32)\n #define MAX_BITS_PER_WORD\t64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD\t\t(TARGET_V9 ? 8 : 4)\n+#define UNITS_PER_WORD\t\t(TARGET_ARCH64 ? 8 : 4)\n #define MIN_UNITS_PER_WORD\t4\n \n /* Now define the sizes of the C data types.  */\n@@ -385,7 +418,7 @@ extern int target_flags;\n #define MAX_INT_TYPE_SIZE\t64\n #define MAX_LONG_TYPE_SIZE\t64\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n /* ??? This does not work in SunOS 4.x, so it is not enabled here.\n    Instead, it is enabled in sol2.h, because it does work under Solaris.  */\n /* Define for support of TFmode long double and REAL_ARITHMETIC.\n@@ -398,22 +431,22 @@ extern int target_flags;\n #define POINTER_SIZE (TARGET_PTR64 ? 64 : 32)\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY (TARGET_V9 ? 64 : 32)\n+#define PARM_BOUNDARY (TARGET_ARCH64 ? 64 : 32)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY (TARGET_V9 ? 128 : 64)\n+#define STACK_BOUNDARY (TARGET_ARCH64 ? 128 : 64)\n \n /* ALIGN FRAMES on double word boundaries */\n \n #define SPARC_STACK_ALIGN(LOC) \\\n-  (TARGET_V9 ? (((LOC)+15) & ~15) : (((LOC)+7) & ~7))\n+  (TARGET_ARCH64 ? (((LOC)+15) & ~15) : (((LOC)+7) & ~7))\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n \n /* Alignment of field after `int : 0' in a structure.  */\n /* ??? Should this be based on TARGET_INT64?  */\n-#define EMPTY_FIELD_BOUNDARY (TARGET_V9 ? 64 : 32)\n+#define EMPTY_FIELD_BOUNDARY (TARGET_ARCH64 ? 64 : 32)\n \n /* Every structure's size must be a multiple of this.  */\n #define STRUCTURE_SIZE_BOUNDARY 8\n@@ -422,7 +455,7 @@ extern int target_flags;\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n /* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT (TARGET_V9 ? 128 : 64)\n+#define BIGGEST_ALIGNMENT (TARGET_ARCH64 ? 128 : 64)\n \n /* The best alignment to use in cases where we have a choice.  */\n #define FASTEST_ALIGNMENT 64\n@@ -515,7 +548,7 @@ extern int target_flags;\n    32+32+32+4 == 100.\n    Register 0 is used as the integer condition code register.  */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n #define FIRST_PSEUDO_REGISTER 100\n #else\n #define FIRST_PSEUDO_REGISTER 64\n@@ -540,7 +573,7 @@ extern int target_flags;\n    Register 1 is also used when restoring call-preserved registers in large\n    stack frames.  */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n #define FIXED_REGISTERS  \\\n  {0, 1, 1, 1, 1, 0, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n@@ -578,7 +611,7 @@ extern int target_flags;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n #define CALL_USED_REGISTERS  \\\n  {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -615,6 +648,15 @@ extern int target_flags;\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n+    if (SPARC_V9 && ! SPARC_ARCH64)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\\\n+\tfor (regno = 1; regno <= 4; regno++)\t\t\t\\\n+\t  fixed_regs[regno] = 0;\t\t\t\t\\\n+\tfixed_regs[5] = 1;\t\t\t\t\t\\\n+\tfor (regno = 48; regno < 80; regno++)\t\t\t\\\n+\t  call_used_regs[regno] = 1;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n     if (! TARGET_FPU)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tint regno;\t\t\t\t\t\t\\\n@@ -664,7 +706,7 @@ while (0)\n    included in the hard register count).  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  (TARGET_V9\t\t\t\t\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\t\t\\\n    ?  ((REGNO) < 32\t\t\t\t\t\t\t\\\n        ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\t\\\n        : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\\\n@@ -748,7 +790,7 @@ extern int sparc_mode_class[];\n \n /* Register in which static-chain is passed to a function.  This must\n    not be a register used by the prologue.  */\n-#define STATIC_CHAIN_REGNUM (TARGET_V9 ? 5 : 2)\n+#define STATIC_CHAIN_REGNUM (TARGET_ARCH64 ? 5 : 2)\n \n /* Register which holds offset table for position-independent\n    data references.  */\n@@ -763,8 +805,8 @@ extern int sparc_mode_class[];\n    For v9, all aggregates are returned in memory.  */\n #define RETURN_IN_MEMORY(TYPE)\t\t\t\t\\\n   (TYPE_MODE (TYPE) == BLKmode\t\t\t\t\\\n-   || (! TARGET_V9 && (TYPE_MODE (TYPE) == TFmode\t\\\n-\t\t       || TYPE_MODE (TYPE) == TCmode)))\n+   || (! TARGET_ARCH64 && (TYPE_MODE (TYPE) == TFmode\t\\\n+\t\t\t    || TYPE_MODE (TYPE) == TCmode)))\n \n /* Functions which return large structures get the address\n    to place the wanted value at offset 64 from the frame.\n@@ -775,13 +817,13 @@ extern int sparc_mode_class[];\n #define STRUCT_VALUE_OFFSET 64\n \n #define STRUCT_VALUE \\\n-  (TARGET_V9\t\t\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\\\n    : gen_rtx (MEM, Pmode,\t\t\t\t\\\n \t      gen_rtx (PLUS, Pmode, stack_pointer_rtx,\t\\\n \t\t       gen_rtx (CONST_INT, VOIDmode, STRUCT_VALUE_OFFSET))))\n #define STRUCT_VALUE_INCOMING \\\n-  (TARGET_V9\t\t\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\\\n    : gen_rtx (MEM, Pmode,\t\t\t\t\\\n \t      gen_rtx (PLUS, Pmode, frame_pointer_rtx,\t\\\n@@ -834,7 +876,7 @@ extern int sparc_mode_class[];\n    trying to compile _fixunsdfsi because fix_truncdfsi2 won't match its\n    constraints.  */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n \t\t GENERAL_OR_FP_REGS, GENERAL_OR_EXTRA_FP_REGS,\n \t\t ALL_REGS, LIM_REG_CLASSES };\n@@ -846,7 +888,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* Give names of register classes as strings for dump file.   */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n #define REG_CLASS_NAMES \\\n   { \"NO_REGS\", \"FPCC_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"EXTRA_FP_REGS\", \\\n     \"GENERAL_OR_FP_REGS\", \"GENERAL_OR_EXTRA_FP_REGS\", \"ALL_REGS\" }\n@@ -859,7 +901,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n #define REG_CLASS_CONTENTS \\\n   {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {-2, 0, 0, 0}, \\\n    {0, -1, 0, 0}, {0, -1, -1, 0}, {-2, -1, 0, 0}, {-2, -1, -1, 0}, \\\n@@ -877,7 +919,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n #define REGNO_REG_CLASS(REGNO) \\\n   ((REGNO) == 0 ? NO_REGS\t\t\\\n    : (REGNO) < 32 ? GENERAL_REGS\t\\\n@@ -898,7 +940,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n    On v9, the float registers are ordered a little \"funny\" because some\n    of them (%f16-%f47) are call-preserved.  */\n-#ifdef SPARCV9\n+#if SPARC_V9\n #define REG_ALLOC_ORDER \\\n { 8, 9, 10, 11, 12, 13,\t\t\t\\\n   15, 16, 17, 18, 19, 20, 21, 22,\t\\\n@@ -932,7 +974,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    then we have the possibility of having a leaf function.\n    v9: The floating point registers are ordered a little \"funny\" because some\n    of them (%f16-%f47) are call-preserved.   */\n-#ifdef SPARCV9\n+#if SPARC_V9\n #define REG_LEAF_ALLOC_ORDER \\\n { 24, 25, 26, 27, 28, 29,\t\t\\\n   15, 8, 9, 10, 11, 12, 13,\t\t\\\n@@ -968,7 +1010,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    register is used and is not permitted in a leaf function.  We make %g7\n    a global reg if -mflat and voila.  Since %g7 is a system register and is\n    fixed it won't be used by gcc anyway.  */\n-#ifdef SPARCV9\n+#if SPARC_V9\n #define LEAF_REGISTERS \\\n { 1, 1, 1, 1, 1, 1, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n@@ -1003,15 +1045,15 @@ extern char leaf_reg_remap[];\n #define BASE_REG_CLASS GENERAL_REGS\n \n /* Local macro to handle the two v9 classes of FP regs.  */\n-#ifdef SPARCV9\n+#if SPARC_V9\n #define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS || (CLASS) == EXTRA_FP_REGS)\n #else\n #define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS)\n #endif\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n \n-#ifdef SPARCV9\n+#if SPARC_V9\n #define REG_CLASS_FROM_LETTER(C) \\\n   ((C) == 'f' ? FP_REGS\t\t\\\n    : (C) == 'e' ? EXTRA_FP_REGS\t\\\n@@ -1106,7 +1148,7 @@ extern char leaf_reg_remap[];\n    because the movsi and movsf patterns don't handle r/f moves.\n    For v8 we copy the default definition.  */\n #define SECONDARY_MEMORY_NEEDED_MODE(MODE) \\\n-  (TARGET_V9\t\t\t\t\t\t\t\\\n+  (TARGET_ARCH64\t\t\t\t\t\t\\\n    ? (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\\\n       ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\t\\\n       : MODE)\t\t\t\t\t\t\t\\\n@@ -1130,7 +1172,7 @@ extern char leaf_reg_remap[];\n    v9: Non-float args are passed in %o0-5 and float args are passed in\n    %f0-%f15.  */\n #define NPARM_REGS(MODE) \\\n-  (TARGET_V9 ? (GET_MODE_CLASS (MODE) == MODE_FLOAT ? 16 : 6) : 6)\n+  (TARGET_ARCH64 ? (GET_MODE_CLASS (MODE) == MODE_FLOAT ? 16 : 6) : 6)\n \n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n@@ -1148,7 +1190,7 @@ extern char leaf_reg_remap[];\n    of the first local allocated.  */\n /* This allows space for one TFmode floating point value.  */\n #define STARTING_FRAME_OFFSET \\\n-  (TARGET_V9 ? (SPARC_STACK_BIAS - 16) \\\n+  (TARGET_ARCH64 ? (SPARC_STACK_BIAS - 16) \\\n    : (-SPARC_STACK_ALIGN (LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)))\n \n /* If we generate an insn to push BYTES bytes,\n@@ -1161,12 +1203,12 @@ extern char leaf_reg_remap[];\n    even if this function isn't going to use it.\n    v9: This is 128 for the ins and locals, plus a reserved space of 8.  */\n #define FIRST_PARM_OFFSET(FNDECL) \\\n-  (TARGET_V9 ? (SPARC_STACK_BIAS + 136) \\\n+  (TARGET_ARCH64 ? (SPARC_STACK_BIAS + 136) \\\n    : (STRUCT_VALUE_OFFSET + UNITS_PER_WORD))\n \n /* When a parameter is passed in a register, stack space is still\n    allocated for it.  */\n-#ifndef SPARCV9\n+#if ! SPARC_ARCH64\n #define REG_PARM_STACK_SPACE(DECL) (NPARM_REGS (SImode) * UNITS_PER_WORD)\n #endif\n \n@@ -1189,19 +1231,23 @@ extern char leaf_reg_remap[];\n    When !TARGET_FPU, put float return values in the general registers,\n    since we don't have any fp registers.  */\n #define BASE_RETURN_VALUE_REG(MODE) \\\n-  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n+  (TARGET_ARCH64 \\\n+   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n    : (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32 : 8))\n #define BASE_OUTGOING_VALUE_REG(MODE) \\\n-  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n-\t\t: TARGET_FRW ? 8 : 24) \\\n+  (TARGET_ARCH64 \\\n+   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n+      : TARGET_FRW ? 8 : 24) \\\n    : (((MODE) == SFmode || (MODE) == DFmode) && TARGET_FPU ? 32\t\\\n       : (TARGET_FRW ? 8 : 24)))\n #define BASE_PASSING_ARG_REG(MODE) \\\n-  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n-   : (8))\n+  (TARGET_ARCH64 \\\n+   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 8) \\\n+   : 8)\n #define BASE_INCOMING_ARG_REG(MODE) \\\n-  (TARGET_V9 ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n-\t\t: TARGET_FRW ? 8 : 24) \\\n+  (TARGET_ARCH64 \\\n+   ? (TARGET_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 \\\n+      : TARGET_FRW ? 8 : 24) \\\n    : (TARGET_FRW ? 8 : 24))\n \n /* Define this macro if the target machine has \"register windows\".  This\n@@ -1257,7 +1303,7 @@ extern char leaf_reg_remap[];\n    On SPARC, these are the \"output\" registers.  v9 also uses %f0-%f15.  */\n \n #define FUNCTION_ARG_REGNO_P(N) \\\n-  (TARGET_V9 ? (((N) < 14 && (N) > 7) || (N) > 31 && (N) < 48) \\\n+  (TARGET_ARCH64 ? (((N) < 14 && (N) > 7) || (N) > 31 && (N) < 48) \\\n    : ((N) < 14 && (N) > 7))\n \f\n /* Define a data type for recording info about an argument list\n@@ -1291,7 +1337,7 @@ extern char leaf_reg_remap[];\n           allocated like all other arguments.\n \t- The unimp instruction stuff for structure returns is gone.  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n enum sparc_arg_class { SPARC_ARG_INT = 0, SPARC_ARG_FLOAT = 1 };\n struct sparc_args {\n     int arg_count[2];\t/* must be int! (for __builtin_args_info) */\n@@ -1318,14 +1364,15 @@ struct sparc_args {\n #define ROUND_ADVANCE(SIZE)\t\\\n   (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#else /* ! SPARCV9 */\n+#else /* ! SPARC_ARCH64 */\n+\n #define CUMULATIVE_ARGS int\n \n #define ROUND_REG(CUM, MODE) (CUM)\n \n #define ROUND_ADVANCE(SIZE)\t\\\n   ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-#endif /* ! SPARCV9 */\n+#endif /* ! SPARC_ARCH64 */\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -1334,7 +1381,7 @@ struct sparc_args {\n    On SPARC, the offset always starts at 0: the first parm reg is always\n    the same reg.  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n extern int sparc_arg_count,sparc_n_named_args;\n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n@@ -1359,7 +1406,7 @@ extern int sparc_arg_count,sparc_n_named_args;\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     (CUM).arg_count[(int) GET_SPARC_ARG_CLASS (MODE)] =\t\t\\\n@@ -1381,7 +1428,7 @@ extern int sparc_arg_count,sparc_n_named_args;\n /* Return boolean indicating arg of mode MODE will be passed in a reg.\n    This macro is only used in this file.  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n #define PASS_IN_REG_P(CUM, MODE, TYPE)\t\t\t\t\\\n   (ROUND_REG ((CUM), (MODE)) < NPARM_REGS (MODE)\t\t\\\n    && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n@@ -1437,7 +1484,7 @@ extern int sparc_arg_count,sparc_n_named_args;\n    needs partial registers on the Sparc (!v9).  On v9, there are no arguments\n    that are passed partially in registers (??? complex values?).  */\n \n-#ifndef SPARCV9\n+#if ! SPARC_ARCH64\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n   (PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n    && ((CUM) + ((MODE) == BLKmode\t\t\t\t\t\\\n@@ -1452,7 +1499,7 @@ extern int sparc_arg_count,sparc_n_named_args;\n    For Pascal, also pass arrays by reference.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n   ((TYPE && AGGREGATE_TYPE_P (TYPE))\t\t\t\t\\\n-   || (!TARGET_V9 && MODE == TFmode))\n+   || (!TARGET_ARCH64 && MODE == TFmode))\n \n /* A C expression that indicates when it is the called function's\n    responsibility to make copies of arguments passed by reference.\n@@ -1461,7 +1508,7 @@ extern int sparc_arg_count,sparc_n_named_args;\n /* ??? We'd love to be able to use NAMED here.  Unfortunately, it doesn't\n    include the last named argument so we keep track of the args ourselves.  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n #define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n   (sparc_arg_count < sparc_n_named_args)\n #endif\n@@ -1475,7 +1522,7 @@ extern int sparc_arg_count,sparc_n_named_args;\n \n extern void sparc64_init_expanders ();\n extern struct rtx_def *sparc64_fpconv_stack_temp ();\n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n #define INIT_EXPANDERS sparc64_init_expanders ()\n #endif\n \n@@ -1949,7 +1996,7 @@ extern union tree_node *current_function_decl;\n \n #define TRAMPOLINE_TEMPLATE(FILE) \\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_V9)\t\t\t\t\t\t\t\\\n+  if (TARGET_ARCH64)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       fprintf (FILE, \"\\trd %%pc,%%g1\\n\");\t\t\t\t\\\n       fprintf (FILE, \"\\tldx [%%g1+24],%%g5\\n\");\t\t\t\t\\\n@@ -1972,7 +2019,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Length in units of the trampoline for entering a nested function.  */\n \n-#define TRAMPOLINE_SIZE (TARGET_V9 ? 40 : 20)\n+#define TRAMPOLINE_SIZE (TARGET_ARCH64 ? 40 : 20)\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n@@ -1982,7 +2029,7 @@ void sparc_initialize_trampoline ();\n void sparc64_initialize_trampoline ();\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n   do {\t\t\t\t\t\t\t\t\\\n-    if (TARGET_V9)\t\t\t\t\t\t\\\n+    if (TARGET_ARCH64)\t\t\t\t\t\t\\\n       sparc64_initialize_trampoline (TRAMP, FNADDR, CXT);\t\\\n     else\t\t\t\t\t\t\t\\\n       sparc_initialize_trampoline (TRAMP, FNADDR, CXT);\t\t\\\n@@ -2013,7 +2060,8 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n \n /* This is the offset of the return address to the true next instruction to be\n    executed for the current function. */\n-#define RETURN_ADDR_OFFSET (8 + 4*(! TARGET_V9 && current_function_returns_struct))\n+#define RETURN_ADDR_OFFSET \\\n+  (8 + 4 * (! TARGET_ARCH64 && current_function_returns_struct))\n \n /* The current return address is in %i7.  The return address of anything\n    farther back is in the register window save area at [%fp+60].  */\n@@ -2131,9 +2179,9 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n        && ! symbolic_memory_operand (OP, VOIDmode))\t\\\n       || (reload_in_progress && GET_CODE (OP) == REG\t\\\n \t  && REGNO (OP) >= FIRST_PSEUDO_REGISTER))\t\\\n-   : ! TARGET_V9 && (C) == 'T'\t\t\t\\\n+   : (! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n    ? (mem_aligned_8 (OP))\t\t\t\t\\\n-   : ! TARGET_V9 && (C) == 'U'\t\t\t\t\t\t\\\n+   : (! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n    ? (register_ok_for_ldd (OP))\t\t\t\t\\\n    : 0)\n  \n@@ -2150,9 +2198,9 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n       ? (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n \t && reg_renumber[REGNO (OP)] < 0)\t\t\\\n       : GET_CODE (OP) == MEM)\t\t\t\t\\\n-   : ! TARGET_V9 && (C) == 'T'\t\t\t\\\n+   : (! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n    ? mem_aligned_8 (OP) && strict_memory_address_p (Pmode, XEXP (OP, 0)) \\\n-   : ! TARGET_V9 && (C) == 'U'\t\t\t\\\n+   : (! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n    ? (GET_CODE (OP) == REG\t\t\t\t\\\n       && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\t\\\n \t  || reg_renumber[REGNO (OP)] > 0)\t\t\\\n@@ -2395,8 +2443,8 @@ extern struct rtx_def *legitimize_pic_address ();\n    ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)\t\t\t\\\n    : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\t\\\n        || GET_CODE (X) == NEG || GET_CODE (X) == ASHIFT)\t\t\\\n-      ? (TARGET_V9 && GET_MODE (X) == DImode ? CCX_NOOVmode : CC_NOOVmode) \\\n-      : (TARGET_V9 && GET_MODE (X) == DImode ? CCXmode : CCmode)))\n+      ? (TARGET_ARCH64 && GET_MODE (X) == DImode ? CCX_NOOVmode : CC_NOOVmode) \\\n+      : (TARGET_ARCH64 && GET_MODE (X) == DImode ? CCXmode : CCmode)))\n \n /* Return non-zero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n@@ -2535,7 +2583,8 @@ extern struct rtx_def *legitimize_pic_address ();\n \n #define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n-    return (TARGET_V8 || TARGET_SPARCLITE || TARGET_V9) ? COSTS_N_INSNS (5) : COSTS_N_INSNS (25);\t\\\n+    return (TARGET_V8 || TARGET_SPARCLITE || TARGET_V9) \\\n+\t? COSTS_N_INSNS (5) : COSTS_N_INSNS (25);\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n@@ -2595,7 +2644,6 @@ extern struct rtx_def *legitimize_pic_address ();\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n-#ifdef SPARCV9\n #define REGISTER_NAMES \\\n {\"%g0\", \"%g1\", \"%g2\", \"%g3\", \"%g4\", \"%g5\", \"%g6\", \"%g7\",\t\t\\\n  \"%o0\", \"%o1\", \"%o2\", \"%o3\", \"%o4\", \"%o5\", \"%sp\", \"%o7\",\t\t\\\n@@ -2605,21 +2653,18 @@ extern struct rtx_def *legitimize_pic_address ();\n  \"%f8\", \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\t\t\\\n  \"%f16\", \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\t\\\n  \"%f24\", \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\",\t\\\n+ SPARC64_REGISTER_NAMES\t\t\t\t\t\t\t\\\n+}\n+\n+#if SPARC_V9\n+#define SPARC64_REGISTER_NAMES \\\n  \"%f32\", \"%f33\", \"%f34\", \"%f35\", \"%f36\", \"%f37\", \"%f38\", \"%f39\",\t\\\n  \"%f40\", \"%f41\", \"%f42\", \"%f43\", \"%f44\", \"%f45\", \"%f46\", \"%f47\",\t\\\n  \"%f48\", \"%f49\", \"%f50\", \"%f51\", \"%f52\", \"%f53\", \"%f54\", \"%f55\",\t\\\n  \"%f56\", \"%f57\", \"%f58\", \"%f59\", \"%f60\", \"%f61\", \"%f62\", \"%f63\",\t\\\n- \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\"}\n+ \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\"\n #else\n-#define REGISTER_NAMES \\\n-{\"%g0\", \"%g1\", \"%g2\", \"%g3\", \"%g4\", \"%g5\", \"%g6\", \"%g7\",\t\t\\\n- \"%o0\", \"%o1\", \"%o2\", \"%o3\", \"%o4\", \"%o5\", \"%sp\", \"%o7\",\t\t\\\n- \"%l0\", \"%l1\", \"%l2\", \"%l3\", \"%l4\", \"%l5\", \"%l6\", \"%l7\",\t\t\\\n- \"%i0\", \"%i1\", \"%i2\", \"%i3\", \"%i4\", \"%i5\", \"%fp\", \"%i7\",\t\t\\\n- \"%f0\", \"%f1\", \"%f2\", \"%f3\", \"%f4\", \"%f5\", \"%f6\", \"%f7\",\t\t\\\n- \"%f8\", \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\t\t\\\n- \"%f16\", \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\t\\\n- \"%f24\", \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\"}\n+#define SPARC64_REGISTER_NAMES\n #endif\n \n /* Define additional names for use in asm clobbers and asm declarations.\n@@ -2757,7 +2802,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\\n   if (Pmode == SImode)\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\\\n-  else if (TARGET_ENV32)\t\t\t\t\t\t\\\n+  else if (TARGET_MEDLOW)\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.word\\t0\\n\\t.word\\t\");\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.xword\\t\");\t\t\t\t\t\\\n@@ -2774,7 +2819,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\\n   if (Pmode == SImode)\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\\\n-  else if (TARGET_ENV32)\t\t\t\t\t\t\\\n+  else if (TARGET_MEDLOW)\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.word\\t0\\n\\t.word\\t\");\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.xword\\t\");\t\t\t\t\t\\"}]}