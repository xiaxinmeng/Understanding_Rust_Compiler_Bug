{"sha": "8e119f1b63d9de421ffdda86e8a710ba30b58d34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUxMTlmMWI2M2Q5ZGU0MjFmZmRkYTg2ZThhNzEwYmEzMGI1OGQzNA==", "commit": {"author": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-03-10T23:28:38Z"}, "committer": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-03-10T23:28:38Z"}, "message": "symbol.c (check_conflict): Allow allocatable function results, except for elemental functions.\n\nfortran/\n2006-03-11  Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        * symbol.c (check_conflict): Allow allocatable function results,\n        except for elemental functions.\n        * trans-array.c (gfc_trans_allocate_temp_array): Rename to ...\n        (gfc_trans_create_temp_array): ... this, and add new argument callee_alloc.\n        (gfc_trans_array_constructor, gfc_conv_loop_setup): Update call\n        to gfc_trans_allocate_temp_array.\n        * trans-array.h (gfc_trans_allocate_temp_array): Update prototype.\n        * trans-expr.c (gfc_conv_function_call): Use new arg of\n        gfc_trans_create_temp_array avoid pre-allocation of temporary\n        result variables of pointer AND allocatable functions.\n        (gfc_trans_arrayfunc_assign): Return NULL for allocatable functions.\n        * resolve.c (resolve_symbol): Copy value of 'allocatable' attribute\n        from sym->result to sym.\n\ntestsuite/\n2006-03-08  Paul Thomas  <pault@gcc.gnu.org>\n            Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        * gfortran.dg/allocatable_function_1.f90: New.\n        * gfortran.dg/allocatable_function_2.f90: New.\n\nFrom-SVN: r111951", "tree": {"sha": "df22f386bb6af80823879f5088a1bd3c99fb5e8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df22f386bb6af80823879f5088a1bd3c99fb5e8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e119f1b63d9de421ffdda86e8a710ba30b58d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e119f1b63d9de421ffdda86e8a710ba30b58d34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e119f1b63d9de421ffdda86e8a710ba30b58d34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e119f1b63d9de421ffdda86e8a710ba30b58d34/comments", "author": null, "committer": null, "parents": [{"sha": "ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea725d4524db8fa1bc593f5aa0e297a01ab721f3"}], "stats": {"total": 220, "additions": 193, "deletions": 27}, "files": [{"sha": "0f0f0492935ff57e091ab23ce289a48fe2c9ddc0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -1,3 +1,21 @@\n+2006-03-11  Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\t* symbol.c (check_conflict): Allow allocatable function results,\n+\t  except for elemental functions.\n+\t* trans-array.c (gfc_trans_allocate_temp_array): Rename to ...\n+\t  (gfc_trans_create_temp_array): ... this, and add new argument\n+\t  callee_alloc.\n+\t  (gfc_trans_array_constructor, gfc_conv_loop_setup): Update call\n+\t  to gfc_trans_allocate_temp_array.\n+\t* trans-array.h (gfc_trans_allocate_temp_array): Update prototype.\n+\t* trans-expr.c (gfc_conv_function_call): Use new arg of\n+\t  gfc_trans_create_temp_array avoid pre-allocation of temporary\n+\t  result variables of pointer AND allocatable functions.\n+\t  (gfc_trans_arrayfunc_assign): Return NULL for allocatable\n+\t  functions.\n+\t* resolve.c (resolve_symbol): Copy value of 'allocatable' attribute\n+\t  from sym->result to sym.\n+\n 2006-03-09  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \t* trans-expr.c (gfc_add_interface_mapping): Copy 'allocatable'"}, {"sha": "89c7770c0ac3282ac07b647006a850eccad98d22", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -1331,9 +1331,17 @@ Support for the declaration of enumeration constants via the\n @command{gcc} is guaranteed also for the case where the\n @command{-fshort-enums} command line option is given.\n \n+@item\n+@cindex TR 15581\n+The following parts of TR 15581:\n+@itemize\n @item\n @cindex @code{ALLOCATABLE} dummy arguments\n The @code{ALLOCATABLE} attribute for dummy arguments.\n+@item\n+@cindex @code{ALLOCATABLE} function results\n+@code{ALLOCATABLE} function results\n+@end itemize\n \n @end itemize\n "}, {"sha": "548b67ef7c5bb4d83e22b5c9528ced6400d764ab", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -5152,6 +5152,7 @@ resolve_symbol (gfc_symbol * sym)\n \t      sym->as = gfc_copy_array_spec (sym->result->as);\n \t      sym->attr.dimension = sym->result->attr.dimension;\n \t      sym->attr.pointer = sym->result->attr.pointer;\n+\t      sym->attr.allocatable = sym->result->attr.allocatable;\n \t    }\n \t}\n     }"}, {"sha": "bd7ad1c758a0c4cd563e10750033e110f24a314a", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -322,6 +322,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   conf (pointer, external);\n   conf (pointer, intrinsic);\n   conf (pointer, elemental);\n+  conf (allocatable, elemental);\n \n   conf (target, external);\n   conf (target, intrinsic);\n@@ -337,8 +338,8 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n \n   conf (allocatable, pointer);\n   conf_std (allocatable, dummy, GFC_STD_F2003);\n-  conf (allocatable, function);\t/* TODO: Allowed in Fortran 200x.  */\n-  conf (allocatable, result);\t/* TODO: Allowed in Fortran 200x.  */\n+  conf_std (allocatable, function, GFC_STD_F2003);\n+  conf_std (allocatable, result, GFC_STD_F2003);\n   conf (elemental, recursive);\n \n   conf (in_common, dummy);"}, {"sha": "15f49b5ad042983ee14b70072c20e78bd9100026", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -558,20 +558,24 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n }\n \n \n-/* Generate code to allocate and initialize the descriptor for a temporary\n+/* Generate code to create and initialize the descriptor for a temporary\n    array.  This is used for both temporaries needed by the scalarizer, and\n-   functions returning arrays.  Adjusts the loop variables to be zero-based,\n-   and calculates the loop bounds for callee allocated arrays.\n-   Also fills in the descriptor, data and offset fields of info if known.\n-   Returns the size of the array, or NULL for a callee allocated array.\n+   functions returning arrays.  Adjusts the loop variables to be\n+   zero-based, and calculates the loop bounds for callee allocated arrays.\n+   Allocate the array unless it's callee allocated (we have a callee\n+   allocated array if 'callee_alloc' is true, or if loop->to[n] is\n+   NULL_TREE for any n).  Also fills in the descriptor, data and offset\n+   fields of info if known.  Returns the size of the array, or NULL for a\n+   callee allocated array.\n \n    PRE, POST, DYNAMIC and DEALLOC are as for gfc_trans_allocate_array_storage.\n  */\n \n tree\n-gfc_trans_allocate_temp_array (stmtblock_t * pre, stmtblock_t * post,\n-                               gfc_loopinfo * loop, gfc_ss_info * info,\n-                               tree eltype, bool dynamic, bool dealloc)\n+gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n+\t\t\t     gfc_loopinfo * loop, gfc_ss_info * info,\n+\t\t\t     tree eltype, bool dynamic, bool dealloc,\n+\t\t\t     bool callee_alloc)\n {\n   tree type;\n   tree desc;\n@@ -662,12 +666,14 @@ gfc_trans_allocate_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   /* Get the size of the array.  */\n   nelem = size;\n-  if (size)\n+  if (size && !callee_alloc)\n     size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+  else\n+    size = NULL_TREE;\n \n   gfc_trans_allocate_array_storage (pre, post, info, size, nelem, dynamic,\n-                                    dealloc);\n+\t\t\t            dealloc);\n \n   if (info->dimen > loop->temp_dim)\n     loop->temp_dim = info->dimen;\n@@ -1417,8 +1423,8 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n       mpz_clear (size);\n     }\n \n-  gfc_trans_allocate_temp_array (&loop->pre, &loop->post, loop,\n-                                 &ss->data.info, type, dynamic, true);\n+  gfc_trans_create_temp_array (&loop->pre, &loop->post, loop, &ss->data.info,\n+\t\t\t       type, dynamic, true, false);\n \n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n@@ -2834,9 +2840,9 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n       memset (&loop->temp_ss->data.info, 0, sizeof (gfc_ss_info));\n       loop->temp_ss->type = GFC_SS_SECTION;\n       loop->temp_ss->data.info.dimen = n;\n-      gfc_trans_allocate_temp_array (&loop->pre, &loop->post, loop,\n-                                     &loop->temp_ss->data.info, tmp, false,\n-                                     true);\n+      gfc_trans_create_temp_array (&loop->pre, &loop->post, loop,\n+\t\t\t\t   &loop->temp_ss->data.info, tmp, false, true,\n+\t\t\t\t   false);\n     }\n \n   for (n = 0; n < loop->temp_dim; n++)"}, {"sha": "bc7cab54db32c01d5f23c3fa0261a2442ec76eb0", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -30,10 +30,9 @@ bool gfc_array_allocate (gfc_se *, gfc_expr *, tree);\n void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,\n \t\t\t\t\t  gfc_se *, gfc_array_spec *);\n \n-/* Generate code to allocate a temporary array.  */\n-tree gfc_trans_allocate_temp_array (stmtblock_t *, stmtblock_t *,\n-                                    gfc_loopinfo *, gfc_ss_info *, tree, bool,\n-                                    bool);\n+/* Generate code to create a temporary array.  */\n+tree gfc_trans_create_temp_array (stmtblock_t *, stmtblock_t *, gfc_loopinfo *,\n+                                  gfc_ss_info *, tree, bool, bool, bool);\n \n /* Generate function entry code for allocation of compiler allocated array\n    variables.  */"}, {"sha": "890b880158f628c93865f2f98cdcb2232f816b2a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -1805,6 +1805,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   gfc_formal_arglist *formal;\n   int has_alternate_specifier = 0;\n   bool need_interface_mapping;\n+  bool callee_alloc;\n   gfc_typespec ts;\n   gfc_charlen cl;\n \n@@ -1992,11 +1993,12 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  /* Evaluate the bounds of the result, if known.  */\n \t  gfc_set_loop_bounds_from_array_spec (&mapping, se, sym->result->as);\n \n-\t  /* Allocate a temporary to store the result.  In case the function\n-             returns a pointer, the temporary will be a shallow copy and\n-             mustn't be deallocated.  */\n-          gfc_trans_allocate_temp_array (&se->pre, &se->post, se->loop, info,\n-                                         tmp, false, !sym->attr.pointer);\n+\t  /* Create a temporary to store the result.  In case the function\n+\t     returns a pointer, the temporary will be a shallow copy and\n+\t     mustn't be deallocated.  */\n+\t  callee_alloc = sym->attr.allocatable || sym->attr.pointer;\n+\t  gfc_trans_create_temp_array (&se->pre, &se->post, se->loop, info, tmp,\n+\t\t\t\t       false, !sym->attr.pointer, callee_alloc);\n \n \t  /* Zero the first stride to indicate a temporary.  */\n \t  tmp = gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n@@ -2955,7 +2957,8 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n     return NULL;\n \n   /* Functions returning pointers need temporaries.  */\n-  if (expr2->symtree->n.sym->attr.pointer)\n+  if (expr2->symtree->n.sym->attr.pointer \n+      || expr2->symtree->n.sym->attr.allocatable)\n     return NULL;\n \n   /* Check that no LHS component references appear during an array"}, {"sha": "92724b034e7e4f0ab63a4a68f053f91c8e768ada", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -1,3 +1,9 @@\n+2006-03-11  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\t* gfortran.dg/allocatable_function_1.f90: New.\n+\t* gfortran.dg/allocatable_function_2.f90: New.\n+\n 2006-03-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/26565"}, {"sha": "b66d6ae182ee24467aba81129d94884cbb3e5bc4", "filename": "gcc/testsuite/gfortran.dg/allocatable_function_1.f90", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_1.f90?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -0,0 +1,112 @@\n+! { dg-do run }\n+! { dg-options \"-O2 -fdump-tree-original\" }\n+! Test ALLOCATABLE functions; the primary purpose here is to check that\n+! each of the various types of reference result in the function result\n+! being deallocated, using _gfortran_internal_free.\n+! The companion, allocatable_function_1r.f90, executes this program.\n+!\n+subroutine moobar (a)\n+    integer, intent(in) :: a(:)\n+\n+    if (.not.all(a == [ 1, 2, 3 ])) call abort()\n+end subroutine moobar\n+\n+function foo2 (n)\n+    integer, intent(in) :: n\n+    integer, allocatable :: foo2(:)\n+    integer :: i\n+    allocate (foo2(n))\n+    do i = 1, n\n+        foo2(i) = i\n+    end do\n+end function foo2\n+\n+module m\n+contains\n+    function foo3 (n)\n+        integer, intent(in) :: n\n+        integer, allocatable :: foo3(:)\n+        integer :: i\n+        allocate (foo3(n))\n+        do i = 1, n\n+            foo3(i) = i\n+        end do\n+    end function foo3\n+end module m\n+\n+program alloc_fun\n+\n+    use m\n+    implicit none\n+\n+    integer :: a(3)\n+\n+    interface\n+      subroutine moobar (a)\n+          integer, intent(in) :: a(:)\n+      end subroutine moobar\n+    end interface\n+\n+    interface\n+        function foo2 (n)\n+            integer, intent(in) :: n\n+            integer, allocatable :: foo2(:)\n+        end function foo2\n+    end interface\n+\n+! 2 _gfortran_internal_free's\n+    if (.not.all(foo1(3) == [ 1, 2, 3 ])) call abort()\n+    a = foo1(size(a))\n+\n+! 1 _gfortran_internal_free\n+    if (.not.all(a == [ 1, 2, 3 ])) call abort()\n+    call foobar(foo1(3))\n+\n+! 1 _gfortran_internal_free\n+    if (.not.all(2*bar(size(a)) + 5 == [ 7, 9, 11 ])) call abort()\n+\n+! The first reference never happens because the rhs determines the loop size.\n+! Thus there is no subsequent _gfortran_internal_free.\n+! 2 _gfortran_internal_free's\n+    a(1:size (bar (3))) = 2*bar(size(a)) + 2 + a(size (bar (3)))\n+    if (.not.all(a == [ 7, 9, 11 ])) call abort()\n+\n+! 3 _gfortran_internal_free's\n+    call moobar(foo1(3))   ! internal function\n+    call moobar(foo2(3))   ! module function\n+    call moobar(foo3(3))   ! explicit interface\n+\n+! 9 _gfortran_internal_free's in total\n+contains\n+\n+    subroutine foobar (a)\n+        integer, intent(in) :: a(:)\n+\n+        if (.not.all(a == [ 1, 2, 3 ])) call abort()\n+    end subroutine foobar\n+\n+    function foo1 (n)\n+        integer, intent(in) :: n\n+        integer, allocatable :: foo1(:)\n+        integer :: i\n+        allocate (foo1(n))\n+        do i = 1, n\n+            foo1(i) = i\n+        end do\n+    end function foo1\n+\n+    function bar (n) result(b)\n+        integer, intent(in) :: n\n+        integer, target, allocatable :: b(:)\n+        integer :: i\n+\n+        allocate (b(n))\n+        do i = 1, n\n+            b(i) = i\n+        end do\n+    end function bar\n+\n+end program alloc_fun\n+! { dg-final { scan-tree-dump-times \"free\" 9 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "ab26c2a04580a773f4ba1f6bd0ec44ebc19ca988", "filename": "gcc/testsuite/gfortran.dg/allocatable_function_2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e119f1b63d9de421ffdda86e8a710ba30b58d34/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_2.f90?ref=8e119f1b63d9de421ffdda86e8a710ba30b58d34", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! Test constraints on ALLOCATABLE functions\n+program alloc_fun\n+\n+contains\n+\n+    elemental function foo (n)\n+        integer, intent(in) :: n\n+        integer, allocatable :: foo(:) ! { dg-error \"ALLOCATABLE .* ELEMENTAL\" }\n+    end function foo\n+\n+end program alloc_fun"}]}