{"sha": "73e9d63709f920702a5fbaa5129e6216158b4420", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNlOWQ2MzcwOWY5MjA3MDJhNWZiYWE1MTI5ZTYyMTYxNThiNDQyMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-06-19T18:19:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-06-19T18:19:26Z"}, "message": "Handle const_vector in mulv4si3 for pre-sse4.1.\n\nFrom-SVN: r188787", "tree": {"sha": "8b4472f4957901c9e79476e3c84ad1af598850b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b4472f4957901c9e79476e3c84ad1af598850b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73e9d63709f920702a5fbaa5129e6216158b4420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e9d63709f920702a5fbaa5129e6216158b4420", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73e9d63709f920702a5fbaa5129e6216158b4420", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e9d63709f920702a5fbaa5129e6216158b4420/comments", "author": null, "committer": null, "parents": [{"sha": "84ddb6810c3954096c6f438a3566b6e28220e9d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84ddb6810c3954096c6f438a3566b6e28220e9d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84ddb6810c3954096c6f438a3566b6e28220e9d3"}], "stats": {"total": 165, "additions": 106, "deletions": 59}, "files": [{"sha": "8b328197cd66acc4e4e514401b37b3cda52d8e32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73e9d63709f920702a5fbaa5129e6216158b4420", "patch": "@@ -1,3 +1,12 @@\n+2012-06-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386-protos.h (ix86_expand_sse2_mulv4si3): Declare.\n+\t* config/i386/i386.c (ix86_expand_sse2_mulv4si3): New.\n+\t* config/i386/predicates.md (nonimmediate_or_const_vector_operand): New.\n+\t* config/i386/sse.md (sse2_mulv4si3): Delete.\n+\t(mul<VI4_AVX2>3): Use ix86_expand_sse2_mulv4si3 and\n+\tnonimmediate_or_const_vector_operand.\n+\n 2012-06-19  Richard Henderson  <rth@redhat.com>\n \n \t* expmed.c (struct init_expmed_rtl): Split ..."}, {"sha": "431db6c8cf567c42914a40c73d10bc97b0f58808", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=73e9d63709f920702a5fbaa5129e6216158b4420", "patch": "@@ -222,6 +222,7 @@ extern void ix86_expand_reduc (rtx (*)(rtx, rtx, rtx), rtx, rtx);\n \n extern void ix86_expand_vec_extract_even_odd (rtx, rtx, rtx, unsigned);\n extern bool ix86_expand_pinsr (rtx *);\n+extern void ix86_expand_sse2_mulv4si3 (rtx, rtx, rtx);\n \n /* In i386-c.c  */\n extern void ix86_target_macros (void);"}, {"sha": "0dc08f3aa3abeffb0ffca90ee1ebd47da19a59a4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=73e9d63709f920702a5fbaa5129e6216158b4420", "patch": "@@ -38438,6 +38438,82 @@ ix86_expand_vec_extract_even_odd (rtx targ, rtx op0, rtx op1, unsigned odd)\n   expand_vec_perm_even_odd_1 (&d, odd);\n }\n \n+void\n+ix86_expand_sse2_mulv4si3 (rtx op0, rtx op1, rtx op2)\n+{\n+  rtx op1_m1, op1_m2;\n+  rtx op2_m1, op2_m2;\n+  rtx res_1, res_2;\n+\n+  /* Shift both input vectors down one element, so that elements 3\n+     and 1 are now in the slots for elements 2 and 0.  For K8, at\n+     least, this is faster than using a shuffle.  */\n+  op1_m1 = op1 = force_reg (V4SImode, op1);\n+  op1_m2 = gen_reg_rtx (V4SImode);\n+  emit_insn (gen_sse2_lshrv1ti3 (gen_lowpart (V1TImode, op1_m2),\n+\t\t\t\t gen_lowpart (V1TImode, op1),\n+\t\t\t\t GEN_INT (32)));\n+\n+  if (GET_CODE (op2) == CONST_VECTOR)\n+    {\n+      rtvec v;\n+\n+      /* Constant propagate the vector shift, leaving the dont-care\n+\t vector elements as zero.  */\n+      v = rtvec_alloc (4);\n+      RTVEC_ELT (v, 0) = CONST_VECTOR_ELT (op2, 0);\n+      RTVEC_ELT (v, 2) = CONST_VECTOR_ELT (op2, 2);\n+      RTVEC_ELT (v, 1) = const0_rtx;\n+      RTVEC_ELT (v, 3) = const0_rtx;\n+      op2_m1 = gen_rtx_CONST_VECTOR (V4SImode, v);\n+      op2_m1 = force_reg (V4SImode, op2_m1);\n+\n+      v = rtvec_alloc (4);\n+      RTVEC_ELT (v, 0) = CONST_VECTOR_ELT (op2, 1);\n+      RTVEC_ELT (v, 2) = CONST_VECTOR_ELT (op2, 3);\n+      RTVEC_ELT (v, 1) = const0_rtx;\n+      RTVEC_ELT (v, 3) = const0_rtx;\n+      op2_m2 = gen_rtx_CONST_VECTOR (V4SImode, v);\n+      op2_m2 = force_reg (V4SImode, op2_m2);\n+    }\n+  else\n+    {\n+      op2_m1 = op2 = force_reg (V4SImode, op2);\n+      op2_m2 = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_sse2_lshrv1ti3 (gen_lowpart (V1TImode, op2_m2),\n+\t\t\t\t     gen_lowpart (V1TImode, op2),\n+\t\t\t\t     GEN_INT (32)));\n+    }\n+\n+  /* Widening multiply of elements 0+2, and 1+3.  */\n+  res_1 = gen_reg_rtx (V4SImode);\n+  res_2 = gen_reg_rtx (V4SImode);\n+  emit_insn (gen_sse2_umulv2siv2di3 (gen_lowpart (V2DImode, res_1),\n+\t\t\t\t     op1_m1, op2_m1));\n+  emit_insn (gen_sse2_umulv2siv2di3 (gen_lowpart (V2DImode, res_2),\n+\t\t\t\t     op1_m2, op2_m2));\n+\n+  /* Move the results in element 2 down to element 1; we don't care\n+     what goes in elements 2 and 3.  Then we can merge the parts\n+     back together with an interleave.\n+\n+     Note that two other sequences were tried:\n+     (1) Use interleaves at the start instead of psrldq, which allows\n+     us to use a single shufps to merge things back at the end.\n+     (2) Use shufps here to combine the two vectors, then pshufd to\n+     put the elements in the correct order.\n+     In both cases the cost of the reformatting stall was too high\n+     and the overall sequence slower.  */\n+\n+  emit_insn (gen_sse2_pshufd_1 (res_1, res_1, const0_rtx, const2_rtx,\n+\t\t\t\tconst0_rtx, const0_rtx));\n+  emit_insn (gen_sse2_pshufd_1 (res_2, res_2, const0_rtx, const2_rtx,\n+\t\t\t\tconst0_rtx, const0_rtx));\n+  res_1 = emit_insn (gen_vec_interleave_lowv4si (op0, res_1, res_2));\n+\n+  set_unique_reg_note (res_1, REG_EQUAL, gen_rtx_MULT (V4SImode, op1, op2));\n+}\n+\n /* Expand an insert into a vector register through pinsr insn.\n    Return true if successful.  */\n "}, {"sha": "f23e932d9f1778e3241c8e32adb473ab5733ee5d", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=73e9d63709f920702a5fbaa5129e6216158b4420", "patch": "@@ -816,6 +816,13 @@\n   return false;\n })\n \n+;; Return true when OP is a nonimmediate or a vector constant.  Note\n+;; that most vector constants are not legitimate operands, so we need\n+;; to special-case this.\n+(define_predicate \"nonimmediate_or_const_vector_operand\"\n+  (ior (match_code \"const_vector\")\n+       (match_operand 0 \"nonimmediate_operand\")))\n+\n ;; Return true if OP is a register or a zero.\n (define_predicate \"reg_or_0_operand\"\n   (ior (match_operand 0 \"register_operand\")"}, {"sha": "6c54d33113b832baa68b45ddfbd68f2a0c261e78", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 13, "deletions": 59, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e9d63709f920702a5fbaa5129e6216158b4420/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=73e9d63709f920702a5fbaa5129e6216158b4420", "patch": "@@ -5610,12 +5610,22 @@\n \n (define_expand \"mul<mode>3\"\n   [(set (match_operand:VI4_AVX2 0 \"register_operand\")\n-\t(mult:VI4_AVX2 (match_operand:VI4_AVX2 1 \"register_operand\")\n-\t\t       (match_operand:VI4_AVX2 2 \"register_operand\")))]\n+\t(mult:VI4_AVX2\n+\t  (match_operand:VI4_AVX2 1 \"nonimmediate_operand\")\n+\t  (match_operand:VI4_AVX2 2 \"nonimmediate_or_const_vector_operand\")))]\n   \"TARGET_SSE2\"\n {\n   if (TARGET_SSE4_1 || TARGET_AVX)\n-    ix86_fixup_binary_operands_no_copy (MULT, <MODE>mode, operands);\n+    {\n+      if (CONSTANT_P (operands[2]))\n+\toperands[2] = force_const_mem (<MODE>mode, operands[2]);\n+      ix86_fixup_binary_operands_no_copy (MULT, <MODE>mode, operands);\n+    }\n+  else\n+    {\n+      ix86_expand_sse2_mulv4si3 (operands[0], operands[1], operands[2]);\n+      DONE;\n+    }\n })\n \n (define_insn \"*<sse4_1_avx2>_mul<mode>3\"\n@@ -5633,62 +5643,6 @@\n    (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn_and_split \"*sse2_mulv4si3\"\n-  [(set (match_operand:V4SI 0 \"register_operand\")\n-\t(mult:V4SI (match_operand:V4SI 1 \"register_operand\")\n-\t\t   (match_operand:V4SI 2 \"register_operand\")))]\n-  \"TARGET_SSE2 && !TARGET_SSE4_1 && !TARGET_AVX\n-   && can_create_pseudo_p ()\"\n-  \"#\"\n-  \"&& 1\"\n-  [(const_int 0)]\n-{\n-  rtx t1, t2, t3, t4, t5, t6, thirtytwo;\n-  rtx op0, op1, op2;\n-\n-  op0 = operands[0];\n-  op1 = operands[1];\n-  op2 = operands[2];\n-  t1 = gen_reg_rtx (V4SImode);\n-  t2 = gen_reg_rtx (V4SImode);\n-  t3 = gen_reg_rtx (V4SImode);\n-  t4 = gen_reg_rtx (V4SImode);\n-  t5 = gen_reg_rtx (V4SImode);\n-  t6 = gen_reg_rtx (V4SImode);\n-  thirtytwo = GEN_INT (32);\n-\n-  /* Multiply elements 2 and 0.  */\n-  emit_insn (gen_sse2_umulv2siv2di3 (gen_lowpart (V2DImode, t1),\n-\t\t\t\t     op1, op2));\n-\n-  /* Shift both input vectors down one element, so that elements 3\n-     and 1 are now in the slots for elements 2 and 0.  For K8, at\n-     least, this is faster than using a shuffle.  */\n-  emit_insn (gen_sse2_lshrv1ti3 (gen_lowpart (V1TImode, t2),\n-\t\t\t\t gen_lowpart (V1TImode, op1),\n-\t\t\t\t thirtytwo));\n-  emit_insn (gen_sse2_lshrv1ti3 (gen_lowpart (V1TImode, t3),\n-\t\t\t\t gen_lowpart (V1TImode, op2),\n-\t\t\t\t thirtytwo));\n-  /* Multiply elements 3 and 1.  */\n-  emit_insn (gen_sse2_umulv2siv2di3 (gen_lowpart (V2DImode, t4),\n-\t\t\t\t     t2, t3));\n-\n-  /* Move the results in element 2 down to element 1; we don't care\n-     what goes in elements 2 and 3.  */\n-  emit_insn (gen_sse2_pshufd_1 (t5, t1, const0_rtx, const2_rtx,\n-\t\t\t\tconst0_rtx, const0_rtx));\n-  emit_insn (gen_sse2_pshufd_1 (t6, t4, const0_rtx, const2_rtx,\n-\t\t\t\tconst0_rtx, const0_rtx));\n-\n-  /* Merge the parts back together.  */\n-  emit_insn (gen_vec_interleave_lowv4si (op0, t5, t6));\n-\n-  set_unique_reg_note (get_last_insn (), REG_EQUAL,\n-\t\t       gen_rtx_MULT (V4SImode, operands[1], operands[2]));\n-  DONE;\n-})\n-\n (define_insn_and_split \"mul<mode>3\"\n   [(set (match_operand:VI8_AVX2 0 \"register_operand\")\n \t(mult:VI8_AVX2 (match_operand:VI8_AVX2 1 \"register_operand\")"}]}