{"sha": "a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdiNjI2ZDk4YTlhODIxZmZiMzM0NjY4MThkNmFhODZjYWMxZDZmZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-08T09:25:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-08T09:25:31Z"}, "message": "i386: Fix up @xorsign<mode>3_1 [PR102224]\n\nAs the testcase shows, we miscompile @xorsign<mode>3_1 if both input\noperands are in the same register, because the splitter overwrites op1\nbefore with op1 & mask before using op0.\n\nFor dest = xorsign op0, op0 we can actually simplify it from\ndest = (op0 & mask) ^ op0 to dest = op0 & ~mask (aka abs).\n\nThe expander change is an optimization improvement, if we at expansion\ntime know it is xorsign op0, op0, we can emit abs right away and get better\ncode through that.\n\nThe @xorsign<mode>3_1 is a fix for the case where xorsign wouldn't be known\nto have same operands during expansion, but during RTL optimizations they\nwould appear.  For non-AVX we need to use earlyclobber, we require\ndest and op1 to be the same but op0 must be different because we overwrite\nop1 first.  For AVX the constraints ensure that at most 2 of the 3 operands\nmay be the same register and if both inputs are the same, handles that case.\nThis case can be easily tested with the xorsign<mode>3 expander change\nreverted.\n\nBootstrapped/regtested on x86_64-linux and i686-linux, ok for trunk?\n\nThinking about it more this morning, while this patch fixes the problems\nrevealed in the testcase, the recent PR89984 change was buggy too, but\nperhaps that can be fixed incrementally.  Because for AVX the new code\ndestructively modifies op1.  If that is different from dest, say on:\nfloat\nfoo (float x, float y)\n{\n  return x * __builtin_copysignf (1.0f, y) + y;\n}\nthen we get after RA:\n(insn 8 7 9 2 (set (reg:SF 20 xmm0 [orig:82 _2 ] [82])\n        (unspec:SF [\n                (reg:SF 20 xmm0 [88])\n                (reg:SF 21 xmm1 [89])\n                (mem/u/c:V4SF (symbol_ref/u:DI (\"*.LC0\") [flags 0x2]) [0  S16 A128])\n            ] UNSPEC_XORSIGN)) \"hohoho.c\":4:12 649 {xorsignsf3_1}\n     (nil))\n(insn 9 8 15 2 (set (reg:SF 20 xmm0 [87])\n        (plus:SF (reg:SF 20 xmm0 [orig:82 _2 ] [82])\n            (reg:SF 21 xmm1 [89]))) \"hohoho.c\":4:44 1021 {*fop_sf_comm}\n     (nil))\nbut split the xorsign into:\n        vandps  .LC0(%rip), %xmm1, %xmm1\n        vxorps  %xmm0, %xmm1, %xmm0\nand then the addition:\n        vaddss  %xmm1, %xmm0, %xmm0\nwhich means we miscompile it - instead of adding y in the end we add\n__builtin_copysignf (0.0f, y).\nSo, wonder if we don't want instead in addition to the &Yv <- Yv, 0\nalternative (enabled for both pre-AVX and AVX as in this patch) the\n&Yv <- Yv, Yv where destination must be different from inputs and another\nYv <- Yv, Yv where it can be the same but then need a match_scratch\n(with X for the other alternatives and =Yv for the last one).\nThat way we'd always have a safe register we can store the op1 & mask\nvalue into, either the destination (in the first alternative known to\nbe equal to op1 which is needed for non-AVX but ok for AVX too), in the\nsecond alternative known to be different from both inputs and in the third\nwhich could be used for those\nfloat bar (float x, float y) { return x * __builtin_copysignf (1.0f, y); }\ncases where op1 is naturally xmm1 and dest == op0 naturally xmm0 we'd use\nsome other register like xmm2.\n\n2021-09-08  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/102224\n\t* config/i386/i386.md (xorsign<mode>3): If operands[1] is equal to\n\toperands[2], emit abs<mode>2 instead.\n\t(@xorsign<mode>3_1): Add early-clobbers for output operand, enable\n\tfirst alternative even for avx, add another alternative with\n\t=&Yv <- 0, Yv, Yvm constraints.\n\t* config/i386/i386-expand.c (ix86_split_xorsign): If op0 is equal\n\tto op1, emit vpandn instead.\n\n\t* gcc.dg/pr102224.c: New test.\n\t* gcc.target/i386/avx-pr102224.c: New test.", "tree": {"sha": "7d986bfc4994ffe3ef04b6e724b11a2c60147816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d986bfc4994ffe3ef04b6e724b11a2c60147816"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a61bcaca074e967f694b30b484671aaeec190ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a61bcaca074e967f694b30b484671aaeec190ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a61bcaca074e967f694b30b484671aaeec190ff"}], "stats": {"total": 127, "additions": 116, "deletions": 11}, "files": [{"sha": "0cc572c49034703d4b9c819486116c4ed7823ca2", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "patch": "@@ -2306,12 +2306,39 @@ ix86_split_xorsign (rtx operands[])\n   mode = GET_MODE (dest);\n   vmode = GET_MODE (mask);\n \n-  op1 = lowpart_subreg (vmode, op1, mode);\n-  x = gen_rtx_AND (vmode, op1, mask);\n-  emit_insn (gen_rtx_SET (op1, x));\n+  /* The constraints ensure that for non-AVX dest == op1 is\n+     different from op0, and for AVX that at most two of\n+     dest, op0 and op1 are the same register but the third one\n+     is different.  */\n+  if (rtx_equal_p (op0, op1))\n+    {\n+      gcc_assert (TARGET_AVX && !rtx_equal_p (op0, dest));\n+      if (vmode == V4SFmode)\n+\tvmode = V4SImode;\n+      else\n+\t{\n+\t  gcc_assert (vmode == V2DFmode);\n+\t  vmode = V2DImode;\n+\t}\n+      mask = lowpart_subreg (vmode, mask, GET_MODE (mask));\n+      if (MEM_P (mask))\n+\t{\n+\t  rtx msk = lowpart_subreg (vmode, dest, mode);\n+\t  emit_insn (gen_rtx_SET (msk, mask));\n+\t  mask = msk;\n+\t}\n+      op0 = lowpart_subreg (vmode, op0, mode);\n+      x = gen_rtx_AND (vmode, gen_rtx_NOT (vmode, mask), op0);\n+    }\n+  else\n+    {\n+      op1 = lowpart_subreg (vmode, op1, mode);\n+      x = gen_rtx_AND (vmode, op1, mask);\n+      emit_insn (gen_rtx_SET (op1, x));\n \n-  op0 = lowpart_subreg (vmode, op0, mode);\n-  x = gen_rtx_XOR (vmode, op1, op0);\n+      op0 = lowpart_subreg (vmode, op0, mode);\n+      x = gen_rtx_XOR (vmode, op1, op0);\n+    }\n \n   dest = lowpart_subreg (vmode, dest, mode);\n   emit_insn (gen_rtx_SET (dest, x));"}, {"sha": "0414f24949eed62397ac52cf226f03f064f91850", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "patch": "@@ -10910,21 +10910,27 @@\n    (match_operand:MODEF 1 \"register_operand\")\n    (match_operand:MODEF 2 \"register_operand\")]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"ix86_expand_xorsign (operands); DONE;\")\n+{\n+  if (rtx_equal_p (operands[1], operands[2]))\n+    emit_insn (gen_abs<mode>2 (operands[0], operands[1]));\n+  else\n+    ix86_expand_xorsign (operands);\n+  DONE;\n+})\n \n (define_insn_and_split \"@xorsign<mode>3_1\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=Yv,Yv\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=&Yv,&Yv,&Yv\")\n \t(unspec:MODEF\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"Yv,Yv\")\n-\t   (match_operand:MODEF 2 \"register_operand\" \"0,Yv\")\n-\t   (match_operand:<ssevecmode> 3 \"nonimmediate_operand\" \"Yvm,Yvm\")]\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"Yv,0,Yv\")\n+\t   (match_operand:MODEF 2 \"register_operand\" \"0,Yv,Yv\")\n+\t   (match_operand:<ssevecmode> 3 \"nonimmediate_operand\" \"Yvm,Yvm,Yvm\")]\n \t  UNSPEC_XORSIGN))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n   \"ix86_split_xorsign (operands); DONE;\"\n-  [(set_attr \"isa\" \"noavx,avx\")])\n+  [(set_attr \"isa\" \"*,avx,avx\")])\n \f\n ;; One complement instructions\n "}, {"sha": "9f09ba5ccbb7b066be3c3a2787057c4a3e8fc676", "filename": "gcc/testsuite/gcc.dg/pr102224.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102224.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102224.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr102224.c?ref=a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "patch": "@@ -0,0 +1,49 @@\n+/* PR target/102224 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+__attribute__((noipa)) float\n+foo (float x)\n+{\n+  return x * __builtin_copysignf (1.0f, x);\n+}\n+\n+__attribute__((noipa)) float\n+bar (float x, float y)\n+{\n+  return x * __builtin_copysignf (1.0f, y);\n+}\n+\n+__attribute__((noipa)) float\n+baz (float z, float x)\n+{\n+  return x * __builtin_copysignf (1.0f, x);\n+}\n+\n+__attribute__((noipa)) float\n+qux (float z, float x, float y)\n+{\n+  return x * __builtin_copysignf (1.0f, y);\n+}\n+\n+int\n+main ()\n+{\n+  if (foo (1.0f) != 1.0f\n+      || foo (-4.0f) != 4.0f)\n+    __builtin_abort ();\n+  if (bar (1.25f, 7.25f) != 1.25f\n+      || bar (1.75f, -3.25f) != -1.75f\n+      || bar (-2.25f, 7.5f) != -2.25f\n+      || bar (-3.0f, -4.0f) != 3.0f)\n+    __builtin_abort ();\n+  if (baz (5.5f, 1.0f) != 1.0f\n+      || baz (4.25f, -4.0f) != 4.0f)\n+    __builtin_abort ();\n+  if (qux (1.0f, 1.25f, 7.25f) != 1.25f\n+      || qux (2.0f, 1.75f, -3.25f) != -1.75f\n+      || qux (3.0f, -2.25f, 7.5f) != -2.25f\n+      || qux (4.0f, -3.0f, -4.0f) != 3.0f)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "be6b88c05db61dea40af398b2af7e7a68770bff5", "filename": "gcc/testsuite/gcc.target/i386/avx-pr102224.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr102224.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b626d98a9a821ffb33466818d6aa86cac1d6fd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr102224.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr102224.c?ref=a7b626d98a9a821ffb33466818d6aa86cac1d6fd", "patch": "@@ -0,0 +1,23 @@\n+/* PR tree-optimization/51581 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-require-effective-target avx } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"avx-check.h\"\n+#endif\n+#ifndef TEST\n+#define TEST avx_test\n+#endif\n+\n+#define main main1\n+#include \"../../gcc.dg/pr102224.c\"\n+#undef main\n+\n+#include CHECK_H\n+\n+static void\n+TEST (void)\n+{\n+  main1 ();\n+}"}]}