{"sha": "5e0216f173c1bef5bec3e709345d8170b1484d2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUwMjE2ZjE3M2MxYmVmNWJlYzNlNzA5MzQ1ZDgxNzBiMTQ4NGQyZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-03-18T10:53:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-03-18T10:53:38Z"}, "message": "acinclude.m4 (GLIBCXX_CHECK_GTHREADS): Check for pthread_rwlock_t.\n\n2015-03-18  Jonathan Wakely  <jwakely@redhat.com>\n\t    Torvald Riegel  <triegel@redhat.com>\n\n\t* acinclude.m4 (GLIBCXX_CHECK_GTHREADS): Check for pthread_rwlock_t.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* include/std/shared_mutex: Check _GLIBCXX_USE_PTHREAD_RWLOCK_T.\n\t(shared_timed_mutex::_M_rwlock): Use PTHREAD_RWLOCK_INITIALIZER.\n\t(shared_timed_mutex::lock_shared()): Retry on EAGAIN.\n\t(shared_timed_mutex::try_lock_shared_until()): Retry on EAGAIN and\n\tEDEADLK.\n\nCo-Authored-By: Torvald Riegel <triegel@redhat.com>\n\nFrom-SVN: r221484", "tree": {"sha": "589296fb247ee2147b0d907485aa46457dc7a4c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/589296fb247ee2147b0d907485aa46457dc7a4c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e0216f173c1bef5bec3e709345d8170b1484d2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0216f173c1bef5bec3e709345d8170b1484d2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e0216f173c1bef5bec3e709345d8170b1484d2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0216f173c1bef5bec3e709345d8170b1484d2f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41cee85a347099bbd151f46cc55f8974970624ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41cee85a347099bbd151f46cc55f8974970624ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41cee85a347099bbd151f46cc55f8974970624ba"}], "stats": {"total": 157, "additions": 134, "deletions": 23}, "files": [{"sha": "ae6445e3b864dd92f88b2c314e9b09ac6bb33850", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5e0216f173c1bef5bec3e709345d8170b1484d2f", "patch": "@@ -1,3 +1,15 @@\n+2015-03-18  Jonathan Wakely  <jwakely@redhat.com>\n+\t    Torvald Riegel  <triegel@redhat.com>\n+\n+\t* acinclude.m4 (GLIBCXX_CHECK_GTHREADS): Check for pthread_rwlock_t.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* include/std/shared_mutex: Check _GLIBCXX_USE_PTHREAD_RWLOCK_T.\n+\t(shared_timed_mutex::_M_rwlock): Use PTHREAD_RWLOCK_INITIALIZER.\n+\t(shared_timed_mutex::lock_shared()): Retry on EAGAIN.\n+\t(shared_timed_mutex::try_lock_shared_until()): Retry on EAGAIN and\n+\tEDEADLK.\n+\n 2015-03-17  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* libsupc++/nested_exception.h: Do not try to derive from final"}, {"sha": "74f5a652fb7f7da51b2c2e46a031da5ecbfcfd66", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=5e0216f173c1bef5bec3e709345d8170b1484d2f", "patch": "@@ -3563,6 +3563,13 @@ AC_DEFUN([GLIBCXX_CHECK_GTHREADS], [\n   if test x\"$ac_has_gthreads\" = x\"yes\"; then\n     AC_DEFINE(_GLIBCXX_HAS_GTHREADS, 1,\n \t      [Define if gthreads library is available.])\n+\n+    # Also check for pthread_rwlock_t for std::shared_timed_mutex in C++14\n+    AC_CHECK_TYPE([pthread_rwlock_t],\n+            [AC_DEFINE([_GLIBCXX_USE_PTHREAD_RWLOCK_T], 1,\n+            [Define if POSIX read/write locks are available in <gthr.h>.])],\n+            [],\n+            [#include \"gthr.h\"])\n   fi\n \n   CXXFLAGS=\"$ac_save_CXXFLAGS\""}, {"sha": "26ccd22de2df6b341d254539269a3050d15ae3cf", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=5e0216f173c1bef5bec3e709345d8170b1484d2f", "patch": "@@ -851,6 +851,9 @@\n /* Define if pthreads_num_processors_np is available in <pthread.h>. */\n #undef _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP\n \n+/* Define if POSIX read/write locks are available in <gthr.h>. */\n+#undef _GLIBCXX_USE_PTHREAD_RWLOCK_T\n+\n /* Define if /dev/random and /dev/urandom are available for the random_device\n    of TR1 (Chapter 5.1). */\n #undef _GLIBCXX_USE_RANDOM_TR1"}, {"sha": "2507ff7e490b3e7fbbc7e619d1abb0a63f9631b5", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=5e0216f173c1bef5bec3e709345d8170b1484d2f", "patch": "@@ -2498,6 +2498,60 @@ $as_echo \"$ac_res\" >&6; }\n   eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n \n } # ac_fn_c_check_type\n+\n+# ac_fn_cxx_check_type LINENO TYPE VAR INCLUDES\n+# ---------------------------------------------\n+# Tests whether TYPE exists after having included INCLUDES, setting cache\n+# variable VAR accordingly.\n+ac_fn_cxx_check_type ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n+$as_echo_n \"checking for $2... \" >&6; }\n+if { as_var=$3; eval \"test \\\"\\${$as_var+set}\\\" = set\"; }; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  eval \"$3=no\"\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+if (sizeof ($2))\n+\t return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+if (sizeof (($2)))\n+\t    return 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+\n+else\n+  eval \"$3=yes\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+\n+} # ac_fn_cxx_check_type\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n@@ -11539,7 +11593,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11542 \"configure\"\n+#line 11596 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11645,7 +11699,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11648 \"configure\"\n+#line 11702 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -15065,7 +15119,7 @@ fi\n     #\n     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n     cat > conftest.$ac_ext << EOF\n-#line 15068 \"configure\"\n+#line 15122 \"configure\"\n struct S { ~S(); };\n void bar();\n void foo()\n@@ -15417,7 +15471,7 @@ $as_echo \"$glibcxx_cv_atomic_long_long\" >&6; }\n   # Fake what AC_TRY_COMPILE does.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15420 \"configure\"\n+#line 15474 \"configure\"\n int main()\n {\n   typedef bool atomic_type;\n@@ -15452,7 +15506,7 @@ $as_echo \"$glibcxx_cv_atomic_bool\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15455 \"configure\"\n+#line 15509 \"configure\"\n int main()\n {\n   typedef short atomic_type;\n@@ -15487,7 +15541,7 @@ $as_echo \"$glibcxx_cv_atomic_short\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15490 \"configure\"\n+#line 15544 \"configure\"\n int main()\n {\n   // NB: _Atomic_word not necessarily int.\n@@ -15523,7 +15577,7 @@ $as_echo \"$glibcxx_cv_atomic_int\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15526 \"configure\"\n+#line 15580 \"configure\"\n int main()\n {\n   typedef long long atomic_type;\n@@ -15602,7 +15656,7 @@ $as_echo \"$as_me: WARNING: Performance of certain classes will degrade as a resu\n   # unnecessary for this test.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15605 \"configure\"\n+#line 15659 \"configure\"\n int main()\n {\n   _Decimal32 d1;\n@@ -15644,7 +15698,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n   # unnecessary for this test.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15647 \"configure\"\n+#line 15701 \"configure\"\n template<typename T1, typename T2>\n   struct same\n   { typedef T2 type; };\n@@ -15678,7 +15732,7 @@ $as_echo \"$enable_int128\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15681 \"configure\"\n+#line 15735 \"configure\"\n template<typename T1, typename T2>\n   struct same\n   { typedef T2 type; };\n@@ -78786,6 +78840,16 @@ $as_echo \"$ac_has_gthreads\" >&6; }\n \n $as_echo \"#define _GLIBCXX_HAS_GTHREADS 1\" >>confdefs.h\n \n+\n+    # Also check for pthread_rwlock_t for std::shared_timed_mutex in C++14\n+    ac_fn_cxx_check_type \"$LINENO\" \"pthread_rwlock_t\" \"ac_cv_type_pthread_rwlock_t\" \"#include \\\"gthr.h\\\"\n+\"\n+if test \"x$ac_cv_type_pthread_rwlock_t\" = x\"\"yes; then :\n+\n+$as_echo \"#define _GLIBCXX_USE_PTHREAD_RWLOCK_T 1\" >>confdefs.h\n+\n+fi\n+\n   fi\n \n   CXXFLAGS=\"$ac_save_CXXFLAGS\""}, {"sha": "ab1b45b87acd76bdc231992d253511cb91ac8f0a", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0216f173c1bef5bec3e709345d8170b1484d2f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=5e0216f173c1bef5bec3e709345d8170b1484d2f", "patch": "@@ -57,10 +57,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// shared_timed_mutex\n   class shared_timed_mutex\n   {\n-#if defined(__GTHREADS_CXX0X)\n+#ifdef _GLIBCXX_USE_PTHREAD_RWLOCK_T\n     typedef chrono::system_clock\t__clock_t;\n \n-    pthread_rwlock_t\t\t\t_M_rwlock;\n+#ifdef PTHREAD_RWLOCK_INITIALIZER\n+    pthread_rwlock_t\t_M_rwlock = PTHREAD_RWLOCK_INITIALIZER;\n+\n+  public:\n+    shared_timed_mutex() = default;\n+    ~shared_timed_mutex() = default;\n+#else\n+    pthread_rwlock_t\t_M_rwlock;\n \n   public:\n     shared_timed_mutex()\n@@ -82,6 +89,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Errors not handled: EBUSY, EINVAL\n       _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n     }\n+#endif\n \n     shared_timed_mutex(const shared_timed_mutex&) = delete;\n     shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;\n@@ -165,12 +173,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     lock_shared()\n     {\n-      int __ret = pthread_rwlock_rdlock(&_M_rwlock);\n+      int __ret;\n+      // We retry if we exceeded the maximum number of read locks supported by\n+      // the POSIX implementation; this can result in busy-waiting, but this\n+      // is okay based on the current specification of forward progress\n+      // guarantees by the standard.\n+      do\n+\t__ret = pthread_rwlock_rdlock(&_M_rwlock);\n+      while (__ret == EAGAIN);\n       if (__ret == EDEADLK)\n \t__throw_system_error(int(errc::resource_deadlock_would_occur));\n-      if (__ret == EAGAIN)\n-\t// Maximum number of read locks has been exceeded.\n-\t__throw_system_error(int(errc::device_or_resource_busy));\n       // Errors not handled: EINVAL\n       _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n     }\n@@ -210,11 +222,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    static_cast<long>(__ns.count())\n \t  };\n \n-\tint __ret = pthread_rwlock_timedrdlock(&_M_rwlock, &__ts);\n-\t// If the maximum number of read locks has been exceeded, or we would\n-\t// deadlock, we just fail to acquire the lock.  Unlike for lock(),\n-\t// we are not allowed to throw an exception.\n-\tif (__ret == ETIMEDOUT || __ret == EAGAIN || __ret == EDEADLK)\n+\tint __ret;\n+\t// Unlike for lock(), we are not allowed to throw an exception so if\n+\t// the maximum number of read locks has been exceeded, or we would\n+\t// deadlock, we just try to acquire the lock again (and will time out\n+\t// eventually). \n+\t// In cases where we would exceed the maximum number of read locks\n+\t// throughout the whole time until the timeout, we will fail to\n+\t// acquire the lock even if it would be logically free; however, this\n+\t// is allowed by the standard, and we made a \"strong effort\"\n+\t// (see C++14 30.4.1.4p26).\n+\t// For cases where the implementation detects a deadlock we\n+\t// intentionally block and timeout so that an early return isn't\n+\t// mistaken for a spurious failure, which might help users realise\n+\t// there is a deadlock.\n+\tdo\n+\t  __ret = pthread_rwlock_timedrdlock(&_M_rwlock, &__ts);\n+\twhile (__ret == EAGAIN || __ret == EDEADLK);\n+\tif (__ret == ETIMEDOUT)\n \t  return false;\n \t// Errors not handled: EINVAL\n \t_GLIBCXX_DEBUG_ASSERT(__ret == 0);\n@@ -241,7 +266,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       unlock();\n     }\n \n-#else // defined(__GTHREADS_CXX0X)\n+#else // ! _GLIBCXX_USE_PTHREAD_RWLOCK_T\n \n #if _GTHREAD_USE_MUTEX_TIMEDLOCK\n     struct _Mutex : mutex, __timed_mutex_impl<_Mutex>\n@@ -438,7 +463,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_gate1.notify_one();\n \t}\n     }\n-#endif // !defined(__GTHREADS_CXX0X)\n+#endif // ! _GLIBCXX_USE_PTHREAD_RWLOCK_T\n   };\n #endif // _GLIBCXX_HAS_GTHREADS\n "}]}