{"sha": "6e42ce54f7112bd3f60e160560d31257faf6ce32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0MmNlNTRmNzExMmJkM2Y2MGUxNjA1NjBkMzEyNTdmYWY2Y2UzMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-12-23T23:05:52Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-12-23T23:05:52Z"}, "message": "tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne, [...]): Use integer_zerop/integer_nonzerop instead of...\n\n\t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne,\n\tassert_no_overflow_lt, assert_loop_rolls_lt,\n\tnumber_of_iterations_lt, number_of_iterations_le,\n\tnumber_of_iterations_cond, number_of_iterations_exit):\n\tUse integer_zerop/integer_nonzerop instead of\n\tnull_or_integer_zerop/nonnull_and_integer_nonzerop.\n\t* tree.h (null_or_integer_zerop, nonnull_and_integer_nonzerop):\n\tRemoved.\n\t* tree-scalar-evolution.c (simple_iv): Return zero for step of\n\tan invariant.\n\t* tree-ssa-loop-ivopts.c (alloc_iv): Do not set step of invariants\n\tto zero.\n\t(get_iv): Return NULL for non-scalar types.  Use zero as a step\n\tof an invariant.\n\t(determine_biv_step, find_interesting_uses_op,\n\tfind_interesting_uses_cond, find_interesting_uses_stmt,\n\tadd_old_ivs_candidates, determine_use_iv_cost_condition,\n\trewrite_use_compare, remove_unused_ivs):\n\tUse integer_zerop instead of null_or_integer_zerop.\n\t(struct ifs_ivopts_data): Replace step_p field with step field.\n\t(idx_find_step): Use zero as a step of an invariant.  Modify\n\tstep instead of *step_p.\n\t(find_interesting_uses_address): Use zero as a step of an invariant.\n\tUse integer_zerop instead of null_or_integer_zerop.\n\t(find_interesting_uses_outside): Call find_interesting_uses_op only\n\tfor phi nodes for real operands.\n\t(add_candidate_1): Expect step to be non-NULL.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Expect step to be\n\tnon-NULL.\n\nFrom-SVN: r120179", "tree": {"sha": "b6c514701475bc8b201274c2bca53ca774f03c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6c514701475bc8b201274c2bca53ca774f03c64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e42ce54f7112bd3f60e160560d31257faf6ce32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e42ce54f7112bd3f60e160560d31257faf6ce32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e42ce54f7112bd3f60e160560d31257faf6ce32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e42ce54f7112bd3f60e160560d31257faf6ce32/comments", "author": null, "committer": null, "parents": [{"sha": "ebf5f54a1d1b83214d3d7083bb656b3808658794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf5f54a1d1b83214d3d7083bb656b3808658794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf5f54a1d1b83214d3d7083bb656b3808658794"}], "stats": {"total": 190, "additions": 93, "deletions": 97}, "files": [{"sha": "e026399476d43649c31137a7654872c016d268b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e42ce54f7112bd3f60e160560d31257faf6ce32", "patch": "@@ -1,3 +1,35 @@\n+2006-12-23  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne,\n+\tassert_no_overflow_lt, assert_loop_rolls_lt,\n+\tnumber_of_iterations_lt, number_of_iterations_le,\n+\tnumber_of_iterations_cond, number_of_iterations_exit):\n+\tUse integer_zerop/integer_nonzerop instead of\n+\tnull_or_integer_zerop/nonnull_and_integer_nonzerop.\n+\t* tree.h (null_or_integer_zerop, nonnull_and_integer_nonzerop):\n+\tRemoved.\n+\t* tree-scalar-evolution.c (simple_iv): Return zero for step of\n+\tan invariant.\n+\t* tree-ssa-loop-ivopts.c (alloc_iv): Do not set step of invariants\n+\tto zero.\n+\t(get_iv): Return NULL for non-scalar types.  Use zero as a step\n+\tof an invariant.\n+\t(determine_biv_step, find_interesting_uses_op,\n+\tfind_interesting_uses_cond, find_interesting_uses_stmt,\n+\tadd_old_ivs_candidates, determine_use_iv_cost_condition,\n+\trewrite_use_compare, remove_unused_ivs):\n+\tUse integer_zerop instead of null_or_integer_zerop.\n+\t(struct ifs_ivopts_data): Replace step_p field with step field.\n+\t(idx_find_step): Use zero as a step of an invariant.  Modify\n+\tstep instead of *step_p.\n+\t(find_interesting_uses_address): Use zero as a step of an invariant.\n+\tUse integer_zerop instead of null_or_integer_zerop.\n+\t(find_interesting_uses_outside): Call find_interesting_uses_op only\n+\tfor phi nodes for real operands.\n+\t(add_candidate_1): Expect step to be non-NULL.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Expect step to be\n+\tnon-NULL.\n+\n 2006-12-23  Andrew Pinski  <pinskia@gmail.com>\n \n \t* vec.c: Don't include tree.h."}, {"sha": "194690185cce8d8b83e65639cef65e0cd0c4e11a", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=6e42ce54f7112bd3f60e160560d31257faf6ce32", "patch": "@@ -2813,6 +2813,7 @@ simple_iv (struct loop *loop, tree stmt, tree op, affine_iv *iv,\n       && !chrec_contains_symbols_defined_in_loop (ev, loop->num))\n     {\n       iv->base = ev;\n+      iv->step = build_int_cst (TREE_TYPE (ev), 0);\n       iv->no_overflow = true;\n       return true;\n     }"}, {"sha": "411cad22544cd2bac39d936c4c5f5d936995be21", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 37, "deletions": 50, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=6e42ce54f7112bd3f60e160560d31257faf6ce32", "patch": "@@ -840,9 +840,7 @@ static struct iv *\n alloc_iv (tree base, tree step)\n {\n   struct iv *iv = XCNEW (struct iv);\n-\n-  if (step && integer_zerop (step))\n-    step = NULL_TREE;\n+  gcc_assert (step != NULL_TREE);\n \n   iv->base = base;\n   iv->base_object = determine_base_object (base);\n@@ -875,14 +873,19 @@ static struct iv *\n get_iv (struct ivopts_data *data, tree var)\n {\n   basic_block bb;\n-  \n+  tree type = TREE_TYPE (var);\n+\n+  if (!POINTER_TYPE_P (type)\n+      && !INTEGRAL_TYPE_P (type))\n+    return NULL;\n+\n   if (!name_info (data, var)->iv)\n     {\n       bb = bb_for_stmt (SSA_NAME_DEF_STMT (var));\n \n       if (!bb\n \t  || !flow_bb_inside_loop_p (data->current_loop, bb))\n-\tset_iv (data, var, var, NULL_TREE);\n+\tset_iv (data, var, var, build_int_cst (type, 0));\n     }\n \n   return name_info (data, var)->iv;\n@@ -904,7 +907,7 @@ determine_biv_step (tree phi)\n   if (!simple_iv (loop, phi, name, &iv, true))\n     return NULL_TREE;\n \n-  return (null_or_integer_zerop (iv.step) ? NULL_TREE : iv.step);\n+  return integer_zerop (iv.step) ? NULL_TREE : iv.step;\n }\n \n /* Finds basic ivs.  */\n@@ -1160,7 +1163,7 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n       return use;\n     }\n \n-  if (null_or_integer_zerop (iv->step))\n+  if (integer_zerop (iv->step))\n     {\n       record_invariant (data, op, true);\n       return NULL;\n@@ -1192,7 +1195,7 @@ find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n   struct iv const_iv;\n   tree zero = integer_zero_node;\n \n-  const_iv.step = NULL_TREE;\n+  const_iv.step = integer_zero_node;\n \n   if (TREE_CODE (*cond_p) != SSA_NAME\n       && !COMPARISON_CLASS_P (*cond_p))\n@@ -1224,23 +1227,23 @@ find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n       (!iv0 || !iv1)\n       /* Eliminating condition based on two ivs would be nontrivial.\n \t ??? TODO -- it is not really important to handle this case.  */\n-      || (!null_or_integer_zerop (iv0->step)\n-\t  && !null_or_integer_zerop (iv1->step)))\n+      || (!integer_zerop (iv0->step)\n+\t  && !integer_zerop (iv1->step)))\n     {\n       find_interesting_uses_op (data, *op0_p);\n       find_interesting_uses_op (data, *op1_p);\n       return;\n     }\n \n-  if (null_or_integer_zerop (iv0->step)\n-      && null_or_integer_zerop (iv1->step))\n+  if (integer_zerop (iv0->step)\n+      && integer_zerop (iv1->step))\n     {\n       /* If both are invariants, this is a work for unswitching.  */\n       return;\n     }\n \n   civ = XNEW (struct iv);\n-  *civ = null_or_integer_zerop (iv0->step) ? *iv1: *iv0;\n+  *civ = integer_zerop (iv0->step) ? *iv1: *iv0;\n   record_use (data, cond_p, civ, stmt, USE_COMPARE);\n }\n \n@@ -1285,7 +1288,7 @@ struct ifs_ivopts_data\n {\n   struct ivopts_data *ivopts_data;\n   tree stmt;\n-  tree *step_p;\n+  tree step;\n };\n \n static bool\n@@ -1334,7 +1337,7 @@ idx_find_step (tree base, tree *idx, void *data)\n \t  ARRAY_REF path below.  */\n   *idx = iv->base;\n \n-  if (!iv->step)\n+  if (integer_zerop (iv->step))\n     return true;\n \n   if (TREE_CODE (base) == ARRAY_REF)\n@@ -1360,11 +1363,7 @@ idx_find_step (tree base, tree *idx, void *data)\n     }\n \n   step = fold_build2 (MULT_EXPR, sizetype, step, iv_step);\n-\n-  if (!*dta->step_p)\n-    *dta->step_p = step;\n-  else\n-    *dta->step_p = fold_build2 (PLUS_EXPR, sizetype, *dta->step_p, step);\n+  dta->step = fold_build2 (PLUS_EXPR, sizetype, dta->step, step);\n \n   return true;\n }\n@@ -1456,7 +1455,7 @@ may_be_nonaddressable_p (tree expr)\n static void\n find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n {\n-  tree base = *op_p, step = NULL;\n+  tree base = *op_p, step = build_int_cst (sizetype, 0);\n   struct iv *civ;\n   struct ifs_ivopts_data ifs_ivopts_data;\n \n@@ -1509,25 +1508,23 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n \t      if (TMR_STEP (base))\n \t\tastep = fold_build2 (MULT_EXPR, type, TMR_STEP (base), astep);\n \n-\t      if (step)\n-\t\tstep = fold_build2 (PLUS_EXPR, type, step, astep);\n-\t      else\n-\t\tstep = astep;\n+\t      step = fold_build2 (PLUS_EXPR, type, step, astep);\n \t    }\n \t}\n \n-      if (null_or_integer_zerop (step))\n+      if (integer_zerop (step))\n \tgoto fail;\n       base = tree_mem_ref_addr (type, base);\n     }\n   else\n     {\n       ifs_ivopts_data.ivopts_data = data;\n       ifs_ivopts_data.stmt = stmt;\n-      ifs_ivopts_data.step_p = &step;\n+      ifs_ivopts_data.step = build_int_cst (sizetype, 0);\n       if (!for_each_index (&base, idx_find_step, &ifs_ivopts_data)\n-\t  || null_or_integer_zerop (step))\n+\t  || integer_zerop (ifs_ivopts_data.step))\n \tgoto fail;\n+      step = ifs_ivopts_data.step;\n \n       gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n       gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n@@ -1600,7 +1597,7 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n \n \t  iv = get_iv (data, lhs);\n \n-\t  if (iv && !null_or_integer_zerop (iv->step))\n+\t  if (iv && !integer_zerop (iv->step))\n \t    return;\n \t}\n \n@@ -1646,7 +1643,7 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n       lhs = PHI_RESULT (stmt);\n       iv = get_iv (data, lhs);\n \n-      if (iv && !null_or_integer_zerop (iv->step))\n+      if (iv && !integer_zerop (iv->step))\n \treturn;\n     }\n \n@@ -1676,7 +1673,8 @@ find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n   for (phi = phi_nodes (exit->dest); phi; phi = PHI_CHAIN (phi))\n     {\n       def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-      find_interesting_uses_op (data, def);\n+      if (is_gimple_reg (def))\n+\tfind_interesting_uses_op (data, def);\n     }\n }\n \n@@ -1944,8 +1942,7 @@ add_candidate_1 (struct ivopts_data *data,\n       if (type != orig_type)\n \t{\n \t  base = fold_convert (type, base);\n-\t  if (step)\n-\t    step = fold_convert (type, step);\n+\t  step = fold_convert (type, step);\n \t}\n     }\n \n@@ -1970,19 +1967,9 @@ add_candidate_1 (struct ivopts_data *data,\n       if (!base && !step)\n \tcontinue;\n \n-      if (!operand_equal_p (base, cand->iv->base, 0))\n-\tcontinue;\n-\n-      if (null_or_integer_zerop (cand->iv->step))\n-\t{\n-\t  if (null_or_integer_zerop (step))\n-\t    break;\n-\t}\n-      else\n-\t{\n-\t  if (step && operand_equal_p (step, cand->iv->step, 0))\n-\t    break;\n-\t}\n+      if (operand_equal_p (base, cand->iv->base, 0)\n+\t  && operand_equal_p (step, cand->iv->step, 0))\n+\tbreak;\n     }\n \n   if (i == n_iv_cands (data))\n@@ -2136,7 +2123,7 @@ add_old_ivs_candidates (struct ivopts_data *data)\n   EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n     {\n       iv = ver_info (data, i)->iv;\n-      if (iv && iv->biv_p && !null_or_integer_zerop (iv->step))\n+      if (iv && iv->biv_p && !integer_zerop (iv->step))\n \tadd_old_iv_candidates (data, iv);\n     }\n }\n@@ -3733,7 +3720,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n     {\n       op = TREE_OPERAND (cond, 0);\n       if (TREE_CODE (op) == SSA_NAME\n-\t  && !null_or_integer_zerop (get_iv (data, op)->step))\n+\t  && !integer_zerop (get_iv (data, op)->step))\n \top = TREE_OPERAND (cond, 1);\n       if (TREE_CODE (op) == SSA_NAME)\n \t{\n@@ -5151,7 +5138,7 @@ rewrite_use_compare (struct ivopts_data *data,\n   cond = *use->op_p;\n   op_p = &TREE_OPERAND (cond, 0);\n   if (TREE_CODE (*op_p) != SSA_NAME\n-      || null_or_integer_zerop (get_iv (data, *op_p)->step))\n+      || integer_zerop (get_iv (data, *op_p)->step))\n     op_p = &TREE_OPERAND (cond, 1);\n \n   op = force_gimple_operand (comp, &stmts, true, SSA_NAME_VAR (*op_p));\n@@ -5222,7 +5209,7 @@ remove_unused_ivs (struct ivopts_data *data)\n \n       info = ver_info (data, j);\n       if (info->iv\n-\t  && !null_or_integer_zerop (info->iv->step)\n+\t  && !integer_zerop (info->iv->step)\n \t  && !info->inv_id\n \t  && !info->iv->have_use_for\n \t  && !info->preserve_biv)"}, {"sha": "affb47d3b1c5f5ca506077a852f49572ea41a1e1", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=6e42ce54f7112bd3f60e160560d31257faf6ce32", "patch": "@@ -193,7 +193,7 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n     mod = fold_build2 (MINUS_EXPR, niter_type, step, mod);\n   tmod = fold_convert (type, mod);\n \n-  if (nonnull_and_integer_nonzerop (iv0->step))\n+  if (integer_nonzerop (iv0->step))\n     {\n       /* The final value of the iv is iv1->base + MOD, assuming that this\n \t computation does not overflow, and that\n@@ -256,7 +256,7 @@ assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree bound, d, assumption, diff;\n   tree niter_type = TREE_TYPE (step);\n \n-  if (nonnull_and_integer_nonzerop (iv0->step))\n+  if (integer_nonzerop (iv0->step))\n     {\n       /* for (i = iv0->base; i < iv1->base; i += iv0->step) */\n       if (iv0->no_overflow)\n@@ -324,7 +324,7 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree assumption = boolean_true_node, bound, diff;\n   tree mbz, mbzl, mbzr;\n \n-  if (nonnull_and_integer_nonzerop (iv0->step))\n+  if (integer_nonzerop (iv0->step))\n     {\n       diff = fold_build2 (MINUS_EXPR, type,\n \t\t\t  iv0->step, build_int_cst (type, 1));\n@@ -384,7 +384,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree niter_type = unsigned_type_for (type);\n   tree delta, step, s;\n \n-  if (nonnull_and_integer_nonzerop (iv0->step))\n+  if (integer_nonzerop (iv0->step))\n     {\n       niter->control = *iv0;\n       niter->cmp = LT_EXPR;\n@@ -402,10 +402,8 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t       fold_convert (niter_type, iv0->base));\n \n   /* First handle the special case that the step is +-1.  */\n-  if ((iv0->step && integer_onep (iv0->step)\n-       && null_or_integer_zerop (iv1->step))\n-      || (iv1->step && integer_all_onesp (iv1->step)\n-\t  && null_or_integer_zerop (iv0->step)))\n+  if ((integer_onep (iv0->step) && integer_zerop (iv1->step))\n+      || (integer_all_onesp (iv1->step) && integer_zerop (iv0->step)))\n     {\n       /* for (i = iv0->base; i < iv1->base; i++)\n \n@@ -421,7 +419,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n       return true;\n     }\n \n-  if (nonnull_and_integer_nonzerop (iv0->step))\n+  if (integer_nonzerop (iv0->step))\n     step = fold_convert (niter_type, iv0->step);\n   else\n     step = fold_convert (niter_type,\n@@ -479,7 +477,7 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   if (!never_infinite)\n     {\n-      if (nonnull_and_integer_nonzerop (iv0->step))\n+      if (integer_nonzerop (iv0->step))\n \tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t\t  iv1->base, TYPE_MAX_VALUE (type));\n       else\n@@ -493,7 +491,7 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t\t\t  niter->assumptions, assumption);\n     }\n \n-  if (nonnull_and_integer_nonzerop (iv0->step))\n+  if (integer_nonzerop (iv0->step))\n     iv1->base = fold_build2 (PLUS_EXPR, type,\n \t\t\t     iv1->base, build_int_cst (type, 1));\n   else\n@@ -542,7 +540,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   /* Make < comparison from > ones, and for NE_EXPR comparisons, ensure that\n      the control variable is on lhs.  */\n   if (code == GE_EXPR || code == GT_EXPR\n-      || (code == NE_EXPR && null_or_integer_zerop (iv0->step)))\n+      || (code == NE_EXPR && integer_zerop (iv0->step)))\n     {\n       SWAP (iv0, iv1);\n       code = swap_tree_comparison (code);\n@@ -578,32 +576,32 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n \n   /* If the control induction variable does not overflow, the loop obviously\n      cannot be infinite.  */\n-  if (!null_or_integer_zerop (iv0->step) && iv0->no_overflow)\n+  if (!integer_zerop (iv0->step) && iv0->no_overflow)\n     never_infinite = true;\n-  else if (!null_or_integer_zerop (iv1->step) && iv1->no_overflow)\n+  else if (!integer_zerop (iv1->step) && iv1->no_overflow)\n     never_infinite = true;\n   else\n     never_infinite = false;\n \n   /* We can handle the case when neither of the sides of the comparison is\n      invariant, provided that the test is NE_EXPR.  This rarely occurs in\n      practice, but it is simple enough to manage.  */\n-  if (!null_or_integer_zerop (iv0->step) && !null_or_integer_zerop (iv1->step))\n+  if (!integer_zerop (iv0->step) && !integer_zerop (iv1->step))\n     {\n       if (code != NE_EXPR)\n \treturn false;\n \n       iv0->step = fold_binary_to_constant (MINUS_EXPR, type,\n \t\t\t\t\t   iv0->step, iv1->step);\n       iv0->no_overflow = false;\n-      iv1->step = NULL_TREE;\n+      iv1->step = build_int_cst (type, 0);\n       iv1->no_overflow = true;\n     }\n \n   /* If the result of the comparison is a constant,  the loop is weird.  More\n      precise handling would be possible, but the situation is not common enough\n      to waste time on it.  */\n-  if (null_or_integer_zerop (iv0->step) && null_or_integer_zerop (iv1->step))\n+  if (integer_zerop (iv0->step) && integer_zerop (iv1->step))\n     return false;\n \n   /* Ignore loops of while (i-- < 10) type.  */\n@@ -612,7 +610,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n       if (iv0->step && tree_int_cst_sign_bit (iv0->step))\n \treturn false;\n \n-      if (!null_or_integer_zerop (iv1->step) && !tree_int_cst_sign_bit (iv1->step))\n+      if (!integer_zerop (iv1->step) && !tree_int_cst_sign_bit (iv1->step))\n \treturn false;\n     }\n \n@@ -628,7 +626,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   switch (code)\n     {\n     case NE_EXPR:\n-      gcc_assert (null_or_integer_zerop (iv1->step));\n+      gcc_assert (integer_zerop (iv1->step));\n       return number_of_iterations_ne (type, iv0, iv1->base, niter, never_infinite);\n     case LT_EXPR:\n       return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite);\n@@ -1099,11 +1097,10 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   \n       /* We can provide a more specific warning if one of the operator is\n \t constant and the other advances by +1 or -1.  */\n-      if (!null_or_integer_zerop (iv1.step)\n-\t  ? (null_or_integer_zerop (iv0.step)\n+      if (!integer_zerop (iv1.step)\n+\t  ? (integer_zerop (iv0.step)\n \t     && (integer_onep (iv1.step) || integer_all_onesp (iv1.step)))\n-\t  : (iv0.step\n-\t     && (integer_onep (iv0.step) || integer_all_onesp (iv0.step))))\n+\t  : (integer_onep (iv0.step) || integer_all_onesp (iv0.step)))\n         wording =\n           flag_unsafe_loop_optimizations\n           ? N_(\"assuming that the loop is not infinite\")"}, {"sha": "198c2342ac188aaceddc8efafe374616bf6359fe", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=6e42ce54f7112bd3f60e160560d31257faf6ce32", "patch": "@@ -337,14 +337,9 @@ idx_analyze_ref (tree base, tree *index, void *data)\n   ibase = iv.base;\n   step = iv.step;\n \n-  if (null_or_integer_zerop (step))\n-    istep = 0;\n-  else\n-    {\n-      if (!cst_and_fits_in_hwi (step))\n-\treturn false;\n-      istep = int_cst_value (step);\n-    }\n+  if (!cst_and_fits_in_hwi (step))\n+    return false;\n+  istep = int_cst_value (step);\n \n   if (TREE_CODE (ibase) == PLUS_EXPR\n       && cst_and_fits_in_hwi (TREE_OPERAND (ibase, 1)))"}, {"sha": "b7ec8035b3cb7966f7d79fc03fe7fa1b458e4def", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e42ce54f7112bd3f60e160560d31257faf6ce32/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6e42ce54f7112bd3f60e160560d31257faf6ce32", "patch": "@@ -4075,22 +4075,6 @@ extern int integer_pow2p (tree);\n \n extern int integer_nonzerop (tree);\n \n-/* Returns true if X is either NULL or zero.  */\n-\n-static inline bool\n-null_or_integer_zerop (tree x)\n-{\n-  return x == NULL_TREE || integer_zerop (x);\n-}\n-\n-/* Returns true if X is non-NULL and non-zero.  */\n-\n-static inline bool\n-nonnull_and_integer_nonzerop (tree x)\n-{\n-  return x != NULL_TREE && integer_nonzerop (x);\n-}\n-\n extern bool cst_and_fits_in_hwi (tree);\n extern tree num_ending_zeros (tree);\n "}]}