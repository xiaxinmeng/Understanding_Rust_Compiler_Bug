{"sha": "38fbfaf6fb23fdcd130cc524839686b9ad28f752", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhmYmZhZjZmYjIzZmRjZDEzMGNjNTI0ODM5Njg2YjlhZDI4Zjc1Mg==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2011-06-06T11:33:42Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-06-06T11:33:42Z"}, "message": "re PR preprocessor/48532 (Wrong location of namespaced pragma involving macros)\n\nPR preprocessor/48532\n\nlibcpp/\n\n\t* directives.c (do_pragma): Don't forget the invocation location\n\twhen parsing the pragma name of a namespaced pragma directive.\n\ngcc/testsuite/\n\n\t* gcc.dg/cpp/pragma-3.c: New test case.\n\nFrom-SVN: r174694", "tree": {"sha": "3c306927913661e1e914dc99031a45c1684aaff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c306927913661e1e914dc99031a45c1684aaff8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38fbfaf6fb23fdcd130cc524839686b9ad28f752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fbfaf6fb23fdcd130cc524839686b9ad28f752", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38fbfaf6fb23fdcd130cc524839686b9ad28f752", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fbfaf6fb23fdcd130cc524839686b9ad28f752/comments", "author": null, "committer": null, "parents": [{"sha": "3bfc61cf25241bdcf7aad08c1e2b6607d25f97bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bfc61cf25241bdcf7aad08c1e2b6607d25f97bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bfc61cf25241bdcf7aad08c1e2b6607d25f97bb"}], "stats": {"total": 76, "additions": 75, "deletions": 1}, "files": [{"sha": "9afc3919a8db8743897040e1d10eddcd106fa210", "filename": "gcc/testsuite/gcc.dg/cpp/pragma-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38fbfaf6fb23fdcd130cc524839686b9ad28f752/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38fbfaf6fb23fdcd130cc524839686b9ad28f752/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-3.c?ref=38fbfaf6fb23fdcd130cc524839686b9ad28f752", "patch": "@@ -0,0 +1,39 @@\n+/* \n+   { dg-options \"-fopenmp\" }\n+   { dg-do preprocess }\n+ */\n+\n+void foo (void)\n+{\n+  int i1, j1, k1;\n+#define p parallel\n+#define P(x) private (x##1)\n+#define S(x) shared (x##1)\n+#define F(x) firstprivate (x##1)\n+#pragma omp \\\n+  p \\\n+  P(i) \\\n+  S(j) \\\n+  F(k)\n+  ;\n+}\n+\n+/* \n+   The bug here was that we had a line like:\n+       # 33554432 \"../../gcc/testsuite/gcc.dg/cpp/pragma-3.c\"\n+   \n+   Before line:\n+\n+       #pragma omp parallel private (i1) shared (j1) firstprivate (k1)\n+\n+   Note the very big integer there.  Normally we should just have\n+   this:\n+   \n+       # 13 \"../../gcc/testsuite/gcc.dg/cpp/pragma-3.c\"\n+       #pragma omp parallel private (i1) shared (j1) firstprivate (k1)\n+\n+   So let's check that we have no line with a number of 3 or more\n+   digit after #:\n+\n+   { dg-final { scan-file-not pragma-3.i \"# \\[0-9\\]{3} \\[^\\n\\r\\]*pragma-3.c\" } }\n+*/"}, {"sha": "e1c01c136607fcd5702a2877d9f8739dcb3b2cdc", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38fbfaf6fb23fdcd130cc524839686b9ad28f752/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38fbfaf6fb23fdcd130cc524839686b9ad28f752/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=38fbfaf6fb23fdcd130cc524839686b9ad28f752", "patch": "@@ -1,3 +1,9 @@\n+2011-06-06  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/48532\n+\t* directives.c (do_pragma): Don't forget the invocation location\n+\twhen parsing the pragma name of a namespaced pragma directive.\n+\n 2011-05-29  John Tytgat  <John.Tytgat@aaug.net>\n \n \t* files.c (read_file_guts): Add test on non-zero value of S_ISREG."}, {"sha": "85e941ed49c9f04e19b3a54b9eea3a11fb350b0b", "filename": "libcpp/directives.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38fbfaf6fb23fdcd130cc524839686b9ad28f752/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38fbfaf6fb23fdcd130cc524839686b9ad28f752/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=38fbfaf6fb23fdcd130cc524839686b9ad28f752", "patch": "@@ -1360,7 +1360,36 @@ do_pragma (cpp_reader *pfile)\n \t{\n \t  bool allow_name_expansion = p->allow_expansion;\n \t  if (allow_name_expansion)\n-\t    pfile->state.prevent_expansion--;\n+\t    {\n+\t      pfile->state.prevent_expansion--;\n+\t      /*\n+\t\tKludge ahead.\n+\n+\t\tConsider this code snippet:\n+\n+\t\t#define P parallel\n+\t\t#pragma omp P for\n+\t\t... a for loop ...\n+\n+\t\tOnce we parsed the 'omp' namespace of the #pragma\n+\t\tdirective, we then parse the 'P' token that represents the\n+\t\tpragma name.  P being a macro, it is expanded into the\n+\t\tresulting 'parallel' token.\n+\n+\t\tAt this point the 'p' variable contains the 'parallel'\n+\t\tpragma name.  And pfile->context->macro is non-null\n+\t\tbecause we are still right at the end of the macro\n+\t\tcontext of 'P'.  The problem is, if we are being\n+\t\t(indirectly) called by cpp_get_token_with_location,\n+\t\tthat function might test pfile->context->macro to see\n+\t\tif we are in the context of a macro expansion, (and we\n+\t\tare) and then use pfile->invocation_location as the\n+\t\tlocation of the macro invocation.  So we must instruct\n+\t\tcpp_get_token below to set\n+\t\tpfile->invocation_location.  */\n+\t      pfile->set_invocation_location = true;\n+\t    }\n+\n \t  token = cpp_get_token (pfile);\n \t  if (token->type == CPP_NAME)\n \t    p = lookup_pragma_entry (p->u.space, token->val.node.node);"}]}