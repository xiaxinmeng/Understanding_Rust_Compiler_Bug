{"sha": "6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIzNDU2ZDFmZjgzNmNmYzQwMDMzYjliMjM4YzVkY2Q5YjE4ZDljYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2010-11-02T14:48:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-11-02T14:48:34Z"}, "message": "lto-object.c: New file.\n\n\t* lto-object.c: New file.\n\t* lto-elf.c: Remove file.\n\t* lto-macho.c: Remove file.\n\t* lto-macho.h: Remove file.\n\t* lto-coff.c: Remove file.\n\t* lto-coff.h: Remove file.\n\t* Make-lang.in (LTO_OBJS): Change lto/$(LTO_BINARY_READER).o to\n\tlto/lto-object.o.\n\t($(LTO_EXE)): Remove $(LTO_USE_LIBELF)\n\t(lto/lto-objfile.o): New target.\n\t(lto/lto-elf.o, lto/lto-coff.o, lto/lto-macho.o): Remove targets.\n\t(lto/lto.o): Remove $(LIBIBERTY_H).\n\nFrom-SVN: r166187", "tree": {"sha": "87d5de3939e75d56c2757de45586be08850b3046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87d5de3939e75d56c2757de45586be08850b3046"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb/comments", "author": null, "committer": null, "parents": [{"sha": "1cfabf34d83637a5e9ffa11dc38379d017738cf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfabf34d83637a5e9ffa11dc38379d017738cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cfabf34d83637a5e9ffa11dc38379d017738cf7"}], "stats": {"total": 3649, "additions": 397, "deletions": 3252}, "files": [{"sha": "c963d6f4bc3b9dfcd3f40b11b57267e38972847c", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb", "patch": "@@ -1,3 +1,18 @@\n+2010-11-02  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lto-object.c: New file.\n+\t* lto-elf.c: Remove file.\n+\t* lto-macho.c: Remove file.\n+\t* lto-macho.h: Remove file.\n+\t* lto-coff.c: Remove file.\n+\t* lto-coff.h: Remove file.\n+\t* Make-lang.in (LTO_OBJS): Change lto/$(LTO_BINARY_READER).o to\n+\tlto/lto-object.o.\n+\t($(LTO_EXE)): Remove $(LTO_USE_LIBELF)\n+\t(lto/lto-objfile.o): New target.\n+\t(lto/lto-elf.o, lto/lto-coff.o, lto/lto-macho.o): Remove targets.\n+\t(lto/lto.o): Remove $(LIBIBERTY_H).\n+\n 2010-10-22  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (add_cgraph_node_to_partition,"}, {"sha": "0c6386525c2c7b37c6043b402be11c1cfd7d341d", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb", "patch": "@@ -23,7 +23,7 @@\n # The name of the LTO compiler.\n LTO_EXE = lto1$(exeext)\n # The LTO-specific object files inclued in $(LTO_EXE).\n-LTO_OBJS = lto/lto-lang.o lto/lto.o lto/$(LTO_BINARY_READER).o attribs.o\n+LTO_OBJS = lto/lto-lang.o lto/lto.o lto/lto-object.o attribs.o\n LTO_H = lto/lto.h $(HASHTAB_H)\n LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h\n LTO_TREE_H = lto/lto-tree.h $(LINKER_PLUGIN_API_H)\n@@ -73,27 +73,22 @@ lto-warn = $(STRICT_WARN)\n \n $(LTO_EXE): $(LTO_OBJS) $(BACKEND) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t\t$(LTO_OBJS) $(BACKEND) $(BACKENDLIBS) $(LIBS) $(LTO_USE_LIBELF)\n+\t\t$(LTO_OBJS) $(BACKEND) $(BACKENDLIBS) $(LIBS)\n \n # Dependencies\n lto/lto-lang.o: lto/lto-lang.c $(CONFIG_H) coretypes.h debug.h \\\n \tflags.h $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) $(SYSTEM_H) \\\n \t$(TARGET_H) $(LTO_H) $(GIMPLE_H) gtype-lto.h gt-lto-lto-lang.h \\\n \t$(EXPR_H)\n lto/lto.o: lto/lto.c $(CONFIG_H) $(SYSTEM_H) coretypes.h opts.h \\\n-\ttoplev.h $(TREE_H) $(DIAGNOSTIC_CORE_H) $(TM_H) $(LIBIBERTY_H) \\\n+\ttoplev.h $(TREE_H) $(DIAGNOSTIC_CORE_H) $(TM_H) \\\n \t$(CGRAPH_H) $(GGC_H) tree-ssa-operands.h $(TREE_PASS_H) \\\n \tlanghooks.h $(VEC_H) $(BITMAP_H) pointer-set.h $(IPA_PROP_H) \\\n \t$(COMMON_H) debug.h $(TIMEVAR_H) $(GIMPLE_H) $(LTO_H) $(LTO_TREE_H) \\\n \t$(LTO_TAGS_H) $(LTO_STREAMER_H) $(SPLAY_TREE_H) gt-lto-lto.h $(PARAMS_H)\n-lto/lto-elf.o: lto/lto-elf.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n-\ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H)\n-lto/lto-coff.o: lto/lto-coff.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n-\ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H) \\\n-\tlto/lto-coff.h\n-lto/lto-macho.o: lto/lto-macho.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n-\ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H) \\\n-\tlto/lto-macho.h lto/lto-endian.h\n+lto/lto-object.o: lto/lto-object.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+\t$(DIAGNOSTIC_CORE_H) $(TOPLEV_H) $(LTO_H) $(TM_H) $(LTO_STREAMER_H) \\\n+\t../include/simple-object.h\n \n # LTO testing is done as part of C/C++/Fortran etc. testing.\n check-lto:"}, {"sha": "f5aaff8bcaaa685145e5a2eb160cdb782076db36", "filename": "gcc/lto/lto-coff.c", "status": "removed", "additions": 0, "deletions": 817, "changes": 817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-coff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-coff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-coff.c?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1,817 +0,0 @@\n-/* LTO routines for COFF object files.\n-   Copyright 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Dave Korn.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"diagnostic-core.h\"\n-#include \"toplev.h\"\n-#include \"lto.h\"\n-#include \"tm.h\"\n-#include \"libiberty.h\"\n-#include \"ggc.h\"\n-#include \"lto-streamer.h\"\n-#include \"lto/lto-coff.h\"\n-\n-\n-/* Rather than implementing a libcoff to match libelf, or attempting to\n-   integrate libbfd into GCC, this file is a self-contained (and very\n-   minimal) COFF format object file reader/writer.  The generated files\n-   will contain a COFF header, a number of COFF section headers, the \n-   section data itself, and a trailing string table for section names.  */\n-\n-/* Handle opening elf files on hosts, such as Windows, that may use \n-   text file handling that will break binary access.  */\n-\n-#ifndef O_BINARY\n-#define O_BINARY 0\n-#endif\n-\n-/* Known header magics for validation, as an array.  */\n-\n-static const unsigned int coff_machine_array[] = COFF_KNOWN_MACHINES;\n-\n-/* Number of valid entries (no sentinel) in array.  */\n-\n-#define NUM_COFF_KNOWN_MACHINES\t\\\n-\t(sizeof (coff_machine_array) / sizeof (coff_machine_array[0]))\n-\n-/* Cached object file header.  */\n-\n-static Coff_header cached_coff_hdr;\n-\n-/* Flag to indicate if we have read and cached any header yet.  */\n-\n-static bool cached_coff_hdr_valid = false;\n-\n-/* The current output file.  */\n-\n-static lto_file *current_out_file;\n-\n-\n-/* Sets the current output file to FILE.  Returns the old output file or\n-   NULL.  */\n-\n-lto_file *\n-lto_set_current_out_file (lto_file *file)\n-{\n-  lto_file *old_file = current_out_file;\n-  current_out_file = file;\n-  return old_file;\n-}\n-\n-\n-/* Returns the current output file.  */\n-\n-lto_file *\n-lto_get_current_out_file (void)\n-{\n-  return current_out_file;\n-}\n-\n-\n-/* COFF section structure constructor.  */\n-\n-static lto_coff_section *\n-coff_newsection (lto_coff_file *file, const char *name, size_t type)\n-{\n-  lto_coff_section *ptr, **chain_ptr_ptr;\n-\n-  ptr = XCNEW (lto_coff_section);\n-  ptr->name = name;\n-  ptr->type = type;\n-\n-  chain_ptr_ptr = &file->section_chain;\n-  while (*chain_ptr_ptr)\n-    chain_ptr_ptr = &(*chain_ptr_ptr)->next;\n-  *chain_ptr_ptr = ptr;\n-\n-  return ptr;\n-}\n-\n-\n-/* COFF section data block structure constructor.  */\n-\n-static lto_coff_data *\n-coff_newdata (lto_coff_section *sec)\n-{\n-  lto_coff_data *ptr, **chain_ptr_ptr;\n-\n-  ptr = XCNEW (lto_coff_data);\n-\n-  chain_ptr_ptr = &sec->data_chain;\n-  while (*chain_ptr_ptr)\n-    chain_ptr_ptr = &(*chain_ptr_ptr)->next;\n-  *chain_ptr_ptr = ptr;\n-\n-  return ptr;\n-}\n-\n-\n-/* Initialize FILE, an LTO file object for FILENAME.  */\n-\n-static void\n-lto_file_init (lto_file *file, const char *filename, off_t offset)\n-{\n-  file->filename = filename;\n-  file->offset = offset;\n-}\n-\n-/* Build a hash table whose key is the section names and whose data is\n-   the start and size of each section in the .o file.  */\n-\n-htab_t\n-lto_obj_build_section_table (lto_file *lto_file) \n-{\n-  lto_coff_file *coff_file = (lto_coff_file *)lto_file;\n-  lto_coff_section *sec;\n-  htab_t section_hash_table;\n-  ssize_t strtab_size;\n-  char *strtab;\n-\n-  section_hash_table = lto_obj_create_section_hash_table ();\n-\n-  /* Seek to start of string table.  */\n-  if (coff_file->strtab_offs != lseek (coff_file->fd,\n-\t\tcoff_file->base.offset + coff_file->strtab_offs, SEEK_SET))\n-    {\n-      error (\"altered or invalid COFF object file\");\n-      return section_hash_table;\n-    }\n-\n-  strtab_size = coff_file->file_size - coff_file->strtab_offs;\n-  strtab = XNEWVEC (char, strtab_size);\n-  if (read (coff_file->fd, strtab, strtab_size) != strtab_size)\n-    {\n-      error (\"invalid COFF object file string table\");\n-      return section_hash_table;\n-    }\n-\n-  /* Scan sections looking at names.  */\n-  COFF_FOR_ALL_SECTIONS(coff_file, sec)\n-    {\n-      struct lto_section_slot s_slot;\n-      void **slot;\n-      char *new_name;\n-      int stringoffset;\n-      char *name = (char *) &sec->coffsec.Name[0];\n-\n-      /* Skip dummy string section if by any chance we see it.  */\n-      if (sec->type == 1)\n-\tcontinue;\n-\n-      if (name[0] == '/')\n-\t{\n-\t  if (1 != sscanf (&name[1], \"%d\", &stringoffset)\n-\t\t|| stringoffset < 0 || stringoffset >= strtab_size)\n-\t    {\n-\t      error (\"invalid COFF section name string\");\n-\t      continue;\n-\t    }\n-\t  name = strtab + stringoffset;\n-\t}\n-      else\n-\t{\n-\t  /* If we cared about the VirtualSize field, we couldn't\n-\t     crudely trash it like this to guarantee nul-termination\n-\t     of the Name field.  But we don't, so we do.  */\n-\t  name[8] = 0;\n-\t}\n-      if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n-\t\t\tstrlen (LTO_SECTION_NAME_PREFIX)) != 0)\n-\t  continue;\n-\n-      new_name = XNEWVEC (char, strlen (name) + 1);\n-      strcpy (new_name, name);\n-      s_slot.name = new_name;\n-      slot = htab_find_slot (section_hash_table, &s_slot, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  struct lto_section_slot *new_slot = XNEW (struct lto_section_slot);\n-\n-\t  new_slot->name = new_name;\n-\t  /* The offset into the file for this section.  */\n-\t  new_slot->start = coff_file->base.offset\n-\t\t\t+ COFF_GET(&sec->coffsec,PointerToRawData);\n-\t  new_slot->len = COFF_GET(&sec->coffsec,SizeOfRawData);\n-\t  *slot = new_slot;\n-\t}\n-      else\n-\t{\n-\t  error (\"two or more sections for %s:\", new_name);\n-\t  return NULL;\n-\t}\n-    }\n-\n-  free (strtab);\n-  return section_hash_table;\n-}\n-\n-\n-/* Begin a new COFF section named NAME with type TYPE in the current output\n-   file.  TYPE is an SHT_* macro from the libelf headers.  */\n-\n-static void\n-lto_coff_begin_section_with_type (const char *name, size_t type)\n-{\n-  lto_coff_file *file;\n-  size_t sh_name;\n-\n-  /* Grab the current output file and do some basic assertion checking.  */\n-  file = (lto_coff_file *) lto_get_current_out_file (),\n-  gcc_assert (file);\n-  gcc_assert (!file->scn);\n-\n-  /* Create a new section.  */\n-  file->scn = coff_newsection (file, name, type);\n-  if (!file->scn)\n-    fatal_error (\"could not create a new COFF section: %m\");\n-\n-  /* Add a string table entry and record the offset.  */\n-  gcc_assert (file->shstrtab_stream);\n-  sh_name = file->shstrtab_stream->total_size;\n-  lto_output_data_stream (file->shstrtab_stream, name, strlen (name) + 1);\n-\n-  /* Initialize the section header.  */\n-  file->scn->strtab_offs = sh_name;\n-}\n-\n-\n-/* Begin a new COFF section named NAME in the current output file.  */\n-\n-void\n-lto_obj_begin_section (const char *name)\n-{\n-  lto_coff_begin_section_with_type (name, 0);\n-}\n-\n-\n-/* Append DATA of length LEN to the current output section.  BASE is a pointer\n-   to the output page containing DATA.  It is freed once the output file has\n-   been written.  */\n-\n-void\n-lto_obj_append_data (const void *data, size_t len, void *block)\n-{\n-  lto_coff_file *file;\n-  lto_coff_data *coff_data;\n-  struct lto_char_ptr_base *base = (struct lto_char_ptr_base *) block;\n-\n-  /* Grab the current output file and do some basic assertion checking.  */\n-  file = (lto_coff_file *) lto_get_current_out_file ();\n-  gcc_assert (file);\n-  gcc_assert (file->scn);\n-\n-  coff_data = coff_newdata (file->scn);\n-  if (!coff_data)\n-    fatal_error (\"could not append data to COFF section: %m\");\n-\n-  coff_data->d_buf = CONST_CAST (void *, data);\n-  coff_data->d_size = len;\n-\n-  /* Chain all data blocks (from all sections) on one singly-linked\n-     list for freeing en masse after the file is closed.  */\n-  base->ptr = (char *)file->data;\n-  file->data = base;\n-}\n-\n-\n-/* End the current output section.  This just does some assertion checking\n-   and sets the current output file's scn member to NULL.  */\n-\n-void\n-lto_obj_end_section (void)\n-{\n-  lto_coff_file *file;\n-\n-  /* Grab the current output file and validate some basic assertions.  */\n-  file = (lto_coff_file *) lto_get_current_out_file ();\n-  gcc_assert (file);\n-  gcc_assert (file->scn);\n-\n-  file->scn = NULL;\n-}\n-\n-\n-/* Validate's COFF_FILE's executable header and, if cached_coff_hdr is\n-   uninitialized, caches the results.  Also records the section header string\n-   table's section index.  Returns true on success or false on failure.  */\n-\n-static bool\n-validate_file (lto_coff_file *coff_file)\n-{\n-  size_t n, secnum;\n-  unsigned int numsections, secheaderssize, numsyms;\n-  off_t sectionsstart, symbolsstart, stringsstart;\n-  unsigned int mach, charact;\n-\n-  /* Read and sanity check the raw header.  */\n-  n = read (coff_file->fd, &coff_file->coffhdr, sizeof (coff_file->coffhdr));\n-  if (n != sizeof (coff_file->coffhdr))\n-    {\n-      error (\"not a COFF object file\");\n-      return false;\n-    }\n-\n-  mach = COFF_GET(&coff_file->coffhdr, Machine);\n-  for (n = 0; n < NUM_COFF_KNOWN_MACHINES; n++)\n-    if (mach == coff_machine_array[n])\n-      break;\n-  if (n == NUM_COFF_KNOWN_MACHINES)\n-    {\n-      error (\"not a recognized COFF object file\");\n-      return false;\n-    }\n-\n-  charact = COFF_GET(&coff_file->coffhdr, Characteristics);\n-  if (COFF_NOT_CHARACTERISTICS & charact)\n-    {\n-      /* DLL, EXE or SYS file.  */\n-      error (\"not a relocatable COFF object file\");\n-      return false;\n-    }\n-\n-  if (mach != IMAGE_FILE_MACHINE_AMD64\n-      && COFF_CHARACTERISTICS != (COFF_CHARACTERISTICS & charact))\n-    {\n-      /* ECOFF/XCOFF support not implemented.  */\n-      error (\"not a 32-bit COFF object file\");\n-      return false;\n-    }\n-\n-  /* It validated OK, so cached it if we don't already have one.  */\n-  if (!cached_coff_hdr_valid)\n-    {\n-      cached_coff_hdr_valid = true;\n-      memcpy (&cached_coff_hdr, &coff_file->coffhdr, sizeof (cached_coff_hdr));\n-    }\n-\n-  if (mach != COFF_GET(&cached_coff_hdr, Machine))\n-    {\n-      error (\"inconsistent file architecture detected\");\n-      return false;\n-    }\n-\n-  /* Read section headers and string table? */\n-\n-  numsections = COFF_GET(&coff_file->coffhdr, NumberOfSections);\n-  secheaderssize = numsections * sizeof (Coff_section);\n-  sectionsstart = sizeof (Coff_header) + secheaderssize;\n-  symbolsstart = COFF_GET(&coff_file->coffhdr, PointerToSymbolTable);\n-  numsyms = COFF_GET(&coff_file->coffhdr, NumberOfSymbols);\n-  stringsstart = (symbolsstart + COFF_SYMBOL_SIZE * numsyms);\n-\n-#define CVOFFSETTTED(x) (coff_file->base.offset + (x))\n-\n-  if (numsections <= 0 || symbolsstart <= 0 || numsyms <= 0\n-\t|| (CVOFFSETTTED(sectionsstart) >= coff_file->file_size)\n-\t|| (CVOFFSETTTED(symbolsstart) >= coff_file->file_size)\n-\t|| (CVOFFSETTTED(stringsstart) >= coff_file->file_size))\n-    {\n-      error (\"not a valid COFF object file\");\n-      return false;\n-    }\n-\n-#undef CVOFFSETTTED\n-\n-  /* Record start of string table.  */\n-  coff_file->strtab_offs = stringsstart;\n-\n-  /* Validate section table entries.  */\n-  for (secnum = 0; secnum < numsections; secnum++)\n-    {\n-      Coff_section coffsec;\n-      lto_coff_section *ltosec;\n-      off_t size_raw, offs_raw, offs_relocs, offs_lines;\n-      off_t num_relocs, num_lines;\n-\n-      n = read (coff_file->fd, &coffsec, sizeof (coffsec));\n-      if (n != sizeof (coffsec))\n-\t{\n-\t  error (\"short/missing COFF section table\");\n-\t  return false;\n-\t}\n-\n-      size_raw = COFF_GET(&coffsec, SizeOfRawData);\n-      offs_raw = COFF_GET(&coffsec, PointerToRawData);\n-      offs_relocs = COFF_GET(&coffsec, PointerToRelocations);\n-      offs_lines = COFF_GET(&coffsec, PointerToLinenumbers);\n-      num_relocs = COFF_GET(&coffsec, NumberOfRelocations);\n-      num_lines = COFF_GET(&coffsec, NumberOfLinenumbers);\n-\n-      if (size_raw < 0 || num_relocs < 0 || num_lines < 0\n-\t|| (size_raw\n-\t  && ((COFF_GET(&coffsec, Characteristics)\n-\t      & IMAGE_SCN_CNT_UNINITIALIZED_DATA)\n-\t    ? (offs_raw != 0)\n-\t    : (offs_raw < sectionsstart || offs_raw >= coff_file->file_size)))\n-\t|| (num_relocs\n-\t  && (offs_relocs < sectionsstart\n-\t    || offs_relocs >= coff_file->file_size))\n-\t|| (num_lines\n-\t  && (offs_lines < sectionsstart\n-\t    || offs_lines >= coff_file->file_size)))\n-\t{\n-\t  error (\"invalid COFF section table\");\n-\t  return false;\n-\t}\n-\n-      /* Looks ok, so record its details.  We don't read the \n-         string table or set up names yet; we'll do that when\n-\t we build the hash table.  */\n-      ltosec = coff_newsection (coff_file, NULL, 0);\n-      memcpy (&ltosec->coffsec, &coffsec, sizeof (ltosec->coffsec));\n-    }\n-\n-  return true;\n-}\n-\n-/* Initialize COFF_FILE's executable header using cached data from previously\n-   read files.  */\n-\n-static void\n-init_coffhdr (lto_coff_file *coff_file)\n-{\n-  gcc_assert (cached_coff_hdr_valid);\n-  memset (&coff_file->coffhdr, 0, sizeof (coff_file->coffhdr));\n-  COFF_PUT(&coff_file->coffhdr, Machine, COFF_GET(&cached_coff_hdr, Machine));\n-  COFF_PUT(&coff_file->coffhdr, Characteristics, COFF_GET(&cached_coff_hdr, Characteristics));\n-}\n-\n-/* Open COFF file FILENAME.  If WRITABLE is true, the file is opened for write\n-   and, if necessary, created.  Otherwise, the file is opened for reading.\n-   Returns the opened file.  */\n-\n-lto_file *\n-lto_obj_file_open (const char *filename, bool writable)\n-{\n-  lto_coff_file *coff_file;\n-  lto_file *result = NULL;\n-  off_t offset;\n-  const char *offset_p;\n-  char *fname;\n-  struct stat statbuf;\n-\n-  offset_p = strchr (filename, '@');\n-  if (!offset_p)\n-    {\n-      fname = xstrdup (filename);\n-      offset = 0;\n-    }\n-  else\n-    {\n-      /* The file started with '@' is a file containing command line\n-\t options.  Stop if it doesn't exist.  */\n-      if (offset_p == filename)\n-\tfatal_error (\"command line option file '%s' does not exist\",\n-\t\t     filename);\n-\n-      fname = (char *) xmalloc (offset_p - filename + 1);\n-      memcpy (fname, filename, offset_p - filename);\n-      fname[offset_p - filename] = '\\0';\n-      offset_p += 3; /* skip the @0x */\n-      offset = lto_parse_hex (offset_p);\n-    }\n-\n-  /* Set up.  */\n-  coff_file = XCNEW (lto_coff_file);\n-  result = (lto_file *) coff_file;\n-  lto_file_init (result, fname, offset);\n-  coff_file->fd = -1;\n-\n-  /* Open the file.  */\n-  coff_file->fd = open (fname,\n-    O_BINARY | (writable ? O_WRONLY | O_CREAT | O_TRUNC : O_RDONLY), 0666);\n-\n-  if (coff_file->fd == -1)\n-    {\n-      error (\"could not open file %s\", fname);\n-      goto fail;\n-    }\n-\n-  if (stat (fname, &statbuf) < 0)\n-    {\n-      error (\"could not stat file %s\", fname);\n-      goto fail;\n-    }\n-\n-  coff_file->file_size = statbuf.st_size;\n-\n-  if (offset != 0)\n-    {\n-      char ar_tail[12];\n-      int size;\n-\n-      /* Surely not?  */\n-      gcc_assert (!writable);\n-\n-      /* Seek to offset, or error.  */\n-      if (lseek (coff_file->fd, offset, SEEK_SET) != (ssize_t) offset)\n-\t{\n-\t  error (\"could not find archive member @0x%lx\", (long) offset);\n-\t  goto fail;\n-\t}\n-\n-      /* Now seek back 12 chars and read the tail of the AR header to\n-         find the length of the member file.  */\n-      if (lseek (coff_file->fd, -12, SEEK_CUR) < 0\n-\t  || read (coff_file->fd, ar_tail, 12) != 12\n-\t  || lseek (coff_file->fd, 0, SEEK_CUR) != (ssize_t) offset\n-\t  || ar_tail[10] != '`' || ar_tail[11] != '\\n')\n-\t{\n-\t  error (\"could not find archive header @0x%lx\", (long) offset);\n-\t  goto fail;\n-\t}\n-\n-      ar_tail[11] = 0;\n-      if (sscanf (ar_tail, \"%d\", &size) != 1)\n-\t{\n-\t  error (\"invalid archive header @0x%lx\", (long) offset);\n-\t  goto fail;\n-\t}\n-      coff_file->file_size = size;\n-    }\n-\n-  if (writable)\n-    {\n-      init_coffhdr (coff_file);\n-      coff_file->shstrtab_stream = XCNEW (struct lto_output_stream);\n-    }\n-  else\n-    if (!validate_file (coff_file))\n-      goto fail;\n-\n-  return result;\n-\n- fail:\n-  if (result)\n-    lto_obj_file_close (result);\n-  return NULL;\n-}\n-\n-\n-/* Close COFF file FILE and clean up any associated data structures.  If FILE\n-   was opened for writing, the file's COFF data is written at this time, and\n-   any cached data buffers are freed.  Return TRUE if there was an error.  */\n-\n-static bool\n-coff_write_object_file (lto_coff_file *coff_file)\n-{\n-  lto_coff_section *cursec, *stringsec;\n-  lto_coff_data *data;\n-  size_t fileoffset, numsections, totalsecsize, numsyms, stringssize;\n-  bool write_err = false;\n-  int secnum;\n-\n-  /* Infer whether this file was opened for reading or writing from the\n-     presence or absense of an initialised stream for the string table;\n-     do nothing if it was opened for reading.  */\n-  if (!coff_file->shstrtab_stream)\n-    return false;\n-  else\n-    {\n-      /* Write the COFF string table into a dummy new section that\n-\t we will not write a header for.  */\n-      lto_file *old_file = lto_set_current_out_file (&coff_file->base);\n-      /* This recursively feeds in the data to a new section.  */\n-      lto_coff_begin_section_with_type (\".strtab\", 1);\n-      lto_write_stream (coff_file->shstrtab_stream);\n-      lto_obj_end_section ();\n-      lto_set_current_out_file (old_file);\n-      free (coff_file->shstrtab_stream);\n-    }\n-\n-  /* Layout the file.  Count sections (not dummy string section) and calculate\n-     data size for all of them.  */\n-  numsections = 0;\n-  totalsecsize = 0;\n-  stringssize = 0;\n-  stringsec = NULL;\n-  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n-    {\n-      lto_coff_data *data;\n-      size_t cursecsize;\n-      cursecsize = 0;\n-      COFF_FOR_ALL_DATA(cursec,data)\n-\tcursecsize += data->d_size;\n-      if (cursec->type == 0)\n-\t{\n-\t  ++numsections;\n-\t  totalsecsize += COFF_ALIGN(cursecsize);\n-#if COFF_ALIGNMENT > 1\n-\t  cursec->pad_needed = COFF_ALIGN(cursecsize) - cursecsize;\n-#endif\n-\t}\n-      else\n-        {\n-\t  stringssize = cursecsize;\n-\t  stringsec = cursec;\n-\t}\n-      COFF_PUT(&cursec->coffsec, SizeOfRawData, cursecsize);\n-    }\n-\n-  /* There is a file symbol and a section symbol per section,\n-     and each of these has a single auxiliary symbol following.  */\n-  numsyms = 2 * (1 + numsections);\n-\n-  /* Great!  Now we have enough info to fill out the file header.  */\n-  COFF_PUT(&coff_file->coffhdr, NumberOfSections, numsections);\n-  COFF_PUT(&coff_file->coffhdr, NumberOfSymbols, numsyms);\n-  COFF_PUT(&coff_file->coffhdr, PointerToSymbolTable, sizeof (Coff_header)\n-\t\t+ numsections * sizeof (Coff_section) + totalsecsize);\n-  /* The remaining members were initialised to zero or copied from\n-     a cached header, so we leave them alone here.  */\n-\n-  /* Now position all the sections, and fill out their headers.  */\n-  fileoffset = sizeof (Coff_header) + numsections * sizeof (Coff_section);\n-  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n-    {\n-      /* Skip dummy string section.  */\n-      if (cursec->type == 1)\n-\tcontinue;\n-      COFF_PUT(&cursec->coffsec, PointerToRawData, fileoffset);\n-      fileoffset += COFF_ALIGN (COFF_GET(&cursec->coffsec, SizeOfRawData));\n-      COFF_PUT(&cursec->coffsec, Characteristics, COFF_SECTION_CHARACTERISTICS);\n-      snprintf ((char *)&cursec->coffsec.Name[0], 8, \"/%d\", cursec->strtab_offs + 4);\n-    }\n-\n-  /* We can write the data now.  As there's no way to indicate an error return\n-     from this hook, error handling is limited to not wasting our time doing\n-     any more writes in the event that any one fails.  */\n-\n-  /* Write the COFF header.  */\n-  write_err = (write (coff_file->fd, &coff_file->coffhdr,\n-\t\tsizeof (coff_file->coffhdr)) != sizeof (coff_file->coffhdr));\n-\n-  /* Write the COFF section headers.  */\n-  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n-    if (cursec->type == 1)\t/* Skip dummy string section.  */\n-\tcontinue;\n-    else if (!write_err)\n-      write_err = (write (coff_file->fd, &cursec->coffsec,\n-\t\tsizeof (cursec->coffsec)) != sizeof (cursec->coffsec));\n-    else\n-      break;\n-\n-  /* Write the COFF sections.  */\n-  COFF_FOR_ALL_SECTIONS(coff_file, cursec)\n-    {\n-#if COFF_ALIGNMENT > 1\n-      static const char padzeros[COFF_ALIGNMENT] = { 0 };\n-#endif\n-      /* Skip dummy string section.  */\n-      if (cursec->type == 1)\n-\tcontinue;\n-      COFF_FOR_ALL_DATA(cursec, data)\n-\tif (!write_err)\n-\t  write_err = (write (coff_file->fd, data->d_buf, data->d_size)\n-\t\t!= data->d_size);\n-\telse\n-\t  break;\n-#if COFF_ALIGNMENT > 1\n-      if (!write_err && cursec->pad_needed)\n-\twrite_err = (write (coff_file->fd, padzeros, cursec->pad_needed)\n-\t\t!= cursec->pad_needed);\n-#endif\n-    }\n-\n-  /* Write the COFF symbol table.  */\n-  if (!write_err)\n-    {\n-      union\n-\t{\n-\t  Coff_symbol sym;\n-\t  Coff_aux_sym_file file;\n-\t  Coff_aux_sym_section sec;\n-\t} symbols[2];\n-      memset (&symbols[0], 0, sizeof (symbols));\n-      strcpy ((char *) &symbols[0].sym.Name[0], \".file\");\n-      COFF_PUT(&symbols[0].sym, SectionNumber, IMAGE_SYM_DEBUG);\n-      COFF_PUT(&symbols[0].sym, Type, IMAGE_SYM_TYPE);\n-      symbols[0].sym.StorageClass[0] = IMAGE_SYM_CLASS_FILE;\n-      symbols[0].sym.NumberOfAuxSymbols[0] = 1;\n-      snprintf ((char *)symbols[1].file.FileName,\n-\t\tsizeof (symbols[1].file.FileName),\n-\t\t\"%s\", lbasename (coff_file->base.filename));\n-      write_err = (write (coff_file->fd, &symbols[0], sizeof (symbols))\n-\t\t!= (2 * COFF_SYMBOL_SIZE));\n-\n-      /* Set up constant parts for section sym loop.  */\n-      memset (&symbols[0], 0, sizeof (symbols));\n-      COFF_PUT(&symbols[0].sym, Type, IMAGE_SYM_TYPE);\n-      symbols[0].sym.StorageClass[0] = IMAGE_SYM_CLASS_STATIC;\n-      symbols[0].sym.NumberOfAuxSymbols[0] = 1;\n-\n-      secnum = 1;\n-      if (!write_err)\n-\tCOFF_FOR_ALL_SECTIONS(coff_file, cursec)\n-\t  {\n-\t    /* Skip dummy string section.  */\n-\t    if (cursec->type == 1)\n-\t      continue;\n-\t    /* Reuse section name string for section symbol name.  */\n-\t    COFF_PUT_NDXSZ(&symbols[0].sym, Name, 0, 0, 4);\n-\t    COFF_PUT_NDXSZ(&symbols[0].sym, Name, cursec->strtab_offs + 4, 4, 4);\n-\t    COFF_PUT(&symbols[0].sym, SectionNumber, secnum++);\n-\t    COFF_PUT(&symbols[1].sec, Length,\n-\t\t\tCOFF_GET(&cursec->coffsec, SizeOfRawData));\n-\t    if (!write_err)\n-\t      write_err = (write (coff_file->fd, &symbols[0], sizeof (symbols))\n-\t\t\t!= (2 * COFF_SYMBOL_SIZE));\n-\t    else\n-\t      break;\n-\t  }\n-    }\n-\n-  /* Write the COFF string table.  */\n-  if (!write_err)\n-    {\n-      unsigned char outlen[4];\n-      COFF_PUT4(outlen, stringssize + 4);\n-      if (!write_err)\n-\twrite_err = (write (coff_file->fd, outlen, 4) != 4);\n-      if (stringsec)\n-\t{\n-\t  COFF_FOR_ALL_DATA(stringsec, data)\n-\t    if (!write_err)\n-\t      write_err = (write (coff_file->fd, data->d_buf, data->d_size)\n-\t\t\t   != data->d_size);\n-\t    else\n-\t      break;\n-\t}\n-    }\n-\n-  return write_err;\n-}\n-\n-/* Close COFF file FILE and clean up any associated data structures.  If FILE\n-   was opened for writing, the file's COFF data is written at this time, and\n-   any cached data buffers are freed.  */\n-\n-void\n-lto_obj_file_close (lto_file *file)\n-{\n-  lto_coff_file *coff_file = (lto_coff_file *) file;\n-  struct lto_char_ptr_base *cur, *tmp;\n-  lto_coff_section *cursec, *nextsec;\n-  bool write_err = false;\n-\n-  /* Write the COFF string table into a dummy new section that\n-     we will not write a header for.  */\n-  if (coff_file->shstrtab_stream)\n-    coff_write_object_file (coff_file);\n-\n-  /* Close the file, we're done.  */\n-  if (coff_file->fd != -1)\n-    close (coff_file->fd);\n-\n-  /* Free any data buffers.  */\n-  cur = coff_file->data;\n-  while (cur)\n-    {\n-      tmp = cur;\n-      cur = (struct lto_char_ptr_base *) cur->ptr;\n-      free (tmp);\n-    }\n-\n-  /* Free any sections and their data chains.  */\n-  cursec = coff_file->section_chain;\n-  while (cursec)\n-    {\n-      lto_coff_data *curdata, *nextdata;\n-      nextsec = cursec->next;\n-      curdata = cursec->data_chain;\n-      while (curdata)\n-\t{\n-\t  nextdata = curdata->next;\n-\t  free (curdata);\n-\t  curdata = nextdata;\n-\t}\n-      free (cursec);\n-      cursec = nextsec;\n-    }\n-\n-  free (file);\n-\n-  /* If there was an error, mention it.  */\n-  if (write_err)\n-    error (\"I/O error writing COFF output file\");\n-}\n-"}, {"sha": "bdc9fa5222204292a644cafc1827ce3503220c37", "filename": "gcc/lto/lto-coff.h", "status": "removed", "additions": 0, "deletions": 408, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-coff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-coff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-coff.h?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1,408 +0,0 @@\n-/* LTO routines for COFF object files.\n-   Copyright 2009 Free Software Foundation, Inc.\n-   Contributed by Dave Korn.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LTO_COFF_H\n-#define LTO_COFF_H\n-\n-/* Rather than implementing a libcoff to match libelf, or attempting to\n-   integrate libbfd into GCC, this file is a self-contained (and very\n-   minimal) COFF format object file reader/writer.  The generated files\n-   will contain a COFF header, a number of COFF section headers, the \n-   section data itself, and a trailing string table for section names.  */\n-\n-/* Alignment of sections in a COFF object file.\n-\n-   The LTO writer uses zlib compression on the data that it streams into\n-   LTO sections in the output object file.  Because these streams don't\n-   have any embedded size information, the section in the object file must\n-   be exactly sized to the data emitted; any trailing padding bytes will\n-   be interpreted as partial and/or corrupt compressed data.\n-\n-   This is easy enough to do on COFF targets (with binutils 2.20.1 or\n-   above) because we can specify 1-byte alignment for the LTO sections.\n-   They are then emitted precisely-sized and byte-packed into the object\n-   and the reader is happy when it parses them later.  This is currently\n-   implemented in the x86/windows backed in i386_pe_asm_named_section()\n-   in config/i386/winnt.c by detecting the LTO section name prefix, \n-\n-   That would be sufficient, but for one thing.  At the start of the LTO\n-   data is a header struct with (currently) a couple of version numbers and\n-   some type info; see struct lto_header in lto-streamer.h.  If the sections\n-   are byte-packed, this header will not necessarily be correctly-aligned\n-   when it is read back into memory.\n-\n-   On x86 targets, which are currently the only LTO-COFF targets, misaligned\n-   memory accesses aren't problematic (okay, inefficient, but not worth\n-   worrying about two half-word memory reads per section in the context of\n-   everything else the compiler has to do at the time!), but RISC targets may\n-   fail on trying to access the header struct.  In this case, it will be\n-   necessary to enable (preferably in a target-dependent fashion, but a few\n-   bytes of padding are hardly an important issue if it comes down to it) the\n-   COFF_ALIGNMENT macros below.\n-\n-   As currently implemented, this will emit padding to the necessary number\n-   of bytes after each LTO section.  These bytes will constitute 'gaps' in\n-   the object file structure, as they won't be covered by any section header.\n-   This hasn't yet been tested, because no such RISC LTO-COFF target yet\n-   exists.  If it causes problems further down the toolchain, it will be\n-   necessary to adapt the code to emit additional section headers for these\n-   padding bytes, but the odds are that it will \"just work\".\n-\n-  */\n-\n-#if 0\n-#define COFF_ALIGNMENT\t (4)\n-#define COFF_ALIGNMENTM1 (COFF_ALIGNMENT - 1)\n-#define COFF_ALIGN(x)\t (((x) + COFF_ALIGNMENTM1) & ~COFF_ALIGNMENTM1)\n-#else\n-#define COFF_ALIGNMENT\t (1)\n-#define COFF_ALIGN(x)\t (x)\n-#endif\n-\n-/* COFF header machine codes.  */\n-\n-#define IMAGE_FILE_MACHINE_I386\t(0x014c)\n-#define IMAGE_FILE_MACHINE_AMD64 (0x8664)\n-\n-/* Known header magics for validation, as an array initialiser.  */\n-\n-#define COFF_KNOWN_MACHINES \\\n-  { IMAGE_FILE_MACHINE_I386, \\\n-    IMAGE_FILE_MACHINE_AMD64/*, ... add more here when working.  */ }\n-\n-/* COFF object file header, section and symbol flags and types.  These are\n-   currently specific to PE-COFF, which is the only LTO-COFF format at the\n-   time of writing.  Maintainers adding support for new COFF formats will\n-   need to make these into target macros of some kind.  */\n-\n-/* COFF header characteristics.  */\n-\n-#define IMAGE_FILE_EXECUTABLE_IMAGE\t(1 << 1)\n-#define IMAGE_FILE_32BIT_MACHINE\t(1 << 8)\n-#define IMAGE_FILE_SYSTEM\t\t(1 << 12)\n-#define IMAGE_FILE_DLL\t\t\t(1 << 13)\n-\n-/* Desired characteristics (for validation).  */\n-\n-#define COFF_CHARACTERISTICS \\\n-  (IMAGE_FILE_32BIT_MACHINE)\n-\n-/* Unwanted characteristics (for validation).  */\n-\n-#define COFF_NOT_CHARACTERISTICS \\\n-  (IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_SYSTEM | IMAGE_FILE_DLL)\n-\n-/* Section flags.  LTO emits byte-aligned read-only loadable data sections.  */\n-\n-#define IMAGE_SCN_CNT_INITIALIZED_DATA\t (1 << 6)\n-#define IMAGE_SCN_CNT_UNINITIALIZED_DATA (1 << 7)\n-#define IMAGE_SCN_ALIGN_1BYTES\t\t (0x1 << 20)\n-#define IMAGE_SCN_MEM_DISCARDABLE\t (1 << 25)\n-#define\tIMAGE_SCN_MEM_SHARED\t\t (1 << 28)\n-#define IMAGE_SCN_MEM_READ\t\t (1 << 30)\n-\n-#define COFF_SECTION_CHARACTERISTICS \\\n-  (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_ALIGN_1BYTES | \\\n-  IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_SHARED | IMAGE_SCN_MEM_READ)\n-\n-/* Symbol-related constants.  */\n-\n-#define IMAGE_SYM_DEBUG\t\t(-2)\n-#define IMAGE_SYM_TYPE_NULL\t(0)\n-#define IMAGE_SYM_DTYPE_NULL\t(0)\n-#define IMAGE_SYM_CLASS_STATIC\t(3)\n-#define IMAGE_SYM_CLASS_FILE\t(103)\n-\n-#define IMAGE_SYM_TYPE \\\n-  ((IMAGE_SYM_DTYPE_NULL << 4) | IMAGE_SYM_TYPE_NULL)\n-\n-/* Size of a COFF symbol in bytes.  */\n-\n-#define COFF_SYMBOL_SIZE\t(18)\n-\n-/* On-disk file structures.  */\n-\n-struct Coff_header\n-{\n-  unsigned char Machine[2];\n-  unsigned char NumberOfSections[2];\n-  unsigned char TimeDateStamp[4];\n-  unsigned char PointerToSymbolTable[4];\n-  unsigned char NumberOfSymbols[4];\n-  unsigned char SizeOfOptionalHeader[2];\n-  unsigned char Characteristics[2];\n-};\n-typedef struct Coff_header Coff_header;\n-\n-struct Coff_section\n-{\n-  unsigned char Name[8];\n-  unsigned char VirtualSize[4];\n-  unsigned char VirtualAddress[4];\n-  unsigned char SizeOfRawData[4];\n-  unsigned char PointerToRawData[4];\n-  unsigned char PointerToRelocations[4];\n-  unsigned char PointerToLinenumbers[4];\n-  unsigned char NumberOfRelocations[2];\n-  unsigned char NumberOfLinenumbers[2];\n-  unsigned char Characteristics[4];\n-};\n-typedef struct Coff_section Coff_section;\n-\n-struct Coff_symbol\n-{\n-  unsigned char Name[8];\n-  unsigned char Value[4];\n-  unsigned char SectionNumber[2];\n-  unsigned char Type[2];\n-  unsigned char StorageClass[1];\n-  unsigned char NumberOfAuxSymbols[1];\n-};\n-typedef struct Coff_symbol Coff_symbol;\n-\n-struct Coff_aux_sym_file\n-{\n-  unsigned char FileName[18];\n-};\n-typedef struct Coff_aux_sym_file Coff_aux_sym_file;\n-\n-struct Coff_aux_sym_section\n-{\n-  unsigned char Length[4];\n-  unsigned char NumberOfRelocations[2];\n-  unsigned char NumberOfLineNumbers[2];\n-  unsigned char Checksum[4];\n-  unsigned char Number[2];\n-  unsigned char Selection[1];\n-  unsigned char Unused[3];\n-};\n-typedef struct Coff_aux_sym_section Coff_aux_sym_section;\n-\n-/* Accessor macros for the above structures.  */\n-\n-#define COFF_GET(struc,memb) \\\n-  ((COFFENDIAN ? get_be : get_le) (&(struc)->memb[0], sizeof ((struc)->memb)))\n-\n-#define COFF_PUT(struc,memb,val) \\\n-  ((COFFENDIAN ? put_be : put_le) (&(struc)->memb[0], sizeof ((struc)->memb), val))\n-\n-#define COFF_PUT_NDXSZ(struc,memb,val,ndx,sz) \\\n-  ((COFFENDIAN ? put_be : put_le) (&(struc)->memb[ndx], sz, val))\n-\n-/* In-memory file structures.  */\n-\n-/* Forward declared structs.  */\n-\n-struct lto_coff_data;\n-struct lto_coff_section;\n-struct lto_coff_file;\n-\n-/* Section data in output files is made of these.  */\n-\n-struct lto_coff_data\n-{\n-  /* Pointer to data block.  */\n-  void *d_buf;\n-\n-  /* Size of data block.  */\n-  ssize_t d_size;\n-\n-  /* Next data block for this section.  */\n-  struct lto_coff_data *next;\n-};\n-typedef struct lto_coff_data lto_coff_data;\n-\n-/* This struct tracks the data for a section.  */\n-\n-struct lto_coff_section\n-{\n-  /* Singly-linked list of section's data blocks.  */\n-  lto_coff_data *data_chain;\n-\n-  /* Offset in string table of name.  */\n-  size_t strtab_offs;\n-\n-  /* Section type: 0 = real, 1 = dummy.  */\n-  size_t type;\n-\n-  /* Section name.  */\n-  const char *name;\n-\n-#if COFF_ALIGNMENT > 1\n-  /* Number of trailing padding bytes needed.  */\n-  ssize_t pad_needed;\n-#endif\n-\n-  /* Raw section header data.  */\n-  Coff_section coffsec;\n-\n-  /* Next section for this file.  */\n-  struct lto_coff_section *next;\n-};\n-typedef struct lto_coff_section lto_coff_section;\n-\n-/* A COFF file.  */\n-\n-struct lto_coff_file \n-{\n-  /* The base information.  */\n-  lto_file base;\n-\n-  /* Common file members:  */\n-\n-  /* The system file descriptor for the file.  */\n-  int fd;\n-\n-  /* The file's overall header.  */\n-  Coff_header coffhdr;\n-\n-  /* All sections in a singly-linked list.  */\n-  lto_coff_section *section_chain;\n-\n-  /* Readable file members:  */\n-\n-  /* File total size.  */\n-  off_t file_size;\n-\n-  /* String table file offset, relative to base.offset.  */\n-  off_t strtab_offs;\n-\n-  /* Writable file members:  */\n-\n-  /* The currently active section.  */\n-  lto_coff_section *scn;\n-\n-  /* The output stream for section header names.  */\n-  struct lto_output_stream *shstrtab_stream;\n-\n-  /* Linked list of data which must be freed *after* the file has been\n-     closed.  This is an annoying limitation of libelf.  Which has been\n-     faithfully reproduced here.  */\n-  struct lto_char_ptr_base *data;\n-};\n-typedef struct lto_coff_file lto_coff_file;\n-\n-/* Data hunk iterator.  */\n-\n-#define COFF_FOR_ALL_DATA(sec,var) \\\n-  for (var = sec->data_chain; var; var = var->next)\n-\n-/* Section list iterator.  */\n-\n-#define COFF_FOR_ALL_SECTIONS(file,var) \\\n-  for (var = file->section_chain; var; var = var->next)\n-\n-/* Very simple endian-ness layer.  */\n-\n-#ifndef COFFENDIAN\n-#define COFFENDIAN (BYTES_BIG_ENDIAN)\n-#endif\n-\n-static inline unsigned int\n-get_2_le (const unsigned char *ptr)\n-{\n-  return ptr[0] | (ptr[1] << 8);\n-}\n-\n-static inline unsigned int\n-get_4_le (const unsigned char *ptr)\n-{\n-  return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24);\n-}\n-\n-static inline unsigned int\n-get_2_be (const unsigned char *ptr)\n-{\n-  return ptr[1] | (ptr[0] << 8);\n-}\n-\n-static inline unsigned int\n-get_4_be (const unsigned char *ptr)\n-{\n-  return ptr[3] | (ptr[2] << 8) | (ptr[1] << 16) | (ptr[0] << 24);\n-}\n-\n-static inline unsigned int\n-get_be (const unsigned char *ptr, size_t size)\n-{\n-  gcc_assert (size == 4 || size == 2);\n-  return (size == 2) ? get_2_be (ptr) : get_4_be (ptr);\n-}\n-\n-static inline unsigned int\n-get_le (const unsigned char *ptr, size_t size)\n-{\n-  gcc_assert (size == 4 || size == 2);\n-  return (size == 2) ? get_2_le (ptr) : get_4_le (ptr);\n-}\n-\n-static inline void\n-put_2_le (unsigned char *ptr, unsigned int data)\n-{\n-  ptr[0] = data & 0xff;\n-  ptr[1] = (data >> 8) & 0xff;\n-}\n-\n-static inline void\n-put_4_le (unsigned char *ptr, unsigned int data)\n-{\n-  ptr[0] = data & 0xff;\n-  ptr[1] = (data >> 8) & 0xff;\n-  ptr[2] = (data >> 16) & 0xff;\n-  ptr[3] = (data >> 24) & 0xff;\n-}\n-\n-static inline void\n-put_2_be (unsigned char *ptr, unsigned int data)\n-{\n-  ptr[1] = data & 0xff;\n-  ptr[0] = (data >> 8) & 0xff;\n-}\n-\n-static inline void\n-put_4_be (unsigned char *ptr, unsigned int data)\n-{\n-  ptr[3] = data & 0xff;\n-  ptr[2] = (data >> 8) & 0xff;\n-  ptr[1] = (data >> 16) & 0xff;\n-  ptr[0] = (data >> 24) & 0xff;\n-}\n-\n-static inline void\n-put_le (unsigned char *ptr, size_t size, unsigned int data)\n-{\n-  gcc_assert (size == 4 || size == 2);\n-  (void) (size == 2 ? put_2_le : put_4_le) (ptr, data);\n-}\n-\n-static inline void\n-put_be (unsigned char *ptr, size_t size, unsigned int data)\n-{\n-  gcc_assert (size == 4 || size == 2);\n-  (void) (size == 2 ? put_2_be : put_4_be) (ptr, data);\n-}\n-\n-/* We use this for putting the string table size.  */\n-\n-#define COFF_PUT4(ptr, data) \\\n-  ((COFFENDIAN ? put_4_be : put_4_le) (ptr, data))\n-\n-\n-#endif /* LTO_COFF_H */"}, {"sha": "6268a9c0bf9a4d696b2506196ebd8b87bc1b3917", "filename": "gcc/lto/lto-elf.c", "status": "removed", "additions": 0, "deletions": 817, "changes": 817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-elf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-elf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-elf.c?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1,817 +0,0 @@\n-/* LTO routines for ELF object files.\n-   Copyright 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by CodeSourcery, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"diagnostic-core.h\"\n-#include \"toplev.h\"\n-#include <gelf.h>\n-#include \"lto.h\"\n-#include \"tm.h\"\n-#include \"libiberty.h\"\n-#include \"ggc.h\"\n-#include \"lto-streamer.h\"\n-\n-/* Cater to hosts with half-backed <elf.h> file like HP-UX.  */\n-#ifndef EM_SPARC\n-# define EM_SPARC 2\n-#endif\n-\n-#ifndef EM_SPARC32PLUS\n-# define EM_SPARC32PLUS 18\n-#endif\n-\n-#ifndef ELFOSABI_NONE\n-# define ELFOSABI_NONE 0\n-#endif\n-\n-#ifndef ELFOSABI_LINUX\n-# define ELFOSABI_LINUX 3\n-#endif\n-\n-#ifndef SHN_XINDEX\n-# define SHN_XINDEX 0xffff\n-#endif\n-\n-\n-/* Handle opening elf files on hosts, such as Windows, that may use \n-   text file handling that will break binary access.  */\n-#ifndef O_BINARY\n-# define O_BINARY 0\n-#endif\n-\n-\n-/* Initialize FILE, an LTO file object for FILENAME.  */\n-static void\n-lto_file_init (lto_file *file, const char *filename, off_t offset)\n-{\n-  file->filename = filename;\n-  file->offset = offset;\n-}\n-\n-/* An ELF file.  */\n-struct lto_elf_file \n-{\n-  /* The base information.  */\n-  lto_file base;\n-\n-  /* The system file descriptor for the file.  */\n-  int fd;\n-\n-  /* The libelf descriptor for the file.  */\n-  Elf *elf;\n-\n-  /* Section number of string table used for section names.  */\n-  size_t sec_strtab;\n-\n-  /* Writable file members.  */\n-\n-  /* The currently active section.  */\n-  Elf_Scn *scn;\n-\n-  /* The output stream for section header names.  */\n-  struct lto_output_stream *shstrtab_stream;\n-\n-  /* Linked list of data which must be freed *after* the file has been\n-     closed.  This is an annoying limitation of libelf.  */\n-  struct lto_char_ptr_base *data;\n-};\n-typedef struct lto_elf_file lto_elf_file;\n-\n-/* Stores executable header attributes which must be shared by all ELF files.\n-   This is used for validating input files and populating output files.  */\n-static struct {\n-  bool initialized;\n-  /* 32 or 64 bits?  */\n-  size_t bits;\n-  unsigned char elf_ident[EI_NIDENT];\n-  Elf64_Half elf_machine;\n-} cached_file_attrs;\n-\n-\n-/* Return the section header for SECTION.  The return value is never\n-   NULL.  Call lto_elf_free_shdr to release the memory allocated.  */\n-\n-static Elf64_Shdr *\n-lto_elf_get_shdr (Elf_Scn *section)\n-{\n-  Elf64_Shdr *shdr;\n-\n-  switch (cached_file_attrs.bits)\n-    {\n-    case 32:\n-      {\n-\tElf32_Shdr *shdr32;\n-\n-\t/* Read the 32-bit section header.  */\n-\tshdr32 = elf32_getshdr (section);\n-\tif (!shdr32)\n-\t  fatal_error (\"could not read section header: %s\", elf_errmsg (0));\n-\n-\t/* Transform it into a 64-bit section header.  */\n-\tshdr = XNEW (Elf64_Shdr);\n-\tshdr->sh_name = shdr32->sh_name;\n-\tshdr->sh_type = shdr32->sh_type;\n-\tshdr->sh_flags = shdr32->sh_flags;\n-\tshdr->sh_addr = shdr32->sh_addr;\n-\tshdr->sh_offset = shdr32->sh_offset;\n-\tshdr->sh_size = shdr32->sh_size;\n-\tshdr->sh_link = shdr32->sh_link;\n-\tshdr->sh_info = shdr32->sh_info;\n-\tshdr->sh_addralign = shdr32->sh_addralign;\n-\tshdr->sh_entsize  = shdr32->sh_entsize;\n-\tbreak;\n-      }\n-      break;\n-\n-    case 64:\n-      shdr = elf64_getshdr (section);\n-      if (!shdr)\n-\tfatal_error (\"could not read section header: %s\", elf_errmsg (0));\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return shdr;\n-}\n-\n-/* Free SHDR, previously allocated by lto_elf_get_shdr.  */\n-static void\n-lto_elf_free_shdr (Elf64_Shdr *shdr)\n-{\n-  if (cached_file_attrs.bits != 64)\n-    free (shdr);\n-}\n-\n-/* Build a hash table whose key is the section names and whose data is\n-   the start and size of each section in the .o file.  */\n-\n-htab_t\n-lto_obj_build_section_table (lto_file *lto_file) \n-{\n-  lto_elf_file *elf_file = (lto_elf_file *)lto_file;\n-  htab_t section_hash_table;\n-  Elf_Scn *section;\n-  size_t base_offset;\n-\n-  section_hash_table = lto_obj_create_section_hash_table ();\n-\n-  base_offset = elf_getbase (elf_file->elf);\n-  /* We are reasonably sure that elf_getbase does not fail at this\n-     point.  So assume that we run into the incompatibility with\n-     the FreeBSD libelf implementation that has a non-working\n-     elf_getbase for non-archive members in which case the offset\n-     should be zero.  */\n-  if (base_offset == (size_t)-1)\n-    base_offset = 0;\n-  for (section = elf_getscn (elf_file->elf, 0);\n-       section;\n-       section = elf_nextscn (elf_file->elf, section)) \n-    {\n-      Elf64_Shdr *shdr;\n-      const char *name;\n-      size_t offset;\n-      char *new_name;\n-      void **slot;\n-      struct lto_section_slot s_slot;\n-\n-      /* Get the name of this section.  */\n-      shdr = lto_elf_get_shdr (section);\n-      offset = shdr->sh_name;\n-      name = elf_strptr (elf_file->elf, \n-\t\t\t elf_file->sec_strtab,\n-\t\t\t offset);\n-\n-      /* Only put lto stuff into the symtab.  */\n-      if (strncmp (name, LTO_SECTION_NAME_PREFIX, \n-\t\t   strlen (LTO_SECTION_NAME_PREFIX)) != 0)\n-\t{\n-\t  lto_elf_free_shdr (shdr);\n-\t  continue;\n-\t}\n-\n-      new_name = XNEWVEC (char, strlen (name) + 1);\n-      strcpy (new_name, name);\n-      s_slot.name = new_name;\n-      slot = htab_find_slot (section_hash_table, &s_slot, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  struct lto_section_slot *new_slot = XNEW (struct lto_section_slot);\n-\n-\t  new_slot->name = new_name;\n-\t  /* The offset into the file for this section.  */\n-\t  new_slot->start = base_offset + shdr->sh_offset;\n-\t  new_slot->len = shdr->sh_size;\n-\t  *slot = new_slot;\n-\t}\n-      else\n-\t{\n-\t  error (\"two or more sections for %s:\", new_name);\n-\t  return NULL;\n-\t}\n-\n-      lto_elf_free_shdr (shdr);\n-    }\n-\n-  return section_hash_table;\n-}\n-\n-\n-/* Initialize the section header of section SCN.  SH_NAME is the section name\n-   as an index into the section header string table.  SH_TYPE is the section\n-   type, an SHT_* macro from libelf headers.  */\n-\n-#define DEFINE_INIT_SHDR(BITS)\t\t\t\t\t      \\\n-static void\t\t\t\t\t\t\t      \\\n-init_shdr##BITS (Elf_Scn *scn, size_t sh_name, size_t sh_type)\t      \\\n-{\t\t\t\t\t\t\t\t      \\\n-  Elf##BITS##_Shdr *shdr;\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t      \\\n-  shdr = elf##BITS##_getshdr (scn);\t\t\t\t      \\\n-  if (!shdr)\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t      \\\n-      if (BITS == 32)\t\t\t\t\t\t      \\\n-\tfatal_error (\"elf32_getshdr() failed: %s\", elf_errmsg (-1));  \\\n-      else\t\t\t\t\t\t\t      \\\n-\tfatal_error (\"elf64_getshdr() failed: %s\", elf_errmsg (-1));  \\\n-    }\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t      \\\n-  shdr->sh_name = sh_name;\t\t\t\t\t      \\\n-  shdr->sh_type = sh_type;\t\t\t\t\t      \\\n-  shdr->sh_addralign = POINTER_SIZE / BITS_PER_UNIT;\t\t      \\\n-  shdr->sh_flags = 0;\t\t\t\t\t\t      \\\n-  shdr->sh_entsize = 0;\t\t\t\t\t\t      \\\n-}\n-\n-DEFINE_INIT_SHDR (32)\n-DEFINE_INIT_SHDR (64)\n-\n-static bool first_data_block;\n-\n-/* Begin a new ELF section named NAME with type TYPE in the current output\n-   file.  TYPE is an SHT_* macro from the libelf headers.  */\n-\n-static void\n-lto_elf_begin_section_with_type (const char *name, size_t type)\n-{\n-  lto_elf_file *file;\n-  Elf_Scn *scn;\n-  size_t sh_name;\n-\n-  /* Grab the current output file and do some basic assertion checking.  */\n-  file = (lto_elf_file *) lto_get_current_out_file (),\n-  gcc_assert (file);\n-  gcc_assert (file->elf);\n-  gcc_assert (!file->scn);\n-\n-  /* Create a new section.  */\n-  scn = elf_newscn (file->elf);\n-  if (!scn)\n-    fatal_error (\"could not create a new ELF section: %s\", elf_errmsg (-1));\n-  file->scn = scn;\n-\n-  /* Add a string table entry and record the offset.  */\n-  gcc_assert (file->shstrtab_stream);\n-  sh_name = file->shstrtab_stream->total_size;\n-  lto_output_data_stream (file->shstrtab_stream, name, strlen (name) + 1);\n-\n-  /* Initialize the section header.  */\n-  switch (cached_file_attrs.bits)\n-    {\n-    case 32:\n-      init_shdr32 (scn, sh_name, type);\n-      break;\n-\n-    case 64:\n-      init_shdr64 (scn, sh_name, type);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  first_data_block = true;\n-}\n-\n-\n-/* Begin a new ELF section named NAME in the current output file.  */\n-\n-void\n-lto_obj_begin_section (const char *name)\n-{\n-  lto_elf_begin_section_with_type (name, SHT_PROGBITS);\n-}\n-\n-\n-/* Append DATA of length LEN to the current output section.  BASE is a pointer\n-   to the output page containing DATA.  It is freed once the output file has\n-   been written.  */\n-\n-void\n-lto_obj_append_data (const void *data, size_t len, void *block)\n-{\n-  lto_elf_file *file;\n-  Elf_Data *elf_data;\n-  struct lto_char_ptr_base *base = (struct lto_char_ptr_base *) block;\n-\n-  /* Grab the current output file and do some basic assertion checking.  */\n-  file = (lto_elf_file *) lto_get_current_out_file ();\n-  gcc_assert (file);\n-  gcc_assert (file->scn);\n-\n-  elf_data = elf_newdata (file->scn);\n-  if (!elf_data)\n-    fatal_error (\"could not append data to ELF section: %s\", elf_errmsg (-1));\n-\n-  if (first_data_block)\n-    {\n-      elf_data->d_align = POINTER_SIZE / BITS_PER_UNIT;\n-      first_data_block = false;\n-    }\n-  else\n-    elf_data->d_align = 1;\n-  elf_data->d_buf = CONST_CAST (void *, data);\n-  elf_data->d_off = 0LL;\n-  elf_data->d_size = len;\n-  elf_data->d_type = ELF_T_BYTE;\n-  elf_data->d_version = EV_CURRENT;\n-\n-  base->ptr = (char *)file->data;\n-  file->data = base;\n-}\n-\n-\n-/* End the current output section.  This just does some assertion checking\n-   and sets the current output file's scn member to NULL.  */\n-\n-void\n-lto_obj_end_section (void)\n-{\n-  lto_elf_file *file;\n-\n-  /* Grab the current output file and validate some basic assertions.  */\n-  file = (lto_elf_file *) lto_get_current_out_file ();\n-  gcc_assert (file);\n-  gcc_assert (file->scn);\n-\n-  file->scn = NULL;\n-}\n-\n-\n-/* Return true if ELF_MACHINE is compatible with the cached value of the\n-   architecture and possibly update the latter.  Return false otherwise.\n-\n-   Note: if you want to add more EM_* cases, you'll need to provide the\n-   corresponding definitions at the beginning of the file.  */\n-\n-static bool\n-is_compatible_architecture (Elf64_Half elf_machine)\n-{\n-  if (cached_file_attrs.elf_machine == elf_machine)\n-    return true;\n-\n-  switch (cached_file_attrs.elf_machine)\n-    {\n-    case EM_SPARC:\n-      if (elf_machine == EM_SPARC32PLUS)\n-\t{\n-\t  cached_file_attrs.elf_machine = elf_machine;\n-\t  return true;\n-\t}\n-      break;\n-\n-    case EM_SPARC32PLUS:\n-      if (elf_machine == EM_SPARC)\n-\treturn true;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return false;\n-}\n-\n-\n-/* Validate's ELF_FILE's executable header and, if cached_file_attrs is\n-   uninitialized, caches the architecture.  */\n-\n-#define DEFINE_VALIDATE_EHDR(BITS)\t\t\t\t\\\n-static bool\t\t\t\t\t\t\t\\\n-validate_ehdr##BITS (lto_elf_file *elf_file)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  Elf##BITS##_Ehdr *elf_header;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  elf_header = elf##BITS##_getehdr (elf_file->elf);\t\t\\\n-  if (!elf_header)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      error (\"could not read ELF header: %s\", elf_errmsg (0));\t\\\n-      return false;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  if (elf_header->e_type != ET_REL)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      error (\"not a relocatable ELF object file\");\t\t\\\n-      return false;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  if (!cached_file_attrs.initialized)\t\t\t\t\\\n-    cached_file_attrs.elf_machine = elf_header->e_machine;\t\\\n-  else if (!is_compatible_architecture (elf_header->e_machine))\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      error (\"inconsistent file architecture detected\");\t\\\n-      return false;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  return true;\t\t\t\t\t\t\t\\\n-}\n-\n-DEFINE_VALIDATE_EHDR (32)\n-DEFINE_VALIDATE_EHDR (64)\n-\n-\n-#ifndef HAVE_ELF_GETSHDRSTRNDX\n-/* elf_getshdrstrndx replacement for systems that lack it, but provide\n-   either the gABI conformant or Solaris 2 variant of elf_getshstrndx\n-   instead.  */\n-\n-static int\n-elf_getshdrstrndx (Elf *elf, size_t *dst)\n-{\n-#ifdef HAVE_ELF_GETSHSTRNDX_GABI\n-  return elf_getshstrndx (elf, dst);\n-#else\n-  return elf_getshstrndx (elf, dst) ? 0 : -1;\n-#endif\n-}\n-#endif\n-\n-/* Validate's ELF_FILE's executable header and, if cached_file_attrs is\n-   uninitialized, caches the results.  Also records the section header string\n-   table's section index.  Returns true on success or false on failure.  */\n-\n-static bool\n-validate_file (lto_elf_file *elf_file)\n-{\n-  const char *elf_ident;\n-\n-  /* Some aspects of the libelf API are dependent on whether the\n-     object file is a 32-bit or 64-bit file.  Determine which kind of\n-     file this is now.  */\n-  elf_ident = elf_getident (elf_file->elf, NULL);\n-  if (!elf_ident)\n-    {\n-      error (\"could not read ELF identification information: %s\",\n-\t      elf_errmsg (0));\n-      return false;\n-    }\n-\n-  if (!cached_file_attrs.initialized)\n-    {\n-      switch (elf_ident[EI_CLASS])\n-\t{\n-\tcase ELFCLASS32:\n-\t  cached_file_attrs.bits = 32;\n-\t  break;\n-\n-\tcase ELFCLASS64:\n-\t  cached_file_attrs.bits = 64;\n-\t  break;\n-\n-\tdefault:\n-\t  error (\"unsupported ELF file class\");\n-\t  return false;\n-\t}\n-\n-      memcpy (cached_file_attrs.elf_ident, elf_ident,\n-\t      sizeof cached_file_attrs.elf_ident);\n-    }\n-  else\n-    {\n-      char elf_ident_buf[EI_NIDENT];\n-\n-      memcpy (elf_ident_buf, elf_ident, sizeof elf_ident_buf);\n-\n-      if (elf_ident_buf[EI_OSABI] != cached_file_attrs.elf_ident[EI_OSABI])\n-\t{\n-\t  /* Allow mixing ELFOSABI_NONE with ELFOSABI_LINUX, with the result\n-\t     ELFOSABI_LINUX.  */\n-\t  if (elf_ident_buf[EI_OSABI] == ELFOSABI_NONE\n-\t      && cached_file_attrs.elf_ident[EI_OSABI] == ELFOSABI_LINUX)\n-\t    elf_ident_buf[EI_OSABI] = cached_file_attrs.elf_ident[EI_OSABI];\n-\t  else if (elf_ident_buf[EI_OSABI] == ELFOSABI_LINUX\n-\t\t   && cached_file_attrs.elf_ident[EI_OSABI] == ELFOSABI_NONE)\n-\t    cached_file_attrs.elf_ident[EI_OSABI] = elf_ident_buf[EI_OSABI];\n-\t}\n-\n-      if (memcmp (elf_ident_buf, cached_file_attrs.elf_ident,\n-\t\t  sizeof cached_file_attrs.elf_ident))\n-\t{\n-\t  error (\"incompatible ELF identification\");\n-\t  return false;\n-\t}\n-    }\n-\n-  /* Check that the input file is a relocatable object file with the correct\n-     architecture.  */\n-  switch (cached_file_attrs.bits)\n-    {\n-    case 32:\n-      if (!validate_ehdr32 (elf_file))\n-\treturn false;\n-      break;\n-\n-    case 64:\n-      if (!validate_ehdr64 (elf_file))\n-\treturn false;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Read the string table used for section header names.  */\n-  if (elf_getshdrstrndx (elf_file->elf, &elf_file->sec_strtab) == -1)\n-    {\n-      error (\"could not locate ELF string table: %s\", elf_errmsg (0));\n-      return false;\n-    }\n-\n-  cached_file_attrs.initialized = true;\n-  return true;\n-}\n-\n-\n-/* Helper functions used by init_ehdr.  Initialize ELF_FILE's executable\n-   header using cached data from previously read files.  */\n-\n-#define DEFINE_INIT_EHDR(BITS)\t\t\t\t\t      \\\n-static void\t\t\t\t\t\t\t      \\\n-init_ehdr##BITS (lto_elf_file *elf_file)\t\t\t      \\\n-{\t\t\t\t\t\t\t\t      \\\n-  Elf##BITS##_Ehdr *ehdr;\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t      \\\n-  gcc_assert (cached_file_attrs.bits);\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t      \\\n-  ehdr = elf##BITS##_newehdr (elf_file->elf);\t\t\t      \\\n-  if (!ehdr)\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t      \\\n-      if (BITS == 32)\t\t\t\t\t\t      \\\n-\tfatal_error (\"elf32_newehdr() failed: %s\", elf_errmsg (-1));  \\\n-      else\t\t\t\t\t\t\t      \\\n-\tfatal_error (\"elf64_newehdr() failed: %s\", elf_errmsg (-1));  \\\n-    }\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t      \\\n-  memcpy (ehdr->e_ident, cached_file_attrs.elf_ident,\t\t      \\\n-\t  sizeof cached_file_attrs.elf_ident);\t\t\t      \\\n-  ehdr->e_type = ET_REL;\t\t\t\t\t      \\\n-  ehdr->e_version = EV_CURRENT;\t\t\t\t\t      \\\n-  ehdr->e_machine = cached_file_attrs.elf_machine;\t\t      \\\n-}\n-\n-DEFINE_INIT_EHDR (32)\n-DEFINE_INIT_EHDR (64)\n-\n-\n-/* Initialize ELF_FILE's executable header using cached data from previously\n-   read files.  */\n-\n-static void\n-init_ehdr (lto_elf_file *elf_file)\n-{\n-  switch (cached_file_attrs.bits)\n-    {\n-    case 32:\n-      init_ehdr32 (elf_file);\n-      break;\n-\n-    case 64:\n-      init_ehdr64 (elf_file);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Open ELF file FILENAME.  If WRITABLE is true, the file is opened for write\n-   and, if necessary, created.  Otherwise, the file is opened for reading.\n-   Returns the opened file.  */\n-\n-lto_file *\n-lto_obj_file_open (const char *filename, bool writable)\n-{\n-  lto_elf_file *elf_file;\n-  lto_file *result = NULL;\n-  off_t offset;\n-  long loffset;\n-  off_t header_offset;\n-  const char *offset_p;\n-  char *fname;\n-  int consumed;\n-\n-  offset_p = strrchr (filename, '@');\n-  if (offset_p\n-      && offset_p != filename\n-      && sscanf (offset_p, \"@%li%n\", &loffset, &consumed) >= 1\n-      && strlen (offset_p) == (unsigned int)consumed)\n-    {\n-      fname = (char *) xmalloc (offset_p - filename + 1);\n-      memcpy (fname, filename, offset_p - filename);\n-      fname[offset_p - filename] = '\\0';\n-      offset = (off_t)loffset;\n-      /* elf_rand expects the offset to point to the ar header, not the\n-         object itself. Subtract the size of the ar header (60 bytes).\n-         We don't uses sizeof (struct ar_hd) to avoid including ar.h */\n-      header_offset = offset - 60;\n-    }\n-  else\n-    {\n-      fname = xstrdup (filename);\n-      offset = 0;\n-      header_offset = 0;\n-    }\n-\n-  /* Set up.  */\n-  elf_file = XCNEW (lto_elf_file);\n-  result = (lto_file *) elf_file;\n-  lto_file_init (result, fname, offset);\n-  elf_file->fd = -1;\n-\n-  /* Open the file.  */\n-  elf_file->fd = open (fname, writable ? O_WRONLY|O_CREAT|O_BINARY \n-\t\t\t\t       : O_RDONLY|O_BINARY, 0666);\n-  if (elf_file->fd == -1)\n-    {\n-      error (\"could not open file %s\", fname);\n-      goto fail;\n-    }\n-\n-  /* Initialize the ELF library.  */\n-  if (elf_version (EV_CURRENT) == EV_NONE)\n-    {\n-      error (\"ELF library is older than that used when building GCC\");\n-      goto fail;\n-    }\n-\n-  /* Open the ELF file descriptor.  */\n-  elf_file->elf = elf_begin (elf_file->fd, writable ? ELF_C_WRITE : ELF_C_READ,\n-\t\t\t     NULL);\n-  if (!elf_file->elf)\n-    {\n-      error (\"could not open %s as an ELF file: %s\", fname, elf_errmsg (0));\n-      goto fail;\n-    }\n-\n-  if (offset != 0)\n-    {\n-      Elf *e;\n-      off_t t = elf_rand (elf_file->elf, header_offset);\n-      if (t != header_offset)\n-        {\n-          error (\"could not seek in archive\");\n-          goto fail;\n-        }\n-\n-      e = elf_begin (elf_file->fd, ELF_C_READ, elf_file->elf);\n-      if (e == NULL)\n-        {\n-          error(\"could not find archive member\");\n-          goto fail;\n-        }\n-      elf_end (elf_file->elf);\n-      elf_file->elf = e;\n-    }\n-\n-  if (writable)\n-    {\n-      init_ehdr (elf_file);\n-      elf_file->shstrtab_stream = XCNEW (struct lto_output_stream);\n-      /* Output an empty string to the section header table.  This becomes the\n-\t name of the initial NULL section.  */\n-      lto_output_1_stream (elf_file->shstrtab_stream, '\\0');\n-    }\n-  else\n-    if (!validate_file (elf_file))\n-      goto fail;\n-\n-  return result;\n-\n- fail:\n-  if (result)\n-    lto_obj_file_close (result);\n-  return NULL;\n-}\n-\n-\n-/* Close ELF file FILE and clean up any associated data structures.  If FILE\n-   was opened for writing, the file's ELF data is written at this time, and\n-   any cached data buffers are freed.  */\n-\n-void\n-lto_obj_file_close (lto_file *file)\n-{\n-  lto_elf_file *elf_file = (lto_elf_file *) file;\n-  struct lto_char_ptr_base *cur, *tmp;\n-\n-  /* Write the ELF section header string table.  */\n-  if (elf_file->shstrtab_stream)\n-    {\n-      size_t strtab;\n-      GElf_Ehdr *ehdr_p, ehdr_buf;\n-      lto_file *old_file = lto_set_current_out_file (file);\n-\n-      lto_elf_begin_section_with_type (\".shstrtab\", SHT_STRTAB);\n-      ehdr_p = gelf_getehdr (elf_file->elf, &ehdr_buf);\n-      if (ehdr_p == NULL)\n-\tfatal_error (\"gelf_getehdr() failed: %s\", elf_errmsg (-1));\n-      strtab = elf_ndxscn (elf_file->scn);\n-      if (strtab < SHN_LORESERVE)\n-\tehdr_p->e_shstrndx = strtab;\n-      else\n-\t{\n-\t  GElf_Shdr *shdr_p, shdr_buf;\n-\t  Elf_Scn *scn_p = elf_getscn (elf_file->elf, 0);\n-\t  if (scn_p == NULL)\n-\t    fatal_error (\"elf_getscn() failed: %s\", elf_errmsg (-1));\n-\t  shdr_p = gelf_getshdr (scn_p, &shdr_buf);\n-\t  if (shdr_p == NULL)\n-\t    fatal_error (\"gelf_getshdr() failed: %s\", elf_errmsg (-1));\n-\t  shdr_p->sh_link = strtab;\n-\t  if (gelf_update_shdr (scn_p, shdr_p) == 0)\n-\t    fatal_error (\"gelf_update_shdr() failed: %s\", elf_errmsg (-1));\n-\t  ehdr_p->e_shstrndx = SHN_XINDEX;\n-\t}\n-      if (gelf_update_ehdr (elf_file->elf, ehdr_p) == 0)\n-\tfatal_error (\"gelf_update_ehdr() failed: %s\", elf_errmsg (-1));\n-      lto_write_stream (elf_file->shstrtab_stream);\n-      lto_obj_end_section ();\n-\n-      lto_set_current_out_file (old_file);\n-      free (elf_file->shstrtab_stream);\n-\n-      if (elf_update (elf_file->elf, ELF_C_WRITE) < 0)\n-\tfatal_error (\"elf_update() failed: %s\", elf_errmsg (-1));\n-    }\n-\n-  if (elf_file->elf)\n-    elf_end (elf_file->elf);\n-  if (elf_file->fd != -1)\n-    close (elf_file->fd);\n-\n-  /* Free any ELF data buffers.  */\n-  cur = elf_file->data;\n-  while (cur)\n-    {\n-      tmp = cur;\n-      cur = (struct lto_char_ptr_base *) cur->ptr;\n-      free (tmp);\n-    }\n-\n-  free (file);\n-}\n-\n-\n-/* The current output file.  */\n-static lto_file *current_out_file;\n-\n-\n-/* Sets the current output file to FILE.  Returns the old output file or\n-   NULL.  */\n-\n-lto_file *\n-lto_set_current_out_file (lto_file *file)\n-{\n-  lto_file *old_file = current_out_file;\n-  current_out_file = file;\n-  return old_file;\n-}\n-\n-\n-/* Returns the current output file.  */\n-\n-lto_file *\n-lto_get_current_out_file (void)\n-{\n-  return current_out_file;\n-}"}, {"sha": "9f89e8e9bb31cd5e0eab246f1111f71957cc444c", "filename": "gcc/lto/lto-macho.c", "status": "removed", "additions": 0, "deletions": 948, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-macho.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-macho.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-macho.c?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1,948 +0,0 @@\n-/* LTO routines for Mach-O object files.\n-   Copyright 2010 Free Software Foundation, Inc.\n-   Contributed by Steven Bosscher.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"diagnostic-core.h\"\n-#include \"toplev.h\"\n-#include \"lto.h\"\n-#include \"tm.h\"\n-#include \"libiberty.h\"\n-#include \"lto-streamer.h\"\n-#include \"lto/lto-endian.h\"\n-#include \"lto/lto-macho.h\"\n-\n-/* Rather than implementing a libmacho to match libelf, or attempting to\n-   integrate libbfd into GCC, this file is a self-contained (and very\n-   minimal) Mach-O format object file reader/writer.  The generated files\n-   will contain a Mach-O header, a number of Mach-O load commands an\n-   section headers, the  section data itself, and a trailing string table\n-   for section names.  */\n-\n-/* This needs to be kept in sync with darwin.c.  Better yet, lto-macho.c\n-   and lto-macho.h should be moved to config/, and likewise for lto-coff.*\n-   and lto-elf.*.  */\n-\n-/* Segment name for LTO sections.  */\n-#define LTO_SEGMENT_NAME \"__GNU_LTO\"\n-\n-/* Section name for LTO section names section.  */\n-#define LTO_NAMES_SECTION \"__section_names\"\n-\n-/* Handle opening elf files on hosts, such as Windows, that may use \n-   text file handling that will break binary access.  */\n-#ifndef O_BINARY\n-# define O_BINARY 0\n-#endif\n-\n-/* Cached object file header.  We use a header_64 for this, since all\n-   the fields we need are in there, in the same position as header_32.  */\n-mach_o_header_64 cached_mach_o_header;\n-uint32_t cached_mach_o_magic;\n-\n-/* The current output file.  */\n-static lto_file *current_out_file;\n-\n-\n-/* Is this a 32-bits or 64-bits Mach-O object file?  */\n-static int\n-mach_o_word_size (void)\n-{\n-  gcc_assert (cached_mach_o_magic != 0);\n-  return (cached_mach_o_magic == MACH_O_MH_MAGIC_64\n-\t  || cached_mach_o_magic == MACH_O_MH_CIGAM_64) ? 64 : 32;\n-}\n-\n-/* Sets the current output file to FILE.  Returns the old output file or\n-   NULL.  */\n-\n-lto_file *\n-lto_set_current_out_file (lto_file *file)\n-{\n-  lto_file *old_file = current_out_file;\n-  current_out_file = file;\n-  return old_file;\n-}\n-\n-\n-/* Returns the current output file.  */\n-\n-lto_file *\n-lto_get_current_out_file (void)\n-{\n-  return current_out_file;\n-}\n-\n-/* Mach-O section structure constructor.  */\n-\n-static lto_mach_o_section\n-mach_o_new_section (lto_mach_o_file *mach_o_file, const char *name)\n-{\n-  lto_mach_o_section ptr;\n-\n-  /* FIXME We could allocate these things on an obstack.  */\n-  ptr = XCNEW (struct lto_mach_o_section_d);\n-  if (name)\n-    {\n-      if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n-\t\t   strlen(LTO_SECTION_NAME_PREFIX)) != 0)\n-\tsorry (\"not implemented: Mach-O writer for non-LTO sections\");\n-      ptr->name = xstrdup (name);\n-    }\n-\n-  VEC_safe_push (lto_mach_o_section, heap, mach_o_file->section_vec, ptr);\n-\n-  return ptr;\n-}\n-\n-/* Mach-O section data block structure constructor.  */\n-\n-static lto_mach_o_data\n-mach_o_new_data (lto_mach_o_section sec)\n-{\n-  lto_mach_o_data ptr, *chain_ptr_ptr;\n-\n-  /* FIXME We could allocate these things on an obstack.  */\n-  ptr = XCNEW (struct lto_mach_o_data_d);\n-\n-  chain_ptr_ptr = &sec->data_chain;\n-  while (*chain_ptr_ptr)\n-    chain_ptr_ptr = &(*chain_ptr_ptr)->next;\n-  *chain_ptr_ptr = ptr;\n-\n-  return ptr;\n-}\n-\n-/* Initialize FILE, an LTO file object for FILENAME.  Offset is the\n-   offset into FILE where the object is located (e.g. in an archive).  */\n-\n-static void\n-lto_file_init (lto_file *file, const char *filename, off_t offset)\n-{\n-  file->filename = filename;\n-  file->offset = offset;\n-}\n-\n-/* Build a hash table whose key is the section names and whose data is\n-   the start and size of each section in the .o file.  */\n-\n-htab_t\n-lto_obj_build_section_table (lto_file *lto_file) \n-{\n-  lto_mach_o_file *mach_o_file = (lto_mach_o_file *)lto_file;\n-  lto_mach_o_section sec;\n-  htab_t section_hash_table;\n-  off_t strtab_offs;\n-  ssize_t strtab_size;\n-  char *strtab = NULL;\n-  int i;\n-\n-  section_hash_table = lto_obj_create_section_hash_table ();\n-\n-  /* Seek the string table.  */\n-  /* FIXME The segment name should be in darwin.h, but can we include it\n-     here in this file?  */\n-  for (i = 0;\n-       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n-       i++)\n-    {\n-      if (strncmp (sec->u.section.segname, \"__GNU_LTO\", 16) != 0)\n-\tcontinue;\n-      if (strncmp (sec->u.section.sectname, \"__section_names\", 16) == 0)\n-        break;\n-    }\n-  if (! sec)\n-    {\n-      error (\"invalid Mach-O LTO object file: no __section_names section found\");\n-      goto done;\n-    }\n-  mach_o_file->section_names_section = sec;\n-\n-  if (mach_o_word_size () == 64)\n-    {\n-      strtab_offs = (off_t) get_uint32 (&sec->u.section_64.offset[0]);\n-      strtab_size = (size_t) get_uint64 (&sec->u.section_64.size[0]);\n-    }\n-  else\n-    {\n-      strtab_offs = (off_t) get_uint32 (&sec->u.section_32.offset[0]);\n-      strtab_size = (size_t) get_uint32 (&sec->u.section_32.size[0]);\n-    }\n-\n-  /* Seek to start of string table.  */\n-  if (strtab_offs != lseek (mach_o_file->fd,\n-\t\t\t    mach_o_file->base.offset + strtab_offs,\n-\t\t\t    SEEK_SET))\n-    {\n-      error (\"altered or invalid Mach-O object file\");\n-      goto done;\n-    }\n-\n-  strtab = XNEWVEC (char, strtab_size);\n-  if (read (mach_o_file->fd, strtab, strtab_size) != strtab_size)\n-    {\n-      error (\"invalid Mach-O LTO object file __section_names section\");\n-      goto done;\n-    }\n-\n-  /* Scan sections looking at names.  */\n-  for (i = 0;\n-       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n-       i++)\n-    {\n-      struct lto_section_slot s_slot;\n-      void **slot;\n-      char *new_name;\n-      unsigned long stringoffset;\n-      char name[17];\n-\n-      /* Ignore non-LTO sections.  Also ignore the __section_names section\n-\t which does not need renaming.  */\n-      if (strncmp (sec->u.section.segname, \"__GNU_LTO\", 16) != 0)\n-\tcontinue;\n-      if (sec == mach_o_file->section_names_section)\n-        continue;\n-\n-      /* Try to extract the offset of the real name for this section from\n-\t __section_names.  */\n-      memcpy (&name[0], sec->u.section.sectname, 16);\n-      name[16] = '\\0';\n-      if (name[0] != '_' || name[1] != '_'\n-\t  || sscanf (&name[2], \"%08lX\", &stringoffset) != 1\n-\t  || strtab_size < (ssize_t) stringoffset)\n-\t{\n-\t  error (\"invalid Mach-O LTO section name string: %s\", name);\n-\t  continue;\n-\t}\n-\n-      new_name = XNEWVEC (char, strlen (strtab + stringoffset) + 1);\n-      strcpy (new_name, strtab + stringoffset);\n-      s_slot.name = new_name;\n-      slot = htab_find_slot (section_hash_table, &s_slot, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  struct lto_section_slot *new_slot = XNEW (struct lto_section_slot);\n-\n-\t  new_slot->name = new_name;\n-\t  if (mach_o_word_size() == 64)\n-\t    {\n-\t      new_slot->start =\n-\t\t(intptr_t) get_uint32 (&sec->u.section_64.offset[0]);\n-\t      new_slot->len =\n-\t\t(size_t) get_uint64 (&sec->u.section_64.size[0]);\n-\t    }\n-\t  else\n-\t    {\n-\t      new_slot->start =\n-\t\t(intptr_t) get_uint32 (&sec->u.section_32.offset[0]);\n-\t      new_slot->len =\n-\t\t(size_t) get_uint32 (&sec->u.section_32.size[0]);\n-\t    }\n-\n-\t  *slot = new_slot;\n-\t}\n-      else\n-\t{\n-\t  error (\"two or more sections for %s:\", new_name);\n-\t  goto done;\n-\t}\n-    }\n-\n- done:\n-  if (strtab)\n-    free (strtab);\n-  return section_hash_table;\n-}\n-\n-\n-/* Begin a new Mach-O section named NAME in the current output file.  */\n-\n-void\n-lto_obj_begin_section (const char *name)\n-{\n-  lto_mach_o_file *file;\n-\n-  if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n-\t       strlen(LTO_SECTION_NAME_PREFIX)) != 0)\n-    sorry (\"not implemented: Mach-O writer for non-LTO sections\");\n-\n-  /* Grab the current output file and do some basic assertion checking.  */\n-  file = (lto_mach_o_file *) lto_get_current_out_file (),\n-  gcc_assert (file && file->writable && !file->scn);\n-\n-  /* Create a new section.  */\n-  file->scn = mach_o_new_section (file, name);\n-  if (!file->scn)\n-    fatal_error (\"could not create a new Mach-O section: %m\");\n-}\n-\n-\n-/* Append DATA of length LEN to the current output section.  BASE is a pointer\n-   to the output page containing DATA.  It is freed once the output file has\n-   been written.  */\n-\n-void\n-lto_obj_append_data (const void *data, size_t len, void *block)\n-{\n-  lto_mach_o_file *file;\n-  lto_mach_o_data mach_o_data;\n-  struct lto_char_ptr_base *base = (struct lto_char_ptr_base *) block;\n-\n-  /* Grab the current output file and do some basic assertion checking.  */\n-  file = (lto_mach_o_file *) lto_get_current_out_file ();\n-  gcc_assert (file);\n-  gcc_assert (file->scn);\n-\n-  mach_o_data = mach_o_new_data (file->scn);\n-  if (!mach_o_data)\n-    fatal_error (\"could not append data to Mach-O section: %m\");\n-\n-  mach_o_data->d_buf = CONST_CAST (void *, data);\n-  mach_o_data->d_size = len;\n-\n-  /* Chain all data blocks (from all sections) on one singly-linked\n-     list for freeing en masse after the file is closed.  */\n-  base->ptr = (char *)file->data;\n-  file->data = base;\n-}\n-\n-\n-/* End the current output section.  This just does some assertion checking\n-   and sets the current output file's scn member to NULL.  */\n-\n-void\n-lto_obj_end_section (void)\n-{\n-  lto_mach_o_file *file;\n-\n-  /* Grab the current output file and validate some basic assertions.  */\n-  file = (lto_mach_o_file *) lto_get_current_out_file ();\n-  gcc_assert (file);\n-  gcc_assert (file->scn);\n-\n-  file->scn = NULL;\n-}\n-\n-\n-/* Read a Mach-O header from MACH_O_FILE and validate it.\n-   The file descriptor in MACH_O_FILE points at the start of the file.\n-   If cached_mach_o_header is uninitialized, caches the results.\n-   On succes, returns true and moves file pointer to the start of the\n-   load commands.  On failure, returns false.  */\n-\n-static bool\n-validate_mach_o_header (lto_mach_o_file *mach_o_file)\n-{\n-  ssize_t i, n;\n-  unsigned char magic[4];\n-  uint32_t cputype;\n-  off_t startpos;\n-\n-  /* Known header magics for validation, as an array.  */\n-  static const unsigned int mach_o_known_formats[] = {\n-    MACH_O_MH_MAGIC,\n-    MACH_O_MH_CIGAM,\n-    MACH_O_MH_MAGIC_64,\n-    MACH_O_MH_CIGAM_64,\n-  };\n-#define MACH_O_NUM_KNOWN_FORMATS \\\n-  ((ssize_t) ARRAY_SIZE (mach_o_known_formats))\n-\n-  startpos = lseek (mach_o_file->fd, 0, SEEK_CUR);\n-  if (read (mach_o_file->fd, &magic, sizeof (magic)) != 4\n-      || lseek (mach_o_file->fd, -4, SEEK_CUR) != startpos)\n-    {\n-      error (\"cannot read file %s\", mach_o_file->base.filename);\n-      return false;\n-    }\n-\n-  for (i = 0; i < MACH_O_NUM_KNOWN_FORMATS; ++i)\n-    if (get_uint32 (&magic[0]) == mach_o_known_formats[i])\n-      break;\n-  if (i == MACH_O_NUM_KNOWN_FORMATS)\n-    goto not_for_target;\n-\n-  /* Check the endian-ness.  */\n-  if (BYTES_BIG_ENDIAN && magic[0] != 0xfe)\n-    goto not_for_target;\n-\n-  /* Set or check cached magic number.  */\n-  if (cached_mach_o_magic == 0)\n-    cached_mach_o_magic = get_uint32 (&magic[0]);\n-  else if (cached_mach_o_magic != get_uint32 (&magic[0]))\n-    goto not_for_target;\n- \n-  n = mach_o_word_size () == 64\n-      ? sizeof (mach_o_header_64) : sizeof (mach_o_header_32);\n-  if (read (mach_o_file->fd, &mach_o_file->u.header, n) != n)\n-    goto not_for_target;\n-\n-  /* Is this a supported CPU?  */\n-  /* ??? Would be nice to validate the exact target architecture.  */\n-  cputype = get_uint32 (&mach_o_file->u.header.cputype[0]);\n-  if (cputype == MACH_O_CPU_TYPE_I386\n-      || cputype == MACH_O_CPU_TYPE_POWERPC)\n-    {\n-      if (mach_o_word_size () != 32)\n-        goto not_for_target;\n-    }\n-  else if (cputype == MACH_O_CPU_TYPE_X86_64\n-\t   || cputype == MACH_O_CPU_TYPE_POWERPC_64)\n-    {\n-      if (mach_o_word_size () != 64)\n-        goto not_for_target;\n-    }\n-\n-  /* Is this an MH_OBJECT file?  */\n-  if (get_uint32 (&mach_o_file->u.header.filetype[0]) != MACH_O_MH_OBJECT)\n-    error (\"Mach-O file %s is not an MH_OBJECT file\",\n-\t   mach_o_file->base.filename);\n-\n-  /* Save the header for future use.  */\n-  memcpy (&cached_mach_o_header, &mach_o_file->u.header,\n-\t  sizeof (cached_mach_o_header));\n-\n-  return true;\n-\n- not_for_target:\n-  error (\"file %s is not a Mach-O object file for target\",\n-\t mach_o_file->base.filename);\n-  return false;\n-}\n-\n-\n-/* Read a Mach-O LC_SEGMENT command (32 bits) from MACH_O_FILE and\n-   validate it.\n-   The file descriptor in MACH_O_FILE points at the start of the load\n-   command.  On sucess, returns true and advances the file pointer\n-   past the end of the load command.  On failure, returns false.  */\n-\n-static bool\n-validate_mach_o_segment_command_32 (lto_mach_o_file *mach_o_file)\n-{\n-  mach_o_segment_command_32 seg_cmd_32;\n-  unsigned int i;\n-  ssize_t n;\n-  off_t startpos;\n-\n-  /* Fields we're interested in.  */\n-  uint32_t cmd;\n-  uint32_t cmdsize;\n-  uint32_t nsects;\n-\n-  startpos = lseek (mach_o_file->fd, 0, SEEK_CUR);\n-\n-  n = sizeof (mach_o_segment_command_32);\n-  if (read (mach_o_file->fd, (void *) &seg_cmd_32, n) != n)\n-    goto fail;\n-\n-  cmd = get_uint32 (&seg_cmd_32.cmd[0]);\n-  cmdsize = get_uint32 (&seg_cmd_32.cmdsize[0]);\n-  nsects = get_uint32 (&seg_cmd_32.nsects[0]);\n-  gcc_assert (cmd == MACH_O_LC_SEGMENT);\n-\n-  /* Validate section table entries.  */\n-  for (i = 0; i < nsects; i++)\n-    {\n-      mach_o_section_32 sec_32;\n-      lto_mach_o_section ltosec;\n-\n-      n = sizeof (mach_o_section_32);\n-      if (read (mach_o_file->fd, &sec_32, n) != n)\n-\tgoto fail;\n-\n-      /* ??? Perform some checks.  */\n-\n-      /* Looks ok, so record its details.  We don't read the \n-         string table or set up names yet; we'll do that when\n-\t we build the hash table.  */\n-      ltosec = mach_o_new_section (mach_o_file, NULL);\n-      memcpy (&ltosec->u.section_32, &sec_32, sizeof (sec_32));\n-    }\n-\n-  if (lseek (mach_o_file->fd, 0, SEEK_CUR) != startpos + cmdsize)\n-    goto fail;\n-\n-  return true;\n-\n- fail:\n-  error (\"could not read LC_SEGMENT command in Mach-O file %s\",\n-\t mach_o_file->base.filename);\n-  return false;\n-}\n-\n-\n-/* Read a Mach-O LC_SEGMENT_64 command from MACH_O_FILE and validate it.\n-   The file descriptor in MACH_O_FILE points at the start of the load\n-   command.  On sucess, returns true and advances the file pointer\n-   past the end of the load command.  On failure, returns false.  */\n-\n-static bool\n-validate_mach_o_segment_command_64 (lto_mach_o_file *mach_o_file)\n-{\n-  mach_o_segment_command_64 seg_cmd_64;\n-  unsigned int i;\n-  ssize_t n;\n-  off_t startpos;\n-\n-  /* Fields we're interested in.  */\n-  uint32_t cmd;\n-  uint32_t cmdsize;\n-  uint32_t nsects;\n-\n-  startpos = lseek (mach_o_file->fd, 0, SEEK_CUR);\n-\n-  n = sizeof (mach_o_segment_command_64);\n-  if (read (mach_o_file->fd, (void *) &seg_cmd_64, n) != n)\n-    goto fail;\n-\n-  cmd = get_uint32 (&seg_cmd_64.cmd[0]);\n-  cmdsize = get_uint32 (&seg_cmd_64.cmdsize[0]);\n-  nsects = get_uint32 (&seg_cmd_64.nsects[0]);\n-  gcc_assert (cmd == MACH_O_LC_SEGMENT_64);\n-\n-  /* Validate section table entries.  */\n-  for (i = 0; i < nsects; i++)\n-    {\n-      mach_o_section_64 sec_64;\n-      lto_mach_o_section ltosec;\n-\n-      n = sizeof (mach_o_section_64);\n-      if (read (mach_o_file->fd, &sec_64, n) != n)\n-\tgoto fail;\n-\n-      /* ??? Perform some checks.  */\n-\n-      /* Looks ok, so record its details.  We don't read the \n-         string table or set up names yet; we'll do that when\n-\t we build the hash table.  */\n-      ltosec = mach_o_new_section (mach_o_file, NULL);\n-      memcpy (&ltosec->u.section_64, &sec_64, sizeof (sec_64));\n-    }\n-\n-  if (lseek (mach_o_file->fd, 0, SEEK_CUR) != startpos + cmdsize)\n-    goto fail;\n-\n-  return true;\n-\n- fail:\n-  error (\"could not read LC_SEGMENT_64 command in Mach-O file %s\",\n-\t mach_o_file->base.filename);\n-  return false;\n-}\n-\n-/* Read a Mach-O load commands from MACH_O_FILE and validate it.\n-   The file descriptor in MACH_O_FILE points at the start of the load\n-   command.  On sucess, returns true and advances the file pointer\n-   past the end of the load command.  On failure, returns false.  */\n-\n-static bool\n-validate_mach_o_load_command (lto_mach_o_file *mach_o_file)\n-{\n-  mach_o_load_command load_command;\n-  uint32_t cmd;\n-  uint32_t cmdsize;\n-  ssize_t n;\n-\n-  n = sizeof (load_command);\n-  if (read (mach_o_file->fd, &load_command, n) != n)\n-    {\n-      error (\"could not read load commands in Mach-O file %s\",\n-\t     mach_o_file->base.filename);\n-      return false;\n-    }\n-  lseek (mach_o_file->fd, -1 * (off_t) sizeof (load_command), SEEK_CUR);\n-\n-  cmd = get_uint32 (&load_command.cmd[0]);\n-  cmdsize = get_uint32 (&load_command.cmdsize[0]);\n-  switch (cmd)\n-    {\n-    case MACH_O_LC_SEGMENT:\n-      return validate_mach_o_segment_command_32 (mach_o_file);\n-    case MACH_O_LC_SEGMENT_64:\n-      return validate_mach_o_segment_command_64 (mach_o_file);\n-\n-    default:\n-      /* Just skip over it.  */\n-      lseek (mach_o_file->fd, cmdsize, SEEK_CUR);\n-      return true;\n-    }\n-}\n-\n-/* Validate's MACH_O_FILE's executable header and, if cached_mach_o_header is\n-   uninitialized, caches the results.  Also records the section header string\n-   table's section index.  Returns true on success, false on failure.  */\n-\n-static bool\n-validate_file (lto_mach_o_file *mach_o_file)\n-{\n-  uint32_t i, ncmds;\n-\n-  /* Read and sanity check the raw header.  */\n-  if (! validate_mach_o_header (mach_o_file))\n-    return false;\n-\n-  ncmds = get_uint32 (&mach_o_file->u.header.ncmds[0]);\n-  for (i = 0; i < ncmds; ++i)\n-    if (! validate_mach_o_load_command (mach_o_file))\n-      return false;\n-\n-  return true;\n-}\n-\n-/* Initialize MACH_O_FILE's executable header using cached data from previously\n-   read files.  */\n-\n-static void\n-init_mach_o_header (lto_mach_o_file *mach_o_file)\n-{\n-  gcc_assert (cached_mach_o_magic != 0);\n-  memcpy (&mach_o_file->u.header,\n-\t  &cached_mach_o_header,\n-\t  sizeof (mach_o_file->u.header));\n-  put_uint32 (&mach_o_file->u.header.ncmds[0], 0);\n-  put_uint32 (&mach_o_file->u.header.sizeofcmds[0], 0);\n-}\n-\n-/* Open Mach-O file FILENAME.  If WRITABLE is true, the file is opened for write\n-   and, if necessary, created.  Otherwise, the file is opened for reading.\n-   Returns the opened file.  */\n-\n-lto_file *\n-lto_obj_file_open (const char *filename, bool writable)\n-{\n-  lto_mach_o_file *mach_o_file;\n-  lto_file *result = NULL;\n-  off_t offset;\n-  const char *offset_p;\n-  char *fname;\n-  struct stat statbuf;\n-\n-  offset_p = strchr (filename, '@');\n-  if (!offset_p)\n-    {\n-      fname = xstrdup (filename);\n-      offset = 0;\n-    }\n-  else\n-    {\n-      /* The file started with '@' is a file containing command line\n-\t options.  Stop if it doesn't exist.  */\n-      if (offset_p == filename)\n-\tfatal_error (\"command line option file '%s' does not exist\",\n-\t\t     filename);\n-\n-      fname = (char *) xmalloc (offset_p - filename + 1);\n-      memcpy (fname, filename, offset_p - filename);\n-      fname[offset_p - filename] = '\\0';\n-      offset_p += 3; /* skip the @0x */\n-      offset = lto_parse_hex (offset_p);\n-    }\n-\n-  /* Set up.  */\n-  mach_o_file = XCNEW (lto_mach_o_file);\n-  result = (lto_file *) mach_o_file;\n-  lto_file_init (result, fname, offset);\n-  mach_o_file->fd = -1;\n-  mach_o_file->writable = writable;\n-\n-  /* Open the file.  */\n-  mach_o_file->fd = open (fname,\n-    O_BINARY | (writable ? O_WRONLY | O_CREAT | O_TRUNC : O_RDONLY), 0666);\n-\n-  if (mach_o_file->fd == -1)\n-    {\n-      error (\"could not open file %s\", fname);\n-      goto fail;\n-    }\n-\n-  if (stat (fname, &statbuf) < 0)\n-    {\n-      error (\"could not stat file %s\", fname);\n-      goto fail;\n-    }\n-\n-  mach_o_file->file_size = statbuf.st_size;\n-\n-  /* If the object is in an archive, get it out.  */\n-  if (offset != 0)\n-    {\n-      char ar_tail[12];\n-      int size;\n-\n-      /* Surely not?  */\n-      gcc_assert (!writable);\n-\n-      /* Seek to offset, or error.  */\n-      if (lseek (mach_o_file->fd, offset, SEEK_SET) != (ssize_t) offset)\n-\t{\n-\t  error (\"could not find archive member @0x%lx\", (long) offset);\n-\t  goto fail;\n-\t}\n-\n-      /* Now seek back 12 chars and read the tail of the AR header to\n-         find the length of the member file.  */\n-      if (lseek (mach_o_file->fd, -12, SEEK_CUR) < 0\n-\t  || read (mach_o_file->fd, ar_tail, 12) != 12\n-\t  || lseek (mach_o_file->fd, 0, SEEK_CUR) != (ssize_t) offset\n-\t  || ar_tail[10] != '`' || ar_tail[11] != '\\n')\n-\t{\n-\t  error (\"could not find archive header @0x%lx\", (long) offset);\n-\t  goto fail;\n-\t}\n-\n-      ar_tail[11] = 0;\n-      if (sscanf (ar_tail, \"%d\", &size) != 1)\n-\t{\n-\t  error (\"invalid archive header @0x%lx\", (long) offset);\n-\t  goto fail;\n-\t}\n-      mach_o_file->file_size = size;\n-    }\n-\n-  if (writable)\n-    {\n-      init_mach_o_header (mach_o_file);\n-    }\n-  else\n-    if (! validate_file (mach_o_file))\n-      goto fail;\n-\n-  return result;\n-\n- fail:\n-  if (result)\n-    lto_obj_file_close (result);\n-  return NULL;\n-}\n-\n-\n-/* Write the data in MACH_O_FILE to a real Mach-O binary object.\n-   We write a header, a segment load command, and section data.  */\n-\n-static bool\n-mach_o_write_object_file (lto_mach_o_file *mach_o_file)\n-{\n-  lto_mach_o_section sec, snsec;\n-  lto_mach_o_data snsec_data;\n-  ssize_t hdrsize, cmdsize, secsize;\n-  size_t num_sections, snsec_size, total_sec_size;\n-  unsigned int sec_offs, strtab_offs;\n-  int i;\n-  bool write_err = false;\n-\n-  /* The number of sections we will write is the number of sections added by\n-     the streamer, plus 1 for the section names section.  */\n-  num_sections = VEC_length (lto_mach_o_section, mach_o_file->section_vec) + 1;\n-\n-  /* Calculate the size of the basic data structures on disk.  */\n-  if (mach_o_word_size () == 64)\n-    {\n-      hdrsize = sizeof (mach_o_header_64);\n-      secsize = sizeof (mach_o_section_64);\n-      cmdsize = sizeof (mach_o_segment_command_64) + num_sections * secsize;\n-    }\n-  else\n-    {\n-      hdrsize = sizeof (mach_o_header_32);\n-      secsize = sizeof (mach_o_section_32);\n-      cmdsize = sizeof (mach_o_segment_command_32) + num_sections * secsize;\n-    }\n- \n-  /* Allocate the section names section.  */\n-  snsec_size = 0;\n-  for (i = 0;\n-       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n-       i++)\n-    snsec_size += strlen (sec->name) + 1;\n-  snsec = mach_o_new_section (mach_o_file, NULL);\n-  snsec->name = LTO_NAMES_SECTION;\n-  snsec_data = mach_o_new_data (snsec);\n-  snsec_data->d_buf = XCNEWVEC (char, snsec_size);\n-  snsec_data->d_size = snsec_size;\n-\n-  /* Position all the sections, and fill out their headers.  */\n-  sec_offs = hdrsize + cmdsize;\n-  strtab_offs = 0;\n-  total_sec_size = 0;\n-  for (i = 0;\n-       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n-       i++)\n-    {\n-      lto_mach_o_data data;\n-      size_t data_size;\n-      /* Put the section and segment names.  Add the section name to the\n-         section names section (unless, of course, this *is* the section\n-\t names section).  */\n-      if (sec == snsec)\n-\tsnprintf (sec->u.section.sectname, 16, \"%s\", LTO_NAMES_SECTION);\n-      else\n-\t{\n-\t  sprintf (sec->u.section.sectname, \"__%08X\", strtab_offs);\n-\t  memcpy ((char *) snsec_data->d_buf + strtab_offs, sec->name, strlen (sec->name));\n-\t}\n-      memcpy (&sec->u.section.segname[0],\n-\t      LTO_SEGMENT_NAME, strlen (LTO_SEGMENT_NAME));\n-\n-      /* Add layout and attributes.  */\n-      for (data = sec->data_chain, data_size = 0; data; data = data->next)\n-\tdata_size += data->d_size;\n-      if (mach_o_word_size () == 64)\n-\t{\n-\t  put_uint64 (&sec->u.section_64.addr[0], total_sec_size); \n-\t  put_uint64 (&sec->u.section_64.size[0], data_size); \n-\t  put_uint32 (&sec->u.section_64.offset[0], sec_offs); \n-\t  put_uint32 (&sec->u.section_64.flags[0], MACH_O_S_ATTR_DEBUG);\n-\t}\n-      else\n-\t{\n-\t  put_uint32 (&sec->u.section_64.addr[0], total_sec_size); \n-\t  put_uint32 (&sec->u.section_32.size[0], data_size); \n-\t  put_uint32 (&sec->u.section_32.offset[0], sec_offs); \n-\t  put_uint32 (&sec->u.section_32.flags[0], MACH_O_S_ATTR_DEBUG);\n-\t}\n-\n-      sec_offs += data_size;\n-      total_sec_size += data_size;\n-      strtab_offs += strlen (sec->name) + 1;\n-    }\n-\n-  /* We can write the data now.  As there's no way to indicate an error return\n-     from this hook, error handling is limited to not wasting our time doing\n-     any more writes in the event that any one fails.  */\n-\n-  /* Write the header.  */\n-  put_uint32 (&mach_o_file->u.header.ncmds[0], 1);\n-  put_uint32 (&mach_o_file->u.header.sizeofcmds[0], cmdsize);\n-  write_err = (write (mach_o_file->fd,\n-\t\t      &mach_o_file->u.header, hdrsize) != hdrsize);\n-  /* Write the segment load command.  */\n-  if (mach_o_word_size () == 64)\n-    {\n-      mach_o_segment_command_64 lc;\n-      ssize_t lc_size = sizeof (lc);\n-      memset (&lc, 0, lc_size);\n-      put_uint32 (&lc.cmd[0], MACH_O_LC_SEGMENT_64);\n-      put_uint32 (&lc.cmdsize[0], cmdsize);\n-      put_uint64 (&lc.fileoff[0], hdrsize + cmdsize);\n-      put_uint64 (&lc.filesize[0], total_sec_size);\n-      put_uint32 (&lc.nsects[0], num_sections);\n-      write_err = (write (mach_o_file->fd, &lc, lc_size) != lc_size);\n-    }\n-  else\n-    {\n-      mach_o_segment_command_32 lc;\n-      ssize_t lc_size = sizeof (lc);\n-      memset (&lc, 0, lc_size);\n-      put_uint32 (&lc.cmd[0], MACH_O_LC_SEGMENT);\n-      put_uint32 (&lc.cmdsize[0], cmdsize);\n-      put_uint32 (&lc.fileoff[0], hdrsize + cmdsize);\n-      put_uint32 (&lc.filesize[0], total_sec_size);\n-      put_uint32 (&lc.nsects[0], num_sections);\n-      write_err = (write (mach_o_file->fd, &lc, lc_size) != lc_size);\n-    }\n-  for (i = 0;\n-       !write_err\n-       && VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n-       i++)\n-    write_err = (write (mach_o_file->fd,\n-\t\t\t&sec->u.section, secsize) != secsize);\n-\n-  gcc_assert (lseek (mach_o_file->fd, 0, SEEK_CUR) == hdrsize + cmdsize);\n-\n-  /* Write the section data.  */\n-  for (i = 0;\n-       !write_err\n-       && VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n-       i++)\n-    {\n-      lto_mach_o_data data;\n-\n-      for (data = sec->data_chain; data; data = data->next)\n-\t{\n-\t  if (!write_err)\n-\t    write_err = (write (mach_o_file->fd, data->d_buf, data->d_size)\n-\t\t\t != data->d_size);\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  return !write_err;\n-}\n-\n-/* Close Mach-O file FILE and clean up any associated data structures.  If FILE\n-   was opened for writing, the file's Mach-O data is written at this time.  Any\n-   cached data buffers are freed.  */\n-\n-void\n-lto_obj_file_close (lto_file *file)\n-{\n-  lto_mach_o_file *mach_o_file = (lto_mach_o_file *) file;\n-  struct lto_char_ptr_base *cur, *tmp;\n-  lto_mach_o_section sec;\n-  bool write_err = false;\n-  int i;\n-\n-  /* If this file is open for writing, write a Mach-O object file.  */\n-  if (mach_o_file->writable)\n-    {\n-      if (! mach_o_write_object_file (mach_o_file))\n-        fatal_error (\"cannot write Mach-O object file\");\n-    }\n-\n-  /* Close the file, we're done.  */\n-  if (mach_o_file->fd != -1)\n-    close (mach_o_file->fd);\n-\n-  /* Free any data buffers.  */\n-  cur = mach_o_file->data;\n-  while (cur)\n-    {\n-      tmp = cur;\n-      cur = (struct lto_char_ptr_base *) cur->ptr;\n-      free (tmp);\n-    }\n-\n-  /* Free any sections and their data chains.  */\n-  for (i = 0;\n-       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n-       i++)\n-    {\n-      lto_mach_o_data curdata, nextdata;\n-      curdata = sec->data_chain;\n-      while (curdata)\n-\t{\n-\t  nextdata = curdata->next;\n-\t  free (curdata);\n-\t  curdata = nextdata;\n-\t}\n-      free (sec);\n-    }\n-  VEC_free (lto_mach_o_section, heap, mach_o_file->section_vec);\n-\n-  free (file);\n-\n-  /* If there was an error, mention it.  */\n-  if (write_err)\n-    error (\"I/O error writing Mach-O output file\");\n-}\n-"}, {"sha": "dcd0de3ca3f2f08bc95d4bceb167b5a07f7f26cc", "filename": "gcc/lto/lto-macho.h", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-macho.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/gcc%2Flto%2Flto-macho.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-macho.h?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1,251 +0,0 @@\n-/* LTO routines for Mach-O object files.\n-   Copyright 2010 Free Software Foundation, Inc.\n-   Contributed by Steven Bosscher.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef LTO_MACH_O_H\n-#define LTO_MACH_O_H\n-\n-/* On-disk file structures.  */\n-\n-/* Mach-O header (32 bits version).  */\n-struct mach_o_header_32\n-{\n-  unsigned char magic[4];\t/* Magic number.  */\n-  unsigned char cputype[4];\t/* CPU that this object is for.  */\n-  unsigned char cpusubtype[4];\t/* CPU subtype.  */\n-  unsigned char filetype[4];\t/* Type of file.  */\n-  unsigned char ncmds[4];\t/* Number of load commands.  */\n-  unsigned char sizeofcmds[4];\t/* Total size of load commands.  */\n-  unsigned char flags[4];\t/* Flags for special featues.  */\n-};\n-typedef struct mach_o_header_32 mach_o_header_32;\n-\n-/* Mach-O header (64 bits version).  */\n-struct mach_o_header_64\n-{\n-  unsigned char magic[4];\t/* Magic number.  */\n-  unsigned char cputype[4];\t/* CPU that this object is for.  */\n-  unsigned char cpusubtype[4];\t/* CPU subtype.  */\n-  unsigned char filetype[4];\t/* Type of file.  */\n-  unsigned char ncmds[4];\t/* Number of load commands.  */\n-  unsigned char sizeofcmds[4];\t/* Total size of load commands.  */\n-  unsigned char flags[4];\t/* Flags for special featues.  */\n-  unsigned char reserved[4];\t/* Reserved.  Duh.  */\n-};\n-typedef struct mach_o_header_64 mach_o_header_64;\n-\n-/* Magic number.  */\n-#define MACH_O_MH_MAGIC\t\t\t0xfeedface\n-#define MACH_O_MH_CIGAM\t\t\t0xcefaedfe\n-#define MACH_O_MH_MAGIC_64\t\t0xfeedfacf\n-#define MACH_O_MH_CIGAM_64\t\t0xcffaedfe\n-\n-/* Supported CPU types.  */\n-#define MACH_O_CPU_TYPE_I386\t\t7\n-#define MACH_O_CPU_TYPE_X86_64\t\t7 + 0x1000000\n-#define MACH_O_CPU_TYPE_POWERPC\t\t18\n-#define MACH_O_CPU_TYPE_POWERPC_64\t18 + 0x1000000\n-\n-/* Supported file types.  */\n-#define MACH_O_MH_OBJECT\t\t0x01\n-\n-/* Mach-O load command data structure.  */\n-struct mach_o_load_command\n-{\n-  unsigned char cmd[4];\t\t/* The type of load command.  */\n-  unsigned char cmdsize[4];\t/* Size in bytes of load command data structure.  */\n-};\n-typedef struct mach_o_load_command mach_o_load_command;\n-\n-/* Supported load commands.  We support only the segment load commands.  */\n-#define MACH_O_LC_SEGMENT\t\t0x01\n-#define MACH_O_LC_SEGMENT_64\t\t0x19\n-\n-/* LC_SEGMENT load command.  */\n-struct mach_o_segment_command_32\n-{\n-  unsigned char cmd[4];\t\t/* The type of load command (LC_SEGMENT).  */\n-  unsigned char cmdsize[4];\t/* Size in bytes of load command data structure.  */\n-  unsigned char segname[16];\t/* Name of this segment.  */\n-  unsigned char vmaddr[4];\t/* Virtual memory address of this segment.  */\n-  unsigned char vmsize[4];\t/* Size there, in bytes.  */\n-  unsigned char fileoff[4];\t/* Offset in bytes of the data to be mapped.  */\n-  unsigned char filesize[4];\t/* Size in bytes on disk.  */\n-  unsigned char maxprot[4];\t/* Maximum permitted vmem protection.  */\n-  unsigned char initprot[4];\t/* Initial vmem protection.  */\n-  unsigned char nsects[4];\t/* Number of sections in this segment.  */\n-  unsigned char flags[4];\t/* Flags that affect the loading.  */\n-};\n-typedef struct mach_o_segment_command_32 mach_o_segment_command_32;\n-\n-/* LC_SEGMENT_64 load command.  Only nsects matters for us, really.  */\n-struct mach_o_segment_command_64\n-{\n-  unsigned char cmd[4];\t\t/* The type of load command (LC_SEGMENT_64).  */\n-  unsigned char cmdsize[4];\t/* Size in bytes of load command data structure.  */\n-  unsigned char segname[16];\t/* Name of this segment.  */\n-  unsigned char vmaddr[8];\t/* Virtual memory address of this segment.  */\n-  unsigned char vmsize[8];\t/* Size there, in bytes.  */\n-  unsigned char fileoff[8];\t/* Offset in bytes of the data to be mapped.  */\n-  unsigned char filesize[8];\t/* Size in bytes on disk.  */\n-  unsigned char maxprot[4];\t/* Maximum permitted vmem protection.  */\n-  unsigned char initprot[4];\t/* Initial vmem protection.  */\n-  unsigned char nsects[4];\t/* Number of sections in this segment.  */\n-  unsigned char flags[4];\t/* Flags that affect the loading.  */\n-};\n-typedef struct mach_o_segment_command_64 mach_o_segment_command_64;\n-\n-/* A Mach-O 32-bits section.  */\n-struct mach_o_section_32\n-{\n-  unsigned char sectname[16];\t/* Section name.  */\n-  unsigned char segname[16];\t/* Segment that the section belongs to.  */\n-  unsigned char addr[4];\t/* Address of this section in memory.  */\n-  unsigned char size[4];\t/* Size in bytes of this section.  */\n-  unsigned char offset[4];\t/* File offset of this section.  */\n-  unsigned char align[4];\t/* log2 of this section's alignment.  */\n-  unsigned char reloff[4];\t/* File offset of this section's relocs.  */\n-  unsigned char nreloc[4];\t/* Number of relocs for this section.  */\n-  unsigned char flags[4];\t/* Section flags/attributes.  */\n-  unsigned char reserved1[4];\n-  unsigned char reserved2[4];\n-};\n-typedef struct mach_o_section_32 mach_o_section_32;\n-\n-/* A Mach-O 64-bits section.  */\n-struct mach_o_section_64\n-{\n-  unsigned char sectname[16];\t/* Section name.  */\n-  unsigned char segname[16];\t/* Segment that the section belongs to.  */\n-  unsigned char addr[8];\t/* Address of this section in memory.  */\n-  unsigned char size[8];\t/* Size in bytes of this section.  */\n-  unsigned char offset[4];\t/* File offset of this section.  */\n-  unsigned char align[4];\t/* log2 of this section's alignment.  */\n-  unsigned char reloff[4];\t/* File offset of this section's relocs.  */\n-  unsigned char nreloc[4];\t/* Number of relocs for this section.  */\n-  unsigned char flags[4];\t/* Section flags/attributes.  */\n-  unsigned char reserved1[4];\n-  unsigned char reserved2[4];\n-  unsigned char reserved3[4];\n-};\n-typedef struct mach_o_section_64 mach_o_section_64;\n-\n-/* Flags for Mach-O sections.  LTO sections are marked with S_ATTR_DEBUG\n-   to instruct the linker to ignore the sections.  */\n-#define MACH_O_S_ATTR_DEBUG\t\t\t0x02000000\n-\n-/* In-memory file structures.  */\n-\n-/* Section data in output files is made of these.  */\n-struct lto_mach_o_data_d\n-{\n-  /* Pointer to data block.  */\n-  void *d_buf;\n-\n-  /* Size of data block.  */\n-  ssize_t d_size;\n-\n-  /* Next data block for this section.  */\n-  struct lto_mach_o_data_d *next;\n-};\n-typedef struct lto_mach_o_data_d *lto_mach_o_data;\n-\n-/* This struct tracks the data for a section.  */\n-struct lto_mach_o_section_d\n-{\n-  /* Singly-linked list of section's data blocks.  */\n-  lto_mach_o_data data_chain;\n-\n-  /* Offset in string table of the section name.  */\n-  size_t strtab_offs;\n-\n-  /* Section name.  */\n-  const char *name;\n-\n-  /* Number of trailing padding bytes needed.  */\n-  ssize_t pad_needed;\n-\n-  /* Raw section header data.  */\n-  size_t section_size;\n-  union {\n-    struct {\n-      char sectname[16];\n-      char segname[16];\n-    } section;\n-    mach_o_section_32 section_32;\n-    mach_o_section_64 section_64;\n-  } u;\n-\n-  /* Next section for this file.  */\n-  struct lto_mach_o_section_d *next;\n-};\n-typedef struct lto_mach_o_section_d *lto_mach_o_section;\n-DEF_VEC_P (lto_mach_o_section);\n-DEF_VEC_ALLOC_P (lto_mach_o_section, heap);\n-\n-/* A Mach-O file.  */\n-struct lto_mach_o_file_d\n-{\n-  /* The base information.  */\n-  lto_file base;\n-\n-  /* Common file members:  */\n-\n-  /* The system file descriptor for the file.  */\n-  int fd;\n-\n-  /* The file's overall header.  */\n-  union {\n-    /* We make use here of the fact that section_32 and section_64\n-       have the same layout (except for section_64.reserved3).  We\n-       read the struct of proper size, but only address the first\n-       member of this union.  */\n-    mach_o_header_64 header;\n-    mach_o_header_32 header_32;\n-    mach_o_header_64 header_64;\n-  } u;\n-\n-  /* All sections in a varray.  */\n-  VEC(lto_mach_o_section, heap) *section_vec;\n-\n-  /* Readable file members:  */\n-\n-  /* File total size.  */\n-  off_t file_size;\n-\n-  /* True if this file is open for writing.  */\n-  bool writable;\n-\n-  /* Section containing the __section_names section.  */\n-  lto_mach_o_section section_names_section;\n-\n-  /* Writable file members:  */\n-\n-  /* The currently active section.  */\n-  lto_mach_o_section scn;\n-\n-  /* Linked list of data which must be freed *after* the file has been\n-     closed.  This is an annoying limitation of libelf.  Which has been\n-     faithfully reproduced here.  */\n-  struct lto_char_ptr_base *data;\n-};\n-typedef struct lto_mach_o_file_d lto_mach_o_file;\n-\n-#endif /* LTO_MACH_O_H */\n-"}, {"sha": "e4a998163cf3dcbd73b922d7167cde74e838d7f5", "filename": "gcc/lto/lto-object.c", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb/gcc%2Flto%2Flto-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb/gcc%2Flto%2Flto-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-object.c?ref=6b3456d1ff836cfc40033b9b238c5dcd9b18d9cb", "patch": "@@ -0,0 +1,376 @@\n+/* LTO routines to use object files.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"toplev.h\"\n+#include \"lto.h\"\n+#include \"tm.h\"\n+#include \"lto-streamer.h\"\n+#include \"libiberty.h\"\n+#include \"simple-object.h\"\n+\n+/* Handle opening elf files on hosts, such as Windows, that may use\n+   text file handling that will break binary access.  */\n+#ifndef O_BINARY\n+# define O_BINARY 0\n+#endif\n+\n+/* Segment name for LTO sections.  This is only used for Mach-O.\n+   FIXME: This needs to be kept in sync with darwin.c.  */\n+\n+#define LTO_SEGMENT_NAME \"__GNU_LTO\"\n+\n+/* An LTO file wrapped around an simple_object.  */\n+\n+struct lto_simple_object\n+{\n+  /* The base information.  */\n+  lto_file base;\n+\n+  /* The system file descriptor.  */\n+  int fd;\n+\n+  /* The simple_object if we are reading the file.  */\n+  simple_object_read *sobj_r;\n+\n+  /* The simple_object if we are writing the file.  */\n+  simple_object_write *sobj_w;\n+\n+  /* The currently active section.  */\n+  simple_object_write_section *section;\n+};\n+\n+/* Saved simple_object attributes.  FIXME: Once set, this is never\n+   cleared.  */\n+\n+static simple_object_attributes *saved_attributes;\n+\n+/* Initialize FILE, an LTO file object for FILENAME.  */\n+\n+static void\n+lto_file_init (lto_file *file, const char *filename, off_t offset)\n+{\n+  file->filename = filename;\n+  file->offset = offset;\n+}\n+\n+/* Open the file FILENAME.  It WRITABLE is true, the file is opened\n+   for write and, if necessary, created.  Otherwise, the file is\n+   opened for reading.  Returns the opened file.  */\n+\n+lto_file *\n+lto_obj_file_open (const char *filename, bool writable)\n+{\n+  const char *offset_p;\n+  long loffset;\n+  int consumed;\n+  char *fname;\n+  off_t offset;\n+  struct lto_simple_object *lo;\n+  const char *errmsg;\n+  int err;\n+\n+  offset_p = strrchr (filename, '@');\n+  if (offset_p != NULL\n+      && offset_p != filename\n+      && sscanf (offset_p, \"@%li%n\", &loffset, &consumed) >= 1\n+      && strlen (offset_p) == (unsigned int) consumed)\n+    {\n+      fname = XNEWVEC (char, offset_p - filename + 1);\n+      memcpy (fname, filename, offset_p - filename);\n+      fname[offset_p - filename] = '\\0';\n+      offset = (off_t) loffset;\n+    }\n+  else\n+    {\n+      fname = xstrdup (filename);\n+      offset = 0;\n+    }\n+\n+  lo = XCNEW (struct lto_simple_object);\n+  lto_file_init ((lto_file *) lo, fname, offset);\n+\n+  lo->fd = open (fname,\n+\t\t (writable\n+\t\t  ? O_WRONLY | O_CREAT | O_BINARY\n+\t\t  : O_RDONLY | O_BINARY),\n+\t\t 0666);\n+  if (lo->fd == -1)\n+    {\n+      error (\"open %s failed: %s\", fname, xstrerror (errno));\n+      goto fail;\n+    }\n+\n+  if (!writable)\n+    {\n+      simple_object_attributes *attrs;\n+\n+      lo->sobj_r = simple_object_start_read (lo->fd, offset, LTO_SEGMENT_NAME,\n+\t\t\t\t\t     &errmsg, &err);\n+      if (lo->sobj_r == NULL)\n+\tgoto fail_errmsg;\n+\n+      attrs = simple_object_fetch_attributes (lo->sobj_r, &errmsg, &err);\n+      if (attrs == NULL)\n+\tgoto fail_errmsg;\n+\n+      if (saved_attributes == NULL)\n+\tsaved_attributes = attrs;\n+      else\n+\t{\n+\t  errmsg = simple_object_attributes_compare (saved_attributes, attrs,\n+\t\t\t\t\t\t     &err);\n+\t  if (errmsg != NULL)\n+\t    goto fail_errmsg;\n+\t}\n+    }\n+  else\n+    {\n+      gcc_assert (saved_attributes != NULL);\n+      lo->sobj_w = simple_object_start_write (saved_attributes,\n+\t\t\t\t\t      LTO_SEGMENT_NAME,\n+\t\t\t\t\t      &errmsg, &err);\n+      if (lo->sobj_w == NULL)\n+\tgoto fail_errmsg;\n+    }\n+\n+  return &lo->base;\n+\n+ fail_errmsg:\n+  if (err == 0)\n+    error (\"%s: %s\", fname, errmsg);\n+  else\n+    error (\"%s: %s: %s\", fname, errmsg, xstrerror (err));\n+\t\t\t\t\t \n+ fail:\n+  if (lo != NULL)\n+    lto_obj_file_close ((lto_file *) lo);\n+  return NULL;\n+}\n+\n+/* Close FILE.  If FILE was opened for writing, it is written out\n+   now.  */\n+\n+void\n+lto_obj_file_close (lto_file *file)\n+{\n+  struct lto_simple_object *lo = (struct lto_simple_object *) file;\n+\n+  if (lo->sobj_r != NULL)\n+    simple_object_release_read (lo->sobj_r);\n+  else if (lo->sobj_w != NULL)\n+    {\n+      const char *errmsg;\n+      int err;\n+\n+      gcc_assert (lo->base.offset == 0);\n+\n+      errmsg = simple_object_write_to_file (lo->sobj_w, lo->fd, &err);\n+      if (errmsg != NULL)\n+\t{\n+\t  if (err == 0)\n+\t    fatal_error (\"%s\", errmsg);\n+\t  else\n+\t    fatal_error (\"%s: %s\", errmsg, xstrerror (err));\n+\t}\n+\n+      simple_object_release_write (lo->sobj_w);\n+    }\n+\n+  if (lo->fd != -1)\n+    {\n+      if (close (lo->fd) < 0)\n+\tfatal_error (\"close: %s\", xstrerror (errno));\n+    }\n+}\n+\n+/* This is passed to lto_obj_add_section.  */\n+\n+struct lto_obj_add_section_data\n+{\n+  /* The hash table of sections.  */\n+  htab_t section_hash_table;\n+  /* The offset of this file.  */\n+  off_t base_offset;\n+};\n+\n+/* This is called for each section in the file.  */\n+\n+static int\n+lto_obj_add_section (void *data, const char *name, off_t offset,\n+\t\t     off_t length)\n+{\n+  struct lto_obj_add_section_data *loasd =\n+    (struct lto_obj_add_section_data *) data;\n+  htab_t section_hash_table = (htab_t) loasd->section_hash_table;\n+  char *new_name;\n+  struct lto_section_slot s_slot;\n+  void **slot;\n+\n+  if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n+\t       strlen (LTO_SECTION_NAME_PREFIX)) != 0)\n+    return 1;\n+\n+  new_name = xstrdup (name);\n+  s_slot.name = new_name;\n+  slot = htab_find_slot (section_hash_table, &s_slot, INSERT);\n+  if (*slot == NULL)\n+    {\n+      struct lto_section_slot *new_slot = XNEW (struct lto_section_slot);\n+\n+      new_slot->name = new_name;\n+      new_slot->start = loasd->base_offset + offset;\n+      new_slot->len = length;\n+      *slot = new_slot;\n+    }\n+  else\n+    {\n+      error (\"two or more sections for %s\", new_name);\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Build a hash table whose key is the section name and whose data is\n+   the start and size of each section in the .o file.  */\n+\n+htab_t\n+lto_obj_build_section_table (lto_file *lto_file)\n+{\n+  struct lto_simple_object *lo = (struct lto_simple_object *) lto_file;\n+  htab_t section_hash_table;\n+  struct lto_obj_add_section_data loasd;\n+  const char *errmsg;\n+  int err;\n+\n+  section_hash_table = lto_obj_create_section_hash_table ();\n+\n+  gcc_assert (lo->sobj_r != NULL && lo->sobj_w == NULL);\n+  loasd.section_hash_table = section_hash_table;\n+  loasd.base_offset = lo->base.offset;\n+  errmsg = simple_object_find_sections (lo->sobj_r, lto_obj_add_section,\n+\t\t\t\t\t&loasd, &err);\n+  if (errmsg != NULL)\n+    {\n+      if (err == 0)\n+\terror (\"%s\", errmsg);\n+      else\n+\terror (\"%s: %s\", errmsg, xstrerror (err));\n+      htab_delete (section_hash_table);\n+      return NULL;\n+    }\n+\n+  return section_hash_table;\n+}\n+\n+/* The current output file.  */\n+\n+static lto_file *current_out_file;\n+\n+/* Set the current output file.  Return the old one.  */\n+\n+lto_file *\n+lto_set_current_out_file (lto_file *file)\n+{\n+  lto_file *old_file;\n+\n+  old_file = current_out_file;\n+  current_out_file = file;\n+  return old_file;\n+}\n+\n+/* Return the current output file.  */\n+\n+lto_file *\n+lto_get_current_out_file (void)\n+{\n+  return current_out_file;\n+}\n+\n+/* Begin writing a new section named NAME in the current output\n+   file.  */\n+\n+void\n+lto_obj_begin_section (const char *name)\n+{\n+  struct lto_simple_object *lo;\n+  int align;\n+  const char *errmsg;\n+  int err;\n+\n+  lo = (struct lto_simple_object *) current_out_file;\n+  gcc_assert (lo != NULL\n+\t      && lo->sobj_r == NULL\n+\t      && lo->sobj_w != NULL\n+\t      && lo->section == NULL);\n+\n+  align = exact_log2 (POINTER_SIZE / BITS_PER_UNIT);\n+  lo->section = simple_object_write_create_section (lo->sobj_w, name, align,\n+\t\t\t\t\t\t    &errmsg, &err);\n+  if (lo->section == NULL)\n+    {\n+      if (err == 0)\n+\tfatal_error (\"%s\", errmsg);\n+      else\n+\tfatal_error (\"%s: %s\", errmsg, xstrerror (errno));\n+    }\n+}\n+\n+/* Add data to a section.  BLOCK is a pointer to memory containing\n+   DATA.  */\n+\n+void\n+lto_obj_append_data (const void *data, size_t len, void *block)\n+{\n+  struct lto_simple_object *lo;\n+  const char *errmsg;\n+  int err;\n+\n+  lo = (struct lto_simple_object *) current_out_file;\n+  gcc_assert (lo != NULL && lo->section != NULL);\n+\n+  errmsg = simple_object_write_add_data (lo->sobj_w, lo->section, data, len,\n+\t\t\t\t\t 1, &err);\n+  if (errmsg != NULL)\n+    {\n+      if (err == 0)\n+\tfatal_error (\"%s\", errmsg);\n+      else\n+\tfatal_error (\"%s: %s\", errmsg, xstrerror (errno));\n+    }\n+\n+  free (block);\n+}\n+\n+/* Stop writing to the current output section.  */\n+\n+void\n+lto_obj_end_section (void)\n+{\n+  struct lto_simple_object *lo;\n+\n+  lo = (struct lto_simple_object *) current_out_file;\n+  gcc_assert (lo != NULL && lo->section != NULL);\n+  lo->section = NULL;\n+}"}]}