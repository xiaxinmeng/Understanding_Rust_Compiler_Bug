{"sha": "e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgzNzRlN2FmMzdjNTZhNzljOGQyOGIwZjczNjdiY2M1YTRkNjcwNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T14:50:56Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T14:50:56Z"}, "message": "[multiple changes]\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_res.adb: Minor reformatting.\n\t* sem_prag.adb: Minor reformatting.\n\n2011-08-02  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_atag.adb, exp_atags.ads\n\t(Build_Common_Dispatching_Select_Statement): Replace argument DT_Ptr\n\tby the tagged type Entity. Required to use this routine in the VM\n\ttargets since we do not have available the Tag entity in the VM\n\tplatforms.\n\t* exp_ch6.adb\n\t(Expand_N_Subprogram_Body): Do not invoke Build_VM_TSDs if package\n\tAda.Tags has not been previously loaded.\n\t* exp_ch7.adb\n\t(Expand_N_Package_Declaration, Expand_N_Package_Body): Do not invoke\n\tBuild_VM_TSDs if package Ada.Tags has not been previously loaded.\n\t* sem_aux.adb\n\t(Enclosing_Dynamic_Scope): Add missing support to handle the full\n\tview of enclosing scopes. Required to handle enclosing scopes that\n\tare synchronized types whose full view is a task type.\n\t* exp_disp.adb\n\t(Build_VM_TSDs): Minor code improvement to avoid generating and\n\tanalyzing lists with empty nodes.\n\t(Make_Disp_Asynchronous_Select_Body): Add support for VM targets.\n\t(Make_Disp_Conditional_Select_Body): Add support for VM targets.\n\t(Make_Disp_Get_Prim_Op_Kind): Add support for VM targets.\n\t(Make_Disp_Timed_Select_Body): Add support for VM targets.\n\t(Make_Select_Specific_Data_Table): Add support for VM targets.\n\t(Make_VM_TSD): Generate code to initialize the SSD structure of\n\tthe TSD.\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* lib-writ.adb (Write_ALI): when ALFA mode is set, write local\n\tcross-references section in ALI.\n\t* lib-xref.adb, lib-xref.ads (Xref_Entry): add components Sub\n\t(enclosing subprogram), Slc (location of Sub) and Sun (unit number of\n\tSub).\n\t(Enclosing_Subprogram_Or_Package): new function to return the enclosing\n\tsubprogram or package entity of a node\n\t(Is_Local_Reference_Type): new function returns True for references\n\tselected in local cross-references.\n\t(Lt): function extracted from Lt in Output_References\n\t(Write_Entity_Name): function extracted from Output_References\n\t(Generate_Definition): generate reference with type 'D' for definition\n\tof objects (object declaration and parameter specification), with\n\tappropriate locations and units, for use in local cross-references.\n\t(Generate_Reference): update fields Sub, Slc and Sun. Keep newly created\n\treferences of type 'I' for initialization in object definition.\n\t(Output_References): move part of function Lt and procedure\n\tWrite_Entity_Name outside of the body. Ignore references of types 'D'\n\tand 'I' introduced for local cross-references.\n\t(Output_Local_References): new procedure to output the local\n\tcross-references sections.\n\t(Lref_Entity_Status): new array defining whether an entity is a local\n\t* sem_ch3.adb (Analyze_Object_Declaration): call Generate_Reference\n\twith 'I' type when initialization expression is present.\n\t* get_scos.adb, get_scos.ads: Correct comments and typos\n\nFrom-SVN: r177168", "tree": {"sha": "a1b06e4ed6a4b1f7880a8bfe87725096075bfc2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1b06e4ed6a4b1f7880a8bfe87725096075bfc2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/comments", "author": null, "committer": null, "parents": [{"sha": "1f6439e34bc08817b3a82b893810e14283fe280e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6439e34bc08817b3a82b893810e14283fe280e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6439e34bc08817b3a82b893810e14283fe280e"}], "stats": {"total": 1254, "additions": 1107, "deletions": 147}, "files": [{"sha": "0890b264a07817dc5b400562ffc11f6ee1000f2d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -1,3 +1,64 @@\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_res.adb: Minor reformatting.\n+\t* sem_prag.adb: Minor reformatting.\n+\n+2011-08-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_atag.adb, exp_atags.ads\n+\t(Build_Common_Dispatching_Select_Statement): Replace argument DT_Ptr\n+\tby the tagged type Entity. Required to use this routine in the VM\n+\ttargets since we do not have available the Tag entity in the VM\n+\tplatforms.\n+\t* exp_ch6.adb\n+\t(Expand_N_Subprogram_Body): Do not invoke Build_VM_TSDs if package\n+\tAda.Tags has not been previously loaded.\n+\t* exp_ch7.adb\n+\t(Expand_N_Package_Declaration, Expand_N_Package_Body): Do not invoke\n+\tBuild_VM_TSDs if package Ada.Tags has not been previously loaded.\n+\t* sem_aux.adb\n+\t(Enclosing_Dynamic_Scope): Add missing support to handle the full\n+\tview of enclosing scopes. Required to handle enclosing scopes that\n+\tare synchronized types whose full view is a task type.\n+\t* exp_disp.adb\n+\t(Build_VM_TSDs): Minor code improvement to avoid generating and\n+\tanalyzing lists with empty nodes.\n+\t(Make_Disp_Asynchronous_Select_Body): Add support for VM targets.\n+\t(Make_Disp_Conditional_Select_Body): Add support for VM targets.\n+\t(Make_Disp_Get_Prim_Op_Kind): Add support for VM targets.\n+\t(Make_Disp_Timed_Select_Body): Add support for VM targets.\n+\t(Make_Select_Specific_Data_Table): Add support for VM targets.\n+\t(Make_VM_TSD): Generate code to initialize the SSD structure of\n+\tthe TSD.\n+\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-writ.adb (Write_ALI): when ALFA mode is set, write local\n+\tcross-references section in ALI.\n+\t* lib-xref.adb, lib-xref.ads (Xref_Entry): add components Sub\n+\t(enclosing subprogram), Slc (location of Sub) and Sun (unit number of\n+\tSub).\n+\t(Enclosing_Subprogram_Or_Package): new function to return the enclosing\n+\tsubprogram or package entity of a node\n+\t(Is_Local_Reference_Type): new function returns True for references\n+\tselected in local cross-references.\n+\t(Lt): function extracted from Lt in Output_References\n+\t(Write_Entity_Name): function extracted from Output_References\n+\t(Generate_Definition): generate reference with type 'D' for definition\n+\tof objects (object declaration and parameter specification), with\n+\tappropriate locations and units, for use in local cross-references.\n+\t(Generate_Reference): update fields Sub, Slc and Sun. Keep newly created\n+\treferences of type 'I' for initialization in object definition.\n+\t(Output_References): move part of function Lt and procedure\n+\tWrite_Entity_Name outside of the body. Ignore references of types 'D'\n+\tand 'I' introduced for local cross-references.\n+\t(Output_Local_References): new procedure to output the local\n+\tcross-references sections.\n+\t(Lref_Entity_Status): new array defining whether an entity is a local\n+\t* sem_ch3.adb (Analyze_Object_Declaration): call Generate_Reference\n+\twith 'I' type when initialization expression is present.\n+\t* get_scos.adb, get_scos.ads: Correct comments and typos\n+\n 2011-08-02  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch6.adb (Expand_N_Subprogram_Body): Enable generation of TSDs in"}, {"sha": "f89263c50c0136a7cdce7bfb1f4a8a0c2927928a", "filename": "gcc/ada/exp_atag.adb", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_atag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_atag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ with Exp_Util; use Exp_Util;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n+with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sinfo;    use Sinfo;\n with Sem_Aux;  use Sem_Aux;\n@@ -71,25 +72,39 @@ package body Exp_Atag is\n \n    procedure Build_Common_Dispatching_Select_Statements\n      (Loc    : Source_Ptr;\n-      DT_Ptr : Entity_Id;\n+      Typ    : Entity_Id;\n       Stmts  : List_Id)\n    is\n+      Tag_Node : Node_Id;\n+\n    begin\n       --  Generate:\n       --    C := get_prim_op_kind (tag! (<type>VP), S);\n \n       --  where C is the out parameter capturing the call kind and S is the\n       --  dispatch table slot number.\n \n+      if Tagged_Type_Expansion then\n+         Tag_Node :=\n+           Unchecked_Convert_To (RTE (RE_Tag),\n+             New_Reference_To\n+              (Node (First_Elmt (Access_Disp_Table (Typ))), Loc));\n+\n+      else\n+         Tag_Node :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix => New_Reference_To (Typ, Loc),\n+             Attribute_Name => Name_Tag);\n+      end if;\n+\n       Append_To (Stmts,\n         Make_Assignment_Statement (Loc,\n           Name => Make_Identifier (Loc, Name_uC),\n           Expression =>\n             Make_Function_Call (Loc,\n               Name => New_Occurrence_Of (RTE (RE_Get_Prim_Op_Kind), Loc),\n               Parameter_Associations => New_List (\n-                Unchecked_Convert_To (RTE (RE_Tag),\n-                  New_Reference_To (DT_Ptr, Loc)),\n+                Tag_Node,\n                 Make_Identifier (Loc, Name_uS)))));\n \n       --  Generate:"}, {"sha": "586904bd381c12e7512596d1814036240c03f0c0", "filename": "gcc/ada/exp_atag.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,9 +35,9 @@ package Exp_Atag is\n    --  location used in constructing the corresponding nodes.\n \n    procedure Build_Common_Dispatching_Select_Statements\n-     (Loc    : Source_Ptr;\n-      DT_Ptr : Entity_Id;\n-      Stmts  : List_Id);\n+     (Loc   : Source_Ptr;\n+      Typ   : Entity_Id;\n+      Stmts : List_Id);\n    --  Ada 2005 (AI-345): Generate statements that are common between timed,\n    --  asynchronous, and conditional select expansion.\n "}, {"sha": "8a842fba5b2ceeb12c8d512a7d5a6e1c8e885702", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -5125,8 +5125,13 @@ package body Exp_Ch6 is\n       --  VM targets, we now generate the Type Specific Data record of all the\n       --  enclosing tagged type declarations.\n \n+      --  If the runtime package Ada_Tags has not been loaded then this\n+      --  subprogram does not have tagged type declarations and there is no\n+      --  need to search for tagged types to generate their TSDs.\n+\n       if not Tagged_Type_Expansion\n         and then Unit (Cunit (Main_Unit)) = N\n+        and then RTU_Loaded (Ada_Tags)\n       then\n          Build_VM_TSDs (N);\n       end if;"}, {"sha": "8063601256b8841d02bb6dccfb315080528c958f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -1560,7 +1560,15 @@ package body Exp_Ch7 is\n             --  we must generate the corresponding Type Specific Data record.\n \n             elsif Unit (Cunit (Main_Unit)) = N then\n-               Build_VM_TSDs (N);\n+\n+               --  If the runtime package Ada_Tags has not been loaded then\n+               --  this package does not have tagged type declarations and\n+               --  there is no need to search for tagged types to generate\n+               --  their TSDs.\n+\n+               if RTU_Loaded (Ada_Tags) then\n+                  Build_VM_TSDs (N);\n+               end if;\n             end if;\n          end if;\n \n@@ -1670,22 +1678,29 @@ package body Exp_Ch7 is\n \n          elsif Unit (Cunit (Main_Unit)) = N then\n \n-            --  Enter the scope of the package because the new declarations are\n-            --  appended at the end of the package and must be analyzed in that\n-            --  context.\n+            --  If the runtime package Ada_Tags has not been loaded then\n+            --  this package does not have tagged types and there is no need\n+            --  to search for tagged types to generate their TSDs.\n+\n+            if RTU_Loaded (Ada_Tags) then\n+\n+               --  Enter the scope of the package because the new declarations\n+               --  are appended at the end of the package and must be analyzed\n+               --  in that context.\n \n-            Push_Scope (Id);\n+               Push_Scope (Id);\n \n-            if Is_Generic_Instance (Main_Unit_Entity) then\n-               if Package_Instantiation (Main_Unit_Entity) = N then\n+               if Is_Generic_Instance (Main_Unit_Entity) then\n+                  if Package_Instantiation (Main_Unit_Entity) = N then\n+                     Build_VM_TSDs (N);\n+                  end if;\n+\n+               else\n                   Build_VM_TSDs (N);\n                end if;\n \n-            else\n-               Build_VM_TSDs (N);\n+               Pop_Scope;\n             end if;\n-\n-            Pop_Scope;\n          end if;\n       end if;\n "}, {"sha": "4f0fc0fbe8739a50aea2d39e5016f4153ec314b6", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 206, "deletions": 47, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -474,7 +474,7 @@ package body Exp_Disp is\n    -------------------\n \n    procedure Build_VM_TSDs (N : Entity_Id) is\n-      Target_List : List_Id;\n+      Target_List : List_Id := No_List;\n \n       procedure Build_TSDs (List : List_Id);\n       --  Build the static dispatch table of tagged types found in the list of\n@@ -538,6 +538,10 @@ package body Exp_Disp is\n                   null;\n \n                else\n+                  if No (Target_List) then\n+                     Target_List := New_List;\n+                  end if;\n+\n                   Append_List_To (Target_List,\n                     Make_VM_TSD (Defining_Entity (D)));\n                end if;\n@@ -552,9 +556,9 @@ package body Exp_Disp is\n       ------------------------\n \n       procedure Build_Package_TSDs (N : Node_Id) is\n-         Spec       : constant Node_Id   := Specification (N);\n-         Vis_Decls  : constant List_Id   := Visible_Declarations (Spec);\n-         Priv_Decls : constant List_Id   := Private_Declarations (Spec);\n+         Spec       : constant Node_Id := Specification (N);\n+         Vis_Decls  : constant List_Id := Visible_Declarations (Spec);\n+         Priv_Decls : constant List_Id := Private_Declarations (Spec);\n \n       begin\n          if Present (Priv_Decls) then\n@@ -571,6 +575,7 @@ package body Exp_Disp is\n    begin\n       if not Expander_Active\n         or else No_Run_Time_Mode\n+        or else Tagged_Type_Expansion\n         or else not RTE_Available (RE_Type_Specific_Data)\n       then\n          return;\n@@ -583,25 +588,33 @@ package body Exp_Disp is\n             Priv_Decls : constant List_Id := Private_Declarations (Spec);\n \n          begin\n-            Target_List := New_List;\n             Build_Package_TSDs (N);\n-            Analyze_List (Target_List);\n \n-            if Present (Priv_Decls)\n-              and then Is_Non_Empty_List (Priv_Decls)\n-            then\n-               Append_List (Target_List, Priv_Decls);\n-            else\n-               Append_List (Target_List, Vis_Decls);\n+            if Present (Target_List) then\n+               Analyze_List (Target_List);\n+\n+               if Present (Priv_Decls)\n+                  and then Is_Non_Empty_List (Priv_Decls)\n+               then\n+                  Append_List (Target_List, Priv_Decls);\n+               else\n+                  Append_List (Target_List, Vis_Decls);\n+               end if;\n             end if;\n          end;\n \n       elsif Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n          if Is_Non_Empty_List (Declarations (N)) then\n-            Target_List := New_List;\n-            Build_TSDs   (Declarations (N));\n-            Analyze_List (Target_List);\n-            Append_List  (Target_List, Declarations (N));\n+            Build_TSDs (Declarations (N));\n+\n+            if Nkind (N) = N_Subprogram_Body then\n+               Build_TSDs (Statements (Handled_Statement_Sequence (N)));\n+            end if;\n+\n+            if Present (Target_List) then\n+               Analyze_List (Target_List);\n+               Append_List  (Target_List, Declarations (N));\n+            end if;\n          end if;\n       end if;\n    end Build_VM_TSDs;\n@@ -2209,10 +2222,10 @@ package body Exp_Disp is\n       Com_Block : Entity_Id;\n       Conc_Typ  : Entity_Id           := Empty;\n       Decls     : constant List_Id    := New_List;\n-      DT_Ptr    : Entity_Id;\n       Loc       : constant Source_Ptr := Sloc (Typ);\n       Obj_Ref   : Node_Id;\n       Stmts     : constant List_Id    := New_List;\n+      Tag_Node  : Node_Id;\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n@@ -2231,8 +2244,6 @@ package body Exp_Disp is\n                  New_List (Make_Null_Statement (Loc))));\n       end if;\n \n-      DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n-\n       if Is_Concurrent_Record_Type (Typ) then\n          Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n@@ -2243,6 +2254,18 @@ package body Exp_Disp is\n          --  where I will be used to capture the entry index of the primitive\n          --  wrapper at position S.\n \n+         if Tagged_Type_Expansion then\n+            Tag_Node :=\n+              Unchecked_Convert_To (RTE (RE_Tag),\n+                New_Reference_To\n+                  (Node (First_Elmt (Access_Disp_Table (Typ))), Loc));\n+         else\n+            Tag_Node :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (Typ, Loc),\n+                Attribute_Name => Name_Tag);\n+         end if;\n+\n          Append_To (Decls,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier =>\n@@ -2255,8 +2278,7 @@ package body Exp_Disp is\n                    New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n                  Parameter_Associations =>\n                    New_List (\n-                     Unchecked_Convert_To (RTE (RE_Tag),\n-                       New_Reference_To (DT_Ptr, Loc)),\n+                     Tag_Node,\n                      Make_Identifier (Loc, Name_uS)))));\n \n          if Ekind (Conc_Typ) = E_Protected_Type then\n@@ -2553,9 +2575,9 @@ package body Exp_Disp is\n       Blk_Nam  : Entity_Id;\n       Conc_Typ : Entity_Id           := Empty;\n       Decls    : constant List_Id    := New_List;\n-      DT_Ptr   : Entity_Id;\n       Obj_Ref  : Node_Id;\n       Stmts    : constant List_Id    := New_List;\n+      Tag_Node : Node_Id;\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n@@ -2574,8 +2596,6 @@ package body Exp_Disp is\n                  New_List (Make_Null_Statement (Loc))));\n       end if;\n \n-      DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n-\n       if Is_Concurrent_Record_Type (Typ) then\n          Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n@@ -2603,7 +2623,7 @@ package body Exp_Disp is\n          --       return;\n          --    end if;\n \n-         Build_Common_Dispatching_Select_Statements (Loc, DT_Ptr, Stmts);\n+         Build_Common_Dispatching_Select_Statements (Loc, Typ, Stmts);\n \n          --  Generate:\n          --    Bnn : Communication_Block;\n@@ -2624,6 +2644,19 @@ package body Exp_Disp is\n \n          --  I is the entry index and S is the dispatch table slot\n \n+         if Tagged_Type_Expansion then\n+            Tag_Node :=\n+              Unchecked_Convert_To (RTE (RE_Tag),\n+                New_Reference_To\n+                  (Node (First_Elmt (Access_Disp_Table (Typ))), Loc));\n+\n+         else\n+            Tag_Node :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (Typ, Loc),\n+                Attribute_Name => Name_Tag);\n+         end if;\n+\n          Append_To (Stmts,\n            Make_Assignment_Statement (Loc,\n              Name => Make_Identifier (Loc, Name_uI),\n@@ -2633,8 +2666,7 @@ package body Exp_Disp is\n                    New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n                  Parameter_Associations =>\n                    New_List (\n-                     Unchecked_Convert_To (RTE (RE_Tag),\n-                       New_Reference_To (DT_Ptr, Loc)),\n+                     Tag_Node,\n                      Make_Identifier (Loc, Name_uS)))));\n \n          if Ekind (Conc_Typ) = E_Protected_Type then\n@@ -2848,8 +2880,8 @@ package body Exp_Disp is\n    function Make_Disp_Get_Prim_Op_Kind_Body\n      (Typ : Entity_Id) return Node_Id\n    is\n-      Loc    : constant Source_Ptr := Sloc (Typ);\n-      DT_Ptr : Entity_Id;\n+      Loc      : constant Source_Ptr := Sloc (Typ);\n+      Tag_Node : Node_Id;\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n@@ -2866,14 +2898,25 @@ package body Exp_Disp is\n                  New_List (Make_Null_Statement (Loc))));\n       end if;\n \n-      DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n-\n       --  Generate:\n       --    C := get_prim_op_kind (tag! (<type>VP), S);\n \n       --  where C is the out parameter capturing the call kind and S is the\n       --  dispatch table slot number.\n \n+      if Tagged_Type_Expansion then\n+         Tag_Node :=\n+           Unchecked_Convert_To (RTE (RE_Tag),\n+             New_Reference_To\n+              (Node (First_Elmt (Access_Disp_Table (Typ))), Loc));\n+\n+      else\n+         Tag_Node :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix => New_Reference_To (Typ, Loc),\n+             Attribute_Name => Name_Tag);\n+      end if;\n+\n       return\n         Make_Subprogram_Body (Loc,\n           Specification =>\n@@ -2891,9 +2934,8 @@ package body Exp_Disp is\n                       Name =>\n                         New_Reference_To (RTE (RE_Get_Prim_Op_Kind), Loc),\n                       Parameter_Associations => New_List (\n-                        Unchecked_Convert_To (RTE (RE_Tag),\n-                          New_Reference_To (DT_Ptr, Loc)),\n-                          Make_Identifier (Loc, Name_uS)))))));\n+                        Tag_Node,\n+                        Make_Identifier (Loc, Name_uS)))))));\n    end Make_Disp_Get_Prim_Op_Kind_Body;\n \n    -------------------------------------\n@@ -3380,9 +3422,9 @@ package body Exp_Disp is\n       Loc      : constant Source_Ptr := Sloc (Typ);\n       Conc_Typ : Entity_Id           := Empty;\n       Decls    : constant List_Id    := New_List;\n-      DT_Ptr   : Entity_Id;\n       Obj_Ref  : Node_Id;\n       Stmts    : constant List_Id    := New_List;\n+      Tag_Node : Node_Id;\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n@@ -3401,8 +3443,6 @@ package body Exp_Disp is\n                  New_List (Make_Null_Statement (Loc))));\n       end if;\n \n-      DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n-\n       if Is_Concurrent_Record_Type (Typ) then\n          Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n@@ -3430,13 +3470,26 @@ package body Exp_Disp is\n          --       return;\n          --    end if;\n \n-         Build_Common_Dispatching_Select_Statements (Loc, DT_Ptr, Stmts);\n+         Build_Common_Dispatching_Select_Statements (Loc, Typ, Stmts);\n \n          --  Generate:\n          --    I := Get_Entry_Index (tag! (<type>VP), S);\n \n          --  I is the entry index and S is the dispatch table slot\n \n+         if Tagged_Type_Expansion then\n+            Tag_Node :=\n+              Unchecked_Convert_To (RTE (RE_Tag),\n+                New_Reference_To\n+                  (Node (First_Elmt (Access_Disp_Table (Typ))), Loc));\n+\n+         else\n+            Tag_Node :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (Typ, Loc),\n+                Attribute_Name => Name_Tag);\n+         end if;\n+\n          Append_To (Stmts,\n            Make_Assignment_Statement (Loc,\n              Name       => Make_Identifier (Loc, Name_uI),\n@@ -3446,8 +3499,7 @@ package body Exp_Disp is\n                    New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n                  Parameter_Associations =>\n                    New_List (\n-                     Unchecked_Convert_To (RTE (RE_Tag),\n-                       New_Reference_To (DT_Ptr, Loc)),\n+                     Tag_Node,\n                      Make_Identifier (Loc, Name_uS)))));\n \n          --  Protected case\n@@ -6258,16 +6310,21 @@ package body Exp_Disp is\n       Loc              : constant Source_Ptr := Sloc (Typ);\n       Result           : constant List_Id := New_List;\n       AI               : Elmt_Id;\n-      I_Depth          : Nat := 0; -- why initialized here ???\n+      I_Depth          : Nat;\n       Iface_Table_Node : Node_Id;\n-      Num_Ifaces       : Nat := 0; -- why initialized here ???\n+      Nb_Prim          : Nat;\n+      Num_Ifaces       : Nat;\n       TSD_Aggr_List    : List_Id;\n       Typ_Ifaces       : Elist_Id;\n       TSD_Tags_List    : List_Id;\n \n       Tname    : constant Name_Id := Chars (Typ);\n+      Name_SSD : constant Name_Id :=\n+                   New_External_Name (Tname, 'S', Suffix_Index => -1);\n       Name_TSD : constant Name_Id :=\n                    New_External_Name (Tname, 'B', Suffix_Index => -1);\n+      SSD      : constant Entity_Id :=\n+                   Make_Defining_Identifier (Loc, Name_SSD);\n       TSD      : constant Entity_Id :=\n                    Make_Defining_Identifier (Loc, Name_TSD);\n    begin\n@@ -6359,6 +6416,7 @@ package body Exp_Disp is\n \n          Collect_Interfaces (Typ, Typ_Ifaces);\n \n+         Num_Ifaces := 0;\n          AI := First_Elmt (Typ_Ifaces);\n          while Present (AI) loop\n             Num_Ifaces := Num_Ifaces + 1;\n@@ -6420,6 +6478,68 @@ package body Exp_Disp is\n          Append_To (TSD_Aggr_List, Iface_Table_Node);\n       end if;\n \n+      --  Generate the Select Specific Data table for synchronized types that\n+      --  implement synchronized interfaces. The size of the table is\n+      --  constrained by the number of non-predefined primitive operations.\n+\n+      --  Count the non-predefined primitive operations\n+\n+      Nb_Prim := 0;\n+\n+      declare\n+         Prim_Elmt : Elmt_Id;\n+         Prim      : Entity_Id;\n+      begin\n+         Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+         while Present (Prim_Elmt) loop\n+            Prim := Node (Prim_Elmt);\n+\n+            if not (Is_Predefined_Dispatching_Operation (Prim)\n+                      or else Is_Predefined_Dispatching_Alias (Prim))\n+            then\n+               Nb_Prim := Nb_Prim + 1;\n+            end if;\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+      end;\n+\n+      if RTE_Record_Component_Available (RE_SSD) then\n+         if Ada_Version >= Ada_2005\n+           and then Has_DT (Typ)\n+           and then Is_Concurrent_Record_Type (Typ)\n+           and then Has_Interfaces (Typ)\n+           and then Nb_Prim > 0\n+           and then not Is_Abstract_Type (Typ)\n+           and then not Is_Controlled (Typ)\n+           and then not Restriction_Active (No_Dispatching_Calls)\n+           and then not Restriction_Active (No_Select_Statements)\n+         then\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => SSD,\n+                Aliased_Present     => True,\n+                Object_Definition   =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark => New_Reference_To (\n+                      RTE (RE_Select_Specific_Data), Loc),\n+                    Constraint   =>\n+                      Make_Index_Or_Discriminant_Constraint (Loc,\n+                        Constraints => New_List (\n+                          Make_Integer_Literal (Loc, Nb_Prim))))));\n+\n+            --  This table is initialized by Make_Select_Specific_Data_Table,\n+            --  which calls Set_Entry_Index and Set_Prim_Op_Kind.\n+\n+            Append_To (TSD_Aggr_List,\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (SSD, Loc),\n+                Attribute_Name => Name_Unchecked_Access));\n+         else\n+            Append_To (TSD_Aggr_List, Make_Null (Loc));\n+         end if;\n+      end if;\n+\n       --  Initialize the table of ancestor tags. In case of interface types\n       --  this table is not needed.\n \n@@ -6510,6 +6630,21 @@ package body Exp_Disp is\n               Prefix => New_Reference_To (TSD, Loc),\n               Attribute_Name => Name_Unrestricted_Access))));\n \n+      --  Populate the two auxiliary tables used for dispatching asynchronous,\n+      --  conditional and timed selects for synchronized types that implement\n+      --  a limited interface. Skip this step in Ravenscar profile or when\n+      --  general dispatching is forbidden.\n+\n+      if Ada_Version >= Ada_2005\n+        and then Is_Concurrent_Record_Type (Typ)\n+        and then Has_Interfaces (Typ)\n+        and then not Restriction_Active (No_Dispatching_Calls)\n+        and then not Restriction_Active (No_Select_Statements)\n+      then\n+         Append_List_To (Result,\n+           Make_Select_Specific_Data_Table (Typ));\n+      end if;\n+\n       return Result;\n    end Make_VM_TSD;\n \n@@ -6525,7 +6660,6 @@ package body Exp_Disp is\n \n       Conc_Typ  : Entity_Id;\n       Decls     : List_Id;\n-      DT_Ptr    : Entity_Id;\n       Prim      : Entity_Id;\n       Prim_Als  : Entity_Id;\n       Prim_Elmt : Elmt_Id;\n@@ -6567,13 +6701,15 @@ package body Exp_Disp is\n          return Uint_0;\n       end Find_Entry_Index;\n \n+      --  Local variables\n+\n+      Tag_Node : Node_Id;\n+\n    --  Start of processing for Make_Select_Specific_Data_Table\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n \n-      DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n-\n       if Present (Corresponding_Concurrent_Type (Typ)) then\n          Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n@@ -6631,11 +6767,23 @@ package body Exp_Disp is\n                --  type. Generate:\n                --    Ada.Tags.Set_Prim_Op_Kind (DT_Ptr, <position>, <kind>);\n \n+               if Tagged_Type_Expansion then\n+                  Tag_Node :=\n+                    New_Reference_To\n+                     (Node (First_Elmt (Access_Disp_Table (Typ))), Loc);\n+\n+               else\n+                  Tag_Node :=\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix => New_Reference_To (Typ, Loc),\n+                      Attribute_Name => Name_Tag);\n+               end if;\n+\n                Append_To (Assignments,\n                  Make_Procedure_Call_Statement (Loc,\n                    Name => New_Reference_To (RTE (RE_Set_Prim_Op_Kind), Loc),\n                    Parameter_Associations => New_List (\n-                     New_Reference_To (DT_Ptr, Loc),\n+                     Tag_Node,\n                      Make_Integer_Literal (Loc, Prim_Pos),\n                      Prim_Op_Kind (Alias (Prim), Typ))));\n \n@@ -6653,12 +6801,23 @@ package body Exp_Disp is\n                   --    Ada.Tags.Set_Entry_Index\n                   --      (DT_Ptr, <position>, <index>);\n \n+                  if Tagged_Type_Expansion then\n+                     Tag_Node :=\n+                       New_Reference_To\n+                        (Node (First_Elmt (Access_Disp_Table (Typ))), Loc);\n+                  else\n+                     Tag_Node :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Reference_To (Typ, Loc),\n+                         Attribute_Name => Name_Tag);\n+                  end if;\n+\n                   Append_To (Assignments,\n                     Make_Procedure_Call_Statement (Loc,\n                       Name =>\n                         New_Reference_To (RTE (RE_Set_Entry_Index), Loc),\n                       Parameter_Associations => New_List (\n-                        New_Reference_To (DT_Ptr, Loc),\n+                        Tag_Node,\n                         Make_Integer_Literal (Loc, Prim_Pos),\n                         Make_Integer_Literal (Loc,\n                           Find_Entry_Index (Wrapped_Entity (Prim_Als))))));"}, {"sha": "074c6587854093d27d6381161b21a5811b75bb9e", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                             G E T _ S C O S                               --\n+--                             G E T _ S C O S                              --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--           Copyright (C) 2009-2011, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "f440b2238cfc03a6d620556f1e3486da48b9e341", "filename": "gcc/ada/get_scos.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fget_scos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fget_scos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.ads?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                             G E T _ S C O S                               --\n+--                             G E T _ S C O S                              --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--           Copyright (C) 2009-2011, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,7 +32,7 @@ generic\n \n    with function Getc return Character is <>;\n    --  Get next character, positioning the ALI file ready to read the following\n-   --  character (equivalent to calling Skipc, then Nextc). If the end of file\n+   --  character (equivalent to calling Nextc, then Skipc). If the end of file\n    --  is encountered, the value Types.EOF is returned.\n \n    with function Nextc return Character is <>;\n@@ -54,5 +54,5 @@ procedure Get_SCOs;\n --  first character of the line following the SCO information (which will\n --  never start with a 'C').\n --\n---  If a format error is detected in the input, then an exceptions is raised\n+--  If a format error is detected in the input, then an exception is raised\n --  (Ada.IO_Exceptions.Data_Error), with the file positioned to the error."}, {"sha": "ecabb393f7f1588aa828e25c4080c2ebf96c9d57", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1301,6 +1301,13 @@ package body Lib.Writ is\n          SCO_Output;\n       end if;\n \n+      --  Output references by subprogram\n+\n+      if ALFA_Mode then\n+         Write_Info_EOL;\n+         Output_Local_References;\n+      end if;\n+\n       --  Output final blank line and we are done. This final blank line is\n       --  probably junk, but we don't feel like making an incompatible change!\n "}, {"sha": "d44f1b8eccf0409ce6401bfecafb5a29ef0c6ac9", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 612, "deletions": 48, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,6 +62,9 @@ package body Lib.Xref is\n       Ent : Entity_Id;\n       --  Entity referenced (E parameter to Generate_Reference)\n \n+      Sub : Entity_Id;\n+      --  Entity of the closest enclosing subprogram or package\n+\n       Def : Source_Ptr;\n       --  Original source location for entity being referenced. Note that these\n       --  values are used only during the output process, they are not set when\n@@ -73,12 +76,18 @@ package body Lib.Xref is\n       --  to Generate_Reference). Set to No_Location for the case of a\n       --  defining occurrence.\n \n+      Slc : Source_Ptr;\n+      --  Original source location for entity Sub\n+\n       Typ : Character;\n       --  Reference type (Typ param to Generate_Reference)\n \n       Eun : Unit_Number_Type;\n       --  Unit number corresponding to Ent\n \n+      Sun : Unit_Number_Type;\n+      --  Unit number corresponding to Sub\n+\n       Lun : Unit_Number_Type;\n       --  Unit number corresponding to Loc. Value is undefined and not\n       --  referenced if Loc is set to No_Location.\n@@ -97,12 +106,71 @@ package body Lib.Xref is\n    --  Local Subprograms --\n    ------------------------\n \n+   function Enclosing_Subprogram_Or_Package (N : Node_Id) return Entity_Id;\n+   --  Return the closest enclosing subprogram of package\n+\n+   function Is_Local_Reference_Type (Typ : Character) return Boolean;\n+   --  Return whether Typ is a suitable reference type for a local reference\n+\n    procedure Generate_Prim_Op_References (Typ : Entity_Id);\n    --  For a tagged type, generate implicit references to its primitive\n    --  operations, for source navigation. This is done right before emitting\n    --  cross-reference information rather than at the freeze point of the type\n    --  in order to handle late bodies that are primitive operations.\n \n+   function Lt (T1, T2 : Xref_Entry) return Boolean;\n+   --  Order cross-references\n+\n+   procedure Write_Entity_Name (E : Entity_Id; Cursrc : Source_Buffer_Ptr);\n+   --  Output entity name for E. We use the occurrence from the actual\n+   --  source program at the definition point.\n+\n+   -------------------------------------\n+   -- Enclosing_Subprogram_Or_Package --\n+   -------------------------------------\n+\n+   function Enclosing_Subprogram_Or_Package (N : Node_Id) return Entity_Id\n+   is\n+      Result : Entity_Id;\n+\n+   begin\n+      Result := N;\n+      loop\n+         exit when No (Result);\n+\n+         case Nkind (Result) is\n+            when N_Package_Specification =>\n+               Result := Defining_Unit_Name (Result);\n+               exit;\n+\n+            when N_Package_Body =>\n+               Result := Corresponding_Spec (Result);\n+               exit;\n+\n+            when N_Subprogram_Specification =>\n+               Result := Defining_Unit_Name (Result);\n+               exit;\n+\n+            when N_Subprogram_Declaration =>\n+               Result := Defining_Unit_Name (Specification (Result));\n+               exit;\n+\n+            when N_Subprogram_Body =>\n+               Result := Defining_Unit_Name (Specification (Result));\n+               exit;\n+\n+            when others =>\n+               Result := Parent (Result);\n+         end case;\n+      end loop;\n+\n+      if Nkind (Result) = N_Defining_Program_Unit_Name then\n+         Result := Defining_Identifier (Result);\n+      end if;\n+\n+      return Result;\n+   end Enclosing_Subprogram_Or_Package;\n+\n    -------------------------\n    -- Generate_Definition --\n    -------------------------\n@@ -146,11 +214,39 @@ package body Lib.Xref is\n          Loc  := Original_Location (Sloc (E));\n \n          Xrefs.Table (Indx).Ent := E;\n-         Xrefs.Table (Indx).Def := No_Location;\n-         Xrefs.Table (Indx).Loc := No_Location;\n-         Xrefs.Table (Indx).Typ := ' ';\n+\n+         if ALFA_Mode\n+           and then Nkind_In (Parent (E),\n+                              N_Object_Declaration,\n+                              N_Parameter_Specification)\n+         then\n+            --  In ALFA mode, define precise 'D' references for object\n+            --  definition.\n+\n+            declare\n+               Sub : constant Entity_Id := Enclosing_Subprogram_Or_Package (E);\n+               Slc : constant Source_Ptr := Original_Location (Sloc (Sub));\n+               Sun : constant Unit_Number_Type := Get_Source_Unit (Slc);\n+            begin\n+               Xrefs.Table (Indx).Typ := 'D';\n+               Xrefs.Table (Indx).Sub := Sub;\n+               Xrefs.Table (Indx).Def := Loc;\n+               Xrefs.Table (Indx).Loc := Loc;\n+               Xrefs.Table (Indx).Slc := Slc;\n+               Xrefs.Table (Indx).Lun := Get_Source_Unit (Loc);\n+               Xrefs.Table (Indx).Sun := Sun;\n+            end;\n+         else\n+            Xrefs.Table (Indx).Typ := ' ';\n+            Xrefs.Table (Indx).Sub := Empty;\n+            Xrefs.Table (Indx).Def := No_Location;\n+            Xrefs.Table (Indx).Loc := No_Location;\n+            Xrefs.Table (Indx).Slc := No_Location;\n+            Xrefs.Table (Indx).Lun := No_Unit;\n+            Xrefs.Table (Indx).Sun := No_Unit;\n+         end if;\n+\n          Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n-         Xrefs.Table (Indx).Lun := No_Unit;\n          Set_Has_Xref_Entry (E);\n \n          if In_Inlined_Body then\n@@ -275,7 +371,9 @@ package body Lib.Xref is\n       Nod  : Node_Id;\n       Ref  : Source_Ptr;\n       Def  : Source_Ptr;\n+      Slc  : Source_Ptr;\n       Ent  : Entity_Id;\n+      Sub  : Entity_Id;\n \n       Call   : Node_Id;\n       Formal : Entity_Id;\n@@ -495,6 +593,7 @@ package body Lib.Xref is\n \n       if not In_Extended_Main_Source_Unit (N) then\n          if Typ = 'e'\n+           or else Typ = 'I'\n            or else Typ = 'p'\n            or else Typ = 'i'\n            or else Typ = 'k'\n@@ -835,13 +934,17 @@ package body Lib.Xref is\n \n          --  Record reference to entity\n \n+         Sub := Enclosing_Subprogram_Or_Package (N);\n+\n          Ref := Original_Location (Sloc (Nod));\n          Def := Original_Location (Sloc (Ent));\n+         Slc := Original_Location (Sloc (Sub));\n \n          Xrefs.Increment_Last;\n          Indx := Xrefs.Last;\n \n          Xrefs.Table (Indx).Loc := Ref;\n+         Xrefs.Table (Indx).Slc := Slc;\n \n          --  Overriding operations are marked with 'P'\n \n@@ -856,7 +959,9 @@ package body Lib.Xref is\n \n          Xrefs.Table (Indx).Eun := Get_Source_Unit (Def);\n          Xrefs.Table (Indx).Lun := Get_Source_Unit (Ref);\n+         Xrefs.Table (Indx).Sun := Get_Source_Unit (Slc);\n          Xrefs.Table (Indx).Ent := Ent;\n+         Xrefs.Table (Indx).Sub := Sub;\n          Set_Has_Xref_Entry (Ent);\n       end if;\n    end Generate_Reference;\n@@ -931,6 +1036,62 @@ package body Lib.Xref is\n       Xrefs.Init;\n    end Initialize;\n \n+   -----------------------------\n+   -- Is_Local_Reference_Type --\n+   -----------------------------\n+\n+   function Is_Local_Reference_Type (Typ : Character) return Boolean is\n+   begin\n+      return Typ = 'r' or else Typ = 'm' or else Typ = 's'\n+        or else Typ = 'I' or else Typ = 'D';\n+   end Is_Local_Reference_Type;\n+\n+   --------\n+   -- Lt --\n+   --------\n+\n+   function Lt (T1, T2 : Xref_Entry) return Boolean is\n+   begin\n+      --  First test: if entity is in different unit, sort by unit\n+\n+      if T1.Eun /= T2.Eun then\n+         return Dependency_Num (T1.Eun) < Dependency_Num (T2.Eun);\n+\n+      --  Second test: within same unit, sort by entity Sloc\n+\n+      elsif T1.Def /= T2.Def then\n+         return T1.Def < T2.Def;\n+\n+      --  Third test: sort definitions ahead of references\n+\n+      elsif T1.Loc = No_Location then\n+         return True;\n+\n+      elsif T2.Loc = No_Location then\n+         return False;\n+\n+      --  Fourth test: for same entity, sort by reference location unit\n+\n+      elsif T1.Lun /= T2.Lun then\n+         return Dependency_Num (T1.Lun) < Dependency_Num (T2.Lun);\n+\n+      --  Fifth test: order of location within referencing unit\n+\n+      elsif T1.Loc /= T2.Loc then\n+         return T1.Loc < T2.Loc;\n+\n+      --  Finally, for two locations at the same address, we prefer\n+      --  the one that does NOT have the type 'r' so that a modification\n+      --  or extension takes preference, when there are more than one\n+      --  reference at the same location. As a result, in the case of\n+      --  entities that are in-out actuals, the read reference follows\n+      --  the modify reference.\n+\n+      else\n+         return T2.Typ = 'r';\n+      end if;\n+   end Lt;\n+\n    -----------------------\n    -- Output_References --\n    -----------------------\n@@ -1409,44 +1570,7 @@ package body Lib.Xref is\n             T2 : Xref_Entry renames Xrefs.Table (Rnums (Nat (Op2)));\n \n          begin\n-            --  First test: if entity is in different unit, sort by unit\n-\n-            if T1.Eun /= T2.Eun then\n-               return Dependency_Num (T1.Eun) < Dependency_Num (T2.Eun);\n-\n-            --  Second test: within same unit, sort by entity Sloc\n-\n-            elsif T1.Def /= T2.Def then\n-               return T1.Def < T2.Def;\n-\n-            --  Third test: sort definitions ahead of references\n-\n-            elsif T1.Loc = No_Location then\n-               return True;\n-\n-            elsif T2.Loc = No_Location then\n-               return False;\n-\n-            --  Fourth test: for same entity, sort by reference location unit\n-\n-            elsif T1.Lun /= T2.Lun then\n-               return Dependency_Num (T1.Lun) < Dependency_Num (T2.Lun);\n-\n-            --  Fifth test: order of location within referencing unit\n-\n-            elsif T1.Loc /= T2.Loc then\n-               return T1.Loc < T2.Loc;\n-\n-            --  Finally, for two locations at the same address, we prefer\n-            --  the one that does NOT have the type 'r' so that a modification\n-            --  or extension takes preference, when there are more than one\n-            --  reference at the same location. As a result, in the case of\n-            --  entities that are in-out actuals, the read reference follows\n-            --  the modify reference.\n-\n-            else\n-               return T2.Typ = 'r';\n-            end if;\n+            return Lt (T1, T2);\n          end Lt;\n \n          ----------\n@@ -1852,17 +1976,28 @@ package body Lib.Xref is\n                   end if;\n                end if;\n \n-               --  Only output reference if interesting type of entity, and\n-               --  suppress self references, except for bodies that act as\n-               --  specs. Also suppress definitions of body formals (we only\n-               --  treat these as references, and the references were\n-               --  separately recorded).\n+               --  Only output reference if interesting type of entity\n \n                if Ctyp = ' '\n+\n+               --  Suppress references to object definitions, used for local\n+               --  references.\n+\n+                 or else XE.Typ = 'D'\n+                 or else XE.Typ = 'I'\n+\n+               --  Suppress self references, except for bodies that act as\n+               --  specs.\n+\n                  or else (XE.Loc = XE.Def\n                             and then\n                               (XE.Typ /= 'b'\n                                 or else not Is_Subprogram (XE.Ent)))\n+\n+               --  Also suppress definitions of body formals (we only\n+               --  treat these as references, and the references were\n+               --  separately recorded).\n+\n                  or else (Is_Formal (XE.Ent)\n                             and then Present (Spec_Entity (XE.Ent)))\n                then\n@@ -2253,4 +2388,433 @@ package body Lib.Xref is\n       end Output_Refs;\n    end Output_References;\n \n+   -----------------------------\n+   -- Output_Local_References --\n+   -----------------------------\n+\n+   procedure Output_Local_References is\n+\n+      Nrefs : Nat := Xrefs.Last;\n+      --  Number of references in table. This value may get reset (reduced)\n+      --  when we eliminate duplicate reference entries as well as references\n+      --  not suitable for local cross-references.\n+\n+      Rnums : array (0 .. Nrefs) of Nat;\n+      --  This array contains numbers of references in the Xrefs table.\n+      --  This list is sorted in output order. The extra 0'th entry is\n+      --  convenient for the call to sort. When we sort the table, we\n+      --  move the entries in Rnums around, but we do not move the\n+      --  original table entries.\n+\n+      Curxu : Unit_Number_Type;\n+      --  Current xref unit\n+\n+      Curru : Unit_Number_Type;\n+      --  Current reference unit for one entity\n+\n+      Cursu : Unit_Number_Type;\n+      --  Current reference unit for one enclosing subprogram\n+\n+      Cursrc : Source_Buffer_Ptr;\n+      --  Current xref unit source text\n+\n+      Cursub : Entity_Id;\n+      --  Current enclosing subprogram\n+\n+      Curent : Entity_Id;\n+      --  Current entity\n+\n+      Curnam : String (1 .. Name_Buffer'Length);\n+      Curlen : Natural;\n+      --  Simple name and length of current entity\n+\n+      Curdef : Source_Ptr;\n+      --  Original source location for current entity\n+\n+      Crloc : Source_Ptr;\n+      --  Current reference location\n+\n+      Ctyp  : Character;\n+      --  Entity type character\n+\n+      Prevt : Character;\n+      --  Reference kind of previous reference\n+\n+      function Lt (Op1, Op2 : Natural) return Boolean;\n+      --  Comparison function for Sort call\n+\n+      function Name_Change (X : Entity_Id) return Boolean;\n+      --  Determines if entity X has a different simple name from Curent\n+\n+      procedure Move (From : Natural; To : Natural);\n+      --  Move procedure for Sort call\n+\n+      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n+\n+      --------\n+      -- Lt --\n+      --------\n+\n+      function Lt (Op1, Op2 : Natural) return Boolean is\n+         T1 : Xref_Entry renames Xrefs.Table (Rnums (Nat (Op1)));\n+         T2 : Xref_Entry renames Xrefs.Table (Rnums (Nat (Op2)));\n+\n+      begin\n+         if T1.Slc = No_Location then\n+            return True;\n+\n+         elsif T2.Slc = No_Location then\n+            return False;\n+\n+         elsif T1.Sun /= T2.Sun then\n+            return Dependency_Num (T1.Sun) < Dependency_Num (T2.Sun);\n+\n+         elsif T1.Slc /= T2.Slc then\n+            return T1.Slc < T2.Slc;\n+\n+         else\n+            return Lt (T1, T2);\n+         end if;\n+      end Lt;\n+\n+      ----------\n+      -- Move --\n+      ----------\n+\n+      procedure Move (From : Natural; To : Natural) is\n+      begin\n+         Rnums (Nat (To)) := Rnums (Nat (From));\n+      end Move;\n+\n+      -----------------\n+      -- Name_Change --\n+      -----------------\n+\n+      --  Why a string comparison here??? Why not compare Name_Id values???\n+\n+      function Name_Change (X : Entity_Id) return Boolean is\n+      begin\n+         Get_Unqualified_Name_String (Chars (X));\n+\n+         if Name_Len /= Curlen then\n+            return True;\n+         else\n+            return Name_Buffer (1 .. Curlen) /= Curnam (1 .. Curlen);\n+         end if;\n+      end Name_Change;\n+\n+      --  Start of processing for Output_Subprogram_References\n+   begin\n+\n+      --  Replace enclosing subprogram pointer by corresponding specification\n+      --  when appropriate. This could not be done before as the information\n+      --  was not always available when registering references.\n+\n+      for J in 1 .. Xrefs.Last loop\n+         if Present (Xrefs.Table (J).Sub) then\n+            declare\n+               N   : constant Node_Id :=\n+                       Parent (Parent (Xrefs.Table (J).Sub));\n+               Sub : Entity_Id;\n+               Slc : Source_Ptr;\n+               Sun : Unit_Number_Type;\n+            begin\n+               if Nkind (N) = N_Subprogram_Body\n+                 and then not Acts_As_Spec (N)\n+               then\n+                  Sub := Corresponding_Spec (N);\n+\n+                  if Nkind (Sub) = N_Defining_Program_Unit_Name then\n+                     Sub := Defining_Identifier (Sub);\n+                  end if;\n+\n+                  Slc := Original_Location (Sloc (Sub));\n+                  Sun := Get_Source_Unit (Slc);\n+\n+                  Xrefs.Table (J).Sub := Sub;\n+                  Xrefs.Table (J).Slc := Slc;\n+                  Xrefs.Table (J).Sun := Sun;\n+               end if;\n+            end;\n+         end if;\n+      end loop;\n+\n+      --  Set up the pointer vector for the sort\n+\n+      for J in 1 .. Nrefs loop\n+         Rnums (J) := J;\n+      end loop;\n+\n+      --  Sort the references\n+\n+      Sorting.Sort (Integer (Nrefs));\n+\n+      declare\n+         NR : Nat;\n+\n+      begin\n+         --  Eliminate duplicate entries\n+\n+         --  We need this test for NR because if we force ALI file\n+         --  generation in case of errors detected, it may be the case\n+         --  that Nrefs is 0, so we should not reset it here\n+\n+         if Nrefs >= 2 then\n+            NR    := Nrefs;\n+            Nrefs := 1;\n+\n+            for J in 2 .. NR loop\n+               if Xrefs.Table (Rnums (J)) /= Xrefs.Table (Rnums (Nrefs)) then\n+                  Nrefs         := Nrefs + 1;\n+                  Rnums (Nrefs) := Rnums (J);\n+               end if;\n+            end loop;\n+         end if;\n+\n+         --  Eliminate entries not appropriate for local references\n+\n+         NR    := Nrefs;\n+         Nrefs := 0;\n+\n+         for J in 1 .. NR loop\n+            if Lref_Entity_Status (Ekind (Xrefs.Table (Rnums (J)).Ent))\n+              and then Is_Local_Reference_Type (Xrefs.Table (Rnums (J)).Typ)\n+            then\n+               Nrefs         := Nrefs + 1;\n+               Rnums (Nrefs) := Rnums (J);\n+            end if;\n+         end loop;\n+      end;\n+\n+      --  Initialize loop through references\n+\n+      Curxu  := No_Unit;\n+      Cursub := Empty;\n+      Curent := Empty;\n+      Curdef := No_Location;\n+      Curru  := No_Unit;\n+      Cursu  := No_Unit;\n+      Crloc  := No_Location;\n+      Prevt  := 'm';\n+\n+      --  Loop to output references\n+\n+      for Refno in 1 .. Nrefs loop\n+         Output_One_Ref : declare\n+            Ent : Entity_Id;\n+            XE  : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n+            --  The current entry to be accessed\n+\n+         begin\n+            Ent  := XE.Ent;\n+            Ctyp := Xref_Entity_Letters (Ekind (Ent));\n+\n+            --  Start new Unit section if subprogram in new unit\n+\n+            if XE.Sun /= Cursu then\n+               if Write_Info_Col > 1 then\n+                  Write_Info_EOL;\n+               end if;\n+\n+               Cursu := XE.Sun;\n+\n+               Write_Info_Initiate ('F');\n+               Write_Info_Char (' ');\n+               Write_Info_Nat (Dependency_Num (XE.Sun));\n+               Write_Info_Char (' ');\n+               Write_Info_Name (Reference_Name (Source_Index (XE.Sun)));\n+               Write_Info_EOL;\n+            end if;\n+\n+            --  Start new Subprogram section if new subprogram\n+\n+            if XE.Sub /= Cursub then\n+               if Write_Info_Col > 1 then\n+                  Write_Info_EOL;\n+               end if;\n+\n+               Cursub := XE.Sub;\n+               Cursrc := Source_Text (Source_Index (Cursu));\n+\n+               Write_Info_Initiate ('S');\n+               Write_Info_Char (' ');\n+               Write_Info_Nat (Int (Get_Logical_Line_Number (XE.Slc)));\n+               Write_Info_Char (Xref_Entity_Letters (Ekind (XE.Sub)));\n+               Write_Info_Nat (Int (Get_Column_Number (XE.Slc)));\n+               Write_Info_Char (' ');\n+               Write_Entity_Name (XE.Sub, Cursrc);\n+\n+               --  Indicate that the entity is in the unit of the current\n+               --  local xref section.\n+\n+               Curru := Cursu;\n+\n+               --  End of processing for subprogram output\n+\n+               Curxu  := No_Unit;\n+               Curent := Empty;\n+            end if;\n+\n+            --  Start new Xref section if new xref unit\n+\n+            if XE.Eun /= Curxu then\n+               if Write_Info_Col > 1 then\n+                  Write_Info_EOL;\n+               end if;\n+\n+               Curxu  := XE.Eun;\n+               Cursrc := Source_Text (Source_Index (Curxu));\n+\n+               Write_Info_Initiate ('X');\n+               Write_Info_Char (' ');\n+               Write_Info_Nat (Dependency_Num (XE.Eun));\n+               Write_Info_Char (' ');\n+               Write_Info_Name (Reference_Name (Source_Index (XE.Eun)));\n+\n+               --  End of processing for Xref section output\n+\n+               Curru := Cursu;\n+            end if;\n+\n+            --  Start new Entity line if new entity. Note that we\n+            --  consider two entities the same if they have the same\n+            --  name and source location. This causes entities in\n+            --  instantiations to be treated as though they referred\n+            --  to the template.\n+\n+            if No (Curent)\n+              or else\n+                (XE.Ent /= Curent\n+                 and then\n+                   (Name_Change (XE.Ent) or else XE.Def /= Curdef))\n+            then\n+               Curent := XE.Ent;\n+               Curdef := XE.Def;\n+\n+               Get_Unqualified_Name_String (Chars (XE.Ent));\n+               Curlen := Name_Len;\n+               Curnam (1 .. Curlen) := Name_Buffer (1 .. Curlen);\n+\n+               if Write_Info_Col > 1 then\n+                  Write_Info_EOL;\n+               end if;\n+\n+               --  Write line and column number information\n+\n+               Write_Info_Nat  (Int (Get_Logical_Line_Number (XE.Def)));\n+               Write_Info_Char (Ctyp);\n+               Write_Info_Nat  (Int (Get_Column_Number (XE.Def)));\n+               Write_Info_Char (' ');\n+\n+               --  Output entity name\n+\n+               Write_Entity_Name (XE.Ent, Cursrc);\n+\n+               --  End of processing for entity output\n+\n+               Crloc := No_Location;\n+            end if;\n+\n+            --  Output the reference if it is not as the same location\n+            --  as the previous one, or it is a read-reference that\n+            --  indicates that the entity is an in-out actual in a call.\n+\n+            if XE.Loc /= No_Location\n+              and then\n+                (XE.Loc /= Crloc\n+                 or else (Prevt = 'm' and then XE.Typ = 'r'))\n+            then\n+               Crloc := XE.Loc;\n+               Prevt := XE.Typ;\n+\n+               --  Start continuation if line full, else blank\n+\n+               if Write_Info_Col > 72 then\n+                  Write_Info_EOL;\n+                  Write_Info_Initiate ('.');\n+               end if;\n+\n+               Write_Info_Char (' ');\n+\n+               --  Output file number if changed\n+\n+               if XE.Lun /= Curru then\n+                  Curru := XE.Lun;\n+                  Write_Info_Nat (Dependency_Num (Curru));\n+                  Write_Info_Char ('|');\n+               end if;\n+\n+               --  Write line and column number information\n+\n+               Write_Info_Nat  (Int (Get_Logical_Line_Number (XE.Loc)));\n+               Write_Info_Char (XE.Typ);\n+               Write_Info_Nat  (Int (Get_Column_Number (XE.Loc)));\n+            end if;\n+         end Output_One_Ref;\n+      end loop;\n+\n+      Write_Info_EOL;\n+   end Output_Local_References;\n+\n+   -----------------------\n+   -- Write_Entity_Name --\n+   -----------------------\n+\n+   procedure Write_Entity_Name (E : Entity_Id; Cursrc : Source_Buffer_Ptr) is\n+      P, P2 : Source_Ptr;\n+      --  Used to index into source buffer to get entity name\n+\n+      WC    : Char_Code;\n+      Err   : Boolean;\n+      pragma Warnings (Off, WC);\n+      pragma Warnings (Off, Err);\n+\n+   begin\n+      P := Original_Location (Sloc (E));\n+\n+      --  Entity is character literal\n+\n+      if Cursrc (P) = ''' then\n+         Write_Info_Char (Cursrc (P));\n+         Write_Info_Char (Cursrc (P + 1));\n+         Write_Info_Char (Cursrc (P + 2));\n+\n+         --  Entity is operator symbol\n+\n+      elsif Cursrc (P) = '\"' or else Cursrc (P) = '%' then\n+         Write_Info_Char (Cursrc (P));\n+\n+         P2 := P;\n+         loop\n+            P2 := P2 + 1;\n+            Write_Info_Char (Cursrc (P2));\n+            exit when Cursrc (P2) = Cursrc (P);\n+         end loop;\n+\n+         --  Entity is identifier\n+\n+      else\n+         loop\n+            if Is_Start_Of_Wide_Char (Cursrc, P) then\n+               Scan_Wide (Cursrc, P, WC, Err);\n+            elsif not Identifier_Char (Cursrc (P)) then\n+               exit;\n+            else\n+               P := P + 1;\n+            end if;\n+         end loop;\n+\n+         --  Write out the identifier by copying the exact\n+         --  source characters used in its declaration. Note\n+         --  that this means wide characters will be in their\n+         --  original encoded form.\n+\n+         for J in\n+           Original_Location (Sloc (E)) .. P - 1\n+         loop\n+            Write_Info_Char (Cursrc (J));\n+         end loop;\n+      end if;\n+   end Write_Entity_Name;\n+\n end Lib.Xref;"}, {"sha": "1d0749cfe83553f45075d6cf9c74c9fb893c70fd", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 139, "deletions": 15, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1998-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,15 +44,15 @@ package Lib.Xref is\n    --        This header precedes xref information (entities/references from\n    --        the unit), identified by dependency number and file name. The\n    --        dependency number is the index into the generated D lines and\n-   --        is ones origin (i.e. 2 = reference to second generated D line).\n+   --        its origin is one (i.e. 2 = reference to second generated D line).\n \n    --        Note that the filename here will reflect the original name if\n    --        a Source_Reference pragma was encountered (since all line number\n    --        references will be with respect to the original file).\n \n    --  The lines following the header look like\n \n-   --  line type col level entity renameref instref typeref overref ref  ref\n+   --  line type col level entity renameref instref typeref overref ref ref\n \n    --        line is the line number of the referenced entity. The name of\n    --        the entity starts in column col. Columns are numbered from one,\n@@ -69,7 +69,7 @@ package Lib.Xref is\n \n    --        level is a single character that separates the col and\n    --        entity fields. It is an asterisk (*) for a top level library\n-   --        entity that is publicly visible, as well for an entity declared\n+   --        entity that is publicly visible, as well as for an entity declared\n    --        in the visible part of a generic package, the plus sign (+) for\n    --        a C/C++ static entity, and space otherwise.\n \n@@ -172,9 +172,11 @@ package Lib.Xref is\n    --              b = body entity\n    --              c = completion of private or incomplete type\n    --              d = discriminant of type\n+   --              D = object definition\n    --              e = end of spec\n    --              H = abstract type\n    --              i = implicit reference\n+   --              I = object definition with initialization\n    --              k = implicit reference to parent unit in child unit\n    --              l = label on END line\n    --              m = modification\n@@ -567,6 +569,134 @@ package Lib.Xref is\n    --    y     abstract function               entry or entry family\n    --    z     generic formal parameter        (unused)\n \n+   -------------------------------------------------------------\n+   -- Format of Local Cross-Reference Information in ALI File --\n+   -------------------------------------------------------------\n+\n+   --  Local cross-reference sections follow the cross-reference section in an\n+   --  ALI file, so that they need not be read by gnatbind, gnatmake etc.\n+\n+   --  A local cross-reference section has a header of the form\n+\n+   --     S line type col entity\n+\n+   --        These precisely define a subprogram or package, with the same\n+   --        components as described for cross-reference sections.\n+\n+   --  These sections are grouped in chapters for each unit introduced by\n+\n+   --     F dependency-number filename\n+\n+   --  Each section groups a number of cross-reference sub-sections introduced\n+   --  by\n+\n+   --     X dependency-number filename\n+\n+   --  Inside each cross-reference sub-section, there are a number of\n+   --  references like\n+\n+   --     line type col entity ref ref ...\n+\n+   -----------------------------------\n+   -- Local-Reference Entity Filter --\n+   -----------------------------------\n+\n+   Lref_Entity_Status : array (Entity_Kind) of Boolean :=\n+     (E_Void                                       => False,\n+      E_Variable                                   => True,\n+      E_Component                                  => False,\n+      E_Constant                                   => True,\n+      E_Discriminant                               => False,\n+\n+      E_Loop_Parameter                             => True,\n+      E_In_Parameter                               => True,\n+      E_Out_Parameter                              => True,\n+      E_In_Out_Parameter                           => True,\n+      E_Generic_In_Out_Parameter                   => False,\n+\n+      E_Generic_In_Parameter                       => False,\n+      E_Named_Integer                              => False,\n+      E_Named_Real                                 => False,\n+      E_Enumeration_Type                           => False,\n+      E_Enumeration_Subtype                        => False,\n+\n+      E_Signed_Integer_Type                        => False,\n+      E_Signed_Integer_Subtype                     => False,\n+      E_Modular_Integer_Type                       => False,\n+      E_Modular_Integer_Subtype                    => False,\n+      E_Ordinary_Fixed_Point_Type                  => False,\n+\n+      E_Ordinary_Fixed_Point_Subtype               => False,\n+      E_Decimal_Fixed_Point_Type                   => False,\n+      E_Decimal_Fixed_Point_Subtype                => False,\n+      E_Floating_Point_Type                        => False,\n+      E_Floating_Point_Subtype                     => False,\n+\n+      E_Access_Type                                => False,\n+      E_Access_Subtype                             => False,\n+      E_Access_Attribute_Type                      => False,\n+      E_Allocator_Type                             => False,\n+      E_General_Access_Type                        => False,\n+\n+      E_Access_Subprogram_Type                     => False,\n+      E_Access_Protected_Subprogram_Type           => False,\n+      E_Anonymous_Access_Subprogram_Type           => False,\n+      E_Anonymous_Access_Protected_Subprogram_Type => False,\n+      E_Anonymous_Access_Type                      => False,\n+\n+      E_Array_Type                                 => False,\n+      E_Array_Subtype                              => False,\n+      E_String_Type                                => False,\n+      E_String_Subtype                             => False,\n+      E_String_Literal_Subtype                     => False,\n+\n+      E_Class_Wide_Type                            => False,\n+      E_Class_Wide_Subtype                         => False,\n+      E_Record_Type                                => False,\n+      E_Record_Subtype                             => False,\n+      E_Record_Type_With_Private                   => False,\n+\n+      E_Record_Subtype_With_Private                => False,\n+      E_Private_Type                               => False,\n+      E_Private_Subtype                            => False,\n+      E_Limited_Private_Type                       => False,\n+      E_Limited_Private_Subtype                    => False,\n+\n+      E_Incomplete_Type                            => False,\n+      E_Incomplete_Subtype                         => False,\n+      E_Task_Type                                  => False,\n+      E_Task_Subtype                               => False,\n+      E_Protected_Type                             => False,\n+\n+      E_Protected_Subtype                          => False,\n+      E_Exception_Type                             => False,\n+      E_Subprogram_Type                            => False,\n+      E_Enumeration_Literal                        => False,\n+      E_Function                                   => True,\n+\n+      E_Operator                                   => True,\n+      E_Procedure                                  => True,\n+      E_Entry                                      => False,\n+      E_Entry_Family                               => False,\n+      E_Block                                      => False,\n+\n+      E_Entry_Index_Parameter                      => False,\n+      E_Exception                                  => False,\n+      E_Generic_Function                           => False,\n+      E_Generic_Package                            => False,\n+      E_Generic_Procedure                          => False,\n+\n+      E_Label                                      => False,\n+      E_Loop                                       => False,\n+      E_Return_Statement                           => False,\n+      E_Package                                    => False,\n+\n+      E_Package_Body                               => False,\n+      E_Protected_Object                           => False,\n+      E_Protected_Body                             => False,\n+      E_Task_Body                                  => False,\n+      E_Subprogram_Body                            => False);\n+\n    --------------------------------------\n    -- Handling of Imported Subprograms --\n    --------------------------------------\n@@ -611,17 +741,8 @@ package Lib.Xref is\n    --  This procedure is called to record a reference. N is the location\n    --  of the reference and E is the referenced entity. Typ is one of:\n    --\n-   --    'b'  body entity\n-   --    'c'  completion of incomplete or private type (see below)\n-   --    'e'  end of construct\n-   --    'i'  implicit reference\n-   --    'l'  label on end line\n-   --    'm'  modification\n-   --    'p'  primitive operation\n-   --    'r'  standard reference\n-   --    't'  end of body\n-   --    'x'  type extension\n-   --    ' '  dummy reference (see below)\n+   --    a character already described in the description of ref entries above\n+   --    ' ' for dummy reference (see below)\n    --\n    --  Note: all references to incomplete or private types are to the\n    --  original (incomplete or private type) declaration. The full\n@@ -675,6 +796,9 @@ package Lib.Xref is\n    procedure Output_References;\n    --  Output references to the current ali file\n \n+   procedure Output_Local_References;\n+   --  Output references in each subprogram of the current ali file\n+\n    procedure Initialize;\n    --  Initialize internal tables\n "}, {"sha": "0e5c3db3cf0028e359db523438766a6c5636940a", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -180,10 +180,16 @@ package body Sem_Aux is\n          if No (S) then\n             return Standard_Standard;\n \n-         --  Quit if we get to standard or a dynamic scope\n+         --  Quit if we get to standard or a dynamic scope. We must also\n+         --  handle enclosing scopes that have a full view; required to\n+         --  locate enclosing scopes that are synchronized private types\n+         --  whose full view is a task type.\n \n          elsif S = Standard_Standard\n            or else Is_Dynamic_Scope (S)\n+           or else (Is_Private_Type (S)\n+                     and then Present (Full_View (S))\n+                     and then Is_Dynamic_Scope (Full_View (S)))\n          then\n             return S;\n "}, {"sha": "d30d4445f76b2691f777e2bb569b8a8673121a13", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3701,6 +3701,10 @@ package body Sem_Ch3 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n+\n+      if ALFA_Mode and then Present (Expression (Original_Node (N))) then\n+         Generate_Reference (Id, Id, 'I');\n+      end if;\n    end Analyze_Object_Declaration;\n \n    ---------------------------"}, {"sha": "01d6aee586916ea259d013e9ded62728e5ec75c4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -7816,7 +7816,7 @@ package body Sem_Prag is\n             end if;\n \n             if (Present (Parameter_Types)\n-                       or else\n+                  or else\n                 Present (Result_Type))\n               and then\n                 Present (Source_Location)"}, {"sha": "ef406e1243c5bb9e663eb1b43a4fa533294586f9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8374e7af37c56a79c8d28b0f7367bcc5a4d6707/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=e8374e7af37c56a79c8d28b0f7367bcc5a4d6707", "patch": "@@ -5751,9 +5751,9 @@ package body Sem_Res is\n --         Check_Formal_Restriction (\"function not inherited\", N);\n --      end if;\n \n-      --  Implement rule in 12.5.1 (23.3/2) : in an instance, if the actual\n-      --  is class-wide and the call dispatches on result in a context that\n-      --  does not provide a tag, the call raises Program_Error.\n+      --  Implement rule in 12.5.1 (23.3/2): In an instance, if the actual is\n+      --  class-wide and the call dispatches on result in a context that does\n+      --  not provide a tag, the call raises Program_Error.\n \n       if Nkind (N) = N_Function_Call\n         and then In_Instance\n@@ -5762,11 +5762,10 @@ package body Sem_Res is\n         and then Has_Controlling_Result (Nam)\n         and then Nkind (Parent (N)) = N_Object_Declaration\n       then\n-\n-         --  verify that none of the formals are controlling.\n+         --  Verify that none of the formals are controlling\n \n          declare\n-            Call_OK :  Boolean := False;\n+            Call_OK : Boolean := False;\n             F       : Entity_Id;\n \n          begin\n@@ -5776,6 +5775,7 @@ package body Sem_Res is\n                   Call_OK := True;\n                   exit;\n                end if;\n+\n                Next_Formal (F);\n             end loop;\n "}]}