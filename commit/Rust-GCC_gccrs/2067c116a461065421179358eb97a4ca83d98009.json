{"sha": "2067c116a461065421179358eb97a4ca83d98009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA2N2MxMTZhNDYxMDY1NDIxMTc5MzU4ZWI5N2E0Y2E4M2Q5ODAwOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-10-05T19:50:56Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-05T19:50:56Z"}, "message": "c-pretty-print.c: Fix comment typos.\n\n\t* c-pretty-print.c: Fix comment typos.\n\t* c-pretty-print.h: Likewise.\n\t* calls.c: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* cppfiles.c: Likewise.\n\t* final.c: Likewise.\n\t* function.c: Likewise.\n\t* gcov-io.h: Likewise.\n\t* gcse.c: Likewise.\n\t* genoutput.c: Likewise.\n\t* loop.c: Likewise.\n\t* postreload.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* regmove.c: Likewise.\n\t* sched-int.h: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* config/m68hc11/m68hc11.h: Likewise.\n\t* config/mmix/mmix.c: Likewise.\n\t* config/mn10300/mn10300.md: Likewise.\n\t* config/sh/sh.h: Likewise.\n\nFrom-SVN: r72118", "tree": {"sha": "181b15e6aed883a9959772d5ec222d6c365758bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/181b15e6aed883a9959772d5ec222d6c365758bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2067c116a461065421179358eb97a4ca83d98009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2067c116a461065421179358eb97a4ca83d98009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2067c116a461065421179358eb97a4ca83d98009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2067c116a461065421179358eb97a4ca83d98009/comments", "author": null, "committer": null, "parents": [{"sha": "3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d"}], "stats": {"total": 76, "additions": 51, "deletions": 25}, "files": [{"sha": "0dd3d1f0f1f9540c6e42c69828f9d600f35725f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -1,3 +1,29 @@\n+2003-10-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-pretty-print.c: Fix comment typos.\n+\t* c-pretty-print.h: Likewise.\n+\t* calls.c: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* cppfiles.c: Likewise.\n+\t* final.c: Likewise.\n+\t* function.c: Likewise.\n+\t* gcov-io.h: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genoutput.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* postreload.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* sched-int.h: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* config/m68hc11/m68hc11.h: Likewise.\n+\t* config/mmix/mmix.c: Likewise.\n+\t* config/mn10300/mn10300.md: Likewise.\n+\t* config/sh/sh.h: Likewise.\n+\n 2003-10-05  Richard Henderson  <rth@redhat.com>\n \n \t* tree-inline.c (remap_type): New."}, {"sha": "4a006b22f4256f6ea6260821940b83adfca64f9f", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -538,7 +538,7 @@ pp_c_declaration_specifiers (c_pretty_printer *pp, tree t)\n       ( declarator )\n       direct-declarator [ type-qualifier-list(opt) assignment-expression(opt) ]\n       direct-declarator [ static type-qualifier-list(opt) assignment-expression(opt)]\n-      direct-declarator [ type-qualifier-list static assignment-exression ]\n+      direct-declarator [ type-qualifier-list static assignment-expression ]\n       direct-declarator [ type-qualifier-list * ]\n       direct-declaratpr ( parameter-type-list )\n       direct-declarator ( identifier-list(opt) )  */\n@@ -884,7 +884,7 @@ pp_c_compound_literal (c_pretty_printer *pp, tree e)\n       integer-constant\n       floating-constant\n       enumeration-constant\n-      chatracter-constant   */\n+      character-constant   */\n \n void\n pp_c_constant (c_pretty_printer *pp, tree e)"}, {"sha": "39e0be77d2d9e38d6ad3d773506ee5dc16be3f9b", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -46,7 +46,7 @@ typedef void (*c_pretty_print_fn) (c_pretty_printer *, tree);\n    language using C/c++ syntax can derive from this datatype and reuse\n    facilities provided here.  It can do so by having a subobject of type\n    c_pretty_printer and override the macro pp_c_base to return a pointer\n-   to that subobject.  Such a pretty-printer has the responsability to\n+   to that subobject.  Such a pretty-printer has the responsibility to\n    initialize the pp_base() part, then call pp_c_pretty_printer_init\n    to set up the components that are specific to the C pretty-printer.\n    A derived pretty-printer can override any function listed in the"}, {"sha": "aa649801ec2e26e39689c3194774837027c865f1", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -2353,7 +2353,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n   /* Start updating where the next arg would go.\n \n-     On some machines (such as the PA) indirect calls have a difuferent\n+     On some machines (such as the PA) indirect calls have a different\n      calling convention than normal calls.  The last argument in\n      INIT_CUMULATIVE_ARGS tells the backend if this is an indirect call\n      or not.  */"}, {"sha": "de1210ce3f255b63ae58ab6d143480bc88c325d0", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -645,7 +645,7 @@ unloop (struct loops *loops, struct loop *loop)\n }\n \n /* Fix placement of LOOP inside loop tree, i.e. find the innermost superloop\n-   FATHER of LOOP such that all of the edges comming out of LOOP belong to\n+   FATHER of LOOP such that all of the edges coming out of LOOP belong to\n    FATHER, and set it as outer loop of LOOP.  Return 1 if placement of\n    LOOP changed.  */\n int"}, {"sha": "5f89a587463db7a0baa788b69c0c7240539010b7", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -106,7 +106,7 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   /* \"extern inline\" functions are never output locally.  */\n   if (DECL_EXTERNAL (decl))\n     return false;\n-  /* We want to emit COMDAT functions only when absolutely neccesary.  */\n+  /* We want to emit COMDAT functions only when absolutely necessary.  */\n   if (DECL_COMDAT (decl))\n     return false;\n   if (!DECL_INLINE (decl)\n@@ -166,7 +166,7 @@ cgraph_finalize_function (tree decl, bool nested)\n \t inlined in others.\n \t \n \t ??? It may make more sense to use one body for inlining and other\n-\t body for expanding the function but this is dificult to do.  */\n+\t body for expanding the function but this is difficult to do.  */\n \n       /* If node->output is set, then this is a unit-at-a-time compilation\n \t and we have already begun whole-unit analysis.  This is *not*"}, {"sha": "7efa0029a49ce2af36069b0781534e6ae0f5281e", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -968,7 +968,7 @@ extern enum reg_class m68hc11_tmp_regs_class;\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n    in order of preference.\n \n-   We have two registers that are eliminated on the 6811. The psuedo arg\n+   We have two registers that are eliminated on the 6811. The pseudo arg\n    pointer and pseudo frame pointer registers can always be eliminated;\n    they are replaced with either the stack or the real frame pointer.  */\n "}, {"sha": "764e9b8a31b6905209bae6cae28a92834662e81c", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -62,7 +62,7 @@ Boston, MA 02111-1307, USA.  */\n    (perhaps any insn).  But regs_ever_live is up-to-date when\n    leaf_function_p () isn't, so we \"or\" them together to get accurate\n    information.  FIXME: Some tweak to leaf_function_p might be\n-   preferrable.  */\n+   preferable.  */\n #define MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS\t\t\t\\\n  (flag_exceptions\t\t\t\t\t\t\\\n   && ((reload_completed && regs_ever_live[MMIX_rJ_REGNUM])\t\\"}, {"sha": "c9d9bb858032ee46b8a8fdeaf51a6b565e82626a", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -859,7 +859,7 @@\n ;; but will have the proper effect on cc0.  Using d0 is arbitrary; any\n ;; data register would work.)\n \n-;; Even though the first alternative would be preferrable if it can\n+;; Even though the first alternative would be preferable if it can\n ;; possibly match, reload must not be given the opportunity to attempt\n ;; to use it.  It assumes that such matches can only occur when one of\n ;; the operands is used for input and the other for output.  Since"}, {"sha": "fdd29fb39c0f5713bdfde4419b3818c34a497467", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -3213,7 +3213,7 @@ extern int rtx_equal_function_value_matters;\n #define MAX_FIXED_MODE_SIZE (TARGET_SH5 ? 128 : 64)\n \n /* ??? Define ACCUMULATE_OUTGOING_ARGS?  This is more efficient than pushing\n-   and poping arguments.  However, we do have push/pop instructions, and\n+   and popping arguments.  However, we do have push/pop instructions, and\n    rather limited offsets (4 bits) in load/store instructions, so it isn't\n    clear if this would give better code.  If implemented, should check for\n    compatibility problems.  */"}, {"sha": "00834aadc4b275677b9e836b74a7f29bf4d1cb48", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -643,7 +643,7 @@ _cpp_mark_file_once_only (cpp_reader *pfile, _cpp_file *file)\n }\n \n /* Return the directory from which searching for FNAME should start,\n-   condiering the directive TYPE and ANGLE_BRACKETS.  If there is\n+   considering the directive TYPE and ANGLE_BRACKETS.  If there is\n    nothing left in the path, returns NULL.  */\n static struct cpp_dir *\n search_path_head (cpp_reader *pfile, const char *fname, int angle_brackets,"}, {"sha": "1938604c25d8a192d223c676413c773c652e7f7a", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -2508,7 +2508,7 @@ cleanup_subreg_operands (rtx insn)\n   extract_insn_cached (insn);\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n-      /* The following test cannot use recog_data.operand when tesing\n+      /* The following test cannot use recog_data.operand when testing\n \t for a SUBREG: the underlying object might have been changed\n \t already if we are inside a match_operator expression that\n \t matches the else clause.  Instead we test the underlying"}, {"sha": "0251fe3df159f29a00cfb87f90292ff19e1db5e7", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -6342,7 +6342,7 @@ allocate_struct_function (tree fndecl)\n }\n \n /* Reset cfun, and other non-struct-function variables to defaults as\n-   appropriate for emiiting rtl at the start of a function.  */\n+   appropriate for emitting rtl at the start of a function.  */\n \n static void\n prepare_function_start (tree fndecl)"}, {"sha": "e1506baca07b70e679785339416f108a8ba1d6cb", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -148,7 +148,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    program.  The checksum is used for whole program summaries, and\n    disambiguates different programs which include the same\n    instrumented object file.  There may be several program summaries,\n-   each with a unique checksum.  The object summary's checkum is zero.\n+   each with a unique checksum.  The object summary's checksum is zero.\n    Note that the data file might contain information from several runs\n    concatenated, or the data might be merged.\n "}, {"sha": "84524b37d198005b46695ac4e7d847b9ec1e9be6", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -5360,7 +5360,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n      reaching_reg <- expr\n      old_reg      <- reaching_reg\n    because this way copy propagation can discover additional PRE\n-   opportunuties.  But if this fails, we try the old way.  */\n+   opportunities.  But if this fails, we try the old way.  */\n \n static void\n pre_insert_copy_insn (struct expr *expr, rtx insn)"}, {"sha": "6a2e0244491c68e9fa68604adadf33727333a4bd", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -1048,7 +1048,7 @@ constraint_len (const char *p, int genoutput_default_constraint_len)\n      check that fails if the value is not the expected one...  */\n   if (DEFAULT_CONSTRAINT_LEN (*p, p) != 1)\n     abort ();\n-  /* And now a comile-time check that should give a diagnostic if the\n+  /* And now a compile-time check that should give a diagnostic if the\n      definition doesn't exactly match.  */\n #define DEFAULT_CONSTRAINT_LEN(C,STR) 1\n   /* Now re-define DEFAULT_CONSTRAINT_LEN so that we can verify it is"}, {"sha": "c5b40608142d433e6324ac4c85cbf96508e1d613", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -6665,7 +6665,7 @@ simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n \t\t\t\t\t\t\t\t    arg1)),\n \t\t\t\t\text_val, benefit);\n \t    }\n-\t  /* Propagate the MULT expressions to the intermost nodes.  */\n+\t  /* Propagate the MULT expressions to the innermost nodes.  */\n \t  else if (GET_CODE (arg0) == PLUS)\n \t    {\n \t      /* (invar_0 + invar_1) * invar_2.  Distribute.  */"}, {"sha": "f5a987a7f0dfe0cb71afb262092e43ba154e4b2b", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -757,7 +757,7 @@ reload_combine (void)\n \t  else\n \t    {\n \t      /* Otherwise, look for a free index register.  Since we have\n-\t\t checked above that neiter REG nor BASE are index registers,\n+\t\t checked above that neither REG nor BASE are index registers,\n \t\t if we find anything at all, it will be different from these\n \t\t two registers.  */\n \t      for (i = first_index_reg; i <= last_index_reg; i++)"}, {"sha": "e1833bce85ad08e8b5dac9b32860edb4bf38ad17", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -2837,7 +2837,7 @@ convert_regs_2 (FILE *file, basic_block block)\n \t some dead EH outgoing edge after the possible deletion of the\n \t trapping insn inside the block.  Since the number of predecessors of\n \t \"block\"'s successors has been computed based on the initial edge set,\n-\t we check for the possiblity to process some of these successors\n+\t we check for the possibility to process some of these successors\n \t before such an edge deletion may happen.  */\n       for (e = block->succ; e ; e = e->succ_next)\n \tif (! (e->flags & EDGE_DFS_BACK))"}, {"sha": "8696d3a5ed15e9e3e751c384b287ac2fc89bfd27", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -706,7 +706,7 @@ optimize_reg_copy_3 (rtx insn, rtx dest, rtx src)\n       if (! INSN_P (p))\n \tcontinue;\n \n-      /* Make a tenative change.  */\n+      /* Make a tentative change.  */\n       validate_replace_rtx_group (src_reg, subreg, p);\n     }\n "}, {"sha": "061ebe419bd48cbf8f6b3ff1cb5757635185fa22", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -82,7 +82,7 @@ struct deps\n      scheduling is done.  */\n   rtx sched_before_next_call;\n \n-  /* Used to keep post-call psuedo/hard reg movements together with\n+  /* Used to keep post-call pseudo/hard reg movements together with\n      the call.  */\n   bool in_post_call_group_p;\n "}, {"sha": "f921061deae453d9881de3e4f0e794a3d11f68b7", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -1340,7 +1340,7 @@ check_live_1 (int src, rtx x)\n \t}\n       else\n \t{\n-\t  /* Check for psuedo registers.  */\n+\t  /* Check for pseudo registers.  */\n \t  for (i = 0; i < candidate_table[src].split_bbs.nr_members; i++)\n \t    {\n \t      int b = candidate_table[src].split_bbs.first_member[i];"}, {"sha": "0e8646313b1c1d8ffaf27230e24071734bd900ca", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -778,7 +778,7 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t   && width <= 2*HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n       /* Although the overflow semantics of RTL's FIX and UNSIGNED_FIX\n-\t operators are intentionally left unspecified (to ease implemention\n+\t operators are intentionally left unspecified (to ease implementation\n \t by target backends), for consistency, this routine implements the\n \t same semantics for constant folding as used by the middle-end.  */\n "}, {"sha": "375a5702291b316e37e9960c44341dd68f6d2bcc", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2067c116a461065421179358eb97a4ca83d98009/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2067c116a461065421179358eb97a4ca83d98009/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=2067c116a461065421179358eb97a4ca83d98009", "patch": "@@ -1944,7 +1944,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n     case BLOCK:\n     case RECORD_TYPE:\n     case CHAR_TYPE:\n-      /* None of thse have subtrees other than those already walked\n+      /* None of these have subtrees other than those already walked\n          above.  */\n       break;\n "}]}