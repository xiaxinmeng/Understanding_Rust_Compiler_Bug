{"sha": "4d449554949422320218bc1d565848cdc5478c80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ0NDk1NTQ5NDk0MjIzMjAyMThiYzFkNTY1ODQ4Y2RjNTQ3OGM4MA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-20T00:10:41Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-20T00:10:41Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1022", "tree": {"sha": "d5131c9328019fdb8214cac66b85ae62911bd393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5131c9328019fdb8214cac66b85ae62911bd393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d449554949422320218bc1d565848cdc5478c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d449554949422320218bc1d565848cdc5478c80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d449554949422320218bc1d565848cdc5478c80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d449554949422320218bc1d565848cdc5478c80/comments", "author": null, "committer": null, "parents": [{"sha": "795068a4b8762f6b3f2e92be5bc726899b2608a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/795068a4b8762f6b3f2e92be5bc726899b2608a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/795068a4b8762f6b3f2e92be5bc726899b2608a5"}], "stats": {"total": 114, "additions": 90, "deletions": 24}, "files": [{"sha": "76527931f5ec62718572157a2e244c3e11cf0f26", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d449554949422320218bc1d565848cdc5478c80/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d449554949422320218bc1d565848cdc5478c80/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=4d449554949422320218bc1d565848cdc5478c80", "patch": "@@ -329,7 +329,8 @@ normal_comp_operator (op, mode)\n   if (GET_RTX_CLASS (code) != '<')\n     return 0;\n \n-  if (GET_MODE (XEXP (op, 0)) == CCFPmode)\n+  if (GET_MODE (XEXP (op, 0)) == CCFPmode\n+      || GET_MODE (XEXP (op, 0)) == CCFPEmode)\n     return 1;\n \n   return (code != NE && code != EQ && code != GEU && code != LTU);\n@@ -1915,8 +1916,9 @@ output_scc_insn (operands, insn)\n    it can easily be got.  */\n \n /* Modes for condition codes.  */\n-#define C_MODES\t\t\\\n-  ((1 << (int) CCmode) | (1 << (int) CC_NOOVmode) | (1 << (int) CCFPmode))\n+#define C_MODES\t\t\t\t\t\t\\\n+  ((1 << (int) CCmode) | (1 << (int) CC_NOOVmode)\t\\\n+   | (1 << (int) CCFPmode) | (1 << (int) CCFPEmode))\n \n /* Modes for single-word (and smaller) quantities.  */\n #define S_MODES\t\t\t\t\t\t\\\n@@ -2282,32 +2284,33 @@ output_cbranch (op, label, reversed, annul, noop)\n      Because there is currently no concept of pre-delay slots, we can fix\n      this only by always emitting a nop before a floating point branch.  */\n \n-  if (mode == CCFPmode)\n+  if (mode == CCFPmode || mode == CCFPEmode)\n     strcpy (string, \"nop\\n\\t\");\n \n   /* If not floating-point or if EQ or NE, we can just reverse the code.  */\n-  if (reversed && (mode != CCFPmode || code == EQ || code == NE))\n+  if (reversed\n+      && ((mode != CCFPmode && mode != CCFPEmode) || code == EQ || code == NE))\n     code = reverse_condition (code), reversed = 0;\n \n   /* Start by writing the branch condition.  */\n   switch (code)\n     {\n     case NE:\n-      if (mode == CCFPmode)\n+      if (mode == CCFPmode || mode == CCFPEmode)\n \tstrcat (string, \"fbne\");\n       else\n \tstrcpy (string, \"bne\");\n       break;\n \n     case EQ:\n-      if (mode == CCFPmode)\n+      if (mode == CCFPmode || mode == CCFPEmode)\n \tstrcat (string, \"fbe\");\n       else\n \tstrcpy (string, \"be\");\n       break;\n \n     case GE:\n-      if (mode == CCFPmode)\n+      if (mode == CCFPmode || mode == CCFPEmode)\n \t{\n \t  if (reversed)\n \t    strcat (string, \"fbul\");\n@@ -2321,7 +2324,7 @@ output_cbranch (op, label, reversed, annul, noop)\n       break;\n \n     case GT:\n-      if (mode == CCFPmode)\n+      if (mode == CCFPmode || mode == CCFPEmode)\n \t{\n \t  if (reversed)\n \t    strcat (string, \"fbule\");\n@@ -2333,7 +2336,7 @@ output_cbranch (op, label, reversed, annul, noop)\n       break;\n \n     case LE:\n-      if (mode == CCFPmode)\n+      if (mode == CCFPmode || mode == CCFPEmode)\n \t{\n \t  if (reversed)\n \t    strcat (string, \"fbug\");\n@@ -2345,7 +2348,7 @@ output_cbranch (op, label, reversed, annul, noop)\n       break;\n \n     case LT:\n-      if (mode == CCFPmode)\n+      if (mode == CCFPmode || mode == CCFPEmode)\n \t{\n \t  if (reversed)\n \t    strcat (string, \"fbuge\");"}, {"sha": "50d0835366525cb0390c5bbf2997ddf27654e6d7", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d449554949422320218bc1d565848cdc5478c80/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d449554949422320218bc1d565848cdc5478c80/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=4d449554949422320218bc1d565848cdc5478c80", "patch": "@@ -1236,23 +1236,26 @@ extern struct rtx_def *legitimize_pic_address ();\n    subtract insn is used to set the condition code.  Different branches are\n    used in this case for some operations.\n \n-   We also have a mode to indicate that the relevant condition code is\n-   in the floating-point condition code.  This really should be a separate\n-   register, but we don't want to go to 65 registers.  */\n-#define EXTRA_CC_MODES CC_NOOVmode, CCFPmode\n+   We also have two modes to indicate that the relevant condition code is\n+   in the floating-point condition code register.  One for comparisons which\n+   will generate an exception if the result is unordered (CCFPEmode) and\n+   one for comparisons which will never trap (CCFPmode).  This really should\n+   be a separate register, but we don't want to go to 65 registers.  */\n+#define EXTRA_CC_MODES CC_NOOVmode, CCFPmode, CCFPEmode\n \n /* Define the names for the modes specified above.  */\n-#define EXTRA_CC_NAMES \"CC_NOOV\", \"CCFP\"\n+#define EXTRA_CC_NAMES \"CC_NOOV\", \"CCFP\", \"CCFPE\"\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  For floating-point, CCFPmode\n-   should be used.  CC_NOOVmode should be used when the first operand is a\n+   return the mode to be used for the comparison.  For floating-point,\n+   CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand is a\n    PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n    needed.  */\n #define SELECT_CC_MODE(OP,X) \\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\t    \\\n-   : (GET_CODE (X) == PLUS || GET_CODE (X) == MINUS || GET_CODE (X) == NEG) \\\n-   ? CC_NOOVmode : CCmode)\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\t\\\n+   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)\t\t\\\n+   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS || GET_CODE (X) == NEG) \\\n+      ? CC_NOOVmode : CCmode))\n \n /* A function address in a call instruction\n    is a byte address (for indexing purposes)"}, {"sha": "45b3946397931c2d91508c2b970645bb1db38ccc", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d449554949422320218bc1d565848cdc5478c80/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d449554949422320218bc1d565848cdc5478c80/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=4d449554949422320218bc1d565848cdc5478c80", "patch": "@@ -366,28 +366,52 @@\n   \"cmp %r0,%1\"\n   [(set_attr \"type\" \"compare\")])\n \n+(define_insn \"\"\n+  [(set (reg:CCFPE 0)\n+\t(compare:CCFPE (match_operand:DF 0 \"register_operand\" \"f\")\n+\t\t       (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fcmped %0,%1\"\n+  [(set_attr \"type\" \"fpcmp\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CCFPE 0)\n+\t(compare:CCFPE (match_operand:SF 0 \"register_operand\" \"f\")\n+\t\t       (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fcmpes %0,%1\"\n+  [(set_attr \"type\" \"fpcmp\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CCFPE 0)\n+\t(compare:CCFPE (match_operand:TF 0 \"register_operand\" \"f\")\n+\t\t       (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fcmpeq %0,%1\"\n+  [(set_attr \"type\" \"fpcmp\")])\n+\n (define_insn \"\"\n   [(set (reg:CCFP 0)\n \t(compare:CCFP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t      (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"\"\n-  \"fcmped %0,%1\"\n+  \"fcmpd %0,%1\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n (define_insn \"\"\n   [(set (reg:CCFP 0)\n \t(compare:CCFP (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"\"\n-  \"fcmpes %0,%1\"\n+  \"fcmps %0,%1\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n (define_insn \"\"\n   [(set (reg:CCFP 0)\n \t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"f\")\n \t\t      (match_operand:TF 1 \"register_operand\" \"f\")))]\n   \"\"\n-  \"fcmpeq %0,%1\"\n+  \"fcmpq %0,%1\"\n   [(set_attr \"type\" \"fpcmp\")])\n \n ;; The SEQ and SNE patterns are special because they can be done"}, {"sha": "2c6f22d3f60f25bdab7f7b330bf5121edd847daf", "filename": "gcc/fixincludes", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d449554949422320218bc1d565848cdc5478c80/gcc%2Ffixincludes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d449554949422320218bc1d565848cdc5478c80/gcc%2Ffixincludes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixincludes?ref=4d449554949422320218bc1d565848cdc5478c80", "patch": "@@ -599,6 +599,42 @@ if [ -r ${LIB}/$file ]; then\n   fi\n fi\n \n+# Fix non-ANSI memcpy declaration that conflicts with gcc's builtin\n+# declaration on Sun OS 4.x.  We must only fix this on Sun OS 4.x, because\n+# many other systems have similar text but correct versions of the file.\n+# To ensure only Sun's is fixed, we grep for a likely unique string.\n+file=memory.h\n+if egrep '/\\*\t@\\(#\\)memory.h 1.4 88/08/19 SMI; from S5R2 1.2\t\\*/' $file > /dev/null; then\n+  if [ -r $file ] && [ ! -r ${LIB}/$file ]; then\n+    cp $file ${LIB}/$file >/dev/null 2>&1 || echo \"Can't copy $file\"\n+    chmod +w ${LIB}/$file 2>/dev/null\n+  fi\n+  if [ -r ${LIB}/$file ]; then\n+    echo Replacing $file\n+    cat > ${LIB}/$file << EOF\n+/* This file was generated by fixincludes */\n+#ifndef __memory_h__\n+#define __memory_h__\n+\n+#ifdef __STDC__\n+extern void *memccpy();\n+extern void *memchr();\n+extern void *memcpy();\n+extern void *memset();\n+#else\n+extern char *memccpy();\n+extern char *memchr();\n+extern char *memcpy();\n+extern char *memset();\n+#endif /* __STDC__ */\n+\n+extern int memcmp();\n+\n+#endif __memory_h__\n+EOF\n+  fi\n+fi\n+\n echo 'Removing unneeded directories:'\n cd $LIB\n files=`find . -type d -print | sort -r`"}]}