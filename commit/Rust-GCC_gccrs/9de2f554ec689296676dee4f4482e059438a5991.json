{"sha": "9de2f554ec689296676dee4f4482e059438a5991", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlMmY1NTRlYzY4OTI5NjY3NmRlZTRmNDQ4MmUwNTk0MzhhNTk5MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2014-02-04T03:42:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-04T03:42:37Z"}, "message": "ipa-cp.c (ipa_get_indirect_edge_target_1): Do direct lookup via vtable pointer...\n\n\n\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Do direct\n\tlookup via vtable pointer; check for type consistency\n\tand turn inconsitent facts into UNREACHABLE.\n\t* ipa-prop.c (try_make_edge_direct_virtual_call): Likewise.\n\t* gimple-fold.c (gimple_get_virt_method_for_vtable): \n\tDo not ICE on type inconsistent querries; return UNREACHABLE\n\tinstead.\n\n\t* g++.dg/ipa/devirt-25.C: New testcase.\n\nFrom-SVN: r207447", "tree": {"sha": "27d5b0441b9bc4563a35749d28be56e44f3e21ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27d5b0441b9bc4563a35749d28be56e44f3e21ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9de2f554ec689296676dee4f4482e059438a5991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de2f554ec689296676dee4f4482e059438a5991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de2f554ec689296676dee4f4482e059438a5991", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de2f554ec689296676dee4f4482e059438a5991/comments", "author": null, "committer": null, "parents": [{"sha": "4b076d8a4d638ded2d71160f88faba811161b378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b076d8a4d638ded2d71160f88faba811161b378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b076d8a4d638ded2d71160f88faba811161b378"}], "stats": {"total": 141, "additions": 118, "deletions": 23}, "files": [{"sha": "4baab8e13bdabae3c76a731e471ed19a4b730fc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de2f554ec689296676dee4f4482e059438a5991/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de2f554ec689296676dee4f4482e059438a5991/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9de2f554ec689296676dee4f4482e059438a5991", "patch": "@@ -1,3 +1,13 @@\n+2014-02-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Do direct\n+\tlookup via vtable pointer; check for type consistency\n+\tand turn inconsitent facts into UNREACHABLE.\n+\t* ipa-prop.c (try_make_edge_direct_virtual_call): Likewise.\n+\t* gimple-fold.c (gimple_get_virt_method_for_vtable): \n+\tDo not ICE on type inconsistent querries; return UNREACHABLE\n+\tinstead.\n+\n 2014-02-03  Richard Henderson  <rth@twiddle.net>\n \n \tPR tree-opt/59924"}, {"sha": "848c1f64e4810ab93c22e0baa6b83e1a7818508d", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=9de2f554ec689296676dee4f4482e059438a5991", "patch": "@@ -3247,12 +3247,14 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n   tree vtable = v, init, fn;\n   unsigned HOST_WIDE_INT size;\n \n+  /* First of all double check we have virtual table.  */\n   if (TREE_CODE (v) != VAR_DECL\n       || !DECL_VIRTUAL_P (v))\n     return NULL_TREE;\n+\n   init = ctor_for_folding (v);\n \n-  /* The virtual tables should always be born with constructors.\n+  /* The virtual tables should always be born with constructors\n      and we always should assume that they are avaialble for\n      folding.  At the moment we do not stream them in all cases,\n      but it should never happen that ctor seem unreachable.  */\n@@ -3266,21 +3268,31 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n   size = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (TREE_TYPE (v))));\n   offset *= BITS_PER_UNIT;\n   offset += token * size;\n+\n+  /* Do not pass from_decl here, we want to know even about values we can\n+     not use and will check can_refer_decl_in_current_unit_p ourselves.  */\n   fn = fold_ctor_reference (TREE_TYPE (TREE_TYPE (v)), init,\n-\t\t\t    offset, size, v);\n-  if (!fn || integer_zerop (fn))\n-    return NULL_TREE;\n-  gcc_assert (TREE_CODE (fn) == ADDR_EXPR\n-\t      || TREE_CODE (fn) == FDESC_EXPR);\n-  fn = TREE_OPERAND (fn, 0);\n-  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n-\n-  /* When cgraph node is missing and function is not public, we cannot\n-     devirtualize.  This can happen in WHOPR when the actual method\n-     ends up in other partition, because we found devirtualization\n-     possibility too late.  */\n-  if (!can_refer_decl_in_current_unit_p (fn, vtable))\n-    return NULL_TREE;\n+\t\t\t    offset, size, NULL);\n+\n+  /* For type inconsistent program we may end up looking up virtual method\n+     in virtual table that does not contain TOKEN entries.  We may overrun\n+     the virtual table and pick up a constant or RTTI info pointer.\n+     In any case the call is undefined.  */\n+  if (!fn\n+      || (TREE_CODE (fn) != ADDR_EXPR && TREE_CODE (fn) != FDESC_EXPR)\n+      || TREE_CODE (TREE_OPERAND (fn, 0)) != FUNCTION_DECL)\n+    fn = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n+  else\n+    {\n+      fn = TREE_OPERAND (fn, 0);\n+\n+      /* When cgraph node is missing and function is not public, we cannot\n+\t devirtualize.  This can happen in WHOPR when the actual method\n+\t ends up in other partition, because we found devirtualization\n+\t possibility too late.  */\n+      if (!can_refer_decl_in_current_unit_p (fn, vtable))\n+\treturn NULL_TREE;\n+    }\n \n   /* Make sure we create a cgraph node for functions we'll reference.\n      They can be non-existent if the reference comes from an entry"}, {"sha": "e2101769e126bd09b35e5a436256ae7b93e72451", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=9de2f554ec689296676dee4f4482e059438a5991", "patch": "@@ -1564,9 +1564,31 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t\t\t\t       true);\n     }\n \n-  /* If we found the virtual table pointer, lookup the binfo.  */\n+  /* If we found the virtual table pointer, lookup the target.  */\n   if (t)\n-    t = vtable_pointer_value_to_binfo (t);\n+    {\n+      tree vtable;\n+      unsigned HOST_WIDE_INT offset;\n+      if (vtable_pointer_value_to_vtable (t, &vtable, &offset))\n+\t{\n+\t  target = gimple_get_virt_method_for_vtable (ie->indirect_info->otr_token,\n+\t\t\t\t\t\t      vtable, offset);\n+\t  if ((TREE_CODE (TREE_TYPE (target)) == FUNCTION_TYPE\n+\t       && DECL_FUNCTION_CODE (target) == BUILT_IN_UNREACHABLE)\n+\t      || !possible_polymorphic_call_target_p\n+\t\t   (ie, cgraph_get_node (target)))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Type inconsident devirtualization: %s/%i->%s\\n\",\n+\t\t\t ie->caller->name (), ie->caller->order,\n+\t\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (target)));\n+\t      target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n+\t      cgraph_get_create_node (target);\n+\t    }\n+\t  return target;\n+\t}\n+    }\n \n   /* Did we work out BINFO via type propagation?  */\n   if (!t && known_binfos.length () > (unsigned int) param_index)"}, {"sha": "39c01c51ef3e4cc769f56c94d3a9913b4279b7da", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=9de2f554ec689296676dee4f4482e059438a5991", "patch": "@@ -2687,23 +2687,44 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t   struct ipa_jump_func *jfunc,\n \t\t\t\t   struct ipa_node_params *new_root_info)\n {\n-  tree binfo = NULL, target;\n+  tree binfo, target;\n \n   if (!flag_devirtualize)\n     return NULL;\n \n-  /* First try to do lookup binfo via known virtual table pointer value.  */\n+  /* First try to do lookup via known virtual table pointer value.  */\n   if (!ie->indirect_info->by_ref)\n     {\n+      tree vtable;\n+      unsigned HOST_WIDE_INT offset;\n       tree t = ipa_find_agg_cst_for_param (&jfunc->agg,\n \t\t\t\t\t   ie->indirect_info->offset,\n \t\t\t\t\t   true);\n-      if (t)\n-        binfo = vtable_pointer_value_to_binfo (t);\n+      if (t && vtable_pointer_value_to_vtable (t, &vtable, &offset))\n+\t{\n+\t  target = gimple_get_virt_method_for_vtable (ie->indirect_info->otr_token,\n+\t\t\t\t\t\t      vtable, offset);\n+\t  if (target)\n+\t    {\n+\t      if ((TREE_CODE (TREE_TYPE (target)) == FUNCTION_TYPE\n+\t\t   && DECL_FUNCTION_CODE (target) == BUILT_IN_UNREACHABLE)\n+\t\t  || !possible_polymorphic_call_target_p\n+\t\t       (ie, cgraph_get_node (target)))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Type inconsident devirtualization: %s/%i->%s\\n\",\n+\t\t\t     ie->caller->name (), ie->caller->order,\n+\t\t\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (target)));\n+\t\t  target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n+\t\t  cgraph_get_create_node (target);\n+\t\t}\n+\t      return ipa_make_edge_direct_to_target (ie, target);\n+\t    }\n+\t}\n     }\n \n-  if (!binfo)\n-    binfo = ipa_value_from_jfunc (new_root_info, jfunc);\n+  binfo = ipa_value_from_jfunc (new_root_info, jfunc);\n \n   if (!binfo)\n     return NULL;"}, {"sha": "3a0c9447dccb07ff9c2a1ab94f3e43af964664bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9de2f554ec689296676dee4f4482e059438a5991", "patch": "@@ -1,3 +1,7 @@\n+2014-02-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* g++.dg/ipa/devirt-25.C: New testcase.\n+\n 2014-02-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/59924"}, {"sha": "751647957facdb5a6a69c009a5ce20da73e9ab9e", "filename": "gcc/testsuite/g++.dg/ipa/devirt-25.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de2f554ec689296676dee4f4482e059438a5991/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-25.C?ref=9de2f554ec689296676dee4f4482e059438a5991", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp\"  } */\n+\n+class ert_RefCounter {\n+ protected:\n+  int refCounterE;\n+  virtual ~ert_RefCounter() {}\n+};\n+\n+class ebs_Object : virtual public ert_RefCounter {\n+};\n+\n+class dpr_App : public ebs_Object {\n+ public:\n+  virtual void run();\n+};\n+\n+class dpr_Job : public ebs_Object {};\n+\n+void dpr_run(ebs_Object& objectA) {\n+  ((dpr_App&)objectA).run();\n+  dpr_Job jobL;\n+  dpr_run(jobL);\n+}\n+/* { dg-final { scan-ipa-dump \"Type inconsident devirtualization\" \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}]}