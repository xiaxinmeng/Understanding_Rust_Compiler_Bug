{"sha": "fbe1758db29ec4459a0a9bce7827597d37b6523a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJlMTc1OGRiMjllYzQ0NTlhMGE5YmNlNzgyNzU5N2QzN2I2NTIzYQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1999-01-21T11:33:44Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1999-01-21T11:33:44Z"}, "message": "expr.c (MOVE_BY_PIECES_P): Define condition for deciding to use move_by_pieces.\n\n\t* expr.c (MOVE_BY_PIECES_P): Define condition for deciding to use\n\tmove_by_pieces.\n\t(MOVE_MAX_PIECES): Define maximum number of bytes to move at once.\n\t(USE_LOAD_POST_INCREMENT, USE_LOAD_PRE_DECREMENT): Define defaults.\n\t(USE_STORE_POST_INCREMENT, USE_STORE_PRE_DECREMENT): Define defaults.\n\t(move_by_pieces): Use new macros.\n\t(emit_block_move): Use new macros.\n\t(clear_by_pieces): Use new macros.\n\t(clear_storage): Use new macros.\n\t(emit_push_insn): Use new macros.\n\t(expand_expr): Use new macros.\n\t* config/sh/sh.h (USE_LOAD_POST_INCREMENT, USE_LOAD_PRE_DECREMENT):\n\tDefine.\n\t(USE_STORE_POST_INCREMENT, USE_STORE_PRE_DECREMENT): Define.\n\t(MOVE_BY_PIECES_P): Define based on alignment and TARGET_SMALLCODE.\n\t(MOVE_MAX_PIECES): move 8 bytes on SH4.\n\t* tm.texi(MOVE_BY_PIECES_P, MOVE_MAX_PIECES, USE_LOAD_POST_INCREMENT,\n\tUSE_LOAD_PRE_DECREMENT, USE_STORE_POST_INCREMENT,\n\tUSE_STORE_PRE_DECREMENT): Describe new macros.\n\nFrom-SVN: r24801", "tree": {"sha": "2dd0db2d241549b740b9698c35b5d5fabd5b22e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dd0db2d241549b740b9698c35b5d5fabd5b22e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbe1758db29ec4459a0a9bce7827597d37b6523a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe1758db29ec4459a0a9bce7827597d37b6523a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe1758db29ec4459a0a9bce7827597d37b6523a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe1758db29ec4459a0a9bce7827597d37b6523a/comments", "author": null, "committer": null, "parents": [{"sha": "0003feb203c94e5ed853432b8c8be9079761244e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0003feb203c94e5ed853432b8c8be9079761244e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0003feb203c94e5ed853432b8c8be9079761244e"}], "stats": {"total": 170, "additions": 143, "deletions": 27}, "files": [{"sha": "69e53eb413434550e957d661a2b6bc0229871e43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbe1758db29ec4459a0a9bce7827597d37b6523a", "patch": "@@ -1,3 +1,25 @@\n+Thu Jan 21 14:18:04 EST 1999  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* expr.c (MOVE_BY_PIECES_P): Define condition for deciding to use\n+\tmove_by_pieces.\n+\t(MOVE_MAX_PIECES): Define maximum number of bytes to move at once.\n+\t(USE_LOAD_POST_INCREMENT, USE_LOAD_PRE_DECREMENT): Define defaults.\n+\t(USE_STORE_POST_INCREMENT, USE_STORE_PRE_DECREMENT): Define defaults.\n+\t(move_by_pieces): Use new macros.\n+\t(emit_block_move): Use new macros.\n+\t(clear_by_pieces): Use new macros.\n+\t(clear_storage): Use new macros.\n+\t(emit_push_insn): Use new macros.\n+\t(expand_expr): Use new macros.\n+\t* config/sh/sh.h (USE_LOAD_POST_INCREMENT, USE_LOAD_PRE_DECREMENT): \n+\tDefine.\n+\t(USE_STORE_POST_INCREMENT, USE_STORE_PRE_DECREMENT): Define.\n+\t(MOVE_BY_PIECES_P): Define based on alignment and TARGET_SMALLCODE.\n+\t(MOVE_MAX_PIECES): move 8 bytes on SH4.\n+\t* tm.texi(MOVE_BY_PIECES_P, MOVE_MAX_PIECES, USE_LOAD_POST_INCREMENT,\n+\tUSE_LOAD_PRE_DECREMENT, USE_STORE_POST_INCREMENT, \n+\tUSE_STORE_PRE_DECREMENT): Describe new macros.\n+\n Thu Jan 21 14:13:31 1999  Vladimir N. Makarov  <vmakarov@cygnus.com>\n \n         * varasm.c (output_constant_pool): Use floor_log2 instead of"}, {"sha": "260e9cb13daa333b5799345ebdebbc6a9b8d9ac5", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=fbe1758db29ec4459a0a9bce7827597d37b6523a", "patch": "@@ -1155,6 +1155,17 @@ extern struct rtx_def *sh_builtin_saveregs ();\n /*#define HAVE_POST_DECREMENT  1*/\n #define HAVE_PRE_DECREMENT   1\n \n+#define USE_LOAD_POST_INCREMENT(mode)    ((mode == SImode || mode == DImode) \\\n+                                           ? 0 : 1)\n+#define USE_LOAD_PRE_DECREMENT(mode)     0\n+#define USE_STORE_POST_INCREMENT(mode)   0\n+#define USE_STORE_PRE_DECREMENT(mode)    ((mode == SImode || mode == DImode) \\\n+                                           ? 0 : 1)\n+\n+#define MOVE_BY_PIECES_P(SIZE, ALIGN)  (move_by_pieces_ninsns (SIZE, ALIGN) \\\n+                                        < (TARGET_SMALLCODE ? 2 :           \\\n+                                           ((ALIGN >= 4) ? 16 : 2)))\n+\n /* Macros to check register numbers against specific register classes.  */\n \n /* These assume that REGNO is a hard or pseudo reg number.\n@@ -1509,6 +1520,10 @@ extern struct rtx_def *sh_builtin_saveregs ();\n    in one reasonably fast instruction.  */\n #define MOVE_MAX 4\n \n+/* Max number of bytes we want move_by_pieces to be able to copy\n+   efficiently.  */\n+#define MOVE_MAX_PIECES (TARGET_SH4 ? 8 : 4)\n+\n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n #define WORD_REGISTER_OPERATIONS\n@@ -2071,8 +2086,6 @@ extern int rtx_equal_function_value_matters;\n extern struct rtx_def *fpscr_rtx;\n extern struct rtx_def *get_fpscr_rtx ();\n \n-\n-#define MOVE_RATIO (TARGET_SMALLCODE ? 2 : 16)\n \f\n /* Instructions with unfilled delay slots take up an extra two bytes for\n    the nop in the delay slot.  */"}, {"sha": "42e305d54f76219fc36d9d78b2a543d36f36a6f8", "filename": "gcc/expr.c", "status": "modified", "additions": 70, "deletions": 25, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fbe1758db29ec4459a0a9bce7827597d37b6523a", "patch": "@@ -210,6 +210,13 @@ static char direct_store[NUM_MACHINE_MODES];\n #endif\n #endif\n \n+/* This macro is used to determine whether move_by_pieces should be called\n+   to perform a structure copy. */\n+#ifndef MOVE_BY_PIECES_P\n+#define MOVE_BY_PIECES_P(SIZE, ALIGN) (move_by_pieces_ninsns        \\\n+                                       (SIZE, ALIGN) < MOVE_RATIO)\n+#endif\n+\n /* This array records the insn_code of insns to perform block moves.  */\n enum insn_code movstr_optab[NUM_MACHINE_MODES];\n \n@@ -1383,6 +1390,38 @@ convert_modes (mode, oldmode, x, unsignedp)\n   return temp;\n }\n \f\n+\n+/* This macro is used to determine what the largest unit size that\n+   move_by_pieces can use is. */\n+\n+/* MOVE_MAX_PIECES is the number of bytes at a time which we can\n+   move efficiently, as opposed to  MOVE_MAX which is the maximum\n+   number of bhytes we can move with a single instruction. */\n+\n+#ifndef MOVE_MAX_PIECES\n+#define MOVE_MAX_PIECES   MOVE_MAX\n+#endif\n+\n+/* Some architectures do not have complete pre/post increment/decrement\n+   instruction sets, or only move some modes efficiently. these macros\n+   allow us to fine tune move_by_pieces for these targets. */\n+\n+#ifndef USE_LOAD_POST_INCREMENT\n+#define USE_LOAD_POST_INCREMENT(MODE)   HAVE_POST_INCREMENT\n+#endif\n+\n+#ifndef USE_LOAD_PRE_DECREMENT\n+#define USE_LOAD_PRE_DECREMENT(MODE)    HAVE_PRE_DECREMENT\n+#endif\n+\n+#ifndef USE_STORE_POST_INCREMENT\n+#define USE_STORE_POST_INCREMENT(MODE)  HAVE_POST_INCREMENT\n+#endif\n+\n+#ifndef USE_STORE_PRE_DECREMENT\n+#define USE_STORE_PRE_DECREMENT(MODE)   HAVE_PRE_DECREMENT\n+#endif\n+\n /* Generate several move instructions to copy LEN bytes\n    from block FROM to block TO.  (These are MEM rtx's with BLKmode).\n    The caller must pass FROM and TO\n@@ -1396,7 +1435,9 @@ move_by_pieces (to, from, len, align)\n {\n   struct move_by_pieces data;\n   rtx to_addr = XEXP (to, 0), from_addr = XEXP (from, 0);\n-  int max_size = MOVE_MAX + 1;\n+  int max_size = MOVE_MAX_PIECES + 1;\n+  enum machine_mode mode = VOIDmode, tmode;\n+  enum insn_code icode;\n \n   data.offset = 0;\n   data.to_addr = to_addr;\n@@ -1427,27 +1468,33 @@ move_by_pieces (to, from, len, align)\n   if (!(data.autinc_from && data.autinc_to)\n       && move_by_pieces_ninsns (len, align) > 2)\n     {\n-      if (HAVE_PRE_DECREMENT && data.reverse && ! data.autinc_from)\n+      /* Find the mode of the largest move... */\n+      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+\tif (GET_MODE_SIZE (tmode) < max_size)\n+\t  mode = tmode;\n+\n+      if (USE_LOAD_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_from)\n \t{\n \t  data.from_addr = copy_addr_to_reg (plus_constant (from_addr, len));\n \t  data.autinc_from = 1;\n \t  data.explicit_inc_from = -1;\n \t}\n-      if (HAVE_POST_INCREMENT && ! data.autinc_from)\n+      if (USE_LOAD_POST_INCREMENT (mode) && ! data.autinc_from)\n \t{\n \t  data.from_addr = copy_addr_to_reg (from_addr);\n \t  data.autinc_from = 1;\n \t  data.explicit_inc_from = 1;\n \t}\n       if (!data.autinc_from && CONSTANT_P (from_addr))\n \tdata.from_addr = copy_addr_to_reg (from_addr);\n-      if (HAVE_PRE_DECREMENT && data.reverse && ! data.autinc_to)\n+      if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)\n \t{\n \t  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len));\n \t  data.autinc_to = 1;\n \t  data.explicit_inc_to = -1;\n \t}\n-      if (HAVE_POST_INCREMENT && ! data.reverse && ! data.autinc_to)\n+      if (USE_STORE_POST_INCREMENT (mode) && ! data.reverse && ! data.autinc_to)\n \t{\n \t  data.to_addr = copy_addr_to_reg (to_addr);\n \t  data.autinc_to = 1;\n@@ -1466,9 +1513,6 @@ move_by_pieces (to, from, len, align)\n \n   while (max_size > 1)\n     {\n-      enum machine_mode mode = VOIDmode, tmode;\n-      enum insn_code icode;\n-\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n \tif (GET_MODE_SIZE (tmode) < max_size)\n@@ -1622,8 +1666,7 @@ emit_block_move (x, y, size, align)\n   if (size == 0)\n     abort ();\n \n-  if (GET_CODE (size) == CONST_INT\n-      && (move_by_pieces_ninsns (INTVAL (size), align) < MOVE_RATIO))\n+  if (GET_CODE (size) == CONST_INT && MOVE_BY_PIECES_P (INTVAL (size), align))\n     move_by_pieces (x, y, INTVAL (size), align);\n   else\n     {\n@@ -2217,7 +2260,9 @@ clear_by_pieces (to, len, align)\n {\n   struct clear_by_pieces data;\n   rtx to_addr = XEXP (to, 0);\n-  int max_size = MOVE_MAX + 1;\n+  int max_size = MOVE_MAX_PIECES + 1;\n+  enum machine_mode mode = VOIDmode, tmode;\n+  enum insn_code icode;\n \n   data.offset = 0;\n   data.to_addr = to_addr;\n@@ -2240,13 +2285,19 @@ clear_by_pieces (to, len, align)\n   if (!data.autinc_to\n       && move_by_pieces_ninsns (len, align) > 2)\n     {\n-      if (HAVE_PRE_DECREMENT && data.reverse && ! data.autinc_to)\n+      /* Determine the main mode we'll be using */\n+      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+\tif (GET_MODE_SIZE (tmode) < max_size)\n+\t  mode = tmode;\n+\n+      if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)\n \t{\n \t  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len));\n \t  data.autinc_to = 1;\n \t  data.explicit_inc_to = -1;\n \t}\n-      if (HAVE_POST_INCREMENT && ! data.reverse && ! data.autinc_to)\n+      if (USE_STORE_POST_INCREMENT (mode) && ! data.reverse && ! data.autinc_to)\n \t{\n \t  data.to_addr = copy_addr_to_reg (to_addr);\n \t  data.autinc_to = 1;\n@@ -2265,9 +2316,6 @@ clear_by_pieces (to, len, align)\n \n   while (max_size > 1)\n     {\n-      enum machine_mode mode = VOIDmode, tmode;\n-      enum insn_code icode;\n-\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n \tif (GET_MODE_SIZE (tmode) < max_size)\n@@ -2351,7 +2399,7 @@ clear_storage (object, size, align)\n       size = protect_from_queue (size, 0);\n \n       if (GET_CODE (size) == CONST_INT\n-\t  && (move_by_pieces_ninsns (INTVAL (size), align) < MOVE_RATIO))\n+\t  && MOVE_BY_PIECES_P (INTVAL (size), align))\n \tclear_by_pieces (object, INTVAL (size), align);\n \n       else\n@@ -2839,8 +2887,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n       if (args_addr == 0\n \t  && GET_CODE (size) == CONST_INT\n \t  && skip == 0\n-\t  && (move_by_pieces_ninsns ((unsigned) INTVAL (size) - used, align)\n-\t      < MOVE_RATIO)\n+\t  && (MOVE_BY_PIECES_P ((unsigned) INTVAL (size) - used, align)))\n \t  /* Here we avoid the case of a structure whose weak alignment\n \t     forces many pushes of a small amount of data,\n \t     and such small pushes do rounding that causes trouble.  */\n@@ -2938,8 +2985,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n \t  /* TEMP is the address of the block.  Copy the data there.  */\n \t  if (GET_CODE (size) == CONST_INT\n-\t      && (move_by_pieces_ninsns ((unsigned) INTVAL (size), align)\n-\t\t  < MOVE_RATIO))\n+\t      && (MOVE_BY_PIECES_P ((unsigned) INTVAL (size), align)))\n \t    {\n \t      move_by_pieces (gen_rtx_MEM (BLKmode, temp), xinner,\n \t\t\t      INTVAL (size), align);\n@@ -6048,10 +6094,9 @@ expand_expr (exp, target, tmode, modifier)\n \t\t     && ! (target != 0 && safe_from_p (target, exp, 1)))\n \t\t    || TREE_ADDRESSABLE (exp)\n \t\t    || (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t\t\t&& (move_by_pieces_ninsns\n-\t\t\t    (TREE_INT_CST_LOW (TYPE_SIZE (type))/BITS_PER_UNIT,\n-\t\t\t     TYPE_ALIGN (type) / BITS_PER_UNIT)\n-\t\t\t    >= MOVE_RATIO)\n+\t\t\t&& (!MOVE_BY_PIECES_P \n+                             (TREE_INT_CST_LOW (TYPE_SIZE (type))/BITS_PER_UNIT,\n+\t\t\t     TYPE_ALIGN (type) / BITS_PER_UNIT))\n \t\t\t&& ! mostly_zeros_p (exp))))\n \t       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))\n \t{"}, {"sha": "2d7cd29a029b206178547cea1ed66b2df34e56e0", "filename": "gcc/tm.texi", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbe1758db29ec4459a0a9bce7827597d37b6523a/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=fbe1758db29ec4459a0a9bce7827597d37b6523a", "patch": "@@ -4754,6 +4754,42 @@ the corresponding number of memory-to-memory @emph{sequences}.\n \n If you don't define this, a reasonable default is used.\n \n+@findex MOVE_BY_PIECES_P\n+@item MOVE_BY_PIECES_P (@var{size}, @var{alignment})\n+A C expression used to determine whether @code{move_by_pieces} will be used to\n+copy a chunk of memory, or whether some other block move mechanism\n+will be used. Defaults to 1 if @code{move_by_pieces_ninsns} returns less\n+than @code{MOVE_RATIO}.\n+\n+@findex MOVE_MAX_PIECES\n+@item MOVE_MAX_PIECES\n+A C expression used by @code{move_by_pieces} to determine the largest unit\n+a load or store used to copy memory is. Defaults to @code{MOVE_MAX}.\n+\n+@findex USE_LOAD_POST_INCREMENT\n+@item USE_LOAD_POST_INCREMENT (@var{mode})\n+A C expression used to determine whether a load postincrement is\n+a good thing for @code{move_by_pieces} to use for a given mode. Defaults\n+to the value of @code{HAVE_POST_INCREMENT}.\n+\n+@findex USE_LOAD_PRE_INCREMENT\n+@item USE_LOAD_PRE_INCREMENT (@var{mode})\n+A C expression used to determine whether a load preincrement is\n+a good thing for @code{move_by_pieces} to use for a given mode. Defaults\n+to the value of @code{HAVE_PRE_INCREMENT}.\n+\n+@findex USE_STORE_POST_INCREMENT\n+@item USE_STORE_POST_INCREMENT (@var{mode})\n+A C expression used to determine whether a store postincrement is\n+a good thing for @code{move_by_pieces} to use for a given mode. Defaults\n+to the value of @code{HAVE_POST_INCREMENT}.\n+\n+@findex USE_STORE_PRE_INCREMENT\n+@item USE_STORE_PRE_INCREMENT (@var{mode})\n+This macro is used to determine whether a store preincrement is\n+a good thing for @code{move_by_pieces} to use for a given mode. Defaults\n+to the value of @code{HAVE_PRE_INCREMENT}.\n+\n @findex NO_FUNCTION_CSE\n @item NO_FUNCTION_CSE\n Define this macro if it is as good or better to call a constant"}]}