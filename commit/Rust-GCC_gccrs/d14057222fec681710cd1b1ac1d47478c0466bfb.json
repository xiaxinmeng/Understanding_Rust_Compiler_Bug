{"sha": "d14057222fec681710cd1b1ac1d47478c0466bfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE0MDU3MjIyZmVjNjgxNzEwY2QxYjFhYzFkNDc0NzhjMDQ2NmJmYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-06T12:39:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-06T12:39:15Z"}, "message": "combine.c (nonzero_bits, case PLUS): If pointers extend unsigned and this is the sum of a pointer and a constant...\n\n\t* combine.c (nonzero_bits, case PLUS): If pointers extend unsigned\n\tand this is the sum of a pointer and a constant, we know the result\n\tdid not overflow.\n\t(num_sign_bit_copies, case PLUS): Likewise.\n\t* explow.c (convert_memory_address): Remove opposite SUBREG.\n\t* function.c (instantiate_new_reg): New function (from common code).\n\t(instantiate_virtual_regs_1): Call it.\n\tFor PLUS, handle if (plus (subreg (virt-reg) (const_int))\n\tif pointers sign- or zero-extend.\n\t* simplify-rtx.c (simplify_unary_operation, case ZERO_EXTEND):\n\tIf pointers extend unsigned, use inside of SUBREG.\n\t(simplify_unary_operation, case SIGN_EXTEND): Likewise, if sign extend.\n\nFrom-SVN: r39489", "tree": {"sha": "ef948bedc788321fdca09d6b2f508f386ee213d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef948bedc788321fdca09d6b2f508f386ee213d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d14057222fec681710cd1b1ac1d47478c0466bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14057222fec681710cd1b1ac1d47478c0466bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d14057222fec681710cd1b1ac1d47478c0466bfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14057222fec681710cd1b1ac1d47478c0466bfb/comments", "author": null, "committer": null, "parents": [{"sha": "a87b4257946d4453f250585aa22adc4f70db1165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87b4257946d4453f250585aa22adc4f70db1165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87b4257946d4453f250585aa22adc4f70db1165"}], "stats": {"total": 168, "additions": 114, "deletions": 54}, "files": [{"sha": "f0c7159456bef9cf0fdb9b4e178f88133db798a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d14057222fec681710cd1b1ac1d47478c0466bfb", "patch": "@@ -1,3 +1,18 @@\n+Mon Feb  5 21:56:16 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* combine.c (nonzero_bits, case PLUS): If pointers extend unsigned\n+\tand this is the sum of a pointer and a constant, we know the result\n+\tdid not overflow.\n+\t(num_sign_bit_copies, case PLUS): Likewise.\n+\t* explow.c (convert_memory_address): Remove opposite SUBREG.\n+\t* function.c (instantiate_new_reg): New function (from common code).\n+\t(instantiate_virtual_regs_1): Call it.\n+\tFor PLUS, handle if (plus (subreg (virt-reg) (const_int))\n+\tif pointers sign- or zero-extend.\n+\t* simplify-rtx.c (simplify_unary_operation, case ZERO_EXTEND):\n+\tIf pointers extend unsigned, use inside of SUBREG.\n+\t(simplify_unary_operation, case SIGN_EXTEND): Likewise, if sign extend.\n+\n 2001-02-05  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* Makefile.in (-DGPLUSPLUS_TOOL_INCLUDE_DIR): Change to target"}, {"sha": "662f05f2240f730770b1a691daca8a04c3e86d0f", "filename": "gcc/combine.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d14057222fec681710cd1b1ac1d47478c0466bfb", "patch": "@@ -8308,6 +8308,16 @@ nonzero_bits (x, mode)\n \n \tif (result_low > 0)\n \t  nonzero &= ~(((HOST_WIDE_INT) 1 << result_low) - 1);\n+\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t/* If pointers extend unsigned and this is an addition or subtraction\n+\t   to a pointer in Pmode, all the bits above ptr_mode are known to be\n+\t   zero.  */\n+\tif (POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n+\t    && (code == PLUS || code == MINUS)\n+\t    && GET_CODE (XEXP (x, 0)) == REG && REG_POINTER (XEXP (x, 0)))\n+\t  nonzero &= GET_MODE_MASK (ptr_mode);\n+#endif\n       }\n       break;\n \n@@ -8646,7 +8656,20 @@ num_sign_bit_copies (x, mode)\n \n       num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n       num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n-      return MAX (1, MIN (num0, num1) - 1);\n+      result = MAX (1, MIN (num0, num1) - 1);\n+\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+      /* If pointers extend signed and this is an addition or subtraction\n+\t to a pointer in Pmode, all the bits above ptr_mode are known to be\n+\t sign bit copies.  */\n+      if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n+\t  && (code == PLUS || code == MINUS)\n+\t  && GET_CODE (XEXP (x, 0)) == REG && REG_POINTER (XEXP (x, 0)))\n+\tresult = MAX ((GET_MODE_BITSIZE (Pmode)\n+\t\t       - GET_MODE_BITSIZE (ptr_mode) + 1),\n+\t\t      result);\n+#endif\n+      return result;\n \n     case MULT:\n       /* The number of bits of the product is the sum of the number of"}, {"sha": "b7c0bb9f6d96970543a97626870dabdffec64b8a", "filename": "gcc/explow.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=d14057222fec681710cd1b1ac1d47478c0466bfb", "patch": "@@ -386,6 +386,11 @@ convert_memory_address (to_mode, x)\n     case CONST_DOUBLE:\n       return x;\n \n+    case SUBREG:\n+      if (GET_MODE (SUBREG_REG (x)) == to_mode)\n+\treturn SUBREG_REG (x);\n+      break;\n+\n     case LABEL_REF:\n       temp = gen_rtx_LABEL_REF (to_mode, XEXP (x, 0));\n       LABEL_REF_NONLOCAL_P (temp) = LABEL_REF_NONLOCAL_P (x);"}, {"sha": "259ccca4fb0e038e81c99b1d18e1ff2c1864f1a9", "filename": "gcc/function.c", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d14057222fec681710cd1b1ac1d47478c0466bfb", "patch": "@@ -269,6 +269,7 @@ static void optimize_bit_field\tPARAMS ((rtx, rtx, rtx *));\n static void instantiate_decls\tPARAMS ((tree, int));\n static void instantiate_decls_1\tPARAMS ((tree, int));\n static void instantiate_decl\tPARAMS ((rtx, HOST_WIDE_INT, int));\n+static rtx instantiate_new_reg\tPARAMS ((rtx, HOST_WIDE_INT *));\n static int instantiate_virtual_regs_1 PARAMS ((rtx *, rtx, int));\n static void delete_handlers\tPARAMS ((void));\n static void pad_to_arg_alignment PARAMS ((struct args_size *, int,\n@@ -3680,6 +3681,35 @@ instantiate_decl (x, size, valid_only)\n   XEXP (x, 0) = addr;\n }\n \f\n+/* Given a piece of RTX and a pointer to a HOST_WIDE_INT, if the RTX\n+   is a virtual register, return the requivalent hard register and set the\n+   offset indirectly through the pointer.  Otherwise, return 0.  */\n+\n+static rtx\n+instantiate_new_reg (x, poffset)\n+     rtx x;\n+     HOST_WIDE_INT *poffset;\n+{\n+  rtx new;\n+  HOST_WIDE_INT offset;\n+\n+  if (x == virtual_incoming_args_rtx)\n+    new = arg_pointer_rtx, offset = in_arg_offset;\n+  else if (x == virtual_stack_vars_rtx)\n+    new = frame_pointer_rtx, offset = var_offset;\n+  else if (x == virtual_stack_dynamic_rtx)\n+    new = stack_pointer_rtx, offset = dynamic_offset;\n+  else if (x == virtual_outgoing_args_rtx)\n+    new = stack_pointer_rtx, offset = out_arg_offset;\n+  else if (x == virtual_cfa_rtx)\n+    new = arg_pointer_rtx, offset = cfa_offset;\n+  else\n+    return 0;\n+\n+  *poffset = offset;\n+  return new;\n+}\n+\f\n /* Given a pointer to a piece of rtx and an optional pointer to the\n    containing object, instantiate any virtual registers present in it.\n \n@@ -3739,21 +3769,14 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t the actual register should receive the source minus the\n \t appropriate offset.  This is used, for example, in the handling\n \t of non-local gotos.  */\n-      if (SET_DEST (x) == virtual_incoming_args_rtx)\n-\tnew = arg_pointer_rtx, offset = -in_arg_offset;\n-      else if (SET_DEST (x) == virtual_stack_vars_rtx)\n-\tnew = frame_pointer_rtx, offset = -var_offset;\n-      else if (SET_DEST (x) == virtual_stack_dynamic_rtx)\n-\tnew = stack_pointer_rtx, offset = -dynamic_offset;\n-      else if (SET_DEST (x) == virtual_outgoing_args_rtx)\n-\tnew = stack_pointer_rtx, offset = -out_arg_offset;\n-      else if (SET_DEST (x) == virtual_cfa_rtx)\n-\tnew = arg_pointer_rtx, offset = -cfa_offset;\n-\n-      if (new)\n+      if ((new = instantiate_new_reg (SET_DEST (x), &offset)) != 0)\n \t{\n \t  rtx src = SET_SRC (x);\n \n+\t  /* We are setting the register, not using it, so the relevant\n+\t     offset is the negative of the offset to use were we using\n+\t     the register.  */\n+\t  offset = - offset;\n \t  instantiate_virtual_regs_1 (&src, NULL_RTX, 0);\n \n \t  /* The only valid sources here are PLUS or REG.  Just do\n@@ -3793,40 +3816,37 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t  /* Check for (plus (plus VIRT foo) (const_int)) first.  */\n \t  if (GET_CODE (XEXP (x, 0)) == PLUS)\n \t    {\n-\t      rtx inner = XEXP (XEXP (x, 0), 0);\n-\n-\t      if (inner == virtual_incoming_args_rtx)\n-\t\tnew = arg_pointer_rtx, offset = in_arg_offset;\n-\t      else if (inner == virtual_stack_vars_rtx)\n-\t\tnew = frame_pointer_rtx, offset = var_offset;\n-\t      else if (inner == virtual_stack_dynamic_rtx)\n-\t\tnew = stack_pointer_rtx, offset = dynamic_offset;\n-\t      else if (inner == virtual_outgoing_args_rtx)\n-\t\tnew = stack_pointer_rtx, offset = out_arg_offset;\n-\t      else if (inner == virtual_cfa_rtx)\n-\t\tnew = arg_pointer_rtx, offset = cfa_offset;\n+\t      if ((new = instantiate_new_reg (XEXP (XEXP (x, 0), 0), &offset)))\n+\t\t{\n+\t\t  instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 1), object,\n+\t\t\t\t\t      extra_insns);\n+\t\t  new = gen_rtx_PLUS (Pmode, new, XEXP (XEXP (x, 0), 1));\n+\t\t}\n \t      else\n \t\t{\n \t\t  loc = &XEXP (x, 0);\n \t\t  goto restart;\n \t\t}\n-\n-\t      instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 1), object,\n-\t\t\t\t\t  extra_insns);\n-\t      new = gen_rtx_PLUS (Pmode, new, XEXP (XEXP (x, 0), 1));\n \t    }\n \n-\t  else if (XEXP (x, 0) == virtual_incoming_args_rtx)\n-\t    new = arg_pointer_rtx, offset = in_arg_offset;\n-\t  else if (XEXP (x, 0) == virtual_stack_vars_rtx)\n-\t    new = frame_pointer_rtx, offset = var_offset;\n-\t  else if (XEXP (x, 0) == virtual_stack_dynamic_rtx)\n-\t    new = stack_pointer_rtx, offset = dynamic_offset;\n-\t  else if (XEXP (x, 0) == virtual_outgoing_args_rtx)\n-\t    new = stack_pointer_rtx, offset = out_arg_offset;\n-\t  else if (XEXP (x, 0) == virtual_cfa_rtx)\n-\t    new = arg_pointer_rtx, offset = cfa_offset;\n-\t  else\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t  /* If we have (plus (subreg (virtual-reg)) (const_int)), we know\n+\t     we can commute the PLUS and SUBREG because pointers into the\n+\t     frame are well-behaved.  */\n+\t  else if (GET_CODE (XEXP (x, 0)) == SUBREG && GET_MODE (x) == ptr_mode\n+\t\t   && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t   && 0 != (new\n+\t\t\t    = instantiate_new_reg (SUBREG_REG (XEXP (x, 0)),\n+\t\t\t\t\t\t   &offset))\n+\t\t   && validate_change (object, loc,\n+\t\t\t\t       plus_constant (gen_lowpart (ptr_mode,\n+\t\t\t\t\t\t\t\t   new),\n+\t\t\t\t\t\t      offset\n+\t\t\t\t\t\t      + INTVAL (XEXP (x, 1))),\n+\t\t\t\t       0))\n+\t\treturn 1;\n+#endif\n+\t  else if ((new = instantiate_new_reg (XEXP (x, 0), &offset)) == 0)\n \t    {\n \t      /* We know the second operand is a constant.  Unless the\n \t\t first operand is a REG (which has been already checked),\n@@ -4025,18 +4045,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n     case REG:\n       /* Try to replace with a PLUS.  If that doesn't work, compute the sum\n \t in front of this insn and substitute the temporary.  */\n-      if (x == virtual_incoming_args_rtx)\n-\tnew = arg_pointer_rtx, offset = in_arg_offset;\n-      else if (x == virtual_stack_vars_rtx)\n-\tnew = frame_pointer_rtx, offset = var_offset;\n-      else if (x == virtual_stack_dynamic_rtx)\n-\tnew = stack_pointer_rtx, offset = dynamic_offset;\n-      else if (x == virtual_outgoing_args_rtx)\n-\tnew = stack_pointer_rtx, offset = out_arg_offset;\n-      else if (x == virtual_cfa_rtx)\n-\tnew = arg_pointer_rtx, offset = cfa_offset;\n-\n-      if (new)\n+      if ((new = instantiate_new_reg (x, &offset)) != 0)\n \t{\n \t  temp = plus_constant (new, offset);\n \t  if (!validate_change (object, loc, temp, 0))"}, {"sha": "afd8d264b62500d66b741aa04bbc7de30b3adf9b", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14057222fec681710cd1b1ac1d47478c0466bfb/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=d14057222fec681710cd1b1ac1d47478c0466bfb", "patch": "@@ -623,7 +623,11 @@ simplify_unary_operation (code, mode, op, op_mode)\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (! POINTERS_EXTEND_UNSIGNED\n \t      && mode == Pmode && GET_MODE (op) == ptr_mode\n-\t      && CONSTANT_P (op))\n+\t      && (CONSTANT_P (op)\n+\t\t  || (GET_CODE (op) == SUBREG\n+\t\t      && GET_CODE (SUBREG_REG (op)) == REG\n+\t\t      && REG_POINTER (SUBREG_REG (op))\n+\t\t      && GET_MODE (SUBREG_REG (op)) == Pmode)))\n \t    return convert_memory_address (Pmode, op);\n #endif\n \t  break;\n@@ -632,7 +636,11 @@ simplify_unary_operation (code, mode, op, op_mode)\n \tcase ZERO_EXTEND:\n \t  if (POINTERS_EXTEND_UNSIGNED\n \t      && mode == Pmode && GET_MODE (op) == ptr_mode\n-\t      && CONSTANT_P (op))\n+\t      && (CONSTANT_P (op)\n+\t\t  || (GET_CODE (op) == SUBREG\n+\t\t      && GET_CODE (SUBREG_REG (op)) == REG\n+\t\t      && REG_POINTER (SUBREG_REG (op))\n+\t\t      && GET_MODE (SUBREG_REG (op)) == Pmode)))\n \t    return convert_memory_address (Pmode, op);\n \t  break;\n #endif"}]}