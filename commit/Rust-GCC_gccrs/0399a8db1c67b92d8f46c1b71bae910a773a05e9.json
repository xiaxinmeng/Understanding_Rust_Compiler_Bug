{"sha": "0399a8db1c67b92d8f46c1b71bae910a773a05e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM5OWE4ZGIxYzY3YjkyZDhmNDZjMWI3MWJhZTkxMGE3NzNhMDVlOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-01-16T13:21:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-01-16T13:21:11Z"}, "message": "re PR middle-end/64568 (error: invalid reference prefix)\n\n2015-01-16  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/64568\n\t* tree-ssa-forwprop.c (pass_forwprop::execute): Guard\n\tcomplex load rewriting for TARGET_MEM_REFs.\n\n\t* g++.dg/torture/pr64568-2.C: New testcase.\n\nFrom-SVN: r219736", "tree": {"sha": "ce8ca9cf40876e7e528d54e27b6478f01da17163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce8ca9cf40876e7e528d54e27b6478f01da17163"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0399a8db1c67b92d8f46c1b71bae910a773a05e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0399a8db1c67b92d8f46c1b71bae910a773a05e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0399a8db1c67b92d8f46c1b71bae910a773a05e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0399a8db1c67b92d8f46c1b71bae910a773a05e9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a1dcf27473f87a94d374238362300f88f4cd7ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1dcf27473f87a94d374238362300f88f4cd7ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1dcf27473f87a94d374238362300f88f4cd7ed"}], "stats": {"total": 159, "additions": 159, "deletions": 0}, "files": [{"sha": "c9a70702d522fc4e1991d0dbab59f814f0f21630", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0399a8db1c67b92d8f46c1b71bae910a773a05e9", "patch": "@@ -1,3 +1,9 @@\n+2015-01-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64568\n+\t* tree-ssa-forwprop.c (pass_forwprop::execute): Guard\n+\tcomplex load rewriting for TARGET_MEM_REFs.\n+\n 2015-01-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* builtins.c (expand_builtin_acc_on_device): Check target for NULL."}, {"sha": "81645b11cae7e46ecd64be7d810fc5129a3c611e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0399a8db1c67b92d8f46c1b71bae910a773a05e9", "patch": "@@ -1,3 +1,8 @@\n+2015-01-16  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/64568\n+\t* g++.dg/torture/pr64568-2.C: New testcase.\n+\n 2015-01-16  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \tPR target/64363"}, {"sha": "0578217900845b061786152b7a2131a3ec2af126", "filename": "gcc/testsuite/g++.dg/torture/pr64568-2.C", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64568-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64568-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr64568-2.C?ref=0399a8db1c67b92d8f46c1b71bae910a773a05e9", "patch": "@@ -0,0 +1,146 @@\n+// { dg-do compile }\n+\n+namespace std\n+{\n+  typedef __SIZE_TYPE__ size_t;\n+}\n+class H;\n+namespace std\n+{\n+  template <typename> struct complex;\n+  template <typename _Tp>\n+      complex<_Tp> operator+(complex<_Tp> &__x, complex<_Tp> __y)\n+\t{\n+\t  complex<_Tp> a = __x;\n+\t  a += __y;\n+\t  return a;\n+\t}\n+  template <> struct complex<double>\n+    {\n+      int\n+\t  imag ()\n+\t    {\n+\t      return __imag__ _M_value;\n+\t    }\n+      void operator+=(complex __z) { _M_value += _M_value; _M_value  += __z.imag (); }\n+      _Complex double _M_value;\n+    };\n+}\n+struct A\n+{\n+  typedef std::complex<double> &const_reference;\n+};\n+class B\n+{\n+public:\n+    B (int);\n+    std::complex<double> &operator[](int i) { return data_[i]; }\n+    std::complex<double> *data_;\n+};\n+struct C\n+{\n+  static std::complex<double>\n+      apply (A::const_reference t1, std::complex<double> t2)\n+\t{\n+\t  return t1 + t2;\n+\t}\n+  typedef std::complex<double> result_type;\n+};\n+template <class T1, class> struct D\n+{\n+  static void\n+      apply (T1 t1, std::complex<double> t2)\n+\t{\n+\t  t1 = t2;\n+\t}\n+};\n+class ublas_expression\n+{\n+public:\n+    ~ublas_expression ();\n+};\n+template <class> class F\n+{\n+};\n+template <class E> class matrix_expression : ublas_expression\n+{\n+public:\n+    E &operator()() {}\n+};\n+class I : public F<int>\n+{\n+public:\n+    typedef int value_type;\n+    I (int);\n+};\n+template <class E1, class E2> matrix_expression<int> outer_prod (F<E1>, F<E2>);\n+template <class E1, class F> class J : public matrix_expression<J<E1, F> >\n+{\n+public:\n+    typedef typename F::result_type value_type;\n+    value_type operator()(int i, int)\n+      {\n+\treturn F::apply (e1_ (i, 0), e2_ (0, 0));\n+      }\n+    E1 e1_;\n+    E1 e2_;\n+};\n+template <class E1, class E2>\n+J<H, C> operator+(matrix_expression<E1>, matrix_expression<E2>);\n+template <template <class, class> class F, class M, class E>\n+void\n+indexing_matrix_assign (M m, matrix_expression<E> e, int)\n+{\n+  for (int i; i; ++i)\n+    F<typename M::reference, typename E::value_type>::apply (m (0, 0),\n+\t\t\t\t\t\t\t     e ()(i, 0));\n+}\n+template <template <class, class> class F, class, class M, class E, class C>\n+void\n+matrix_assign (M m, matrix_expression<E> e, int, C)\n+{\n+  indexing_matrix_assign<F> (m, e, 0);\n+}\n+template <template <class, class> class F, class M, class E>\n+void\n+matrix_assign (M m, matrix_expression<E> e)\n+{\n+  matrix_assign<F, int> (m, e, 0, typename M::orientation_category ());\n+}\n+class H : matrix_expression<int>\n+{\n+public:\n+    typedef std::complex<double> &reference;\n+    typedef int orientation_category;\n+    H (int, int) : data_ (0) {}\n+    template <class AE> H (matrix_expression<AE> ae) : data_ (0)\n+  {\n+    matrix_assign<D> (*this, ae);\n+  }\n+    B &\n+\tdata ()\n+\t  {\n+\t  }\n+    std::complex<double> &operator()(int i, int) { return data ()[i]; }\n+    void operator+=(matrix_expression ae) { H (*this + ae); }\n+    B data_;\n+};\n+template <class M, class T, class V1, class V2>\n+void\n+sr2 (M m, T, V1 v1, V2 v2)\n+{\n+  m += outer_prod (v2, v1);\n+}\n+template <class, class, std::size_t> struct G\n+{\n+  void test ();\n+};\n+template struct G<I, H, 3>;\n+template <class V, class M, std::size_t N>\n+void\n+G<V, M, N>::test ()\n+{\n+  V b (0), c (0);\n+  M m (0, 0);\n+  sr2 (m, typename V::value_type (), b, c);\n+}"}, {"sha": "82d832d475484e352eaf3a0a8cf55bd7e897f56c", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0399a8db1c67b92d8f46c1b71bae910a773a05e9/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=0399a8db1c67b92d8f46c1b71bae910a773a05e9", "patch": "@@ -2230,6 +2230,8 @@ pass_forwprop::execute (function *fun)\n \t  else if (TREE_CODE (TREE_TYPE (lhs)) == COMPLEX_TYPE\n \t\t   && gimple_assign_load_p (stmt)\n \t\t   && !gimple_has_volatile_ops (stmt)\n+\t\t   && (TREE_CODE (gimple_assign_rhs1 (stmt))\n+\t\t       != TARGET_MEM_REF)\n \t\t   && !stmt_can_throw_internal (stmt))\n \t    {\n \t      /* Rewrite loads used only in real/imagpart extractions to"}]}