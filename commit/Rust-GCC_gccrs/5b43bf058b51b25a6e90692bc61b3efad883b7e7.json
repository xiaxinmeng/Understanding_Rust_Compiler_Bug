{"sha": "5b43bf058b51b25a6e90692bc61b3efad883b7e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0M2JmMDU4YjUxYjI1YTZlOTA2OTJiYzYxYjNlZmFkODgzYjdlNw==", "commit": {"author": {"name": "Hariharan Sandanagobalane", "email": "hariharan@picochip.com", "date": "2009-02-04T16:17:47Z"}, "committer": {"name": "Hariharan Sandanagobalane", "email": "hariharans@gcc.gnu.org", "date": "2009-02-04T16:17:47Z"}, "message": "picochip.c (GO_IF_LEGITIMATE_ADDRESS): Disallow non-indexable addresses even before reload.\n\n        * config/picochip/picochip.c (GO_IF_LEGITIMATE_ADDRESS): Disallow\n          non-indexable addresses even before reload.\n\nFrom-SVN: r143929", "tree": {"sha": "c23ecf0172ace4c94e988440c80873a057c4dd6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23ecf0172ace4c94e988440c80873a057c4dd6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b43bf058b51b25a6e90692bc61b3efad883b7e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b43bf058b51b25a6e90692bc61b3efad883b7e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b43bf058b51b25a6e90692bc61b3efad883b7e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b43bf058b51b25a6e90692bc61b3efad883b7e7/comments", "author": null, "committer": null, "parents": [{"sha": "062c4bb37ac6f2af6753060d8f8db5230bc18b49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062c4bb37ac6f2af6753060d8f8db5230bc18b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062c4bb37ac6f2af6753060d8f8db5230bc18b49"}], "stats": {"total": 21, "additions": 12, "deletions": 9}, "files": [{"sha": "a13903c89f06ddde6c6f49aecf5cd27ef83a4316", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43bf058b51b25a6e90692bc61b3efad883b7e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43bf058b51b25a6e90692bc61b3efad883b7e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b43bf058b51b25a6e90692bc61b3efad883b7e7", "patch": "@@ -1,3 +1,8 @@\n+2009-02-04  Hariharan Sandanagobalane  <hariharan@picochip.com>\n+\n+\t* config/picochip/picochip.c (GO_IF_LEGITIMATE_ADDRESS): Disallow\n+\tnon-indexable addresses even before reload.\n+\n 2009-02-03  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/29129"}, {"sha": "066765661a9aef4f4f5b98f1c6956bfc19bf2f8d", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b43bf058b51b25a6e90692bc61b3efad883b7e7/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b43bf058b51b25a6e90692bc61b3efad883b7e7/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=5b43bf058b51b25a6e90692bc61b3efad883b7e7", "patch": "@@ -1200,26 +1200,24 @@ picochip_legitimate_address_register (rtx x, unsigned strict)\n /* Determine whether the given constant is in the range required for\n    the given base register. */\n static int\n-picochip_const_ok_for_base (enum machine_mode mode, int regno, int offset,\n-                            int strict)\n+picochip_const_ok_for_base (enum machine_mode mode, int regno, int offset)\n {\n   HOST_WIDE_INT corrected_offset;\n \n   if (GET_MODE_SIZE (mode) != 0)\n     {\n       if (GET_MODE_SIZE(mode) <= 4)\n       {\n-         /* We can allow incorrect offsets if strict is 0. If strict is 1,\n-            we are in reload and these memory accesses need to be changed. */\n-         if (offset % GET_MODE_SIZE (mode) != 0 && strict == 1)\n+         /* We used to allow incorrect offsets if strict is 0. But, this would\n+            then rely on reload doing the right thing. We have had problems\n+            there before, and on > 4.3 compiler, there are no benefits. */\n+         if (offset % GET_MODE_SIZE (mode) != 0)\n            return 0;\n          corrected_offset = offset / GET_MODE_SIZE (mode);\n       }\n       else\n       {\n-         /* We can allow incorrect offsets if strict is 0. If strict is 1,\n-            we are in reload and these memory accesses need to be changed. */\n-         if (offset % 4 != 0 && strict == 1)\n+         if (offset % 4 != 0)\n            return 0;\n          corrected_offset = offset / 4;\n       }\n@@ -1272,7 +1270,7 @@ picochip_legitimate_address_p (int mode, rtx x, unsigned strict)\n \t\t picochip_legitimate_address_register (base, strict) &&\n \t\t CONST_INT == GET_CODE (offset) &&\n \t\t picochip_const_ok_for_base (mode, REGNO (base),\n-\t\t\t\t\t     INTVAL (offset),strict));\n+\t\t\t\t\t     INTVAL (offset)));\n \tbreak;\n       }\n "}]}