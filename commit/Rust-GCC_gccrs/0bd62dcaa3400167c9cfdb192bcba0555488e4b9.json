{"sha": "0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJkNjJkY2FhMzQwMDE2N2M5Y2ZkYjE5MmJjYmEwNTU1NDg4ZTRiOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-06-06T21:38:25Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-06-06T21:38:25Z"}, "message": "extend.texi (PowerPC AltiVec/VSX Built-in Functions): Document new power8 builtins.\n\n[gcc]\n2013-06-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Pat Haugen <pthaugen@us.ibm.com>\n\t    Peter Bergner <bergner@vnet.ibm.com>\n\n\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n\tDocument new power8 builtins.\n\n\t* config/rs6000/vector.md (and<mode>3): Add a clobber/scratch of a\n\tcondition code register, to allow 128-bit logical operations to be\n\tdone in the VSX or GPR registers.\n\t(nor<mode>3): Use the canonical form for nor.\n\t(eqv<mode>3): Add expanders for power8 xxleqv, xxlnand, xxlorc,\n\tvclz*, and vpopcnt* vector instructions.\n\t(nand<mode>3): Likewise.\n\t(orc<mode>3): Likewise.\n\t(clz<mode>2): LIkewise.\n\t(popcount<mode>2): Likewise.\n\n\t* config/rs6000/predicates.md (int_reg_operand): Rework tests so\n\tthat only the GPRs are recognized.\n\n\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n\tsupport for new power8 builtins.\n\n\t* config/rs6000/rs6000-builtin.def (xscvspdpn): Add new power8\n\tbuiltin functions.\n\t(xscvdpspn): Likewise.\n\t(vclz): Likewise.\n\t(vclzb): Likewise.\n\t(vclzh): Likewise.\n\t(vclzw): Likewise.\n\t(vclzd): Likewise.\n\t(vpopcnt): Likewise.\n\t(vpopcntb): Likewise.\n\t(vpopcnth): Likewise.\n\t(vpopcntw): Likewise.\n\t(vpopcntd): Likewise.\n\t(vgbbd): Likewise.\n\t(vmrgew): Likewise.\n\t(vmrgow): Likewise.\n\t(eqv): Likewise.\n\t(eqv_v16qi3): Likewise.\n\t(eqv_v8hi3): Likewise.\n\t(eqv_v4si3): Likewise.\n\t(eqv_v2di3): Likewise.\n\t(eqv_v4sf3): Likewise.\n\t(eqv_v2df3): Likewise.\n\t(nand): Likewise.\n\t(nand_v16qi3): Likewise.\n\t(nand_v8hi3): Likewise.\n\t(nand_v4si3): Likewise.\n\t(nand_v2di3): Likewise.\n\t(nand_v4sf3): Likewise.\n\t(nand_v2df3): Likewise.\n\t(orc): Likewise.\n\t(orc_v16qi3): Likewise.\n\t(orc_v8hi3): Likewise.\n\t(orc_v4si3): Likewise.\n\t(orc_v2di3): Likewise.\n\t(orc_v4sf3): Likewise.\n\t(orc_v2df3): Likewise.\n\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Only\n\tallow power8 quad mode in 64-bit.\n\t(rs6000_builtin_vectorized_function): Add support to vectorize\n\tISA 2.07 count leading zeros, population count builtins.\n\t(rs6000_expand_vector_init): On ISA 2.07 use xscvdpspn to form\n\tV4SF vectors instead of xscvdpsp to avoid IEEE related traps.\n\t(builtin_function_type): Add vgbbd builtin function which takes an\n\tunsigned argument.\n\t(altivec_expand_vec_perm_const): Add support for new power8 merge\n\tinstructions.\n\n\t* config/rs6000/vsx.md (VSX_L2): New iterator for 128-bit types,\n\tthat does not include TImdoe for use with 32-bit.\n\t(UNSPEC_VSX_CVSPDPN): Support for power8 xscvdpspn and xscvspdpn\n\tinstructions.\n\t(UNSPEC_VSX_CVDPSPN): Likewise.\n\t(vsx_xscvdpspn): Likewise.\n\t(vsx_xscvspdpn): Likewise.\n\t(vsx_xscvdpspn_scalar): Likewise.\n\t(vsx_xscvspdpn_directmove): Likewise.\n\t(vsx_and<mode>3): Split logical operations into 32-bit and\n\t64-bit. Add support to do logical operations on TImode as well as\n\tVSX vector types.  Allow logical operations to be done in either\n\tVSX registers or in general purpose registers in 64-bit mode.  Add\n\tsplitters if GPRs were used. For AND, add clobber of CCmode to\n\tallow use of ANDI on GPRs.  Rewrite nor to use the canonical RTL\n\tencoding.\n\t(vsx_and<mode>3_32bit): Likewise.\n\t(vsx_and<mode>3_64bit): Likewise.\n\t(vsx_ior<mode>3): Likewise.\n\t(vsx_ior<mode>3_32bit): Likewise.\n\t(vsx_ior<mode>3_64bit): Likewise.\n\t(vsx_xor<mode>3): Likewise.\n\t(vsx_xor<mode>3_32bit): Likewise.\n\t(vsx_xor<mode>3_64bit): Likewise.\n\t(vsx_one_cmpl<mode>2): Likewise.\n\t(vsx_one_cmpl<mode>2_32bit): Likewise.\n\t(vsx_one_cmpl<mode>2_64bit): Likewise.\n\t(vsx_nor<mode>3): Likewise.\n\t(vsx_nor<mode>3_32bit): Likewise.\n\t(vsx_nor<mode>3_64bit): Likewise.\n\t(vsx_andc<mode>3): Likewise.\n\t(vsx_andc<mode>3_32bit): Likewise.\n\t(vsx_andc<mode>3_64bit): Likewise.\n\t(vsx_eqv<mode>3_32bit): Add support for power8 xxleqv, xxlnand,\n\tand xxlorc instructions.\n\t(vsx_eqv<mode>3_64bit): Likewise.\n\t(vsx_nand<mode>3_32bit): Likewise.\n\t(vsx_nand<mode>3_64bit): Likewise.\n\t(vsx_orc<mode>3_32bit): Likewise.\n\t(vsx_orc<mode>3_64bit): Likewise.\n\n\t* config/rs6000/rs6000.h (VLOGICAL_REGNO_P): Update comment.\n\n\t* config/rs6000/altivec.md (UNSPEC_VGBBD): Add power8 vgbbd\n\tinstruction.\n\t(p8_vmrgew): Add power8 vmrgew and vmrgow instructions.\n\t(p8_vmrgow): Likewise.\n\t(altivec_and<mode>3): Add clobber of CCmode to allow AND using\n\tGPRs to be split under VSX.\n\t(p8v_clz<mode>2): Add power8 count leading zero support.\n\t(p8v_popcount<mode>2): Add power8 population count support.\n\t(p8v_vgbbd): Add power8 gather bits by bytes by doubleword\n\tsupport.\n\n\t* config/rs6000/rs6000.md (eqv<mode>3): Add support for powerp eqv\n\tinstruction.\n\n\t* config/rs6000/altivec.h (vec_eqv): Add defines to export power8\n\tbuiltin functions.\n\t(vec_nand): Likewise.\n\t(vec_vclz): Likewise.\n\t(vec_vclzb): Likewise.\n\t(vec_vclzd): Likewise.\n\t(vec_vclzh): Likewise.\n\t(vec_vclzw): Likewise.\n\t(vec_vgbbd): Likewise.\n\t(vec_vmrgew): Likewise.\n\t(vec_vmrgow): Likewise.\n\t(vec_vpopcnt): Likewise.\n\t(vec_vpopcntb): Likewise.\n\t(vec_vpopcntd): Likewise.\n\t(vec_vpopcnth): Likewise.\n\t(vec_vpopcntw): Likewise.\n\n[gcc/testsuite]\n2013-06-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Pat Haugen <pthaugen@us.ibm.com>\n\t    Peter Bergner <bergner@vnet.ibm.com>\n\n\t* gcc.target/powerpc/crypto-builtin-1.c: Use effective target\n\tpowerpc_p8vector_ok instead of powerpc_vsx_ok.\n\n\t* gcc.target/powerpc/bool.c: New file, add eqv, nand, nor tests.\n\n\t* lib/target-supports.exp (check_p8vector_hw_available) Add power8\n\tsupport.\n\t(check_effective_target_powerpc_p8vector_ok): Likewise.\n\t(is-effective-target): Likewise.\n\t(check_vect_support_and_set_flags): Likewise.\n\n\n\nCo-Authored-By: Pat Haugen <pthaugen@us.ibm.com>\nCo-Authored-By: Peter Bergner <bergner@vnet.ibm.com>\n\nFrom-SVN: r199767", "tree": {"sha": "8a800ff7feaa2dbff8224b96ed3c550c8d468a2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a800ff7feaa2dbff8224b96ed3c550c8d468a2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/comments", "author": null, "committer": null, "parents": [{"sha": "76ba1222c5014b8f2d16efcd9696666b162a537a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76ba1222c5014b8f2d16efcd9696666b162a537a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76ba1222c5014b8f2d16efcd9696666b162a537a"}], "stats": {"total": 1497, "additions": 1420, "deletions": 77}, "files": [{"sha": "9bff304fed5c29702c2ec0c2ad0f23427d6d6f7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -1,3 +1,150 @@\n+2013-06-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen <pthaugen@us.ibm.com>\n+\t    Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n+\tDocument new power8 builtins.\n+\n+\t* config/rs6000/vector.md (and<mode>3): Add a clobber/scratch of a\n+\tcondition code register, to allow 128-bit logical operations to be\n+\tdone in the VSX or GPR registers.\n+\t(nor<mode>3): Use the canonical form for nor.\n+\t(eqv<mode>3): Add expanders for power8 xxleqv, xxlnand, xxlorc,\n+\tvclz*, and vpopcnt* vector instructions.\n+\t(nand<mode>3): Likewise.\n+\t(orc<mode>3): Likewise.\n+\t(clz<mode>2): LIkewise.\n+\t(popcount<mode>2): Likewise.\n+\n+\t* config/rs6000/predicates.md (int_reg_operand): Rework tests so\n+\tthat only the GPRs are recognized.\n+\n+\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n+\tsupport for new power8 builtins.\n+\n+\t* config/rs6000/rs6000-builtin.def (xscvspdpn): Add new power8\n+\tbuiltin functions.\n+\t(xscvdpspn): Likewise.\n+\t(vclz): Likewise.\n+\t(vclzb): Likewise.\n+\t(vclzh): Likewise.\n+\t(vclzw): Likewise.\n+\t(vclzd): Likewise.\n+\t(vpopcnt): Likewise.\n+\t(vpopcntb): Likewise.\n+\t(vpopcnth): Likewise.\n+\t(vpopcntw): Likewise.\n+\t(vpopcntd): Likewise.\n+\t(vgbbd): Likewise.\n+\t(vmrgew): Likewise.\n+\t(vmrgow): Likewise.\n+\t(eqv): Likewise.\n+\t(eqv_v16qi3): Likewise.\n+\t(eqv_v8hi3): Likewise.\n+\t(eqv_v4si3): Likewise.\n+\t(eqv_v2di3): Likewise.\n+\t(eqv_v4sf3): Likewise.\n+\t(eqv_v2df3): Likewise.\n+\t(nand): Likewise.\n+\t(nand_v16qi3): Likewise.\n+\t(nand_v8hi3): Likewise.\n+\t(nand_v4si3): Likewise.\n+\t(nand_v2di3): Likewise.\n+\t(nand_v4sf3): Likewise.\n+\t(nand_v2df3): Likewise.\n+\t(orc): Likewise.\n+\t(orc_v16qi3): Likewise.\n+\t(orc_v8hi3): Likewise.\n+\t(orc_v4si3): Likewise.\n+\t(orc_v2di3): Likewise.\n+\t(orc_v4sf3): Likewise.\n+\t(orc_v2df3): Likewise.\n+\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Only\n+\tallow power8 quad mode in 64-bit.\n+\t(rs6000_builtin_vectorized_function): Add support to vectorize\n+\tISA 2.07 count leading zeros, population count builtins.\n+\t(rs6000_expand_vector_init): On ISA 2.07 use xscvdpspn to form\n+\tV4SF vectors instead of xscvdpsp to avoid IEEE related traps.\n+\t(builtin_function_type): Add vgbbd builtin function which takes an\n+\tunsigned argument.\n+\t(altivec_expand_vec_perm_const): Add support for new power8 merge\n+\tinstructions.\n+\n+\t* config/rs6000/vsx.md (VSX_L2): New iterator for 128-bit types,\n+\tthat does not include TImdoe for use with 32-bit.\n+\t(UNSPEC_VSX_CVSPDPN): Support for power8 xscvdpspn and xscvspdpn\n+\tinstructions.\n+\t(UNSPEC_VSX_CVDPSPN): Likewise.\n+\t(vsx_xscvdpspn): Likewise.\n+\t(vsx_xscvspdpn): Likewise.\n+\t(vsx_xscvdpspn_scalar): Likewise.\n+\t(vsx_xscvspdpn_directmove): Likewise.\n+\t(vsx_and<mode>3): Split logical operations into 32-bit and\n+\t64-bit. Add support to do logical operations on TImode as well as\n+\tVSX vector types.  Allow logical operations to be done in either\n+\tVSX registers or in general purpose registers in 64-bit mode.  Add\n+\tsplitters if GPRs were used. For AND, add clobber of CCmode to\n+\tallow use of ANDI on GPRs.  Rewrite nor to use the canonical RTL\n+\tencoding.\n+\t(vsx_and<mode>3_32bit): Likewise.\n+\t(vsx_and<mode>3_64bit): Likewise.\n+\t(vsx_ior<mode>3): Likewise.\n+\t(vsx_ior<mode>3_32bit): Likewise.\n+\t(vsx_ior<mode>3_64bit): Likewise.\n+\t(vsx_xor<mode>3): Likewise.\n+\t(vsx_xor<mode>3_32bit): Likewise.\n+\t(vsx_xor<mode>3_64bit): Likewise.\n+\t(vsx_one_cmpl<mode>2): Likewise.\n+\t(vsx_one_cmpl<mode>2_32bit): Likewise.\n+\t(vsx_one_cmpl<mode>2_64bit): Likewise.\n+\t(vsx_nor<mode>3): Likewise.\n+\t(vsx_nor<mode>3_32bit): Likewise.\n+\t(vsx_nor<mode>3_64bit): Likewise.\n+\t(vsx_andc<mode>3): Likewise.\n+\t(vsx_andc<mode>3_32bit): Likewise.\n+\t(vsx_andc<mode>3_64bit): Likewise.\n+\t(vsx_eqv<mode>3_32bit): Add support for power8 xxleqv, xxlnand,\n+\tand xxlorc instructions.\n+\t(vsx_eqv<mode>3_64bit): Likewise.\n+\t(vsx_nand<mode>3_32bit): Likewise.\n+\t(vsx_nand<mode>3_64bit): Likewise.\n+\t(vsx_orc<mode>3_32bit): Likewise.\n+\t(vsx_orc<mode>3_64bit): Likewise.\n+\n+\t* config/rs6000/rs6000.h (VLOGICAL_REGNO_P): Update comment.\n+\n+\t* config/rs6000/altivec.md (UNSPEC_VGBBD): Add power8 vgbbd\n+\tinstruction.\n+\t(p8_vmrgew): Add power8 vmrgew and vmrgow instructions.\n+\t(p8_vmrgow): Likewise.\n+\t(altivec_and<mode>3): Add clobber of CCmode to allow AND using\n+\tGPRs to be split under VSX.\n+\t(p8v_clz<mode>2): Add power8 count leading zero support.\n+\t(p8v_popcount<mode>2): Add power8 population count support.\n+\t(p8v_vgbbd): Add power8 gather bits by bytes by doubleword\n+\tsupport.\n+\n+\t* config/rs6000/rs6000.md (eqv<mode>3): Add support for powerp eqv\n+\tinstruction.\n+\n+\t* config/rs6000/altivec.h (vec_eqv): Add defines to export power8\n+\tbuiltin functions.\n+\t(vec_nand): Likewise.\n+\t(vec_vclz): Likewise.\n+\t(vec_vclzb): Likewise.\n+\t(vec_vclzd): Likewise.\n+\t(vec_vclzh): Likewise.\n+\t(vec_vclzw): Likewise.\n+\t(vec_vgbbd): Likewise.\n+\t(vec_vmrgew): Likewise.\n+\t(vec_vmrgow): Likewise.\n+\t(vec_vpopcnt): Likewise.\n+\t(vec_vpopcntb): Likewise.\n+\t(vec_vpopcntd): Likewise.\n+\t(vec_vpopcnth): Likewise.\n+\t(vec_vpopcntw): Likewise.\n+\n 2013-06-06  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/57468"}, {"sha": "4b91c5c5e2422db4f3b0ada2a6a575d07cfebef9", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -323,15 +323,31 @@\n \n #ifdef _ARCH_PWR8\n /* Vector additions added in ISA 2.07.  */\n+#define vec_eqv __builtin_vec_eqv\n+#define vec_nand __builtin_vec_nand\n+#define vec_orc __builtin_vec_orc\n #define vec_vaddudm __builtin_vec_vaddudm\n+#define vec_vclz __builtin_vec_vclz\n+#define vec_vclzb __builtin_vec_vclzb\n+#define vec_vclzd __builtin_vec_vclzd\n+#define vec_vclzh __builtin_vec_vclzh\n+#define vec_vclzw __builtin_vec_vclzw\n+#define vec_vgbbd __builtin_vec_vgbbd\n #define vec_vmaxsd __builtin_vec_vmaxsd\n #define vec_vmaxud __builtin_vec_vmaxud\n #define vec_vminsd __builtin_vec_vminsd\n #define vec_vminud __builtin_vec_vminud\n+#define vec_vmrgew __builtin_vec_vmrgew\n+#define vec_vmrgow __builtin_vec_vmrgow\n #define vec_vpksdss __builtin_vec_vpksdss\n #define vec_vpksdus __builtin_vec_vpksdus\n #define vec_vpkudum __builtin_vec_vpkudum\n #define vec_vpkudus __builtin_vec_vpkudus\n+#define vec_vpopcnt __builtin_vec_vpopcnt\n+#define vec_vpopcntb __builtin_vec_vpopcntb\n+#define vec_vpopcntd __builtin_vec_vpopcntd\n+#define vec_vpopcnth __builtin_vec_vpopcnth\n+#define vec_vpopcntw __builtin_vec_vpopcntw\n #define vec_vrld __builtin_vec_vrld\n #define vec_vsld __builtin_vec_vsld\n #define vec_vsrad __builtin_vec_vsrad"}, {"sha": "6607e450be3289f00c6d7b361767d0b6cf0dfcc7", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -128,6 +128,7 @@\n    UNSPEC_VUPKLS_V4SF\n    UNSPEC_VUPKHU_V4SF\n    UNSPEC_VUPKLU_V4SF\n+   UNSPEC_VGBBD\n ])\n \n (define_c_enum \"unspecv\"\n@@ -941,6 +942,31 @@\n   \"vmrglw %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n+;; Power8 vector merge even/odd\n+(define_insn \"p8_vmrgew\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+\t(vec_select:V4SI\n+\t  (vec_concat:V8SI\n+\t    (match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t    (match_operand:V4SI 2 \"register_operand\" \"v\"))\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 2) (const_int 6)])))]\n+  \"TARGET_P8_VECTOR\"\n+  \"vmrgew %0,%1,%2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"p8_vmrgow\"\n+  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+\t(vec_select:V4SI\n+\t  (vec_concat:V8SI\n+\t    (match_operand:V4SI 1 \"register_operand\" \"v\")\n+\t    (match_operand:V4SI 2 \"register_operand\" \"v\"))\n+\t  (parallel [(const_int 1) (const_int 5)\n+\t\t     (const_int 3) (const_int 7)])))]\n+  \"TARGET_P8_VECTOR\"\n+  \"vmrgow %0,%1,%2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n (define_insn \"vec_widen_umult_even_v16qi\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n@@ -1017,10 +1043,13 @@\n ;; logical ops.  Have the logical ops follow the memory ops in\n ;; terms of whether to prefer VSX or Altivec\n \n+;; AND has a clobber to be consistant with VSX, which adds splitters for using\n+;; the GPR registers.\n (define_insn \"*altivec_and<mode>3\"\n   [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n         (and:VM (match_operand:VM 1 \"register_operand\" \"v\")\n-\t\t(match_operand:VM 2 \"register_operand\" \"v\")))]\n+\t\t(match_operand:VM 2 \"register_operand\" \"v\")))\n+   (clobber (match_scratch:CC 3 \"=X\"))]\n   \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n   \"vand %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n@@ -1050,8 +1079,8 @@\n   \n (define_insn \"*altivec_nor<mode>3\"\n   [(set (match_operand:VM 0 \"register_operand\" \"=v\")\n-        (not:VM (ior:VM (match_operand:VM 1 \"register_operand\" \"v\")\n-\t\t\t(match_operand:VM 2 \"register_operand\" \"v\"))))]\n+\t(and:VM (not:VM (match_operand:VM 1 \"register_operand\" \"v\"))\n+\t\t(not:VM (match_operand:VM 2 \"register_operand\" \"v\"))))]\n   \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\"\n   \"vnor %0,%1,%2\"\n   [(set_attr \"type\" \"vecsimple\")])\n@@ -2370,3 +2399,34 @@\n   emit_insn (gen_altivec_vcfux (operands[0], tmp, const0_rtx));\n   DONE;\n }\")\n+\n+\f\n+;; Power8 vector instructions encoded as Altivec instructions\n+\n+;; Vector count leading zeros\n+(define_insn \"*p8v_clz<mode>2\"\n+  [(set (match_operand:VI2 0 \"register_operand\" \"=v\")\n+\t(clz:VI2 (match_operand:VI2 1 \"register_operand\" \"v\")))]\n+  \"TARGET_P8_VECTOR\"\n+  \"vclz<wd> %0,%1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+;; Vector population count\n+(define_insn \"*p8v_popcount<mode>2\"\n+  [(set (match_operand:VI2 0 \"register_operand\" \"=v\")\n+        (popcount:VI2 (match_operand:VI2 1 \"register_operand\" \"v\")))]\n+  \"TARGET_P8_VECTOR\"\n+  \"vpopcnt<wd> %0,%1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+;; Vector Gather Bits by Bytes by Doubleword\n+(define_insn \"p8v_vgbbd\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+\t(unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"v\")]\n+\t\t      UNSPEC_VGBBD))]\n+  \"TARGET_P8_VECTOR\"\n+  \"vgbbd %0,%1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])"}, {"sha": "12a602b78c4372c4f995d5b73216083ff97a5a55", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -207,7 +207,7 @@\n   if (!REG_P (op))\n     return 0;\n \n-  if (REGNO (op) >= ARG_POINTER_REGNUM && !CA_REGNO_P (REGNO (op)))\n+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n     return 1;\n \n   return INT_REGNO_P (REGNO (op));"}, {"sha": "1a5a709751d630530c0db0977dee7bb52bd49b25", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -1234,17 +1234,32 @@ BU_VSX_OVERLOAD_2 (XXSPLTW,  \"xxspltw\")\n BU_VSX_OVERLOAD_X (LD,\t     \"ld\")\n BU_VSX_OVERLOAD_X (ST,\t     \"st\")\n \f\n+/* 1 argument VSX instructions added in ISA 2.07.  */\n+BU_P8V_VSX_1 (XSCVSPDPN,      \"xscvspdpn\",\tCONST,\tvsx_xscvspdpn)\n+BU_P8V_VSX_1 (XSCVDPSPN,      \"xscvdpspn\",\tCONST,\tvsx_xscvdpspn)\n+\n /* 1 argument altivec instructions added in ISA 2.07.  */\n BU_P8V_AV_1 (ABS_V2DI,\t      \"abs_v2di\",\tCONST,\tabsv2di2)\n BU_P8V_AV_1 (VUPKHSW,\t      \"vupkhsw\",\tCONST,\taltivec_vupkhsw)\n BU_P8V_AV_1 (VUPKLSW,\t      \"vupklsw\",\tCONST,\taltivec_vupklsw)\n+BU_P8V_AV_1 (VCLZB,\t      \"vclzb\",\t\tCONST,  clzv16qi2)\n+BU_P8V_AV_1 (VCLZH,\t      \"vclzh\",\t\tCONST,  clzv8hi2)\n+BU_P8V_AV_1 (VCLZW,\t      \"vclzw\",\t\tCONST,  clzv4si2)\n+BU_P8V_AV_1 (VCLZD,\t      \"vclzd\",\t\tCONST,  clzv2di2)\n+BU_P8V_AV_1 (VPOPCNTB,\t      \"vpopcntb\",\tCONST,  popcountv16qi2)\n+BU_P8V_AV_1 (VPOPCNTH,\t      \"vpopcnth\",\tCONST,  popcountv8hi2)\n+BU_P8V_AV_1 (VPOPCNTW,\t      \"vpopcntw\",\tCONST,  popcountv4si2)\n+BU_P8V_AV_1 (VPOPCNTD,\t      \"vpopcntd\",\tCONST,  popcountv2di2)\n+BU_P8V_AV_1 (VGBBD,\t      \"vgbbd\",\t\tCONST,  p8v_vgbbd)\n \n /* 2 argument altivec instructions added in ISA 2.07.  */\n BU_P8V_AV_2 (VADDUDM,\t\t\"vaddudm\",\tCONST,\taddv2di3)\n BU_P8V_AV_2 (VMINSD,\t\t\"vminsd\",\tCONST,\tsminv2di3)\n BU_P8V_AV_2 (VMAXSD,\t\t\"vmaxsd\",\tCONST,\tsmaxv2di3)\n BU_P8V_AV_2 (VMINUD,\t\t\"vminud\",\tCONST,\tuminv2di3)\n BU_P8V_AV_2 (VMAXUD,\t\t\"vmaxud\",\tCONST,\tumaxv2di3)\n+BU_P8V_AV_2 (VMRGEW,\t\t\"vmrgew\",\tCONST,\tp8_vmrgew)\n+BU_P8V_AV_2 (VMRGOW,\t\t\"vmrgow\",\tCONST,\tp8_vmrgow)\n BU_P8V_AV_2 (VPKUDUM,\t\t\"vpkudum\",\tCONST,\taltivec_vpkudum)\n BU_P8V_AV_2 (VPKSDSS,\t\t\"vpksdss\",\tCONST,\taltivec_vpksdss)\n BU_P8V_AV_2 (VPKUDUS,\t\t\"vpkudus\",\tCONST,\taltivec_vpkudus)\n@@ -1255,6 +1270,27 @@ BU_P8V_AV_2 (VSRD,\t\t\"vsrd\",\t\tCONST,\tvlshrv2di3)\n BU_P8V_AV_2 (VSRAD,\t\t\"vsrad\",\tCONST,\tvashrv2di3)\n BU_P8V_AV_2 (VSUBUDM,\t\t\"vsubudm\",\tCONST,\tsubv2di3)\n \n+BU_P8V_AV_2 (EQV_V16QI,\t\t\"eqv_v16qi\",\tCONST,\teqvv16qi3)\n+BU_P8V_AV_2 (EQV_V8HI,\t\t\"eqv_v8hi\",\tCONST,\teqvv8hi3)\n+BU_P8V_AV_2 (EQV_V4SI,\t\t\"eqv_v4si\",\tCONST,\teqvv4si3)\n+BU_P8V_AV_2 (EQV_V2DI,\t\t\"eqv_v2di\",\tCONST,\teqvv2di3)\n+BU_P8V_AV_2 (EQV_V4SF,\t\t\"eqv_v4sf\",\tCONST,\teqvv4sf3)\n+BU_P8V_AV_2 (EQV_V2DF,\t\t\"eqv_v2df\",\tCONST,\teqvv2df3)\n+\n+BU_P8V_AV_2 (NAND_V16QI,\t\"nand_v16qi\",\tCONST,\tnandv16qi3)\n+BU_P8V_AV_2 (NAND_V8HI,\t\t\"nand_v8hi\",\tCONST,\tnandv8hi3)\n+BU_P8V_AV_2 (NAND_V4SI,\t\t\"nand_v4si\",\tCONST,\tnandv4si3)\n+BU_P8V_AV_2 (NAND_V2DI,\t\t\"nand_v2di\",\tCONST,\tnandv2di3)\n+BU_P8V_AV_2 (NAND_V4SF,\t\t\"nand_v4sf\",\tCONST,\tnandv4sf3)\n+BU_P8V_AV_2 (NAND_V2DF,\t\t\"nand_v2df\",\tCONST,\tnandv2df3)\n+\n+BU_P8V_AV_2 (ORC_V16QI,\t\t\"orc_v16qi\",\tCONST,\torcv16qi3)\n+BU_P8V_AV_2 (ORC_V8HI,\t\t\"orc_v8hi\",\tCONST,\torcv8hi3)\n+BU_P8V_AV_2 (ORC_V4SI,\t\t\"orc_v4si\",\tCONST,\torcv4si3)\n+BU_P8V_AV_2 (ORC_V2DI,\t\t\"orc_v2di\",\tCONST,\torcv2di3)\n+BU_P8V_AV_2 (ORC_V4SF,\t\t\"orc_v4sf\",\tCONST,\torcv4sf3)\n+BU_P8V_AV_2 (ORC_V2DF,\t\t\"orc_v2df\",\tCONST,\torcv2df3)\n+\n /* Vector comparison instructions added in ISA 2.07.  */\n BU_P8V_AV_2 (VCMPEQUD,\t\t\"vcmpequd\",\tCONST,\tvector_eqv2di)\n BU_P8V_AV_2 (VCMPGTSD,\t\t\"vcmpgtsd\",\tCONST,\tvector_gtv2di)\n@@ -1268,13 +1304,29 @@ BU_P8V_AV_P (VCMPGTUD_P,\t\"vcmpgtud_p\",\tCONST,\tvector_gtu_v2di_p)\n /* ISA 2.07 vector overloaded 1 argument functions.  */\n BU_P8V_OVERLOAD_1 (VUPKHSW,\t\"vupkhsw\")\n BU_P8V_OVERLOAD_1 (VUPKLSW,\t\"vupklsw\")\n+BU_P8V_OVERLOAD_1 (VCLZ,\t\"vclz\")\n+BU_P8V_OVERLOAD_1 (VCLZB,\t\"vclzb\")\n+BU_P8V_OVERLOAD_1 (VCLZH,\t\"vclzh\")\n+BU_P8V_OVERLOAD_1 (VCLZW,\t\"vclzw\")\n+BU_P8V_OVERLOAD_1 (VCLZD,\t\"vclzd\")\n+BU_P8V_OVERLOAD_1 (VPOPCNT,\t\"vpopcnt\")\n+BU_P8V_OVERLOAD_1 (VPOPCNTB,\t\"vpopcntb\")\n+BU_P8V_OVERLOAD_1 (VPOPCNTH,\t\"vpopcnth\")\n+BU_P8V_OVERLOAD_1 (VPOPCNTW,\t\"vpopcntw\")\n+BU_P8V_OVERLOAD_1 (VPOPCNTD,\t\"vpopcntd\")\n+BU_P8V_OVERLOAD_1 (VGBBD,\t\"vgbbd\")\n \n /* ISA 2.07 vector overloaded 2 argument functions.  */\n+BU_P8V_OVERLOAD_2 (EQV,\t\t\"eqv\")\n+BU_P8V_OVERLOAD_2 (NAND,\t\"nand\")\n+BU_P8V_OVERLOAD_2 (ORC,\t\t\"orc\")\n BU_P8V_OVERLOAD_2 (VADDUDM,\t\"vaddudm\")\n BU_P8V_OVERLOAD_2 (VMAXSD,\t\"vmaxsd\")\n BU_P8V_OVERLOAD_2 (VMAXUD,\t\"vmaxud\")\n BU_P8V_OVERLOAD_2 (VMINSD,\t\"vminsd\")\n BU_P8V_OVERLOAD_2 (VMINUD,\t\"vminud\")\n+BU_P8V_OVERLOAD_2 (VMRGEW,\t\"vmrgew\")\n+BU_P8V_OVERLOAD_2 (VMRGOW,\t\"vmrgow\")\n BU_P8V_OVERLOAD_2 (VPKSDSS,\t\"vpksdss\")\n BU_P8V_OVERLOAD_2 (VPKSDUS,\t\"vpksdus\")\n BU_P8V_OVERLOAD_2 (VPKUDUM,\t\"vpkudum\")"}, {"sha": "593b772ebd13f67635790ad445a041d2fe35879a", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -3515,6 +3515,404 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_VCMPGE_P, VSX_BUILTIN_XVCMPGEDP_P,\n     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DF, RS6000_BTI_V2DF },\n \n+  /* Power8 vector overloaded functions.  */\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_bool_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI,\n+    RS6000_BTI_unsigned_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_bool_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_unsigned_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_bool_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V4SF,\n+    RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n+  { P8V_BUILTIN_VEC_EQV, P8V_BUILTIN_EQV_V2DF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },\n+\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_bool_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI,\n+    RS6000_BTI_unsigned_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_bool_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_unsigned_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_bool_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V4SF,\n+    RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n+  { P8V_BUILTIN_VEC_NAND, P8V_BUILTIN_NAND_V2DF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },\n+\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, RS6000_BTI_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_bool_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_bool_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_bool_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V16QI,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, RS6000_BTI_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_bool_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_bool_V8HI,\n+    RS6000_BTI_unsigned_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_bool_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V8HI,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI,\n+    RS6000_BTI_unsigned_V8HI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_bool_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_bool_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SI,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DI,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V4SF,\n+    RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n+  { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DF,\n+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },\n+\n+  { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZB,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZB,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZH,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZH,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZW,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VCLZB, P8V_BUILTIN_VCLZB,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZB, P8V_BUILTIN_VCLZB,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VCLZH, P8V_BUILTIN_VCLZH,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZH, P8V_BUILTIN_VCLZH,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VCLZW, P8V_BUILTIN_VCLZW,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZW, P8V_BUILTIN_VCLZW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VCLZD, P8V_BUILTIN_VCLZD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VCLZD, P8V_BUILTIN_VCLZD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VMINSD, P8V_BUILTIN_VMINSD,\n+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMINSD, P8V_BUILTIN_VMINSD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMINSD, P8V_BUILTIN_VMINSD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VMAXSD, P8V_BUILTIN_VMAXSD,\n+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMAXSD, P8V_BUILTIN_VMAXSD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMAXSD, P8V_BUILTIN_VMAXSD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VMINUD, P8V_BUILTIN_VMINUD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMINUD, P8V_BUILTIN_VMINUD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMINUD, P8V_BUILTIN_VMINUD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VMAXUD, P8V_BUILTIN_VMAXUD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMAXUD, P8V_BUILTIN_VMAXUD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VMAXUD, P8V_BUILTIN_VMAXUD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI,\n+    RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VMRGEW, P8V_BUILTIN_VMRGEW,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_VMRGEW, P8V_BUILTIN_VMRGEW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },\n+  { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n+    RS6000_BTI_unsigned_V4SI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTB,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTB,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTH,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTH,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTW,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPOPCNTB, P8V_BUILTIN_VPOPCNTB,\n+    RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNTB, P8V_BUILTIN_VPOPCNTB,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPOPCNTH, P8V_BUILTIN_VPOPCNTH,\n+    RS6000_BTI_V8HI, RS6000_BTI_V8HI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNTH, P8V_BUILTIN_VPOPCNTH,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPOPCNTW, P8V_BUILTIN_VPOPCNTW,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNTW, P8V_BUILTIN_VPOPCNTW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPOPCNTD, P8V_BUILTIN_VPOPCNTD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VPOPCNTD, P8V_BUILTIN_VPOPCNTD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPKUDUM, P8V_BUILTIN_VPKUDUM,\n+    RS6000_BTI_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VPKUDUM, P8V_BUILTIN_VPKUDUM,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VPKUDUM, P8V_BUILTIN_VPKUDUM,\n+    RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPKSDSS, P8V_BUILTIN_VPKSDSS,\n+    RS6000_BTI_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPKUDUS, P8V_BUILTIN_VPKUDUS,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VPKSDUS, P8V_BUILTIN_VPKSDUS,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VRLD, P8V_BUILTIN_VRLD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VRLD, P8V_BUILTIN_VRLD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VSLD, P8V_BUILTIN_VSLD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSLD, P8V_BUILTIN_VSLD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VSRD, P8V_BUILTIN_VSRD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSRD, P8V_BUILTIN_VSRD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VSRAD, P8V_BUILTIN_VSRAD,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSRAD, P8V_BUILTIN_VSRD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },\n+  { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P8V_BUILTIN_VEC_VUPKHSW, P8V_BUILTIN_VUPKHSW,\n+    RS6000_BTI_V2DI, RS6000_BTI_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VUPKHSW, P8V_BUILTIN_VUPKHSW,\n+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VUPKLSW, P8V_BUILTIN_VUPKLSW,\n+    RS6000_BTI_V2DI, RS6000_BTI_V4SI, 0, 0 },\n+  { P8V_BUILTIN_VEC_VUPKLSW, P8V_BUILTIN_VUPKLSW,\n+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V4SI, 0, 0 },\n+\n+  { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n+    RS6000_BTI_V16QI, 0, 0, 0 },\n+  { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n+    RS6000_BTI_unsigned_V16QI, 0, 0, 0 },\n+\n   /* Crypto builtins.  */\n   { CRYPTO_BUILTIN_VPERMXOR, CRYPTO_BUILTIN_VPERMXOR_V16QI,\n     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI,"}, {"sha": "161fd6b88e193ec8fc80e8fedd57bfb277c13d9b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -2859,6 +2859,16 @@ rs6000_option_override_internal (bool global_init_p)\n \t}\n     }\n \n+  /* The quad memory instructions only works in 64-bit mode. In 32-bit mode,\n+     silently turn off quad memory mode.  */\n+  if (TARGET_QUAD_MEMORY && !TARGET_POWERPC64)\n+    {\n+      if ((rs6000_isa_flags_explicit & OPTION_MASK_QUAD_MEMORY) != 0)\n+\twarning (0, N_(\"-mquad-memory requires 64-bit mode\"));\n+\n+      rs6000_isa_flags &= ~OPTION_MASK_QUAD_MEMORY;\n+    }\n+\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"before defaults\", rs6000_isa_flags);\n \n@@ -4082,6 +4092,22 @@ rs6000_builtin_vectorized_function (tree fndecl, tree type_out,\n       enum built_in_function fn = DECL_FUNCTION_CODE (fndecl);\n       switch (fn)\n \t{\n+\tcase BUILT_IN_CLZIMAX:\n+\tcase BUILT_IN_CLZLL:\n+\tcase BUILT_IN_CLZL:\n+\tcase BUILT_IN_CLZ:\n+\t  if (TARGET_P8_VECTOR && in_mode == out_mode && out_n == in_n)\n+\t    {\n+\t      if (out_mode == QImode && out_n == 16)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VCLZB];\n+\t      else if (out_mode == HImode && out_n == 8)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VCLZH];\n+\t      else if (out_mode == SImode && out_n == 4)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VCLZW];\n+\t      else if (out_mode == DImode && out_n == 2)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VCLZD];\n+\t    }\n+\t  break;\n \tcase BUILT_IN_COPYSIGN:\n \t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t      && out_mode == DFmode && out_n == 2\n@@ -4097,6 +4123,22 @@ rs6000_builtin_vectorized_function (tree fndecl, tree type_out,\n \t  if (VECTOR_UNIT_ALTIVEC_P (V4SFmode))\n \t    return rs6000_builtin_decls[ALTIVEC_BUILTIN_COPYSIGN_V4SF];\n \t  break;\n+\tcase BUILT_IN_POPCOUNTIMAX:\n+\tcase BUILT_IN_POPCOUNTLL:\n+\tcase BUILT_IN_POPCOUNTL:\n+\tcase BUILT_IN_POPCOUNT:\n+\t  if (TARGET_P8_VECTOR && in_mode == out_mode && out_n == in_n)\n+\t    {\n+\t      if (out_mode == QImode && out_n == 16)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VPOPCNTB];\n+\t      else if (out_mode == HImode && out_n == 8)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VPOPCNTH];\n+\t      else if (out_mode == SImode && out_n == 4)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VPOPCNTW];\n+\t      else if (out_mode == DImode && out_n == 2)\n+\t\treturn rs6000_builtin_decls[P8V_BUILTIN_VPOPCNTD];\n+\t    }\n+\t  break;\n \tcase BUILT_IN_SQRT:\n \t  if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t      && out_mode == DFmode && out_n == 2\n@@ -4955,8 +4997,11 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n \t{\n \t  rtx freg = gen_reg_rtx (V4SFmode);\n \t  rtx sreg = force_reg (SFmode, XVECEXP (vals, 0, 0));\n+\t  rtx cvt  = ((TARGET_XSCVDPSPN)\n+\t\t      ? gen_vsx_xscvdpspn_scalar (freg, sreg)\n+\t\t      : gen_vsx_xscvdpsp_scalar (freg, sreg));\n \n-\t  emit_insn (gen_vsx_xscvdpsp_scalar (freg, sreg));\n+\t  emit_insn (cvt);\n \t  emit_insn (gen_vsx_xxspltw_v4sf (target, freg, const0_rtx));\n \t}\n       else\n@@ -12857,6 +12902,7 @@ builtin_function_type (enum machine_mode mode_ret, enum machine_mode mode_arg0,\n     {\n       /* unsigned 1 argument functions.  */\n     case CRYPTO_BUILTIN_VSBOX:\n+    case P8V_BUILTIN_VGBBD:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       break;\n@@ -27214,26 +27260,31 @@ bool\n altivec_expand_vec_perm_const (rtx operands[4])\n {\n   struct altivec_perm_insn {\n+    HOST_WIDE_INT mask;\n     enum insn_code impl;\n     unsigned char perm[16];\n   };\n   static const struct altivec_perm_insn patterns[] = {\n-    { CODE_FOR_altivec_vpkuhum,\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vpkuhum,\n       {  1,  3,  5,  7,  9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31 } },\n-    { CODE_FOR_altivec_vpkuwum,\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vpkuwum,\n       {  2,  3,  6,  7, 10, 11, 14, 15, 18, 19, 22, 23, 26, 27, 30, 31 } },\n-    { CODE_FOR_altivec_vmrghb,\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vmrghb,\n       {  0, 16,  1, 17,  2, 18,  3, 19,  4, 20,  5, 21,  6, 22,  7, 23 } },\n-    { CODE_FOR_altivec_vmrghh,\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vmrghh,\n       {  0,  1, 16, 17,  2,  3, 18, 19,  4,  5, 20, 21,  6,  7, 22, 23 } },\n-    { CODE_FOR_altivec_vmrghw,\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vmrghw,\n       {  0,  1,  2,  3, 16, 17, 18, 19,  4,  5,  6,  7, 20, 21, 22, 23 } },\n-    { CODE_FOR_altivec_vmrglb,\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vmrglb,\n       {  8, 24,  9, 25, 10, 26, 11, 27, 12, 28, 13, 29, 14, 30, 15, 31 } },\n-    { CODE_FOR_altivec_vmrglh,\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vmrglh,\n       {  8,  9, 24, 25, 10, 11, 26, 27, 12, 13, 28, 29, 14, 15, 30, 31 } },\n-    { CODE_FOR_altivec_vmrglw,\n-      {  8,  9, 10, 11, 24, 25, 26, 27, 12, 13, 14, 15, 28, 29, 30, 31 } }\n+    { OPTION_MASK_ALTIVEC, CODE_FOR_altivec_vmrglw,\n+      {  8,  9, 10, 11, 24, 25, 26, 27, 12, 13, 14, 15, 28, 29, 30, 31 } },\n+    { OPTION_MASK_P8_VECTOR, CODE_FOR_p8_vmrgew,\n+      {  0,  1,  2,  3, 16, 17, 18, 19,  8,  9, 10, 11, 24, 25, 26, 27 } },\n+    { OPTION_MASK_P8_VECTOR, CODE_FOR_p8_vmrgow,\n+      {  4,  5,  6,  7, 20, 21, 22, 23, 12, 13, 14, 15, 28, 29, 30, 31 } }\n   };\n \n   unsigned int i, j, elt, which;\n@@ -27333,6 +27384,9 @@ altivec_expand_vec_perm_const (rtx operands[4])\n     {\n       bool swapped;\n \n+      if ((patterns[j].mask & rs6000_isa_flags) == 0)\n+\tcontinue;\n+\n       elt = patterns[j].perm[0];\n       if (perm[0] == elt)\n \tswapped = false;"}, {"sha": "e5573503650af61abc825dd15e451ae6eea28096", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -1114,10 +1114,10 @@ extern unsigned rs6000_pointer_size;\n #define VINT_REGNO_P(N) ALTIVEC_REGNO_P (N)\n \n /* Alternate name for any vector register supporting logical operations, no\n-   matter which instruction set(s) are available.  Under VSX, we allow GPRs as\n-   well as vector registers on 64-bit systems.  We don't allow 32-bit systems,\n-   due to the number of registers involved, and the number of instructions to\n-   load/store the values..  */\n+   matter which instruction set(s) are available.  For 64-bit mode, we also\n+   allow logical operations in the GPRS.  This is to allow atomic quad word\n+   builtins not to need the VSX registers for lqarx/stqcx.  It also helps with\n+   __int128_t arguments that are passed in GPRs.  */\n #define VLOGICAL_REGNO_P(N)\t\t\t\t\t\t\\\n   (ALTIVEC_REGNO_P (N)\t\t\t\t\t\t\t\\\n    || (TARGET_VSX && FP_REGNO_P (N))\t\t\t\t\t\\"}, {"sha": "478831e50f364036510fa3bbfe0f51ab2ec93ee7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -8290,6 +8290,18 @@\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n+\n+;; Eqv operation.\n+(define_insn \"*eqv<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(not:GPR\n+\t (xor:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"r\"))))]\n+  \"\"\n+  \"eqv %0,%1,%2\"\n+  [(set_attr \"type\" \"integer\")\n+   (set_attr \"length\" \"4\")])\n+\n \f\n ;; Now define ways of moving data around.\n "}, {"sha": "9329ff540c8cad1c5b1cd6767023ffd6b31de2c3", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -730,9 +730,10 @@\n   \"\")\n \n (define_expand \"and<mode>3\"\n-  [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-        (and:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n-\t\t   (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))]\n+  [(parallel [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n+\t\t   (and:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n+\t\t\t      (match_operand:VEC_L 2 \"vlogical_operand\" \"\")))\n+\t      (clobber (match_scratch:CC 3 \"\"))])]\n   \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n    && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n@@ -746,8 +747,8 @@\n \n (define_expand \"nor<mode>3\"\n   [(set (match_operand:VEC_L 0 \"vlogical_operand\" \"\")\n-        (not:VEC_L (ior:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\")\n-\t\t\t      (match_operand:VEC_L 2 \"vlogical_operand\" \"\"))))]\n+\t(and:VEC_L (not:VEC_L (match_operand:VEC_L 1 \"vlogical_operand\" \"\"))\n+\t\t   (not:VEC_L (match_operand:VEC_L 2 \"vlogical_operand\" \"\"))))]\n   \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\n    && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n@@ -760,6 +761,47 @@\n    && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n   \"\")\n \n+;; Power8 vector logical instructions.\n+(define_expand \"eqv<mode>3\"\n+  [(set (match_operand:VEC_L 0 \"register_operand\" \"\")\n+\t(not:VEC_L\n+\t (xor:VEC_L (match_operand:VEC_L 1 \"register_operand\" \"\")\n+\t\t    (match_operand:VEC_L 2 \"register_operand\" \"\"))))]\n+  \"TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\")\n+\n+;; Rewrite nand into canonical form\n+(define_expand \"nand<mode>3\"\n+  [(set (match_operand:VEC_L 0 \"register_operand\" \"\")\n+\t(ior:VEC_L\n+\t (not:VEC_L (match_operand:VEC_L 1 \"register_operand\" \"\"))\n+\t (not:VEC_L (match_operand:VEC_L 2 \"register_operand\" \"\"))))]\n+  \"TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\")\n+\n+;; The canonical form is to have the negated elment first, so we need to\n+;; reverse arguments.\n+(define_expand \"orc<mode>3\"\n+  [(set (match_operand:VEC_L 0 \"register_operand\" \"\")\n+\t(ior:VEC_L\n+\t (not:VEC_L (match_operand:VEC_L 1 \"register_operand\" \"\"))\n+\t (match_operand:VEC_L 2 \"register_operand\" \"\")))]\n+  \"TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (<MODE>mode != TImode || TARGET_POWERPC64)\")\n+\n+;; Vector count leading zeros\n+(define_expand \"clz<mode>2\"\n+  [(set (match_operand:VEC_I 0 \"register_operand\" \"\")\n+\t(clz:VEC_I (match_operand:VEC_I 1 \"register_operand\" \"\")))]\n+  \"TARGET_P8_VECTOR\")\n+\n+;; Vector population count\n+(define_expand \"popcount<mode>2\"\n+  [(set (match_operand:VEC_I 0 \"register_operand\" \"\")\n+        (popcount:VEC_I (match_operand:VEC_I 1 \"register_operand\" \"\")))]\n+  \"TARGET_P8_VECTOR\")\n+\n+\f\n ;; Same size conversions\n (define_expand \"float<VEC_int><mode>2\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\" \"\")"}, {"sha": "daf9a24d7ea7d2bc2b4946fa81df40dd491c5a9c", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 390, "deletions": 52, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -36,6 +36,10 @@\n ;; Iterator for logical types supported by VSX\n (define_mode_iterator VSX_L [V16QI V8HI V4SI V2DI V4SF V2DF TI])\n \n+;; Like VSX_L, but don't support TImode for doing logical instructions in\n+;; 32-bit\n+(define_mode_iterator VSX_L2 [V16QI V8HI V4SI V2DI V4SF V2DF])\n+\n ;; Iterator for memory move.  Handle TImode specially to allow\n ;; it to use gprs as well as vsx registers.\n (define_mode_iterator VSX_M [V16QI V8HI V4SI V2DI V4SF V2DF])\n@@ -191,6 +195,8 @@\n    UNSPEC_VSX_CVDPSXWS\n    UNSPEC_VSX_CVDPUXWS\n    UNSPEC_VSX_CVSPDP\n+   UNSPEC_VSX_CVSPDPN\n+   UNSPEC_VSX_CVDPSPN\n    UNSPEC_VSX_CVSXWDP\n    UNSPEC_VSX_CVUXWDP\n    UNSPEC_VSX_CVSXDSP\n@@ -1003,6 +1009,40 @@\n   \"xscvspdp %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n+;; ISA 2.07 xscvdpspn/xscvspdpn that does not raise an error on signalling NaNs\n+(define_insn \"vsx_xscvdpspn\"\n+  [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=ws,?wa\")\n+\t(unspec:V4SF [(match_operand:DF 1 \"vsx_register_operand\" \"wd,wa\")]\n+\t\t     UNSPEC_VSX_CVDPSPN))]\n+  \"TARGET_XSCVDPSPN\"\n+  \"xscvdpspn %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"vsx_xscvspdpn\"\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,?wa\")\n+\t(unspec:DF [(match_operand:V4SF 1 \"vsx_register_operand\" \"wa,wa\")]\n+\t\t   UNSPEC_VSX_CVSPDPN))]\n+  \"TARGET_XSCVSPDPN\"\n+  \"xscvspdpn %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"vsx_xscvdpspn_scalar\"\n+  [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:V4SF [(match_operand:SF 1 \"vsx_register_operand\" \"f\")]\n+\t\t     UNSPEC_VSX_CVDPSPN))]\n+  \"TARGET_XSCVDPSPN\"\n+  \"xscvdpspn %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Used by direct move to move a SFmode value from GPR to VSX register\n+(define_insn \"vsx_xscvspdpn_directmove\"\n+  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:SF [(match_operand:SF 1 \"vsx_register_operand\" \"wa\")]\n+\t\t   UNSPEC_VSX_CVSPDPN))]\n+  \"TARGET_XSCVSPDPN\"\n+  \"xscvspdpn %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n ;; Convert from 64-bit to 32-bit types\n ;; Note, favor the Altivec registers since the usual use of these instructions\n ;; is in vector converts and we need to use the Altivec vperm instruction.\n@@ -1088,70 +1128,368 @@\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n \f\n-;; Logical operations\n-;; Do not support TImode logical instructions on 32-bit at present, because the\n-;; compiler will see that we have a TImode and when it wanted DImode, and\n-;; convert the DImode to TImode, store it on the stack, and load it in a VSX\n-;; register.\n-(define_insn \"*vsx_and<mode>3\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (and:VSX_L\n-\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n+;; Logical operations.  Do not support TImode logical instructions on 32-bit at\n+;; present, because the compiler will see that we have a TImode and when it\n+;; wanted DImode, and convert the DImode to TImode, store it on the stack, and\n+;; load it in a VSX register or generate extra logical instructions in GPR\n+;; registers.\n+\n+;; When we are splitting the operations to GPRs, we use three alternatives, two\n+;; where the first/second inputs and output are in the same register, and the\n+;; third where the output specifies an early clobber so that we don't have to\n+;; worry about overlapping registers.\n+\n+(define_insn \"*vsx_and<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+        (and:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"%wa\")\n+\t\t    (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))\n+   (clobber (match_scratch:CC 3 \"X\"))]\n+  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxland %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn \"*vsx_ior<mode>3\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (ior:VSX_L (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t   (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n+(define_insn_and_split \"*vsx_and<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r\")\n+        (and:VSX_L\n+\t (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r\")\n+\t (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\")))\n+   (clobber (match_scratch:CC 3 \"X,X,X,X\"))]\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxland %x0,%x1,%x2\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(parallel [(set (match_dup 4) (and:DI (match_dup 5) (match_dup 6)))\n+\t      (clobber (match_dup 3))])\n+   (parallel [(set (match_dup 7) (and:DI (match_dup 8) (match_dup 9)))\n+\t      (clobber (match_dup 3))])]\n+{\n+  operands[4] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[7] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[9] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two\")\n+   (set_attr \"length\" \"4,8,8,8\")])\n+\n+(define_insn \"*vsx_ior<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+        (ior:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"%wa\")\n+\t\t    (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))]\n+  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxlor %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"*vsx_ior<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r,?r,&?r\")\n+        (ior:VSX_L\n+\t (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r,0,r\")\n+\t (match_operand:VSX_L 2 \"vsx_reg_or_cint_operand\" \"wa,r,0,r,n,n\")))]\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxlor %x0,%x1,%x2\n+   #\n+   #\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(const_int 0)]\n+{\n+  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n \n-(define_insn \"*vsx_xor<mode>3\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (xor:VSX_L\n-\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n+  if (operands[5] == constm1_rtx)\n+    emit_move_insn (operands[3], constm1_rtx);\n+\n+  else if (operands[5] == const0_rtx)\n+    {\n+      if (!rtx_equal_p (operands[3], operands[4]))\n+\temit_move_insn (operands[3], operands[4]);\n+    }\n+  else\n+    emit_insn (gen_iordi3 (operands[3], operands[4], operands[5]));\n+\n+  if (operands[8] == constm1_rtx)\n+    emit_move_insn (operands[8], constm1_rtx);\n+\n+  else if (operands[8] == const0_rtx)\n+    {\n+      if (!rtx_equal_p (operands[6], operands[7]))\n+\temit_move_insn (operands[6], operands[7]);\n+    }\n+  else\n+    emit_insn (gen_iordi3 (operands[6], operands[7], operands[8]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two,three,three\")\n+   (set_attr \"length\" \"4,8,8,8,16,16\")])\n+\n+(define_insn \"*vsx_xor<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+        (xor:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"%wa\")\n+\t\t    (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && !TARGET_POWERPC64\"\n   \"xxlxor %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn \"*vsx_one_cmpl<mode>2\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (not:VSX_L\n-\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n+(define_insn_and_split \"*vsx_xor<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r,?r,&?r\")\n+        (xor:VSX_L\n+\t (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r,0,r\")\n+\t (match_operand:VSX_L 2 \"vsx_reg_or_cint_operand\" \"wa,r,0,r,n,n\")))]\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxlxor %x0,%x1,%x2\n+   #\n+   #\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(set (match_dup 3) (xor:DI (match_dup 4) (match_dup 5)))\n+   (set (match_dup 6) (xor:DI (match_dup 7) (match_dup 8)))]\n+{\n+  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two,three,three\")\n+   (set_attr \"length\" \"4,8,8,8,16,16\")])\n+\n+(define_insn \"*vsx_one_cmpl<mode>2_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+        (not:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\")))]\n+  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxlnor %x0,%x1,%x1\"\n-  [(set_attr \"type\" \"vecsimple\")])\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"*vsx_one_cmpl<mode>2_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,&?r\")\n+        (not:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,0,r\")))]\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxlnor %x0,%x1,%x1\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(set (match_dup 2) (not:DI (match_dup 3)))\n+   (set (match_dup 4) (not:DI (match_dup 5)))]\n+{\n+  operands[2] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[3] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[5] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two\")\n+   (set_attr \"length\" \"4,8,8\")])\n   \n-(define_insn \"*vsx_nor<mode>3\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (not:VSX_L\n-\t (ior:VSX_L\n-\t  (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n-\t  (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,?wa\"))))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n+(define_insn \"*vsx_nor<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+\t(and:VSX_L2\n+\t (not:VSX_L2 (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa\"))\n+\t (not:VSX_L2 (match_operand:VSX_L 2 \"vlogical_operand\" \"wa\"))))]\n+  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxlnor %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"*vsx_nor<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,&?r\")\n+\t(and:VSX_L\n+\t (not:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"%wa,0,r,r\"))\n+\t (not:VSX_L (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\"))))]\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxlnor %x0,%x1,%x2\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(set (match_dup 3) (and:DI (not:DI (match_dup 4)) (not:DI (match_dup 5))))\n+   (set (match_dup 6) (and:DI (not:DI (match_dup 7)) (not:DI (match_dup 8))))]\n+{\n+  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two\")\n+   (set_attr \"length\" \"4,8,8,8\")])\n+\n+(define_insn \"*vsx_andc<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+        (and:VSX_L2\n+\t (not:VSX_L2\n+\t  (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\"))\n+\t (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\")))]\n+  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"xxlandc %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn \"*vsx_andc<mode>3\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+(define_insn_and_split \"*vsx_andc<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,?r\")\n         (and:VSX_L\n \t (not:VSX_L\n-\t  (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,?wa\"))\n-\t (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,?wa\")))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (<MODE>mode != TImode || TARGET_POWERPC64)\"\n-  \"xxlandc %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"vecsimple\")])\n+\t  (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,0,r,r\"))\n+\t (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,r,0,r\")))]\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxlandc %x0,%x1,%x2\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(set (match_dup 3) (and:DI (not:DI (match_dup 4)) (match_dup 5)))\n+   (set (match_dup 6) (and:DI (not:DI (match_dup 7)) (match_dup 8)))]\n+{\n+  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two\")\n+   (set_attr \"length\" \"4,8,8,8\")])\n+\n+;; Power8 vector logical instructions.\n+(define_insn \"*vsx_eqv<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+\t(not:VSX_L2\n+\t (xor:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\")\n+\t\t     (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\"))))]\n+  \"!TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"xxleqv %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"*vsx_eqv<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,?r\")\n+\t(not:VSX_L\n+\t (xor:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,0,r,r\")\n+\t\t    (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\"))))]\n+  \"TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxleqv %x0,%x1,%x2\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && TARGET_P8_VECTOR\n+   && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(set (match_dup 3) (not:DI (xor:DI (match_dup 4) (match_dup 5))))\n+   (set (match_dup 6) (not:DI (xor:DI (match_dup 7) (match_dup 8))))]\n+{\n+  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two\")\n+   (set_attr \"length\" \"4,8,8,8\")])\n+\n+;; Rewrite nand into canonical form\n+(define_insn \"*vsx_nand<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+\t(ior:VSX_L2\n+\t (not:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\"))\n+\t (not:VSX_L2 (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\"))))]\n+  \"!TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"xxlnand %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"*vsx_nand<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"register_operand\" \"=wa,?r,?r,?r\")\n+\t(ior:VSX_L\n+\t (not:VSX_L (match_operand:VSX_L 1 \"register_operand\" \"wa,0,r,r\"))\n+\t (not:VSX_L (match_operand:VSX_L 2 \"register_operand\" \"wa,r,0,r\"))))]\n+  \"TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxlnand %x0,%x1,%x2\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && TARGET_P8_VECTOR\n+   && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(set (match_dup 3) (ior:DI (not:DI (match_dup 4)) (not:DI (match_dup 5))))\n+   (set (match_dup 6) (ior:DI (not:DI (match_dup 7)) (not:DI (match_dup 8))))]\n+{\n+  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two\")\n+   (set_attr \"length\" \"4,8,8,8\")])\n+\n+;; Rewrite or complement into canonical form, by reversing the arguments\n+(define_insn \"*vsx_orc<mode>3_32bit\"\n+  [(set (match_operand:VSX_L2 0 \"vlogical_operand\" \"=wa\")\n+\t(ior:VSX_L2\n+\t (not:VSX_L2 (match_operand:VSX_L2 1 \"vlogical_operand\" \"wa\"))\n+\t (match_operand:VSX_L2 2 \"vlogical_operand\" \"wa\")))]\n+  \"!TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"xxlorc %x0,%x2,%x1\"\n+  [(set_attr \"type\" \"vecsimple\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"*vsx_orc<mode>3_64bit\"\n+  [(set (match_operand:VSX_L 0 \"vlogical_operand\" \"=wa,?r,?r,?r\")\n+\t(ior:VSX_L\n+\t (not:VSX_L (match_operand:VSX_L 1 \"vlogical_operand\" \"wa,0,r,r\"))\n+\t (match_operand:VSX_L 2 \"vlogical_operand\" \"wa,r,0,r\")))]\n+  \"TARGET_POWERPC64 && TARGET_P8_VECTOR && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   xxlorc %x0,%x2,%x1\n+   #\n+   #\n+   #\"\n+  \"reload_completed && TARGET_POWERPC64 && TARGET_P8_VECTOR\n+   && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && int_reg_operand (operands[0], <MODE>mode)\"\n+  [(set (match_dup 3) (ior:DI (not:DI (match_dup 4)) (match_dup 5)))\n+   (set (match_dup 6) (ior:DI (not:DI (match_dup 7)) (match_dup 8)))]\n+{\n+  operands[3] = simplify_subreg (DImode, operands[0], <MODE>mode, 0);\n+  operands[4] = simplify_subreg (DImode, operands[1], <MODE>mode, 0);\n+  operands[5] = simplify_subreg (DImode, operands[2], <MODE>mode, 0);\n+  operands[6] = simplify_subreg (DImode, operands[0], <MODE>mode, 8);\n+  operands[7] = simplify_subreg (DImode, operands[1], <MODE>mode, 8);\n+  operands[8] = simplify_subreg (DImode, operands[2], <MODE>mode, 8);\n+}\n+  [(set_attr \"type\" \"vecsimple,two,two,two\")\n+   (set_attr \"length\" \"4,8,8,8\")])\n \n \f\n ;; Permute operations"}, {"sha": "6ce26efbe1e2e31557482d5eac380941515b07a2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -13991,6 +13991,38 @@ int vec_any_le (vector long long, vector long long);\n int vec_any_lt (vector long long, vector long long);\n int vec_any_ne (vector long long, vector long long);\n \n+vector long long vec_eqv (vector long long, vector long long);\n+vector long long vec_eqv (vector bool long long, vector long long);\n+vector long long vec_eqv (vector long long, vector bool long long);\n+vector unsigned long long vec_eqv (vector unsigned long long,\n+                                   vector unsigned long long);\n+vector unsigned long long vec_eqv (vector bool long long,\n+                                   vector unsigned long long);\n+vector unsigned long long vec_eqv (vector unsigned long long,\n+                                   vector bool long long);\n+vector int vec_eqv (vector int, vector int);\n+vector int vec_eqv (vector bool int, vector int);\n+vector int vec_eqv (vector int, vector bool int);\n+vector unsigned int vec_eqv (vector unsigned int, vector unsigned int);\n+vector unsigned int vec_eqv (vector bool unsigned int,\n+                             vector unsigned int);\n+vector unsigned int vec_eqv (vector unsigned int,\n+                             vector bool unsigned int);\n+vector short vec_eqv (vector short, vector short);\n+vector short vec_eqv (vector bool short, vector short);\n+vector short vec_eqv (vector short, vector bool short);\n+vector unsigned short vec_eqv (vector unsigned short, vector unsigned short);\n+vector unsigned short vec_eqv (vector bool unsigned short,\n+                               vector unsigned short);\n+vector unsigned short vec_eqv (vector unsigned short,\n+                               vector bool unsigned short);\n+vector signed char vec_eqv (vector signed char, vector signed char);\n+vector signed char vec_eqv (vector bool signed char, vector signed char);\n+vector signed char vec_eqv (vector signed char, vector bool signed char);\n+vector unsigned char vec_eqv (vector unsigned char, vector unsigned char);\n+vector unsigned char vec_eqv (vector bool unsigned char, vector unsigned char);\n+vector unsigned char vec_eqv (vector unsigned char, vector bool unsigned char);\n+\n vector long long vec_max (vector long long, vector long long);\n vector unsigned long long vec_max (vector unsigned long long,\n                                    vector unsigned long long);\n@@ -13999,6 +14031,70 @@ vector long long vec_min (vector long long, vector long long);\n vector unsigned long long vec_min (vector unsigned long long,\n                                    vector unsigned long long);\n \n+vector long long vec_nand (vector long long, vector long long);\n+vector long long vec_nand (vector bool long long, vector long long);\n+vector long long vec_nand (vector long long, vector bool long long);\n+vector unsigned long long vec_nand (vector unsigned long long,\n+                                    vector unsigned long long);\n+vector unsigned long long vec_nand (vector bool long long,\n+                                   vector unsigned long long);\n+vector unsigned long long vec_nand (vector unsigned long long,\n+                                    vector bool long long);\n+vector int vec_nand (vector int, vector int);\n+vector int vec_nand (vector bool int, vector int);\n+vector int vec_nand (vector int, vector bool int);\n+vector unsigned int vec_nand (vector unsigned int, vector unsigned int);\n+vector unsigned int vec_nand (vector bool unsigned int,\n+                              vector unsigned int);\n+vector unsigned int vec_nand (vector unsigned int,\n+                              vector bool unsigned int);\n+vector short vec_nand (vector short, vector short);\n+vector short vec_nand (vector bool short, vector short);\n+vector short vec_nand (vector short, vector bool short);\n+vector unsigned short vec_nand (vector unsigned short, vector unsigned short);\n+vector unsigned short vec_nand (vector bool unsigned short,\n+                                vector unsigned short);\n+vector unsigned short vec_nand (vector unsigned short,\n+                                vector bool unsigned short);\n+vector signed char vec_nand (vector signed char, vector signed char);\n+vector signed char vec_nand (vector bool signed char, vector signed char);\n+vector signed char vec_nand (vector signed char, vector bool signed char);\n+vector unsigned char vec_nand (vector unsigned char, vector unsigned char);\n+vector unsigned char vec_nand (vector bool unsigned char, vector unsigned char);\n+vector unsigned char vec_nand (vector unsigned char, vector bool unsigned char);\n+\n+vector long long vec_orc (vector long long, vector long long);\n+vector long long vec_orc (vector bool long long, vector long long);\n+vector long long vec_orc (vector long long, vector bool long long);\n+vector unsigned long long vec_orc (vector unsigned long long,\n+                                   vector unsigned long long);\n+vector unsigned long long vec_orc (vector bool long long,\n+                                   vector unsigned long long);\n+vector unsigned long long vec_orc (vector unsigned long long,\n+                                   vector bool long long);\n+vector int vec_orc (vector int, vector int);\n+vector int vec_orc (vector bool int, vector int);\n+vector int vec_orc (vector int, vector bool int);\n+vector unsigned int vec_orc (vector unsigned int, vector unsigned int);\n+vector unsigned int vec_orc (vector bool unsigned int,\n+                             vector unsigned int);\n+vector unsigned int vec_orc (vector unsigned int,\n+                             vector bool unsigned int);\n+vector short vec_orc (vector short, vector short);\n+vector short vec_orc (vector bool short, vector short);\n+vector short vec_orc (vector short, vector bool short);\n+vector unsigned short vec_orc (vector unsigned short, vector unsigned short);\n+vector unsigned short vec_orc (vector bool unsigned short,\n+                               vector unsigned short);\n+vector unsigned short vec_orc (vector unsigned short,\n+                               vector bool unsigned short);\n+vector signed char vec_orc (vector signed char, vector signed char);\n+vector signed char vec_orc (vector bool signed char, vector signed char);\n+vector signed char vec_orc (vector signed char, vector bool signed char);\n+vector unsigned char vec_orc (vector unsigned char, vector unsigned char);\n+vector unsigned char vec_orc (vector bool unsigned char, vector unsigned char);\n+vector unsigned char vec_orc (vector unsigned char, vector bool unsigned char);\n+\n vector int vec_pack (vector long long, vector long long);\n vector unsigned int vec_pack (vector unsigned long long,\n                               vector unsigned long long);\n@@ -14047,6 +14143,27 @@ vector unsigned long long vec_vaddudm (vector bool unsigned long long,\n vector unsigned long long vec_vaddudm (vector unsigned long long,\n                                        vector bool unsigned long long);\n \n+vector long long vec_vclz (vector long long);\n+vector unsigned long long vec_vclz (vector unsigned long long);\n+vector int vec_vclz (vector int);\n+vector unsigned int vec_vclz (vector int);\n+vector short vec_vclz (vector short);\n+vector unsigned short vec_vclz (vector unsigned short);\n+vector signed char vec_vclz (vector signed char);\n+vector unsigned char vec_vclz (vector unsigned char);\n+\n+vector signed char vec_vclzb (vector signed char);\n+vector unsigned char vec_vclzb (vector unsigned char);\n+\n+vector long long vec_vclzd (vector long long);\n+vector unsigned long long vec_vclzd (vector unsigned long long);\n+\n+vector short vec_vclzh (vector short);\n+vector unsigned short vec_vclzh (vector unsigned short);\n+\n+vector int vec_vclzw (vector int);\n+vector unsigned int vec_vclzw (vector int);\n+\n vector long long vec_vmaxsd (vector long long, vector long long);\n \n vector unsigned long long vec_vmaxud (vector unsigned long long,\n@@ -14068,6 +14185,27 @@ vector unsigned int vec_vpkudum (vector unsigned long long,\n                                  vector unsigned long long);\n vector bool int vec_vpkudum (vector bool long long, vector bool long long);\n \n+vector long long vec_vpopcnt (vector long long);\n+vector unsigned long long vec_vpopcnt (vector unsigned long long);\n+vector int vec_vpopcnt (vector int);\n+vector unsigned int vec_vpopcnt (vector int);\n+vector short vec_vpopcnt (vector short);\n+vector unsigned short vec_vpopcnt (vector unsigned short);\n+vector signed char vec_vpopcnt (vector signed char);\n+vector unsigned char vec_vpopcnt (vector unsigned char);\n+\n+vector signed char vec_vpopcntb (vector signed char);\n+vector unsigned char vec_vpopcntb (vector unsigned char);\n+\n+vector long long vec_vpopcntd (vector long long);\n+vector unsigned long long vec_vpopcntd (vector unsigned long long);\n+\n+vector short vec_vpopcnth (vector short);\n+vector unsigned short vec_vpopcnth (vector unsigned short);\n+\n+vector int vec_vpopcntw (vector int);\n+vector unsigned int vec_vpopcntw (vector int);\n+\n vector long long vec_vrld (vector long long, vector unsigned long long);\n vector unsigned long long vec_vrld (vector unsigned long long,\n                                     vector unsigned long long);"}, {"sha": "2e50423d6102872c56288eecef91354c79c87671", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -1,3 +1,18 @@\n+2013-06-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen <pthaugen@us.ibm.com>\n+\t    Peter Bergner <bergner@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/crypto-builtin-1.c: Use effective target\n+\tpowerpc_p8vector_ok instead of powerpc_vsx_ok.\n+\n+\t* gcc.target/powerpc/bool.c: New file, add eqv, nand, nor tests.\n+\n+\t* lib/target-supports.exp (check_p8vector_hw_available) Add power8\n+\tsupport.\n+\t(check_effective_target_powerpc_p8vector_ok): Likewise.\n+\t(is-effective-target): Likewise.\n+\t(check_vect_support_and_set_flags): Likewise.\n+\n 2013-06-06  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/43652"}, {"sha": "f007db4b5bd4f945ed6bcd1c39ce1ad18de57419", "filename": "gcc/testsuite/gcc.target/powerpc/bool.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbool.c?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \"eqv\" } } */\n+/* { dg-final { scan-assembler \"nand\" } } */\n+/* { dg-final { scan-assembler \"nor\" } } */\n+\n+#ifndef TYPE\n+#define TYPE unsigned long\n+#endif\n+\n+TYPE op1 (TYPE a, TYPE b) { return ~(a ^ b); }\t/* eqv */\n+TYPE op2 (TYPE a, TYPE b) { return ~(a & b); }\t/* nand */\n+TYPE op3 (TYPE a, TYPE b) { return ~(a | b); }\t/* nor */\n+"}, {"sha": "87291954ee38f8f2aaa18e7de1d9c5b109c7393c", "filename": "gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcrypto-builtin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcrypto-builtin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fcrypto-builtin-1.c?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n-/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-options \"-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model -fno-unroll-loops -fno-unroll-all-loops\" } */\n \n typedef vector unsigned long long\tcrypto_t;"}, {"sha": "a80078a1dd95620b99e3fbf75bb04f999e4e6df4", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bd62dcaa3400167c9cfdb192bcba0555488e4b9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=0bd62dcaa3400167c9cfdb192bcba0555488e4b9", "patch": "@@ -1311,6 +1311,32 @@ proc check_effective_target_avx_runtime { } {\n     return 0\n }\n \n+# Return 1 if the target supports executing power8 vector instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_p8vector_hw_available { } {\n+    return [check_cached_effective_target p8vector_hw_available {\n+\t# Some simulators are known to not support VSX/power8 instructions.\n+\t# For now, disable on Darwin\n+\tif { [istarget powerpc-*-eabi] || [istarget powerpc*-*-eabispe] || [istarget *-*-darwin*]} {\n+\t    expr 0\n+\t} else {\n+\t    set options \"-mpower8-vector\"\n+\t    check_runtime_nocache p8vector_hw_available {\n+\t\tint main()\n+\t\t{\n+\t\t#ifdef __MACH__\n+\t\t  asm volatile (\"xxlorc vs0,vs0,vs0\");\n+\t\t#else\n+\t\t  asm volatile (\"xxlorc 0,0,0\");\n+\t        #endif\n+\t\t  return 0;\n+\t\t}\n+\t    } $options\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports executing VSX instructions, 0\n # otherwise.  Cache the result.\n \n@@ -2749,6 +2775,33 @@ proc check_effective_target_powerpc_altivec_ok { } {\n     }\n }\n \n+# Return 1 if this is a PowerPC target supporting -mpower8-vector\n+\n+proc check_effective_target_powerpc_p8vector_ok { } {\n+    if { ([istarget powerpc*-*-*]\n+         && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget rs6000-*-*] } {\n+\t# AltiVec is not supported on AIX before 5.3.\n+\tif { [istarget powerpc*-*-aix4*]\n+\t     || [istarget powerpc*-*-aix5.1*] \n+\t     || [istarget powerpc*-*-aix5.2*] } {\n+\t    return 0\n+\t}\n+\treturn [check_no_compiler_messages powerpc_p8vector_ok object {\n+\t    int main (void) {\n+#ifdef __MACH__\n+\t\tasm volatile (\"xxlorc vs0,vs0,vs0\");\n+#else\n+\t\tasm volatile (\"xxlorc 0,0,0\");\n+#endif\n+\t\treturn 0;\n+\t    }\n+\t} \"-mpower8-vector\"]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n # Return 1 if this is a PowerPC target supporting -mvsx\n \n proc check_effective_target_powerpc_vsx_ok { } {\n@@ -4576,6 +4629,7 @@ proc is-effective-target { arg } {\n \tswitch $arg {\n \t  \"vmx_hw\"         { set selected [check_vmx_hw_available] }\n \t  \"vsx_hw\"         { set selected [check_vsx_hw_available] }\n+\t  \"p8vector_hw\"    { set selected [check_p8vector_hw_available] }\n \t  \"ppc_recip_hw\"   { set selected [check_ppc_recip_hw_available] }\n \t  \"named_sections\" { set selected [check_named_sections_available] }\n \t  \"gc_sections\"    { set selected [check_gc_sections_available] }\n@@ -4597,6 +4651,7 @@ proc is-effective-target-keyword { arg } {\n \tswitch $arg {\n \t  \"vmx_hw\"         { return 1 }\n \t  \"vsx_hw\"         { return 1 }\n+\t  \"p8vector_hw\"    { return 1 }\n \t  \"ppc_recip_hw\"   { return 1 }\n \t  \"named_sections\" { return 1 }\n \t  \"gc_sections\"    { return 1 }\n@@ -5181,7 +5236,9 @@ proc check_vect_support_and_set_flags { } {\n         }\n \n         lappend DEFAULT_VECTCFLAGS \"-maltivec\"\n-        if [check_vsx_hw_available] {\n+        if [check_p8vector_hw_available] {\n+            lappend DEFAULT_VECTCFLAGS \"-mpower8-vector\" \"-mno-allow-movmisalign\"\n+        } elseif [check_vsx_hw_available] {\n             lappend DEFAULT_VECTCFLAGS \"-mvsx\" \"-mno-allow-movmisalign\"\n         }\n "}]}