{"sha": "7f1c097d36682769f1f3f8fd72c7845d545104ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YxYzA5N2QzNjY4Mjc2OWYxZjNmOGZkNzJjNzg0NWQ1NDUxMDRlZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-05-25T21:38:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-25T21:38:49Z"}, "message": "combine.c (try_combine): Use any_condjump_p...\n\n        * combine.c (try_combine): Use any_condjump_p, any_uncondjump_p\n        and pc_set at the place of simplejump_p and condjump_p.\n        * cse.c (record_jump_equiv): Likewise.\n        * emit-rtl.c (emit): Likewise.\n        * explow.c (find_next_ref): Likewise.\n        * flow.c (tidy_fallthru_edge): Likewise.\n        (init_propagate_block_info): Likewise.\n        * gcse.c (delete_null_pointer_checks): Likewise.\n        * ifcvt.c (cond_exec_get_condition, noce_get_condition,\n        dead_or_predicable): Likewise.\n        * integrate.c (copy_insn_list): Likewise.\n        * loop.c (scan_loop, verify_dominator, find_and_verify_loops,\n        for_each_insn_in_loop, check_dbra_loop, get_condition,\n        insert_bct, load_mems): Likewise.\n        * resource.c (find_dead_or_set_registers): Likewise.\n        * sibcalls.c (simplejump_p): Likewise.\n        * unroll.c (copy_loop_body, reg_dead_after_loop): Likewise.\n\nFrom-SVN: r34175", "tree": {"sha": "d95b18f4384b97d8d27889e062c1e3644fa14f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d95b18f4384b97d8d27889e062c1e3644fa14f68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f1c097d36682769f1f3f8fd72c7845d545104ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1c097d36682769f1f3f8fd72c7845d545104ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f1c097d36682769f1f3f8fd72c7845d545104ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1c097d36682769f1f3f8fd72c7845d545104ed/comments", "author": null, "committer": null, "parents": [{"sha": "acad7ed35f094e0456334422554ef2558851367c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acad7ed35f094e0456334422554ef2558851367c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acad7ed35f094e0456334422554ef2558851367c"}], "stats": {"total": 134, "additions": 80, "deletions": 54}, "files": [{"sha": "287cfb8cde2454847f8d4754e3dea3cfdad129cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -1,3 +1,23 @@\n+2000-05-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* combine.c (try_combine): Use any_condjump_p, any_uncondjump_p\n+\tand pc_set at the place of simplejump_p and condjump_p.\n+\t* cse.c (record_jump_equiv): Likewise.\n+\t* emit-rtl.c (emit): Likewise.\n+\t* explow.c (find_next_ref): Likewise.\n+\t* flow.c (tidy_fallthru_edge): Likewise.\n+\t(init_propagate_block_info): Likewise.\n+\t* gcse.c (delete_null_pointer_checks): Likewise.\n+\t* ifcvt.c (cond_exec_get_condition, noce_get_condition,\n+\tdead_or_predicable): Likewise.\n+\t* integrate.c (copy_insn_list): Likewise.\n+\t* loop.c (scan_loop, verify_dominator, find_and_verify_loops,\n+\tfor_each_insn_in_loop, check_dbra_loop, get_condition,\n+\tinsert_bct, load_mems): Likewise.\n+\t* resource.c (find_dead_or_set_registers): Likewise.\n+\t* sibcalls.c (simplejump_p): Likewise.\n+\t* unroll.c (copy_loop_body, reg_dead_after_loop): Likewise.\n+\n 2000-05-25  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.c (expand_block_move): Add 64-bit PowerPC doubleword move"}, {"sha": "c9d6a52f294c8a43eca8939ee52f3ee78ab39a90", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -2737,7 +2737,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n        BARRIER following it since it may have initially been a\n        conditional jump.  It may also be the last nonnote insn.  */\n     \n-    if (GET_CODE (newpat) == RETURN || simplejump_p (i3))\n+    if (GET_CODE (newpat) == RETURN || any_uncondjump_p (i3))\n       {\n \t*new_direct_jump_p = 1;\n "}, {"sha": "15210d85e0a8377f86836f67207f4932c114904e", "filename": "gcc/cse.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -4201,26 +4201,28 @@ record_jump_equiv (insn, taken)\n {\n   int cond_known_true;\n   rtx op0, op1;\n+  rtx set;\n   enum machine_mode mode, mode0, mode1;\n   int reversed_nonequality = 0;\n   enum rtx_code code;\n \n   /* Ensure this is the right kind of insn.  */\n-  if (! condjump_p (insn) || simplejump_p (insn))\n+  if (! any_condjump_p (insn))\n     return;\n+  set = pc_set (insn);\n \n   /* See if this jump condition is known true or false.  */\n   if (taken)\n-    cond_known_true = (XEXP (SET_SRC (PATTERN (insn)), 2) == pc_rtx);\n+    cond_known_true = (XEXP (SET_SRC (set), 2) == pc_rtx);\n   else\n-    cond_known_true = (XEXP (SET_SRC (PATTERN (insn)), 1) == pc_rtx);\n+    cond_known_true = (XEXP (SET_SRC (set), 1) == pc_rtx);\n \n   /* Get the type of comparison being done and the operands being compared.\n      If we had to reverse a non-equality condition, record that fact so we\n      know that it isn't valid for floating-point.  */\n-  code = GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 0));\n-  op0 = fold_rtx (XEXP (XEXP (SET_SRC (PATTERN (insn)), 0), 0), insn);\n-  op1 = fold_rtx (XEXP (XEXP (SET_SRC (PATTERN (insn)), 0), 1), insn);\n+  code = GET_CODE (XEXP (SET_SRC (set), 0));\n+  op0 = fold_rtx (XEXP (XEXP (SET_SRC (set), 0), 0), insn);\n+  op1 = fold_rtx (XEXP (XEXP (SET_SRC (set), 0), 1), insn);\n \n   code = find_comparison_args (code, &op0, &op1, &mode0, &mode1);\n   if (! cond_known_true)\n@@ -7033,7 +7035,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t basic block.  If we are jumping to the end of our block, show\n \t that we can have one usage of TO.  */\n \n-      if (simplejump_p (insn))\n+      if (any_uncondjump_p (insn))\n \t{\n \t  if (to == 0)\n \t    {"}, {"sha": "a455c1e44fc5efe204eb9d2e4f0c23a63af5a363", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -3457,7 +3457,7 @@ emit (x)\n   else if (code == JUMP_INSN)\n     {\n       register rtx insn = emit_jump_insn (x);\n-      if (simplejump_p (insn) || GET_CODE (x) == RETURN)\n+      if (any_uncondjump_p (insn) || GET_CODE (x) == RETURN)\n \treturn emit_barrier ();\n       return insn;\n     }"}, {"sha": "f689b88b9e1330b394b3ca6e1deb583d672d3fbe", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -294,7 +294,7 @@ find_next_ref (reg, insn)\n \t    return insn;\n \t  if (GET_CODE (insn) == JUMP_INSN)\n \t    {\n-\t      if (simplejump_p (insn))\n+\t      if (any_uncondjump_p (insn))\n \t\tnext = JUMP_LABEL (insn);\n \t      else\n \t\treturn 0;"}, {"sha": "ec621e555b40a87392154121d34470756b65540b", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -2454,13 +2454,14 @@ tidy_fallthru_edge (e, b, c)\n      note.  */\n   q = b->end;\n   if (GET_CODE (q) == JUMP_INSN\n-      && (simplejump_p (q)\n+      && onlyjump_p (q)\n+      && (any_uncondjump_p (q)\n \t  || (b->succ == e && e->succ_next == NULL)))\n     {\n #ifdef HAVE_cc0\n       /* If this was a conditional jump, we need to also delete\n \t the insn that set cc0.  */\n-      if (! simplejump_p (q) && condjump_p (q) && sets_cc0_p (PREV_INSN (q)))\n+      if (any_condjump_p (q) && sets_cc0_p (PREV_INSN (q)))\n \tq = PREV_INSN (q);\n #endif\n \n@@ -3589,8 +3590,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n      from one side of the branch and not the other, record the register\n      as conditionally dead.  */\n   if (GET_CODE (bb->end) == JUMP_INSN\n-      && condjump_p (bb->end)\n-      && ! simplejump_p (bb->end))\n+      && any_condjump_p (bb->end))\n     {\n       regset_head diff_head;\n       regset diff = INITIALIZE_REG_SET (diff_head);"}, {"sha": "4665133ee60212b34053dcf1488f77bab190b273", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -5101,8 +5101,8 @@ delete_null_pointer_checks (f)\n \n       /* We only want conditional branches.  */\n       if (GET_CODE (last_insn) != JUMP_INSN\n-\t  || !condjump_p (last_insn)\n-\t  || simplejump_p (last_insn))\n+\t  || !any_condjump_p (last_insn)\n+\t  || !onlyjump_p (last_insn))\n \tcontinue;\n \n       /* LAST_INSN is a conditional jump.  Get its condition.  */"}, {"sha": "088efd0943dae893fbcd3fb216e68c3a440dd692", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -247,10 +247,8 @@ cond_exec_get_condition (jump)\n {\n   rtx test_if, cond;\n \n-  if (condjump_p (jump))\n-    test_if = SET_SRC (PATTERN (jump));\n-  else if (condjump_in_parallel_p (jump))\n-    test_if = SET_SRC (XVECEXP (PATTERN (jump), 0, 0));\n+  if (any_condjump_p (jump))\n+    test_if = pc_set (jump);\n   else\n     return NULL_RTX;\n   cond = XEXP (test_if, 0);\n@@ -1014,23 +1012,26 @@ noce_get_condition (jump, earliest)\n      rtx *earliest;\n {\n   rtx cond;\n+  rtx set;\n \n   /* If the condition variable is a register and is MODE_INT, accept it.\n      Otherwise, fall back on get_condition.  */\n \n-  if (! condjump_p (jump))\n+  if (! any_condjump_p (jump))\n     return NULL_RTX;\n \n-  cond = XEXP (SET_SRC (PATTERN (jump)), 0);\n+  set = pc_set (jump);\n+\n+  cond = XEXP (SET_SRC (set), 0);\n   if (GET_CODE (XEXP (cond, 0)) == REG\n       && GET_MODE_CLASS (GET_MODE (XEXP (cond, 0))) == MODE_INT)\n     {\n       *earliest = jump;\n \n       /* If this branches to JUMP_LABEL when the condition is false,\n \t reverse the condition.  */\n-      if (GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 2)) == LABEL_REF\n-\t  && XEXP (XEXP (SET_SRC (PATTERN (jump)), 2), 0) == JUMP_LABEL (jump))\n+      if (GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n+\t  && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump))\n \tcond = gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond)),\n \t\t\t       GET_MODE (cond), XEXP (cond, 0),\n \t\t\t       XEXP (cond, 1));\n@@ -1840,7 +1841,7 @@ dead_or_predicable (test_bb, merge_bb, other_bb, new_dest, reversep)\n \t    break;\n \t}\n \n-      if (! condjump_p (jump))\n+      if (! any_condjump_p (jump))\n \treturn FALSE;\n \n       /* Find the extent of the conditional.  */"}, {"sha": "53295744ff48bc2b0664788891ca3cd4acdcc3e2", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -1400,7 +1400,7 @@ copy_insn_list (insns, map, static_chain_value)\n \n \t  /* If this used to be a conditional jump insn but whose branch\n \t     direction is now know, we must do something special.  */\n-\t  if (condjump_p (insn) && ! simplejump_p (insn) && map->last_pc_value)\n+\t  if (any_condjump_p (insn) && onlyjump_p (insn) && map->last_pc_value)\n \t    {\n #ifdef HAVE_cc0\n \t      /* If the previous insn set cc0 for us, delete it.  */"}, {"sha": "a5e878721ecc7746f77c9cb393f1af14784d9f77", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -553,16 +553,16 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t\t   && GET_CODE (PATTERN (temp)) == TRAP_IF\n \t\t   && (this_is_any_uncondjump\n \t\t       || (this_is_any_condjump\n-\t\t\t   && temp2 = get_condition (insn, &temp4))))\n+\t\t\t   && (temp2 = get_condition (insn, &temp4)))))\n \t    {\n \t      rtx tc = TRAP_CONDITION (PATTERN (temp));\n \n \t      if (tc == const_true_rtx\n-\t\t  || (! this_is_uncondjump && rtx_equal_p (temp2, tc)))\n+\t\t  || (! this_is_any_uncondjump && rtx_equal_p (temp2, tc)))\n \t\t{\n \t\t  rtx new;\n \t\t  /* Replace an unconditional jump to a trap with a trap.  */\n-\t\t  if (this_is_uncondjump)\n+\t\t  if (this_is_any_uncondjump)\n \t\t    {\n \t\t      emit_barrier_after (emit_insn_before (gen_trap (), insn));\n \t\t      delete_jump (insn);"}, {"sha": "90abf7e84344103131eed5aa9e5d1992534e91c2", "filename": "gcc/loop.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -668,7 +668,7 @@ scan_loop (loop, flags)\n       loop_entry_jump = p;\n \n       /* Loop entry must be unconditional jump (and not a RETURN)  */\n-      if (simplejump_p (p)\n+      if (any_uncondjump_p (p)\n \t  && JUMP_LABEL (p) != 0\n \t  /* Check to see whether the jump actually\n \t     jumps out of the loop (meaning it's no loop).\n@@ -1074,7 +1074,7 @@ scan_loop (loop, flags)\n \t\t  followed a by barrier then loop end.  */\n                && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop->top\n \t\t     && NEXT_INSN (NEXT_INSN (p)) == loop_end\n-\t\t     && simplejump_p (p)))\n+\t\t     && any_uncondjump_p (p)))\n \tmaybe_never = 1;\n       else if (GET_CODE (p) == NOTE)\n \t{\n@@ -2569,8 +2569,7 @@ verify_dominator (loop)\n \t     which we do not have jump target information in the JUMP_LABEL\n \t     field (consider ADDR_VEC and ADDR_DIFF_VEC insns), then clear\n \t     LOOP->CONT_DOMINATOR.  */\n-\t  if ((! condjump_p (insn)\n-\t       && ! condjump_in_parallel_p (insn))\n+\t  if (! any_condjump_p (insn)\n \t      || label == NULL_RTX)\n \t    {\n \t      loop->cont_dominator = NULL_RTX;\n@@ -2666,7 +2665,7 @@ find_and_verify_loops (f, loops)\n \t{\n \t  rtx label = JUMP_LABEL (insn);\n \n-\t  if (! condjump_p (insn) && ! condjump_in_parallel_p (insn))\n+\t  if (! any_condjump_p (insn))\n \t    label = NULL_RTX;\n \n \t  loop = current_loop;\n@@ -2760,7 +2759,8 @@ find_and_verify_loops (f, loops)\n \t/* See if this is an unconditional branch outside the loop.  */\n \tif (this_loop\n \t    && (GET_CODE (PATTERN (insn)) == RETURN\n-\t\t|| (simplejump_p (insn)\n+\t\t|| (any_uncondjump_p (insn)\n+\t\t    && onlyjump_p (insn)\n \t\t    && (uid_loop[INSN_UID (JUMP_LABEL (insn))]\n \t\t\t!= this_loop)))\n \t    && get_max_uid () < max_uid_for_loop)\n@@ -2817,8 +2817,7 @@ find_and_verify_loops (f, loops)\n \t\t/* Just ignore jumps to labels that were never emitted.\n \t\t   These always indicate compilation errors.  */\n \t\t&& INSN_UID (JUMP_LABEL (p)) != 0\n-\t\t&& condjump_p (p)\n-\t\t&& ! simplejump_p (p)\n+\t\t&& any_condjump_p (p) && onlyjump_p (p)\n \t\t&& next_real_insn (JUMP_LABEL (p)) == our_next\n \t\t/* If it's not safe to move the sequence, then we\n \t\t   mustn't try.  */\n@@ -3757,7 +3756,7 @@ for_each_insn_in_loop (loop, fncall)\n \n \t      if (GET_CODE (insn) == JUMP_INSN\n \t\t  && GET_CODE (PATTERN (insn)) != RETURN\n-\t\t  && (!condjump_p (insn)\n+\t\t  && (!any_condjump_p (insn)\n \t\t      || (JUMP_LABEL (insn) != 0\n \t\t\t  && JUMP_LABEL (insn) != loop->scan_start\n \t\t\t  && !loop_insn_first_p (p, JUMP_LABEL (insn)))))\n@@ -3778,8 +3777,9 @@ for_each_insn_in_loop (loop, fncall)\n          This can be any kind of jump, since we want to know if insns\n          will be executed if the loop is executed.  */\n \t  && !(JUMP_LABEL (p) == loop->top\n-\t     && ((NEXT_INSN (NEXT_INSN (p)) == loop->end && simplejump_p (p))\n-\t\t || (NEXT_INSN (p) == loop->end && condjump_p (p)))))\n+\t     && ((NEXT_INSN (NEXT_INSN (p)) == loop->end\n+\t\t  && any_uncondjump_p (p))\n+\t\t || (NEXT_INSN (p) == loop->end && any_condjump_p (p)))))\n \t{\n \t  rtx label = 0;\n \n@@ -7782,6 +7782,8 @@ check_dbra_loop (loop, insn_count)\n   comparison = get_condition_for_loop (loop, jump);\n   if (comparison == 0)\n     return 0;\n+  if (!onlyjump_p (jump))\n+    return 0;\n \n   /* Try to compute whether the compare/branch at the loop end is one or\n      two instructions.  */\n@@ -9189,19 +9191,21 @@ get_condition (jump, earliest)\n {\n   rtx cond;\n   int reverse;\n+  rtx set;\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n   if (GET_CODE (jump) != JUMP_INSN\n-      || ! condjump_p (jump) || simplejump_p (jump))\n+      || ! any_condjump_p (jump))\n     return 0;\n+  set = pc_set (jump);\n \n-  cond = XEXP (SET_SRC (PATTERN (jump)), 0);\n+  cond = XEXP (SET_SRC (set), 0);\n \n   /* If this branches to JUMP_LABEL when the condition is false, reverse\n      the condition.  */\n   reverse\n-    = GET_CODE (XEXP (SET_SRC (PATTERN (jump)), 2)) == LABEL_REF\n-      && XEXP (XEXP (SET_SRC (PATTERN (jump)), 2), 0) == JUMP_LABEL (jump);\n+    = GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n+      && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump);\n \n   return canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX);\n }\n@@ -9276,8 +9280,8 @@ insert_bct (loop)\n \n   /* Make sure that the last loop insn is a conditional jump.  */\n   if (GET_CODE (PREV_INSN (loop_end)) != JUMP_INSN\n-      || ! condjump_p (PREV_INSN (loop_end))\n-      || simplejump_p (PREV_INSN (loop_end)))\n+      || ! onlyjump_p (PREV_INSN (loop_end))\n+      || ! any_condjump_p (PREV_INSN (loop_end)))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -9712,9 +9716,9 @@ load_mems (loop)\n \t       && ! (GET_CODE (p) == JUMP_INSN \n \t\t     && JUMP_LABEL (p) == loop->top\n \t\t     && NEXT_INSN (NEXT_INSN (p)) == loop->end\n-\t\t     && simplejump_p (p)))\n+\t\t     && any_uncondjump_p (p)))\n \t{\n-\t  if (!condjump_p (p))\n+\t  if (!any_condjump_p (p))\n \t    /* Something complicated.  */\n \t    maybe_never = 1;\n \t  else"}, {"sha": "23f5e0e4ead50ca05a17552a8ebca21e3127d0c5", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -472,7 +472,7 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \t{\n \t  if (jump_count++ < 10)\n \t    {\n-\t      if (simplejump_p (this_jump_insn)\n+\t      if (any_uncondjump_p (this_jump_insn)\n \t\t  || GET_CODE (PATTERN (this_jump_insn)) == RETURN)\n \t\t{\n \t\t  next = JUMP_LABEL (this_jump_insn);\n@@ -483,8 +483,7 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \t\t\t*jump_target = JUMP_LABEL (this_jump_insn);\n \t\t    }\n \t\t}\n-\t      else if (condjump_p (this_jump_insn)\n-\t\t       || condjump_in_parallel_p (this_jump_insn))\n+\t      else if (any_condjump_p (this_jump_insn))\n \t\t{\n \t\t  struct resources target_set, target_res;\n \t\t  struct resources fallthrough_res;"}, {"sha": "8387bf5d79b5292dc34f6506872806bf41843ee1", "filename": "gcc/sibcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -229,7 +229,7 @@ skip_jump_insn (orig_insn)\n \n   if (insn\n       && GET_CODE (insn) == JUMP_INSN\n-      && simplejump_p (insn))\n+      && any_uncondjump_p (insn))\n     return insn;\n \n   return orig_insn;"}, {"sha": "f8dfc034b5a497973281e4f86174ee5bf0616023", "filename": "gcc/unroll.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1c097d36682769f1f3f8fd72c7845d545104ed/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=7f1c097d36682769f1f3f8fd72c7845d545104ed", "patch": "@@ -2124,7 +2124,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \n \t  /* If this used to be a conditional jump insn but whose branch\n \t     direction is now known, we must do something special.  */\n-\t  if (condjump_p (insn) && !simplejump_p (insn) && map->last_pc_value)\n+\t  if (any_condjump_p (insn) && onlyjump_p (insn) && map->last_pc_value)\n \t    {\n #ifdef HAVE_cc0\n \t      /* If the previous insn set cc0 for us, delete it.  */\n@@ -3281,7 +3281,7 @@ reg_dead_after_loop (loop, reg)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == RETURN)\n \t\tbreak;\n-\t      else if (! simplejump_p (insn)\n+\t      else if (!any_uncondjump_p (insn)\n \t\t       /* Prevent infinite loop following infinite loops.  */\n \t\t       || jump_count++ > 20)\n \t\treturn 0;"}]}