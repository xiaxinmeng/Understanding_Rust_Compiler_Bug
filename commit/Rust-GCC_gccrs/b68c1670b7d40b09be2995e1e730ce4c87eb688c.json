{"sha": "b68c1670b7d40b09be2995e1e730ce4c87eb688c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY4YzE2NzBiN2Q0MGIwOWJlMjk5NWUxZTczMGNlNGM4N2ViNjg4Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-01-21T11:44:25Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-04T09:10:58Z"}, "message": "[Ada] Remove System.Parameters.Single_Lock\n\n2020-06-04  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* libgnarl/a-dynpri.adb, libgnarl/a-taside.adb,\n\tlibgnarl/a-taster.adb, libgnarl/s-interr.adb,\n\tlibgnarl/s-interr__sigaction.adb, libgnarl/s-taasde.adb,\n\tlibgnarl/s-taenca.adb, libgnarl/s-taenca.ads,\n\tlibgnarl/s-taprop.ads, libgnarl/s-taprop__hpux-dce.adb,\n\tlibgnarl/s-taprop__linux.adb, libgnarl/s-taprop__mingw.adb,\n\tlibgnarl/s-taprop__posix.adb, libgnarl/s-taprop__qnx.adb,\n\tlibgnarl/s-taprop__solaris.adb, libgnarl/s-taprop__vxworks.adb,\n\tlibgnarl/s-tarest.adb, libgnarl/s-tasini.adb,\n\tlibgnarl/s-tasque.adb, libgnarl/s-tasque.ads,\n\tlibgnarl/s-tasren.adb, libgnarl/s-tasren.ads,\n\tlibgnarl/s-tassta.adb, libgnarl/s-tasuti.adb,\n\tlibgnarl/s-tasuti.ads, libgnarl/s-tpoben.adb,\n\tlibgnarl/s-tpobop.adb, libgnarl/s-tpopmo.adb,\n\tlibgnarl/s-tposen.adb, libgnat/s-parame.ads,\n\tlibgnat/s-parame__ae653.ads, libgnat/s-parame__hpux.ads,\n\tlibgnat/s-parame__vxworks.ads: Remove references to Single_Lock\n\tand Global_Lock.", "tree": {"sha": "3b8fa447ce36bcc0602fff3dfaa145ede658aa87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b8fa447ce36bcc0602fff3dfaa145ede658aa87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b68c1670b7d40b09be2995e1e730ce4c87eb688c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68c1670b7d40b09be2995e1e730ce4c87eb688c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b68c1670b7d40b09be2995e1e730ce4c87eb688c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68c1670b7d40b09be2995e1e730ce4c87eb688c/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbe376e136edb8456088d7298d4ba7c93d4e0529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe376e136edb8456088d7298d4ba7c93d4e0529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe376e136edb8456088d7298d4ba7c93d4e0529"}], "stats": {"total": 1658, "additions": 283, "deletions": 1375}, "files": [{"sha": "a7e11f3db9106346b4d60e5aeabc5671e9f80678", "filename": "gcc/ada/libgnarl/a-dynpri.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fa-dynpri.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fa-dynpri.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fa-dynpri.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -31,7 +31,6 @@\n \n with System.Task_Primitives.Operations;\n with System.Tasking;\n-with System.Parameters;\n with System.Soft_Links;\n \n with Ada.Unchecked_Conversion;\n@@ -41,7 +40,6 @@ package body Ada.Dynamic_Priorities is\n    package STPO renames System.Task_Primitives.Operations;\n    package SSL renames System.Soft_Links;\n \n-   use System.Parameters;\n    use System.Tasking;\n \n    function Convert_Ids is new\n@@ -103,10 +101,6 @@ package body Ada.Dynamic_Priorities is\n \n       SSL.Abort_Defer.all;\n \n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Target);\n \n       Target.Common.Base_Priority := Priority;\n@@ -141,10 +135,6 @@ package body Ada.Dynamic_Priorities is\n \n       STPO.Unlock (Target);\n \n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      end if;\n-\n       if STPO.Self = Target and then Yield_Needed then\n \n          --  Yield is needed to enforce FIFO task dispatching"}, {"sha": "9df547f8dfff441e7db4b97ef2f97fbe024458cb", "filename": "gcc/ada/libgnarl/a-taside.adb", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fa-taside.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fa-taside.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fa-taside.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -30,7 +30,6 @@\n ------------------------------------------------------------------------------\n \n with System.Address_Image;\n-with System.Parameters;\n with System.Soft_Links;\n with System.Task_Primitives;\n with System.Task_Primitives.Operations;\n@@ -48,9 +47,6 @@ pragma Warnings (On);\n package body Ada.Task_Identification with\n   SPARK_Mode => Off\n is\n-\n-   use System.Parameters;\n-\n    package STPO renames System.Task_Primitives.Operations;\n \n    -----------------------\n@@ -165,20 +161,11 @@ is\n          raise Program_Error;\n       else\n          System.Soft_Links.Abort_Defer.all;\n-\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Id);\n          Result := Id.Callable;\n          STPO.Unlock (Id);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n          System.Soft_Links.Abort_Undefer.all;\n+\n          return Result;\n       end if;\n    end Is_Callable;\n@@ -198,20 +185,11 @@ is\n          raise Program_Error;\n       else\n          System.Soft_Links.Abort_Defer.all;\n-\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Id);\n          Result := Id.Common.State = Terminated;\n          STPO.Unlock (Id);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n          System.Soft_Links.Abort_Undefer.all;\n+\n          return Result;\n       end if;\n    end Is_Terminated;"}, {"sha": "fdf4811a09d83fc0d13a19f8e015a538173a9028", "filename": "gcc/ada/libgnarl/a-taster.adb", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fa-taster.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fa-taster.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fa-taster.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -31,7 +31,6 @@\n \n with System.Tasking;\n with System.Task_Primitives.Operations;\n-with System.Parameters;\n with System.Soft_Links;\n \n with Ada.Unchecked_Conversion;\n@@ -43,8 +42,6 @@ package body Ada.Task_Termination is\n    package STPO renames System.Task_Primitives.Operations;\n    package SSL  renames System.Soft_Links;\n \n-   use System.Parameters;\n-\n    -----------------------\n    -- Local subprograms --\n    -----------------------\n@@ -82,21 +79,11 @@ package body Ada.Task_Termination is\n \n    begin\n       SSL.Abort_Defer.all;\n-\n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Self);\n \n       Self.Common.Fall_Back_Handler := To_ST (Handler);\n \n       STPO.Unlock (Self);\n-\n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      end if;\n-\n       SSL.Abort_Undefer.all;\n    end Set_Dependents_Fallback_Handler;\n \n@@ -123,21 +110,11 @@ package body Ada.Task_Termination is\n \n          begin\n             SSL.Abort_Defer.all;\n-\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Target);\n \n             Target.Common.Specific_Handler := To_ST (Handler);\n \n             STPO.Unlock (Target);\n-\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n-\n             SSL.Abort_Undefer.all;\n          end;\n       end if;\n@@ -166,21 +143,11 @@ package body Ada.Task_Termination is\n \n          begin\n             SSL.Abort_Defer.all;\n-\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Target);\n \n             TH := To_TT (Target.Common.Specific_Handler);\n \n             STPO.Unlock (Target);\n-\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n-\n             SSL.Abort_Undefer.all;\n \n             return TH;"}, {"sha": "c386c4742a2b244b9a87d229be2baef2db219aef", "filename": "gcc/ada/libgnarl/s-interr.adb", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-interr.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -1288,11 +1288,6 @@ package body System.Interrupts is\n \n       loop\n          System.Tasking.Initialization.Defer_Abort (Self_ID);\n-\n-         if Single_Lock then\n-            POP.Lock_RTS;\n-         end if;\n-\n          POP.Write_Lock (Self_ID);\n \n          if User_Handler (Interrupt).H = null\n@@ -1327,10 +1322,6 @@ package body System.Interrupts is\n             Self_ID.Common.State := Interrupt_Server_Blocked_On_Event_Flag;\n             POP.Unlock (Self_ID);\n \n-            if Single_Lock then\n-               POP.Unlock_RTS;\n-            end if;\n-\n             --  Avoid race condition when terminating application and\n             --  System.Parameters.No_Abort is True.\n \n@@ -1347,18 +1338,9 @@ package body System.Interrupts is\n                --  Inform the Interrupt_Manager of wakeup from above sigwait\n \n                POP.Abort_Task (Interrupt_Manager_ID);\n-\n-               if Single_Lock then\n-                  POP.Lock_RTS;\n-               end if;\n-\n                POP.Write_Lock (Self_ID);\n \n             else\n-               if Single_Lock then\n-                  POP.Lock_RTS;\n-               end if;\n-\n                POP.Write_Lock (Self_ID);\n \n                if Ret_Interrupt /= Interrupt then\n@@ -1383,17 +1365,7 @@ package body System.Interrupts is\n                      --  RTS calls should not be made with self being locked\n \n                      POP.Unlock (Self_ID);\n-\n-                     if Single_Lock then\n-                        POP.Unlock_RTS;\n-                     end if;\n-\n                      Tmp_Handler.all;\n-\n-                     if Single_Lock then\n-                        POP.Lock_RTS;\n-                     end if;\n-\n                      POP.Write_Lock (Self_ID);\n \n                   elsif User_Entry (Interrupt).T /= Null_Task then\n@@ -1402,21 +1374,13 @@ package body System.Interrupts is\n \n                      --  RTS calls should not be made with self being locked\n \n-                     if Single_Lock then\n-                        POP.Unlock_RTS;\n-                     end if;\n-\n                      POP.Unlock (Self_ID);\n \n                      System.Tasking.Rendezvous.Call_Simple\n                        (Tmp_ID, Tmp_Entry_Index, System.Null_Address);\n \n                      POP.Write_Lock (Self_ID);\n \n-                     if Single_Lock then\n-                        POP.Lock_RTS;\n-                     end if;\n-\n                   else\n                      --  This is a situation that this task wakes up receiving\n                      --  an Interrupt and before it gets the lock the Interrupt\n@@ -1432,11 +1396,6 @@ package body System.Interrupts is\n          end if;\n \n          POP.Unlock (Self_ID);\n-\n-         if Single_Lock then\n-            POP.Unlock_RTS;\n-         end if;\n-\n          System.Tasking.Initialization.Undefer_Abort (Self_ID);\n \n          if Self_ID.Pending_Action then"}, {"sha": "83bd36c2efa6051d87d08b2d0aaf85251aeab44e", "filename": "gcc/ada/libgnarl/s-interr__sigaction.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-interr__sigaction.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-interr__sigaction.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-interr__sigaction.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -42,11 +42,9 @@ with System.Tasking.Utilities;\n with System.Tasking.Rendezvous;\n with System.Tasking.Initialization;\n with System.Interrupt_Management;\n-with System.Parameters;\n \n package body System.Interrupts is\n \n-   use Parameters;\n    use Tasking;\n    use System.OS_Interface;\n    use Interfaces.C;\n@@ -644,21 +642,11 @@ package body System.Interrupts is\n          end loop;\n \n          Initialization.Defer_Abort (Self_Id);\n-\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Self_Id);\n          Self_Id.Common.State := Interrupt_Server_Idle_Sleep;\n          STPO.Sleep (Self_Id, Interrupt_Server_Idle_Sleep);\n          Self_Id.Common.State := Runnable;\n          STPO.Unlock (Self_Id);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n          Initialization.Undefer_Abort (Self_Id);\n \n          --  Undefer abort here to allow a window for this task to be aborted"}, {"sha": "dc7dac16cca723218582be001760d8cf590a9c20", "filename": "gcc/ada/libgnarl/s-taasde.adb", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taasde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taasde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taasde.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -51,8 +51,6 @@ package body System.Tasking.Async_Delays is\n    package STI renames System.Tasking.Initialization;\n    package OSP renames System.OS_Primitives;\n \n-   use Parameters;\n-\n    function To_System is new Ada.Unchecked_Conversion\n      (Ada.Task_Identification.Task_Id, Task_Id);\n \n@@ -118,11 +116,6 @@ package body System.Tasking.Async_Delays is\n       --  Remove self from timer queue\n \n       STI.Defer_Abort_Nestable (D.Self_Id);\n-\n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Timer_Server_ID);\n       Dpred := D.Pred;\n       Dsucc := D.Succ;\n@@ -141,11 +134,6 @@ package body System.Tasking.Async_Delays is\n       STPO.Write_Lock (D.Self_Id);\n       STU.Exit_One_ATC_Level (D.Self_Id);\n       STPO.Unlock (D.Self_Id);\n-\n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      end if;\n-\n       STI.Undefer_Abort_Nestable (D.Self_Id);\n    end Cancel_Async_Delay;\n \n@@ -217,11 +205,6 @@ package body System.Tasking.Async_Delays is\n       D.Level := Self_Id.ATC_Nesting_Level;\n       D.Self_Id := Self_Id;\n       D.Resume_Time := T;\n-\n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Timer_Server_ID);\n \n       --  Previously, there was code here to dynamically create\n@@ -258,10 +241,6 @@ package body System.Tasking.Async_Delays is\n       end if;\n \n       STPO.Unlock (Timer_Server_ID);\n-\n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      end if;\n    end Time_Enqueue;\n \n    ---------------\n@@ -305,11 +284,6 @@ package body System.Tasking.Async_Delays is\n \n       loop\n          STI.Defer_Abort (Timer_Server_ID);\n-\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Timer_Server_ID);\n \n          --  The timer server needs to catch pending aborts after finalization\n@@ -383,11 +357,6 @@ package body System.Tasking.Async_Delays is\n          --  an actual delay in this server.\n \n          STPO.Unlock (Timer_Server_ID);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n          STI.Undefer_Abort (Timer_Server_ID);\n       end loop;\n    end Timer_Server;"}, {"sha": "49c4c3026f7d8034f3366a3a171eb04984535bb5", "filename": "gcc/ada/libgnarl/s-taenca.adb", "status": "modified", "additions": 3, "deletions": 79, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taenca.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taenca.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taenca.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -35,13 +35,11 @@ with System.Tasking.Protected_Objects.Entries;\n with System.Tasking.Protected_Objects.Operations;\n with System.Tasking.Queuing;\n with System.Tasking.Utilities;\n-with System.Parameters;\n \n package body System.Tasking.Entry_Calls is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n-   use Parameters;\n    use Protected_Objects.Entries;\n    use Protected_Objects.Operations;\n \n@@ -71,24 +69,18 @@ package body System.Tasking.Entry_Calls is\n    --  permitted. Since the server cannot be obtained reliably, it must be\n    --  obtained unreliably and then checked again once it has been locked.\n    --\n-   --  If Single_Lock and server is a PO, release RTS_Lock\n-   --\n    --  This should only be called by the Entry_Call.Self.\n    --  It should be holding no other ATCB locks at the time.\n \n    procedure Unlock_Server (Entry_Call : Entry_Call_Link);\n    --  STPO.Unlock the server targeted by Entry_Call. The server must\n    --  be locked before calling this.\n-   --\n-   --  If Single_Lock and server is a PO, take RTS_Lock on exit.\n \n    procedure Unlock_And_Update_Server\n      (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link);\n    --  Similar to Unlock_Server, but services entry calls if the\n    --  server is a protected object.\n-   --\n-   --  If Single_Lock and server is a PO, take RTS_Lock on exit.\n \n    procedure Check_Pending_Actions_For_Entry_Call\n      (Self_ID    : Task_Id;\n@@ -200,19 +192,9 @@ package body System.Tasking.Entry_Calls is\n                --  We had very bad luck, interleaving with TWO different\n                --  requeue operations. Go around the loop and try again.\n \n-               if Single_Lock then\n-                  STPO.Unlock_RTS;\n-                  STPO.Yield;\n-                  STPO.Lock_RTS;\n-               else\n-                  STPO.Yield;\n-               end if;\n+               STPO.Yield;\n \n             else\n-               if Single_Lock then\n-                  STPO.Unlock_RTS;\n-               end if;\n-\n                Lock_Entries_With_Status (Test_PO, Ceiling_Violation);\n \n                --  ???\n@@ -232,21 +214,13 @@ package body System.Tasking.Entry_Calls is\n                      Old_Base_Priority : System.Any_Priority;\n \n                   begin\n-                     if Single_Lock then\n-                        STPO.Lock_RTS;\n-                     end if;\n-\n                      STPO.Write_Lock (Current_Task);\n                      Old_Base_Priority := Current_Task.Common.Base_Priority;\n                      Current_Task.New_Base_Priority := Test_PO.Ceiling;\n                      System.Tasking.Initialization.Change_Base_Priority\n                        (Current_Task);\n                      STPO.Unlock (Current_Task);\n \n-                     if Single_Lock then\n-                        STPO.Unlock_RTS;\n-                     end if;\n-\n                      --  Following lock should not fail\n \n                      Lock_Entries (Test_PO);\n@@ -258,10 +232,6 @@ package body System.Tasking.Entry_Calls is\n \n                exit when To_Address (Test_PO) = Entry_Call.Called_PO;\n                Unlock_Entries (Test_PO);\n-\n-               if Single_Lock then\n-                  STPO.Lock_RTS;\n-               end if;\n             end if;\n \n          else\n@@ -343,11 +313,6 @@ package body System.Tasking.Entry_Calls is\n \n       pragma Assert (Entry_Call.Mode = Asynchronous_Call);\n       Initialization.Defer_Abort_Nestable (Self_ID);\n-\n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Self_ID);\n       Entry_Call.Cancellation_Attempted := True;\n \n@@ -357,13 +322,7 @@ package body System.Tasking.Entry_Calls is\n \n       Entry_Calls.Wait_For_Completion (Entry_Call);\n       STPO.Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      end if;\n-\n       Succeeded := Entry_Call.State = Cancelled;\n-\n       Initialization.Undefer_Abort_Nestable (Self_ID);\n \n       --  Ideally, abort should no longer be deferred at this point, so we\n@@ -401,26 +360,13 @@ package body System.Tasking.Entry_Calls is\n          if Called_PO.Pending_Action then\n             Called_PO.Pending_Action := False;\n             Caller := STPO.Self;\n-\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Caller);\n             Caller.New_Base_Priority := Called_PO.Old_Base_Priority;\n             Initialization.Change_Base_Priority (Caller);\n             STPO.Unlock (Caller);\n-\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n          end if;\n \n          Unlock_Entries (Called_PO);\n-\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n       end if;\n    end Unlock_And_Update_Server;\n \n@@ -441,26 +387,13 @@ package body System.Tasking.Entry_Calls is\n          if Called_PO.Pending_Action then\n             Called_PO.Pending_Action := False;\n             Caller := STPO.Self;\n-\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Caller);\n             Caller.New_Base_Priority := Called_PO.Old_Base_Priority;\n             Initialization.Change_Base_Priority (Caller);\n             STPO.Unlock (Caller);\n-\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n          end if;\n \n          Unlock_Entries (Called_PO);\n-\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n       end if;\n    end Unlock_Server;\n \n@@ -481,21 +414,13 @@ package body System.Tasking.Entry_Calls is\n       --  a chance of getting ready immediately, using Unlock & Yield.\n       --  See similar action in Wait_For_Call & Timed_Selective_Wait.\n \n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      else\n-         STPO.Unlock (Self_Id);\n-      end if;\n+      STPO.Unlock (Self_Id);\n \n       if Entry_Call.State < Done then\n          STPO.Yield;\n       end if;\n \n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      else\n-         STPO.Write_Lock (Self_Id);\n-      end if;\n+      STPO.Write_Lock (Self_Id);\n \n       loop\n          Check_Pending_Actions_For_Entry_Call (Self_Id, Entry_Call);\n@@ -507,7 +432,6 @@ package body System.Tasking.Entry_Calls is\n \n       Self_Id.Common.State := Runnable;\n       Utilities.Exit_One_ATC_Level (Self_Id);\n-\n    end Wait_For_Completion;\n \n    --------------------------------------"}, {"sha": "2b013eb5ba7a9817ed349c7e2bb53ee421376bdb", "filename": "gcc/ada/libgnarl/s-taenca.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taenca.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taenca.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taenca.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -61,8 +61,7 @@ package System.Tasking.Entry_Calls is\n       Call    : Entry_Call_Link);\n    --  This procedure suspends the calling task until the specified entry\n    --  call is queued abortably or completes.\n-   --  Abortion must be deferred when calling this procedure, and the global\n-   --  RTS lock taken when Single_Lock.\n+   --  Abortion must be deferred when calling this procedure.\n \n    procedure Try_To_Cancel_Entry_Call (Succeeded : out Boolean);\n    pragma Inline (Try_To_Cancel_Entry_Call);"}, {"sha": "32faac57485b859ae10c0b673eae51454a3332b6", "filename": "gcc/ada/libgnarl/s-taprop.ads", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -181,11 +181,8 @@ package System.Task_Primitives.Operations is\n    procedure Write_Lock\n      (L                 : not null access Lock;\n       Ceiling_Violation : out Boolean);\n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False);\n-   procedure Write_Lock\n-     (T : ST.Task_Id);\n+   procedure Write_Lock (L : not null access RTS_Lock);\n+   procedure Write_Lock (T : ST.Task_Id);\n    pragma Inline (Write_Lock);\n    --  Lock a lock object for write access. After this operation returns,\n    --  the calling task holds write permission for the lock object. No other\n@@ -198,9 +195,6 @@ package System.Task_Primitives.Operations is\n    --  operation failed, which will happen if there is a priority ceiling\n    --  violation.\n    --\n-   --  For the operation on RTS_Lock, Global_Lock should be set to True\n-   --  if L is a global lock (Single_RTS_Lock, Global_Task_Lock).\n-   --\n    --  For the operation on ST.Task_Id, the lock is the special lock object\n    --  associated with that task's ATCB. This lock has effective ceiling\n    --  priority high enough that it is safe to call by a task with any\n@@ -235,11 +229,8 @@ package System.Task_Primitives.Operations is\n \n    procedure Unlock\n      (L : not null access Lock);\n-   procedure Unlock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False);\n-   procedure Unlock\n-     (T : ST.Task_Id);\n+   procedure Unlock (L : not null access RTS_Lock);\n+   procedure Unlock (T : ST.Task_Id);\n    pragma Inline (Unlock);\n    --  Unlock a locked lock object\n    --\n@@ -249,9 +240,6 @@ package System.Task_Primitives.Operations is\n    --  read or write permission. (That is, matching pairs of Lock and Unlock\n    --  operations on each lock object must be properly nested.)\n \n-   --  For the operation on RTS_Lock, Global_Lock should be set to True if L\n-   --  is a global lock (Single_RTS_Lock, Global_Task_Lock).\n-   --\n    --  Note that Write_Lock for RTS_Lock does not have an out-parameter.\n    --  RTS_Locks are used in situations where we have not made provision for\n    --  recovery from ceiling violations. We do not expect them to occur inside\n@@ -424,10 +412,7 @@ package System.Task_Primitives.Operations is\n \n    --  Following two routines are used for possible operations needed to be\n    --  setup/cleared upon entrance/exit of RTS while maintaining a single\n-   --  thread of control in the RTS. Since we intend these routines to be used\n-   --  for implementing the Single_Lock RTS, Lock_RTS should follow the first\n-   --  Defer_Abort operation entering RTS. In the same fashion Unlock_RTS\n-   --  should precede the last Undefer_Abort exiting RTS.\n+   --  thread of control in the RTS.\n    --\n    --  These routines also replace the functions Lock/Unlock_All_Tasks_List\n "}, {"sha": "99049f11b37a61b4f9cf946bc0168cc0ca3d5b4f", "filename": "gcc/ada/libgnarl/s-taprop__hpux-dce.adb", "status": "modified", "additions": 34, "deletions": 69, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__hpux-dce.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -83,7 +83,7 @@ package body System.Task_Primitives.Operations is\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+   --  Used to protect All_Tasks_List\n \n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n@@ -325,25 +325,18 @@ package body System.Task_Primitives.Operations is\n       Ceiling_Violation := False;\n    end Write_Lock;\n \n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    ---------------\n@@ -369,25 +362,18 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Unlock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    -----------------\n@@ -421,9 +407,7 @@ package body System.Task_Primitives.Operations is\n       Result :=\n         pthread_cond_wait\n           (cond  => Self_ID.Common.LL.CV'Access,\n-           mutex => (if Single_Lock\n-                     then Single_RTS_Lock'Access\n-                     else Self_ID.Common.LL.L'Access));\n+           mutex => Self_ID.Common.LL.L'Access);\n \n       --  EINTR is not considered a failure\n \n@@ -467,9 +451,7 @@ package body System.Task_Primitives.Operations is\n             Result :=\n               pthread_cond_timedwait\n                 (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n+                 mutex   => Self_ID.Common.LL.L'Access,\n                  abstime => Request'Access);\n \n             exit when Abs_Time <= Monotonic_Clock;\n@@ -504,10 +486,6 @@ package body System.Task_Primitives.Operations is\n       pragma Warnings (Off, Result);\n \n    begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Self_ID);\n \n       Abs_Time :=\n@@ -525,9 +503,7 @@ package body System.Task_Primitives.Operations is\n             Result :=\n               pthread_cond_timedwait\n                 (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n+                 mutex   => Self_ID.Common.LL.L'Access,\n                  abstime => Request'Access);\n \n             exit when Abs_Time <= Monotonic_Clock;\n@@ -541,11 +517,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Result := sched_yield;\n    end Timed_Delay;\n \n@@ -733,26 +704,24 @@ package body System.Task_Primitives.Operations is\n       Cond_Attr  : aliased pthread_condattr_t;\n \n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-         if Result = 0 then\n-            Result :=\n-              pthread_mutex_init\n-                (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n-            pragma Assert (Result = 0 or else Result = ENOMEM);\n-         end if;\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-         if Result /= 0 then\n-            Succeeded := False;\n-            return;\n-         end if;\n+      if Result = 0 then\n+         Result :=\n+           pthread_mutex_init\n+             (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n \n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n       end if;\n \n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n@@ -767,10 +736,8 @@ package body System.Task_Primitives.Operations is\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n \n          Succeeded := False;\n       end if;\n@@ -841,10 +808,8 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n \n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -1093,7 +1058,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Lock_RTS is\n    begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Write_Lock (Single_RTS_Lock'Access);\n    end Lock_RTS;\n \n    ----------------\n@@ -1102,7 +1067,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock_RTS is\n    begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Unlock (Single_RTS_Lock'Access);\n    end Unlock_RTS;\n \n    ------------------"}, {"sha": "03f5a7ba4cfb024bd6dfb94edf82956d966bf9ce", "filename": "gcc/ada/libgnarl/s-taprop__linux.adb", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -75,7 +75,7 @@ package body System.Task_Primitives.Operations is\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+   --  Used to protect All_Tasks_List\n \n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n@@ -304,7 +304,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Lock_RTS is\n    begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Write_Lock (Single_RTS_Lock'Access);\n    end Lock_RTS;\n \n    ----------------\n@@ -313,7 +313,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock_RTS is\n    begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Unlock (Single_RTS_Lock'Access);\n    end Unlock_RTS;\n \n    -----------------\n@@ -484,25 +484,18 @@ package body System.Task_Primitives.Operations is\n       Ceiling_Violation := Result = EINVAL;\n    end Write_Lock;\n \n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n       Result : C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    ---------------\n@@ -542,25 +535,18 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Unlock (L : not null access RTS_Lock) is\n       Result : C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n       Result : C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    -----------------\n@@ -596,9 +582,7 @@ package body System.Task_Primitives.Operations is\n       Result :=\n         pthread_cond_wait\n           (cond  => Self_ID.Common.LL.CV'Access,\n-           mutex => (if Single_Lock\n-                     then Single_RTS_Lock'Access\n-                     else Self_ID.Common.LL.L'Access));\n+           mutex => Self_ID.Common.LL.L'Access);\n \n       --  EINTR is not considered a failure\n \n@@ -860,13 +844,9 @@ package body System.Task_Primitives.Operations is\n \n       Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n-      if not Single_Lock then\n-         if Init_Mutex\n-           (Self_ID.Common.LL.L'Access, Any_Priority'Last) /= 0\n-         then\n-            Succeeded := False;\n-            return;\n-         end if;\n+      if Init_Mutex (Self_ID.Common.LL.L'Access, Any_Priority'Last) /= 0 then\n+         Succeeded := False;\n+         return;\n       end if;\n \n       Result := pthread_condattr_init (Cond_Attr'Access);\n@@ -885,10 +865,8 @@ package body System.Task_Primitives.Operations is\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n \n          Succeeded := False;\n       end if;\n@@ -1070,10 +1048,8 @@ package body System.Task_Primitives.Operations is\n       Result : C.int;\n \n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n \n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);"}, {"sha": "8fa5435a6003f2300b8227401dde227b0b4517ad", "filename": "gcc/ada/libgnarl/s-taprop__mingw.adb", "status": "modified", "additions": 26, "deletions": 71, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__mingw.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -111,7 +111,7 @@ package body System.Task_Primitives.Operations is\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+   --  Used to protect All_Tasks_List\n \n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n@@ -290,15 +290,15 @@ package body System.Task_Primitives.Operations is\n \n       Result_Bool := ResetEvent (HANDLE (Cond.all));\n       pragma Assert (Result_Bool = Win32.TRUE);\n-      Unlock (L, Global_Lock => True);\n+      Unlock (L);\n \n       --  No problem if we are interrupted here: if the condition is signaled,\n       --  WaitForSingleObject will simply not block\n \n       Result := WaitForSingleObject (HANDLE (Cond.all), Wait_Infinite);\n       pragma Assert (Result = 0);\n \n-      Write_Lock (L, Global_Lock => True);\n+      Write_Lock (L);\n    end Cond_Wait;\n \n    ---------------------\n@@ -330,7 +330,7 @@ package body System.Task_Primitives.Operations is\n \n       Result := ResetEvent (HANDLE (Cond.all));\n       pragma Assert (Result = Win32.TRUE);\n-      Unlock (L, Global_Lock => True);\n+      Unlock (L);\n \n       --  No problem if we are interrupted here: if the condition is signaled,\n       --  WaitForSingleObject will simply not block.\n@@ -355,7 +355,7 @@ package body System.Task_Primitives.Operations is\n          end if;\n       end if;\n \n-      Write_Lock (L, Global_Lock => True);\n+      Write_Lock (L);\n \n       --  Ensure post-condition\n \n@@ -465,21 +465,14 @@ package body System.Task_Primitives.Operations is\n       Ceiling_Violation := False;\n    end Write_Lock;\n \n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         EnterCriticalSection (L);\n-      end if;\n+      EnterCriticalSection (L);\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n    begin\n-      if not Single_Lock then\n-         EnterCriticalSection (T.Common.LL.L'Access);\n-      end if;\n+      EnterCriticalSection (T.Common.LL.L'Access);\n    end Write_Lock;\n \n    ---------------\n@@ -501,19 +494,14 @@ package body System.Task_Primitives.Operations is\n       LeaveCriticalSection (L.Mutex'Access);\n    end Unlock;\n \n-   procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False) is\n+   procedure Unlock (L : not null access RTS_Lock) is\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         LeaveCriticalSection (L);\n-      end if;\n+      LeaveCriticalSection (L);\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n    begin\n-      if not Single_Lock then\n-         LeaveCriticalSection (T.Common.LL.L'Access);\n-      end if;\n+      LeaveCriticalSection (T.Common.LL.L'Access);\n    end Unlock;\n \n    -----------------\n@@ -544,11 +532,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       pragma Assert (Self_ID = Self);\n \n-      if Single_Lock then\n-         Cond_Wait (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Cond_Wait (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n+      Cond_Wait (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n \n       if Self_ID.Deferral_Level = 0\n         and then Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n@@ -599,19 +583,12 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Cond_Timed_Wait\n-                 (Self_ID.Common.LL.CV'Access,\n-                  Single_RTS_Lock'Access,\n-                  Rel_Time, Local_Timedout, Result);\n-            else\n-               Cond_Timed_Wait\n-                 (Self_ID.Common.LL.CV'Access,\n-                  Self_ID.Common.LL.L'Access,\n-                  Rel_Time, Local_Timedout, Result);\n-            end if;\n-\n+            Cond_Timed_Wait\n+              (Self_ID.Common.LL.CV'Access,\n+               Self_ID.Common.LL.L'Access,\n+               Rel_Time, Local_Timedout, Result);\n             Check_Time := Monotonic_Clock;\n+\n             exit when Abs_Time <= Check_Time;\n \n             if not Local_Timedout then\n@@ -645,10 +622,6 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (Timedout, Result);\n \n    begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Self_ID);\n \n       if Mode = Relative then\n@@ -665,19 +638,12 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Cond_Timed_Wait\n-                 (Self_ID.Common.LL.CV'Access,\n-                  Single_RTS_Lock'Access,\n-                  Rel_Time, Timedout, Result);\n-            else\n-               Cond_Timed_Wait\n-                 (Self_ID.Common.LL.CV'Access,\n-                  Self_ID.Common.LL.L'Access,\n-                  Rel_Time, Timedout, Result);\n-            end if;\n-\n+            Cond_Timed_Wait\n+              (Self_ID.Common.LL.CV'Access,\n+               Self_ID.Common.LL.L'Access,\n+               Rel_Time, Timedout, Result);\n             Check_Time := Monotonic_Clock;\n+\n             exit when Abs_Time <= Check_Time;\n \n             Rel_Time := Abs_Time - Check_Time;\n@@ -687,11 +653,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Yield;\n    end Timed_Delay;\n \n@@ -845,10 +806,7 @@ package body System.Task_Primitives.Operations is\n       Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n       Initialize_Cond (Self_ID.Common.LL.CV'Access);\n-\n-      if not Single_Lock then\n-         Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n-      end if;\n+      Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n \n       Succeeded := True;\n    end Initialize_TCB;\n@@ -976,10 +934,7 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (Succeeded);\n \n    begin\n-      if not Single_Lock then\n-         Finalize_Lock (T.Common.LL.L'Access);\n-      end if;\n-\n+      Finalize_Lock (T.Common.LL.L'Access);\n       Finalize_Cond (T.Common.LL.CV'Access);\n \n       if T.Known_Tasks_Index /= -1 then\n@@ -1035,7 +990,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Lock_RTS is\n    begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Write_Lock (Single_RTS_Lock'Access);\n    end Lock_RTS;\n \n    ----------------\n@@ -1044,7 +999,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock_RTS is\n    begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Unlock (Single_RTS_Lock'Access);\n    end Unlock_RTS;\n \n    ----------------"}, {"sha": "c983c77e37e45429b95056fcddacf9e34110cdb2", "filename": "gcc/ada/libgnarl/s-taprop__posix.adb", "status": "modified", "additions": 49, "deletions": 71, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__posix.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -82,7 +82,7 @@ package body System.Task_Primitives.Operations is\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+   --  Used to protect All_Tasks_List\n \n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n@@ -443,25 +443,18 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0 or else Ceiling_Violation);\n    end Write_Lock;\n \n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    ---------------\n@@ -485,24 +478,18 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n-   is\n+   procedure Unlock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    -----------------\n@@ -536,9 +523,7 @@ package body System.Task_Primitives.Operations is\n       Result :=\n         pthread_cond_wait\n           (cond  => Self_ID.Common.LL.CV'Access,\n-           mutex => (if Single_Lock\n-                     then Single_RTS_Lock'Access\n-                     else Self_ID.Common.LL.L'Access));\n+           mutex => Self_ID.Common.LL.L'Access);\n \n       --  EINTR is not considered a failure\n \n@@ -728,48 +713,46 @@ package body System.Task_Primitives.Operations is\n       Next_Serial_Number := Next_Serial_Number + 1;\n       pragma Assert (Next_Serial_Number /= 0);\n \n-      if not Single_Lock then\n-         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-         if Result = 0 then\n-            if Locking_Policy = 'C' then\n-               Result :=\n-                 pthread_mutexattr_setprotocol\n-                   (Mutex_Attr'Access,\n-                    PTHREAD_PRIO_PROTECT);\n-               pragma Assert (Result = 0);\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n \n-               Result :=\n-                 pthread_mutexattr_setprioceiling\n-                   (Mutex_Attr'Access,\n-                    Interfaces.C.int (System.Any_Priority'Last));\n-               pragma Assert (Result = 0);\n+      if Result = 0 then\n+         if Locking_Policy = 'C' then\n+            Result :=\n+              pthread_mutexattr_setprotocol\n+                (Mutex_Attr'Access,\n+                 PTHREAD_PRIO_PROTECT);\n+            pragma Assert (Result = 0);\n \n-            elsif Locking_Policy = 'I' then\n-               Result :=\n-                 pthread_mutexattr_setprotocol\n-                   (Mutex_Attr'Access,\n-                    PTHREAD_PRIO_INHERIT);\n-               pragma Assert (Result = 0);\n-            end if;\n+            Result :=\n+              pthread_mutexattr_setprioceiling\n+                (Mutex_Attr'Access,\n+                 Interfaces.C.int (System.Any_Priority'Last));\n+            pragma Assert (Result = 0);\n \n+         elsif Locking_Policy = 'I' then\n             Result :=\n-              pthread_mutex_init\n-                (Self_ID.Common.LL.L'Access,\n-                 Mutex_Attr'Access);\n-            pragma Assert (Result = 0 or else Result = ENOMEM);\n+              pthread_mutexattr_setprotocol\n+                (Mutex_Attr'Access,\n+                 PTHREAD_PRIO_INHERIT);\n+            pragma Assert (Result = 0);\n          end if;\n \n-         if Result /= 0 then\n-            Succeeded := False;\n-            return;\n-         end if;\n+         Result :=\n+           pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access,\n+              Mutex_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n \n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n       end if;\n \n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n       Result := pthread_condattr_init (Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n@@ -786,11 +769,8 @@ package body System.Task_Primitives.Operations is\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n-\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n          Succeeded := False;\n       end if;\n \n@@ -915,10 +895,8 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n \n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -1212,7 +1190,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Lock_RTS is\n    begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Write_Lock (Single_RTS_Lock'Access);\n    end Lock_RTS;\n \n    ----------------\n@@ -1221,7 +1199,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock_RTS is\n    begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Unlock (Single_RTS_Lock'Access);\n    end Unlock_RTS;\n \n    ------------------"}, {"sha": "52d353c5ca09fe019de11199af5816b092677481", "filename": "gcc/ada/libgnarl/s-taprop__qnx.adb", "status": "modified", "additions": 24, "deletions": 46, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__qnx.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -82,7 +82,7 @@ package body System.Task_Primitives.Operations is\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+   --  Used to protect All_Tasks_List\n \n    Environment_Task_Id : Task_Id;\n    --  A variable to hold Task_Id for the environment task\n@@ -458,25 +458,18 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Write_Lock;\n \n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    ---------------\n@@ -500,24 +493,18 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock\n-     (L : not null access RTS_Lock; Global_Lock : Boolean := False)\n-   is\n+   procedure Unlock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    -----------------\n@@ -551,9 +538,7 @@ package body System.Task_Primitives.Operations is\n       Result :=\n         pthread_cond_wait\n           (cond  => Self_ID.Common.LL.CV'Access,\n-           mutex => (if Single_Lock\n-                     then Single_RTS_Lock'Access\n-                     else Self_ID.Common.LL.L'Access));\n+           mutex => Self_ID.Common.LL.L'Access);\n \n       --  EINTR is not considered a failure\n \n@@ -713,8 +698,7 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_TCB --\n    --------------------\n \n-   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean)\n-   is\n+   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n       Result     : Interfaces.C.int;\n       Cond_Attr  : aliased pthread_condattr_t;\n \n@@ -725,14 +709,12 @@ package body System.Task_Primitives.Operations is\n       Next_Serial_Number := Next_Serial_Number + 1;\n       pragma Assert (Next_Serial_Number /= 0);\n \n-      if not Single_Lock then\n-         Result := Init_Mutex (Self_ID.Common.LL.L'Access, Any_Priority'Last);\n-         pragma Assert (Result = 0);\n+      Result := Init_Mutex (Self_ID.Common.LL.L'Access, Any_Priority'Last);\n+      pragma Assert (Result = 0);\n \n-         if Result /= 0 then\n-            Succeeded := False;\n-            return;\n-         end if;\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n       end if;\n \n       Result := pthread_condattr_init (Cond_Attr'Access);\n@@ -751,10 +733,8 @@ package body System.Task_Primitives.Operations is\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n \n          Succeeded := False;\n       end if;\n@@ -894,10 +874,8 @@ package body System.Task_Primitives.Operations is\n       Result : Interfaces.C.int;\n \n    begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n \n       Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -1191,7 +1169,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Lock_RTS is\n    begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Write_Lock (Single_RTS_Lock'Access);\n    end Lock_RTS;\n \n    ----------------\n@@ -1200,7 +1178,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock_RTS is\n    begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Unlock (Single_RTS_Lock'Access);\n    end Unlock_RTS;\n \n    ------------------"}, {"sha": "8b0183d7f7d3551774307af5a0951d6f37338555", "filename": "gcc/ada/libgnarl/s-taprop__solaris.adb", "status": "modified", "additions": 43, "deletions": 110, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__solaris.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -91,7 +91,7 @@ package body System.Task_Primitives.Operations is\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at\n    --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+   --  Used to protect All_Tasks_List\n \n    Next_Serial_Number : Task_Serial_Number := 100;\n    --  We start at 100, to reserve some special values for\n@@ -653,29 +653,22 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Record_Lock (Lock_Ptr (L)));\n    end Write_Lock;\n \n-   procedure Write_Lock\n-     (L          : not null access RTS_Lock;\n-     Global_Lock : Boolean := False)\n-   is\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         pragma Assert (Check_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n-         Result := mutex_lock (L.L'Access);\n-         pragma Assert (Result = 0);\n-         pragma Assert (Record_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n-      end if;\n+      pragma Assert (Check_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n+      Result := mutex_lock (L.L'Access);\n+      pragma Assert (Result = 0);\n+      pragma Assert (Record_Lock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         pragma Assert (Check_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n-         Result := mutex_lock (T.Common.LL.L.L'Access);\n-         pragma Assert (Result = 0);\n-         pragma Assert (Record_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n-      end if;\n+      pragma Assert (Check_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n+      Result := mutex_lock (T.Common.LL.L.L'Access);\n+      pragma Assert (Result = 0);\n+      pragma Assert (Record_Lock (To_Lock_Ptr (T.Common.LL.L'Access)));\n    end Write_Lock;\n \n    ---------------\n@@ -717,27 +710,20 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Unlock;\n \n-   procedure Unlock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Unlock (L : not null access RTS_Lock) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         pragma Assert (Check_Unlock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n-         Result := mutex_unlock (L.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      pragma Assert (Check_Unlock (To_Lock_Ptr (RTS_Lock_Ptr (L))));\n+      Result := mutex_unlock (L.L'Access);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      if not Single_Lock then\n-         pragma Assert (Check_Unlock (To_Lock_Ptr (T.Common.LL.L'Access)));\n-         Result := mutex_unlock (T.Common.LL.L.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      pragma Assert (Check_Unlock (To_Lock_Ptr (T.Common.LL.L'Access)));\n+      Result := mutex_unlock (T.Common.LL.L.L'Access);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    -----------------\n@@ -929,14 +915,12 @@ package body System.Task_Primitives.Operations is\n \n       Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n-      if not Single_Lock then\n-         Result :=\n-           mutex_init\n-             (Self_ID.Common.LL.L.L'Access, USYNC_THREAD, System.Null_Address);\n-         Self_ID.Common.LL.L.Level :=\n-           Private_Task_Serial_Number (Self_ID.Serial_Number);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-      end if;\n+      Result :=\n+        mutex_init\n+          (Self_ID.Common.LL.L.L'Access, USYNC_THREAD, System.Null_Address);\n+      Self_ID.Common.LL.L.Level :=\n+        Private_Task_Serial_Number (Self_ID.Serial_Number);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = 0 then\n          Result := cond_init (Self_ID.Common.LL.CV'Access, USYNC_THREAD, 0);\n@@ -946,10 +930,8 @@ package body System.Task_Primitives.Operations is\n       if Result = 0 then\n          Succeeded := True;\n       else\n-         if not Single_Lock then\n-            Result := mutex_destroy (Self_ID.Common.LL.L.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n+         Result := mutex_destroy (Self_ID.Common.LL.L.L'Access);\n+         pragma Assert (Result = 0);\n \n          Succeeded := False;\n       end if;\n@@ -1049,10 +1031,8 @@ package body System.Task_Primitives.Operations is\n    begin\n       T.Common.LL.Thread := Null_Thread_Id;\n \n-      if not Single_Lock then\n-         Result := mutex_destroy (T.Common.LL.L.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := mutex_destroy (T.Common.LL.L.L'Access);\n+      pragma Assert (Result = 0);\n \n       Result := cond_destroy (T.Common.LL.CV'Access);\n       pragma Assert (Result = 0);\n@@ -1107,15 +1087,9 @@ package body System.Task_Primitives.Operations is\n    begin\n       pragma Assert (Check_Sleep (Reason));\n \n-      if Single_Lock then\n-         Result :=\n-           cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock.L'Access);\n-      else\n-         Result :=\n-           cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L.L'Access);\n-      end if;\n+      Result :=\n+        cond_wait\n+          (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L.L'Access);\n \n       pragma Assert\n         (Record_Wakeup (To_Lock_Ptr (Self_ID.Common.LL.L'Access), Reason));\n@@ -1221,21 +1195,13 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock.L'Access, Request'Access);\n-            else\n-               Result :=\n-                 cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L.L'Access, Request'Access);\n-            end if;\n-\n+            Result :=\n+              cond_timedwait\n+                (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L.L'Access, Request'Access);\n             Yielded := True;\n-\n             Check_Time := Monotonic_Clock;\n+\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             if Result = 0 or Result = EINTR then\n@@ -1271,10 +1237,6 @@ package body System.Task_Primitives.Operations is\n       Yielded    : Boolean := False;\n \n    begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Self_ID);\n \n       Abs_Time :=\n@@ -1291,23 +1253,14 @@ package body System.Task_Primitives.Operations is\n          loop\n             exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n \n-            if Single_Lock then\n-               Result :=\n-                 cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock.L'Access,\n-                    Request'Access);\n-            else\n-               Result :=\n-                 cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L.L'Access,\n-                    Request'Access);\n-            end if;\n-\n+            Result :=\n+              cond_timedwait\n+                (Self_ID.Common.LL.CV'Access,\n+                 Self_ID.Common.LL.L.L'Access,\n+                 Request'Access);\n             Yielded := True;\n-\n             Check_Time := Monotonic_Clock;\n+\n             exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n \n             pragma Assert\n@@ -1325,10 +1278,6 @@ package body System.Task_Primitives.Operations is\n \n       Unlock (Self_ID);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       if not Yielded then\n          thr_yield;\n       end if;\n@@ -1412,10 +1361,6 @@ package body System.Task_Primitives.Operations is\n          return False;\n       end if;\n \n-      if Single_Lock then\n-         return True;\n-      end if;\n-\n       --  Check that TCB lock order rules are satisfied\n \n       P := Self_ID.Common.LL.Locks;\n@@ -1451,10 +1396,6 @@ package body System.Task_Primitives.Operations is\n \n       L.Owner := To_Owner_ID (To_Address (Self_ID));\n \n-      if Single_Lock then\n-         return True;\n-      end if;\n-\n       --  Check that TCB lock order rules are satisfied\n \n       P := Self_ID.Common.LL.Locks;\n@@ -1485,10 +1426,6 @@ package body System.Task_Primitives.Operations is\n          return False;\n       end if;\n \n-      if Single_Lock then\n-         return True;\n-      end if;\n-\n       --  Check that caller is holding own lock, on top of list\n \n       if Self_ID.Common.LL.Locks /=\n@@ -1528,10 +1465,6 @@ package body System.Task_Primitives.Operations is\n \n       L.Owner := To_Owner_ID (To_Address (Self_ID));\n \n-      if Single_Lock then\n-         return True;\n-      end if;\n-\n       --  Check that TCB lock order rules are satisfied\n \n       P := Self_ID.Common.LL.Locks;\n@@ -1880,7 +1813,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Lock_RTS is\n    begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Write_Lock (Single_RTS_Lock'Access);\n    end Lock_RTS;\n \n    ----------------\n@@ -1889,7 +1822,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock_RTS is\n    begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Unlock (Single_RTS_Lock'Access);\n    end Unlock_RTS;\n \n    ------------------"}, {"sha": "32c301dc8c0e6713cc9206edc46d3bd26a54194d", "filename": "gcc/ada/libgnarl/s-taprop__vxworks.adb", "status": "modified", "additions": 28, "deletions": 81, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-taprop__vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__vxworks.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -101,7 +101,7 @@ package body System.Task_Primitives.Operations is\n    Single_RTS_Lock : aliased RTS_Lock;\n    --  This is a lock to allow only one thread of control in the RTS at a\n    --  time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n+   --  Used to protect All_Tasks_List\n \n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n@@ -374,25 +374,18 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Write_Lock;\n \n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Write_Lock (L : not null access RTS_Lock) is\n       Result : int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := semTake (L.Mutex, WAIT_FOREVER);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := semTake (L.Mutex, WAIT_FOREVER);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n       Result : int;\n    begin\n-      if not Single_Lock then\n-         Result := semTake (T.Common.LL.L.Mutex, WAIT_FOREVER);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := semTake (T.Common.LL.L.Mutex, WAIT_FOREVER);\n+      pragma Assert (Result = 0);\n    end Write_Lock;\n \n    ---------------\n@@ -401,8 +394,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Read_Lock\n      (L                 : not null access Lock;\n-      Ceiling_Violation : out Boolean)\n-   is\n+      Ceiling_Violation : out Boolean) is\n    begin\n       Write_Lock (L, Ceiling_Violation);\n    end Read_Lock;\n@@ -418,25 +410,18 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Unlock;\n \n-   procedure Unlock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n+   procedure Unlock (L : not null access RTS_Lock) is\n       Result : int;\n    begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := semGive (L.Mutex);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := semGive (L.Mutex);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n       Result : int;\n    begin\n-      if not Single_Lock then\n-         Result := semGive (T.Common.LL.L.Mutex);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := semGive (T.Common.LL.L.Mutex);\n+      pragma Assert (Result = 0);\n    end Unlock;\n \n    -----------------\n@@ -468,10 +453,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Release the mutex before sleeping\n \n-      Result :=\n-        semGive (if Single_Lock\n-                 then Single_RTS_Lock.Mutex\n-                 else Self_ID.Common.LL.L.Mutex);\n+      Result := semGive (Self_ID.Common.LL.L.Mutex);\n       pragma Assert (Result = 0);\n \n       --  Perform a blocking operation to take the CV semaphore. Note that a\n@@ -484,10 +466,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Take the mutex back\n \n-      Result :=\n-        semTake ((if Single_Lock\n-                  then Single_RTS_Lock.Mutex\n-                  else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n+      Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n       pragma Assert (Result = 0);\n    end Sleep;\n \n@@ -540,10 +519,7 @@ package body System.Task_Primitives.Operations is\n          loop\n             --  Release the mutex before sleeping\n \n-            Result :=\n-              semGive (if Single_Lock\n-                       then Single_RTS_Lock.Mutex\n-                       else Self_ID.Common.LL.L.Mutex);\n+            Result := semGive (Self_ID.Common.LL.L.Mutex);\n             pragma Assert (Result = 0);\n \n             --  Perform a blocking operation to take the CV semaphore. Note\n@@ -583,10 +559,7 @@ package body System.Task_Primitives.Operations is\n \n             --  Take the mutex back\n \n-            Result :=\n-              semTake ((if Single_Lock\n-                        then Single_RTS_Lock.Mutex\n-                        else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n+            Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n             pragma Assert (Result = 0);\n \n             exit when Timedout or Wakeup;\n@@ -597,16 +570,9 @@ package body System.Task_Primitives.Operations is\n \n          --  Should never hold a lock while yielding\n \n-         if Single_Lock then\n-            Result := semGive (Single_RTS_Lock.Mutex);\n-            Result := taskDelay (0);\n-            Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n-\n-         else\n-            Result := semGive (Self_ID.Common.LL.L.Mutex);\n-            Result := taskDelay (0);\n-            Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n-         end if;\n+         Result := semGive (Self_ID.Common.LL.L.Mutex);\n+         Result := taskDelay (0);\n+         Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n       end if;\n    end Timed_Sleep;\n \n@@ -653,10 +619,7 @@ package body System.Task_Primitives.Operations is\n \n          --  Modifying State, locking the TCB\n \n-         Result :=\n-           semTake ((if Single_Lock\n-                     then Single_RTS_Lock.Mutex\n-                     else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n+         Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n \n          pragma Assert (Result = 0);\n \n@@ -668,10 +631,7 @@ package body System.Task_Primitives.Operations is\n \n             --  Release the TCB before sleeping\n \n-            Result :=\n-              semGive (if Single_Lock\n-                       then Single_RTS_Lock.Mutex\n-                       else Self_ID.Common.LL.L.Mutex);\n+            Result := semGive (Self_ID.Common.LL.L.Mutex);\n             pragma Assert (Result = 0);\n \n             exit when Aborted;\n@@ -697,11 +657,7 @@ package body System.Task_Primitives.Operations is\n             --  Take back the lock after having slept, to protect further\n             --  access to Self_ID.\n \n-            Result :=\n-              semTake\n-                ((if Single_Lock\n-                  then Single_RTS_Lock.Mutex\n-                  else Self_ID.Common.LL.L.Mutex), WAIT_FOREVER);\n+            Result := semTake (Self_ID.Common.LL.L.Mutex, WAIT_FOREVER);\n \n             pragma Assert (Result = 0);\n \n@@ -710,11 +666,7 @@ package body System.Task_Primitives.Operations is\n \n          Self_ID.Common.State := Runnable;\n \n-         Result :=\n-           semGive\n-             (if Single_Lock\n-              then Single_RTS_Lock.Mutex\n-              else Self_ID.Common.LL.L.Mutex);\n+         Result := semGive (Self_ID.Common.LL.L.Mutex);\n \n       else\n          Result := taskDelay (0);\n@@ -875,10 +827,7 @@ package body System.Task_Primitives.Operations is\n \n       else\n          Succeeded := True;\n-\n-         if not Single_Lock then\n-            Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n-         end if;\n+         Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n       end if;\n    end Initialize_TCB;\n \n@@ -996,10 +945,8 @@ package body System.Task_Primitives.Operations is\n       Result : int;\n \n    begin\n-      if not Single_Lock then\n-         Result := semDelete (T.Common.LL.L.Mutex);\n-         pragma Assert (Result = 0);\n-      end if;\n+      Result := semDelete (T.Common.LL.L.Mutex);\n+      pragma Assert (Result = 0);\n \n       T.Common.LL.Thread := Null_Thread_Id;\n \n@@ -1251,7 +1198,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Lock_RTS is\n    begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Write_Lock (Single_RTS_Lock'Access);\n    end Lock_RTS;\n \n    ----------------\n@@ -1260,7 +1207,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Unlock_RTS is\n    begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n+      Unlock (Single_RTS_Lock'Access);\n    end Unlock_RTS;\n \n    ------------------"}, {"sha": "ddaa9839dbb0a0087fa9c0a00906bf8dd8b6e6f8", "filename": "gcc/ada/libgnarl/s-tarest.adb", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tarest.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -62,7 +62,6 @@ package body System.Tasking.Restricted.Stages is\n \n    use Ada.Exceptions;\n \n-   use Parameters;\n    use Task_Primitives.Operations;\n \n    Tasks_Activation_Chain : Task_Id;\n@@ -153,7 +152,7 @@ package body System.Tasking.Restricted.Stages is\n         Self_ID.Common.Global_Task_Lock_Nesting + 1;\n \n       if Self_ID.Common.Global_Task_Lock_Nesting = 1 then\n-         STPO.Write_Lock (Global_Task_Lock'Access, Global_Lock => True);\n+         STPO.Write_Lock (Global_Task_Lock'Access);\n       end if;\n    end Task_Lock;\n \n@@ -170,7 +169,7 @@ package body System.Tasking.Restricted.Stages is\n         Self_ID.Common.Global_Task_Lock_Nesting - 1;\n \n       if Self_ID.Common.Global_Task_Lock_Nesting = 0 then\n-         STPO.Unlock (Global_Task_Lock'Access, Global_Lock => True);\n+         STPO.Unlock (Global_Task_Lock'Access);\n       end if;\n    end Task_Unlock;\n \n@@ -265,20 +264,12 @@ package body System.Tasking.Restricted.Stages is\n          TH : Termination_Handler := null;\n \n       begin\n-         if Single_Lock then\n-            Lock_RTS;\n-         end if;\n-\n          Write_Lock (Self_ID.Common.Parent);\n \n          TH := Self_ID.Common.Parent.Common.Fall_Back_Handler;\n \n          Unlock (Self_ID.Common.Parent);\n \n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          --  Execute the task termination handler if we found it\n \n          if TH /= null then\n@@ -347,10 +338,6 @@ package body System.Tasking.Restricted.Stages is\n       pragma Assert (Self_ID = Environment_Task);\n       pragma Assert (Self_ID.Common.Wait_Count = 0);\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       --  Lock self, to prevent activated tasks from racing ahead before we\n       --  finish activating the chain.\n \n@@ -403,10 +390,6 @@ package body System.Tasking.Restricted.Stages is\n \n       Self_ID.Common.State := Runnable;\n       Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n    end Activate_Tasks;\n \n    ------------------------------------\n@@ -423,10 +406,6 @@ package body System.Tasking.Restricted.Stages is\n       Activator : constant Task_Id := Self_ID.Common.Activator;\n \n    begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Activator);\n       Write_Lock (Self_ID);\n \n@@ -449,10 +428,6 @@ package body System.Tasking.Restricted.Stages is\n       Unlock (Self_ID);\n       Unlock (Activator);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  After the activation, active priority should be the same as base\n       --  priority. We must unlock the Activator first, though, since it should\n       --  not wait if we have lower priority.\n@@ -533,10 +508,6 @@ package body System.Tasking.Restricted.Stages is\n             else System.Multiprocessors.CPU_Range (CPU));\n       end if;\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Self_ID);\n \n       --  With no task hierarchy, the parent of all non-Environment tasks that\n@@ -554,11 +525,6 @@ package body System.Tasking.Restricted.Stages is\n \n       if not Success then\n          Unlock (Self_ID);\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          raise Program_Error;\n       end if;\n \n@@ -581,10 +547,6 @@ package body System.Tasking.Restricted.Stages is\n \n       Unlock (Self_ID);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  Create TSD as early as possible in the creation of a task, since\n       --  it may be used by the operation of Ada code within the task. If the\n       --  compiler has not allocated a secondary stack, a stack will be\n@@ -681,10 +643,6 @@ package body System.Tasking.Restricted.Stages is\n    begin\n       pragma Assert (Self_ID = STPO.Environment_Task);\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       --  Handle normal task termination by the environment task, but only for\n       --  the normal task termination. In the case of Abnormal and\n       --  Unhandled_Exception they must have been handled before, and the task\n@@ -705,10 +663,6 @@ package body System.Tasking.Restricted.Stages is\n       Sleep (Self_ID, Master_Completion_Sleep);\n       Unlock (Self_ID);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  Should never return from Master Completion Sleep\n \n       raise Program_Error;"}, {"sha": "cdcb0ba7534d24bd3dd2d7cde7c72e62cd2e8c41", "filename": "gcc/ada/libgnarl/s-tasini.adb", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasini.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -44,7 +44,6 @@ with System.Soft_Links;\n with System.Soft_Links.Tasking;\n with System.Tasking.Debug;\n with System.Tasking.Task_Attributes;\n-with System.Parameters;\n \n with System.Secondary_Stack;\n pragma Elaborate_All (System.Secondary_Stack);\n@@ -244,18 +243,10 @@ package body System.Tasking.Initialization is\n \n          Self_ID.Deferral_Level := Self_ID.Deferral_Level + 1;\n \n-         if Single_Lock then\n-            Lock_RTS;\n-         end if;\n-\n          Write_Lock (Self_ID);\n          Self_ID.Pending_Action := False;\n          Unlock (Self_ID);\n \n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          --  Restore the original Deferral value\n \n          Self_ID.Deferral_Level := Self_ID.Deferral_Level - 1;\n@@ -309,7 +300,7 @@ package body System.Tasking.Initialization is\n    procedure Final_Task_Unlock (Self_ID : Task_Id) is\n    begin\n       pragma Assert (Self_ID.Common.Global_Task_Lock_Nesting = 1);\n-      Unlock (Global_Task_Lock'Access, Global_Lock => True);\n+      Unlock (Global_Task_Lock'Access);\n    end Final_Task_Unlock;\n \n    --------------\n@@ -563,7 +554,7 @@ package body System.Tasking.Initialization is\n \n       if Self_ID.Common.Global_Task_Lock_Nesting = 1 then\n          Defer_Abort_Nestable (Self_ID);\n-         Write_Lock (Global_Task_Lock'Access, Global_Lock => True);\n+         Write_Lock (Global_Task_Lock'Access);\n       end if;\n    end Task_Lock;\n \n@@ -593,7 +584,7 @@ package body System.Tasking.Initialization is\n         Self_ID.Common.Global_Task_Lock_Nesting - 1;\n \n       if Self_ID.Common.Global_Task_Lock_Nesting = 0 then\n-         Unlock (Global_Task_Lock'Access, Global_Lock => True);\n+         Unlock (Global_Task_Lock'Access);\n          Undefer_Abort_Nestable (Self_ID);\n       end if;\n    end Task_Unlock;"}, {"sha": "7a9211a7346791907d9349fd2c5def4a9522f92b", "filename": "gcc/ada/libgnarl/s-tasque.adb", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasque.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasque.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasque.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -35,11 +35,9 @@\n \n with System.Task_Primitives.Operations;\n with System.Tasking.Initialization;\n-with System.Parameters;\n \n package body System.Tasking.Queuing is\n \n-   use Parameters;\n    use Task_Primitives.Operations;\n    use Protected_Objects;\n    use Protected_Objects.Entries;\n@@ -68,15 +66,10 @@ package body System.Tasking.Queuing is\n    procedure Broadcast_Program_Error\n      (Self_ID      : Task_Id;\n       Object       : Protection_Entries_Access;\n-      Pending_Call : Entry_Call_Link;\n-      RTS_Locked   : Boolean := False)\n+      Pending_Call : Entry_Call_Link)\n    is\n       Entry_Call : Entry_Call_Link;\n    begin\n-      if Single_Lock and then not RTS_Locked then\n-         Lock_RTS;\n-      end if;\n-\n       if Pending_Call /= null then\n          Send_Program_Error (Self_ID, Pending_Call);\n       end if;\n@@ -91,10 +84,6 @@ package body System.Tasking.Queuing is\n             Dequeue_Head (Object.Entry_Queues (E), Entry_Call);\n          end loop;\n       end loop;\n-\n-      if Single_Lock and then not RTS_Locked then\n-         Unlock_RTS;\n-      end if;\n    end Broadcast_Program_Error;\n \n    -----------------"}, {"sha": "07540196dee080223710d8e2397e201e2b7374ca", "filename": "gcc/ada/libgnarl/s-tasque.ads", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasque.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasque.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasque.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -38,13 +38,10 @@ package System.Tasking.Queuing is\n    procedure Broadcast_Program_Error\n      (Self_ID      : Task_Id;\n       Object       : POE.Protection_Entries_Access;\n-      Pending_Call : Entry_Call_Link;\n-      RTS_Locked   : Boolean := False);\n+      Pending_Call : Entry_Call_Link);\n    --  Raise Program_Error in all tasks calling the protected entries of Object\n    --  The exception will not be raised immediately for the calling task; it\n    --  will be deferred until it calls Check_Exception.\n-   --  RTS_Locked indicates whether the global RTS lock is taken (only\n-   --  relevant if Single_Lock is True).\n \n    procedure Enqueue (E : in out Entry_Queue; Call : Entry_Call_Link);\n    --  Enqueue Call at the end of entry_queue E"}, {"sha": "567b955dc6bf4891c437732a981835bd218ca099", "filename": "gcc/ada/libgnarl/s-tasren.adb", "status": "modified", "additions": 7, "deletions": 190, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasren.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -37,15 +37,13 @@ with System.Tasking.Utilities;\n with System.Tasking.Protected_Objects.Operations;\n with System.Tasking.Debug;\n with System.Restrictions;\n-with System.Parameters;\n \n package body System.Tasking.Rendezvous is\n \n    package STPO renames System.Task_Primitives.Operations;\n    package POO renames Protected_Objects.Operations;\n    package POE renames Protected_Objects.Entries;\n \n-   use Parameters;\n    use Task_Primitives.Operations;\n \n    type Select_Treatment is (\n@@ -155,11 +153,6 @@ package body System.Tasking.Rendezvous is\n \n    begin\n       Initialization.Defer_Abort (Self_Id);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Self_Id);\n \n       if not Self_Id.Callable then\n@@ -168,11 +161,6 @@ package body System.Tasking.Rendezvous is\n          pragma Assert (Self_Id.Pending_Action);\n \n          STPO.Unlock (Self_Id);\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          Initialization.Undefer_Abort (Self_Id);\n \n          --  Should never get here ???\n@@ -221,13 +209,7 @@ package body System.Tasking.Rendezvous is\n       --  return, we will start the rendezvous.\n \n       STPO.Unlock (Self_Id);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Initialization.Undefer_Abort (Self_Id);\n-\n    end Accept_Call;\n \n    --------------------\n@@ -242,11 +224,6 @@ package body System.Tasking.Rendezvous is\n \n    begin\n       Initialization.Defer_Abort_Nestable (Self_Id);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Self_Id);\n \n       if not Self_Id.Callable then\n@@ -255,11 +232,6 @@ package body System.Tasking.Rendezvous is\n          pragma Assert (Self_Id.Pending_Action);\n \n          STPO.Unlock (Self_Id);\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          Initialization.Undefer_Abort_Nestable (Self_Id);\n \n          --  Should never get here ???\n@@ -303,10 +275,6 @@ package body System.Tasking.Rendezvous is\n          STPO.Unlock (Caller);\n       end if;\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Initialization.Undefer_Abort_Nestable (Self_Id);\n    end Accept_Trivial;\n \n@@ -401,20 +369,12 @@ package body System.Tasking.Rendezvous is\n \n       --  Note: the caller will undefer abort on return (see WARNING above)\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n          STPO.Write_Lock (Self_Id);\n          Utilities.Exit_One_ATC_Level (Self_Id);\n          STPO.Unlock (Self_Id);\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          Local_Undefer_Abort (Self_Id);\n+\n          raise Tasking_Error;\n       end if;\n \n@@ -426,11 +386,6 @@ package body System.Tasking.Rendezvous is\n         (Debug.Trace (Self_Id, \"Call_Synchronous: done waiting\", 'R'));\n       Rendezvous_Successful := Entry_Call.State = Done;\n       STPO.Unlock (Self_Id);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Local_Undefer_Abort (Self_Id);\n       Entry_Calls.Check_Exception (Self_Id, Entry_Call);\n    end Call_Synchronous;\n@@ -445,20 +400,11 @@ package body System.Tasking.Rendezvous is\n \n    begin\n       Initialization.Defer_Abort_Nestable (Self_Id);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (T);\n       Result := T.Callable;\n       STPO.Unlock (T);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Initialization.Undefer_Abort_Nestable (Self_Id);\n+\n       return Result;\n    end Callable;\n \n@@ -545,10 +491,6 @@ package body System.Tasking.Rendezvous is\n       --  it was aborted.\n \n       if Ex = Standard'Abort_Signal'Identity then\n-         if Single_Lock then\n-            Lock_RTS;\n-         end if;\n-\n          while Entry_Call /= null loop\n             Entry_Call.Exception_To_Raise := Tasking_Error'Identity;\n \n@@ -568,11 +510,6 @@ package body System.Tasking.Rendezvous is\n             STPO.Unlock (Caller);\n             Entry_Call := Entry_Call.Acceptor_Prev_Call;\n          end loop;\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n       else\n          Caller := Entry_Call.Self;\n \n@@ -588,23 +525,10 @@ package body System.Tasking.Rendezvous is\n \n                --  Requeue to another task entry\n \n-               if Single_Lock then\n-                  Lock_RTS;\n-               end if;\n-\n                if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n-                  if Single_Lock then\n-                     Unlock_RTS;\n-                  end if;\n-\n                   Initialization.Undefer_Abort (Self_Id);\n                   raise Tasking_Error;\n                end if;\n-\n-               if Single_Lock then\n-                  Unlock_RTS;\n-               end if;\n-\n             else\n                --  Requeue to a protected entry\n \n@@ -614,20 +538,11 @@ package body System.Tasking.Rendezvous is\n                if Ceiling_Violation then\n                   pragma Assert (Ex = Ada.Exceptions.Null_Id);\n                   Entry_Call.Exception_To_Raise := Program_Error'Identity;\n-\n-                  if Single_Lock then\n-                     Lock_RTS;\n-                  end if;\n-\n                   STPO.Write_Lock (Caller);\n                   Initialization.Wakeup_Entry_Caller\n                     (Self_Id, Entry_Call, Done);\n                   STPO.Unlock (Caller);\n \n-                  if Single_Lock then\n-                     Unlock_RTS;\n-                  end if;\n-\n                else\n                   POO.PO_Do_Or_Queue (Self_Id, Called_PO, Entry_Call);\n                   POO.PO_Service_Entries (Self_Id, Called_PO);\n@@ -642,11 +557,6 @@ package body System.Tasking.Rendezvous is\n \n             Self_Id.Common.Call := Entry_Call.Acceptor_Prev_Call;\n             Entry_Call.Exception_To_Raise := Ex;\n-\n-            if Single_Lock then\n-               Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Caller);\n \n             --  Done with Caller locked to make sure that Wakeup is not lost\n@@ -661,11 +571,6 @@ package body System.Tasking.Rendezvous is\n             Initialization.Wakeup_Entry_Caller (Self_Id, Entry_Call, Done);\n \n             STPO.Unlock (Caller);\n-\n-            if Single_Lock then\n-               Unlock_RTS;\n-            end if;\n-\n             Entry_Calls.Reset_Priority (Self_Id, Acceptor_Prev_Priority);\n          end if;\n       end if;\n@@ -733,11 +638,6 @@ package body System.Tasking.Rendezvous is\n \n    begin\n       Initialization.Defer_Abort (Self_Id);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Self_Id);\n \n       if not Self_Id.Callable then\n@@ -747,10 +647,6 @@ package body System.Tasking.Rendezvous is\n \n          STPO.Unlock (Self_Id);\n \n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          --  ??? In some cases abort is deferred more than once. Need to\n          --  figure out why this happens.\n \n@@ -902,10 +798,6 @@ package body System.Tasking.Rendezvous is\n \n                STPO.Unlock (Self_Id);\n \n-               if Single_Lock then\n-                  Unlock_RTS;\n-               end if;\n-\n                Index := Self_Id.Chosen_Index;\n                Initialization.Undefer_Abort_Nestable (Self_Id);\n \n@@ -961,21 +853,11 @@ package body System.Tasking.Rendezvous is\n \n             else\n                STPO.Unlock (Self_Id);\n-\n-               if Single_Lock then\n-                  Unlock_RTS;\n-               end if;\n-\n                Initialization.Undefer_Abort (Self_Id);\n-               raise Program_Error with\n-                 \"entry call not a delay mode\";\n+               raise Program_Error with \"entry call not a delay mode\";\n             end if;\n       end case;\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  Caller has been chosen\n \n       --  Self_Id.Common.Call should already be updated by the Caller.\n@@ -1018,19 +900,9 @@ package body System.Tasking.Rendezvous is\n \n    begin\n       Initialization.Defer_Abort (Self_Id);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Self_Id);\n       Return_Count := Queuing.Count_Waiting (Self_Id.Entry_Queues (E));\n       STPO.Unlock (Self_Id);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Initialization.Undefer_Abort (Self_Id);\n \n       return Return_Count;\n@@ -1306,19 +1178,10 @@ package body System.Tasking.Rendezvous is\n          Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n          Entry_Call.With_Abort := True;\n \n-         if Single_Lock then\n-            Lock_RTS;\n-         end if;\n-\n          if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n             STPO.Write_Lock (Self_Id);\n             Utilities.Exit_One_ATC_Level (Self_Id);\n             STPO.Unlock (Self_Id);\n-\n-            if Single_Lock then\n-               Unlock_RTS;\n-            end if;\n-\n             Initialization.Undefer_Abort (Self_Id);\n \n             raise Tasking_Error;\n@@ -1335,10 +1198,6 @@ package body System.Tasking.Rendezvous is\n             Entry_Calls.Wait_Until_Abortable (Self_Id, Entry_Call);\n          end if;\n \n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          --  Note: following assignment needs to be atomic\n \n          Rendezvous_Successful := Entry_Call.State = Done;\n@@ -1392,10 +1251,6 @@ package body System.Tasking.Rendezvous is\n \n       --  If we are aborted here, the effect will be pending\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Self_Id);\n \n       if not Self_Id.Callable then\n@@ -1404,11 +1259,6 @@ package body System.Tasking.Rendezvous is\n          pragma Assert (Self_Id.Pending_Action);\n \n          STPO.Unlock (Self_Id);\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          Initialization.Undefer_Abort (Self_Id);\n \n          --  Should never get here ???\n@@ -1484,21 +1334,13 @@ package body System.Tasking.Rendezvous is\n             --  caller a chance of getting ready immediately, using Unlock\n             --  Yield. See similar action in Wait_For_Completion/Wait_For_Call.\n \n-            if Single_Lock then\n-               Unlock_RTS;\n-            else\n-               Unlock (Self_Id);\n-            end if;\n+            Unlock (Self_Id);\n \n             if Self_Id.Open_Accepts /= null then\n                Yield;\n             end if;\n \n-            if Single_Lock then\n-               Lock_RTS;\n-            else\n-               Write_Lock (Self_Id);\n-            end if;\n+            Write_Lock (Self_Id);\n \n             --  Check if this task has been aborted while the lock was released\n \n@@ -1574,10 +1416,6 @@ package body System.Tasking.Rendezvous is\n             null;\n       end case;\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       if not Yielded then\n          Yield;\n       end if;\n@@ -1657,19 +1495,10 @@ package body System.Tasking.Rendezvous is\n \n       --  Note: the caller will undefer abort on return (see WARNING above)\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       if not Task_Do_Or_Queue (Self_Id, Entry_Call) then\n          STPO.Write_Lock (Self_Id);\n          Utilities.Exit_One_ATC_Level (Self_Id);\n          STPO.Unlock (Self_Id);\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          Initialization.Undefer_Abort (Self_Id);\n \n          raise Tasking_Error;\n@@ -1680,10 +1509,6 @@ package body System.Tasking.Rendezvous is\n         (Entry_Call, Timeout, Mode, Yielded);\n       Unlock (Self_Id);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  ??? Do we need to yield in case Yielded is False\n \n       Rendezvous_Successful := Entry_Call.State = Done;\n@@ -1703,21 +1528,13 @@ package body System.Tasking.Rendezvous is\n       --  a chance of getting ready immediately, using Unlock & Yield.\n       --  See similar action in Wait_For_Completion & Timed_Selective_Wait.\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      else\n-         Unlock (Self_Id);\n-      end if;\n+      Unlock (Self_Id);\n \n       if Self_Id.Open_Accepts /= null then\n          Yield;\n       end if;\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      else\n-         Write_Lock (Self_Id);\n-      end if;\n+      Write_Lock (Self_Id);\n \n       --  Check if this task has been aborted while the lock was released\n "}, {"sha": "52b21c34e489318d268021d0d56a375cb655be33", "filename": "gcc/ada/libgnarl/s-tasren.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasren.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasren.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasren.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -317,8 +317,7 @@ package System.Tasking.Rendezvous is\n    function Task_Do_Or_Queue\n      (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link) return Boolean;\n-   --  Call this only with abort deferred and holding no locks, except\n-   --  the global RTS lock when Single_Lock is True which must be owned.\n+   --  Call this only with abort deferred and holding no locks.\n    --  Returns False iff the call cannot be served or queued, as is the\n    --  case if the caller is not callable; i.e., a False return value\n    --  indicates that Tasking_Error should be raised."}, {"sha": "4c7029eee8c5afbe685f5aa4c35c3356f5b1d752", "filename": "gcc/ada/libgnarl/s-tassta.adb", "status": "modified", "additions": 18, "deletions": 112, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tassta.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -74,7 +74,6 @@ package body System.Tasking.Stages is\n \n    use Ada.Exceptions;\n \n-   use Parameters;\n    use Secondary_Stack;\n    use Task_Primitives;\n    use Task_Primitives.Operations;\n@@ -341,9 +340,7 @@ package body System.Tasking.Stages is\n          C := C.Common.Activation_Link;\n       end loop;\n \n-      if not Single_Lock then\n-         Unlock_RTS;\n-      end if;\n+      Unlock_RTS;\n \n       --  Close the entries of any tasks that failed thread creation, and count\n       --  those that have not finished activation.\n@@ -382,10 +379,6 @@ package body System.Tasking.Stages is\n       Self_ID.Common.State := Runnable;\n       Unlock (Self_ID);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  Remove the tasks from the chain\n \n       Chain_Access.T_ID := null;\n@@ -406,17 +399,7 @@ package body System.Tasking.Stages is\n \n    begin\n       Initialization.Defer_Abort_Nestable (Self_ID);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Vulnerable_Complete_Activation (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Initialization.Undefer_Abort_Nestable (Self_ID);\n \n       --  ??? Why do we need to allow for nested deferral here?\n@@ -846,12 +829,8 @@ package body System.Tasking.Stages is\n       --  Force termination of \"independent\" library-level server tasks\n \n       Lock_RTS;\n-\n       Abort_Dependents (Self_ID);\n-\n-      if not Single_Lock then\n-         Unlock_RTS;\n-      end if;\n+      Unlock_RTS;\n \n       --  We need to explicitly wait for the task to be terminated here\n       --  because on true concurrent system, we may end this procedure before\n@@ -891,10 +870,6 @@ package body System.Tasking.Stages is\n \n       Unlock (Self_ID);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  Complete the environment task\n \n       Vulnerable_Complete_Task (Self_ID);\n@@ -1294,10 +1269,6 @@ package body System.Tasking.Stages is\n       --  the environment task. The task termination code for the environment\n       --  task is executed by SSL.Task_Termination_Handler.\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Self_ID);\n \n       if Self_ID.Common.Specific_Handler /= null then\n@@ -1320,10 +1291,6 @@ package body System.Tasking.Stages is\n \n       Unlock (Self_ID);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  Execute the task termination handler if we found it\n \n       if TH /= null then\n@@ -1393,26 +1360,16 @@ package body System.Tasking.Stages is\n \n       Initialization.Task_Lock (Self_ID);\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Master_Of_Task := Self_ID.Master_Of_Task;\n \n       --  Check if the current task is an independent task If so, decrement\n       --  the Independent_Task_Count value.\n \n       if Master_Of_Task = Independent_Task_Level then\n-         if Single_Lock then\n-            Utilities.Independent_Task_Count :=\n-              Utilities.Independent_Task_Count - 1;\n-\n-         else\n-            Write_Lock (Environment_Task);\n-            Utilities.Independent_Task_Count :=\n-              Utilities.Independent_Task_Count - 1;\n-            Unlock (Environment_Task);\n-         end if;\n+         Write_Lock (Environment_Task);\n+         Utilities.Independent_Task_Count :=\n+           Utilities.Independent_Task_Count - 1;\n+         Unlock (Environment_Task);\n       end if;\n \n       --  Unprotect the guard page if needed\n@@ -1422,10 +1379,6 @@ package body System.Tasking.Stages is\n       Utilities.Make_Passive (Self_ID, Task_Completed => True);\n       Deallocate := Self_ID.Free_On_Termination;\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       pragma Assert (Check_Exit (Self_ID));\n \n       SSL.Destroy_TSD (Self_ID.Common.Compiler_Data);\n@@ -1454,20 +1407,11 @@ package body System.Tasking.Stages is\n \n    begin\n       Initialization.Defer_Abort_Nestable (Self_ID);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (T);\n       Result := T.Common.State = Terminated;\n       Unlock (T);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Initialization.Undefer_Abort_Nestable (Self_ID);\n+\n       return Result;\n    end Terminated;\n \n@@ -1600,10 +1544,7 @@ package body System.Tasking.Stages is\n \n       function Check_Unactivated_Tasks return Boolean is\n       begin\n-         if not Single_Lock then\n-            Lock_RTS;\n-         end if;\n-\n+         Lock_RTS;\n          Write_Lock (Self_ID);\n \n          C := All_Tasks_List;\n@@ -1626,10 +1567,7 @@ package body System.Tasking.Stages is\n          end loop;\n \n          Unlock (Self_ID);\n-\n-         if not Single_Lock then\n-            Unlock_RTS;\n-         end if;\n+         Unlock_RTS;\n \n          return True;\n       end Check_Unactivated_Tasks;\n@@ -1698,10 +1636,7 @@ package body System.Tasking.Stages is\n \n       Self_ID.Common.State := Master_Completion_Sleep;\n       Unlock (Self_ID);\n-\n-      if not Single_Lock then\n-         Unlock_RTS;\n-      end if;\n+      Unlock_RTS;\n \n       --  Wait until dependent tasks are all terminated or ready to terminate.\n       --  While waiting, the task may be awakened if the task's priority needs\n@@ -1718,15 +1653,11 @@ package body System.Tasking.Stages is\n          if Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n            and then not Self_ID.Dependents_Aborted\n          then\n-            if Single_Lock then\n-               Abort_Dependents (Self_ID);\n-            else\n-               Unlock (Self_ID);\n-               Lock_RTS;\n-               Abort_Dependents (Self_ID);\n-               Unlock_RTS;\n-               Write_Lock (Self_ID);\n-            end if;\n+            Unlock (Self_ID);\n+            Lock_RTS;\n+            Abort_Dependents (Self_ID);\n+            Unlock_RTS;\n+            Write_Lock (Self_ID);\n          else\n             pragma Debug\n               (Debug.Trace (Self_ID, \"master_completion_sleep\", 'C'));\n@@ -1753,10 +1684,7 @@ package body System.Tasking.Stages is\n \n          --  Force any remaining dependents to terminate by aborting them\n \n-         if not Single_Lock then\n-            Lock_RTS;\n-         end if;\n-\n+         Lock_RTS;\n          Abort_Dependents (Self_ID);\n \n          --  Above, when we \"abort\" the dependents we are simply using this\n@@ -1801,10 +1729,7 @@ package body System.Tasking.Stages is\n \n          Self_ID.Common.State := Master_Phase_2_Sleep;\n          Unlock (Self_ID);\n-\n-         if not Single_Lock then\n-            Unlock_RTS;\n-         end if;\n+         Unlock_RTS;\n \n          --  Wait for all counted tasks to finish terminating themselves\n \n@@ -1828,10 +1753,7 @@ package body System.Tasking.Stages is\n       --  locks. Instead, we put those ATCBs to be freed onto a temporary list,\n       --  called To_Be_Freed.\n \n-      if not Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n+      Lock_RTS;\n       C := All_Tasks_List;\n       P := null;\n       while C /= null loop\n@@ -1986,10 +1908,6 @@ package body System.Tasking.Stages is\n \n       pragma Debug (Debug.Trace (Self_ID, \"V_Complete_Task\", 'C'));\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Self_ID);\n       Self_ID.Callable := False;\n \n@@ -2005,10 +1923,6 @@ package body System.Tasking.Stages is\n          Vulnerable_Complete_Activation (Self_ID);\n       end if;\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       --  If Self_ID.Master_Within = Self_ID.Master_Of_Task + 2 we may have\n       --  dependent tasks for which we need to wait. Otherwise we just exit.\n \n@@ -2035,18 +1949,10 @@ package body System.Tasking.Stages is\n    begin\n       pragma Debug (Debug.Trace (Self, \"Vulnerable_Free_Task\", 'C', T));\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (T);\n       Initialization.Finalize_Attributes (T);\n       Unlock (T);\n \n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       System.Task_Primitives.Operations.Finalize_TCB (T);\n    end Vulnerable_Free_Task;\n "}, {"sha": "90c5bd9935a87ac103b651158cf61c8dafefe6b9", "filename": "gcc/ada/libgnarl/s-tasuti.adb", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasuti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasuti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasuti.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -41,13 +41,11 @@ with System.Tasking.Debug;\n with System.Task_Primitives.Operations;\n with System.Tasking.Initialization;\n with System.Tasking.Queuing;\n-with System.Parameters;\n \n package body System.Tasking.Utilities is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n-   use Parameters;\n    use Tasking.Debug;\n    use Task_Primitives;\n    use Task_Primitives.Operations;\n@@ -58,7 +56,7 @@ package body System.Tasking.Utilities is\n \n    --  Similar to Locked_Abort_To_Level (Self_ID, T, Level_Completed_Task),\n    --  but:\n-   --    (1) caller should be holding no locks except RTS_Lock when Single_Lock\n+   --    (1) caller should be holding no locks\n    --    (2) may be called for tasks that have not yet been activated\n    --    (3) always aborts whole task\n \n@@ -248,11 +246,6 @@ package body System.Tasking.Utilities is\n       end if;\n \n       Initialization.Defer_Abort (Self_Id);\n-\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Environment_Task);\n       Write_Lock (Self_Id);\n \n@@ -277,11 +270,6 @@ package body System.Tasking.Utilities is\n       pragma Assert (Environment_Task.Common.State /= Master_Completion_Sleep);\n \n       Unlock (Environment_Task);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       Initialization.Undefer_Abort (Self_Id);\n \n       --  Return True. Actually the return value is junk, since we expect it"}, {"sha": "1ef237e8d16cf503742be3d39d63d50fa5e35632", "filename": "gcc/ada/libgnarl/s-tasuti.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tasuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasuti.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -102,7 +102,7 @@ package System.Tasking.Utilities is\n \n    procedure Cancel_Queued_Entry_Calls (T : Task_Id);\n    --  Cancel any entry calls queued on target task.\n-   --  Call this while holding T's lock (or RTS_Lock in Single_Lock mode).\n+   --  Call this while holding T's lock.\n \n    procedure Exit_One_ATC_Level (Self_ID : Task_Id);\n    pragma Inline (Exit_One_ATC_Level);\n@@ -124,7 +124,6 @@ package System.Tasking.Utilities is\n    procedure Make_Passive (Self_ID : Task_Id; Task_Completed : Boolean);\n    --  Update counts to indicate current task is either terminated or\n    --  accepting on a terminate alternative. Call holding no locks except\n-   --  Global_Task_Lock when calling from Terminate_Task, and RTS_Lock when\n-   --  Single_Lock is True.\n+   --  Global_Task_Lock when calling from Terminate_Task.\n \n end System.Tasking.Utilities;"}, {"sha": "ae06edec6fad1004413baa03d7fb4b94a39e9b58", "filename": "gcc/ada/libgnarl/s-tpoben.adb", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpoben.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -43,7 +43,6 @@\n \n with System.Task_Primitives.Operations;\n with System.Restrictions;\n-with System.Parameters;\n \n with System.Tasking.Initialization;\n pragma Elaborate_All (System.Tasking.Initialization);\n@@ -53,7 +52,6 @@ package body System.Tasking.Protected_Objects.Entries is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n-   use Parameters;\n    use Task_Primitives.Operations;\n \n    ----------------\n@@ -81,10 +79,6 @@ package body System.Tasking.Protected_Objects.Entries is\n \n       STPO.Write_Lock (Object.L'Unrestricted_Access, Ceiling_Violation);\n \n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       if Ceiling_Violation then\n \n          --  Dip our own priority down to ceiling of lock. See similar code in\n@@ -95,21 +89,12 @@ package body System.Tasking.Protected_Objects.Entries is\n          Self_ID.New_Base_Priority := Object.Ceiling;\n          Initialization.Change_Base_Priority (Self_ID);\n          STPO.Unlock (Self_ID);\n-\n-         if Single_Lock then\n-            Unlock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Object.L'Unrestricted_Access, Ceiling_Violation);\n \n          if Ceiling_Violation then\n             raise Program_Error with \"ceiling violation\";\n          end if;\n \n-         if Single_Lock then\n-            Lock_RTS;\n-         end if;\n-\n          Object.Old_Base_Priority := Old_Base_Priority;\n          Object.Pending_Action := True;\n       end if;\n@@ -133,13 +118,7 @@ package body System.Tasking.Protected_Objects.Entries is\n       end loop;\n \n       Object.Finalized := True;\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       STPO.Unlock (Object.L'Unrestricted_Access);\n-\n       STPO.Finalize_Lock (Object.L'Unrestricted_Access);\n    end Finalize;\n "}, {"sha": "5537c1a4b1fa54401f3912afa67f39412459b441", "filename": "gcc/ada/libgnarl/s-tpobop.adb", "status": "modified", "additions": 9, "deletions": 110, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -48,7 +48,6 @@ with System.Tasking.Queuing;\n with System.Tasking.Rendezvous;\n with System.Tasking.Utilities;\n with System.Tasking.Debug;\n-with System.Parameters;\n with System.Restrictions;\n \n with System.Tasking.Initialization;\n@@ -59,7 +58,6 @@ package body System.Tasking.Protected_Objects.Operations is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n-   use Parameters;\n    use Ada.Exceptions;\n    use Entries;\n \n@@ -313,19 +311,10 @@ package body System.Tasking.Protected_Objects.Operations is\n             --  Body of current entry served call to completion\n \n             Object.Call_In_Progress := null;\n-\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Entry_Call.Self);\n             Initialization.Wakeup_Entry_Caller (Self_ID, Entry_Call, Done);\n             STPO.Unlock (Entry_Call.Self);\n \n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n-\n          else\n             Requeue_Call (Self_ID, Object, Entry_Call);\n          end if;\n@@ -353,19 +342,10 @@ package body System.Tasking.Protected_Objects.Operations is\n                --  Max_Queue_Length bound, raise Program_Error.\n \n                Entry_Call.Exception_To_Raise := Program_Error'Identity;\n-\n-               if Single_Lock then\n-                  STPO.Lock_RTS;\n-               end if;\n-\n                STPO.Write_Lock (Entry_Call.Self);\n                Initialization.Wakeup_Entry_Caller (Self_ID, Entry_Call, Done);\n                STPO.Unlock (Entry_Call.Self);\n \n-               if Single_Lock then\n-                  STPO.Unlock_RTS;\n-               end if;\n-\n                return;\n             end if;\n          end if;\n@@ -379,18 +359,10 @@ package body System.Tasking.Protected_Objects.Operations is\n       else\n          --  Conditional_Call and With_Abort\n \n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Entry_Call.Self);\n          pragma Assert (Entry_Call.State /= Not_Yet_Abortable);\n          Initialization.Wakeup_Entry_Caller (Self_ID, Entry_Call, Cancelled);\n          STPO.Unlock (Entry_Call.Self);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n       end if;\n \n    exception\n@@ -437,8 +409,7 @@ package body System.Tasking.Protected_Objects.Operations is\n \n          exception\n             when others =>\n-               Queuing.Broadcast_Program_Error\n-                 (Self_ID, Object, Entry_Call);\n+               Queuing.Broadcast_Program_Error (Self_ID, Object, Entry_Call);\n          end;\n \n          if Object.Call_In_Progress = null then\n@@ -448,18 +419,9 @@ package body System.Tasking.Protected_Objects.Operations is\n          else\n             Object.Call_In_Progress := null;\n             Caller := Entry_Call.Self;\n-\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Caller);\n             Initialization.Wakeup_Entry_Caller (Self_ID, Entry_Call, Done);\n             STPO.Unlock (Caller);\n-\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n          end if;\n       end loop;\n \n@@ -608,18 +570,10 @@ package body System.Tasking.Protected_Objects.Operations is\n \n          --  Once State >= Done it will not change any more\n \n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Self_ID);\n          Utilities.Exit_One_ATC_Level (Self_ID);\n          STPO.Unlock (Self_ID);\n \n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n          Block.Enqueued := False;\n          Block.Cancelled := Entry_Call.State = Cancelled;\n          Initialization.Undefer_Abort_Nestable (Self_ID);\n@@ -640,30 +594,17 @@ package body System.Tasking.Protected_Objects.Operations is\n          --  Try to avoid an expensive call\n \n          if not Initially_Abortable then\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-               Entry_Calls.Wait_Until_Abortable (Self_ID, Entry_Call);\n-               STPO.Unlock_RTS;\n-            else\n-               Entry_Calls.Wait_Until_Abortable (Self_ID, Entry_Call);\n-            end if;\n+            Entry_Calls.Wait_Until_Abortable (Self_ID, Entry_Call);\n          end if;\n \n       else\n          case Mode is\n             when Conditional_Call\n                | Simple_Call\n             =>\n-               if Single_Lock then\n-                  STPO.Lock_RTS;\n-                  Entry_Calls.Wait_For_Completion (Entry_Call);\n-                  STPO.Unlock_RTS;\n-\n-               else\n-                  STPO.Write_Lock (Self_ID);\n-                  Entry_Calls.Wait_For_Completion (Entry_Call);\n-                  STPO.Unlock (Self_ID);\n-               end if;\n+               STPO.Write_Lock (Self_ID);\n+               Entry_Calls.Wait_For_Completion (Entry_Call);\n+               STPO.Unlock (Self_ID);\n \n                Block.Cancelled := Entry_Call.State = Cancelled;\n \n@@ -700,21 +641,11 @@ package body System.Tasking.Protected_Objects.Operations is\n \n          --  Call is to be requeued to a task entry\n \n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          Result := Rendezvous.Task_Do_Or_Queue (Self_Id, Entry_Call);\n \n          if not Result then\n-            Queuing.Broadcast_Program_Error\n-              (Self_Id, Object, Entry_Call, RTS_Locked => True);\n+            Queuing.Broadcast_Program_Error (Self_Id, Object, Entry_Call);\n          end if;\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n       else\n          --  Call should be requeued to a PO\n \n@@ -767,19 +698,11 @@ package body System.Tasking.Protected_Objects.Operations is\n \n                   Entry_Call.Exception_To_Raise := Program_Error'Identity;\n \n-                  if Single_Lock then\n-                     STPO.Lock_RTS;\n-                  end if;\n-\n                   STPO.Write_Lock (Entry_Call.Self);\n                   Initialization.Wakeup_Entry_Caller\n                     (Self_Id, Entry_Call, Done);\n                   STPO.Unlock (Entry_Call.Self);\n \n-                  if Single_Lock then\n-                     STPO.Unlock_RTS;\n-                  end if;\n-\n                else\n                   Queuing.Enqueue\n                     (New_Object.Entry_Queues (E), Entry_Call);\n@@ -993,23 +916,13 @@ package body System.Tasking.Protected_Objects.Operations is\n \n       PO_Do_Or_Queue (Self_Id, Object, Entry_Call);\n       PO_Service_Entries (Self_Id, Object);\n-\n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      else\n-         STPO.Write_Lock (Self_Id);\n-      end if;\n+      STPO.Write_Lock (Self_Id);\n \n       --  Try to avoid waiting for completed or cancelled calls\n \n       if Entry_Call.State >= Done then\n          Utilities.Exit_One_ATC_Level (Self_Id);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         else\n-            STPO.Unlock (Self_Id);\n-         end if;\n+         STPO.Unlock (Self_Id);\n \n          Entry_Call_Successful := Entry_Call.State = Done;\n          Initialization.Undefer_Abort_Nestable (Self_Id);\n@@ -1019,12 +932,7 @@ package body System.Tasking.Protected_Objects.Operations is\n \n       Entry_Calls.Wait_For_Completion_With_Timeout\n         (Entry_Call, Timeout, Mode, Yielded);\n-\n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      else\n-         STPO.Unlock (Self_Id);\n-      end if;\n+      STPO.Unlock (Self_Id);\n \n       --  ??? Do we need to yield in case Yielded is False\n \n@@ -1075,22 +983,13 @@ package body System.Tasking.Protected_Objects.Operations is\n          if Old < Was_Abortable and then\n            Entry_Call.State = Now_Abortable\n          then\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n             STPO.Write_Lock (Entry_Call.Self);\n \n             if Entry_Call.Self.Common.State = Async_Select_Sleep then\n                STPO.Wakeup (Entry_Call.Self, Async_Select_Sleep);\n             end if;\n \n             STPO.Unlock (Entry_Call.Self);\n-\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n-\n          end if;\n \n       elsif Entry_Call.Mode = Conditional_Call then"}, {"sha": "ab70679858934d2029de1cf53c33ddde5052c2f4", "filename": "gcc/ada/libgnarl/s-tpopmo.adb", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tpopmo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tpopmo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpopmo.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -193,9 +193,7 @@ package body Monotonic is\n                Result :=\n                  pthread_cond_timedwait\n                    (cond    => Self_ID.Common.LL.CV'Access,\n-                    mutex   => (if Single_Lock\n-                                then Single_RTS_Lock'Access\n-                                else Self_ID.Common.LL.L'Access),\n+                    mutex   => Self_ID.Common.LL.L'Access,\n                     abstime => Request'Access);\n \n                case Result is\n@@ -244,10 +242,6 @@ package body Monotonic is\n       Exit_Outer : Boolean := False;\n \n    begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n       Write_Lock (Self_ID);\n \n       Compute_Deadline\n@@ -286,9 +280,7 @@ package body Monotonic is\n                Result :=\n                  pthread_cond_timedwait\n                    (cond    => Self_ID.Common.LL.CV'Access,\n-                    mutex   => (if Single_Lock\n-                                then Single_RTS_Lock'Access\n-                                else Self_ID.Common.LL.L'Access),\n+                    mutex   => Self_ID.Common.LL.L'Access,\n                     abstime => Request'Access);\n \n                case Result is\n@@ -314,11 +306,6 @@ package body Monotonic is\n       end if;\n \n       Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n       pragma Unreferenced (Result);\n       Result := sched_yield;\n    end Timed_Delay;"}, {"sha": "3545435f738eea6f8762fab0304f5aa6f7e39aa9", "filename": "gcc/ada/libgnarl/s-tposen.adb", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tposen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnarl%2Fs-tposen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tposen.adb?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -62,14 +62,11 @@ pragma Suppress (All_Checks);\n with Ada.Exceptions;\n \n with System.Task_Primitives.Operations;\n-with System.Parameters;\n \n package body System.Tasking.Protected_Objects.Single_Entry is\n \n    package STPO renames System.Task_Primitives.Operations;\n \n-   use Parameters;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -143,18 +140,9 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n \n    begin\n       Entry_Call.Exception_To_Raise := Program_Error'Identity;\n-\n-      if Single_Lock then\n-         STPO.Lock_RTS;\n-      end if;\n-\n       STPO.Write_Lock (Caller);\n       Wakeup_Entry_Caller (Entry_Call);\n       STPO.Unlock (Caller);\n-\n-      if Single_Lock then\n-         STPO.Unlock_RTS;\n-      end if;\n    end Send_Program_Error;\n \n    -------------------------\n@@ -286,18 +274,10 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n            (Object.Compiler_Info, Entry_Call.Uninterpreted_Data, 1);\n          Object.Call_In_Progress := null;\n \n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Entry_Call.Self);\n          Wakeup_Entry_Caller (Entry_Call);\n          STPO.Unlock (Entry_Call.Self);\n \n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n       else\n          pragma Assert (Entry_Call.Mode = Simple_Call);\n \n@@ -370,17 +350,9 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n       pragma Assert (Entry_Call.State /= Cancelled);\n \n       if Entry_Call.State /= Done then\n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Self_Id);\n          Wait_For_Completion (Entry_Call'Access);\n          STPO.Unlock (Self_Id);\n-\n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n       end if;\n \n       Check_Exception (Self_Id, Entry_Call'Access);\n@@ -427,18 +399,10 @@ package body System.Tasking.Protected_Objects.Single_Entry is\n          Caller := Entry_Call.Self;\n          Unlock_Entry (Object);\n \n-         if Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n          STPO.Write_Lock (Caller);\n          Wakeup_Entry_Caller (Entry_Call);\n          STPO.Unlock (Caller);\n \n-         if Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n       else\n          --  Just unlock the entry\n "}, {"sha": "f9bc3d006334ee5b67f8d74729dc2032fdc96011", "filename": "gcc/ada/libgnat/s-parame.ads", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-parame.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -147,19 +147,6 @@ package System.Parameters is\n    --  allow some optimizations and fine tuning within the tasking run time\n    --  based on restrictions on the tasking features.\n \n-   ----------------------\n-   -- Locking Strategy --\n-   ----------------------\n-\n-   Single_Lock : constant Boolean := False;\n-   --  Indicates whether a single lock should be used within the tasking\n-   --  run-time to protect internal structures. If True, a single lock\n-   --  will be used, meaning less locking/unlocking operations, but also\n-   --  more global contention. In general, Single_Lock should be set to\n-   --  True on single processor machines, and to False to multi-processor\n-   --  systems, but this can vary from application to application and also\n-   --  depends on the scheduling policy.\n-\n    -------------------\n    -- Task Abortion --\n    -------------------"}, {"sha": "3e73f5e2897860193d2c981a3c6881e3e883fb55", "filename": "gcc/ada/libgnat/s-parame__ae653.ads", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame__ae653.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame__ae653.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-parame__ae653.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -147,19 +147,6 @@ package System.Parameters is\n    --  allow some optimizations and fine tuning within the tasking run time\n    --  based on restrictions on the tasking features.\n \n-   ----------------------\n-   -- Locking Strategy --\n-   ----------------------\n-\n-   Single_Lock : constant Boolean := False;\n-   --  Indicates whether a single lock should be used within the tasking\n-   --  run-time to protect internal structures. If True, a single lock\n-   --  will be used, meaning less locking/unlocking operations, but also\n-   --  more global contention. In general, Single_Lock should be set to\n-   --  True on single processor machines, and to False to multi-processor\n-   --  systems, but this can vary from application to application and also\n-   --  depends on the scheduling policy.\n-\n    -------------------\n    -- Task Abortion --\n    -------------------"}, {"sha": "e09313f6e59e64018a3b3c65a66d21c0a45b6025", "filename": "gcc/ada/libgnat/s-parame__hpux.ads", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame__hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame__hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-parame__hpux.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -145,19 +145,6 @@ package System.Parameters is\n    --  allow some optimizations and fine tuning within the tasking run time\n    --  based on restrictions on the tasking features.\n \n-   ----------------------\n-   -- Locking Strategy --\n-   ----------------------\n-\n-   Single_Lock : constant Boolean := False;\n-   --  Indicates whether a single lock should be used within the tasking\n-   --  run-time to protect internal structures. If True, a single lock\n-   --  will be used, meaning less locking/unlocking operations, but also\n-   --  more global contention. In general, Single_Lock should be set to\n-   --  True on single processor machines, and to False to multi-processor\n-   --  systems, but this can vary from application to application and also\n-   --  depends on the scheduling policy.\n-\n    -------------------\n    -- Task Abortion --\n    -------------------"}, {"sha": "c836444a326b71bc49cdfdba0fe1ac4bc67d1852", "filename": "gcc/ada/libgnat/s-parame__vxworks.ads", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame__vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68c1670b7d40b09be2995e1e730ce4c87eb688c/gcc%2Fada%2Flibgnat%2Fs-parame__vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-parame__vxworks.ads?ref=b68c1670b7d40b09be2995e1e730ce4c87eb688c", "patch": "@@ -147,19 +147,6 @@ package System.Parameters is\n    --  allow some optimizations and fine tuning within the tasking run time\n    --  based on restrictions on the tasking features.\n \n-   ----------------------\n-   -- Locking Strategy --\n-   ----------------------\n-\n-   Single_Lock : constant Boolean := False;\n-   --  Indicates whether a single lock should be used within the tasking\n-   --  run-time to protect internal structures. If True, a single lock\n-   --  will be used, meaning less locking/unlocking operations, but also\n-   --  more global contention. In general, Single_Lock should be set to\n-   --  True on single processor machines, and to False to multi-processor\n-   --  systems, but this can vary from application to application and also\n-   --  depends on the scheduling policy.\n-\n    -------------------\n    -- Task Abortion --\n    -------------------"}]}