{"sha": "b61a0d75fe479befe4bb92eb1447ed52b095599b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYxYTBkNzVmZTQ3OWJlZmU0YmI5MmViMTQ0N2VkNTJiMDk1NTk5Yg==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2015-08-19T22:55:28Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2015-08-19T22:55:28Z"}, "message": "[Patch][expand] Check gimple statement to improve LSHIFT_EXP expand\n\nThis patch improves LSHIFT_EXP expand if the shift operand comes from sign\nextension and the shift result across word_mode_size boundary. See code\ncomments for details.\n\n2015-08-19  Jiong.Wang  <jiong.wang@arm.com>\n\ngcc/\n  * expr.c (expand_expr_real_2): Check gimple statement during\n  LSHIFT_EXPR expand.\n  \ngcc/testsuite\n  * gcc.dg/wide_shift_64_1.c: New testcase.\n  * gcc.dg/wide_shift_128_1.c: Likewise.\n  * gcc.target/aarch64/ashlti3_1.c: Likewise.\n\nFrom-SVN: r227018", "tree": {"sha": "5aa74ee7132df7a44f46653bee3dce7ee3bdf5b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aa74ee7132df7a44f46653bee3dce7ee3bdf5b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b61a0d75fe479befe4bb92eb1447ed52b095599b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61a0d75fe479befe4bb92eb1447ed52b095599b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61a0d75fe479befe4bb92eb1447ed52b095599b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61a0d75fe479befe4bb92eb1447ed52b095599b/comments", "author": null, "committer": null, "parents": [{"sha": "e0f6cba004eb94ef9a06c68d09160d8601503085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f6cba004eb94ef9a06c68d09160d8601503085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f6cba004eb94ef9a06c68d09160d8601503085"}], "stats": {"total": 202, "additions": 186, "deletions": 16}, "files": [{"sha": "78a7a7930ba493bfbbe462998a59bd3c3df2e248", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b61a0d75fe479befe4bb92eb1447ed52b095599b", "patch": "@@ -1,3 +1,8 @@\n+2015-08-19  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* expr.c (expand_expr_real_2): Check gimple statement during\n+\tLSHIFT_EXPR expand.\n+\n 2015-08-19  Magnus Granberg  <zorry@gentoo.org>\n \n \t* common.opt (fstack-protector): Initialize to -1."}, {"sha": "1e820b45a247bcccef29741057f5ebc20a63ecf5", "filename": "gcc/expr.c", "status": "modified", "additions": 105, "deletions": 16, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b61a0d75fe479befe4bb92eb1447ed52b095599b", "patch": "@@ -8836,23 +8836,112 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n-      /* If this is a fixed-point operation, then we cannot use the code\n-\t below because \"expand_shift\" doesn't support sat/no-sat fixed-point\n-         shifts.   */\n-      if (ALL_FIXED_POINT_MODE_P (mode))\n-\tgoto binop;\n+      {\n+\t/* If this is a fixed-point operation, then we cannot use the code\n+\t   below because \"expand_shift\" doesn't support sat/no-sat fixed-point\n+\t   shifts.  */\n+\tif (ALL_FIXED_POINT_MODE_P (mode))\n+\t  goto binop;\n+\n+\tif (! safe_from_p (subtarget, treeop1, 1))\n+\t  subtarget = 0;\n+\tif (modifier == EXPAND_STACK_PARM)\n+\t  target = 0;\n+\top0 = expand_expr (treeop0, subtarget,\n+\t\t\t   VOIDmode, EXPAND_NORMAL);\n+\n+\t/* Left shift optimization when shifting across word_size boundary.\n+\n+\t   If mode == GET_MODE_WIDER_MODE (word_mode), then normally there isn't\n+\t   native instruction to support this wide mode left shift.  Given below\n+\t   scenario:\n+\n+\t    Type A = (Type) B  << C\n+\n+\t    |<\t\t T\t    >|\n+\t    | dest_high  |  dest_low |\n+\n+\t\t\t | word_size |\n+\n+\t   If the shift amount C caused we shift B to across the word size\n+\t   boundary, i.e part of B shifted into high half of destination\n+\t   register, and part of B remains in the low half, then GCC will use\n+\t   the following left shift expand logic:\n+\n+\t   1. Initialize dest_low to B.\n+\t   2. Initialize every bit of dest_high to the sign bit of B.\n+\t   3. Logic left shift dest_low by C bit to finalize dest_low.\n+\t      The value of dest_low before this shift is kept in a temp D.\n+\t   4. Logic left shift dest_high by C.\n+\t   5. Logic right shift D by (word_size - C).\n+\t   6. Or the result of 4 and 5 to finalize dest_high.\n+\n+\t   While, by checking gimple statements, if operand B is coming from\n+\t   signed extension, then we can simplify above expand logic into:\n+\n+\t      1. dest_high = src_low >> (word_size - C).\n+\t      2. dest_low = src_low << C.\n+\n+\t   We can use one arithmetic right shift to finish all the purpose of\n+\t   steps 2, 4, 5, 6, thus we reduce the steps needed from 6 into 2.  */\n+\n+\ttemp = NULL_RTX;\n+\tif (code == LSHIFT_EXPR\n+\t    && target\n+\t    && REG_P (target)\n+\t    && ! unsignedp\n+\t    && mode == GET_MODE_WIDER_MODE (word_mode)\n+\t    && GET_MODE_SIZE (mode) == 2 * GET_MODE_SIZE (word_mode)\n+\t    && ! have_insn_for (ASHIFT, mode)\n+\t    && TREE_CONSTANT (treeop1)\n+\t    && TREE_CODE (treeop0) == SSA_NAME)\n+\t  {\n+\t    gimple def = SSA_NAME_DEF_STMT (treeop0);\n+\t    if (is_gimple_assign (def)\n+\t\t&& gimple_assign_rhs_code (def) == NOP_EXPR)\n+\t      {\n+\t\tmachine_mode rmode = TYPE_MODE\n+\t\t  (TREE_TYPE (gimple_assign_rhs1 (def)));\n \n-      if (! safe_from_p (subtarget, treeop1, 1))\n-\tsubtarget = 0;\n-      if (modifier == EXPAND_STACK_PARM)\n-\ttarget = 0;\n-      op0 = expand_expr (treeop0, subtarget,\n-\t\t\t VOIDmode, EXPAND_NORMAL);\n-      temp = expand_variable_shift (code, mode, op0, treeop1, target,\n-\t\t\t\t    unsignedp);\n-      if (code == LSHIFT_EXPR)\n-\ttemp = REDUCE_BIT_FIELD (temp);\n-      return temp;\n+\t\tif (GET_MODE_SIZE (rmode) < GET_MODE_SIZE (mode)\n+\t\t    && TREE_INT_CST_LOW (treeop1) < GET_MODE_BITSIZE (word_mode)\n+\t\t    && ((TREE_INT_CST_LOW (treeop1) + GET_MODE_BITSIZE (rmode))\n+\t\t\t>= GET_MODE_BITSIZE (word_mode)))\n+\t\t  {\n+\t\t    unsigned int high_off = subreg_highpart_offset (word_mode,\n+\t\t\t\t\t\t\t\t    mode);\n+\t\t    rtx low = lowpart_subreg (word_mode, op0, mode);\n+\t\t    rtx dest_low = lowpart_subreg (word_mode, target, mode);\n+\t\t    rtx dest_high = simplify_gen_subreg (word_mode, target,\n+\t\t\t\t\t\t\t mode, high_off);\n+\t\t    HOST_WIDE_INT ramount = (BITS_PER_WORD\n+\t\t\t\t\t     - TREE_INT_CST_LOW (treeop1));\n+\t\t    tree rshift = build_int_cst (TREE_TYPE (treeop1), ramount);\n+\n+\t\t    /* dest_high = src_low >> (word_size - C).  */\n+\t\t    temp = expand_variable_shift (RSHIFT_EXPR, word_mode, low,\n+\t\t\t\t\t\t  rshift, dest_high, unsignedp);\n+\t\t    if (temp != dest_high)\n+\t\t      emit_move_insn (dest_high, temp);\n+\n+\t\t    /* dest_low = src_low << C.  */\n+\t\t    temp = expand_variable_shift (LSHIFT_EXPR, word_mode, low,\n+\t\t\t\t\t\t  treeop1, dest_low, unsignedp);\n+\t\t    if (temp != dest_low)\n+\t\t      emit_move_insn (dest_low, temp);\n+\n+\t\t    temp = target ;\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tif (temp == NULL_RTX)\n+\t  temp = expand_variable_shift (code, mode, op0, treeop1, target,\n+\t\t\t\t\tunsignedp);\n+\tif (code == LSHIFT_EXPR)\n+\t  temp = REDUCE_BIT_FIELD (temp);\n+\treturn temp;\n+      }\n \n       /* Could determine the answer when only additive constants differ.  Also,\n \t the addition of one can be handled by changing the condition.  */"}, {"sha": "076de9ca6063787020ff536b847155d55b45f61e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b61a0d75fe479befe4bb92eb1447ed52b095599b", "patch": "@@ -1,3 +1,9 @@\n+2015-08-19  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* gcc.dg/wide_shift_64_1.c: New testcase.\n+\t* gcc.dg/wide_shift_128_1.c: Likewise.\n+\t* gcc.target/aarch64/ashlti3_1.c: Likewise.\n+\n 2015-08-19  Magnus Granberg  <zorry@gentoo.org>\n \n \t* lib/target-supports.exp"}, {"sha": "d769833af04f9f4b47938fc9b5dbccf4350ed8e9", "filename": "gcc/testsuite/gcc.dg/wide-shift-128.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2Fgcc.dg%2Fwide-shift-128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2Fgcc.dg%2Fwide-shift-128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwide-shift-128.c?ref=b61a0d75fe479befe4bb92eb1447ed52b095599b", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target aarch64*-*-* mips64*-*-* sparc64*-*-* } } */\n+/* { dg-require-effective-target int128 } */\n+/* { dg-options \"-O2 -fdump-rtl-combine\" } */\n+\n+__int128_t\n+load2 (int data)\n+{\n+    return (__int128_t) data << 50;\n+}\n+\n+/* { dg-final { scan-rtl-dump-not \"ior\" \"combine\" } } */"}, {"sha": "c1624c5cdbf7ce71e1d0d31ee3118e6f82122c97", "filename": "gcc/testsuite/gcc.dg/wide-shift-64.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2Fgcc.dg%2Fwide-shift-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2Fgcc.dg%2Fwide-shift-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwide-shift-64.c?ref=b61a0d75fe479befe4bb92eb1447ed52b095599b", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target mips*-*-* sparc*-*-* } } */\n+/* { dg-options \"-O2 -fdump-rtl-combine\" } */\n+\n+long long\n+load1 (int data)\n+{\n+    return (long long) data << 12;\n+}\n+\n+/* { dg-final { scan-rtl-dump-not \"ior\" \"combine\" } } */"}, {"sha": "293a0f2563b77ddc4fdebf2a6b9967f20f0966b9", "filename": "gcc/testsuite/gcc.target/aarch64/ashltidisi.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fashltidisi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b61a0d75fe479befe4bb92eb1447ed52b095599b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fashltidisi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fashltidisi.c?ref=b61a0d75fe479befe4bb92eb1447ed52b095599b", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -save-temps\" } */\n+\n+extern void abort (void);\n+\n+#define GEN_TEST_CASE(x, y, z)\\\n+__uint128_t __attribute__ ((noinline))\\\n+ushift_##x##_##z (unsigned y data)\\\n+{\\\n+  return (__uint128_t) data << x;\\\n+}\\\n+__int128_t __attribute__ ((noinline)) \\\n+shift_##x##_##z (y data) \\\n+{\\\n+  return (__int128_t) data << x;\\\n+}\n+\n+GEN_TEST_CASE (53, int, i)\n+GEN_TEST_CASE (3, long long, ll)\n+GEN_TEST_CASE (13, long long, ll)\n+GEN_TEST_CASE (53, long long, ll)\n+\n+int\n+main (int argc, char **argv)\n+{\n+\n+#define SHIFT_CHECK(x, y, z, p) \\\n+\tif (ushift_##y##_##p (x)\\\n+\t    != ((__uint128_t) (unsigned z) x << y)) \\\n+\t  abort ();\\\n+\tif (shift_##y##_##p (x)\\\n+\t    != ((__uint128_t) (signed z) x << y)) \\\n+\t  abort ();\n+\n+  SHIFT_CHECK (0x12345678, 53, int, i)\n+  SHIFT_CHECK (0xcafecafe, 53, int, i)\n+\n+  SHIFT_CHECK (0x1234567890abcdefLL, 3, long long, ll)\n+  SHIFT_CHECK (0x1234567890abcdefLL, 13, long long, ll)\n+  SHIFT_CHECK (0x1234567890abcdefLL, 53, long long, ll)\n+  SHIFT_CHECK (0xcafecafedeaddeadLL, 3, long long, ll)\n+  SHIFT_CHECK (0xcafecafedeaddeadLL, 13, long long, ll)\n+  SHIFT_CHECK (0xcafecafedeaddeadLL, 53, long long, ll)\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"asr\" 4 } } */\n+/* { dg-final { scan-assembler-not \"extr\\t\" } } */"}]}