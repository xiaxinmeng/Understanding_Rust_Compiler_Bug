{"sha": "0a6969ad7cfe5a44854a2e19a8c38505862c2528", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE2OTY5YWQ3Y2ZlNWE0NDg1NGEyZTE5YThjMzg1MDU4NjJjMjUyOA==", "commit": {"author": {"name": "John F. Carr", "email": "jfc@mit.edu", "date": "1997-12-12T06:49:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-12T06:49:29Z"}, "message": "tree.c, tree.h: Change tree_code_type, tree_code_length, and tree_code_name from pointers to arrays.\n\n        * tree.c, tree.h: Change tree_code_type, tree_code_length, and\n        tree_code_name from pointers to arrays.\n        * tree.c: Remove standard_tree_code_* variables, no longer used.\n        * print-tree.c: Remove declaration of tree_code_name.\n\n        * cp/lex.c (init_lex): Update for tree_code_* changes.\n        * objc/objc-act.c (init_objc): Likewise.\n\n        * tree.def, cp/cp-tree.def, objc/objc-tree.def: Update for tree_code\n        changes.\n\nFrom-SVN: r17061", "tree": {"sha": "5b4b9de36c3d7dc6f7a0fd049bc566fd4636cabf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b4b9de36c3d7dc6f7a0fd049bc566fd4636cabf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a6969ad7cfe5a44854a2e19a8c38505862c2528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a6969ad7cfe5a44854a2e19a8c38505862c2528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a6969ad7cfe5a44854a2e19a8c38505862c2528", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a6969ad7cfe5a44854a2e19a8c38505862c2528/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c55dcc7ddd984dd72e8dc89fe18f422f4d6344fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c55dcc7ddd984dd72e8dc89fe18f422f4d6344fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c55dcc7ddd984dd72e8dc89fe18f422f4d6344fa"}], "stats": {"total": 499, "additions": 236, "deletions": 263}, "files": [{"sha": "c6e8e20e998c2debb5f7f727fc2030588720ffe7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -1,3 +1,16 @@\n+Thu Dec 11 23:50:17 1997  John F. Carr  <jfc@mit.edu>\n+\n+\t* tree.c, tree.h: Change tree_code_type, tree_code_length, and\n+\ttree_code_name from pointers to arrays.\n+\t* tree.c: Remove standard_tree_code_* variables, no longer used.\n+\t* print-tree.c: Remove declaration of tree_code_name.\n+\n+\t* cp/lex.c (init_lex): Update for tree_code_* changes.\n+\t* objc/objc-act.c (init_objc): Likewise.\n+\n+\t* tree.def, cp/cp-tree.def, objc/objc-tree.def: Update for tree_code\n+\tchanges.\n+\n Thu Dec 11 23:34:54 1997  Fred Fish  <fnf@ninemoons.com>\n \n \t* config.sub: Add support for BeOS target."}, {"sha": "9665a4d916dca73b9547c1fe76845a86a527fb7f", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -27,43 +27,43 @@ Boston, MA 02111-1307, USA.  */\n    Operand 0 is the object within which the offset is taken.\n    Operand 1 is the offset.  The language independent OFFSET_REF\n    just won't work for us.  */\n-DEFTREECODE (OFFSET_REF, \"offset_ref\", \"r\", 2)\n+DEFTREECODE (OFFSET_REF, \"offset_ref\", 'r', 2)\n \n /* For DELETE_EXPR, operand 0 is the store to be destroyed.\n    Operand 1 is the value to pass to the destroying function\n    saying whether the store should be deallocated as well.  */\n-DEFTREECODE (DELETE_EXPR, \"dl_expr\", \"e\", 2)\n-DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", \"e\", 2)\n+DEFTREECODE (DELETE_EXPR, \"dl_expr\", 'e', 2)\n+DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", 'e', 2)\n \n /* Value is reference to particular overloaded class method.\n    Operand 0 is the class name (an IDENTIFIER_NODE);\n    operand 1 is the field (also an IDENTIFIER_NODE).\n    The COMPLEXITY field holds the class level (usually 0).  */\n-DEFTREECODE (SCOPE_REF, \"scope_ref\", \"r\", 2)\n+DEFTREECODE (SCOPE_REF, \"scope_ref\", 'r', 2)\n \n /* When composing an object with a member, this is the result.\n    Operand 0 is the object.  Operand 1 is the member (usually\n    a dereferenced pointer to member).  */\n-DEFTREECODE (MEMBER_REF, \"member_ref\", \"r\", 2)\n+DEFTREECODE (MEMBER_REF, \"member_ref\", 'r', 2)\n \n /* Type conversion operator in C++.  TREE_TYPE is type that this\n    operator converts to.  Operand is expression to be converted.  */\n-DEFTREECODE (TYPE_EXPR, \"type_expr\", \"e\", 1)\n+DEFTREECODE (TYPE_EXPR, \"type_expr\", 'e', 1)\n \n /* For NEW_EXPR, operand 0 is function which performs initialization,\n    operand 1 is argument list to initialization function,\n    and operand 2 is the slot which was allocated for this expression.  */\n-DEFTREECODE (NEW_EXPR, \"nw_expr\", \"e\", 3)\n-DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", \"e\", 3)\n+DEFTREECODE (NEW_EXPR, \"nw_expr\", 'e', 3)\n+DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", 'e', 3)\n \n /* A throw expression.  operand 0 is the expression, if there was one,\n    else it is NULL_TREE.  */\n-DEFTREECODE (THROW_EXPR, \"throw_expr\", \"e\", 1)\n+DEFTREECODE (THROW_EXPR, \"throw_expr\", 'e', 1)\n \n /* Initialization of a vector, used in build_new.  Operand 0 is the target\n    of the initialization, operand 1 is the initializer, and operand 2 is\n    the number of elements.  */\n-DEFTREECODE (VEC_INIT_EXPR, \"vec_init_expr\", \"e\", 3)\n+DEFTREECODE (VEC_INIT_EXPR, \"vec_init_expr\", 'e', 3)\n \n /* Template definition.  The following fields have the specified uses,\n    although there are other macros in cp-tree.h that should be used for\n@@ -80,18 +80,18 @@ DEFTREECODE (VEC_INIT_EXPR, \"vec_init_expr\", \"e\", 3)\n         DECL_RESULT             decl for object to be created\n                                 (e.g., FUNCTION_DECL with tmpl parms used)\n  */\n-DEFTREECODE (TEMPLATE_DECL, \"template_decl\", \"d\", 0)\n+DEFTREECODE (TEMPLATE_DECL, \"template_decl\", 'd', 0)\n \n /* Index into a template parameter list.  This parameter must be a type.\n    Use TYPE_FIELDS to find parmlist and index.  */\n-DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", \"t\", 0)\n+DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", 't', 0)\n \n /* A type designated by 'typename T::t'. */\n-DEFTREECODE (TYPENAME_TYPE, \"typename_type\", \"t\", 0)\n+DEFTREECODE (TYPENAME_TYPE, \"typename_type\", 't', 0)\n \n /* Index into a template parameter list.  This parameter must not be a\n    type.  */\n-DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", \"c\", 3)\n+DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", 'c', 3)\n \n /* A thunk is a stub function.\n \n@@ -101,69 +101,69 @@ DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", \"c\", 3)\n    (which is an ADDR_EXPR whose operand is a FUNCTION_DECL).\n \n    Other kinds of thunks may be defined later. */\n-DEFTREECODE (THUNK_DECL, \"thunk_decl\", \"d\", 0)\n+DEFTREECODE (THUNK_DECL, \"thunk_decl\", 'd', 0)\n \n /* A namespace declaration.  */\n-DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", \"d\", 0)\n+DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", 'd', 0)\n \n /* A using declaration.  DECL_INITIAL contains the specified scope.  \n    This is not an alias, but is later expanded into multiple aliases.  */\n-DEFTREECODE (USING_DECL, \"using_decl\", \"d\", 0)\n+DEFTREECODE (USING_DECL, \"using_decl\", 'd', 0)\n \n /* An un-parsed default argument.  Looks like an IDENTIFIER_NODE.  */\n-DEFTREECODE (DEFAULT_ARG, \"default_arg\", \"c\", 2)\n+DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'c', 2)\n \n /* A template-id, like foo<int>.  The first operand is the template.  \n    The second is the list of explicitly specified arguments.  The \n    template will be a FUNCTION_DECL, TEMPLATE_DECL, or a list of\n    overloaded functions and templates if the template-id refers to\n    a global template.  If the template-id refers to a member template,\n    the template will will be an IDENTIFIER_NODE.  */\n-DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", \"e\", 2)\n+DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n-DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", \"e\", 2)\n-DEFTREECODE (MODOP_EXPR, \"modop_expr\", \"e\", 3)\n-DEFTREECODE (CAST_EXPR, \"cast_expr\", \"1\", 1)\n-DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", \"1\", 1)\n-DEFTREECODE (CONST_CAST_EXPR, \"const_cast_expr\", \"1\", 1)\n-DEFTREECODE (STATIC_CAST_EXPR, \"static_cast_expr\", \"1\", 1)\n-DEFTREECODE (DYNAMIC_CAST_EXPR, \"dynamic_cast_expr\", \"1\", 1)\n-DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", \"1\", 1)\n-DEFTREECODE (ARROW_EXPR, \"arrow_expr\", \"e\", 1)\n-DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", \"e\", 2)\n-DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", \"e\", 1)\n-\n-DEFTREECODE (EXPR_STMT, \"expr_stmt\", \"e\", 1)\n-DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", \"e\", 1)\n-DEFTREECODE (DECL_STMT, \"decl_stmt\", \"e\", 3)\n-DEFTREECODE (IF_STMT, \"if_stmt\", \"e\", 3)\n-DEFTREECODE (FOR_STMT, \"for_stmt\", \"e\", 4)\n-DEFTREECODE (WHILE_STMT, \"while_stmt\", \"e\", 2)\n-DEFTREECODE (DO_STMT, \"do_stmt\", \"e\", 2)\n-DEFTREECODE (RETURN_STMT, \"return_stmt\", \"e\", 1)\n-DEFTREECODE (BREAK_STMT, \"break_stmt\", \"e\", 0)\n-DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", \"e\", 0)\n-DEFTREECODE (SWITCH_STMT, \"switch_stmt\", \"e\", 2)\n-DEFTREECODE (GOTO_STMT, \"goto_stmt\", \"e\", 1)\n-\n-DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", \"e\", 2)\n-DEFTREECODE (CASE_LABEL, \"case_label\", \"e\", 2)\n-DEFTREECODE (RETURN_INIT, \"return_init\", \"e\", 2)\n-DEFTREECODE (TRY_BLOCK, \"try_stmt\", \"e\", 2)\n-DEFTREECODE (HANDLER, \"catch_stmt\", \"e\", 2)\n-\n-DEFTREECODE (IDENTITY_CONV, \"identity_conv\", \"e\", 1)\n-DEFTREECODE (LVALUE_CONV, \"lvalue_conv\", \"e\", 1)\n-DEFTREECODE (QUAL_CONV, \"qual_conv\", \"e\", 1)\n-DEFTREECODE (STD_CONV, \"std_conv\", \"e\", 1)\n-DEFTREECODE (PTR_CONV, \"ptr_conv\", \"e\", 1)\n-DEFTREECODE (PMEM_CONV, \"pmem_conv\", \"e\", 1)\n-DEFTREECODE (BASE_CONV, \"base_conv\", \"e\", 1)\n-DEFTREECODE (REF_BIND, \"ref_bind\", \"e\", 1)\n-DEFTREECODE (USER_CONV, \"user_conv\", \"e\", 4)\n-DEFTREECODE (AMBIG_CONV, \"ambig_conv\", \"e\", 1)\n-DEFTREECODE (RVALUE_CONV, \"rvalue_conv\", \"e\", 1)\n-\n-DEFTREECODE (TAG_DEFN, \"tag_defn\", \"e\", 0)\n+DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", 'e', 2)\n+DEFTREECODE (MODOP_EXPR, \"modop_expr\", 'e', 3)\n+DEFTREECODE (CAST_EXPR, \"cast_expr\", '1', 1)\n+DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", '1', 1)\n+DEFTREECODE (CONST_CAST_EXPR, \"const_cast_expr\", '1', 1)\n+DEFTREECODE (STATIC_CAST_EXPR, \"static_cast_expr\", '1', 1)\n+DEFTREECODE (DYNAMIC_CAST_EXPR, \"dynamic_cast_expr\", '1', 1)\n+DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", '1', 1)\n+DEFTREECODE (ARROW_EXPR, \"arrow_expr\", 'e', 1)\n+DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", 'e', 2)\n+DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", 'e', 1)\n+\n+DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n+DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", 'e', 1)\n+DEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 3)\n+DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n+DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n+DEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)\n+DEFTREECODE (DO_STMT, \"do_stmt\", 'e', 2)\n+DEFTREECODE (RETURN_STMT, \"return_stmt\", 'e', 1)\n+DEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n+DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n+DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 2)\n+DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n+\n+DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n+DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n+DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n+DEFTREECODE (TRY_BLOCK, \"try_stmt\", 'e', 2)\n+DEFTREECODE (HANDLER, \"catch_stmt\", 'e', 2)\n+\n+DEFTREECODE (IDENTITY_CONV, \"identity_conv\", 'e', 1)\n+DEFTREECODE (LVALUE_CONV, \"lvalue_conv\", 'e', 1)\n+DEFTREECODE (QUAL_CONV, \"qual_conv\", 'e', 1)\n+DEFTREECODE (STD_CONV, \"std_conv\", 'e', 1)\n+DEFTREECODE (PTR_CONV, \"ptr_conv\", 'e', 1)\n+DEFTREECODE (PMEM_CONV, \"pmem_conv\", 'e', 1)\n+DEFTREECODE (BASE_CONV, \"base_conv\", 'e', 1)\n+DEFTREECODE (REF_BIND, \"ref_bind\", 'e', 1)\n+DEFTREECODE (USER_CONV, \"user_conv\", 'e', 4)\n+DEFTREECODE (AMBIG_CONV, \"ambig_conv\", 'e', 1)\n+DEFTREECODE (RVALUE_CONV, \"rvalue_conv\", 'e', 1)\n+\n+DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)"}, {"sha": "88068e3b2a99d83c0e1cf98acb1ea8858f0fcd62", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -361,8 +361,8 @@ my_get_run_time ()\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-char *cplus_tree_code_type[] = {\n-  \"x\",\n+char cplus_tree_code_type[] = {\n+  'x',\n #include \"cp-tree.def\"\n };\n #undef DEFTREECODE\n@@ -461,18 +461,9 @@ init_lex ()\n \n   init_cplus_expand ();\n \n-  tree_code_type\n-    = (char **) realloc (tree_code_type,\n-\t\t\t sizeof (char *) * LAST_CPLUS_TREE_CODE);\n-  tree_code_length\n-    = (int *) realloc (tree_code_length,\n-\t\t       sizeof (int) * LAST_CPLUS_TREE_CODE);\n-  tree_code_name\n-    = (char **) realloc (tree_code_name,\n-\t\t\t sizeof (char *) * LAST_CPLUS_TREE_CODE);\n-  bcopy ((char *)cplus_tree_code_type,\n-\t (char *)(tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE),\n-\t (LAST_CPLUS_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (char *));\n+  bcopy (cplus_tree_code_type,\n+\t tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE,\n+\t (int)LAST_CPLUS_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE);\n   bcopy ((char *)cplus_tree_code_length,\n \t (char *)(tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE),\n \t (LAST_CPLUS_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (int));"}, {"sha": "c4a2690e8156c7489cd860d48ca000dee185cbfb", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -86,8 +86,8 @@ Boston, MA 02111-1307, USA.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-char *objc_tree_code_type[] = {\n-  \"x\",\n+char objc_tree_code_type[] = {\n+  'x',\n #include \"objc-tree.def\"\n };\n #undef DEFTREECODE\n@@ -8022,19 +8022,9 @@ init_objc ()\n   gcc_obstack_init (&util_obstack);\n   util_firstobj = (char *) obstack_finish (&util_obstack);\n \n-  tree_code_type\n-    = (char **) xrealloc (tree_code_type,\n-\t\t\t  sizeof (char *) * LAST_OBJC_TREE_CODE);\n-  tree_code_length\n-    = (int *) xrealloc (tree_code_length,\n-\t\t\tsizeof (int) * LAST_OBJC_TREE_CODE);\n-  tree_code_name\n-    = (char **) xrealloc (tree_code_name,\n-\t\t\t  sizeof (char *) * LAST_OBJC_TREE_CODE);\n-  bcopy ((char *) objc_tree_code_type,\n-\t (char *) (tree_code_type + (int) LAST_CODE),\n-\t (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE)\n-\t  * sizeof (char *)));\n+  bcopy (objc_tree_code_type,\n+\t tree_code_type + (int) LAST_CODE,\n+\t (int) LAST_OBJC_TREE_CODE - (int) LAST_CODE);\n   bcopy ((char *) objc_tree_code_length,\n \t (char *) (tree_code_length + (int) LAST_CODE),\n \t (((int) LAST_OBJC_TREE_CODE - (int) LAST_CODE)"}, {"sha": "9d6765b295e3b91f7b2dbe5bf4f625ee195f1eb4", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -22,16 +22,16 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* Objective-C types.  */\n-DEFTREECODE (CLASS_INTERFACE_TYPE, \"class_interface_type\", \"t\", 0)\n-DEFTREECODE (CLASS_IMPLEMENTATION_TYPE, \"class_implementation_type\", \"t\", 0)\n-DEFTREECODE (CATEGORY_INTERFACE_TYPE, \"category_interface_type\", \"t\", 0)\n-DEFTREECODE (CATEGORY_IMPLEMENTATION_TYPE,\"category_implementation_type\",\"t\",0)\n-DEFTREECODE (PROTOCOL_INTERFACE_TYPE, \"protocol_interface_type\", \"t\", 0)\n+DEFTREECODE (CLASS_INTERFACE_TYPE, \"class_interface_type\", 't', 0)\n+DEFTREECODE (CLASS_IMPLEMENTATION_TYPE, \"class_implementation_type\", 't', 0)\n+DEFTREECODE (CATEGORY_INTERFACE_TYPE, \"category_interface_type\", 't', 0)\n+DEFTREECODE (CATEGORY_IMPLEMENTATION_TYPE,\"category_implementation_type\",'t',0)\n+DEFTREECODE (PROTOCOL_INTERFACE_TYPE, \"protocol_interface_type\", 't', 0)\n \n /* Objective-C decls.  */\n-DEFTREECODE (KEYWORD_DECL, \"keyword_decl\", \"d\", 0)\n-DEFTREECODE (INSTANCE_METHOD_DECL, \"instance_method_decl\", \"d\", 0)\n-DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", \"d\", 0)\n+DEFTREECODE (KEYWORD_DECL, \"keyword_decl\", 'd', 0)\n+DEFTREECODE (INSTANCE_METHOD_DECL, \"instance_method_decl\", 'd', 0)\n+DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", 'd', 0)\n \n /* Objective-C constants.  */\n-DEFTREECODE (OBJC_STRING_CST, \"objc_string_cst\", \"c\", 3)\n+DEFTREECODE (OBJC_STRING_CST, \"objc_string_cst\", 'c', 3)"}, {"sha": "8d7db2b987b09dc3b9bd8d36a9b146e5454e2fe8", "filename": "gcc/print-tree.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -1,5 +1,5 @@\n /* Prints out tree in human readable form - GNU C-compiler\n-   Copyright (C) 1990, 91, 93, 94, 95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 91, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -23,8 +23,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include <stdio.h>\n \n-extern char **tree_code_name;\n-\n extern char *mode_name[];\n \n void print_node ();\n@@ -541,9 +539,8 @@ print_node (file, prefix, node, indent)\n     case '2':\n     case 'r':\n     case 's':\n-      switch (TREE_CODE (node))\n+      if (TREE_CODE (node) == BIND_EXPR)\n \t{\n-\tcase BIND_EXPR:\n \t  print_node (file, \"vars\", TREE_OPERAND (node, 0), indent + 4);\n \t  print_node (file, \"body\", TREE_OPERAND (node, 1), indent + 4);\n \t  print_node (file, \"block\", TREE_OPERAND (node, 2), indent + 4);\n@@ -570,6 +567,8 @@ print_node (file, prefix, node, indent)\n \t  break;\n \tcase RTL_EXPR:\n \t  first_rtl = 0;\n+\tdefault:\n+\t  break;\n \t}\n       for (i = 0; i < len; i++)\n \t{\n@@ -689,6 +688,10 @@ print_node (file, prefix, node, indent)\n \tcase OP_IDENTIFIER:\n \t  print_node (file, \"op1\", TREE_PURPOSE (node), indent + 4);\n \t  print_node (file, \"op2\", TREE_VALUE (node), indent + 4);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n \n       break;"}, {"sha": "7b150ebf3885d2734cb643dbe80d4b0a3afe0741", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -189,7 +189,7 @@ struct momentary_level *momentary_stack;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-char *standard_tree_code_type[] = {\n+char tree_code_type[MAX_TREE_CODES] = {\n #include \"tree.def\"\n };\n #undef DEFTREECODE\n@@ -200,7 +200,7 @@ char *standard_tree_code_type[] = {\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) LENGTH,\n \n-int standard_tree_code_length[] = {\n+int tree_code_length[MAX_TREE_CODES] = {\n #include \"tree.def\"\n };\n #undef DEFTREECODE\n@@ -209,27 +209,11 @@ int standard_tree_code_length[] = {\n    Used for printing out the tree and error messages.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LEN) NAME,\n \n-char *standard_tree_code_name[] = {\n+char *tree_code_name[MAX_TREE_CODES] = {\n #include \"tree.def\"\n };\n #undef DEFTREECODE\n \n-/* Table indexed by tree code giving a string containing a character\n-   classifying the tree code.  Possibilities are\n-   t, d, s, c, r, e, <, 1 and 2.  See tree.def for details.  */\n-\n-char **tree_code_type;\n-\n-/* Table indexed by tree code giving number of expression\n-   operands beyond the fixed part of the node structure.\n-   Not used for types or decls.  */\n-\n-int *tree_code_length;\n-\n-/* Table indexed by tree code giving name of tree code, as a string.  */\n-\n-char **tree_code_name;\n-\n /* Statistics-gathering stuff.  */\n typedef enum\n {\n@@ -942,15 +926,7 @@ resume_momentary (yes)\n void\n init_tree_codes ()\n {\n-  tree_code_type = (char **) xmalloc (sizeof (standard_tree_code_type));\n-  tree_code_length = (int *) xmalloc (sizeof (standard_tree_code_length));\n-  tree_code_name = (char **) xmalloc (sizeof (standard_tree_code_name));\n-  bcopy ((char *) standard_tree_code_type, (char *) tree_code_type,\n-\t sizeof (standard_tree_code_type));\n-  bcopy ((char *) standard_tree_code_length, (char *) tree_code_length,\n-\t sizeof (standard_tree_code_length));\n-  bcopy ((char *) standard_tree_code_name, (char *) tree_code_name,\n-\t sizeof (standard_tree_code_name));\n+  \n }\n \n /* Return a newly allocated node of code CODE.\n@@ -3906,8 +3882,7 @@ simple_cst_equal (t1, t2)\n      handled above.  If this is a language-specific tree code, we can't\n      trust what might be in the operand, so say we don't know\n      the situation.  */\n-  if ((int) code1\n-      >= sizeof standard_tree_code_type / sizeof standard_tree_code_type[0])\n+  if ((int) code1 >= (int) LAST_AND_UNUSED_TREE_CODE)\n     return -1;\n \n   switch (TREE_CODE_CLASS (code1))"}, {"sha": "9a654c9a3b6b87b782662b57d00671aeb5a2c94b", "filename": "gcc/tree.def", "status": "modified", "additions": 123, "deletions": 123, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -122,7 +122,7 @@ DEFTREECODE (BLOCK, \"block\", \"b\", 0)\n     ENUMERAL_TYPE, RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE nodes;\n     see below.  */\n \n-DEFTREECODE (VOID_TYPE, \"void_type\", \"t\", 0)\t/* The void type in C */\n+DEFTREECODE (VOID_TYPE, \"void_type\", 't', 0)\t/* The void type in C */\n \n /* Integer types in all languages, including char in C.\n    Also used for sub-ranges of other discrete types.\n@@ -132,15 +132,15 @@ DEFTREECODE (VOID_TYPE, \"void_type\", \"t\", 0)\t/* The void type in C */\n    of this will point at the supertype (another INTEGER_TYPE,\n    or an ENUMERAL_TYPE, CHAR_TYPE, or BOOLEAN_TYPE).\n    Otherwise, the TREE_TYPE is zero.  */\n-DEFTREECODE (INTEGER_TYPE, \"integer_type\", \"t\", 0)\n+DEFTREECODE (INTEGER_TYPE, \"integer_type\", 't', 0)\n \n /* C's float and double.  Different floating types are distinguished\n    by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  */\n-DEFTREECODE (REAL_TYPE, \"real_type\", \"t\", 0)\n+DEFTREECODE (REAL_TYPE, \"real_type\", 't', 0)\n \n /* Complex number types.  The TREE_TYPE field is the data type\n    of the real and imaginary parts.  */\n-DEFTREECODE (COMPLEX_TYPE, \"complex_type\", \"t\", 0)\n+DEFTREECODE (COMPLEX_TYPE, \"complex_type\", 't', 0)\n \n /* C enums.  The type node looks just like an INTEGER_TYPE node.\n    The symbols for the values of the enum type are defined by\n@@ -153,39 +153,39 @@ DEFTREECODE (COMPLEX_TYPE, \"complex_type\", \"t\", 0)\n    fields are filled in.\n    RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE forward refs are\n    treated similarly.  */\n-DEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", \"t\", 0)\n+DEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", 't', 0)\n \n /* Pascal's boolean type (true or false are the only values);\n    no special fields needed.  */\n-DEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", \"t\", 0)\n+DEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", 't', 0)\n \n /* CHAR in Pascal; not used in C.\n    No special fields needed.  */\n-DEFTREECODE (CHAR_TYPE, \"char_type\", \"t\", 0)\n+DEFTREECODE (CHAR_TYPE, \"char_type\", 't', 0)\n \n /* All pointer-to-x types have code POINTER_TYPE.\n    The TREE_TYPE points to the node for the type pointed to.  */\n-DEFTREECODE (POINTER_TYPE, \"pointer_type\", \"t\", 0)\n+DEFTREECODE (POINTER_TYPE, \"pointer_type\", 't', 0)\n \n /* An offset is a pointer relative to an object.\n    The TREE_TYPE field is the type of the object at the offset.\n    The TYPE_OFFSET_BASETYPE points to the node for the type of object\n    that the offset is relative to.  */\n-DEFTREECODE (OFFSET_TYPE, \"offset_type\", \"t\", 0)\n+DEFTREECODE (OFFSET_TYPE, \"offset_type\", 't', 0)\n \n /* A reference is like a pointer except that it is coerced\n    automatically to the value it points to.  Used in C++.  */\n-DEFTREECODE (REFERENCE_TYPE, \"reference_type\", \"t\", 0)\n+DEFTREECODE (REFERENCE_TYPE, \"reference_type\", 't', 0)\n \n /* METHOD_TYPE is the type of a function which takes an extra first\n    argument for \"self\", which is not present in the declared argument list.\n    The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE\n    is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which\n    includes the hidden argument for \"self\".  */\n-DEFTREECODE (METHOD_TYPE, \"method_type\", \"t\", 0)\n+DEFTREECODE (METHOD_TYPE, \"method_type\", 't', 0)\n \n /* Used for Pascal; details not determined right now.  */\n-DEFTREECODE (FILE_TYPE, \"file_type\", \"t\", 0)\n+DEFTREECODE (FILE_TYPE, \"file_type\", 't', 0)\n \n /* Types of arrays.  Special fields:\n    TREE_TYPE\t\t  Type of an array element.\n@@ -198,13 +198,13 @@ DEFTREECODE (FILE_TYPE, \"file_type\", \"t\", 0)\n  TYPE_STRING_FLAG indicates a string (in contrast to an array of chars)\n  in languages (such as Chill) that make a distinction. */\n /* Array types in C or Pascal */\n-DEFTREECODE (ARRAY_TYPE, \"array_type\", \"t\", 0)\n+DEFTREECODE (ARRAY_TYPE, \"array_type\", 't', 0)\n \n /* Types of sets for Pascal.  Special fields are the same as\n    in an array type.  The target type is always a boolean type.\n    Used for both bitstrings and powersets in Chill;\n    TYPE_STRING_FLAG indicates a bitstring. */\n-DEFTREECODE (SET_TYPE, \"set_type\", \"t\", 0)\n+DEFTREECODE (SET_TYPE, \"set_type\", 't', 0)\n \n /* Struct in C, or record in Pascal.  */\n /* Special fields:\n@@ -214,33 +214,33 @@ DEFTREECODE (SET_TYPE, \"set_type\", \"t\", 0)\n    A few may need to be added for Pascal.  */\n /* See the comment above, before ENUMERAL_TYPE, for how\n    forward references to struct tags are handled in C.  */\n-DEFTREECODE (RECORD_TYPE, \"record_type\", \"t\", 0)\n+DEFTREECODE (RECORD_TYPE, \"record_type\", 't', 0)\n \n /* Union in C.  Like a struct, except that the offsets of the fields\n    will all be zero.  */\n /* See the comment above, before ENUMERAL_TYPE, for how\n    forward references to union tags are handled in C.  */\n-DEFTREECODE (UNION_TYPE, \"union_type\", \"t\", 0)\t/* C union type */\n+DEFTREECODE (UNION_TYPE, \"union_type\", 't', 0)\t/* C union type */\n \n /* Similar to UNION_TYPE, except that the expressions in DECL_QUALIFIER\n    in each FIELD_DECL determine what the union contains.  The first\n    field whose DECL_QUALIFIER expression is true is deemed to occupy\n    the union.  */\n-DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", \"t\", 0)\n+DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", 't', 0)\n \n /* Type of functions.  Special fields:\n    TREE_TYPE\t\t    type of value returned.\n    TYPE_ARG_TYPES      list of types of arguments expected.\n \tthis list is made of TREE_LIST nodes.\n    Types of \"Procedures\" in languages where they are different from functions\n    have code FUNCTION_TYPE also, but then TREE_TYPE is zero or void type.  */\n-DEFTREECODE (FUNCTION_TYPE, \"function_type\", \"t\", 0)\n+DEFTREECODE (FUNCTION_TYPE, \"function_type\", 't', 0)\n \n /* This is a language-specific kind of type.\n    Its meaning is defined by the language front end.\n    layout_type does not know how to lay this out,\n    so the front-end must do so manually.  */\n-DEFTREECODE (LANG_TYPE, \"lang_type\", \"t\", 0)\n+DEFTREECODE (LANG_TYPE, \"lang_type\", 't', 0)\n \f\n /* Expressions */\n \n@@ -251,19 +251,19 @@ DEFTREECODE (LANG_TYPE, \"lang_type\", \"t\", 0)\n    Note: constants of type char in Pascal are INTEGER_CST,\n    and so are pointer constants such as nil in Pascal or NULL in C.\n    `(int *) 1' in C also results in an INTEGER_CST.  */\n-DEFTREECODE (INTEGER_CST, \"integer_cst\", \"c\", 2)\n+DEFTREECODE (INTEGER_CST, \"integer_cst\", 'c', 2)\n \n /* Contents are in TREE_REAL_CST field.  Also there is TREE_CST_RTL.  */\n-DEFTREECODE (REAL_CST, \"real_cst\", \"c\", 3)\n+DEFTREECODE (REAL_CST, \"real_cst\", 'c', 3)\n \n /* Contents are in TREE_REALPART and TREE_IMAGPART fields,\n    whose contents are other constant nodes.\n    Also there is TREE_CST_RTL.  */\n-DEFTREECODE (COMPLEX_CST, \"complex_cst\", \"c\", 3)\n+DEFTREECODE (COMPLEX_CST, \"complex_cst\", 'c', 3)\n \n /* Contents are TREE_STRING_LENGTH and TREE_STRING_POINTER fields.\n    Also there is TREE_CST_RTL.  */\n-DEFTREECODE (STRING_CST, \"string_cst\", \"c\", 3)\n+DEFTREECODE (STRING_CST, \"string_cst\", 'c', 3)\n \n /* Declarations.  All references to names are represented as ..._DECL nodes.\n    The decls in one binding context are chained through the TREE_CHAIN field.\n@@ -323,21 +323,21 @@ DEFTREECODE (STRING_CST, \"string_cst\", \"c\", 3)\n    of a decl (i.e. one which is nested within an abstract instance of a\n    inline function.  */\n \n-DEFTREECODE (FUNCTION_DECL, \"function_decl\", \"d\", 0)\n-DEFTREECODE (LABEL_DECL, \"label_decl\", \"d\", 0)\n-DEFTREECODE (CONST_DECL, \"const_decl\", \"d\", 0)\n-DEFTREECODE (TYPE_DECL, \"type_decl\", \"d\", 0)\n-DEFTREECODE (VAR_DECL, \"var_decl\", \"d\", 0)\n-DEFTREECODE (PARM_DECL, \"parm_decl\", \"d\", 0)\n-DEFTREECODE (RESULT_DECL, \"result_decl\", \"d\", 0)\n-DEFTREECODE (FIELD_DECL, \"field_decl\", \"d\", 0)\n+DEFTREECODE (FUNCTION_DECL, \"function_decl\", 'd', 0)\n+DEFTREECODE (LABEL_DECL, \"label_decl\", 'd', 0)\n+DEFTREECODE (CONST_DECL, \"const_decl\", 'd', 0)\n+DEFTREECODE (TYPE_DECL, \"type_decl\", 'd', 0)\n+DEFTREECODE (VAR_DECL, \"var_decl\", 'd', 0)\n+DEFTREECODE (PARM_DECL, \"parm_decl\", 'd', 0)\n+DEFTREECODE (RESULT_DECL, \"result_decl\", 'd', 0)\n+DEFTREECODE (FIELD_DECL, \"field_decl\", 'd', 0)\n \f\n /* References to storage.  */\n \n /* Value is structure or union component.\n    Operand 0 is the structure or union (an expression);\n    operand 1 is the field (a node of type FIELD_DECL).  */\n-DEFTREECODE (COMPONENT_REF, \"component_ref\", \"r\", 2)\n+DEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 2)\n \n /* Reference to a group of bits within an object.  Similar to COMPONENT_REF\n    except the position is given explicitly rather than via a FIELD_DECL.\n@@ -346,18 +346,18 @@ DEFTREECODE (COMPONENT_REF, \"component_ref\", \"r\", 2)\n    operand 2 is a tree giving the position of the first referenced bit.\n    The field can be either a signed or unsigned field;\n    TREE_UNSIGNED says which.  */\n-DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", \"r\", 3)\n+DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", 'r', 3)\n    \n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n-DEFTREECODE (INDIRECT_REF, \"indirect_ref\", \"r\", 1)\n+DEFTREECODE (INDIRECT_REF, \"indirect_ref\", 'r', 1)\n \n /* Pascal `^` on a file.  One operand, an expression for the file.  */\n-DEFTREECODE (BUFFER_REF, \"buffer_ref\", \"r\", 1)\n+DEFTREECODE (BUFFER_REF, \"buffer_ref\", 'r', 1)\n \n /* Array indexing in languages other than C.\n    Operand 0 is the array; operand 1 is a list of indices\n    stored as a chain of TREE_LIST nodes.  */\n-DEFTREECODE (ARRAY_REF, \"array_ref\", \"r\", 2)\n+DEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 2)\n \n /* Constructor: return an aggregate value made from specified components.\n    In C, this is used only for structure and array initializers.\n@@ -381,7 +381,7 @@ DEFTREECODE (ARRAY_REF, \"array_ref\", \"r\", 2)\n    The TREE_VALUE specifies a value (index) in the set that is true.\n    If TREE_PURPOSE is non-NULL, it specifies the lower limit of a\n    range of true values.  Elements not listed are false (not in the set).  */\n-DEFTREECODE (CONSTRUCTOR, \"constructor\", \"e\", 2)\n+DEFTREECODE (CONSTRUCTOR, \"constructor\", 'e', 2)\n \n /* The expression types are mostly straightforward, with the fourth argument\n    of DEFTREECODE saying how many operands there are.\n@@ -391,29 +391,29 @@ DEFTREECODE (CONSTRUCTOR, \"constructor\", \"e\", 2)\n /* Contains two expressions to compute, one followed by the other.\n    the first value is ignored.  The second one's value is used.  The\n    type of the first expression need not agree with the other types.  */\n-DEFTREECODE (COMPOUND_EXPR, \"compound_expr\", \"e\", 2)\n+DEFTREECODE (COMPOUND_EXPR, \"compound_expr\", 'e', 2)\n \n /* Assignment expression.  Operand 0 is the what to set; 1, the new value.  */\n-DEFTREECODE (MODIFY_EXPR, \"modify_expr\", \"e\", 2)\n+DEFTREECODE (MODIFY_EXPR, \"modify_expr\", 'e', 2)\n \n /* Initialization expression.  Operand 0 is the variable to initialize;\n    Operand 1 is the initializer.  */\n-DEFTREECODE (INIT_EXPR, \"init_expr\", \"e\", 2)\n+DEFTREECODE (INIT_EXPR, \"init_expr\", 'e', 2)\n \n /* For TARGET_EXPR, operand 0 is the target of an initialization,\n    operand 1 is the initializer for the target,\n    and operand 2 is the cleanup for this node, if any.\n    and operand 3 is the saved initializer after this node has been\n    expanded once, this is so we can re-expand the tree later.  */\n-DEFTREECODE (TARGET_EXPR, \"target_expr\", \"e\", 4)\n+DEFTREECODE (TARGET_EXPR, \"target_expr\", 'e', 4)\n \n /* Conditional expression ( ... ? ... : ...  in C).\n    Operand 0 is the condition.\n    Operand 1 is the then-value.\n    Operand 2 is the else-value.\n    Operand 0 may be of any types, but the types of operands 1 and 2\n    must be the same and the same as the the of this expression.  */\n-DEFTREECODE (COND_EXPR, \"cond_expr\", \"e\", 3)\n+DEFTREECODE (COND_EXPR, \"cond_expr\", 'e', 3)\n \n /* Declare local variables, including making RTL and allocating space.\n    Operand 0 is a chain of VAR_DECL nodes for the variables.\n@@ -436,19 +436,19 @@ DEFTREECODE (COND_EXPR, \"cond_expr\", \"e\", 3)\n    In order for the BIND_EXPR to be known at all, the code that creates it\n    must also install it as a subblock in the tree of BLOCK\n    nodes for the function.  */\n-DEFTREECODE (BIND_EXPR, \"bind_expr\", \"e\", 3)\n+DEFTREECODE (BIND_EXPR, \"bind_expr\", 'e', 3)\n \n /* Function call.  Operand 0 is the function.\n    Operand 1 is the argument list, a list of expressions\n    made out of a chain of TREE_LIST nodes.\n    There is no operand 2.  That slot is used for the\n    CALL_EXPR_RTL macro (see preexpand_calls).  */\n-DEFTREECODE (CALL_EXPR, \"call_expr\", \"e\", 3)\n+DEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 3)\n \n /* Call a method.  Operand 0 is the method, whose type is a METHOD_TYPE.\n    Operand 1 is the expression for \"self\".\n    Operand 2 is the list of explicit arguments.  */\n-DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", \"e\", 4)\n+DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", 'e', 4)\n \n /* Specify a value to compute along with its corresponding cleanup.\n    Operand 0 argument is an expression whose value needs a cleanup.\n@@ -462,7 +462,7 @@ DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", \"e\", 4)\n \n    This differs from TRY_CATCH_EXPR in that operand 2 is always\n    evaluated when an exception isn't thrown when cleanups are run.  */\n-DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", \"e\", 3)\n+DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 3)\n \n /* Specify a cleanup point.\n    Operand 0 is an expression that may have cleanups.  If it does, those\n@@ -479,7 +479,7 @@ DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", \"e\", 3)\n \n    As a consequence, the operand of a CLEANUP_POINT_EXPR must not have\n    BLKmode, because it will not be forced out of memory.  */\n-DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", \"e\", 1)\n+DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n \n /* The following two codes are used in languages that have types where\n    the position and/or sizes of fields vary from object to object of the\n@@ -519,133 +519,133 @@ DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", \"e\", 1)\n /* Denotes a record to later be supplied with a WITH_RECORD_EXPR when\n    evaluating this expression.  The type of this expression is used to\n    find the record to replace it.  */\n-DEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", \"x\", 0)\n+DEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", 'x', 0)\n \n /* Provide an expression that references a record to be used in place\n    of a PLACEHOLDER_EXPR.  The record to be used is the record within\n    operand 1 that has the same type as the PLACEHOLDER_EXPR in\n    operand 0.  */\n-DEFTREECODE (WITH_RECORD_EXPR, \"with_record_expr\", \"e\", 2)\n+DEFTREECODE (WITH_RECORD_EXPR, \"with_record_expr\", 'e', 2)\n \n /* Simple arithmetic.  */\n-DEFTREECODE (PLUS_EXPR, \"plus_expr\", \"2\", 2)\n-DEFTREECODE (MINUS_EXPR, \"minus_expr\", \"2\", 2)\n-DEFTREECODE (MULT_EXPR, \"mult_expr\", \"2\", 2)\n+DEFTREECODE (PLUS_EXPR, \"plus_expr\", '2', 2)\n+DEFTREECODE (MINUS_EXPR, \"minus_expr\", '2', 2)\n+DEFTREECODE (MULT_EXPR, \"mult_expr\", '2', 2)\n \n /* Division for integer result that rounds the quotient toward zero.  */\n-DEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", \"2\", 2)\n+DEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", '2', 2)\n \n /* Division for integer result that rounds the quotient toward infinity.  */\n-DEFTREECODE (CEIL_DIV_EXPR, \"ceil_div_expr\", \"2\", 2)\n+DEFTREECODE (CEIL_DIV_EXPR, \"ceil_div_expr\", '2', 2)\n \n /* Division for integer result that rounds toward minus infinity.  */\n-DEFTREECODE (FLOOR_DIV_EXPR, \"floor_div_expr\", \"2\", 2)\n+DEFTREECODE (FLOOR_DIV_EXPR, \"floor_div_expr\", '2', 2)\n \n /* Division for integer result that rounds toward nearest integer.  */\n-DEFTREECODE (ROUND_DIV_EXPR, \"round_div_expr\", \"2\", 2)\n+DEFTREECODE (ROUND_DIV_EXPR, \"round_div_expr\", '2', 2)\n \n /* Four kinds of remainder that go with the four kinds of division.  */\n-DEFTREECODE (TRUNC_MOD_EXPR, \"trunc_mod_expr\", \"2\", 2)\n-DEFTREECODE (CEIL_MOD_EXPR, \"ceil_mod_expr\", \"2\", 2)\n-DEFTREECODE (FLOOR_MOD_EXPR, \"floor_mod_expr\", \"2\", 2)\n-DEFTREECODE (ROUND_MOD_EXPR, \"round_mod_expr\", \"2\", 2)\n+DEFTREECODE (TRUNC_MOD_EXPR, \"trunc_mod_expr\", '2', 2)\n+DEFTREECODE (CEIL_MOD_EXPR, \"ceil_mod_expr\", '2', 2)\n+DEFTREECODE (FLOOR_MOD_EXPR, \"floor_mod_expr\", '2', 2)\n+DEFTREECODE (ROUND_MOD_EXPR, \"round_mod_expr\", '2', 2)\n \n /* Division for real result.  */\n-DEFTREECODE (RDIV_EXPR, \"rdiv_expr\", \"2\", 2)\n+DEFTREECODE (RDIV_EXPR, \"rdiv_expr\", '2', 2)\n \n /* Division which is not supposed to need rounding.\n    Used for pointer subtraction in C.  */\n-DEFTREECODE (EXACT_DIV_EXPR, \"exact_div_expr\", \"2\", 2)\n+DEFTREECODE (EXACT_DIV_EXPR, \"exact_div_expr\", '2', 2)\n \n /* Conversion of real to fixed point: four ways to round,\n    like the four ways to divide.\n    CONVERT_EXPR can also be used to convert a real to an integer,\n    and that is what is used in languages that do not have ways of\n    specifying which of these is wanted.  Maybe these are not needed.  */\n-DEFTREECODE (FIX_TRUNC_EXPR, \"fix_trunc_expr\", \"1\", 1)\n-DEFTREECODE (FIX_CEIL_EXPR, \"fix_ceil_expr\", \"1\", 1)\n-DEFTREECODE (FIX_FLOOR_EXPR, \"fix_floor_expr\", \"1\", 1)\n-DEFTREECODE (FIX_ROUND_EXPR, \"fix_round_expr\", \"1\", 1)\n+DEFTREECODE (FIX_TRUNC_EXPR, \"fix_trunc_expr\", '1', 1)\n+DEFTREECODE (FIX_CEIL_EXPR, \"fix_ceil_expr\", '1', 1)\n+DEFTREECODE (FIX_FLOOR_EXPR, \"fix_floor_expr\", '1', 1)\n+DEFTREECODE (FIX_ROUND_EXPR, \"fix_round_expr\", '1', 1)\n \n /* Conversion of an integer to a real.  */\n-DEFTREECODE (FLOAT_EXPR, \"float_expr\", \"1\", 1)\n+DEFTREECODE (FLOAT_EXPR, \"float_expr\", '1', 1)\n \n /* Exponentiation.  Operands may have any types;\n    constraints on value type are not known yet.  */\n-DEFTREECODE (EXPON_EXPR, \"expon_expr\", \"2\", 2)\n+DEFTREECODE (EXPON_EXPR, \"expon_expr\", '2', 2)\n \n /* Unary negation.  */\n-DEFTREECODE (NEGATE_EXPR, \"negate_expr\", \"1\", 1)\n+DEFTREECODE (NEGATE_EXPR, \"negate_expr\", '1', 1)\n \n-DEFTREECODE (MIN_EXPR, \"min_expr\", \"2\", 2)\n-DEFTREECODE (MAX_EXPR, \"max_expr\", \"2\", 2)\n-DEFTREECODE (ABS_EXPR, \"abs_expr\", \"1\", 1)\n-DEFTREECODE (FFS_EXPR, \"ffs_expr\", \"1\", 1)\n+DEFTREECODE (MIN_EXPR, \"min_expr\", '2', 2)\n+DEFTREECODE (MAX_EXPR, \"max_expr\", '2', 2)\n+DEFTREECODE (ABS_EXPR, \"abs_expr\", '1', 1)\n+DEFTREECODE (FFS_EXPR, \"ffs_expr\", '1', 1)\n \n /* Shift operations for shift and rotate.\n    Shift is supposed to mean logical shift if done on an\n    unsigned type, arithmetic shift on a signed type.\n    The second operand is the number of bits to\n    shift by; it need not be the same type as the first operand and result.  */\n-DEFTREECODE (LSHIFT_EXPR, \"lshift_expr\", \"2\", 2)\n-DEFTREECODE (RSHIFT_EXPR, \"rshift_expr\", \"2\", 2)\n-DEFTREECODE (LROTATE_EXPR, \"lrotate_expr\", \"2\", 2)\n-DEFTREECODE (RROTATE_EXPR, \"rrotate_expr\", \"2\", 2)\n+DEFTREECODE (LSHIFT_EXPR, \"lshift_expr\", '2', 2)\n+DEFTREECODE (RSHIFT_EXPR, \"rshift_expr\", '2', 2)\n+DEFTREECODE (LROTATE_EXPR, \"lrotate_expr\", '2', 2)\n+DEFTREECODE (RROTATE_EXPR, \"rrotate_expr\", '2', 2)\n \n /* Bitwise operations.  Operands have same mode as result.  */\n-DEFTREECODE (BIT_IOR_EXPR, \"bit_ior_expr\", \"2\", 2)\n-DEFTREECODE (BIT_XOR_EXPR, \"bit_xor_expr\", \"2\", 2)\n-DEFTREECODE (BIT_AND_EXPR, \"bit_and_expr\", \"2\", 2)\n-DEFTREECODE (BIT_ANDTC_EXPR, \"bit_andtc_expr\", \"2\", 2)\n-DEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", \"1\", 1)\n+DEFTREECODE (BIT_IOR_EXPR, \"bit_ior_expr\", '2', 2)\n+DEFTREECODE (BIT_XOR_EXPR, \"bit_xor_expr\", '2', 2)\n+DEFTREECODE (BIT_AND_EXPR, \"bit_and_expr\", '2', 2)\n+DEFTREECODE (BIT_ANDTC_EXPR, \"bit_andtc_expr\", '2', 2)\n+DEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", '1', 1)\n \n /* Combination of boolean values or of integers considered only\n    as zero or nonzero.  ANDIF and ORIF allow the second operand\n    not to be computed if the value of the expression is determined\n    from the first operand.  AND, OR, and XOR always compute the second\n    operand whether its value is needed or not (for side effects).  */\n-DEFTREECODE (TRUTH_ANDIF_EXPR, \"truth_andif_expr\", \"e\", 2)\n-DEFTREECODE (TRUTH_ORIF_EXPR, \"truth_orif_expr\", \"e\", 2)\n-DEFTREECODE (TRUTH_AND_EXPR, \"truth_and_expr\", \"e\", 2)\n-DEFTREECODE (TRUTH_OR_EXPR, \"truth_or_expr\", \"e\", 2)\n-DEFTREECODE (TRUTH_XOR_EXPR, \"truth_xor_expr\", \"e\", 2)\n-DEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", \"e\", 1)\n+DEFTREECODE (TRUTH_ANDIF_EXPR, \"truth_andif_expr\", 'e', 2)\n+DEFTREECODE (TRUTH_ORIF_EXPR, \"truth_orif_expr\", 'e', 2)\n+DEFTREECODE (TRUTH_AND_EXPR, \"truth_and_expr\", 'e', 2)\n+DEFTREECODE (TRUTH_OR_EXPR, \"truth_or_expr\", 'e', 2)\n+DEFTREECODE (TRUTH_XOR_EXPR, \"truth_xor_expr\", 'e', 2)\n+DEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", 'e', 1)\n \n /* Relational operators.\n    `EQ_EXPR' and `NE_EXPR' are allowed for any types.\n    The others are allowed only for integer (or pointer or enumeral)\n    or real types.\n    In all cases the operands will have the same type,\n    and the value is always the type used by the language for booleans.  */\n-DEFTREECODE (LT_EXPR, \"lt_expr\", \"<\", 2)\n-DEFTREECODE (LE_EXPR, \"le_expr\", \"<\", 2)\n-DEFTREECODE (GT_EXPR, \"gt_expr\", \"<\", 2)\n-DEFTREECODE (GE_EXPR, \"ge_expr\", \"<\", 2)\n-DEFTREECODE (EQ_EXPR, \"eq_expr\", \"<\", 2)\n-DEFTREECODE (NE_EXPR, \"ne_expr\", \"<\", 2)\n+DEFTREECODE (LT_EXPR, \"lt_expr\", '<', 2)\n+DEFTREECODE (LE_EXPR, \"le_expr\", '<', 2)\n+DEFTREECODE (GT_EXPR, \"gt_expr\", '<', 2)\n+DEFTREECODE (GE_EXPR, \"ge_expr\", '<', 2)\n+DEFTREECODE (EQ_EXPR, \"eq_expr\", '<', 2)\n+DEFTREECODE (NE_EXPR, \"ne_expr\", '<', 2)\n \n /* Operations for Pascal sets.  Not used now.  */\n-DEFTREECODE (IN_EXPR, \"in_expr\", \"2\", 2)\n-DEFTREECODE (SET_LE_EXPR, \"set_le_expr\", \"<\", 2)\n-DEFTREECODE (CARD_EXPR, \"card_expr\", \"1\", 1)\n-DEFTREECODE (RANGE_EXPR, \"range_expr\", \"2\", 2)\n+DEFTREECODE (IN_EXPR, \"in_expr\", '2', 2)\n+DEFTREECODE (SET_LE_EXPR, \"set_le_expr\", '<', 2)\n+DEFTREECODE (CARD_EXPR, \"card_expr\", '1', 1)\n+DEFTREECODE (RANGE_EXPR, \"range_expr\", '2', 2)\n \n /* Represents a conversion of type of a value.\n    All conversions, including implicit ones, must be\n    represented by CONVERT_EXPR or NOP_EXPR nodes.  */\n-DEFTREECODE (CONVERT_EXPR, \"convert_expr\", \"1\", 1)\n+DEFTREECODE (CONVERT_EXPR, \"convert_expr\", '1', 1)\n \n /* Represents a conversion expected to require no code to be generated.  */\n-DEFTREECODE (NOP_EXPR, \"nop_expr\", \"1\", 1)\n+DEFTREECODE (NOP_EXPR, \"nop_expr\", '1', 1)\n \n /* Value is same as argument, but guaranteed not an lvalue.  */\n-DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", \"1\", 1)\n+DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n \n /* Represents something we computed once and will use multiple times.\n    First operand is that expression.  Second is the function decl\n    in which the SAVE_EXPR was created.  The third operand is the RTL,\n    nonzero only after the expression has been computed.  */\n-DEFTREECODE (SAVE_EXPR, \"save_expr\", \"e\", 3)\n+DEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 3)\n \n /* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n    mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs,\n@@ -654,90 +654,90 @@ DEFTREECODE (SAVE_EXPR, \"save_expr\", \"e\", 3)\n    expand_expr call of this expr will cause those to be re-evaluated.\n    This is useful when we want to reuse a tree in different places,\n    but where we must re-expand.  */\n-DEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", \"e\", 1)\n+DEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", 'e', 1)\n \n /* Represents something whose RTL has already been expanded\n    as a sequence which should be emitted when this expression is expanded.\n    The first operand is the RTL to emit.  It is the first of a chain of insns.\n    The second is the RTL expression for the result.  */\n-DEFTREECODE (RTL_EXPR, \"rtl_expr\", \"e\", 2)\n+DEFTREECODE (RTL_EXPR, \"rtl_expr\", 'e', 2)\n \n /* & in C.  Value is the address at which the operand's value resides.\n    Operand may have any mode.  Result mode is Pmode.  */\n-DEFTREECODE (ADDR_EXPR, \"addr_expr\", \"e\", 1)\n+DEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)\n \n /* Non-lvalue reference or pointer to an object.  */\n-DEFTREECODE (REFERENCE_EXPR, \"reference_expr\", \"e\", 1)\n+DEFTREECODE (REFERENCE_EXPR, \"reference_expr\", 'e', 1)\n \n /* Operand is a function constant; result is a function variable value\n    of typeEPmode.  Used only for languages that need static chains.  */\n-DEFTREECODE (ENTRY_VALUE_EXPR, \"entry_value_expr\", \"e\", 1)\n+DEFTREECODE (ENTRY_VALUE_EXPR, \"entry_value_expr\", 'e', 1)\n \n /* Given two real or integer operands of the same type,\n    returns a complex value of the corresponding complex type.  */\n-DEFTREECODE (COMPLEX_EXPR, \"complex_expr\", \"2\", 2)\n+DEFTREECODE (COMPLEX_EXPR, \"complex_expr\", '2', 2)\n \n /* Complex conjugate of operand.  Used only on complex types.  */\n-DEFTREECODE (CONJ_EXPR, \"conj_expr\", \"1\", 1)\n+DEFTREECODE (CONJ_EXPR, \"conj_expr\", '1', 1)\n \n /* Used only on an operand of complex type, these return\n    a value of the corresponding component type.  */\n-DEFTREECODE (REALPART_EXPR, \"realpart_expr\", \"1\", 1)\n-DEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", \"1\", 1)\n+DEFTREECODE (REALPART_EXPR, \"realpart_expr\", '1', 1)\n+DEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", '1', 1)\n \n /* Nodes for ++ and -- in C.\n    The second arg is how much to increment or decrement by.\n    For a pointer, it would be the size of the object pointed to.  */\n-DEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", \"e\", 2)\n-DEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", \"e\", 2)\n-DEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", \"e\", 2)\n-DEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", \"e\", 2)\n+DEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", 'e', 2)\n+DEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", 'e', 2)\n+DEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", 'e', 2)\n+DEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", 'e', 2)\n \n /* Evaluate operand 1.  If and only if an exception is thrown during\n    the evaluation of operand 1, evaluate operand 2.\n \n    This differs from WITH_CLEANUP_EXPR, in that operand 2 is never\n    evaluated unless an exception is throw.  */\n-DEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", \"e\", 2)\n+DEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", 'e', 2)\n \n /* Pop the top element off the dynamic handler chain.  Used in\n    conjunction with setjmp/longjmp based exception handling, see\n    except.c for more details.  This is meant to be used only by the\n    exception handling backend, expand_dhc_cleanup specifically.  */\n-DEFTREECODE (POPDHC_EXPR, \"popdhc_expr\", \"s\", 0)\n+DEFTREECODE (POPDHC_EXPR, \"popdhc_expr\", 's', 0)\n \n /* Pop the top element off the dynamic cleanup chain.  Used in\n    conjunction with the exception handling.  This is meant to be used\n    only by the exception handling backend.  */\n-DEFTREECODE (POPDCC_EXPR, \"popdcc_expr\", \"s\", 0)\n+DEFTREECODE (POPDCC_EXPR, \"popdcc_expr\", 's', 0)\n \f\n /* These types of expressions have no useful value,\n    and always have side effects.  */\n \n /* A label definition, encapsulated as a statement.\n    Operand 0 is the LABEL_DECL node for the label that appears here.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (LABEL_EXPR, \"label_expr\", \"s\", 1)\n+DEFTREECODE (LABEL_EXPR, \"label_expr\", 's', 1)\n \n /* GOTO.  Operand 0 is a LABEL_DECL node.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (GOTO_EXPR, \"goto_expr\", \"s\", 1)\n+DEFTREECODE (GOTO_EXPR, \"goto_expr\", 's', 1)\n \n /* RETURN.  Evaluates operand 0, then returns from the current function.\n    Presumably that operand is an assignment that stores into the\n    RESULT_DECL that hold the value to be returned.\n    The operand may be null.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (RETURN_EXPR, \"return_expr\", \"s\", 1)\n+DEFTREECODE (RETURN_EXPR, \"return_expr\", 's', 1)\n \n /* Exit the inner most loop conditionally.  Operand 0 is the condition.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (EXIT_EXPR, \"exit_expr\", \"s\", 1)\n+DEFTREECODE (EXIT_EXPR, \"exit_expr\", 's', 1)\n \n /* A loop.  Operand 0 is the body of the loop.\n    It must contain an EXIT_EXPR or is an infinite loop.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (LOOP_EXPR, \"loop_expr\", \"s\", 1)\n+DEFTREECODE (LOOP_EXPR, \"loop_expr\", 's', 1)\n \n /*\n Local variables:"}, {"sha": "e951a427635e9951858062daf5e49ea121ce40ba", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a6969ad7cfe5a44854a2e19a8c38505862c2528/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0a6969ad7cfe5a44854a2e19a8c38505862c2528", "patch": "@@ -47,16 +47,17 @@ enum tree_code {\n    constant, `d' for a decl, `t' for a type, `s' for a statement,\n    and `x' for anything else (TREE_LIST, IDENTIFIER, etc).  */\n \n-extern char **tree_code_type;\n-#define TREE_CODE_CLASS(CODE)\t(*tree_code_type[(int) (CODE)])\n+#define MAX_TREE_CODES 256\n+extern char tree_code_type[MAX_TREE_CODES];\n+#define TREE_CODE_CLASS(CODE)\ttree_code_type[(int) (CODE)]\n \n /* Number of argument-words in each kind of tree-node.  */\n \n-extern int *tree_code_length;\n+extern int tree_code_length[MAX_TREE_CODES];\n \n /* Names of tree components.  */\n \n-extern char **tree_code_name;\n+extern char *tree_code_name[MAX_TREE_CODES];\n \f\n /* Codes that identify the various built in functions\n    so that expand_call can identify them quickly.  */"}]}