{"sha": "d083ee47a9828236016841356fc7207e7c90bbbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4M2VlNDdhOTgyODIzNjAxNjg0MTM1NmZjNzIwN2U3YzkwYmJiZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T14:39:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T14:39:57Z"}, "message": "Replace mode_for_int_vector with related_int_vector_mode\n\nmode_for_int_vector, like mode_for_vector, can sometimes return\nan integer mode or an unsupported vector mode.  But no callers\nare interested in that case, and only want supported vector modes.\nThis patch therefore replaces mode_for_int_vector with\nrelated_int_vector_mode, which gives the target a chance to pick\nits preferred vector mode for the given element mode and size.\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* machmode.h (mode_for_int_vector): Delete.\n\t(related_int_vector_mode): Declare.\n\t* stor-layout.c (mode_for_int_vector): Delete.\n\t(related_int_vector_mode): New function.\n\t* optabs.c (expand_vec_perm_1): Use related_int_vector_mode\n\tinstead of mode_for_int_vector.\n\t(expand_vec_perm_const): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_emit_approx_sqrt): Likewise.\n\t(aarch64_evpc_sve_tbl): Likewise.\n\t* config/s390/s390.c (s390_expand_vec_compare_cc): Likewise.\n\t(s390_expand_vcond): Likewise.\n\nFrom-SVN: r278230", "tree": {"sha": "90747a64f3a7312d7fcdd25bc7c864ff408c02df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90747a64f3a7312d7fcdd25bc7c864ff408c02df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d083ee47a9828236016841356fc7207e7c90bbbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d083ee47a9828236016841356fc7207e7c90bbbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d083ee47a9828236016841356fc7207e7c90bbbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d083ee47a9828236016841356fc7207e7c90bbbd/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f09552335030433018fd5f7f6b9848339b5ca2da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f09552335030433018fd5f7f6b9848339b5ca2da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f09552335030433018fd5f7f6b9848339b5ca2da"}], "stats": {"total": 79, "additions": 42, "deletions": 37}, "files": [{"sha": "3131af715c905abea49ca1179c249ba8da137a56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d083ee47a9828236016841356fc7207e7c90bbbd", "patch": "@@ -1,3 +1,17 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* machmode.h (mode_for_int_vector): Delete.\n+\t(related_int_vector_mode): Declare.\n+\t* stor-layout.c (mode_for_int_vector): Delete.\n+\t(related_int_vector_mode): New function.\n+\t* optabs.c (expand_vec_perm_1): Use related_int_vector_mode\n+\tinstead of mode_for_int_vector.\n+\t(expand_vec_perm_const): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_emit_approx_sqrt): Likewise.\n+\t(aarch64_evpc_sve_tbl): Likewise.\n+\t* config/s390/s390.c (s390_expand_vec_compare_cc): Likewise.\n+\t(s390_expand_vcond): Likewise.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (related_mode): New hook."}, {"sha": "b6c8d7701b2e856b0041cf71207ea19e3248441d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=d083ee47a9828236016841356fc7207e7c90bbbd", "patch": "@@ -1816,7 +1816,7 @@ aarch64_sve_element_int_mode (machine_mode mode)\n }\n \n /* Return the integer vector mode associated with SVE mode MODE.\n-   Unlike mode_for_int_vector, this can handle the case in which\n+   Unlike related_int_vector_mode, this can handle the case in which\n    MODE is a predicate (and thus has a different total size).  */\n \n machine_mode\n@@ -12537,7 +12537,7 @@ aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n     gcc_assert (use_rsqrt_p (mode));\n \n   machine_mode mmsk = (VECTOR_MODE_P (mode)\n-\t\t       ? mode_for_int_vector (mode).require ()\n+\t\t       ? related_int_vector_mode (mode).require ()\n \t\t       : int_mode_for_mode (mode).require ());\n   rtx xmsk = gen_reg_rtx (mmsk);\n   if (!recp)\n@@ -19068,7 +19068,7 @@ aarch64_evpc_sve_tbl (struct expand_vec_perm_d *d)\n   if (d->testing_p)\n     return true;\n \n-  machine_mode sel_mode = mode_for_int_vector (d->vmode).require ();\n+  machine_mode sel_mode = related_int_vector_mode (d->vmode).require ();\n   rtx sel = vec_perm_indices_to_rtx (sel_mode, d->perm);\n   if (d->one_vector_p)\n     emit_unspec2 (d->target, UNSPEC_TBL, d->op0, force_reg (sel_mode, sel));"}, {"sha": "8cb19ea4666f27d9ed6c216a66accd4c59fe6e55", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d083ee47a9828236016841356fc7207e7c90bbbd", "patch": "@@ -6653,7 +6653,7 @@ s390_expand_vec_compare_cc (rtx target, enum rtx_code code,\n \tcase LE:   cc_producer_mode = CCVFHEmode; code = GE; swap_p = true; break;\n \tdefault: gcc_unreachable ();\n \t}\n-      scratch_mode = mode_for_int_vector (GET_MODE (cmp1)).require ();\n+      scratch_mode = related_int_vector_mode (GET_MODE (cmp1)).require ();\n \n       if (inv_p)\n \tall_p = !all_p;\n@@ -6759,7 +6759,7 @@ s390_expand_vcond (rtx target, rtx then, rtx els,\n \n   /* We always use an integral type vector to hold the comparison\n      result.  */\n-  result_mode = mode_for_int_vector (cmp_mode).require ();\n+  result_mode = related_int_vector_mode (cmp_mode).require ();\n   result_target = gen_reg_rtx (result_mode);\n \n   /* We allow vector immediates as comparison operands that"}, {"sha": "6750833c2feedf20517ec695837462f4d9c06e5c", "filename": "gcc/machmode.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=d083ee47a9828236016841356fc7207e7c90bbbd", "patch": "@@ -879,22 +879,9 @@ smallest_int_mode_for_size (poly_uint64 size)\n extern opt_scalar_int_mode int_mode_for_mode (machine_mode);\n extern opt_machine_mode bitwise_mode_for_mode (machine_mode);\n extern opt_machine_mode mode_for_vector (scalar_mode, poly_uint64);\n-extern opt_machine_mode mode_for_int_vector (unsigned int, poly_uint64);\n extern opt_machine_mode related_vector_mode (machine_mode, scalar_mode,\n \t\t\t\t\t     poly_uint64 = 0);\n-\n-/* Return the integer vector equivalent of MODE, if one exists.  In other\n-   words, return the mode for an integer vector that has the same number\n-   of bits as MODE and the same number of elements as MODE, with the\n-   latter being 1 if MODE is scalar.  The returned mode can be either\n-   an integer mode or a vector mode.  */\n-\n-inline opt_machine_mode\n-mode_for_int_vector (machine_mode mode)\n-{\n-  return mode_for_int_vector (GET_MODE_UNIT_BITSIZE (mode),\n-\t\t\t      GET_MODE_NUNITS (mode));\n-}\n+extern opt_machine_mode related_int_vector_mode (machine_mode);\n \n /* A class for iterating through possible bitfield modes.  */\n class bit_field_mode_iterator"}, {"sha": "3c3dd9ef25a7a98d40aa625e7cde910a1152ca03", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d083ee47a9828236016841356fc7207e7c90bbbd", "patch": "@@ -5542,7 +5542,7 @@ expand_vec_perm_1 (enum insn_code icode, rtx target,\n   class expand_operand ops[4];\n \n   gcc_assert (GET_MODE_CLASS (smode) == MODE_VECTOR_INT\n-\t      || mode_for_int_vector (tmode).require () == smode);\n+\t      || related_int_vector_mode (tmode).require () == smode);\n   create_output_operand (&ops[0], target, tmode);\n   create_input_operand (&ops[3], sel, smode);\n \n@@ -5679,8 +5679,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n   /* The optabs are only defined for selectors with the same width\n      as the values being permuted.  */\n   machine_mode required_sel_mode;\n-  if (!mode_for_int_vector (mode).exists (&required_sel_mode)\n-      || !VECTOR_MODE_P (required_sel_mode))\n+  if (!related_int_vector_mode (mode).exists (&required_sel_mode))\n     {\n       delete_insns_since (last);\n       return NULL_RTX;"}, {"sha": "7d003644bad41cabdae7a57659dde251543eb12b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d083ee47a9828236016841356fc7207e7c90bbbd/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d083ee47a9828236016841356fc7207e7c90bbbd", "patch": "@@ -515,21 +515,6 @@ mode_for_vector (scalar_mode innermode, poly_uint64 nunits)\n   return opt_machine_mode ();\n }\n \n-/* Return the mode for a vector that has NUNITS integer elements of\n-   INT_BITS bits each, if such a mode exists.  The mode can be either\n-   an integer mode or a vector mode.  */\n-\n-opt_machine_mode\n-mode_for_int_vector (unsigned int int_bits, poly_uint64 nunits)\n-{\n-  scalar_int_mode int_mode;\n-  machine_mode vec_mode;\n-  if (int_mode_for_size (int_bits, 0).exists (&int_mode)\n-      && mode_for_vector (int_mode, nunits).exists (&vec_mode))\n-    return vec_mode;\n-  return opt_machine_mode ();\n-}\n-\n /* If a piece of code is using vector mode VECTOR_MODE and also wants\n    to operate on elements of mode ELEMENT_MODE, return the vector mode\n    it should use for those elements.  If NUNITS is nonzero, ensure that\n@@ -550,6 +535,26 @@ related_vector_mode (machine_mode vector_mode, scalar_mode element_mode,\n   return targetm.vectorize.related_mode (vector_mode, element_mode, nunits);\n }\n \n+/* If a piece of code is using vector mode VECTOR_MODE and also wants\n+   to operate on integer vectors with the same element size and number\n+   of elements, return the vector mode it should use.  Return an empty\n+   opt_machine_mode if there is no supported vector mode with the\n+   required properties.\n+\n+   Unlike mode_for_vector. any returned mode is guaranteed to satisfy\n+   both VECTOR_MODE_P and targetm.vector_mode_supported_p.  */\n+\n+opt_machine_mode\n+related_int_vector_mode (machine_mode vector_mode)\n+{\n+  gcc_assert (VECTOR_MODE_P (vector_mode));\n+  scalar_int_mode int_mode;\n+  if (int_mode_for_mode (GET_MODE_INNER (vector_mode)).exists (&int_mode))\n+    return related_vector_mode (vector_mode, int_mode,\n+\t\t\t\tGET_MODE_NUNITS (vector_mode));\n+  return opt_machine_mode ();\n+}\n+\n /* Return the alignment of MODE. This will be bounded by 1 and\n    BIGGEST_ALIGNMENT.  */\n "}]}