{"sha": "f797c2b745ec8a1b5750900caf54c96dcbc904ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc5N2MyYjc0NWVjOGExYjU3NTA5MDBjYWY1NGM5NmRjYmM5MDRjYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-25T20:18:44Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-25T20:18:44Z"}, "message": "gigi.h (build_atomic_load): Adjust prototype.\n\n\t* gcc-interface/gigi.h (build_atomic_load): Adjust prototype.\n\t(build_atomic_store): Likewise.\n\t(build_load_modify_store): Declare.\n\t(VECTOR_TYPE_P): Delete.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Replace Is_Atomic with\n\tIs_Atomic_Or_VFA throughout.\n\t<E_Array_Type>: Build a variant of the XUA type instead of forcing\n\tTYPE_VOLATILE on it.\n\t<E_Array_Subtype>: Use the main variant of the base type.\n\tDo not force TYPE_VOLATILE on the type being built.\n\t<E_Record_Type>: Likewise.\n\t<E_Array_Subtype>: Likewise.\n\t<E_Subprogram_Type>: Rename local variable.\n\tAdd Atomic qualifier in conjunction with Volatile on types if needed.\n\tForce BLKmode for by-ref types only at the end of the processing.\n\tChange qualifiers only after changing the mode of the type.  Set\n\tTYPE_UNIVERSAL_ALIASING_P on the type directly.\n\t(check_ok_for_atomic_type): Issue specific error message for VFA.\n\t(gnat_to_gnu_component_type): Replace Is_Atomic with\n\tIs_Atomic_Or_VFA throughout.\n\t* gcc-interface/misc.c (gnat_get_alias_set): Test\n\tTYPE_UNIVERSAL_ALIASING_P on the type directly.\n\t* gcc-interface/trans.c (lvalue_required_p): Replace Is_Atomic with\n\tIs_Atomic_Or_VFA throughout.  Add missing guard.\n\t(node_is_atomic): New predicate.\n\t(node_has_volatile_full_access): Likewise.\n\t(gnat_strip_type_conversion): New function.\n\t(outer_atomic_access_required_p): New predicate.\n\t(atomic_sync_required_p): Rename into...\n\t(atomic_access_required_p): ...this.  Add SYNC parameter, scan the\n\tparent node first and then look for the atomic setting.  Add support\n\tfor Volatile_Full_Access.\n\t(Call_to_gnu): Add atomic_access and outer_atomic_access parameters\n\tand adjusts calls to above functions.  Use load-modify-store sequence\n\tfor updates of In/Out and Out parameters if required, as well as for\n\tmoving the result to the target if required.  Add couple of missing\n\tguards.\n\t(gnat_to_gnu): Adjust calls to above functions.\n\t<N_Object_Renaming_Declaration>: If the renamed object has side-effects\n\tevaluate only its address.\n\t<N_Assignment_Statement>: Adjust call to Call_to_gnu.  Use load-modify\n\tstore sequence if required.\n\t<N_Function_Call>: Adjust call to Call_to_gnu.\n\t(extract_values): Adjust comment.\n\t* gcc-interface/utils2.c (build_atomic_load): Add SYNC parameter and\n\tuse relaxed memory model if it is not set.\n\t(build_atomic_store): Likewise.\n\t(call_is_atomic_load): New predicate.\n\t(build_load_modify_store): New function.\n\t(build_binary_op) <MODIFY_EXPR>: Accept SAVE_EXPR on the LHS.\n\t(gnat_stabilize_reference) <CALL_EXPR>: Deal with atomic loads.\n\nFrom-SVN: r223652", "tree": {"sha": "79e475b241a12de74ed6db829e811d0c9aff7480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79e475b241a12de74ed6db829e811d0c9aff7480"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f797c2b745ec8a1b5750900caf54c96dcbc904ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f797c2b745ec8a1b5750900caf54c96dcbc904ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f797c2b745ec8a1b5750900caf54c96dcbc904ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f797c2b745ec8a1b5750900caf54c96dcbc904ca/comments", "author": null, "committer": null, "parents": [{"sha": "2e24efd3f49524b05dfb198cd60205a7113b10a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e24efd3f49524b05dfb198cd60205a7113b10a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e24efd3f49524b05dfb198cd60205a7113b10a2"}], "stats": {"total": 879, "additions": 737, "deletions": 142}, "files": [{"sha": "eb0a3baa9f5f0536eb3e6da685acefb1a73a7e53", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -1,3 +1,57 @@\n+2015-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (build_atomic_load): Adjust prototype.\n+\t(build_atomic_store): Likewise.\n+\t(build_load_modify_store): Declare.\n+\t(VECTOR_TYPE_P): Delete.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Replace Is_Atomic with\n+\tIs_Atomic_Or_VFA throughout.\n+\t<E_Array_Type>: Build a variant of the XUA type instead of forcing\n+\tTYPE_VOLATILE on it.\n+\t<E_Array_Subtype>: Use the main variant of the base type.\n+\tDo not force TYPE_VOLATILE on the type being built.\n+\t<E_Record_Type>: Likewise.\n+\t<E_Array_Subtype>: Likewise.\n+\t<E_Subprogram_Type>: Rename local variable.\n+\tAdd Atomic qualifier in conjunction with Volatile on types if needed.\n+\tForce BLKmode for by-ref types only at the end of the processing.\n+\tChange qualifiers only after changing the mode of the type.  Set\n+\tTYPE_UNIVERSAL_ALIASING_P on the type directly.\n+\t(check_ok_for_atomic_type): Issue specific error message for VFA.\n+\t(gnat_to_gnu_component_type): Replace Is_Atomic with\n+\tIs_Atomic_Or_VFA throughout.\n+\t* gcc-interface/misc.c (gnat_get_alias_set): Test\n+\tTYPE_UNIVERSAL_ALIASING_P on the type directly.\n+\t* gcc-interface/trans.c (lvalue_required_p): Replace Is_Atomic with\n+\tIs_Atomic_Or_VFA throughout.  Add missing guard.\n+\t(node_is_atomic): New predicate.\n+\t(node_has_volatile_full_access): Likewise.\n+\t(gnat_strip_type_conversion): New function.\n+\t(outer_atomic_access_required_p): New predicate.\n+\t(atomic_sync_required_p): Rename into...\n+\t(atomic_access_required_p): ...this.  Add SYNC parameter, scan the\n+\tparent node first and then look for the atomic setting.  Add support\n+\tfor Volatile_Full_Access.\n+\t(Call_to_gnu): Add atomic_access and outer_atomic_access parameters\n+\tand adjusts calls to above functions.  Use load-modify-store sequence\n+\tfor updates of In/Out and Out parameters if required, as well as for\n+\tmoving the result to the target if required.  Add couple of missing\n+\tguards.\n+\t(gnat_to_gnu): Adjust calls to above functions.\n+\t<N_Object_Renaming_Declaration>: If the renamed object has side-effects\n+\tevaluate only its address.\n+\t<N_Assignment_Statement>: Adjust call to Call_to_gnu.  Use load-modify\n+\tstore sequence if required.\n+\t<N_Function_Call>: Adjust call to Call_to_gnu.\n+\t(extract_values): Adjust comment.\n+\t* gcc-interface/utils2.c (build_atomic_load): Add SYNC parameter and\n+\tuse relaxed memory model if it is not set.\n+\t(build_atomic_store): Likewise.\n+\t(call_is_atomic_load): New predicate.\n+\t(build_load_modify_store): New function.\n+\t(build_binary_op) <MODIFY_EXPR>: Accept SAVE_EXPR on the LHS.\n+\t(gnat_stabilize_reference) <CALL_EXPR>: Deal with atomic loads.\n+\n 2015-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (DECL_RENAMING_GLOBAL_P): Rename into..."}, {"sha": "27f906d68910f24e659b73b8e1ed6b911c718dcd", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 55, "deletions": 53, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -816,7 +816,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   constant, set the alignment to the smallest one which is not\n \t   smaller than the size, with an appropriate cap.  */\n \tif (!gnu_size && align == 0\n-\t    && (Is_Atomic (gnat_entity)\n+\t    && (Is_Atomic_Or_VFA (gnat_entity)\n \t\t|| (!Optimize_Alignment_Space (gnat_entity)\n \t\t    && kind != E_Exception\n \t\t    && kind != E_Out_Parameter\n@@ -837,7 +837,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       to support BIGGEST_ALIGNMENT if we don't really have to.\n \t       So we cap to the smallest alignment that corresponds to\n \t       a known efficient memory access pattern of the target.  */\n-\t    if (Is_Atomic (gnat_entity))\n+\t    if (Is_Atomic_Or_VFA (gnat_entity))\n \t      {\n \t\tsize_cap = UINT_MAX;\n \t\talign_cap = BIGGEST_ALIGNMENT;\n@@ -890,7 +890,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   the padded record to assign to the object.  We could fix this by\n \t   always copying via an intermediate value, but it's not clear it's\n \t   worth the effort.  */\n-\tif (Is_Atomic (gnat_entity))\n+\tif (Is_Atomic_Or_VFA (gnat_entity))\n \t  check_ok_for_atomic_type (gnu_type, gnat_entity, false);\n \n \t/* If this is an aliased object with an unconstrained nominal subtype,\n@@ -1135,7 +1135,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     || imported_p\n \t\t     || Present (Address_Clause (gnat_entity)))))\n \t    && !TYPE_VOLATILE (gnu_type))\n-\t  gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n+\t  {\n+\t    const int quals\n+\t      = TYPE_QUAL_VOLATILE\n+\t\t| (Is_Atomic_Or_VFA (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n+\t    gnu_type = change_qualified_type (gnu_type, quals);\n+\t  }\n \n \t/* If we are defining an aliased object whose nominal subtype is\n \t   unconstrained, the object is a record that contains both the\n@@ -2223,16 +2228,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    TYPE_MULTI_ARRAY_P (tem) = (index > 0);\n \t    if (array_type_has_nonaliased_component (tem, gnat_entity))\n \t      TYPE_NONALIASED_COMPONENT (tem) = 1;\n-\n-\t    /* If it is passed by reference, force BLKmode to ensure that\n-\t       objects of this type will always be put in memory.  */\n-\t    if (TYPE_MODE (tem) != BLKmode\n-\t\t&& Is_By_Reference_Type (gnat_entity))\n-\t      SET_TYPE_MODE (tem, BLKmode);\n \t  }\n \n-\tTYPE_VOLATILE (tem) = Treat_As_Volatile (gnat_entity);\n-\n \t/* If an alignment is specified, use it if valid.  But ignore it\n \t   for the original type of packed array types.  If the alignment\n \t   was requested with an explicit alignment clause, state so.  */\n@@ -2248,6 +2245,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \tTYPE_CONVENTION_FORTRAN_P (tem) = convention_fortran_p;\n \n+\tif (Treat_As_Volatile (gnat_entity))\n+\t  tem = change_qualified_type (tem, TYPE_QUAL_VOLATILE);\n+\n \t/* Adjust the type of the pointer-to-array field of the fat pointer\n \t   and record the aliasing relationships if necessary.  */\n \tTREE_TYPE (TYPE_FIELDS (gnu_fat_type)) = build_pointer_type (tem);\n@@ -2317,7 +2317,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t First check to see if this is simply a renaming of the array type.\n \t If so, the result is the array type.  */\n \n-      gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n+      gnu_type = TYPE_MAIN_VARIANT (gnat_to_gnu_type (Etype (gnat_entity)));\n       if (!Is_Constrained (gnat_entity))\n \t;\n       else\n@@ -2592,15 +2592,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n \t      if (array_type_has_nonaliased_component (gnu_type, gnat_entity))\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n-\n-\t      /* See the E_Array_Type case for the rationale.  */\n-\t      if (TYPE_MODE (gnu_type) != BLKmode\n-\t\t  && Is_By_Reference_Type (gnat_entity))\n-\t\tSET_TYPE_MODE (gnu_type, BLKmode);\n \t    }\n \n-\t  TYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n-\n \t  /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n \t  TYPE_STUB_DECL (gnu_type)\n \t    = create_type_stub_decl (gnu_entity_name, gnu_type);\n@@ -2727,8 +2720,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t debugging information for it.  */\n \t      process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \t      if (Treat_As_Volatile (gnat_entity))\n-\t\tgnu_type\n-\t\t  = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n+\t\t{\n+\t\t  const int quals\n+\t\t    = TYPE_QUAL_VOLATILE\n+\t\t      | (Is_Atomic_Or_VFA (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n+\t\t  gnu_type = change_qualified_type (gnu_type, quals);\n+\t\t}\n \t      /* Make it artificial only if the base type was artificial too.\n \t\t That's sort of \"morally\" true and will make it possible for\n \t\t the debugger to look it up by name in DWARF, which is needed\n@@ -2978,7 +2975,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (Known_Alignment (gnat_entity))\n \t  TYPE_ALIGN (gnu_type)\n \t    = validate_alignment (Alignment (gnat_entity), gnat_entity, 0);\n-\telse if (Is_Atomic (gnat_entity) && Known_Esize (gnat_entity))\n+\telse if (Is_Atomic_Or_VFA (gnat_entity) && Known_Esize (gnat_entity))\n \t  {\n \t    unsigned int size = UI_To_Int (Esize (gnat_entity));\n \t    TYPE_ALIGN (gnu_type)\n@@ -3236,14 +3233,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      false, OK_To_Reorder_Components (gnat_entity),\n \t\t\t      all_rep ? NULL_TREE : bitsize_zero_node, NULL);\n \n-\t/* If it is passed by reference, force BLKmode to ensure that objects\n-\t   of this type will always be put in memory.  */\n-\tif (TYPE_MODE (gnu_type) != BLKmode\n-\t    && Is_By_Reference_Type (gnat_entity))\n-\t  SET_TYPE_MODE (gnu_type, BLKmode);\n-\n-\tTYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n-\n \t/* Fill in locations of fields.  */\n \tannotate_rep (gnat_entity, gnu_type);\n \n@@ -3320,7 +3309,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      this_deferred = true;\n \t    }\n \n-\t  gnu_base_type = gnat_to_gnu_type (gnat_base_type);\n+\t  gnu_base_type\n+\t    = TYPE_MAIN_VARIANT (gnat_to_gnu_type (gnat_base_type));\n \n \t  if (present_gnu_tree (gnat_entity))\n \t    {\n@@ -3637,13 +3627,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t  false);\n \t      compute_record_mode (gnu_type);\n \n-\t      /* See the E_Record_Type case for the rationale.  */\n-\t      if (TYPE_MODE (gnu_type) != BLKmode\n-\t\t  && Is_By_Reference_Type (gnat_entity))\n-\t\tSET_TYPE_MODE (gnu_type, BLKmode);\n-\n-\t      TYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n-\n \t      /* Fill in locations of fields.  */\n \t      annotate_rep (gnat_entity, gnu_type);\n \n@@ -4188,7 +4171,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool const_flag\n \t  = (Exception_Mechanism == Back_End_Exceptions\n \t     && Is_Pure (gnat_entity));\n-\tbool volatile_flag = No_Return (gnat_entity);\n+\tbool noreturn_flag = No_Return (gnat_entity);\n \tbool return_by_direct_ref_p = false;\n \tbool return_by_invisi_ref_p = false;\n \tbool return_unconstrained_p = false;\n@@ -4605,12 +4588,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (TREE_CODE (gnu_return_type) == VOID_TYPE || return_unconstrained_p)\n \t  const_flag = false;\n \n-\tif (const_flag || volatile_flag)\n+\tif (const_flag || noreturn_flag)\n \t  {\n \t    const int quals\n \t      = (const_flag ? TYPE_QUAL_CONST : 0)\n-\t\t| (volatile_flag ? TYPE_QUAL_VOLATILE : 0);\n-\n+\t\t| (noreturn_flag ? TYPE_QUAL_VOLATILE : 0);\n \t    gnu_type = change_qualified_type (gnu_type, quals);\n \t  }\n \n@@ -4900,12 +4882,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t       gnat_entity);\n \t    }\n \t}\n-      else if (Is_Atomic (gnat_entity) && !gnu_size\n+      else if (Is_Atomic_Or_VFA (gnat_entity) && !gnu_size\n \t       && tree_fits_uhwi_p (TYPE_SIZE (gnu_type))\n \t       && integer_pow2p (TYPE_SIZE (gnu_type)))\n \talign = MIN (BIGGEST_ALIGNMENT,\n \t\t     tree_to_uhwi (TYPE_SIZE (gnu_type)));\n-      else if (Is_Atomic (gnat_entity) && gnu_size\n+      else if (Is_Atomic_Or_VFA (gnat_entity) && gnu_size\n \t       && tree_fits_uhwi_p (gnu_size)\n \t       && integer_pow2p (gnu_size))\n \talign = MIN (BIGGEST_ALIGNMENT, tree_to_uhwi (gnu_size));\n@@ -5052,20 +5034,32 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t}\n \t    }\n \n-      if (Is_Atomic (gnat_entity))\n+      if (Is_Atomic_Or_VFA (gnat_entity))\n \tcheck_ok_for_atomic_type (gnu_type, gnat_entity, false);\n \n       /* If this is not an unconstrained array type, set some flags.  */\n       if (TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE)\n \t{\n-\t  if (Treat_As_Volatile (gnat_entity))\n-\t    gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n-\n \t  if (Present (Alignment_Clause (gnat_entity)))\n \t    TYPE_USER_ALIGN (gnu_type) = 1;\n \n \t  if (Universal_Aliasing (gnat_entity))\n-\t    TYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (gnu_type)) = 1;\n+\t    TYPE_UNIVERSAL_ALIASING_P (gnu_type) = 1;\n+\n+\t  /* If it is passed by reference, force BLKmode to ensure that\n+\t     objects of this type will always be put in memory.  */\n+\t  if (TYPE_MODE (gnu_type) != BLKmode\n+\t      && AGGREGATE_TYPE_P (gnu_type)\n+\t      && TYPE_BY_REFERENCE_P (gnu_type))\n+\t    SET_TYPE_MODE (gnu_type, BLKmode);\n+\n+\t  if (Treat_As_Volatile (gnat_entity))\n+\t    {\n+\t      const int quals\n+\t\t= TYPE_QUAL_VOLATILE\n+\t\t  | (Is_Atomic_Or_VFA (gnat_entity) ? TYPE_QUAL_ATOMIC : 0);\n+\t      gnu_type = change_qualified_type (gnu_type, quals);\n+\t    }\n \t}\n \n       if (!gnu_decl)\n@@ -5628,7 +5622,12 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n     }\n \n   if (Has_Volatile_Components (gnat_array))\n-    gnu_type = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n+    {\n+      const int quals\n+\t= TYPE_QUAL_VOLATILE\n+\t  | (Has_Atomic_Components (gnat_array) ? TYPE_QUAL_ATOMIC : 0);\n+      gnu_type = change_qualified_type (gnu_type, quals);\n+    }\n \n   return gnu_type;\n }\n@@ -6450,7 +6449,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   const bool is_aliased\n     = Is_Aliased (gnat_field);\n   const bool is_atomic\n-    = (Is_Atomic (gnat_field) || Is_Atomic (gnat_field_type));\n+    = (Is_Atomic_Or_VFA (gnat_field) || Is_Atomic_Or_VFA (gnat_field_type));\n   const bool is_independent\n     = (Is_Independent (gnat_field) || Is_Independent (gnat_field_type));\n   const bool is_volatile\n@@ -6526,7 +6525,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t}\n     }\n \n-  if (Is_Atomic (gnat_field))\n+  if (Is_Atomic_Or_VFA (gnat_field))\n     check_ok_for_atomic_type (gnu_field_type, gnat_field, false);\n \n   if (Present (Component_Clause (gnat_field)))\n@@ -8202,6 +8201,9 @@ check_ok_for_atomic_type (tree type, Entity_Id gnat_entity, bool component_p)\n   if (component_p)\n     post_error_ne (\"atomic access to component of & cannot be guaranteed\",\n \t\t   gnat_error_point, gnat_entity);\n+  else if (Is_Volatile_Full_Access (gnat_entity))\n+    post_error_ne (\"volatile full access to & cannot be guaranteed\",\n+\t\t   gnat_error_point, gnat_entity);\n   else\n     post_error_ne (\"atomic access to & cannot be guaranteed\",\n \t\t   gnat_error_point, gnat_entity);"}, {"sha": "35833ba885bf7f2858eea8aee26c167c062c117c", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -858,11 +858,18 @@ extern unsigned int known_alignment (tree exp);\n    of 2.  */\n extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n \n-/* Build an atomic load for the underlying atomic object in SRC.  */\n-extern tree build_atomic_load (tree src);\n+/* Build an atomic load for the underlying atomic object in SRC.  SYNC is\n+   true if the load requires synchronization.  */\n+extern tree build_atomic_load (tree src, bool sync);\n \n-/* Build an atomic store from SRC to the underlying atomic object in DEST.  */\n-extern tree build_atomic_store (tree dest, tree src);\n+/* Build an atomic store from SRC to the underlying atomic object in DEST.\n+   SYNC is true if the store requires synchronization.  */\n+extern tree build_atomic_store (tree dest, tree src, bool sync);\n+\n+/* Build a load-modify-store sequence from SRC to DEST.  GNAT_NODE is used for\n+   the location of the sequence.  Note that, even if the load and the store are\n+   both atomic, the sequence itself is not atomic.  */\n+extern tree build_load_modify_store (tree dest, tree src, Node_Id gnat_node);\n \n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n@@ -1053,9 +1060,6 @@ extern void enumerate_modes (void (*f) (const char *, int, int, int, int, int,\n }\n #endif\n \n-/* Convenient shortcuts.  */\n-#define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)\n-\n /* If EXP's type is a VECTOR_TYPE, return EXP converted to the associated\n    TYPE_REPRESENTATIVE_ARRAY.  */\n \n@@ -1070,6 +1074,8 @@ maybe_vector_array (tree exp)\n   return exp;\n }\n \n+/* Return the smallest power of 2 larger than X.  */\n+\n static inline unsigned HOST_WIDE_INT\n ceil_pow2 (unsigned HOST_WIDE_INT x)\n {"}, {"sha": "24fcdde68e853487dc81c123614ffd541b97ac76", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -606,8 +606,7 @@ gnat_get_alias_set (tree type)\n       get_alias_set (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type)))));\n \n   /* If the type can alias any other types, return the alias set 0.  */\n-  else if (TYPE_P (type)\n-\t   && TYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (type)))\n+  else if (TYPE_P (type) && TYPE_UNIVERSAL_ALIASING_P (type))\n     return 0;\n \n   return -1;"}, {"sha": "3c957a68a1de686760ecc5e1a664ce04e3abd50a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 216, "deletions": 70, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -896,7 +896,7 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \t the actual assignment might end up being done component-wise.  */\n       return (!constant\n \t      ||(Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n-\t\t && Is_Atomic (Defining_Entity (gnat_parent)))\n+\t\t && Is_Atomic_Or_VFA (Defining_Entity (gnat_parent)))\n \t      /* We don't use a constructor if this is a class-wide object\n \t\t because the effective type of the object is the equivalent\n \t\t type of the class-wide subtype and it smashes most of the\n@@ -910,7 +910,8 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n       return (!constant\n \t      || Name (gnat_parent) == gnat_node\n \t      || (Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n-\t\t  && Is_Atomic (Entity (Name (gnat_parent)))));\n+\t\t  && Is_Entity_Name (Name (gnat_parent))\n+\t\t  && Is_Atomic_Or_VFA (Entity (Name (gnat_parent)))));\n \n     case N_Unchecked_Type_Conversion:\n \tif (!constant)\n@@ -3886,57 +3887,171 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     rest_of_subprog_body_compilation (gnu_subprog_decl);\n }\n \f\n-/* Return true if GNAT_NODE requires atomic synchronization.  */\n+/* Return true if GNAT_NODE references an Atomic entity.  */\n \n static bool\n-atomic_sync_required_p (Node_Id gnat_node)\n+node_is_atomic (Node_Id gnat_node)\n {\n-  const Node_Id gnat_parent = Parent (gnat_node);\n-  Node_Kind kind;\n-  unsigned char attr_id;\n+  Entity_Id gnat_entity;\n \n-  /* First, scan the node to find the Atomic_Sync_Required flag.  */\n-  kind = Nkind (gnat_node);\n-  if (kind == N_Type_Conversion || kind == N_Unchecked_Type_Conversion)\n+  switch (Nkind (gnat_node))\n     {\n-      gnat_node = Expression (gnat_node);\n-      kind = Nkind (gnat_node);\n+    case N_Identifier:\n+    case N_Expanded_Name:\n+      gnat_entity = Entity (gnat_node);\n+      if (Ekind (gnat_entity) != E_Variable)\n+\tbreak;\n+      return Is_Atomic (gnat_entity) || Is_Atomic (Etype (gnat_entity));\n+\n+    case N_Selected_Component:\n+      gnat_entity = Entity (Selector_Name (gnat_node));\n+      return Is_Atomic (gnat_entity) || Is_Atomic (Etype (gnat_entity));\n+\n+    case N_Indexed_Component:\n+      if (Has_Atomic_Components (Etype (Prefix (gnat_node))))\n+\treturn true;\n+\n+      /* ... fall through ... */\n+\n+    case N_Explicit_Dereference:\n+      return Is_Atomic (Etype (gnat_node));\n+\n+    default:\n+      break;\n     }\n \n-  switch (kind)\n+  return false;\n+}\n+\n+/* Return true if GNAT_NODE references a Volatile_Full_Access entity.  */\n+\n+static bool\n+node_has_volatile_full_access (Node_Id gnat_node)\n+{\n+  Entity_Id gnat_entity;\n+\n+  switch (Nkind (gnat_node))\n     {\n-    case N_Expanded_Name:\n-    case N_Explicit_Dereference:\n     case N_Identifier:\n-    case N_Indexed_Component:\n+    case N_Expanded_Name:\n+      gnat_entity = Entity (gnat_node);\n+      if (Ekind (gnat_entity) != E_Variable)\n+\tbreak;\n+      return Is_Volatile_Full_Access (gnat_entity)\n+\t     || Is_Volatile_Full_Access (Etype (gnat_entity));\n+\n     case N_Selected_Component:\n-      if (!Atomic_Sync_Required (gnat_node))\n-\treturn false;\n-      break;\n+      gnat_entity = Entity (Selector_Name (gnat_node));\n+      return Is_Volatile_Full_Access (gnat_entity)\n+\t     || Is_Volatile_Full_Access (Etype (gnat_entity));\n+\n+    case N_Indexed_Component:\n+    case N_Explicit_Dereference:\n+      return Is_Volatile_Full_Access (Etype (gnat_node));\n \n     default:\n-      return false;\n+      break;\n     }\n \n-  /* Then, scan the parent to find out cases where the flag is irrelevant.  */\n-  kind = Nkind (gnat_parent);\n-  switch (kind)\n+  return false;\n+}\n+\n+/* Strip any type conversion on GNAT_NODE and return the result.  */\n+\n+static Node_Id\n+gnat_strip_type_conversion (Node_Id gnat_node)\n+{\n+  Node_Kind kind = Nkind (gnat_node);\n+\n+  if (kind == N_Type_Conversion || kind == N_Unchecked_Type_Conversion)\n+    gnat_node = Expression (gnat_node);\n+\n+  return gnat_node;\n+}\n+\n+/* Return true if GNAT_NODE requires outer atomic access, i.e. atomic access\n+   of an object of which GNAT_NODE is a component.  */\n+\n+static bool\n+outer_atomic_access_required_p (Node_Id gnat_node)\n+{\n+  gnat_node = gnat_strip_type_conversion (gnat_node);\n+\n+  while (Nkind (gnat_node) == N_Indexed_Component\n+\t || Nkind (gnat_node) == N_Selected_Component\n+\t || Nkind (gnat_node) == N_Slice)\n+    {\n+      gnat_node = gnat_strip_type_conversion (Prefix (gnat_node));\n+      if (node_has_volatile_full_access (gnat_node))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if GNAT_NODE requires atomic access and set SYNC according to\n+   the associated synchronization setting.  */\n+\n+static bool\n+atomic_access_required_p (Node_Id gnat_node, bool *sync)\n+{\n+  const Node_Id gnat_parent = Parent (gnat_node);\n+  unsigned char attr_id;\n+  bool as_a_whole = true;\n+\n+  /* First, scan the parent to find out cases where the flag is irrelevant.  */\n+  switch (Nkind (gnat_parent))\n     {\n     case N_Attribute_Reference:\n       attr_id = Get_Attribute_Id (Attribute_Name (gnat_parent));\n       /* Do not mess up machine code insertions.  */\n       if (attr_id == Attr_Asm_Input || attr_id == Attr_Asm_Output)\n \treturn false;\n+\n+      /* Nothing to do if we are the prefix of an attribute, since we do not\n+\t want an atomic access for things like 'Size.  */\n+\n+      /* ... fall through ... */\n+\n+    case N_Reference:\n+      /* The N_Reference node is like an attribute.  */\n+      if (Prefix (gnat_parent) == gnat_node)\n+\treturn false;\n+      break;\n+\n+    case N_Indexed_Component:\n+    case N_Selected_Component:\n+    case N_Slice:\n+      /* If we are the prefix, then the access is only partial.  */\n+      if (Prefix (gnat_parent) == gnat_node)\n+\tas_a_whole = false;\n       break;\n \n     case N_Object_Renaming_Declaration:\n-      /* Do not generate a function call as a renamed object.  */\n+      /* Nothing to do for the identifier in an object renaming declaration,\n+         the renaming itself does not need atomic access.  */\n       return false;\n \n     default:\n       break;\n     }\n \n+  /* Then, scan the node to find the atomic object.  */\n+  gnat_node = gnat_strip_type_conversion (gnat_node);\n+\n+  /* For Atomic itself, only reads and updates of the object as a whole require\n+     atomic access (RM C.6 (15)).  But for Volatile_Full_Access, all reads and\n+     updates require atomic access.  */\n+  if (!(as_a_whole && node_is_atomic (gnat_node))\n+      && !node_has_volatile_full_access (gnat_node))\n+    return false;\n+\n+  /* If an outer atomic access will also be required, it cancels this one.  */\n+  if (outer_atomic_access_required_p (gnat_node))\n+    return false;\n+\n+  *sync = Atomic_Sync_Required (gnat_node);\n+\n   return true;\n }\n \f\n@@ -3975,12 +4090,14 @@ create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n    If GNU_TARGET is non-null, this must be a function call on the RHS of a\n    N_Assignment_Statement and the result is to be placed into that object.\n-   If, in addition, ATOMIC_SYNC is true, then the assignment to GNU_TARGET\n-   requires atomic synchronization.  */\n+   If OUTER_ATOMIC_ACCESS is true, then the assignment to GNU_TARGET must be a\n+   load-modify-store sequence.  Otherwise, if ATOMIC_ACCESS is true, then the\n+   assignment to GNU_TARGET must be atomic.  If, in addition, ATOMIC_SYNC is\n+   true, then the assignment to GNU_TARGET requires atomic synchronization.  */\n \n static tree\n Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n-\t     bool atomic_sync)\n+\t     bool outer_atomic_access, bool atomic_access, bool atomic_sync)\n {\n   const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n   const bool returning_value = (function_call && !gnu_target);\n@@ -4004,6 +4121,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   bool pushed_binding_level = false;\n   Entity_Id gnat_formal;\n   Node_Id gnat_actual;\n+  bool sync;\n \n   gcc_assert (TREE_CODE (gnu_subprog_type) == FUNCTION_TYPE);\n \n@@ -4248,13 +4366,13 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       /* Start from the real object and build the actual.  */\n       gnu_actual = gnu_name;\n \n-      /* If this is an atomic access of an In or In Out parameter for which\n-\t synchronization is required, build the atomic load.  */\n+      /* If atomic access is required for an In or In Out actual parameter,\n+\t build the atomic load.  */\n       if (is_true_formal_parm\n \t  && !is_by_ref_formal_parm\n \t  && Ekind (gnat_formal) != E_Out_Parameter\n-\t  && atomic_sync_required_p (gnat_actual))\n-\tgnu_actual = build_atomic_load (gnu_actual);\n+\t  && atomic_access_required_p (gnat_actual, &sync))\n+\tgnu_actual = build_atomic_load (gnu_actual, sync);\n \n       /* If this was a procedure call, we may not have removed any padding.\n \t So do it here for the part we will use as an input, if any.  */\n@@ -4537,12 +4655,24 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t  gnu_result = convert (TREE_TYPE (gnu_actual), gnu_result);\n \t      }\n \n-\t    if (atomic_sync_required_p (gnat_actual))\n-\t      gnu_result = build_atomic_store (gnu_actual, gnu_result);\n+\t    /* If an outer atomic access is required for an actual parameter,\n+\t       build the load-modify-store sequence.  */\n+\t    if (outer_atomic_access_required_p (gnat_actual))\n+\t      gnu_result\n+\t\t= build_load_modify_store (gnu_actual, gnu_result, gnat_node);\n+\n+\t    /* Or else, if simple atomic access is required, build the atomic\n+\t       store.  */\n+\t    else if (atomic_access_required_p (gnat_actual, &sync))\n+\t      gnu_result = build_atomic_store (gnu_actual, gnu_result, sync);\n+\n+\t    /* Otherwise build a regular assignment.  */\n \t    else\n \t      gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t\t\t    gnu_actual, gnu_result);\n-\t    set_expr_location_from_node (gnu_result, gnat_node);\n+\n+\t    if (EXPR_P (gnu_result))\n+\t      set_expr_location_from_node (gnu_result, gnat_node);\n \t    append_to_statement_list (gnu_result, &gnu_stmt_list);\n \t    gnu_cico_list = TREE_CHAIN (gnu_cico_list);\n \t    gnu_name_list = TREE_CHAIN (gnu_name_list);\n@@ -4593,12 +4723,18 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  else\n \t    op_code = MODIFY_EXPR;\n \n-\t  if (atomic_sync)\n-\t    gnu_call = build_atomic_store (gnu_target, gnu_call);\n+\t  /* Use the required method to move the result to the target.  */\n+\t  if (outer_atomic_access)\n+\t    gnu_call\n+\t      = build_load_modify_store (gnu_target, gnu_call, gnat_node);\n+\t  else if (atomic_access)\n+\t    gnu_call = build_atomic_store (gnu_target, gnu_call, atomic_sync);\n \t  else\n \t    gnu_call\n \t      = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_call);\n-\t  set_expr_location_from_node (gnu_call, gnat_parent);\n+\n+\t  if (EXPR_P (gnu_call))\n+\t    set_expr_location_from_node (gnu_call, gnat_parent);\n \t  append_to_statement_list (gnu_call, &gnu_stmt_list);\n \t}\n       else\n@@ -5394,6 +5530,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   tree gnu_result_type = void_type_node;\n   tree gnu_expr, gnu_lhs, gnu_rhs;\n   Node_Id gnat_temp;\n+  bool sync;\n \n   /* Save node number for error message and set location information.  */\n   error_gnat_node = gnat_node;\n@@ -5456,11 +5593,10 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Defining_Identifier:\n       gnu_result = Identifier_to_gnu (gnat_node, &gnu_result_type);\n \n-      /* If this is an atomic access on the RHS for which synchronization is\n-\t required, build the atomic load.  */\n-      if (atomic_sync_required_p (gnat_node)\n+      /* If atomic access is required on the RHS, build the atomic load.  */\n+      if (atomic_access_required_p (gnat_node, &sync)\n \t  && !present_in_lhs_or_actual_p (gnat_node))\n-\tgnu_result = build_atomic_load (gnu_result);\n+\tgnu_result = build_atomic_load (gnu_result, sync);\n       break;\n \n     case N_Integer_Literal:\n@@ -5694,9 +5830,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       /* Don't do anything if this renaming is handled by the front end or if\n \t we are just annotating types and this object has a composite or task\n-\t type, don't elaborate it.  We return the result in case it contains\n-\t any SAVE_EXPRs that need to be evaluated here, but this cannot occur\n-\t at the global level (see Renaming, case 2 in gnat_to_gnu_entity).  */\n+\t type, don't elaborate it.  */\n       if (!Is_Renaming_Of_Object (gnat_temp)\n \t  && ! (type_annotate_only\n \t\t&& (Is_Array_Type (Etype (gnat_temp))\n@@ -5706,8 +5840,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  tree gnu_temp\n \t    = gnat_to_gnu_entity (gnat_temp,\n \t\t\t\t  gnat_to_gnu (Renamed_Object (gnat_temp)), 1);\n-\t  if (!global_bindings_p ())\n-\t    gnu_result = gnu_temp;\n+\t  /* We need to make sure that the side-effects of the renamed object\n+\t     are evaluated at this point, so we evaluate its address.  */\n+\t  if (TREE_SIDE_EFFECTS (gnu_temp))\n+\t    gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_temp);\n \t}\n       break;\n \n@@ -5721,8 +5857,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  tree gnu_temp\n \t    = gnat_to_gnu_entity (gnat_temp,\n \t\t\t\t  gnat_to_gnu (Renamed_Entity (gnat_temp)), 1);\n-\t  if (!global_bindings_p ())\n-\t    gnu_result = gnu_temp;\n+\t  if (TREE_SIDE_EFFECTS (gnu_temp))\n+\t    gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_temp);\n \t}\n       break;\n \n@@ -5749,11 +5885,10 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \n-      /* If this is an atomic access on the RHS for which synchronization is\n-\t required, build the atomic load.  */\n-      if (atomic_sync_required_p (gnat_node)\n+      /* If atomic access is required on the RHS, build the atomic load.  */\n+      if (atomic_access_required_p (gnat_node, &sync)\n \t  && !present_in_lhs_or_actual_p (gnat_node))\n-\tgnu_result = build_atomic_load (gnu_result);\n+\tgnu_result = build_atomic_load (gnu_result, sync);\n       break;\n \n     case N_Indexed_Component:\n@@ -5842,11 +5977,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\t/* If this is an atomic access on the RHS for which synchronization is\n-\t   required, build the atomic load.  */\n-\tif (atomic_sync_required_p (gnat_node)\n+\t/* If atomic access is required on the RHS, build the atomic load.  */\n+\tif (atomic_access_required_p (gnat_node, &sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n-\t  gnu_result = build_atomic_load (gnu_result);\n+\t  gnu_result = build_atomic_load (gnu_result, sync);\n       }\n       break;\n \n@@ -5985,11 +6119,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\t/* If this is an atomic access on the RHS for which synchronization is\n-\t   required, build the atomic load.  */\n-\tif (atomic_sync_required_p (gnat_node)\n+\t/* If atomic access is required on the RHS, build the atomic load.  */\n+\tif (atomic_access_required_p (gnat_node, &sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n-\t  gnu_result = build_atomic_load (gnu_result);\n+\t  gnu_result = build_atomic_load (gnu_result, sync);\n       }\n       break;\n \n@@ -6492,9 +6625,16 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_result = build_call_raise (SE_Object_Too_Large, gnat_node,\n \t\t\t\t       N_Raise_Storage_Error);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call)\n-\tgnu_result\n-\t  = Call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n-\t\t\t atomic_sync_required_p (Name (gnat_node)));\n+\t{\n+\t  bool outer_atomic_access\n+\t    = outer_atomic_access_required_p (Name (gnat_node));\n+\t  bool atomic_access\n+\t    = !outer_atomic_access\n+\t      && atomic_access_required_p (Name (gnat_node), &sync);\n+\t  gnu_result\n+\t    = Call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n+\t\t\t   outer_atomic_access, atomic_access, sync);\n+\t}\n       else\n \t{\n \t  const Node_Id gnat_expr = Expression (gnat_node);\n@@ -6526,9 +6666,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)),\n \t\t\t\t\tgnat_node);\n \n-\t  /* If atomic synchronization is required, build an atomic store.  */\n-\t  if (atomic_sync_required_p (Name (gnat_node)))\n-\t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs);\n+\t  /* If an outer atomic access is required on the LHS, build the load-\n+\t     modify-store sequence.  */\n+\t  if (outer_atomic_access_required_p (Name (gnat_node)))\n+\t    gnu_result = build_load_modify_store (gnu_lhs, gnu_rhs, gnat_node);\n+\n+\t  /* Or else, if atomic access is required, build the atomic store.  */\n+\t  else if (atomic_access_required_p (Name (gnat_node), &sync))\n+\t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs, sync);\n \n \t  /* Or else, use memset when the conditions are met.  */\n \t  else if (use_memset_p)\n@@ -6829,7 +6974,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n-      gnu_result = Call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE, false);\n+      gnu_result = Call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE,\n+\t\t\t\tfalse, false, false);\n       break;\n \n     /************************/\n@@ -9174,9 +9320,9 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n }\n \f\n /* Subroutine of assoc_to_constructor: VALUES is a list of field associations,\n-   some of which are from RECORD_TYPE.  Return a CONSTRUCTOR consisting\n-   of the associations that are from RECORD_TYPE.  If we see an internal\n-   record, make a recursive call to fill it in as well.  */\n+   some of which are from RECORD_TYPE.  Return a CONSTRUCTOR consisting of the\n+   associations that are from RECORD_TYPE.  If we see an internal record, make\n+   a recursive call to fill it in as well.  */\n \n static tree\n extract_values (tree values, tree record_type)"}, {"sha": "aa92382e99e4e4ba6dd70d8b2761801698de79e3", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 107, "deletions": 10, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -658,15 +658,19 @@ resolve_atomic_size (tree type)\n   return 0;\n }\n \n-/* Build an atomic load for the underlying atomic object in SRC.  */\n+/* Build an atomic load for the underlying atomic object in SRC.  SYNC is\n+   true if the load requires synchronization.  */\n \n tree\n-build_atomic_load (tree src)\n+build_atomic_load (tree src, bool sync)\n {\n   tree ptr_type\n     = build_pointer_type\n-      (build_qualified_type (void_type_node, TYPE_QUAL_VOLATILE));\n-  tree mem_model = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n+      (build_qualified_type (void_type_node,\n+\t\t\t     TYPE_QUAL_ATOMIC | TYPE_QUAL_VOLATILE));\n+  tree mem_model\n+    = build_int_cst (integer_type_node,\n+\t\t     sync ? MEMMODEL_SEQ_CST : MEMMODEL_RELAXED);\n   tree orig_src = src;\n   tree t, addr, val;\n   unsigned int size;\n@@ -690,15 +694,19 @@ build_atomic_load (tree src)\n   return convert (TREE_TYPE (orig_src), t);\n }\n \n-/* Build an atomic store from SRC to the underlying atomic object in DEST.  */\n+/* Build an atomic store from SRC to the underlying atomic object in DEST.\n+   SYNC is true if the store requires synchronization.  */\n \n tree\n-build_atomic_store (tree dest, tree src)\n+build_atomic_store (tree dest, tree src, bool sync)\n {\n   tree ptr_type\n     = build_pointer_type\n-      (build_qualified_type (void_type_node, TYPE_QUAL_VOLATILE));\n-  tree mem_model = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n+      (build_qualified_type (void_type_node,\n+\t\t\t     TYPE_QUAL_ATOMIC | TYPE_QUAL_VOLATILE));\n+  tree mem_model\n+    = build_int_cst (integer_type_node,\n+\t\t     sync ? MEMMODEL_SEQ_CST : MEMMODEL_RELAXED);\n   tree orig_dest = dest;\n   tree t, int_type, addr;\n   unsigned int size;\n@@ -729,6 +737,87 @@ build_atomic_store (tree dest, tree src)\n \n   return build_call_expr (t, 3, addr, src, mem_model);\n }\n+\n+/* Return true if EXP, a CALL_EXPR, is an atomic load.  */\n+\n+static bool\n+call_is_atomic_load (tree exp)\n+{\n+  tree fndecl = get_callee_fndecl (exp);\n+\n+  if (!(fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL))\n+    return false;\n+\n+  enum built_in_function code = DECL_FUNCTION_CODE (fndecl);\n+  return BUILT_IN_ATOMIC_LOAD_N <= code && code <= BUILT_IN_ATOMIC_LOAD_16;\n+}\n+\n+/* Build a load-modify-store sequence from SRC to DEST.  GNAT_NODE is used for\n+   the location of the sequence.  Note that, even if the load and the store are\n+   both atomic, the sequence itself is not atomic.  */\n+\n+tree\n+build_load_modify_store (tree dest, tree src, Node_Id gnat_node)\n+{\n+  tree ref = dest;\n+\n+  while (handled_component_p (ref))\n+    {\n+      /* The load should already have been generated during the translation\n+\t of the GNAT destination tree; find it out in the GNU tree.  */\n+      if (TREE_CODE (TREE_OPERAND (ref, 0)) == VIEW_CONVERT_EXPR)\n+\t{\n+\t  tree op = TREE_OPERAND (TREE_OPERAND (ref, 0), 0);\n+\t  if (TREE_CODE (op) == CALL_EXPR && call_is_atomic_load (op))\n+\t    {\n+\t      tree type = TREE_TYPE (TREE_OPERAND (ref, 0));\n+\t      tree t = CALL_EXPR_ARG (op, 0);\n+\t      tree obj, temp, stmt;\n+\n+\t      /* Find out the loaded object.  */\n+\t      if (TREE_CODE (t) == NOP_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (t) == ADDR_EXPR)\n+\t\tobj = TREE_OPERAND (t, 0);\n+\t      else\n+\t\tobj = build1 (INDIRECT_REF, type, t);\n+\n+\t      /* Drop atomic and volatile qualifiers for the temporary.  */\n+\t      type = TYPE_MAIN_VARIANT (type);\n+\n+\t      /* And drop BLKmode, if need be, to put it into a register.  */\n+\t      if (TYPE_MODE (type) == BLKmode)\n+\t\t{\n+\t\t  unsigned int size = tree_to_uhwi (TYPE_SIZE (type));\n+\t\t  type = copy_type (type);\n+\t\t  SET_TYPE_MODE (type, mode_for_size (size, MODE_INT, 0));\n+\t\t}\n+\n+\t      /* Create the temporary by inserting a SAVE_EXPR.  */\n+\t      temp = build1 (SAVE_EXPR, type,\n+\t\t\t     build1 (VIEW_CONVERT_EXPR, type, op));\n+\t      TREE_OPERAND (ref, 0) = temp;\n+\n+\t      start_stmt_group ();\n+\n+\t      /* Build the modify of the temporary.  */\n+\t      stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, dest, src);\n+\t      add_stmt_with_node (stmt, gnat_node);\n+\n+\t      /* Build the store to the object.  */\n+\t      stmt = build_atomic_store (obj, temp, false);\n+\t      add_stmt_with_node (stmt, gnat_node);\n+\n+\t      return end_stmt_group ();\n+\t    }\n+\t}\n+\n+      ref = TREE_OPERAND (ref, 0);\n+    }\n+\n+  /* Something went wrong earlier if we have not found the atomic load.  */\n+  gcc_unreachable ();\n+}\n \f\n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n@@ -870,7 +959,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t strip anything that get_inner_reference can handle.  Then remove any\n \t conversions between types having the same code and mode.  And mark\n \t VIEW_CONVERT_EXPRs with TREE_ADDRESSABLE.  When done, we must have\n-\t either an INDIRECT_REF, a NULL_EXPR or a DECL node.  */\n+\t either an INDIRECT_REF, a NULL_EXPR, a SAVE_EXPR or a DECL node.  */\n       result = left_operand;\n       while (true)\n \t{\n@@ -903,6 +992,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \n       gcc_assert (TREE_CODE (result) == INDIRECT_REF\n \t\t  || TREE_CODE (result) == NULL_EXPR\n+\t\t  || TREE_CODE (result) == SAVE_EXPR\n \t\t  || DECL_P (result));\n \n       /* Convert the right operand to the operation type unless it is\n@@ -2716,7 +2806,14 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n       break;\n \n     case CALL_EXPR:\n-      result = gnat_stabilize_reference_1 (ref, force);\n+      if (call_is_atomic_load (ref))\n+\tresult\n+\t  = build_call_expr (TREE_OPERAND (CALL_EXPR_FN (ref), 0), 2,\n+\t\t\t     gnat_stabilize_reference (CALL_EXPR_ARG (ref, 0),\n+\t\t\t\t\t\t       force, success),\n+\t\t\t     CALL_EXPR_ARG (ref, 1));\n+      else\n+\tresult = gnat_stabilize_reference_1 (ref, force);\n       break;\n \n     case COMPOUND_EXPR:"}, {"sha": "3be8bfcce72f0054b60b998a9d480d711391cb0d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -1,3 +1,11 @@\n+2015-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/vfa1_1.adb: New test.\n+\t* gnat.dg/vfa1_2.adb: Likewise.\n+\t* gnat.dg/vfa1_3.adb: Likewise.\n+\t* gnat.dg/vfa1_4.adb: Likewise.\n+\t* gnat.dg/vfa1_pkg.ads: New helper.\n+\n 2015-05-25  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* gcc.target/i386/pr66232-1.c: Adjust scan pattern."}, {"sha": "ac27a3c9bf041e942882e4509bf61e7e014b291e", "filename": "gcc/testsuite/gnat.dg/vfa1_1.adb", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_1.adb?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -0,0 +1,60 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with VFA1_Pkg; use VFA1_Pkg;\n+\n+procedure VFA1_1 is\n+  Temp : Integer;\n+\n+  function F (I : Integer) return Integer is\n+  begin\n+    return I;\n+  end;\n+\n+  function F2 return Integer is\n+  begin\n+    return Integer(Counter1);\n+  end;\n+\n+  procedure P3 (I : Out Integer) is\n+  begin\n+    null;\n+  end;\n+\n+begin\n+\n+  Counter1 := Int(Counter2);\n+  Counter2 := Integer(Counter1);\n+\n+  Temp := Integer(Counter1);\n+  Counter1 := Int(Temp);\n+\n+  Temp := Counter2;\n+  Counter2 := Temp;\n+\n+  Temp := Integer (Counter1) + Counter2;\n+\n+  if Counter1 /= Int (Counter2) then\n+    raise Program_Error;\n+  end if;\n+\n+  Temp := F(Integer (Counter1));\n+  Counter1 := Int(F(Temp));\n+\n+  Temp := F(Counter2);\n+  Counter2 := F(Temp);\n+\n+  Temp := F2;\n+  P3 (Counter2);\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__counter1\" 6 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__counter2\" 5 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__counter1\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__counter2\" 4 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "7c432a256f4f5c2d220710d0f652208ec2b83b78", "filename": "gcc/testsuite/gnat.dg/vfa1_2.adb", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_2.adb?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -0,0 +1,57 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with VFA1_Pkg; use VFA1_Pkg;\n+\n+procedure VFA1_2 is\n+  Temp : Int8_t;\n+\n+  function F (I : Int8_t) return Int8_t is\n+  begin\n+    return I;\n+  end;\n+\n+  function F2 return Int8_t is\n+  begin\n+    return Int8_t(Timer1(1));\n+  end;\n+\n+  procedure P3 (I : out Int8_t) is\n+  begin\n+    null;\n+  end;\n+\n+begin\n+\n+  Temp := Timer1(1);\n+  Timer1(2) := Temp;\n+\n+  Temp := Timer2(1);\n+  Timer2(2) := Temp;\n+\n+  Temp := Timer1(1) + Timer2(2);\n+\n+  if Timer1(1) /= Timer2(2) then\n+    raise Program_Error;\n+  end if;\n+\n+  Temp := F(Timer1(1));\n+  Timer2(2) := F(Temp);\n+\n+  Temp := F(Timer2(2));\n+  Timer1(1) := F(Temp);\n+\n+  Temp := F2;\n+  P3 (Timer2(2));\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__timer1\" 7 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__timer2\" 7 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__timer1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__timer2\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "cdf38f9908bf6f64515d3d72e2f44f2d06254e76", "filename": "gcc/testsuite/gnat.dg/vfa1_3.adb", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_3.adb?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -0,0 +1,58 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with VFA1_Pkg; use VFA1_Pkg;\n+\n+procedure VFA1_3 is\n+\n+  Temp : Short_Integer;\n+\n+  function F (I : Short_Integer) return Short_Integer is\n+  begin\n+    return I;\n+  end;\n+\n+  function F2 return Short_Integer is\n+  begin\n+    return Short_Integer(Buffer1.A);\n+  end;\n+\n+  procedure P3 (I : out Short_Integer) is\n+  begin\n+    null;\n+  end;\n+\n+begin\n+\n+  Temp := Buffer1.A;\n+  Buffer1.B := Temp;\n+\n+  Temp := Buffer2.A;\n+  Buffer2.B := Temp;\n+\n+  Temp := Buffer1.A + Buffer2.B;\n+\n+  if Buffer1.A /= Buffer2.B then\n+    raise Program_Error;\n+  end if;\n+\n+  Temp := F(Buffer1.A);\n+  Buffer2.B := F(Temp);\n+\n+  Temp := F(Buffer2.B);\n+  Buffer1.A := F(Temp);\n+\n+  Temp := F2;\n+  P3 (Buffer2.B);\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__buffer1\" 7 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__buffer2\" 7 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__buffer1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__buffer2\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "f7f33e4270fb0781eff9f41393f409ffa751759b", "filename": "gcc/testsuite/gnat.dg/vfa1_4.adb", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_4.adb?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -0,0 +1,58 @@\n+-- { dg-do compile }\n+-- { dg-options \"-fdump-tree-gimple\" }\n+\n+with VFA1_Pkg; use VFA1_Pkg;\n+\n+procedure VFA1_4 is\n+\n+  Temp : Int8_t;\n+\n+  function F (I : Int8_t) return Int8_t is\n+  begin\n+    return I;\n+  end;\n+\n+  function F2 return Int8_t is\n+  begin\n+    return Int8_t(Mixer1(1).R);\n+  end;\n+\n+  procedure P3 (I : out Int8_t) is\n+  begin\n+    null;\n+  end;\n+\n+begin\n+\n+  Temp := Mixer1(1).R;\n+  Mixer1(2).R := Temp;\n+\n+  Temp := Mixer2(1).R;\n+  Mixer2(2).R := Temp;\n+\n+  Temp := Mixer1(1).R + Mixer2(2).R;\n+\n+  if Mixer1(1).R /= Mixer2(2).R then\n+    raise Program_Error;\n+  end if;\n+\n+  Temp := F(Mixer1(1).R);\n+  Mixer2(2).R := F(Temp);\n+\n+  Temp := F(Mixer2(2).R);\n+  Mixer1(1).R := F(Temp);\n+\n+  Temp := F2;\n+  P3 (Mixer2(2).R);\n+\n+end;\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__mixer1\" 7 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&vfa1_pkg__mixer2\" 7 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_load\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__mixer1\" 2 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&vfa1_pkg__mixer2\" 3 \"gimple\"} }\n+-- { dg-final { scan-tree-dump-times \"atomic_store\\[^\\n\\r\\]*&temp\" 0 \"gimple\"} }\n+\n+-- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "444ee17a1f286394ad4fc3256db56b92559a1352", "filename": "gcc/testsuite/gnat.dg/vfa1_pkg.ads", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f797c2b745ec8a1b5750900caf54c96dcbc904ca/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvfa1_pkg.ads?ref=f797c2b745ec8a1b5750900caf54c96dcbc904ca", "patch": "@@ -0,0 +1,50 @@\n+package VFA1_Pkg is\n+\n+  type Int8_t is mod 2**8;\n+\n+  type Int is new Integer;\n+  pragma Volatile_Full_Access (Int);\n+\n+  Counter1 : Int;\n+\n+  Counter2 : Integer;\n+  pragma Volatile_Full_Access (Counter2);\n+\n+  type Arr is array (1 .. 4) of Int8_t;\n+  for Arr'Alignment use 4;\n+  pragma Volatile_Full_Access (Arr);\n+\n+  Timer1 : Arr;\n+\n+  Timer2 : array (1 .. 4) of Int8_t;\n+  for Timer2'Alignment use 4;\n+  pragma Volatile_Full_Access (Timer2);\n+\n+  type Rec is record\n+    A : Short_Integer;\n+    B : Short_Integer;\n+  end record;\n+\n+  type Rec_VFA is new Rec;\n+  pragma Volatile_Full_Access (Rec_VFA);\n+\n+  Buffer1 : Rec_VFA;\n+\n+  Buffer2 : Rec;\n+  pragma Volatile_Full_Access (Buffer2);\n+\n+  type Code is record\n+    R : Int8_t;\n+    I : Int8_t;\n+  end record;\n+  pragma Volatile_Full_Access (Code);\n+\n+  type CArr is array (1 .. 2) of Code;\n+  pragma Volatile_Full_Access (CArr);\n+\n+  Mixer1 : Carr;\n+\n+  Mixer2 :  array (1 .. 2) of Code;\n+  pragma Volatile_Full_Access (Mixer2);\n+\n+end VFA1_Pkg;"}]}