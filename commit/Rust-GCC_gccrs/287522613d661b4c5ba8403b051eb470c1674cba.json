{"sha": "287522613d661b4c5ba8403b051eb470c1674cba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg3NTIyNjEzZDY2MWI0YzViYTg0MDNiMDUxZWI0NzBjMTY3NGNiYQ==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2020-08-10T10:50:42Z"}, "committer": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2020-08-10T10:53:01Z"}, "message": "Simplify X * C1 == C2 with wrapping overflow\n\nOdd numbers are invertible in Z / 2^n Z, so X * C1 == C2 can be rewritten\nas X == C2 * inv(C1) when overflow wraps.\n\nmod_inv should probably be updated to better match the other wide_int\nfunctions, but that's a separate issue.\n\n2020-08-10  Marc Glisse  <marc.glisse@inria.fr>\n\n\tPR tree-optimization/95433\n\t* match.pd (X * C1 == C2): Handle wrapping overflow.\n\t* expr.c (maybe_optimize_mod_cmp): Qualify call to mod_inv.\n\t(mod_inv): Move...\n\t* wide-int.cc (mod_inv): ... here.\n\t* wide-int.h (mod_inv): Declare it.\n\n\t* gcc.dg/tree-ssa/pr95433-2.c: New file.", "tree": {"sha": "f9c3ea8dfe1d1a8e89a20f898746d93f96a9de4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9c3ea8dfe1d1a8e89a20f898746d93f96a9de4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/287522613d661b4c5ba8403b051eb470c1674cba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287522613d661b4c5ba8403b051eb470c1674cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/287522613d661b4c5ba8403b051eb470c1674cba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287522613d661b4c5ba8403b051eb470c1674cba/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9939be5758b52ed2fe1a7e56b94ce6d0f4d81580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9939be5758b52ed2fe1a7e56b94ce6d0f4d81580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9939be5758b52ed2fe1a7e56b94ce6d0f4d81580"}], "stats": {"total": 103, "additions": 68, "deletions": 35}, "files": [{"sha": "ebf0c9e4797d5a4b6c46bef5c4419497df13c3d4", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=287522613d661b4c5ba8403b051eb470c1674cba", "patch": "@@ -11859,38 +11859,6 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n   return init;\n }\n \f\n-/* Compute the modular multiplicative inverse of A modulo M\n-   using extended Euclid's algorithm.  Assumes A and M are coprime.  */\n-static wide_int\n-mod_inv (const wide_int &a, const wide_int &b)\n-{\n-  /* Verify the assumption.  */\n-  gcc_checking_assert (wi::eq_p (wi::gcd (a, b), 1));\n-\n-  unsigned int p = a.get_precision () + 1;\n-  gcc_checking_assert (b.get_precision () + 1 == p);\n-  wide_int c = wide_int::from (a, p, UNSIGNED);\n-  wide_int d = wide_int::from (b, p, UNSIGNED);\n-  wide_int x0 = wide_int::from (0, p, UNSIGNED);\n-  wide_int x1 = wide_int::from (1, p, UNSIGNED);\n-\n-  if (wi::eq_p (b, 1))\n-    return wide_int::from (1, p, UNSIGNED);\n-\n-  while (wi::gt_p (c, 1, UNSIGNED))\n-    {\n-      wide_int t = d;\n-      wide_int q = wi::divmod_trunc (c, d, UNSIGNED, &d);\n-      c = t;\n-      wide_int s = x0;\n-      x0 = wi::sub (x1, wi::mul (q, x0));\n-      x1 = s;\n-    }\n-  if (wi::lt_p (x1, 0, SIGNED))\n-    x1 += d;\n-  return x1;\n-}\n-\n /* Optimize x % C1 == C2 for signed modulo if C1 is a power of two and C2\n    is non-zero and C3 ((1<<(prec-1)) | (C1 - 1)):\n    for C2 > 0 to x & C3 == C2\n@@ -12101,7 +12069,7 @@ maybe_optimize_mod_cmp (enum tree_code code, tree *arg0, tree *arg1)\n   w = wi::lrshift (w, shift);\n   wide_int a = wide_int::from (w, prec + 1, UNSIGNED);\n   wide_int b = wi::shifted_mask (prec, 1, false, prec + 1);\n-  wide_int m = wide_int::from (mod_inv (a, b), prec, UNSIGNED);\n+  wide_int m = wide_int::from (wi::mod_inv (a, b), prec, UNSIGNED);\n   tree c3 = wide_int_to_tree (type, m);\n   tree c5 = NULL_TREE;\n   wide_int d, e;"}, {"sha": "c3b88168ac45e8b00465e3a195d78dce38ae3830", "filename": "gcc/match.pd", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=287522613d661b4c5ba8403b051eb470c1674cba", "patch": "@@ -3828,7 +3828,9 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n      (cmp @0 @2))))))\n \n /* For integral types with undefined overflow fold\n-   x * C1 == C2 into x == C2 / C1 or false.  */\n+   x * C1 == C2 into x == C2 / C1 or false.\n+   If overflow wraps and C1 is odd, simplify to x == C2 / C1 in the ring\n+   Z / 2^n Z.  */\n (for cmp (eq ne)\n  (simplify\n   (cmp (mult @0 INTEGER_CST@1) INTEGER_CST@2)\n@@ -3839,7 +3841,20 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     (if (wi::multiple_of_p (wi::to_widest (@2), wi::to_widest (@1),\n \t\t\t    TYPE_SIGN (TREE_TYPE (@0)), &quot))\n      (cmp @0 { wide_int_to_tree (TREE_TYPE (@0), quot); })\n-     { constant_boolean_node (cmp == NE_EXPR, type); })))))\n+     { constant_boolean_node (cmp == NE_EXPR, type); }))\n+   (if (INTEGRAL_TYPE_P (TREE_TYPE (@0))\n+\t&& TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0))\n+\t&& (wi::bit_and (wi::to_wide (@1), 1) == 1))\n+    (cmp @0\n+     {\n+       tree itype = TREE_TYPE (@0);\n+       int p = TYPE_PRECISION (itype);\n+       wide_int m = wi::one (p + 1) << p;\n+       wide_int a = wide_int::from (wi::to_wide (@1), p + 1, UNSIGNED);\n+       wide_int i = wide_int::from (wi::mod_inv (a, m),\n+\t\t\t\t    p, TYPE_SIGN (itype));\n+       wide_int_to_tree (itype, wi::mul (i, wi::to_wide (@2)));\n+     })))))\n \n /* Simplify comparison of something with itself.  For IEEE\n    floating-point, we can only do some of these simplifications.  */"}, {"sha": "c830a3d195f0a89c326e77f2987f2a0ac248c759", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr95433-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr95433-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr95433-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr95433-2.c?ref=287522613d661b4c5ba8403b051eb470c1674cba", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fwrapv -fdump-tree-gimple\" } */\n+\n+typedef __INT32_TYPE__ int32_t;\n+typedef unsigned __INT32_TYPE__ uint32_t;\n+\n+int e(int32_t x){return 3*x==5;}\n+int f(int32_t x){return 3*x==-5;}\n+int g(int32_t x){return -3*x==5;}\n+int h(int32_t x){return 7*x==3;}\n+int i(uint32_t x){return 7*x==3;}\n+\n+/* { dg-final { scan-tree-dump-times \"== 1431655767\" 1 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"== -1431655767\" 2 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"== 613566757\" 2 \"gimple\" } } */"}, {"sha": "f4d949c38a0193792083ff4f1fdd64113441fc65", "filename": "gcc/wide-int.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fwide-int.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fwide-int.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.cc?ref=287522613d661b4c5ba8403b051eb470c1674cba", "patch": "@@ -2223,6 +2223,39 @@ wi::round_up_for_mask (const wide_int &val, const wide_int &mask)\n   return (val | tmp) & -tmp;\n }\n \n+/* Compute the modular multiplicative inverse of A modulo B\n+   using extended Euclid's algorithm.  Assumes A and B are coprime,\n+   and that A and B have the same precision.  */\n+wide_int\n+wi::mod_inv (const wide_int &a, const wide_int &b)\n+{\n+  /* Verify the assumption.  */\n+  gcc_checking_assert (wi::eq_p (wi::gcd (a, b), 1));\n+\n+  unsigned int p = a.get_precision () + 1;\n+  gcc_checking_assert (b.get_precision () + 1 == p);\n+  wide_int c = wide_int::from (a, p, UNSIGNED);\n+  wide_int d = wide_int::from (b, p, UNSIGNED);\n+  wide_int x0 = wide_int::from (0, p, UNSIGNED);\n+  wide_int x1 = wide_int::from (1, p, UNSIGNED);\n+\n+  if (wi::eq_p (b, 1))\n+    return wide_int::from (1, p, UNSIGNED);\n+\n+  while (wi::gt_p (c, 1, UNSIGNED))\n+    {\n+      wide_int t = d;\n+      wide_int q = wi::divmod_trunc (c, d, UNSIGNED, &d);\n+      c = t;\n+      wide_int s = x0;\n+      x0 = wi::sub (x1, wi::mul (q, x0));\n+      x1 = s;\n+    }\n+  if (wi::lt_p (x1, 0, SIGNED))\n+    x1 += d;\n+  return x1;\n+}\n+\n /*\n  * Private utilities.\n  */"}, {"sha": "39cd5b9bd178d519ff781513e55a7d7cbfdd07ca", "filename": "gcc/wide-int.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/287522613d661b4c5ba8403b051eb470c1674cba/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=287522613d661b4c5ba8403b051eb470c1674cba", "patch": "@@ -3389,6 +3389,8 @@ namespace wi\n   wide_int round_down_for_mask (const wide_int &, const wide_int &);\n   wide_int round_up_for_mask (const wide_int &, const wide_int &);\n \n+  wide_int mod_inv (const wide_int &a, const wide_int &b);\n+\n   template <typename T>\n   T mask (unsigned int, bool);\n "}]}