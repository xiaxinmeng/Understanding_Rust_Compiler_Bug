{"sha": "a517d6c19a572a4aa37569f54186883d70627686", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxN2Q2YzE5YTU3MmE0YWEzNzU2OWY1NDE4Njg4M2Q3MDYyNzY4Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-16T10:34:33Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-16T10:34:33Z"}, "message": "[Ada] AI12-0001: Independence and Representation clauses for atomic objects\n\n2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust calls to\n\tvalidate_size.\n\t(gnat_to_gnu_component_type): Likewise.\n\t(gnat_to_gnu_field): Likewise and pass string for error messages.\n\t(components_need_strict_alignment): Remove test on Is_Aliased and\n\tadd test for the independence of the component.\n\t(validate_size): Add S1 and S2 string parameters and use them to\n\tgive better error messages for fields.  Tweak a couple of messages.\n\t* einfo.ads (Has_Independent_Components): Document more cases.\n\t(Is_Independent): Likewise.\n\t(Strict_Alignment): Document new semantics.\n\t* exp_ch9.adb (Install_Private_Data_Declarations): Also set the\n\tIs_Independent flag along with Is_Aliased on the renaming\n\tentity.\n\t* freeze.adb (Size_Known): Remove always-false test and add test\n\tfor the strict-alignment on the record type.  Remove redundant\n\ttests and add test for the strict-alignment on the component\n\ttype.\n\t(Check_Strict_Alignment): Set the flag if the type is by-ref and\n\tremove now redundant conditions.  Set the flag on an array type\n\tif it has aliased components.  In the record type case, do not\n\tset type for C_Pass_By_Copy convention.\n\t(Freeze_Array_Type): Move code checking for conflicts between\n\trepresentation aspects and clauses to before specific handling\n\tof packed array types. Give a warnind instead of an error for a\n\tconflict with pragma Pack.  Do not test Has_Pragma_Pack for the\n\tspecific handling of packed array types.\n\t(Freeze_Record_Type): Move error checking of representation\n\tclause to...\n\t(Freeze_Entity): ...here after Check_Strict_Alignment is called.\n\t* sem_aggr.adb (Array_Aggr_Subtype): Also set the Is_Independent\n\tflag along with Is_Aliased on the Itype.\n\t* sem_ch13.adb (Check_Record_Representation_Clause): Do not set\n\tthe RM size for a strict-alignment type.\n\t* sem_ch3.adb (Add_Interface_Tag_Components): Also set the\n\tIs_Independent flag along with Is_Aliased on the tag.\n\t(Add_Interface_Tag_Components): Likewise on the offset.\n\t(Analyze_Component_Declaration): Likewise on the component.\n\t(Analyze_Object_Declaration): Likewise on the object.\n\t(Constrain_Array): Likewise on the array.\n\t(Record_Type_Declaration: Likewise on the tag.\n\t(Array_Type_Declaration): Also set the\n\tHas_Independent_Components flag along with\n\tHas_Aliased_Components on the array.\n\t(Copy_Array_Base_Type_Attributes): Copy\n\tHas_Independent_Components.\n\t(Copy_Array_Subtype_Attributes): Copy Is_Atomic, Is_Independent\n\tand Is_Volatile_Full_Access.\n\t(Analyze_Iterator_Specification): Set Is_Independent on the loop\n\tvariable according to Independent_Components on the array.\n\t* sem_ch5.adb: Likewise.\n\t* sem_ch6.adb (Process_Formals): Also set the Is_Independent\n\tflag along with Is_Aliased on the formal.\n\ngcc/testsuite/\n\n\t* gnat.dg/specs/clause_on_volatile.ads,\n\tgnat.dg/specs/size_clause3.ads: Update expected diagnostics.\n\nFrom-SVN: r279430", "tree": {"sha": "cb4c651cb474cafe0000663fa7df2e7379d4acad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb4c651cb474cafe0000663fa7df2e7379d4acad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a517d6c19a572a4aa37569f54186883d70627686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a517d6c19a572a4aa37569f54186883d70627686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a517d6c19a572a4aa37569f54186883d70627686", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a517d6c19a572a4aa37569f54186883d70627686/comments", "author": null, "committer": null, "parents": [{"sha": "2cee58d81076c99ab3db3305c1850bf79fa12f17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cee58d81076c99ab3db3305c1850bf79fa12f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cee58d81076c99ab3db3305c1850bf79fa12f17"}], "stats": {"total": 670, "additions": 398, "deletions": 272}, "files": [{"sha": "063043656a02045c57da14b4224e0c169062fa61", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -1,3 +1,59 @@\n+2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust calls to\n+\tvalidate_size.\n+\t(gnat_to_gnu_component_type): Likewise.\n+\t(gnat_to_gnu_field): Likewise and pass string for error messages.\n+\t(components_need_strict_alignment): Remove test on Is_Aliased and\n+\tadd test for the independence of the component.\n+\t(validate_size): Add S1 and S2 string parameters and use them to\n+\tgive better error messages for fields.  Tweak a couple of messages.\n+\t* einfo.ads (Has_Independent_Components): Document more cases.\n+\t(Is_Independent): Likewise.\n+\t(Strict_Alignment): Document new semantics.\n+\t* exp_ch9.adb (Install_Private_Data_Declarations): Also set the\n+\tIs_Independent flag along with Is_Aliased on the renaming\n+\tentity.\n+\t* freeze.adb (Size_Known): Remove always-false test and add test\n+\tfor the strict-alignment on the record type.  Remove redundant\n+\ttests and add test for the strict-alignment on the component\n+\ttype.\n+\t(Check_Strict_Alignment): Set the flag if the type is by-ref and\n+\tremove now redundant conditions.  Set the flag on an array type\n+\tif it has aliased components.  In the record type case, do not\n+\tset type for C_Pass_By_Copy convention.\n+\t(Freeze_Array_Type): Move code checking for conflicts between\n+\trepresentation aspects and clauses to before specific handling\n+\tof packed array types. Give a warnind instead of an error for a\n+\tconflict with pragma Pack.  Do not test Has_Pragma_Pack for the\n+\tspecific handling of packed array types.\n+\t(Freeze_Record_Type): Move error checking of representation\n+\tclause to...\n+\t(Freeze_Entity): ...here after Check_Strict_Alignment is called.\n+\t* sem_aggr.adb (Array_Aggr_Subtype): Also set the Is_Independent\n+\tflag along with Is_Aliased on the Itype.\n+\t* sem_ch13.adb (Check_Record_Representation_Clause): Do not set\n+\tthe RM size for a strict-alignment type.\n+\t* sem_ch3.adb (Add_Interface_Tag_Components): Also set the\n+\tIs_Independent flag along with Is_Aliased on the tag.\n+\t(Add_Interface_Tag_Components): Likewise on the offset.\n+\t(Analyze_Component_Declaration): Likewise on the component.\n+\t(Analyze_Object_Declaration): Likewise on the object.\n+\t(Constrain_Array): Likewise on the array.\n+\t(Record_Type_Declaration: Likewise on the tag.\n+\t(Array_Type_Declaration): Also set the\n+\tHas_Independent_Components flag along with\n+\tHas_Aliased_Components on the array.\n+\t(Copy_Array_Base_Type_Attributes): Copy\n+\tHas_Independent_Components.\n+\t(Copy_Array_Subtype_Attributes): Copy Is_Atomic, Is_Independent\n+\tand Is_Volatile_Full_Access.\n+\t(Analyze_Iterator_Specification): Set Is_Independent on the loop\n+\tvariable according to Independent_Components on the array.\n+\t* sem_ch5.adb: Likewise.\n+\t* sem_ch6.adb (Process_Formals): Also set the Is_Independent\n+\tflag along with Is_Aliased on the formal.\n+\n 2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_ch8.adb (Analyze_Object_Renaming): Set Atomic, Independent"}, {"sha": "d5a26d1d638b897bc640fb06a438021ef0785d0b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -1725,7 +1725,8 @@ package Einfo is\n --       has independent components is to see if either the object or its base\n --       type has this flag set. Note that in the case of a type, the pragma\n --       will be chained to the rep item chain of the first subtype in the\n---       usual manner.\n+--       usual manner. Also set if a pragma Has_Atomic_Components or pragma\n+--       Has_Aliased_Components applies to the type or object.\n \n --    Has_Inheritable_Invariants (Flag248) [base type only]\n --       Defined in all type entities. Set on private types and interface types\n@@ -2720,13 +2721,14 @@ package Einfo is\n --       Applies to all entities, true for incomplete types and subtypes\n \n --    Is_Independent (Flag268)\n---       Defined in all type entities, and also in constants, components and\n---       variables. Set if a valid pragma or aspect Independent applies to the\n---       entity, or if a valid pragma or aspect Independent_Components applies\n---       to the enclosing record type for a component. Also set if a pragma\n---       Shared or pragma Atomic applies to the entity. In the case of private\n---       and incomplete types, this flag is set in both the partial view and\n---       the full view.\n+--       Defined in all types and objects. Set if a valid pragma or aspect\n+--       Independent applies to the entity, or for a component if a valid\n+--       pragma or aspect Independent_Components applies to the enclosing\n+--       record type. Also set if a pragma Shared or pragma Atomic applies to\n+--       the entity, or if the declaration of the entity carries the Aliased\n+--       keyword. For Ada 2012, also applies to formal parameters. In the\n+--       case of private and incomplete types, this flag is set in both the\n+--       partial view and the full view.\n \n --    Is_Initial_Condition_Procedure (Flag302)\n --       Defined in functions and procedures. Set for a generated procedure\n@@ -4448,9 +4450,10 @@ package Einfo is\n --       the value of attribute 'Old's prefix.\n \n --    Strict_Alignment (Flag145) [implementation base type only]\n---       Defined in all type entities. Indicates that some containing part\n---       is either aliased or tagged. This prohibits packing the object\n---       tighter than its natural size and alignment.\n+--       Defined in all type entities. Indicates that the type is by-reference\n+--       or contains an aliased part. This forbids packing a component of this\n+--       type tighter than the alignment and size of the type, as specified by\n+--       RM 13.2(7) modified by AI12-001 as a Binding Interpretation.\n \n --    String_Literal_Length (Uint16)\n --       Defined in string literal subtypes (which are created to correspond"}, {"sha": "7b8edf43509e2ac18202dcf6d52d63671e85ca5f", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -13721,9 +13721,10 @@ package body Exp_Ch9 is\n                         Set_Ekind (Decl_Id, E_Variable);\n                      end if;\n \n-                     Set_Prival      (Comp_Id, Decl_Id);\n-                     Set_Prival_Link (Decl_Id, Comp_Id);\n-                     Set_Is_Aliased  (Decl_Id, Is_Aliased (Comp_Id));\n+                     Set_Prival         (Comp_Id, Decl_Id);\n+                     Set_Prival_Link    (Decl_Id, Comp_Id);\n+                     Set_Is_Aliased     (Decl_Id, Is_Aliased     (Comp_Id));\n+                     Set_Is_Independent (Decl_Id, Is_Independent (Comp_Id));\n \n                      --  Generate:\n                      --    comp_name : comp_typ renames _object.comp_name;"}, {"sha": "36cf63cad165d9e2c8815c9c1f862aa8c821edce", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 191, "deletions": 182, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -937,8 +937,9 @@ package body Freeze is\n                --  size of packed records if we can tell the size of the packed\n                --  record in the front end. Packed_Size_Known is True if so far\n                --  we can figure out the size. It is initialized to True for a\n-               --  packed record, unless the record has discriminants or atomic\n-               --  components or independent components.\n+               --  packed record, unless the record has either discriminants or\n+               --  independent components, or is a strict-alignment type, since\n+               --  it cannot be fully packed in this case.\n \n                --  The reason we eliminate the discriminated case is that\n                --  we don't know the way the back end lays out discriminated\n@@ -948,8 +949,8 @@ package body Freeze is\n                Packed_Size_Known : Boolean :=\n                  Is_Packed (T)\n                    and then not Has_Discriminants (T)\n-                   and then not Has_Atomic_Components (T)\n-                   and then not Has_Independent_Components (T);\n+                   and then not Has_Independent_Components (T)\n+                   and then not Strict_Alignment (T);\n \n                Packed_Size : Uint := Uint_0;\n                --  Size in bits so far\n@@ -997,17 +998,13 @@ package body Freeze is\n                      Packed_Size_Known := False;\n                   end if;\n \n-                  --  We do not know the packed size for an atomic/VFA type\n-                  --  or component, or an independent type or component, or a\n-                  --  by-reference type or aliased component (because packing\n-                  --  does not touch these).\n+                  --  We do not know the packed size for an independent\n+                  --  component or if it is of a strict-alignment type,\n+                  --  since packing does not touch these (RM 13.2(7)).\n \n-                  if        Is_Atomic_Or_VFA (Ctyp)\n-                    or else Is_Atomic_Or_VFA (Comp)\n+                  if Is_Independent (Comp)\n                     or else Is_Independent (Ctyp)\n-                    or else Is_Independent (Comp)\n-                    or else Is_By_Reference_Type (Ctyp)\n-                    or else Is_Aliased (Comp)\n+                    or else Strict_Alignment (Ctyp)\n                   then\n                      Packed_Size_Known := False;\n                   end if;\n@@ -1613,23 +1610,33 @@ package body Freeze is\n       Comp  : Entity_Id;\n \n    begin\n-      if Is_Tagged_Type (E) or else Is_Concurrent_Type (E) then\n+      if Is_By_Reference_Type (E) then\n          Set_Strict_Alignment (E);\n \n       elsif Is_Array_Type (E) then\n-         Set_Strict_Alignment (E, Strict_Alignment (Component_Type (E)));\n+         if Has_Aliased_Components (E)\n+           or else Strict_Alignment (Component_Type (E))\n+         then\n+            Set_Strict_Alignment (E);\n+         end if;\n \n       elsif Is_Record_Type (E) then\n-         if Is_Limited_Record (E) then\n-            Set_Strict_Alignment (E);\n+         --  ??? If the type has convention C_Pass_By_Copy, we consider\n+         --  that it may be packed even if it contains aliased parts.\n+         --  Such types are very unlikely to be misaligned in practice\n+         --  and this makes the compiler accept dubious representation\n+         --  clauses used in Florist on types containing arrays with\n+         --  aliased components.\n+\n+         if C_Pass_By_Copy (E) then\n             return;\n          end if;\n \n          Comp := First_Component (E);\n          while Present (Comp) loop\n             if not Is_Type (Comp)\n-              and then (Strict_Alignment (Etype (Comp))\n-                         or else Is_Aliased (Comp))\n+              and then (Is_Aliased (Comp)\n+                         or else Strict_Alignment (Etype (Comp)))\n             then\n                Set_Strict_Alignment (E);\n                return;\n@@ -2622,6 +2629,152 @@ package body Freeze is\n                end;\n             end if;\n \n+            --  Check for Aliased or Atomic_Components/Atomic/VFA with\n+            --  unsuitable packing or explicit component size clause given.\n+\n+            if (Has_Aliased_Components (Arr)\n+                 or else Has_Atomic_Components (Arr)\n+                 or else Is_Atomic_Or_VFA (Ctyp))\n+              and then\n+                (Has_Component_Size_Clause (Arr) or else Is_Packed (Arr))\n+            then\n+               Alias_Atomic_Check : declare\n+\n+                  procedure Complain_CS (T : String);\n+                  --  Outputs error messages for incorrect CS clause or pragma\n+                  --  Pack for aliased or atomic/VFA components (T is \"aliased\"\n+                  --  or \"atomic/vfa\");\n+\n+                  -----------------\n+                  -- Complain_CS --\n+                  -----------------\n+\n+                  procedure Complain_CS (T : String) is\n+                  begin\n+                     if Has_Component_Size_Clause (Arr) then\n+                        Clause :=\n+                          Get_Attribute_Definition_Clause\n+                            (FS, Attribute_Component_Size);\n+\n+                        Error_Msg_N\n+                          (\"incorrect component size for \"\n+                           & T & \" components\", Clause);\n+                        Error_Msg_Uint_1 := Esize (Ctyp);\n+                        Error_Msg_N\n+                          (\"\\only allowed value is^\", Clause);\n+\n+                     else\n+                        Error_Msg_N\n+                          (\"?cannot pack \" & T & \" components (RM 13.2(7))\",\n+                           Get_Rep_Pragma (FS, Name_Pack));\n+                        Set_Is_Packed (Arr, False);\n+                     end if;\n+                  end Complain_CS;\n+\n+                  --  Start of processing for Alias_Atomic_Check\n+\n+               begin\n+                  --  If object size of component type isn't known, we cannot\n+                  --  be sure so we defer to the back end.\n+\n+                  if not Known_Static_Esize (Ctyp) then\n+                     null;\n+\n+                  --  Case where component size has no effect. First check for\n+                  --  object size of component type multiple of the storage\n+                  --  unit size.\n+\n+                  elsif Esize (Ctyp) mod System_Storage_Unit = 0\n+\n+                    --  OK in both packing case and component size case if RM\n+                    --  size is known and static and same as the object size.\n+\n+                    and then\n+                      ((Known_Static_RM_Size (Ctyp)\n+                         and then Esize (Ctyp) = RM_Size (Ctyp))\n+\n+                        --  Or if we have an explicit component size clause and\n+                        --  the component size and object size are equal.\n+\n+                        or else\n+                          (Has_Component_Size_Clause (Arr)\n+                            and then Component_Size (Arr) = Esize (Ctyp)))\n+                  then\n+                     null;\n+\n+                  elsif Has_Aliased_Components (Arr) then\n+                     Complain_CS (\"aliased\");\n+\n+                  elsif Has_Atomic_Components (Arr)\n+                    or else Is_Atomic (Ctyp)\n+                  then\n+                     Complain_CS (\"atomic\");\n+\n+                  elsif Is_Volatile_Full_Access (Ctyp) then\n+                     Complain_CS (\"volatile full access\");\n+                  end if;\n+               end Alias_Atomic_Check;\n+            end if;\n+\n+            --  Check for Independent_Components/Independent with unsuitable\n+            --  packing or explicit component size clause given.\n+\n+            if (Has_Independent_Components (Arr) or else Is_Independent (Ctyp))\n+                  and then\n+               (Has_Component_Size_Clause  (Arr) or else Is_Packed (Arr))\n+            then\n+               begin\n+                  --  If object size of component type isn't known, we cannot\n+                  --  be sure so we defer to the back end.\n+\n+                  if not Known_Static_Esize (Ctyp) then\n+                     null;\n+\n+                  --  Case where component size has no effect. First check for\n+                  --  object size of component type multiple of the storage\n+                  --  unit size.\n+\n+                  elsif Esize (Ctyp) mod System_Storage_Unit = 0\n+\n+                    --  OK in both packing case and component size case if RM\n+                    --  size is known and multiple of the storage unit size.\n+\n+                    and then\n+                      ((Known_Static_RM_Size (Ctyp)\n+                         and then RM_Size (Ctyp) mod System_Storage_Unit = 0)\n+\n+                        --  Or if we have an explicit component size clause and\n+                        --  the component size is larger than the object size.\n+\n+                        or else\n+                          (Has_Component_Size_Clause (Arr)\n+                            and then Component_Size (Arr) >= Esize (Ctyp)))\n+                  then\n+                     null;\n+\n+                  else\n+                     if Has_Component_Size_Clause (Arr) then\n+                        Clause :=\n+                          Get_Attribute_Definition_Clause\n+                            (FS, Attribute_Component_Size);\n+\n+                        Error_Msg_N\n+                          (\"incorrect component size for \"\n+                           & \"independent components\", Clause);\n+                        Error_Msg_Uint_1 := Esize (Ctyp);\n+                        Error_Msg_N\n+                          (\"\\minimum allowed is^\", Clause);\n+\n+                     else\n+                        Error_Msg_N\n+                          (\"?cannot pack independent components (RM 13.2(7))\",\n+                           Get_Rep_Pragma (FS, Name_Pack));\n+                        Set_Is_Packed (Arr, False);\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n+\n             --  If packing was requested or if the component size was\n             --  set explicitly, then see if bit packing is required. This\n             --  processing is only done for base types, since all of the\n@@ -2637,7 +2790,7 @@ package body Freeze is\n                Esiz : Uint;\n \n             begin\n-               if (Is_Packed (Arr) or else Has_Pragma_Pack (Arr))\n+               if Is_Packed (Arr)\n                  and then Known_Static_RM_Size (Ctyp)\n                  and then not Has_Component_Size_Clause (Arr)\n                then\n@@ -2797,150 +2950,6 @@ package body Freeze is\n                end if;\n             end;\n \n-            --  Check for Aliased or Atomic_Components/Atomic/VFA with\n-            --  unsuitable packing or explicit component size clause given.\n-\n-            if (Has_Aliased_Components (Arr)\n-                 or else Has_Atomic_Components (Arr)\n-                 or else Is_Atomic_Or_VFA (Ctyp))\n-              and then\n-                (Has_Component_Size_Clause (Arr) or else Is_Packed (Arr))\n-            then\n-               Alias_Atomic_Check : declare\n-\n-                  procedure Complain_CS (T : String);\n-                  --  Outputs error messages for incorrect CS clause or pragma\n-                  --  Pack for aliased or atomic/VFA components (T is \"aliased\"\n-                  --  or \"atomic/vfa\");\n-\n-                  -----------------\n-                  -- Complain_CS --\n-                  -----------------\n-\n-                  procedure Complain_CS (T : String) is\n-                  begin\n-                     if Has_Component_Size_Clause (Arr) then\n-                        Clause :=\n-                          Get_Attribute_Definition_Clause\n-                            (FS, Attribute_Component_Size);\n-\n-                        Error_Msg_N\n-                          (\"incorrect component size for \"\n-                           & T & \" components\", Clause);\n-                        Error_Msg_Uint_1 := Esize (Ctyp);\n-                        Error_Msg_N\n-                          (\"\\only allowed value is^\", Clause);\n-\n-                     else\n-                        Error_Msg_N\n-                          (\"cannot pack \" & T & \" components\",\n-                           Get_Rep_Pragma (FS, Name_Pack));\n-                     end if;\n-                  end Complain_CS;\n-\n-                  --  Start of processing for Alias_Atomic_Check\n-\n-               begin\n-                  --  If object size of component type isn't known, we cannot\n-                  --  be sure so we defer to the back end.\n-\n-                  if not Known_Static_Esize (Ctyp) then\n-                     null;\n-\n-                  --  Case where component size has no effect. First check for\n-                  --  object size of component type multiple of the storage\n-                  --  unit size.\n-\n-                  elsif Esize (Ctyp) mod System_Storage_Unit = 0\n-\n-                    --  OK in both packing case and component size case if RM\n-                    --  size is known and static and same as the object size.\n-\n-                    and then\n-                      ((Known_Static_RM_Size (Ctyp)\n-                         and then Esize (Ctyp) = RM_Size (Ctyp))\n-\n-                        --  Or if we have an explicit component size clause and\n-                        --  the component size and object size are equal.\n-\n-                        or else\n-                          (Has_Component_Size_Clause (Arr)\n-                            and then Component_Size (Arr) = Esize (Ctyp)))\n-                  then\n-                     null;\n-\n-                  elsif Has_Aliased_Components (Arr) then\n-                     Complain_CS (\"aliased\");\n-\n-                  elsif Has_Atomic_Components (Arr)\n-                    or else Is_Atomic (Ctyp)\n-                  then\n-                     Complain_CS (\"atomic\");\n-\n-                  elsif Is_Volatile_Full_Access (Ctyp) then\n-                     Complain_CS (\"volatile full access\");\n-                  end if;\n-               end Alias_Atomic_Check;\n-            end if;\n-\n-            --  Check for Independent_Components/Independent with unsuitable\n-            --  packing or explicit component size clause given.\n-\n-            if (Has_Independent_Components (Arr) or else Is_Independent (Ctyp))\n-                  and then\n-               (Has_Component_Size_Clause  (Arr) or else Is_Packed (Arr))\n-            then\n-               begin\n-                  --  If object size of component type isn't known, we cannot\n-                  --  be sure so we defer to the back end.\n-\n-                  if not Known_Static_Esize (Ctyp) then\n-                     null;\n-\n-                  --  Case where component size has no effect. First check for\n-                  --  object size of component type multiple of the storage\n-                  --  unit size.\n-\n-                  elsif Esize (Ctyp) mod System_Storage_Unit = 0\n-\n-                    --  OK in both packing case and component size case if RM\n-                    --  size is known and multiple of the storage unit size.\n-\n-                    and then\n-                      ((Known_Static_RM_Size (Ctyp)\n-                         and then RM_Size (Ctyp) mod System_Storage_Unit = 0)\n-\n-                        --  Or if we have an explicit component size clause and\n-                        --  the component size is larger than the object size.\n-\n-                        or else\n-                          (Has_Component_Size_Clause (Arr)\n-                            and then Component_Size (Arr) >= Esize (Ctyp)))\n-                  then\n-                     null;\n-\n-                  else\n-                     if Has_Component_Size_Clause (Arr) then\n-                        Clause :=\n-                          Get_Attribute_Definition_Clause\n-                            (FS, Attribute_Component_Size);\n-\n-                        Error_Msg_N\n-                          (\"incorrect component size for \"\n-                           & \"independent components\", Clause);\n-                        Error_Msg_Uint_1 := Esize (Ctyp);\n-                        Error_Msg_N\n-                          (\"\\minimum allowed is^\", Clause);\n-\n-                     else\n-                        Error_Msg_N\n-                          (\"cannot pack independent components\",\n-                           Get_Rep_Pragma (FS, Name_Pack));\n-                     end if;\n-                  end if;\n-               end;\n-            end if;\n-\n             --  Warn for case of atomic type\n \n             Clause := Get_Rep_Pragma (FS, Name_Atomic);\n@@ -4589,18 +4598,6 @@ package body Freeze is\n             end if;\n          end if;\n \n-         --  Complete error checking on record representation clause (e.g.\n-         --  overlap of components). This is called after adjusting the\n-         --  record for reverse bit order.\n-\n-         declare\n-            RRC : constant Node_Id := Get_Record_Representation_Clause (Rec);\n-         begin\n-            if Present (RRC) then\n-               Check_Record_Representation_Clause (RRC);\n-            end if;\n-         end;\n-\n          --  Check for useless pragma Pack when all components placed. We only\n          --  do this check for record types, not subtypes, since a subtype may\n          --  have all its components placed, and it still makes perfectly good\n@@ -6792,17 +6789,29 @@ package body Freeze is\n             end if;\n          end if;\n \n-         --  Now that all types from which E may depend are frozen, see if the\n-         --  size is known at compile time, if it must be unsigned, or if\n-         --  strict alignment is required\n-\n-         Check_Compile_Time_Size (E);\n-         Check_Unsigned_Type (E);\n+         --  Now that all types from which E may depend are frozen, see if\n+         --  strict alignment is required, a component clause on a record\n+         --  is correct, the size is known at compile time and if it must\n+         --  be unsigned, in that order.\n \n          if Base_Type (E) = E then\n             Check_Strict_Alignment (E);\n          end if;\n \n+         if Ekind_In (E, E_Record_Type, E_Record_Subtype) then\n+            declare\n+               RC : constant Node_Id := Get_Record_Representation_Clause (E);\n+            begin\n+               if Present (RC) then\n+                  Check_Record_Representation_Clause (RC);\n+               end if;\n+            end;\n+         end if;\n+\n+         Check_Compile_Time_Size (E);\n+\n+         Check_Unsigned_Type (E);\n+\n          --  Do not allow a size clause for a type which does not have a size\n          --  that is known at compile time\n "}, {"sha": "57d163169d0a979d63c8d0e14fbc7ea9cb8a19c1", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 59, "deletions": 43, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -233,7 +233,8 @@ static vec<subst_pair> build_subst_list (Entity_Id, Entity_Id, bool);\n static vec<variant_desc> build_variant_list (tree, vec<subst_pair>,\n \t\t\t\t\t     vec<variant_desc>);\n static tree maybe_saturate_size (tree);\n-static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n+static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool,\n+\t\t\t   const char *, const char *);\n static void set_rm_size (Uint, tree, Entity_Id);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static unsigned int promote_object_alignment (tree, Entity_Id);\n@@ -780,7 +781,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tif (Known_Esize (gnat_entity))\n \t  gnu_size\n \t    = validate_size (Esize (gnat_entity), gnu_type, gnat_entity,\n-\t\t\t     VAR_DECL, false, Has_Size_Clause (gnat_entity));\n+\t\t\t     VAR_DECL, false, Has_Size_Clause (gnat_entity),\n+\t\t\t     NULL, NULL);\n \tif (gnu_size)\n \t  {\n \t    gnu_type\n@@ -4243,7 +4245,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t   ? Esize (gnat_entity) : RM_Size (gnat_entity);\n \t  gnu_size\n \t    = validate_size (gnat_size, gnu_type, gnat_entity, TYPE_DECL,\n-\t\t\t     false, Has_Size_Clause (gnat_entity));\n+\t\t\t     false, Has_Size_Clause (gnat_entity), NULL, NULL);\n \t}\n \n       /* If a size was specified, see if we can make a new type of that size\n@@ -5090,8 +5092,8 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n   /* Get and validate any specified Component_Size.  */\n   gnu_comp_size\n     = validate_size (Component_Size (gnat_array), gnu_type, gnat_array,\n-\t\t     has_packed_components ? TYPE_DECL : VAR_DECL,\n-\t\t     true, Has_Component_Size_Clause (gnat_array));\n+\t\t     has_packed_components ? TYPE_DECL : VAR_DECL, true,\n+\t\t     Has_Component_Size_Clause (gnat_array), NULL, NULL);\n \n   /* If the component type is a RECORD_TYPE that has a self-referential size,\n      then use the maximum size for the component size.  */\n@@ -6999,13 +7001,16 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   const Node_Id gnat_clause = Component_Clause (gnat_field);\n   const Entity_Id gnat_record_type = Underlying_Type (Scope (gnat_field));\n   const Entity_Id gnat_field_type = Etype (gnat_field);\n+  tree gnu_field_type = gnat_to_gnu_type (gnat_field_type);\n+  tree gnu_field_id = get_entity_name (gnat_field);\n   const bool is_atomic\n     = (Is_Atomic_Or_VFA (gnat_field) || Is_Atomic_Or_VFA (gnat_field_type));\n   const bool is_aliased = Is_Aliased (gnat_field);\n   const bool is_independent\n     = (Is_Independent (gnat_field) || Is_Independent (gnat_field_type));\n   const bool is_volatile\n     = (Treat_As_Volatile (gnat_field) || Treat_As_Volatile (gnat_field_type));\n+  const bool is_by_ref = TYPE_IS_BY_REFERENCE_P (gnu_field_type);\n   const bool is_strict_alignment = Strict_Alignment (gnat_field_type);\n   /* We used to consider that volatile fields also require strict alignment,\n      but that was an interpolation and would cause us to reject a pragma\n@@ -7014,16 +7019,36 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n      involve load-modify-store sequences, but that's OK for volatile.  The\n      only constraint is the implementation advice whereby only the bits of\n      the components should be accessed if they both start and end on byte\n-     boundaries, but that should be guaranteed by the GCC memory model.  */\n-  const bool needs_strict_alignment\n-    = (is_atomic || is_aliased || is_independent || is_strict_alignment);\n-  bool is_bitfield;\n-  tree gnu_field_type = gnat_to_gnu_type (gnat_field_type);\n-  tree gnu_field_id = get_entity_name (gnat_field);\n+     boundaries, but that should be guaranteed by the GCC memory model.\n+     Note that we have some redundancies (is_atomic => is_independent,\n+     is_aliased => is_independent and is_by_ref => is_strict_alignment)\n+     so the following formula is sufficient.  */\n+  const bool needs_strict_alignment = (is_independent || is_strict_alignment);\n+  const char *field_s, *size_s;\n   tree gnu_field, gnu_size, gnu_pos;\n+  bool is_bitfield;\n+\n+  /* The qualifier to be used in messages.  */\n+  if (is_atomic)\n+    field_s = \"atomic&\";\n+  else if (is_aliased)\n+    field_s = \"aliased&\";\n+  else if (is_independent)\n+    field_s = \"independent&\";\n+  else if (is_by_ref)\n+    field_s = \"& with by-reference type\";\n+  else if (is_strict_alignment)\n+    field_s = \"& with aliased part\";\n+  else\n+    field_s = \"&\";\n \n-  /* If this field requires strict alignment, we cannot pack it because\n-     it would very likely be under-aligned in the record.  */\n+  /* The message to be used for incompatible size.  */\n+  if (is_atomic || is_aliased)\n+    size_s = \"size for %s must be ^\";\n+  else if (field_s)\n+    size_s = \"size for %s too small{, minimum allowed is ^}\";\n+\n+  /* If a field requires strict alignment, we cannot pack it (RM 13.2(7)).  */\n   if (needs_strict_alignment)\n     packed = 0;\n   else\n@@ -7034,7 +7059,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n      for further details.  */\n   if (Present (gnat_clause) || Known_Esize (gnat_field))\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type, gnat_field,\n-\t\t\t      FIELD_DECL, false, true);\n+\t\t\t      FIELD_DECL, false, true, size_s, field_s);\n   else if (packed == 1)\n     {\n       gnu_size = rm_size (gnu_field_type);\n@@ -7152,23 +7177,11 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t  && !(type_annotate_only && Is_Tagged_Type (gnat_field_type)))\n \t{\n \t  const unsigned int type_align = TYPE_ALIGN (gnu_field_type);\n-\t  const char *field_s;\n \n \t  if (TYPE_ALIGN (gnu_record_type)\n \t      && TYPE_ALIGN (gnu_record_type) < type_align)\n \t    SET_TYPE_ALIGN (gnu_record_type, type_align);\n \n-\t  if (is_atomic)\n-\t    field_s = \"atomic &\";\n-\t  else if (is_aliased)\n-\t    field_s = \"aliased &\";\n-\t  else if (is_independent)\n-\t    field_s = \"independent &\";\n-\t  else if (is_strict_alignment)\n-\t    field_s = \"& with aliased or tagged part\";\n-\t  else\n-\t    gcc_unreachable ();\n-\n \t  /* If the position is not a multiple of the storage unit, then error\n \t     out and reset the position.  */\n \t  if (!integer_zerop (size_binop (TRUNC_MOD_EXPR, gnu_pos,\n@@ -7221,11 +7234,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t\t       || (cmp > 0 && (is_atomic || is_aliased)))\n \t\t{\n \t\t  char s[128];\n-\t\t  if (is_atomic || is_aliased)\n-\t\t    snprintf (s, sizeof (s), \"size for %s must be ^\", field_s);\n-\t\t  else\n-  \t\t    snprintf (s, sizeof (s), \"size for %s must be at least ^\",\n-\t\t\t      field_s);\n+\t\t  snprintf (s, sizeof (s), size_s, field_s);\n \t\t  post_error_ne_tree (s, Last_Bit (gnat_clause), gnat_field,\n \t\t\t\t      type_size);\n \t\t  gnu_size = NULL_TREE;\n@@ -7362,7 +7371,7 @@ components_need_strict_alignment (Node_Id component_list)\n     {\n       Entity_Id gnat_field = Defining_Entity (component_decl);\n \n-      if (Is_Aliased (gnat_field))\n+      if (Is_Independent (gnat_field) || Is_Independent (Etype (gnat_field)))\n \treturn true;\n \n       if (Strict_Alignment (Etype (gnat_field)))\n@@ -8838,11 +8847,12 @@ maybe_saturate_size (tree size)\n    true if we are being called to process the Component_Size of GNAT_OBJECT;\n    this is used only for error messages.  ZERO_OK is true if a size of zero\n    is permitted; if ZERO_OK is false, it means that a size of zero should be\n-   treated as an unspecified size.  */\n+   treated as an unspecified size.  S1 and S2 are used for error messages.  */\n \n static tree\n validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n-\t       enum tree_code kind, bool component_p, bool zero_ok)\n+\t       enum tree_code kind, bool component_p, bool zero_ok,\n+\t       const char *s1, const char *s2)\n {\n   Node_Id gnat_error_node;\n   tree old_size, size;\n@@ -8888,10 +8898,10 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n       && !integer_zerop (size_binop (TRUNC_MOD_EXPR, size, bitsize_unit_node)))\n     {\n       if (component_p)\n-\tpost_error_ne (\"component size for& is not a multiple of Storage_Unit\",\n+\tpost_error_ne (\"component size for& must be multiple of Storage_Unit\",\n \t\t       gnat_error_node, gnat_object);\n       else\n-\tpost_error_ne (\"size for& is not a multiple of Storage_Unit\",\n+\tpost_error_ne (\"size for& must be multiple of Storage_Unit\",\n \t\t       gnat_error_node, gnat_object);\n       return NULL_TREE;\n     }\n@@ -8932,14 +8942,20 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n       || TREE_OVERFLOW (old_size)\n       || tree_int_cst_lt (size, old_size))\n     {\n-      if (component_p)\n-\tpost_error_ne_tree\n-\t  (\"component size for& too small{, minimum allowed is ^}\",\n-\t   gnat_error_node, gnat_object, old_size);\n+      char buf[128];\n+      const char *s;\n+\n+      if (kind == FIELD_DECL)\n+\t{\n+\t  snprintf (buf, sizeof (buf), s1, s2);\n+\t  s = buf;\n+\t}\n+      else if (component_p)\n+\ts = \"component size for& too small{, minimum allowed is ^}\";\n       else\n-\tpost_error_ne_tree\n-\t  (\"size for& too small{, minimum allowed is ^}\",\n-\t   gnat_error_node, gnat_object, old_size);\n+\ts = \"size for& too small{, minimum allowed is ^}\";\n+      post_error_ne_tree (s, gnat_error_node, gnat_object, old_size);\n+\n       return NULL_TREE;\n     }\n "}, {"sha": "e41fcdb6cc0e33b582ab34d94140423b07930d85", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -602,6 +602,7 @@ package body Sem_Aggr is\n       Set_Etype                  (Itype, Base_Type             (Typ));\n       Set_Has_Alignment_Clause   (Itype, Has_Alignment_Clause  (Typ));\n       Set_Is_Aliased             (Itype, Is_Aliased            (Typ));\n+      Set_Is_Independent         (Itype, Is_Independent        (Typ));\n       Set_Depends_On_Private     (Itype, Depends_On_Private    (Typ));\n \n       Copy_Suppress_Status (Index_Check,  Typ, Itype);"}, {"sha": "bbdb065908b515fbaa2cffeeeb77d25e46dc63b8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -10937,9 +10937,9 @@ package body Sem_Ch13 is\n       end if;\n \n       --  For records that have component clauses for all components, and whose\n-      --  size is less than or equal to 32, we need to know the size in the\n-      --  front end to activate possible packed array processing where the\n-      --  component type is a record.\n+      --  size is less than or equal to 32, and which can be fully packed, we\n+      --  need to know the size in the front end to activate possible packed\n+      --  array processing where the component type is a record.\n \n       --  At this stage Hbit + 1 represents the first unused bit from all the\n       --  component clauses processed, so if the component clauses are\n@@ -10950,7 +10950,10 @@ package body Sem_Ch13 is\n       --  length (it may for example be appropriate to round up the size\n       --  to some convenient boundary, based on alignment considerations, etc).\n \n-      if Unknown_RM_Size (Rectype) and then Hbit + 1 <= 32 then\n+      if Unknown_RM_Size (Rectype)\n+        and then Hbit + 1 <= 32\n+        and then not Strict_Alignment (Rectype)\n+      then\n \n          --  Nothing to do if at least one component has no component clause\n "}, {"sha": "ca2247671e11870e40264bfaa7f63ac8cb85404f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -1505,6 +1505,7 @@ package body Sem_Ch3 is\n          Set_Ekind               (Tag, E_Component);\n          Set_Is_Tag              (Tag);\n          Set_Is_Aliased          (Tag);\n+         Set_Is_Independent      (Tag);\n          Set_Related_Type        (Tag, Iface);\n          Init_Component_Location (Tag);\n \n@@ -1544,6 +1545,7 @@ package body Sem_Ch3 is\n             Set_Analyzed (Decl);\n             Set_Ekind               (Offset, E_Component);\n             Set_Is_Aliased          (Offset);\n+            Set_Is_Independent      (Offset);\n             Set_Related_Type        (Offset, Iface);\n             Init_Component_Location (Offset);\n             Insert_After (Last_Tag, Decl);\n@@ -2083,7 +2085,15 @@ package body Sem_Ch3 is\n       end if;\n \n       Set_Etype (Id, T);\n-      Set_Is_Aliased (Id, Aliased_Present (Component_Definition (N)));\n+\n+      if Aliased_Present (Component_Definition (N)) then\n+         Set_Is_Aliased (Id);\n+\n+         --  AI12-001: All aliased objects are considered to be specified as\n+         --  independently addressable (RM C.6(8.1/4)).\n+\n+         Set_Is_Independent (Id);\n+      end if;\n \n       --  The component declaration may have a per-object constraint, set\n       --  the appropriate flag in the defining identifier of the subtype.\n@@ -4846,6 +4856,11 @@ package body Sem_Ch3 is\n       if Aliased_Present (N) then\n          Set_Is_Aliased (Id);\n \n+         --  AI12-001: All aliased objects are considered to be specified as\n+         --  independently addressable (RM C.6(8.1/4)).\n+\n+         Set_Is_Independent (Id);\n+\n          --  If the object is aliased and the type is unconstrained with\n          --  defaulted discriminants and there is no expression, then the\n          --  object is constrained by the defaults, so it is worthwhile\n@@ -6346,6 +6361,11 @@ package body Sem_Ch3 is\n          Check_SPARK_05_Restriction\n            (\"aliased is not allowed\", Component_Definition (Def));\n          Set_Has_Aliased_Components (Etype (T));\n+\n+         --  AI12-001: All aliased objects are considered to be specified as\n+         --  independently addressable (RM C.6(8.1/4)).\n+\n+         Set_Has_Independent_Components (Etype (T));\n       end if;\n \n       --  Ada 2005 (AI-231): Propagate the null-excluding attribute to the\n@@ -13237,6 +13257,7 @@ package body Sem_Ch3 is\n \n       Set_Is_Constrained     (Def_Id, True);\n       Set_Is_Aliased         (Def_Id, Is_Aliased (T));\n+      Set_Is_Independent     (Def_Id, Is_Independent (T));\n       Set_Depends_On_Private (Def_Id, Has_Private_Component (Def_Id));\n \n       Set_Is_Private_Composite (Def_Id, Is_Private_Composite (T));\n@@ -14579,16 +14600,17 @@ package body Sem_Ch3 is\n \n    procedure Copy_Array_Base_Type_Attributes (T1, T2 : Entity_Id) is\n    begin\n-      Set_Component_Alignment      (T1, Component_Alignment      (T2));\n-      Set_Component_Type           (T1, Component_Type           (T2));\n-      Set_Component_Size           (T1, Component_Size           (T2));\n-      Set_Has_Controlled_Component (T1, Has_Controlled_Component (T2));\n-      Set_Has_Non_Standard_Rep     (T1, Has_Non_Standard_Rep     (T2));\n-      Propagate_Concurrent_Flags   (T1, T2);\n-      Set_Is_Packed                (T1, Is_Packed                (T2));\n-      Set_Has_Aliased_Components   (T1, Has_Aliased_Components   (T2));\n-      Set_Has_Atomic_Components    (T1, Has_Atomic_Components    (T2));\n-      Set_Has_Volatile_Components  (T1, Has_Volatile_Components  (T2));\n+      Set_Component_Alignment        (T1, Component_Alignment        (T2));\n+      Set_Component_Type             (T1, Component_Type             (T2));\n+      Set_Component_Size             (T1, Component_Size             (T2));\n+      Set_Has_Controlled_Component   (T1, Has_Controlled_Component   (T2));\n+      Set_Has_Non_Standard_Rep       (T1, Has_Non_Standard_Rep       (T2));\n+      Propagate_Concurrent_Flags     (T1,                             T2);\n+      Set_Is_Packed                  (T1, Is_Packed                  (T2));\n+      Set_Has_Aliased_Components     (T1, Has_Aliased_Components     (T2));\n+      Set_Has_Atomic_Components      (T1, Has_Atomic_Components      (T2));\n+      Set_Has_Independent_Components (T1, Has_Independent_Components (T2));\n+      Set_Has_Volatile_Components    (T1, Has_Volatile_Components    (T2));\n    end Copy_Array_Base_Type_Attributes;\n \n    -----------------------------------\n@@ -14599,17 +14621,20 @@ package body Sem_Ch3 is\n    begin\n       Set_Size_Info (T1, T2);\n \n-      Set_First_Index            (T1, First_Index            (T2));\n-      Set_Is_Aliased             (T1, Is_Aliased             (T2));\n-      Set_Is_Volatile            (T1, Is_Volatile            (T2));\n-      Set_Treat_As_Volatile      (T1, Treat_As_Volatile      (T2));\n-      Set_Is_Constrained         (T1, Is_Constrained         (T2));\n-      Set_Depends_On_Private     (T1, Has_Private_Component  (T2));\n-      Inherit_Rep_Item_Chain     (T1,                         T2);\n-      Set_Convention             (T1, Convention             (T2));\n-      Set_Is_Limited_Composite   (T1, Is_Limited_Composite   (T2));\n-      Set_Is_Private_Composite   (T1, Is_Private_Composite   (T2));\n-      Set_Packed_Array_Impl_Type (T1, Packed_Array_Impl_Type (T2));\n+      Set_First_Index             (T1, First_Index             (T2));\n+      Set_Is_Aliased              (T1, Is_Aliased              (T2));\n+      Set_Is_Atomic               (T1, Is_Atomic               (T2));\n+      Set_Is_Independent          (T1, Is_Independent          (T2));\n+      Set_Is_Volatile             (T1, Is_Volatile             (T2));\n+      Set_Is_Volatile_Full_Access (T1, Is_Volatile_Full_Access (T2));\n+      Set_Treat_As_Volatile       (T1, Treat_As_Volatile       (T2));\n+      Set_Is_Constrained          (T1, Is_Constrained          (T2));\n+      Set_Depends_On_Private      (T1, Has_Private_Component   (T2));\n+      Inherit_Rep_Item_Chain      (T1,                          T2);\n+      Set_Convention              (T1, Convention              (T2));\n+      Set_Is_Limited_Composite    (T1, Is_Limited_Composite    (T2));\n+      Set_Is_Private_Composite    (T1, Is_Private_Composite    (T2));\n+      Set_Packed_Array_Impl_Type  (T1, Packed_Array_Impl_Type  (T2));\n    end Copy_Array_Subtype_Attributes;\n \n    -----------------------------------\n@@ -22069,6 +22094,7 @@ package body Sem_Ch3 is\n             Set_Ekind                     (Tag_Comp, E_Component);\n             Set_Is_Tag                    (Tag_Comp);\n             Set_Is_Aliased                (Tag_Comp);\n+            Set_Is_Independent            (Tag_Comp);\n             Set_Etype                     (Tag_Comp, RTE (RE_Tag));\n             Set_DT_Entry_Count            (Tag_Comp, No_Uint);\n             Set_Original_Record_Component (Tag_Comp, Tag_Comp);"}, {"sha": "2342c544b32e0b46fccf54abe99d44a6b8629605", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -2441,9 +2441,10 @@ package body Sem_Ch5 is\n             Set_Etype (Def_Id, Component_Type (Typ));\n \n             --  The loop variable is aliased if the array components are\n-            --  aliased.\n+            --  aliased. Likewise for the independent aspect.\n \n-            Set_Is_Aliased (Def_Id, Has_Aliased_Components (Typ));\n+            Set_Is_Aliased     (Def_Id, Has_Aliased_Components     (Typ));\n+            Set_Is_Independent (Def_Id, Has_Independent_Components (Typ));\n \n             --  AI12-0047 stipulates that the domain (array or container)\n             --  cannot be a component that depends on a discriminant if the"}, {"sha": "4afcf01345ab0c98797c008236dcc75694a82bc5", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -11654,6 +11654,11 @@ package body Sem_Ch6 is\n               and then Aliased_Present (Param_Spec)\n             then\n                Set_Is_Aliased (Formal);\n+\n+               --  AI12-001: All aliased objects are considered to be specified\n+               --  as independently addressable (RM C.6(8.1/4)).\n+\n+               Set_Is_Independent (Formal);\n             end if;\n \n             --  Ada 2005 (AI-231): Create and decorate an internal subtype"}, {"sha": "247064bd955b1e533cb256b53e97df0905148832", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -1,3 +1,8 @@\n+2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/clause_on_volatile.ads,\n+\tgnat.dg/specs/size_clause3.ads: Update expected diagnostics.\n+\n 2019-12-16  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \tPR target/92950"}, {"sha": "157f724477406d8ab8a63de90be691448286e44e", "filename": "gcc/testsuite/gnat.dg/specs/clause_on_volatile.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fclause_on_volatile.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fclause_on_volatile.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fclause_on_volatile.ads?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -57,7 +57,7 @@ package Clause_On_Volatile is\n   end record;\n   For V1'Alignment use 4;\n   for V1 use record\n-     VW at 0 range 0 .. 15;\n+     VW at 0 range 0 .. 15; -- { dg-error \"too small*\" }\n   end record;\n \n   type V2 is record\n@@ -67,7 +67,7 @@ package Clause_On_Volatile is\n   For V2'Alignment use 4;\n   for V2 use record\n      B at 0 range 0 .. 7;\n-     VW at 1 range 0 .. 31;\n+     VW at 1 range 0 .. 31; -- { dg-error \"must be multiple|alignment\" }\n   end record;\n \n   type V3 is record\n@@ -77,7 +77,7 @@ package Clause_On_Volatile is\n   For V3'Alignment use 4;\n   for V3 use record\n      B at 0 range 0 .. 7;\n-     VW at 1 range 0 .. 15;\n+     VW at 1 range 0 .. 15; -- { dg-error \"must be multiple|alignment|too small\" }\n   end record;\n \n end Clause_On_Volatile;"}, {"sha": "a9ab5c57e3a5dd349cfb1a0c361764ae15015ace", "filename": "gcc/testsuite/gnat.dg/specs/size_clause3.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a517d6c19a572a4aa37569f54186883d70627686/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads?ref=a517d6c19a572a4aa37569f54186883d70627686", "patch": "@@ -14,7 +14,7 @@ package Size_Clause3 is\n     rr : R1; -- size must be 40\n   end record;\n   for S1 use record\n-    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. too small\" }\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. with aliased part too small\" }\n   end record;\n \n   -- The record is explicitly given alignment 1 so its real type is 40.\n@@ -44,7 +44,7 @@ package Size_Clause3 is\n     rr : R3; -- size must be 40\n   end record;\n   for S3 use record\n-    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. too small\" }\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. with aliased part too small\" }\n   end record;\n \n end Size_Clause3;"}]}