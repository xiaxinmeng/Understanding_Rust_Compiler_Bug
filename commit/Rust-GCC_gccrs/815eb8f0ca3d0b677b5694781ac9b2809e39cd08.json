{"sha": "815eb8f0ca3d0b677b5694781ac9b2809e39cd08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE1ZWI4ZjBjYTNkMGI2NzdiNTY5NDc4MWFjOWIyODA5ZTM5Y2QwOA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-12-02T06:15:54Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-12-02T06:15:54Z"}, "message": "re PR middle-end/25176 ([4.0 only] FAIL: Array_3 -O3 execution - bytecode->native test)\n\n\tPR middle-end/25176\n\t* function.c (expand_function_end): Emit blockage for unwinder\n\tafter return label.\n\nFrom-SVN: r107871", "tree": {"sha": "730ebd016476c654c4418b56a23dac1460fc7f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/730ebd016476c654c4418b56a23dac1460fc7f74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/815eb8f0ca3d0b677b5694781ac9b2809e39cd08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815eb8f0ca3d0b677b5694781ac9b2809e39cd08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815eb8f0ca3d0b677b5694781ac9b2809e39cd08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815eb8f0ca3d0b677b5694781ac9b2809e39cd08/comments", "author": null, "committer": null, "parents": [{"sha": "87f2a9f57bfc1a95934202110badb4d1a31409ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f2a9f57bfc1a95934202110badb4d1a31409ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87f2a9f57bfc1a95934202110badb4d1a31409ed"}], "stats": {"total": 35, "additions": 23, "deletions": 12}, "files": [{"sha": "d33807b378ee9804e01cd867fce26e26c484e64b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815eb8f0ca3d0b677b5694781ac9b2809e39cd08/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815eb8f0ca3d0b677b5694781ac9b2809e39cd08/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=815eb8f0ca3d0b677b5694781ac9b2809e39cd08", "patch": "@@ -1,3 +1,9 @@\n+2005-12-02  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR middle-end/25176\n+\t* function.c (expand_function_end): Emit blockage for unwinder\n+\tafter return label.\n+\n 2005-12-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* tree.h (TREE_OVERFLOW): Make this flag/predicate specific to"}, {"sha": "ff80df70b28104a5a764868ccf55350fa07e415c", "filename": "gcc/function.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815eb8f0ca3d0b677b5694781ac9b2809e39cd08/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815eb8f0ca3d0b677b5694781ac9b2809e39cd08/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=815eb8f0ca3d0b677b5694781ac9b2809e39cd08", "patch": "@@ -4334,14 +4334,6 @@ expand_function_end (void)\n   clear_pending_stack_adjust ();\n   do_pending_stack_adjust ();\n \n-  /* @@@ This is a kludge.  We want to ensure that instructions that\n-     may trap are not moved into the epilogue by scheduling, because\n-     we don't always emit unwind information for the epilogue.\n-     However, not all machine descriptions define a blockage insn, so\n-     emit an ASM_INPUT to act as one.  */\n-  if (flag_non_call_exceptions)\n-    emit_insn (gen_rtx_ASM_INPUT (VOIDmode, \"\"));\n-\n   /* Mark the end of the function body.\n      If control reaches this insn, the function can drop through\n      without returning a value.  */\n@@ -4373,10 +4365,23 @@ expand_function_end (void)\n   /* Output the label for the actual return from the function.  */\n   emit_label (return_label);\n \n-  /* Let except.c know where it should emit the call to unregister\n-     the function context for sjlj exceptions.  */\n-  if (flag_exceptions && USING_SJLJ_EXCEPTIONS)\n-    sjlj_emit_function_exit_after (get_last_insn ());\n+  if (USING_SJLJ_EXCEPTIONS)\n+    {\n+      /* Let except.c know where it should emit the call to unregister\n+\t the function context for sjlj exceptions.  */\n+      if (flag_exceptions)\n+\tsjlj_emit_function_exit_after (get_last_insn ());\n+    }\n+  else\n+    {\n+      /* @@@ This is a kludge.  We want to ensure that instructions that\n+\t may trap are not moved into the epilogue by scheduling, because\n+\t we don't always emit unwind information for the epilogue.\n+\t However, not all machine descriptions define a blockage insn, so\n+\t emit an ASM_INPUT to act as one.  */\n+      if (flag_non_call_exceptions)\n+\temit_insn (gen_rtx_ASM_INPUT (VOIDmode, \"\"));\n+    }\n \n   /* If this is an implementation of throw, do what's necessary to\n      communicate between __builtin_eh_return and the epilogue.  */"}]}