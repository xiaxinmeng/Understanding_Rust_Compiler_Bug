{"sha": "40289199ee725183a286f50cf448f6347267047e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyODkxOTllZTcyNTE4M2EyODZmNTBjZjQ0OGY2MzQ3MjY3MDQ3ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-05-13T11:37:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-05-13T11:37:21Z"}, "message": "re PR tree-optimization/90402 (ICE in slpeel_duplicate_current_defs_from_edges)\n\n2019-05-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/90402\n\t* tree-if-conv.c (tree_if_conversion): Value number only\n\tthe loop body by making the latch an exit of the region\n\tas well.\n\t* tree-ssa-sccvn.c (process_bb): Add flag whether to skip\n\tprocessing PHIs.\n\t(do_rpo_vn): Deal with multiple edges into the entry block\n\tthat are not backedges inside the region by skipping PHIs\n\tof the entry block.\n\n\t* gcc.dg/torture/pr90402-1.c: New testcase.\n\nFrom-SVN: r271125", "tree": {"sha": "e5c9e26646781ec79c4aa4ae92b04c9ebef06279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5c9e26646781ec79c4aa4ae92b04c9ebef06279"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40289199ee725183a286f50cf448f6347267047e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40289199ee725183a286f50cf448f6347267047e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40289199ee725183a286f50cf448f6347267047e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40289199ee725183a286f50cf448f6347267047e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aae6da83564549a6f8700407df50cdd52d411727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aae6da83564549a6f8700407df50cdd52d411727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aae6da83564549a6f8700407df50cdd52d411727"}], "stats": {"total": 211, "additions": 142, "deletions": 69}, "files": [{"sha": "925d23ca69d3c23db35a7a76d30162ed2fc00a98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40289199ee725183a286f50cf448f6347267047e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40289199ee725183a286f50cf448f6347267047e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40289199ee725183a286f50cf448f6347267047e", "patch": "@@ -1,3 +1,15 @@\n+2019-05-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/90402\n+\t* tree-if-conv.c (tree_if_conversion): Value number only\n+\tthe loop body by making the latch an exit of the region\n+\tas well.\n+\t* tree-ssa-sccvn.c (process_bb): Add flag whether to skip\n+\tprocessing PHIs.\n+\t(do_rpo_vn): Deal with multiple edges into the entry block\n+\tthat are not backedges inside the region by skipping PHIs\n+\tof the entry block.\n+\n 2019-05-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/90316"}, {"sha": "ebefd00c02d455c8efb0832f0ce5b45b98e798dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=40289199ee725183a286f50cf448f6347267047e", "patch": "@@ -1,3 +1,8 @@\n+2019-05-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/90402\n+\t* gcc.dg/torture/pr90402-1.c: New testcase.\n+\n 2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>\n \t    Dominique d'Humieres  <dominiq@gcc.gnu.org>\n "}, {"sha": "c4bd8945ed5c501b9951106afea4e1578efb8584", "filename": "gcc/testsuite/gcc.dg/torture/pr90402-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr90402-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr90402-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr90402-1.c?ref=40289199ee725183a286f50cf448f6347267047e", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-mavx\" { target x86_64-*-* i?86-*-* } } */\n+\n+int kn, ha;\n+\n+int\n+c7 (void)\n+{\n+}\n+\n+void\n+ul (int w3)\n+{\n+  kn = c7 ();\n+\n+  while (w3 < 1)\n+    {\n+      ha += !!kn ? 1 : w3;\n+\n+      for (kn = 0; kn < 2; ++kn)\n+\t{\n+\t}\n+\n+      ++w3;\n+    }\n+}"}, {"sha": "98566e3fd194278f858b61d0dedfb0fbdf1b472b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=40289199ee725183a286f50cf448f6347267047e", "patch": "@@ -3066,10 +3066,12 @@ tree_if_conversion (struct loop *loop, vec<gimple *> *preds)\n   ifcvt_local_dce (loop->header);\n \n   /* Perform local CSE, this esp. helps the vectorizer analysis if loads\n-     and stores are involved.\n+     and stores are involved.  CSE only the loop body, not the entry\n+     PHIs, those are to be kept in sync with the non-if-converted copy.\n      ???  We'll still keep dead stores though.  */\n   exit_bbs = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (exit_bbs, single_exit (loop)->dest->index);\n+  bitmap_set_bit (exit_bbs, loop->latch->index);\n   todo |= do_rpo_vn (cfun, loop_preheader_edge (loop), exit_bbs);\n   BITMAP_FREE (exit_bbs);\n "}, {"sha": "b4f626000dd01c759c4f11180c4029cd2a6910ff", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 96, "deletions": 68, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40289199ee725183a286f50cf448f6347267047e/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=40289199ee725183a286f50cf448f6347267047e", "patch": "@@ -5979,7 +5979,7 @@ insert_related_predicates_on_edge (enum tree_code code, tree *ops, edge pred_e)\n static unsigned\n process_bb (rpo_elim &avail, basic_block bb,\n \t    bool bb_visited, bool iterate_phis, bool iterate, bool eliminate,\n-\t    bool do_region, bitmap exit_bbs)\n+\t    bool do_region, bitmap exit_bbs, bool skip_phis)\n {\n   unsigned todo = 0;\n   edge_iterator ei;\n@@ -5990,7 +5990,8 @@ process_bb (rpo_elim &avail, basic_block bb,\n   /* If we are in loop-closed SSA preserve this state.  This is\n      relevant when called on regions from outside of FRE/PRE.  */\n   bool lc_phi_nodes = false;\n-  if (loops_state_satisfies_p (LOOP_CLOSED_SSA))\n+  if (!skip_phis\n+      && loops_state_satisfies_p (LOOP_CLOSED_SSA))\n     FOR_EACH_EDGE (e, ei, bb->preds)\n       if (e->src->loop_father != e->dest->loop_father\n \t  && flow_loop_nested_p (e->dest->loop_father,\n@@ -6011,67 +6012,68 @@ process_bb (rpo_elim &avail, basic_block bb,\n     }\n \n   /* Value-number all defs in the basic-block.  */\n-  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n-       gsi_next (&gsi))\n-    {\n-      gphi *phi = gsi.phi ();\n-      tree res = PHI_RESULT (phi);\n-      vn_ssa_aux_t res_info = VN_INFO (res);\n-      if (!bb_visited)\n-\t{\n-\t  gcc_assert (!res_info->visited);\n-\t  res_info->valnum = VN_TOP;\n-\t  res_info->visited = true;\n-\t}\n+  if (!skip_phis)\n+    for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t gsi_next (&gsi))\n+      {\n+\tgphi *phi = gsi.phi ();\n+\ttree res = PHI_RESULT (phi);\n+\tvn_ssa_aux_t res_info = VN_INFO (res);\n+\tif (!bb_visited)\n+\t  {\n+\t    gcc_assert (!res_info->visited);\n+\t    res_info->valnum = VN_TOP;\n+\t    res_info->visited = true;\n+\t  }\n \n-      /* When not iterating force backedge values to varying.  */\n-      visit_stmt (phi, !iterate_phis);\n-      if (virtual_operand_p (res))\n-\tcontinue;\n+\t/* When not iterating force backedge values to varying.  */\n+\tvisit_stmt (phi, !iterate_phis);\n+\tif (virtual_operand_p (res))\n+\t  continue;\n \n-      /* Eliminate */\n-      /* The interesting case is gcc.dg/tree-ssa/pr22230.c for correctness\n-\t how we handle backedges and availability.\n-\t And gcc.dg/tree-ssa/ssa-sccvn-2.c for optimization.  */\n-      tree val = res_info->valnum;\n-      if (res != val && !iterate && eliminate)\n-\t{\n-\t  if (tree leader = avail.eliminate_avail (bb, res))\n-\t    {\n-\t      if (leader != res\n-\t\t  /* Preserve loop-closed SSA form.  */\n-\t\t  && (! lc_phi_nodes\n-\t\t      || is_gimple_min_invariant (leader)))\n-\t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Replaced redundant PHI node \"\n-\t\t\t       \"defining \");\n-\t\t      print_generic_expr (dump_file, res);\n-\t\t      fprintf (dump_file, \" with \");\n-\t\t      print_generic_expr (dump_file, leader);\n-\t\t      fprintf (dump_file, \"\\n\");\n-\t\t    }\n-\t\t  avail.eliminations++;\n+\t/* Eliminate */\n+\t/* The interesting case is gcc.dg/tree-ssa/pr22230.c for correctness\n+\t   how we handle backedges and availability.\n+\t   And gcc.dg/tree-ssa/ssa-sccvn-2.c for optimization.  */\n+\ttree val = res_info->valnum;\n+\tif (res != val && !iterate && eliminate)\n+\t  {\n+\t    if (tree leader = avail.eliminate_avail (bb, res))\n+\t      {\n+\t\tif (leader != res\n+\t\t    /* Preserve loop-closed SSA form.  */\n+\t\t    && (! lc_phi_nodes\n+\t\t\t|| is_gimple_min_invariant (leader)))\n+\t\t  {\n+\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t      {\n+\t\t\tfprintf (dump_file, \"Replaced redundant PHI node \"\n+\t\t\t\t \"defining \");\n+\t\t\tprint_generic_expr (dump_file, res);\n+\t\t\tfprintf (dump_file, \" with \");\n+\t\t\tprint_generic_expr (dump_file, leader);\n+\t\t\tfprintf (dump_file, \"\\n\");\n+\t\t      }\n+\t\t    avail.eliminations++;\n \n-\t\t  if (may_propagate_copy (res, leader))\n-\t\t    {\n-\t\t      /* Schedule for removal.  */\n-\t\t      avail.to_remove.safe_push (phi);\n-\t\t      continue;\n-\t\t    }\n-\t\t  /* ???  Else generate a copy stmt.  */\n-\t\t}\n-\t    }\n-\t}\n-      /* Only make defs available that not already are.  But make\n-\t sure loop-closed SSA PHI node defs are picked up for\n-\t downstream uses.  */\n-      if (lc_phi_nodes\n-\t  || res == val\n-\t  || ! avail.eliminate_avail (bb, res))\n-\tavail.eliminate_push_avail (bb, res);\n-    }\n+\t\t    if (may_propagate_copy (res, leader))\n+\t\t      {\n+\t\t\t/* Schedule for removal.  */\n+\t\t\tavail.to_remove.safe_push (phi);\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    /* ???  Else generate a copy stmt.  */\n+\t\t  }\n+\t      }\n+\t  }\n+\t/* Only make defs available that not already are.  But make\n+\t   sure loop-closed SSA PHI node defs are picked up for\n+\t   downstream uses.  */\n+\tif (lc_phi_nodes\n+\t    || res == val\n+\t    || ! avail.eliminate_avail (bb, res))\n+\t  avail.eliminate_push_avail (bb, res);\n+      }\n \n   /* For empty BBs mark outgoing edges executable.  For non-empty BBs\n      we do this when processing the last stmt as we have to do this\n@@ -6415,6 +6417,13 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n       bitmap_set_bit (exit_bbs, EXIT_BLOCK);\n     }\n \n+  /* Clear EDGE_DFS_BACK on \"all\" entry edges, RPO order compute will\n+     re-mark those that are contained in the region.  */\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, entry->dest->preds)\n+    e->flags &= ~EDGE_DFS_BACK;\n+\n   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fn) - NUM_FIXED_BLOCKS);\n   int n = rev_post_order_and_mark_dfs_back_seme\n     (fn, entry, exit_bbs, !loops_state_satisfies_p (LOOPS_NEED_FIXUP), rpo);\n@@ -6425,6 +6434,18 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n   if (!do_region)\n     BITMAP_FREE (exit_bbs);\n \n+  /* If there are any non-DFS_BACK edges into entry->dest skip\n+     processing PHI nodes for that block.  This supports\n+     value-numbering loop bodies w/o the actual loop.  */\n+  FOR_EACH_EDGE (e, ei, entry->dest->preds)\n+    if (e != entry\n+\t&& !(e->flags & EDGE_DFS_BACK))\n+      break;\n+  bool skip_entry_phis = e != NULL;\n+  if (skip_entry_phis && dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Region does not contain all edges into \"\n+\t     \"the entry block, skipping its PHIs.\\n\");\n+\n   int *bb_to_rpo = XNEWVEC (int, last_basic_block_for_fn (fn));\n   for (int i = 0; i < n; ++i)\n     bb_to_rpo[rpo[i]] = i;\n@@ -6454,7 +6475,9 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \t  edge e;\n \t  edge_iterator ei;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n-\t    gcc_assert (e == entry || (e->src->flags & bb_in_region));\n+\t    gcc_assert (e == entry\n+\t\t\t|| (skip_entry_phis && bb == entry->dest)\n+\t\t\t|| (e->src->flags & bb_in_region));\n \t}\n       for (int i = 0; i < n; ++i)\n \t{\n@@ -6499,7 +6522,7 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \t  if (e->flags & EDGE_DFS_BACK)\n \t    has_backedges = true;\n \t  e->flags &= ~EDGE_EXECUTABLE;\n-\t  if (iterate || e == entry)\n+\t  if (iterate || e == entry || (skip_entry_phis && bb == entry->dest))\n \t    continue;\n \t  if (bb_to_rpo[e->src->index] > i)\n \t    {\n@@ -6532,7 +6555,7 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \t  edge_iterator ei;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n-\t      if (e == entry)\n+\t      if (e == entry || (skip_entry_phis && bb == entry->dest))\n \t\tcontinue;\n \t      int max_rpo = MAX (rpo_state[i].max_rpo,\n \t\t\t\t rpo_state[bb_to_rpo[e->src->index]].max_rpo);\n@@ -6621,7 +6644,7 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \ttodo |= process_bb (avail, bb,\n \t\t\t    rpo_state[idx].visited != 0,\n \t\t\t    rpo_state[idx].iterate,\n-\t\t\t    iterate, eliminate, do_region, exit_bbs);\n+\t\t\t    iterate, eliminate, do_region, exit_bbs, false);\n \trpo_state[idx].visited++;\n \n \t/* Verify if changed values flow over executable outgoing backedges\n@@ -6719,8 +6742,10 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \t  edge e;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    if (!(e->flags & EDGE_EXECUTABLE)\n-\t\t&& !rpo_state[bb_to_rpo[e->src->index]].visited\n-\t\t&& rpo_state[bb_to_rpo[e->src->index]].max_rpo >= (int)idx)\n+\t\t&& (bb == entry->dest\n+\t\t    || (!rpo_state[bb_to_rpo[e->src->index]].visited\n+\t\t\t&& (rpo_state[bb_to_rpo[e->src->index]].max_rpo\n+\t\t\t    >= (int)idx))))\n \t      {\n \t\tif (dump_file && (dump_flags & TDF_DETAILS))\n \t\t  fprintf (dump_file, \"Cannot trust state of predecessor \"\n@@ -6731,7 +6756,8 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n \n \t  nblk++;\n \t  todo |= process_bb (avail, bb, false, false, false, eliminate,\n-\t\t\t      do_region, exit_bbs);\n+\t\t\t      do_region, exit_bbs,\n+\t\t\t      skip_entry_phis && bb == entry->dest);\n \t  rpo_state[idx].visited++;\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -6813,7 +6839,9 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n }\n \n /* Region-based entry for RPO VN.  Performs value-numbering and elimination\n-   on the SEME region specified by ENTRY and EXIT_BBS.  */\n+   on the SEME region specified by ENTRY and EXIT_BBS.  If ENTRY is not\n+   the only edge into the region at ENTRY->dest PHI nodes in ENTRY->dest\n+   are not considered.  */\n \n unsigned\n do_rpo_vn (function *fn, edge entry, bitmap exit_bbs)"}]}