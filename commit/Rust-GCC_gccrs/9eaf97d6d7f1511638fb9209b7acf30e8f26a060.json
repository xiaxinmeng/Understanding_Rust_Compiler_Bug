{"sha": "9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVhZjk3ZDZkN2YxNTExNjM4ZmI5MjA5YjdhY2YzMGU4ZjI2YTA2MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-26T16:12:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-26T16:12:09Z"}, "message": "Make more use of df_read_modify_subreg_p\n\nThis patch uses df_read_modify_subreg_p to check whether writing\nto a subreg would preserve some of the existing contents.\n\nThis has the effect of putting more emphasis on the\nREGMODE_NATURAL_SIZE-based definition of whether something can be\npartially modified, instead of using UNITS_PER_WORD unconditionally.\nThis becomes important for SVE, where UNITS_PER_WORD has no\nsignificance for subregs of multi-register LD2/ST2, LD3/ST3 and\nLD4/ST4 tuples.\n\n2017-10-26  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* caller-save.c (mark_referenced_regs):  Use read_modify_subreg_p.\n\t* combine.c (find_single_use_1): Likewise.\n\t(expand_field_assignment): Likewise.\n\t(move_deaths): Likewise.\n\t* lra-constraints.c (simplify_operand_subreg): Likewise.\n\t(curr_insn_transform): Likewise.\n\t* lra.c (collect_non_operand_hard_regs): Likewise.\n\t(add_regs_to_insn_regno_info): Likewise.\n\t* rtlanal.c (reg_referenced_p): Likewise.\n\t(covers_regno_no_parallel_p): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254110", "tree": {"sha": "16674acba1f8fe4ba22347b1846ccdecf4c4d541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16674acba1f8fe4ba22347b1846ccdecf4c4d541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/comments", "author": null, "committer": null, "parents": [{"sha": "7984457f8295811880c37e7861aa7c0454ce9845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7984457f8295811880c37e7861aa7c0454ce9845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7984457f8295811880c37e7861aa7c0454ce9845"}], "stats": {"total": 78, "additions": 34, "deletions": 44}, "files": [{"sha": "4d5c9d2c66a2a98e04d096d469b39be016a6f01c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "patch": "@@ -1,3 +1,18 @@\n+2017-10-26  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* caller-save.c (mark_referenced_regs):  Use read_modify_subreg_p.\n+\t* combine.c (find_single_use_1): Likewise.\n+\t(expand_field_assignment): Likewise.\n+\t(move_deaths): Likewise.\n+\t* lra-constraints.c (simplify_operand_subreg): Likewise.\n+\t(curr_insn_transform): Likewise.\n+\t* lra.c (collect_non_operand_hard_regs): Likewise.\n+\t(add_regs_to_insn_regno_info): Likewise.\n+\t* rtlanal.c (reg_referenced_p): Likewise.\n+\t(covers_regno_no_parallel_p): Likewise.\n+\n 2017-10-26  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* wide-int-print.cc (print_hex): Loop based on extract_uhwi."}, {"sha": "576a023b8a376a421880391b2fce2874270d4927", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "patch": "@@ -1034,10 +1034,7 @@ mark_referenced_regs (rtx *loc, refmarker_fn *mark, void *arg)\n \t      /* If we're setting only part of a multi-word register,\n \t\t we shall mark it as referenced, because the words\n \t\t that are not being set should be restored.  */\n-\t      && ((GET_MODE_SIZE (GET_MODE (*loc))\n-\t\t   >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (*loc))))\n-\t\t  || (GET_MODE_SIZE (GET_MODE (SUBREG_REG (*loc)))\n-\t\t      <= UNITS_PER_WORD))))\n+\t      && !read_modify_subreg_p (*loc)))\n \treturn;\n     }\n   if (code == MEM || code == SUBREG)"}, {"sha": "93adfc11be749fba7fecc9b06cf72c57553dbdf2", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "patch": "@@ -579,10 +579,7 @@ find_single_use_1 (rtx dest, rtx *loc)\n \t  && !REG_P (SET_DEST (x))\n \t  && ! (GET_CODE (SET_DEST (x)) == SUBREG\n \t\t&& REG_P (SUBREG_REG (SET_DEST (x)))\n-\t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n-\t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n-\t\t\t + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))))\n+\t\t&& !read_modify_subreg_p (SET_DEST (x))))\n \tbreak;\n \n       return find_single_use_1 (dest, &SET_SRC (x));\n@@ -7361,15 +7358,12 @@ expand_field_assignment (const_rtx x)\n \t    }\n \t}\n \n-      /* A SUBREG between two modes that occupy the same numbers of words\n-\t can be done by moving the SUBREG to the source.  */\n+      /* If the destination is a subreg that overwrites the whole of the inner\n+\t register, we can move the subreg to the source.  */\n       else if (GET_CODE (SET_DEST (x)) == SUBREG\n \t       /* We need SUBREGs to compute nonzero_bits properly.  */\n \t       && nonzero_sign_valid\n-\t       && (((GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n-\t\t     + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\t\t   == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n-\t\t\t+ (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n+\t       && !read_modify_subreg_p (SET_DEST (x)))\n \t{\n \t  x = gen_rtx_SET (SUBREG_REG (SET_DEST (x)),\n \t\t\t   gen_lowpart\n@@ -13993,10 +13987,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_luid, rtx_insn *to_insn,\n       if (GET_CODE (dest) == ZERO_EXTRACT\n \t  || GET_CODE (dest) == STRICT_LOW_PART\n \t  || (GET_CODE (dest) == SUBREG\n-\t      && (((GET_MODE_SIZE (GET_MODE (dest))\n-\t\t    + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\t\t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n-\t\t       + UNITS_PER_WORD - 1) / UNITS_PER_WORD))))\n+\t      && !read_modify_subreg_p (dest)))\n \t{\n \t  move_deaths (dest, maybe_kill_insn, from_luid, to_insn, pnotes);\n \t  return;"}, {"sha": "c3bbfd7151fb12fc67c6e227b1602ef014c38142", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "patch": "@@ -1679,7 +1679,7 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n \n \t  insert_before = (type != OP_OUT\n-\t\t\t   || GET_MODE_SIZE (innermode) > GET_MODE_SIZE (mode));\n+\t\t\t   || read_modify_subreg_p (operand));\n \t  insert_after = (type != OP_IN);\n \t  insert_move_for_subreg (insert_before ? &before : NULL,\n \t\t\t\t  insert_after ? &after : NULL,\n@@ -4232,9 +4232,7 @@ curr_insn_transform (bool check_only_p)\n \t\t     constraints.  */\n \t\t  if (type == OP_OUT\n \t\t      && (curr_static_id->operand[i].strict_low\n-\t\t\t  || (GET_MODE_SIZE (GET_MODE (reg)) > UNITS_PER_WORD\n-\t\t\t      && (GET_MODE_SIZE (mode)\n-\t\t\t\t  < GET_MODE_SIZE (GET_MODE (reg))))))\n+\t\t\t  || read_modify_subreg_p (*loc)))\n \t\t    type = OP_INOUT;\n \t\t  loc = &SUBREG_REG (*loc);\n \t\t  mode = GET_MODE (*loc);"}, {"sha": "04acf884f1cadd31e0341b03bb7dbd7a31b130b1", "filename": "gcc/lra.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "patch": "@@ -832,14 +832,12 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n   subreg_p = false;\n   if (code == SUBREG)\n     {\n+      if (read_modify_subreg_p (op))\n+\tsubreg_p = true;\n       op = SUBREG_REG (op);\n       code = GET_CODE (op);\n       if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (op)))\n-\t{\n-\t  mode = GET_MODE (op);\n-\t  if (GET_MODE_SIZE (mode) > REGMODE_NATURAL_SIZE (mode))\n-\t    subreg_p = true;\n-\t}\n+\tmode = GET_MODE (op);\n     }\n   if (REG_P (op))\n     {\n@@ -1427,14 +1425,12 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n   subreg_p = false;\n   if (GET_CODE (x) == SUBREG)\n     {\n+      if (read_modify_subreg_p (x))\n+\tsubreg_p = true;\n       x = SUBREG_REG (x);\n       code = GET_CODE (x);\n       if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x)))\n-\t{\n-\t  mode = GET_MODE (x);\n-\t  if (GET_MODE_SIZE (mode) > REGMODE_NATURAL_SIZE (mode))\n-\t    subreg_p = true;\n-\t}\n+\tmode = GET_MODE (x);\n     }\n   if (REG_P (x))\n     {"}, {"sha": "beb24ba573c1176fb8e6debf00d17f3d4ad507e4", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eaf97d6d7f1511638fb9209b7acf30e8f26a060/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=9eaf97d6d7f1511638fb9209b7acf30e8f26a060", "patch": "@@ -1124,10 +1124,7 @@ reg_referenced_p (const_rtx x, const_rtx body)\n \t  && !REG_P (SET_DEST (body))\n \t  && ! (GET_CODE (SET_DEST (body)) == SUBREG\n \t\t&& REG_P (SUBREG_REG (SET_DEST (body)))\n-\t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (body))))\n-\t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (body)))\n-\t\t\t + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n+\t\t&& !read_modify_subreg_p (SET_DEST (body)))\n \t  && reg_overlap_mentioned_p (x, SET_DEST (body)))\n \treturn 1;\n       return 0;\n@@ -2017,20 +2014,16 @@ dead_or_set_p (const rtx_insn *insn, const_rtx x)\n   return 1;\n }\n \n-/* Return TRUE iff DEST is a register or subreg of a register and\n-   doesn't change the number of words of the inner register, and any\n-   part of the register is TEST_REGNO.  */\n+/* Return TRUE iff DEST is a register or subreg of a register, is a\n+   complete rather than read-modify-write destination, and contains\n+   register TEST_REGNO.  */\n \n static bool\n covers_regno_no_parallel_p (const_rtx dest, unsigned int test_regno)\n {\n   unsigned int regno, endregno;\n \n-  if (GET_CODE (dest) == SUBREG\n-      && (((GET_MODE_SIZE (GET_MODE (dest))\n-\t    + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n-\t       + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n+  if (GET_CODE (dest) == SUBREG && !read_modify_subreg_p (dest))\n     dest = SUBREG_REG (dest);\n \n   if (!REG_P (dest))"}]}