{"sha": "68f0213570062f6d576ea274e8fef99689b88ad4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhmMDIxMzU3MDA2MmY2ZDU3NmVhMjc0ZThmZWY5OTY4OWI4OGFkNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-20T13:04:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-20T13:04:28Z"}, "message": "(last_setjmp_suid, regs_crosses_setjmp): New variables.\n\n(stupid_life_analysis, stupid_mark_refs): Use them to track which\nregs are live over a setjmp; don't allocate such regs.\n\nFrom-SVN: r11573", "tree": {"sha": "9ba21bcb4d67ed212b4f70d9c075a93a80b0e31b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ba21bcb4d67ed212b4f70d9c075a93a80b0e31b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68f0213570062f6d576ea274e8fef99689b88ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f0213570062f6d576ea274e8fef99689b88ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f0213570062f6d576ea274e8fef99689b88ad4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f0213570062f6d576ea274e8fef99689b88ad4/comments", "author": null, "committer": null, "parents": [{"sha": "ba9d9bfa1c53e9ef319a84279e213ded7844d4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9d9bfa1c53e9ef319a84279e213ded7844d4e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9d9bfa1c53e9ef319a84279e213ded7844d4e5"}], "stats": {"total": 25, "additions": 23, "deletions": 2}, "files": [{"sha": "f8fc9d9d605d4d40bf38c10a5549c6d7ca4e0f67", "filename": "gcc/stupid.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f0213570062f6d576ea274e8fef99689b88ad4/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f0213570062f6d576ea274e8fef99689b88ad4/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=68f0213570062f6d576ea274e8fef99689b88ad4", "patch": "@@ -65,6 +65,11 @@ static int *uid_suid;\n \n static int last_call_suid;\n \n+/* Record the suid of the last NOTE_INSN_SETJMP\n+   so we can tell whether a pseudo reg crosses any setjmp.  */\n+\n+static int last_setjmp_suid;\n+\n /* Element N is suid of insn where life span of pseudo reg N ends.\n    Element is  0 if register N has not been seen yet on backward scan.  */\n \n@@ -88,6 +93,10 @@ static char *regs_live;\n \n static char *regs_change_size;\n \n+/* Indexed by reg number, nonzero if reg crosses a setjmp.  */\n+\n+static char *regs_crosses_setjmp;\n+\n /* Indexed by insn's suid, the set of hard regs live after that insn.  */\n \n static HARD_REG_SET *after_insn_hard_regs;\n@@ -148,6 +157,7 @@ stupid_life_analysis (f, nregs, file)\n     }\n \n   last_call_suid = i + 1;\n+  last_setjmp_suid = i + 1;\n   max_suid = i + 1;\n \n   max_regno = nregs;\n@@ -166,6 +176,9 @@ stupid_life_analysis (f, nregs, file)\n   regs_change_size = (char *) alloca (nregs * sizeof (char));\n   bzero ((char *) regs_change_size, nregs * sizeof (char));\n \n+  regs_crosses_setjmp = (char *) alloca (nregs * sizeof (char));\n+  bzero ((char *) regs_crosses_setjmp, nregs * sizeof (char));\n+\n   reg_renumber = (short *) oballoc (nregs * sizeof (short));\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_renumber[i] = i;\n@@ -215,6 +228,10 @@ stupid_life_analysis (f, nregs, file)\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \tstupid_mark_refs (PATTERN (insn), insn);\n \n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+\tlast_setjmp_suid = INSN_SUID (insn);\n+\n       /* Mark all call-clobbered regs as live after each call insn\n \t so that a pseudo whose life span includes this insn\n \t will not go in one of them.\n@@ -253,8 +270,9 @@ stupid_life_analysis (f, nregs, file)\n     {\n       register int r = reg_order[i];\n \n-      /* Some regnos disappear from the rtl.  Ignore them to avoid crash.  */\n-      if (regno_reg_rtx[r] == 0)\n+      /* Some regnos disappear from the rtl.  Ignore them to avoid crash. \n+\t Also don't allocate registers that cross a setjmp.  */\n+      if (regno_reg_rtx[r] == 0 || regs_crosses_setjmp[r])\n \tcontinue;\n \n       /* Now find the best hard-register class for this pseudo register */\n@@ -494,6 +512,9 @@ stupid_mark_refs (x, insn)\n \n \t      if (last_call_suid < reg_where_dead[regno])\n \t\treg_n_calls_crossed[regno] += 1;\n+\n+\t      if (last_setjmp_suid < reg_where_dead[regno])\n+\t\tregs_crosses_setjmp[regno] = 1;\n \t    }\n \t}\n "}]}