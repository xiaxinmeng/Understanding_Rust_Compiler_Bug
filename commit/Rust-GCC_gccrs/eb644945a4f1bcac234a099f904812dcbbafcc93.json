{"sha": "eb644945a4f1bcac234a099f904812dcbbafcc93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2NDQ5NDVhNGYxYmNhYzIzNGEwOTlmOTA0ODEyZGNiYmFmY2M5Mw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-10-11T14:11:02Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:15Z"}, "message": "Added cfg stripping code (will top-level strip currently)\n\nRearranged order of definitions in rust-ast.h, should fix compile error\n\nAttempted error fix for Attribute-AttrInput interaction and Crate stripping\n\nFixed constructor arguments for MacroExpander", "tree": {"sha": "5343707ddba956043cd3cf3a69ecbde605399625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5343707ddba956043cd3cf3a69ecbde605399625"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb644945a4f1bcac234a099f904812dcbbafcc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb644945a4f1bcac234a099f904812dcbbafcc93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb644945a4f1bcac234a099f904812dcbbafcc93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb644945a4f1bcac234a099f904812dcbbafcc93/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "423462fb6785896c8031319d50ac38fbca3afb51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423462fb6785896c8031319d50ac38fbca3afb51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/423462fb6785896c8031319d50ac38fbca3afb51"}], "stats": {"total": 320, "additions": 184, "deletions": 136}, "files": [{"sha": "e2696452c71f50cc3d6c573cdd09d40eea4a00c5", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=eb644945a4f1bcac234a099f904812dcbbafcc93", "patch": "@@ -171,13 +171,29 @@ Attribute::as_string () const\n {\n   std::string path_str = path.as_string ();\n   if (attr_input == nullptr)\n-    {\n       return path_str;\n-    }\n   else\n-    {\n       return path_str + attr_input->as_string ();\n-    }\n+}\n+\n+// Copy constructor must deep copy attr_input as unique pointer\n+Attribute::Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n+{\n+  // guard to protect from null pointer dereference\n+  if (other.attr_input != nullptr)\n+    attr_input = other.attr_input->clone_attr_input ();\n+}\n+\n+// overload assignment operator to use custom clone method\n+Attribute &Attribute::operator= (Attribute const &other)\n+{\n+  path = other.path;\n+  locus = other.locus;\n+  // guard to protect from null pointer dereference\n+  if (other.attr_input != nullptr)\n+    attr_input = other.attr_input->clone_attr_input ();\n+\n+  return *this;\n }\n \n std::string"}, {"sha": "90e3504c04dae0d655c0bd12fbb9b43fb841f3fb", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 138, "deletions": 121, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=eb644945a4f1bcac234a099f904812dcbbafcc93", "patch": "@@ -62,34 +62,6 @@ Location?\n };*/\n // decided to not have node as a \"node\" would never need to be stored\n \n-// Attribute body - abstract base class\n-class AttrInput\n-{\n-public:\n-  virtual ~AttrInput () {}\n-\n-  // Unique pointer custom clone function\n-  std::unique_ptr<AttrInput> clone_attr_input () const\n-  {\n-    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n-  }\n-\n-  virtual std::string as_string () const = 0;\n-\n-  virtual void accept_vis (ASTVisitor &vis) = 0;\n-\n-  virtual bool check_cfg_predicate (const Session &session) const = 0;\n-\n-  // Parse attribute input to meta item, if possible\n-  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n-\n-  virtual std::vector<Attribute> separate_cfg_attrs () const { return {}; }\n-\n-protected:\n-  // pure virtual clone implementation\n-  virtual AttrInput *clone_attr_input_impl () const = 0;\n-};\n-\n // forward decl for use in token tree method\n class Token;\n \n@@ -281,95 +253,6 @@ struct Literal\n   bool is_error () const { return value_as_string == \"\"; }\n };\n \n-// A token tree with delimiters\n-class DelimTokenTree : public TokenTree, public AttrInput\n-{\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree>> token_trees;\n-  Location locus;\n-\n-protected:\n-  DelimTokenTree *clone_delim_tok_tree_impl () const\n-  {\n-    return new DelimTokenTree (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_attr_input_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_token_tree_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-public:\n-  DelimTokenTree (DelimType delim_type,\n-\t\t  std::vector<std::unique_ptr<TokenTree>> token_trees\n-\t\t  = std::vector<std::unique_ptr<TokenTree>> (),\n-\t\t  Location locus = Location ())\n-    : delim_type (delim_type), token_trees (std::move (token_trees)),\n-      locus (locus)\n-  {}\n-\n-  // Copy constructor with vector clone\n-  DelimTokenTree (DelimTokenTree const &other)\n-    : delim_type (other.delim_type), locus (other.locus)\n-  {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-  }\n-\n-  // overloaded assignment operator with vector clone\n-  DelimTokenTree &operator= (DelimTokenTree const &other)\n-  {\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n-\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  DelimTokenTree (DelimTokenTree &&other) = default;\n-  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n-\n-  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  bool\n-  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n-  {\n-    // this should never be called - should be converted first\n-    return false;\n-  }\n-\n-  AttrInput *parse_to_meta_item () const override;\n-\n-  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n-\n-  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n-  {\n-    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n-  }\n-};\n-\n-/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n- * be defined */\n-class AttrInputLiteral;\n-\n /* TODO: move applicable stuff into here or just don't include it because\n  * nothing uses it A segment of a path (maybe) */\n class PathSegment\n@@ -462,6 +345,9 @@ class SimplePath\n   }\n };\n \n+// forward decl for Attribute\n+class AttrInput;\n+\n // aka Attr\n // Attribute AST representation\n struct Attribute\n@@ -490,15 +376,17 @@ struct Attribute\n   ~Attribute () = default;\n \n   // Copy constructor must deep copy attr_input as unique pointer\n-  Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n+  /*Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n   {\n     // guard to protect from null pointer dereference\n     if (other.attr_input != nullptr)\n       attr_input = other.attr_input->clone_attr_input ();\n-  }\n+  }*/\n+  // no point in being defined inline as requires virtual call anyway\n+  Attribute (const Attribute &other);\n \n   // overload assignment operator to use custom clone method\n-  Attribute &operator= (Attribute const &other)\n+  /*Attribute &operator= (Attribute const &other)\n   {\n     path = other.path;\n     locus = other.locus;\n@@ -507,7 +395,9 @@ struct Attribute\n       attr_input = other.attr_input->clone_attr_input ();\n \n     return *this;\n-  }\n+  }*/\n+  // no point in being defined inline as requires virtual call anyway\n+  Attribute &operator= (const Attribute &other);\n \n   // default move semantics\n   Attribute (Attribute &&other) = default;\n@@ -604,6 +494,123 @@ struct Attribute\n   }\n };\n \n+// Attribute body - abstract base class\n+class AttrInput\n+{\n+public:\n+  virtual ~AttrInput () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<AttrInput> clone_attr_input () const\n+  {\n+    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual bool check_cfg_predicate (const Session &session) const = 0;\n+\n+  // Parse attribute input to meta item, if possible\n+  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n+\n+  virtual std::vector<Attribute> separate_cfg_attrs () const { return {}; }\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual AttrInput *clone_attr_input_impl () const = 0;\n+};\n+\n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree>> token_trees;\n+  Location locus;\n+\n+protected:\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  std::vector<std::unique_ptr<TokenTree>> token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree>> (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool\n+  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n+  {\n+    // this should never be called - should be converted first\n+    return false;\n+  }\n+\n+  AttrInput *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n+\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n+};\n+\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n // Forward decl - defined in rust-macro.h\n class MetaNameValueStr;\n \n@@ -1452,6 +1459,16 @@ struct Crate\n \n   // Get crate representation as string (e.g. for debugging).\n   std::string as_string () const;\n+\n+  // Delete all crate information, e.g. if fails cfg.\n+  void strip_crate () {\n+    inner_attrs.clear ();\n+    inner_attrs.shrink_to_fit ();\n+\n+    items.clear ();\n+    items.shrink_to_fit ();\n+    // TODO: is this the best way to do this? \n+  }\n };\n \n // Base path expression AST node - abstract"}, {"sha": "4a39be3e68930472ce11bb59a7113db937808c79", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=eb644945a4f1bcac234a099f904812dcbbafcc93", "patch": "@@ -24,24 +24,31 @@ namespace Rust {\n             - derive container macro - unreachable*/\n     }\n \n-    /* Determines whether cfg predicate is true and item with attribute should not\n-     * be stripped. TODO can this be const reference or does it have to mutate? */\n-    bool MacroExpander::check_cfg(AST::Attribute& attr) {}\n+    /* Determines whether any cfg predicate is false and hence item with attributes should \n+     * be stripped.  */\n+    bool MacroExpander::fails_cfg(std::vector<AST::Attribute>& attrs) {\n+        for (auto& attr : attrs) {\n+            if (attr.get_path() == \"cfg\" && !attr.check_cfg_predicate(session))\n+                return true;\n+        }\n+        return false;\n+    }\n \n     // Expands cfg_attr attributes.\n     void MacroExpander::expand_cfg_attrs(std::vector<AST::Attribute>& attrs) {\n-        for (int i = 0; i < attrs.size (); ) {\n+        for (int i = 0; i < attrs.size();) {\n             auto& attr = attrs[i];\n             if (attr.get_path() == \"cfg_attr\") {\n-                if (attr.check_cfg_predicate (session)) {\n+                if (attr.check_cfg_predicate(session)) {\n                     // split off cfg_attr\n-                    std::vector<AST::Attribute> new_attrs = attr.separate_cfg_attrs ();\n+                    std::vector<AST::Attribute> new_attrs = attr.separate_cfg_attrs();\n \n                     // remove attr from vector\n-                    attrs.erase (attrs.begin () + i);\n+                    attrs.erase(attrs.begin() + i);\n \n                     // add new attrs to vector\n-                    attrs.insert (attrs.begin() + i, std::make_move_iterator (new_attrs.begin ()), std::make_move_iterator (new_attrs.end ()));\n+                    attrs.insert(attrs.begin() + i, std::make_move_iterator(new_attrs.begin()),\n+                      std::make_move_iterator(new_attrs.end()));\n                 }\n \n                 /* do something - if feature (first token in tree) is in fact enabled,\n@@ -54,16 +61,24 @@ namespace Rust {\n                 i++;\n             }\n         }\n-        attrs.shrink_to_fit ();\n+        attrs.shrink_to_fit();\n     }\n \n     void MacroExpander::expand_crate() {\n         /* fill macro/decorator map from init list? not sure where init list comes\n          * from? */\n \n+        // TODO: does cfg apply for inner attributes? research.\n+        // the apparent answer (from playground test) is yes\n+\n         // expand crate cfg_attr attributes\n         expand_cfg_attrs(crate.inner_attrs);\n \n+        if (fails_cfg(crate.inner_attrs)) {\n+            // basically, delete whole crate\n+            crate.strip_crate();\n+            // TODO: maybe create warning here? probably not desired behaviour\n+        }\n         // expand module attributes?\n \n         // expand module tree recursively"}, {"sha": "a7fe0765031d560cbc6c86ddc1580524e34e77ad", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=eb644945a4f1bcac234a099f904812dcbbafcc93", "patch": "@@ -41,7 +41,7 @@ struct MacroExpander\n   void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n   void expand_cfg_attrs(std::vector<AST::Attribute>& attrs);\n-  bool check_cfg(AST::Attribute& attr);\n+  bool fails_cfg(std::vector<AST::Attribute>& attr);\n \n   /* TODO: make it extend ASTVisitor so that individual items can be accessed\n    * properly? */"}, {"sha": "7940df781182ecc75d8fc8383bf00029fec02a7b", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb644945a4f1bcac234a099f904812dcbbafcc93/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=eb644945a4f1bcac234a099f904812dcbbafcc93", "patch": "@@ -715,7 +715,7 @@ Session::expansion (AST::Crate &crate)\n   // create extctxt? from parse session, cfg, and resolver?\n   /* expand by calling cxtctxt object's monotonic_expander's expand_crate\n    * method. */\n-  MacroExpander expander (crate, cfg);\n+  MacroExpander expander (crate, cfg, *this);\n   expander.expand_crate ();\n \n   // error reporting - check unused macros, get missing fragment specifiers"}]}