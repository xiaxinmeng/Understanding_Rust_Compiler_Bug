{"sha": "4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGViOGY5M2QwMjZlYWExZGU5YjQ4MjAzMzcwNjlmM2NlMzQ2NWNkMA==", "commit": {"author": {"name": "Roman Zhuykov", "email": "zhroma@ispras.ru", "date": "2020-12-05T15:45:27Z"}, "committer": {"name": "Roman Zhuykov", "email": "zhroma@ispras.ru", "date": "2020-12-05T15:45:27Z"}, "message": "modulo-sched: Carefully process loop counter initialization [PR97421]\n\nDo not allow direct adjustment of pre-header initialization instruction for\ncount register if is read in some instruction below in that basic block.\n\ngcc/ChangeLog:\n\n\tPR rtl-optimization/97421\n\t* modulo-sched.c (generate_prolog_epilog): Remove forward\n\tdeclaration, adjust last argument name and type.\n\t(const_iteration_count): Add bool pointer parameter to return\n\twhether count register is read in pre-header after its\n\tinitialization.\n\t(sms_schedule): Fix count register initialization adjustment\n\tprocedure according to what const_iteration_count said.\n\ngcc/testsuite/ChangeLog:\n\n\tPR rtl-optimization/97421\n\t* gcc.c-torture/execute/pr97421-1.c: New test.\n\t* gcc.c-torture/execute/pr97421-2.c: New test.\n\t* gcc.c-torture/execute/pr97421-3.c: New test.", "tree": {"sha": "634fd95b9a60f6e2a837980a61318d109a29605a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/634fd95b9a60f6e2a837980a61318d109a29605a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/comments", "author": {"login": "zhroma", "id": 23097573, "node_id": "MDQ6VXNlcjIzMDk3NTcz", "avatar_url": "https://avatars.githubusercontent.com/u/23097573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhroma", "html_url": "https://github.com/zhroma", "followers_url": "https://api.github.com/users/zhroma/followers", "following_url": "https://api.github.com/users/zhroma/following{/other_user}", "gists_url": "https://api.github.com/users/zhroma/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhroma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhroma/subscriptions", "organizations_url": "https://api.github.com/users/zhroma/orgs", "repos_url": "https://api.github.com/users/zhroma/repos", "events_url": "https://api.github.com/users/zhroma/events{/privacy}", "received_events_url": "https://api.github.com/users/zhroma/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zhroma", "id": 23097573, "node_id": "MDQ6VXNlcjIzMDk3NTcz", "avatar_url": "https://avatars.githubusercontent.com/u/23097573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhroma", "html_url": "https://github.com/zhroma", "followers_url": "https://api.github.com/users/zhroma/followers", "following_url": "https://api.github.com/users/zhroma/following{/other_user}", "gists_url": "https://api.github.com/users/zhroma/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhroma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhroma/subscriptions", "organizations_url": "https://api.github.com/users/zhroma/orgs", "repos_url": "https://api.github.com/users/zhroma/repos", "events_url": "https://api.github.com/users/zhroma/events{/privacy}", "received_events_url": "https://api.github.com/users/zhroma/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ae210d5db5eb96989b2f639e65678b5597e61f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ae210d5db5eb96989b2f639e65678b5597e61f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ae210d5db5eb96989b2f639e65678b5597e61f0"}], "stats": {"total": 134, "additions": 103, "deletions": 31}, "files": [{"sha": "4568674aa6c58f0edf71672120239159ee37c2b8", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "patch": "@@ -210,8 +210,6 @@ static int sms_order_nodes (ddg_ptr, int, int *, int *);\n static void set_node_sched_params (ddg_ptr);\n static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);\n static void permute_partial_schedule (partial_schedule_ptr, rtx_insn *);\n-static void generate_prolog_epilog (partial_schedule_ptr, class loop *,\n-                                    rtx, rtx);\n static int calculate_stage_count (partial_schedule_ptr, int);\n static void calculate_must_precede_follow (ddg_node_ptr, int, int,\n \t\t\t\t\t   int, int, sbitmap, sbitmap, sbitmap);\n@@ -391,30 +389,40 @@ doloop_register_get (rtx_insn *head, rtx_insn *tail)\n    this constant.  Otherwise return 0.  */\n static rtx_insn *\n const_iteration_count (rtx count_reg, basic_block pre_header,\n-\t\t       int64_t * count)\n+\t\t       int64_t *count, bool* adjust_inplace)\n {\n   rtx_insn *insn;\n   rtx_insn *head, *tail;\n \n+  *adjust_inplace = false;\n+  bool read_after = false;\n+\n   if (! pre_header)\n     return NULL;\n \n   get_ebb_head_tail (pre_header, pre_header, &head, &tail);\n \n   for (insn = tail; insn != PREV_INSN (head); insn = PREV_INSN (insn))\n-    if (NONDEBUG_INSN_P (insn) && single_set (insn) &&\n-\trtx_equal_p (count_reg, SET_DEST (single_set (insn))))\n+    if (single_set (insn) && rtx_equal_p (count_reg,\n+\t\t\t\t\t  SET_DEST (single_set (insn))))\n       {\n \trtx pat = single_set (insn);\n \n \tif (CONST_INT_P (SET_SRC (pat)))\n \t  {\n \t    *count = INTVAL (SET_SRC (pat));\n+\t    *adjust_inplace = !read_after;\n \t    return insn;\n \t  }\n \n \treturn NULL;\n       }\n+    else if (NONDEBUG_INSN_P (insn) && reg_mentioned_p (count_reg, insn))\n+      {\n+\tread_after = true;\n+\tif (reg_set_p (count_reg, insn))\n+\t   break;\n+      }\n \n   return NULL;\n }\n@@ -1126,7 +1134,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n /* Generate the instructions (including reg_moves) for prolog & epilog.  */\n static void\n generate_prolog_epilog (partial_schedule_ptr ps, class loop *loop,\n-                        rtx count_reg, rtx count_init)\n+\t\t\trtx count_reg, bool adjust_init)\n {\n   int i;\n   int last_stage = PS_STAGE_COUNT (ps) - 1;\n@@ -1135,12 +1143,12 @@ generate_prolog_epilog (partial_schedule_ptr ps, class loop *loop,\n   /* Generate the prolog, inserting its insns on the loop-entry edge.  */\n   start_sequence ();\n \n-  if (!count_init)\n+  if (adjust_init)\n     {\n       /* Generate instructions at the beginning of the prolog to\n-         adjust the loop count by STAGE_COUNT.  If loop count is constant\n-         (count_init), this constant is adjusted by STAGE_COUNT in\n-         generate_prolog_epilog function.  */\n+\t adjust the loop count by STAGE_COUNT.  If loop count is constant\n+\t and it not used anywhere in prologue, this constant is adjusted by\n+\t STAGE_COUNT outside of generate_prolog_epilog function.  */\n       rtx sub_reg = NULL_RTX;\n \n       sub_reg = expand_simple_binop (GET_MODE (count_reg), MINUS, count_reg,\n@@ -1528,7 +1536,8 @@ sms_schedule (void)\n       rtx_insn *count_init;\n       int mii, rec_mii, stage_count, min_cycle;\n       int64_t loop_count = 0;\n-      bool opt_sc_p;\n+      bool opt_sc_p, adjust_inplace = false;\n+      basic_block pre_header;\n \n       if (! (g = g_arr[loop->num]))\n         continue;\n@@ -1569,19 +1578,13 @@ sms_schedule (void)\n \t}\n \n \n-      /* In case of th loop have doloop register it gets special\n-\t handling.  */\n-      count_init = NULL;\n-      if ((count_reg = doloop_register_get (head, tail)))\n-\t{\n-\t  basic_block pre_header;\n-\n-\t  pre_header = loop_preheader_edge (loop)->src;\n-\t  count_init = const_iteration_count (count_reg, pre_header,\n-\t\t\t\t\t      &loop_count);\n-\t}\n+      count_reg = doloop_register_get (head, tail);\n       gcc_assert (count_reg);\n \n+      pre_header = loop_preheader_edge (loop)->src;\n+      count_init = const_iteration_count (count_reg, pre_header, &loop_count,\n+\t\t\t\t\t  &adjust_inplace);\n+\n       if (dump_file && count_init)\n         {\n           fprintf (dump_file, \"SMS const-doloop \");\n@@ -1701,9 +1704,20 @@ sms_schedule (void)\n \t      print_partial_schedule (ps, dump_file);\n \t    }\n  \n-          /* case the BCT count is not known , Do loop-versioning */\n-\t  if (count_reg && ! count_init)\n+\t  if (count_init)\n+\t    {\n+\t       if (adjust_inplace)\n+\t\t{\n+\t\t  /* When possible, set new iteration count of loop kernel in\n+\t\t     place.  Otherwise, generate_prolog_epilog creates an insn\n+\t\t     to adjust.  */\n+\t\t  SET_SRC (single_set (count_init)) = GEN_INT (loop_count\n+\t\t\t\t\t\t\t    - stage_count + 1);\n+\t\t}\n+\t    }\n+\t  else\n             {\n+\t      /* case the BCT count is not known , Do loop-versioning */\n \t      rtx comp_rtx = gen_rtx_GT (VOIDmode, count_reg,\n \t\t\t\t\t gen_int_mode (stage_count,\n \t\t\t\t\t\t       GET_MODE (count_reg)));\n@@ -1713,12 +1727,7 @@ sms_schedule (void)\n \t      loop_version (loop, comp_rtx, &condition_bb,\n \t  \t\t    prob, prob.invert (),\n \t\t\t    prob, prob.invert (), true);\n-\t     }\n-\n-\t  /* Set new iteration count of loop kernel.  */\n-          if (count_reg && count_init)\n-\t    SET_SRC (single_set (count_init)) = GEN_INT (loop_count\n-\t\t\t\t\t\t     - stage_count + 1);\n+\t    }\n \n \t  /* Now apply the scheduled kernel to the RTL of the loop.  */\n \t  permute_partial_schedule (ps, g->closing_branch->first_note);\n@@ -1735,7 +1744,7 @@ sms_schedule (void)\n \t  if (dump_file)\n \t    print_node_sched_params (dump_file, g->num_nodes, ps);\n \t  /* Generate prolog and epilog.  */\n-          generate_prolog_epilog (ps, loop, count_reg, count_init);\n+\t  generate_prolog_epilog (ps, loop, count_reg, !adjust_inplace);\n \t  break;\n \t}\n "}, {"sha": "e32fb129f1833cee49a4f6dc18ec999a6635a653", "filename": "gcc/testsuite/gcc.c-torture/execute/pr97421-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-1.c?ref=4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "patch": "@@ -0,0 +1,23 @@\n+/* PR rtl-optimization/97421 */\n+/* { dg-additional-options \"-fmodulo-sched\" } */\n+\n+int a, b, d, e;\n+int *volatile c = &a;\n+\n+__attribute__((noinline))\n+void f(void)\n+{\n+  for (int g = 2; g >= 0; g--) {\n+    d = 0;\n+    for (b = 0; b <= 2; b++)\n+      ;\n+    e = *c;\n+  }\n+}\n+\n+int main(void)\n+{\n+  f();\n+  if (b != 3)\n+    __builtin_abort();\n+}"}, {"sha": "142bcbcee91eb3340d11e4a830fb00afa849e6b6", "filename": "gcc/testsuite/gcc.c-torture/execute/pr97421-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-2.c?ref=4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "patch": "@@ -0,0 +1,18 @@\n+/* PR rtl-optimization/97421 */\n+/* { dg-additional-options \"-fmodulo-sched -fno-dce -fno-strict-aliasing\" } */\n+\n+static int a, b, c;\n+int *d = &c;\n+int **e = &d;\n+int ***f = &e;\n+int main()\n+{\n+  int h;\n+  for (a = 2; a; a--)\n+    for (h = 0; h <= 2; h++)\n+      for (b = 0; b <= 2; b++)\n+        ***f = 6;\n+\n+  if (b != 3)\n+    __builtin_abort();\n+}"}, {"sha": "3f1485a4a3d8c6b58436ebe69acc6a2589a18b26", "filename": "gcc/testsuite/gcc.c-torture/execute/pr97421-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb8f93d026eaa1de9b4820337069f3ce3465cd0/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr97421-3.c?ref=4eb8f93d026eaa1de9b4820337069f3ce3465cd0", "patch": "@@ -0,0 +1,22 @@\n+/* PR rtl-optimization/97421 */\n+/* { dg-additional-options \"-fmodulo-sched\" } */\n+\n+int a, b, c;\n+short d;\n+void e(void) {\n+  unsigned f = 0;\n+  for (; f <= 2; f++) {\n+    int g[1];\n+    int h = (long)g;\n+    c = 0;\n+    for (; c < 10; c++)\n+      g[0] = a = 0;\n+    for (; a <= 2; a++)\n+      b = d;\n+  }\n+}\n+int main(void) {\n+  e();\n+  if (a != 3)\n+    __builtin_abort();\n+}"}]}