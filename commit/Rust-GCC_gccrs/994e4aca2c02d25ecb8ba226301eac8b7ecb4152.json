{"sha": "994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk0ZTRhY2EyYzAyZDI1ZWNiOGJhMjI2MzAxZWFjOGI3ZWNiNDE1Mg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-01-03T07:04:01Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-01-03T07:04:01Z"}, "message": "PR 78534 Change character length from int to size_t\n\nIn order to handle large character lengths on (L)LP64 targets, switch\nthe GFortran character length from an int to a size_t.\n\nThis is an ABI change, as procedures with character arguments take\nhidden arguments with the character length.\n\nI also changed the _size member in vtables from int to size_t, as\nthere were some cases where character lengths and sizes were\napparently mixed up and caused regressions otherwise. Although I\nhaven't tested, this might enable very large derived types as well.\n\nAlso, as there are some places in the frontend were negative character\nlengths are used as special flag values, in the frontend the character\nlength is handled as a signed variable of the same size as a size_t,\nalthough in the runtime library it really is size_t.\n\nI haven't changed the character length variables for the co-array\nintrinsics, as this is something that may need to be synchronized with\nOpenCoarrays.\n\nThis is v3 of the patch. All the issues pointed out by FX's review of\nv2 have been fixed. In particular, there are now new functions\ngfc_mpz_get_hwi and gfc_mpz_set_hwi, similar to the GMP functions\nmpz_get_si and mpz_set_si, except that they get/set a HOST_WIDE_INT\ninstead of a long value. Similarly, gfc_get_int_expr now takes a\nHOST_WIDE_INT instead of a long, gfc_extract_long is replaced by\ngfc_extract_hwi. Also, the preliminary work to handle\ngfc_charlen_type_node being unsigned has been removed.\n\nRegtested on x86_64-pc-linux-gnu.\n\nfrontend:\n\n2017-01-03  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/78534\n\tPR fortran/66310\n\t* class.c (gfc_find_derived_vtab): Use gfc_size_kind instead of\n\thardcoded kind.\n\t(find_intrinsic_vtab): Likewise.\n\t* expr.c (gfc_get_character_expr): Length parameter of type\n\tgfc_charlen_t.\n\t(gfc_get_int_expr): Value argument of type HOST_WIDE_INT.\n\t(gfc_extract_hwi): New function.\n\t(simplify_const_ref): Make string_len of type gfc_charlen_t.\n\t(gfc_simplify_expr): Use HOST_WIDE_INT for substring refs.\n\t* gfortran.h (gfc_mpz_get_hwi): New prototype.\n\t(gfc_mpz_set_hwi): Likewise.\n\t(gfc_charlen_t): New typedef.\n\t(gfc_expr): Use gfc_charlen_t for character lengths.\n\t(gfc_size_kind): New extern variable.\n\t(gfc_extract_hwi): New prototype.\n\t(gfc_get_character_expr): Use gfc_charlen_t for character length.\n\t(gfc_get_int_expr): Use HOST_WIDE_INT type for value argument.\n\t* iresolve.c (gfc_resolve_repeat): Pass string length directly without\n\ttemporary, use gfc_charlen_int_kind.\n\t* match.c (select_intrinsic_set_tmp): Use HOST_WIDE_INT for charlen.\n\t* misc.c (gfc_mpz_get_hwi): New function.\n\t(gfc_mpz_set_hwi): New function.\n\t* module.c (atom_int): Change type from int to HOST_WIDE_INT.\n\t(parse_integer): Don't complain about large integers.\n\t(write_atom): Use HOST_WIDE_INT for integers.\n\t(mio_integer): Handle integer type mismatch.\n\t(mio_hwi): New function.\n\t(mio_intrinsic_op): Use HOST_WIDE_INT.\n\t(mio_array_ref): Likewise.\n\t(mio_expr): Likewise.\n\t* resolve.c (resolve_select_type): Use HOST_WIDE_INT for charlen,\n\tuse snprintf.\n\t(resolve_charlen): Use mpz_sgn to determine sign.\n\t* simplify.c (gfc_simplify_repeat): Use HOST_WIDE_INT/gfc_charlen_t\n\tinstead of long.\n\t* target-memory.c (size_character): Length argument of type\n\tgfc_charlen_t.\n\t(gfc_encode_character): Likewise.\n\t(gfc_interpret_character): Use gfc_charlen_t.\n\t* target-memory.h (gfc_encode_character): Modify prototype.\n\t* trans-array.c (get_array_ctor_var_strlen): Use\n\tgfc_conv_mpz_to_tree_type.\n\t* trans-const.c (gfc_conv_mpz_to_tree_type): New function.\n\t* trans-const.h (gfc_conv_mpz_to_tree_type): New prototype.\n\t* trans-expr.c (gfc_class_len_or_zero_get): Build const of type\n\tgfc_charlen_type_node.\n\t(gfc_conv_intrinsic_to_class): Use gfc_charlen_int_kind instead of\n\t4, fold_convert to correct type.\n\t(gfc_conv_class_to_class): Build const of type size_type_node for\n\tsize.\n\t(gfc_copy_class_to_class): Likewise.\n\t(gfc_conv_string_length): Use same type in expression.\n\t(gfc_conv_substring): Likewise, use HOST_WIDE_INT for charlen.\n\t(gfc_conv_string_tmp): Make sure len is of the right type.\n\t(gfc_conv_concat_op): Use same type in expression.\n\t(gfc_conv_procedure_call): Likewise.\n\t(alloc_scalar_allocatable_for_subcomponent_assignment):\n\tfold_convert to right type.\n\t(gfc_trans_subcomponent_assign): Likewise.\n\t(trans_class_vptr_len_assignment): Build const of correct type.\n\t(gfc_trans_pointer_assignment): Likewise.\n\t(alloc_scalar_allocatable_for_assignment): fold_convert to right\n\ttype in expr.\n\t(trans_class_assignment): Build const of correct type.\n\t* trans-intrinsic.c (gfc_conv_associated): Likewise.\n\t(gfc_conv_intrinsic_repeat): Do calculation in sizetype.\n\t* trans-io.c (gfc_build_io_library_fndecls): Use\n\tgfc_charlen_type_node for character lengths.\n\t* trans-stmt.c (gfc_trans_label_assign): Build const of\n\tgfc_charlen_type_node.\n\t(gfc_trans_character_select): Likewise.\n\t(gfc_trans_allocate): Likewise, don't typecast strlen result.\n\t(gfc_trans_deallocate): Don't typecast strlen result.\n\t* trans-types.c (gfc_size_kind): New variable.\n\t(gfc_init_types): Determine gfc_charlen_int_kind and gfc_size_kind\n\tfrom size_type_node.\n\ntestsuite:\n\n2017-01-03  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/78534\n\tPR fortran/66310\n\t* gfortran.dg/dependency_49.f90: Change scan-tree-dump-times\n          due to gfc_trans_string_copy change to avoid\n          -Wstringop-overflow.\n\t* gfortran.dg/repeat_4.f90: Use integers of kind C_SIZE_T.\n\t* gfortran.dg/repeat_7.f90: New test for PR 66310.\n\t* gfortran.dg/scan_2.f90: Handle potential cast in assignment.\n\t* gfortran.dg/string_1.f90: Limit to ilp32 targets.\n\t* gfortran.dg/string_1_lp64.f90: New test.\n\t* gfortran.dg/string_3.f90: Limit to ilp32 targets.\n\t* gfortran.dg/string_3_lp64.f90: New test.\n\t* gfortran.dg/transfer_intrinsic_1.f90: Change\n          scan-tree-dump-times due to gfc_trans_string_copy change to\n          avoid -Wstringop-overflow.\n\nlibgfortran:\n\n2017-01-03  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/78534\n\t* intrinsics/args.c (getarg_i4): Use gfc_charlen_type.\n\t(get_command_argument_i4): Likewise.\n\t(get_command_i4): Likewise.\n\t* intrinsics/chmod.c (chmod_internal): Likewise.\n\t* intrinsics/env.c (get_environment_variable_i4): Likewise.\n\t* intrinsics/extends_type_of.c (struct vtype): Use size_t for size\n\tmember.\n\t* intrinsics/gerror.c (gerror): Use gfc_charlen_type.\n\t* intrinsics/getlog.c (getlog): Likewise.\n\t* intrinsics/hostnm.c (hostnm_0): Likewise.\n\t* intrinsics/string_intrinsics_inc.c (string_len_trim): Rework to\n\twork if gfc_charlen_type is unsigned.\n\t(string_scan): Likewise.\n\t* io/transfer.c (transfer_character): Modify prototype.\n\t(transfer_character_write): Likewise.\n\t(transfer_character_wide): Likewise.\n\t(transfer_character_wide_write): Likewise.\n\t(transfer_array): Typecast to avoid signed-unsigned comparison.\n\t* io/unit.c (is_trim_ok): Use gfc_charlen_type.\n\t* io/write.c (namelist_write): Likewise.\n\t* libgfortran.h (gfc_charlen_type): Change typedef to size_t.\n\nFrom-SVN: r244011", "tree": {"sha": "cea9bb5f82ffbd936171e6e6755b07aaaeaa891c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cea9bb5f82ffbd936171e6e6755b07aaaeaa891c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/comments", "author": null, "committer": null, "parents": [{"sha": "ce005f353d9620a3feb3a7691000ecdd93e81d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce005f353d9620a3feb3a7691000ecdd93e81d92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce005f353d9620a3feb3a7691000ecdd93e81d92"}], "stats": {"total": 697, "additions": 503, "deletions": 194}, "files": [{"sha": "996e9710a2e17405ad9b69ff71732b228eb7b4fc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -1,3 +1,84 @@\n+2017-01-03  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR fortran/78534\n+        PR fortran/66310\n+        * class.c (gfc_find_derived_vtab): Use gfc_size_kind instead of\n+        hardcoded kind.\n+        (find_intrinsic_vtab): Likewise.\n+        * expr.c (gfc_get_character_expr): Length parameter of type\n+        gfc_charlen_t.\n+        (gfc_get_int_expr): Value argument of type HOST_WIDE_INT.\n+        (gfc_extract_hwi): New function.\n+        (simplify_const_ref): Make string_len of type gfc_charlen_t.\n+        (gfc_simplify_expr): Use HOST_WIDE_INT for substring refs.\n+        * gfortran.h (gfc_mpz_get_hwi): New prototype.\n+        (gfc_mpz_set_hwi): Likewise.\n+        (gfc_charlen_t): New typedef.\n+        (gfc_expr): Use gfc_charlen_t for character lengths.\n+        (gfc_size_kind): New extern variable.\n+        (gfc_extract_hwi): New prototype.\n+        (gfc_get_character_expr): Use gfc_charlen_t for character length.\n+        (gfc_get_int_expr): Use HOST_WIDE_INT type for value argument.\n+        * iresolve.c (gfc_resolve_repeat): Pass string length directly without\n+        temporary, use gfc_charlen_int_kind.\n+        * match.c (select_intrinsic_set_tmp): Use HOST_WIDE_INT for charlen.\n+        * misc.c (gfc_mpz_get_hwi): New function.\n+        (gfc_mpz_set_hwi): New function.\n+        * module.c (atom_int): Change type from int to HOST_WIDE_INT.\n+        (parse_integer): Don't complain about large integers.\n+        (write_atom): Use HOST_WIDE_INT for integers.\n+        (mio_integer): Handle integer type mismatch.\n+        (mio_hwi): New function.\n+        (mio_intrinsic_op): Use HOST_WIDE_INT.\n+        (mio_array_ref): Likewise.\n+        (mio_expr): Likewise.\n+        * resolve.c (resolve_select_type): Use HOST_WIDE_INT for charlen,\n+        use snprintf.\n+        (resolve_charlen): Use mpz_sgn to determine sign.\n+        * simplify.c (gfc_simplify_repeat): Use HOST_WIDE_INT/gfc_charlen_t\n+        instead of long.\n+        * target-memory.c (size_character): Length argument of type\n+        gfc_charlen_t.\n+        (gfc_encode_character): Likewise.\n+        (gfc_interpret_character): Use gfc_charlen_t.\n+        * target-memory.h (gfc_encode_character): Modify prototype.\n+        * trans-array.c (get_array_ctor_var_strlen): Use\n+        gfc_conv_mpz_to_tree_type.\n+        * trans-const.c (gfc_conv_mpz_to_tree_type): New function.\n+        * trans-const.h (gfc_conv_mpz_to_tree_type): New prototype.\n+        * trans-expr.c (gfc_class_len_or_zero_get): Build const of type\n+        gfc_charlen_type_node.\n+        (gfc_conv_intrinsic_to_class): Use gfc_charlen_int_kind instead of\n+        4, fold_convert to correct type.\n+        (gfc_conv_class_to_class): Build const of type size_type_node for\n+        size.\n+        (gfc_copy_class_to_class): Likewise.\n+        (gfc_conv_string_length): Use same type in expression.\n+        (gfc_conv_substring): Likewise, use HOST_WIDE_INT for charlen.\n+        (gfc_conv_string_tmp): Make sure len is of the right type.\n+        (gfc_conv_concat_op): Use same type in expression.\n+        (gfc_conv_procedure_call): Likewise.\n+        (alloc_scalar_allocatable_for_subcomponent_assignment):\n+        fold_convert to right type.\n+        (gfc_trans_subcomponent_assign): Likewise.\n+        (trans_class_vptr_len_assignment): Build const of correct type.\n+        (gfc_trans_pointer_assignment): Likewise.\n+        (alloc_scalar_allocatable_for_assignment): fold_convert to right\n+        type in expr.\n+        (trans_class_assignment): Build const of correct type.\n+        * trans-intrinsic.c (gfc_conv_associated): Likewise.\n+        (gfc_conv_intrinsic_repeat): Do calculation in sizetype.\n+        * trans-io.c (gfc_build_io_library_fndecls): Use\n+        gfc_charlen_type_node for character lengths.\n+        * trans-stmt.c (gfc_trans_label_assign): Build const of\n+        gfc_charlen_type_node.\n+        (gfc_trans_character_select): Likewise.\n+        (gfc_trans_allocate): Likewise, don't typecast strlen result.\n+        (gfc_trans_deallocate): Don't typecast strlen result.\n+        * trans-types.c (gfc_size_kind): New variable.\n+        (gfc_init_types): Determine gfc_charlen_int_kind and gfc_size_kind\n+        from size_type_node.\n+\n 2017-01-02  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/78534"}, {"sha": "6149adaac98aee9e6b2e01331dca66eea040d04b", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n     * _vptr: A pointer to the vtable entry (see below) of the dynamic type.\n \n     Only for unlimited polymorphic classes:\n-    * _len:  An integer(4) to store the string length when the unlimited\n+    * _len:  An integer(C_SIZE_T) to store the string length when the unlimited\n              polymorphic pointer is used to point to a char array.  The '_len'\n              component will be zero when no character array is stored in\n              '_data'.\n@@ -2310,13 +2310,13 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = 4;\n+\t      c->ts.kind = gfc_size_kind;\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      /* Remember the derived type in ts.u.derived,\n \t\t so that the correct initializer can be set later on\n \t\t (in gfc_conv_structure).  */\n \t      c->ts.u.derived = derived;\n-\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t      c->initializer = gfc_get_int_expr (gfc_size_kind,\n \t\t\t\t\t\t NULL, 0);\n \n \t      /* Add component _extends.  */\n@@ -2676,7 +2676,7 @@ find_intrinsic_vtab (gfc_typespec *ts)\n \t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = 4;\n+\t      c->ts.kind = gfc_size_kind;\n \t      c->attr.access = ACCESS_PRIVATE;\n \n \t      /* Build a minimal expression to make use of\n@@ -2687,11 +2687,11 @@ find_intrinsic_vtab (gfc_typespec *ts)\n \t      e = gfc_get_expr ();\n \t      e->ts = *ts;\n \t      e->expr_type = EXPR_VARIABLE;\n-\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t      c->initializer = gfc_get_int_expr (gfc_size_kind,\n \t\t\t\t\t\t NULL,\n \t\t\t\t\t\t ts->type == BT_CHARACTER\n \t\t\t\t\t\t ? ts->kind\n-\t\t\t\t\t\t : (int)gfc_element_size (e));\n+\t\t\t\t\t\t : gfc_element_size (e));\n \t      gfc_free_expr (e);\n \n \t      /* Add component _extends.  */"}, {"sha": "65b47de8dd031ae712ff46a19903efc500e70308", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -348,12 +348,10 @@ show_constructor (gfc_constructor_base base)\n \n \n static void\n-show_char_const (const gfc_char_t *c, int length)\n+show_char_const (const gfc_char_t *c, gfc_charlen_t length)\n {\n-  int i;\n-\n   fputc ('\\'', dumpfile);\n-  for (i = 0; i < length; i++)\n+  for (size_t i = 0; i < (size_t) length; i++)\n     {\n       if (c[i] == '\\'')\n \tfputs (\"''\", dumpfile);\n@@ -465,7 +463,8 @@ show_expr (gfc_expr *p)\n \t  break;\n \n \tcase BT_HOLLERITH:\n-\t  fprintf (dumpfile, \"%dH\", p->representation.length);\n+\t  fprintf (dumpfile, HOST_WIDE_INT_PRINT_DEC \"H\",\n+\t\t   p->representation.length);\n \t  c = p->representation.string;\n \t  for (i = 0; i < p->representation.length; i++, c++)\n \t    {"}, {"sha": "754b0132e068d479fdb1f02f2cb5358814d3fecb", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"target-memory.h\" /* for gfc_convert_boz */\n #include \"constructor.h\"\n+#include \"tree.h\"\n \n \n /* The following set of functions provide access to gfc_expr* of\n@@ -184,7 +185,7 @@ gfc_get_constant_expr (bt type, int kind, locus *where)\n    blanked and null-terminated.  */\n \n gfc_expr *\n-gfc_get_character_expr (int kind, locus *where, const char *src, int len)\n+gfc_get_character_expr (int kind, locus *where, const char *src, gfc_charlen_t len)\n {\n   gfc_expr *e;\n   gfc_char_t *dest;\n@@ -210,13 +211,14 @@ gfc_get_character_expr (int kind, locus *where, const char *src, int len)\n /* Get a new expression node that is an integer constant.  */\n \n gfc_expr *\n-gfc_get_int_expr (int kind, locus *where, int value)\n+gfc_get_int_expr (int kind, locus *where, HOST_WIDE_INT value)\n {\n   gfc_expr *p;\n   p = gfc_get_constant_expr (BT_INTEGER, kind,\n \t\t\t     where ? where : &gfc_current_locus);\n \n-  mpz_set_si (p->value.integer, value);\n+  const wide_int w = wi::shwi (value, kind * BITS_PER_UNIT);\n+  wi::to_mpz (w, p->value.integer, SIGNED);\n \n   return p;\n }\n@@ -636,6 +638,32 @@ gfc_extract_int (gfc_expr *expr, int *result)\n }\n \n \n+/* Same as gfc_extract_int, but use a HWI.  */\n+\n+const char *\n+gfc_extract_hwi (gfc_expr *expr, HOST_WIDE_INT *result)\n+{\n+  if (expr->expr_type != EXPR_CONSTANT)\n+    return _(\"Constant expression required at %C\");\n+\n+  if (expr->ts.type != BT_INTEGER)\n+    return _(\"Integer expression required at %C\");\n+\n+  /* Use long_long_integer_type_node to determine when to saturate.  */\n+  const wide_int val = wi::from_mpz (long_long_integer_type_node,\n+\t\t\t\t     expr->value.integer, false);\n+\n+  if (!wi::fits_shwi_p (val))\n+    {\n+      return _(\"Integer value too large in expression at %C\");\n+    }\n+\n+  *result = val.to_shwi ();\n+\n+  return NULL;\n+}\n+\n+\n /* Recursively copy a list of reference structures.  */\n \n gfc_ref *\n@@ -1655,7 +1683,7 @@ simplify_const_ref (gfc_expr *p)\n \t\t\t a substring out of it, update the type-spec's\n \t\t\t character length according to the first element\n \t\t\t (as all should have the same length).  */\n-\t\t      int string_len;\n+\t\t      gfc_charlen_t string_len;\n \t\t      if ((c = gfc_constructor_first (p->value.constructor)))\n \t\t\t{\n \t\t\t  const gfc_expr* first = c->expr;\n@@ -1824,18 +1852,18 @@ gfc_simplify_expr (gfc_expr *p, int type)\n       if (gfc_is_constant_expr (p))\n \t{\n \t  gfc_char_t *s;\n-\t  int start, end;\n+\t  HOST_WIDE_INT start, end;\n \n \t  start = 0;\n \t  if (p->ref && p->ref->u.ss.start)\n \t    {\n-\t      gfc_extract_int (p->ref->u.ss.start, &start);\n+\t      gfc_extract_hwi (p->ref->u.ss.start, &start);\n \t      start--;  /* Convert from one-based to zero-based.  */\n \t    }\n \n \t  end = p->value.character.length;\n \t  if (p->ref && p->ref->u.ss.end)\n-\t    gfc_extract_int (p->ref->u.ss.end, &end);\n+\t    gfc_extract_hwi (p->ref->u.ss.end, &end);\n \n \t  if (end < start)\n \t    end = start;"}, {"sha": "e1917a82fb3699ae2ed1b8a95224538012f280ff", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -2064,6 +2064,14 @@ gfc_intrinsic_sym;\n \n typedef splay_tree gfc_constructor_base;\n \n+\n+/* This should be an unsigned variable of type size_t.  But to handle\n+   compiling to a 64-bit target from a 32-bit host, we need to use a\n+   HOST_WIDE_INT.  Also, occasionally the string length field is used\n+   as a flag with values -1 and -2, see e.g. gfc_add_assign_aux_vars.\n+   So it needs to be signed.  */\n+typedef HOST_WIDE_INT gfc_charlen_t;\n+\n typedef struct gfc_expr\n {\n   expr_t expr_type;\n@@ -2109,7 +2117,7 @@ typedef struct gfc_expr\n      the value.  */\n   struct\n   {\n-    int length;\n+    gfc_charlen_t length;\n     char *string;\n   }\n   representation;\n@@ -2165,7 +2173,7 @@ typedef struct gfc_expr\n \n     struct\n     {\n-      int length;\n+      gfc_charlen_t length;\n       gfc_char_t *string;\n     }\n     character;\n@@ -2759,6 +2767,9 @@ void gfc_done_2 (void);\n \n int get_c_kind (const char *, CInteropKind_t *);\n \n+HOST_WIDE_INT gfc_mpz_get_hwi (mpz_t);\n+void gfc_mpz_set_hwi (mpz_t, const HOST_WIDE_INT);\n+\n /* options.c */\n unsigned int gfc_option_lang_mask (void);\n void gfc_init_options_struct (struct gcc_options *);\n@@ -2850,6 +2861,7 @@ extern int gfc_atomic_int_kind;\n extern int gfc_atomic_logical_kind;\n extern int gfc_intio_kind;\n extern int gfc_charlen_int_kind;\n+extern int gfc_size_kind;\n extern int gfc_numeric_storage_size;\n extern int gfc_character_storage_size;\n \n@@ -3081,6 +3093,7 @@ void gfc_resolve_oacc_blocks (gfc_code *, gfc_namespace *);\n void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n+const char *gfc_extract_hwi (gfc_expr *, HOST_WIDE_INT *);\n bool is_subref_array (gfc_expr *);\n bool gfc_is_simply_contiguous (gfc_expr *, bool, bool);\n bool gfc_check_init_expr (gfc_expr *);\n@@ -3098,8 +3111,8 @@ gfc_expr *gfc_get_null_expr (locus *);\n gfc_expr *gfc_get_operator_expr (locus *, gfc_intrinsic_op,gfc_expr *, gfc_expr *);\n gfc_expr *gfc_get_structure_constructor_expr (bt, int, locus *);\n gfc_expr *gfc_get_constant_expr (bt, int, locus *);\n-gfc_expr *gfc_get_character_expr (int, locus *, const char *, int len);\n-gfc_expr *gfc_get_int_expr (int, locus *, int);\n+gfc_expr *gfc_get_character_expr (int, locus *, const char *, gfc_charlen_t len);\n+gfc_expr *gfc_get_int_expr (int, locus *, HOST_WIDE_INT);\n gfc_expr *gfc_get_logical_expr (int, locus *, bool);\n gfc_expr *gfc_get_iokind_expr (locus *, io_kind);\n "}, {"sha": "1a36dd7b80d473bb5c22df9a033018010a2cf013", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -3810,12 +3810,42 @@ front ends of GCC, e.g. to GCC's C99 compiler for @code{_Bool}\n or GCC's Ada compiler for @code{Boolean}.)\n \n For arguments of @code{CHARACTER} type, the character length is passed\n-as hidden argument.  For deferred-length strings, the value is passed\n-by reference, otherwise by value.  The character length has the type\n-@code{INTEGER(kind=4)}.  Note with C binding, @code{CHARACTER(len=1)}\n-result variables are returned according to the platform ABI and no\n-hidden length argument is used for dummy arguments; with @code{VALUE},\n-those variables are passed by value.\n+as a hidden argument at the end of the argument list.  For\n+deferred-length strings, the value is passed by reference, otherwise\n+by value.  The character length has the C type @code{size_t} (or\n+@code{INTEGER(kind=C_SIZE_T)} in Fortran).  Note that this is\n+different to older versions of the GNU Fortran compiler, where the\n+type of the hidden character length argument was a C @code{int}.  In\n+order to retain compatibility with older versions, one can e.g. for\n+the following Fortran procedure\n+\n+@smallexample\n+subroutine fstrlen (s, a)\n+   character(len=*) :: s\n+   integer :: a\n+   print*, len(s)\n+end subroutine fstrlen\n+@end smallexample\n+\n+define the corresponding C prototype as follows:\n+\n+@smallexample\n+#if __GNUC__ > 6\n+typedef size_t fortran_charlen_t;\n+#else\n+typedef int fortran_charlen_t;\n+#endif\n+\n+void fstrlen_ (char*, int*, fortran_charlen_t);\n+@end smallexample\n+\n+In order to avoid such compiler-specific details, for new code it is\n+instead recommended to use the ISO_C_BINDING feature.\n+\n+Note with C binding, @code{CHARACTER(len=1)} result variables are\n+returned according to the platform ABI and no hidden length argument\n+is used for dummy arguments; with @code{VALUE}, those variables are\n+passed by value.\n \n For @code{OPTIONAL} dummy arguments, an absent argument is denoted\n by a NULL pointer, except for scalar dummy arguments of type"}, {"sha": "fd2747fb4f83f45dcfe3bc61d5678125097584c8", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -2147,7 +2147,6 @@ void\n gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n \t\t    gfc_expr *ncopies)\n {\n-  int len;\n   gfc_expr *tmp;\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n@@ -2160,8 +2159,8 @@ gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n   tmp = NULL;\n   if (string->expr_type == EXPR_CONSTANT)\n     {\n-      len = string->value.character.length;\n-      tmp = gfc_get_int_expr (gfc_default_integer_kind, NULL , len);\n+      tmp = gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n+\t\t\t      string->value.character.length);\n     }\n   else if (string->ts.u.cl && string->ts.u.cl->length)\n     {"}, {"sha": "992a6d96744833f0cb33caa3f63975270b6faf31", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -5765,7 +5765,7 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_symtree *tmp;\n-  int charlen = 0;\n+  HOST_WIDE_INT charlen = 0;\n \n   if (ts->type == BT_CLASS || ts->type == BT_DERIVED)\n     return NULL;\n@@ -5776,14 +5776,14 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n \n   if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length\n       && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n-    charlen = mpz_get_si (ts->u.cl->length->value.integer);\n+    charlen = gfc_mpz_get_hwi (ts->u.cl->length->value.integer);\n \n   if (ts->type != BT_CHARACTER)\n     sprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (ts->type),\n \t     ts->kind);\n   else\n-    sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (ts->type),\n-\t     charlen, ts->kind);\n+    snprintf (name, sizeof (name), \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n+\t      gfc_basic_typename (ts->type), charlen, ts->kind);\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n   gfc_add_type (tmp->n.sym, ts, NULL);"}, {"sha": "7dd0557bb3b8bef17ec7c15cfcbb53b9da870e0a", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"gfortran.h\"\n+#include \"tree.h\"\n \n \n /* Initialize a typespec to unknown.  */\n@@ -280,3 +281,24 @@ get_c_kind(const char *c_kind_name, CInteropKind_t kinds_table[])\n \n   return ISOCBINDING_INVALID;\n }\n+\n+\n+/* Convert between GMP integers (mpz_t) and HOST_WIDE_INT.  */\n+\n+HOST_WIDE_INT\n+gfc_mpz_get_hwi (mpz_t op)\n+{\n+  /* Using long_long_integer_type_node as that is the integer type\n+     node that closest matches HOST_WIDE_INT; both are guaranteed to\n+     be at least 64 bits.  */\n+  const wide_int w = wi::from_mpz (long_long_integer_type_node, op, true);\n+  return w.to_shwi ();\n+}\n+\n+\n+void\n+gfc_mpz_set_hwi (mpz_t rop, const HOST_WIDE_INT op)\n+{\n+  const wide_int w = wi::shwi (op, HOST_BITS_PER_WIDE_INT);\n+  wi::to_mpz (w, rop, SIGNED);\n+}"}, {"sha": "d9c995f43b9f67b4251106b310ec2595d7c1cb9e", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -1141,7 +1141,7 @@ static atom_type last_atom;\n \n #define MAX_ATOM_SIZE 100\n \n-static int atom_int;\n+static HOST_WIDE_INT atom_int;\n static char *atom_string, atom_name[MAX_ATOM_SIZE];\n \n \n@@ -1271,7 +1271,7 @@ parse_string (void)\n }\n \n \n-/* Parse a small integer.  */\n+/* Parse an integer. Should fit in a HOST_WIDE_INT.  */\n \n static void\n parse_integer (int c)\n@@ -1288,8 +1288,6 @@ parse_integer (int c)\n \t}\n \n       atom_int = 10 * atom_int + c - '0';\n-      if (atom_int > 99999999)\n-\tbad_module (\"Integer overflow\");\n     }\n \n }\n@@ -1631,11 +1629,12 @@ write_char (char out)\n static void\n write_atom (atom_type atom, const void *v)\n {\n-  char buffer[20];\n+  char buffer[32];\n \n   /* Workaround -Wmaybe-uninitialized false positive during\n      profiledbootstrap by initializing them.  */\n-  int i = 0, len;\n+  int len;\n+  HOST_WIDE_INT i = 0;\n   const char *p;\n \n   switch (atom)\n@@ -1654,11 +1653,9 @@ write_atom (atom_type atom, const void *v)\n       break;\n \n     case ATOM_INTEGER:\n-      i = *((const int *) v);\n-      if (i < 0)\n-\tgfc_internal_error (\"write_atom(): Writing negative integer\");\n+      i = *((const HOST_WIDE_INT *) v);\n \n-      sprintf (buffer, \"%d\", i);\n+      snprintf (buffer, sizeof (buffer), HOST_WIDE_INT_PRINT_DEC, i);\n       p = buffer;\n       break;\n \n@@ -1766,14 +1763,29 @@ static void\n mio_integer (int *ip)\n {\n   if (iomode == IO_OUTPUT)\n-    write_atom (ATOM_INTEGER, ip);\n+    {\n+      HOST_WIDE_INT hwi = *ip;\n+      write_atom (ATOM_INTEGER, &hwi);\n+    }\n   else\n     {\n       require_atom (ATOM_INTEGER);\n       *ip = atom_int;\n     }\n }\n \n+static void\n+mio_hwi (HOST_WIDE_INT *hwi)\n+{\n+  if (iomode == IO_OUTPUT)\n+    write_atom (ATOM_INTEGER, hwi);\n+  else\n+    {\n+      require_atom (ATOM_INTEGER);\n+      *hwi = atom_int;\n+    }\n+}\n+\n \n /* Read or write a gfc_intrinsic_op value.  */\n \n@@ -1783,7 +1795,7 @@ mio_intrinsic_op (gfc_intrinsic_op* op)\n   /* FIXME: Would be nicer to do this via the operators symbolic name.  */\n   if (iomode == IO_OUTPUT)\n     {\n-      int converted = (int) *op;\n+      HOST_WIDE_INT converted = (HOST_WIDE_INT) *op;\n       write_atom (ATOM_INTEGER, &converted);\n     }\n   else\n@@ -2680,7 +2692,7 @@ mio_array_ref (gfc_array_ref *ar)\n     {\n       for (i = 0; i < ar->dimen; i++)\n \t{\n-\t  int tmp = (int)ar->dimen_type[i];\n+\t  HOST_WIDE_INT tmp = (HOST_WIDE_INT)ar->dimen_type[i];\n \t  write_atom (ATOM_INTEGER, &tmp);\n \t}\n     }\n@@ -3382,6 +3394,7 @@ fix_mio_expr (gfc_expr *e)\n static void\n mio_expr (gfc_expr **ep)\n {\n+  HOST_WIDE_INT hwi;\n   gfc_expr *e;\n   atom_type t;\n   int flag;\n@@ -3596,7 +3609,9 @@ mio_expr (gfc_expr **ep)\n \t  break;\n \n \tcase BT_CHARACTER:\n-\t  mio_integer (&e->value.character.length);\n+\t  hwi = e->value.character.length;\n+\t  mio_hwi (&hwi);\n+\t  e->value.character.length = hwi;\n \t  e->value.character.string\n \t    = CONST_CAST (gfc_char_t *,\n \t\t\t  mio_allocated_wide_string (e->value.character.string,"}, {"sha": "be630380fba99753871e0fae1c0dbe59698baec0", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -8469,7 +8469,6 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_namespace *ns;\n   int error = 0;\n-  int charlen = 0;\n   int rank = 0;\n   gfc_ref* ref = NULL;\n   gfc_expr *selector_expr = NULL;\n@@ -8717,11 +8716,13 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \tsprintf (name, \"__tmp_type_%s\", c->ts.u.derived->name);\n       else if (c->ts.type == BT_CHARACTER)\n \t{\n+\t  HOST_WIDE_INT charlen = 0;\n \t  if (c->ts.u.cl && c->ts.u.cl->length\n \t      && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-\t    charlen = mpz_get_si (c->ts.u.cl->length->value.integer);\n-\t  sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (c->ts.type),\n-\t           charlen, c->ts.kind);\n+\t    charlen = gfc_mpz_get_hwi (c->ts.u.cl->length->value.integer);\n+\t  snprintf (name, sizeof (name),\n+\t\t    \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n+\t\t    gfc_basic_typename (c->ts.type), charlen, c->ts.kind);\n \t}\n       else\n \tsprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (c->ts.type),\n@@ -11383,7 +11384,7 @@ resolve_index_expr (gfc_expr *e)\n static bool\n resolve_charlen (gfc_charlen *cl)\n {\n-  int i, k;\n+  int k;\n   bool saved_specification_expr;\n \n   if (cl->resolved)\n@@ -11419,7 +11420,7 @@ resolve_charlen (gfc_charlen *cl)\n \n   /* F2008, 4.4.3.2:  If the character length parameter value evaluates to\n      a negative value, the length of character entities declared is zero.  */\n-  if (cl->length && !gfc_extract_int (cl->length, &i) && i < 0)\n+  if (cl->length && mpz_sgn (cl->length->value.integer) < 0)\n     gfc_replace_expr (cl->length,\n \t\t      gfc_get_int_expr (gfc_default_integer_kind, NULL, 0));\n "}, {"sha": "0bf3cfe9e4427bc858f659e59652fd9ece4ccfa7", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -5190,7 +5190,7 @@ gfc_expr *\n gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n {\n   gfc_expr *result;\n-  int i, j, len, ncop, nlen;\n+  gfc_charlen_t len;\n   mpz_t ncopies;\n   bool have_length = false;\n \n@@ -5210,7 +5210,7 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   if (e->ts.u.cl && e->ts.u.cl->length\n \t&& e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n     {\n-      len = mpz_get_si (e->ts.u.cl->length->value.integer);\n+      len = gfc_mpz_get_hwi (e->ts.u.cl->length->value.integer);\n       have_length = true;\n     }\n   else if (e->expr_type == EXPR_CONSTANT\n@@ -5246,7 +5246,8 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n \t}\n       else\n \t{\n-\t  mpz_init_set_si (mlen, len);\n+\t  mpz_init (mlen);\n+\t  gfc_mpz_set_hwi (mlen, len);\n \t  mpz_tdiv_q (max, gfc_integer_kinds[i].huge, mlen);\n \t  mpz_clear (mlen);\n \t}\n@@ -5270,11 +5271,12 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n+  HOST_WIDE_INT ncop;\n   if (len ||\n       (e->ts.u.cl->length &&\n        mpz_sgn (e->ts.u.cl->length->value.integer) != 0))\n     {\n-      const char *res = gfc_extract_int (n, &ncop);\n+      const char *res = gfc_extract_hwi (n, &ncop);\n       gcc_assert (res == NULL);\n     }\n   else\n@@ -5284,11 +5286,18 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n     return gfc_get_character_expr (e->ts.kind, &e->where, NULL, 0);\n \n   len = e->value.character.length;\n-  nlen = ncop * len;\n+  gfc_charlen_t nlen = ncop * len;\n+\n+  /* Here's a semi-arbitrary limit. If the string is longer than 32 MB\n+     (8 * 2**20 elements * 4 bytes (wide chars) per element) defer to\n+     runtime instead of consuming (unbounded) memory and CPU at\n+     compile time.  */\n+  if (nlen > 8388608)\n+    return NULL;\n \n   result = gfc_get_character_expr (e->ts.kind, &e->where, NULL, nlen);\n-  for (i = 0; i < ncop; i++)\n-    for (j = 0; j < len; j++)\n+  for (size_t i = 0; i < (size_t) ncop; i++)\n+    for (size_t j = 0; j < (size_t) len; j++)\n       result->value.character.string[j+i*len]= e->value.character.string[j];\n \n   result->value.character.string[nlen] = '\\0';\t/* For debugger */"}, {"sha": "34b61dc2e11648a0342fa02aeea4bb804771bcb0", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -65,7 +65,7 @@ size_logical (int kind)\n \n \n static size_t\n-size_character (int length, int kind)\n+size_character (gfc_charlen_t length, int kind)\n {\n   int i = gfc_validate_kind (BT_CHARACTER, kind, false);\n   return length * gfc_character_kinds[i].bit_size / 8;\n@@ -97,9 +97,9 @@ gfc_element_size (gfc_expr *e)\n \t       && e->ts.u.cl->length->expr_type == EXPR_CONSTANT\n \t       && e->ts.u.cl->length->ts.type == BT_INTEGER)\n \t{\n-\t  int length;\n+\t  HOST_WIDE_INT length;\n \n-\t  gfc_extract_int (e->ts.u.cl->length, &length);\n+\t  gfc_extract_hwi (e->ts.u.cl->length, &length);\n \t  return size_character (length, e->ts.kind);\n \t}\n       else\n@@ -217,16 +217,15 @@ encode_logical (int kind, int logical, unsigned char *buffer, size_t buffer_size\n \n \n int\n-gfc_encode_character (int kind, int length, const gfc_char_t *string,\n+gfc_encode_character (int kind, gfc_charlen_t length, const gfc_char_t *string,\n \t\t      unsigned char *buffer, size_t buffer_size)\n {\n   size_t elsize = size_character (1, kind);\n   tree type = gfc_get_char_type (kind);\n-  int i;\n \n   gcc_assert (buffer_size >= size_character (length, kind));\n \n-  for (i = 0; i < length; i++)\n+  for (size_t i = 0; i < (size_t) length; i++)\n     native_encode_expr (build_int_cst (type, string[i]), &buffer[i*elsize],\n \t\t\telsize);\n \n@@ -438,19 +437,17 @@ int\n gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n \t\t\t gfc_expr *result)\n {\n-  int i;\n-\n   if (result->ts.u.cl && result->ts.u.cl->length)\n     result->value.character.length =\n-      (int) mpz_get_ui (result->ts.u.cl->length->value.integer);\n+      gfc_mpz_get_hwi (result->ts.u.cl->length->value.integer);\n \n   gcc_assert (buffer_size >= size_character (result->value.character.length,\n \t\t\t\t\t     result->ts.kind));\n   result->value.character.string =\n     gfc_get_wide_string (result->value.character.length + 1);\n \n   if (result->ts.kind == gfc_default_character_kind)\n-    for (i = 0; i < result->value.character.length; i++)\n+    for (size_t i = 0; i < (size_t) result->value.character.length; i++)\n       result->value.character.string[i] = (gfc_char_t) buffer[i];\n   else\n     {\n@@ -459,7 +456,7 @@ gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n       mpz_init (integer);\n       gcc_assert (bytes <= sizeof (unsigned long));\n \n-      for (i = 0; i < result->value.character.length; i++)\n+      for (size_t i = 0; i < (size_t) result->value.character.length; i++)\n \t{\n \t  gfc_conv_tree_to_mpz (integer,\n \t    native_interpret_expr (gfc_get_char_type (result->ts.kind),"}, {"sha": "ddcaf602b56124548ccbd80367c2d44ef4708024", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -28,7 +28,7 @@ size_t gfc_element_size (gfc_expr *);\n size_t gfc_target_expr_size (gfc_expr *);\n \n /* Write a constant expression in binary form to a target buffer.  */\n-int gfc_encode_character (int, int, const gfc_char_t *, unsigned char *,\n+int gfc_encode_character (int, gfc_charlen_t, const gfc_char_t *, unsigned char *,\n \t\t\t  size_t);\n unsigned HOST_WIDE_INT gfc_target_encode_expr (gfc_expr *, unsigned char *,\n \t\t\t\t\t       size_t);"}, {"sha": "0642d56164df1abb30df4c6ce134ffdea35c10d1", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -1909,8 +1909,7 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)\n \t  mpz_init_set_ui (char_len, 1);\n \t  mpz_add (char_len, char_len, ref->u.ss.end->value.integer);\n \t  mpz_sub (char_len, char_len, ref->u.ss.start->value.integer);\n-\t  *len = gfc_conv_mpz_to_tree (char_len, gfc_default_integer_kind);\n-\t  *len = convert (gfc_charlen_type_node, *len);\n+\t  *len = gfc_conv_mpz_to_tree_type (char_len, gfc_charlen_type_node);\n \t  mpz_clear (char_len);\n \t  return;\n "}, {"sha": "cd4a8d7588ba976c7fb78faaf192be677bd95df9", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -206,6 +206,18 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n   return wide_int_to_tree (gfc_get_int_type (kind), val);\n }\n \n+\n+/* Convert a GMP integer into a tree node of type given by the type\n+   argument.  */\n+\n+tree\n+gfc_conv_mpz_to_tree_type (mpz_t i, const tree type)\n+{\n+  const wide_int val = wi::from_mpz (type, i, true);\n+  return wide_int_to_tree (type, val);\n+}\n+\n+\n /* Converts a backend tree into a GMP integer.  */\n \n void"}, {"sha": "7863e833929bdae9eb4de47af3f5406637994e04", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Converts between INT_CST and GMP integer representations.  */\n tree gfc_conv_mpz_to_tree (mpz_t, int);\n+tree gfc_conv_mpz_to_tree_type (mpz_t, const tree);\n void gfc_conv_tree_to_mpz (mpz_t, tree);\n \n /* Converts between REAL_CST and MPFR floating-point representations.  */"}, {"sha": "da944a8973044be29753d6be5d04095fe43cb3c4", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -250,7 +250,7 @@ gfc_class_len_or_zero_get (tree decl)\n   return len != NULL_TREE ? fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t\t     TREE_TYPE (len), decl, len,\n \t\t\t\t\t     NULL_TREE)\n-\t\t\t  : integer_zero_node;\n+    : build_zero_cst (gfc_charlen_type_node);\n }\n \n \n@@ -884,7 +884,8 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t{\n \t\t  /* Amazingly all data is present to compute the length of a\n \t\t   constant string, but the expression is not yet there.  */\n-\t\t  e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 4,\n+\t\t  e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER,\n+\t\t\t\t\t\t\t      gfc_charlen_int_kind,\n \t\t\t\t\t\t\t      &e->where);\n \t\t  mpz_set_ui (e->ts.u.cl->length->value.integer,\n \t\t\t      e->value.character.length);\n@@ -902,7 +903,7 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n       else\n \ttmp = integer_zero_node;\n \n-      gfc_add_modify (&parmse->pre, ctree, tmp);\n+      gfc_add_modify (&parmse->pre, ctree, fold_convert (TREE_TYPE (ctree), tmp));\n     }\n   else if (class_ts.type == BT_CLASS\n \t   && class_ts.u.derived->components\n@@ -1041,7 +1042,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n       if (DECL_LANG_SPECIFIC (tmp) && GFC_DECL_SAVED_DESCRIPTOR (tmp))\n \ttmp = GFC_DECL_SAVED_DESCRIPTOR (tmp);\n \n-      slen = integer_zero_node;\n+      slen = build_zero_cst (size_type_node);\n     }\n   else\n     {\n@@ -1088,7 +1089,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n \t  tmp = slen;\n \t}\n       else\n-\ttmp = integer_zero_node;\n+\ttmp = build_zero_cst (size_type_node);\n       gfc_add_modify (&parmse->pre, ctree,\n \t\t      fold_convert (TREE_TYPE (ctree), tmp));\n \n@@ -1227,7 +1228,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n       if (from != NULL_TREE && unlimited)\n \tfrom_len = gfc_class_len_or_zero_get (from);\n       else\n-\tfrom_len = integer_zero_node;\n+\tfrom_len = build_zero_cst (size_type_node);\n     }\n \n   if (GFC_CLASS_TYPE_P (TREE_TYPE (to)))\n@@ -1339,7 +1340,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t boolean_type_node, from_len,\n-\t\t\t\t integer_zero_node);\n+\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t  gfc_add_expr_to_block (&body, tmp);\n@@ -1367,7 +1368,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \t  extcopy = build_call_vec (fcn_type, fcn, args);\n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t boolean_type_node, from_len,\n-\t\t\t\t integer_zero_node);\n+\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t}\n@@ -2195,7 +2196,7 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n \n   gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n   se.expr = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n-\t\t\t     se.expr, build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t     se.expr, build_zero_cst (TREE_TYPE (se.expr)));\n   gfc_add_block_to_block (pblock, &se.pre);\n \n   if (cl->backend_decl)\n@@ -2267,7 +2268,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       /* Check lower bound.  */\n       fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n \t\t\t       start.expr,\n-\t\t\t       build_int_cst (gfc_charlen_type_node, 1));\n+\t\t\t       build_one_cst (TREE_TYPE (start.expr)));\n       fault = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n \t\t\t       boolean_type_node, nonempty, fault);\n       if (name)\n@@ -2303,9 +2304,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   if (ref->u.ss.end\n       && gfc_dep_difference (ref->u.ss.end, ref->u.ss.start, &length))\n     {\n-      int i_len;\n+      HOST_WIDE_INT i_len;\n \n-      i_len = mpz_get_si (length) + 1;\n+      i_len = gfc_mpz_get_hwi (length) + 1;\n       if (i_len < 0)\n \ti_len = 0;\n \n@@ -2315,7 +2316,8 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   else\n     {\n       tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_charlen_type_node,\n-\t\t\t     end.expr, start.expr);\n+\t\t\t     fold_convert (gfc_charlen_type_node, end.expr),\n+\t\t\t     fold_convert (gfc_charlen_type_node, start.expr));\n       tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_charlen_type_node,\n \t\t\t     build_int_cst (gfc_charlen_type_node, 1), tmp);\n       tmp = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n@@ -3115,9 +3117,10 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n     {\n       /* Create a temporary variable to hold the result.  */\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t     gfc_charlen_type_node, len,\n+\t\t\t     gfc_charlen_type_node,\n+\t\t\t     fold_convert (gfc_charlen_type_node, len),\n \t\t\t     build_int_cst (gfc_charlen_type_node, 1));\n-      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n+      tmp = build_range_type (gfc_charlen_type_node, gfc_index_zero_node, tmp);\n \n       if (TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n \ttmp = build_array_type (TREE_TYPE (TREE_TYPE (type)), tmp);\n@@ -3180,7 +3183,9 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n     {\n       len = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t     TREE_TYPE (lse.string_length),\n-\t\t\t     lse.string_length, rse.string_length);\n+\t\t\t     lse.string_length,\n+\t\t\t     fold_convert (TREE_TYPE (lse.string_length),\n+\t\t\t\t\t   rse.string_length));\n     }\n \n   type = build_pointer_type (type);\n@@ -5872,7 +5877,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  tmp = fold_convert (gfc_charlen_type_node, parmse.expr);\n \t  tmp = fold_build2_loc (input_location, MAX_EXPR,\n \t\t\t\t gfc_charlen_type_node, tmp,\n-\t\t\t\t build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t\t build_zero_cst (TREE_TYPE (tmp)));\n \t  cl.backend_decl = tmp;\n \t}\n \n@@ -7201,7 +7206,8 @@ alloc_scalar_allocatable_for_subcomponent_assignment (stmtblock_t *block,\n \n   if (cm->ts.type == BT_CHARACTER && cm->ts.deferred)\n     /* Update the lhs character length.  */\n-    gfc_add_modify (block, lhs_cl_size, size);\n+    gfc_add_modify (block, lhs_cl_size,\n+\t\t    fold_convert (TREE_TYPE (lhs_cl_size), size));\n }\n \n \n@@ -7440,7 +7446,8 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \t\t\t\t     1, size);\n \t  gfc_add_modify (&block, dest,\n \t\t\t  fold_convert (TREE_TYPE (dest), tmp));\n-\t  gfc_add_modify (&block, strlen, se.string_length);\n+\t  gfc_add_modify (&block, strlen,\n+\t\t\t  fold_convert (TREE_TYPE (strlen), se.string_length));\n \t  tmp = gfc_build_memcpy_call (dest, se.expr, size);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n@@ -8106,7 +8113,7 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,\n \t\t  from_len = gfc_evaluate_now (se.expr, block);\n \t\t}\n \t      else\n-\t\tfrom_len = integer_zero_node;\n+\t\tfrom_len = build_zero_cst (gfc_charlen_type_node);\n \t    }\n \t  gfc_add_modify (pre, to_len, fold_convert (TREE_TYPE (to_len),\n \t\t\t\t\t\t     from_len));\n@@ -8235,7 +8242,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t    gfc_add_modify (&block, lse.string_length, rse.string_length);\n \t  else if (lse.string_length != NULL)\n \t    gfc_add_modify (&block, lse.string_length,\n-\t\t\t    build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t    build_zero_cst (TREE_TYPE (lse.string_length)));\n \t}\n \n       gfc_add_modify (&block, lse.expr,\n@@ -9490,7 +9497,9 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n   if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n     {\n       cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t      lse.string_length, size);\n+\t\t\t      lse.string_length,\n+\t\t\t      fold_convert (TREE_TYPE (lse.string_length),\n+\t\t\t\t\t    size));\n       /* Jump past the realloc if the lengths are the same.  */\n       tmp = build3_v (COND_EXPR, cond,\n \t\t      build1_v (GOTO_EXPR, jump_label2),\n@@ -9507,7 +9516,8 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n \n       /* Update the lhs character length.  */\n       size = string_length;\n-      gfc_add_modify (block, lse.string_length, size);\n+      gfc_add_modify (block, lse.string_length,\n+\t\t      fold_convert (TREE_TYPE (lse.string_length), size));\n     }\n }\n \n@@ -9689,7 +9699,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t boolean_type_node, from_len,\n-\t\t\t\t integer_zero_node);\n+\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n \t  return fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t  void_type_node, tmp,\n \t\t\t\t  extcopy, stdcopy);"}, {"sha": "9bc0525afd2765b3694425da66cfb8dcf94d16b9", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -7491,10 +7491,12 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \n       nonzero_charlen = NULL_TREE;\n       if (arg1->expr->ts.type == BT_CHARACTER)\n-\tnonzero_charlen = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t   boolean_type_node,\n-\t\t\t\t\t   arg1->expr->ts.u.cl->backend_decl,\n-\t\t\t\t\t   integer_zero_node);\n+\tnonzero_charlen\n+\t  = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t     boolean_type_node,\n+\t\t\t     arg1->expr->ts.u.cl->backend_decl,\n+\t\t\t     build_zero_cst\n+\t\t\t     (TREE_TYPE (arg1->expr->ts.u.cl->backend_decl)));\n       if (scalar)\n         {\n \t  /* A pointer to a scalar.  */\n@@ -7784,11 +7786,11 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \n   /* We store in charsize the size of a character.  */\n   i = gfc_validate_kind (BT_CHARACTER, expr->ts.kind, false);\n-  size = build_int_cst (size_type_node, gfc_character_kinds[i].bit_size / 8);\n+  size = build_int_cst (sizetype, gfc_character_kinds[i].bit_size / 8);\n \n   /* Get the arguments.  */\n   gfc_conv_intrinsic_function_args (se, expr, args, 3);\n-  slen = fold_convert (size_type_node, gfc_evaluate_now (args[0], &se->pre));\n+  slen = fold_convert (sizetype, gfc_evaluate_now (args[0], &se->pre));\n   src = args[1];\n   ncopies = gfc_evaluate_now (args[2], &se->pre);\n   ncopies_type = TREE_TYPE (ncopies);\n@@ -7805,7 +7807,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n      is valid, and nothing happens.  */\n   n = gfc_create_var (ncopies_type, \"ncopies\");\n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n-\t\t\t  build_int_cst (size_type_node, 0));\n+\t\t\t  size_zero_node);\n   tmp = fold_build3_loc (input_location, COND_EXPR, ncopies_type, cond,\n \t\t\t build_int_cst (ncopies_type, 0), ncopies);\n   gfc_add_modify (&se->pre, n, tmp);\n@@ -7815,17 +7817,17 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n      (or equal to) MAX / slen, where MAX is the maximal integer of\n      the gfc_charlen_type_node type.  If slen == 0, we need a special\n      case to avoid the division by zero.  */\n-  i = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);\n-  max = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, gfc_charlen_int_kind);\n-  max = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,\n-\t\t\t  fold_convert (size_type_node, max), slen);\n-  largest = TYPE_PRECISION (size_type_node) > TYPE_PRECISION (ncopies_type)\n-\t      ? size_type_node : ncopies_type;\n+  max = fold_build2_loc (input_location, TRUNC_DIV_EXPR, sizetype,\n+\t\t\t fold_convert (sizetype,\n+\t\t\t\t       TYPE_MAX_VALUE (gfc_charlen_type_node)),\n+\t\t\t slen);\n+  largest = TYPE_PRECISION (sizetype) > TYPE_PRECISION (ncopies_type)\n+\t      ? sizetype : ncopies_type;\n   cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n \t\t\t  fold_convert (largest, ncopies),\n \t\t\t  fold_convert (largest, max));\n   tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n-\t\t\t build_int_cst (size_type_node, 0));\n+\t\t\t size_zero_node);\n   cond = fold_build3_loc (input_location, COND_EXPR, boolean_type_node, tmp,\n \t\t\t  boolean_false_node, cond);\n   gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n@@ -7842,42 +7844,39 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n        for (i = 0; i < ncopies; i++)\n          memmove (dest + (i * slen * size), src, slen*size);  */\n   gfc_start_block (&block);\n-  count = gfc_create_var (ncopies_type, \"count\");\n-  gfc_add_modify (&block, count, build_int_cst (ncopies_type, 0));\n+  count = gfc_create_var (sizetype, \"count\");\n+  gfc_add_modify (&block, count, size_zero_node);\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Start the loop body.  */\n   gfc_start_block (&body);\n \n   /* Exit the loop if count >= ncopies.  */\n   cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, count,\n-\t\t\t  ncopies);\n+\t\t\t  fold_convert (sizetype, ncopies));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n \t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Call memmove (dest + (i*slen*size), src, slen*size).  */\n-  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n-\t\t\t fold_convert (gfc_charlen_type_node, slen),\n-\t\t\t fold_convert (gfc_charlen_type_node, count));\n-  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n-\t\t\t tmp, fold_convert (gfc_charlen_type_node, size));\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, sizetype, slen,\n+\t\t\t count);\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, sizetype, tmp,\n+\t\t\t size);\n   tmp = fold_build_pointer_plus_loc (input_location,\n \t\t\t\t     fold_convert (pvoid_type_node, dest), tmp);\n   tmp = build_call_expr_loc (input_location,\n \t\t\t     builtin_decl_explicit (BUILT_IN_MEMMOVE),\n \t\t\t     3, tmp, src,\n \t\t\t     fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t\t      size_type_node, slen,\n-\t\t\t\t\t      fold_convert (size_type_node,\n-\t\t\t\t\t\t\t    size)));\n+\t\t\t\t\t      size_type_node, slen, size));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Increment count.  */\n-  tmp = fold_build2_loc (input_location, PLUS_EXPR, ncopies_type,\n-\t\t\t count, build_int_cst (TREE_TYPE (count), 1));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, sizetype,\n+\t\t\t count, size_one_node);\n   gfc_add_modify (&body, count, tmp);\n \n   /* Build the loop.  */"}, {"sha": "02e2b918291d3872eb1f4e6b345b3e6506ed42ff", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -339,11 +339,11 @@ gfc_build_io_library_fndecls (void)\n \n   iocall[IOCALL_X_CHARACTER] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character\")), \".wW\",\n-\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_int4_type_node);\n+\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_charlen_type_node);\n \n   iocall[IOCALL_X_CHARACTER_WRITE] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character_write\")), \".wR\",\n-\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_int4_type_node);\n+\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_charlen_type_node);\n \n   iocall[IOCALL_X_CHARACTER_WIDE] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character_wide\")), \".wW\","}, {"sha": "c171ab54b47ae8871ff1aabe36b40c4df85d6e5a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -112,7 +112,7 @@ gfc_trans_label_assign (gfc_code * code)\n       || code->label1->defined == ST_LABEL_DO_TARGET)\n     {\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n-      len_tree = integer_minus_one_node;\n+      len_tree = build_int_cst (gfc_charlen_type_node, -1);\n     }\n   else\n     {\n@@ -125,7 +125,7 @@ gfc_trans_label_assign (gfc_code * code)\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n     }\n \n-  gfc_add_modify (&se.pre, len, len_tree);\n+  gfc_add_modify (&se.pre, len, fold_convert (TREE_TYPE (len), len_tree));\n   gfc_add_modify (&se.pre, addr, label_tree);\n \n   return gfc_finish_block (&se.pre);\n@@ -2750,7 +2750,7 @@ gfc_trans_character_select (gfc_code *code)\n     {\n       for (d = cp; d; d = d->right)\n \t{\n-\t  int i;\n+\t  gfc_charlen_t i;\n \t  if (d->low)\n \t    {\n \t      gcc_assert (d->low->expr_type == EXPR_CONSTANT\n@@ -2955,7 +2955,7 @@ gfc_trans_character_select (gfc_code *code)\n       if (d->low == NULL)\n         {\n           CONSTRUCTOR_APPEND_ELT (node, ss_string1[k], null_pointer_node);\n-          CONSTRUCTOR_APPEND_ELT (node, ss_string1_len[k], integer_zero_node);\n+          CONSTRUCTOR_APPEND_ELT (node, ss_string1_len[k], build_zero_cst (gfc_charlen_type_node));\n         }\n       else\n         {\n@@ -2968,7 +2968,7 @@ gfc_trans_character_select (gfc_code *code)\n       if (d->high == NULL)\n         {\n           CONSTRUCTOR_APPEND_ELT (node, ss_string2[k], null_pointer_node);\n-          CONSTRUCTOR_APPEND_ELT (node, ss_string2_len[k], integer_zero_node);\n+          CONSTRUCTOR_APPEND_ELT (node, ss_string2_len[k], build_zero_cst (gfc_charlen_type_node));\n         }\n       else\n         {\n@@ -5640,7 +5640,7 @@ gfc_trans_allocate (gfc_code * code)\n \t{\n \t  gfc_init_se (&se, NULL);\n \t  temp_var_needed = false;\n-\t  expr3_len = integer_zero_node;\n+\t  expr3_len = build_zero_cst (gfc_charlen_type_node);\n \t  e3_is = E3_MOLD;\n \t}\n       /* Prevent aliasing, i.e., se.expr may be already a\n@@ -6036,7 +6036,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t     e.g., a string.  */\n \t\t  memsz = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t\t   boolean_type_node, expr3_len,\n-\t\t\t\t\t   integer_zero_node);\n+\t\t\t\t\t   build_zero_cst\n+\t\t\t\t\t   (TREE_TYPE (expr3_len)));\n \t\t  memsz = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t TREE_TYPE (expr3_esize),\n \t\t\t\t\t memsz, tmp, expr3_esize);\n@@ -6332,7 +6333,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\tgfc_build_addr_expr (pchar_type_node,\n \t\t\tgfc_build_localized_cstring_const (msg)));\n \n-      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n+      slen = build_int_cst (gfc_charlen_type_node, strlen (msg));\n       dlen = gfc_get_expr_charlen (code->expr2);\n       slen = fold_build2_loc (input_location, MIN_EXPR,\n \t\t\t      TREE_TYPE (slen), dlen, slen);\n@@ -6613,7 +6614,7 @@ gfc_trans_deallocate (gfc_code *code)\n       gfc_add_modify (&errmsg_block, errmsg_str,\n \t\tgfc_build_addr_expr (pchar_type_node,\n                         gfc_build_localized_cstring_const (msg)));\n-      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n+      slen = build_int_cst (gfc_charlen_type_node, strlen (msg));\n       dlen = gfc_get_expr_charlen (code->expr2);\n \n       gfc_trans_string_copy (&errmsg_block, dlen, errmsg, code->expr2->ts.kind,"}, {"sha": "448faa31f69a29da8cbfffc2d4597935b549367e", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -118,6 +118,9 @@ int gfc_intio_kind;\n /* The integer kind used to store character lengths.  */\n int gfc_charlen_int_kind;\n \n+/* Kind of internal integer for storing object sizes.  */\n+int gfc_size_kind;\n+\n /* The size of the numeric storage unit and character storage unit.  */\n int gfc_numeric_storage_size;\n int gfc_character_storage_size;\n@@ -961,9 +964,13 @@ gfc_init_types (void)\n \t\t\twi::mask (n, UNSIGNED,\n \t\t\t\t  TYPE_PRECISION (size_type_node)));\n \n-  /* ??? Shouldn't this be based on gfc_index_integer_kind or so?  */\n-  gfc_charlen_int_kind = 4;\n+  /* Character lengths are of type size_t, except signed.  */\n+  gfc_charlen_int_kind = get_int_kind_from_node (size_type_node);\n   gfc_charlen_type_node = gfc_get_int_type (gfc_charlen_int_kind);\n+\n+  /* Fortran kind number of size_type_node (size_t). This is used for\n+     the _size member in vtables.  */\n+  gfc_size_kind = get_int_kind_from_node (size_type_node);\n }\n \n /* Get the type node for the given type and kind.  */"}, {"sha": "ec154ffdb3a4adb3cece861a6771fb3097717542", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GFC_BACKEND_H\n #define GFC_BACKEND_H\n \n+\n extern GTY(()) tree gfc_array_index_type;\n extern GTY(()) tree gfc_array_range_type;\n extern GTY(()) tree gfc_character1_type_node;\n@@ -35,10 +36,9 @@ extern GTY(()) tree gfc_complex_float128_type_node;\n \n /* This is the type used to hold the lengths of character variables.\n    It must be the same as the corresponding definition in gfortran.h.  */\n-/* TODO: This is still hardcoded as kind=4 in some bits of the compiler\n-   and runtime library.  */\n extern GTY(()) tree gfc_charlen_type_node;\n \n+\n /* The following flags give us information on the correspondence of\n    real (and complex) kinds with C floating-point types long double\n    and __float128.  */"}, {"sha": "560976989b8310c3389d17420ba155143582114a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -1,3 +1,21 @@\n+2017-01-03  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR fortran/78534\n+        PR fortran/66310\n+        * gfortran.dg/dependency_49.f90: Change scan-tree-dump-times\n+          due to gfc_trans_string_copy change to avoid\n+          -Wstringop-overflow.\n+        * gfortran.dg/repeat_4.f90: Use integers of kind C_SIZE_T.\n+        * gfortran.dg/repeat_7.f90: New test for PR 66310.\n+        * gfortran.dg/scan_2.f90: Handle potential cast in assignment.\n+        * gfortran.dg/string_1.f90: Limit to ilp32 targets.\n+        * gfortran.dg/string_1_lp64.f90: New test.\n+        * gfortran.dg/string_3.f90: Limit to ilp32 targets.\n+        * gfortran.dg/string_3_lp64.f90: New test.\n+        * gfortran.dg/transfer_intrinsic_1.f90: Change\n+          scan-tree-dump-times due to gfc_trans_string_copy change to\n+          avoid -Wstringop-overflow.\n+\n 2017-01-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/78967"}, {"sha": "43ee284169fed138596d0c916b8ad52fa4e8e33b", "filename": "gcc/testsuite/gfortran.dg/dependency_49.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_49.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_49.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_49.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -11,4 +11,4 @@ program main\n   a%x = a%x(2:3)\n   print *,a%x\n end program main\n-! { dg-final { scan-tree-dump-times \"__var_1\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__var_1\" 3 \"original\" } }"}, {"sha": "99e7aee4670fa36261409153cb58b5c89132c0e5", "filename": "gcc/testsuite/gfortran.dg/repeat_4.f90", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -2,6 +2,7 @@\n !\n ! { dg-do compile }\n program test\n+  use iso_c_binding, only: k => c_size_t\n   implicit none\n   character(len=0), parameter :: s0 = \"\" \n   character(len=1), parameter :: s1 = \"a\"\n@@ -21,18 +22,18 @@ program test\n   print *, repeat(t2, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n \n   ! Check for too large NCOPIES argument and limit cases\n-  print *, repeat(t0, huge(0))\n-  print *, repeat(t1, huge(0))\n-  print *, repeat(t2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n-  print *, repeat(s2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(t0, huge(0_k))\n+  print *, repeat(t1, huge(0_k))\n+  print *, repeat(t2, huge(0_k)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0_k)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n \n-  print *, repeat(t0, huge(0)/2)\n-  print *, repeat(t1, huge(0)/2)\n-  print *, repeat(t2, huge(0)/2)\n+  print *, repeat(t0, huge(0_k)/2)\n+  print *, repeat(t1, huge(0_k)/2)\n+  print *, repeat(t2, huge(0_k)/2)\n \n-  print *, repeat(t0, huge(0)/2+1)\n-  print *, repeat(t1, huge(0)/2+1)\n-  print *, repeat(t2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n-  print *, repeat(s2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(t0, huge(0_k)/2+1)\n+  print *, repeat(t1, huge(0_k)/2+1)\n+  print *, repeat(t2, huge(0_k)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0_k)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n \n end program test"}, {"sha": "82f8dbf4deaab62625f7aa1c7c2dedb6b3c7128d", "filename": "gcc/testsuite/gfortran.dg/repeat_7.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+! PR 66310\n+! Make sure there is a limit to how large arrays we try to handle at\n+! compile time.\n+program p\n+  character, parameter :: z = 'z'\n+  print *, repeat(z, huge(1_4))\n+end program p"}, {"sha": "5ef02300d9bad6dfcfba286a27976f2fa2a10b32", "filename": "gcc/testsuite/gfortran.dg/scan_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -30,5 +30,5 @@ program p1\n    call s1(.TRUE.)\n end program p1\n \n-! { dg-final { scan-tree-dump-times \"iscan = _gfortran_string_scan \\\\(2,\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"iverify = _gfortran_string_verify \\\\(2,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_string_scan \\\\(2,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_string_verify \\\\(2,\" 1 \"original\" } }"}, {"sha": "6a6151e20a4ea919040429352827828c57c1d97b", "filename": "gcc/testsuite/gfortran.dg/string_1.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-require-effective-target ilp32 }\n !\n program main\n   implicit none"}, {"sha": "a0edbefc53e4cb8df3148b41556f568f588fe782", "filename": "gcc/testsuite/gfortran.dg/string_1_lp64.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-require-effective-target lp64 }\n+! { dg-require-effective-target fortran_integer_16 }\n+program main\n+  implicit none\n+  integer(kind=16), parameter :: l1 = 2_16**64_16\n+  character (len=2_16**64_16+4_16), parameter :: s = \"\" ! { dg-error \"too large\" }\n+  character (len=2_16**64_8+4_16) :: ch ! { dg-error \"too large\" }\n+  character (len=l1 + 1_16) :: v ! { dg-error \"too large\" }\n+  character (len=int(huge(0_8),kind=16) + 1_16) :: z ! { dg-error \"too large\" }\n+  character (len=int(huge(0_8),kind=16) + 0_16) :: w\n+\n+  print *, len(s)\n+\n+end program main"}, {"sha": "4a88b06da7cbbc907e2310c432818f2310365dc1", "filename": "gcc/testsuite/gfortran.dg/string_3.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-require-effective-target ilp32 }\n !\n subroutine foo(i)\n   implicit none"}, {"sha": "162561fad00b1778e05c63a3b6eaad751f6c0998", "filename": "gcc/testsuite/gfortran.dg/string_3_lp64.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-require-effective-target lp64 }\n+! { dg-require-effective-target fortran_integer_16 }\n+subroutine foo(i)\n+  implicit none\n+  integer, intent(in) :: i\n+  character(len=i) :: s\n+\n+  s = ''\n+  print *, s(1:2_16**64_16+3_16) ! { dg-error \"too large\" }\n+  print *, s(2_16**64_16+3_16:2_16**64_16+4_16) ! { dg-error \"too large\" }\n+  print *, len(s(1:2_16**64_16+3_16)) ! { dg-error \"too large\" }\n+  print *, len(s(2_16**64_16+3_16:2_16**64_16+4_16)) ! { dg-error \"too large\" }\n+\n+  print *, s(2_16**64_16+3_16:1)\n+  print *, s(2_16**64_16+4_16:2_16**64_16+3_16)\n+  print *, len(s(2_16**64_16+3_16:1))\n+  print *, len(s(2_16**64_16+4_16:2_16**64_16+3_16))\n+\n+end subroutine"}, {"sha": "73a7e7724f5b08c790a53625e994afd57f2aeb2d", "filename": "gcc/testsuite/gfortran.dg/transfer_intrinsic_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_intrinsic_1.f90?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -14,4 +14,4 @@ subroutine BytesToString(bytes, string)\n     character(len=*) :: string\n     string = transfer(bytes, string)\n   end subroutine\n-! { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"MIN_EXPR\" 2 \"original\" } }"}, {"sha": "b1f6d045b7db7afabd170ff240265889de278071", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -1,3 +1,28 @@\n+2017-01-03  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR fortran/78534\n+        * intrinsics/args.c (getarg_i4): Use gfc_charlen_type.\n+        (get_command_argument_i4): Likewise.\n+        (get_command_i4): Likewise.\n+        * intrinsics/chmod.c (chmod_internal): Likewise.\n+        * intrinsics/env.c (get_environment_variable_i4): Likewise.\n+        * intrinsics/extends_type_of.c (struct vtype): Use size_t for size\n+        member.\n+        * intrinsics/gerror.c (gerror): Use gfc_charlen_type.\n+        * intrinsics/getlog.c (getlog): Likewise.\n+        * intrinsics/hostnm.c (hostnm_0): Likewise.\n+        * intrinsics/string_intrinsics_inc.c (string_len_trim): Rework to\n+        work if gfc_charlen_type is unsigned.\n+        (string_scan): Likewise.\n+        * io/transfer.c (transfer_character): Modify prototype.\n+        (transfer_character_write): Likewise.\n+        (transfer_character_wide): Likewise.\n+        (transfer_character_wide_write): Likewise.\n+        (transfer_array): Typecast to avoid signed-unsigned comparison.\n+        * io/unit.c (is_trim_ok): Use gfc_charlen_type.\n+        * io/write.c (namelist_write): Likewise.\n+        * libgfortran.h (gfc_charlen_type): Change typedef to size_t.\n+\n 2017-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "ded5a35f415901267a584070ed09cde8ebf572e6", "filename": "libgfortran/intrinsics/args.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fargs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fargs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fargs.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -37,7 +37,6 @@ void\n getarg_i4 (GFC_INTEGER_4 *pos, char  *val, gfc_charlen_type val_len)\n {\n   int argc;\n-  int arglen;\n   char **argv;\n \n   get_args (&argc, &argv);\n@@ -49,7 +48,7 @@ getarg_i4 (GFC_INTEGER_4 *pos, char  *val, gfc_charlen_type val_len)\n \n   if ((*pos) + 1 <= argc  && *pos >=0 )\n     {\n-      arglen = strlen (argv[*pos]);\n+      gfc_charlen_type arglen = strlen (argv[*pos]);\n       if (arglen > val_len)\n \targlen = val_len;\n       memcpy (val, argv[*pos], arglen);\n@@ -119,7 +118,8 @@ get_command_argument_i4 (GFC_INTEGER_4 *number, char *value,\n \t\t\t GFC_INTEGER_4 *length, GFC_INTEGER_4 *status, \n \t\t\t gfc_charlen_type value_len)\n {\n-  int argc, arglen = 0, stat_flag = GFC_GC_SUCCESS;\n+  int argc, stat_flag = GFC_GC_SUCCESS;\n+  gfc_charlen_type arglen = 0;\n   char **argv;\n \n   if (number == NULL )\n@@ -195,10 +195,10 @@ void\n get_command_i4 (char *command, GFC_INTEGER_4 *length, GFC_INTEGER_4 *status,\n \t\tgfc_charlen_type command_len)\n {\n-  int i, argc, arglen, thisarg;\n+  int i, argc, thisarg;\n   int stat_flag = GFC_GC_SUCCESS;\n-  int tot_len = 0;\n   char **argv;\n+  gfc_charlen_type arglen, tot_len = 0;\n \n   if (command == NULL && length == NULL && status == NULL)\n     return; /* No need to do anything.  */"}, {"sha": "4e917a1c7f4b896ebea55fc665fe9d5f340f5cbf", "filename": "libgfortran/intrinsics/chmod.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fchmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fchmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchmod.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -64,7 +64,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n static int\n chmod_internal (char *file, char *mode, gfc_charlen_type mode_len)\n {\n-  int i;\n   bool ugo[3];\n   bool rwxXstugo[9];\n   int set_mode, part;\n@@ -104,7 +103,7 @@ chmod_internal (char *file, char *mode, gfc_charlen_type mode_len)\n   honor_umask = false;\n #endif\n \n-  for (i = 0; i < mode_len; i++)\n+  for (gfc_charlen_type i = 0; i < mode_len; i++)\n     {\n       if (!continue_clause)\n \t{"}, {"sha": "f8e77584c26ed800e4232a04beae3b4e4aebd615", "filename": "libgfortran/intrinsics/env.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fenv.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -93,7 +93,8 @@ get_environment_variable_i4 (char *name, char *value, GFC_INTEGER_4 *length,\n \t\t\t     gfc_charlen_type name_len,\n \t\t\t     gfc_charlen_type value_len)\n {\n-  int stat = GFC_SUCCESS, res_len = 0;\n+  int stat = GFC_SUCCESS;\n+  gfc_charlen_type res_len = 0;\n   char *name_nt;\n   char *res;\n "}, {"sha": "8dc9ef85e2266bd57ea595a76899a19ba0d10063", "filename": "libgfortran/intrinsics/extends_type_of.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fextends_type_of.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fextends_type_of.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fextends_type_of.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -30,7 +30,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n typedef struct vtype\n {\n   GFC_INTEGER_4 hash;\n-  GFC_INTEGER_4 size;\n+  size_t size;\n   struct vtype *extends;\n }\n vtype;"}, {"sha": "51432a4d010903f8958420157449511fd6997d00", "filename": "libgfortran/intrinsics/gerror.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fgerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fgerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fgerror.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -39,7 +39,7 @@ export_proto_np(PREFIX(gerror));\n void \n PREFIX(gerror) (char * msg, gfc_charlen_type msg_len)\n {\n-  int p_len;\n+  gfc_charlen_type p_len;\n   char *p;\n \n   p = gf_strerror (errno, msg, msg_len);"}, {"sha": "33ad52e470f1c584ff324e5b27c14cef3ddad2fd", "filename": "libgfortran/intrinsics/getlog.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fgetlog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fgetlog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fgetlog.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -70,7 +70,6 @@ export_proto_np(PREFIX(getlog));\n void\n PREFIX(getlog) (char * login, gfc_charlen_type login_len)\n {\n-  int p_len;\n   char *p;\n \n   memset (login, ' ', login_len); /* Blank the string.  */\n@@ -107,7 +106,7 @@ PREFIX(getlog) (char * login, gfc_charlen_type login_len)\n   if (p == NULL)\n     goto cleanup;\n \n-  p_len = strlen (p);\n+  gfc_charlen_type p_len = strlen (p);\n   if (login_len < p_len)\n     p_len = login_len;\n   memcpy (login, p, p_len);"}, {"sha": "2395067eae1fa013e539a94e13c6e069eb1776da", "filename": "libgfortran/intrinsics/hostnm.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fhostnm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fhostnm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fhostnm.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -88,8 +88,8 @@ w32_gethostname (char *name, size_t len)\n static int\n hostnm_0 (char *name, gfc_charlen_type name_len)\n {\n-  int val, i;\n   char p[HOST_NAME_MAX + 1];\n+  int val;\n \n   memset (name, ' ', name_len);\n \n@@ -99,8 +99,7 @@ hostnm_0 (char *name, gfc_charlen_type name_len)\n \n   if (val == 0)\n   {\n-    i = -1;\n-    while (i < name_len && p[++i] != '\\0')\n+    for (gfc_charlen_type i = 0; i < name_len && p[i] != '\\0'; i++)\n       name[i] = p[i];\n   }\n "}, {"sha": "0da5130b6538b43a97e75c5e39c3b7efb52049f7", "filename": "libgfortran/intrinsics/string_intrinsics_inc.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -224,14 +224,15 @@ string_len_trim (gfc_charlen_type len, const CHARTYPE *s)\n \t      break;\n \t    }\n \t}\n-\n-      /* Now continue for the last characters with naive approach below.  */\n-      assert (i >= 0);\n     }\n \n   /* Simply look for the first non-blank character.  */\n-  while (i >= 0 && s[i] == ' ')\n-    --i;\n+  while (s[i] == ' ')\n+    {\n+      if (i == 0)\n+\treturn 0;\n+      --i;\n+    }\n   return i + 1;\n }\n \n@@ -327,12 +328,12 @@ string_scan (gfc_charlen_type slen, const CHARTYPE *str,\n \n   if (back)\n     {\n-      for (i = slen - 1; i >= 0; i--)\n+      for (i = slen; i != 0; i--)\n \t{\n \t  for (j = 0; j < setlen; j++)\n \t    {\n-\t      if (str[i] == set[j])\n-\t\treturn (i + 1);\n+\t      if (str[i - 1] == set[j])\n+\t\treturn i;\n \t    }\n \t}\n     }"}, {"sha": "9724ccbe5045f2ee7361c8964e8c9950c680c3f3", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -93,17 +93,17 @@ export_proto(transfer_logical);\n extern void transfer_logical_write (st_parameter_dt *, void *, int);\n export_proto(transfer_logical_write);\n \n-extern void transfer_character (st_parameter_dt *, void *, int);\n+extern void transfer_character (st_parameter_dt *, void *, gfc_charlen_type);\n export_proto(transfer_character);\n \n-extern void transfer_character_write (st_parameter_dt *, void *, int);\n+extern void transfer_character_write (st_parameter_dt *, void *, gfc_charlen_type);\n export_proto(transfer_character_write);\n \n-extern void transfer_character_wide (st_parameter_dt *, void *, int, int);\n+extern void transfer_character_wide (st_parameter_dt *, void *, gfc_charlen_type, int);\n export_proto(transfer_character_wide);\n \n extern void transfer_character_wide_write (st_parameter_dt *,\n-\t\t\t\t\t   void *, int, int);\n+\t\t\t\t\t   void *, gfc_charlen_type, int);\n export_proto(transfer_character_wide_write);\n \n extern void transfer_complex (st_parameter_dt *, void *, int);\n@@ -2272,7 +2272,7 @@ transfer_logical_write (st_parameter_dt *dtp, void *p, int kind)\n }\n \n void\n-transfer_character (st_parameter_dt *dtp, void *p, int len)\n+transfer_character (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n {\n   static char *empty_string[0];\n \n@@ -2290,13 +2290,13 @@ transfer_character (st_parameter_dt *dtp, void *p, int len)\n }\n \n void\n-transfer_character_write (st_parameter_dt *dtp, void *p, int len)\n+transfer_character_write (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n {\n   transfer_character (dtp, p, len);\n }\n \n void\n-transfer_character_wide (st_parameter_dt *dtp, void *p, int len, int kind)\n+transfer_character_wide (st_parameter_dt *dtp, void *p, gfc_charlen_type len, int kind)\n {\n   static char *empty_string[0];\n \n@@ -2314,7 +2314,7 @@ transfer_character_wide (st_parameter_dt *dtp, void *p, int len, int kind)\n }\n \n void\n-transfer_character_wide_write (st_parameter_dt *dtp, void *p, int len, int kind)\n+transfer_character_wide_write (st_parameter_dt *dtp, void *p, gfc_charlen_type len, int kind)\n {\n   transfer_character_wide (dtp, p, len, kind);\n }\n@@ -2351,7 +2351,7 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n     return;\n \n   iotype = (bt) GFC_DESCRIPTOR_TYPE (desc);\n-  size = iotype == BT_CHARACTER ? charlen : GFC_DESCRIPTOR_SIZE (desc);\n+  size = iotype == BT_CHARACTER ? (index_type) charlen : GFC_DESCRIPTOR_SIZE (desc);\n \n   rank = GFC_DESCRIPTOR_RANK (desc);\n   for (n = 0; n < rank; n++)"}, {"sha": "2bd40e4cdcff4d95e90e96c227e3d64b67b4f353", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -439,10 +439,9 @@ is_trim_ok (st_parameter_dt *dtp)\n   if (dtp->common.flags & IOPARM_DT_HAS_FORMAT)\n     {\n       char *p = dtp->format;\n-      off_t i;\n       if (dtp->common.flags & IOPARM_DT_HAS_BLANK)\n \treturn false;\n-      for (i = 0; i < dtp->format_len; i++)\n+      for (gfc_charlen_type i = 0; i < dtp->format_len; i++)\n \t{\n \t  if (p[i] == '/') return false;\n \t  if (p[i] == 'b' || p[i] == 'B')"}, {"sha": "86836df1b91f6cfa5e3933c822dd4e27b64e7d33", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -2380,7 +2380,6 @@ void\n namelist_write (st_parameter_dt *dtp)\n {\n   namelist_info * t1, *t2, *dummy = NULL;\n-  index_type i;\n   index_type dummy_offset = 0;\n   char c;\n   char * dummy_name = NULL;\n@@ -2402,7 +2401,7 @@ namelist_write (st_parameter_dt *dtp)\n   write_character (dtp, \"&\", 1, 1, NODELIM);\n \n   /* Write namelist name in upper case - f95 std.  */\n-  for (i = 0 ;i < dtp->namelist_name_len ;i++ )\n+  for (gfc_charlen_type i = 0; i < dtp->namelist_name_len; i++ )\n     {\n       c = toupper ((int) dtp->namelist_name[i]);\n       write_character (dtp, &c, 1 ,1, NODELIM);"}, {"sha": "5b74a9dc8aca578654013632b340eb60d31e22da", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994e4aca2c02d25ecb8ba226301eac8b7ecb4152/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=994e4aca2c02d25ecb8ba226301eac8b7ecb4152", "patch": "@@ -250,7 +250,7 @@ typedef GFC_INTEGER_4 GFC_IO_INT;\n typedef ptrdiff_t index_type;\n \n /* The type used for the lengths of character variables.  */\n-typedef GFC_INTEGER_4 gfc_charlen_type;\n+typedef size_t gfc_charlen_type;\n \n /* Definitions of CHARACTER data types:\n      - CHARACTER(KIND=1) corresponds to the C char type,"}]}