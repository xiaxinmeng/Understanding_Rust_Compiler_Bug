{"sha": "701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAxYmQxYmQ5Y2IxZDI2YTU3YTgxMmZjM2Q2NzU2M2Q1OWMzYTJmYg==", "commit": {"author": {"name": "Sofiane Naci", "email": "sofiane@gcc.gnu.org", "date": "2013-07-31T14:29:54Z"}, "committer": {"name": "Sofiane Naci", "email": "sofiane@gcc.gnu.org", "date": "2013-07-31T14:29:54Z"}, "message": "arm.md: Include new file \"types.md\".\n\n\t* config/arm/arm.md: Include new file \"types.md\".\n\t(define_attr \"type\"): Move from here to ...\n\t(define_attr \"mul32\"): Likewise.\n\t(define_attr \"mul64\"): Likewise.\n\t* config/arm/types.md: ... here.  New file.\n\nFrom-SVN: r201375", "tree": {"sha": "29227258af37851a2dd83831585e443dbcc1749a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29227258af37851a2dd83831585e443dbcc1749a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb/comments", "author": null, "committer": null, "parents": [{"sha": "228c1313ff36f619420b46ed15fdc848b3ce2d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/228c1313ff36f619420b46ed15fdc848b3ce2d69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/228c1313ff36f619420b46ed15fdc848b3ce2d69"}], "stats": {"total": 689, "additions": 356, "deletions": 333}, "files": [{"sha": "3cdfc8e36c6f80275f0cf04c9863d7d0f0f7fce9", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 333, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "patch": "@@ -245,339 +245,8 @@\n   (set_attr \"length\" \"4\")\n   (set_attr \"pool_range\" \"250\")])\n \n-; TYPE attribute is used to classify instructions for use in scheduling.\n-;\n-; Instruction classification:\n-;\n-; arlo_imm           any arithmetic or logical instruction that doesn't have\n-;                    a shifted operand and has an immediate operand.  This\n-;                    excludes MOV, MVN and RSB(S) immediate.\n-; arlo_reg           any arithmetic or logical instruction that doesn't have\n-;                    a shifted or an immediate operand.  This excludes\n-;                    MOV and MVN but includes MOVT.  This is also the default.\n-; arlo_shift         any arithmetic or logical instruction that has a source\n-;                    operand shifted by a constant.  This excludes\n-;                    simple shifts.\n-; arlo_shift_reg     as arlo_shift, with the shift amount specified in a\n-;                    register.\n-; block              blockage insn, this blocks all functional units.\n-; branch             branch.\n-; call               subroutine call.\n-; clz                count leading zeros (CLZ).\n-; extend             extend instruction (SXTB, SXTH, UXTB, UXTH).\n-; f_2_r              transfer from float to core (no memory needed).\n-; f_cvt              conversion between float and integral.\n-; f_flag             transfer of co-processor flags to the CPSR.\n-; f_load[d,s]        double/single load from memory.  Used for VFP unit.\n-; f_minmax[d,s]      double/single floating point minimum/maximum.\n-; f_rint[d,s]        double/single floating point rount to integral.\n-; f_sel[d,s]         double/single floating byte select.\n-; f_store[d,s]       double/single store to memory.  Used for VFP unit.\n-; fadd[d,s]          double/single floating-point scalar addition.\n-; fcmp[d,s]          double/single floating-point compare.\n-; fconst[d,s]        double/single load immediate.\n-; fcpys              single precision floating point cpy.\n-; fdiv[d,s]          double/single precision floating point division.\n-; ffarith[d,s]       double/single floating point abs/neg/cpy.\n-; ffma[d,s]          double/single floating point fused multiply-accumulate.\n-; float              floating point arithmetic operation.\n-; fmac[d,s]          double/single floating point multiply-accumulate.\n-; fmul[d,s]          double/single floating point multiply.\n-; load_byte          load byte(s) from memory to arm registers.\n-; load1              load 1 word from memory to arm registers.\n-; load2              load 2 words from memory to arm registers.\n-; load3              load 3 words from memory to arm registers.\n-; load4              load 4 words from memory to arm registers.\n-; mla                integer multiply accumulate.\n-; mlas               integer multiply accumulate, flag setting.\n-; mov_imm            simple MOV instruction that moves an immediate to\n-;                    register.  This includes MOVW, but not MOVT.\n-; mov_reg            simple MOV instruction that moves a register to another\n-;                    register.  This includes MOVW, but not MOVT.\n-; mov_shift          simple MOV instruction, shifted operand by a constant.\n-; mov_shift_reg      simple MOV instruction, shifted operand by a register.\n-; mul                integer multiply.\n-; muls               integer multiply, flag setting.\n-; mvn_imm            inverting move instruction, immediate.\n-; mvn_reg            inverting move instruction, register.\n-; mvn_shift          inverting move instruction, shifted operand by a constant.\n-; mvn_shift_reg      inverting move instruction, shifted operand by a register.\n-; r_2_f              transfer from core to float.\n-; sdiv               signed division.\n-; shift              simple shift operation (LSL, LSR, ASR, ROR) with an\n-;                    immediate.\n-; shift_reg          simple shift by a register.\n-; smlad              signed multiply accumulate dual.\n-; smladx             signed multiply accumulate dual reverse.\n-; smlal              signed multiply accumulate long.\n-; smlald             signed multiply accumulate long dual.\n-; smlals             signed multiply accumulate long, flag setting.\n-; smlalxy            signed multiply accumulate, 16x16-bit, 64-bit accumulate.\n-; smlawx             signed multiply accumulate, 32x16-bit, 32-bit accumulate.\n-; smlawy             signed multiply accumulate wide, 32x16-bit,\n-;                    32-bit accumulate.\n-; smlaxy             signed multiply accumulate, 16x16-bit, 32-bit accumulate.\n-; smlsd              signed multiply subtract dual.\n-; smlsdx             signed multiply subtract dual reverse.\n-; smlsld             signed multiply subtract long dual.\n-; smmla              signed most significant word multiply accumulate.\n-; smmul              signed most significant word multiply.\n-; smmulr             signed most significant word multiply, rounded.\n-; smuad              signed dual multiply add.\n-; smuadx             signed dual multiply add reverse.\n-; smull              signed multiply long.\n-; smulls             signed multiply long, flag setting.\n-; smulwy             signed multiply wide, 32x16-bit, 32-bit accumulate.\n-; smulxy             signed multiply, 16x16-bit, 32-bit accumulate.\n-; smusd              signed dual multiply subtract.\n-; smusdx             signed dual multiply subtract reverse.\n-; store1             store 1 word to memory from arm registers.\n-; store2             store 2 words to memory from arm registers.\n-; store3             store 3 words to memory from arm registers.\n-; store4             store 4 (or more) words to memory from arm registers.\n-; udiv               unsigned division.\n-; umaal              unsigned multiply accumulate accumulate long.\n-; umlal              unsigned multiply accumulate long.\n-; umlals             unsigned multiply accumulate long, flag setting.\n-; umull              unsigned multiply long.\n-; umulls             unsigned multiply long, flag setting.\n-;\n-; The classification below is for instructions used by the Wireless MMX\n-; Technology. Each attribute value is used to classify an instruction of the\n-; same name or family.\n-;\n-; wmmx_tandc\n-; wmmx_tbcst\n-; wmmx_textrc\n-; wmmx_textrm\n-; wmmx_tinsr\n-; wmmx_tmcr\n-; wmmx_tmcrr\n-; wmmx_tmia\n-; wmmx_tmiaph\n-; wmmx_tmiaxy\n-; wmmx_tmrc\n-; wmmx_tmrrc\n-; wmmx_tmovmsk\n-; wmmx_torc\n-; wmmx_torvsc\n-; wmmx_wabs\n-; wmmx_wdiff\n-; wmmx_wacc\n-; wmmx_wadd\n-; wmmx_waddbhus\n-; wmmx_waddsubhx\n-; wmmx_waligni\n-; wmmx_walignr\n-; wmmx_wand\n-; wmmx_wandn\n-; wmmx_wavg2\n-; wmmx_wavg4\n-; wmmx_wcmpeq\n-; wmmx_wcmpgt\n-; wmmx_wmac\n-; wmmx_wmadd\n-; wmmx_wmax\n-; wmmx_wmerge\n-; wmmx_wmiawxy\n-; wmmx_wmiaxy\n-; wmmx_wmin\n-; wmmx_wmov\n-; wmmx_wmul\n-; wmmx_wmulw\n-; wmmx_wldr\n-; wmmx_wor\n-; wmmx_wpack\n-; wmmx_wqmiaxy\n-; wmmx_wqmulm\n-; wmmx_wqmulwm\n-; wmmx_wror\n-; wmmx_wsad\n-; wmmx_wshufh\n-; wmmx_wsll\n-; wmmx_wsra\n-; wmmx_wsrl\n-; wmmx_wstr\n-; wmmx_wsub\n-; wmmx_wsubaddhx\n-; wmmx_wunpckeh\n-; wmmx_wunpckel\n-; wmmx_wunpckih\n-; wmmx_wunpckil\n-; wmmx_wxor\n-\n-(define_attr \"type\"\n- \"arlo_imm,\\\n-  arlo_reg,\\\n-  arlo_shift,\\\n-  arlo_shift_reg,\\\n-  block,\\\n-  branch,\\\n-  call,\\\n-  clz,\\\n-  extend,\\\n-  f_2_r,\\\n-  f_cvt,\\\n-  f_flag,\\\n-  f_loadd,\\\n-  f_loads,\\\n-  f_minmaxd,\\\n-  f_minmaxs,\\\n-  f_rintd,\\\n-  f_rints,\\\n-  f_seld,\\\n-  f_sels,\\\n-  f_stored,\\\n-  f_stores,\\\n-  faddd,\\\n-  fadds,\\\n-  fcmpd,\\\n-  fcmps,\\\n-  fconstd,\\\n-  fconsts,\\\n-  fcpys,\\\n-  fdivd,\\\n-  fdivs,\\\n-  ffarithd,\\\n-  ffariths,\\\n-  ffmad,\\\n-  ffmas,\\\n-  float,\\\n-  fmacd,\\\n-  fmacs,\\\n-  fmuld,\\\n-  fmuls,\\\n-  load_byte,\\\n-  load1,\\\n-  load2,\\\n-  load3,\\\n-  load4,\\\n-  mla,\\\n-  mlas,\\\n-  mov_imm,\\\n-  mov_reg,\\\n-  mov_shift,\\\n-  mov_shift_reg,\\\n-  mul,\\\n-  muls,\\\n-  mvn_imm,\\\n-  mvn_reg,\\\n-  mvn_shift,\\\n-  mvn_shift_reg,\\\n-  r_2_f,\\\n-  sdiv,\\\n-  shift,\\\n-  shift_reg,\\\n-  smlad,\\\n-  smladx,\\\n-  smlal,\\\n-  smlald,\\\n-  smlals,\\\n-  smlalxy,\\\n-  smlawx,\\\n-  smlawy,\\\n-  smlaxy,\\\n-  smlsd,\\\n-  smlsdx,\\\n-  smlsld,\\\n-  smmla,\\\n-  smmul,\\\n-  smmulr,\\\n-  smuad,\\\n-  smuadx,\\\n-  smull,\\\n-  smulls,\\\n-  smulwy,\\\n-  smulxy,\\\n-  smusd,\\\n-  smusdx,\\\n-  store1,\\\n-  store2,\\\n-  store3,\\\n-  store4,\\\n-  udiv,\\\n-  umaal,\\\n-  umlal,\\\n-  umlals,\\\n-  umull,\\\n-  umulls,\\\n-  wmmx_tandc,\\\n-  wmmx_tbcst,\\\n-  wmmx_textrc,\\\n-  wmmx_textrm,\\\n-  wmmx_tinsr,\\\n-  wmmx_tmcr,\\\n-  wmmx_tmcrr,\\\n-  wmmx_tmia,\\\n-  wmmx_tmiaph,\\\n-  wmmx_tmiaxy,\\\n-  wmmx_tmrc,\\\n-  wmmx_tmrrc,\\\n-  wmmx_tmovmsk,\\\n-  wmmx_torc,\\\n-  wmmx_torvsc,\\\n-  wmmx_wabs,\\\n-  wmmx_wabsdiff,\\\n-  wmmx_wacc,\\\n-  wmmx_wadd,\\\n-  wmmx_waddbhus,\\\n-  wmmx_waddsubhx,\\\n-  wmmx_waligni,\\\n-  wmmx_walignr,\\\n-  wmmx_wand,\\\n-  wmmx_wandn,\\\n-  wmmx_wavg2,\\\n-  wmmx_wavg4,\\\n-  wmmx_wcmpeq,\\\n-  wmmx_wcmpgt,\\\n-  wmmx_wmac,\\\n-  wmmx_wmadd,\\\n-  wmmx_wmax,\\\n-  wmmx_wmerge,\\\n-  wmmx_wmiawxy,\\\n-  wmmx_wmiaxy,\\\n-  wmmx_wmin,\\\n-  wmmx_wmov,\\\n-  wmmx_wmul,\\\n-  wmmx_wmulw,\\\n-  wmmx_wldr,\\\n-  wmmx_wor,\\\n-  wmmx_wpack,\\\n-  wmmx_wqmiaxy,\\\n-  wmmx_wqmulm,\\\n-  wmmx_wqmulwm,\\\n-  wmmx_wror,\\\n-  wmmx_wsad,\\\n-  wmmx_wshufh,\\\n-  wmmx_wsll,\\\n-  wmmx_wsra,\\\n-  wmmx_wsrl,\\\n-  wmmx_wstr,\\\n-  wmmx_wsub,\\\n-  wmmx_wsubaddhx,\\\n-  wmmx_wunpckeh,\\\n-  wmmx_wunpckel,\\\n-  wmmx_wunpckih,\\\n-  wmmx_wunpckil,\\\n-  wmmx_wxor\"\n-  (const_string \"arlo_reg\"))\n-\n-; Is this an (integer side) multiply with a 32-bit (or smaller) result?\n-(define_attr \"mul32\" \"no,yes\"\n-  (if_then_else\n-    (eq_attr \"type\"\n-     \"smulxy,smlaxy,smulwy,smlawx,mul,muls,mla,mlas,smlawy,smuad,smuadx,\\\n-      smlad,smladx,smusd,smusdx,smlsd,smlsdx,smmul,smmulr,smmla,smlald,smlsld\")\n-    (const_string \"yes\")\n-    (const_string \"no\")))\n-\n-; Is this an (integer side) multiply with a 64-bit result?\n-(define_attr \"mul64\" \"no,yes\"\n-  (if_then_else\n-    (eq_attr \"type\"\n-     \"smlalxy,umull,umulls,umaal,umlal,umlals,smull,smulls,smlal,smlals\")\n-    (const_string \"yes\")\n-    (const_string \"no\")))\n+;; Instruction classification types\n+(include \"types.md\")\n \n ; Load scheduling, set from the arm_ld_sched variable\n ; initialized by arm_option_override()"}, {"sha": "f6bcd14edda2374608fd3d4411a6b4072d2b1ff3", "filename": "gcc/config/arm/types.md", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb/gcc%2Fconfig%2Farm%2Ftypes.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb/gcc%2Fconfig%2Farm%2Ftypes.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftypes.md?ref=701bd1bd9cb1d26a57a812fc3d67563d59c3a2fb", "patch": "@@ -0,0 +1,354 @@\n+;; Instruction Classification for ARM for GNU compiler.\n+\n+;; Copyright (C) 1991-2013 Free Software Foundation, Inc.\n+;; Contributed by ARM Ltd.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+; TYPE attribute is used to classify instructions for use in scheduling.\n+;\n+; Instruction classification:\n+;\n+; arlo_imm           any arithmetic or logical instruction that doesn't have\n+;                    a shifted operand and has an immediate operand.  This\n+;                    excludes MOV, MVN and RSB(S) immediate.\n+; arlo_reg           any arithmetic or logical instruction that doesn't have\n+;                    a shifted or an immediate operand.  This excludes\n+;                    MOV and MVN but includes MOVT.  This is also the default.\n+; arlo_shift         any arithmetic or logical instruction that has a source\n+;                    operand shifted by a constant.  This excludes\n+;                    simple shifts.\n+; arlo_shift_reg     as arlo_shift, with the shift amount specified in a\n+;                    register.\n+; block              blockage insn, this blocks all functional units.\n+; branch             branch.\n+; call               subroutine call.\n+; clz                count leading zeros (CLZ).\n+; extend             extend instruction (SXTB, SXTH, UXTB, UXTH).\n+; f_2_r              transfer from float to core (no memory needed).\n+; f_cvt              conversion between float and integral.\n+; f_flag             transfer of co-processor flags to the CPSR.\n+; f_load[d,s]        double/single load from memory.  Used for VFP unit.\n+; f_minmax[d,s]      double/single floating point minimum/maximum.\n+; f_rint[d,s]        double/single floating point rount to integral.\n+; f_sel[d,s]         double/single floating byte select.\n+; f_store[d,s]       double/single store to memory.  Used for VFP unit.\n+; fadd[d,s]          double/single floating-point scalar addition.\n+; fcmp[d,s]          double/single floating-point compare.\n+; fconst[d,s]        double/single load immediate.\n+; fcpys              single precision floating point cpy.\n+; fdiv[d,s]          double/single precision floating point division.\n+; ffarith[d,s]       double/single floating point abs/neg/cpy.\n+; ffma[d,s]          double/single floating point fused multiply-accumulate.\n+; float              floating point arithmetic operation.\n+; fmac[d,s]          double/single floating point multiply-accumulate.\n+; fmul[d,s]          double/single floating point multiply.\n+; load_byte          load byte(s) from memory to arm registers.\n+; load1              load 1 word from memory to arm registers.\n+; load2              load 2 words from memory to arm registers.\n+; load3              load 3 words from memory to arm registers.\n+; load4              load 4 words from memory to arm registers.\n+; mla                integer multiply accumulate.\n+; mlas               integer multiply accumulate, flag setting.\n+; mov_imm            simple MOV instruction that moves an immediate to\n+;                    register.  This includes MOVW, but not MOVT.\n+; mov_reg            simple MOV instruction that moves a register to another\n+;                    register.  This includes MOVW, but not MOVT.\n+; mov_shift          simple MOV instruction, shifted operand by a constant.\n+; mov_shift_reg      simple MOV instruction, shifted operand by a register.\n+; mul                integer multiply.\n+; muls               integer multiply, flag setting.\n+; mvn_imm            inverting move instruction, immediate.\n+; mvn_reg            inverting move instruction, register.\n+; mvn_shift          inverting move instruction, shifted operand by a constant.\n+; mvn_shift_reg      inverting move instruction, shifted operand by a register.\n+; r_2_f              transfer from core to float.\n+; sdiv               signed division.\n+; shift              simple shift operation (LSL, LSR, ASR, ROR) with an\n+;                    immediate.\n+; shift_reg          simple shift by a register.\n+; smlad              signed multiply accumulate dual.\n+; smladx             signed multiply accumulate dual reverse.\n+; smlal              signed multiply accumulate long.\n+; smlald             signed multiply accumulate long dual.\n+; smlals             signed multiply accumulate long, flag setting.\n+; smlalxy            signed multiply accumulate, 16x16-bit, 64-bit accumulate.\n+; smlawx             signed multiply accumulate, 32x16-bit, 32-bit accumulate.\n+; smlawy             signed multiply accumulate wide, 32x16-bit,\n+;                    32-bit accumulate.\n+; smlaxy             signed multiply accumulate, 16x16-bit, 32-bit accumulate.\n+; smlsd              signed multiply subtract dual.\n+; smlsdx             signed multiply subtract dual reverse.\n+; smlsld             signed multiply subtract long dual.\n+; smmla              signed most significant word multiply accumulate.\n+; smmul              signed most significant word multiply.\n+; smmulr             signed most significant word multiply, rounded.\n+; smuad              signed dual multiply add.\n+; smuadx             signed dual multiply add reverse.\n+; smull              signed multiply long.\n+; smulls             signed multiply long, flag setting.\n+; smulwy             signed multiply wide, 32x16-bit, 32-bit accumulate.\n+; smulxy             signed multiply, 16x16-bit, 32-bit accumulate.\n+; smusd              signed dual multiply subtract.\n+; smusdx             signed dual multiply subtract reverse.\n+; store1             store 1 word to memory from arm registers.\n+; store2             store 2 words to memory from arm registers.\n+; store3             store 3 words to memory from arm registers.\n+; store4             store 4 (or more) words to memory from arm registers.\n+; udiv               unsigned division.\n+; umaal              unsigned multiply accumulate accumulate long.\n+; umlal              unsigned multiply accumulate long.\n+; umlals             unsigned multiply accumulate long, flag setting.\n+; umull              unsigned multiply long.\n+; umulls             unsigned multiply long, flag setting.\n+;\n+; The classification below is for instructions used by the Wireless MMX\n+; Technology. Each attribute value is used to classify an instruction of the\n+; same name or family.\n+;\n+; wmmx_tandc\n+; wmmx_tbcst\n+; wmmx_textrc\n+; wmmx_textrm\n+; wmmx_tinsr\n+; wmmx_tmcr\n+; wmmx_tmcrr\n+; wmmx_tmia\n+; wmmx_tmiaph\n+; wmmx_tmiaxy\n+; wmmx_tmrc\n+; wmmx_tmrrc\n+; wmmx_tmovmsk\n+; wmmx_torc\n+; wmmx_torvsc\n+; wmmx_wabs\n+; wmmx_wdiff\n+; wmmx_wacc\n+; wmmx_wadd\n+; wmmx_waddbhus\n+; wmmx_waddsubhx\n+; wmmx_waligni\n+; wmmx_walignr\n+; wmmx_wand\n+; wmmx_wandn\n+; wmmx_wavg2\n+; wmmx_wavg4\n+; wmmx_wcmpeq\n+; wmmx_wcmpgt\n+; wmmx_wmac\n+; wmmx_wmadd\n+; wmmx_wmax\n+; wmmx_wmerge\n+; wmmx_wmiawxy\n+; wmmx_wmiaxy\n+; wmmx_wmin\n+; wmmx_wmov\n+; wmmx_wmul\n+; wmmx_wmulw\n+; wmmx_wldr\n+; wmmx_wor\n+; wmmx_wpack\n+; wmmx_wqmiaxy\n+; wmmx_wqmulm\n+; wmmx_wqmulwm\n+; wmmx_wror\n+; wmmx_wsad\n+; wmmx_wshufh\n+; wmmx_wsll\n+; wmmx_wsra\n+; wmmx_wsrl\n+; wmmx_wstr\n+; wmmx_wsub\n+; wmmx_wsubaddhx\n+; wmmx_wunpckeh\n+; wmmx_wunpckel\n+; wmmx_wunpckih\n+; wmmx_wunpckil\n+; wmmx_wxor\n+\n+(define_attr \"type\"\n+ \"arlo_imm,\\\n+  arlo_reg,\\\n+  arlo_shift,\\\n+  arlo_shift_reg,\\\n+  block,\\\n+  branch,\\\n+  call,\\\n+  clz,\\\n+  extend,\\\n+  f_2_r,\\\n+  f_cvt,\\\n+  f_flag,\\\n+  f_loadd,\\\n+  f_loads,\\\n+  f_minmaxd,\\\n+  f_minmaxs,\\\n+  f_rintd,\\\n+  f_rints,\\\n+  f_seld,\\\n+  f_sels,\\\n+  f_stored,\\\n+  f_stores,\\\n+  faddd,\\\n+  fadds,\\\n+  fcmpd,\\\n+  fcmps,\\\n+  fconstd,\\\n+  fconsts,\\\n+  fcpys,\\\n+  fdivd,\\\n+  fdivs,\\\n+  ffarithd,\\\n+  ffariths,\\\n+  ffmad,\\\n+  ffmas,\\\n+  float,\\\n+  fmacd,\\\n+  fmacs,\\\n+  fmuld,\\\n+  fmuls,\\\n+  load_byte,\\\n+  load1,\\\n+  load2,\\\n+  load3,\\\n+  load4,\\\n+  mla,\\\n+  mlas,\\\n+  mov_imm,\\\n+  mov_reg,\\\n+  mov_shift,\\\n+  mov_shift_reg,\\\n+  mul,\\\n+  muls,\\\n+  mvn_imm,\\\n+  mvn_reg,\\\n+  mvn_shift,\\\n+  mvn_shift_reg,\\\n+  r_2_f,\\\n+  sdiv,\\\n+  shift,\\\n+  shift_reg,\\\n+  smlad,\\\n+  smladx,\\\n+  smlal,\\\n+  smlald,\\\n+  smlals,\\\n+  smlalxy,\\\n+  smlawx,\\\n+  smlawy,\\\n+  smlaxy,\\\n+  smlsd,\\\n+  smlsdx,\\\n+  smlsld,\\\n+  smmla,\\\n+  smmul,\\\n+  smmulr,\\\n+  smuad,\\\n+  smuadx,\\\n+  smull,\\\n+  smulls,\\\n+  smulwy,\\\n+  smulxy,\\\n+  smusd,\\\n+  smusdx,\\\n+  store1,\\\n+  store2,\\\n+  store3,\\\n+  store4,\\\n+  udiv,\\\n+  umaal,\\\n+  umlal,\\\n+  umlals,\\\n+  umull,\\\n+  umulls,\\\n+  wmmx_tandc,\\\n+  wmmx_tbcst,\\\n+  wmmx_textrc,\\\n+  wmmx_textrm,\\\n+  wmmx_tinsr,\\\n+  wmmx_tmcr,\\\n+  wmmx_tmcrr,\\\n+  wmmx_tmia,\\\n+  wmmx_tmiaph,\\\n+  wmmx_tmiaxy,\\\n+  wmmx_tmrc,\\\n+  wmmx_tmrrc,\\\n+  wmmx_tmovmsk,\\\n+  wmmx_torc,\\\n+  wmmx_torvsc,\\\n+  wmmx_wabs,\\\n+  wmmx_wabsdiff,\\\n+  wmmx_wacc,\\\n+  wmmx_wadd,\\\n+  wmmx_waddbhus,\\\n+  wmmx_waddsubhx,\\\n+  wmmx_waligni,\\\n+  wmmx_walignr,\\\n+  wmmx_wand,\\\n+  wmmx_wandn,\\\n+  wmmx_wavg2,\\\n+  wmmx_wavg4,\\\n+  wmmx_wcmpeq,\\\n+  wmmx_wcmpgt,\\\n+  wmmx_wmac,\\\n+  wmmx_wmadd,\\\n+  wmmx_wmax,\\\n+  wmmx_wmerge,\\\n+  wmmx_wmiawxy,\\\n+  wmmx_wmiaxy,\\\n+  wmmx_wmin,\\\n+  wmmx_wmov,\\\n+  wmmx_wmul,\\\n+  wmmx_wmulw,\\\n+  wmmx_wldr,\\\n+  wmmx_wor,\\\n+  wmmx_wpack,\\\n+  wmmx_wqmiaxy,\\\n+  wmmx_wqmulm,\\\n+  wmmx_wqmulwm,\\\n+  wmmx_wror,\\\n+  wmmx_wsad,\\\n+  wmmx_wshufh,\\\n+  wmmx_wsll,\\\n+  wmmx_wsra,\\\n+  wmmx_wsrl,\\\n+  wmmx_wstr,\\\n+  wmmx_wsub,\\\n+  wmmx_wsubaddhx,\\\n+  wmmx_wunpckeh,\\\n+  wmmx_wunpckel,\\\n+  wmmx_wunpckih,\\\n+  wmmx_wunpckil,\\\n+  wmmx_wxor\"\n+  (const_string \"arlo_reg\"))\n+\n+; Is this an (integer side) multiply with a 32-bit (or smaller) result?\n+(define_attr \"mul32\" \"no,yes\"\n+  (if_then_else\n+    (eq_attr \"type\"\n+     \"smulxy,smlaxy,smulwy,smlawx,mul,muls,mla,mlas,smlawy,smuad,smuadx,\\\n+      smlad,smladx,smusd,smusdx,smlsd,smlsdx,smmul,smmulr,smmla,smlald,smlsld\")\n+    (const_string \"yes\")\n+    (const_string \"no\")))\n+\n+; Is this an (integer side) multiply with a 64-bit result?\n+(define_attr \"mul64\" \"no,yes\"\n+  (if_then_else\n+    (eq_attr \"type\"\n+     \"smlalxy,umull,umulls,umaal,umlal,umlals,smull,smulls,smlal,smlals\")\n+    (const_string \"yes\")\n+    (const_string \"no\")))"}]}