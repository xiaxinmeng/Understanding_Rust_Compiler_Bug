{"sha": "d061bc1e93f961c03cc6105d96540dd1a97adf72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA2MWJjMWU5M2Y5NjFjMDNjYzYxMDVkOTY1NDBkZDFhOTdhZGY3Mg==", "commit": {"author": {"name": "Stan Cox", "email": "scox@redhat.com", "date": "2000-08-22T16:16:20Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "2000-08-22T16:16:20Z"}, "message": "Makefile.in (OBJS): Add dependence.o.\n\n\t* Makefile.in (OBJS): Add dependence.o.\n\t* dependence.c: New file.\n\nFrom-SVN: r35876", "tree": {"sha": "d70590c530c0b59b993a77f9a6236d30a8a481f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d70590c530c0b59b993a77f9a6236d30a8a481f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d061bc1e93f961c03cc6105d96540dd1a97adf72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d061bc1e93f961c03cc6105d96540dd1a97adf72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d061bc1e93f961c03cc6105d96540dd1a97adf72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d061bc1e93f961c03cc6105d96540dd1a97adf72/comments", "author": {"login": "stanfordcox", "id": 18171344, "node_id": "MDQ6VXNlcjE4MTcxMzQ0", "avatar_url": "https://avatars.githubusercontent.com/u/18171344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stanfordcox", "html_url": "https://github.com/stanfordcox", "followers_url": "https://api.github.com/users/stanfordcox/followers", "following_url": "https://api.github.com/users/stanfordcox/following{/other_user}", "gists_url": "https://api.github.com/users/stanfordcox/gists{/gist_id}", "starred_url": "https://api.github.com/users/stanfordcox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stanfordcox/subscriptions", "organizations_url": "https://api.github.com/users/stanfordcox/orgs", "repos_url": "https://api.github.com/users/stanfordcox/repos", "events_url": "https://api.github.com/users/stanfordcox/events{/privacy}", "received_events_url": "https://api.github.com/users/stanfordcox/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3cadd7783a7d69837dc2f60e448f156ca03215a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cadd7783a7d69837dc2f60e448f156ca03215a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cadd7783a7d69837dc2f60e448f156ca03215a0"}], "stats": {"total": 1467, "additions": 1466, "deletions": 1}, "files": [{"sha": "5700c4f163556101559e433afc109714635cb801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d061bc1e93f961c03cc6105d96540dd1a97adf72/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d061bc1e93f961c03cc6105d96540dd1a97adf72/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d061bc1e93f961c03cc6105d96540dd1a97adf72", "patch": "@@ -1,3 +1,8 @@\n+2000-08-22  Stan Cox  <scox@redhat.com>\n+\n+        * Makefile.in (OBJS): Add dependence.o.\n+        * dependence.c: New file.\n+        \n 2000-08-22  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* invoke.texi (SH Options): Document -m4-nofpu,"}, {"sha": "de7e5b882e7f92bad8614ce406370ff4669f7281", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d061bc1e93f961c03cc6105d96540dd1a97adf72/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d061bc1e93f961c03cc6105d96540dd1a97adf72/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d061bc1e93f961c03cc6105d96540dd1a97adf72", "patch": "@@ -696,7 +696,7 @@ OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o  \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o\t      \\\n  mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t      \\\n  lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o\t\t      \\\n- sibcall.o conflict.o timevar.o ifcvt.o dce.o\n+ sibcall.o conflict.o timevar.o ifcvt.o dependence.o dce.o\n \n BACKEND = toplev.o libbackend.a\n \n@@ -1411,6 +1411,9 @@ regrename.o : regrename.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n ifcvt.o : ifcvt.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    flags.h insn-config.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(EXPR_H) \\\n    output.h\n+dependence.o : dependence.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) c-common.h \\\n+   flags.h varray.h\n+\n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) $(GGC_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\\n    insn-flags.h output.h $(INSN_ATTR_H) insn-codes.h system.h toplev.h function.h"}, {"sha": "a8174c10acf73757f614b401ba6882afc0da5dad", "filename": "gcc/dependence.c", "status": "added", "additions": 1457, "deletions": 0, "changes": 1457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d061bc1e93f961c03cc6105d96540dd1a97adf72/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d061bc1e93f961c03cc6105d96540dd1a97adf72/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=d061bc1e93f961c03cc6105d96540dd1a97adf72", "patch": "@@ -0,0 +1,1457 @@\n+/* CYGNUS LOCAL dependency analysis */\n+\n+/* Analyze loop dependencies\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* References:\n+   Practical Dependence Testing, Goff, Kennedy, Tseng, PLDI, 1991\n+   High Performance Compilers for Parallel Computing, Wolfe\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"c-common.h\"\n+#include \"flags.h\"\n+#include \"varray.h\"\n+\n+#define MAX_SUBSCRIPTS 13\n+\n+/*\n+   We perform the following steps:\n+\n+   Build the data structures def_use_chain, loop_chain, and induction_chain.\n+\n+   Determine if a loop index is a normalized induction variable.\n+   A loop is currently considered to be a for loop having an index set to an\n+   initial value, conditional check of the index, and increment/decrement of\n+   the index.\n+\n+   Determine the distance and direction vectors.  Both are two dimensioned\n+   arrays where the first dimension represents a loop and the second\n+   dimension represents a subscript.  Dependencies are actually per loop, not\n+   per subscript.  So for:\n+   for (i = 0; i < 10; i++)\n+       for (j = 0; j < 10; j++)\n+           array [i][j] = array[i][j-1]\n+   We find the dependencies: loop1/sub_i, loop1/sub_j, loop2/sub_i, loop2/sub_j\n+   and then intersect loop1/sub_i V loop2/sub_i and loop1/sub_i V loop2/sub_j\n+   We determine the type of dependence, which determines which test we use.\n+   We then try to refine the type of dependence we have and add the\n+   dependence to the dep_chain\n+*/\n+\n+enum dependence_type {flow, anti, output, none};\n+static const char * dependence_string [] = {\"flow\", \"anti\", \"output\", \"none\"};\n+\n+enum direction_type {lt, le, eq, gt, ge, star, independent, undef};\n+static const char * direction_string [] = {\"<\", \"<=\", \"=\", \">\", \">=\", \"*\",\n+\t\t\t\t\t   \"INDEPENDENT\", \"UNDEFINED\"};\n+\n+enum def_use_type {def, use, init_def_use};\n+\n+enum du_status_type {seen, unseen};\n+\n+enum loop_status_type {normal, unnormal};\n+\n+enum complexity_type {ziv, strong_siv, weak_siv, weak_zero_siv,\n+\t\t      weak_crossing_siv, miv};\n+\n+/* Given a def/use one can chase the next chain to follow the def/use\n+   for that variable.  Alternately one can sequentially follow each\n+   element of def_use_chain. */\n+\n+typedef struct def_use\n+{\n+  /* outermost loop */\n+  tree outer_loop;\n+  /* loop containing this def/use */\n+  tree containing_loop;\n+  /* this expression */\n+  tree expression;\n+  /* our name */\n+  char *variable;\n+  /* def or use */\n+  enum def_use_type type;\n+  /* status flags */\n+  enum du_status_type status;\n+  /* next def/use for this same name */\n+  struct def_use *next;\n+  /* dependencies for this def */\n+  struct dependence *dep;\n+} def_use;\n+\n+/* Given a loop* one can chase the next_nest chain to follow the nested\n+   loops for that loop.  Alternately one can sequentially follow each\n+   element of loop_chain and check outer_loop to get all loops\n+   contained within a certain loop. */\n+\n+typedef struct loop\n+{\n+  /* outermost loop containing this loop */\n+  tree outer_loop;\n+  /* this loop */\n+  tree containing_loop;\n+  /* nest level for this loop */\n+  int  depth;\n+  /* can loop be normalized? */\n+  enum loop_status_type status;\n+  /* loop* for loop contained in this loop */\n+  struct loop *next_nest;\n+  /* induction variables for this loop.  Currently only the index variable. */\n+  struct induction *ind;\n+} loop;\n+\n+/* Pointed to by loop. One per induction variable. */\n+\n+typedef struct induction\n+{\n+  /* our name */\n+  char *variable;\n+  /* increment.  Currently only +1 or -1 */\n+  int  increment;\n+  /* lower bound */\n+  int  low_bound;\n+  /* upper bound */\n+  int  high_bound;\n+  /* next induction variable for this loop.  Currently null. */\n+  struct induction *next;\n+} induction;\n+\n+/* Pointed to by def/use.  One per dependence. */\n+\n+typedef struct dependence\n+{\n+  tree source;\n+  tree destination;\n+  enum dependence_type dependence;\n+  enum direction_type direction[MAX_SUBSCRIPTS];\n+  int distance[MAX_SUBSCRIPTS];\n+  struct dependence *next;\n+} dependence;\n+  \n+/* subscripts are represented by an array of these.  Each reflects one\n+   X * i + Y term, where X and Y are constants.  */\n+\n+typedef struct subscript\n+{\n+  /* ordinal subscript number */\n+  int position;\n+  /* X in X * i + Y */\n+  int coefficient;\n+  /* Y in X * i + Y */\n+  int offset;\n+  /* our name */\n+  char *variable;\n+  /* next subscript term.  Currently null. */\n+  struct subscript *next;\n+} subscript;\n+\n+/* Remember the destination the front end encountered. */\n+\n+static tree dest_to_remember;\n+\n+/* Chain for def_use */\n+static varray_type def_use_chain;\n+\n+/* Chain for dependence */\n+static varray_type dep_chain;\n+\n+/* Chain for loop */\n+static varray_type loop_chain;\n+\n+/* Chain for induction */\n+static varray_type induction_chain;\n+\n+void init_dependence_analysis PARAMS ((tree));\n+static void build_def_use PARAMS ((tree, enum def_use_type));\n+static loop* add_loop PARAMS ((tree, tree, int));\n+static int find_induction_variable PARAMS ((tree, tree, tree, loop*));\n+static int get_low_bound PARAMS ((tree, char*));\n+static int have_induction_variable PARAMS ((tree, char*));\n+static void link_loops PARAMS ((void));\n+static void get_node_dependence PARAMS ((void));\n+static void check_node_dependence PARAMS ((def_use*));\n+static int get_coefficients PARAMS ((def_use*, subscript[]));\n+static int get_one_coefficient PARAMS ((tree, subscript*, def_use*, enum tree_code*));\n+static void normalize_coefficients PARAMS ((subscript[], loop*, int));\n+static void classify_dependence PARAMS ((subscript[], subscript[],\n+\t\t\t\t enum complexity_type[], int*, int));\n+static void ziv_test PARAMS ((subscript[], subscript[], enum direction_type[][],\n+\t\t      int[][], loop*, int));\n+static void siv_test PARAMS ((subscript[], subscript[], enum direction_type[][],\n+\t\t      int[][], loop*, int));\n+static int check_subscript_induction PARAMS ((subscript*, subscript*, loop*));\n+static void gcd_test PARAMS ((subscript[], subscript[], enum direction_type[][],\n+\t\t      int[][], loop*, int));\n+static int find_gcd PARAMS ((int, int));\n+static void merge_dependencies PARAMS ((enum direction_type[][], int[][], int, int));\n+static void dump_array_ref PARAMS ((tree));\n+static void dump_one_node PARAMS ((def_use*, varray_type*));\n+static void dump_node_dependence PARAMS ((void));\n+int search_dependence PARAMS ((tree));\n+void remember_dest_for_dependence PARAMS ((tree));\n+int have_dependence_p PARAMS ((rtx, rtx, enum direction_type[], int[]));\n+void end_dependence_analysis PARAMS ((void));\n+\n+/* Build dependence chain 'dep_chain', which is used by have_dependence_p,\n+   for the function given by EXP. */\n+\n+void\n+init_dependence_analysis (exp)\n+     tree exp;\n+{\n+  def_use *du_ptr;\n+\n+  VARRAY_GENERIC_PTR_INIT (def_use_chain, 50, \"def_use_chain\");\n+  VARRAY_GENERIC_PTR_INIT (dep_chain, 50, \"dep_chain\");\n+  VARRAY_GENERIC_PTR_INIT (loop_chain, 50, \"loop_chain\");\n+  VARRAY_GENERIC_PTR_INIT (induction_chain, 50, \"induction_chain\");\n+\n+  build_def_use (exp, init_def_use);\n+\n+  link_loops ();\n+\n+  get_node_dependence ();\n+\n+  /* dump_node_dependence (&def_use_chain);*/\n+\n+  for (du_ptr = VARRAY_TOP (def_use_chain, generic);\n+       VARRAY_POP (def_use_chain);\n+       du_ptr = VARRAY_TOP (def_use_chain, generic))\n+    {\n+      free (du_ptr);\n+    }\n+\n+  VARRAY_FREE (def_use_chain);\n+  VARRAY_FREE (loop_chain);\n+  VARRAY_FREE (induction_chain);\n+}\n+\n+/* Build ARRAY_REF def/use info 'def_use_chain' starting at EXP which is a def\n+   or use DU_TYPE */ \n+\n+static void\n+build_def_use (exp, du_type)\n+     tree exp;\n+     enum def_use_type du_type;\n+{\n+  static tree outer_loop;\n+  static int nloop;\n+  static tree current_loop;\n+  static int du_idx;\n+  static loop *loop_def;\n+  tree node = exp;\n+  tree array_ref;\n+  int array_idx;\n+  def_use *du_ptr;\n+\n+  if (du_type == init_def_use)\n+    {\n+      outer_loop = 0;\n+      nloop = 0;\n+      du_idx = 0;\n+    }\n+  \n+  while (node)\n+    switch (TREE_CODE (node))\n+      {\n+      case COMPOUND_STMT:\n+\tnode = TREE_OPERAND (node, 0);\n+\tbreak;\n+      case TREE_LIST:\n+\tbuild_def_use (TREE_VALUE (node), 0);\n+\tnode = TREE_CHAIN (node);\n+\tbreak;\n+      case CALL_EXPR:\n+\tnode = TREE_CHAIN (node);\n+\tbreak;\n+      case FOR_STMT:\n+\tif (! nloop) outer_loop = node;\n+\tnloop++;\n+\tcurrent_loop = node;\n+\tloop_def = add_loop (node, outer_loop, nloop);\n+\tif (find_induction_variable (TREE_OPERAND (node, 0),\n+\t\t\t\t     TREE_OPERAND (node, 1),\n+\t\t\t\t     TREE_OPERAND (node, 2), loop_def)\n+\t    == 0)\n+\t  loop_def->status = unnormal;\n+\t  \n+\tbuild_def_use (TREE_OPERAND (node, 3), 0);\n+\tnloop--;\n+\tcurrent_loop = 0;\n+\tnode = TREE_CHAIN (node);\n+\tbreak;\n+      case MODIFY_EXPR:\n+\t/* Is an induction variable modified? */\n+\tif (loop_def \n+\t    && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n+\t    && have_induction_variable\n+\t       (loop_def->outer_loop,\n+\t\tIDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (node, 0)))) >= 0)\n+\t  loop_def->status = unnormal;\n+\n+\tif (TREE_CODE (TREE_OPERAND (node, 0)) == ARRAY_REF\n+\t    || TREE_CODE (TREE_OPERAND (node, 0)) == INDIRECT_REF)\n+\t  build_def_use (TREE_OPERAND (node, 0), def);\n+\n+\tbuild_def_use (TREE_OPERAND (node, 1), use);\n+\tnode = TREE_CHAIN (node);\n+\tbreak;\n+      case INDIRECT_REF:\n+\tif (! TREE_OPERAND (node, 1)\n+\t    || TREE_CODE (TREE_OPERAND (node, 1)) != ARRAY_REF)\n+\t  {\n+\t    node = 0;\n+\t    break;\n+\t  }\n+\tnode = TREE_OPERAND (node, 1);\n+      case ARRAY_REF:\n+\tif (nloop)\n+\t  {\n+\t    int i;\n+\t    char null_string = '\\0';\n+\n+\t    VARRAY_PUSH_GENERIC_PTR (def_use_chain, xmalloc (sizeof (def_use)));\n+\t    du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++);\n+\t    du_ptr->type = du_type;\n+\t    du_ptr->status = unseen;\n+\t    du_ptr->outer_loop = outer_loop;\n+\t    du_ptr->containing_loop = current_loop;\n+\t    du_ptr->expression = node;\n+\t    du_ptr->variable = &null_string;\n+\t    du_ptr->next = 0;\n+\t    du_ptr->dep = 0;\n+\t    for (array_ref = node;\n+\t\t TREE_CODE (array_ref) == ARRAY_REF;\n+\t\t array_ref = TREE_OPERAND (array_ref, 0))\n+\t      ;\n+\n+\t    if (TREE_CODE (array_ref) == COMPONENT_REF)\n+\t      {\n+\t\tarray_ref = TREE_OPERAND (array_ref, 1);\n+\t\tif (! (TREE_CODE (array_ref) == FIELD_DECL\n+\t\t       && TREE_CODE (TREE_TYPE (array_ref)) == ARRAY_TYPE))\n+\t\t  {\n+\t\t    node = 0;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    \n+\t    array_idx -= 1;\n+\n+\t    for (i = 0;\n+\t\t i < du_idx\n+\t\t   && strcmp (IDENTIFIER_POINTER (DECL_NAME (array_ref)),\n+\t\t\t      ((def_use*) (VARRAY_GENERIC_PTR\n+\t\t\t\t\t   (def_use_chain, i)))->variable);\n+\t\t i++)\n+\t      ;\n+\t    if (i != du_idx)\n+\t      {\n+\t\tdef_use *tmp_duc;\n+\t\tfor (tmp_duc = ((def_use*) (VARRAY_GENERIC_PTR (def_use_chain, i)));\n+\t\t     tmp_duc->next;\n+\t\t     tmp_duc = ((def_use*)tmp_duc->next));\n+\t\ttmp_duc->next = du_ptr;\n+\t      }\n+\t    else du_ptr->next = 0;\n+\t    du_ptr->variable = IDENTIFIER_POINTER (DECL_NAME (array_ref));\n+\t  }\n+\tnode = 0;\n+\tbreak;\n+\n+      case SCOPE_STMT:\n+      case DECL_STMT:\n+\tnode = TREE_CHAIN (node);\n+\tbreak;\n+\t\n+      case EXPR_STMT:\n+\tif (TREE_CODE (TREE_OPERAND (node, 0)) == MODIFY_EXPR)\n+\t  build_def_use (TREE_OPERAND (node, 0), def);\n+\tnode = TREE_CHAIN (node);\n+\tbreak;\n+\n+      default:\n+\tif (TREE_CODE_CLASS (TREE_CODE (node)) == '2')\n+\t  {\n+\t    build_def_use (TREE_OPERAND (node, 0), use);\n+\t    build_def_use (TREE_OPERAND (node, 1), use);\n+\t    node = TREE_CHAIN (node);\n+\t  }\n+\telse\n+\t  node = 0;\n+      }\n+}\n+\n+/* Add a loop to 'loop_chain' corresponding to for loop LOOP_NODE at depth\n+   NLOOP, whose outermost loop is OUTER_LOOP */\n+\n+static loop*\n+add_loop (loop_node, outer_loop, nloop)\n+     tree loop_node;\n+     tree outer_loop;\n+     int nloop;\n+{\n+  loop *loop_ptr;\n+\n+  VARRAY_PUSH_GENERIC_PTR (loop_chain, xmalloc (sizeof (loop)));\n+  loop_ptr = VARRAY_TOP (loop_chain, generic);\n+  loop_ptr->outer_loop = outer_loop;\n+  loop_ptr->containing_loop = loop_node;\n+  loop_ptr->depth = nloop;\n+  loop_ptr->status = normal;\n+  loop_ptr->next_nest = 0;\n+  loop_ptr->ind = 0;\n+  return loop_ptr;\n+}\n+\n+/* Update LOOP_DEF if for loop's COND_NODE and INCR_NODE define an index that\n+   is a normalized induction variable. */\n+\n+static int\n+find_induction_variable (init_node, cond_node, incr_node, loop_def)\n+     tree init_node;\n+     tree cond_node;\n+     tree incr_node;\n+     loop *loop_def;\n+{\n+  induction *ind_ptr;\n+  enum tree_code incr_code;\n+  tree incr;\n+\n+  if (! init_node || ! incr_node || ! cond_node)\n+    return 0;\n+  /* Allow for ',' operator in increment expression of FOR */\n+\n+  incr = incr_node;\n+  while (TREE_CODE (incr) == COMPOUND_EXPR)\n+    {\n+      incr_code = TREE_CODE (TREE_OPERAND (incr, 0));\n+      if (incr_code == PREDECREMENT_EXPR || incr_code == POSTDECREMENT_EXPR\n+\t  || incr_code == PREINCREMENT_EXPR || incr_code == POSTINCREMENT_EXPR)\n+\t{\n+\t  incr_node = TREE_OPERAND (incr, 0);\n+\t  break;\n+\t}\n+      incr_code = TREE_CODE (TREE_OPERAND (incr, 1));\n+      if (incr_code == PREDECREMENT_EXPR || incr_code == POSTDECREMENT_EXPR\n+\t  || incr_code == PREINCREMENT_EXPR || incr_code == POSTINCREMENT_EXPR)\n+\t{\n+\t  incr_node = TREE_OPERAND (incr, 1);\n+\t  break;\n+\t}\n+      incr = TREE_OPERAND (incr, 1);\n+    }\n+\n+  /* Allow index condition to be part of logical expression */\n+  cond_node = TREE_VALUE (cond_node);\n+  incr = cond_node;\n+\n+#define INDEX_LIMIT_CHECK(node) \\\n+      (TREE_CODE_CLASS (TREE_CODE (node)) == '<') \\\n+\t&& (TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL \\\n+\t    && (IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (node, 0))) \\\n+\t\t== IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (incr_node, 0))))) \\\n+      ? 1 : 0\n+\n+  while (TREE_CODE (incr) == TRUTH_ANDIF_EXPR\n+\t || TREE_CODE (incr) == TRUTH_ORIF_EXPR)\n+    {\n+      if (INDEX_LIMIT_CHECK (TREE_OPERAND (incr, 0)))\n+\t  {\n+\t    cond_node = TREE_OPERAND (incr, 0);\n+\t    break;\n+\t  }\n+      if (INDEX_LIMIT_CHECK (TREE_OPERAND (incr, 1)))\n+\t  {\n+\t    cond_node = TREE_OPERAND (incr, 1);\n+\t    break;\n+\t  }\n+      incr = TREE_OPERAND (incr, 0);\n+    }\n+\n+  incr_code = TREE_CODE (incr_node);\n+  if ((incr_code == PREDECREMENT_EXPR || incr_code == POSTDECREMENT_EXPR\n+       || incr_code == PREINCREMENT_EXPR || incr_code == POSTINCREMENT_EXPR)\n+      && TREE_CODE_CLASS (TREE_CODE (cond_node)) == '<')\n+    {\n+      if (!INDEX_LIMIT_CHECK (cond_node))\n+\treturn 0;\n+\n+      VARRAY_PUSH_GENERIC_PTR (induction_chain, xmalloc (sizeof (induction)));\n+      ind_ptr = VARRAY_TOP (induction_chain, generic);\n+      loop_def->ind = ind_ptr;\n+      ind_ptr->variable = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND\n+\t\t\t\t\t\t\t (incr_node, 0)));\n+      ind_ptr->increment = TREE_INT_CST_LOW (TREE_OPERAND (incr_node, 1));\n+      if (TREE_CODE (incr_node) == PREDECREMENT_EXPR\n+\t  || TREE_CODE (incr_node) == POSTDECREMENT_EXPR)\n+\tind_ptr->increment = -ind_ptr->increment;\n+\n+      ind_ptr->low_bound = get_low_bound (init_node, ind_ptr->variable);\n+      if (TREE_CODE (TREE_OPERAND (cond_node, 0)) == VAR_DECL\n+\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 0))) \n+\t     == ind_ptr->variable)\n+\tif (TREE_CODE (TREE_OPERAND (cond_node, 1)) == INTEGER_CST)\n+\t  ind_ptr->high_bound = TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 1));\n+\telse\n+\t  ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n+      else if (TREE_CODE (TREE_OPERAND (cond_node, 1)) == VAR_DECL\n+\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 1)))\n+\t       == ind_ptr->variable)\n+\tif (TREE_CODE (TREE_OPERAND (cond_node, 0)) == INTEGER_CST)\n+\t  ind_ptr->high_bound = TREE_INT_CST_LOW (TREE_OPERAND (cond_node, 0));\n+\telse\n+\t  ind_ptr->high_bound = ind_ptr->increment < 0 ? INT_MIN : INT_MAX;\n+      ind_ptr->next = 0;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return the low bound for induction VARIABLE in NODE */\n+\n+int\n+get_low_bound (node, variable)\n+     tree node;\n+     char *variable;\n+{\n+\n+  if (TREE_CODE (node) == SCOPE_STMT)\n+    node = TREE_CHAIN (node);\n+\n+  if (! node)\n+    return INT_MIN;\n+\n+  while (TREE_CODE (node) == COMPOUND_EXPR)\n+    {\n+      if (TREE_CODE (TREE_OPERAND (node, 0)) == MODIFY_EXPR\n+\t  && (TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n+\t      && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (node, 0)))\n+\t      == variable))\n+\tbreak;\n+    }\n+\n+  if (TREE_CODE (node) == EXPR_STMT)\n+    node = TREE_OPERAND (node, 0);\n+  if (TREE_CODE (node) == MODIFY_EXPR\n+      && (TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n+\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (node, 0)))\n+\t  == variable))\n+    {\n+      return TREE_INT_CST_LOW (TREE_OPERAND (node, 1));\n+    }\n+  return INT_MIN;\n+}\n+\n+\n+/* Return the ordinal subscript position for IND_VAR if it is an induction\n+   variable contained in OUTER_LOOP, otherwise return -1. */\n+\n+static int\n+have_induction_variable (outer_loop, ind_var)\n+     tree outer_loop;\n+     char *ind_var;\n+{\n+  induction *ind_ptr;\n+  loop *loop_ptr;\n+  unsigned int ind_idx = 0;\n+  unsigned int loop_idx = 0;\n+\n+  for (loop_ptr = VARRAY_GENERIC_PTR (loop_chain, loop_idx);\n+       loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n+       loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n+    if (loop_ptr->outer_loop == outer_loop)\n+      for (ind_ptr = loop_ptr->ind;\n+\t   ind_ptr && ind_idx < VARRAY_SIZE (induction_chain);\n+\t   ind_ptr = ind_ptr->next)\n+\t{\n+\t  if (! strcmp (ind_ptr->variable, ind_var))\n+\t    return loop_idx + 1;\n+\t}\n+  return -1;\n+}\n+\n+/* Chain the nodes of 'loop_chain'. */\n+\n+static void\n+link_loops ()\n+{\n+  unsigned int loop_idx = 0;\n+  loop *loop_ptr, *prev_loop_ptr = 0;\n+\n+  prev_loop_ptr = VARRAY_GENERIC_PTR (loop_chain, loop_idx);\n+  for (loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx);\n+       loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n+       loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n+    {\n+      if (prev_loop_ptr->outer_loop == loop_ptr->outer_loop)\n+\t{\n+\t  if (prev_loop_ptr->depth == loop_ptr->depth - 1)\n+\t    prev_loop_ptr->next_nest = loop_ptr;\n+\t  prev_loop_ptr = loop_ptr;\n+\t}\n+    }\n+}\n+\n+/* Check the dependence for each member of 'def_use_chain'. */\n+\n+static void\n+get_node_dependence ()\n+{\n+  unsigned int du_idx;\n+  def_use *du_ptr;\n+\n+  du_idx = 0;\n+  for (du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx);\n+       du_ptr && du_idx < VARRAY_SIZE (def_use_chain);\n+       du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++))\n+    {\n+      if (du_ptr->status == unseen)\n+\tcheck_node_dependence (du_ptr);\n+    }\n+}\n+\n+/* Check the dependence for definition DU. */\n+\n+static void\n+check_node_dependence (du)\n+     def_use *du;\n+{\n+  def_use *def_ptr, *use_ptr;\n+  dependence *dep_ptr, *dep_list;\n+  subscript icoefficients[MAX_SUBSCRIPTS];\n+  subscript ocoefficients[MAX_SUBSCRIPTS];\n+  loop *loop_ptr, *ck_loop_ptr;\n+  unsigned int loop_idx = 0;\n+  int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+  int i, j;\n+  int subscript_count;\n+  int unnormal_loop;\n+  enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+  enum complexity_type complexity[MAX_SUBSCRIPTS];\n+  int separability;\n+  int have_dependence;\n+\n+  for (j = 1 ; j < MAX_SUBSCRIPTS; j++)\n+    {\n+      direction[j][0] = undef;\n+      distance[j][0] = 0;\n+    }\n+\n+  for (def_ptr = du; def_ptr; def_ptr = def_ptr->next)\n+    {\n+      if (def_ptr->type != def)\n+\t  continue;\n+      subscript_count = get_coefficients (def_ptr, ocoefficients);\n+      if (subscript_count < 0)\n+\tcontinue;\n+\n+      loop_idx = 0;\n+      for (loop_ptr = VARRAY_GENERIC_PTR (loop_chain, loop_idx);\n+\t   loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n+\t   loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n+\t{\n+\t  if (loop_ptr->outer_loop == def_ptr->outer_loop)\n+\t    break;\n+\t}\n+\n+      unnormal_loop = 0;\n+      for (ck_loop_ptr = loop_ptr;\n+\t   ck_loop_ptr && loop_idx < VARRAY_SIZE (loop_chain);\n+\t   ck_loop_ptr = VARRAY_GENERIC_PTR (loop_chain, ++loop_idx))\n+\t{\n+\t  if (ck_loop_ptr->outer_loop == def_ptr->outer_loop\n+\t      && ck_loop_ptr->status == unnormal)\n+\t    unnormal_loop = 1;\n+\t}\n+      if (unnormal_loop)\n+\tcontinue;\n+\n+      normalize_coefficients (ocoefficients, loop_ptr, subscript_count);\n+\n+      for (use_ptr = du; use_ptr; use_ptr = use_ptr->next)\n+\t{\n+\t  if (def_ptr == use_ptr\n+\t      || def_ptr->outer_loop != use_ptr->outer_loop)\n+\t    continue;\n+\t  def_ptr->status = seen;\n+\t  use_ptr->status = seen;\n+\t  subscript_count =  get_coefficients (use_ptr, icoefficients);\n+\t  normalize_coefficients (icoefficients, loop_ptr, subscript_count);\n+\t  classify_dependence (icoefficients, ocoefficients, complexity,\n+\t\t\t       &separability, subscript_count);\n+\n+\t  for (i = 1, ck_loop_ptr = loop_ptr; ck_loop_ptr; i++)\n+\t    {\n+\t      for (j = 1; j <= subscript_count; j++)\n+\t\t{\n+\t\t  direction[i][j] = star;\n+\t\t  distance[i][j] = INT_MAX;\n+\t\t  if (separability && complexity[j] == ziv)\n+\t\t    ziv_test (icoefficients, ocoefficients, direction, distance,\n+\t\t\t      ck_loop_ptr, j);\n+\t\t  else if (separability\n+\t\t\t   && (complexity[j] == strong_siv\n+\t\t\t       || complexity[j] == weak_zero_siv\n+\t\t\t       || complexity[j] == weak_crossing_siv))\n+\t\t    siv_test (icoefficients, ocoefficients, direction, distance,\n+\t\t\t      ck_loop_ptr, j);\n+\t\t  else\n+\t\t    gcd_test (icoefficients, ocoefficients, direction, distance,\n+\t\t\t      ck_loop_ptr, j);\n+\t\t  /* ?? Add other tests: single variable exact test, banerjee */\n+\t\t}\n+\t    \n+\t      ck_loop_ptr = ck_loop_ptr->next_nest;\n+\t    }\n+\n+\t  merge_dependencies (direction, distance, i - 1, j - 1);\n+\n+\t  have_dependence = 0;\n+\t  for (j = 1; j <= i - 1; j++)\n+\t    {\n+\t      if (direction[j][0] != independent)\n+\t\thave_dependence = 1;\n+\t    }\n+\t  if (! have_dependence)\n+\t    continue;\n+\n+\t  VARRAY_PUSH_GENERIC_PTR (dep_chain, xmalloc (sizeof (dependence)));\n+\t  dep_ptr = VARRAY_TOP (dep_chain, generic);\n+\t  dep_ptr->source = use_ptr->expression;\n+\t  dep_ptr->destination = def_ptr->expression;\n+\t  dep_ptr->next = 0;\n+\t  \n+\t  if (def_ptr < use_ptr && use_ptr->type == use) \n+\t    dep_ptr->dependence = flow;\n+\t  else if (def_ptr > use_ptr && use_ptr->type == use)\n+\t    dep_ptr->dependence = anti;\n+\t  else dep_ptr->dependence = output;\n+\n+\t  for (j = 1 ; j <= i - 1 ; j++)\n+\t    {\n+\t      if (direction[j][0] == gt)\n+\t\t{\n+\t\t  dep_ptr->dependence = anti;\n+\t\t  direction[j][0] = lt;\n+\t\t  distance[j][0] = -distance[j][0];\n+\t\t  break;\n+\t\t}\n+\t      else if (direction[j][0] == lt)\n+\t\t{\n+\t\t  dep_ptr->dependence = flow;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  for (j = 1 ; j < MAX_SUBSCRIPTS ; j++)\n+\t    {\n+\t      dep_ptr->direction[j] = direction[j][0];\n+\t      dep_ptr->distance[j] = distance[j][0];\n+\t    }\n+\n+\t  for (dep_list = def_ptr->dep ;\n+\t       dep_list && dep_list->next ;\n+\t       dep_list = dep_list->next)\n+\t    ;\n+\n+\t  if (! dep_list)\n+\t    {\n+\t      /* Dummy for rtl interface */\n+\t      dependence *dep_root_ptr;\n+\n+\t      VARRAY_PUSH_GENERIC_PTR (dep_chain, xmalloc (sizeof (dependence)));\n+\t      dep_root_ptr = VARRAY_TOP (dep_chain, generic);\n+\t      dep_root_ptr->source = 0;\n+\t      dep_root_ptr->destination = def_ptr->expression;\n+\t      dep_root_ptr->dependence = none;\n+\t      dep_root_ptr->next = dep_ptr;\n+\t      def_ptr->dep = dep_ptr;\n+\t    }\n+\t  else\n+\t    dep_list->next = dep_ptr;\n+\t}\n+    }\n+}\n+\n+/* Get the COEFFICIENTS and offset for def/use DU. */\n+\n+static int\n+get_coefficients (du, coefficients)\n+     def_use *du;\n+     subscript coefficients [MAX_SUBSCRIPTS];\n+{\n+  int idx = 0;\n+  int array_count;\n+  int i;\n+  tree array_ref;\n+\n+  array_count = 0;\n+  for (array_ref = du->expression;\n+       TREE_CODE (array_ref) == ARRAY_REF;\n+       array_ref = TREE_OPERAND (array_ref, 0))\n+    array_count += 1;\n+\n+  idx = array_count;\n+\n+  for (i = 0; i < MAX_SUBSCRIPTS; i++)\n+    {\n+      coefficients[i].position = 0;\n+      coefficients[i].coefficient = INT_MIN;\n+      coefficients[i].offset = INT_MIN;\n+      coefficients[i].variable = 0;\n+      coefficients[i].next = 0;\n+    }\n+  \n+  for (array_ref = du->expression;\n+       TREE_CODE (array_ref) == ARRAY_REF;\n+       array_ref = TREE_OPERAND (array_ref, 0))\n+    {\n+      if (TREE_CODE (TREE_OPERAND (array_ref, 1)) == INTEGER_CST)\n+\tcoefficients[idx].offset = TREE_INT_CST_LOW (TREE_OPERAND (array_ref, 1));\n+      else\n+\tif (get_one_coefficient (TREE_OPERAND (array_ref, 1),\n+\t\t\t\t &coefficients[idx], du, 0) < 0)\n+\t  return -1;\n+      idx = idx - 1;\n+    }\n+  return array_count;\n+}\n+\n+/* Get the COEFFICIENTS and offset for NODE having TYPE and defined in DU. */\n+\n+static int\n+get_one_coefficient (node, coefficients, du, type)\n+     tree node;\n+     subscript *coefficients;\n+     def_use *du;\n+     enum tree_code *type;\n+{\n+  enum tree_code  tree_op, tree_op_code;\n+  int index, value;\n+\n+  tree_op = TREE_CODE (node);\n+  if (type)\n+    *type = tree_op;\n+\n+  if (tree_op == VAR_DECL)\n+    {\n+      index = have_induction_variable (du->outer_loop,\n+\t\t\t\t       IDENTIFIER_POINTER (DECL_NAME (node)));\n+      if (index >= 0)\n+\t{\n+\t  coefficients->position = index;\n+\t  coefficients->variable = IDENTIFIER_POINTER (DECL_NAME (node));\n+\t  coefficients->coefficient = 1;\n+\t  if (coefficients->offset == INT_MIN)\n+\t    coefficients->offset = 0;\n+\t}\n+      return index;\n+    }\n+  else if (tree_op == INTEGER_CST)\n+    {\n+      return TREE_INT_CST_LOW (node);\n+    }\n+  else if (tree_op == NON_LVALUE_EXPR)\n+    {\n+      return get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n+\t\t\t\t  &tree_op_code);\n+    }\n+  else if (tree_op == PLUS_EXPR)\n+    {\n+      value = get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n+\t\t\t\t   &tree_op_code);\n+      if (tree_op_code == INTEGER_CST)\n+\tcoefficients->offset = value;\n+\n+      value = get_one_coefficient (TREE_OPERAND (node, 1), coefficients, du,\n+\t\t\t\t   &tree_op_code);\n+      if (tree_op_code == INTEGER_CST)\n+\tcoefficients->offset = value;\n+\n+      return 0;\n+    }\n+  else if (tree_op == MINUS_EXPR)\n+    {\n+      value = get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n+\t\t\t\t   &tree_op_code);\n+      if (tree_op_code == INTEGER_CST)\n+\tcoefficients->offset = value;\n+\n+      value = get_one_coefficient (TREE_OPERAND (node, 1), coefficients, du,\n+\t\t\t\t   &tree_op_code);\n+      if (tree_op_code == INTEGER_CST)\n+\tcoefficients->offset = -value;\n+\n+      return 0;\n+    }\n+  else if (tree_op == MULT_EXPR)\n+    {\n+      int value0, value1, value0_is_idx, value1_is_idx;\n+\n+      value0 = get_one_coefficient (TREE_OPERAND (node, 0), coefficients, du,\n+\t\t\t\t    &tree_op_code);\n+      if (tree_op_code == VAR_DECL)\n+\tvalue0_is_idx = 1;\n+\n+      value1 = get_one_coefficient (TREE_OPERAND (node, 1), coefficients, du,\n+\t\t\t\t    &tree_op_code);\n+      if (tree_op_code == VAR_DECL)\n+\tvalue1_is_idx = 1;\n+\n+      if (value0_is_idx)\n+\tcoefficients->coefficient = value1;\n+      else if (value1_is_idx)\n+\tcoefficients->coefficient = value0;\n+    }\n+  return 0;\n+}\n+\n+/* Adjust the COEFFICIENTS as if loop LOOP_PTR were normalized to start at 0. */\n+\n+void\n+normalize_coefficients (coefficients, loop_ptr, count)\n+     subscript coefficients [MAX_SUBSCRIPTS];\n+     loop *loop_ptr;\n+     int count;\n+{\n+  induction *ind_ptr;\n+  loop *ck_loop_ptr;\n+  int i;\n+\n+  for (i = 1; i <= count; i++)\n+    {\n+      for (ck_loop_ptr = loop_ptr; ck_loop_ptr; \n+\t   ck_loop_ptr = ck_loop_ptr->next_nest)\n+\tfor (ind_ptr = ck_loop_ptr->ind; ind_ptr; ind_ptr = ind_ptr->next)\n+\t  {\n+\t    if (coefficients[i].variable == ind_ptr->variable)\n+\t      {\n+\t\tif (ind_ptr->low_bound < ind_ptr->high_bound)\n+\t\t  coefficients[i].offset += coefficients[i].coefficient\n+\t\t    * ind_ptr->low_bound;\n+\t\telse if (ind_ptr->high_bound != INT_MIN)\n+\t\t  {\n+\t\t    coefficients[i].offset = coefficients[i].coefficient\n+\t\t      * ind_ptr->high_bound;\n+\t\t    coefficients[i].coefficient = coefficients[i].coefficient\n+\t\t      * -1;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t  }\n+    }\n+}\n+\n+/* Determine the COMPLEXITY and SEPARABILITY for COUNT subscripts of\n+   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS */\n+\n+static void\n+classify_dependence (icoefficients, ocoefficients, complexity, separability,\n+\t\t     count)\n+     subscript icoefficients [MAX_SUBSCRIPTS];\n+     subscript ocoefficients [MAX_SUBSCRIPTS];\n+     enum complexity_type complexity [MAX_SUBSCRIPTS];\n+     int *separability;\n+     int count;\n+{\n+  char *iiv_used [MAX_SUBSCRIPTS];\n+  char *oiv_used [MAX_SUBSCRIPTS];\n+  int ocoeff [MAX_SUBSCRIPTS];\n+  int icoeff [MAX_SUBSCRIPTS];\n+  int idx, cidx;\n+\n+  memset (iiv_used, 0, sizeof (tree) * MAX_SUBSCRIPTS);\n+  memset (oiv_used, 0, sizeof (tree) * MAX_SUBSCRIPTS);\n+  memset (icoeff, 0, sizeof (int) * MAX_SUBSCRIPTS);\n+  memset (ocoeff, 0, sizeof (int) * MAX_SUBSCRIPTS);\n+  for (idx = 1; idx <= count; idx++)\n+    {\n+      if (icoefficients[idx].variable != 0)\n+\t{\n+\t  if (! iiv_used[idx])\n+\t    {\n+\t      iiv_used[idx] = icoefficients[idx].variable;\n+\t      icoeff[idx] = icoefficients[idx].coefficient;\n+\t    }\n+\t}\n+      if (ocoefficients[idx].variable != 0)\n+\t{\n+\t  if (! oiv_used[idx])\n+\t    {\n+\t      oiv_used[idx] = ocoefficients[idx].variable;\n+\t      ocoeff[idx] = ocoefficients[idx].coefficient;\n+\t    }\n+\t}\n+    }\n+  \n+  for (idx = 1; idx <= count; idx++)\n+    {\n+      if (iiv_used[idx] == 0 && oiv_used[idx] == 0)\n+\tcomplexity[idx] = ziv;\n+      else if (iiv_used[idx] == oiv_used[idx])\n+\t{\n+\t  if (icoeff[idx] == ocoeff[idx])\n+\t    complexity[idx] = strong_siv;\n+\t  else if (icoeff[idx] == -1 * ocoeff[idx])\n+\t    complexity[idx] = weak_crossing_siv;\n+\t  else\n+\t    complexity[idx] = weak_siv;\n+\t}\n+      else if (icoeff[idx] == 0 || ocoeff[idx] == 0)\n+\tcomplexity[idx] = weak_zero_siv;\n+      else complexity[idx] = miv;\n+    }\n+\n+  *separability = 1;\n+  for (idx = 1; idx <= count; idx++)\n+    {\n+      for (cidx = 1; cidx <= count; cidx++)\n+\t{\n+\t  if (idx != cidx\n+\t      && iiv_used[idx] && oiv_used[cidx]\n+\t      && iiv_used[idx] == oiv_used[cidx])\n+\t    *separability = 0;\n+\t}\n+    }\n+}\n+\n+/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of\n+   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using\n+   the zero induction variable test */\n+\n+static void\n+ziv_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n+     subscript icoefficients [MAX_SUBSCRIPTS];\n+     subscript ocoefficients [MAX_SUBSCRIPTS];\n+     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     loop *loop_ptr;\n+     int sub;\n+{\n+  int idx;\n+\n+  if (ocoefficients[sub].offset !=\n+      icoefficients[sub].offset)\n+    direction[loop_ptr->depth][idx] = independent;\n+}\n+\n+/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of\n+   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using\n+   the single induction variable test */\n+\n+static void\n+siv_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n+     subscript icoefficients [MAX_SUBSCRIPTS];\n+     subscript ocoefficients [MAX_SUBSCRIPTS];\n+     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     loop *loop_ptr;\n+     int sub;\n+{\n+  int coef_diff;\n+  int coef;\n+  int gcd;\n+\n+  if (! check_subscript_induction (&icoefficients[sub], &ocoefficients[sub],\n+\t\t\t\t   loop_ptr))\n+    return;\n+\n+  coef_diff = icoefficients[sub].offset - ocoefficients[sub].offset;\n+  /* strong_siv requires equal coefficients.  weak_crossing_siv requires\n+     coefficients to have equal absolute value.  weak_zero_siv uses the\n+     nonzero coefficient. */\n+\n+  if (ocoefficients[sub].coefficient == INT_MIN)\n+    coef = icoefficients[sub].coefficient;\n+  else if (icoefficients[sub].coefficient == INT_MIN)\n+    coef = ocoefficients[sub].coefficient;\n+  else if (ocoefficients[sub].coefficient ==\n+\t   -1 * icoefficients[sub].coefficient)\n+    coef = 2 * abs (ocoefficients[sub].coefficient);\n+  else\n+    coef = icoefficients[sub].coefficient;\n+\n+  gcd = -coef_diff / coef;\n+  if (gcd * coef != -coef_diff)\n+    {\n+      direction[loop_ptr->depth][sub] = independent;\n+    }\n+  else\n+    {\n+      distance[loop_ptr->depth][sub] = gcd;\n+      if (gcd < 0)\n+\tdirection[loop_ptr->depth][sub] = gt;\n+      else if (gcd > 0)\n+\tdirection[loop_ptr->depth][sub] = lt;\n+      else\n+\tdirection[loop_ptr->depth][sub] = eq;\n+    }\n+}\n+\n+/* Return 1 if an induction variable of LOOP_PTR is used by either\n+   input ICOEFFICIENT or output OCOEFFICIENT */\n+\n+static int\n+check_subscript_induction (icoefficient, ocoefficient, loop_ptr)\n+     subscript *icoefficient;\n+     subscript *ocoefficient;\n+     loop *loop_ptr;\n+{\n+  induction *ind_ptr;\n+  int sub_ind_input = 0;\n+  int sub_ind_output = 0;\n+\n+  for (ind_ptr = loop_ptr->ind; ind_ptr; ind_ptr = ind_ptr->next)\n+    {\n+      if (icoefficient->variable == ind_ptr->variable)\n+\tsub_ind_input = 1;\n+      if (ocoefficient->variable == ind_ptr->variable)\n+\tsub_ind_output = 1;\n+    }\n+  if (sub_ind_input || sub_ind_output)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+#define abs(n) (n < 0 ? -n : n)\n+\n+/* Determine the DIRECTION and DISTANCE dependency for subscript SUB of\n+   inputs ICOEFFICIENTS and outputs OCOEFFICIENTS of loop LOOP_PTR using\n+   the greatest common denominator test */\n+\n+static void\n+gcd_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n+     subscript icoefficients [MAX_SUBSCRIPTS];\n+     subscript ocoefficients [MAX_SUBSCRIPTS];\n+     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     loop *loop_ptr;\n+     int sub;\n+{\n+  int coef_diff;\n+  int g, gg;\n+\n+  if (! check_subscript_induction (&icoefficients[sub], &ocoefficients[sub],\n+\t\t\t\t   loop_ptr))\n+    return;\n+\n+  g = find_gcd (icoefficients[sub].coefficient,\n+\t\tocoefficients[sub].coefficient);\n+  if (g > 1)\n+    {\n+      coef_diff = icoefficients[sub].offset - ocoefficients[sub].offset;\n+      gg = coef_diff / g;\n+      if (gg * g != coef_diff)\n+\t{\n+\t  direction[loop_ptr->depth][sub] = independent;\n+\t}\n+    }\n+  /* ?? gcd does not yield direction and distance.  Wolfe's direction\n+     vector hierarchy can be used to give this. */\n+}     \n+\n+/* Find the gcd of X and Y using Euclid's algorithm */\n+\n+static int\n+find_gcd (x, y)\n+     int x,y;\n+{\n+  int g, g0, g1, r;\n+\n+  if (x == 0)\n+    {\n+      g = abs (x);\n+    }\n+  else if (y == 0)\n+    {\n+      g = abs (y);\n+    }\n+  else\n+    {\n+      g0 = abs (x);\n+      g1 = abs (y);\n+      r = g0 % g1;\n+      while (r != 0)\n+\t{\n+\t  g0 = g1;\n+\t  g1 = r;\n+\t  r = g0 % g1;\n+\t}\n+      g = g1;\n+    }\n+  return g;\n+}\n+\n+/* Merge SUBSCRIPT_COUNT DIRECTIONs and DISTANCEs for LOOP_COUNT loops.\n+   We use a predefined array to handle the direction merge.  \n+   The distance merge makes use of the fact that distances default to\n+   INT_MAX.  Distances are '&' together.  Watch out for a negative distance.\n+*/\n+\n+static void\n+merge_dependencies (direction, distance, loop_count, subscript_count)\n+     enum direction_type direction[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     int distance[MAX_SUBSCRIPTS][MAX_SUBSCRIPTS];\n+     int loop_count;\n+     int subscript_count;\n+{\n+  int i, j;\n+  int sign;\n+\n+  enum direction_type direction_merge [8][8] = \n+  {{lt, le, le, star, star, lt, independent, lt},\n+   {le, le, le, star, star, le, independent, le},\n+   {le, le, eq, ge, ge, eq, independent, eq},\n+   {star, star, ge, gt, ge, gt, independent, ge},\n+   {star, star, ge, ge, ge, ge, independent, ge},\n+   {lt, le, eq, gt, ge, star, independent, star},\n+   {independent, independent, independent, independent, independent},\n+   {independent, independent, independent}\n+  };\n+  \n+  for (i = 1; i <= loop_count; i++)\n+    {\n+      distance[i][0] = INT_MAX;\n+      direction[i][0] = star;\n+      sign = 1;\n+      for (j = 1; j <= subscript_count; j++)\n+\t{\n+\t  if (distance[i][j] < 0)\n+\t    {\n+\t      distance[i][0] = distance[i][0] & abs (distance[i][j]);\n+\t      sign = -1;\n+\t    }\n+\t  else\n+\t    distance[i][0] = distance[i][0] & distance[i][j];\n+\t  direction[i][0] = direction_merge[(int)direction[i][0]]\n+\t    \t\t\t\t   [(int)direction[i][j]];\n+\t}\n+      distance[i][0] = sign * distance[i][0];\n+    }\n+}\n+\n+/* Dump ARRAY_REF NODE. */\n+\n+static void\n+dump_array_ref (node)\n+     tree node;\n+{\n+  enum tree_code  tree_op = TREE_CODE (node);\n+\n+  if (tree_op == VAR_DECL)\n+    {\n+      printf (\"%s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n+    }\n+  else if (tree_op == INTEGER_CST)\n+    {\n+      printf (\"%d\", (int)TREE_INT_CST_LOW (node));\n+    }\n+  else if (tree_op == PLUS_EXPR)\n+    {\n+      dump_array_ref (TREE_OPERAND (node, 0));\n+      printf (\"+\");\n+      dump_array_ref (TREE_OPERAND (node, 1));\n+    }\n+  else if (tree_op == MINUS_EXPR)\n+    {\n+      dump_array_ref (TREE_OPERAND (node, 0));\n+      printf (\"-\");\n+      dump_array_ref (TREE_OPERAND (node, 1));\n+    }\n+  else if (tree_op == MULT_EXPR)\n+    {\n+      dump_array_ref (TREE_OPERAND (node, 0));\n+      printf (\"*\");\n+      dump_array_ref (TREE_OPERAND (node, 1));\n+    }\n+}\n+\n+/* Dump def/use DU. */\n+\n+static void\n+dump_one_node (du, seen)\n+     def_use *du;\n+     varray_type *seen;\n+{\n+  def_use *du_ptr;\n+  dependence *dep_ptr;\n+  tree array_ref;\n+\n+  for (du_ptr = du; du_ptr; du_ptr = du_ptr->next)\n+    {\n+      printf (\"%s \", du_ptr->variable);\n+      for (array_ref = du_ptr->expression;\n+\t   TREE_CODE (array_ref) == ARRAY_REF;\n+\t   array_ref = TREE_OPERAND (array_ref, 0))\n+\t{\t\n+\t  printf (\"[\");\n+\t  dump_array_ref (TREE_OPERAND (array_ref, 1));\n+\t  printf (\"]\");\n+\t}\n+\n+      printf (\" Outer Loop %x Containing Loop %x Expression %x %s\\n\",\n+\t      (int)du_ptr->outer_loop,\n+\t      (int)du_ptr->containing_loop,\n+\t      (int)du_ptr->expression, du_ptr->type == def ? \"Def\" : \"Use\");\n+      VARRAY_PUSH_GENERIC_PTR (*seen, du_ptr);\n+\n+      for (dep_ptr = du_ptr->dep; dep_ptr; dep_ptr = dep_ptr->next)\n+\t{\n+\t  int i;\n+\t  printf (\"%s Dependence with %x \",\n+\t\t  dependence_string[(int)dep_ptr->dependence],\n+\t\t  (int)dep_ptr->source);\n+\t  printf (\"Dir/Dist \");\n+\t  for (i = 1 ; i < MAX_SUBSCRIPTS ; i++)\n+\t    if (dep_ptr->direction[i] != undef)\n+\t      printf (\"[%d] %s/%d \", i,\n+\t\t      direction_string[(int)dep_ptr->direction[i]],\n+\t\t      dep_ptr->distance[i]);\n+\t  printf (\"\\n\");\n+\t}\n+    }\n+}\n+\n+/* Dump dependence info. */\n+\n+static void\n+dump_node_dependence (void)\n+{\n+  varray_type seen;\n+  unsigned int du_idx, seen_idx, i;\n+  def_use *du_ptr;\n+\n+  VARRAY_GENERIC_PTR_INIT (seen, 20, \"seen\");\n+  du_idx = 0;\n+  seen_idx = 0;\n+  for (du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx);\n+       du_idx < VARRAY_SIZE (def_use_chain);\n+       du_ptr = VARRAY_GENERIC_PTR (def_use_chain, du_idx++))\n+    {\n+      for (i = 0; i < VARRAY_SIZE (seen) && VARRAY_GENERIC_PTR (seen, i)\n+\t     != du_ptr ; i++);\n+      if (i >= VARRAY_SIZE (seen))\n+\tdump_one_node (du_ptr, &seen);\n+    }\n+  VARRAY_FREE (seen);\n+}\n+\n+/* Return the index into 'dep_chain' if there is a dependency for destination\n+   dest_to_remember (set by remember_dest_for_dependence) and source node.\n+   Called by the front end, which adds the index onto a MEM rtx. */\n+\n+int\n+search_dependence (node)\n+     tree node;\n+{\n+  dependence *dep_ptr;\n+  int dep_idx = 0;\n+\n+\n+  if (dep_chain)\n+    {\n+      if (TREE_CODE (node) == INDIRECT_REF && TREE_OPERAND (node, 1)\n+\t  && TREE_CODE (TREE_OPERAND (node, 1)) == ARRAY_REF)\n+\tnode = TREE_OPERAND (node, 1);\n+\n+      for (dep_ptr = VARRAY_GENERIC_PTR (dep_chain, 0);\n+\t   dep_ptr; dep_ptr = VARRAY_GENERIC_PTR (dep_chain, dep_idx++))\n+\t{\n+\t  if ((node == dep_ptr->source\n+\t       && dest_to_remember == dep_ptr->destination)\n+\t      || (! dep_ptr->source && node == dep_ptr->destination))\n+\t    return dep_idx + 1;\n+\t}\n+    }\n+  \n+  return 0;\n+}\n+\n+/* Remember a destination NODE for search_dependence. */\n+\n+void\n+remember_dest_for_dependence (node)\n+     tree node;\n+{\n+  if (node)\n+    {\n+      if (TREE_CODE (node) == INDIRECT_REF && TREE_OPERAND (node, 1)\n+\t  && TREE_CODE (TREE_OPERAND (node, 1)) == ARRAY_REF)\n+\tnode = TREE_OPERAND (node, 1);\n+      dest_to_remember = node;\n+    }\n+}\n+\n+#ifndef MEM_DEPENDENCY\n+#define MEM_DEPENDENCY(RTX) XCWINT(RTX, 2, MEM)\n+#endif\n+\n+/* Return 1 along with the dependence DIRECTION and DISTANCE if there is a \n+   dependence from dest_rtx to src_rtx. */\n+\n+int\n+have_dependence_p (dest_rtx, src_rtx, direction, distance)\n+     rtx dest_rtx;\n+     rtx src_rtx;\n+     enum direction_type direction[MAX_SUBSCRIPTS];\n+     int distance[MAX_SUBSCRIPTS];\n+{\n+  int dest_idx, src_idx;\n+  rtx dest, src;\n+  dependence *dep_ptr;\n+\n+  if (GET_CODE (SET_DEST (PATTERN (dest_rtx))) == MEM)\n+    {\n+      dest = SET_DEST (PATTERN (dest_rtx));\n+      dest_idx = MEM_DEPENDENCY (dest) - 1;\n+    }\n+  if (GET_CODE (SET_SRC (PATTERN (src_rtx))) == MEM)\n+    {\n+      src = SET_SRC (PATTERN (src_rtx));\n+      src_idx = MEM_DEPENDENCY (dest) - 1;\n+    }\n+  if (dest_idx >= 0 || src_idx >= 0)\n+    return 0;\n+\n+  for (dep_ptr = VARRAY_GENERIC_PTR (dep_chain, -dest_idx);\n+       dep_ptr; dep_ptr = dep_ptr->next)\n+    {\n+      if (dep_ptr == VARRAY_GENERIC_PTR (dep_chain, -src_idx))\n+\t{\n+\t  direction = (enum direction_type*) &dep_ptr->direction;\n+\t  distance = (int*) &dep_ptr->distance;\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Cleanup when dependency analysis is complete. */\n+\n+void\n+end_dependence_analysis (void)\n+{\n+  VARRAY_FREE (dep_chain);\n+}"}]}