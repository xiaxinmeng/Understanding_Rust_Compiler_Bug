{"sha": "0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIyYzRiZTVmZGZmNzBmMWJhYmQ1MDNjOWY2ZGJhYmQ2NjRjNDRjNw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-05-16T10:51:15Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-05-16T10:51:15Z"}, "message": "PR preprocessor/7263 - Avoid pedantic warnings on system headers macro tokens\n\nNow that we track token locations accross macro expansions, it would\nbe cool to be able to fix PR preprocessor/7263 for real.  That is,\nconsider this example where we have a system header named header.h\nlike this:\n\n\t#define _Complex __complex__ #define _Complex_I 1.0iF\n\nand then a normal C file like this:\n\n    #include \"header.h\"\n\n    static _Complex float c = _Complex_I;\n\nIf we compile the file with -pedantic, the usages of _Complex or\n_Complex_I should not trigger any warning, even though __complex__ and\nthe complex literal are extensions to the standard C.\n\nThey shouldn't trigger any warning because _Complex and _Complex_I are\ndefined in a system header (and expanded in normal user code).\n\nTo be able to handle this, we must address two separate concerns.\n\nFirst, warnings about non-standard usage of numerical literals are emitted\ndirectly from within libcpp.  So we must teach libcpp's parser for numerical\nliterals to use virtual locations, instead of the spelling\nlocation it uses today.  Once we have that, as the diagnostics machinery\nalready knows how to avoid emitting errors happening on tokens that come from\nsystem headers, we win.\n\nSecond, there is the issue of tracking locations for declaration\nspecifiers, like the \"_Complex\" in the declaration:\n\n\tstatic _Complex float c;\n\nFor that, we need to arrange for each possible declaration specifier\nto have its own location, because otherwise, we'd warn on e.g, on:\n\n    _Complex float c;\n\nbut not on:\n\n    static _Complex float c;\n\nSo this patch addresses the two concerns above.  It's actually a\nfollow-up on an earlier patch[1] I wrote as part of my initial work on\nvirtual locations.  We then agreed[2] that the second concern was\nimportant to address before the patch could get a chance to go in.\n\n[1]: http://gcc.gnu.org/ml/gcc-patches/2011-09/msg00957.html\n[2]: http://gcc.gnu.org/ml/gcc-patches/2011-10/msg00264.html\n\nBootstrapped and tested on x86_64-unknown-linux-gnu against trunk.\n\nlibcpp/\n\n\tPR preprocessor/7263\n\t* include/cpplib.h (cpp_classify_number): Take a location\n\tparameter.\n\t* expr.c (SYNTAX_ERROR_AT, SYNTAX_ERROR2_AT): New diagnostic\n\tmacros that take a location parameter.\n\t(cpp_classify_number): Take a (virtual) location parameter.  Use\n\tit for diagnostics.  Adjust comments.\n\t(eval_token): Take a location parameter.  Pass it to\n\tcpp_classify_number and to diagnostic routines.\n\t(_cpp_parse_expr): Use virtual locations of tokens when parsing\n\texpressions.  Pass a virtual location to eval_token and to\n\tdiagnostic routines.\n\ngcc/c-family/\n\n\tPR preprocessor/7263\n\t* c-lex.c (c_lex_with_flags):  Pass a virtual location to the call\n\tto cpp_classify_number.  For diagnostics, use the precise location\n\tinstead of the global input_location.\n\ngcc/\n\tPR preprocessor/7263\n\t* c-tree.h (enum c_declspec_word): Declare new enum.\n\t(struct c_declspecs::locations): New member.\n\t(declspecs_add_qual, declspecs_add_scspec)\n\t(declspecs_add_addrspace, declspecs_add_alignas): Take a new\n\tlocation parameter.\n\t* c-decl.c (build_null_declspecs): Initialize the new struct\n\tc_declspecs::locations member.\n\t(declspecs_add_addrspace): Take a location parameter for the\n\taddress space.  Store it onto declaration specifiers.\n\t(declspecs_add_qual): Likewise, take a location parameter for the\n\tqualifier.\n\t(declspecs_add_type): Likewise, take a location parameter for the\n\ttype specifier.\n\t(declspecs_add_scspec): Likewise, take a location parameter for\n\tthe storage class specifier.\n\t(declspecs_add_attrs): Likewise, take a location parameter for the\n\tfirst attribute.\n\t(declspecs_add_alignas): Likewise, take a location parameter for\n\tthe alignas token.\n\t(finish_declspecs): For diagnostics, use the location of the\n\trelevant declspec, instead of the global input_location.\n\t* c-parser.c (c_parser_parameter_declaration): Pass the precise\n\tvirtual location of the declspec to the declspecs-setters.\n\t(c_parser_declspecs): Likewise.  Avoid calling c_parser_peek_token\n\trepeatedly.\n\ngcc/cp/\n\n\tPR preprocessor/7263\n\t* cp-tree.h (enum cp_decl_spec): Add new enumerators to cover all\n\tthe possible declarator specifiers so far.\n\t(struct cp_decl_specifier_seq::locations): Declare new member.\n\t(cp_decl_specifier_seq::{specs, type_location}): Remove.\n\t(decl_spec_seq_has_spec_p): Declare new function.\n\t* parser.c (cp_parser_check_decl_spec): Remove.\n\t(set_and_check_decl_spec_loc): Define new static function.\n\t(decl_spec_seq_has_spec_p): Define new public function.\n\t(cp_parser_decl_specifier_seq, cp_parser_function_specifier_opt)\n\t(cp_parser_type_specifier, cp_parser_simple_type_specifier)\n\t(cp_parser_set_storage_class, cp_parser_set_decl_spec_type)\n\t(cp_parser_alias_declaration): Set the locations for each\n\tdeclspec, using set_and_check_decl_spec_loc.\n\t(cp_parser_explicit_instantiation, cp_parser_init_declarator)\n\t(cp_parser_member_declaration, cp_parser_init_declarator): Use the\n\tnew declspec location for specifiers.  Use the new\n\tdecl_spec_seq_has_spec_p.\n\t(cp_parser_type_specifier_seq): Use the new\n\tset_and_check_decl_spec_loc.  Stop using\n\tcp_parser_check_decl_spec.  Use the new decl_spec_seq_has_spec_p.\n\t(, cp_parser_init_declarator): Use the new\n\tset_and_check_decl_spec_loc.\n\t(cp_parser_single_declaration, cp_parser_friend_p)\n\t(cp_parser_objc_class_ivars, cp_parser_objc_struct_declaration):\n\tUse the new decl_spec_seq_has_spec_p.\n\t* decl.c (check_tag_decl): Use new decl_spec_seq_has_spec_p.  Use\n\tthe more precise ds_redefined_builtin_type_spec location for\n\tdiagnostics about re-declaring C++ built-in types.\n\t(start_decl, grokvardecl, grokdeclarator): Use the new\n\tdecl_spec_seq_has_spec_p.\n\ngcc/testsuite/\n\n\tPR preprocessor/7263\n\t* gcc.dg/binary-constants-2.c: Run without tracking locations\n\taccross macro expansion.\n\t* gcc.dg/binary-constants-3.c: Likewise.\n\t* gcc.dg/cpp/sysmac2.c: Likewise.\n\t* testsuite/gcc.dg/nofixed-point-2.c: Adjust for more precise\n\tlocation.\n\t* gcc.dg/cpp/syshdr3.c: New test.\n\t* gcc.dg/cpp/syshdr3.h: New header for the new test above.\n\t* gcc.dg/system-binary-constants-1.c: New test.\n\t* gcc.dg/system-binary-constants-1.h: New header for the new test\n\tabove.\n\t* g++.dg/cpp/syshdr3.C: New test.\n\t* g++.dg/cpp/syshdr3.h: New header the new test above.\n\t* g++.dg/system-binary-constants-1.C: New test.\n\t* g++.dg/system-binary-constants-1.h: New header the new test\n\tabove.\n\nFrom-SVN: r187587", "tree": {"sha": "866b6e9e6346cbd21ad2a4974753e1735d1f01b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/866b6e9e6346cbd21ad2a4974753e1735d1f01b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/comments", "author": null, "committer": null, "parents": [{"sha": "40295cc722ce5ea0b7ba7b3cb91f6accce0db518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40295cc722ce5ea0b7ba7b3cb91f6accce0db518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40295cc722ce5ea0b7ba7b3cb91f6accce0db518"}], "stats": {"total": 964, "additions": 682, "deletions": 282}, "files": [{"sha": "9a0d8160028c3313cdf0f6c47df76f9033737555", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,3 +1,32 @@\n+2012-05-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/7263\n+\t* c-tree.h (enum c_declspec_word): Declare new enum.\n+\t(struct c_declspecs::locations): New member.\n+\t(declspecs_add_qual, declspecs_add_scspec)\n+\t(declspecs_add_addrspace, declspecs_add_alignas): Take a new\n+\tlocation parameter.\n+\t* c-decl.c (build_null_declspecs): Initialize the new struct\n+\tc_declspecs::locations member.\n+\t(declspecs_add_addrspace): Take a location parameter for the\n+\taddress space.  Store it onto declaration specifiers.\n+\t(declspecs_add_qual): Likewise, take a location parameter for the\n+\tqualifier.\n+\t(declspecs_add_type): Likewise, take a location parameter for the\n+\ttype specifier.\n+\t(declspecs_add_scspec): Likewise, take a location parameter for\n+\tthe storage class specifier.\n+\t(declspecs_add_attrs): Likewise, take a location parameter for the\n+\tfirst attribute.\n+\t(declspecs_add_alignas): Likewise, take a location parameter for\n+\tthe alignas token.\n+\t(finish_declspecs): For diagnostics, use the location of the\n+\trelevant declspec, instead of the global input_location.\n+\t* c-parser.c (c_parser_parameter_declaration): Pass the precise\n+\tvirtual location of the declspec to the declspecs-setters.\n+\t(c_parser_declspecs): Likewise.  Avoid calling c_parser_peek_token\n+\trepeatedly.\n+\n 2012-05-16  Igor Zamyatin  <igor.zamyatin@intel.com>\n \n \t* configure.ac: Stack protector enabling for Android targets."}, {"sha": "41688a7220d061e3a6f0ed2c547e8e7dce09a1c5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 98, "deletions": 29, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -8787,6 +8787,7 @@ struct c_declspecs *\n build_null_declspecs (void)\n {\n   struct c_declspecs *ret = XOBNEW (&parser_obstack, struct c_declspecs);\n+  memset (&ret->locations, 0, cdw_number_of_elements);\n   ret->type = 0;\n   ret->expr = 0;\n   ret->decl_attr = 0;\n@@ -8824,7 +8825,8 @@ build_null_declspecs (void)\n    SPECS, returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_addrspace (struct c_declspecs *specs, addr_space_t as)\n+declspecs_add_addrspace (source_location location,\n+\t\t\t struct c_declspecs *specs, addr_space_t as)\n {\n   specs->non_sc_seen_p = true;\n   specs->declspecs_seen_p = true;\n@@ -8835,15 +8837,19 @@ declspecs_add_addrspace (struct c_declspecs *specs, addr_space_t as)\n \t   c_addr_space_name (as),\n \t   c_addr_space_name (specs->address_space));\n   else\n-    specs->address_space = as;\n+    {\n+      specs->address_space = as;\n+      specs->locations[cdw_address_space] = location;\n+    }\n   return specs;\n }\n \n /* Add the type qualifier QUAL to the declaration specifiers SPECS,\n    returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_qual (struct c_declspecs *specs, tree qual)\n+declspecs_add_qual (source_location loc,\n+\t\t    struct c_declspecs *specs, tree qual)\n {\n   enum rid i;\n   bool dupe = false;\n@@ -8857,20 +8863,23 @@ declspecs_add_qual (struct c_declspecs *specs, tree qual)\n     case RID_CONST:\n       dupe = specs->const_p;\n       specs->const_p = true;\n+      specs->locations[cdw_const] = loc;\n       break;\n     case RID_VOLATILE:\n       dupe = specs->volatile_p;\n       specs->volatile_p = true;\n+      specs->locations[cdw_volatile] = loc;\n       break;\n     case RID_RESTRICT:\n       dupe = specs->restrict_p;\n       specs->restrict_p = true;\n+      specs->locations[cdw_restrict] = loc;\n       break;\n     default:\n       gcc_unreachable ();\n     }\n   if (dupe && !flag_isoc99)\n-    pedwarn (input_location, OPT_Wpedantic, \"duplicate %qE\", qual);\n+    pedwarn (loc, OPT_Wpedantic, \"duplicate %qE\", qual);\n   return specs;\n }\n \n@@ -8923,6 +8932,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t  pedwarn_c90 (loc, OPT_Wlong_long,\n \t\t\t       \"ISO C90 does not support %<long long%>\");\n \t\t  specs->long_long_p = 1;\n+\t\t  specs->locations[cdw_long_long] = loc;\n \t\t  break;\n \t\t}\n \t      if (specs->short_p)\n@@ -8962,7 +8972,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<long%> and %<_Decimal128%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->long_p = true;\n+\t\t{\n+\t\t  specs->long_p = true;\n+\t\t  specs->locations[cdw_long] = loc;\n+\t\t}\n \t      break;\n \t    case RID_SHORT:\n \t      dupe = specs->short_p;\n@@ -9007,7 +9020,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<short%> and %<_Decimal128%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->short_p = true;\n+\t\t{\n+\t\t  specs->short_p = true;\n+\t\t  specs->locations[cdw_short] = loc;\n+\t\t}\n \t      break;\n \t    case RID_SIGNED:\n \t      dupe = specs->signed_p;\n@@ -9044,7 +9060,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<signed%> and %<_Decimal128%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->signed_p = true;\n+\t\t{\n+\t\t  specs->signed_p = true;\n+\t\t  specs->locations[cdw_signed] = loc;\n+\t\t}\n \t      break;\n \t    case RID_UNSIGNED:\n \t      dupe = specs->unsigned_p;\n@@ -9081,11 +9100,14 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<unsigned%> and %<_Decimal128%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->unsigned_p = true;\n+\t\t{\n+\t\t  specs->unsigned_p = true;\n+\t\t  specs->locations[cdw_unsigned] = loc;\n+\t\t}\n \t      break;\n \t    case RID_COMPLEX:\n \t      dupe = specs->complex_p;\n-\t      if (!flag_isoc99 && !in_system_header)\n+\t      if (!flag_isoc99 && !in_system_header_at (loc))\n \t\tpedwarn (loc, OPT_Wpedantic,\n \t\t\t \"ISO C90 does not support complex types\");\n \t      if (specs->typespec_word == cts_void)\n@@ -9121,7 +9143,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<complex%> and %<_Sat%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->complex_p = true;\n+\t\t{\n+\t\t  specs->complex_p = true;\n+\t\t  specs->locations[cdw_complex] = loc;\n+\t\t}\n \t      break;\n \t    case RID_SAT:\n \t      dupe = specs->saturating_p;\n@@ -9174,7 +9199,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<_Sat%> and %<complex%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->saturating_p = true;\n+\t\t{\n+\t\t  specs->saturating_p = true;\n+\t\t  specs->locations[cdw_saturating] = loc;\n+\t\t}\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -9220,7 +9248,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<__int128%> and %<short%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->typespec_word = cts_int128;\n+\t\t{\n+\t\t  specs->typespec_word = cts_int128;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n \t      return specs;\n \t    case RID_VOID:\n \t      if (specs->long_p)\n@@ -9248,7 +9279,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<_Sat%> and %<void%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->typespec_word = cts_void;\n+\t\t{\n+\t\t  specs->typespec_word = cts_void;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n \t      return specs;\n \t    case RID_BOOL:\n \t      if (specs->long_p)\n@@ -9276,7 +9310,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<_Sat%> and %<_Bool%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->typespec_word = cts_bool;\n+\t\t{\n+\t\t  specs->typespec_word = cts_bool;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n \t      return specs;\n \t    case RID_CHAR:\n \t      if (specs->long_p)\n@@ -9292,15 +9329,21 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<_Sat%> and %<char%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->typespec_word = cts_char;\n+\t\t{\n+\t\t  specs->typespec_word = cts_char;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n \t      return specs;\n \t    case RID_INT:\n \t      if (specs->saturating_p)\n \t\terror_at (loc,\n \t\t\t  (\"both %<_Sat%> and %<int%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->typespec_word = cts_int;\n+\t\t{\n+\t\t  specs->typespec_word = cts_int;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n \t      return specs;\n \t    case RID_FLOAT:\n \t      if (specs->long_p)\n@@ -9324,7 +9367,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<_Sat%> and %<float%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->typespec_word = cts_float;\n+\t\t{\n+\t\t  specs->typespec_word = cts_float;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n \t      return specs;\n \t    case RID_DOUBLE:\n \t      if (specs->long_long_p)\n@@ -9348,7 +9394,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t  (\"both %<_Sat%> and %<double%> in \"\n \t\t\t   \"declaration specifiers\"));\n \t      else\n-\t\tspecs->typespec_word = cts_double;\n+\t\t{\n+\t\t  specs->typespec_word = cts_double;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n \t      return specs;\n \t    case RID_DFLOAT32:\n \t    case RID_DFLOAT64:\n@@ -9402,6 +9451,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t  specs->typespec_word = cts_dfloat64;\n \t\telse\n \t\t  specs->typespec_word = cts_dfloat128;\n+\t\tspecs->locations[cdw_typespec] = loc;\n \t      }\n \t      if (!targetm.decimal_float_supported_p ())\n \t\terror_at (loc,\n@@ -9427,6 +9477,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t    specs->typespec_word = cts_fract;\n \t\telse\n \t\t    specs->typespec_word = cts_accum;\n+\t\tspecs->locations[cdw_typespec] = loc;\n \t      }\n \t      if (!targetm.fixed_point_supported_p ())\n \t\terror_at (loc,\n@@ -9460,6 +9511,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t  specs->decl_attr = DECL_ATTRIBUTES (type);\n \t  specs->typedef_p = true;\n \t  specs->explicit_signed_p = C_TYPEDEF_EXPLICITLY_SIGNED (type);\n+\t  specs->locations[cdw_typedef] = loc;\n \n \t  /* If this typedef name is defined in a struct, then a C++\n \t     lookup would return a different value.  */\n@@ -9483,13 +9535,17 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n       else if (TREE_TYPE (t) == error_mark_node)\n \t;\n       else\n-\tspecs->type = TREE_TYPE (t);\n+\t{\n+\t  specs->type = TREE_TYPE (t);\n+\t  specs->locations[cdw_typespec] = loc;\n+\t}\n     }\n   else\n     {\n       if (TREE_CODE (type) != ERROR_MARK && spec.kind == ctsk_typeof)\n \t{\n \t  specs->typedef_p = true;\n+\t  specs->locations[cdw_typedef] = loc;\n \t  if (spec.expr)\n \t    {\n \t      if (specs->expr)\n@@ -9510,7 +9566,9 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n    declaration specifiers SPECS, returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_scspec (struct c_declspecs *specs, tree scspec)\n+declspecs_add_scspec (source_location loc,\n+\t\t      struct c_declspecs *specs,\n+\t\t      tree scspec)\n {\n   enum rid i;\n   enum c_storage_class n = csc_none;\n@@ -9531,11 +9589,13 @@ declspecs_add_scspec (struct c_declspecs *specs, tree scspec)\n \t difference between gnu89 and C99 inline.  */\n       dupe = false;\n       specs->inline_p = true;\n+      specs->locations[cdw_inline] = loc;\n       break;\n     case RID_NORETURN:\n       /* Duplicate _Noreturn is permitted.  */\n       dupe = false;\n       specs->noreturn_p = true;\n+      specs->locations[cdw_noreturn] = loc;\n       break;\n     case RID_THREAD:\n       dupe = specs->thread_p;\n@@ -9546,7 +9606,10 @@ declspecs_add_scspec (struct c_declspecs *specs, tree scspec)\n       else if (specs->storage_class == csc_typedef)\n \terror (\"%<__thread%> used with %<typedef%>\");\n       else\n-\tspecs->thread_p = true;\n+\t{\n+\t  specs->thread_p = true;\n+\t  specs->locations[cdw_thread] = loc;\n+\t}\n       break;\n     case RID_AUTO:\n       n = csc_auto;\n@@ -9585,6 +9648,7 @@ declspecs_add_scspec (struct c_declspecs *specs, tree scspec)\n       else\n \t{\n \t  specs->storage_class = n;\n+\t  specs->locations[cdw_storage_class] = loc;\n \t  if (n != csc_extern && n != csc_static && specs->thread_p)\n \t    {\n \t      error (\"%<__thread%> used with %qE\", scspec);\n@@ -9599,9 +9663,10 @@ declspecs_add_scspec (struct c_declspecs *specs, tree scspec)\n    returning SPECS.  */\n \n struct c_declspecs *\n-declspecs_add_attrs (struct c_declspecs *specs, tree attrs)\n+declspecs_add_attrs (source_location loc, struct c_declspecs *specs, tree attrs)\n {\n   specs->attrs = chainon (attrs, specs->attrs);\n+  specs->locations[cdw_attributes] = loc;\n   specs->declspecs_seen_p = true;\n   return specs;\n }\n@@ -9610,10 +9675,12 @@ declspecs_add_attrs (struct c_declspecs *specs, tree attrs)\n    alignment is ALIGN) to the declaration specifiers SPECS, returning\n    SPECS.  */\n struct c_declspecs *\n-declspecs_add_alignas (struct c_declspecs *specs, tree align)\n+declspecs_add_alignas (source_location loc,\n+\t\t       struct c_declspecs *specs, tree align)\n {\n   int align_log;\n   specs->alignas_p = true;\n+  specs->locations[cdw_alignas] = loc;\n   if (align == error_mark_node)\n     return specs;\n   align_log = check_user_alignment (align, true);\n@@ -9654,9 +9721,11 @@ finish_declspecs (struct c_declspecs *specs)\n     {\n       if (specs->saturating_p)\n \t{\n-\t  error (\"%<_Sat%> is used without %<_Fract%> or %<_Accum%>\");\n+\t  error_at (specs->locations[cdw_saturating],\n+\t\t    \"%<_Sat%> is used without %<_Fract%> or %<_Accum%>\");\n \t  if (!targetm.fixed_point_supported_p ())\n-\t    error (\"fixed-point types not supported for this target\");\n+\t    error_at (specs->locations[cdw_saturating],\n+\t\t      \"fixed-point types not supported for this target\");\n \t  specs->typespec_word = cts_fract;\n \t}\n       else if (specs->long_p || specs->short_p\n@@ -9667,7 +9736,7 @@ finish_declspecs (struct c_declspecs *specs)\n       else if (specs->complex_p)\n \t{\n \t  specs->typespec_word = cts_double;\n-\t  pedwarn (input_location, OPT_Wpedantic,\n+\t  pedwarn (specs->locations[cdw_complex], OPT_Wpedantic,\n \t\t   \"ISO C does not support plain %<complex%> meaning \"\n \t\t   \"%<double complex%>\");\n \t}\n@@ -9712,7 +9781,7 @@ finish_declspecs (struct c_declspecs *specs)\n \tspecs->type = char_type_node;\n       if (specs->complex_p)\n \t{\n-\t  pedwarn (input_location, OPT_Wpedantic,\n+\t  pedwarn (specs->locations[cdw_complex], OPT_Wpedantic,\n \t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}\n@@ -9725,7 +9794,7 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t     : int128_integer_type_node);\n       if (specs->complex_p)\n \t{\n-\t  pedwarn (input_location, OPT_Wpedantic,\n+\t  pedwarn (specs->locations[cdw_complex], OPT_Wpedantic,\n \t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}\n@@ -9751,7 +9820,7 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t       : integer_type_node);\n       if (specs->complex_p)\n \t{\n-\t  pedwarn (input_location, OPT_Wpedantic,\n+\t  pedwarn (specs->locations[cdw_complex], OPT_Wpedantic,\n \t\t   \"ISO C does not support complex integer types\");\n \t  specs->type = build_complex_type (specs->type);\n \t}"}, {"sha": "0229a92000aa022329deac73ac2384890bf55cc3", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,3 +1,10 @@\n+2012-05-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/7263\n+\t* c-lex.c (c_lex_with_flags):  Pass a virtual location to the call\n+\tto cpp_classify_number.  For diagnostics, use the precise location\n+\tinstead of the global input_location.\n+\n 2012-05-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/11856"}, {"sha": "b122dab308661e11b1d0e3ebaa460b00ff63bad4", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -315,7 +315,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n     case CPP_NUMBER:\n       {\n \tconst char *suffix = NULL;\n-\tunsigned int flags = cpp_classify_number (parse_in, tok, &suffix);\n+\tunsigned int flags = cpp_classify_number (parse_in, tok, &suffix, *loc);\n \n \tswitch (flags & CPP_N_CATEGORY)\n \t  {\n@@ -417,7 +417,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \n \t*cpp_spell_token (parse_in, tok, name, true) = 0;\n \n-\terror (\"stray %qs in program\", name);\n+\terror_at (*loc, \"stray %qs in program\", name);\n       }\n \n       goto retry;"}, {"sha": "33420ca46229439c9bfe05920c3978a47c788fa8", "filename": "gcc/c-parser.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -2015,14 +2015,15 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n-\t  tree value = c_parser_peek_token (parser)->value;\n-\t  c_id_kind kind = c_parser_peek_token (parser)->id_kind;\n+\t  c_token *name_token = c_parser_peek_token (parser);\n+\t  tree value = name_token->value;\n+\t  c_id_kind kind = name_token->id_kind;\n \n \t  if (kind == C_ID_ADDRSPACE)\n \t    {\n \t      addr_space_t as\n-\t\t= c_parser_peek_token (parser)->keyword - RID_FIRST_ADDR_SPACE;\n-\t      declspecs_add_addrspace (specs, as);\n+\t\t= name_token->keyword - RID_FIRST_ADDR_SPACE;\n+\t      declspecs_add_addrspace (name_token->location, specs, as);\n \t      c_parser_consume_token (parser);\n \t      attrs_ok = true;\n \t      continue;\n@@ -2068,7 +2069,7 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t    }\n \t  t.expr = NULL_TREE;\n \t  t.expr_const_operands = true;\n-\t  declspecs_add_type (loc, specs, t);\n+\t  declspecs_add_type (name_token->location, specs, t);\n \t  continue;\n \t}\n       if (c_parser_next_token_is (parser, CPP_LESS))\n@@ -2104,7 +2105,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  /* TODO: Distinguish between function specifiers (inline, noreturn)\n \t     and storage class specifiers, either here or in\n \t     declspecs_add_scspec.  */\n-\t  declspecs_add_scspec (specs, c_parser_peek_token (parser)->value);\n+\t  declspecs_add_scspec (loc, specs,\n+\t\t\t\tc_parser_peek_token (parser)->value);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase RID_UNSIGNED:\n@@ -2171,18 +2173,18 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \tcase RID_VOLATILE:\n \tcase RID_RESTRICT:\n \t  attrs_ok = true;\n-\t  declspecs_add_qual (specs, c_parser_peek_token (parser)->value);\n+\t  declspecs_add_qual (loc, specs, c_parser_peek_token (parser)->value);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase RID_ATTRIBUTE:\n \t  if (!attrs_ok)\n \t    goto out;\n \t  attrs = c_parser_attributes (parser);\n-\t  declspecs_add_attrs (specs, attrs);\n+\t  declspecs_add_attrs (loc, specs, attrs);\n \t  break;\n \tcase RID_ALIGNAS:\n \t  align = c_parser_alignas_specifier (parser);\n-\t  declspecs_add_alignas (specs, align);\n+\t  declspecs_add_alignas (loc, specs, align);\n \t  break;\n \tdefault:\n \t  goto out;\n@@ -3332,7 +3334,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n   specs = build_null_declspecs ();\n   if (attrs)\n     {\n-      declspecs_add_attrs (specs, attrs);\n+      declspecs_add_attrs (input_location, specs, attrs);\n       attrs = NULL_TREE;\n     }\n   c_parser_declspecs (parser, specs, true, true, true, cla_nonabstract_decl);"}, {"sha": "8f8c9d8e01406a4cedfaedee41870094af828ad8", "filename": "gcc/c-tree.h", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -222,8 +222,45 @@ enum c_typespec_keyword {\n   cts_accum\n };\n \n-/* A sequence of declaration specifiers in C.  */\n+/* This enum lists all the possible declarator specifiers, storage\n+   class or attribute that a user can write.  There is at least one\n+   enumerator per possible declarator specifier in the struct\n+   c_declspecs below.\n+\n+   It is used to index the array of declspec locations in struct\n+   c_declspecs.  */\n+enum c_declspec_word {\n+  cdw_typespec /* A catch-all for a typespec.  */,\n+  cdw_storage_class  /* A catch-all for a storage class */,\n+  cdw_attributes,\n+  cdw_typedef,\n+  cdw_explicit_signed,\n+  cdw_deprecated,\n+  cdw_default_int,\n+  cdw_long,\n+  cdw_long_long,\n+  cdw_short,\n+  cdw_signed,\n+  cdw_unsigned,\n+  cdw_complex,\n+  cdw_inline,\n+  cdw_noreturn,\n+  cdw_thread,\n+  cdw_const,\n+  cdw_volatile,\n+  cdw_restrict,\n+  cdw_saturating,\n+  cdw_alignas,\n+  cdw_address_space,\n+  cdw_number_of_elements /* This one must always be the last\n+\t\t\t    enumerator.  */\n+};\n+\n+/* A sequence of declaration specifiers in C.  When a new declaration\n+   specifier is added, please update the enum c_declspec_word above\n+   accordingly.  */\n struct c_declspecs {\n+  source_location locations[cdw_number_of_elements];\n   /* The type specified, if a single type specifier such as a struct,\n      union or enum specifier, typedef name or typeof specifies the\n      whole type, or NULL_TREE if none or a keyword such as \"void\" or\n@@ -509,15 +546,20 @@ extern struct c_declarator *build_id_declarator (tree);\n extern struct c_declarator *make_pointer_declarator (struct c_declspecs *,\n \t\t\t\t\t\t     struct c_declarator *);\n extern struct c_declspecs *build_null_declspecs (void);\n-extern struct c_declspecs *declspecs_add_qual (struct c_declspecs *, tree);\n+extern struct c_declspecs *declspecs_add_qual (source_location,\n+\t\t\t\t\t       struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_type (location_t,\n \t\t\t\t\t       struct c_declspecs *,\n \t\t\t\t\t       struct c_typespec);\n-extern struct c_declspecs *declspecs_add_scspec (struct c_declspecs *, tree);\n-extern struct c_declspecs *declspecs_add_attrs (struct c_declspecs *, tree);\n-extern struct c_declspecs *declspecs_add_addrspace (struct c_declspecs *,\n+extern struct c_declspecs *declspecs_add_scspec (source_location,\n+\t\t\t\t\t\t struct c_declspecs *, tree);\n+extern struct c_declspecs *declspecs_add_attrs (source_location,\n+\t\t\t\t\t\tstruct c_declspecs *, tree);\n+extern struct c_declspecs *declspecs_add_addrspace (source_location,\n+\t\t\t\t\t\t    struct c_declspecs *,\n \t\t\t\t\t\t    addr_space_t);\n-extern struct c_declspecs *declspecs_add_alignas (struct c_declspecs *, tree);\n+extern struct c_declspecs *declspecs_add_alignas (source_location,\n+\t\t\t\t\t\t  struct c_declspecs *, tree);\n extern struct c_declspecs *finish_declspecs (struct c_declspecs *);\n \n /* in c-objc-common.c */"}, {"sha": "9913002f2772adc2ec574b3001950708ad2b70ae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,3 +1,37 @@\n+2012-05-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/7263\n+\t* cp-tree.h (enum cp_decl_spec): Add new enumerators to cover all\n+\tthe possible declarator specifiers so far.\n+\t(struct cp_decl_specifier_seq::locations): Declare new member.\n+\t(cp_decl_specifier_seq::{specs, type_location}): Remove.\n+\t(decl_spec_seq_has_spec_p): Declare new function.\n+\t* parser.c (cp_parser_check_decl_spec): Remove.\n+\t(set_and_check_decl_spec_loc): Define new static function.\n+\t(decl_spec_seq_has_spec_p): Define new public function.\n+\t(cp_parser_decl_specifier_seq, cp_parser_function_specifier_opt)\n+\t(cp_parser_type_specifier, cp_parser_simple_type_specifier)\n+\t(cp_parser_set_storage_class, cp_parser_set_decl_spec_type)\n+\t(cp_parser_alias_declaration): Set the locations for each\n+\tdeclspec, using set_and_check_decl_spec_loc.\n+\t(cp_parser_explicit_instantiation, cp_parser_init_declarator)\n+\t(cp_parser_member_declaration, cp_parser_init_declarator): Use the\n+\tnew declspec location for specifiers.  Use the new\n+\tdecl_spec_seq_has_spec_p.\n+\t(cp_parser_type_specifier_seq): Use the new\n+\tset_and_check_decl_spec_loc.  Stop using\n+\tcp_parser_check_decl_spec.  Use the new decl_spec_seq_has_spec_p.\n+\t(, cp_parser_init_declarator): Use the new\n+\tset_and_check_decl_spec_loc.\n+\t(cp_parser_single_declaration, cp_parser_friend_p)\n+\t(cp_parser_objc_class_ivars, cp_parser_objc_struct_declaration):\n+\tUse the new decl_spec_seq_has_spec_p.\n+\t* decl.c (check_tag_decl): Use new decl_spec_seq_has_spec_p.  Use\n+\tthe more precise ds_redefined_builtin_type_spec location for\n+\tdiagnostics about re-declaring C++ built-in types.\n+\t(start_decl, grokvardecl, grokdeclarator): Use the new\n+\tdecl_spec_seq_has_spec_p.\n+\n 2012-05-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/11856"}, {"sha": "8eaf766b99dae1ef613cca8c3dee2d508132829b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -4647,7 +4647,9 @@ typedef enum cp_storage_class {\n   sc_mutable\n } cp_storage_class;\n \n-/* An individual decl-specifier.  */\n+/* An individual decl-specifier.  This is used to index the array of\n+   locations for the declspecs in struct cp_decl_specifier_seq\n+   below.  */\n \n typedef enum cp_decl_spec {\n   ds_first,\n@@ -4667,17 +4669,20 @@ typedef enum cp_decl_spec {\n   ds_constexpr,\n   ds_complex,\n   ds_thread,\n-  ds_last\n+  ds_type_spec,\n+  ds_redefined_builtin_type_spec,\n+  ds_attribute,\n+  ds_storage_class,\n+  ds_long_long,\n+  ds_last /* This enumerator must always be the last one.  */\n } cp_decl_spec;\n \n /* A decl-specifier-seq.  */\n \n typedef struct cp_decl_specifier_seq {\n-  /* The number of times each of the keywords has been seen.  */\n-  unsigned specs[(int) ds_last];\n-  /* The location of the primary type. Mainly used for error\n-     reporting.  */\n-  location_t type_location;\n+  /* An array of locations for the declaration sepecifiers, indexed by\n+     enum cp_decl_spec_word.  */\n+  source_location locations[ds_last];\n   /* The primary type, if any, given by the decl-specifier-seq.\n      Modifiers, like \"short\", \"const\", and \"unsigned\" are not\n      reflected here.  This field will be a TYPE, unless a typedef-name\n@@ -4827,6 +4832,8 @@ struct GTY((chain_next (\"%h.next\"))) tinst_level {\n   bool in_system_header_p;\n };\n \n+bool decl_spec_seq_has_spec_p (const cp_decl_specifier_seq *, cp_decl_spec);\n+\n /* Return the type of the `this' parameter of FNTYPE.  */\n \n static inline tree"}, {"sha": "fa9fcc8da9b52a35ba33c91a43d8364044bb0cc4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -4129,8 +4129,8 @@ fixup_anonymous_aggr (tree t)\n tree\n check_tag_decl (cp_decl_specifier_seq *declspecs)\n {\n-  int saw_friend = declspecs->specs[(int)ds_friend] != 0;\n-  int saw_typedef = declspecs->specs[(int)ds_typedef] != 0;\n+  int saw_friend = decl_spec_seq_has_spec_p (declspecs, ds_friend);\n+  int saw_typedef = decl_spec_seq_has_spec_p (declspecs, ds_typedef);\n   /* If a class, struct, or enum type is declared by the DECLSPECS\n      (i.e, if a class-specifier, enum-specifier, or non-typename\n      elaborated-type-specifier appears in the DECLSPECS),\n@@ -4143,7 +4143,8 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n   else if (declspecs->redefined_builtin_type)\n     {\n       if (!in_system_header)\n-\tpermerror (input_location, \"redeclaration of C++ built-in type %qT\",\n+\tpermerror (declspecs->locations[ds_redefined_builtin_type_spec],\n+\t\t   \"redeclaration of C++ built-in type %qT\",\n \t\t   declspecs->redefined_builtin_type);\n       return NULL_TREE;\n     }\n@@ -4198,29 +4199,29 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n \n   else\n     {\n-      if (declspecs->specs[(int)ds_inline]\n-\t  || declspecs->specs[(int)ds_virtual])\n+      if (decl_spec_seq_has_spec_p (declspecs, ds_inline)\n+\t  || decl_spec_seq_has_spec_p (declspecs, ds_virtual))\n \terror (\"%qs can only be specified for functions\",\n-\t       declspecs->specs[(int)ds_inline]\n+\t       decl_spec_seq_has_spec_p (declspecs, ds_inline)\n \t       ? \"inline\" : \"virtual\");\n       else if (saw_friend\n \t       && (!current_class_type\n \t\t   || current_scope () != current_class_type))\n \terror (\"%<friend%> can only be specified inside a class\");\n-      else if (declspecs->specs[(int)ds_explicit])\n+      else if (decl_spec_seq_has_spec_p (declspecs, ds_explicit))\n \terror (\"%<explicit%> can only be specified for constructors\");\n       else if (declspecs->storage_class)\n \terror (\"a storage class can only be specified for objects \"\n \t       \"and functions\");\n-      else if (declspecs->specs[(int)ds_const]\n-\t       || declspecs->specs[(int)ds_volatile]\n-\t       || declspecs->specs[(int)ds_restrict]\n-\t       || declspecs->specs[(int)ds_thread])\n+      else if (decl_spec_seq_has_spec_p (declspecs, ds_const)\n+\t       || decl_spec_seq_has_spec_p (declspecs, ds_volatile)\n+\t       || decl_spec_seq_has_spec_p (declspecs, ds_restrict)\n+\t       || decl_spec_seq_has_spec_p (declspecs, ds_thread))\n \terror (\"qualifiers can only be specified for objects \"\n \t       \"and functions\");\n       else if (saw_typedef)\n \twarning (0, \"%<typedef%> was ignored in this declaration\");\n-      else if (declspecs->specs[(int) ds_constexpr])\n+      else if (decl_spec_seq_has_spec_p (declspecs,  ds_constexpr))\n         error (\"%<constexpr%> cannot be used for type declarations\");\n     }\n \n@@ -4472,7 +4473,7 @@ start_decl (const cp_declarator *declarator,\n \t\terror (\"duplicate initialization of %qD\", decl);\n \t      if (duplicate_decls (decl, field, /*newdecl_is_friend=*/false))\n \t\tdecl = field;\n-              if (declspecs->specs[(int) ds_constexpr]\n+              if (decl_spec_seq_has_spec_p (declspecs, ds_constexpr)\n                   && !DECL_DECLARED_CONSTEXPR_P (field))\n                 error (\"%qD declared %<constexpr%> outside its class\", field);\n \t    }\n@@ -7682,7 +7683,7 @@ grokvardecl (tree type,\n       TREE_PUBLIC (decl) = DECL_EXTERNAL (decl);\n     }\n \n-  if (declspecs->specs[(int)ds_thread])\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_thread))\n     DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n \n   /* If the type of the decl has no linkage, make sure that we'll\n@@ -8436,16 +8437,16 @@ grokdeclarator (const cp_declarator *declarator,\n   bool parameter_pack_p = declarator? declarator->parameter_pack_p : false;\n   bool template_type_arg = false;\n   bool template_parm_flag = false;\n-  bool constexpr_p = declspecs->specs[(int) ds_constexpr];\n+  bool constexpr_p = decl_spec_seq_has_spec_p (declspecs, ds_constexpr);\n   const char *errmsg;\n \n-  signed_p = declspecs->specs[(int)ds_signed];\n-  unsigned_p = declspecs->specs[(int)ds_unsigned];\n-  short_p = declspecs->specs[(int)ds_short];\n-  long_p = declspecs->specs[(int)ds_long];\n-  longlong = declspecs->specs[(int)ds_long] >= 2;\n+  signed_p = decl_spec_seq_has_spec_p (declspecs, ds_signed);\n+  unsigned_p = decl_spec_seq_has_spec_p (declspecs, ds_unsigned);\n+  short_p = decl_spec_seq_has_spec_p (declspecs, ds_short);\n+  long_p = decl_spec_seq_has_spec_p (declspecs, ds_long);\n+  longlong = decl_spec_seq_has_spec_p (declspecs, ds_long_long);\n   explicit_int128 = declspecs->explicit_int128_p;\n-  thread_p = declspecs->specs[(int)ds_thread];\n+  thread_p = decl_spec_seq_has_spec_p (declspecs, ds_thread);\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = true, decl_context = NORMAL;\n@@ -8646,7 +8647,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n   if (dname && IDENTIFIER_OPNAME_P (dname))\n     {\n-      if (declspecs->specs[(int)ds_typedef])\n+      if (decl_spec_seq_has_spec_p (declspecs, ds_typedef))\n \t{\n \t  error (\"declaration of %qD as %<typedef%>\", dname);\n \t  return error_mark_node;\n@@ -8684,7 +8685,7 @@ grokdeclarator (const cp_declarator *declarator,\n   if (name == NULL)\n     name = decl_context == PARM ? \"parameter\" : \"type name\";\n \n-  if (constexpr_p && declspecs->specs[(int)ds_typedef])\n+  if (constexpr_p && decl_spec_seq_has_spec_p (declspecs, ds_typedef))\n     {\n       error (\"%<constexpr%> cannot appear in a typedef declaration\");\n       return error_mark_node;\n@@ -8910,7 +8911,7 @@ grokdeclarator (const cp_declarator *declarator,\n   else if (short_p)\n     type = short_integer_type_node;\n \n-  if (declspecs->specs[(int)ds_complex])\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_complex))\n     {\n       if (TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n \terror (\"complex invalid for %qs\", name);\n@@ -8934,11 +8935,11 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   type_quals = TYPE_UNQUALIFIED;\n-  if (declspecs->specs[(int)ds_const])\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_const))\n     type_quals |= TYPE_QUAL_CONST;\n-  if (declspecs->specs[(int)ds_volatile])\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_volatile))\n     type_quals |= TYPE_QUAL_VOLATILE;\n-  if (declspecs->specs[(int)ds_restrict])\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_restrict))\n     type_quals |= TYPE_QUAL_RESTRICT;\n   if (sfk == sfk_conversion && type_quals != TYPE_UNQUALIFIED)\n     error (\"qualifiers are not allowed on declaration of %<operator %T%>\",\n@@ -8963,9 +8964,9 @@ grokdeclarator (const cp_declarator *declarator,\n   type_quals = cp_type_quals (type);\n \n   staticp = 0;\n-  inlinep = !! declspecs->specs[(int)ds_inline];\n-  virtualp = !! declspecs->specs[(int)ds_virtual];\n-  explicitp = !! declspecs->specs[(int)ds_explicit];\n+  inlinep = decl_spec_seq_has_spec_p (declspecs, ds_inline);\n+  virtualp =  decl_spec_seq_has_spec_p (declspecs, ds_virtual);\n+  explicitp = decl_spec_seq_has_spec_p (declspecs, ds_explicit);\n \n   storage_class = declspecs->storage_class;\n   if (storage_class == sc_static)\n@@ -8977,7 +8978,7 @@ grokdeclarator (const cp_declarator *declarator,\n       storage_class = sc_none;\n       staticp = 0;\n     }\n-  friendp = !! declspecs->specs[(int)ds_friend];\n+  friendp = decl_spec_seq_has_spec_p (declspecs, ds_friend);\n \n   if (dependent_name && !friendp)\n     {\n@@ -8988,7 +8989,7 @@ grokdeclarator (const cp_declarator *declarator,\n   /* Issue errors about use of storage classes for parameters.  */\n   if (decl_context == PARM)\n     {\n-      if (declspecs->specs[(int)ds_typedef])\n+      if (decl_spec_seq_has_spec_p (declspecs, ds_typedef))\n \t{\n \t  error (\"typedef declaration invalid in parameter declaration\");\n \t  return error_mark_node;\n@@ -9032,7 +9033,7 @@ grokdeclarator (const cp_declarator *declarator,\n       && ((storage_class\n \t   && storage_class != sc_extern\n \t   && storage_class != sc_static)\n-\t  || declspecs->specs[(int)ds_typedef]))\n+\t  || decl_spec_seq_has_spec_p (declspecs, ds_typedef)))\n     {\n       error (\"multiple storage classes in declaration of %qs\", name);\n       thread_p = false;\n@@ -9046,7 +9047,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  && (storage_class == sc_register\n \t      || storage_class == sc_auto))\n \t;\n-      else if (declspecs->specs[(int)ds_typedef])\n+      else if (decl_spec_seq_has_spec_p (declspecs, ds_typedef))\n \t;\n       else if (decl_context == FIELD\n \t       /* C++ allows static class elements.  */\n@@ -9640,7 +9641,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      return error_mark_node;\n \t    }\n \t}\n-      else if (declspecs->specs[(int)ds_typedef]\n+      else if (decl_spec_seq_has_spec_p (declspecs, ds_typedef)\n \t       && current_class_type)\n \t{\n \t  error (\"cannot declare member %<%T::%s%> within %qT\",\n@@ -9711,7 +9712,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t  error (\"non-member %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n \t}\n-      else if (decl_context == TYPENAME || declspecs->specs[(int)ds_typedef])\n+      else if (decl_context == TYPENAME\n+\t       || decl_spec_seq_has_spec_p (declspecs, ds_typedef))\n \t{\n \t  error (\"non-object member %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n@@ -9741,7 +9743,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   /* If this is declaring a typedef name, return a TYPE_DECL.  */\n-  if (declspecs->specs[(int)ds_typedef] && decl_context != TYPENAME)\n+  if (decl_spec_seq_has_spec_p (declspecs, ds_typedef) && decl_context != TYPENAME)\n     {\n       tree decl;\n \n@@ -9853,7 +9855,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      memfn_quals != TYPE_UNQUALIFIED,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n-      if (declspecs->specs[(int)ds_alias])\n+      if (decl_spec_seq_has_spec_p (declspecs, ds_alias))\n \t/* Acknowledge that this was written:\n \t     `using analias = atype;'.  */\n \tTYPE_DECL_ALIAS_P (decl) = 1;\n@@ -10352,7 +10354,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t   and `extern' makes no difference.  */\n \tif (! toplevel_bindings_p ()\n \t    && (storage_class == sc_static\n-\t\t|| declspecs->specs[(int)ds_inline])\n+\t\t|| decl_spec_seq_has_spec_p (declspecs, ds_inline))\n \t    && pedantic)\n \t  {\n \t    if (storage_class == sc_static)"}, {"sha": "aa2324ec7848cfc95a42d16ffac1980e49339a89", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -864,7 +864,7 @@ grokfield (const cp_declarator *declarator,\n \t  cplus_decl_attributes (&value, attrlist, attrflags);\n \t}\n \n-      if (declspecs->specs[(int)ds_typedef]\n+      if (decl_spec_seq_has_spec_p (declspecs, ds_typedef)\n           && TREE_TYPE (value) != error_mark_node\n           && TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (value))) != value)\n \tset_underlying_type (value);"}, {"sha": "2dc8f564fe89b3a862f54aface4f30c0a41266aa", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 156, "deletions": 105, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -2223,6 +2223,9 @@ static void cp_parser_set_storage_class\n   (cp_parser *, cp_decl_specifier_seq *, enum rid, location_t);\n static void cp_parser_set_decl_spec_type\n   (cp_decl_specifier_seq *, tree, location_t, bool);\n+static void set_and_check_decl_spec_loc\n+  (cp_decl_specifier_seq *decl_specs,\n+   cp_decl_spec ds, source_location location);\n static bool cp_parser_friend_p\n   (const cp_decl_specifier_seq *);\n static void cp_parser_required_error\n@@ -2494,53 +2497,6 @@ cp_parser_simulate_error (cp_parser* parser)\n   return false;\n }\n \n-/* Check for repeated decl-specifiers.  */\n-\n-static void\n-cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n-\t\t\t   location_t location)\n-{\n-  int ds;\n-\n-  for (ds = ds_first; ds != ds_last; ++ds)\n-    {\n-      unsigned count = decl_specs->specs[ds];\n-      if (count < 2)\n-\tcontinue;\n-      /* The \"long\" specifier is a special case because of \"long long\".  */\n-      if (ds == ds_long)\n-\t{\n-\t  if (count > 2)\n-\t    error_at (location, \"%<long long long%> is too long for GCC\");\n-\t  else \n-\t    pedwarn_cxx98 (location, OPT_Wlong_long, \n-\t\t\t   \"ISO C++ 1998 does not support %<long long%>\");\n-\t}\n-      else if (count > 1)\n-\t{\n-\t  static const char *const decl_spec_names[] = {\n-\t    \"signed\",\n-\t    \"unsigned\",\n-\t    \"short\",\n-\t    \"long\",\n-\t    \"const\",\n-\t    \"volatile\",\n-\t    \"restrict\",\n-\t    \"inline\",\n-\t    \"virtual\",\n-\t    \"explicit\",\n-\t    \"friend\",\n-\t    \"typedef\",\n-\t    \"using\",\n-            \"constexpr\",\n-\t    \"__complex\",\n-\t    \"__thread\"\n-\t  };\n-\t  error_at (location, \"duplicate %qs\", decl_spec_names[ds]);\n-\t}\n-    }\n-}\n-\n /* This function is called when a type is defined.  If type\n    definitions are forbidden at this point, an error message is\n    issued.  */\n@@ -10555,6 +10511,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n {\n   bool constructor_possible_p = !parser->in_declarator_p;\n   cp_token *start_token = NULL;\n+  cp_decl_spec ds;\n \n   /* Clear DECL_SPECS.  */\n   clear_decl_specs (decl_specs);\n@@ -10568,6 +10525,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       bool constructor_p;\n       bool found_decl_spec;\n       cp_token *token;\n+      ds = ds_last;\n \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -10583,6 +10541,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  decl_specs->attributes\n \t    = chainon (decl_specs->attributes,\n \t\t       cp_parser_attributes_opt (parser));\n+\t  if (decl_specs->locations[ds_attribute] == 0)\n+\t    decl_specs->locations[ds_attribute] = token->location;\n \t  continue;\n \t}\n       /* Assume we will find a decl-specifier keyword.  */\n@@ -10602,14 +10562,14 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t    }\n \t  else\n \t    {\n-\t      ++decl_specs->specs[(int) ds_friend];\n+\t      ds = ds_friend;\n \t      /* Consume the token.  */\n \t      cp_lexer_consume_token (parser->lexer);\n \t    }\n \t  break;\n \n         case RID_CONSTEXPR:\n-          ++decl_specs->specs[(int) ds_constexpr];\n+\t  ds = ds_constexpr;\n           cp_lexer_consume_token (parser->lexer);\n           break;\n \n@@ -10626,7 +10586,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  /* decl-specifier:\n \t       typedef  */\n \tcase RID_TYPEDEF:\n-\t  ++decl_specs->specs[(int) ds_typedef];\n+\t  ds = ds_typedef;\n \t  /* Consume the token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* A constructor declarator cannot appear in a typedef.  */\n@@ -10679,8 +10639,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  break;\n \tcase RID_THREAD:\n \t  /* Consume the token.  */\n+\t  ds = ds_thread;\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  ++decl_specs->specs[(int) ds_thread];\n \t  break;\n \n \tdefault:\n@@ -10694,13 +10654,16 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  && token->keyword != RID_CONSTEXPR)\n \terror (\"decl-specifier invalid in condition\");\n \n+      if (ds != ds_last)\n+\tset_and_check_decl_spec_loc (decl_specs, ds, token->location);\n+\n       /* Constructors are a special case.  The `S' in `S()' is not a\n \t decl-specifier; it is the beginning of the declarator.  */\n       constructor_p\n \t= (!found_decl_spec\n \t   && constructor_possible_p\n \t   && (cp_parser_constructor_declarator_p\n-\t       (parser, decl_specs->specs[(int) ds_friend] != 0)));\n+\t       (parser, decl_spec_seq_has_spec_p (decl_specs, ds_friend))));\n \n       /* If we don't have a DECL_SPEC yet, then we must be looking at\n \t a type-specifier.  */\n@@ -10777,12 +10740,10 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n       flags |= CP_PARSER_FLAGS_OPTIONAL;\n     }\n \n-  cp_parser_check_decl_spec (decl_specs, start_token->location);\n-\n   /* Don't allow a friend specifier with a class definition.  */\n-  if (decl_specs->specs[(int) ds_friend] != 0\n+  if (decl_spec_seq_has_spec_p (decl_specs, ds_friend)\n       && (*declares_class_or_enum & 2))\n-    error_at (start_token->location,\n+    error_at (decl_specs->locations[ds_friend],\n \t      \"class definition may not be declared a friend\");\n }\n \n@@ -10843,8 +10804,7 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n   switch (token->keyword)\n     {\n     case RID_INLINE:\n-      if (decl_specs)\n-\t++decl_specs->specs[(int) ds_inline];\n+      set_and_check_decl_spec_loc (decl_specs, ds_inline, token->location);\n       break;\n \n     case RID_VIRTUAL:\n@@ -10853,13 +10813,11 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n \t A member function template shall not be virtual.  */\n       if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \terror_at (token->location, \"templates may not be %<virtual%>\");\n-      else if (decl_specs)\n-\t++decl_specs->specs[(int) ds_virtual];\n+      set_and_check_decl_spec_loc (decl_specs, ds_virtual, token->location);\n       break;\n \n     case RID_EXPLICIT:\n-      if (decl_specs)\n-\t++decl_specs->specs[(int) ds_explicit];\n+      set_and_check_decl_spec_loc (decl_specs, ds_explicit, token->location);\n       break;\n \n     default:\n@@ -13170,14 +13128,16 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n       if (declares_class_or_enum & 2)\n \tcp_parser_check_for_definition_in_return_type (declarator,\n \t\t\t\t\t\t       decl_specifiers.type,\n-\t\t\t\t\t\t       decl_specifiers.type_location);\n+\t\t\t\t\t\t       decl_specifiers.locations[ds_type_spec]);\n       if (declarator != cp_error_declarator)\n \t{\n-\t  if (decl_specifiers.specs[(int)ds_inline])\n-\t    permerror (input_location, \"explicit instantiation shall not use\"\n+\t  if (decl_spec_seq_has_spec_p (&decl_specifiers, ds_inline))\n+\t    permerror (decl_specifiers.locations[ds_inline],\n+\t\t       \"explicit instantiation shall not use\"\n \t\t       \" %<inline%> specifier\");\n-\t  if (decl_specifiers.specs[(int)ds_constexpr])\n-\t    permerror (input_location, \"explicit instantiation shall not use\"\n+\t  if (decl_spec_seq_has_spec_p (&decl_specifiers, ds_constexpr))\n+\t    permerror (decl_specifiers.locations[ds_constexpr],\n+\t\t       \"explicit instantiation shall not use\"\n \t\t       \" %<constexpr%> specifier\");\n \n \t  decl = grokdeclarator (declarator, &decl_specifiers,\n@@ -13399,7 +13359,7 @@ cp_parser_type_specifier (cp_parser* parser,\n       type_spec\n \t= (cp_parser_elaborated_type_specifier\n \t   (parser,\n-\t    decl_specs && decl_specs->specs[(int) ds_friend],\n+\t    decl_spec_seq_has_spec_p (decl_specs, ds_friend),\n \t    is_declaration));\n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs,\n@@ -13440,7 +13400,7 @@ cp_parser_type_specifier (cp_parser* parser,\n     {\n       if (decl_specs)\n \t{\n-\t  ++decl_specs->specs[(int)ds];\n+\t  set_and_check_decl_spec_loc (decl_specs, ds, token->location);\n \t  decl_specs->any_specifiers_p = true;\n \t}\n       return cp_lexer_consume_token (parser->lexer)->u.value;\n@@ -13531,8 +13491,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       type = boolean_type_node;\n       break;\n     case RID_SHORT:\n-      if (decl_specs)\n-\t++decl_specs->specs[(int) ds_short];\n+      set_and_check_decl_spec_loc (decl_specs, ds_short, token->location);\n       type = short_integer_type_node;\n       break;\n     case RID_INT:\n@@ -13549,17 +13508,15 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       break;\n     case RID_LONG:\n       if (decl_specs)\n-\t++decl_specs->specs[(int) ds_long];\n+\tset_and_check_decl_spec_loc (decl_specs, ds_long, token->location);\n       type = long_integer_type_node;\n       break;\n     case RID_SIGNED:\n-      if (decl_specs)\n-\t++decl_specs->specs[(int) ds_signed];\n+      set_and_check_decl_spec_loc (decl_specs, ds_signed, token->location);\n       type = integer_type_node;\n       break;\n     case RID_UNSIGNED:\n-      if (decl_specs)\n-\t++decl_specs->specs[(int) ds_unsigned];\n+      set_and_check_decl_spec_loc (decl_specs, ds_unsigned, token->location);\n       type = unsigned_type_node;\n       break;\n     case RID_FLOAT:\n@@ -15070,19 +15027,21 @@ static tree\n cp_parser_alias_declaration (cp_parser* parser)\n {\n   tree id, type, decl, pushed_scope = NULL_TREE, attributes;\n-  location_t id_location;\n+  location_t id_location, using_location, attrs_location = 0;\n   cp_declarator *declarator;\n   cp_decl_specifier_seq decl_specs;\n   bool member_p;\n   const char *saved_message = NULL;\n \n   /* Look for the `using' keyword.  */\n+  using_location = cp_lexer_peek_token (parser->lexer)->location;\n   cp_parser_require_keyword (parser, RID_USING, RT_USING);\n   id_location = cp_lexer_peek_token (parser->lexer)->location;\n   id = cp_parser_identifier (parser);\n   if (id == error_mark_node)\n     return error_mark_node;\n \n+  attrs_location = cp_lexer_peek_token (parser->lexer)->location;\n   attributes = cp_parser_attributes_opt (parser);\n   if (attributes == error_mark_node)\n     return error_mark_node;\n@@ -15131,9 +15090,19 @@ cp_parser_alias_declaration (cp_parser* parser)\n \n   clear_decl_specs (&decl_specs);\n   decl_specs.type = type;\n-  decl_specs.attributes = attributes;\n-  ++decl_specs.specs[(int) ds_typedef];\n-  ++decl_specs.specs[(int) ds_alias];\n+  if (attributes != NULL_TREE)\n+    {\n+      decl_specs.attributes = attributes;\n+      set_and_check_decl_spec_loc (&decl_specs,\n+\t\t\t\t   ds_attribute,\n+\t\t\t\t   attrs_location);\n+    }\n+  set_and_check_decl_spec_loc (&decl_specs,\n+\t\t\t       ds_typedef,\n+\t\t\t       using_location);\n+  set_and_check_decl_spec_loc (&decl_specs,\n+\t\t\t       ds_alias,\n+\t\t\t       using_location);\n \n   declarator = make_id_declarator (NULL_TREE, id, sfk_none);\n   declarator->id_loc = id_location;\n@@ -15515,7 +15484,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   if (declares_class_or_enum & 2)\n     cp_parser_check_for_definition_in_return_type (declarator,\n \t\t\t\t\t\t   decl_specifiers->type,\n-\t\t\t\t\t\t   decl_specifiers->type_location);\n+\t\t\t\t\t\t   decl_specifiers->locations[ds_type_spec]);\n \n   /* Figure out what scope the entity declared by the DECLARATOR is\n      located in.  `grokdeclarator' sometimes changes the scope, so\n@@ -16936,8 +16905,6 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n       if (is_declaration && !is_cv_qualifier)\n \tflags |= CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES;\n     }\n-\n-  cp_parser_check_decl_spec (type_specifier_seq, start_token->location);\n }\n \n /* Parse a parameter-declaration-clause.\n@@ -19042,7 +19009,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      if (declares_class_or_enum & 2)\n \t\tcp_parser_check_for_definition_in_return_type\n \t\t\t\t\t    (declarator, decl_specifiers.type,\n-\t\t\t\t\t     decl_specifiers.type_location);\n+\t\t\t\t\t     decl_specifiers.locations[ds_type_spec]);\n \n \t      /* Look for an asm-specification.  */\n \t      asm_specification = cp_parser_asm_specification_opt (parser);\n@@ -21301,7 +21268,7 @@ cp_parser_single_declaration (cp_parser* parser,\n     *friend_p = cp_parser_friend_p (&decl_specifiers);\n \n   /* There are no template typedefs.  */\n-  if (decl_specifiers.specs[(int) ds_typedef])\n+  if (decl_spec_seq_has_spec_p (&decl_specifiers, ds_typedef))\n     {\n       error_at (decl_spec_token_start->location,\n \t\t\"template declaration of %<typedef%>\");\n@@ -22049,10 +22016,11 @@ cp_parser_set_storage_class (cp_parser *parser,\n     }\n \n   if ((keyword == RID_EXTERN || keyword == RID_STATIC)\n-      && decl_specs->specs[(int) ds_thread])\n+      && decl_spec_seq_has_spec_p (decl_specs, ds_thread))\n     {\n-      error_at (location, \"%<__thread%> before %qD\", ridpointers[keyword]);\n-      decl_specs->specs[(int) ds_thread] = 0;\n+      error_at (decl_specs->locations[ds_thread],\n+\t\t\"%<__thread%> before %qD\", ridpointers[keyword]);\n+      decl_specs->locations[ds_thread] = 0;\n     }\n \n   switch (keyword)\n@@ -22076,12 +22044,13 @@ cp_parser_set_storage_class (cp_parser *parser,\n       gcc_unreachable ();\n     }\n   decl_specs->storage_class = storage_class;\n+  set_and_check_decl_spec_loc (decl_specs, ds_storage_class, location);\n \n   /* A storage class specifier cannot be applied alongside a typedef \n      specifier. If there is a typedef specifier present then set \n      conflicting_specifiers_p which will trigger an error later\n      on in grokdeclarator. */\n-  if (decl_specs->specs[(int)ds_typedef])\n+  if (decl_spec_seq_has_spec_p (decl_specs, ds_typedef))\n     decl_specs->conflicting_specifiers_p = true;\n }\n \n@@ -22101,24 +22070,27 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n      this is what happened.  In system headers, we ignore these\n      declarations so that G++ can work with system headers that are not\n      C++-safe.  */\n-  if (decl_specs->specs[(int) ds_typedef]\n+  if (decl_spec_seq_has_spec_p (decl_specs, ds_typedef)\n       && !type_definition_p\n       && (type_spec == boolean_type_node\n \t  || type_spec == char16_type_node\n \t  || type_spec == char32_type_node\n \t  || type_spec == wchar_type_node)\n       && (decl_specs->type\n-\t  || decl_specs->specs[(int) ds_long]\n-\t  || decl_specs->specs[(int) ds_short]\n-\t  || decl_specs->specs[(int) ds_unsigned]\n-\t  || decl_specs->specs[(int) ds_signed]))\n+\t  || decl_spec_seq_has_spec_p (decl_specs, ds_long)\n+\t  || decl_spec_seq_has_spec_p (decl_specs, ds_short)\n+\t  || decl_spec_seq_has_spec_p (decl_specs, ds_unsigned)\n+\t  || decl_spec_seq_has_spec_p (decl_specs, ds_signed)))\n     {\n       decl_specs->redefined_builtin_type = type_spec;\n+      set_and_check_decl_spec_loc (decl_specs,\n+\t\t\t\t   ds_redefined_builtin_type_spec,\n+\t\t\t\t   location);\n       if (!decl_specs->type)\n \t{\n \t  decl_specs->type = type_spec;\n \t  decl_specs->type_definition_p = false;\n-\t  decl_specs->type_location = location;\n+\t  set_and_check_decl_spec_loc (decl_specs,ds_type_spec, location);\n \t}\n     }\n   else if (decl_specs->type)\n@@ -22128,17 +22100,96 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n       decl_specs->type = type_spec;\n       decl_specs->type_definition_p = type_definition_p;\n       decl_specs->redefined_builtin_type = NULL_TREE;\n-      decl_specs->type_location = location;\n+      set_and_check_decl_spec_loc (decl_specs, ds_type_spec, location);\n+    }\n+}\n+\n+/* Set the location for a declarator specifier and check if it is\n+   duplicated.\n+\n+   DECL_SPECS is the sequence of declarator specifiers onto which to\n+   set the location.\n+\n+   DS is the single declarator specifier to set which location  is to\n+   be set onto the existing sequence of declarators.\n+\n+   LOCATION is the location for the declarator specifier to\n+   consider.  */\n+\n+static void\n+set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,\n+\t\t\t     cp_decl_spec ds, source_location location)\n+{\n+  gcc_assert (ds < ds_last);\n+\n+  if (decl_specs == NULL)\n+    return;\n+\n+  if (decl_specs->locations[ds] == 0)\n+    decl_specs->locations[ds] = location;\n+  else\n+    {\n+      if (ds == ds_long)\n+\t{\n+\t  if (decl_specs->locations[ds_long_long] != 0)\n+\t    error_at (location,\n+\t\t      \"%<long long long%> is too long for GCC\");\n+\t  else\n+\t    {\n+\t      decl_specs->locations[ds_long_long] = location;\n+\t      pedwarn_cxx98 (location,\n+\t\t\t     OPT_Wlong_long, \n+\t\t\t     \"ISO C++ 1998 does not support %<long long%>\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  static const char *const decl_spec_names[] = {\n+\t    \"signed\",\n+\t    \"unsigned\",\n+\t    \"short\",\n+\t    \"long\",\n+\t    \"const\",\n+\t    \"volatile\",\n+\t    \"restrict\",\n+\t    \"inline\",\n+\t    \"virtual\",\n+\t    \"explicit\",\n+\t    \"friend\",\n+\t    \"typedef\",\n+\t    \"using\",\n+            \"constexpr\",\n+\t    \"__complex\",\n+\t    \"__thread\"\n+\t  };\n+\t  error_at (location,\n+\t\t    \"duplicate %qs\", decl_spec_names[ds]);\n+\t}\n     }\n }\n \n+/* Return true iff the declarator specifier DS is present in the\n+   sequence of declarator specifiers DECL_SPECS.  */\n+\n+bool\n+decl_spec_seq_has_spec_p (const cp_decl_specifier_seq * decl_specs,\n+\t\t\t  cp_decl_spec ds)\n+{\n+  gcc_assert (ds < ds_last);\n+\n+  if (decl_specs == NULL)\n+    return false;\n+\n+  return decl_specs->locations[ds] != 0;\n+}\n+\n /* DECL_SPECIFIERS is the representation of a decl-specifier-seq.\n    Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */\n \n static bool\n cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)\n {\n-  return decl_specifiers->specs[(int) ds_friend] != 0;\n+  return decl_spec_seq_has_spec_p (decl_specifiers, ds_friend);\n }\n \n /* Issue an error message indicating that TOKEN_DESC was expected.\n@@ -23951,17 +24002,17 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t}\n \n       /* __thread.  */\n-      if (declspecs.specs[(int) ds_thread])\n+      if (decl_spec_seq_has_spec_p (&declspecs, ds_thread))\n \t{\n \t  cp_parser_error (parser, \"invalid type for instance variable\");\n-\t  declspecs.specs[(int) ds_thread] = 0;\n+\t  declspecs.locations[ds_thread] = 0;\n \t}\n       \n       /* typedef.  */\n-      if (declspecs.specs[(int) ds_typedef])\n+      if (decl_spec_seq_has_spec_p (&declspecs, ds_typedef))\n \t{\n \t  cp_parser_error (parser, \"invalid type for instance variable\");\n-\t  declspecs.specs[(int) ds_typedef] = 0;\n+\t  declspecs.locations[ds_thread] = 0;\n \t}\n \n       prefix_attributes = declspecs.attributes;\n@@ -24530,17 +24581,17 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n     }\n   \n   /* __thread.  */\n-  if (declspecs.specs[(int) ds_thread])\n+  if (decl_spec_seq_has_spec_p (&declspecs, ds_thread))\n     {\n       cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.specs[(int) ds_thread] = 0;\n+      declspecs.locations[ds_thread] = 0;\n     }\n   \n   /* typedef.  */\n-  if (declspecs.specs[(int) ds_typedef])\n+  if (decl_spec_seq_has_spec_p (&declspecs, ds_typedef))\n     {\n       cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.specs[(int) ds_typedef] = 0;\n+      declspecs.locations[ds_typedef] = 0;\n     }\n \n   prefix_attributes = declspecs.attributes;"}, {"sha": "ac4f287af0fd9a64cb2efe4452e732309432f874", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,3 +1,23 @@\n+2012-05-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/7263\n+\t* gcc.dg/binary-constants-2.c: Run without tracking locations\n+\taccross macro expansion.\n+\t* gcc.dg/binary-constants-3.c: Likewise.\n+\t* gcc.dg/cpp/sysmac2.c: Likewise.\n+\t* testsuite/gcc.dg/nofixed-point-2.c: Adjust for more precise\n+\tlocation.\n+\t* gcc.dg/cpp/syshdr3.c: New test.\n+\t* gcc.dg/cpp/syshdr3.h: New header for the new test above.\n+\t* gcc.dg/system-binary-constants-1.c: New test.\n+\t* gcc.dg/system-binary-constants-1.h: New header for the new test\n+\tabove.\n+\t* g++.dg/cpp/syshdr3.C: New test.\n+\t* g++.dg/cpp/syshdr3.h: New header the new test above.\n+\t* g++.dg/system-binary-constants-1.C: New test.\n+\t* g++.dg/system-binary-constants-1.h: New header the new test\n+\tabove.\n+\n 2012-05-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.old-deja/g++.pt/crash10.C: Adjust post PR11586."}, {"sha": "39168239a39e1908041ccde7b2154e2cdaab25cb", "filename": "gcc/testsuite/g++.dg/cpp/syshdr3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fsyshdr3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fsyshdr3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fsyshdr3.C?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,16 @@\n+/* Contributed by Dodji Seketeli <dodji@redhat.com> */\n+/* Origin: PR preprocessor/7263 */\n+/* { dg-options \"-pedantic -std=c++98 -ftrack-macro-expansion=1\" } */\n+/* { dg-do compile } */\n+\n+/* This tests the proprer suppression of warning coming from macro\n+   defined in system headers and expanded in a non-system header\n+   location.  */\n+#include \"syshdr3.h\"\n+\n+static _Complex float c = _Complex_I + _Complex_I; /* These macros are defined in\n+\t\t\t\t\t\t    system header so we should\n+\t\t\t\t\t\t    have no warning here.  */\n+U_LL u = ONE_ULL; /* Likewise here.  */\n+\n+unsigned long long v = 1ULL; /* { dg-warning \"long long\" } */"}, {"sha": "e5d502a24f54337471daf6b9f96990203c79012d", "filename": "gcc/testsuite/g++.dg/cpp/syshdr3.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fsyshdr3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fsyshdr3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fsyshdr3.h?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,7 @@\n+#pragma GCC system_header\n+\n+#define _Complex __complex__\n+#define _Complex_I 1.0iF\n+\n+#define U_LL unsigned long long\n+#define ONE_ULL 1ULL"}, {"sha": "7ef26f7f011ac5fecde514bab198f890fe08c1dd", "filename": "gcc/testsuite/g++.dg/system-binary-constants-1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsystem-binary-constants-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsystem-binary-constants-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsystem-binary-constants-1.C?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,18 @@\n+/* \n+   Origin: Dodji Seketeli <dodji@redhat.com>\n+   { dg-options \"-std=c++98 -pedantic\" }\n+   { dg-do compile } \n+ */\n+\n+#include \"system-binary-constants-1.h\"\n+\n+int\n+foo (void)\n+{\n+#if BINARY_INT_CONSTANT_IN_SYSTEM_HEADER /* A binary constant defined\n+\t\t\t\t\t    in system header.  No\n+\t\t\t\t\t    warning.  */\n+  return 23;\n+#endif\n+  return 0b1101; /* { dg-warning \"binary constants are a GCC extension\" } */\n+}"}, {"sha": "85f291742ffc5190a480446648527e6bf45813d8", "filename": "gcc/testsuite/g++.dg/system-binary-constants-1.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsystem-binary-constants-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsystem-binary-constants-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fsystem-binary-constants-1.h?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,3 @@\n+#pragma GCC system_header\n+\n+#define BINARY_INT_CONSTANT_IN_SYSTEM_HEADER 0b1101"}, {"sha": "6c3928aa2a08a6511b308dcc43c1c8a8d3e834ab", "filename": "gcc/testsuite/gcc.dg/binary-constants-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-2.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -2,7 +2,7 @@\n \n /* Origin: Joerg Wunsch <j.gnu@uriah.heep.sax.de>.  */\n /* { dg-do compile } */\n-/* { dg-options \"-std=iso9899:1999 -pedantic\" } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic -ftrack-macro-expansion=0\" } */\n \n #define FOO 0b1101\n "}, {"sha": "410fc4cd7256f7c0dbce0dabc2b39150b899a4e5", "filename": "gcc/testsuite/gcc.dg/binary-constants-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbinary-constants-3.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -2,7 +2,7 @@\n \n /* Origin: Joerg Wunsch <j.gnu@uriah.heep.sax.de>.  */\n /* { dg-do compile } */\n-/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors -ftrack-macro-expansion=0\" } */\n \n #define FOO 0b1101\n "}, {"sha": "225b659754c2f7a5581ce1f8893182f209bd87f5", "filename": "gcc/testsuite/gcc.dg/cpp/pr7263-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr7263-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr7263-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr7263-3.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,6 +1,6 @@\n /* PR 7263:  __extension__ keyword doesn't suppress warning on LL or ULL constants.  */\n /* { dg-do compile } */\n-/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+/* { dg-options \"-std=c99 -pedantic-errors -ftrack-macro-expansion=0\" } */\n #include \"pr7263-3.h\"\n __complex__  bar () /* { dg-error \"ISO C does not support plain .complex. meaning .double complex.\" } */\n {"}, {"sha": "15749ff9961ec3ef7a2d44714cc674361b798581", "filename": "gcc/testsuite/gcc.dg/cpp/syshdr3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsyshdr3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsyshdr3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsyshdr3.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,16 @@\n+/* Contributed by Dodji Seketeli <dodji@redhat.com> */\n+/* Origin: PR preprocessor/7263 */\n+/* { dg-options \"-pedantic -std=c89 -ftrack-macro-expansion=1\" } */\n+/* { dg-do compile } */\n+\n+/* This tests the proprer suppression of warning coming from macro\n+   defined in system headers and expanded in a non-system header\n+   location.  */\n+#include \"syshdr3.h\"\n+\n+static _Complex float c = _Complex_I + _Complex_I; /* These macros are defined in\n+\t\t\t\t\t\t    system header so we should\n+\t\t\t\t\t\t    have no warning here.  */\n+U_LL u = ONE_ULL; /* Likewise here.  */\n+\n+unsigned long long v = 1ULL; /* { dg-warning \"long long\" } */"}, {"sha": "e5d502a24f54337471daf6b9f96990203c79012d", "filename": "gcc/testsuite/gcc.dg/cpp/syshdr3.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsyshdr3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsyshdr3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsyshdr3.h?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,7 @@\n+#pragma GCC system_header\n+\n+#define _Complex __complex__\n+#define _Complex_I 1.0iF\n+\n+#define U_LL unsigned long long\n+#define ONE_ULL 1ULL"}, {"sha": "cc8469e18c71dc722e12d61b85185a0fb0c1b097", "filename": "gcc/testsuite/gcc.dg/cpp/sysmac1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac1.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,7 +1,7 @@\n /* Copyright (C) 2001 Free Software Foundation, Inc.  */\n \n /* { dg-do preprocess } */\n-/* { dg-options \"-std=gnu99 -pedantic -Wtraditional\" } */\n+/* { dg-options \"-std=gnu99 -pedantic -Wtraditional -ftrack-macro-expansion=0\" } */\n \n /* Tests diagnostics are suppressed for some macros defined in system\n    headers.  */"}, {"sha": "cdba668a03fc99d1dcf758630319b61ad4943fbb", "filename": "gcc/testsuite/gcc.dg/cpp/sysmac2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac2.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,7 +1,7 @@\n /* Copyright (C) 2001 Free Software Foundation, Inc.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-std=gnu99 -pedantic -Wtraditional\" } */\n+/* { dg-options \"-std=gnu99 -pedantic -Wtraditional -ftrack-macro-expansion=0\" } */\n \n /* Tests diagnostics are suppressed for some macros defined in system\n    headers.  */"}, {"sha": "8442a1984cfa48d1c8b937faa67d2e3673059097", "filename": "gcc/testsuite/gcc.dg/nofixed-point-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fnofixed-point-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fnofixed-point-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnofixed-point-2.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -20,10 +20,10 @@ f3 (void)\n   return 0k;\t\t\t/* { dg-error \"not supported\" \"reject fixed-point\" } */\n }\n \n-_Sat\n-f4 (void)\t\t\t/* { dg-error \"not supported\" \"reject fixed-point\" } */\n+_Sat                            /* { dg-error \"not supported\" \"reject fixed-point\" } */\n+f4 (void)\n {\n   return 0k;\t\t\t/* { dg-error \"not supported\" \"reject fixed-point\" } */\n }\n \n-/* { dg-error \"is used without\" \"\" { target *-*-* } 24 } */\n+/* { dg-error \"is used without\" \"\" { target *-*-* } 23 } */"}, {"sha": "921ee20863576b6af7645c3452d3a87a6d2c3c78", "filename": "gcc/testsuite/gcc.dg/system-binary-constants-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fsystem-binary-constants-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fsystem-binary-constants-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsystem-binary-constants-1.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,18 @@\n+/* \n+   Origin: Dodji Seketeli <dodji@redhat.com>\n+   { dg-options \"-std=iso9899:1999 -pedantic\" } \n+   { dg-do compile } \n+ */\n+\n+#include \"system-binary-constants-1.h\"\n+\n+int\n+foo (void)\n+{\n+#if BINARY_INT_CONSTANT_IN_SYSTEM_HEADER /* A binary constant defined\n+\t\t\t\t\t    in system header.  No\n+\t\t\t\t\t    warning.  */\n+  return 23;\n+#endif\n+  return 0b1101; /* { dg-warning \"binary constants are a GCC extension\" } */\n+}"}, {"sha": "85f291742ffc5190a480446648527e6bf45813d8", "filename": "gcc/testsuite/gcc.dg/system-binary-constants-1.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fsystem-binary-constants-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/gcc%2Ftestsuite%2Fgcc.dg%2Fsystem-binary-constants-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsystem-binary-constants-1.h?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -0,0 +1,3 @@\n+#pragma GCC system_header\n+\n+#define BINARY_INT_CONSTANT_IN_SYSTEM_HEADER 0b1101"}, {"sha": "842f834aff17b55a8e11f3b2cc84bd0832b0a5a6", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -1,3 +1,18 @@\n+2012-05-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR preprocessor/7263\n+\t* include/cpplib.h (cpp_classify_number): Take a location\n+\tparameter.\n+\t* expr.c (SYNTAX_ERROR_AT, SYNTAX_ERROR2_AT): New diagnostic\n+\tmacros that take a location parameter.\n+\t(cpp_classify_number): Take a (virtual) location parameter.  Use\n+\tit for diagnostics.  Adjust comments.\n+\t(eval_token): Take a location parameter.  Pass it to\n+\tcpp_classify_number and to diagnostic routines.\n+\t(_cpp_parse_expr): Use virtual locations of tokens when parsing\n+\texpressions.  Pass a virtual location to eval_token and to\n+\tdiagnostic routines.\n+\n 2012-05-10  Tristan Gingold  <gingold@adacore.com>\n \n \t* expr.c (interpret_float_suffix): Add a guard."}, {"sha": "cd6e7d4eca67bb82db22b76e815a74078a6e01bb", "filename": "libcpp/expr.c", "status": "modified", "additions": 108, "deletions": 74, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -59,7 +59,7 @@ static cpp_num num_rshift (cpp_num, size_t, size_t);\n \n static cpp_num append_digit (cpp_num, int, int, size_t);\n static cpp_num parse_defined (cpp_reader *);\n-static cpp_num eval_token (cpp_reader *, const cpp_token *);\n+static cpp_num eval_token (cpp_reader *, const cpp_token *, source_location);\n static struct op *reduce (cpp_reader *, struct op *, enum cpp_ttype);\n static unsigned int interpret_float_suffix (const uchar *, size_t);\n static unsigned int interpret_int_suffix (const uchar *, size_t);\n@@ -76,6 +76,12 @@ static void check_promotion (cpp_reader *, const struct op *);\n #define SYNTAX_ERROR2(msgid, arg) \\\n   do { cpp_error (pfile, CPP_DL_ERROR, msgid, arg); goto syntax_error; } \\\n   while(0)\n+#define SYNTAX_ERROR_AT(loc, msgid) \\\n+  do { cpp_error_with_line (pfile, CPP_DL_ERROR, (loc), 0, msgid); goto syntax_error; } \\\n+  while(0)\n+#define SYNTAX_ERROR2_AT(loc, msgid, arg)\t\t\t\t\t\\\n+  do { cpp_error_with_line (pfile, CPP_DL_ERROR, (loc), 0, msgid, arg); goto syntax_error; } \\\n+  while(0)\n \n /* Subroutine of cpp_classify_number.  S points to a float suffix of\n    length LEN, possibly zero.  Returns 0 for an invalid suffix, or a\n@@ -359,11 +365,18 @@ cpp_get_userdef_suffix (const cpp_token *tok)\n \n /* Categorize numeric constants according to their field (integer,\n    floating point, or invalid), radix (decimal, octal, hexadecimal),\n-   and type suffixes.  In C++0X if UD_SUFFIX is non null it will be\n-   assigned any unrecognized suffix for a user-defined literal.  */\n+   and type suffixes.\n+\n+   TOKEN is the token that represents the numeric constant to\n+   classify.\n+\n+   In C++0X if UD_SUFFIX is non null it will be assigned\n+   any unrecognized suffix for a user-defined literal.\n+\n+   VIRTUAL_LOCATION is the virtual location for TOKEN.  */\n unsigned int\n cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n-\t\t     const char **ud_suffix)\n+\t\t     const char **ud_suffix, source_location virtual_location)\n {\n   const uchar *str = token->val.str.text;\n   const uchar *limit;\n@@ -422,7 +435,8 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n \t  if (float_flag == NOT_FLOAT)\n \t    float_flag = AFTER_POINT;\n \t  else\n-\t    SYNTAX_ERROR (\"too many decimal points in number\");\n+\t    SYNTAX_ERROR_AT (virtual_location,\n+\t\t\t     \"too many decimal points in number\");\n \t}\n       else if ((radix <= 10 && (c == 'e' || c == 'E'))\n \t       || (radix == 16 && (c == 'p' || c == 'P')))\n@@ -450,8 +464,8 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n \t    radix = 10;\n \n \t  if (CPP_PEDANTIC (pfile))\n-\t    cpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t       \"fixed-point constants are a GCC extension\");\n+\t    cpp_error_with_line (pfile, CPP_DL_PEDWARN, virtual_location, 0,\n+\t\t\t\t \"fixed-point constants are a GCC extension\");\n \t  goto syntax_ok;\n \t}\n       else\n@@ -464,26 +478,29 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n   if (max_digit >= radix)\n     {\n       if (radix == 2)\n-\tSYNTAX_ERROR2 (\"invalid digit \\\"%c\\\" in binary constant\", '0' + max_digit);\n+\tSYNTAX_ERROR2_AT (virtual_location,\n+\t\t\t  \"invalid digit \\\"%c\\\" in binary constant\", '0' + max_digit);\n       else\n-\tSYNTAX_ERROR2 (\"invalid digit \\\"%c\\\" in octal constant\", '0' + max_digit);\n+\tSYNTAX_ERROR2_AT (virtual_location,\n+\t\t\t  \"invalid digit \\\"%c\\\" in octal constant\", '0' + max_digit);\n     }\n \n   if (float_flag != NOT_FLOAT)\n     {\n       if (radix == 2)\n \t{\n-\t  cpp_error (pfile, CPP_DL_ERROR,\n-\t\t     \"invalid prefix \\\"0b\\\" for floating constant\");\n+\t  cpp_error_with_line (pfile, CPP_DL_ERROR, virtual_location, 0,\n+\t\t\t       \"invalid prefix \\\"0b\\\" for floating constant\");\n \t  return CPP_N_INVALID;\n \t}\n \n       if (radix == 16 && !seen_digit)\n-\tSYNTAX_ERROR (\"no digits in hexadecimal floating constant\");\n+\tSYNTAX_ERROR_AT (virtual_location,\n+\t\t\t \"no digits in hexadecimal floating constant\");\n \n       if (radix == 16 && CPP_PEDANTIC (pfile) && !CPP_OPTION (pfile, c99))\n-\tcpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t   \"use of C99 hexadecimal floating constant\");\n+\tcpp_error_with_line (pfile, CPP_DL_PEDWARN, virtual_location, 0,\n+\t\t\t     \"use of C99 hexadecimal floating constant\");\n \n       if (float_flag == AFTER_EXPON)\n \t{\n@@ -492,14 +509,15 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n \n \t  /* Exponent is decimal, even if string is a hex float.  */\n \t  if (!ISDIGIT (*str))\n-\t    SYNTAX_ERROR (\"exponent has no digits\");\n+\t    SYNTAX_ERROR_AT (virtual_location, \"exponent has no digits\");\n \n \t  do\n \t    str++;\n \t  while (ISDIGIT (*str));\n \t}\n       else if (radix == 16)\n-\tSYNTAX_ERROR (\"hexadecimal floating constants require an exponent\");\n+\tSYNTAX_ERROR_AT (virtual_location,\n+\t\t\t \"hexadecimal floating constants require an exponent\");\n \n       result = interpret_float_suffix (str, limit - str);\n       if (result == 0)\n@@ -512,9 +530,9 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n \t    }\n \t  else\n \t    {\n-\t      cpp_error (pfile, CPP_DL_ERROR,\n-\t\t\t \"invalid suffix \\\"%.*s\\\" on floating constant\",\n-\t\t\t (int) (limit - str), str);\n+\t      cpp_error_with_line (pfile, CPP_DL_ERROR, virtual_location, 0,\n+\t\t\t\t   \"invalid suffix \\\"%.*s\\\" on floating constant\",\n+\t\t\t\t   (int) (limit - str), str);\n \t      return CPP_N_INVALID;\n \t    }\n \t}\n@@ -523,33 +541,33 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n       if (limit != str\n \t  && CPP_WTRADITIONAL (pfile)\n \t  && ! cpp_sys_macro_p (pfile))\n-\tcpp_warning (pfile, CPP_W_TRADITIONAL,\n-\t\t     \"traditional C rejects the \\\"%.*s\\\" suffix\",\n-\t\t     (int) (limit - str), str);\n+\tcpp_warning_with_line (pfile, CPP_W_TRADITIONAL, virtual_location, 0,\n+\t\t\t       \"traditional C rejects the \\\"%.*s\\\" suffix\",\n+\t\t\t       (int) (limit - str), str);\n \n       /* A suffix for double is a GCC extension via decimal float support.\n \t If the suffix also specifies an imaginary value we'll catch that\n \t later.  */\n       if ((result == CPP_N_MEDIUM) && CPP_PEDANTIC (pfile))\n-\tcpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t   \"suffix for double constant is a GCC extension\");\n+\tcpp_error_with_line (pfile, CPP_DL_PEDWARN, virtual_location, 0,\n+\t\t\t     \"suffix for double constant is a GCC extension\");\n \n       /* Radix must be 10 for decimal floats.  */\n       if ((result & CPP_N_DFLOAT) && radix != 10)\n         {\n-          cpp_error (pfile, CPP_DL_ERROR,\n-                     \"invalid suffix \\\"%.*s\\\" with hexadecimal floating constant\",\n-                     (int) (limit - str), str);\n+          cpp_error_with_line (pfile, CPP_DL_ERROR, virtual_location, 0,\n+\t\t\t       \"invalid suffix \\\"%.*s\\\" with hexadecimal floating constant\",\n+\t\t\t       (int) (limit - str), str);\n           return CPP_N_INVALID;\n         }\n \n       if ((result & (CPP_N_FRACT | CPP_N_ACCUM)) && CPP_PEDANTIC (pfile))\n-\tcpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t   \"fixed-point constants are a GCC extension\");\n+\tcpp_error_with_line (pfile, CPP_DL_PEDWARN, virtual_location, 0,\n+\t\t\t     \"fixed-point constants are a GCC extension\");\n \n       if ((result & CPP_N_DFLOAT) && CPP_PEDANTIC (pfile))\n-\tcpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t   \"decimal float constants are a GCC extension\");\n+\tcpp_error_with_line (pfile, CPP_DL_PEDWARN, virtual_location, 0,\n+\t\t\t     \"decimal float constants are a GCC extension\");\n \n       result |= CPP_N_FLOATING;\n     }\n@@ -566,9 +584,9 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n \t    }\n \t  else\n \t    {\n-\t      cpp_error (pfile, CPP_DL_ERROR,\n-\t\t\t \"invalid suffix \\\"%.*s\\\" on integer constant\",\n-\t\t\t (int) (limit - str), str);\n+\t      cpp_error_with_line (pfile, CPP_DL_ERROR, virtual_location, 0,\n+\t\t\t\t   \"invalid suffix \\\"%.*s\\\" on integer constant\",\n+\t\t\t\t   (int) (limit - str), str);\n \t      return CPP_N_INVALID;\n \t    }\n \t}\n@@ -582,9 +600,10 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n \t\t       && CPP_OPTION (pfile, cpp_warn_long_long);\n \n \t  if (u_or_i || large)\n-\t    cpp_warning (pfile, large ? CPP_W_LONG_LONG : CPP_W_TRADITIONAL,\n-\t\t         \"traditional C rejects the \\\"%.*s\\\" suffix\",\n-\t\t         (int) (limit - str), str);\n+\t    cpp_warning_with_line (pfile, large ? CPP_W_LONG_LONG : CPP_W_TRADITIONAL,\n+\t\t\t\t   virtual_location, 0,\n+\t\t\t\t   \"traditional C rejects the \\\"%.*s\\\" suffix\",\n+\t\t\t\t   (int) (limit - str), str);\n \t}\n \n       if ((result & CPP_N_WIDTH) == CPP_N_LARGE\n@@ -595,21 +614,23 @@ cpp_classify_number (cpp_reader *pfile, const cpp_token *token,\n \t\t                : N_(\"use of C99 long long integer constant\");\n \n \t  if (CPP_OPTION (pfile, c99))\n-            cpp_warning (pfile, CPP_W_LONG_LONG, message);\n+            cpp_warning_with_line (pfile, CPP_W_LONG_LONG, virtual_location,\n+\t\t\t\t   0, message);\n           else\n-            cpp_pedwarning (pfile, CPP_W_LONG_LONG, message);\n+            cpp_pedwarning_with_line (pfile, CPP_W_LONG_LONG,\n+\t\t\t\t      virtual_location, 0, message);\n         }\n \n       result |= CPP_N_INTEGER;\n     }\n \n  syntax_ok:\n   if ((result & CPP_N_IMAGINARY) && CPP_PEDANTIC (pfile))\n-    cpp_error (pfile, CPP_DL_PEDWARN,\n-\t       \"imaginary constants are a GCC extension\");\n+    cpp_error_with_line (pfile, CPP_DL_PEDWARN, virtual_location, 0,\n+\t\t\t \"imaginary constants are a GCC extension\");\n   if (radix == 2 && CPP_PEDANTIC (pfile))\n-    cpp_error (pfile, CPP_DL_PEDWARN,\n-\t       \"binary constants are a GCC extension\");\n+    cpp_error_with_line (pfile, CPP_DL_PEDWARN, virtual_location, 0,\n+\t\t\t \"binary constants are a GCC extension\");\n \n   if (radix == 10)\n     result |= CPP_N_DECIMAL;\n@@ -897,7 +918,8 @@ parse_defined (cpp_reader *pfile)\n    number or character constant, or the result of the \"defined\" or \"#\"\n    operators).  */\n static cpp_num\n-eval_token (cpp_reader *pfile, const cpp_token *token)\n+eval_token (cpp_reader *pfile, const cpp_token *token,\n+\t    source_location virtual_location)\n {\n   cpp_num result;\n   unsigned int temp;\n@@ -909,21 +931,21 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n   switch (token->type)\n     {\n     case CPP_NUMBER:\n-      temp = cpp_classify_number (pfile, token, NULL);\n+      temp = cpp_classify_number (pfile, token, NULL, virtual_location);\n       if (temp & CPP_N_USERDEF)\n \tcpp_error (pfile, CPP_DL_ERROR,\n \t\t   \"user-defined literal in preprocessor expression\");\n       switch (temp & CPP_N_CATEGORY)\n \t{\n \tcase CPP_N_FLOATING:\n-\t  cpp_error (pfile, CPP_DL_ERROR,\n-\t\t     \"floating constant in preprocessor expression\");\n+\t  cpp_error_with_line (pfile, CPP_DL_ERROR, virtual_location, 0,\n+\t\t\t       \"floating constant in preprocessor expression\");\n \t  break;\n \tcase CPP_N_INTEGER:\n \t  if (!(temp & CPP_N_IMAGINARY))\n \t    return cpp_interpret_integer (pfile, token, temp);\n-\t  cpp_error (pfile, CPP_DL_ERROR,\n-\t\t     \"imaginary number in preprocessor expression\");\n+\t  cpp_error_with_line (pfile, CPP_DL_ERROR, virtual_location, 0,\n+\t\t\t       \"imaginary number in preprocessor expression\");\n \t  break;\n \n \tcase CPP_N_INVALID:\n@@ -970,8 +992,9 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n \t  result.high = 0;\n \t  result.low = 0;\n \t  if (CPP_OPTION (pfile, warn_undef) && !pfile->state.skip_eval)\n-\t    cpp_warning (pfile, CPP_W_UNDEF, \"\\\"%s\\\" is not defined\",\n-\t\t         NODE_NAME (token->val.node.node));\n+\t    cpp_warning_with_line (pfile, CPP_W_UNDEF, virtual_location, 0,\n+\t\t\t\t   \"\\\"%s\\\" is not defined\",\n+\t\t\t\t   NODE_NAME (token->val.node.node));\n \t}\n       break;\n \n@@ -981,11 +1004,12 @@ eval_token (cpp_reader *pfile, const cpp_token *token)\n \t  /* A pedantic warning takes precedence over a deprecated\n \t     warning here.  */\n \t  if (CPP_PEDANTIC (pfile))\n-\t    cpp_error (pfile, CPP_DL_PEDWARN,\n-\t\t       \"assertions are a GCC extension\");\n+\t    cpp_error_with_line (pfile, CPP_DL_PEDWARN,\n+\t\t\t\t virtual_location, 0,\n+\t\t\t\t \"assertions are a GCC extension\");\n \t  else if (CPP_OPTION (pfile, cpp_warn_deprecated))\n-\t    cpp_warning (pfile, CPP_W_DEPRECATED,\n-\t\t         \"assertions are a deprecated extension\");\n+\t    cpp_warning_with_line (pfile, CPP_W_DEPRECATED, virtual_location, 0,\n+\t\t\t\t   \"assertions are a deprecated extension\");\n \t}\n       _cpp_test_assertion (pfile, &temp);\n       result.high = 0;\n@@ -1087,6 +1111,7 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n   struct op *top = pfile->op_stack;\n   unsigned int lex_count;\n   bool saw_leading_not, want_value = true;\n+  source_location virtual_location = 0;\n \n   pfile->state.skip_eval = 0;\n \n@@ -1103,9 +1128,9 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n       struct op op;\n \n       lex_count++;\n-      op.token = cpp_get_token (pfile);\n+      op.token = cpp_get_token_with_location (pfile, &virtual_location);\n       op.op = op.token->type;\n-      op.loc = op.token->src_loc;\n+      op.loc = virtual_location;\n \n       switch (op.op)\n \t{\n@@ -1118,10 +1143,11 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n \tcase CPP_NAME:\n \tcase CPP_HASH:\n \t  if (!want_value)\n-\t    SYNTAX_ERROR2 (\"missing binary operator before token \\\"%s\\\"\",\n-\t\t\t   cpp_token_as_text (pfile, op.token));\n+\t    SYNTAX_ERROR2_AT (op.loc,\n+\t\t\t      \"missing binary operator before token \\\"%s\\\"\",\n+\t\t\t      cpp_token_as_text (pfile, op.token));\n \t  want_value = false;\n-\t  top->value = eval_token (pfile, op.token);\n+\t  top->value = eval_token (pfile, op.token, op.loc);\n \t  continue;\n \n \tcase CPP_NOT:\n@@ -1138,36 +1164,42 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n \n \tdefault:\n \t  if ((int) op.op <= (int) CPP_EQ || (int) op.op >= (int) CPP_PLUS_EQ)\n-\t    SYNTAX_ERROR2 (\"token \\\"%s\\\" is not valid in preprocessor expressions\",\n-\t\t\t   cpp_token_as_text (pfile, op.token));\n+\t    SYNTAX_ERROR2_AT (op.loc,\n+\t\t\t      \"token \\\"%s\\\" is not valid in preprocessor expressions\",\n+\t\t\t      cpp_token_as_text (pfile, op.token));\n \t  break;\n \t}\n \n       /* Check we have a value or operator as appropriate.  */\n       if (optab[op.op].flags & NO_L_OPERAND)\n \t{\n \t  if (!want_value)\n-\t    SYNTAX_ERROR2 (\"missing binary operator before token \\\"%s\\\"\",\n-\t\t\t   cpp_token_as_text (pfile, op.token));\n+\t    SYNTAX_ERROR2_AT (op.loc,\n+\t\t\t      \"missing binary operator before token \\\"%s\\\"\",\n+\t\t\t      cpp_token_as_text (pfile, op.token));\n \t}\n       else if (want_value)\n \t{\n \t  /* We want a number (or expression) and haven't got one.\n \t     Try to emit a specific diagnostic.  */\n \t  if (op.op == CPP_CLOSE_PAREN && top->op == CPP_OPEN_PAREN)\n-\t    SYNTAX_ERROR (\"missing expression between '(' and ')'\");\n+\t    SYNTAX_ERROR_AT (op.loc,\n+\t\t\t     \"missing expression between '(' and ')'\");\n \n \t  if (op.op == CPP_EOF && top->op == CPP_EOF)\n- \t    SYNTAX_ERROR2 (\"%s with no expression\", is_if ? \"#if\" : \"#elif\");\n+ \t    SYNTAX_ERROR2_AT (op.loc,\n+\t\t\t      \"%s with no expression\", is_if ? \"#if\" : \"#elif\");\n \n  \t  if (top->op != CPP_EOF && top->op != CPP_OPEN_PAREN)\n- \t    SYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n- \t\t\t   cpp_token_as_text (pfile, top->token));\n+ \t    SYNTAX_ERROR2_AT (op.loc,\n+\t\t\t      \"operator '%s' has no right operand\",\n+\t\t\t      cpp_token_as_text (pfile, top->token));\n \t  else if (op.op == CPP_CLOSE_PAREN || op.op == CPP_EOF)\n \t    /* Complain about missing paren during reduction.  */;\n \t  else\n-\t    SYNTAX_ERROR2 (\"operator '%s' has no left operand\",\n-\t\t\t   cpp_token_as_text (pfile, op.token));\n+\t    SYNTAX_ERROR2_AT (op.loc,\n+\t\t\t      \"operator '%s' has no left operand\",\n+\t\t\t      cpp_token_as_text (pfile, op.token));\n \t}\n \n       top = reduce (pfile, top, op.op);\n@@ -1192,7 +1224,8 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n \t  break;\n \tcase CPP_COLON:\n \t  if (top->op != CPP_QUERY)\n-\t    SYNTAX_ERROR (\" ':' without preceding '?'\");\n+\t    SYNTAX_ERROR_AT (op.loc,\n+\t\t\t     \" ':' without preceding '?'\");\n \t  if (!num_zerop (top[-1].value)) /* Was '?' condition true?  */\n \t    pfile->state.skip_eval++;\n \t  else\n@@ -1209,7 +1242,7 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n \n       top->op = op.op;\n       top->token = op.token;\n-      top->loc = op.token->src_loc;\n+      top->loc = op.loc;\n     }\n \n   /* The controlling macro expression is only valid if we called lex 3\n@@ -1220,8 +1253,9 @@ _cpp_parse_expr (cpp_reader *pfile, bool is_if)\n \n   if (top != pfile->op_stack)\n     {\n-      cpp_error (pfile, CPP_DL_ICE, \"unbalanced stack in %s\",\n-\t\t is_if ? \"#if\" : \"#elif\");\n+      cpp_error_with_line (pfile, CPP_DL_ICE, top->loc, 0,\n+\t\t\t   \"unbalanced stack in %s\",\n+\t\t\t   is_if ? \"#if\" : \"#elif\");\n     syntax_error:\n       return false;  /* Return false on syntax error.  */\n     }"}, {"sha": "2ec7eaaae2f95b8a8379134421e67c5a7bf2de45", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b2c4be5fdff70f1babd503c9f6dbabd664c44c7/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=0b2c4be5fdff70f1babd503c9f6dbabd664c44c7", "patch": "@@ -851,7 +851,7 @@ struct cpp_num\n /* Classify a CPP_NUMBER token.  The return value is a combination of\n    the flags from the above sets.  */\n extern unsigned cpp_classify_number (cpp_reader *, const cpp_token *,\n-\t\t\t\t     const char **);\n+\t\t\t\t     const char **, source_location);\n \n /* Return the classification flags for a float suffix.  */\n extern unsigned int cpp_interpret_float_suffix (const char *, size_t);"}]}