{"sha": "77dbdb5745d52b1ff3ddede885706d77a3817dd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdkYmRiNTc0NWQ1MmIxZmYzZGRlZGU4ODU3MDZkNzdhMzgxN2RkNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-03-09T23:39:16Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-03-09T23:39:16Z"}, "message": "* c-decl.c (last_function_parms, last_function_parm_tags)\n\t(last_function_parm_others, current_function_parms)\n\t(current_function_parm_tags, current_function_parm_others):\n\tDelete.\n\t(ARG_INFO_PARMS, ARG_INFO_TAGS, ARG_INFO_TYPES, ARG_INFO_OTHERS):\n\tNew macros.\n\t(grokdeclarator): For function definitions, save the arg-info\n\tblock from the declarator in DECL_ARGUMENTS.\n\t(grokparms): Do not write to last_function_parm*.  Use ARG_INFO_*\n\tmacros to operate on arg-info block.  Can assume ARG_INFO_PARMS\n\tcontains only PARM_DECLs.  Improve diagnostics.\n\t(get_parm_info): Use ARG_INFO_* macros.  Improve comments and\n\tdiagnostics.  Disable some expensive checks if not ENABLE_CHECKING.\n\t(store_parm_decls_newstyle): Take the function to operate on,\n\tand an arg-info block, as arguments; don't get anything from\n\tcurrent_function_* globals.\n\t(store_parm_decls_oldstyle): Likewise.\n\t(store_parm_decls): Pass fndecl and its arg-info block down to\n\tstore_parm_decls_newstyle/oldstyle.  Send functions with empty\n\targument lists through store_parm_decls_newstyle to reduce\n\toverhead.\n\t(pushdecl): Comment on the problems with the call to copy_node.\n\tClear DECL_ARGUMENTS of the old node after copying it, if it\n\tis an arg-info block instead of a chain of decls.\n\t(start_function): Do not manipulate current_function_parm* or\n\tlast_function_parm*.\n\n\t* testsuite/gcc.dg/noncompile/incomplete-2.c: Move dg-error to\n\tproper line.\n\nFrom-SVN: r79206", "tree": {"sha": "0c69b5e19f8954ba545d24fb4b1c73984cd752bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c69b5e19f8954ba545d24fb4b1c73984cd752bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77dbdb5745d52b1ff3ddede885706d77a3817dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77dbdb5745d52b1ff3ddede885706d77a3817dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77dbdb5745d52b1ff3ddede885706d77a3817dd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77dbdb5745d52b1ff3ddede885706d77a3817dd7/comments", "author": null, "committer": null, "parents": [{"sha": "305eeaeb7a5acd2256d075f463fe32fe80781e85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305eeaeb7a5acd2256d075f463fe32fe80781e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305eeaeb7a5acd2256d075f463fe32fe80781e85"}], "stats": {"total": 308, "additions": 176, "deletions": 132}, "files": [{"sha": "9a4f62c616ed43b18101512dfdafb667e21f599a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77dbdb5745d52b1ff3ddede885706d77a3817dd7", "patch": "@@ -1,3 +1,32 @@\n+2004-03-09  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (last_function_parms, last_function_parm_tags)\n+\t(last_function_parm_others, current_function_parms)\n+\t(current_function_parm_tags, current_function_parm_others):\n+\tDelete.\n+\t(ARG_INFO_PARMS, ARG_INFO_TAGS, ARG_INFO_TYPES, ARG_INFO_OTHERS):\n+\tNew macros.\n+\t(grokdeclarator): For function definitions, save the arg-info\n+\tblock from the declarator in DECL_ARGUMENTS.\n+\t(grokparms): Do not write to last_function_parm*.  Use ARG_INFO_*\n+\tmacros to operate on arg-info block.  Can assume ARG_INFO_PARMS\n+\tcontains only PARM_DECLs.  Improve diagnostics.\n+\t(get_parm_info): Use ARG_INFO_* macros.  Improve comments and\n+\tdiagnostics.  Disable some expensive checks if not ENABLE_CHECKING.\n+\t(store_parm_decls_newstyle): Take the function to operate on,\n+\tand an arg-info block, as arguments; don't get anything from\n+\tcurrent_function_* globals.\n+\t(store_parm_decls_oldstyle): Likewise.\n+\t(store_parm_decls): Pass fndecl and its arg-info block down to\n+\tstore_parm_decls_newstyle/oldstyle.  Send functions with empty\n+\targument lists through store_parm_decls_newstyle to reduce\n+\toverhead.\n+\t(pushdecl): Comment on the problems with the call to copy_node.\n+\tClear DECL_ARGUMENTS of the old node after copying it, if it\n+\tis an arg-info block instead of a chain of decls.\n+\t(start_function): Do not manipulate current_function_parm* or\n+\tlast_function_parm*.\n+\n 2004-03-09  Roger Sayle  <roger@eyesopen.com>\n \t    Andrew Pinski  <pinskia@physics.uc.edu>\n \n@@ -93,9 +122,9 @@\n \n 2004-03-07  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.md (ashrdi3): Do not call ashrdi3_no_power\n-        for little endian.\n-        (\"ashrdi3_no_power\"): Disable for little endian.\n+\t* config/rs6000/rs6000.md (ashrdi3): Do not call ashrdi3_no_power\n+\tfor little endian.\n+\t(\"ashrdi3_no_power\"): Disable for little endian.\n \t(ashrdi3): Same.\n \n 2004-03-07  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>"}, {"sha": "c296bb9c8af1df44998b99667985fb186e65ccac", "filename": "gcc/c-decl.c", "status": "modified", "additions": 137, "deletions": 126, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=77dbdb5745d52b1ff3ddede885706d77a3817dd7", "patch": "@@ -83,37 +83,16 @@ static tree enum_next_value;\n \n static int enum_overflow;\n \n-/* Parsing a function declarator leaves a list of parameter names\n-   or a chain of parameter decls here.  */\n+/* These #defines are for clarity in working with the information block\n+   returned by get_parm_info.  */\n+#define ARG_INFO_PARMS(args)  TREE_PURPOSE(args)\n+#define ARG_INFO_TAGS(args)   TREE_VALUE(args)\n+#define ARG_INFO_TYPES(args)  TREE_CHAIN(args)\n+#define ARG_INFO_OTHERS(args) TREE_TYPE(args)\n \n-static tree last_function_parms;\n-\n-/* ... and a chain of structure and enum types declared in the\n-   parmlist here.  */\n-\n-static tree last_function_parm_tags;\n-\n-/* ... and a chain of all non-parameter declarations (such as\n-   CONST_DECLs from enumerations) here.  */\n-\n-static tree last_function_parm_others;\n-\n-/* After parsing the declarator that starts a function definition,\n-   `start_function' puts the list of parameter names or chain of decls here\n-   for `store_parm_decls' to find.  */\n-\n-static tree current_function_parms;\n-\n-/* Similar, for last_function_parm_tags.  */\n-\n-static tree current_function_parm_tags;\n-\n-/* And for last_function_parm_others.  */\n-\n-static tree current_function_parm_others;\n-\n-/* Similar, for the file and line that the prototype came from if this is\n-   an old-style definition.  */\n+/* The file and line that the prototype came from if this is an\n+   old-style definition; used for diagnostics in\n+   store_parm_decls_oldstyle.  */\n \n static location_t current_function_prototype_locus;\n \n@@ -314,8 +293,6 @@ static tree lookup_name_current_level (tree);\n static tree grokdeclarator (tree, tree, enum decl_context, int, tree *);\n static tree grokparms (tree, int);\n static void layout_array_type (tree);\n-static void store_parm_decls_newstyle (void);\n-static void store_parm_decls_oldstyle (void);\n static tree c_make_fname_decl (tree, int);\n static void c_expand_body_1 (tree, int);\n static tree any_external_decl (tree);\n@@ -1723,7 +1700,26 @@ pushdecl (tree x)\n \t  if (ext)\n \t    {\n \t      if (duplicate_decls (x, ext))\n-\t\tx = copy_node (ext);\n+\t\t{\n+\t\t  /* XXX This copy_node call violates the basic\n+\t\t     assumption that there is only one DECL for any\n+\t\t     given object.  This causes all sorts of problems\n+\t\t     elsewhere.  To correct it we must stop chaining\n+\t\t     DECLs directly within the scope structure (work\n+\t\t     in progress).  -zw 2004-03-05  */\n+\t\t  x = copy_node (ext);\n+\n+\t\t  /* Kludge around one of the worst consequences of\n+\t\t     the above copy_node call, viz. that the arg_info\n+\t\t     block created by get_parm_info can survive in a\n+\t\t     copied FUNCTION_DECL after store_parm_decls is\n+\t\t     done with it, and confuse the debug info\n+\t\t     generators.  */\n+\t\t  if (TREE_CODE (ext) == FUNCTION_DECL\n+\t\t      && DECL_ARGUMENTS (ext)\n+\t\t      && TREE_CODE (DECL_ARGUMENTS (ext)) == TREE_LIST)\n+\t\t    DECL_ARGUMENTS (ext) = 0;\n+\t\t}\n \t    }\n \t  else\n \t    record_external_decl (x);\n@@ -3273,6 +3269,7 @@ grokdeclarator (tree declarator, tree declspecs,\n   tree returned_attrs = NULL_TREE;\n   bool bitfield = width != NULL;\n   tree element_type;\n+  tree arg_info = NULL_TREE;\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = 1, decl_context = NORMAL;\n@@ -3970,10 +3967,14 @@ grokdeclarator (tree declarator, tree declspecs,\n \t}\n       else if (TREE_CODE (declarator) == CALL_EXPR)\n \t{\n+\t  /* Declaring a function type.  Say it's a definition only\n+\t   for the CALL_EXPR closest to the identifier.  */\n+\t  bool really_funcdef = (funcdef_flag\n+\t\t\t\t && (TREE_CODE (TREE_OPERAND (declarator, 0))\n+\t\t\t\t     == IDENTIFIER_NODE));\n \t  tree arg_types;\n \n-\t  /* Declaring a function type.\n-\t     Make sure we have a valid type for the function to return.  */\n+\t  /* Make sure we have a valid type for the function to return.  */\n \t  if (type == error_mark_node)\n \t    continue;\n \n@@ -3994,13 +3995,9 @@ grokdeclarator (tree declarator, tree declspecs,\n \n \t  /* Construct the function type and go to the next\n \t     inner layer of declarator.  */\n+\t  arg_info = TREE_OPERAND (declarator, 1);\n+\t  arg_types = grokparms (arg_info, really_funcdef);\n \n-\t  arg_types = grokparms (TREE_OPERAND (declarator, 1),\n-\t\t\t\t funcdef_flag\n-\t\t\t\t /* Say it's a definition\n-\t\t\t\t    only for the CALL_EXPR\n-\t\t\t\t    closest to the identifier.  */\n-\t\t\t\t && TREE_CODE (TREE_OPERAND (declarator, 0)) == IDENTIFIER_NODE);\n \t  /* Type qualifiers before the return type of the function\n \t     qualify the return type, not the function type.  */\n \t  if (type_quals)\n@@ -4036,7 +4033,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  {\n \t    tree link;\n \n-\t    for (link = last_function_parm_tags;\n+\t    for (link = ARG_INFO_TAGS (arg_info);\n \t\t link;\n \t\t link = TREE_CHAIN (link))\n \t      TYPE_CONTEXT (TREE_VALUE (link)) = type;\n@@ -4356,6 +4353,12 @@ grokdeclarator (tree declarator, tree declspecs,\n \tTREE_PUBLIC (decl)\n \t  = !(specbits & ((1 << (int) RID_STATIC) | (1 << (int) RID_AUTO)));\n \n+\t/* For a function definition, record the argument information\n+\t   block in DECL_ARGUMENTS where store_parm_decls will look\n+\t   for it.  */\n+\tif (funcdef_flag)\n+\t  DECL_ARGUMENTS (decl) = arg_info;\n+\n \tif (defaulted_int)\n \t  C_FUNCTION_IMPLICIT_INT (decl) = 1;\n \n@@ -4493,85 +4496,87 @@ grokdeclarator (tree declarator, tree declspecs,\n    of calls is different.  The last call to `grokparms' is always the one\n    that contains the formal parameter names of a function definition.\n \n-   Store in `last_function_parms' a chain of the decls of parms.\n-   Also store in `last_function_parm_tags' a chain of the struct, union,\n-   and enum tags declared among the parms.\n-\n    Return a list of arg types to use in the FUNCTION_TYPE for this function.\n \n    FUNCDEF_FLAG is nonzero for a function definition, 0 for\n    a mere declaration.  A nonempty identifier-list gets an error message\n    when FUNCDEF_FLAG is zero.  */\n \n static tree\n-grokparms (tree parms_info, int funcdef_flag)\n+grokparms (tree arg_info, int funcdef_flag)\n {\n-  tree first_parm = TREE_CHAIN (parms_info);\n+  tree arg_types = ARG_INFO_TYPES (arg_info);\n \n-  last_function_parms = TREE_PURPOSE (parms_info);\n-  last_function_parm_tags = TREE_VALUE (parms_info);\n-  last_function_parm_others = TREE_TYPE (parms_info);\n-\n-  if (warn_strict_prototypes && first_parm == 0 && !funcdef_flag\n+  if (warn_strict_prototypes && arg_types == 0 && !funcdef_flag\n       && !in_system_header)\n     warning (\"function declaration isn't a prototype\");\n \n-  if (first_parm != 0\n-      && TREE_CODE (TREE_VALUE (first_parm)) == IDENTIFIER_NODE)\n+  if (arg_types && TREE_CODE (TREE_VALUE (arg_types)) == IDENTIFIER_NODE)\n     {\n       if (! funcdef_flag)\n \tpedwarn (\"parameter names (without types) in function declaration\");\n \n-      last_function_parms = first_parm;\n+      ARG_INFO_PARMS (arg_info) = ARG_INFO_TYPES (arg_info);\n+      ARG_INFO_TYPES (arg_info) = 0;\n       return 0;\n     }\n   else\n     {\n-      tree parm;\n-      tree typelt;\n-      /* If the arg types are incomplete in a declaration,\n-\t they must include undefined tags.\n-\t These tags can never be defined in the scope of the declaration,\n-\t so the types can never be completed,\n-\t and no call can be compiled successfully.  */\n+      tree parm, type, typelt;\n+      unsigned int parmno;\n+\n+      /* If the arg types are incomplete in a declaration, they must\n+\t include undefined tags.  These tags can never be defined in\n+\t the scope of the declaration, so the types can never be\n+\t completed, and no call can be compiled successfully.  */\n \n-      for (parm = last_function_parms, typelt = first_parm;\n+      for (parm = ARG_INFO_PARMS (arg_info), typelt = arg_types, parmno = 1;\n \t   parm;\n-\t   parm = TREE_CHAIN (parm))\n-\t/* Skip over any enumeration constants declared here.  */\n-\tif (TREE_CODE (parm) == PARM_DECL)\n-\t  {\n-\t    /* Barf if the parameter itself has an incomplete type.  */\n-\t    tree type = TREE_VALUE (typelt);\n-\t    if (type == error_mark_node)\n-\t      continue;\n-\t    if (!COMPLETE_TYPE_P (type))\n-\t      {\n-\t\tif (funcdef_flag && DECL_NAME (parm) != 0)\n-\t\t  error (\"parameter `%s' has incomplete type\",\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parm)));\n-\t\telse\n-\t\t  warning (\"parameter has incomplete type\");\n-\t\tif (funcdef_flag)\n-\t\t  {\n-\t\t    TREE_VALUE (typelt) = error_mark_node;\n-\t\t    TREE_TYPE (parm) = error_mark_node;\n-\t\t  }\n-\t      }\n-\t    typelt = TREE_CHAIN (typelt);\n-\t  }\n+\t   parm = TREE_CHAIN (parm), typelt = TREE_CHAIN (typelt), parmno++)\n+\t{\n+\t  type = TREE_VALUE (typelt);\n+\t  if (type == error_mark_node)\n+\t    continue;\n+\n+\t  if (!COMPLETE_TYPE_P (type))\n+\t    {\n+\t      if (funcdef_flag)\n+\t\t{\n+\t\t  if (DECL_NAME (parm))\n+\t\t    error (\"%Jparameter %u ('%D') has incomplete type\",\n+\t\t\t   parm, parmno, parm);\n+\t\t  else\n+\t\t    error (\"%Jparameter %u has incomplete type\",\n+\t\t\t   parm, parmno);\n \n-      return first_parm;\n+\t\t  TREE_VALUE (typelt) = error_mark_node;\n+\t\t  TREE_TYPE (parm) = error_mark_node;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (DECL_NAME (parm))\n+\t\t    warning (\"%Jparameter %u ('%D') has incomplete type\",\n+\t\t\t     parm, parmno, parm);\n+\t\t  else\n+\t\t    warning (\"%Jparameter %u has incomplete type\",\n+\t\t\t     parm, parmno);\n+\t\t}\n+\t    }\n+\t}\n+      return arg_types;\n     }\n }\n \n /* Return a tree_list node with info on a parameter list just parsed.\n-   The TREE_PURPOSE is a list of decls of those parms.\n-   The TREE_VALUE is a list of structure, union and enum tags defined.\n-   The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.\n-   The TREE_TYPE is a list of non-parameter decls which appeared with the\n-   parameters.\n-   This tree_list node is later fed to `grokparms'.\n+   This tree_list node should be examined using the ARG_INFO_* macros,\n+   defined above:\n+     ARG_INFO_PARMS:  a list of parameter decls.\n+     ARG_INFO_TAGS:   a list of structure, union and enum tags defined.\n+     ARG_INFO_TYPES:  a list of argument types to go in the FUNCTION_TYPE.\n+     ARG_INFO_OTHERS: a list of non-parameter decls (notably enumeration\n+\t\t      constants) defined with the parameters.\n+\n+   This tree_list node is later fed to 'grokparms' and 'store_parm_decls'.\n \n    VOID_AT_END nonzero means append `void' to the end of the type-list.\n    Zero means the parmlist ended with an ellipsis so don't append `void'.  */\n@@ -4588,10 +4593,10 @@ get_parm_info (int void_at_end)\n   static bool explained_incomplete_types = false;\n   bool gave_void_only_once_err = false;\n \n-  /* Just \"void\" (and no ellipsis) is special.  There are really no parms.\n-     But if the \"void\" is qualified (by \"const\" or \"volatile\"), or has a\n-     storage class specifier (\"register\"), then the behavior is undefined;\n-     issue an error.  Typedefs for \"void\" are OK (see DR#157).  */\n+  /* Just 'void' (and no ellipsis) is special.  There are really no parms.\n+     But if the 'void' is qualified (by 'const' or 'volatile'), or has a\n+     storage class specifier ('register'), then the behavior is undefined;\n+     issue an error.  Typedefs for 'void' are OK (see DR#157).  */\n   if (void_at_end && parms != 0\n       && TREE_CHAIN (parms) == 0\n       && VOID_TYPE_P (TREE_TYPE (parms))\n@@ -4600,18 +4605,22 @@ get_parm_info (int void_at_end)\n       if (TREE_THIS_VOLATILE (parms)\n \t  || TREE_READONLY (parms)\n \t  || DECL_REGISTER (parms))\n-\terror (\"\\\"void\\\" as only parameter may not be qualified\");\n+\terror (\"'void' as only parameter may not be qualified\");\n \n-      return tree_cons (0, 0, tree_cons (0, void_type_node, 0));\n+      list = make_node (TREE_LIST);\n+      ARG_INFO_TYPES (list) = build_tree_list (0, void_type_node);\n+      return list;\n     }\n \n   /* Sanity check all of the parameter declarations.  */\n   for (decl = parms; decl; decl = TREE_CHAIN (decl))\n     {\n+#ifdef ENABLE_CHECKING\n       if (TREE_CODE (decl) != PARM_DECL)\n \tabort ();\n       if (TREE_ASM_WRITTEN (decl))\n \tabort ();\n+#endif\n \n       /* Since there is a prototype, args are passed in their\n \t declared types.  The back end may override this.  */\n@@ -4621,7 +4630,7 @@ get_parm_info (int void_at_end)\n       /* Check for (..., void, ...) and issue an error.  */\n       if (VOID_TYPE_P (type) && !DECL_NAME (decl) && !gave_void_only_once_err)\n \t{\n-\t  error (\"\\\"void\\\" must be the only parameter\");\n+\t  error (\"'void' must be the only parameter\");\n \t  gave_void_only_once_err = true;\n \t}\n \n@@ -4638,7 +4647,7 @@ get_parm_info (int void_at_end)\n \tif (!TREE_ASM_WRITTEN (decl))\n \t  abort ();\n \n-\t  error (\"%Jparameter \\\"%D\\\" has just a forward declaration\",\n+\t  error (\"%Jparameter '%D' has just a forward declaration\",\n \t\t decl, decl);\n       }\n \n@@ -4665,9 +4674,9 @@ get_parm_info (int void_at_end)\n \t}\n \n       if (TREE_PURPOSE (decl))\n-\t/* The first %s will be one of 'struct', 'union', or 'enum'.  */\n-\twarning (\"\\\"%s %s\\\" declared inside parameter list\",\n-\t\t keyword, IDENTIFIER_POINTER (TREE_PURPOSE (decl)));\n+\t/* The %s will be one of 'struct', 'union', or 'enum'.  */\n+\twarning (\"'%s %E' declared inside parameter list\",\n+\t\t keyword, TREE_PURPOSE (decl));\n       else\n \t/* The %s will be one of 'struct', 'union', or 'enum'.  */\n \twarning (\"anonymous %s declared inside parameter list\", keyword);\n@@ -4687,8 +4696,11 @@ get_parm_info (int void_at_end)\n       *last_type = type;\n     }\n \n-  list = tree_cons (parms, tags, types);\n-  TREE_TYPE (list) = others;\n+  list = make_node (TREE_LIST);\n+  ARG_INFO_PARMS  (list) = parms;\n+  ARG_INFO_TAGS   (list) = tags;\n+  ARG_INFO_TYPES  (list) = types;\n+  ARG_INFO_OTHERS (list) = others;\n   return list;\n }\n \f\n@@ -5443,12 +5455,6 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   if (warn_about_return_type)\n     pedwarn_c99 (\"return type defaults to `int'\");\n \n-  /* Save the parm names or decls from this function's declarator\n-     where store_parm_decls will find them.  */\n-  current_function_parms = last_function_parms;\n-  current_function_parm_tags = last_function_parm_tags;\n-  current_function_parm_others = last_function_parm_others;\n-\n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n   DECL_INITIAL (decl1) = error_mark_node;\n@@ -5624,13 +5630,13 @@ start_function (tree declspecs, tree declarator, tree attributes)\n    need only record them as in effect and complain if any redundant\n    old-style parm decls were written.  */\n static void\n-store_parm_decls_newstyle (void)\n+store_parm_decls_newstyle (tree fndecl, tree arg_info)\n {\n   tree decl, last;\n-  tree fndecl = current_function_decl;\n-  tree parms = current_function_parms;\n-  tree tags = current_function_parm_tags;\n-  tree others = current_function_parm_others;\n+\n+  tree parms = ARG_INFO_PARMS (arg_info);\n+  tree tags = ARG_INFO_TAGS (arg_info);\n+  tree others = ARG_INFO_OTHERS (arg_info);\n \n   if (current_scope->parms || current_scope->names || current_scope->tags)\n     {\n@@ -5701,13 +5707,12 @@ store_parm_decls_newstyle (void)\n    definitions (separate parameter list and declarations).  */\n \n static void\n-store_parm_decls_oldstyle (void)\n+store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n {\n   tree parm, decl, last;\n-  tree fndecl = current_function_decl;\n \n   /* This is the identifier list from the function declarator.  */\n-  tree parmids = current_function_parms;\n+  tree parmids = ARG_INFO_PARMS (arg_info);\n \n   /* We use DECL_WEAK as a flag to show which parameters have been\n      seen already, since it is not used on PARM_DECL.  */\n@@ -5932,14 +5937,20 @@ store_parm_decls (void)\n   /* The function containing FNDECL, if any.  */\n   tree context = decl_function_context (fndecl);\n \n-  /* True if this definition is written with a prototype.  */\n-  bool prototype = (current_function_parms\n-\t\t    && TREE_CODE (current_function_parms) != TREE_LIST);\n+  /* The argument information block for FNDECL.  */\n+  tree arg_info = DECL_ARGUMENTS (fndecl);\n+\n+  /* True if this definition is written with a prototype.  Since this\n+     is a function definition, we can treat a null parameter list\n+     (i.e. \"foo()\") as prototyped (C99 6.7.5.3p14) - this reduces\n+     overhead.  */\n+  bool prototype = (!ARG_INFO_PARMS (arg_info)\n+\t\t    || TREE_CODE (ARG_INFO_PARMS (arg_info)) != TREE_LIST);\n \n   if (prototype)\n-    store_parm_decls_newstyle ();\n+    store_parm_decls_newstyle (fndecl, arg_info);\n   else\n-    store_parm_decls_oldstyle ();\n+    store_parm_decls_oldstyle (fndecl, arg_info);\n \n   /* The next call to pushlevel will be a function body.  */\n "}, {"sha": "362aba8bbc9fdedc26b04d6ad10afca7476e7018", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=77dbdb5745d52b1ff3ddede885706d77a3817dd7", "patch": "@@ -1,3 +1,7 @@\n+2004-03-09  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/noncompile/incomplete-2.c: Move dg-error to proper line.\n+\n 2004-03-09  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.c-torture/execute/20040309-1.c: New test case.\n@@ -40,7 +44,7 @@\n \t* g++.dg/overload/koenig1.C: Likewise.\n \t* g++.dg/parse/crash13.C: Likewise.\n \t* g++.dg/template/instantiate3.C: Likewise.\n-\t\n+\n 2004-03-08  Eric Christopher  <echristo@redhat.com>\n \n \t* * lib/target-supports.exp: Enable libiconv in test"}, {"sha": "0c707e3729af894d5e8c3a372740fd0b41ace1d2", "filename": "gcc/testsuite/gcc.dg/noncompile/incomplete-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fincomplete-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77dbdb5745d52b1ff3ddede885706d77a3817dd7/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fincomplete-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fincomplete-2.c?ref=77dbdb5745d52b1ff3ddede885706d77a3817dd7", "patch": "@@ -6,7 +6,7 @@\n int g95_type_for_mode (enum machine_mode);\n \n int\n-g95_type_for_mode (enum machine_mode mode)\n-{ /* { dg-error \"has incomplete type\" } */\n+g95_type_for_mode (enum machine_mode mode) /* { dg-error \"incomplete type\" } */\n+{\n   return 0;\n }"}]}