{"sha": "af410c4c29cb65c21cb106747b9ea14c4f9dd9bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY0MTBjNGMyOWNiNjVjMjFjYjEwNjc0N2I5ZWExNGM0ZjlkZDliYw==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2015-01-13T11:23:01Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2015-01-13T11:23:01Z"}, "message": "re PR tree-optimization/64436 (optimize-bswapdi-3.c fails on aarch64_be-none-elf)\n\n2015-01-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR tree-optimization/64436\n    * tree-ssa-math-opts.c (find_bswap_or_nop_1): Move code performing the\n    merge of two symbolic numbers for a bitwise OR to ...\n    (perform_symbolic_merge): This. Also fix computation of the range and\n    end of the symbolic number corresponding to the result of a bitwise OR.\n\nFrom-SVN: r219525", "tree": {"sha": "861e267cd6a45f6ac93c476b4eadcb5c3c906ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/861e267cd6a45f6ac93c476b4eadcb5c3c906ee8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71aa170d28053078fde8f703c9918ed7448520ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71aa170d28053078fde8f703c9918ed7448520ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71aa170d28053078fde8f703c9918ed7448520ec"}], "stats": {"total": 208, "additions": 131, "deletions": 77}, "files": [{"sha": "4700629e53f521c705fef570667a186baf916c63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af410c4c29cb65c21cb106747b9ea14c4f9dd9bc", "patch": "@@ -1,3 +1,11 @@\n+2015-01-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/64436\n+\t* tree-ssa-math-opts.c (find_bswap_or_nop_1): Move code performing the\n+\tmerge of two symbolic numbers for a bitwise OR to ...\n+\t(perform_symbolic_merge): This. Also fix computation of the range and\n+\tend of the symbolic number corresponding to the result of a bitwise OR.\n+\n 2014-01-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/64568"}, {"sha": "16fa1681ce2fd446854db7255f03625927d88bc2", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 123, "deletions": 77, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af410c4c29cb65c21cb106747b9ea14c4f9dd9bc/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=af410c4c29cb65c21cb106747b9ea14c4f9dd9bc", "patch": "@@ -1822,6 +1822,123 @@ find_bswap_or_nop_load (gimple stmt, tree ref, struct symbolic_number *n)\n   return true;\n }\n \n+/* Compute the symbolic number N representing the result of a bitwise OR on 2\n+   symbolic number N1 and N2 whose source statements are respectively\n+   SOURCE_STMT1 and SOURCE_STMT2.  */\n+\n+static gimple\n+perform_symbolic_merge (gimple source_stmt1, struct symbolic_number *n1,\n+\t\t\tgimple source_stmt2, struct symbolic_number *n2,\n+\t\t\tstruct symbolic_number *n)\n+{\n+  int i, size;\n+  uint64_t mask;\n+  gimple source_stmt;\n+  struct symbolic_number *n_start;\n+\n+  /* Sources are different, cancel bswap if they are not memory location with\n+     the same base (array, structure, ...).  */\n+  if (gimple_assign_rhs1 (source_stmt1) != gimple_assign_rhs1 (source_stmt2))\n+    {\n+      int64_t inc;\n+      HOST_WIDE_INT start_sub, end_sub, end1, end2, end;\n+      struct symbolic_number *toinc_n_ptr, *n_end;\n+\n+      if (!n1->base_addr || !n2->base_addr\n+\t  || !operand_equal_p (n1->base_addr, n2->base_addr, 0))\n+\treturn NULL;\n+\n+      if (!n1->offset != !n2->offset ||\n+          (n1->offset && !operand_equal_p (n1->offset, n2->offset, 0)))\n+\treturn NULL;\n+\n+      if (n1->bytepos < n2->bytepos)\n+\t{\n+\t  n_start = n1;\n+\t  start_sub = n2->bytepos - n1->bytepos;\n+\t  source_stmt = source_stmt1;\n+\t}\n+      else\n+\t{\n+\t  n_start = n2;\n+\t  start_sub = n1->bytepos - n2->bytepos;\n+\t  source_stmt = source_stmt2;\n+\t}\n+\n+      /* Find the highest address at which a load is performed and\n+\t compute related info.  */\n+      end1 = n1->bytepos + (n1->range - 1);\n+      end2 = n2->bytepos + (n2->range - 1);\n+      if (end1 < end2)\n+\t{\n+\t  end = end2;\n+\t  end_sub = end2 - end1;\n+\t}\n+      else\n+\t{\n+\t  end = end1;\n+\t  end_sub = end1 - end2;\n+\t}\n+      n_end = (end2 > end1) ? n2 : n1;\n+\n+      /* Find symbolic number whose lsb is the most significant.  */\n+      if (BYTES_BIG_ENDIAN)\n+\ttoinc_n_ptr = (n_end == n1) ? n2 : n1;\n+      else\n+\ttoinc_n_ptr = (n_start == n1) ? n2 : n1;\n+\n+      n->range = end - n_start->bytepos + 1;\n+\n+      /* Check that the range of memory covered can be represented by\n+\t a symbolic number.  */\n+      if (n->range > 64 / BITS_PER_MARKER)\n+\treturn NULL;\n+\n+      /* Reinterpret byte marks in symbolic number holding the value of\n+\t bigger weight according to target endianness.  */\n+      inc = BYTES_BIG_ENDIAN ? end_sub : start_sub;\n+      size = TYPE_PRECISION (n1->type) / BITS_PER_UNIT;\n+      for (i = 0; i < size; i++, inc <<= BITS_PER_MARKER)\n+\t{\n+\t  unsigned marker =\n+\t    (toinc_n_ptr->n >> (i * BITS_PER_MARKER)) & MARKER_MASK;\n+\t  if (marker && marker != MARKER_BYTE_UNKNOWN)\n+\t    toinc_n_ptr->n += inc;\n+\t}\n+    }\n+  else\n+    {\n+      n->range = n1->range;\n+      n_start = n1;\n+      source_stmt = source_stmt1;\n+    }\n+\n+  if (!n1->alias_set\n+      || alias_ptr_types_compatible_p (n1->alias_set, n2->alias_set))\n+    n->alias_set = n1->alias_set;\n+  else\n+    n->alias_set = ptr_type_node;\n+  n->vuse = n_start->vuse;\n+  n->base_addr = n_start->base_addr;\n+  n->offset = n_start->offset;\n+  n->bytepos = n_start->bytepos;\n+  n->type = n_start->type;\n+  size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n+\n+  for (i = 0, mask = MARKER_MASK; i < size; i++, mask <<= BITS_PER_MARKER)\n+    {\n+      uint64_t masked1, masked2;\n+\n+      masked1 = n1->n & mask;\n+      masked2 = n2->n & mask;\n+      if (masked1 && masked2 && masked1 != masked2)\n+\treturn NULL;\n+    }\n+  n->n = n1->n | n2->n;\n+\n+  return source_stmt;\n+}\n+\n /* find_bswap_or_nop_1 invokes itself recursively with N and tries to perform\n    the operation given by the rhs of STMT on the result.  If the operation\n    could successfully be executed the function returns a gimple stmt whose\n@@ -1948,10 +2065,8 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n   if (rhs_class == GIMPLE_BINARY_RHS)\n     {\n-      int i, size;\n       struct symbolic_number n1, n2;\n-      uint64_t mask;\n-      gimple source_stmt2;\n+      gimple source_stmt, source_stmt2;\n \n       if (code != BIT_IOR_EXPR)\n \treturn NULL;\n@@ -1981,80 +2096,11 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  (n1.vuse && !operand_equal_p (n1.vuse, n2.vuse, 0)))\n \t    return NULL;\n \n-\t  if (gimple_assign_rhs1 (source_stmt1)\n-\t      != gimple_assign_rhs1 (source_stmt2))\n-\t    {\n-\t      int64_t inc;\n-\t      HOST_WIDE_INT off_sub;\n-\t      struct symbolic_number *n_ptr;\n-\n-\t      if (!n1.base_addr || !n2.base_addr\n-\t\t  || !operand_equal_p (n1.base_addr, n2.base_addr, 0))\n-\t\treturn NULL;\n-\t      if (!n1.offset != !n2.offset ||\n-\t          (n1.offset && !operand_equal_p (n1.offset, n2.offset, 0)))\n-\t\treturn NULL;\n+\t  source_stmt =\n+\t    perform_symbolic_merge (source_stmt1, &n1, source_stmt2, &n2, n);\n \n-\t      /* We swap n1 with n2 to have n1 < n2.  */\n-\t      if (n2.bytepos < n1.bytepos)\n-\t\t{\n-\t\t  struct symbolic_number tmpn;\n-\n-\t\t  tmpn = n2;\n-\t\t  n2 = n1;\n-\t\t  n1 = tmpn;\n-\t\t  source_stmt1 = source_stmt2;\n-\t\t}\n-\n-\t      off_sub = n2.bytepos - n1.bytepos;\n-\n-\t      /* Check that the range of memory covered can be represented by\n-\t\t a symbolic number.  */\n-\t      if (off_sub + n2.range > 64 / BITS_PER_MARKER)\n-\t\treturn NULL;\n-\t      n->range = n2.range + off_sub;\n-\n-\t      /* Reinterpret byte marks in symbolic number holding the value of\n-\t\t bigger weight according to target endianness.  */\n-\t      inc = BYTES_BIG_ENDIAN ? off_sub + n2.range - n1.range : off_sub;\n-\t      size = TYPE_PRECISION (n1.type) / BITS_PER_UNIT;\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\tn_ptr = &n1;\n-\t      else\n-\t\tn_ptr = &n2;\n-\t      for (i = 0; i < size; i++, inc <<= BITS_PER_MARKER)\n-\t\t{\n-\t\t  unsigned marker =\n-\t\t    (n_ptr->n >> (i * BITS_PER_MARKER)) & MARKER_MASK;\n-\t\t  if (marker && marker != MARKER_BYTE_UNKNOWN)\n-\t\t    n_ptr->n += inc;\n-\t\t}\n-\t    }\n-\t  else\n-\t    n->range = n1.range;\n-\n-\t  if (!n1.alias_set\n-\t      || alias_ptr_types_compatible_p (n1.alias_set, n2.alias_set))\n-\t    n->alias_set = n1.alias_set;\n-\t  else\n-\t    n->alias_set = ptr_type_node;\n-\t  n->vuse = n1.vuse;\n-\t  n->base_addr = n1.base_addr;\n-\t  n->offset = n1.offset;\n-\t  n->bytepos = n1.bytepos;\n-\t  n->type = n1.type;\n-\t  size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n-\t  for (i = 0, mask = MARKER_MASK; i < size;\n-\t       i++, mask <<= BITS_PER_MARKER)\n-\t    {\n-\t      uint64_t masked1, masked2;\n-\n-\t      masked1 = n1.n & mask;\n-\t      masked2 = n2.n & mask;\n-\t      if (masked1 && masked2 && masked1 != masked2)\n-\t\treturn NULL;\n-\t    }\n-\t  n->n = n1.n | n2.n;\n+\t  if (!source_stmt)\n+\t    return NULL;\n \n \t  if (!verify_symbolic_number_p (n, stmt))\n \t    return NULL;\n@@ -2063,7 +2109,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \tdefault:\n \t  return NULL;\n \t}\n-      return source_stmt1;\n+      return source_stmt;\n     }\n   return NULL;\n }"}]}