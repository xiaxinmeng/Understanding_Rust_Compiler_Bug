{"sha": "f9225794387f19498aa5dfbd505736d1267d66e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkyMjU3OTQzODdmMTk0OThhYTVkZmJkNTA1NzM2ZDEyNjdkNjZlMQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-10-24T14:15:45Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-24T14:15:45Z"}, "message": "* doc/libgcc.texi: Document some more of the libgcc API.\n\nFrom-SVN: r72894", "tree": {"sha": "d97c663df3e4ca3de1086680d2eda52196dbc17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d97c663df3e4ca3de1086680d2eda52196dbc17c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9225794387f19498aa5dfbd505736d1267d66e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9225794387f19498aa5dfbd505736d1267d66e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9225794387f19498aa5dfbd505736d1267d66e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9225794387f19498aa5dfbd505736d1267d66e1/comments", "author": null, "committer": null, "parents": [{"sha": "b0f26df5db7c471770e7219881e9bfe85cd3a039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f26df5db7c471770e7219881e9bfe85cd3a039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0f26df5db7c471770e7219881e9bfe85cd3a039"}], "stats": {"total": 348, "additions": 234, "deletions": 114}, "files": [{"sha": "45b9fa451ae7dbe74eca81306fac68e794ecb0d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9225794387f19498aa5dfbd505736d1267d66e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9225794387f19498aa5dfbd505736d1267d66e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9225794387f19498aa5dfbd505736d1267d66e1", "patch": "@@ -1,3 +1,7 @@\n+2003-10-24  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* doc/libgcc.texi: Document some more of the libgcc API.\n+\n 2003-10-24  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (arm_rtx_costs_1, case TARGET_THUMB): Adjust costs for"}, {"sha": "af6f7be3e59b880b4c239c41c8f5bf2259df64f6", "filename": "gcc/doc/libgcc.texi", "status": "modified", "additions": 230, "deletions": 114, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9225794387f19498aa5dfbd505736d1267d66e1/gcc%2Fdoc%2Flibgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9225794387f19498aa5dfbd505736d1267d66e1/gcc%2Fdoc%2Flibgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flibgcc.texi?ref=f9225794387f19498aa5dfbd505736d1267d66e1", "patch": "@@ -26,6 +26,16 @@ GCC will also generate calls to C library routines, such as\n that GCC may possibly use is documented in @ref{Other\n Builtins,,,gcc, Using the GNU Compiler Collection (GCC)}.\n \n+These routines take arguments and return values of a specific machine\n+mode, not a specific C type.  @xref{Machine Modes}, for an explanation\n+of this concept.  For illustrative purposes, in this chapter the\n+floating point type @code{float} is assumed to correspond to @code{SFmode};\n+@code{double} to @code{DFmode}; and @code{@w{long double}} to both\n+@code{TFmode} and @code{XFmode}.  Similarly, the integer types @code{int}\n+and @code{@w{unsigned int}} correspond to @code{SImode}; @code{long} and\n+@code{@w{unsigned long}} to @code{DImode}; and @code{@w{long long}} and\n+@code{@w{unsigned long long}} to @code{TImode}.\n+\n @menu\n * Integer library routines::\n * Soft float library routines::\n@@ -36,98 +46,170 @@ Builtins,,,gcc, Using the GNU Compiler Collection (GCC)}.\n @node Integer library routines\n @section Routines for integer arithmetic\n \n-document me!\n+The integer arithmetic routines are used on platforms that don't provide\n+hardware support for arithmetic operations on some modes.\n \n-@example\n-  __absvsi2\n-  __addvsi3\n-  __ashlsi3\n-  __ashrsi3\n-  __divsi3\n-  __lshrsi3\n-  __modsi3\n-  __mulsi3\n-  __mulvsi3\n-  __negvsi2\n-  __subvsi3\n-  __udivsi3\n-  __umodsi3\n-\n-  __absvdi2\n-  __addvdi3\n-  __ashldi3\n-  __ashrdi3\n-  __cmpdi2\n-  __divdi3\n-  __ffsdi2\n-  __fixdfdi\n-  __fixsfdi\n-  __fixtfdi\n-  __fixxfdi\n-  __fixunsdfdi\n-  __fixunsdfsi\n-  __fixunssfsi\n-  __fixunssfdi\n-  __fixunstfdi\n-  __fixunstfsi\n-  __fixunsxfdi\n-  __fixunsxfsi\n-  __floatdidf\n-  __floatdisf\n-  __floatdixf\n-  __floatditf\n-  __lshrdi3\n-  __moddi3\n-  __muldi3\n-  __mulvdi3\n-  __negdi2\n-  __negvdi2\n-  __subvdi3\n-  __ucmpdi2\n-  __udivdi3\n-  __udivmoddi4\n-  __umoddi3\n-\n-  __ashlti3\n-  __ashrti3\n-  __cmpti2\n-  __divti3\n-  __ffsti2\n-  __fixdfti\n-  __fixsfti\n-  __fixtfti\n-  __fixxfti\n-  __lshrti3\n-  __modti3\n-  __multi3\n-  __negti2\n-  __ucmpti2\n-  __udivmodti4\n-  __udivti3\n-  __umodti3\n-  __fixunsdfti\n-  __fixunssfti\n-  __fixunstfti\n-  __fixunsxfti\n-  __floattidf\n-  __floattisf\n-  __floattixf\n-  __floattitf\n-\n-  __clzsi2\n-  __clzdi2\n-  __clzti2\n-  __ctzsi2\n-  __ctzdi2\n-  __ctzti2\n-  __popcountsi2\n-  __popcountdi2\n-  __popcountti2\n-  __paritysi2\n-  __paritydi2\n-  __parityti2\n-@end example\n+@subsection Arithmetic functions\n+\n+@deftypefn {Runtime Function} int __ashlsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __ashldi3 (long @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} {long long} __ashlti3 (long long @var{a}, int @var{b})\n+These functions return the result of shifting @var{a} left by @var{b} bits.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __ashrsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __ashrdi3 (long @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} {long long} __ashrti3 (long long @var{a}, int @var{b})\n+These functions return the result of arithmetically shifting @var{a} right\n+by @var{b} bits.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __divsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __divdi3 (long @var{a}, long @var{b})\n+@deftypefnx {Runtime Function} {long long} __divti3 (long long @var{a}, long long @var{b})\n+These functions return the quotient of the signed division of @var{a} and\n+@var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __lshrsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __lshrdi3 (long @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} {long long} __lshrti3 (long long @var{a}, int @var{b})\n+These functions return the result of logically shifting @var{a} right by\n+@var{b} bits.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __modsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __moddi3 (long @var{a}, long @var{b})\n+@deftypefnx {Runtime Function} {long long} __modti3 (long long @var{a}, long long @var{b})\n+These functions return the remainder of the signed division of @var{a}\n+and @var{b}.\n+@end deftypefn\n \n+@deftypefn {Runtime Function} int __mulsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __muldi3 (long @var{a}, long @var{b})\n+@deftypefnx {Runtime Function} {long long} __multi3 (long long @var{a}, long long @var{b})\n+These functions return the product of @var{a} and @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} long __negdi2 (long @var{a})\n+@deftypefnx {Runtime Function} {long long} __negti2 (long long @var{a})\n+These functions return the negation of @var{a}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} {unsigned int} __udivsi3 (unsigned int @var{a}, unsigned int @var{b})\n+@deftypefnx {Runtime Function} {unsigned long} __udivdi3 (unsigned long @var{a}, unsigned long @var{b})\n+@deftypefnx {Runtime Function} {unsigned long long} __udivti3 (unsigned long long @var{a}, unsigned long long @var{b})\n+These functions return the quotient of the unsigned division of @var{a}\n+and @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} {unsigned long} __udivmoddi3 (unsigned long @var{a}, unsigned long @var{b}, unsigned long *@var{c})\n+@deftypefnx {Runtime Function} {unsigned long long} __udivti3 (unsigned long long @var{a}, unsigned long long @var{b}, unsigned long long *@var{c})\n+These functions calculate both the quotient and remainder of the unsigned\n+division of @var{a} and @var{b}.  The return value is the quotient, and\n+the remainder is placed in variable pointed to by @var{c}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} {unsigned int} __umodsi3 (unsigned int @var{a}, unsigned int @var{b})\n+@deftypefnx {Runtime Function} {unsigned long} __umoddi3 (unsigned long @var{a}, unsigned long @var{b})\n+@deftypefnx {Runtime Function} {unsigned long long} __umodti3 (unsigned long long @var{a}, unsigned long long @var{b})\n+These functions return the remainder of the unsigned division of @var{a}\n+and @var{b}.\n+@end deftypefn\n+\n+@subsection Comparison functions\n+\n+The following functions implement integral comparisons.  These functions\n+implement a low-level compare, upon which the higher level comparison\n+operators (such as less than and greater than or equal to) can be\n+constructed.  The returned values lie in the range zero to two, to allow\n+the high-level operators to be implemented by testing the returned\n+result using either signed or unsigned comparison.\n+\n+@deftypefn {Runtime Function} int __cmpdi2 (long @var{a}, long @var{b})\n+@deftypefnx {Runtime Function} int __cmpti2 (long long @var{a}, long long @var{b})\n+These functions perform a signed comparison of @var{a} and @var{b}.  If\n+@var{a} is less than @var{b}, they return 0; if @var{a} is greater than\n+@var{b}, they return 2; and if @var{a} and @var{b} are equal they return 1.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __ucmpdi2 (unsigned long @var{a}, unsigned long @var{b})\n+@deftypefnx {Runtime Function} int __ucmpti2 (unsigned long long @var{a}, unsigned long long @var{b})\n+These functions perform an unsigned comparison of @var{a} and @var{b}.\n+If @var{a} is less than @var{b}, they return 0; if @var{a} is greater than\n+@var{b}, they return 2; and if @var{a} and @var{b} are equal they return 1.\n+@end deftypefn\n+\n+@subsection Trapping arithmetic functions\n+\n+The following functions implement trapping arithmetic.  These functions\n+call the libc function @code{abort} upon signed arithmetic overflow.\n+\n+@deftypefn {Runtime Function} int __absvsi2 (int @var{a})\n+@deftypefnx {Runtime Function} long __absvdi2 (long @var{a})\n+These functions return the absolute value of @var{a}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __addvsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __addvdi3 (long @var{a}, long @var{b})\n+These functions return the sum of @var{a} and @var{b}; that is\n+@code{@var{a} + @var{b}}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __mulvsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __mulvdi3 (long @var{a}, long @var{b})\n+The functions return the product of @var{a} and @var{b}; that is\n+@code{@var{a} * @var{b}}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __negvsi2 (int @var{a})\n+@deftypefnx {Runtime Function} long __negvdi2 (long @var{a})\n+These functions return the negation of @var{a}; that is @code{-@var{a}}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __subvsi3 (int @var{a}, int @var{b})\n+@deftypefnx {Runtime Function} long __subvdi3 (long @var{a}, long @var{b})\n+These functions return the difference between @var{b} and @var{a};\n+that is @code{@var{a} - @var{b}}.\n+@end deftypefn\n+\n+@subsection Bit operations\n+\n+@deftypefn {Runtime Function} int __clzsi2 (int @var{a})\n+@deftypefnx {Runtime Function} int __clzdi2 (long @var{a})\n+@deftypefnx {Runtime Function} int __clzti2 (long long @var{a})\n+These functions return the number of leading 0-bits in @var{a}, starting\n+at the most significant bit position.  If @var{a} is zero, the result is\n+undefined.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __ctzsi2 (int @var{a})\n+@deftypefnx {Runtime Function} int __ctzdi2 (long @var{a})\n+@deftypefnx {Runtime Function} int __ctzti2 (long long @var{a})\n+These functions return the number of trailing 0-bits in @var{a}, starting\n+at the least significant bit position.  If @var{a} is zero, the result is\n+undefined.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __ffsdi2 (long @var{a})\n+@deftypefnx {Runtime Function} int __ffsti2 (long long @var{a})\n+These functions return the index of the least significant 1-bit in @var{a},\n+or the value zero if @var{a} is zero.  The least significant bit is index\n+one.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __paritysi2 (int @var{a})\n+@deftypefnx {Runtime Function} int __paritydi2 (long @var{a})\n+@deftypefnx {Runtime Function} int __parityti2 (long long @var{a})\n+These functions return the value zero if the number of bits set in\n+@var{a} is even, and the value one otherwise.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __popcountsi2 (int @var{a})\n+@deftypefnx {Runtime Function} int __popcountdi2 (long @var{a})\n+@deftypefnx {Runtime Function} int __popcountti2 (long long @var{a})\n+These functions return the number of bits set in @var{a}.\n+@end deftypefn\n \n @node Soft float library routines\n @section Routines for floating point emulation\n@@ -145,14 +227,6 @@ For compatibility with other compilers, the floating point emulation\n routines can be renamed with the @code{DECLARE_LIBRARY_RENAMES} macro\n (@pxref{Library Calls}).  In this section, the default names are used.\n \n-These routines take arguments and return values of a specific machine\n-mode, not a specific C type.  @xref{Machine Modes}, for an explanation\n-of this concept.  For illustrative purposes, in this section\n-@code{float} is assumed to correspond to @code{SFmode}; @code{double}\n-to @code{DFmode}; @code{@w{long double}} to @code{TFmode}; and\n-@code{int} to @code{SImode}.  This is a common mapping, but not the\n-only possibility.\n-\n Presently the library does not support @code{XFmode}, which is used\n for @code{long double} on some architectures.\n \n@@ -161,32 +235,37 @@ for @code{long double} on some architectures.\n @deftypefn {Runtime Function} float __addsf3 (float @var{a}, float @var{b})\n @deftypefnx {Runtime Function} double __adddf3 (double @var{a}, double @var{b})\n @deftypefnx {Runtime Function} {long double} __addtf3 (long double @var{a}, long double @var{b})\n+@deftypefnx {Runtime Function} {long double} __addxf3 (long double @var{a}, long double @var{b})\n These functions return the sum of @var{a} and @var{b}.\n @end deftypefn\n \n @deftypefn {Runtime Function} float __subsf3 (float @var{a}, float @var{b})\n @deftypefnx {Runtime Function} double __subdf3 (double @var{a}, double @var{b})\n @deftypefnx {Runtime Function} {long double} __subtf3 (long double @var{a}, long double @var{b})\n+@deftypefnx {Runtime Function} {long double} __subxf3 (long double @var{a}, long double @var{b})\n These functions return the difference between @var{b} and @var{a};\n that is, @w{@math{@var{a} - @var{b}}}.\n @end deftypefn\n \n @deftypefn {Runtime Function} float __mulsf3 (float @var{a}, float @var{b})\n @deftypefnx {Runtime Function} double __muldf3 (double @var{a}, double @var{b})\n @deftypefnx {Runtime Function} {long double} __multf3 (long double @var{a}, long double @var{b})\n+@deftypefnx {Runtime Function} {long double} __mulxf3 (long double @var{a}, long double @var{b})\n These functions return the product of @var{a} and @var{b}.\n @end deftypefn\n \n @deftypefn {Runtime Function} float __divsf3 (float @var{a}, float @var{b})\n @deftypefnx {Runtime Function} double __divdf3 (double @var{a}, double @var{b})\n @deftypefnx {Runtime Function} {long double} __divtf3 (long double @var{a}, long double @var{b})\n+@deftypefnx {Runtime Function} {long double} __divxf3 (long double @var{a}, long double @var{b})\n These functions return the quotient of @var{a} and @var{b}; that is,\n @w{@math{@var{a} / @var{b}}}.\n @end deftypefn\n \n @deftypefn {Runtime Function} float __negsf2 (float @var{a})\n @deftypefnx {Runtime Function} double __negdf2 (double @var{a})\n @deftypefnx {Runtime Function} {long double} __negtf2 (long double @var{a})\n+@deftypefnx {Runtime Function} {long double} __negxf2 (long double @var{a})\n These functions return the negation of @var{a}.  They simply flip the\n sign bit, so they can produce negative zero and negative NaN.\n @end deftypefn\n@@ -195,12 +274,16 @@ sign bit, so they can produce negative zero and negative NaN.\n \n @deftypefn {Runtime Function} double __extendsfdf2 (float @var{a})\n @deftypefnx {Runtime Function} {long double} __extendsftf2 (float @var{a})\n+@deftypefnx {Runtime Function} {long double} __extendsfxf2 (float @var{a})\n @deftypefnx {Runtime Function} {long double} __extenddftf2 (double @var{a})\n+@deftypefnx {Runtime Function} {long double} __extenddfxf2 (double @var{a})\n These functions extend @var{a} to the wider mode of their return\n type.\n @end deftypefn\n \n-@deftypefn {Runtime Function} double __trunctfdf2 (long double @var{a})\n+@deftypefn {Runtime Function} double __truncxfdf2 (long double @var{a})\n+@deftypefnx {Runtime Function} double __trunctfdf2 (long double @var{a})\n+@deftypefnx {Runtime Function} float __truncxfsf2 (long double @var{a})\n @deftypefnx {Runtime Function} float __trunctfsf2 (long double @var{a})\n @deftypefnx {Runtime Function} float __truncdfsf2 (double @var{a})\n These functions truncate @var{a} to the narrower mode of their return\n@@ -210,33 +293,68 @@ type, rounding toward zero.\n @deftypefn {Runtime Function} int __fixsfsi (float @var{a})\n @deftypefnx {Runtime Function} int __fixdfsi (double @var{a})\n @deftypefnx {Runtime Function} int __fixtfsi (long double @var{a})\n+@deftypefnx {Runtime Function} int __fixxfsi (long double @var{a})\n These functions convert @var{a} to a signed integer, rounding toward zero.\n @end deftypefn\n \n+@deftypefn {Runtime Function} long __fixsfdi (float @var{a})\n+@deftypefnx {Runtime Function} long __fixdfdi (double @var{a})\n+@deftypefnx {Runtime Function} long __fixtfdi (long double @var{a})\n+@deftypefnx {Runtime Function} long __fixxfdi (long double @var{a})\n+These functions convert @var{a} to a signed long, rounding toward zero.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} {long long} __fixsfti (float @var{a})\n+@deftypefnx {Runtime Function} {long long} __fixdfti (double @var{a})\n+@deftypefnx {Runtime Function} {long long} __fixtfti (long double @var{a})\n+@deftypefnx {Runtime Function} {long long} __fixxfti (long double @var{a})\n+These functions convert @var{a} to a signed long long, rounding toward zero.\n+@end deftypefn\n+\n @deftypefn {Runtime Function} {unsigned int} __fixunssfsi (float @var{a})\n @deftypefnx {Runtime Function} {unsigned int} __fixunsdfsi (double @var{a})\n @deftypefnx {Runtime Function} {unsigned int} __fixunstfsi (long double @var{a})\n+@deftypefnx {Runtime Function} {unsigned int} __fixunsxfsi (long double @var{a})\n These functions convert @var{a} to an unsigned integer, rounding\n toward zero.  Negative values all become zero.\n @end deftypefn\n \n+@deftypefn {Runtime Function} {unsigned long} __fixunssfdi (float @var{a})\n+@deftypefnx {Runtime Function} {unsigned long} __fixunsdfdi (double @var{a})\n+@deftypefnx {Runtime Function} {unsigned long} __fixunstfdi (long double @var{a})\n+@deftypefnx {Runtime Function} {unsigned long} __fixunsxfdi (long double @var{a})\n+These functions convert @var{a} to an unsigned long, rounding\n+toward zero.  Negative values all become zero.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} {unsigned long long} __fixunssfti (float @var{a})\n+@deftypefnx {Runtime Function} {unsigned long long} __fixunsdfti (double @var{a})\n+@deftypefnx {Runtime Function} {unsigned long long} __fixunstfti (long double @var{a})\n+@deftypefnx {Runtime Function} {unsigned long long} __fixunsxfti (long double @var{a})\n+These functions convert @var{a} to an unsigned long long, rounding\n+toward zero.  Negative values all become zero.\n+@end deftypefn\n+\n @deftypefn {Runtime Function} float __floatsisf (int @var{i})\n @deftypefnx {Runtime Function} double __floatsidf (int @var{i})\n @deftypefnx {Runtime Function} {long double} __floatsitf (int @var{i})\n+@deftypefnx {Runtime Function} {long double} __floatsixf (int @var{i})\n These functions convert @var{i}, a signed integer, to floating point.\n @end deftypefn\n \n-@deftypefn {Runtime Function} float __floatunsisf (unsigned int @var{n})\n-@deftypefnx {Runtime Function} double __floatunsidf (unsigned int @var{n})\n-@deftypefnx {Runtime Function} {long double} __floatunsitf (unsigned int @var{n})\n-These functions convert @var{n}, an unsigned integer, to floating point.\n+@deftypefn {Runtime Function} float __floatdisf (long @var{i})\n+@deftypefnx {Runtime Function} double __floatdidf (long @var{i})\n+@deftypefnx {Runtime Function} {long double} __floatditf (long @var{i})\n+@deftypefnx {Runtime Function} {long double} __floatdixf (long @var{i})\n+These functions convert @var{i}, a signed long, to floating point.\n @end deftypefn\n \n-There are no functions to convert @code{DImode} integers to or from\n-floating point; this reflects the fact that such conversions are rare,\n-and processors with native 64-bit arithmetic tend to have hardware\n-floating point support.  If such routines ever get added, they will be\n-named @code{__fixsfdi}, @code{__floatdisf}, and so on.\n+@deftypefn {Runtime Function} float __floattisf (long long @var{i})\n+@deftypefnx {Runtime Function} double __floattidf (long long @var{i})\n+@deftypefnx {Runtime Function} {long double} __floattitf (long long @var{i})\n+@deftypefnx {Runtime Function} {long double} __floattixf (long long @var{i})\n+These functions convert @var{i}, a signed long long, to floating point.\n+@end deftypefn\n \n @subsection Comparison functions\n \n@@ -359,10 +477,8 @@ document me!\n @node Miscellaneous routines\n @section Miscellaneous runtime library routines\n \n-document me!\n-\n-@example\n-  __clear_cache\n-@end example\n+@subsection Cache control functions\n+@deftypefn {Runtime Function} void __clear_cache (char *@var{beg}, char *@var{end})\n+This function clears the instruction cache between @var{beg} and @var{end}.\n+@end deftypefn\n \n-any others?"}]}