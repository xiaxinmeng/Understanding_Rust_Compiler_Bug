{"sha": "8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkNjFiM2M4YjZiYzZmZjMzNjk5NTMxMmUwNjc0OGM2MDJlYzZkZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-08-25T22:55:12Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-08-25T22:55:12Z"}, "message": "re PR fortran/58146 (Array slice bounds checking)\n\n2013-08-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/58146\n\t* array.c (gfc_ref_dimen_size):  If possible, use\n\tgfc_dep_difference to calculate array refrence\n\tsizes.  Fall back to integer code otherwise.\n\t* dependency.c (discard_nops).  Move up.\n\tAlso discarde widening integer conversions.\n\t(gfc_dep_compare_expr):  Use discard_nops.\n\n2013-08-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/58146\n\t* gfortran.dg/bounds_check_18.f90:  New test.\n\nFrom-SVN: r201981", "tree": {"sha": "a2e63d552ee312ff52abe80fd7a8922174507b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2e63d552ee312ff52abe80fd7a8922174507b77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/comments", "author": null, "committer": null, "parents": [{"sha": "7ecc260031bb303b3fb04895f1951d8914ac7f73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecc260031bb303b3fb04895f1951d8914ac7f73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ecc260031bb303b3fb04895f1951d8914ac7f73"}], "stats": {"total": 195, "additions": 122, "deletions": 73}, "files": [{"sha": "7e8326b8ba5a328c0c8456dec1ede5c41b50f42a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "patch": "@@ -1,3 +1,13 @@\n+2013-08-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/58146\n+\t* array.c (gfc_ref_dimen_size):  If possible, use\n+\tgfc_dep_difference to calculate array refrence\n+\tsizes.  Fall back to integer code otherwise.\n+\t* dependency.c (discard_nops).  Move up.\n+\tAlso discarde widening integer conversions.\n+\t(gfc_dep_compare_expr):  Use discard_nops.\n+\n 2013-08-23  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/57798"}, {"sha": "687ae3d2f0d7901891ca017e134324d19c531eb8", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "patch": "@@ -2112,6 +2112,7 @@ bool\n gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n {\n   mpz_t upper, lower, stride;\n+  mpz_t diff;\n   bool t;\n \n   if (dimen < 0 || ar == NULL || dimen > ar->dimen - 1)\n@@ -2130,9 +2131,63 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n       break;\n \n     case DIMEN_RANGE:\n+\n+      mpz_init (stride);\n+\n+      if (ar->stride[dimen] == NULL)\n+\tmpz_set_ui (stride, 1);\n+      else\n+\t{\n+\t  if (ar->stride[dimen]->expr_type != EXPR_CONSTANT)\n+\t    {\n+\t      mpz_clear (stride);\n+\t      return false;\n+\t    }\n+\t  mpz_set (stride, ar->stride[dimen]->value.integer);\n+\t}\n+\n+      /* Calculate the number of elements via gfc_dep_differce, but only if\n+\t start and end are both supplied in the reference or the array spec.\n+\t This is to guard against strange but valid code like\n+\n+\t subroutine foo(a,n)\n+\t real a(1:n)\n+\t n = 3\n+\t print *,size(a(n-1:))\n+\n+\t where the user changes the value of a variable.  If we have to\n+\t determine end as well, we cannot do this using gfc_dep_difference.\n+\t Fall back to the constants-only code then.  */\n+\n+      if (end == NULL)\n+\t{\n+\t  bool use_dep;\n+\n+\t  use_dep = gfc_dep_difference (ar->end[dimen], ar->start[dimen],\n+\t\t\t\t\t&diff);\n+\t  if (!use_dep && ar->end[dimen] == NULL && ar->start[dimen] == NULL)\n+\t    use_dep = gfc_dep_difference (ar->as->upper[dimen],\n+\t\t\t\t\t    ar->as->lower[dimen], &diff);\n+\n+\t  if (use_dep)\n+\t    {\n+\t      mpz_init (*result);\n+\t      mpz_add (*result, diff, stride);\n+\t      mpz_div (*result, *result, stride);\n+\t      if (mpz_cmp_ui (*result, 0) < 0)\n+\t\tmpz_set_ui (*result, 0);\n+\n+\t      mpz_clear (stride);\n+\t      mpz_clear (diff);\n+\t      return true;\n+\t    }\n+\n+\t}\n+\n+      /*  Constant-only code here, which covers more cases\n+\t  like a(:4) etc.  */\n       mpz_init (upper);\n       mpz_init (lower);\n-      mpz_init (stride);\n       t = false;\n \n       if (ar->start[dimen] == NULL)\n@@ -2163,15 +2218,6 @@ gfc_ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result, mpz_t *end)\n \t  mpz_set (upper, ar->end[dimen]->value.integer);\n \t}\n \n-      if (ar->stride[dimen] == NULL)\n-\tmpz_set_ui (stride, 1);\n-      else\n-\t{\n-\t  if (ar->stride[dimen]->expr_type != EXPR_CONSTANT)\n-\t    goto cleanup;\n-\t  mpz_set (stride, ar->stride[dimen]->value.integer);\n-\t}\n-\n       mpz_init (*result);\n       mpz_sub (*result, upper, lower);\n       mpz_add (*result, *result, stride);"}, {"sha": "d85905cb6b8fc50904a002a81251678f02267ff0", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "patch": "@@ -240,6 +240,46 @@ gfc_dep_compare_functions (gfc_expr *e1, gfc_expr *e2, bool impure_ok)\n \treturn -2;      \n }\n \n+/* Helper function to look through parens, unary plus and widening\n+   integer conversions.  */\n+\n+static gfc_expr*\n+discard_nops (gfc_expr *e)\n+{\n+  gfc_actual_arglist *arglist;\n+\n+  if (e == NULL)\n+    return NULL;\n+\n+  while (true)\n+    {\n+      if (e->expr_type == EXPR_OP\n+\t  && (e->value.op.op == INTRINSIC_UPLUS\n+\t      || e->value.op.op == INTRINSIC_PARENTHESES))\n+\t{\n+\t  e = e->value.op.op1;\n+\t  continue;\n+\t}\n+\n+      if (e->expr_type == EXPR_FUNCTION && e->value.function.isym\n+\t  && e->value.function.isym->id == GFC_ISYM_CONVERSION\n+\t  && e->ts.type == BT_INTEGER)\n+\t{\n+\t  arglist = e->value.function.actual;\n+\t  if (arglist->expr->ts.type == BT_INTEGER\n+\t      && e->ts.kind > arglist->expr->ts.kind)\n+\t    {\n+\t      e = arglist->expr;\n+\t      continue;\n+\t    }\n+\t}\n+      break;\n+    }\n+\n+  return e;\n+}\n+\n+\n /* Compare two expressions.  Return values:\n    * +1 if e1 > e2\n    * 0 if e1 == e2\n@@ -252,59 +292,13 @@ gfc_dep_compare_functions (gfc_expr *e1, gfc_expr *e2, bool impure_ok)\n int\n gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n {\n-  gfc_actual_arglist *args1;\n-  gfc_actual_arglist *args2;\n   int i;\n-  gfc_expr *n1, *n2;\n-\n-  n1 = NULL;\n-  n2 = NULL;\n \n   if (e1 == NULL && e2 == NULL)\n     return 0;\n \n-  /* Remove any integer conversion functions to larger types.  */\n-  if (e1->expr_type == EXPR_FUNCTION && e1->value.function.isym\n-      && e1->value.function.isym->id == GFC_ISYM_CONVERSION\n-      && e1->ts.type == BT_INTEGER)\n-    {\n-      args1 = e1->value.function.actual;\n-      if (args1->expr->ts.type == BT_INTEGER\n-\t  && e1->ts.kind > args1->expr->ts.kind)\n-\tn1 = args1->expr;\n-    }\n-\n-  if (e2->expr_type == EXPR_FUNCTION && e2->value.function.isym\n-      && e2->value.function.isym->id == GFC_ISYM_CONVERSION\n-      && e2->ts.type == BT_INTEGER)\n-    {\n-      args2 = e2->value.function.actual;\n-      if (args2->expr->ts.type == BT_INTEGER\n-\t  && e2->ts.kind > args2->expr->ts.kind)\n-\tn2 = args2->expr;\n-    }\n-\n-  if (n1 != NULL)\n-    {\n-      if (n2 != NULL)\n-\treturn gfc_dep_compare_expr (n1, n2);\n-      else\n-\treturn gfc_dep_compare_expr (n1, e2);\n-    }\n-  else\n-    {\n-      if (n2 != NULL)\n-\treturn gfc_dep_compare_expr (e1, n2);\n-    }\n-  \n-  if (e1->expr_type == EXPR_OP\n-      && (e1->value.op.op == INTRINSIC_UPLUS\n-\t  || e1->value.op.op == INTRINSIC_PARENTHESES))\n-    return gfc_dep_compare_expr (e1->value.op.op1, e2);\n-  if (e2->expr_type == EXPR_OP\n-      && (e2->value.op.op == INTRINSIC_UPLUS\n-\t  || e2->value.op.op == INTRINSIC_PARENTHESES))\n-    return gfc_dep_compare_expr (e1, e2->value.op.op1);\n+  e1 = discard_nops (e1);\n+  e2 = discard_nops (e2);\n \n   if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_PLUS)\n     {\n@@ -501,21 +495,6 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n }\n \n \n-/* Helper function to look through parens and unary plus.  */\n-\n-static gfc_expr*\n-discard_nops (gfc_expr *e)\n-{\n-\n-  while (e && e->expr_type == EXPR_OP\n-\t && (e->value.op.op == INTRINSIC_UPLUS\n-\t     || e->value.op.op == INTRINSIC_PARENTHESES))\n-    e = e->value.op.op1;\n-\n-  return e;\n-}\n-\n-\n /* Return the difference between two expressions.  Integer expressions of\n    the form \n "}, {"sha": "1d1e2742c69db31606a1bd503da3b5e911b85f02", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "patch": "@@ -1,3 +1,8 @@\n+2013-08-26  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/58146\n+\t* gfortran.dg/bounds_check_18.f90:  New test.\n+\n 2013-08-23  Jan Hubicka  <jh@suse.cz>\n \n \t* g++.dg/ipa/devirt-14.C: Fix typo."}, {"sha": "afd0503ef10cf254d4617000d5a017cd19373745", "filename": "gcc/testsuite/gfortran.dg/bounds_check_18.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd61b3c8b6bc6ff336995312e06748c602ec6dd/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_18.f90?ref=8cd61b3c8b6bc6ff336995312e06748c602ec6dd", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+program main\n+  implicit none\n+  integer :: n\n+  real, dimension(10) :: a\n+  n = 0\n+  call random_number(a)\n+  if (any(a(n+1:n+5) > [1.0, 2.0, 3.0])) print *,\"Hello!\" ! { dg-error \"not conformable\" }\n+end program main"}]}