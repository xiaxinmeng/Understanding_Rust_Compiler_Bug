{"sha": "ec09945c8ead3030ccf7739a685513e64e2e3539", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMwOTk0NWM4ZWFkMzAzMGNjZjc3MzlhNjg1NTEzZTY0ZTJlMzUzOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-30T15:03:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-30T15:03:46Z"}, "message": "* trans-expr.c: Remove trailing ^M.\n\nFrom-SVN: r100359", "tree": {"sha": "804e0a58b5a88cad817cf74457664789882e2d4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/804e0a58b5a88cad817cf74457664789882e2d4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec09945c8ead3030ccf7739a685513e64e2e3539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec09945c8ead3030ccf7739a685513e64e2e3539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec09945c8ead3030ccf7739a685513e64e2e3539", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec09945c8ead3030ccf7739a685513e64e2e3539/comments", "author": null, "committer": null, "parents": [{"sha": "771e816bd8b66ea06cba4614454ce70318c3bb72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771e816bd8b66ea06cba4614454ce70318c3bb72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/771e816bd8b66ea06cba4614454ce70318c3bb72"}], "stats": {"total": 106, "additions": 55, "deletions": 51}, "files": [{"sha": "74b3a437a5d821302983c04578b83cf0f862a7f5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec09945c8ead3030ccf7739a685513e64e2e3539/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec09945c8ead3030ccf7739a685513e64e2e3539/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ec09945c8ead3030ccf7739a685513e64e2e3539", "patch": "@@ -1,3 +1,7 @@\n+2005-05-30  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* trans-expr.c: Remove trailing ^M.\n+\n 2005-05-29  Janne Blomqvist  <jblomqvi@vipunen.hut.fi>\n             Steven G. Kargl  <kargls@comcast.net>\n   "}, {"sha": "9d48ed4a6488c492ffad3c5070e628f3892eda7b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec09945c8ead3030ccf7739a685513e64e2e3539/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec09945c8ead3030ccf7739a685513e64e2e3539/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ec09945c8ead3030ccf7739a685513e64e2e3539", "patch": "@@ -354,43 +354,43 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t      se->expr = gfc_build_addr_expr (NULL, se->expr);\n \t    }\n \t  return;\n-\t}\r\n-\n-\r\n-      /* Dereference the expression, where needed. Since characters\r\n-\t are entirely different from other types, they are treated \r\n-\t separately.  */\r\n-      if (sym->ts.type == BT_CHARACTER)\r\n-\t{\r\n-          /* Dereference character pointer dummy arguments\r\n+\t}\n+\n+\n+      /* Dereference the expression, where needed. Since characters\n+\t are entirely different from other types, they are treated \n+\t separately.  */\n+      if (sym->ts.type == BT_CHARACTER)\n+\t{\n+          /* Dereference character pointer dummy arguments\n \t     or results.  */\n-\t  if ((sym->attr.pointer || sym->attr.allocatable)\r\n-\t      && ((sym->attr.dummy)\r\n-\t\t  || (sym->attr.function\r\n-\t\t  || sym->attr.result)))\r\n-\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n-\t}\r\n-      else\r\n-\t{\r\n+\t  if ((sym->attr.pointer || sym->attr.allocatable)\n+\t      && ((sym->attr.dummy)\n+\t\t  || (sym->attr.function\n+\t\t  || sym->attr.result)))\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\n+\t}\n+      else\n+\t{\n           /* Dereference non-charcter scalar dummy arguments.  */\n-\t  if ((sym->attr.dummy) && (!sym->attr.dimension))\r\n-\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n-\r\n+\t  if ((sym->attr.dummy) && (!sym->attr.dimension))\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\n+\n           /* Dereference scalar hidden result.  */\n-\t  if ((gfc_option.flag_f2c && sym->ts.type == BT_COMPLEX)\r\n-\t      && (sym->attr.function || sym->attr.result)\r\n-\t      && (!sym->attr.dimension))\r\n-\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n-\r\n-          /* Dereference non-character pointer variables. \r\n+\t  if ((gfc_option.flag_f2c && sym->ts.type == BT_COMPLEX)\n+\t      && (sym->attr.function || sym->attr.result)\n+\t      && (!sym->attr.dimension))\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\n+\n+          /* Dereference non-character pointer variables. \n \t     These must be dummys or results or scalars.  */\n-\t  if ((sym->attr.pointer || sym->attr.allocatable)\r\n-\t      && ((sym->attr.dummy) \r\n-\t\t  || (sym->attr.function || sym->attr.result)\r\n-\t\t  || (!sym->attr.dimension)))\r\n-\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n-\t}\r\n-\r\n+\t  if ((sym->attr.pointer || sym->attr.allocatable)\n+\t      && ((sym->attr.dummy) \n+\t\t  || (sym->attr.function || sym->attr.result)\n+\t\t  || (!sym->attr.dimension)))\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\n+\t}\n+\n       ref = expr->ref;\n     }\n \n@@ -1136,8 +1136,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n       if (se->direct_byref) \n \t{\n \t  arglist = gfc_chainon_list (arglist, se->expr);\n-\r\n-\t  /* Add string length to argument list.  */\r\n+\n+\t  /* Add string length to argument list.  */\n \t  if (sym->ts.type == BT_CHARACTER)\n \t    {\n \t      sym->ts.cl->backend_decl = len;\n@@ -1147,11 +1147,11 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t}\n       else if (sym->result->attr.dimension)\n \t{\n-\t  gcc_assert (se->loop && se->ss);\r\n+\t  gcc_assert (se->loop && se->ss);\n \n \t  /* Set the type of the array.  */\n \t  tmp = gfc_typenode_for_spec (&sym->ts);\n-\t  info->dimen = se->loop->dimen;\r\n+\t  info->dimen = se->loop->dimen;\n \n \t  /* Allocate a temporary to store the result.  */\n \t  gfc_trans_allocate_temp_array (se->loop, info, tmp);\n@@ -1161,7 +1161,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t    gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n \t  gfc_add_modify_expr (&se->pre, tmp,\n \t\t\t       convert (TREE_TYPE (tmp), integer_zero_node));\n-\r\n+\n \t  /* Pass the temporary as the first argument.  */\n \t  tmp = info->descriptor;\n \t  tmp = gfc_build_addr_expr (NULL, tmp);\n@@ -1178,8 +1178,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t}\n       else if (sym->ts.type == BT_CHARACTER)\n \t{\n-\r\n-\t  /* Pass the string length.  */\r\n+\n+\t  /* Pass the string length.  */\n \t  sym->ts.cl->backend_decl = len;\n \t  type = gfc_get_character_type (sym->ts.kind, sym->ts.cl);\n \t  type = build_pointer_type (type);\n@@ -1188,18 +1188,18 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  if (sym->attr.pointer || sym->attr.allocatable)\n \t    {\n \t      /* Build char[4] * pstr.  */\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\r\n-\t\t\t\t convert (gfc_charlen_type_node, integer_one_node));\r\n-\t      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\r\n-\t      tmp = build_array_type (gfc_character1_type_node, tmp);\r\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\n+\t\t\t\t convert (gfc_charlen_type_node, integer_one_node));\n+\t      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n+\t      tmp = build_array_type (gfc_character1_type_node, tmp);\n \t      var = gfc_create_var (build_pointer_type (tmp), \"pstr\");\n \n-\t      /* Provide an address expression for the function arguments.  */\r\n-\t      var = gfc_build_addr_expr (NULL, var);\r\n+\t      /* Provide an address expression for the function arguments.  */\n+\t      var = gfc_build_addr_expr (NULL, var);\n \t    }\n \t  else\n \t    {\n-\t      var = gfc_conv_string_tmp (se, type, len);\r\n+\t      var = gfc_conv_string_tmp (se, type, len);\n \t    }\n \t  arglist = gfc_chainon_list (arglist, var);\n \t  arglist = gfc_chainon_list (arglist, \n@@ -1364,11 +1364,11 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      se->string_length = len;\n \t    }\n \t  else if (sym->ts.type == BT_CHARACTER)\n-\t    {\r\n+\t    {\n \t      /* Dereference for character pointer results.  */\n \t      if (sym->attr.pointer || sym->attr.allocatable)\n-\t\tse->expr = gfc_build_indirect_ref (var);\r\n-\t      else\r\n+\t\tse->expr = gfc_build_indirect_ref (var);\n+\t      else\n \t        se->expr = var;\n \n \t      se->string_length = len;\n@@ -2297,7 +2297,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     }\n   else\n     gfc_conv_expr (&lse, expr1);\n-\r\n+\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n   gfc_add_expr_to_block (&body, tmp);\n "}]}