{"sha": "35d6034bcb3fb342b49ad96088da16f995217c44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVkNjAzNGJjYjNmYjM0MmI0OWFkOTYwODhkYTE2Zjk5NTIxN2M0NA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-06-26T20:07:23Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-06-26T20:07:23Z"}, "message": "reload.c (can_reload_into): New function.\n\n\t* reload.c (can_reload_into): New function.\n\t(push_reload): Use it.\n\nFrom-SVN: r68542", "tree": {"sha": "db76991a87e963ae60ca8ba2deb25702ea376a21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db76991a87e963ae60ca8ba2deb25702ea376a21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35d6034bcb3fb342b49ad96088da16f995217c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d6034bcb3fb342b49ad96088da16f995217c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35d6034bcb3fb342b49ad96088da16f995217c44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d6034bcb3fb342b49ad96088da16f995217c44/comments", "author": null, "committer": null, "parents": [{"sha": "6f8507b13f187ed4d529fe34e13a0d738abfd14b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f8507b13f187ed4d529fe34e13a0d738abfd14b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f8507b13f187ed4d529fe34e13a0d738abfd14b"}], "stats": {"total": 244, "additions": 243, "deletions": 1}, "files": [{"sha": "735494437d493aae2cc69800d6a5a3103374fa02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35d6034bcb3fb342b49ad96088da16f995217c44", "patch": "@@ -1,3 +1,8 @@\n+2003-06-26  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* reload.c (can_reload_into): New function.\n+\t(push_reload): Use it.\n+\n 2003-06-26  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (compute_a_rotate_length): Fix the"}, {"sha": "7a2efa31f5d1c8b3b23ffac2c5722a088e8853f8", "filename": "gcc/reload.c", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=35d6034bcb3fb342b49ad96088da16f995217c44", "patch": "@@ -840,6 +840,56 @@ reload_inner_reg_of_subreg (x, mode, output)\n \t      != (int) HARD_REGNO_NREGS (REGNO (inner), GET_MODE (inner))));\n }\n \n+/* Return nonzero if IN can be reloaded into REGNO with mode MODE without\n+   requiring an extra reload register.  The caller has already found that\n+   IN contains some reference to REGNO, so check that we can produce the\n+   new value in a single step.  E.g. if we have\n+   (set (reg r13) (plus (reg r13) (const int 1))), and there is an\n+   instruction that adds one to a register, this should succeed.\n+   However, if we have something like\n+   (set (reg r13) (plus (reg r13) (const int 999))), and the constant 999\n+   needs to be loaded into a register first, we need a separate reload\n+   register.\n+   Such PLUS reloads are generated by find_reload_address_part.\n+   The out-of-range PLUS expressions are usually introduced in the instruction\n+   patterns by register elimination and substituting pseudos without a home\n+   by their function-invariant equivalences.  */\n+static int\n+can_reload_into (rtx in, int regno, enum machine_mode mode)\n+{\n+  rtx dst, test_insn;\n+  int r = 0;\n+  struct recog_data save_recog_data;\n+\n+  /* For matching constraints, we often get notional input reloads where\n+     we want to use the original register as the reload register.  I.e.\n+     technically this is a non-optional input-output reload, but IN is\n+     already a valid register, and has been chosen as the reload register.\n+     Speed this up, since it trivially works.  */\n+  if (GET_CODE (in) == REG)\n+    return 1;\n+\n+  /* To test MEMs properly, we'd have to take into account all the reloads\n+     that are already scheduled, which can become quite complicated.\n+     And since we've already handled address reloads for this MEM, it\n+     should always succeed anyway.  */\n+  if (GET_CODE (in) == MEM)\n+    return 1;\n+\n+  /* If we can make a simple SET insn that does the job, everything should\n+     be fine.  */\n+  dst =  gen_rtx_REG (mode, regno);\n+  test_insn = make_insn_raw (gen_rtx_SET (VOIDmode, dst, in));\n+  save_recog_data = recog_data;\n+  if (recog_memoized (test_insn) >= 0)\n+    {\n+      extract_insn (test_insn);\n+      r = constrain_operands (1);\n+    }\n+  recog_data = save_recog_data;\n+  return r;\n+}\n+\n /* Record one reload that needs to be performed.\n    IN is an rtx saying where the data are to be found before this instruction.\n    OUT says where they must be stored after the instruction.\n@@ -1532,7 +1582,11 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t\t\t  regno + offs))\n \t\tbreak;\n \n-\t    if (offs == nregs)\n+\t    if (offs == nregs\n+\t\t&& (! (refers_to_regno_for_reload_p\n+\t\t       (regno, (regno + HARD_REGNO_NREGS (regno, inmode)),\n+\t\t\t\tin, (rtx *)0))\n+\t\t    || can_reload_into (in, regno, inmode)))\n \t      {\n \t\trld[i].reg_rtx = gen_rtx_REG (rel_mode, regno);\n \t\tbreak;"}, {"sha": "df08e070e654b913e7379d9385b7e4a2c471d30e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35d6034bcb3fb342b49ad96088da16f995217c44", "patch": "@@ -1,5 +1,7 @@\n 2003-06-26  J\"orn Rennecke <joern.rennecke@superh.com>\n \n+\t* gcc.c-torture/execute/multi-ix.c: New test.\n+\n \t* gcc.c-torture/execute/simd-4.c (main):\n \tAdded missing semicolon at end of union.\n "}, {"sha": "71cdcb15988e254ed6164b7e9fba0210dbb1f4d2", "filename": "gcc/testsuite/gcc.c-torture/execute/multi-ix.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmulti-ix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35d6034bcb3fb342b49ad96088da16f995217c44/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmulti-ix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmulti-ix.c?ref=35d6034bcb3fb342b49ad96088da16f995217c44", "patch": "@@ -0,0 +1,181 @@\n+/* Test for a reload bug:\n+   if you have a memory reference using the indexed addressing\n+   mode, and the base address is a pseudo containing an address in the frame\n+   and this pseudo fails to get a hard register, we end up with a double PLUS,\n+   so the frame address gets reloaded.  Now, when the index got a hard register,\n+   and it dies in this insn, push_reload will consider that hard register as\n+   a reload register, and disregrad overlaps with rld[n_reloads].in .  That is\n+   fine as long as the add can be done with a single insn, but when the\n+   constant is so large that it has to be reloaded into a register first,\n+   that clobbers the index.  */\n+\n+#include <stdarg.h>\n+\n+#ifdef STACK_SIZE\n+#define CHUNK ((STACK_SIZE-100)/40/sizeof(int))\n+#else\n+#define CHUNK 500\n+#endif\n+\n+void s(int, ...);\n+void z(int, ...);\n+void c(int, ...);\n+\n+typedef int l[CHUNK];\n+\n+void\n+f (int n)\n+{\n+  int i;\n+  l a0, a1, a2, a3, a4, a5, a6, a7, a8, a9;\n+  l a10, a11, a12, a13, a14, a15, a16, a17, a18, a19;\n+  l a20, a21, a22, a23, a24, a25, a26, a27, a28, a29;\n+  l a30, a31, a32, a33, a34, a35, a36, a37, a38, a39;\n+  int i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+  int i10, i11, i12, i13, i14, i15, i16, i17, i18, i19;\n+  int i20, i21, i22, i23, i24, i25, i26, i27, i28, i29;\n+  int i30, i31, i32, i33, i34, i35, i36, i37, i38, i39;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      s (40, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9,\n+\t a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,\n+         a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,\n+         a30, a31, a32, a33, a34, a35, a36, a37, a38, a39);\n+      i0 = a0[0];\n+      i1 = a1[0];\n+      i2 = a2[0];\n+      i3 = a3[0];\n+      i4 = a4[0];\n+      i5 = a5[0];\n+      i6 = a6[0];\n+      i7 = a7[0];\n+      i8 = a8[0];\n+      i9 = a9[0];\n+      i10 = a10[0];\n+      i11 = a11[0];\n+      i12 = a12[0];\n+      i13 = a13[0];\n+      i14 = a14[0];\n+      i15 = a15[0];\n+      i16 = a16[0];\n+      i17 = a17[0];\n+      i18 = a18[0];\n+      i19 = a19[0];\n+      i20 = a20[0];\n+      i21 = a21[0];\n+      i22 = a22[0];\n+      i23 = a23[0];\n+      i24 = a24[0];\n+      i25 = a25[0];\n+      i26 = a26[0];\n+      i27 = a27[0];\n+      i28 = a28[0];\n+      i29 = a29[0];\n+      i30 = a30[0];\n+      i31 = a31[0];\n+      i32 = a32[0];\n+      i33 = a33[0];\n+      i34 = a34[0];\n+      i35 = a35[0];\n+      i36 = a36[0];\n+      i37 = a37[0];\n+      i38 = a38[0];\n+      i39 = a39[0];\n+      z (40, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9,\n+\t a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,\n+         a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,\n+         a30, a31, a32, a33, a34, a35, a36, a37, a38, a39);\n+      a0[i0] = i0;\n+      a1[i1] = i1;\n+      a2[i2] = i2;\n+      a3[i3] = i3;\n+      a4[i4] = i4;\n+      a5[i5] = i5;\n+      a6[i6] = i6;\n+      a7[i7] = i7;\n+      a8[i8] = i8;\n+      a9[i9] = i9;\n+      a10[i10] = i10;\n+      a11[i11] = i11;\n+      a12[i12] = i12;\n+      a13[i13] = i13;\n+      a14[i14] = i14;\n+      a15[i15] = i15;\n+      a16[i16] = i16;\n+      a17[i17] = i17;\n+      a18[i18] = i18;\n+      a19[i19] = i19;\n+      a20[i20] = i20;\n+      a21[i21] = i21;\n+      a22[i22] = i22;\n+      a23[i23] = i23;\n+      a24[i24] = i24;\n+      a25[i25] = i25;\n+      a26[i26] = i26;\n+      a27[i27] = i27;\n+      a28[i28] = i28;\n+      a29[i29] = i29;\n+      a30[i30] = i30;\n+      a31[i31] = i31;\n+      a32[i32] = i32;\n+      a33[i33] = i33;\n+      a34[i34] = i34;\n+      a35[i35] = i35;\n+      a36[i36] = i36;\n+      a37[i37] = i37;\n+      a38[i38] = i38;\n+      a39[i39] = i39;\n+      c (40, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9,\n+\t a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,\n+         a20, a21, a22, a23, a24, a25, a26, a27, a28, a29,\n+         a30, a31, a32, a33, a34, a35, a36, a37, a38, a39);\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  f (1);\n+  exit (0);\n+}\n+\n+void s(int n, ...)\n+{\n+  va_list list;\n+\n+  va_start (list, n);\n+  while (--n)\n+    {\n+      int *a = va_arg (list, int *);\n+      a[0] = n;\n+    }\n+  va_end (list);\n+}\n+\n+void z(int n, ...)\n+{\n+  va_list list;\n+\n+  va_start (list, n);\n+  while (--n)\n+    {\n+      int *a = va_arg (list, int *);\n+      bzero (a, sizeof (l));\n+    }\n+  va_end (list);\n+}\n+\n+void c(int n, ...)\n+{\n+  va_list list;\n+\n+  va_start (list, n);\n+  while (--n)\n+    {\n+      int *a = va_arg (list, int *);\n+      if (a[n] != n)\n+\tabort ();\n+    }\n+  va_end (list);\n+}"}]}