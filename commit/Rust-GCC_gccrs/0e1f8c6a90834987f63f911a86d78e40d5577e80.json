{"sha": "0e1f8c6a90834987f63f911a86d78e40d5577e80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUxZjhjNmE5MDgzNDk4N2Y2M2Y5MTFhODZkNzhlNDBkNTU3N2U4MA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-07-17T09:40:29Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-07-17T09:40:29Z"}, "message": "Fix PR61831: Side-effect variable component deallocation\n\ngcc/fortran/\n2015-07-17  Mikael Morin  <mikael@gcc.gnu.org>\n\t    Dominique d'Humieres  <dominiq@lps.ens.fr>\n\n\tPR fortran/61831\n\t* trans-array.c (gfc_conv_array_parameter): Guard allocatable\n\tcomponent deallocation code generation with descriptorless\n\tcalling convention flag.\n\t* trans-expr.c (gfc_conv_expr_reference): Remove allocatable\n\tcomponent deallocation code generation from revision 212329.\n\t(expr_may_alias_variables): New function.\n\t(gfc_conv_procedure_call): New boolean elemental_proc to factor\n\tcheck for procedure elemental-ness.  Rename boolean f to nodesc_arg\n\tand declare it in the outer scope.  Use expr_may_alias_variables,\n\telemental_proc and nodesc_arg to decide whether generate allocatable\n\tcomponent deallocation code.\n\t(gfc_trans_subarray_assign): Set deep copy flag.\n\ngcc/testsuite/\n2015-07-17  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/61831\n\t* gfortran.dg/alloc_comp_auto_array_3.f90: Count the number\n\tof generated while loops in the tree dump.\n\t* gfortran.dg/derived_constructor_comps_6.f90: New file.\n\n\nCo-Authored-By: Dominique d'Humieres <dominiq@lps.ens.fr>\n\nFrom-SVN: r225926", "tree": {"sha": "7078210f7a994805cf1f64553e2404f73464f23c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7078210f7a994805cf1f64553e2404f73464f23c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e1f8c6a90834987f63f911a86d78e40d5577e80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1f8c6a90834987f63f911a86d78e40d5577e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e1f8c6a90834987f63f911a86d78e40d5577e80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1f8c6a90834987f63f911a86d78e40d5577e80/comments", "author": null, "committer": null, "parents": [{"sha": "a6c51a129328343ba445f1cc663f455c173cdc97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c51a129328343ba445f1cc663f455c173cdc97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c51a129328343ba445f1cc663f455c173cdc97"}], "stats": {"total": 304, "additions": 258, "deletions": 46}, "files": [{"sha": "af81bd543f9234eb6f2b945db165c8443a743397", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0e1f8c6a90834987f63f911a86d78e40d5577e80", "patch": "@@ -1,3 +1,20 @@\n+2015-07-17  Mikael Morin  <mikael@gcc.gnu.org>\n+\t    Dominique d'Humieres  <dominiq@lps.ens.fr>\n+\n+\tPR fortran/61831\n+\t* trans-array.c (gfc_conv_array_parameter): Guard allocatable\n+\tcomponent deallocation code generation with descriptorless\n+\tcalling convention flag.\n+\t* trans-expr.c (gfc_conv_expr_reference): Remove allocatable\n+\tcomponent deallocation code generation from revision 212329.\n+\t(expr_may_alias_variables): New function.\n+\t(gfc_conv_procedure_call): New boolean elemental_proc to factor\n+\tcheck for procedure elemental-ness.  Rename boolean f to nodesc_arg\n+\tand declare it in the outer scope.  Use expr_may_alias_variables,\n+\telemental_proc and nodesc_arg to decide whether generate allocatable\n+\tcomponent deallocation code.\n+\t(gfc_trans_subarray_assign): Set deep copy flag.\n+\n 2015-07-16  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66724"}, {"sha": "1d5ddd0b68d047cbe7c4410549b4795f8ab7f311", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0e1f8c6a90834987f63f911a86d78e40d5577e80", "patch": "@@ -7395,10 +7395,11 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n     }\n \n   /* Deallocate the allocatable components of structures that are\n-     not variable.  */\n-  if ((expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)\n-\t&& expr->ts.u.derived->attr.alloc_comp\n-\t&& expr->expr_type != EXPR_VARIABLE)\n+     not variable, for descriptorless arguments.\n+     Arguments with a descriptor are handled in gfc_conv_procedure_call.  */\n+  if (g77 && (expr->ts.type == BT_DERIVED || expr->ts.type == BT_CLASS)\n+\t  && expr->ts.u.derived->attr.alloc_comp\n+\t  && expr->expr_type != EXPR_VARIABLE)\n     {\n       tmp = build_fold_indirect_ref_loc (input_location, se->expr);\n       tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, tmp, expr->rank);"}, {"sha": "caafe7672e82b71ee7076d02d8eeed8da569bf69", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 95, "deletions": 42, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0e1f8c6a90834987f63f911a86d78e40d5577e80", "patch": "@@ -4528,6 +4528,62 @@ conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)\n }\n \n \n+/* This function tells whether the middle-end representation of the expression\n+   E given as input may point to data otherwise accessible through a variable\n+   (sub-)reference.\n+   It is assumed that the only expressions that may alias are variables,\n+   and array constructors if ARRAY_MAY_ALIAS is true and some of its elements\n+   may alias.\n+   This function is used to decide whether freeing an expression's allocatable\n+   components is safe or should be avoided.\n+\n+   If ARRAY_MAY_ALIAS is true, an array constructor may alias if some of\n+   its elements are copied from a variable.  This ARRAY_MAY_ALIAS trick\n+   is necessary because for array constructors, aliasing depends on how\n+   the array is used:\n+    - If E is an array constructor used as argument to an elemental procedure,\n+      the array, which is generated through shallow copy by the scalarizer,\n+      is used directly and can alias the expressions it was copied from.\n+    - If E is an array constructor used as argument to a non-elemental\n+      procedure,the scalarizer is used in gfc_conv_expr_descriptor to generate\n+      the array as in the previous case, but then that array is used\n+      to initialize a new descriptor through deep copy.  There is no alias\n+      possible in that case.\n+   Thus, the ARRAY_MAY_ALIAS flag is necessary to distinguish the two cases\n+   above.  */\n+\n+static bool\n+expr_may_alias_variables (gfc_expr *e, bool array_may_alias)\n+{\n+  gfc_constructor *c;\n+\n+  if (e->expr_type == EXPR_VARIABLE)\n+    return true;\n+  else if (e->expr_type == EXPR_FUNCTION)\n+    {\n+      gfc_symbol *proc_ifc = gfc_get_proc_ifc_for_expr (e);\n+\n+      if ((proc_ifc->result->ts.type == BT_CLASS\n+\t   && proc_ifc->result->ts.u.derived->attr.is_class\n+\t   && CLASS_DATA (proc_ifc->result)->attr.class_pointer)\n+\t  || proc_ifc->result->attr.pointer)\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n+  else if (e->expr_type != EXPR_ARRAY || !array_may_alias)\n+    return false;\n+\n+  for (c = gfc_constructor_first (e->value.constructor);\n+       c; c = gfc_constructor_next (c))\n+    if (c->expr\n+\t&& expr_may_alias_variables (c->expr, array_may_alias))\n+      return true;\n+\n+  return false;\n+}\n+\n+\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.\n@@ -4580,9 +4636,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n   comp = gfc_get_proc_ptr_comp (expr);\n \n+  bool elemental_proc = (comp\n+\t\t\t && comp->ts.interface\n+\t\t\t && comp->ts.interface->attr.elemental)\n+\t\t\t|| (comp && comp->attr.elemental)\n+\t\t\t|| sym->attr.elemental;\n+\n   if (se->ss != NULL)\n     {\n-      if (!sym->attr.elemental && !(comp && comp->attr.elemental))\n+      if (!elemental_proc)\n \t{\n \t  gcc_assert (se->ss->info->type == GFC_SS_FUNCTION);\n \t  if (se->ss->info->useflags)\n@@ -4639,6 +4701,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       fsym = formal ? formal->sym : NULL;\n       parm_kind = MISSING;\n \n+      /* If the procedure requires an explicit interface, the actual\n+\t argument is passed according to the corresponding formal\n+\t argument.  If the corresponding formal argument is a POINTER,\n+\t ALLOCATABLE or assumed shape, we do not use g77's calling\n+\t convention, and pass the address of the array descriptor\n+\t instead.  Otherwise we use g77's calling convention, in other words\n+\t pass the array data pointer without descriptor.  */\n+      bool nodesc_arg = fsym != NULL\n+\t\t\t&& !(fsym->attr.pointer || fsym->attr.allocatable)\n+\t\t\t&& fsym->as\n+\t\t\t&& fsym->as->type != AS_ASSUMED_SHAPE\n+\t\t\t&& fsym->as->type != AS_ASSUMED_RANK;\n+      if (comp)\n+\tnodesc_arg = nodesc_arg || !comp->attr.always_explicit;\n+      else\n+\tnodesc_arg = nodesc_arg || !sym->attr.always_explicit;\n+\n       /* Class array expressions are sometimes coming completely unadorned\n \t with either arrayspec or _data component.  Correct that here.\n \t OOP-TODO: Move this to the frontend.  */\n@@ -5165,22 +5244,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    }\n \t  else\n \t    {\n-              /* If the procedure requires an explicit interface, the actual\n-                 argument is passed according to the corresponding formal\n-                 argument.  If the corresponding formal argument is a POINTER,\n-                 ALLOCATABLE or assumed shape, we do not use g77's calling\n-                 convention, and pass the address of the array descriptor\n-                 instead. Otherwise we use g77's calling convention.  */\n-\t      bool f;\n-\t      f = (fsym != NULL)\n-\t\t  && !(fsym->attr.pointer || fsym->attr.allocatable)\n-\t\t  && fsym->as && fsym->as->type != AS_ASSUMED_SHAPE\n-\t\t  && fsym->as->type != AS_ASSUMED_RANK;\n-\t      if (comp)\n-\t\tf = f || !comp->attr.always_explicit;\n-\t      else\n-\t\tf = f || !sym->attr.always_explicit;\n-\n \t      /* If the argument is a function call that may not create\n \t\t a temporary for the result, we have to check that we\n \t\t can do it, i.e. that there is no alias between this\n@@ -5225,7 +5288,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t   array of derived types.  In this case, the argument\n \t\t   is converted to a temporary, which is passed and then\n \t\t   written back after the procedure call.  */\n-\t\tgfc_conv_subref_array_arg (&parmse, e, f,\n+\t\tgfc_conv_subref_array_arg (&parmse, e, nodesc_arg,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n \t      else if (gfc_is_class_array_ref (e, NULL)\n@@ -5237,7 +5300,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t   OOP-TODO: Insert code so that if the dynamic type is\n \t\t   the same as the declared type, copy-in/copy-out does\n \t\t   not occur.  */\n-\t\tgfc_conv_subref_array_arg (&parmse, e, f,\n+\t\tgfc_conv_subref_array_arg (&parmse, e, nodesc_arg,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n \n@@ -5248,12 +5311,13 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t   intent in.  */\n \t\t{\n \t\t  e->must_finalize = 1;\n-\t\t  gfc_conv_subref_array_arg (&parmse, e, f,\n+\t\t  gfc_conv_subref_array_arg (&parmse, e, nodesc_arg,\n \t\t\t\t\t     INTENT_IN,\n \t\t\t\t\t     fsym && fsym->attr.pointer);\n \t\t}\n \t      else\n-\t        gfc_conv_array_parameter (&parmse, e, f, fsym, sym->name, NULL);\n+\t\tgfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,\n+\t\t\t\t\t  sym->name, NULL);\n \n \t      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is\n \t\t allocated on entry, it must be deallocated.  */\n@@ -5295,7 +5359,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t     but do not always set fsym.  */\n \t  if (e->expr_type == EXPR_VARIABLE\n \t      && e->symtree->n.sym->attr.optional\n-\t      && ((e->rank != 0 && sym->attr.elemental)\n+\t      && ((e->rank != 0 && elemental_proc)\n \t\t  || e->representation.length || e->ts.type == BT_CHARACTER\n \t\t  || (e->rank != 0\n \t\t      && (fsym == NULL\n@@ -5330,13 +5394,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       gfc_add_block_to_block (&post, &parmse.post);\n \n       /* Allocated allocatable components of derived types must be\n-\t deallocated for non-variable scalars.  Non-variable arrays are\n-\t dealt with in trans-array.c(gfc_conv_array_parameter).  */\n+\t deallocated for non-variable scalars, array arguments to elemental\n+\t procedures, and array arguments with descriptor to non-elemental\n+\t procedures.  As bounds information for descriptorless arrays is no\n+\t longer available here, they are dealt with in trans-array.c\n+\t (gfc_conv_array_parameter).  */\n       if (e && (e->ts.type == BT_DERIVED || e->ts.type == BT_CLASS)\n \t    && e->ts.u.derived->attr.alloc_comp\n-\t    && !(e->symtree && e->symtree->n.sym->attr.pointer)\n-\t    && e->expr_type != EXPR_VARIABLE && !e->rank)\n-        {\n+\t    && (e->rank == 0 || elemental_proc || !nodesc_arg)\n+\t    && !expr_may_alias_variables (e, elemental_proc))\n+\t{\n \t  int parm_rank;\n \t  /* It is known the e returns a structure type with at least one\n \t     allocatable component.  When e is a function, ensure that the\n@@ -6674,7 +6741,7 @@ gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \n   gfc_conv_expr (&rse, expr);\n \n-  tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts, true, false, true);\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts, true, true, true);\n   gfc_add_expr_to_block (&body, tmp);\n \n   gcc_assert (rse.ss == gfc_ss_terminator);\n@@ -7545,20 +7612,6 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n \n   /* Take the address of that value.  */\n   se->expr = gfc_build_addr_expr (NULL_TREE, var);\n-  if (expr->ts.type == BT_DERIVED && expr->rank\n-      && !gfc_is_finalizable (expr->ts.u.derived, NULL)\n-      && expr->ts.u.derived->attr.alloc_comp\n-      && expr->expr_type != EXPR_VARIABLE)\n-    {\n-      tree tmp;\n-\n-      tmp = build_fold_indirect_ref_loc (input_location, se->expr);\n-      tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, tmp, expr->rank);\n-\n-      /* The components shall be deallocated before\n-         their containing entity.  */\n-      gfc_prepend_expr_to_block (&se->post, tmp);\n-    }\n }\n \n "}, {"sha": "ccba51fb38aa28d1a68bb2a00f5bc9d08c1eb8b6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e1f8c6a90834987f63f911a86d78e40d5577e80", "patch": "@@ -1,3 +1,10 @@\n+2015-07-17  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/61831\n+\t* gfortran.dg/alloc_comp_auto_array_3.f90: Count the number\n+\tof generated while loops in the tree dump.\n+\t* gfortran.dg/derived_constructor_components_6.f90: New file.\n+\n 2015-07-17  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \t* gcc.dg/vect/vect-outer-simd-2.c: New test."}, {"sha": "b135d3d56e4477648cf0063cc694eec25b7d34b1", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_auto_array_3.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_auto_array_3.f90?ref=0e1f8c6a90834987f63f911a86d78e40d5577e80", "patch": "@@ -27,3 +27,4 @@ function bar_1d () result (array)\n end\n ! { dg-final { scan-tree-dump-times \"builtin_malloc\" 3 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"builtin_free\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"while \\\\(1\\\\)\" 4 \"original\" } }"}, {"sha": "f9fbcb1514556cd8ad63d27fd033d3407e1232b7", "filename": "gcc/testsuite/gfortran.dg/derived_constructor_comps_6.f90", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1f8c6a90834987f63f911a86d78e40d5577e80/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_constructor_comps_6.f90?ref=0e1f8c6a90834987f63f911a86d78e40d5577e80", "patch": "@@ -0,0 +1,133 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fsanitize=address -fdump-tree-original\"\n+!\n+! PR fortran/61831\n+! The deallocation of components of array constructor elements\n+! used to have the side effect of also deallocating some other\n+! variable's components from which they were copied.\n+\n+program main\n+  implicit none\n+\n+  integer, parameter :: n = 2\n+\n+  type :: string_t\n+     character(LEN=1), dimension(:), allocatable :: chars\n+  end type string_t\n+\n+  type :: string_container_t\n+     type(string_t) :: comp\n+  end type string_container_t\n+\n+  type :: string_array_container_t\n+     type(string_t) :: comp(n)\n+  end type string_array_container_t\n+\n+  type(string_t) :: prt_in, tmp, tmpa(n)\n+  type(string_container_t) :: tmpc, tmpca(n)\n+  type(string_array_container_t) :: tmpac, tmpaca(n)\n+  integer :: i, j, k\n+\n+  do i=1,16\n+\n+     ! Test without intermediary function\n+     prt_in = string_t([\"A\"])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"A\")) call abort\n+     deallocate (prt_in%chars)\n+\n+     ! scalar elemental function\n+     prt_in = string_t([\"B\"])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"B\")) call abort\n+     tmp = new_prt_spec (prt_in)\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"B\")) call abort\n+     deallocate (prt_in%chars)\n+     deallocate (tmp%chars)\n+\n+     ! array elemental function with array constructor\n+     prt_in = string_t([\"C\"])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"C\")) call abort\n+     tmpa = new_prt_spec ([(prt_in, i=1,2)])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"C\")) call abort\n+     deallocate (prt_in%chars)\n+     do j=1,n\n+        deallocate (tmpa(j)%chars)\n+     end do\n+\n+     ! scalar elemental function with structure constructor\n+     prt_in = string_t([\"D\"])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"D\")) call abort\n+     tmpc = new_prt_spec2 (string_container_t(prt_in))\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"D\")) call abort\n+     deallocate (prt_in%chars)\n+     deallocate(tmpc%comp%chars)\n+\n+     ! array elemental function of an array constructor of structure constructors\n+     prt_in = string_t([\"E\"])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"E\")) call abort\n+     tmpca = new_prt_spec2 ([ (string_container_t(prt_in), i=1,2) ])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"E\")) call abort\n+     deallocate (prt_in%chars)\n+     do j=1,n\n+        deallocate (tmpca(j)%comp%chars)\n+     end do\n+\n+     ! scalar elemental function with a structure constructor and a nested array constructor\n+     prt_in = string_t([\"F\"])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"F\")) call abort\n+     tmpac = new_prt_spec3 (string_array_container_t([ (prt_in, i=1,2) ]))\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"F\")) call abort\n+     deallocate (prt_in%chars)\n+     do j=1,n\n+        deallocate (tmpac%comp(j)%chars)\n+     end do\n+\n+     ! array elemental function with an array constructor nested inside\n+     ! a structure constructor nested inside  an array constructor\n+     prt_in = string_t([\"G\"])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"G\")) call abort\n+     tmpaca = new_prt_spec3 ([ (string_array_container_t([ (prt_in, i=1,2) ]), j=1,2) ])\n+     if (.not. allocated(prt_in%chars)) call abort\n+     if (any(prt_in%chars .ne. \"G\")) call abort\n+     deallocate (prt_in%chars)\n+     do j=1,n\n+        do k=1,n\n+           deallocate (tmpaca(j)%comp(k)%chars)\n+        end do\n+     end do\n+\n+  end do\n+\n+contains\n+\n+  elemental function new_prt_spec (name) result (prt_spec)\n+    type(string_t), intent(in) :: name\n+    type(string_t) :: prt_spec\n+    prt_spec = name\n+  end function new_prt_spec\n+\n+  elemental function new_prt_spec2 (name) result (prt_spec)\n+    type(string_container_t), intent(in) :: name\n+    type(string_container_t) :: prt_spec\n+    prt_spec = name\n+  end function new_prt_spec2\n+\n+  elemental function new_prt_spec3 (name) result (prt_spec)\n+    type(string_array_container_t), intent(in) :: name\n+    type(string_array_container_t) :: prt_spec\n+    prt_spec = name\n+  end function new_prt_spec3\n+end program main\n+! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 15 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 33 \"original\" } }"}]}