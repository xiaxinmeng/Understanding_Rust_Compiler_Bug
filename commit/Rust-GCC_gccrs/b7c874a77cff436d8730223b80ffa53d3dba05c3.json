{"sha": "b7c874a77cff436d8730223b80ffa53d3dba05c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdjODc0YTc3Y2ZmNDM2ZDg3MzAyMjNiODBmZmE1M2QzZGJhMDVjMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T09:58:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T09:58:06Z"}, "message": "[multiple changes]\n\n2014-07-31  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Enable_Overflow_Check): More precise setting of\n\tDo_Overflow_Check flag for division.\n\n2014-07-31  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Reject packed\n\tarray types with implementation type.\n\n2014-07-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch10.adb (Process_State): Remove local variable Name. Add\n\tlocal variable Decl. Partially declare an abstract state by\n\tgenerating an entity and storing it in the state declaration.\n\t* sem_prag.adb (Create_Abstract_State): Fully declare a\n\tsemi-declared abstract state.\n\nFrom-SVN: r213335", "tree": {"sha": "7e48781eb00a70bb90b702a951747b8b6beaa8e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e48781eb00a70bb90b702a951747b8b6beaa8e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7c874a77cff436d8730223b80ffa53d3dba05c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c874a77cff436d8730223b80ffa53d3dba05c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c874a77cff436d8730223b80ffa53d3dba05c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c874a77cff436d8730223b80ffa53d3dba05c3/comments", "author": null, "committer": null, "parents": [{"sha": "e1360f501bd99b198e997e1ce2f22231dfc9b69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1360f501bd99b198e997e1ce2f22231dfc9b69d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1360f501bd99b198e997e1ce2f22231dfc9b69d"}], "stats": {"total": 144, "additions": 118, "deletions": 26}, "files": [{"sha": "bd7154fbdf5d490a4ded2936a205eac7c9d92ea4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b7c874a77cff436d8730223b80ffa53d3dba05c3", "patch": "@@ -1,3 +1,21 @@\n+2014-07-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Enable_Overflow_Check): More precise setting of\n+\tDo_Overflow_Check flag for division.\n+\n+2014-07-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Reject packed\n+\tarray types with implementation type.\n+\n+2014-07-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch10.adb (Process_State): Remove local variable Name. Add\n+\tlocal variable Decl. Partially declare an abstract state by\n+\tgenerating an entity and storing it in the state declaration.\n+\t* sem_prag.adb (Create_Abstract_State): Fully declare a\n+\tsemi-declared abstract state.\n+\n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n \n \t* prj-nmsc.adb: Minor reformatting."}, {"sha": "f75f1c6f2e2fc28aa7a3bf46442171caca96d4ec", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b7c874a77cff436d8730223b80ffa53d3dba05c3", "patch": "@@ -1795,6 +1795,8 @@ package body Checks is\n          if Do_Overflow_Check (N)\n            and then not Overflow_Checks_Suppressed (Etype (N))\n          then\n+            Set_Do_Overflow_Check (N, False);\n+\n             --  Test for extremely annoying case of xxx'First divided by -1\n             --  for division of signed integer types (only overflow case).\n \n@@ -1855,6 +1857,8 @@ package body Checks is\n          --  it is a Division_Check and not an Overflow_Check.\n \n          if Do_Division_Check (N) then\n+            Set_Do_Division_Check (N, False);\n+\n             if (not ROK) or else (Rlo <= 0 and then 0 <= Rhi) then\n                Insert_Action (N,\n                  Make_Raise_Constraint_Error (Loc,\n@@ -5110,6 +5114,8 @@ package body Checks is\n       Lo   : Uint;\n       Hi   : Uint;\n \n+      Do_Ovflow_Check : Boolean;\n+\n    begin\n       if Debug_Flag_CC then\n          w (\"Enable_Overflow_Check for node \", Int (N));\n@@ -5187,15 +5193,52 @@ package body Checks is\n          --   c) The alternative is a lot of special casing in this routine\n          --      which would partially duplicate Determine_Range processing.\n \n-         if OK\n-           and then Lo > Expr_Value (Type_Low_Bound  (Typ))\n-           and then Hi < Expr_Value (Type_High_Bound (Typ))\n-         then\n-            if Debug_Flag_CC then\n-               w (\"No overflow check required\");\n+         if OK then\n+            Do_Ovflow_Check := True;\n+\n+            --  Note that the following checks are quite deliberately > and <\n+            --  rather than >= and <= as explained above.\n+\n+            if  Lo > Expr_Value (Type_Low_Bound  (Typ))\n+                  and then\n+                Hi < Expr_Value (Type_High_Bound (Typ))\n+            then\n+               Do_Ovflow_Check := False;\n+\n+            --  Despite the comments above, it is worth dealing specially with\n+            --  division specially. The only case where integer division can\n+            --  overflow is (largest negative number) / (-1). So we will do\n+            --  an extra range analysis to see if this is possible.\n+\n+            elsif Nkind (N) = N_Op_Divide then\n+               Determine_Range\n+                 (Left_Opnd (N), OK, Lo, Hi, Assume_Valid => True);\n+\n+               if OK and then Lo > Expr_Value (Type_Low_Bound (Typ)) then\n+                  Do_Ovflow_Check := False;\n+\n+               else\n+                  Determine_Range\n+                    (Right_Opnd (N), OK, Lo, Hi, Assume_Valid => True);\n+\n+                  if OK and then (Lo > Uint_Minus_1\n+                                    or else\n+                                  Hi < Uint_Minus_1)\n+                  then\n+                     Do_Ovflow_Check := False;\n+                  end if;\n+               end if;\n             end if;\n \n-            return;\n+            --  If no overflow check required, we are done\n+\n+            if not Do_Ovflow_Check then\n+               if Debug_Flag_CC then\n+                  w (\"No overflow check required\");\n+               end if;\n+\n+               return;\n+            end if;\n          end if;\n       end if;\n "}, {"sha": "19debb301af52aece1a9c76063fba366d251738c", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=b7c874a77cff436d8730223b80ffa53d3dba05c3", "patch": "@@ -4039,13 +4039,15 @@ package body Exp_Aggr is\n \n       --    1. N consists of a single OTHERS choice, possibly recursively\n \n-      --    2. The array type has no atomic components\n+      --    2. The array type is not packed\n \n-      --    3. The component type is discrete\n+      --    3. The array type has no atomic components\n \n-      --    4. The component size is a multiple of Storage_Unit\n+      --    4. The component type is discrete\n \n-      --    5. The component size is Storage_Unit or the value is of the form\n+      --    5. The component size is a multiple of Storage_Unit\n+\n+      --    6. The component size is Storage_Unit or the value is of the form\n       --       M * (1 + A**1 + A**2 + .. A**(K-1)) where A = 2**(Storage_Unit)\n       --       and M in 1 .. A-1. This can also be viewed as K occurrences of\n       --       the 8-bit value M, concatenated together.\n@@ -4071,6 +4073,10 @@ package body Exp_Aggr is\n                return False;\n             end if;\n \n+            if Present (Packed_Array_Impl_Type (Ctyp)) then\n+               return False;\n+            end if;\n+\n             if Has_Atomic_Components (Ctyp) then\n                return False;\n             end if;\n@@ -4119,7 +4125,7 @@ package body Exp_Aggr is\n             Value := Value - Expr_Value (Type_Low_Bound (Ctyp));\n          end if;\n \n-         --  0 and -1 immediately satisfy check #5\n+         --  0 and -1 immediately satisfy the last check\n \n          if Value = Uint_0 or else Value = Uint_Minus_1 then\n             return True;"}, {"sha": "aea29d098fe459fbd9328f9274c22fa5c42f576e", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=b7c874a77cff436d8730223b80ffa53d3dba05c3", "patch": "@@ -5695,10 +5695,10 @@ package body Sem_Ch10 is\n \n             procedure Process_State (State : Node_Id) is\n                Loc   : constant Source_Ptr := Sloc (State);\n+               Decl  : Node_Id;\n+               Dummy : Entity_Id;\n                Elmt  : Node_Id;\n                Id    : Entity_Id;\n-               Name  : Name_Id;\n-               Dummy : Entity_Id;\n \n             begin\n                --  Multiple abstract states appear as an aggregate\n@@ -5721,27 +5721,39 @@ package body Sem_Ch10 is\n                --  extension aggregate.\n \n                elsif Nkind (State) = N_Extension_Aggregate then\n-                  Name := Chars (Ancestor_Part (State));\n+                  Decl := Ancestor_Part (State);\n \n                --  Simple state declaration\n \n                elsif Nkind (State) = N_Identifier then\n-                  Name := Chars (State);\n+                  Decl := State;\n \n                --  Possibly an illegal state declaration\n \n                else\n                   return;\n                end if;\n \n-               --  Construct a dummy state for the purposes of establishing a\n-               --  non-limited => limited view relation. Note that the dummy\n-               --  state is not added to list Abstract_States to avoid multiple\n-               --  definitions.\n+               --  Abstract states are elaborated when the related pragma is\n+               --  elaborated. Since the withed package is not analyzed yet,\n+               --  the entities of the abstract states are not available. To\n+               --  overcome this complication, create the entities now and\n+               --  store them in their respective declarations. The entities\n+               --  are later used by routine Create_Abstract_State to declare\n+               --  and enter the states into visibility.\n+\n+               if No (Entity (Decl)) then\n+                  Id := Make_Defining_Identifier (Loc, Chars (Decl));\n+\n+                  Set_Entity     (Decl, Id);\n+                  Set_Parent     (Id, State);\n+                  Decorate_State (Id, Scop);\n \n-               Id := Make_Defining_Identifier (Loc, New_External_Name (Name));\n-               Set_Parent     (Id, State);\n-               Decorate_State (Id, Scop);\n+               --  Otherwise the package was previously withed\n+\n+               else\n+                  Id := Entity (Decl);\n+               end if;\n \n                Build_Shadow_Entity (Id, Scop, Dummy);\n             end Process_State;"}, {"sha": "10ffab9d5b09ef68711d517200e146b747a40a60", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7c874a77cff436d8730223b80ffa53d3dba05c3/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b7c874a77cff436d8730223b80ffa53d3dba05c3", "patch": "@@ -10519,10 +10519,23 @@ package body Sem_Prag is\n                   Is_Null : Boolean)\n                is\n                begin\n-                  --  The generated state abstraction reuses the same chars\n-                  --  from the original state declaration. Decorate the entity.\n+                  --  The abstract state may be semi-declared when the related\n+                  --  package was withed through a limited with clause. In that\n+                  --  case reuse the entity to fully declare the state.\n \n-                  State_Id := Make_Defining_Identifier (Loc, Nam);\n+                  if Present (Decl) and then Present (Entity (Decl)) then\n+                     State_Id := Entity (Decl);\n+\n+                  --  Otherwise the elaboration of pragma Abstract_State\n+                  --  declares the state.\n+\n+                  else\n+                     State_Id := Make_Defining_Identifier (Loc, Nam);\n+\n+                     if Present (Decl) then\n+                        Set_Entity (Decl, State_Id);\n+                     end if;\n+                  end if;\n \n                   --  Null states never come from source\n "}]}