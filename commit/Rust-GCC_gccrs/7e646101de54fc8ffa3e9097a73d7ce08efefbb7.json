{"sha": "7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U2NDYxMDFkZTU0ZmM4ZmZhM2U5MDk3YTczZDdjZTA4ZWZlZmJiNw==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2006-02-17T22:19:05Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2006-02-17T22:19:05Z"}, "message": "re PR target/26255 (internal compiler error: in reload_cse_simplify_operands, at postreload.c:391)\n\n\tPR target/26255\n\t* pa.md: Create separate HI and QI move patterns for 32-bit and 64-bit\n\twith hardware float support, and software float support.  Add fcpy\n\talternative to hardware patterns.  Add alternatives to copy between\n\tgeneral and floating-point registers to the 32-bit pattern.\n\t* pa.c (pa_secondary_reload): Don't abort if reload tries to find a\n\tsecondary reload to load a QI or HI mode constant into a floating\n\tpoint register. \n\t* pa32-regs.h (VALID_FP_MODE_P): Allow QImode and HImode.\n\t* pa64-regs.h (VALID_FP_MODE_P): Likewise.\n\nFrom-SVN: r111214", "tree": {"sha": "93a8730db7dc286303ddafcad044b3fdecc4e637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a8730db7dc286303ddafcad044b3fdecc4e637"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/comments", "author": null, "committer": null, "parents": [{"sha": "1435ba17b5c4070038cb8116e428a9c899882b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1435ba17b5c4070038cb8116e428a9c899882b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1435ba17b5c4070038cb8116e428a9c899882b8b"}], "stats": {"total": 134, "additions": 123, "deletions": 11}, "files": [{"sha": "25d45d6b3efee551aade8271ad772451dc127c9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "patch": "@@ -1,3 +1,16 @@\n+2006-02-17  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/26255\n+\t* pa.md: Create separate HI and QI move patterns for 32-bit and 64-bit\n+\twith hardware float support, and software float support.  Add fcpy\n+\talternative to hardware patterns.  Add alternatives to copy between\n+\tgeneral and floating-point registers to the 32-bit pattern.\n+\t* pa.c (pa_secondary_reload): Don't abort if reload tries to find a\n+\tsecondary reload to load a QI or HI mode constant into a floating\n+\tpoint register. \n+\t* pa32-regs.h (VALID_FP_MODE_P): Allow QImode and HImode.\n+\t* pa64-regs.h (VALID_FP_MODE_P): Likewise.\n+\n 2006-02-17  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR target/26272"}, {"sha": "2fbb4194448412fcdd419cb4a2f4e8a17925ba82", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "patch": "@@ -5630,11 +5630,10 @@ pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n   /* Trying to load a constant into a FP register during PIC code\n      generation requires %r1 as a scratch register.  */\n   if (flag_pic\n-      && GET_MODE_CLASS (mode) == MODE_INT\n+      && (mode == SImode || mode == DImode)\n       && FP_REG_CLASS_P (class)\n       && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n     {\n-      gcc_assert (mode == SImode || mode == DImode);\n       sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1\n \t\t    : CODE_FOR_reload_indi_r1);\n       return NO_REGS;"}, {"sha": "8844d26a3c516e24b7112adf2b3b1efe5fb66b71", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 102, "deletions": 4, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "patch": "@@ -2947,13 +2947,62 @@\n     DONE;\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"move_dest_operand\"\n+\t \t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f,!r,!f\")\n+\t(match_operand:HI 1 \"move_src_operand\"\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM,!f,!r\"))]\n+  \"(register_operand (operands[0], HImode)\n+    || reg_or_0_operand (operands[1], HImode))\n+   && !TARGET_SOFT_FLOAT\n+   && !TARGET_64BIT\"\n+  \"@\n+   copy %1,%0\n+   ldi %1,%0\n+   ldil L'%1,%0\n+   {zdepi|depwi,z} %Z1,%0\n+   ldh%M1 %1,%0\n+   sth%M0 %r1,%0\n+   mtsar %r1\n+   {mfctl|mfctl,w} %sar,%0\n+   fcpy,sgl %f1,%0\n+   {fstws|fstw} %1,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\n+   {stws|stw} %1,-16(%%sp)\\n\\t{fldws|fldw} -16(%%sp),%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move,move,move\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"move_dest_operand\"\n+\t \t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f\")\n+\t(match_operand:HI 1 \"move_src_operand\"\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM\"))]\n+  \"(register_operand (operands[0], HImode)\n+    || reg_or_0_operand (operands[1], HImode))\n+   && !TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\"\n+  \"@\n+   copy %1,%0\n+   ldi %1,%0\n+   ldil L'%1,%0\n+   {zdepi|depwi,z} %Z1,%0\n+   ldh%M1 %1,%0\n+   sth%M0 %r1,%0\n+   mtsar %r1\n+   {mfctl|mfctl,w} %sar,%0\n+   fcpy,sgl %f1,%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"move_dest_operand\"\n \t \t\t  \"=r,r,r,r,r,Q,!*q,!r\")\n \t(match_operand:HI 1 \"move_src_operand\"\n \t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q\"))]\n-  \"register_operand (operands[0], HImode)\n-   || reg_or_0_operand (operands[1], HImode)\"\n+  \"(register_operand (operands[0], HImode)\n+    || reg_or_0_operand (operands[1], HImode))\n+   && TARGET_SOFT_FLOAT\"\n   \"@\n    copy %1,%0\n    ldi %1,%0\n@@ -3071,13 +3120,62 @@\n     DONE;\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f,!r,!f\")\n+\t(match_operand:QI 1 \"move_src_operand\"\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM,!f,!r\"))]\n+  \"(register_operand (operands[0], QImode)\n+    || reg_or_0_operand (operands[1], QImode))\n+   && !TARGET_SOFT_FLOAT\n+   && !TARGET_64BIT\"\n+  \"@\n+   copy %1,%0\n+   ldi %1,%0\n+   ldil L'%1,%0\n+   {zdepi|depwi,z} %Z1,%0\n+   ldb%M1 %1,%0\n+   stb%M0 %r1,%0\n+   mtsar %r1\n+   {mfctl|mfctl,w} %%sar,%0\n+   fcpy,sgl %f1,%0\n+   {fstws|fstw} %1,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\n+   {stws|stw} %1,-16(%%sp)\\n\\t{fldws|fldw} -16(%%sp),%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move,move,move\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f\")\n+\t(match_operand:QI 1 \"move_src_operand\"\n+\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM\"))]\n+  \"(register_operand (operands[0], QImode)\n+    || reg_or_0_operand (operands[1], QImode))\n+   && !TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\"\n+  \"@\n+   copy %1,%0\n+   ldi %1,%0\n+   ldil L'%1,%0\n+   {zdepi|depwi,z} %Z1,%0\n+   ldb%M1 %1,%0\n+   stb%M0 %r1,%0\n+   mtsar %r1\n+   {mfctl|mfctl,w} %%sar,%0\n+   fcpy,sgl %f1,%0\"\n+  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"move_dest_operand\"\n \t\t\t  \"=r,r,r,r,r,Q,!*q,!r\")\n \t(match_operand:QI 1 \"move_src_operand\"\n \t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q\"))]\n-  \"register_operand (operands[0], QImode)\n-   || reg_or_0_operand (operands[1], QImode)\"\n+  \"(register_operand (operands[0], QImode)\n+    || reg_or_0_operand (operands[1], QImode))\n+   && TARGET_SOFT_FLOAT\"\n   \"@\n    copy %1,%0\n    ldi %1,%0"}, {"sha": "a17c117726a4ae5c436faddb1cc84929b7f0a510", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "patch": "@@ -172,7 +172,8 @@\n #define VALID_FP_MODE_P(MODE)\t\t\t\t\t\t\\\n   ((MODE) == SFmode || (MODE) == DFmode\t\t\t\t\t\\\n    || (MODE) == SCmode || (MODE) == DCmode\t\t\t\t\\\n-   || (MODE) == SImode || (TARGET_PA_11 && (MODE) == DImode))\n+   || (MODE) == QImode || (MODE) == HImode || (MODE) == SImode\t\t\\\n+   || (TARGET_PA_11 && (MODE) == DImode))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n "}, {"sha": "cbf2d981c6cb05f76e60d7ff92fb2a2aafb5e381", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e646101de54fc8ffa3e9097a73d7ce08efefbb7/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=7e646101de54fc8ffa3e9097a73d7ce08efefbb7", "patch": "@@ -154,10 +154,11 @@ Boston, MA 02110-1301, USA.  */\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* These are the valid FP modes.  */\n-#define VALID_FP_MODE_P(MODE)                                           \\\n-  ((MODE) == SFmode || (MODE) == DFmode                                 \\\n-   || (MODE) == SCmode || (MODE) == DCmode                              \\\n-   || (MODE) == SImode || (MODE) == DImode)\n+#define VALID_FP_MODE_P(MODE)\t\t\t\t\t\t\\\n+  ((MODE) == SFmode || (MODE) == DFmode\t\t\t\t\t\\\n+   || (MODE) == SCmode || (MODE) == DCmode\t\t\t\t\\\n+   || (MODE) == QImode || (MODE) == HImode || (MODE) == SImode\t\t\\\n+   || (MODE) == DImode)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We"}]}