{"sha": "c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "node_id": "C_kwDOANBUbNoAKGMzZWQ5ZTBkNmU5NmQ4Njk3ZTRiYWI5OTRmOGFjYmM1NTA2MjQwZWU", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-07-11T15:04:46Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-07-11T15:04:46Z"}, "message": "Improved Scalar-To-Vector (STV) support for TImode to V1TImode on x86_64.\n\nThis patch upgrades x86_64's scalar-to-vector (STV) pass to more\naggressively transform 128-bit scalar TImode operations into vector\nV1TImode operations performed on SSE registers.  TImode functionality\nalready exists in STV, but only for move operations.  This change\nbrings support for logical operations (AND, IOR, XOR, NOT and ANDN)\nand comparisons.\n\nThe effect of these changes are conveniently demonstrated by the new\nsse4_1-stv-5.c test case:\n\n__int128 a[16];\n__int128 b[16];\n__int128 c[16];\n\nvoid foo()\n{\n  for (unsigned int i=0; i<16; i++)\n    a[i] = b[i] & ~c[i];\n}\n\nwhich when currently compiled on mainline wtih -O2 -msse4 produces:\n\nfoo:    xorl    %eax, %eax\n.L2:    movq    c(%rax), %rsi\n        movq    c+8(%rax), %rdi\n        addq    $16, %rax\n        notq    %rsi\n        notq    %rdi\n        andq    b-16(%rax), %rsi\n        andq    b-8(%rax), %rdi\n        movq    %rsi, a-16(%rax)\n        movq    %rdi, a-8(%rax)\n        cmpq    $256, %rax\n        jne     .L2\n        ret\n\nbut with this patch now produces:\n\nfoo:    xorl    %eax, %eax\n.L2:    movdqa  c(%rax), %xmm0\n        pandn   b(%rax), %xmm0\n        addq    $16, %rax\n        movaps  %xmm0, a-16(%rax)\n        cmpq    $256, %rax\n        jne     .L2\n        ret\n\nTechnically, the STV pass is implemented by three C++ classes, a common\nabstract base class \"scalar_chain\" that contains common functionality,\nand two derived classes: general_scalar_chain (which handles SI and\nDI modes) and timode_scalar_chain (which handles TI modes).  As\nmentioned previously, because only TI mode moves were handled the\ntwo worker classes behaved significantly differently.  These changes\nbring the functionality of these two classes closer together, which\nis reflected by refactoring more shared code from general_scalar_chain\nto the parent scalar_chain and reusing it from timode_scalar_chain.\nThere still remain significant differences (and simplifications) so\nthe existing division of classes (as specializations) continues to\nmake sense.\n\n2022-07-11  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* config/i386/i386-features.h (scalar_chain): Add fields\n\tinsns_conv, n_sse_to_integer and n_integer_to_sse to this\n\tparent class, moved from general_scalar_chain.\n\t(scalar_chain::convert_compare): Protected method moved\n\tfrom general_scalar_chain.\n\t(mark_dual_mode_def): Make protected, not private virtual.\n\t(scalar_chain:convert_op): New private virtual method.\n\n\t(general_scalar_chain::general_scalar_chain): Simplify constructor.\n\t(general_scalar_chain::~general_scalar_chain): Delete destructor.\n\t(general_scalar_chain): Move insns_conv, n_sse_to_integer and\n\tn_integer_to_sse fields to parent class, scalar_chain.\n\t(general_scalar_chain::mark_dual_mode_def): Delete prototype.\n\t(general_scalar_chain::convert_compare): Delete prototype.\n\n\t(timode_scalar_chain::compute_convert_gain): Remove simplistic\n\timplementation, convert to a method prototype.\n\t(timode_scalar_chain::mark_dual_mode_def): Delete prototype.\n\t(timode_scalar_chain::convert_op): Prototype new virtual method.\n\n\t* config/i386/i386-features.cc (scalar_chain::scalar_chain):\n\tAllocate insns_conv and initialize n_sse_to_integer and\n\tn_integer_to_sse fields in constructor.\n\t(scalar_chain::scalar_chain): Free insns_conv in destructor.\n\n\t(general_scalar_chain::general_scalar_chain): Delete\n\tconstructor, now defined in the class declaration.\n\t(general_scalar_chain::~general_scalar_chain): Delete destructor.\n\n\t(scalar_chain::mark_dual_mode_def): Renamed from\n\tgeneral_scalar_chain::mark_dual_mode_def.\n\t(timode_scalar_chain::mark_dual_mode_def): Delete.\n\t(scalar_chain::convert_compare): Renamed from\n\tgeneral_scalar_chain::convert_compare.\n\n\t(timode_scalar_chain::compute_convert_gain): New method to\n\tdetermine the gain from converting a TImode chain to V1TImode.\n\t(timode_scalar_chain::convert_op): New method to convert an\n\toperand from TImode to V1TImode.\n\n\t(timode_scalar_chain::convert_insn) <case REG>: Only PUT_MODE\n\ton REG_EQUAL notes that were originally TImode (not CONST_INT).\n\tHandle AND, ANDN, XOR, IOR, NOT and COMPARE.\n\t(timode_mem_p): Helper predicate to check where operand is\n\tmemory reference with sufficient alignment for TImode STV.\n\t(timode_scalar_to_vector_candidate_p): Use convertible_comparison_p\n\tto check whether COMPARE is convertible.  Handle SET_DESTs that\n\tthat are REG_P or MEM_P and SET_SRCs that are REG, CONST_INT,\n\tCONST_WIDE_INT, MEM, AND, ANDN, IOR, XOR or NOT.\n\ngcc/testsuite/ChangeLog\n\t* gcc.target/i386/sse4_1-stv-2.c: New test case, pand.\n\t* gcc.target/i386/sse4_1-stv-3.c: New test case, por.\n\t* gcc.target/i386/sse4_1-stv-4.c: New test case, pxor.\n\t* gcc.target/i386/sse4_1-stv-5.c: New test case, pandn.\n\t* gcc.target/i386/sse4_1-stv-6.c: New test case, ptest.", "tree": {"sha": "44f43aaa152c4dcb07ad1357fae8a53db8dd4e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44f43aaa152c4dcb07ad1357fae8a53db8dd4e36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7a7fed818d238d45b18dfd927cde93b4711052d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a7fed818d238d45b18dfd927cde93b4711052d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a7fed818d238d45b18dfd927cde93b4711052d"}], "stats": {"total": 432, "additions": 347, "deletions": 85}, "files": [{"sha": "f1b03c3bfc695571532ceafea80891a336f33a34", "filename": "gcc/config/i386/i386-features.cc", "status": "modified", "additions": 260, "deletions": 70, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.cc?ref=c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "patch": "@@ -291,7 +291,11 @@ scalar_chain::scalar_chain (enum machine_mode smode_, enum machine_mode vmode_)\n   insns = BITMAP_ALLOC (NULL);\n   defs = BITMAP_ALLOC (NULL);\n   defs_conv = BITMAP_ALLOC (NULL);\n+  insns_conv = BITMAP_ALLOC (NULL);\n   queue = NULL;\n+\n+  n_sse_to_integer = 0;\n+  n_integer_to_sse = 0;\n }\n \n /* Free chain's data.  */\n@@ -301,6 +305,7 @@ scalar_chain::~scalar_chain ()\n   BITMAP_FREE (insns);\n   BITMAP_FREE (defs);\n   BITMAP_FREE (defs_conv);\n+  BITMAP_FREE (insns_conv);\n   bitmap_obstack_release (NULL);\n }\n \n@@ -319,25 +324,11 @@ scalar_chain::add_to_queue (unsigned insn_uid)\n   bitmap_set_bit (queue, insn_uid);\n }\n \n-general_scalar_chain::general_scalar_chain (enum machine_mode smode_,\n-\t\t\t\t\t    enum machine_mode vmode_)\n-     : scalar_chain (smode_, vmode_)\n-{\n-  insns_conv = BITMAP_ALLOC (NULL);\n-  n_sse_to_integer = 0;\n-  n_integer_to_sse = 0;\n-}\n-\n-general_scalar_chain::~general_scalar_chain ()\n-{\n-  BITMAP_FREE (insns_conv);\n-}\n-\n /* For DImode conversion, mark register defined by DEF as requiring\n    conversion.  */\n \n void\n-general_scalar_chain::mark_dual_mode_def (df_ref def)\n+scalar_chain::mark_dual_mode_def (df_ref def)\n {\n   gcc_assert (DF_REF_REG_DEF_P (def));\n \n@@ -364,14 +355,6 @@ general_scalar_chain::mark_dual_mode_def (df_ref def)\n \t     DF_REF_REGNO (def), DF_REF_INSN_UID (def), chain_id);\n }\n \n-/* For TImode conversion, it is unused.  */\n-\n-void\n-timode_scalar_chain::mark_dual_mode_def (df_ref)\n-{\n-  gcc_unreachable ();\n-}\n-\n /* Check REF's chain to add new insns into a queue\n    and find registers requiring conversion.  */\n \n@@ -934,7 +917,7 @@ general_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n /* Convert COMPARE to vector mode.  */\n \n rtx\n-general_scalar_chain::convert_compare (rtx op1, rtx op2, rtx_insn *insn)\n+scalar_chain::convert_compare (rtx op1, rtx op2, rtx_insn *insn)\n {\n   rtx tmp = gen_reg_rtx (vmode);\n   rtx src;\n@@ -1068,7 +1051,7 @@ general_scalar_chain::convert_insn (rtx_insn *insn)\n       emit_conversion_insns (gen_move_insn (dst, tmp), insn);\n       dst = gen_rtx_SUBREG (vmode, tmp, 0);\n     }\n-  else if (REG_P (dst))\n+  else if (REG_P (dst) && GET_MODE (dst) == smode)\n     {\n       /* Replace the definition with a SUBREG to the definition we\n          use inside the chain.  */\n@@ -1173,6 +1156,83 @@ general_scalar_chain::convert_insn (rtx_insn *insn)\n   df_insn_rescan (insn);\n }\n \n+/* Compute a gain for chain conversion.  */\n+\n+int\n+timode_scalar_chain::compute_convert_gain ()\n+{\n+  /* Assume that if we have to move TImode values between units,\n+     then transforming this chain isn't worth it.  */\n+  if (n_sse_to_integer || n_integer_to_sse)\n+    return -1;\n+\n+  bitmap_iterator bi;\n+  unsigned insn_uid;\n+\n+  /* Split ties to prefer V1TImode when not optimizing for size.  */\n+  int gain = optimize_size ? 0 : 1;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Computing gain for chain #%d...\\n\", chain_id);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (insns, 0, insn_uid, bi)\n+    {\n+      rtx_insn *insn = DF_INSN_UID_GET (insn_uid)->insn;\n+      rtx def_set = single_set (insn);\n+      rtx src = SET_SRC (def_set);\n+      rtx dst = SET_DEST (def_set);\n+      int igain = 0;\n+\n+      switch (GET_CODE (src))\n+\t{\n+\tcase REG:\n+\t  if (optimize_insn_for_size_p ())\n+\t    igain = MEM_P (dst) ? COSTS_N_BYTES (6) : COSTS_N_BYTES (3);\n+\t  else\n+\t    igain = COSTS_N_INSNS (1);\n+\t  break;\n+\n+\tcase MEM:\n+\t  igain = optimize_insn_for_size_p () ? COSTS_N_BYTES (7)\n+\t\t\t\t\t      : COSTS_N_INSNS (1);\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  if (MEM_P (dst)\n+\t      && standard_sse_constant_p (src, V1TImode))\n+\t    igain = optimize_insn_for_size_p() ? COSTS_N_BYTES (11) : 1;\n+\t  break;\n+\n+\tcase NOT:\n+\t  if (MEM_P (dst))\n+\t    igain = -COSTS_N_INSNS (1);\n+\t  break;\n+\n+\tcase AND:\n+\tcase XOR:\n+\tcase IOR:\n+\t  if (!MEM_P (dst))\n+\t    igain = COSTS_N_INSNS (1);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      if (igain != 0 && dump_file)\n+\t{\n+\t  fprintf (dump_file, \"  Instruction gain %d for \", igain);\n+\t  dump_insn_slim (dump_file, insn);\n+\t}\n+      gain += igain;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  Total gain: %d\\n\", gain);\n+\n+  return gain;\n+}\n+\n /* Fix uses of converted REG in debug insns.  */\n \n void\n@@ -1211,6 +1271,61 @@ timode_scalar_chain::fix_debug_reg_uses (rtx reg)\n     }\n }\n \n+/* Convert operand OP in INSN from TImode to V1TImode.  */\n+\n+void\n+timode_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n+{\n+  *op = copy_rtx_if_shared (*op);\n+\n+  if (REG_P (*op))\n+    *op = gen_rtx_SUBREG (V1TImode, *op, 0);\n+  else if (MEM_P (*op))\n+    {\n+      rtx tmp = gen_reg_rtx (V1TImode);\n+      emit_insn_before (gen_rtx_SET (gen_rtx_SUBREG (V1TImode, tmp, 0),\n+\t\t\t\t     gen_gpr_to_xmm_move_src (V1TImode, *op)),\n+\t\t\tinsn);\n+      *op = gen_rtx_SUBREG (V1TImode, tmp, 0);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"  Preloading operand for insn %d into r%d\\n\",\n+\t\t INSN_UID (insn), REGNO (tmp));\n+    }\n+  else if (CONST_INT_P (*op))\n+    {\n+      rtx vec_cst;\n+      rtx tmp = gen_rtx_SUBREG (V1TImode, gen_reg_rtx (TImode), 0);\n+\n+      /* Prefer all ones vector in case of -1.  */\n+      if (constm1_operand (*op, TImode))\n+\tvec_cst = CONSTM1_RTX (V1TImode);\n+      else\n+\t{\n+\t  rtx *v = XALLOCAVEC (rtx, 1);\n+\t  v[0] = *op;\n+\t  vec_cst = gen_rtx_CONST_VECTOR (V1TImode, gen_rtvec_v (1, v));\n+\t}\n+\n+      if (!standard_sse_constant_p (vec_cst, V1TImode))\n+\t{\n+\t  start_sequence ();\n+\t  vec_cst = validize_mem (force_const_mem (V1TImode, vec_cst));\n+\t  rtx_insn *seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn_before (seq, insn);\n+\t}\n+\n+      emit_insn_before (gen_move_insn (copy_rtx (tmp), vec_cst), insn);\n+      *op = tmp;\n+    }\n+  else\n+    {\n+      gcc_assert (SUBREG_P (*op));\n+      gcc_assert (GET_MODE (*op) == vmode);\n+    }\n+}\n+\n /* Convert INSN from TImode to V1T1mode.  */\n \n void\n@@ -1219,17 +1334,24 @@ timode_scalar_chain::convert_insn (rtx_insn *insn)\n   rtx def_set = single_set (insn);\n   rtx src = SET_SRC (def_set);\n   rtx dst = SET_DEST (def_set);\n+  rtx tmp;\n \n+  if (MEM_P (dst) && !REG_P (src))\n+    {\n+      /* There are no scalar integer instructions and therefore\n+\t temporary register usage is required.  */\n+    }\n   switch (GET_CODE (dst))\n     {\n     case REG:\n-      {\n-\trtx tmp = find_reg_equal_equiv_note (insn);\n-\tif (tmp)\n-\t  PUT_MODE (XEXP (tmp, 0), V1TImode);\n-\tPUT_MODE (dst, V1TImode);\n-\tfix_debug_reg_uses (dst);\n-      }\n+      if (GET_MODE (dst) == TImode)\n+\t{\n+\t  tmp = find_reg_equal_equiv_note (insn);\n+\t  if (tmp && GET_MODE (XEXP (tmp, 0)) == TImode)\n+\t    PUT_MODE (XEXP (tmp, 0), V1TImode);\n+\t  PUT_MODE (dst, V1TImode);\n+\t  fix_debug_reg_uses (dst);\n+\t}\n       break;\n     case MEM:\n       PUT_MODE (dst, V1TImode);\n@@ -1257,16 +1379,19 @@ timode_scalar_chain::convert_insn (rtx_insn *insn)\n \t{\n \t  /* Since there are no instructions to store 128-bit constant,\n \t     temporary register usage is required.  */\n-\t  rtx tmp = gen_reg_rtx (V1TImode);\n \t  start_sequence ();\n \t  src = gen_rtx_CONST_VECTOR (V1TImode, gen_rtvec (1, src));\n \t  src = validize_mem (force_const_mem (V1TImode, src));\n \t  rtx_insn *seq = get_insns ();\n \t  end_sequence ();\n \t  if (seq)\n \t    emit_insn_before (seq, insn);\n-\t  emit_conversion_insns (gen_rtx_SET (dst, tmp), insn);\n-\t  dst = tmp;\n+\t  if (MEM_P (dst))\n+\t    {\n+\t      tmp = gen_reg_rtx (V1TImode);\n+\t      emit_insn_before (gen_rtx_SET (tmp, src), insn);\n+\t      src = tmp;\n+\t    }\n \t}\n       break;\n \n@@ -1282,16 +1407,57 @@ timode_scalar_chain::convert_insn (rtx_insn *insn)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      if (NONDEBUG_INSN_P (insn))\n+      if (MEM_P (dst))\n+\t{\n+\t  tmp = gen_reg_rtx (V1TImode);\n+          emit_insn_before (gen_rtx_SET (tmp, src), insn);\n+          src = tmp;\n+\t}\n+      break;\n+\n+    case AND:\n+      if (GET_CODE (XEXP (src, 0)) == NOT)\n+\t{\n+\t  convert_op (&XEXP (XEXP (src, 0), 0), insn);\n+\t  convert_op (&XEXP (src, 1), insn);\n+\t  PUT_MODE (XEXP (src, 0), V1TImode);\n+\t  PUT_MODE (src, V1TImode);\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n+\n+    case XOR:\n+    case IOR:\n+      convert_op (&XEXP (src, 0), insn);\n+      convert_op (&XEXP (src, 1), insn);\n+      PUT_MODE (src, V1TImode);\n+      if (MEM_P (dst))\n \t{\n-\t  rtx tmp = gen_reg_rtx (V1TImode);\n-\t  /* Since there are no instructions to store standard SSE\n-\t     constant, temporary register usage is required.  */\n-\t  emit_conversion_insns (gen_rtx_SET (dst, tmp), insn);\n-\t  dst = tmp;\n+\t  tmp = gen_reg_rtx (V1TImode);\n+          emit_insn_before (gen_rtx_SET (tmp, src), insn);\n+          src = tmp;\n \t}\n       break;\n \n+    case NOT:\n+      src = XEXP (src, 0);\n+      convert_op (&src, insn);\n+      tmp = gen_reg_rtx (V1TImode);\n+      emit_insn_before (gen_move_insn (tmp, CONSTM1_RTX (V1TImode)), insn);\n+      src = gen_rtx_XOR (V1TImode, src, tmp);\n+      if (MEM_P (dst))\n+\t{\n+\t  tmp = gen_reg_rtx (V1TImode);\n+          emit_insn_before (gen_rtx_SET (tmp, src), insn);\n+          src = tmp;\n+\t}\n+      break;\n+\n+    case COMPARE:\n+      dst = gen_rtx_REG (CCmode, FLAGS_REG);\n+      src = convert_compare (XEXP (src, 0), XEXP (src, 1), insn);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -1551,6 +1717,16 @@ general_scalar_to_vector_candidate_p (rtx_insn *insn, enum machine_mode mode)\n   return true;\n }\n \n+/* Check for a suitable TImode memory operand.  */\n+\n+static bool\n+timode_mem_p (rtx x)\n+{\n+  return MEM_P (x)\n+\t && (TARGET_SSE_UNALIGNED_LOAD_OPTIMAL\n+\t     || !misaligned_operand (x, TImode));\n+}\n+\n /* The TImode version of scalar_to_vector_candidate_p.  */\n \n static bool\n@@ -1564,45 +1740,59 @@ timode_scalar_to_vector_candidate_p (rtx_insn *insn)\n   rtx src = SET_SRC (def_set);\n   rtx dst = SET_DEST (def_set);\n \n-  /* Only TImode load and store are allowed.  */\n-  if (GET_MODE (dst) != TImode)\n+  if (GET_CODE (src) == COMPARE)\n+    return convertible_comparison_p (insn, TImode);\n+\n+  if (GET_MODE (dst) != TImode\n+      || (GET_MODE (src) != TImode\n+          && !CONST_SCALAR_INT_P (src)))\n     return false;\n \n-  if (MEM_P (dst))\n-    {\n-      /* Check for store.  Memory must be aligned or unaligned store\n-\t is optimal.  Only support store from register, standard SSE\n-\t constant or CONST_WIDE_INT generated from piecewise store.\n+  if (!REG_P (dst) && !MEM_P (dst))\n+    return false;\n \n-\t ??? Verify performance impact before enabling CONST_INT for\n-\t __int128 store.  */\n-      if (misaligned_operand (dst, TImode)\n-\t  && !TARGET_SSE_UNALIGNED_STORE_OPTIMAL)\n-\treturn false;\n+  if (MEM_P (dst)\n+      && misaligned_operand (dst, TImode)\n+      && !TARGET_SSE_UNALIGNED_STORE_OPTIMAL)\n+    return false;\n \n-      switch (GET_CODE (src))\n-\t{\n-\tdefault:\n-\t  return false;\n+  switch (GET_CODE (src))\n+    {\n+    case REG:\n+    case CONST_WIDE_INT:\n+      return true;\n \n-\tcase REG:\n-\tcase CONST_WIDE_INT:\n-\t  return true;\n+    case CONST_INT:\n+      /* ??? Verify performance impact before enabling CONST_INT for\n+\t __int128 store.  */\n+      return standard_sse_constant_p (src, TImode);\n \n-\tcase CONST_INT:\n-\t  return standard_sse_constant_p (src, TImode);\n-\t}\n-    }\n-  else if (MEM_P (src))\n-    {\n-      /* Check for load.  Memory must be aligned or unaligned load is\n-\t optimal.  */\n+    case MEM:\n+      /* Memory must be aligned or unaligned load is optimal.  */\n       return (REG_P (dst)\n \t      && (!misaligned_operand (src, TImode)\n \t\t  || TARGET_SSE_UNALIGNED_LOAD_OPTIMAL));\n-    }\n \n-  return false;\n+    case AND:\n+      if (!MEM_P (dst)\n+\t  && GET_CODE (XEXP (src, 0)) == NOT\n+\t  && REG_P (XEXP (XEXP (src, 0), 0))\n+\t  && (REG_P (XEXP (src, 1)) || timode_mem_p (XEXP (src, 1))))\n+\treturn true;\n+      return REG_P (XEXP (src, 0))\n+\t     && (REG_P (XEXP (src, 1)) || timode_mem_p (XEXP (src, 1)));\n+\n+    case IOR:\n+    case XOR:\n+      return REG_P (XEXP (src, 0))\n+\t     && (REG_P (XEXP (src, 1)) || timode_mem_p (XEXP (src, 1)));\n+\n+    case NOT:\n+      return REG_P (XEXP (src, 0)) || timode_mem_p (XEXP (src, 0));\n+\n+    default:\n+      return false;\n+    }\n }\n \n /* For a register REGNO, scan instructions for its defs and uses."}, {"sha": "88b222debc991929c1f8dc4068aede01119b1c81", "filename": "gcc/config/i386/i386-features.h", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Fconfig%2Fi386%2Fi386-features.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Fconfig%2Fi386%2Fi386-features.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.h?ref=c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "patch": "@@ -148,62 +148,63 @@ class scalar_chain\n   /* Registers used in both vector and sclar modes.  */\n   bitmap defs_conv;\n \n+  bitmap insns_conv;\n+  unsigned n_sse_to_integer;\n+  unsigned n_integer_to_sse;\n+\n   void build (bitmap candidates, unsigned insn_uid);\n   virtual int compute_convert_gain () = 0;\n   int convert ();\n \n  protected:\n   void add_to_queue (unsigned insn_uid);\n   void emit_conversion_insns (rtx insns, rtx_insn *pos);\n+  rtx convert_compare (rtx op1, rtx op2, rtx_insn *insn);\n+  void mark_dual_mode_def (df_ref def);\n \n  private:\n   void add_insn (bitmap candidates, unsigned insn_uid);\n   void analyze_register_chain (bitmap candidates, df_ref ref);\n-  virtual void mark_dual_mode_def (df_ref def) = 0;\n   virtual void convert_insn (rtx_insn *insn) = 0;\n   virtual void convert_registers () = 0;\n+  virtual void convert_op (rtx *op, rtx_insn *insn) = 0;\n };\n \n class general_scalar_chain : public scalar_chain\n {\n  public:\n-  general_scalar_chain (enum machine_mode smode_, enum machine_mode vmode_);\n-  ~general_scalar_chain ();\n+  general_scalar_chain (enum machine_mode smode_, enum machine_mode vmode_)\n+    : scalar_chain (smode_, vmode_) {}\n   int compute_convert_gain () final override;\n+\n  private:\n   hash_map<rtx, rtx> defs_map;\n-  bitmap insns_conv;\n-  unsigned n_sse_to_integer;\n-  unsigned n_integer_to_sse;\n-  void mark_dual_mode_def (df_ref def) final override;\n   void convert_insn (rtx_insn *insn) final override;\n-  void convert_op (rtx *op, rtx_insn *insn);\n   void convert_reg (rtx_insn *insn, rtx dst, rtx src);\n+  void convert_op (rtx *op, rtx_insn *insn);\n   void make_vector_copies (rtx_insn *, rtx);\n   void convert_registers () final override;\n-  rtx convert_compare (rtx op1, rtx op2, rtx_insn *insn);\n   int vector_const_cost (rtx exp);\n };\n \n class timode_scalar_chain : public scalar_chain\n {\n  public:\n   timode_scalar_chain () : scalar_chain (TImode, V1TImode) {}\n-\n-  /* Convert from TImode to V1TImode is always faster.  */\n-  int compute_convert_gain () final override { return 1; }\n+  int compute_convert_gain () final override;\n \n  private:\n-  void mark_dual_mode_def (df_ref def) final override;\n   void fix_debug_reg_uses (rtx reg);\n   void convert_insn (rtx_insn *insn) final override;\n-  /* We don't convert registers to difference size.  */\n+  void convert_op (rtx *op, rtx_insn *insn);\n+  /* We don't convert registers to different size.  */\n   void convert_registers () final override {}\n };\n \n } // anon namespace\n \n-bool ix86_save_reg (unsigned int regno, bool maybe_eh_return, bool ignore_outlined);\n+bool ix86_save_reg (unsigned int regno, bool maybe_eh_return,\n+\t\t    bool ignore_outlined);\n int ix86_compare_version_priority (tree decl1, tree decl2);\n tree ix86_generate_version_dispatcher_body (void *node_p);\n tree ix86_get_function_versions_dispatcher (void *decl);"}, {"sha": "e637927b79f882c721d18341803475b26614e0da", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-stv-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-2.c?ref=c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -msse4.1 -mstv -mno-stackrealign\" } */\n+\n+__int128 a[16];\n+__int128 b[16];\n+__int128 c[16];\n+\n+void foo()\n+{\n+  for (unsigned int i=0; i<16; i++)\n+    a[i] = b[i] & c[i];\n+}\n+\n+/* { dg-final { scan-assembler \"pand\" } } */"}, {"sha": "bdc0bac36d1f5a4a7434eaad3caea19102bc493b", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-stv-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-3.c?ref=c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -msse4.1 -mstv -mno-stackrealign\" } */\n+\n+__int128 a[16];\n+__int128 b[16];\n+__int128 c[16];\n+\n+void foo()\n+{\n+  for (unsigned int i=0; i<16; i++)\n+    a[i] = b[i] | c[i];\n+}\n+\n+/* { dg-final { scan-assembler \"por\" } } */"}, {"sha": "a9ef61980a9a05e1359178f73ea5da27bf177c7b", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-stv-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-4.c?ref=c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -msse4.1 -mstv -mno-stackrealign\" } */\n+\n+__int128 a[16];\n+__int128 b[16];\n+__int128 c[16];\n+\n+void foo()\n+{\n+  for (unsigned int i=0; i<16; i++)\n+    a[i] = b[i] ^ c[i];\n+}\n+\n+/* { dg-final { scan-assembler \"pxor\" } } */"}, {"sha": "7eff3c1726e43b10b981a73829baa64ed0f07f46", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-stv-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-5.c?ref=c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -msse4.1 -mstv -mno-stackrealign\" } */\n+\n+__int128 a[16];\n+__int128 b[16];\n+__int128 c[16];\n+\n+void foo()\n+{\n+  for (unsigned int i=0; i<16; i++)\n+    a[i] = b[i] & ~c[i];\n+}\n+\n+/* { dg-final { scan-assembler \"pandn\" } } */"}, {"sha": "407bc551b642f02047f23c1d6708c2708384a00b", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-stv-6.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3ed9e0d6e96d8697e4bab994f8acbc5506240ee/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-6.c?ref=c3ed9e0d6e96d8697e4bab994f8acbc5506240ee", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -msse4.1 -mstv -mno-stackrealign\" } */\n+\n+__int128 a[16];\n+__int128 b[16];\n+\n+int foo()\n+{\n+  for (unsigned int i=0; i<16; i++)\n+    if (a[i] == b[i])\n+      return i;\n+  return -1;\n+}\n+\n+/* { dg-final { scan-assembler \"ptest\" } } */"}]}