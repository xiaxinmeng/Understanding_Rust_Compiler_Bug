{"sha": "6f795a9239f6029072ac83357e8966c56cd572e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY3OTVhOTIzOWY2MDI5MDcyYWM4MzM1N2U4OTY2YzU2Y2Q1NzJlMA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-08-17T18:21:31Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-08-17T18:21:31Z"}, "message": "Formatted printing for dump_* in the middle-end\n\nThis patch converts dump_print and dump_printf_loc from using\nprintf (and thus ATTRIBUTE_PRINTF) to using a new pretty-printer\nbased on pp_format, which supports formatting middle-end types.\n\nIn particular, the following codes are implemented (in addition\nto the standard pretty_printer ones):\n\n   %E: gimple *:\n       Equivalent to: dump_gimple_expr (MSG_*, TDF_SLIM, stmt, 0)\n   %G: gimple *:\n       Equivalent to: dump_gimple_stmt (MSG_*, TDF_SLIM, stmt, 0)\n   %T: tree:\n       Equivalent to: dump_generic_expr (MSG_*, arg, TDF_SLIM).\n\nHence it becomes possible to convert e.g.:\n\n  if (dump_enabled_p ())\n    {\n      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                       \"not vectorized: different sized vector \"\n                       \"types in statement, \");\n      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, vectype);\n      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, nunits_vectype);\n      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n    }\n\ninto a one-liner:\n\n  if (dump_enabled_p ())\n    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                     \"not vectorized: different sized vector \"\n                     \"types in statement, %T and %T\\n\",\n                     vectype, nunits_vectype);\n\nUnlike regular pretty-printers, this one captures optinfo_item\ninstances for the formatted chunks as appropriate, so that when\nwritten out to a JSON optimization record, the relevant parts of\nthe message are labelled by type, and by source location (so that\ne.g. %G is entirely equivalent to using dump_gimple_stmt).\n\ndump_printf and dump_printf_loc become marked with\nATTRIBUTE_GCC_DUMP_PRINTF, which the patch also implements.\n\ngcc/c-family/ChangeLog:\n\t* c-format.c (enum format_type): Add gcc_dump_printf_format_type.\n\t(gcc_dump_printf_length_specs): New.\n\t(gcc_dump_printf_flag_pairs): New.\n\t(gcc_dump_printf_flag_specs): New.\n\t(gcc_dump_printf_char_table): New.\n\t(format_types_orig): Add entry for \"gcc_dump_printf\".\n\t(init_dynamic_diag_info): Set up length_char_specs and\n\tconversion_specs for gcc_dump_printf_format_type.\n\t(handle_format_attribute): Handle gcc_dump_printf_format_type.\n\ngcc/ChangeLog:\n\t* dump-context.h: Include \"dumpfile.h\".\n\t(dump_context::dump_printf_va): Convert final param from va_list\n\tto va_list *.  Convert from ATTRIBUTE_PRINTF to\n\tATTRIBUTE_GCC_DUMP_PRINTF.\n\t(dump_context::dump_printf_loc_va): Likewise.\n\t* dumpfile.c: Include \"stringpool.h\".\n\t(make_item_for_dump_printf_va): Delete.\n\t(make_item_for_dump_printf): Delete.\n\t(class dump_pretty_printer): New class.\n\t(dump_pretty_printer::dump_pretty_printer): New ctor.\n\t(dump_pretty_printer::emit_items): New member function.\n\t(dump_pretty_printer::emit_any_pending_textual_chunks): New member\n\tfunction.\n\t(dump_pretty_printer::emit_item): New member function.\n\t(dump_pretty_printer::stash_item): New member function.\n\t(dump_pretty_printer::format_decoder_cb): New member function.\n\t(dump_pretty_printer::decode_format): New member function.\n\t(dump_context::dump_printf_va): Reimplement in terms of\n\tdump_pretty_printer.\n\t(dump_context::dump_printf_loc_va): Convert final param from va_list\n\tto va_list *.\n\t(dump_context::begin_scope): Reimplement call to\n\tmake_item_for_dump_printf.\n\t(dump_printf): Update for change to dump_printf_va.\n\t(dump_printf_loc): Likewise.\n\t(selftest::test_capture_of_dump_calls): Convert \"stmt\" from\n\tgreturn * to gimple *.  Add a test_decl.  Add tests of dump_printf\n\twith %T, %E, and %G.\n\t* dumpfile.h (ATTRIBUTE_GCC_DUMP_PRINTF): New macro.\n\t(dump_printf): Replace ATTRIBUTE_PRINTF_2 with\n\tATTRIBUTE_GCC_DUMP_PRINTF (2, 3).\n\t(dump_printf_loc): Replace ATTRIBUTE_PRINTF_3 with\n\tATTRIBUTE_GCC_DUMP_PRINTF (3, 0).\n\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Convert\n\tuse of HOST_WIDE_INT_PRINT_DEC on unsigned HOST_WIDE_INT \"count\"\n\twithin a dump_printf_loc call to \"%wu\".\n\t(vector_alignment_reachable_p): Merge two dump_printf[_loc] calls,\n\tconverting a use of HOST_WIDE_INT_PRINT_DEC to \"%wd\".  Add a\n\tmissing space after \"=\".\n\t* tree-vect-loop.c (vect_analyze_loop_2) Within a dump_printf\n\tcall, convert use of HOST_WIDE_INT_PRINT_DEC to \"%wd\".\n\t* tree-vect-slp.c (vect_slp_bb): Within a dump_printf_loc call,\n\tconvert use of HOST_WIDE_INT_PRINT_UNSIGNED to \"%wu\".\n\t* tree-vectorizer.c (try_vectorize_loop_1): Likewise.  Remove\n\tduplicate \"vectorized\" from message.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/format/gcc_diag-1.c: Fix typo.  Add test coverage for\n\tgcc_dump_printf.\n\t* gcc.dg/format/gcc_diag-10.c: Add gimple typedef.  Add test\n\tcoverage for gcc_dump_printf.\n\nFrom-SVN: r263626", "tree": {"sha": "bf03104d1e9fad436a85e1855394ea092e82d743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf03104d1e9fad436a85e1855394ea092e82d743"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f795a9239f6029072ac83357e8966c56cd572e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f795a9239f6029072ac83357e8966c56cd572e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f795a9239f6029072ac83357e8966c56cd572e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f795a9239f6029072ac83357e8966c56cd572e0/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "478490f681da504e75723828d9f1b3b09928b5e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478490f681da504e75723828d9f1b3b09928b5e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478490f681da504e75723828d9f1b3b09928b5e5"}], "stats": {"total": 546, "additions": 496, "deletions": 50}, "files": [{"sha": "f51e30abf217577bec64b8f12c0f3ac609a47303", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -1,3 +1,51 @@\n+2018-08-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dump-context.h: Include \"dumpfile.h\".\n+\t(dump_context::dump_printf_va): Convert final param from va_list\n+\tto va_list *.  Convert from ATTRIBUTE_PRINTF to\n+\tATTRIBUTE_GCC_DUMP_PRINTF.\n+\t(dump_context::dump_printf_loc_va): Likewise.\n+\t* dumpfile.c: Include \"stringpool.h\".\n+\t(make_item_for_dump_printf_va): Delete.\n+\t(make_item_for_dump_printf): Delete.\n+\t(class dump_pretty_printer): New class.\n+\t(dump_pretty_printer::dump_pretty_printer): New ctor.\n+\t(dump_pretty_printer::emit_items): New member function.\n+\t(dump_pretty_printer::emit_any_pending_textual_chunks): New member\n+\tfunction.\n+\t(dump_pretty_printer::emit_item): New member function.\n+\t(dump_pretty_printer::stash_item): New member function.\n+\t(dump_pretty_printer::format_decoder_cb): New member function.\n+\t(dump_pretty_printer::decode_format): New member function.\n+\t(dump_context::dump_printf_va): Reimplement in terms of\n+\tdump_pretty_printer.\n+\t(dump_context::dump_printf_loc_va): Convert final param from va_list\n+\tto va_list *.\n+\t(dump_context::begin_scope): Reimplement call to\n+\tmake_item_for_dump_printf.\n+\t(dump_printf): Update for change to dump_printf_va.\n+\t(dump_printf_loc): Likewise.\n+\t(selftest::test_capture_of_dump_calls): Convert \"stmt\" from\n+\tgreturn * to gimple *.  Add a test_decl.  Add tests of dump_printf\n+\twith %T, %E, and %G.\n+\t* dumpfile.h (ATTRIBUTE_GCC_DUMP_PRINTF): New macro.\n+\t(dump_printf): Replace ATTRIBUTE_PRINTF_2 with\n+\tATTRIBUTE_GCC_DUMP_PRINTF (2, 3).\n+\t(dump_printf_loc): Replace ATTRIBUTE_PRINTF_3 with\n+\tATTRIBUTE_GCC_DUMP_PRINTF (3, 0).\n+\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Convert\n+\tuse of HOST_WIDE_INT_PRINT_DEC on unsigned HOST_WIDE_INT \"count\"\n+\twithin a dump_printf_loc call to \"%wu\".\n+\t(vector_alignment_reachable_p): Merge two dump_printf[_loc] calls,\n+\tconverting a use of HOST_WIDE_INT_PRINT_DEC to \"%wd\".  Add a\n+\tmissing space after \"=\".\n+\t* tree-vect-loop.c (vect_analyze_loop_2) Within a dump_printf\n+\tcall, convert use of HOST_WIDE_INT_PRINT_DEC to \"%wd\".\n+\t* tree-vect-slp.c (vect_slp_bb): Within a dump_printf_loc call,\n+\tconvert use of HOST_WIDE_INT_PRINT_UNSIGNED to \"%wu\".\n+\t* tree-vectorizer.c (try_vectorize_loop_1): Likewise.  Remove\n+\tduplicate \"vectorized\" from message.\n+\n 2018-08-17  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n \n \t* config/arm/arm-builtins.c (arm_init_simd_builtin_types): Clear"}, {"sha": "47221b43f0452634fd20ca29735ac3291feb7c56", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -1,3 +1,15 @@\n+2018-08-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-format.c (enum format_type): Add gcc_dump_printf_format_type.\n+\t(gcc_dump_printf_length_specs): New.\n+\t(gcc_dump_printf_flag_pairs): New.\n+\t(gcc_dump_printf_flag_specs): New.\n+\t(gcc_dump_printf_char_table): New.\n+\t(format_types_orig): Add entry for \"gcc_dump_printf\".\n+\t(init_dynamic_diag_info): Set up length_char_specs and\n+\tconversion_specs for gcc_dump_printf_format_type.\n+\t(handle_format_attribute): Handle gcc_dump_printf_format_type.\n+\n 2018-08-17  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-ada-spec.c (macro_length, dump_ada_macros): Constify."}, {"sha": "035878fd954f49b2a240cea75292ccba83c77424", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -46,6 +46,7 @@ enum format_type { printf_format_type, asm_fprintf_format_type,\n \t\t   gcc_diag_format_type, gcc_tdiag_format_type,\n \t\t   gcc_cdiag_format_type,\n \t\t   gcc_cxxdiag_format_type, gcc_gfc_format_type,\n+\t\t   gcc_dump_printf_format_type,\n \t\t   gcc_objc_string_format_type,\n \t\t   format_type_error = -1};\n \n@@ -463,6 +464,7 @@ static const format_length_info gcc_diag_length_specs[] =\n #define gcc_tdiag_length_specs gcc_diag_length_specs\n #define gcc_cdiag_length_specs gcc_diag_length_specs\n #define gcc_cxxdiag_length_specs gcc_diag_length_specs\n+#define gcc_dump_printf_length_specs gcc_diag_length_specs\n \n /* This differs from printf_length_specs only in that \"Z\" is not accepted.  */\n static const format_length_info scanf_length_specs[] =\n@@ -552,6 +554,7 @@ static const format_flag_pair gcc_diag_flag_pairs[] =\n #define gcc_cdiag_flag_pairs gcc_diag_flag_pairs\n #define gcc_cxxdiag_flag_pairs gcc_diag_flag_pairs\n #define gcc_gfc_flag_pairs gcc_diag_flag_pairs\n+#define gcc_dump_printf_flag_pairs gcc_diag_flag_pairs\n \n static const format_flag_spec gcc_diag_flag_specs[] =\n {\n@@ -567,6 +570,7 @@ static const format_flag_spec gcc_diag_flag_specs[] =\n #define gcc_cdiag_flag_specs gcc_diag_flag_specs\n #define gcc_cxxdiag_flag_specs gcc_diag_flag_specs\n #define gcc_gfc_flag_specs gcc_diag_flag_specs\n+#define gcc_dump_printf_flag_specs gcc_diag_flag_specs\n \n static const format_flag_spec scanf_flag_specs[] =\n {\n@@ -788,6 +792,22 @@ static const format_char_info gcc_gfc_char_table[] =\n   { NULL,  0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n };\n \n+static const format_char_info gcc_dump_printf_char_table[] =\n+{\n+  /* The conversion specifiers implemented within pp_format.  */\n+  PP_FORMAT_CHAR_TABLE,\n+\n+  /* Custom conversion specifiers implemented by dump_pretty_printer.  */\n+\n+  /* E and G require a \"gimple *\" argument at runtime.  */\n+  { \"EG\",   1, STD_C89, { T89_G,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL },\n+\n+  /* T requires a \"tree\" at runtime.  */\n+  { \"T\",   1, STD_C89, { T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL },\n+\n+  { NULL,  0, STD_C89, NOLENGTHS, NULL, NULL, NULL }\n+};\n+\n static const format_char_info scan_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n@@ -887,6 +907,13 @@ static const format_kind_info format_types_orig[] =\n     0, 0, 0, 0, 0, 0,\n     NULL, NULL\n   },\n+  { \"gcc_dump_printf\",   gcc_dump_printf_length_specs,\n+    gcc_dump_printf_char_table, \"q+#\", NULL,\n+    gcc_dump_printf_flag_specs, gcc_dump_printf_flag_pairs,\n+    FMT_FLAG_ARG_CONVERT,\n+    0, 0, 'p', 0, 'L', 0,\n+    NULL, &integer_type_node\n+  },\n   { \"NSString\",   NULL,  NULL, NULL, NULL,\n     NULL, NULL,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_PARSE_ARG_CONVERT_EXTERNAL, 0, 0, 0, 0, 0, 0,\n@@ -3971,6 +3998,7 @@ init_dynamic_diag_info (void)\n \t  dynamic_format_types[gcc_tdiag_format_type].length_char_specs =\n \t  dynamic_format_types[gcc_cdiag_format_type].length_char_specs =\n \t  dynamic_format_types[gcc_cxxdiag_format_type].length_char_specs =\n+\t  dynamic_format_types[gcc_dump_printf_format_type].length_char_specs =\n \t  diag_ls = (format_length_info *)\n \t\t    xmemdup (gcc_diag_length_specs,\n \t\t\t     sizeof (gcc_diag_length_specs),\n@@ -3997,6 +4025,8 @@ init_dynamic_diag_info (void)\n     gcc_cdiag_char_table;\n   dynamic_format_types[gcc_cxxdiag_format_type].conversion_specs =\n     gcc_cxxdiag_char_table;\n+  dynamic_format_types[gcc_dump_printf_format_type].conversion_specs =\n+    gcc_dump_printf_char_table;\n }\n \n #ifdef TARGET_FORMAT_TYPES\n@@ -4151,7 +4181,8 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       || info.format_type == gcc_diag_format_type\n       || info.format_type == gcc_tdiag_format_type\n       || info.format_type == gcc_cdiag_format_type\n-      || info.format_type == gcc_cxxdiag_format_type)\n+      || info.format_type == gcc_cxxdiag_format_type\n+      || info.format_type == gcc_dump_printf_format_type)\n     {\n       /* Our first time through, we have to make sure that our\n \t format_type data is allocated dynamically and is modifiable.  */\n@@ -4173,7 +4204,8 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       else if (info.format_type == gcc_diag_format_type\n \t       || info.format_type == gcc_tdiag_format_type\n \t       || info.format_type == gcc_cdiag_format_type\n-\t       || info.format_type == gcc_cxxdiag_format_type)\n+\t       || info.format_type == gcc_cxxdiag_format_type\n+\t       || info.format_type == gcc_dump_printf_format_type)\n \tinit_dynamic_diag_info ();\n       else\n \tgcc_unreachable ();"}, {"sha": "5ac9dd60e8dd719c3eea842cc355533a774732dd", "filename": "gcc/dump-context.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fdump-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fdump-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdump-context.h?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_DUMP_CONTEXT_H\n #define GCC_DUMP_CONTEXT_H 1\n \n+#include \"dumpfile.h\"\n #include \"pretty-print.h\"\n \n /* A class for handling the various dump_* calls.\n@@ -73,11 +74,11 @@ class dump_context\n \t\t\t      tree t);\n \n   void dump_printf_va (dump_flags_t dump_kind, const char *format,\n-\t\t       va_list ap) ATTRIBUTE_PRINTF (3, 0);\n+\t\t       va_list *ap) ATTRIBUTE_GCC_DUMP_PRINTF (3, 0);\n \n   void dump_printf_loc_va (dump_flags_t dump_kind, const dump_location_t &loc,\n-\t\t\t   const char *format, va_list ap)\n-    ATTRIBUTE_PRINTF (4, 0);\n+\t\t\t   const char *format, va_list *ap)\n+    ATTRIBUTE_GCC_DUMP_PRINTF (4, 0);\n \n   template<unsigned int N, typename C>\n   void dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value);"}, {"sha": "a81ab3ed3c6da46dcb1ecd289414d73d99e61a0f", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 327, "deletions": 31, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"tree-pass.h\" /* for \"current_pass\".  */\n #include \"optinfo-emit-json.h\"\n+#include \"stringpool.h\" /* for get_identifier.  */\n \n /* If non-NULL, return one past-the-end of the matching SUBPART of\n    the WHOLE string.  */\n@@ -681,56 +682,262 @@ dump_context::dump_generic_expr_loc (dump_flags_t dump_kind,\n   dump_generic_expr (dump_kind, extra_dump_flags, t);\n }\n \n-/* Make an item for the given dump call.  */\n+/* A subclass of pretty_printer for implementing dump_context::dump_printf_va.\n+   In particular, the formatted chunks are captured as optinfo_item instances,\n+   thus retaining metadata about the entities being dumped (e.g. source\n+   locations), rather than just as plain text.  */\n \n-static optinfo_item *\n-make_item_for_dump_printf_va (const char *format, va_list ap)\n-  ATTRIBUTE_PRINTF (1, 0);\n+class dump_pretty_printer : public pretty_printer\n+{\n+public:\n+  dump_pretty_printer (dump_context *context, dump_flags_t dump_kind);\n \n-static optinfo_item *\n-make_item_for_dump_printf_va (const char *format, va_list ap)\n+  void emit_items (optinfo *dest);\n+\n+private:\n+  /* Information on an optinfo_item that was generated during phase 2 of\n+     formatting.  */\n+  struct stashed_item\n+  {\n+    stashed_item (const char **buffer_ptr_, optinfo_item *item_)\n+      : buffer_ptr (buffer_ptr_), item (item_) {}\n+    const char **buffer_ptr;\n+    optinfo_item *item;\n+  };\n+\n+  static bool format_decoder_cb (pretty_printer *pp, text_info *text,\n+\t\t\t\t const char *spec, int /*precision*/,\n+\t\t\t\t bool /*wide*/, bool /*set_locus*/,\n+\t\t\t\t bool /*verbose*/, bool */*quoted*/,\n+\t\t\t\t const char **buffer_ptr);\n+\n+  bool decode_format (text_info *text, const char *spec,\n+\t\t      const char **buffer_ptr);\n+\n+  void stash_item (const char **buffer_ptr, optinfo_item *item);\n+\n+  void emit_any_pending_textual_chunks (optinfo *dest);\n+\n+  void emit_item (optinfo_item *item, optinfo *dest);\n+\n+  dump_context *m_context;\n+  dump_flags_t m_dump_kind;\n+  auto_vec<stashed_item> m_stashed_items;\n+};\n+\n+/* dump_pretty_printer's ctor.  */\n+\n+dump_pretty_printer::dump_pretty_printer (dump_context *context,\n+\t\t\t\t\t  dump_flags_t dump_kind)\n+: pretty_printer (), m_context (context), m_dump_kind (dump_kind),\n+  m_stashed_items ()\n+{\n+  pp_format_decoder (this) = format_decoder_cb;\n+}\n+\n+/* Phase 3 of formatting; compare with pp_output_formatted_text.\n+\n+   Emit optinfo_item instances for the various formatted chunks from phases\n+   1 and 2 (i.e. pp_format).\n+\n+   Some chunks may already have had their items built (during decode_format).\n+   These chunks have been stashed into m_stashed_items; we emit them here.\n+\n+   For all other purely textual chunks, they are printed into\n+   buffer->formatted_obstack, and then emitted as a textual optinfo_item.\n+   This consolidates multiple adjacent text chunks into a single text\n+   optinfo_item.  */\n+\n+void\n+dump_pretty_printer::emit_items (optinfo *dest)\n+{\n+  output_buffer *buffer = pp_buffer (this);\n+  struct chunk_info *chunk_array = buffer->cur_chunk_array;\n+  const char **args = chunk_array->args;\n+\n+  gcc_assert (buffer->obstack == &buffer->formatted_obstack);\n+  gcc_assert (buffer->line_length == 0);\n+\n+  unsigned stashed_item_idx = 0;\n+  for (unsigned chunk = 0; args[chunk]; chunk++)\n+    {\n+      if (stashed_item_idx < m_stashed_items.length ()\n+\t  && args[chunk] == *m_stashed_items[stashed_item_idx].buffer_ptr)\n+\t{\n+\t  emit_any_pending_textual_chunks (dest);\n+\t  /* This chunk has a stashed item: use it.  */\n+\t  emit_item (m_stashed_items[stashed_item_idx++].item, dest);\n+\t}\n+      else\n+\t/* This chunk is purely textual.  Print it (to\n+\t   buffer->formatted_obstack), so that we can consolidate adjacent\n+\t   chunks into one textual optinfo_item.  */\n+\tpp_string (this, args[chunk]);\n+    }\n+\n+  emit_any_pending_textual_chunks (dest);\n+\n+  /* Ensure that we consumed all of stashed_items.  */\n+  gcc_assert (stashed_item_idx == m_stashed_items.length ());\n+\n+  /* Deallocate the chunk structure and everything after it (i.e. the\n+     associated series of formatted strings).  */\n+  buffer->cur_chunk_array = chunk_array->prev;\n+  obstack_free (&buffer->chunk_obstack, chunk_array);\n+}\n+\n+/* Subroutine of dump_pretty_printer::emit_items\n+   for consolidating multiple adjacent pure-text chunks into single\n+   optinfo_items (in phase 3).  */\n+\n+void\n+dump_pretty_printer::emit_any_pending_textual_chunks (optinfo *dest)\n {\n-  char *formatted_text = xvasprintf (format, ap);\n+  gcc_assert (buffer->obstack == &buffer->formatted_obstack);\n+\n+  /* Don't emit an item if the pending text is empty.  */\n+  if (output_buffer_last_position_in_text (buffer) == NULL)\n+    return;\n+\n+  char *formatted_text = xstrdup (pp_formatted_text (this));\n   optinfo_item *item\n     = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n \t\t\tformatted_text);\n-  return item;\n+  emit_item (item, dest);\n+\n+  /* Clear the pending text by unwinding formatted_text back to the start\n+     of the buffer (without deallocating).  */\n+  obstack_free (&buffer->formatted_obstack,\n+\t\tbuffer->formatted_obstack.object_base);\n }\n \n-/* Make an item for the given dump call.  */\n+/* Emit ITEM and take ownership of it.  If DEST is non-NULL, add ITEM\n+   to DEST; otherwise delete ITEM.  */\n \n-static optinfo_item *\n-make_item_for_dump_printf (const char *format, ...)\n-  ATTRIBUTE_PRINTF (1, 2);\n+void\n+dump_pretty_printer::emit_item (optinfo_item *item, optinfo *dest)\n+{\n+  m_context->emit_item (item, m_dump_kind);\n+  if (dest)\n+    dest->add_item (item);\n+  else\n+    delete item;\n+}\n \n-static optinfo_item *\n-make_item_for_dump_printf (const char *format, ...)\n+/* Record that ITEM (generated in phase 2 of formatting) is to be used for\n+   the chunk at BUFFER_PTR in phase 3 (by emit_items).  */\n+\n+void\n+dump_pretty_printer::stash_item (const char **buffer_ptr, optinfo_item *item)\n {\n-  va_list ap;\n-  va_start (ap, format);\n-  optinfo_item *item\n-    = make_item_for_dump_printf_va (format, ap);\n-  va_end (ap);\n-  return item;\n+  gcc_assert (buffer_ptr);\n+  gcc_assert (item);\n+\n+  m_stashed_items.safe_push (stashed_item (buffer_ptr, item));\n+}\n+\n+/* pp_format_decoder callback for dump_pretty_printer, and thus for\n+   dump_printf and dump_printf_loc.\n+\n+   A wrapper around decode_format, for type-safety.  */\n+\n+bool\n+dump_pretty_printer::format_decoder_cb (pretty_printer *pp, text_info *text,\n+\t\t\t\t\tconst char *spec, int /*precision*/,\n+\t\t\t\t\tbool /*wide*/, bool /*set_locus*/,\n+\t\t\t\t\tbool /*verbose*/, bool */*quoted*/,\n+\t\t\t\t\tconst char **buffer_ptr)\n+{\n+  dump_pretty_printer *opp = static_cast <dump_pretty_printer *> (pp);\n+  return opp->decode_format (text, spec, buffer_ptr);\n+}\n+\n+/* Format decoder for dump_pretty_printer, and thus for dump_printf and\n+   dump_printf_loc.\n+\n+   Supported format codes (in addition to the standard pretty_printer ones)\n+   are:\n+\n+   %E: gimple *:\n+       Equivalent to: dump_gimple_expr (MSG_*, TDF_SLIM, stmt, 0)\n+   %G: gimple *:\n+       Equivalent to: dump_gimple_stmt (MSG_*, TDF_SLIM, stmt, 0)\n+   %T: tree:\n+       Equivalent to: dump_generic_expr (MSG_*, arg, TDF_SLIM).\n+\n+   FIXME: add symtab_node?\n+\n+   These format codes build optinfo_item instances, thus capturing metadata\n+   about the arguments being dumped, as well as the textual output.  */\n+\n+bool\n+dump_pretty_printer::decode_format (text_info *text, const char *spec,\n+\t\t\t\t       const char **buffer_ptr)\n+{\n+  /* Various format codes that imply making an optinfo_item and stashed it\n+     for later use (to capture metadata, rather than plain text).  */\n+  switch (*spec)\n+    {\n+    case 'E':\n+      {\n+\tgimple *stmt = va_arg (*text->args_ptr, gimple *);\n+\n+\t/* Make an item for the stmt, and stash it.  */\n+\toptinfo_item *item = make_item_for_dump_gimple_expr (stmt, 0, TDF_SLIM);\n+\tstash_item (buffer_ptr, item);\n+\treturn true;\n+      }\n+\n+    case 'G':\n+      {\n+\tgimple *stmt = va_arg (*text->args_ptr, gimple *);\n+\n+\t/* Make an item for the stmt, and stash it.  */\n+\toptinfo_item *item = make_item_for_dump_gimple_stmt (stmt, 0, TDF_SLIM);\n+\tstash_item (buffer_ptr, item);\n+\treturn true;\n+      }\n+\n+    case 'T':\n+      {\n+\ttree t = va_arg (*text->args_ptr, tree);\n+\n+\t/* Make an item for the tree, and stash it.  */\n+\toptinfo_item *item = make_item_for_dump_generic_expr (t, TDF_SLIM);\n+\tstash_item (buffer_ptr, item);\n+\treturn true;\n+      }\n+\n+    default:\n+      return false;\n+    }\n }\n \n /* Output a formatted message using FORMAT on appropriate dump streams.  */\n \n void\n dump_context::dump_printf_va (dump_flags_t dump_kind, const char *format,\n-\t\t\t      va_list ap)\n+\t\t\t      va_list *ap)\n {\n-  optinfo_item *item = make_item_for_dump_printf_va (format, ap);\n-  emit_item (item, dump_kind);\n+  dump_pretty_printer pp (this, dump_kind);\n \n+  text_info text;\n+  text.err_no = errno;\n+  text.args_ptr = ap;\n+  text.format_spec = format;\n+\n+  /* Phases 1 and 2, using pp_format.  */\n+  pp_format (&pp, &text);\n+\n+  /* Phase 3.  */\n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = ensure_pending_optinfo ();\n       info.handle_dump_file_kind (dump_kind);\n-      info.add_item (item);\n+      pp.emit_items (&info);\n     }\n   else\n-    delete item;\n+    pp.emit_items (NULL);\n }\n \n /* Similar to dump_printf, except source location is also printed, and\n@@ -739,7 +946,7 @@ dump_context::dump_printf_va (dump_flags_t dump_kind, const char *format,\n void\n dump_context::dump_printf_loc_va (dump_flags_t dump_kind,\n \t\t\t\t  const dump_location_t &loc,\n-\t\t\t\t  const char *format, va_list ap)\n+\t\t\t\t  const char *format, va_list *ap)\n {\n   dump_loc (dump_kind, loc);\n   dump_printf_va (dump_kind, format, ap);\n@@ -851,15 +1058,18 @@ dump_context::begin_scope (const char *name, const dump_location_t &loc)\n   if (m_test_pp)\n     ::dump_loc (MSG_NOTE, m_test_pp, loc.get_location_t ());\n \n-  optinfo_item *item = make_item_for_dump_printf (\"=== %s ===\\n\", name);\n+  pretty_printer pp;\n+  pp_printf (&pp, \"=== %s ===\\n\", name);\n+  optinfo_item *item\n+    = new optinfo_item (OPTINFO_ITEM_KIND_TEXT, UNKNOWN_LOCATION,\n+\t\t\txstrdup (pp_formatted_text (&pp)));\n   emit_item (item, MSG_NOTE);\n \n   if (optinfo_enabled_p ())\n     {\n       optinfo &info = begin_next_optinfo (loc);\n       info.m_kind = OPTINFO_KIND_SCOPE;\n       info.add_item (item);\n-      end_any_optinfo ();\n     }\n   else\n     delete item;\n@@ -1006,7 +1216,7 @@ dump_printf (dump_flags_t dump_kind, const char *format, ...)\n {\n   va_list ap;\n   va_start (ap, format);\n-  dump_context::get ().dump_printf_va (dump_kind, format, ap);\n+  dump_context::get ().dump_printf_va (dump_kind, format, &ap);\n   va_end (ap);\n }\n \n@@ -1019,7 +1229,7 @@ dump_printf_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n {\n   va_list ap;\n   va_start (ap, format);\n-  dump_context::get ().dump_printf_loc_va (dump_kind, loc, format, ap);\n+  dump_context::get ().dump_printf_loc_va (dump_kind, loc, format, &ap);\n   va_end (ap);\n }\n \n@@ -1808,9 +2018,12 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \n   dump_location_t loc = dump_location_t::from_location_t (where);\n \n-  greturn *stmt = gimple_build_return (NULL);\n+  gimple *stmt = gimple_build_return (NULL);\n   gimple_set_location (stmt, where);\n \n+  tree test_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t       get_identifier (\"test_decl\"),\n+\t\t\t       integer_type_node);\n   /* Run all tests twice, with and then without optinfo enabled, to ensure\n      that immediate destinations vs optinfo-based destinations both\n      work, independently of each other, with no leaks.  */\n@@ -1834,6 +2047,89 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  }\n       }\n \n+      /* Test of dump_printf with %T.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_printf (MSG_NOTE, \"tree: %T\", integer_zero_node);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"tree: 0\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 2);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"tree: \");\n+\t    ASSERT_IS_TREE (info->get_item (1), UNKNOWN_LOCATION, \"0\");\n+\t  }\n+      }\n+\n+      /* Test of dump_printf with %E.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_printf (MSG_NOTE, \"gimple: %E\", stmt);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"gimple: return;\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 2);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"gimple: \");\n+\t    ASSERT_IS_GIMPLE (info->get_item (1), where, \"return;\");\n+\t  }\n+      }\n+\n+      /* Test of dump_printf with %G.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_printf (MSG_NOTE, \"gimple: %G\", stmt);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp, \"gimple: return;\\n\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 2);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"gimple: \");\n+\t    ASSERT_IS_GIMPLE (info->get_item (1), where, \"return;\\n\");\n+\t  }\n+      }\n+\n+      /* dump_print_loc with multiple format codes.  This tests various\n+\t things:\n+\t - intermingling of text, format codes handled by the base\n+\t pretty_printer, and dump-specific format codes\n+\t - multiple dump-specific format codes: some consecutive, others\n+\t separated by text, trailing text after the final one.  */\n+      {\n+\ttemp_dump_context tmp (with_optinfo, MSG_ALL);\n+\tdump_printf_loc (MSG_NOTE, loc, \"before %T and %T\"\n+\t\t\t \" %i consecutive %E%E after\\n\",\n+\t\t\t integer_zero_node, test_decl, 42, stmt, stmt);\n+\n+\tASSERT_DUMPED_TEXT_EQ (tmp,\n+\t\t\t       \"test.txt:5:10: note: before 0 and test_decl\"\n+\t\t\t       \" 42 consecutive return;return; after\\n\");\n+\tif (with_optinfo)\n+\t  {\n+\t    optinfo *info = tmp.get_pending_optinfo ();\n+\t    ASSERT_TRUE (info != NULL);\n+\t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n+\t    ASSERT_EQ (info->num_items (), 8);\n+\t    ASSERT_IS_TEXT (info->get_item (0), \"before \");\n+\t    ASSERT_IS_TREE (info->get_item (1), UNKNOWN_LOCATION, \"0\");\n+\t    ASSERT_IS_TEXT (info->get_item (2), \" and \");\n+\t    ASSERT_IS_TREE (info->get_item (3), UNKNOWN_LOCATION, \"test_decl\");\n+\t    ASSERT_IS_TEXT (info->get_item (4), \" 42 consecutive \");\n+\t    ASSERT_IS_GIMPLE (info->get_item (5), where, \"return;\");\n+\t    ASSERT_IS_GIMPLE (info->get_item (6), where, \"return;\");\n+\t    ASSERT_IS_TEXT (info->get_item (7), \" after\\n\");\n+\t  }\n+      }\n+\n       /* Tree, via dump_generic_expr.  */\n       {\n \ttemp_dump_context tmp (with_optinfo, MSG_ALL);"}, {"sha": "0305d36fa78e2a4f90d789d1ace8adacc72689f6", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -23,6 +23,19 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"profile-count.h\"\n \n+/* An attribute for annotating formatting printing functions that use\n+   the dumpfile/optinfo formatting codes.  These are the pretty_printer\n+   format codes (see pretty-print.c), with additional codes for middle-end\n+   specific entities (see dumpfile.c).  */\n+\n+#if GCC_VERSION >= 3005\n+#define ATTRIBUTE_GCC_DUMP_PRINTF(m, n) \\\n+  __attribute__ ((__format__ (__gcc_dump_printf__, m ,n))) \\\n+  ATTRIBUTE_NONNULL(m)\n+#else\n+#define ATTRIBUTE_GCC_DUMP_PRINTF(m, n) ATTRIBUTE_NONNULL(m)\n+#endif\n+\n /* Different tree dump places.  When you add new tree dump places,\n    extend the DUMP_FILES array in dumpfile.c.  */\n enum tree_dump_index\n@@ -476,9 +489,12 @@ dump_enabled_p (void)\n    to minimize the work done for the common case where dumps\n    are disabled.  */\n \n-extern void dump_printf (dump_flags_t, const char *, ...) ATTRIBUTE_PRINTF_2;\n+extern void dump_printf (dump_flags_t, const char *, ...)\n+  ATTRIBUTE_GCC_DUMP_PRINTF (2, 3);\n+\n extern void dump_printf_loc (dump_flags_t, const dump_location_t &,\n-\t\t\t     const char *, ...) ATTRIBUTE_PRINTF_3;\n+\t\t\t     const char *, ...)\n+  ATTRIBUTE_GCC_DUMP_PRINTF (3, 0);\n extern void dump_function (int phase, tree fn);\n extern void dump_basic_block (dump_flags_t, basic_block, int);\n extern void dump_generic_expr_loc (dump_flags_t, const dump_location_t &,"}, {"sha": "745382c28cf884e2f13b85d84fce809792aba00f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -1,3 +1,10 @@\n+2018-08-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/format/gcc_diag-1.c: Fix typo.  Add test coverage for\n+\tgcc_dump_printf.\n+\t* gcc.dg/format/gcc_diag-10.c: Add gimple typedef.  Add test\n+\tcoverage for gcc_dump_printf.\n+\n 2018-08-17  Martin Liska  <mliska@suse.cz>\n \n \t* g++.dg/opt/mpx.C: Fix scanned pattern."}, {"sha": "87614567b9124e2e0da4964b728cb0fe15324830", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-1.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -1,4 +1,4 @@\n-/* Test for GCC diagnositc formats.  */\n+/* Test for GCC diagnostic formats.  */\n /* Origin: Kaveh Ghazi <ghazi@caip.rutgers.edu> */\n /* { dg-do compile } */\n /* { dg-options \"-Wformat\" } */\n@@ -24,6 +24,7 @@ extern int diag (const char *, ...) ATTRIBUTE_DIAG(__gcc_diag__);\n extern int tdiag (const char *, ...) ATTRIBUTE_DIAG(__gcc_tdiag__);\n extern int cdiag (const char *, ...) ATTRIBUTE_DIAG(__gcc_cdiag__);\n extern int cxxdiag (const char *, ...) ATTRIBUTE_DIAG(__gcc_cxxdiag__);\n+extern int dump (const char *, ...) ATTRIBUTE_DIAG(__gcc_dump_printf__);\n \n void\n foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n@@ -39,36 +40,44 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   tdiag (\"%%\");\n   cdiag (\"%%\");\n   cxxdiag (\"%%\");\n+  dump (\"%%\");\n   diag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n   tdiag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n   cdiag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n   cxxdiag (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n+  dump (\"%d%i%o%u%x%c%s%p%%\", i, i, u, u, u, i, s, p);\n   diag (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n   tdiag (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n   cdiag (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n   cxxdiag (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n+  dump (\"%qd%qi%qo%qu%qx%qc%qs%qp%<%%%'%>\", i, i, u, u, u, i, s, p);\n   diag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n   tdiag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n   cdiag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n   cxxdiag (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n+  dump (\"%ld%li%lo%lu%lx\", l, l, ul, ul, ul);\n   diag (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n   tdiag (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n   cdiag (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n   cxxdiag (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n+  dump (\"%lld%lli%llo%llu%llx\", ll, ll, ull, ull, ull);\n   diag (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n   tdiag (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n   cdiag (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n   cxxdiag (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n+  dump (\"%wd%wi%wo%wu%wx\", ll, ll, ull, ull, ull);\n   diag (\"%.*s\", i, s);\n   tdiag (\"%.*s\", i, s);\n   cdiag (\"%.*s\", i, s);\n   cxxdiag (\"%.*s\", i, s);\n+  dump (\"%.*s\", i, s);\n \n   /* Extensions provided in the diagnostic framework.  */\n   diag (\"%m\");\n   tdiag (\"%m\");\n   cdiag (\"%m\");\n   cxxdiag (\"%m\");\n+  dump (\"%m\");\n \n   /* Quote directives to avoid \"warning: conversion used unquoted.\" */\n   tdiag (\"%<%D%F%T%V%>\", t1, t1, t1, t1);\n@@ -94,20 +103,24 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   tdiag (\"%Z\", v, v_len);\n   cdiag (\"%Z\", v, v_len);\n   cxxdiag (\"%Z\", v, v_len);\n+  dump (\"%Z\", v, v_len);\n \n   /* Bad stuff with extensions.  */\n   diag (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n   tdiag (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n   cdiag (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n   cxxdiag (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n+  dump (\"%m\", i); /* { dg-warning \"format\" \"extra arg\" } */\n   diag (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   tdiag (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   cdiag (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   cxxdiag (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  dump (\"%#m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   diag (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   tdiag (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   cdiag (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   cxxdiag (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n+  dump (\"%+m\"); /* { dg-warning \"format\" \"bogus modifier\" } */\n   diag (\"%D\", t1); /* { dg-warning \"format\" \"bogus tree\" } */\n   tdiag (\"%A\", t1); /* { dg-warning \"format\" \"bogus tree\" } */\n   tdiag (\"%E\", t1);"}, {"sha": "2f6a002a47f9b1ab6f867ecc36833ad0c7d83e4d", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-10.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -19,12 +19,16 @@ typedef union tree_node *tree;\n    the C test to find the symbol.  */\n typedef struct gimple gimple;\n \n+/* Likewise for gimple.  */\n+typedef struct gimple gimple;\n+\n #define FORMAT(kind) __attribute__ ((format (__gcc_## kind ##__, 1, 2)))\n \n void diag (const char*, ...) FORMAT (diag);\n void cdiag (const char*, ...) FORMAT (cdiag);\n void tdiag (const char*, ...) FORMAT (tdiag);\n void cxxdiag (const char*, ...) FORMAT (cxxdiag);\n+void dump (const char*, ...) FORMAT (dump_printf);\n \n void test_diag (tree t, gimple *gc)\n {\n@@ -157,3 +161,25 @@ void test_cxxdiag (tree t, gimple *gc)\n   cxxdiag (\"%<%V%>\", t);\n   cxxdiag (\"%<%X%>\", t);\n }\n+\n+void test_dump (tree t, gimple *stmt)\n+{\n+  dump (\"%<\");   /* { dg-warning \"unterminated quoting directive\" } */\n+  dump (\"%>\");   /* { dg-warning \"unmatched quoting directive \" } */\n+  dump (\"%<foo%<bar%>%>\");   /* { dg-warning \"nested quoting directive\" } */\n+\n+  dump (\"%R\");       /* { dg-warning \"unmatched color reset directive\" } */\n+  dump (\"%r\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  dump (\"%r%r\", \"\", \"\");   /* { dg-warning \"unterminated color directive\" } */\n+  dump (\"%r%R\", \"\");\n+  dump (\"%r%r%R\", \"\", \"\");\n+  dump (\"%r%R%r%R\", \"\", \"\");\n+\n+  dump (\"%<%R%>\");      /* { dg-warning \"unmatched color reset directive\" } */\n+  dump (\"%<%r%>\", \"\");  /* { dg-warning \"unterminated color directive\" } */\n+  dump (\"%<%r%R%>\", \"\");\n+\n+  dump (\"%E\", stmt);\n+  dump (\"%T\", t);\n+  dump (\"%G\", stmt);\n+}"}, {"sha": "d70d207c7d24077bde09c8191c41ca5fef650a22", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -74,8 +74,7 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"no array mode for %s[\"\n-\t\t\t     HOST_WIDE_INT_PRINT_DEC \"]\\n\",\n+\t\t\t     \"no array mode for %s[%wu]\\n\",\n \t\t\t     GET_MODE_NAME (mode), count);\n \t  return false;\n \t}\n@@ -1249,9 +1248,8 @@ vector_alignment_reachable_p (dr_vec_info *dr_info)\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t                   \"data size =\" HOST_WIDE_INT_PRINT_DEC, elmsize);\n-\t  dump_printf (MSG_NOTE,\n-\t               \". misalignment = %d.\\n\", DR_MISALIGNMENT (dr_info));\n+\t                   \"data size = %wd. misalignment = %d.\\n\", elmsize,\n+\t\t\t   DR_MISALIGNMENT (dr_info));\n \t}\n       if (DR_MISALIGNMENT (dr_info) % elmsize)\n \t{"}, {"sha": "db92f76c74fdf5f39cbe0ed22304f8cb15c2f47e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -1958,7 +1958,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"vectorization_factor = \");\n       dump_dec (MSG_NOTE, vectorization_factor);\n-      dump_printf (MSG_NOTE, \", niters = \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+      dump_printf (MSG_NOTE, \", niters = %wd\\n\",\n \t\t   LOOP_VINFO_INT_NITERS (loop_vinfo));\n     }\n "}, {"sha": "0a9ce24608c91552d0df7535e1b00105e9fc6ac1", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -2984,8 +2984,7 @@ vect_slp_bb (basic_block bb)\n \t  unsigned HOST_WIDE_INT bytes;\n \t  if (current_vector_size.is_constant (&bytes))\n \t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t     \"basic block part vectorized using \"\n-\t\t\t     HOST_WIDE_INT_PRINT_UNSIGNED \" byte \"\n+\t\t\t     \"basic block part vectorized using %wu byte \"\n \t\t\t     \"vectors\\n\", bytes);\n \t  else\n \t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,"}, {"sha": "db4fb766dc2423fe5c443b772bfe6033c6835733", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f795a9239f6029072ac83357e8966c56cd572e0/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6f795a9239f6029072ac83357e8966c56cd572e0", "patch": "@@ -935,9 +935,7 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n   unsigned HOST_WIDE_INT bytes;\n   if (current_vector_size.is_constant (&bytes))\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t     \"loop vectorized vectorized using \"\n-\t\t     HOST_WIDE_INT_PRINT_UNSIGNED \" byte \"\n-\t\t     \"vectors\\n\", bytes);\n+\t\t     \"loop vectorized using %wu byte vectors\\n\", bytes);\n   else\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t     \"loop vectorized using variable length vectors\\n\");"}]}