{"sha": "a9d8907c2025d9f9d29b96f236166389998a5a99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlkODkwN2MyMDI1ZDlmOWQyOWI5NmYyMzYxNjYzODk5OThhNWE5OQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-03-15T15:54:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T15:54:14Z"}, "message": "atree.ads, atree.adb: Add support for Elist24 field\n\n2005-03-08  Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\t    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* atree.ads, atree.adb: Add support for Elist24 field\n\n\t* atree.h: Fix wrong definition of Field27\n\tAdd support for Elist16 field\n\tAdd support for Elist24 field\n\n\t* einfo.ads, einfo.adb (Abstract_Interfaces,\n\tSet_Abstract_Interfaces): New subprograms.\n\t(Abstract_Interface_Alias, Set_Abstract_Interface_Alias): New\n\tsubprograms.\n\t(Access_Disp_Table, Set_Access_Disp_Table): Modified to handle a list of\n\tentities rather than a single node.\n\t(Is_Interface, Set_Is_Interface): New subprogram\n\t(First_Tag_Component): New syntesized attribute\n\t(Next_Tag_Component): New synthesized attribute\n\t(Write_Entity_Flags): Upgraded to write Is_Interface\n\t(Write_Field24_Name): Upgraded to write Abstract_Interfaces\n\t(Write_Field25_Name): Upgraded to write Abstract_Interface_Alias\n\t(Task_Body_Procedure): New subprogram to read this attribute.\n\t(Set_Task_Body_Procedure): New subprogram to set this attribute.\n\t(Has_Controlled_Component): Now applies to all entities.\n\tThis is only a documentation change, since it always worked to apply\n\tthis to other than composite types (yielding false), but now this is\n\tofficial.\n\tUpdate documentation on Must_Be_Byte_Aligned for new spec\n\n\t* tbuild.adb, exp_dist.adb, exp_disp.adb, exp_ch3.ads, exp_ch3.adb,\n\texp_attr.adb, exp_aggr.adb, exp_ch4.adb, exp_ch5.adb: Upgrade all the\n\tuses of the Access_Disp_Table attribute to reference the first dispatch\n\ttable associated with a tagged type. As\n\tpart of the implementation of abstract interface types,\n\tAccess_Disp_Table has been redefined to contain a list of dispatch\n\ttables (rather than a single dispatch table).\n\tSimilarly, upgrade all the references to Tag_Component by the\n\tnew attribute First_Tag_Component.\n\t(Find_Inherited_TSS): Moved to exp_tss.\n\tClean up test in Expand_N_Object_Declaration for cases\n\twhere we need to do a separate assignment of the initial value.\n\t(Expand_N_Object_Declaration): If the expression in the\n\tdeclaration of a tagged type is an aggregate, no need to generate an\n\tadditional tag assignment.\n\t(Freeze_Type): Now a function that returns True if the N_Freeze_Entity\n\tis to be deleted.\n\tBit packed array ops are only called if operands are known to be\n\taligned.\n\t(Component_Equality): When returning an N_Raise_Program_Error statement,\n\tensure that its Etype is set to Empty to avoid confusing GIGI (which\n\texpects that only expressions have a bona fide type).\n\t(Make_Tag_Ctrl_Assignment): Use Build_Actual_Subtype to correctly\n\tdetermine the amount of data to be copied.\n\n\t* par.adb (P_Interface_Type_Definition): New subprogram that parses the\n\tnew syntax rule of Ada 2005 interfaces (for AI-251 and AI-345):\n\t    INTERFACE_TYPE_DEFINITION ::=\n\t      [limited | task | protected | synchronized] interface\n\t        [AND interface_list]\n\n\t* par-ch3.adb (P_Type_Declaration): Modified to give support to\n\tinterfaces.\n\t(P_Derived_Type_Def_Or_Private_Ext_Decl): Modified to give support to\n\tinterfaces.\n\t(P_Interface_Type_Definition): New subprogram that parses the new\n\tsyntax rule of Ada 2005 interfaces\n\t(P_Identifier_Declarations): fix two occurrences of 'RENAMES' in error\n\tmessages by the correct RENAMES (quotes removed).\n\n\t* sem_prag.adb: Upgrade all the references to Tag_Component by the new\n\tattribute First_Tag_Component.\n\n\t* sinfo.ads, sinfo.adb: Remove OK_For_Stream flag, not used, not needed\n\t(Interface_List, Set_Interface_List): New subprograms.\n\t(Interface_Present, Set_Interface_Present): New subprograms.\n\t(Limited_Present, Set_Limited_Present): Available also in derived\n\ttype definition nodes.\n\t(Protected_Present, Set_Protected_Present): Available also in\n\trecord type definition and\n\tderived type definition nodes.\n\t(Synchronized_Present, Set_Synchronized_Present): New subprograms.\n\t(Task_Present, Set_Task_Present): New subprogram.\n\t(Task_Body_Procedure): Removed.\n\t(Set_Task_Body_Procedure): Removed.\n\tThese subprogram have been removed because the attribute\n\tTask_Body_Procedure has been moved to the corresponding task type\n\tor task subtype entity to leave a field free to store the list\n\tof interfaces implemented by a task (for AI-345)\n\tAdd Expression field to N_Raise_Statement node for Ada 2005 AI-361\n\t(Null_Exclusion_Present): Change to Flag11, to avoid conflict with\n\texpression flag Do_Range_Check\n\t(Exception_Junk): Change to Flag7 to accomodate above change\n\t(Box_Present, Default_Name, Specification, Set_Box_Present,\n\tSet_Default_Name, Set_Specification): Expand the expression\n\t\"X in N_Formal_Subprogram_Declaration\" into the corresponding\n\ttwo comparisons. Required to use the csinfo tool.\n\n\t* exp_ch11.adb (Expand_N_Raise_Statement): Deal with case where\n\t\"with string\" given.\n\n        * sem_ch11.adb (Analyze_Raise_Statement): Handle case where string\n        expression given.\n\n\t* par-ch11.adb (P_Raise_Statement): Recognize with string expression\n\tin 2005 mode\n\n\t* exp_ch9.adb (Build_Task_Proc_Specification): Modified to use entity\n\tattribute Task_Body_Procedure rather than the old semantic field that\n\twas available in the task_type_declaration node.\n\n\t* par-ch12.adb (P_Formal_Type_Definition): Modified to handle formal\n\tinterface type definitions.\n\t(P_Formal_Derived_Type_Definition): Modified to handle the list of\n\tinterfaces.\n\n\t* par-ch9.adb (P_Task): Modified to handle the list of interfaces in a\n\ttask type declaration.\n\t(P_Protected): Modified to handle the list of interfaces in a\n\tprotected type declaration.\n\nFrom-SVN: r96489", "tree": {"sha": "826fcec0a5407caae82fabd04cb7e41ec79589fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/826fcec0a5407caae82fabd04cb7e41ec79589fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9d8907c2025d9f9d29b96f236166389998a5a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d8907c2025d9f9d29b96f236166389998a5a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9d8907c2025d9f9d29b96f236166389998a5a99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d8907c2025d9f9d29b96f236166389998a5a99/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f388d2db6113fc8113d983c7370b7c45b1024ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f388d2db6113fc8113d983c7370b7c45b1024ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f388d2db6113fc8113d983c7370b7c45b1024ab"}], "stats": {"total": 2164, "additions": 1437, "deletions": 727}, "files": [{"sha": "f226634397195b1497aca68d40cce861aafca2a4", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -2919,9 +2919,15 @@ package body Atree is\n       end Elist15;\n \n       function Elist16 (N : Node_Id) return Elist_Id is\n+         Value : constant Union_Id := Nodes.Table (N + 2).Field9;\n+\n       begin\n          pragma Assert (Nkind (N) in N_Entity);\n-         return Elist_Id (Nodes.Table (N + 2).Field9);\n+         if Value = 0 then\n+            return No_Elist;\n+         else\n+            return Elist_Id (Nodes.Table (N + 2).Field9);\n+         end if;\n       end Elist16;\n \n       function Elist18 (N : Node_Id) return Elist_Id is\n@@ -2942,6 +2948,12 @@ package body Atree is\n          return Elist_Id (Nodes.Table (N + 3).Field10);\n       end Elist23;\n \n+      function Elist24 (N : Node_Id) return Elist_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Elist_Id (Nodes.Table (N + 4).Field6);\n+      end Elist24;\n+\n       function Name1 (N : Node_Id) return Name_Id is\n       begin\n          pragma Assert (N in Nodes.First .. Nodes.Last);\n@@ -4845,6 +4857,12 @@ package body Atree is\n          Nodes.Table (N + 3).Field10 := Union_Id (Val);\n       end Set_Elist23;\n \n+      procedure Set_Elist24 (N : Node_Id; Val : Elist_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 4).Field6 := Union_Id (Val);\n+      end Set_Elist24;\n+\n       procedure Set_Name1 (N : Node_Id; Val : Name_Id) is\n       begin\n          pragma Assert (N in Nodes.First .. Nodes.Last);"}, {"sha": "309310487c558b94b43b3c52cfc47bdcb7d1d5f5", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 84, "deletions": 68, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -75,62 +75,73 @@ package Atree is\n    --  a node contains a number of fields, much as though the nodes were\n    --  defined as a record type. The fields in a node are as follows:\n \n-   --   Nkind            Indicates the kind of the node. This field is present\n-   --                    in all nodes. The type is Node_Kind, which is declared\n-   --                    in the package Sinfo.\n+   --   Nkind         Indicates the kind of the node. This field is present\n+   --                 in all nodes. The type is Node_Kind, which is declared\n+   --                 in the package Sinfo.\n \n-   --   Sloc             Location (Source_Ptr) of the corresponding token\n-   --                    in the Source buffer. The individual node definitions\n-   --                    show which token is referenced by this pointer.\n+   --   Sloc          Location (Source_Ptr) of the corresponding token\n+   --                 in the Source buffer. The individual node definitions\n+   --                 show which token is referenced by this pointer.\n \n-   --   In_List          A flag used to indicate if the node is a member\n+   --   In_List       A flag used to indicate if the node is a member\n    --                    of a node list.\n \n-   --   Rewrite_Sub      A flag set if the node has been rewritten using\n-   --                    the Rewrite procedure. The original value of the\n-   --                    node is retrievable with Original_Node.\n+   --   Rewrite_Sub   A flag set if the node has been rewritten using\n+   --                 the Rewrite procedure. The original value of the\n+   --                 node is retrievable with Original_Node.\n \n-   --   Rewrite_Ins      A flag set if a node is marked as a rewrite inserted\n-   --                    node as a result of a call to Mark_Rewrite_Insertion.\n+   --   Rewrite_Ins   A flag set if a node is marked as a rewrite inserted\n+   --                 node as a result of a call to Mark_Rewrite_Insertion.\n \n-   --   Paren_Count      A 2-bit count used on expression nodes to indicate\n-   --                    the level of parentheses. Up to 3 levels can be\n-   --                    accomodated. Anything more than 3 levels is treated\n-   --                    as 3 levels (conformance tests that complain about\n-   --                    this are hereby deemed pathological!) Set to zero\n-   --                    for non-subexpression nodes.\n+   --   Paren_Count   A 2-bit count used on expression nodes to indicate\n+   --                 the level of parentheses. Up to 3 levels can be\n+   --                 accomodated. Anything more than 3 levels is treated\n+   --                 as 3 levels (conformance tests that complain about\n+   --                 this are hereby deemed pathological!) Set to zero\n+   --                 for non-subexpression nodes.\n \n    --   Comes_From_Source\n-   --                    This flag is present in all nodes. It is set if the\n-   --                    node is built by the scanner or parser, and clear if\n-   --                    the node is built by the analyzer or expander. It\n-   --                    indicates that the node corresponds to a construct\n-   --                    that appears in the original source program.\n-\n-   --   Analyzed         This flag is present in all nodes. It is set when\n-   --                    a node is analyzed, and is used to avoid analyzing\n-   --                    the same node twice. Analysis includes expansion if\n-   --                    expansion is active, so in this case if the flag is\n-   --                    set it means the node has been analyzed and expanded.\n-\n-   --   Error_Posted     This flag is present in all nodes. It is set when\n-   --                    an error message is posted which is associated with\n-   --                    the flagged node. This is used to avoid posting more\n-   --                    than one message on the same node.\n+   --                 This flag is present in all nodes. It is set if the\n+   --                 node is built by the scanner or parser, and clear if\n+   --                 the node is built by the analyzer or expander. It\n+   --                 indicates that the node corresponds to a construct\n+   --                 that appears in the original source program.\n+\n+   --   Analyzed      This flag is present in all nodes. It is set when\n+   --                 a node is analyzed, and is used to avoid analyzing\n+   --                 the same node twice. Analysis includes expansion if\n+   --                 expansion is active, so in this case if the flag is\n+   --                 set it means the node has been analyzed and expanded.\n+\n+   --   Error_Posted  This flag is present in all nodes. It is set when\n+   --                 an error message is posted which is associated with\n+   --                 the flagged node. This is used to avoid posting more\n+   --                 than one message on the same node.\n \n    --   Field1\n    --   Field2\n    --   Field3\n    --   Field4\n-   --   Field5           Five fields holding Union_Id values\n-\n-   --   ElistN           Synonym for FieldN typed as Elist_Id\n-   --   ListN            Synonym for FieldN typed as List_Id\n-   --   NameN            Synonym for FieldN typed as Name_Id\n-   --   NodeN            Synonym for FieldN typed as Node_Id\n-   --   StrN             Synonym for FieldN typed as String_Id\n-   --   UintN            Synonym for FieldN typed as Uint (Empty = Uint_0)\n-   --   UrealN           Synonym for FieldN typed as Ureal\n+   --   Field5        Five fields holding Union_Id values\n+\n+   --   ElistN        Synonym for FieldN typed as Elist_Id (Empty = No_Elist)\n+   --   ListN         Synonym for FieldN typed as List_Id\n+   --   NameN         Synonym for FieldN typed as Name_Id\n+   --   NodeN         Synonym for FieldN typed as Node_Id\n+   --   StrN          Synonym for FieldN typed as String_Id\n+   --   UintN         Synonym for FieldN typed as Uint (Empty = Uint_0)\n+   --   UrealN        Synonym for FieldN typed as Ureal\n+\n+   --   Note: in the case of ElistN and UintN fields, it is common that we\n+   --   end up with a value of Union_Id'(0) as the default value. This value\n+   --   is meaningless as a Uint or Elist_Id value. We have two choices here.\n+   --   We could require that all Uint and Elist fields be initialized to an\n+   --   appropriate value, but that's error prone, since it would be easy to\n+   --   miss an initialization. So instead we have the retrieval functions\n+   --   generate an appropriate default value (Uint_0 or No_Elist). Probably\n+   --   it would be cleaner to generate No_Uint in the Uint case but we got\n+   --   stuck with representing an \"unset\" size value as zero early on, and\n+   --   it will take a bit of fiddling to change that ???\n \n    --   Note: the actual usage of FieldN (i.e. whether it contains a Elist_Id,\n    --   List_Id, Name_Id, Node_Id, String_Id, Uint or Ureal), depends on the\n@@ -146,46 +157,46 @@ package Atree is\n    --   it is useful to be able to do untyped traversals, and an internal\n    --   package in Atree allows for direct untyped accesses in such cases.\n \n-   --   Flag4            Fifteen Boolean flags (use depends on Nkind and\n-   --   Flag5            Ekind, as described for FieldN). Again the access\n-   --   Flag6            is usually via subprograms in Sinfo and Einfo which\n-   --   Flag7            provide high-level synonyms for these flags, and\n-   --   Flag8            contain debugging code that checks that the values\n-   --   Flag9            in Nkind and Ekind are appropriate for the access.\n+   --   Flag4         Fifteen Boolean flags (use depends on Nkind and\n+   --   Flag5         Ekind, as described for FieldN). Again the access\n+   --   Flag6         is usually via subprograms in Sinfo and Einfo which\n+   --   Flag7         provide high-level synonyms for these flags, and\n+   --   Flag8         contain debugging code that checks that the values\n+   --   Flag9         in Nkind and Ekind are appropriate for the access.\n    --   Flag10\n-   --   Flag11           Note that Flag1-3 are missing from this list. The\n-   --   Flag12           first three flag positions are reserved for the\n-   --   Flag13           standard flags (Comes_From_Source, Error_Posted,\n-   --   Flag14           and Analyzed)\n+   --   Flag11        Note that Flag1-3 are missing from this list. The\n+   --   Flag12        first three flag positions are reserved for the\n+   --   Flag13        standard flags (Comes_From_Source, Error_Posted,\n+   --   Flag14        and Analyzed)\n    --   Flag15\n    --   Flag16\n    --   Flag17\n    --   Flag18\n \n-   --   Link             For a node, points to the Parent. For a list, points\n-   --                    to the list header. Note that in the latter case, a\n-   --                    client cannot modify the link field. This field is\n-   --                    private to the Atree package (but is also modified\n-   --                    by the Nlists package).\n+   --   Link          For a node, points to the Parent. For a list, points\n+   --                 to the list header. Note that in the latter case, a\n+   --                 client cannot modify the link field. This field is\n+   --                 private to the Atree package (but is also modified\n+   --                 by the Nlists package).\n \n    --  The following additional fields are present in extended nodes used\n    --  for entities (Nkind in N_Entity).\n \n-   --   Ekind            Entity type. This field indicates the type of the\n-   --                    entity, it is of type Entity_Kind which is defined\n-   --                    in package Einfo.\n+   --   Ekind         Entity type. This field indicates the type of the\n+   --                 entity, it is of type Entity_Kind which is defined\n+   --                 in package Einfo.\n \n-   --   Flag19           197 additional flags\n+   --   Flag19        197 additional flags\n    --   ...\n    --   Flag215\n \n-   --   Convention       Entity convention (Convention_Id value)\n+   --   Convention    Entity convention (Convention_Id value)\n \n-   --   Field6           Additional Union_Id value stored in tree\n+   --   Field6        Additional Union_Id value stored in tree\n \n-   --   Node6            Synonym for Field6 typed as Node_Id\n-   --   Elist6           Synonym for Field6 typed as Elist_Id\n-   --   Uint6            Synonym for Field6 typed as Uint (Empty = Uint_0)\n+   --   Node6         Synonym for Field6 typed as Node_Id\n+   --   Elist6        Synonym for Field6 typed as Elist_Id (Empty = No_Elist)\n+   --   Uint6         Synonym for Field6 typed as Uint (Empty = Uint_0)\n \n    --   Similar definitions for Field7 to Field27 (and Node7-Node27,\n    --   Elist7-Elist27, Uint7-Uint27, Ureal7-Ureal27). Note that not all\n@@ -981,6 +992,9 @@ package Atree is\n       function Elist23 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist23);\n \n+      function Elist24 (N : Node_Id) return Elist_Id;\n+      pragma Inline (Elist24);\n+\n       function Name1 (N : Node_Id) return Name_Id;\n       pragma Inline (Name1);\n \n@@ -1903,6 +1917,9 @@ package Atree is\n       procedure Set_Elist23 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist23);\n \n+      procedure Set_Elist24 (N : Node_Id; Val : Elist_Id);\n+      pragma Inline (Set_Elist24);\n+\n       procedure Set_Name1 (N : Node_Id; Val : Name_Id);\n       pragma Inline (Set_Name1);\n \n@@ -2602,7 +2619,6 @@ package Atree is\n       procedure Set_Flag215 (N : Node_Id; Val : Boolean);\n       pragma Inline (Set_Flag215);\n \n-\n       --  The following versions of Set_Noden also set the parent\n       --  pointer of the referenced node if it is non_Empty\n "}, {"sha": "c878a125afc4ebf6581dc0986487bf6a89c93db0", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -381,7 +381,7 @@ extern Node_Id Current_Error_Node;\n #define Field24(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field6)\n #define Field25(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field7)\n #define Field26(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field8)\n-#define Field27(N)    (Nodes_Ptr[(N) - First_Node_Id + 3].V.EX.field9)\n+#define Field27(N)    (Nodes_Ptr[(N) - First_Node_Id + 4].V.EX.field9)\n \n #define Node1(N)      Field1  (N)\n #define Node2(N)      Field2  (N)\n@@ -425,9 +425,11 @@ extern Node_Id Current_Error_Node;\n #define Elist8(N)     Field8  (N)\n #define Elist13(N)    Field13 (N)\n #define Elist15(N)    Field15 (N)\n+#define Elist16(N)    Field16 (N)\n #define Elist18(N)    Field18 (N)\n #define Elist21(N)    Field21 (N)\n #define Elist23(N)    Field23 (N)\n+#define Elist24(N)    Field24 (N)\n \n #define Name1(N)      Field1  (N)\n #define Name2(N)      Field2  (N)"}, {"sha": "900b69a7e2bd613bf9a6d11f99d0d53d40f4ade4", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 123, "deletions": 13, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -129,7 +129,7 @@ package body Einfo is\n    --    String_Literal_Low_Bound        Node15\n    --    Shared_Var_Read_Proc            Node15\n \n-   --    Access_Disp_Table               Node16\n+   --    Access_Disp_Table               Elist16\n    --    Cloned_Subtype                  Node16\n    --    DTC_Entity                      Node16\n    --    Entry_Formal                    Node16\n@@ -210,9 +210,13 @@ package body Einfo is\n    --    Protected_Operation             Node23\n \n    --    Obsolescent_Warning             Node24\n+   --    Task_Body_Procedure             Node24\n+   --    Abstract_Interfaces             Node24\n+\n+   --    Abstract_Interface_Alias        Node25\n \n-   --    (unused)                        Node25\n    --    (unused)                        Node26\n+\n    --    (unused)                        Node27\n \n    ---------------------------------------------\n@@ -428,8 +432,8 @@ package body Einfo is\n    --    Must_Be_On_Byte_Boundary       Flag183\n    --    Has_Stream_Size_Clause         Flag184\n    --    Is_Ada_2005                    Flag185\n+   --    Is_Interface                   Flag186\n \n-   --    (unused)                       Flag186\n    --    (unused)                       Flag187\n    --    (unused)                       Flag188\n    --    (unused)                       Flag189\n@@ -494,15 +498,31 @@ package body Einfo is\n    -- Attribute Access Functions --\n    --------------------------------\n \n+   function Abstract_Interfaces (Id : E) return L is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Record_Type\n+                       or else Ekind (Id) = E_Record_Subtype\n+                       or else Ekind (Id) = E_Record_Type_With_Private\n+                       or else Ekind (Id) = E_Record_Subtype_With_Private);\n+      return Elist24 (Id);\n+   end Abstract_Interfaces;\n+\n+   function Abstract_Interface_Alias (Id : E) return E is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Procedure or Ekind (Id) = E_Function);\n+      return Node25 (Id);\n+   end Abstract_Interface_Alias;\n+\n    function Accept_Address (Id : E) return L is\n    begin\n       return Elist21 (Id);\n    end Accept_Address;\n \n-   function Access_Disp_Table (Id : E) return E is\n+   function Access_Disp_Table (Id : E) return L is\n    begin\n       pragma Assert (Is_Tagged_Type (Id));\n-      return Node16 (Implementation_Base_Type (Id));\n+      return Elist16 (Implementation_Base_Type (Id));\n    end Access_Disp_Table;\n \n    function Actual_Subtype (Id : E) return E is\n@@ -1551,6 +1571,16 @@ package body Einfo is\n       return Flag11 (Id);\n    end Is_Inlined;\n \n+   function Is_Interface (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Record_Type\n+                       or else Ekind (Id) = E_Record_Subtype\n+                       or else Ekind (Id) = E_Record_Type_With_Private\n+                       or else Ekind (Id) = E_Record_Subtype_With_Private\n+                       or else Ekind (Id) = E_Class_Wide_Type);\n+      return Flag186 (Id);\n+   end Is_Interface;\n+\n    function Is_Instantiated (Id : E) return B is\n    begin\n       return Flag126 (Id);\n@@ -2207,6 +2237,13 @@ package body Einfo is\n       return Flag165 (Id);\n    end Suppress_Style_Checks;\n \n+   function Task_Body_Procedure (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Task_Type\n+                      or else Ekind (Id) = E_Task_Subtype);\n+      return Node24 (Id);\n+   end Task_Body_Procedure;\n+\n    function Treat_As_Volatile (Id : E) return B is\n    begin\n       return Flag41 (Id);\n@@ -2434,15 +2471,31 @@ package body Einfo is\n    -- Attribute Set Procedures --\n    ------------------------------\n \n+   procedure Set_Abstract_Interfaces (Id : E; V : L) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Record_Type\n+                       or else Ekind (Id) = E_Record_Subtype\n+                       or else Ekind (Id) = E_Record_Type_With_Private\n+                       or else Ekind (Id) = E_Record_Subtype_With_Private);\n+      Set_Elist24 (Id, V);\n+   end Set_Abstract_Interfaces;\n+\n+   procedure Set_Abstract_Interface_Alias (Id : E; V : E) is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Procedure or Ekind (Id) = E_Function);\n+      Set_Node25 (Id, V);\n+   end Set_Abstract_Interface_Alias;\n+\n    procedure Set_Accept_Address (Id : E; V : L) is\n    begin\n       Set_Elist21 (Id, V);\n    end Set_Accept_Address;\n \n-   procedure Set_Access_Disp_Table (Id : E; V : E) is\n+   procedure Set_Access_Disp_Table (Id : E; V : L) is\n    begin\n       pragma Assert (Is_Tagged_Type (Id) and then Id = Base_Type (Id));\n-      Set_Node16 (Id, V);\n+      Set_Elist16 (Id, V);\n    end Set_Access_Disp_Table;\n \n    procedure Set_Associated_Final_Chain (Id : E; V : E) is\n@@ -3527,6 +3580,15 @@ package body Einfo is\n       Set_Flag11 (Id, V);\n    end Set_Is_Inlined;\n \n+   procedure Set_Is_Interface (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Record_Type\n+                       or else Ekind (Id) = E_Record_Subtype\n+                       or else Ekind (Id) = E_Record_Type_With_Private\n+                       or else Ekind (Id) = E_Record_Subtype_With_Private);\n+      Set_Flag186 (Id, V);\n+   end Set_Is_Interface;\n+\n    procedure Set_Is_Instantiated (Id : E; V : B := True) is\n    begin\n       Set_Flag126 (Id, V);\n@@ -4194,6 +4256,13 @@ package body Einfo is\n       Set_Flag165 (Id, V);\n    end Set_Suppress_Style_Checks;\n \n+   procedure Set_Task_Body_Procedure (Id : E; V : N) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Task_Type\n+                      or else Ekind (Id) = E_Task_Subtype);\n+      Set_Node24 (Id, V);\n+   end Set_Task_Body_Procedure;\n+\n    procedure Set_Treat_As_Volatile (Id : E; V : B := True) is\n    begin\n       Set_Flag41 (Id, V);\n@@ -6039,11 +6108,11 @@ package body Einfo is\n       return Kind;\n    end Subtype_Kind;\n \n-   -------------------\n-   -- Tag_Component --\n-   -------------------\n+   -------------------------\n+   -- First_Tag_Component --\n+   -------------------------\n \n-   function Tag_Component (Id : E) return E is\n+   function First_Tag_Component (Id : E) return E is\n       Comp : Entity_Id;\n       Typ  : Entity_Id := Id;\n \n@@ -6070,7 +6139,34 @@ package body Einfo is\n       --  No tag component found\n \n       return Empty;\n-   end Tag_Component;\n+   end First_Tag_Component;\n+\n+   ------------------------\n+   -- Next_Tag_Component --\n+   ------------------------\n+\n+   function Next_Tag_Component (Id : E) return E is\n+      Comp : Entity_Id;\n+      Typ  : constant Entity_Id := Scope (Id);\n+\n+   begin\n+      pragma Assert (Ekind (Id) = E_Component\n+                       and then Is_Tagged_Type (Typ));\n+\n+      Comp := Next_Entity (Id);\n+      while Present (Comp) loop\n+         if Is_Tag (Comp) then\n+            pragma Assert (Chars (Comp) /= Name_uTag);\n+            return Comp;\n+         end if;\n+\n+         Comp := Next_Entity (Comp);\n+      end loop;\n+\n+      --  No tag component found\n+\n+      return Empty;\n+   end Next_Tag_Component;\n \n    ---------------------\n    -- Type_High_Bound --\n@@ -6311,6 +6407,7 @@ package body Einfo is\n       W (\"Is_Imported\",                   Flag24  (Id));\n       W (\"Is_Inlined\",                    Flag11  (Id));\n       W (\"Is_Instantiated\",               Flag126 (Id));\n+      W (\"Is_Interface\",                  Flag186 (Id));\n       W (\"Is_Internal\",                   Flag17  (Id));\n       W (\"Is_Interrupt_Handler\",          Flag89  (Id));\n       W (\"Is_Intrinsic_Subprogram\",       Flag64  (Id));\n@@ -6939,7 +7036,7 @@ package body Einfo is\n               E_Procedure                                =>\n             Write_Str (\"Alias\");\n \n-         when E_Record_Type                =>\n+         when E_Record_Type                              =>\n             Write_Str (\"Corresponding_Concurrent_Type\");\n \n          when E_Entry_Index_Parameter                    =>\n@@ -7255,9 +7352,18 @@ package body Einfo is\n    procedure Write_Field24_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Record_Type                              |\n+              E_Record_Subtype                           |\n+              E_Record_Type_With_Private                 |\n+              E_Record_Subtype_With_Private              =>\n+            Write_Str (\"Abstract_Interfaces\");\n+\n          when Subprogram_Kind                            =>\n             Write_Str (\"Obsolescent_Warning\");\n \n+         when Task_Kind                                  =>\n+            Write_Str (\"Task_Body_Procedure\");\n+\n          when others                                     =>\n             Write_Str (\"Field24??\");\n       end case;\n@@ -7270,6 +7376,10 @@ package body Einfo is\n    procedure Write_Field25_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Procedure                                |\n+              E_Function                                 =>\n+            Write_Str (\"Abstract_Interface_Alias\");\n+\n          when others                                     =>\n             Write_Str (\"Field25??\");\n       end case;"}, {"sha": "8218d9c66c5bafd8af340f40b52cf2750ca07400", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 74, "deletions": 22, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -286,6 +286,17 @@ package Einfo is\n --  and if assertions are enabled, an attempt to set the attribute on a\n --  subtype will raise an assert error.\n \n+--    Abstract_Interfaces (Elist24)\n+--       Present in record types and subtypes. List of abstract interfaces\n+--       implemented by a tagged type that are not already implemented by the\n+--       ancestors (Ada 2005: AI-251).\n+\n+--    Abstract_Interface_Alias (Node25)\n+--       Present in subprograms that cover a primitive operation of an abstract\n+--       interface type. Points to its associated interface subprogram. It is\n+--       used to register the subprogram in secondary dispatch table of the\n+--       interface (Ada 2005: AI-251).\n+\n --    Accept_Address (Elist21)\n --       Present in entries. If an accept has a statement sequence, then an\n --       address variable is created, which is used to hold the address of the\n@@ -313,9 +324,9 @@ package Einfo is\n --       rather irregular, and the semantic checks that depend on the nominal\n --       subtype being unconstrained use flag Is_Constr_Subt_For_U_Nominal(qv).\n \n---    Access_Disp_Table (Node16) [implementation base type only]\n+--    Access_Disp_Table (Elist16) [implementation base type only]\n --       Present in record type entities. For a tagged type, points to the\n---       dispatch table associated with the tagged type. For a non-tagged\n+--       dispatch tables associated with the tagged type. For a non-tagged\n --       record, contains Empty.\n \n --    Address_Clause (synthesized)\n@@ -1279,10 +1290,10 @@ package Einfo is\n --       function of a tagged type which can dispatch on result\n \n --    Has_Controlled_Component (Flag43) [base type only]\n---       Present in composite type entities. Indicates that the type has a\n---       component that either is a controlled type, or itself contains a\n---       controlled component (i.e. either Has_Controlled_Component or\n---       Is_Controlled is set for at least one component).\n+--       Present in all entities. Set only for composite type entities which\n+--       contain a component that either is a controlled type, or itself\n+--       contains controlled component (i.e. either Has_Controlled_Component\n+--       or Is_Controlled is set for at least one component).\n \n --    Has_Convention_Pragma (Flag119)\n --       Present in an entity for which a Convention, Import, or Export\n@@ -1959,6 +1970,15 @@ package Einfo is\n --    Is_Integer_Type (synthesized)\n --       Applies to all entities, true for integer types and subtypes\n \n+--    Is_Interface (Flag186)\n+--       Present in record types and subtypes to indicate that the current\n+--       entity corresponds with an abstract interface. Because abstract\n+--       interfaces are conceptually a special kind of abstract tagged types\n+--       we represent them by means of tagged record types and subtypes\n+--       marked with this attribute. This allows us to reuse most of the\n+--       compiler support for abstract tagged types to implement interfaces\n+--       (Ada 2005: AI-251).\n+\n --    Is_Internal (Flag17)\n --       Present in all entities. Set to indicate an entity created during\n --       semantic processing (e.g. an implicit type). Need more documentation\n@@ -2472,7 +2492,8 @@ package Einfo is\n --       accurately a storage unit boundary). The front end checks that\n --       component clauses respect this rule, and the back end ensures\n --       that record packing does not violate this rule. Currently the\n---       flag is set only for packed arrays longer than 64 bits.\n+--       flag is set only for packed arrays longer than 64 bits where\n+--       the component size is not a power of 2.\n \n --    Needs_Debug_Info (Flag147)\n --       Present in all entities. Set if the entity requires debugging\n@@ -3070,9 +3091,19 @@ package Einfo is\n --       Present in all entities. Suppresses any style checks specifically\n --       associated with the given entity if set.\n \n---    Tag_Component (synthesized)\n---       Applies to tagged record types, returns the entity for the _Tag\n---       field in this record, which must be present.\n+--    Task_Body_Procedure (Node24)\n+--       Present in task types and subtypes. Points to the entity for\n+--       the task body procedure (as further described in Exp_Ch9, task\n+--       bodies are expanded into procedures). A convenient function to\n+--       retrieve this field is Sem_Util.Get_Task_Body_Procedure.\n+\n+--    First_Tag_Component (synthesized)\n+--       Applies to tagged record types, returns the entity for the first\n+--       _Tag field in this record.\n+\n+--    Next_Tag_Component (synthesized)\n+--       Applies to components of tagged record types. Given a _Tag field\n+--       of a record, returns the next _Tag field in this record.\n \n --    Treat_As_Volatile (Flag41)\n --       Present in all type entities, and also in constants, components and\n@@ -3921,6 +3952,7 @@ package Einfo is\n    --    Can_Never_Be_Null             (Flag38)\n    --    Checks_May_Be_Suppressed      (Flag31)\n    --    Debug_Info_Off                (Flag166)\n+   --    Has_Controlled_Component      (Flag43)   (base type only)\n    --    Has_Convention_Pragma         (Flag119)\n    --    Has_Delayed_Freeze            (Flag18)\n    --    Has_Fully_Qualified_Name      (Flag173)\n@@ -4108,7 +4140,6 @@ package Einfo is\n    --    Packed_Array_Type             (Node23)\n    --    Component_Alignment           (special)  (base type only)\n    --    Has_Component_Size_Clause     (Flag68)   (base type only)\n-   --    Has_Controlled_Component      (Flag43)   (base type only)\n    --    Has_Pragma_Pack               (Flag121)  (base type only)\n    --    Is_Aliased                    (Flag15)\n    --    Is_Constrained                (Flag12)\n@@ -4137,7 +4168,6 @@ package Einfo is\n    --    First_Entity                  (Node17)\n    --    Equivalent_Type               (Node18)   (always Empty in type case)\n    --    Last_Entity                   (Node20)\n-   --    Has_Controlled_Component      (Flag43)   (base type only)\n    --    First_Component               (synth)\n    --    (plus type attributes)\n \n@@ -4165,6 +4195,7 @@ package Einfo is\n    --    Treat_As_Volatile             (Flag41)\n    --    Is_Protected_Private          (synth)\n    --    Next_Component                (synth)\n+   --    Next_Tag_Component            (synth)\n \n    --  E_Constant\n    --  E_Loop_Parameter\n@@ -4320,6 +4351,7 @@ package Einfo is\n    --    Inner_Instances               (Elist23)  (for a generic function)\n    --    Privals_Chain                 (Elist23)  (for a protected function)\n    --    Obsolescent_Warning           (Node24)\n+   --    Abstract_Interface_Alias      (Node25)\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    Function_Returns_With_DSP     (Flag169)\n@@ -4567,6 +4599,7 @@ package Einfo is\n    --    Inner_Instances               (Elist23)  (for a generic procedure)\n    --    Privals_Chain                 (Elist23)  (for a protected procedure)\n    --    Obsolescent_Warning           (Node24)\n+   --    Abstract_Interface_Alias      (Node25)\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Elaboration_Entity_Required   (Flag174)\n    --    Function_Returns_With_DSP     (Flag169)  (always False for procedure)\n@@ -4623,7 +4656,6 @@ package Einfo is\n    --    Scope_Depth_Value             (Uint22)\n    --    Scope_Depth                   (synth)\n    --    Stored_Constraint             (Elist23)\n-   --    Has_Controlled_Component      (Flag43)   (base type only)\n    --    Has_Interrupt_Handler         (synth)\n    --    Sec_Stack_Needed_For_Return   (Flag167) ???\n    --    Uses_Sec_Stack                (Flag95) ???\n@@ -4633,7 +4665,7 @@ package Einfo is\n    --  E_Record_Type\n    --  E_Record_Subtype\n    --    Primitive_Operations          (Elist15)\n-   --    Access_Disp_Table             (Node16)   (base type only)\n+   --    Access_Disp_Table             (Elist16)  (base type only)\n    --    Cloned_Subtype                (Node16)   (subtype case only)\n    --    First_Entity                  (Node17)\n    --    Corresponding_Concurrent_Type (Node18)\n@@ -4642,46 +4674,48 @@ package Einfo is\n    --    Discriminant_Constraint       (Elist21)\n    --    Corresponding_Remote_Type     (Node22)\n    --    Stored_Constraint             (Elist23)\n+   --    Abstract_Interfaces           (Elist24)\n    --    Component_Alignment           (special)  (base type only)\n    --    C_Pass_By_Copy                (Flag125)  (base type only)\n-   --    Has_Controlled_Component      (Flag43)   (base type only)\n    --    Has_External_Tag_Rep_Clause   (Flag110)\n    --    Has_Record_Rep_Clause         (Flag65)   (base type only)\n    --    Is_Class_Wide_Equivalent_Type (Flag35)\n    --    Is_Concurrent_Record_Type     (Flag20)\n    --    Is_Constrained                (Flag12)\n    --    Is_Controlled                 (Flag42)   (base type only)\n+   --    Is_Interface                  (Flag186)\n    --    Reverse_Bit_Order             (Flag164)  (base type only)\n    --    First_Component               (synth)\n    --    First_Discriminant            (synth)\n    --    First_Stored_Discriminant     (synth)\n-   --    Tag_Component                 (synth)\n+   --    First_Tag_Component           (synth)\n    --    (plus type attributes)\n \n    --  E_Record_Type_With_Private\n    --  E_Record_Subtype_With_Private\n    --    Primitive_Operations          (Elist15)\n-   --    Access_Disp_Table             (Node16)   (base type only)\n+   --    Access_Disp_Table             (Elist16)  (base type only)\n    --    First_Entity                  (Node17)\n    --    Private_Dependents            (Elist18)\n    --    Underlying_Full_View          (Node19)\n    --    Last_Entity                   (Node20)\n    --    Discriminant_Constraint       (Elist21)\n    --    Private_View                  (Node22)\n    --    Stored_Constraint             (Elist23)\n+   --    Abstract_Interfaces           (Elist24)\n    --    Has_Completion                (Flag26)\n    --    Has_Completion_In_Body        (Flag71)\n-   --    Has_Controlled_Component      (Flag43)   (base type only)\n    --    Has_Record_Rep_Clause         (Flag65)   (base type only)\n    --    Has_External_Tag_Rep_Clause   (Flag110)\n    --    Is_Concurrent_Record_Type     (Flag20)\n    --    Is_Constrained                (Flag12)\n    --    Is_Controlled                 (Flag42)   (base type only)\n+   --    Is_Interface                  (Flag186)\n    --    Reverse_Bit_Order             (Flag164)  (base type only)\n    --    First_Component               (synth)\n    --    First_Discriminant            (synth)\n    --    First_Stored_Discriminant     (synth)\n-   --    Tag_Component                 (synth)\n+   --    First_Tag_Component           (synth)\n    --    (plus type attributes)\n \n    --  E_Signed_Integer_Type\n@@ -4737,6 +4771,7 @@ package Einfo is\n    --    Scope_Depth_Value             (Uint22)\n    --    Scope_Depth                   (synth)\n    --    Stored_Constraint             (Elist23)\n+   --    Task_Body_Procedure           (Node24)\n    --    Delay_Cleanups                (Flag114)\n    --    Has_Master_Entity             (Flag21)\n    --    Has_Storage_Size_Clause       (Flag23)   (base type only)\n@@ -5006,11 +5041,13 @@ package Einfo is\n    --  section contains the functions used to obtain attribute values which\n    --  correspond to values in fields or flags in the entity itself.\n \n+   function Abstract_Interfaces                (Id : E) return L;\n    function Accept_Address                     (Id : E) return L;\n-   function Access_Disp_Table                  (Id : E) return E;\n+   function Access_Disp_Table                  (Id : E) return L;\n    function Actual_Subtype                     (Id : E) return E;\n    function Address_Taken                      (Id : E) return B;\n    function Alias                              (Id : E) return E;\n+   function Abstract_Interface_Alias           (Id : E) return E;\n    function Alignment                          (Id : E) return U;\n    function Associated_Final_Chain             (Id : E) return E;\n    function Associated_Formal_Package          (Id : E) return E;\n@@ -5189,6 +5226,7 @@ package Einfo is\n    function Is_Immediately_Visible             (Id : E) return B;\n    function Is_Imported                        (Id : E) return B;\n    function Is_Inlined                         (Id : E) return B;\n+   function Is_Interface                       (Id : E) return B;\n    function Is_Instantiated                    (Id : E) return B;\n    function Is_Internal                        (Id : E) return B;\n    function Is_Interrupt_Handler               (Id : E) return B;\n@@ -5302,6 +5340,7 @@ package Einfo is\n    function Suppress_Elaboration_Warnings      (Id : E) return B;\n    function Suppress_Init_Proc                 (Id : E) return B;\n    function Suppress_Style_Checks              (Id : E) return B;\n+   function Task_Body_Procedure                (Id : E) return N;\n    function Treat_As_Volatile                  (Id : E) return B;\n    function Underlying_Full_View               (Id : E) return E;\n    function Unset_Reference                    (Id : E) return N;\n@@ -5416,7 +5455,8 @@ package Einfo is\n    function Scope_Depth_Set                    (Id : E) return B;\n    function Size_Clause                        (Id : E) return N;\n    function Stream_Size_Clause                 (Id : E) return N;\n-   function Tag_Component                      (Id : E) return E;\n+   function First_Tag_Component                (Id : E) return E;\n+   function Next_Tag_Component                 (Id : E) return E;\n    function Type_High_Bound                    (Id : E) return N;\n    function Type_Low_Bound                     (Id : E) return N;\n    function Underlying_Type                    (Id : E) return E;\n@@ -5481,11 +5521,13 @@ package Einfo is\n    -- Attribute Set Procedures --\n    ------------------------------\n \n+   procedure Set_Abstract_Interfaces           (Id : E; V : L);\n    procedure Set_Accept_Address                (Id : E; V : L);\n-   procedure Set_Access_Disp_Table             (Id : E; V : E);\n+   procedure Set_Access_Disp_Table             (Id : E; V : L);\n    procedure Set_Actual_Subtype                (Id : E; V : E);\n    procedure Set_Address_Taken                 (Id : E; V : B := True);\n    procedure Set_Alias                         (Id : E; V : E);\n+   procedure Set_Abstract_Interface_Alias      (Id : E; V : E);\n    procedure Set_Alignment                     (Id : E; V : U);\n    procedure Set_Associated_Final_Chain        (Id : E; V : E);\n    procedure Set_Associated_Formal_Package     (Id : E; V : E);\n@@ -5667,6 +5709,7 @@ package Einfo is\n    procedure Set_Is_Immediately_Visible        (Id : E; V : B := True);\n    procedure Set_Is_Imported                   (Id : E; V : B := True);\n    procedure Set_Is_Inlined                    (Id : E; V : B := True);\n+   procedure Set_Is_Interface                  (Id : E; V : B := True);\n    procedure Set_Is_Instantiated               (Id : E; V : B := True);\n    procedure Set_Is_Internal                   (Id : E; V : B := True);\n    procedure Set_Is_Interrupt_Handler          (Id : E; V : B := True);\n@@ -5781,6 +5824,7 @@ package Einfo is\n    procedure Set_Suppress_Elaboration_Warnings (Id : E; V : B := True);\n    procedure Set_Suppress_Init_Proc            (Id : E; V : B := True);\n    procedure Set_Suppress_Style_Checks         (Id : E; V : B := True);\n+   procedure Set_Task_Body_Procedure           (Id : E; V : N);\n    procedure Set_Treat_As_Volatile             (Id : E; V : B := True);\n    procedure Set_Underlying_Full_View          (Id : E; V : E);\n    procedure Set_Unset_Reference               (Id : E; V : N);\n@@ -6012,10 +6056,12 @@ package Einfo is\n    --  subprograms meeting the requirements documented in the section on\n    --  XEINFO may be referenced in this section.\n \n+   pragma Inline (Abstract_Interfaces);\n    pragma Inline (Accept_Address);\n    pragma Inline (Access_Disp_Table);\n    pragma Inline (Actual_Subtype);\n    pragma Inline (Address_Taken);\n+   pragma Inline (Abstract_Interface_Alias);\n    pragma Inline (Alias);\n    pragma Inline (Alignment);\n    pragma Inline (Associated_Final_Chain);\n@@ -6216,6 +6262,7 @@ package Einfo is\n    pragma Inline (Is_Imported);\n    pragma Inline (Is_Incomplete_Or_Private_Type);\n    pragma Inline (Is_Inlined);\n+   pragma Inline (Is_Interface);\n    pragma Inline (Is_Instantiated);\n    pragma Inline (Is_Integer_Type);\n    pragma Inline (Is_Internal);\n@@ -6348,6 +6395,7 @@ package Einfo is\n    pragma Inline (Suppress_Elaboration_Warnings);\n    pragma Inline (Suppress_Init_Proc);\n    pragma Inline (Suppress_Style_Checks);\n+   pragma Inline (Task_Body_Procedure);\n    pragma Inline (Treat_As_Volatile);\n    pragma Inline (Underlying_Full_View);\n    pragma Inline (Unset_Reference);\n@@ -6362,10 +6410,12 @@ package Einfo is\n    pragma Inline (Init_Esize);\n    pragma Inline (Init_RM_Size);\n \n+   pragma Inline (Set_Abstract_Interfaces);\n    pragma Inline (Set_Accept_Address);\n    pragma Inline (Set_Access_Disp_Table);\n    pragma Inline (Set_Actual_Subtype);\n    pragma Inline (Set_Address_Taken);\n+   pragma Inline (Set_Abstract_Interface_Alias);\n    pragma Inline (Set_Alias);\n    pragma Inline (Set_Alignment);\n    pragma Inline (Set_Associated_Final_Chain);\n@@ -6543,6 +6593,7 @@ package Einfo is\n    pragma Inline (Set_Is_Immediately_Visible);\n    pragma Inline (Set_Is_Imported);\n    pragma Inline (Set_Is_Inlined);\n+   pragma Inline (Set_Is_Interface);\n    pragma Inline (Set_Is_Instantiated);\n    pragma Inline (Set_Is_Internal);\n    pragma Inline (Set_Is_Interrupt_Handler);\n@@ -6657,6 +6708,7 @@ package Einfo is\n    pragma Inline (Set_Suppress_Elaboration_Warnings);\n    pragma Inline (Set_Suppress_Init_Proc);\n    pragma Inline (Set_Suppress_Style_Checks);\n+   pragma Inline (Set_Task_Body_Procedure);\n    pragma Inline (Set_Treat_As_Volatile);\n    pragma Inline (Set_Underlying_Full_View);\n    pragma Inline (Set_Unset_Reference);"}, {"sha": "fd68f991430051251eaf9316a0aef65be9fe14fe", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -910,12 +910,14 @@ package body Exp_Aggr is\n                      Make_Selected_Component (Loc,\n                        Prefix =>  New_Copy_Tree (Indexed_Comp),\n                        Selector_Name =>\n-                         New_Reference_To (Tag_Component (Comp_Type), Loc)),\n+                         New_Reference_To\n+                           (First_Tag_Component (Comp_Type), Loc)),\n \n                    Expression =>\n                      Unchecked_Convert_To (RTE (RE_Tag),\n-                       New_Reference_To (\n-                         Access_Disp_Table (Comp_Type), Loc)));\n+                       New_Reference_To\n+                         (Node (First_Elmt (Access_Disp_Table (Comp_Type))),\n+                          Loc)));\n \n                Append_To (L, A);\n             end if;\n@@ -1711,8 +1713,9 @@ package body Exp_Aggr is\n               Make_Procedure_Call_Statement (Loc,\n                 Name =>\n                   New_Reference_To\n-                         (Find_Prim_Op (RTE (RE_Limited_Record_Controller),\n-                    Name_Initialize), Loc),\n+                    (Find_Prim_Op\n+                       (RTE (RE_Limited_Record_Controller), Name_Initialize),\n+                     Loc),\n                 Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n \n          else\n@@ -1727,8 +1730,10 @@ package body Exp_Aggr is\n             Append_To (L,\n               Make_Procedure_Call_Statement (Loc,\n                 Name =>\n-                  New_Reference_To (Find_Prim_Op (RTE (RE_Record_Controller),\n-                    Name_Initialize), Loc),\n+                  New_Reference_To\n+                    (Find_Prim_Op\n+                       (RTE (RE_Record_Controller), Name_Initialize),\n+                     Loc),\n                 Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n \n          end if;\n@@ -1869,13 +1874,16 @@ package body Exp_Aggr is\n                       Name =>\n                         Make_Selected_Component (Loc,\n                           Prefix => New_Copy_Tree (Target),\n-                          Selector_Name => New_Reference_To (\n-                            Tag_Component (Base_Type (Typ)), Loc)),\n+                          Selector_Name =>\n+                            New_Reference_To\n+                              (First_Tag_Component (Base_Type (Typ)), Loc)),\n \n                       Expression =>\n                         Unchecked_Convert_To (RTE (RE_Tag),\n-                          New_Reference_To (\n-                            Access_Disp_Table (Base_Type (Typ)), Loc)));\n+                          New_Reference_To\n+                            (Node (First_Elmt\n+                               (Access_Disp_Table (Base_Type (Typ)))),\n+                             Loc)));\n \n                   Set_Assignment_OK (Name (Instr));\n                   Append_To (L, Instr);\n@@ -2090,12 +2098,14 @@ package body Exp_Aggr is\n                         Make_Selected_Component (Loc,\n                           Prefix =>  New_Copy_Tree (Comp_Expr),\n                           Selector_Name =>\n-                            New_Reference_To (Tag_Component (Comp_Type), Loc)),\n+                            New_Reference_To\n+                              (First_Tag_Component (Comp_Type), Loc)),\n \n                       Expression =>\n                         Unchecked_Convert_To (RTE (RE_Tag),\n-                          New_Reference_To (\n-                            Access_Disp_Table (Comp_Type), Loc)));\n+                          New_Reference_To\n+                            (Node (First_Elmt (Access_Disp_Table (Comp_Type))),\n+                             Loc)));\n \n                   Append_To (L, Instr);\n                end if;\n@@ -2172,11 +2182,14 @@ package body Exp_Aggr is\n                Make_Selected_Component (Loc,\n                   Prefix => New_Copy_Tree (Target),\n                  Selector_Name =>\n-                   New_Reference_To (Tag_Component (Base_Type (Typ)), Loc)),\n+                   New_Reference_To\n+                     (First_Tag_Component (Base_Type (Typ)), Loc)),\n \n              Expression =>\n                Unchecked_Convert_To (RTE (RE_Tag),\n-                 New_Reference_To (Access_Disp_Table (Base_Type (Typ)), Loc)));\n+                 New_Reference_To\n+                   (Node (First_Elmt (Access_Disp_Table (Base_Type (Typ)))),\n+                    Loc)));\n \n          Append_To (L, Instr);\n       end if;\n@@ -2186,9 +2199,10 @@ package body Exp_Aggr is\n \n       if Present (Obj)\n         and then Finalize_Storage_Only (Typ)\n-        and then (Is_Library_Level_Entity (Obj)\n-        or else Entity (Constant_Value (RTE (RE_Garbage_Collected)))\n-                  = Standard_True)\n+        and then\n+          (Is_Library_Level_Entity (Obj)\n+             or else Entity (Constant_Value (RTE (RE_Garbage_Collected))) =\n+                                                              Standard_True)\n       then\n          Attach := Make_Integer_Literal (Loc, 0);\n \n@@ -2232,8 +2246,9 @@ package body Exp_Aggr is\n             Set_Assignment_OK (Ref);\n             Append_To (L,\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (\n-                  Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n+                Name =>\n+                  New_Reference_To\n+                    (Find_Prim_Op (Init_Typ, Name_Initialize), Loc),\n                 Parameter_Associations => New_List (New_Copy_Tree (Ref))));\n          end if;\n \n@@ -4282,7 +4297,9 @@ package body Exp_Aggr is\n               Parent_Expr => A);\n          else\n             Expand_Record_Aggregate (N,\n-              Orig_Tag    => New_Occurrence_Of (Access_Disp_Table (Typ), Loc),\n+              Orig_Tag    =>\n+                New_Occurrence_Of\n+                  (Node (First_Elmt (Access_Disp_Table (Typ))), Loc),\n               Parent_Expr => A);\n          end if;\n       end if;\n@@ -4649,7 +4666,9 @@ package body Exp_Aggr is\n             elsif Java_VM then\n                Tag_Value := Empty;\n             else\n-               Tag_Value := New_Occurrence_Of (Access_Disp_Table (Typ), Loc);\n+               Tag_Value :=\n+                 New_Occurrence_Of\n+                   (Node (First_Elmt (Access_Disp_Table (Typ))), Loc);\n             end if;\n \n             --  For a derived type, an aggregate for the parent is formed with\n@@ -4712,7 +4731,8 @@ package body Exp_Aggr is\n             elsif not Java_VM then\n                declare\n                   Tag_Name  : constant Node_Id :=\n-                                New_Occurrence_Of (Tag_Component (Typ), Loc);\n+                                New_Occurrence_Of\n+                                  (First_Tag_Component (Typ), Loc);\n                   Typ_Tag   : constant Entity_Id := RTE (RE_Tag);\n                   Conv_Node : constant Node_Id :=\n                                 Unchecked_Convert_To (Typ_Tag, Tag_Value);"}, {"sha": "e832c5a5457c097c53811c2588f6a09fef2df4a4", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -122,13 +122,6 @@ package body Exp_Attr is\n    --  A reference to a type within its own scope is resolved to a reference\n    --  to the current instance of the type in its initialization procedure.\n \n-   function Find_Inherited_TSS\n-     (Typ : Entity_Id;\n-      Nam : TSS_Name_Type) return Entity_Id;\n-   --  Returns the TSS of name Nam of Typ, or of its closest ancestor defining\n-   --  such a TSS. Empty is returned is neither Typ nor any of its ancestors\n-   --  have such a TSS.\n-\n    function Find_Stream_Subprogram\n      (Typ : Entity_Id;\n       Nam : TSS_Name_Type) return Entity_Id;\n@@ -3510,7 +3503,8 @@ package body Exp_Attr is\n             if not Java_VM then\n                Rewrite (N,\n                  Unchecked_Convert_To (RTE (RE_Tag),\n-                   New_Reference_To (Access_Disp_Table (Ttyp), Loc)));\n+                   New_Reference_To\n+                     (Node (First_Elmt (Access_Disp_Table (Ttyp))), Loc)));\n                Analyze_And_Resolve (N, RTE (RE_Tag));\n             end if;\n \n@@ -3519,7 +3513,7 @@ package body Exp_Attr is\n               Make_Selected_Component (Loc,\n                 Prefix => Relocate_Node (Pref),\n                 Selector_Name =>\n-                  New_Reference_To (Tag_Component (Ttyp), Loc)));\n+                  New_Reference_To (First_Tag_Component (Ttyp), Loc)));\n             Analyze_And_Resolve (N, RTE (RE_Tag));\n          end if;\n       end Tag;\n@@ -4423,41 +4417,6 @@ package body Exp_Attr is\n           Reason => CE_Overflow_Check_Failed));\n    end Expand_Pred_Succ;\n \n-   ------------------------\n-   -- Find_Inherited_TSS --\n-   ------------------------\n-\n-   function Find_Inherited_TSS\n-     (Typ : Entity_Id;\n-      Nam : TSS_Name_Type) return Entity_Id\n-   is\n-      Btyp : Entity_Id := Typ;\n-      Proc : Entity_Id;\n-\n-   begin\n-      loop\n-         Btyp := Base_Type (Btyp);\n-         Proc :=  TSS (Btyp, Nam);\n-\n-         exit when Present (Proc)\n-           or else not Is_Derived_Type (Btyp);\n-\n-         --  If Typ is a derived type, it may inherit attributes from\n-         --  some ancestor.\n-\n-         Btyp := Etype (Btyp);\n-      end loop;\n-\n-      if No (Proc) then\n-\n-         --  If nothing else, use the TSS of the root type\n-\n-         Proc := TSS (Base_Type (Underlying_Type (Typ)), Nam);\n-      end if;\n-\n-      return Proc;\n-   end Find_Inherited_TSS;\n-\n    ----------------------------\n    -- Find_Stream_Subprogram --\n    ----------------------------"}, {"sha": "06d8e7c0c00aba7f37cedecfa77d4093857fe09b", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -1067,6 +1067,29 @@ package body Exp_Ch11 is\n       Str   : String_Id;\n \n    begin\n+      --  If a string expression is present, then the raise statement is\n+      --  converted to a call:\n+\n+      --     Raise_Exception (exception-name'Identity, string);\n+\n+      --  and there is nothing else to do\n+\n+      if Present (Expression (N)) then\n+         Rewrite (N,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (RTE (RE_Raise_Exception), Loc),\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix => Name (N),\n+                 Attribute_Name => Name_Identity),\n+               Expression (N))));\n+         Analyze (N);\n+         return;\n+      end if;\n+\n+      --  Remaining processing is for the case where no string expression\n+      --  is present.\n+\n       --  There is no expansion needed for statement \"raise <exception>;\" when\n       --  compiling for the JVM since the JVM has a built-in exception\n       --  mechanism. However we need the keep the expansion for \"raise;\""}, {"sha": "b3517bf18ba0b367e8672be8ea6b562588e6d60d", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 185, "deletions": 157, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -1512,11 +1512,12 @@ package body Exp_Ch3 is\n                   Make_Selected_Component (Loc,\n                     Prefix =>  New_Copy_Tree (Lhs),\n                     Selector_Name =>\n-                      New_Reference_To (Tag_Component (Typ), Loc)),\n+                      New_Reference_To (First_Tag_Component (Typ), Loc)),\n \n                 Expression =>\n                   Unchecked_Convert_To (RTE (RE_Tag),\n-                    New_Reference_To (Access_Disp_Table (Typ), Loc))));\n+                    New_Reference_To\n+                      (Node (First_Elmt (Access_Disp_Table (Typ))), Loc))));\n          end if;\n \n          --  Adjust the component if controlled except if it is an\n@@ -1825,10 +1826,11 @@ package body Exp_Ch3 is\n                   Make_Selected_Component (Loc,\n                     Prefix => Make_Identifier (Loc, Name_uInit),\n                     Selector_Name =>\n-                      New_Reference_To (Tag_Component (Rec_Type), Loc)),\n+                      New_Reference_To (First_Tag_Component (Rec_Type), Loc)),\n \n                 Expression =>\n-                  New_Reference_To (Access_Disp_Table (Rec_Type), Loc));\n+                  New_Reference_To\n+                    (Node (First_Elmt (Access_Disp_Table (Rec_Type))), Loc));\n \n             --  The tag must be inserted before the assignments to other\n             --  components,  because the initial value of the component may\n@@ -3497,18 +3499,20 @@ package body Exp_Ch3 is\n                end;\n             end if;\n \n-            --  For tagged types, when an init value is given, the tag has\n-            --  to be re-initialized separately in order to avoid the\n-            --  propagation of a wrong tag coming from a view conversion\n-            --  unless the type is class wide (in this case the tag comes\n-            --  from the init value). Suppress the tag assignment when\n-            --  Java_VM because JVM tags are represented implicitly\n-            --  in objects. Ditto for types that are CPP_CLASS.\n+            --  For tagged types, when an init value is given, the tag has to\n+            --  be re-initialized separately in order to avoid the propagation\n+            --  of a wrong tag coming from a view conversion unless the type\n+            --  is class wide (in this case the tag comes from the init\n+            --  value). Suppress the tag assignment when Java_VM because JVM\n+            --  tags are represented implicitly in objects. Ditto for types\n+            --  that are CPP_CLASS, and for initializations that are\n+            --  aggregates, because they have to have the right tag.\n \n             if Is_Tagged_Type (Typ)\n               and then not Is_Class_Wide_Type (Typ)\n               and then not Is_CPP_Class (Typ)\n               and then not Java_VM\n+              and then Nkind (Expr) /= N_Aggregate\n             then\n                --  The re-assignment of the tag has to be done even if\n                --  the object is a constant\n@@ -3517,7 +3521,7 @@ package body Exp_Ch3 is\n                  Make_Selected_Component (Loc,\n                     Prefix => New_Reference_To (Def_Id, Loc),\n                     Selector_Name =>\n-                      New_Reference_To (Tag_Component (Typ), Loc));\n+                      New_Reference_To (First_Tag_Component (Typ), Loc));\n \n                Set_Assignment_OK (New_Ref);\n \n@@ -3527,7 +3531,10 @@ package body Exp_Ch3 is\n                    Expression =>\n                      Unchecked_Convert_To (RTE (RE_Tag),\n                        New_Reference_To\n-                         (Access_Disp_Table (Base_Type (Typ)), Loc))));\n+                         (Node\n+                           (First_Elmt\n+                             (Access_Disp_Table (Base_Type (Typ)))),\n+                          Loc))));\n \n             --  For discrete types, set the Is_Known_Valid flag if the\n             --  initializing value is known to be valid.\n@@ -3553,8 +3560,8 @@ package body Exp_Ch3 is\n                end if;\n \n                --  For access types set the Is_Known_Non_Null flag if the\n-               --  initializing value is known to be non-null. We can also\n-               --  set Can_Never_Be_Null if this is a constant.\n+               --  initializing value is known to be non-null. We can also set\n+               --  Can_Never_Be_Null if this is a constant.\n \n                if Known_Non_Null (Expr) then\n                   Set_Is_Known_Non_Null (Def_Id);\n@@ -3575,21 +3582,33 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         if Is_Possibly_Unaligned_Slice (Expr) then\n+         --  Cases where the back end cannot handle the initialization\n+         --  directly. In such cases, we expand an assignment that will\n+         --  be appropriately handled by Expand_N_Assignment_Statement.\n \n-            --  Make a separate assignment that will be expanded into a\n-            --  loop, to bypass back-end problems with misaligned arrays.\n+         --  The exclusion of the unconstrained case is wrong, but for\n+         --  now it is too much trouble ???\n \n+         if (Is_Possibly_Unaligned_Slice (Expr)\n+               or else (Is_Possibly_Unaligned_Object (Expr)\n+                          and then not Represented_As_Scalar (Etype (Expr))))\n+\n+            --  The exclusion of the unconstrained case is wrong, but for\n+            --  now it is too much trouble ???\n+\n+           and then not (Is_Array_Type (Etype (Expr))\n+                           and then not Is_Constrained (Etype (Expr)))\n+         then\n             declare\n                Stat : constant Node_Id :=\n                        Make_Assignment_Statement (Loc,\n-                         Name => New_Reference_To (Def_Id, Loc),\n+                         Name       => New_Reference_To (Def_Id, Loc),\n                          Expression => Relocate_Node (Expr));\n-\n             begin\n                Set_Expression (N, Empty);\n                Set_No_Initialization (N);\n                Set_Assignment_OK (Name (Stat));\n+               Set_No_Ctrl_Actions (Stat);\n                Insert_After (N, Stat);\n                Analyze (Stat);\n             end;\n@@ -3612,10 +3631,10 @@ package body Exp_Ch3 is\n    -- Expand_N_Subtype_Indication --\n    ---------------------------------\n \n-   --  Add a check on the range of the subtype. The static case is\n-   --  partially duplicated by Process_Range_Expr_In_Decl in Sem_Ch3,\n-   --  but we still need to check here for the static case in order to\n-   --  avoid generating extraneous expanded code.\n+   --  Add a check on the range of the subtype. The static case is partially\n+   --  duplicated by Process_Range_Expr_In_Decl in Sem_Ch3, but we still need\n+   --  to check here for the static case in order to avoid generating\n+   --  extraneous expanded code.\n \n    procedure Expand_N_Subtype_Indication (N : Node_Id) is\n       Ran : constant Node_Id   := Range_Expression (Constraint (N));\n@@ -3634,18 +3653,17 @@ package body Exp_Ch3 is\n    -- Expand_N_Variant_Part --\n    ---------------------------\n \n-   --  If the last variant does not contain the Others choice, replace\n-   --  it with an N_Others_Choice node since Gigi always wants an Others.\n-   --  Note that we do not bother to call Analyze on the modified variant\n-   --  part, since it's only effect would be to compute the contents of\n-   --  the Others_Discrete_Choices node laboriously, and of course we\n-   --  already know the list of choices that corresponds to the others\n-   --  choice (it's the list we are replacing!)\n+   --  If the last variant does not contain the Others choice, replace it with\n+   --  an N_Others_Choice node since Gigi always wants an Others. Note that we\n+   --  do not bother to call Analyze on the modified variant part, since it's\n+   --  only effect would be to compute the contents of the\n+   --  Others_Discrete_Choices node laboriously, and of course we already know\n+   --  the list of choices that corresponds to the others choice (it's the\n+   --  list we are replacing!)\n \n    procedure Expand_N_Variant_Part (N : Node_Id) is\n       Last_Var    : constant Node_Id := Last_Non_Pragma (Variants (N));\n       Others_Node : Node_Id;\n-\n    begin\n       if Nkind (First (Discrete_Choices (Last_Var))) /= N_Others_Choice then\n          Others_Node := Make_Others_Choice (Sloc (Last_Var));\n@@ -3737,9 +3755,9 @@ package body Exp_Ch3 is\n          Set_Null_Present (Comp_List, False);\n \n       else\n-         --  The controller cannot be placed before the _Parent field\n-         --  since gigi lays out field in order and _parent must be\n-         --  first to preserve the polymorphism of tagged types.\n+         --  The controller cannot be placed before the _Parent field since\n+         --  gigi lays out field in order and _parent must be first to\n+         --  preserve the polymorphism of tagged types.\n \n          First_Comp := First (Component_Items (Comp_List));\n \n@@ -3757,9 +3775,9 @@ package body Exp_Ch3 is\n       Set_Ekind (Ent, E_Component);\n       Init_Component_Location (Ent);\n \n-      --  Move the _controller entity ahead in the list of internal\n-      --  entities of the enclosing record so that it is selected\n-      --  instead of a potentially inherited one.\n+      --  Move the _controller entity ahead in the list of internal entities\n+      --  of the enclosing record so that it is selected instead of a\n+      --  potentially inherited one.\n \n       declare\n          E    : constant Entity_Id := Last_Entity (T);\n@@ -3818,7 +3836,7 @@ package body Exp_Ch3 is\n \n       Comp_Decl :=\n         Make_Component_Declaration (Sloc_N,\n-          Defining_Identifier => Tag_Component (T),\n+          Defining_Identifier => First_Tag_Component (T),\n           Component_Definition =>\n             Make_Component_Definition (Sloc_N,\n               Aliased_Present => False,\n@@ -3835,8 +3853,8 @@ package body Exp_Ch3 is\n       end if;\n \n       --  We don't Analyze the whole expansion because the tag component has\n-      --  already been analyzed previously. Here we just insure that the\n-      --  tree is coherent with the semantic decoration\n+      --  already been analyzed previously. Here we just insure that the tree\n+      --  is coherent with the semantic decoration\n \n       Find_Type (Subtype_Indication (Component_Definition (Comp_Decl)));\n \n@@ -3856,10 +3874,10 @@ package body Exp_Ch3 is\n    begin\n       if not Is_Bit_Packed_Array (Typ) then\n \n-         --  If the component contains tasks, so does the array type.\n-         --  This may not be indicated in the array type because the\n-         --  component may have been a private type at the point of\n-         --  definition. Same if component type is controlled.\n+         --  If the component contains tasks, so does the array type. This may\n+         --  not be indicated in the array type because the component may have\n+         --  been a private type at the point of definition. Same if component\n+         --  type is controlled.\n \n          Set_Has_Task (Base, Has_Task (Component_Type (Typ)));\n          Set_Has_Controlled_Component (Base,\n@@ -3868,9 +3886,9 @@ package body Exp_Ch3 is\n \n          if No (Init_Proc (Base)) then\n \n-            --  If this is an anonymous array created for a declaration\n-            --  with an initial value, its init_proc will never be called.\n-            --  The initial value itself may have been expanded into assign-\n+            --  If this is an anonymous array created for a declaration with\n+            --  an initial value, its init_proc will never be called. The\n+            --  initial value itself may have been expanded into assign-\n             --  ments, in which case the object declaration is carries the\n             --  No_Initialization flag.\n \n@@ -3911,9 +3929,9 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-      --  For packed case, there is a default initialization, except\n-      --  if the component type is itself a packed structure with an\n-      --  initialization procedure.\n+      --  For packed case, there is a default initialization, except if the\n+      --  component type is itself a packed structure with an initialization\n+      --  procedure.\n \n       elsif Present (Init_Proc (Component_Type (Base)))\n         and then No (Base_Init_Proc (Base))\n@@ -3943,8 +3961,8 @@ package body Exp_Ch3 is\n       pragma Warnings (Off, Func);\n \n    begin\n-      --  Various optimization are possible if the given representation\n-      --  is contiguous.\n+      --  Various optimization are possible if the given representation is\n+      --  contiguous.\n \n       Is_Contiguous := True;\n       Ent := First_Literal (Typ);\n@@ -3987,9 +4005,9 @@ package body Exp_Ch3 is\n       --    typA : array (Natural range 0 .. num - 1) of ctype :=\n       --             (v, v, v, v, v, ....)\n \n-      --  where ctype is the corresponding integer type. If the\n-      --  representation is contiguous, we only keep the first literal,\n-      --  which provides the offset for Pos_To_Rep computations.\n+      --  where ctype is the corresponding integer type. If the representation\n+      --  is contiguous, we only keep the first literal, which provides the\n+      --  offset for Pos_To_Rep computations.\n \n       Arr :=\n         Make_Defining_Identifier (Loc,\n@@ -4044,22 +4062,22 @@ package body Exp_Ch3 is\n       --  representation) raises Constraint_Error or returns a unique value\n       --  of minus one. The latter case is used, e.g. in 'Valid code.\n \n-      --  Note: the reason we use Enum_Rep values in the case here is to\n-      --  avoid the code generator making inappropriate assumptions about\n-      --  the range of the values in the case where the value is invalid.\n-      --  ityp is a signed or unsigned integer type of appropriate width.\n+      --  Note: the reason we use Enum_Rep values in the case here is to avoid\n+      --  the code generator making inappropriate assumptions about the range\n+      --  of the values in the case where the value is invalid. ityp is a\n+      --  signed or unsigned integer type of appropriate width.\n \n       --  Note: if exceptions are not supported, then we suppress the raise\n       --  and return -1 unconditionally (this is an erroneous program in any\n-      --  case and there is no obligation to raise Constraint_Error here!)\n-      --  We also do this if pragma Restrictions (No_Exceptions) is active.\n+      --  case and there is no obligation to raise Constraint_Error here!) We\n+      --  also do this if pragma Restrictions (No_Exceptions) is active.\n \n       --  Representations are signed\n \n       if Enumeration_Rep (First_Literal (Typ)) < 0 then\n \n          --  The underlying type is signed. Reset the Is_Unsigned_Type\n-         --  explicitly, because it might have been inherited from a\n+         --  explicitly, because it might have been inherited from\n          --  parent type.\n \n          Set_Is_Unsigned_Type (Typ, False);\n@@ -4080,8 +4098,8 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n-      --  The body of the function is a case statement. First collect\n-      --  case alternatives, or optimize the contiguous case.\n+      --  The body of the function is a case statement. First collect case\n+      --  alternatives, or optimize the contiguous case.\n \n       Lst := New_List;\n \n@@ -4303,29 +4321,28 @@ package body Exp_Ch3 is\n       end loop;\n \n       --  Creation of the Dispatch Table. Note that a Dispatch Table is\n-      --  created for regular tagged types as well as for Ada types\n-      --  deriving from a C++ Class, but not for tagged types directly\n-      --  corresponding to the C++ classes. In the later case we assume\n-      --  that the Vtable is created in the C++ side and we just use it.\n+      --  created for regular tagged types as well as for Ada types deriving\n+      --  from a C++ Class, but not for tagged types directly corresponding to\n+      --  the C++ classes. In the later case we assume that the Vtable is\n+      --  created in the C++ side and we just use it.\n \n       if Is_Tagged_Type (Def_Id) then\n          if Is_CPP_Class (Def_Id) then\n             Set_All_DT_Position (Def_Id);\n             Set_Default_Constructor (Def_Id);\n \n          else\n-            --  Usually inherited primitives are not delayed but the first\n-            --  Ada extension of a CPP_Class is an exception since the\n-            --  address of the inherited subprogram has to be inserted in\n-            --  the new Ada Dispatch Table and this is a freezing action\n-            --  (usually the inherited primitive address is inserted in the\n-            --  DT by Inherit_DT)\n-\n-            --  Similarly, if this is an inherited operation whose parent\n-            --  is not frozen yet, it is not in the DT of the parent, and\n-            --  we generate an explicit freeze node for the inherited\n-            --  operation, so that it is properly inserted in the DT of the\n-            --  current type.\n+            --  Usually inherited primitives are not delayed but the first Ada\n+            --  extension of a CPP_Class is an exception since the address of\n+            --  the inherited subprogram has to be inserted in the new Ada\n+            --  Dispatch Table and this is a freezing action (usually the\n+            --  inherited primitive address is inserted in the DT by\n+            --  Inherit_DT)\n+\n+            --  Similarly, if this is an inherited operation whose parent is\n+            --  not frozen yet, it is not in the DT of the parent, and we\n+            --  generate an explicit freeze node for the inherited operation,\n+            --  so that it is properly inserted in the DT of the current type.\n \n             declare\n                Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Def_Id));\n@@ -4355,11 +4372,10 @@ package body Exp_Ch3 is\n                Expand_Tagged_Root (Def_Id);\n             end if;\n \n-            --  Unfreeze momentarily the type to add the predefined\n-            --  primitives operations. The reason we unfreeze is so\n-            --  that these predefined operations will indeed end up\n-            --  as primitive operations (which must be before the\n-            --  freeze point).\n+            --  Unfreeze momentarily the type to add the predefined primitives\n+            --  operations. The reason we unfreeze is so that these predefined\n+            --  operations will indeed end up as primitive operations (which\n+            --  must be before the freeze point).\n \n             Set_Is_Frozen (Def_Id, False);\n             Make_Predefined_Primitive_Specs\n@@ -4369,22 +4385,22 @@ package body Exp_Ch3 is\n             Set_All_DT_Position (Def_Id);\n \n             --  Add the controlled component before the freezing actions\n-            --  it is referenced in those actions.\n+            --  referenced in those actions.\n \n             if Has_New_Controlled_Component (Def_Id) then\n                Expand_Record_Controller (Def_Id);\n             end if;\n \n-            --  Suppress creation of a dispatch table when Java_VM because\n-            --  the dispatching mechanism is handled internally by the JVM.\n+            --  Suppress creation of a dispatch table when Java_VM because the\n+            --  dispatching mechanism is handled internally by the JVM.\n \n             if not Java_VM then\n                Append_Freeze_Actions (Def_Id, Make_DT (Def_Id));\n             end if;\n \n-            --  Make sure that the primitives Initialize, Adjust and\n-            --  Finalize are Frozen before other TSS subprograms. We\n-            --  don't want them Frozen inside.\n+            --  Make sure that the primitives Initialize, Adjust and Finalize\n+            --  are Frozen before other TSS subprograms. We don't want them\n+            --  Frozen inside.\n \n             if Is_Controlled (Def_Id) then\n                if not Is_Limited_Type (Def_Id) then\n@@ -4408,8 +4424,8 @@ package body Exp_Ch3 is\n               (Def_Id, Predefined_Primitive_Freeze (Def_Id));\n          end if;\n \n-      --  In the non-tagged case, an equality function is provided only\n-      --  for variant records (that are not unchecked unions).\n+      --  In the non-tagged case, an equality function is provided only for\n+      --  variant records (that are not unchecked unions).\n \n       elsif Has_Discriminants (Def_Id)\n         and then not Is_Limited_Type (Def_Id)\n@@ -4428,10 +4444,10 @@ package body Exp_Ch3 is\n       end if;\n \n       --  Before building the record initialization procedure, if we are\n-      --  dealing with a concurrent record value type, then we must go\n-      --  through the discriminants, exchanging discriminals between the\n-      --  concurrent type and the concurrent record value type. See the\n-      --  section \"Handling of Discriminants\" in the Einfo spec for details.\n+      --  dealing with a concurrent record value type, then we must go through\n+      --  the discriminants, exchanging discriminals between the concurrent\n+      --  type and the concurrent record value type. See the section \"Handling\n+      --  of Discriminants\" in the Einfo spec for details.\n \n       if Is_Concurrent_Record_Type (Def_Id)\n         and then Has_Discriminants (Def_Id)\n@@ -4472,10 +4488,9 @@ package body Exp_Ch3 is\n       Adjust_Discriminants (Def_Id);\n       Build_Record_Init_Proc (Type_Decl, Def_Id);\n \n-      --  For tagged type, build bodies of primitive operations. Note\n-      --  that we do this after building the record initialization\n-      --  experiment, since the primitive operations may need the\n-      --  initialization routine\n+      --  For tagged type, build bodies of primitive operations. Note that we\n+      --  do this after building the record initialization experiment, since\n+      --  the primitive operations may need the initialization routine\n \n       if Is_Tagged_Type (Def_Id) then\n          Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n@@ -4525,15 +4540,16 @@ package body Exp_Ch3 is\n    -- Freeze_Type --\n    -----------------\n \n-   --  Full type declarations are expanded at the point at which the type\n-   --  is frozen. The formal N is the Freeze_Node for the type. Any statements\n-   --  or declarations generated by the freezing (e.g. the procedure generated\n+   --  Full type declarations are expanded at the point at which the type is\n+   --  frozen. The formal N is the Freeze_Node for the type. Any statements or\n+   --  declarations generated by the freezing (e.g. the procedure generated\n    --  for initialization) are chained in the Acions field list of the freeze\n    --  node using Append_Freeze_Actions.\n \n-   procedure Freeze_Type (N : Node_Id) is\n+   function Freeze_Type (N : Node_Id) return Boolean is\n       Def_Id    : constant Entity_Id := Entity (N);\n       RACW_Seen : Boolean := False;\n+      Result    : Boolean := False;\n \n    begin\n       --  Process associated access types needing special processing\n@@ -4566,13 +4582,13 @@ package body Exp_Ch3 is\n          if Ekind (Def_Id) = E_Record_Type then\n             Freeze_Record_Type (N);\n \n-         --  The subtype may have been declared before the type was frozen.\n-         --  If the type has controlled components it is necessary to create\n-         --  the entity for the controller explicitly because it did not\n-         --  exist at the point of the subtype declaration. Only the entity is\n-         --  needed, the back-end will obtain the layout from the type.\n-         --  This is only necessary if this is constrained subtype whose\n-         --  component list is not shared with the base type.\n+         --  The subtype may have been declared before the type was frozen. If\n+         --  the type has controlled components it is necessary to create the\n+         --  entity for the controller explicitly because it did not exist at\n+         --  the point of the subtype declaration. Only the entity is needed,\n+         --  the back-end will obtain the layout from the type. This is only\n+         --  necessary if this is constrained subtype whose component list is\n+         --  not shared with the base type.\n \n          elsif Ekind (Def_Id) = E_Record_Subtype\n            and then Has_Discriminants (Def_Id)\n@@ -4596,8 +4612,20 @@ package body Exp_Ch3 is\n                end if;\n             end;\n \n-         --  Similar process if the controller of the subtype is not\n-         --  present but the parent has it. This can happen with constrained\n+            if Is_Itype (Def_Id)\n+              and then Is_Record_Type (Underlying_Type (Scope (Def_Id)))\n+            then\n+               --  The freeze node is only used to introduce the controller,\n+               --  the back-end has no use for it for a discriminated\n+               --   component.\n+\n+               Set_Freeze_Node (Def_Id, Empty);\n+               Set_Has_Delayed_Freeze (Def_Id, False);\n+               Result := True;\n+            end if;\n+\n+         --  Similar process if the controller of the subtype is not present\n+         --  but the parent has it. This can happen with constrained\n          --  record components where the subtype is an itype.\n \n          elsif Ekind (Def_Id) = E_Record_Subtype\n@@ -4620,7 +4648,7 @@ package body Exp_Ch3 is\n \n                Set_Freeze_Node (Def_Id, Empty);\n                Set_Has_Delayed_Freeze (Def_Id, False);\n-               Remove (N);\n+               Result := True;\n             end;\n          end if;\n \n@@ -4689,9 +4717,9 @@ package body Exp_Ch3 is\n                   DT_Align : Node_Id;\n \n                begin\n-                  --  For unconstrained composite types we give a size of\n-                  --  zero so that the pool knows that it needs a special\n-                  --  algorithm for variable size object allocation.\n+                  --  For unconstrained composite types we give a size of zero\n+                  --  so that the pool knows that it needs a special algorithm\n+                  --  for variable size object allocation.\n \n                   if Is_Composite_Type (Desig_Type)\n                     and then not Is_Constrained (Desig_Type)\n@@ -4718,11 +4746,10 @@ package body Exp_Ch3 is\n                     Make_Defining_Identifier (Loc,\n                       Chars => New_External_Name (Chars (Def_Id), 'P'));\n \n-                  --  We put the code associated with the pools in the\n-                  --  entity that has the later freeze node, usually the\n-                  --  acces type but it can also be the designated_type;\n-                  --  because the pool code requires both those types to be\n-                  --  frozen\n+                  --  We put the code associated with the pools in the entity\n+                  --  that has the later freeze node, usually the acces type\n+                  --  but it can also be the designated_type; because the pool\n+                  --  code requires both those types to be frozen\n \n                   if Is_Frozen (Desig_Type)\n                     and then (not Present (Freeze_Node (Desig_Type))\n@@ -4784,16 +4811,16 @@ package body Exp_Ch3 is\n                null;\n             end if;\n \n-            --  For access-to-controlled types (including class-wide types\n-            --  and Taft-amendment types which potentially have controlled\n-            --  components), expand the list controller object that will\n-            --  store the dynamically allocated objects. Do not do this\n+            --  For access-to-controlled types (including class-wide types and\n+            --  Taft-amendment types which potentially have controlled\n+            --  components), expand the list controller object that will store\n+            --  the dynamically allocated objects. Do not do this\n             --  transformation for expander-generated access types, but do it\n             --  for types that are the full view of types derived from other\n             --  private types. Also suppress the list controller in the case\n             --  of a designated type with convention Java, since this is used\n-            --  when binding to Java API specs, where there's no equivalent\n-            --  of a finalization list and we don't want to pull in the\n+            --  when binding to Java API specs, where there's no equivalent of\n+            --  a finalization list and we don't want to pull in the\n             --  finalization support if not needed.\n \n             if not Comes_From_Source (Def_Id)\n@@ -4864,20 +4891,21 @@ package body Exp_Ch3 is\n         and then Freeze_Node (Full_View (Def_Id)) = N\n       then\n          Set_Entity (N, Full_View (Def_Id));\n-         Freeze_Type (N);\n+         Result := Freeze_Type (N);\n          Set_Entity (N, Def_Id);\n \n-      --  All other types require no expander action. There are such\n-      --  cases (e.g. task types and protected types). In such cases,\n-      --  the freeze nodes are there for use by Gigi.\n+      --  All other types require no expander action. There are such cases\n+      --  (e.g. task types and protected types). In such cases, the freeze\n+      --  nodes are there for use by Gigi.\n \n       end if;\n \n       Freeze_Stream_Operations (N, Def_Id);\n+      return Result;\n \n    exception\n       when RE_Not_Available =>\n-         return;\n+         return False;\n    end Freeze_Type;\n \n    -------------------------\n@@ -4902,10 +4930,10 @@ package body Exp_Ch3 is\n       --  These are the values computed by the procedure Check_Subtype_Bounds\n \n       procedure Check_Subtype_Bounds;\n-      --  This procedure examines the subtype T, and its ancestor subtypes\n-      --  and derived types to determine the best known information about\n-      --  the bounds of the subtype. After the call Lo_Bound is set either\n-      --  to No_Uint if no information can be determined, or to a value which\n+      --  This procedure examines the subtype T, and its ancestor subtypes and\n+      --  derived types to determine the best known information about the\n+      --  bounds of the subtype. After the call Lo_Bound is set either to\n+      --  No_Uint if no information can be determined, or to a value which\n       --  represents a known low bound, i.e. a valid value of the subtype can\n       --  not be less than this value. Hi_Bound is similarly set to a known\n       --  high bound (valid value cannot be greater than this).\n@@ -4969,16 +4997,16 @@ package body Exp_Ch3 is\n    begin\n       --  For a private type, we should always have an underlying type\n       --  (because this was already checked in Needs_Simple_Initialization).\n-      --  What we do is to get the value for the underlying type and then\n-      --  do an Unchecked_Convert to the private type.\n+      --  What we do is to get the value for the underlying type and then do\n+      --  an Unchecked_Convert to the private type.\n \n       if Is_Private_Type (T) then\n          Val := Get_Simple_Init_Val (Underlying_Type (T), Loc, Size);\n \n-         --  A special case, if the underlying value is null, then qualify\n-         --  it with the underlying type, so that the null is properly typed\n-         --  Similarly, if it is an aggregate it must be qualified, because\n-         --  an unchecked conversion does not provide a context for it.\n+         --  A special case, if the underlying value is null, then qualify it\n+         --  with the underlying type, so that the null is properly typed\n+         --  Similarly, if it is an aggregate it must be qualified, because an\n+         --  unchecked conversion does not provide a context for it.\n \n          if Nkind (Val) = N_Null\n            or else Nkind (Val) = N_Aggregate\n@@ -5007,9 +5035,9 @@ package body Exp_Ch3 is\n       elsif Is_Scalar_Type (T) then\n          pragma Assert (Init_Or_Norm_Scalars);\n \n-         --  Compute size of object. If it is given by the caller, we can\n-         --  use it directly, otherwise we use Esize (T) as an estimate. As\n-         --  far as we know this covers all cases correctly.\n+         --  Compute size of object. If it is given by the caller, we can use\n+         --  it directly, otherwise we use Esize (T) as an estimate. As far as\n+         --  we know this covers all cases correctly.\n \n          if Size = No_Uint or else Size <= Uint_0 then\n             Size_To_Use := UI_Max (Uint_1, Esize (T));\n@@ -5074,9 +5102,9 @@ package body Exp_Ch3 is\n \n                begin\n                   --  Normally we like to use the most negative number. The\n-                  --  one exception is when this number is in the known subtype\n-                  --  range and the largest positive number is not in the known\n-                  --  subtype range.\n+                  --  one exception is when this number is in the known\n+                  --  subtype range and the largest positive number is not in\n+                  --  the known subtype range.\n \n                   --  For this exceptional case, use largest positive value\n \n@@ -5491,29 +5519,29 @@ package body Exp_Ch3 is\n    begin\n       Renamed_Eq := Empty;\n \n-      --  Spec of _Alignment\n+      --  Spec of _Size\n \n       Append_To (Res, Predef_Spec_Or_Body (Loc,\n         Tag_Typ => Tag_Typ,\n-        Name    => Name_uAlignment,\n+        Name    => Name_uSize,\n         Profile => New_List (\n           Make_Parameter_Specification (Loc,\n             Defining_Identifier => Make_Defining_Identifier (Loc, Name_X),\n             Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n \n-        Ret_Type => Standard_Integer));\n+        Ret_Type => Standard_Long_Long_Integer));\n \n-      --  Spec of _Size\n+      --  Spec of _Alignment\n \n       Append_To (Res, Predef_Spec_Or_Body (Loc,\n         Tag_Typ => Tag_Typ,\n-        Name    => Name_uSize,\n+        Name    => Name_uAlignment,\n         Profile => New_List (\n           Make_Parameter_Specification (Loc,\n             Defining_Identifier => Make_Defining_Identifier (Loc, Name_X),\n             Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n \n-        Ret_Type => Standard_Long_Long_Integer));\n+        Ret_Type => Standard_Integer));\n \n       --  Specs for dispatching stream attributes. We skip these for limited\n       --  types, since there is no question of dispatching in the limited case."}, {"sha": "fcb7c9375ade4e78fca5c39fc757c7c219132caa", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -82,9 +82,13 @@ package Exp_Ch3 is\n    --  initialization call corresponds to a default initialized component\n    --  of an aggregate.\n \n-   procedure Freeze_Type (N : Node_Id);\n-   --  This procedure executes the freezing actions associated with the given\n-   --  freeze type node N.\n+   function Freeze_Type (N : Node_Id) return Boolean;\n+   --  This function executes the freezing actions associated with the given\n+   --  freeze type node N and returns True if the node is to be deleted.\n+   --  We delete the node if it is present just for front end purpose and\n+   --  we don't want Gigi to see the node.  This function can't delete the\n+   --  node itself since it would confuse any remaining processing of the\n+   --  freeze node.\n \n    function Needs_Simple_Initialization (T : Entity_Id) return Boolean;\n    --  Certain types need initialization even though there is no specific"}, {"sha": "525bf67c2c35ed7194fe254b94e0bf0df7c2b193", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 94, "deletions": 63, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -458,11 +458,13 @@ package body Exp_Ch4 is\n                   Make_Selected_Component (Loc,\n                     Prefix => New_Reference_To (Temp, Loc),\n                     Selector_Name =>\n-                      New_Reference_To (Tag_Component (T), Loc)),\n+                      New_Reference_To (First_Tag_Component (T), Loc)),\n \n                 Expression =>\n                   Unchecked_Convert_To (RTE (RE_Tag),\n-                    New_Reference_To (Access_Disp_Table (T), Loc)));\n+                    New_Reference_To\n+                      (Elists.Node (First_Elmt (Access_Disp_Table (T))),\n+                       Loc)));\n \n             --  The previous assignment has to be done in any case\n \n@@ -487,12 +489,13 @@ package body Exp_Ch4 is\n                      Make_Selected_Component (Loc,\n                        Prefix => Ref,\n                        Selector_Name =>\n-                         New_Reference_To (Tag_Component (Utyp), Loc)),\n+                         New_Reference_To (First_Tag_Component (Utyp), Loc)),\n \n                    Expression =>\n                      Unchecked_Convert_To (RTE (RE_Tag),\n                        New_Reference_To (\n-                         Access_Disp_Table (Utyp), Loc)));\n+                         Elists.Node (First_Elmt (Access_Disp_Table (Utyp))),\n+                         Loc)));\n \n                Set_Assignment_OK (Name (Tag_Assign));\n                Insert_Action (N, Tag_Assign);\n@@ -1063,10 +1066,16 @@ package body Exp_Ch4 is\n          Test := Expand_Composite_Equality\n                    (Nod, Component_Type (Typ), L, R, Decls);\n \n-         --  If some (sub)component is an unchecked_union, the whole\n-         --  operation will raise program error.\n+         --  If some (sub)component is an unchecked_union, the whole operation\n+         --  will raise program error.\n \n          if Nkind (Test) = N_Raise_Program_Error then\n+\n+            --  This node is going to be inserted at a location where a\n+            --  statement is expected: clear its Etype so analysis will\n+            --  set it to the expected Standard_Void_Type.\n+\n+            Set_Etype (Test, Empty);\n             return Test;\n \n          else\n@@ -1160,6 +1169,7 @@ package body Exp_Ch4 is\n            Handle_One_Dimension (N + 1, Next_Index (Index)));\n \n          if Need_Separate_Indexes then\n+\n             --  Generate guard for loop, followed by increments of indices\n \n             Append_To (Stm_List,\n@@ -1188,8 +1198,8 @@ package body Exp_Ch4 is\n                     Expressions    => New_List (New_Reference_To (Bn, Loc)))));\n          end if;\n \n-         --  If separate indexes, we need a declare block for An and Bn,\n-         --  and a loop without an iteration scheme.\n+         --  If separate indexes, we need a declare block for An and Bn, and a\n+         --  loop without an iteration scheme.\n \n          if Need_Separate_Indexes then\n             Loop_Stm :=\n@@ -1419,61 +1429,69 @@ package body Exp_Ch4 is\n       Typ : constant Entity_Id  := Etype (N);\n \n    begin\n-      if Is_Bit_Packed_Array (Typ) then\n+      --  Special case of bit packed array where both operands are known\n+      --  to be properly aligned. In this case we use an efficient run time\n+      --  routine to carry out the operation (see System.Bit_Ops).\n+\n+      if Is_Bit_Packed_Array (Typ)\n+        and then not Is_Possibly_Unaligned_Object (Left_Opnd (N))\n+        and then not Is_Possibly_Unaligned_Object (Right_Opnd (N))\n+      then\n          Expand_Packed_Boolean_Operator (N);\n+         return;\n+      end if;\n \n-      else\n-         --  For the normal non-packed case, the general expansion is\n-         --  to build a function for carrying out the comparison (using\n-         --  Make_Boolean_Array_Op) and then inserting it into the tree.\n-         --  The original operator node is then rewritten as a call to\n-         --  this function.\n+      --  For the normal non-packed case, the general expansion is to build\n+      --  function for carrying out the comparison (use Make_Boolean_Array_Op)\n+      --  and then inserting it into the tree. The original operator node is\n+      --  then rewritten as a call to this function. We also use this in the\n+      --  packed case if either operand is a possibly unaligned object.\n \n-         declare\n-            Loc       : constant Source_Ptr := Sloc (N);\n-            L         : constant Node_Id    := Relocate_Node (Left_Opnd  (N));\n-            R         : constant Node_Id    := Relocate_Node (Right_Opnd (N));\n-            Func_Body : Node_Id;\n-            Func_Name : Entity_Id;\n+      declare\n+         Loc       : constant Source_Ptr := Sloc (N);\n+         L         : constant Node_Id    := Relocate_Node (Left_Opnd  (N));\n+         R         : constant Node_Id    := Relocate_Node (Right_Opnd (N));\n+         Func_Body : Node_Id;\n+         Func_Name : Entity_Id;\n \n-         begin\n-            Convert_To_Actual_Subtype (L);\n-            Convert_To_Actual_Subtype (R);\n-            Ensure_Defined (Etype (L), N);\n-            Ensure_Defined (Etype (R), N);\n-            Apply_Length_Check (R, Etype (L));\n-\n-            if Nkind (Parent (N)) = N_Assignment_Statement\n-               and then Safe_In_Place_Array_Op (Name (Parent (N)), L, R)\n-            then\n-               Build_Boolean_Array_Proc_Call (Parent (N), L, R);\n+      begin\n+         Convert_To_Actual_Subtype (L);\n+         Convert_To_Actual_Subtype (R);\n+         Ensure_Defined (Etype (L), N);\n+         Ensure_Defined (Etype (R), N);\n+         Apply_Length_Check (R, Etype (L));\n+\n+         if Nkind (Parent (N)) = N_Assignment_Statement\n+           and then Safe_In_Place_Array_Op (Name (Parent (N)), L, R)\n+         then\n+            Build_Boolean_Array_Proc_Call (Parent (N), L, R);\n \n-            elsif Nkind (Parent (N)) = N_Op_Not\n-               and then Nkind (N) = N_Op_And\n-               and then\n-                 Safe_In_Place_Array_Op (Name (Parent (Parent (N))), L, R)\n-            then\n-               return;\n-            else\n+         elsif Nkind (Parent (N)) = N_Op_Not\n+           and then Nkind (N) = N_Op_And\n+           and then\n+         Safe_In_Place_Array_Op (Name (Parent (Parent (N))), L, R)\n+         then\n+            return;\n+         else\n \n-               Func_Body := Make_Boolean_Array_Op (Etype (L), N);\n-               Func_Name := Defining_Unit_Name (Specification (Func_Body));\n-               Insert_Action (N, Func_Body);\n+            Func_Body := Make_Boolean_Array_Op (Etype (L), N);\n+            Func_Name := Defining_Unit_Name (Specification (Func_Body));\n+            Insert_Action (N, Func_Body);\n \n-               --  Now rewrite the expression with a call\n+            --  Now rewrite the expression with a call\n \n-               Rewrite (N,\n-                 Make_Function_Call (Loc,\n-                   Name => New_Reference_To (Func_Name, Loc),\n-                   Parameter_Associations =>\n-                     New_List\n-                       (L, Make_Type_Conversion\n-                          (Loc, New_Reference_To (Etype (L), Loc), R))));\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name                   => New_Reference_To (Func_Name, Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+                    L,\n+                    Make_Type_Conversion\n+                      (Loc, New_Reference_To (Etype (L), Loc), R))));\n \n-               Analyze_And_Resolve (N, Typ);\n-            end if;\n-         end;\n-      end if;\n+            Analyze_And_Resolve (N, Typ);\n+         end if;\n+      end;\n    end Expand_Boolean_Operator;\n \n    -------------------------------\n@@ -4254,20 +4272,25 @@ package body Exp_Ch4 is\n                Force_Validity_Checks := Save_Force_Validity_Checks;\n             end;\n \n-         --  Packed case\n+         --  Packed case where both operands are known aligned\n \n-         elsif Is_Bit_Packed_Array (Typl) then\n+         elsif Is_Bit_Packed_Array (Typl)\n+           and then not Is_Possibly_Unaligned_Object (Lhs)\n+           and then not Is_Possibly_Unaligned_Object (Rhs)\n+         then\n             Expand_Packed_Eq (N);\n \n          --  Where the component type is elementary we can use a block bit\n          --  comparison (if supported on the target) exception in the case\n          --  of floating-point (negative zero issues require element by\n          --  element comparison), and atomic types (where we must be sure\n-         --  to load elements independently).\n+         --  to load elements independently) and possibly unaligned arrays.\n \n          elsif Is_Elementary_Type (Component_Type (Typl))\n            and then not Is_Floating_Point_Type (Component_Type (Typl))\n            and then not Is_Atomic (Component_Type (Typl))\n+           and then not Is_Possibly_Unaligned_Object (Lhs)\n+           and then not Is_Possibly_Unaligned_Object (Rhs)\n            and then Support_Composite_Compare_On_Target\n          then\n             null;\n@@ -5278,9 +5301,13 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  Case of array operand. If bit packed, handle it in Exp_Pakd\n+      --  Case of array operand. If bit packed with a component size of 1,\n+      --  handle it in Exp_Pakd if the operand is known to be aligned.\n \n-      if Is_Bit_Packed_Array (Typ) and then Component_Size (Typ) = 1 then\n+      if Is_Bit_Packed_Array (Typ)\n+        and then Component_Size (Typ) = 1\n+        and then not Is_Possibly_Unaligned_Object (Right_Opnd (N))\n+      then\n          Expand_Packed_Not (N);\n          return;\n       end if;\n@@ -7984,22 +8011,26 @@ package body Exp_Ch4 is\n       Obj_Tag :=\n         Make_Selected_Component (Loc,\n           Prefix        => Relocate_Node (Left),\n-          Selector_Name => New_Reference_To (Tag_Component (Left_Type), Loc));\n+          Selector_Name =>\n+            New_Reference_To (First_Tag_Component (Left_Type), Loc));\n \n       if Is_Class_Wide_Type (Right_Type) then\n          return\n            Make_DT_Access_Action (Left_Type,\n              Action => CW_Membership,\n              Args   => New_List (\n                Obj_Tag,\n-               New_Reference_To (\n-                 Access_Disp_Table (Root_Type (Right_Type)), Loc)));\n+               New_Reference_To\n+                 (Node (First_Elmt\n+                          (Access_Disp_Table (Root_Type (Right_Type)))),\n+                  Loc)));\n       else\n          return\n            Make_Op_Eq (Loc,\n            Left_Opnd  => Obj_Tag,\n            Right_Opnd =>\n-             New_Reference_To (Access_Disp_Table (Right_Type), Loc));\n+             New_Reference_To\n+               (Node (First_Elmt (Access_Disp_Table (Right_Type))), Loc));\n       end if;\n \n    end Tagged_Membership;"}, {"sha": "d78da78dbcb5fbc75cc18554b2a0fd76c800d456", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,6 +27,7 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch11; use Exp_Ch11;\n@@ -454,13 +455,13 @@ package body Exp_Ch5 is\n             end if;\n          end Check_Unconstrained_Bit_Packed_Array;\n \n-      --  Gigi can always handle the assignment if the right side is a string\n-      --  literal (note that overlap is definitely impossible in this case).\n-      --  If the type is packed, a string literal is always converted into a\n-      --  aggregate, except in the case of a null slice, for which no aggregate\n-      --  can be written. In that case, rewrite the assignment as a null\n-      --  statement, a length check has already been emitted to verify that\n-      --  the range of the left-hand side is empty.\n+      --  The back end can always handle the assignment if the right side is a\n+      --  string literal (note that overlap is definitely impossible in this\n+      --  case). If the type is packed, a string literal is always converted\n+      --  into aggregate, except in the case of a null slice, for which no\n+      --  aggregate can be written. In that case, rewrite the assignment as a\n+      --  null statement, a length check has already been emitted to verify\n+      --  that the range of the left-hand side is empty.\n \n       --  Note that this code is not executed if we had an assignment of\n       --  a string literal to a non-bit aligned component of a record, a\n@@ -479,7 +480,7 @@ package body Exp_Ch5 is\n       --  If either operand is bit packed, then we need a loop, since we\n       --  can't be sure that the slice is byte aligned. Similarly, if either\n       --  operand is a possibly unaligned slice, then we need a loop (since\n-      --  gigi cannot handle unaligned slices).\n+      --  the back end cannot handle unaligned slices).\n \n       elsif Is_Bit_Packed_Array (L_Type)\n         or else Is_Bit_Packed_Array (R_Type)\n@@ -490,7 +491,7 @@ package body Exp_Ch5 is\n \n       --  If we are not bit-packed, and we have only one slice, then no\n       --  overlap is possible except in the parameter case, so we can let\n-      --  gigi handle things.\n+      --  the back end handle things.\n \n       elsif not (L_Slice and R_Slice) then\n          if Forwards_OK (N) then\n@@ -641,7 +642,6 @@ package body Exp_Ch5 is\n          if not Loop_Required then\n             if Forwards_OK (N) then\n                return;\n-\n             else\n                null;\n                --  Here is where a memmove would be appropriate ???\n@@ -843,7 +843,7 @@ package body Exp_Ch5 is\n             then\n \n                --  Call TSS procedure for array assignment, passing the\n-               --  the explicit bounds of right- and left-hand side.\n+               --  the explicit bounds of right and left hand sides.\n \n                declare\n                   Proc    : constant Node_Id :=\n@@ -999,13 +999,20 @@ package body Exp_Ch5 is\n            Make_Assignment_Statement (Loc,\n              Name =>\n                Make_Indexed_Component (Loc,\n-                 Prefix => Duplicate_Subexpr (Larray, Name_Req => True),\n+                 Prefix      => Duplicate_Subexpr (Larray, Name_Req => True),\n                  Expressions => ExprL),\n              Expression =>\n                Make_Indexed_Component (Loc,\n-                 Prefix => Duplicate_Subexpr (Rarray, Name_Req => True),\n+                 Prefix      => Duplicate_Subexpr (Rarray, Name_Req => True),\n                  Expressions => ExprR));\n \n+         --  We set assignment OK, since there are some cases, e.g. in object\n+         --  declarations, where we are actually assigning into a constant.\n+         --  If there really is an illegality, it was caught long before now,\n+         --  and was flagged when the original assignment was analyzed.\n+\n+         Set_Assignment_OK (Name (Assign));\n+\n          --  Propagate the No_Ctrl_Actions flag to individual assignments\n \n          Set_No_Ctrl_Actions (Assign, No_Ctrl_Actions (N));\n@@ -1356,9 +1363,8 @@ package body Exp_Ch5 is\n    -- Expand_N_Assignment_Statement --\n    -----------------------------------\n \n-   --  For array types, deal with slice assignments and setting the flags\n-   --  to indicate if it can be statically determined which direction the\n-   --  move should go in. Also deal with generating range/length checks.\n+   --  This procedure implements various cases where an assignment statement\n+   --  cannot just be passed on to the back end in untransformed state.\n \n    procedure Expand_N_Assignment_Statement (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n@@ -1469,7 +1475,8 @@ package body Exp_Ch5 is\n \n             declare\n                Uses_Transient_Scope : constant Boolean :=\n-                  Scope_Is_Transient and then N = Node_To_Be_Wrapped;\n+                                        Scope_Is_Transient\n+                                          and then N = Node_To_Be_Wrapped;\n \n             begin\n                if Uses_Transient_Scope then\n@@ -1647,8 +1654,6 @@ package body Exp_Ch5 is\n          Expand_Bit_Packed_Element_Set (N);\n          return;\n \n-      --  Case of tagged type assignment\n-\n       elsif Is_Tagged_Type (Typ)\n         or else (Controlled_Type (Typ) and then not Is_Array_Type (Typ))\n       then\n@@ -1673,19 +1678,23 @@ package body Exp_Ch5 is\n \n             if Is_Class_Wide_Type (Typ)\n \n-            --  If the type is tagged, we may as well use the predefined\n-            --  primitive assignment. This avoids inlining a lot of code\n-            --  and in the class-wide case, the assignment is replaced by\n-            --  a dispatch call to _assign. Note that this cannot be done\n-            --  when discriminant checks are locally suppressed (as in\n-            --  extension aggregate expansions) because otherwise the\n-            --  discriminant check will be performed within the _assign\n-            --  call.\n-\n-            or else (Is_Tagged_Type (Typ)\n-              and then Chars (Current_Scope) /= Name_uAssign\n-              and then Expand_Ctrl_Actions\n-              and then not Discriminant_Checks_Suppressed (Empty))\n+               --  If the type is tagged, we may as well use the predefined\n+               --  primitive assignment. This avoids inlining a lot of code\n+               --  and in the class-wide case, the assignment is replaced by\n+               --  dispatch call to _assign. Note that this cannot be done\n+               --  when discriminant checks are locally suppressed (as in\n+               --  extension aggregate expansions) because otherwise the\n+               --  discriminant check will be performed within the _assign\n+               --  call. It is also suppressed for assignmments created by the\n+               --  expander that correspond to initializations, where we do\n+               --  want to copy the tag (No_Ctrl_Actions flag set True).\n+               --  by the expander and we do not need to mess with tags ever\n+               --  (Expand_Ctrl_Actions flag is set True in this case).\n+\n+               or else (Is_Tagged_Type (Typ)\n+                          and then Chars (Current_Scope) /= Name_uAssign\n+                          and then Expand_Ctrl_Actions\n+                          and then not Discriminant_Checks_Suppressed (Empty))\n             then\n                --  Fetch the primitive op _assign and proper type to call\n                --  it. Because of possible conflits between private and\n@@ -1787,8 +1796,8 @@ package body Exp_Ch5 is\n             then\n                declare\n                   Blk : constant Entity_Id :=\n-                    New_Internal_Entity (\n-                      E_Block, Current_Scope, Sloc (N), 'B');\n+                          New_Internal_Entity\n+                            (E_Block, Current_Scope, Sloc (N), 'B');\n \n                begin\n                   Set_Scope (Blk, Current_Scope);\n@@ -2784,11 +2793,13 @@ package body Exp_Ch5 is\n                       Make_Selected_Component (Loc,\n                         Prefix => Duplicate_Subexpr (Exp),\n                         Selector_Name =>\n-                          New_Reference_To (Tag_Component (Utyp), Loc)),\n+                          New_Reference_To (First_Tag_Component (Utyp), Loc)),\n                     Right_Opnd =>\n                       Unchecked_Convert_To (RTE (RE_Tag),\n                         New_Reference_To\n-                          (Access_Disp_Table (Base_Type (Utyp)), Loc))),\n+                          (Node (First_Elmt\n+                                  (Access_Disp_Table (Base_Type (Utyp)))),\n+                           Loc))),\n                 Reason => CE_Tag_Check_Failed));\n \n          --  If the result type is a specific nonlimited tagged type,\n@@ -3155,7 +3166,8 @@ package body Exp_Ch5 is\n              Expression =>\n                Make_Selected_Component (Loc,\n                  Prefix        => Duplicate_Subexpr_No_Checks (L),\n-                 Selector_Name => New_Reference_To (Tag_Component (T), Loc))));\n+                 Selector_Name => New_Reference_To (First_Tag_Component (T),\n+                                                    Loc))));\n \n       --  Otherwise Tag_Tmp not used\n \n@@ -3194,7 +3206,8 @@ package body Exp_Ch5 is\n             --  Index of first byte to be copied after outermost record\n             --  controller data.\n \n-            Expr, Source_Size      : Node_Id;\n+            Expr, Source_Size     : Node_Id;\n+            Source_Actual_Subtype : Entity_Id;\n             --  Used for computation of the size of the data to be copied\n \n             Range_Type  : Entity_Id;\n@@ -3269,26 +3282,27 @@ package body Exp_Ch5 is\n                Expr := Expression (Expr);\n             end if;\n \n+            Source_Actual_Subtype := Etype (Expr);\n+\n+            if Has_Discriminants (Source_Actual_Subtype)\n+              and then not Is_Constrained (Source_Actual_Subtype)\n+            then\n+               Append_To (Res,\n+                 Build_Actual_Subtype (Source_Actual_Subtype, Expr));\n+               Source_Actual_Subtype := Defining_Identifier (Last (Res));\n+            end if;\n+\n             Source_Size :=\n               Make_Op_Add (Loc,\n                 Left_Opnd =>\n                   Make_Attribute_Reference (Loc,\n                     Prefix =>\n-                      Expr,\n+                      New_Occurrence_Of (Source_Actual_Subtype, Loc),\n                     Attribute_Name =>\n                       Name_Size),\n                 Right_Opnd =>\n                   Make_Integer_Literal (Loc,\n                   System_Storage_Unit - 1));\n-\n-            --  If Expr is a type conversion, standard Ada does not allow\n-            --  'Size to be taken on it, but Gigi can handle this case,\n-            --  and thus we can determine the amount of data to be copied.\n-            --  The appropriate circuitry is enabled only for conversions\n-            --  that do not Come_From_Source.\n-\n-            Set_Comes_From_Source (Prefix (Left_Opnd (Source_Size)), False);\n-\n             Source_Size :=\n               Make_Op_Divide (Loc,\n                 Left_Opnd => Source_Size,\n@@ -3484,7 +3498,8 @@ package body Exp_Ch5 is\n              Name =>\n                Make_Selected_Component (Loc,\n                  Prefix        => Duplicate_Subexpr_No_Checks (L),\n-                 Selector_Name => New_Reference_To (Tag_Component (T), Loc)),\n+                 Selector_Name => New_Reference_To (First_Tag_Component (T),\n+                                                    Loc)),\n              Expression => New_Reference_To (Tag_Tmp, Loc)));\n       end if;\n "}, {"sha": "05c886a5be1b1669ebaf201e02cdd850a904e86a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -162,7 +162,7 @@ package body Exp_Ch9 is\n       Pid       : Node_Id;\n       N_Op_Spec : Node_Id) return Node_Id;\n    --  This function is used to construct the protected version of a protected\n-   --  subprogram. Its statement sequence first defers abortion, then locks\n+   --  subprogram. Its statement sequence first defers abort, then locks\n    --  the associated protected object, and then enters a block that contains\n    --  a call to the unprotected version of the subprogram (for details, see\n    --  Build_Unprotected_Subprogram_Body). This block statement requires\n@@ -2531,10 +2531,9 @@ package body Exp_Ch9 is\n    -----------------------------------\n \n    function Build_Task_Proc_Specification (T : Entity_Id) return Node_Id is\n-      Loc  : constant Source_Ptr := Sloc (T);\n-      Nam  : constant Name_Id    := Chars (T);\n-      Tdec : constant Node_Id    := Declaration_Node (T);\n-      Ent  : Entity_Id;\n+      Loc : constant Source_Ptr := Sloc (T);\n+      Nam : constant Name_Id    := Chars (T);\n+      Ent : Entity_Id;\n \n    begin\n       Ent :=\n@@ -2545,8 +2544,8 @@ package body Exp_Ch9 is\n       --  Associate the procedure with the task, if this is the declaration\n       --  (and not the body) of the procedure.\n \n-      if No (Task_Body_Procedure (Tdec)) then\n-         Set_Task_Body_Procedure (Tdec, Ent);\n+      if No (Task_Body_Procedure (T)) then\n+         Set_Task_Body_Procedure (T, Ent);\n       end if;\n \n       return\n@@ -4255,7 +4254,7 @@ package body Exp_Ch9 is\n                New_Reference_To (Cancel_Param, Loc)),\n              Then_Statements => Tstats));\n \n-         --  Protected the call against abortion\n+         --  Protected the call against abort\n \n          Prepend_To (Stmts,\n            Make_Procedure_Call_Statement (Loc,"}, {"sha": "03001dc867ea750930cef62cd72997ceda48f8da", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -288,7 +288,7 @@ package body Exp_Disp is\n             --     typ!(Displaced_This (Address!(Param)))\n \n             if Param = Ctrl_Arg\n-              and then DTC_Entity (Subp) /= Tag_Component (Typ)\n+              and then DTC_Entity (Subp) /= First_Tag_Component (Typ)\n             then\n                Append_To (New_Params,\n \n@@ -390,14 +390,16 @@ package body Exp_Disp is\n                          Make_Selected_Component (Loc,\n                            Prefix => New_Value (Ctrl_Arg),\n                            Selector_Name =>\n-                             New_Reference_To (Tag_Component (Typ), Loc)),\n+                             New_Reference_To\n+                               (First_Tag_Component (Typ), Loc)),\n \n                        Right_Opnd =>\n                          Make_Selected_Component (Loc,\n                            Prefix =>\n                              Unchecked_Convert_To (Typ, New_Value (Param)),\n                            Selector_Name =>\n-                             New_Reference_To (Tag_Component (Typ), Loc))),\n+                             New_Reference_To\n+                               (First_Tag_Component (Typ), Loc))),\n \n                    Then_Statements =>\n                      New_List (New_Constraint_Error (Loc))));\n@@ -545,15 +547,17 @@ package body Exp_Disp is\n                          Make_Selected_Component (Loc,\n                            Prefix => New_Value (Param),\n                            Selector_Name =>\n-                             New_Reference_To (Tag_Component (Typ), Loc)),\n+                             New_Reference_To\n+                               (First_Tag_Component (Typ), Loc)),\n \n                        Right_Opnd =>\n                          Make_Selected_Component (Loc,\n                            Prefix =>\n                              Unchecked_Convert_To (Typ,\n                                New_Value (Next_Actual (Param))),\n                            Selector_Name =>\n-                             New_Reference_To (Tag_Component (Typ), Loc))),\n+                             New_Reference_To\n+                               (First_Tag_Component (Typ), Loc))),\n \n                 Right_Opnd => New_Call);\n          end if;\n@@ -579,7 +583,8 @@ package body Exp_Disp is\n       return Node_Id\n    is\n       Typ    : constant Entity_Id := Scope (DTC_Entity (Prim));\n-      DT_Ptr : constant Entity_Id := Access_Disp_Table (Typ);\n+      DT_Ptr : constant Entity_Id := Node (First_Elmt\n+                                           (Access_Disp_Table (Typ)));\n \n    begin\n       return\n@@ -619,8 +624,9 @@ package body Exp_Disp is\n    function Make_DT (Typ : Entity_Id) return List_Id is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n-      Result    : constant List_Id := New_List;\n-      Elab_Code : constant List_Id := New_List;\n+      ADT_List  : constant Elist_Id := New_Elmt_List;\n+      Result    : constant List_Id  := New_List;\n+      Elab_Code : constant List_Id  := New_List;\n \n       Tname       : constant Name_Id := Chars (Typ);\n       Name_DT     : constant Name_Id := New_External_Name (Tname, 'T');\n@@ -684,7 +690,7 @@ package body Exp_Disp is\n                 Make_DT_Access_Action (Typ, DT_Entry_Size, No_List),\n               Right_Opnd =>\n                 Make_Integer_Literal (Loc,\n-                  DT_Entry_Count (Tag_Component (Typ)))));\n+                  DT_Entry_Count (First_Tag_Component (Typ)))));\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n@@ -748,7 +754,8 @@ package body Exp_Disp is\n \n       --  Set Access_Disp_Table field to be the dispatch table pointer\n \n-      Set_Access_Disp_Table (Typ, DT_Ptr);\n+      Append_Elmt (DT_Ptr, ADT_List);\n+      Set_Access_Disp_Table (Typ, ADT_List);\n \n       --  Count ancestors to compute the inheritance depth. For private\n       --  extensions, always go to the full view in order to compute the real\n@@ -840,12 +847,15 @@ package body Exp_Disp is\n              Make_Integer_Literal (Loc, 0));\n \n       else\n-         Old_Tag := New_Reference_To (Access_Disp_Table (Etype (Typ)), Loc);\n+         Old_Tag :=\n+           New_Reference_To\n+             (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc);\n          Old_TSD :=\n            Make_DT_Access_Action (Typ,\n              Action => Get_TSD,\n              Args   => New_List (\n-               New_Reference_To (Access_Disp_Table (Etype (Typ)), Loc)));\n+               New_Reference_To\n+                 (Node (First_Elmt (Access_Disp_Table (Etype (Typ)))), Loc)));\n       end if;\n \n       --  Generate: Inherit_DT (parent'tag, DT_Ptr, nb_prim of parent);\n@@ -857,7 +867,7 @@ package body Exp_Disp is\n             Node1 => Old_Tag,\n             Node2 => New_Reference_To (DT_Ptr, Loc),\n             Node3 => Make_Integer_Literal (Loc,\n-                       DT_Entry_Count (Tag_Component (Etype (Typ)))))));\n+                       DT_Entry_Count (First_Tag_Component (Etype (Typ)))))));\n \n       --  Generate: Inherit_TSD (Get_TSD (parent), DT_Ptr);\n \n@@ -1107,7 +1117,7 @@ package body Exp_Disp is\n       Parent_Typ : constant Entity_Id := Etype (Typ);\n       Root_Typ   : constant Entity_Id := Root_Type (Typ);\n       First_Prim : constant Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n-      The_Tag    : constant Entity_Id := Tag_Component (Typ);\n+      The_Tag    : constant Entity_Id := First_Tag_Component (Typ);\n       Adjusted   : Boolean := False;\n       Finalized  : Boolean := False;\n       Parent_EC  : Int;\n@@ -1120,9 +1130,10 @@ package body Exp_Disp is\n       --  Get Entry_Count of the parent\n \n       if Parent_Typ /= Typ\n-        and then DT_Entry_Count (Tag_Component (Parent_Typ)) /= No_Uint\n+        and then DT_Entry_Count (First_Tag_Component (Parent_Typ)) /= No_Uint\n       then\n-         Parent_EC := UI_To_Int (DT_Entry_Count (Tag_Component (Parent_Typ)));\n+         Parent_EC := UI_To_Int (DT_Entry_Count\n+                                   (First_Tag_Component (Parent_Typ)));\n       else\n          Parent_EC := 0;\n       end if;\n@@ -1327,7 +1338,7 @@ package body Exp_Disp is\n \n          pragma Assert (\n            DT_Entry_Count (The_Tag) >=\n-           DT_Entry_Count (Tag_Component (Parent_Typ)));\n+           DT_Entry_Count (First_Tag_Component (Parent_Typ)));\n       end if;\n    end Set_All_DT_Position;\n "}, {"sha": "e1c69b7a8f18c864c9ed3fd95481fd9a45704d06", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 13, "deletions": 68, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -266,7 +266,7 @@ package body Exp_Dist is\n    procedure Set_Renaming_TSS\n      (Typ     : Entity_Id;\n       Nam     : Entity_Id;\n-      TSS_Nam : Name_Id);\n+      TSS_Nam : TSS_Name_Type);\n    --  Create a renaming declaration of subprogram Nam,\n    --  and register it as a TSS for Typ with name TSS_Nam.\n \n@@ -1866,7 +1866,7 @@ package body Exp_Dist is\n               Prefix =>\n                 New_Occurrence_Of (Pointer, Loc),\n               Selector_Name =>\n-                New_Occurrence_Of (Tag_Component\n+                New_Occurrence_Of (First_Tag_Component\n                   (Designated_Type (Etype (Pointer))), Loc)),\n           Expression =>\n             Make_Attribute_Reference (Loc,\n@@ -5467,7 +5467,7 @@ package body Exp_Dist is\n          Insert_After (Declaration_Node (RACW_Type), Func_Decl);\n          Append_To (Declarations, Func_Body);\n \n-         Set_Renaming_TSS (RACW_Type, Fnam, Name_uFrom_Any);\n+         Set_Renaming_TSS (RACW_Type, Fnam, TSS_From_Any);\n       end Add_RACW_From_Any;\n \n       -----------------------------\n@@ -5781,7 +5781,7 @@ package body Exp_Dist is\n          Insert_After (Declaration_Node (RACW_Type), Func_Decl);\n          Append_To (Declarations, Func_Body);\n \n-         Set_Renaming_TSS (RACW_Type, Fnam, Name_uTo_Any);\n+         Set_Renaming_TSS (RACW_Type, Fnam, TSS_To_Any);\n       end Add_RACW_To_Any;\n \n       -----------------------\n@@ -5855,7 +5855,7 @@ package body Exp_Dist is\n          Insert_After (Declaration_Node (RACW_Type), Func_Decl);\n          Append_To (Declarations, Func_Body);\n \n-         Set_Renaming_TSS (RACW_Type, Fnam, Name_uTypeCode);\n+         Set_Renaming_TSS (RACW_Type, Fnam, TSS_TypeCode);\n       end Add_RACW_TypeCode;\n \n       ------------------------------\n@@ -6369,7 +6369,7 @@ package body Exp_Dist is\n          Insert_After (Declaration_Node (RAS_Type), Func_Decl);\n          Append_To (Declarations, Func_Body);\n \n-         Set_Renaming_TSS (RAS_Type, Fnam, Name_uFrom_Any);\n+         Set_Renaming_TSS (RAS_Type, Fnam, TSS_From_Any);\n       end Add_RAS_From_Any;\n \n       --------------------\n@@ -6461,7 +6461,7 @@ package body Exp_Dist is\n          Insert_After (Declaration_Node (RAS_Type), Func_Decl);\n          Append_To (Declarations, Func_Body);\n \n-         Set_Renaming_TSS (RAS_Type, Fnam, Name_uTo_Any);\n+         Set_Renaming_TSS (RAS_Type, Fnam, TSS_To_Any);\n       end Add_RAS_To_Any;\n \n       ----------------------\n@@ -6550,7 +6550,7 @@ package body Exp_Dist is\n          Insert_After (Declaration_Node (RAS_Type), Func_Decl);\n          Append_To (Declarations, Func_Body);\n \n-         Set_Renaming_TSS (RAS_Type, Fnam, Name_uTypeCode);\n+         Set_Renaming_TSS (RAS_Type, Fnam, TSS_TypeCode);\n       end Add_RAS_TypeCode;\n \n       -----------------------------------------\n@@ -8099,13 +8099,6 @@ package body Exp_Dist is\n          -- Local Subprograms --\n          -----------------------\n \n-         function Find_Inherited_TSS\n-           (Typ : Entity_Id;\n-            Nam : Name_Id) return Entity_Id;\n-         --  A TSS reference for a representation aspect of a derived tagged\n-         --  type must take into account inheritance of that aspect from\n-         --  ancestor types. (copied from exp_attr.adb, should be shared???)\n-\n          function Find_Numeric_Representation\n            (Typ : Entity_Id) return Entity_Id;\n          --  Given a numeric type Typ, return the smallest integer or floarting\n@@ -8236,7 +8229,7 @@ package body Exp_Dist is\n             --  First simple case where the From_Any function is present\n             --  in the type's TSS.\n \n-            Fnam := Find_Inherited_TSS (U_Type, Name_uFrom_Any);\n+            Fnam := Find_Inherited_TSS (U_Type, TSS_From_Any);\n \n             if Sloc (U_Type) <= Standard_Location then\n                U_Type := Base_Type (U_Type);\n@@ -8374,7 +8367,6 @@ package body Exp_Dist is\n             pragma Assert\n               (not (Is_Remote_Access_To_Class_Wide_Type (Typ)));\n \n-\n             if Is_Derived_Type (Typ)\n               and then not Is_Tagged_Type (Typ)\n             then\n@@ -9017,7 +9009,7 @@ package body Exp_Dist is\n             --  First simple case where the To_Any function is present\n             --  in the type's TSS.\n \n-            Fnam := Find_Inherited_TSS (U_Type, Name_uTo_Any);\n+            Fnam := Find_Inherited_TSS (U_Type, TSS_To_Any);\n \n             --  Check first for Boolean and Character. These are enumeration\n             --  types, but we treat them specially, since they may require\n@@ -9686,7 +9678,7 @@ package body Exp_Dist is\n                --  First simple case where the TypeCode is present\n                --  in the type's TSS.\n \n-               Fnam := Find_Inherited_TSS (U_Type, Name_uTypeCode);\n+               Fnam := Find_Inherited_TSS (U_Type, TSS_TypeCode);\n \n                if Present (Fnam) then\n \n@@ -10346,52 +10338,6 @@ package body Exp_Dist is\n                     Statements => Stms));\n          end Build_TypeCode_Function;\n \n-         ------------------------\n-         -- Find_Inherited_TSS --\n-         ------------------------\n-\n-         function Find_Inherited_TSS\n-           (Typ : Entity_Id;\n-            Nam : Name_Id) return Entity_Id\n-         is\n-            P_Type : Entity_Id := Typ;\n-            Proc   : Entity_Id;\n-\n-         begin\n-            Proc :=  TSS (Base_Type (Typ), Nam);\n-\n-            --  Check first if there is a TSS given for the type itself\n-\n-            if Present (Proc) then\n-               return Proc;\n-            end if;\n-\n-            --  If Typ is a derived type, it may inherit attributes from some\n-            --  ancestor which is not the ultimate underlying one. If Typ is a\n-            --  derived tagged type, The corresponding primitive operation has\n-            --  been created explicitly.\n-\n-            if Is_Derived_Type (P_Type) then\n-               if Is_Tagged_Type (P_Type) then\n-                  return Find_Prim_Op (P_Type, Nam);\n-               else\n-                  while Is_Derived_Type (P_Type) loop\n-                     Proc :=  TSS (Base_Type (Etype (Typ)), Nam);\n-\n-                     if Present (Proc) then\n-                        return Proc;\n-                     else\n-                        P_Type := Base_Type (Etype (P_Type));\n-                     end if;\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            --  If nothing else, use the TSS of the root type\n-\n-            return TSS (Base_Type (Underlying_Type (Typ)), Nam);\n-         end Find_Inherited_TSS;\n-\n          ---------------------------------\n          -- Find_Numeric_Representation --\n          ---------------------------------\n@@ -10634,7 +10580,6 @@ package body Exp_Dist is\n                  Counter => Counter,\n                  Datum   => New_Occurrence_Of (Inner_Any, Loc));\n \n-\n                Append_To (Stmts,\n                  Make_Block_Statement (Loc,\n                    Declarations =>\n@@ -10769,7 +10714,7 @@ package body Exp_Dist is\n    procedure Set_Renaming_TSS\n      (Typ     : Entity_Id;\n       Nam     : Entity_Id;\n-      TSS_Nam : Name_Id)\n+      TSS_Nam : TSS_Name_Type)\n    is\n       Loc  : constant Source_Ptr := Sloc (Nam);\n       Spec : constant Node_Id := Parent (Nam);\n@@ -10779,7 +10724,7 @@ package body Exp_Dist is\n                      Specification =>\n                        Copy_Specification (Loc,\n                          Spec     => Spec,\n-                         New_Name => TSS_Nam),\n+                         New_Name => Make_TSS_Name (Typ, TSS_Nam)),\n                        Name => New_Occurrence_Of (Nam, Loc));\n \n       Snam : constant Entity_Id :="}, {"sha": "928d52d0af16dd07fe2aff7e09db579c497bc4c6", "filename": "gcc/ada/par-ch11.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch11.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -190,6 +190,16 @@ package body Ch11 is\n          Set_Name (Raise_Node, P_Name);\n       end if;\n \n+      if Token = Tok_With then\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_SC (\"string expression in raise is Ada 2005 extension\");\n+            Error_Msg_SC (\"\\unit must be compiled with -gnat05 switch\");\n+         end if;\n+\n+         Scan; -- past WITH\n+         Set_Expression (Raise_Node, P_Expression);\n+      end if;\n+\n       TF_Semicolon;\n       return Raise_Node;\n    end P_Raise_Statement;"}, {"sha": "56ec4a15f39cc5fb74e7343358040da83a52cfcb", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 92, "deletions": 17, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -487,13 +487,17 @@ package body Ch12 is\n    --  | FORMAL_DECIMAL_FIXED_POINT_DEFINITION\n    --  | FORMAL_ARRAY_TYPE_DEFINITION\n    --  | FORMAL_ACCESS_TYPE_DEFINITION\n+   --  | FORMAL_INTERFACE_TYPE_DEFINITION\n \n    --  FORMAL_ARRAY_TYPE_DEFINITION ::= ARRAY_TYPE_DEFINITION\n \n    --  FORMAL_ACCESS_TYPE_DEFINITION ::= ACCESS_TYPE_DEFINITION\n \n+   --  FORMAL_INTERFACE_TYPE_DEFINITION ::= INTERFACE_TYPE_DEFINITION\n+\n    function P_Formal_Type_Definition return Node_Id is\n-      Scan_State : Saved_Scan_State;\n+      Scan_State   : Saved_Scan_State;\n+      Typedef_Node : Node_Id;\n \n    begin\n       if Token_Name = Name_Abstract then\n@@ -524,38 +528,89 @@ package body Ch12 is\n                return P_Formal_Private_Type_Definition;\n             end if;\n \n-         when Tok_Private | Tok_Limited | Tok_Tagged =>\n-            return P_Formal_Private_Type_Definition;\n+         when Tok_Access =>\n+            return P_Access_Type_Definition;\n \n-         when Tok_New =>\n-            return P_Formal_Derived_Type_Definition;\n+         when Tok_Array =>\n+            return P_Array_Type_Definition;\n+\n+         when Tok_Delta =>\n+            return P_Formal_Fixed_Point_Definition;\n+\n+         when Tok_Digits =>\n+            return P_Formal_Floating_Point_Definition;\n+\n+         when Tok_Interface => --  Ada 2005 (AI-251)\n+            return P_Interface_Type_Definition (Is_Synchronized => False);\n \n          when Tok_Left_Paren =>\n             return P_Formal_Discrete_Type_Definition;\n \n-         when Tok_Range =>\n-            return P_Formal_Signed_Integer_Type_Definition;\n+         when Tok_Limited =>\n+            Save_Scan_State (Scan_State);\n+            Scan; --  past LIMITED\n+\n+            if Token = Tok_Interface then\n+               Typedef_Node := P_Interface_Type_Definition\n+                                (Is_Synchronized => False);\n+               Set_Limited_Present (Typedef_Node);\n+               return Typedef_Node;\n+\n+            else\n+               Restore_Scan_State (Scan_State);\n+               return P_Formal_Private_Type_Definition;\n+            end if;\n \n          when Tok_Mod =>\n             return P_Formal_Modular_Type_Definition;\n \n-         when Tok_Digits =>\n-            return P_Formal_Floating_Point_Definition;\n-\n-         when Tok_Delta =>\n-            return P_Formal_Fixed_Point_Definition;\n+         when Tok_New =>\n+            return P_Formal_Derived_Type_Definition;\n \n-         when Tok_Array =>\n-            return P_Array_Type_Definition;\n+         when Tok_Private |\n+              Tok_Tagged  =>\n+            return P_Formal_Private_Type_Definition;\n \n-         when Tok_Access =>\n-            return P_Access_Type_Definition;\n+         when Tok_Range =>\n+            return P_Formal_Signed_Integer_Type_Definition;\n \n          when Tok_Record =>\n             Error_Msg_SC (\"record not allowed in generic type definition!\");\n             Discard_Junk_Node (P_Record_Definition);\n             return Error;\n \n+         --  Ada 2005 (AI-345)\n+\n+         when Tok_Protected    |\n+              Tok_Synchronized |\n+              Tok_Task         =>\n+\n+            Scan; -- past TASK, PROTECTED or SYNCHRONIZED\n+\n+            declare\n+               Saved_Token  : constant Token_Type := Token;\n+\n+            begin\n+               Typedef_Node := P_Interface_Type_Definition\n+                                (Is_Synchronized => True);\n+\n+               case Saved_Token is\n+                  when Tok_Task =>\n+                     Set_Task_Present         (Typedef_Node);\n+\n+                  when Tok_Protected =>\n+                     Set_Protected_Present    (Typedef_Node);\n+\n+                  when Tok_Synchronized =>\n+                     Set_Synchronized_Present (Typedef_Node);\n+\n+                  when others =>\n+                     null;\n+               end case;\n+\n+               return Typedef_Node;\n+            end;\n+\n          when others =>\n             Error_Msg_BC (\"expecting generic type definition here\");\n             Resync_Past_Semicolon;\n@@ -617,7 +672,7 @@ package body Ch12 is\n    --------------------------------------------\n \n    --  FORMAL_DERIVED_TYPE_DEFINITION ::=\n-   --    [abstract] new SUBTYPE_MARK [with private]\n+   --    [abstract] new SUBTYPE_MARK [[AND interface_list] with private]\n \n    --  The caller has checked the initial token(s) is/are NEW or ASTRACT NEW\n \n@@ -638,6 +693,26 @@ package body Ch12 is\n       Set_Subtype_Mark (Def_Node, P_Subtype_Mark);\n       No_Constraint;\n \n+      --  Ada 2005 (AI-251): Deal with interfaces\n+\n+      if Token = Tok_And then\n+         Scan; -- past AND\n+\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_SP\n+              (\"abstract interface is an Ada 2005 extension\");\n+            Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+         end if;\n+\n+         Set_Interface_List (Def_Node, New_List);\n+\n+         loop\n+            Append (P_Qualified_Simple_Name, Interface_List (Def_Node));\n+            exit when Token /= Tok_And;\n+            Scan; -- past AND\n+         end loop;\n+      end if;\n+\n       if Token = Tok_With then\n          Scan; -- past WITH\n          Set_Private_Present (Def_Node, True);"}, {"sha": "d28f1a9a07dc2eda8fed32f2efcb1b56b69cd4ca", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 194, "deletions": 18, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -241,12 +241,16 @@ package body Ch3 is\n    --    ENUMERATION_TYPE_DEFINITION  | INTEGER_TYPE_DEFINITION\n    --  | REAL_TYPE_DEFINITION         | ARRAY_TYPE_DEFINITION\n    --  | RECORD_TYPE_DEFINITION       | ACCESS_TYPE_DEFINITION\n-   --  | DERIVED_TYPE_DEFINITION\n+   --  | DERIVED_TYPE_DEFINITION      | INTERFACE_TYPE_DEFINITION\n \n    --  INTEGER_TYPE_DEFINITION ::=\n    --    SIGNED_INTEGER_TYPE_DEFINITION\n    --    MODULAR_TYPE_DEFINITION\n \n+   --  INTERFACE_TYPE_DEFINITION ::=\n+   --    [limited | task | protected | synchronized ] interface\n+   --      [AND interface_list]\n+\n    --  Error recovery: can raise Error_Resync\n \n    --  Note: The processing for full type declaration, incomplete type\n@@ -256,18 +260,19 @@ package body Ch3 is\n    --  function handles only declarations starting with TYPE).\n \n    function P_Type_Declaration return Node_Id is\n-      Type_Loc         : Source_Ptr;\n-      Type_Start_Col   : Column_Number;\n-      Ident_Node       : Node_Id;\n+      Abstract_Present : Boolean;\n+      Abstract_Loc     : Source_Ptr;\n       Decl_Node        : Node_Id;\n       Discr_List       : List_Id;\n-      Unknown_Dis      : Boolean;\n       Discr_Sloc       : Source_Ptr;\n-      Abstract_Present : Boolean;\n-      Abstract_Loc     : Source_Ptr;\n       End_Labl         : Node_Id;\n+      Type_Loc         : Source_Ptr;\n+      Type_Start_Col   : Column_Number;\n+      Ident_Node       : Node_Id;\n+      Is_Derived_Iface : Boolean := False;\n+      Unknown_Dis      : Boolean;\n \n-      Typedef_Node : Node_Id;\n+      Typedef_Node     : Node_Id;\n       --  Normally holds type definition, except in the case of a private\n       --  extension declaration, in which case it holds the declaration itself\n \n@@ -551,12 +556,6 @@ package body Ch3 is\n                TF_Semicolon;\n                exit;\n \n-            when Tok_Private =>\n-               Decl_Node := New_Node (N_Private_Type_Declaration, Type_Loc);\n-               Scan; -- past PRIVATE\n-               TF_Semicolon;\n-               exit;\n-\n             when Tok_Limited =>\n                Scan; -- past LIMITED\n \n@@ -585,6 +584,18 @@ package body Ch3 is\n                   Typedef_Node := P_Record_Definition;\n                   Set_Limited_Present (Typedef_Node, True);\n \n+               --  Ada 2005 (AI-251): LIMITED INTERFACE\n+\n+               elsif Token = Tok_Interface then\n+                  Typedef_Node := P_Interface_Type_Definition\n+                                    (Is_Synchronized => False);\n+                  Abstract_Present := True;\n+                  Set_Limited_Present (Typedef_Node);\n+\n+                  if Nkind (Typedef_Node) = N_Derived_Type_Definition then\n+                     Is_Derived_Iface := True;\n+                  end if;\n+\n                --  LIMITED PRIVATE is the only remaining possibility here\n \n                else\n@@ -634,6 +645,55 @@ package body Ch3 is\n \n                exit;\n \n+            --  Ada 2005 (AI-251): INTERFACE\n+\n+            when Tok_Interface =>\n+               Typedef_Node := P_Interface_Type_Definition\n+                                (Is_Synchronized => False);\n+               Abstract_Present := True;\n+               TF_Semicolon;\n+               exit;\n+\n+            when Tok_Private =>\n+               Decl_Node := New_Node (N_Private_Type_Declaration, Type_Loc);\n+               Scan; -- past PRIVATE\n+               TF_Semicolon;\n+               exit;\n+\n+            --  Ada 2005 (AI-345)\n+\n+            when Tok_Protected    |\n+                 Tok_Synchronized |\n+                 Tok_Task         =>\n+\n+               declare\n+                  Saved_Token : constant Token_Type := Token;\n+\n+               begin\n+                  Scan; -- past TASK, PROTECTED or SYNCHRONIZED\n+\n+                  Typedef_Node := P_Interface_Type_Definition\n+                                   (Is_Synchronized => True);\n+\n+                  case Saved_Token is\n+                     when Tok_Task =>\n+                        Set_Task_Present         (Typedef_Node);\n+\n+                     when Tok_Protected =>\n+                        Set_Protected_Present    (Typedef_Node);\n+\n+                     when Tok_Synchronized =>\n+                        Set_Synchronized_Present (Typedef_Node);\n+\n+                     when others =>\n+                        pragma Assert (False);\n+                        null;\n+                  end case;\n+               end;\n+\n+               TF_Semicolon;\n+               exit;\n+\n             --  Anything else is an error\n \n             when others =>\n@@ -693,6 +753,7 @@ package body Ch3 is\n          if Nkind (Typedef_Node) = N_Record_Definition\n            or else (Nkind (Typedef_Node) = N_Derived_Type_Definition\n                       and then Present (Record_Extension_Part (Typedef_Node)))\n+           or else Is_Derived_Iface\n          then\n             Set_Abstract_Present (Typedef_Node, Abstract_Present);\n \n@@ -1407,7 +1468,7 @@ package body Ch3 is\n                Acc_Node := P_Access_Definition (Not_Null_Present);\n \n                if Token /= Tok_Renames then\n-                  Error_Msg_SC (\"'RENAMES' expected\");\n+                  Error_Msg_SC (\"RENAMES expected\");\n                   raise Error_Resync;\n                end if;\n \n@@ -1463,7 +1524,7 @@ package body Ch3 is\n             Acc_Node := P_Access_Definition (Null_Exclusion_Present => False);\n \n             if Token /= Tok_Renames then\n-               Error_Msg_SC (\"'RENAMES' expected\");\n+               Error_Msg_SC (\"RENAMES expected\");\n                raise Error_Resync;\n             end if;\n \n@@ -1583,11 +1644,12 @@ package body Ch3 is\n \n    --  DERIVED_TYPE_DEFINITION ::=\n    --    [abstract] new [NULL_EXCLUSION] parent_SUBTYPE_INDICATION\n-   --    [RECORD_EXTENSION_PART]\n+   --    [[AND interface_list] RECORD_EXTENSION_PART]\n \n    --  PRIVATE_EXTENSION_DECLARATION ::=\n    --     type DEFINING_IDENTIFIER [DISCRIMINANT_PART] is\n-   --       [abstract] new ancestor_SUBTYPE_INDICATION with PRIVATE;\n+   --       [abstract] new ancestor_SUBTYPE_INDICATION\n+   --       [AND interface_list] with PRIVATE;\n \n    --  RECORD_EXTENSION_PART ::= with RECORD_DEFINITION\n \n@@ -1605,6 +1667,7 @@ package body Ch3 is\n       Typedef_Node     : Node_Id;\n       Typedecl_Node    : Node_Id;\n       Not_Null_Present : Boolean := False;\n+\n    begin\n       Typedef_Node := New_Node (N_Derived_Type_Definition, Token_Ptr);\n       T_New;\n@@ -1619,6 +1682,31 @@ package body Ch3 is\n       Set_Subtype_Indication (Typedef_Node,\n          P_Subtype_Indication (Not_Null_Present));\n \n+      --  Ada 2005 (AI-251): Deal with interfaces\n+\n+      if Token = Tok_And then\n+         Scan; -- past AND\n+\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_SP\n+              (\"abstract interface is an Ada 2005 extension\");\n+            Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+         end if;\n+\n+         Set_Interface_List (Typedef_Node, New_List);\n+\n+         loop\n+            Append (P_Qualified_Simple_Name, Interface_List (Typedef_Node));\n+            exit when Token /= Tok_And;\n+            Scan; -- past AND\n+         end loop;\n+\n+         if Token /= Tok_With then\n+            Error_Msg_SC (\"WITH expected\");\n+            raise Error_Resync;\n+         end if;\n+      end if;\n+\n       --  Deal with record extension, note that we assume that a WITH is\n       --  missing in the case of \"type X is new Y record ...\" or in the\n       --  case of \"type X is new Y null record\".\n@@ -3279,6 +3367,94 @@ package body Ch3 is\n \n    --  Parsed by P_Derived_Type_Def_Or_Private_Ext_Decl (3.4)\n \n+   --------------------------------------\n+   -- 3.9.4  Interface Type Definition --\n+   --------------------------------------\n+\n+   --  INTERFACE_TYPE_DEFINITION ::=\n+   --    [limited | task | protected | synchronized] interface\n+   --      [AND interface_list]\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   function P_Interface_Type_Definition\n+      (Is_Synchronized : Boolean) return Node_Id\n+   is\n+      Typedef_Node : Node_Id;\n+\n+   begin\n+      if Ada_Version < Ada_05 then\n+         Error_Msg_SP (\"abstract interface is an Ada 2005 extension\");\n+         Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+      end if;\n+\n+      Scan; -- past INTERFACE\n+\n+      --  Ada 2005 (AI-345): In case of synchronized interfaces and\n+      --  interfaces with a null list of interfaces we build a\n+      --  record_definition node.\n+\n+      if Is_Synchronized\n+        or else Token = Tok_Semicolon\n+      then\n+         Typedef_Node := New_Node (N_Record_Definition, Token_Ptr);\n+\n+         Set_Abstract_Present  (Typedef_Node);\n+         Set_Tagged_Present    (Typedef_Node);\n+         Set_Null_Present      (Typedef_Node);\n+         Set_Interface_Present (Typedef_Node);\n+\n+         if Is_Synchronized\n+           and then Token = Tok_And\n+         then\n+            Scan; -- past AND\n+            Set_Interface_List (Typedef_Node, New_List);\n+\n+            loop\n+               Append (P_Qualified_Simple_Name,\n+                       Interface_List (Typedef_Node));\n+               exit when Token /= Tok_And;\n+               Scan; -- past AND\n+            end loop;\n+         end if;\n+\n+      --  Ada 2005 (AI-251): In case of not-synchronized interfaces that have\n+      --  a list of interfaces we build a derived_type_definition node. This\n+      --  simplifies the semantic analysis (and hence further mainteinance)\n+\n+      else\n+         if Token /= Tok_And then\n+            Error_Msg_AP (\"AND expected\");\n+         else\n+            Scan; -- past AND\n+         end if;\n+\n+         Typedef_Node := New_Node (N_Derived_Type_Definition, Token_Ptr);\n+\n+         Set_Abstract_Present   (Typedef_Node);\n+         Set_Interface_Present  (Typedef_Node);\n+         Set_Subtype_Indication (Typedef_Node, P_Qualified_Simple_Name);\n+\n+         Set_Record_Extension_Part (Typedef_Node,\n+           New_Node (N_Record_Definition, Token_Ptr));\n+         Set_Null_Present (Record_Extension_Part (Typedef_Node));\n+\n+         if Token = Tok_And then\n+            Set_Interface_List (Typedef_Node, New_List);\n+            Scan; -- past AND\n+\n+            loop\n+               Append (P_Qualified_Simple_Name,\n+                       Interface_List (Typedef_Node));\n+               exit when Token /= Tok_And;\n+               Scan; -- past AND\n+            end loop;\n+         end if;\n+      end if;\n+\n+      return Typedef_Node;\n+   end P_Interface_Type_Definition;\n+\n    ----------------------------------\n    -- 3.10  Access Type Definition --\n    ----------------------------------"}, {"sha": "eba22acbb28a258554959c128defb37fe16d7d0f", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,7 +53,7 @@ package body Ch9 is\n \n    --  TASK_TYPE_DECLARATION ::=\n    --    task type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]\n-   --      [is TASK_DEFINITION];\n+   --      [is [new INTERFACE_LIST with] TASK_DEFINITION];\n \n    --  SINGLE_TASK_DECLARATION ::=\n    --    task DEFINING_IDENTIFIER [is TASK_DEFINITION];\n@@ -161,6 +161,32 @@ package body Ch9 is\n             end if;\n          else\n             TF_Is; -- must have IS if no semicolon\n+\n+            --  Ada 2005 (AI-345)\n+\n+            if Token = Tok_New then\n+               Scan; --  past NEW\n+\n+               if Ada_Version < Ada_05 then\n+                  Error_Msg_SP (\"task interface is an Ada 2005 extension\");\n+                  Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+               end if;\n+\n+               Set_Interface_List (Task_Node, New_List);\n+\n+               loop\n+                  Append (P_Qualified_Simple_Name, Interface_List (Task_Node));\n+                  exit when Token /= Tok_And;\n+                  Scan; --  past AND\n+               end loop;\n+\n+               if Token /= Tok_With then\n+                  Error_Msg_SC (\"WITH expected\");\n+               end if;\n+\n+               Scan; -- past WITH\n+            end if;\n+\n             Set_Task_Definition (Task_Node, P_Task_Definition);\n          end if;\n \n@@ -308,7 +334,7 @@ package body Ch9 is\n \n    --  PROTECTED_TYPE_DECLARATION ::=\n    --    protected type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]\n-   --      is PROTECTED_DEFINITION;\n+   --      is [new INTERFACE_LIST with] PROTECTED_DEFINITION;\n \n    --  SINGLE_PROTECTED_DECLARATION ::=\n    --    protected DEFINING_IDENTIFIER is PROTECTED_DEFINITION;\n@@ -402,6 +428,34 @@ package body Ch9 is\n          end if;\n \n          T_Is;\n+\n+         --  Ada 2005 (AI-345)\n+\n+         if Token = Tok_New then\n+            Scan; --  past NEW\n+\n+            if Ada_Version < Ada_05 then\n+               Error_Msg_SP (\"task interface is an Ada 2005 extension\");\n+               Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+            end if;\n+\n+            Set_Interface_List (Protected_Node, New_List);\n+\n+            loop\n+               Append (P_Qualified_Simple_Name,\n+                 Interface_List (Protected_Node));\n+\n+               exit when Token /= Tok_And;\n+               Scan; --  past AND\n+            end loop;\n+\n+            if Token /= Tok_With then\n+               Error_Msg_SC (\"WITH expected\");\n+            end if;\n+\n+            Scan; -- past WITH\n+         end if;\n+\n          Set_Protected_Definition (Protected_Node, P_Protected_Definition);\n          return Protected_Node;\n       end if;"}, {"sha": "8b4e69081b764a2e8b062dcab30d979e73964f03", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -601,6 +601,17 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  treatment of errors in case a reserved word is scanned. See the\n       --  declaration of this type for details.\n \n+      function P_Interface_Type_Definition\n+        (Is_Synchronized : Boolean) return Node_Id;\n+      --  Ada 2005 (AI-251): Parse the interface type definition part. The\n+      --  parameter Is_Synchronized is True in case of task interfaces,\n+      --  protected interfaces, and synchronized interfaces; it is used to\n+      --  generate a record_definition node. In the rest of cases (limited\n+      --  interfaces and interfaces) we generate a record_definition node if\n+      --  the list of interfaces is empty; otherwise we generate a\n+      --  derived_type_definition node (the first interface in this list is the\n+      --  ancestor interface).\n+\n       function P_Null_Exclusion return Boolean;\n       --  Ada 2005 (AI-231): Parse the null-excluding part. True indicates\n       --  that the null-excluding part was present."}, {"sha": "79dab061c25d62027632e5323f2823b919e3f787", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -363,7 +363,7 @@ package body Sem_Ch11 is\n \n    procedure Analyze_Raise_Statement (N : Node_Id) is\n       Exception_Id   : constant Node_Id := Name (N);\n-      Exception_Name : Entity_Id := Empty;\n+      Exception_Name : Entity_Id        := Empty;\n       P              : Node_Id;\n       Nkind_P        : Node_Kind;\n \n@@ -445,6 +445,10 @@ package body Sem_Ch11 is\n             Error_Msg_N\n               (\"exception name expected in raise statement\", Exception_Id);\n          end if;\n+\n+         if Present (Expression (N)) then\n+            Analyze_And_Resolve (Expression (N), Standard_String);\n+         end if;\n       end if;\n    end Analyze_Raise_Statement;\n "}, {"sha": "b301929471541f9584271efd7960dda5ddcc045e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -5179,7 +5179,7 @@ package body Sem_Prag is\n \n                if Expander_Active and then Typ = Root_Type (Typ) then\n \n-                  Tag_C := Tag_Component (Typ);\n+                  Tag_C := First_Tag_Component (Typ);\n                   C := First_Entity (Typ);\n \n                   if C = Tag_C then\n@@ -5313,7 +5313,7 @@ package body Sem_Prag is\n             --    . DT_Position will be set at the freezing point\n \n             if Arg_Count = 1 then\n-               Set_DTC_Entity (Subp, Tag_Component (Typ));\n+               Set_DTC_Entity (Subp, First_Tag_Component (Typ));\n                return;\n             end if;\n \n@@ -5431,9 +5431,9 @@ package body Sem_Prag is\n             --  If it is the first pragma Vtable, This becomes the default tag\n \n             elsif (not Is_Tag (DTC))\n-              and then DT_Entry_Count (Tag_Component (Typ)) = No_Uint\n+              and then DT_Entry_Count (First_Tag_Component (Typ)) = No_Uint\n             then\n-               Set_Is_Tag (Tag_Component (Typ), False);\n+               Set_Is_Tag (First_Tag_Component (Typ), False);\n                Set_Is_Tag (DTC, True);\n                Set_DT_Entry_Count (DTC, No_Uint);\n             end if;"}, {"sha": "c6117ee7b7c94283c49060dda6e58a1a033b0f58", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 112, "deletions": 50, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -314,8 +314,9 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Component_Association\n-        or else NT (N).Nkind = N_Formal_Package_Declaration\n-        or else NT (N).Nkind in N_Formal_Subprogram_Declaration);\n+        or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Package_Declaration);\n       return Flag15 (N);\n    end Box_Present;\n \n@@ -628,7 +629,8 @@ package body Sinfo is\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind in N_Formal_Subprogram_Declaration);\n+        or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration);\n       return Node2 (N);\n    end Default_Name;\n \n@@ -1056,7 +1058,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Label\n         or else NT (N).Nkind = N_Object_Declaration\n         or else NT (N).Nkind = N_Subtype_Declaration);\n-      return Flag11 (N);\n+      return Flag7 (N);\n    end Exception_Junk;\n \n    function Expansion_Delayed\n@@ -1110,6 +1112,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Parameter_Specification\n         or else NT (N).Nkind = N_Pragma_Argument_Association\n         or else NT (N).Nkind = N_Qualified_Expression\n+        or else NT (N).Nkind = N_Raise_Statement\n         or else NT (N).Nkind = N_Return_Statement\n         or else NT (N).Nkind = N_Type_Conversion\n         or else NT (N).Nkind = N_Unchecked_Expression\n@@ -1403,6 +1406,28 @@ package body Sinfo is\n       return Flag16 (N);\n    end Implicit_With;\n \n+   function Interface_List\n+      (N : Node_Id) return List_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Formal_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Private_Extension_Declaration\n+        or else NT (N).Nkind = N_Protected_Type_Declaration\n+        or else NT (N).Nkind = N_Record_Definition\n+        or else NT (N).Nkind = N_Task_Type_Declaration);\n+      return List2 (N);\n+   end Interface_List;\n+\n+   function Interface_Present\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      return Flag16 (N);\n+   end Interface_Present;\n+\n    function In_Present\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1639,6 +1664,7 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n         or else NT (N).Nkind = N_Formal_Private_Type_Definition\n         or else NT (N).Nkind = N_Private_Type_Declaration\n         or else NT (N).Nkind = N_Record_Definition\n@@ -1865,7 +1891,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Object_Declaration\n         or else NT (N).Nkind = N_Parameter_Specification\n         or else NT (N).Nkind = N_Subtype_Declaration);\n-      return Flag9 (N);\n+      return Flag11 (N);\n    end Null_Exclusion_Present;\n \n    function Null_Record_Present\n@@ -1885,14 +1911,6 @@ package body Sinfo is\n       return Node4 (N);\n    end Object_Definition;\n \n-   function OK_For_Stream\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Attribute_Reference);\n-      return Flag4 (N);\n-   end OK_For_Stream;\n-\n    function Original_Discriminant\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -2121,8 +2139,10 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Access_Function_Definition\n-        or else NT (N).Nkind = N_Access_Procedure_Definition);\n-      return Flag15 (N);\n+        or else NT (N).Nkind = N_Access_Procedure_Definition\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      return Flag6 (N);\n    end Protected_Present;\n \n    function Raises_Constraint_Error\n@@ -2296,14 +2316,15 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration\n         or else NT (N).Nkind = N_Generic_Package_Declaration\n         or else NT (N).Nkind = N_Generic_Subprogram_Declaration\n         or else NT (N).Nkind = N_Package_Declaration\n         or else NT (N).Nkind = N_Subprogram_Body\n         or else NT (N).Nkind = N_Subprogram_Body_Stub\n         or else NT (N).Nkind = N_Subprogram_Declaration\n-        or else NT (N).Nkind = N_Subprogram_Renaming_Declaration\n-        or else NT (N).Nkind in N_Formal_Subprogram_Declaration);\n+        or else NT (N).Nkind = N_Subprogram_Renaming_Declaration);\n       return Node1 (N);\n    end Specification;\n \n@@ -2388,6 +2409,15 @@ package body Sinfo is\n       return List2 (N);\n    end Subtype_Marks;\n \n+   function Synchronized_Present\n+     (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      return Flag7 (N);\n+   end Synchronized_Present;\n+\n    function Tagged_Present\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2407,14 +2437,6 @@ package body Sinfo is\n       return Node2 (N);\n    end Target_Type;\n \n-   function Task_Body_Procedure\n-      (N : Node_Id) return Entity_Id is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Type_Declaration);\n-      return Node2 (N);\n-   end Task_Body_Procedure;\n-\n    function Task_Definition\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -2424,6 +2446,15 @@ package body Sinfo is\n       return Node3 (N);\n    end Task_Definition;\n \n+   function Task_Present\n+     (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      return Flag5 (N);\n+   end Task_Present;\n+\n    function Then_Actions\n       (N : Node_Id) return List_Id is\n    begin\n@@ -2816,8 +2847,9 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Component_Association\n-        or else NT (N).Nkind = N_Formal_Package_Declaration\n-        or else NT (N).Nkind in N_Formal_Subprogram_Declaration);\n+        or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Package_Declaration);\n       Set_Flag15 (N, Val);\n    end Set_Box_Present;\n \n@@ -3130,7 +3162,8 @@ package body Sinfo is\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind in N_Formal_Subprogram_Declaration);\n+        or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration);\n       Set_Node2_With_Parent (N, Val);\n    end Set_Default_Name;\n \n@@ -3549,7 +3582,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Label\n         or else NT (N).Nkind = N_Object_Declaration\n         or else NT (N).Nkind = N_Subtype_Declaration);\n-      Set_Flag11 (N, Val);\n+      Set_Flag7 (N, Val);\n    end Set_Exception_Junk;\n \n    procedure Set_Expansion_Delayed\n@@ -3603,6 +3636,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Parameter_Specification\n         or else NT (N).Nkind = N_Pragma_Argument_Association\n         or else NT (N).Nkind = N_Qualified_Expression\n+        or else NT (N).Nkind = N_Raise_Statement\n         or else NT (N).Nkind = N_Return_Statement\n         or else NT (N).Nkind = N_Type_Conversion\n         or else NT (N).Nkind = N_Unchecked_Expression\n@@ -3896,6 +3930,28 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Implicit_With;\n \n+   procedure Set_Interface_List\n+      (N : Node_Id; Val : List_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Formal_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Private_Extension_Declaration\n+        or else NT (N).Nkind = N_Protected_Type_Declaration\n+        or else NT (N).Nkind = N_Record_Definition\n+        or else NT (N).Nkind = N_Task_Type_Declaration);\n+      Set_List2_With_Parent (N, Val);\n+   end Set_Interface_List;\n+\n+   procedure Set_Interface_Present\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      Set_Flag16 (N, Val);\n+   end Set_Interface_Present;\n+\n    procedure Set_In_Present\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4132,6 +4188,7 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n         or else NT (N).Nkind = N_Formal_Private_Type_Definition\n         or else NT (N).Nkind = N_Private_Type_Declaration\n         or else NT (N).Nkind = N_Record_Definition\n@@ -4358,7 +4415,7 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Object_Declaration\n         or else NT (N).Nkind = N_Parameter_Specification\n         or else NT (N).Nkind = N_Subtype_Declaration);\n-      Set_Flag9 (N, Val);\n+      Set_Flag11 (N, Val);\n    end Set_Null_Exclusion_Present;\n \n    procedure Set_Null_Record_Present\n@@ -4378,14 +4435,6 @@ package body Sinfo is\n       Set_Node4_With_Parent (N, Val);\n    end Set_Object_Definition;\n \n-   procedure Set_OK_For_Stream\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Attribute_Reference);\n-      Set_Flag4 (N, Val);\n-   end Set_OK_For_Stream;\n-\n    procedure Set_Original_Discriminant\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -4614,8 +4663,10 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Access_Function_Definition\n-        or else NT (N).Nkind = N_Access_Procedure_Definition);\n-      Set_Flag15 (N, Val);\n+        or else NT (N).Nkind = N_Access_Procedure_Definition\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      Set_Flag6 (N, Val);\n    end Set_Protected_Present;\n \n    procedure Set_Raises_Constraint_Error\n@@ -4789,14 +4840,15 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Abstract_Subprogram_Declaration\n+        or else NT (N).Nkind = N_Formal_Concrete_Subprogram_Declaration\n         or else NT (N).Nkind = N_Generic_Package_Declaration\n         or else NT (N).Nkind = N_Generic_Subprogram_Declaration\n         or else NT (N).Nkind = N_Package_Declaration\n         or else NT (N).Nkind = N_Subprogram_Body\n         or else NT (N).Nkind = N_Subprogram_Body_Stub\n         or else NT (N).Nkind = N_Subprogram_Declaration\n-        or else NT (N).Nkind = N_Subprogram_Renaming_Declaration\n-        or else NT (N).Nkind in N_Formal_Subprogram_Declaration);\n+        or else NT (N).Nkind = N_Subprogram_Renaming_Declaration);\n       Set_Node1_With_Parent (N, Val);\n    end Set_Specification;\n \n@@ -4881,6 +4933,15 @@ package body Sinfo is\n       Set_List2_With_Parent (N, Val);\n    end Set_Subtype_Marks;\n \n+   procedure Set_Synchronized_Present\n+     (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      Set_Flag7 (N, Val);\n+   end Set_Synchronized_Present;\n+\n    procedure Set_Tagged_Present\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4900,14 +4961,6 @@ package body Sinfo is\n       Set_Node2 (N, Val); -- semantic field, no parent set\n    end Set_Target_Type;\n \n-   procedure Set_Task_Body_Procedure\n-      (N : Node_Id; Val : Entity_Id) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Task_Type_Declaration);\n-      Set_Node2 (N, Val); -- semantic field, no parent set\n-   end Set_Task_Body_Procedure;\n-\n    procedure Set_Task_Definition\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -4917,6 +4970,15 @@ package body Sinfo is\n       Set_Node3_With_Parent (N, Val);\n    end Set_Task_Definition;\n \n+   procedure Set_Task_Present\n+     (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Record_Definition);\n+      Set_Flag5 (N, Val);\n+   end Set_Task_Present;\n+\n    procedure Set_Then_Actions\n       (N : Node_Id; Val : List_Id) is\n    begin"}, {"sha": "c7df4dbd8d356e40154c9614506c54959f37b536", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 163, "deletions": 82, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -897,7 +897,7 @@ package Sinfo is\n    --    Note: if the Is_Overloaded flag is set, then Etype points to\n    --    an essentially arbitrary choice from the possible set of types.\n \n-   --  Exception_Junk (Flag11-Sem)\n+   --  Exception_Junk (Flag7-Sem)\n    --    This flag is set in a various nodes appearing in a statement\n    --    sequence to indicate that the corresponding node is an artifact\n    --    of the generated code for exception handling, and should be\n@@ -1317,16 +1317,6 @@ package Sinfo is\n    --    is used for properly setting out of range values for use by pragmas\n    --    Initialize_Scalars and Normalize_Scalars.\n \n-   --  OK_For_Stream (Flag4-Sem)\n-   --    Present in N_Attribute_Definition clauses for stream attributes. If\n-   --    set, indicates that the attribute is permitted even though the type\n-   --    involved is a limited type. In the case of a protected type, the\n-   --    result is to stream all components (including discriminants) in\n-   --    lexical order. For other limited types, the effect is simply to\n-   --    use the corresponding stream routine for the full type. This flag\n-   --    is used for internally generated code, where the streaming of these\n-   --    types is required, even though not normally allowed by the language.\n-\n    --  Original_Discriminant (Node2-Sem)\n    --    Present in identifiers. Used in references to discriminants that\n    --    appear in generic units. Because the names of the discriminants\n@@ -1430,7 +1420,7 @@ package Sinfo is\n    --    be rounded to the nearest integer (breaking ties away from zero),\n    --    rather than truncated towards zero as usual. These rounded integer\n    --    operations are the result of expansion of rounded fixed-point\n-   --    divide, conersion and multiplication operations.\n+   --    divide, conversion and multiplication operations.\n \n    --  Scope (Node3-Sem)\n    --    Present in defining identifiers, defining character literals and\n@@ -1477,12 +1467,6 @@ package Sinfo is\n    --    target type entity for the unchecked conversion instantiation\n    --    which gigi must do size validation for.\n \n-   --  Task_Body_Procedure (Node2-Sem)\n-   --    Present in task type declaration nodes. Points to the entity for\n-   --    the task body procedure (as further described in Exp_Ch9, task\n-   --    bodies are expanded into procedures). A convenient function to\n-   --    retrieve this field is Sem_Util.Get_Task_Body_Procedure.\n-\n    --  Then_Actions (List3-Sem)\n    --    This field is present in conditional expression nodes. During code\n    --    expansion we use the Insert_Actions procedure (in Exp_Util) to insert\n@@ -1888,7 +1872,7 @@ package Sinfo is\n       --    ENUMERATION_TYPE_DEFINITION  | INTEGER_TYPE_DEFINITION\n       --  | REAL_TYPE_DEFINITION         | ARRAY_TYPE_DEFINITION\n       --  | RECORD_TYPE_DEFINITION       | ACCESS_TYPE_DEFINITION\n-      --  | DERIVED_TYPE_DEFINITION\n+      --  | DERIVED_TYPE_DEFINITION      | INTERFACE_TYPE_DEFINITION\n \n       --------------------------------\n       -- 3.2.2  Subtype Declaration --\n@@ -1903,10 +1887,10 @@ package Sinfo is\n       --  N_Subtype_Declaration\n       --  Sloc points to SUBTYPE\n       --  Defining_Identifier (Node1)\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11)\n       --  Subtype_Indication (Node5)\n       --  Generic_Parent_Type (Node4-Sem) (set for an actual derived type).\n-      --  Exception_Junk (Flag11-Sem)\n+      --  Exception_Junk (Flag7-Sem)\n \n       -------------------------------\n       -- 3.2.2  Subtype Indication --\n@@ -2015,7 +1999,7 @@ package Sinfo is\n       --  Defining_Identifier (Node1)\n       --  Aliased_Present (Flag4) set if ALIASED appears\n       --  Constant_Present (Flag17) set if CONSTANT appears\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11)\n       --  Object_Definition (Node4) subtype indication/array type definition\n       --  Expression (Node3) (set to Empty if not present)\n       --  Handler_List_Entry (Node2-Sem)\n@@ -2024,7 +2008,7 @@ package Sinfo is\n       --  Prev_Ids (Flag6) (set to False if no previous identifiers in list)\n       --  No_Initialization (Flag13-Sem)\n       --  Assignment_OK (Flag15-Sem)\n-      --  Exception_Junk (Flag11-Sem)\n+      --  Exception_Junk (Flag7-Sem)\n       --  Delay_Finalize_Attach (Flag14-Sem)\n       --  Is_Subprogram_Descriptor (Flag16-Sem)\n \n@@ -2063,7 +2047,7 @@ package Sinfo is\n \n       --  DERIVED_TYPE_DEFINITION ::=\n       --    [abstract] new [NULL_EXCLUSION] parent_SUBTYPE_INDICATION\n-      --    [RECORD_EXTENSION_PART]\n+      --    [[and INTERFACE_LIST] RECORD_EXTENSION_PART]\n \n       --  Note: ABSTRACT, record extension part not permitted in Ada 83 mode\n \n@@ -2072,9 +2056,20 @@ package Sinfo is\n       --  N_Derived_Type_Definition\n       --  Sloc points to NEW\n       --  Abstract_Present (Flag4)\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11) (set to False if not present)\n       --  Subtype_Indication (Node5)\n       --  Record_Extension_Part (Node3) (set to Empty if not present)\n+      --  Limited_Present (Flag17) set in interfaces\n+      --  Task_Present (Flag5) set in task interfaces\n+      --  Protected_Present (Flag6) set in protected interfaces\n+      --  Synchronized_Present (Flag7) set in interfaces\n+      --  Interface_List (List2) (set to No_List if none)\n+      --  Interface_Present (Flag16) set in abstract interfaces\n+\n+      --  Note: The attributes Limited_Present, Task_Present, Protected_Present\n+      --        Synchronized_Present, Interface_List and Interface_Present are\n+      --        used for abstract interfaces (see comment in the definition\n+      --        of INTERFACE_TYPE_DEFINITION)\n \n       ---------------------------\n       -- 3.5  Range Constraint --\n@@ -2364,7 +2359,7 @@ package Sinfo is\n       --  N_Component_Definition\n       --  Sloc points to ALIASED, ACCESS or to first token of subtype mark\n       --  Aliased_Present (Flag4)\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11)\n       --  Subtype_Indication (Node5) (set to Empty if not present)\n       --  Access_Definition (Node3) (set to Empty if not present)\n \n@@ -2437,9 +2432,8 @@ package Sinfo is\n       --  N_Discriminant_Specification\n       --  Sloc points to first identifier\n       --  Defining_Identifier (Node1)\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n-      --  Discriminant_Type (Node5) subtype mark or\n-      --    access parameter definition\n+      --  Null_Exclusion_Present (Flag11)\n+      --  Discriminant_Type (Node5) subtype mark or access parameter definition\n       --  Expression (Node3) (set to Empty if no default expression)\n       --  More_Ids (Flag5) (set to False if no more identifiers in list)\n       --  Prev_Ids (Flag6) (set to False if no previous identifiers in list)\n@@ -2525,6 +2519,16 @@ package Sinfo is\n       --  Limited_Present (Flag17)\n       --  Component_List (Node1) empty in null record case\n       --  Null_Present (Flag13) set in null record case\n+      --  Task_Present (Flag5) set in task interfaces\n+      --  Protected_Present (Flag6) set in protected interfaces\n+      --  Synchronized_Present (Flag7) set in interfaces\n+      --  Interface_Present (Flag16) set in abstract interfaces\n+      --  Interface_List (List2) (set to No_List if none)\n+\n+      --  Note: The attributes Task_Present, Protected_Present, Synchronized\n+      --        _Present, Interface_List and Interface_Present are\n+      --        used for abstract interfaces (see comment in the definition\n+      --        of INTERFACE_TYPE_DEFINITION)\n \n       -------------------------\n       -- 3.8  Component List --\n@@ -2651,6 +2655,19 @@ package Sinfo is\n \n       --  Note: record extension parts are not permitted in Ada 83 mode\n \n+      --------------------------------------\n+      -- 3.9.4  Interface Type Definition --\n+      --------------------------------------\n+\n+      --  INTERFACE_TYPE_DEFINITION ::=\n+      --    [limited | task | protected | synchronized]\n+      --    interface [interface_list]\n+\n+      --  Note: Interfaces are implemented with N_Record_Definition and\n+      --        N_Derived_Type_Definition nodes because most of the support\n+      --        for the analysis of abstract types has been reused to\n+      --        analyze abstract interfaces.\n+\n       ----------------------------------\n       -- 3.10  Access Type Definition --\n       ----------------------------------\n@@ -2676,7 +2693,7 @@ package Sinfo is\n       --  N_Access_To_Object_Definition\n       --  Sloc points to ACCESS\n       --  All_Present (Flag15)\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11)\n       --  Subtype_Indication (Node5)\n       --  Constant_Present (Flag17)\n \n@@ -2705,15 +2722,15 @@ package Sinfo is\n \n       --  N_Access_Function_Definition\n       --  Sloc points to ACCESS\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n-      --  Protected_Present (Flag15)\n+      --  Null_Exclusion_Present (Flag11)\n+      --  Protected_Present (Flag6)\n       --  Parameter_Specifications (List3) (set to No_List if no formal part)\n       --  Subtype_Mark (Node4) result subtype\n \n       --  N_Access_Procedure_Definition\n       --  Sloc points to ACCESS\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n-      --  Protected_Present (Flag15)\n+      --  Null_Exclusion_Present (Flag11)\n+      --  Protected_Present (Flag6)\n       --  Parameter_Specifications (List3) (set to No_List if no formal part)\n \n       -----------------------------\n@@ -2728,7 +2745,7 @@ package Sinfo is\n \n       --  N_Access_Definition\n       --  Sloc points to ACCESS\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11)\n       --  All_Present (Flag15)\n       --  Constant_Present (Flag17)\n       --  Subtype_Mark (Node4)\n@@ -2933,11 +2950,11 @@ package Sinfo is\n       --  i.e. digits, access, delta, range, the Attribute_Name field contains\n       --  the corresponding name, even though no identifier is involved.\n \n-      --  The flag OK_For_Stream is used in generated code to indicate that\n-      --  a stream attribute is permissible for a limited type, and results\n-      --  in the use of the stream attribute for the underlying full type,\n-      --  or in the case of a protected type, the components (including any\n-      --  disriminants) are merely streamed in order.\n+      --  Note: the generated code may contain stream attributes applied to\n+      --  limited types for which no stream routines exist officially. In such\n+      --  case, the result is to use the stream attribute for the underlying\n+      --  full type, or in the case of a protected type, the components\n+      --  (including any disriminants) are merely streamed in order.\n \n       --  See Exp_Attr for a complete description of which attributes are\n       --  passed onto Gigi, and which are handled entirely by the front end.\n@@ -2964,7 +2981,6 @@ package Sinfo is\n       --  Associated_Node (Node4-Sem)\n       --  Do_Overflow_Check (Flag17-Sem)\n       --  Redundant_Use (Flag13-Sem)\n-      --  OK_For_Stream (Flag4-Sem)\n       --  Must_Be_Byte_Aligned (Flag14)\n       --  plus fields for expression\n \n@@ -3529,7 +3545,7 @@ package Sinfo is\n       --  N_Allocator\n       --  Sloc points to NEW\n       --  Expression (Node3) subtype indication or qualified expression\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11)\n       --  Storage_Pool (Node1-Sem)\n       --  Procedure_To_Call (Node4-Sem)\n       --  No_Initialization (Flag13-Sem)\n@@ -3606,7 +3622,7 @@ package Sinfo is\n       --  N_Label\n       --  Sloc points to <<\n       --  Identifier (Node1) direct name of statement identifier\n-      --  Exception_Junk (Flag11-Sem)\n+      --  Exception_Junk (Flag7-Sem)\n \n       -------------------------------\n       -- 5.1  Statement Identifier --\n@@ -3846,7 +3862,7 @@ package Sinfo is\n       --  N_Goto_Statement\n       --  Sloc points to GOTO\n       --  Name (Node2)\n-      --  Exception_Junk (Flag11-Sem)\n+      --  Exception_Junk (Flag7-Sem)\n \n       ---------------------------------\n       -- 6.1  Subprogram Declaration --\n@@ -4044,7 +4060,7 @@ package Sinfo is\n       --  Defining_Identifier (Node1)\n       --  In_Present (Flag15)\n       --  Out_Present (Flag17)\n-      --  Null_Exclusion_Present (Flag9) (set to False if not present)\n+      --  Null_Exclusion_Present (Flag11)\n       --  Parameter_Type (Node2) subtype mark or access definition\n       --  Expression (Node3) (set to Empty if no default expression present)\n       --  Do_Accessibility_Check (Flag13-Sem)\n@@ -4283,7 +4299,8 @@ package Sinfo is\n \n       --  PRIVATE_EXTENSION_DECLARATION ::=\n       --    type DEFINING_IDENTIFIER [DISCRIMINANT_PART] is\n-      --      [abstract] new ancestor_SUBTYPE_INDICATION with private;\n+      --      [abstract] new ancestor_SUBTYPE_INDICATION\n+      --      [and INTERFACE_LIST] with private;\n \n       --  Note: private extension declarations are not allowed in Ada 83 mode\n \n@@ -4295,6 +4312,7 @@ package Sinfo is\n       --  Unknown_Discriminants_Present (Flag13) set if (<>) discriminant\n       --  Abstract_Present (Flag4)\n       --  Subtype_Indication (Node5)\n+      --  Interface_List (List2) (set to No_List if none)\n \n       ---------------------\n       -- 8.4  Use Clause --\n@@ -4436,14 +4454,14 @@ package Sinfo is\n \n       --  TASK_TYPE_DECLARATION ::=\n       --    task type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]\n-      --      [is TASK_DEFINITITION];\n+      --      [is [new INTERFACE_LIST with] TASK_DEFINITITION];\n \n       --  N_Task_Type_Declaration\n       --  Sloc points to TASK\n       --  Defining_Identifier (Node1)\n-      --  Task_Body_Procedure (Node2-Sem)\n       --  Discriminant_Specifications (List4) (set to No_List if no\n       --   discriminant part)\n+      --  Interface_List (List2) (set to No_List if none)\n       --  Task_Definition (Node3) (set to Empty if not present)\n       --  Corresponding_Body (Node5-Sem)\n \n@@ -4517,7 +4535,7 @@ package Sinfo is\n \n       --  PROTECTED_TYPE_DECLARATION ::=\n       --    protected type DEFINING_IDENTIFIER [KNOWN_DISCRIMINANT_PART]\n-      --      is PROTECTED_DEFINITION;\n+      --      is [new INTERFACE_LIST with] PROTECTED_DEFINITION;\n \n       --  Note: protected type declarations are not permitted in Ada 83 mode\n \n@@ -4526,6 +4544,7 @@ package Sinfo is\n       --  Defining_Identifier (Node1)\n       --  Discriminant_Specifications (List4) (set to No_List if no\n       --   discriminant part)\n+      --  Interface_List (List2) (set to No_List if none)\n       --  Protected_Definition (Node3)\n       --  Corresponding_Body (Node5-Sem)\n \n@@ -5393,9 +5412,14 @@ package Sinfo is\n \n       --  RAISE_STATEMENT ::= raise [exception_NAME];\n \n+      --  In Ada 2005, we have\n+\n+      --  RAISE_STATEMENT ::= raise; | raise exception_NAME [with EXPRESSION];\n+\n       --  N_Raise_Statement\n       --  Sloc points to RAISE\n       --  Name (Node2) (set to Empty if no exception name present)\n+      --  Expression (Node3) (set to Empty if no expression present)\n \n       -------------------------------\n       -- 12.1  Generic Declaration --\n@@ -5591,6 +5615,7 @@ package Sinfo is\n       --  | FORMAL_DECIMAL_FIXED_POINT_DEFINITION\n       --  | FORMAL_ARRAY_TYPE_DEFINITION\n       --  | FORMAL_ACCESS_TYPE_DEFINITION\n+      --  | FORMAL_INTERFACE_TYPE_DEFINITION\n \n       ---------------------------------------------\n       -- 12.5.1  Formal Private Type Definition --\n@@ -5612,15 +5637,15 @@ package Sinfo is\n       --------------------------------------------\n \n       --  FORMAL_DERIVED_TYPE_DEFINITION ::=\n-      --    [abstract] new SUBTYPE_MARK [with private]\n-\n+      --    [abstract] new SUBTYPE_MARK [[and INTERFACE_LIST] with private]\n       --  Note: this construct is not allowed in Ada 83 mode\n \n       --  N_Formal_Derived_Type_Definition\n       --  Sloc points to NEW\n       --  Subtype_Mark (Node4)\n       --  Private_Present (Flag15)\n       --  Abstract_Present (Flag4)\n+      --  Interface_List (List2) (set to No_List if none)\n \n       ---------------------------------------------\n       -- 12.5.2  Formal Discrete Type Definition --\n@@ -5690,6 +5715,12 @@ package Sinfo is\n \n       --  FORMAL_ACCESS_TYPE_DEFINITION ::= ACCESS_TYPE_DEFINITION\n \n+      ----------------------------------------------\n+      -- 12.5.5  Formal Interface Type Definition --\n+      ----------------------------------------------\n+\n+      --  FORMAL_INTERFACE_TYPE_DEFINITION ::= INTERFACE_TYPE_DEFINITION\n+\n       -----------------------------------------\n       -- 12.6  Formal Subprogram Declaration --\n       -----------------------------------------\n@@ -6503,42 +6534,51 @@ package Sinfo is\n       N_Unused_At_Start,\n \n       --  N_Representation_Clause\n+\n       N_At_Clause,\n       N_Component_Clause,\n       N_Enumeration_Representation_Clause,\n       N_Mod_Clause,\n       N_Record_Representation_Clause,\n \n       --  N_Representation_Clause, N_Has_Chars\n+\n       N_Attribute_Definition_Clause,\n \n       --  N_Has_Chars\n+\n       N_Empty,\n       N_Pragma,\n       N_Pragma_Argument_Association,\n \n       --  N_Has_Etype\n+\n       N_Error,\n \n       --  N_Entity, N_Has_Etype, N_Has_Chars\n+\n       N_Defining_Character_Literal,\n       N_Defining_Identifier,\n       N_Defining_Operator_Symbol,\n \n       --  N_Subexpr, N_Has_Etype, N_Has_Chars, N_Has_Entity\n+\n       N_Expanded_Name,\n \n       --  N_Direct_Name, N_Subexpr, N_Has_Etype,\n       --  N_Has_Chars, N_Has_Entity\n+\n       N_Identifier,\n       N_Operator_Symbol,\n \n       --  N_Direct_Name, N_Subexpr, N_Has_Etype,\n       --  N_Has_Chars, N_Has_Entity\n+\n       N_Character_Literal,\n \n       --  N_Binary_Op, N_Op, N_Subexpr,\n       --  N_Has_Etype, N_Has_Chars, N_Has_Entity\n+\n       N_Op_Add,\n       N_Op_Concat,\n       N_Op_Expon,\n@@ -6554,11 +6594,12 @@ package Sinfo is\n \n       --  N_Binary_Op, N_Op, N_Subexpr, N_Has_Etype\n       --  N_Has_Entity, N_Has_Chars, N_Op_Boolean\n+\n       N_Op_And,\n \n       --  N_Binary_Op, N_Op, N_Subexpr, N_Has_Etype\n-      --  N_Has_Entity, N_Has_Chars, N_Op_Boolean,\n-      --  N_Op_Compare\n+      --  N_Has_Entity, N_Has_Chars, N_Op_Boolean, N_Op_Compare\n+\n       N_Op_Eq,\n       N_Op_Ge,\n       N_Op_Gt,\n@@ -6568,11 +6609,13 @@ package Sinfo is\n \n       --  N_Binary_Op, N_Op, N_Subexpr, N_Has_Etype\n       --  N_Has_Entity, N_Has_Chars, N_Op_Boolean\n+\n       N_Op_Or,\n       N_Op_Xor,\n \n       --  N_Binary_Op, N_Op, N_Subexpr, N_Has_Etype,\n       --  N_Op_Shift, N_Has_Chars, N_Has_Entity\n+\n       N_Op_Rotate_Left,\n       N_Op_Rotate_Right,\n       N_Op_Shift_Left,\n@@ -6581,15 +6624,18 @@ package Sinfo is\n \n       --  N_Unary_Op, N_Op, N_Subexpr, N_Has_Etype,\n       --  N_Has_Chars, N_Has_Entity\n+\n       N_Op_Abs,\n       N_Op_Minus,\n       N_Op_Not,\n       N_Op_Plus,\n \n       --  N_Subexpr, N_Has_Etype, N_Has_Entity\n+\n       N_Attribute_Reference,\n \n       --  N_Subexpr, N_Has_Etype\n+\n       N_And_Then,\n       N_Conditional_Expression,\n       N_Explicit_Dereference,\n@@ -6626,9 +6672,11 @@ package Sinfo is\n       N_Unchecked_Type_Conversion,\n \n       --  N_Has_Etype\n+\n       N_Subtype_Indication,\n \n       --  N_Declaration\n+\n       N_Component_Declaration,\n       N_Entry_Declaration,\n       N_Formal_Object_Declaration,\n@@ -6643,66 +6691,75 @@ package Sinfo is\n       N_Subtype_Declaration,\n \n       --  N_Subprogram_Specification, N_Declaration\n+\n       N_Function_Specification,\n       N_Procedure_Specification,\n \n-      --  (nothing special)\n-      N_Entry_Index_Specification,\n-      N_Freeze_Entity,\n-\n       --  N_Access_To_Subprogram_Definition\n+\n       N_Access_Function_Definition,\n       N_Access_Procedure_Definition,\n \n-      --  N_Later_Decl_Item,\n+      --  N_Later_Decl_Item\n+\n       N_Task_Type_Declaration,\n \n       --  N_Body_Stub, N_Later_Decl_Item\n+\n       N_Package_Body_Stub,\n       N_Protected_Body_Stub,\n       N_Subprogram_Body_Stub,\n       N_Task_Body_Stub,\n \n       --  N_Generic_Instantiation, N_Later_Decl_Item\n+\n       N_Function_Instantiation,\n       N_Package_Instantiation,\n       N_Procedure_Instantiation,\n \n       --  N_Unit_Body, N_Later_Decl_Item, N_Proper_Body\n+\n       N_Package_Body,\n       N_Subprogram_Body,\n \n       --  N_Later_Decl_Item, N_Proper_Body\n+\n       N_Protected_Body,\n       N_Task_Body,\n \n       --  N_Later_Decl_Item\n+\n       N_Implicit_Label_Declaration,\n       N_Package_Declaration,\n       N_Single_Task_Declaration,\n       N_Subprogram_Declaration,\n       N_Use_Package_Clause,\n \n       --  N_Generic_Declaration, N_Later_Decl_Item\n+\n       N_Generic_Package_Declaration,\n       N_Generic_Subprogram_Declaration,\n \n       --  N_Array_Type_Definition\n+\n       N_Constrained_Array_Definition,\n       N_Unconstrained_Array_Definition,\n \n       --  N_Renaming_Declaration\n+\n       N_Exception_Renaming_Declaration,\n       N_Object_Renaming_Declaration,\n       N_Package_Renaming_Declaration,\n       N_Subprogram_Renaming_Declaration,\n \n       --  N_Generic_Renaming_Declarations, N_Renaming_Declaration\n+\n       N_Generic_Function_Renaming_Declaration,\n       N_Generic_Package_Renaming_Declaration,\n       N_Generic_Procedure_Renaming_Declaration,\n \n       --  N_Statement_Other_Than_Procedure_Call\n+\n       N_Abort_Statement,\n       N_Accept_Statement,\n       N_Assignment_Statement,\n@@ -6725,18 +6782,26 @@ package Sinfo is\n       N_Timed_Entry_Call,\n \n       --  N_Statement_Other_Than_Procedure_Call, N_Has_Condition\n+\n       N_Exit_Statement,\n       N_If_Statement,\n \n       --  N_Has_Condition\n+\n       N_Accept_Alternative,\n       N_Delay_Alternative,\n       N_Elsif_Part,\n       N_Entry_Body_Formal_Part,\n       N_Iteration_Scheme,\n       N_Terminate_Alternative,\n \n+      --  N_Formal_Subprogram_Declaration\n+\n+      N_Formal_Abstract_Subprogram_Declaration,\n+      N_Formal_Concrete_Subprogram_Declaration,\n+\n       --  Other nodes (not part of any subtype class)\n+\n       N_Abortable_Part,\n       N_Abstract_Subprogram_Declaration,\n       N_Access_Definition,\n@@ -6758,11 +6823,10 @@ package Sinfo is\n       N_Enumeration_Type_Definition,\n       N_Entry_Body,\n       N_Entry_Call_Alternative,\n+      N_Entry_Index_Specification,\n       N_Exception_Declaration,\n       N_Exception_Handler,\n       N_Floating_Point_Definition,\n-      N_Formal_Abstract_Subprogram_Declaration,\n-      N_Formal_Concrete_Subprogram_Declaration,\n       N_Formal_Decimal_Fixed_Point_Definition,\n       N_Formal_Derived_Type_Definition,\n       N_Formal_Discrete_Type_Definition,\n@@ -6772,6 +6836,7 @@ package Sinfo is\n       N_Formal_Package_Declaration,\n       N_Formal_Private_Type_Definition,\n       N_Formal_Signed_Integer_Type_Definition,\n+      N_Freeze_Entity,\n       N_Generic_Association,\n       N_Handled_Sequence_Of_Statements,\n       N_Index_Or_Discriminant_Constraint,\n@@ -7276,7 +7341,7 @@ package Sinfo is\n      (N : Node_Id) return List_Id;    -- List5\n \n    function Exception_Junk\n-     (N : Node_Id) return Boolean;    -- Flag11\n+     (N : Node_Id) return Boolean;    -- Flag7\n \n    function Explicit_Actual_Parameter\n      (N : Node_Id) return Node_Id;    -- Node3\n@@ -7383,6 +7448,12 @@ package Sinfo is\n    function Identifier\n      (N : Node_Id) return Node_Id;    -- Node1\n \n+   function Interface_List\n+     (N : Node_Id) return List_Id;    -- List2\n+\n+   function Interface_Present\n+     (N : Node_Id) return Boolean;    -- Flag16\n+\n    function Implicit_With\n      (N : Node_Id) return Boolean;    -- Flag16\n \n@@ -7531,17 +7602,14 @@ package Sinfo is\n      (N : Node_Id) return Boolean;    -- Flag13\n \n    function Null_Exclusion_Present\n-     (N : Node_Id) return Boolean;    -- Flag9\n+     (N : Node_Id) return Boolean;    -- Flag11\n \n    function Null_Record_Present\n      (N : Node_Id) return Boolean;    -- Flag17\n \n    function Object_Definition\n      (N : Node_Id) return Node_Id;    -- Node4\n \n-   function OK_For_Stream\n-     (N : Node_Id) return Boolean;    -- Flag4\n-\n    function Original_Discriminant\n      (N : Node_Id) return Node_Id;    -- Node2\n \n@@ -7609,7 +7677,7 @@ package Sinfo is\n      (N : Node_Id) return Node_Id;    -- Node3\n \n    function Protected_Present\n-     (N : Node_Id) return Boolean;    -- Flag15\n+     (N : Node_Id) return Boolean;    -- Flag6\n \n    function Raises_Constraint_Error\n      (N : Node_Id) return Boolean;    -- Flag7\n@@ -7689,18 +7757,21 @@ package Sinfo is\n    function Subtype_Marks\n      (N : Node_Id) return List_Id;    -- List2\n \n+   function Synchronized_Present\n+     (N : Node_Id) return Boolean;    -- Flag7\n+\n    function Tagged_Present\n      (N : Node_Id) return Boolean;    -- Flag15\n \n    function Target_Type\n      (N : Node_Id) return Entity_Id;  -- Node2\n \n-   function Task_Body_Procedure\n-     (N : Node_Id) return Entity_Id;  -- Node2\n-\n    function Task_Definition\n      (N : Node_Id) return Node_Id;    -- Node3\n \n+   function Task_Present\n+     (N : Node_Id) return Boolean;    -- Flag5\n+\n    function Then_Actions\n      (N : Node_Id) return List_Id;    -- List2\n \n@@ -8071,7 +8142,7 @@ package Sinfo is\n      (N : Node_Id; Val : List_Id);            -- List5\n \n    procedure Set_Exception_Junk\n-     (N : Node_Id; Val : Boolean := True);    -- Flag11\n+     (N : Node_Id; Val : Boolean := True);    -- Flag7\n \n    procedure Set_Expansion_Delayed\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n@@ -8178,6 +8249,12 @@ package Sinfo is\n    procedure Set_Identifier\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n+   procedure Set_Interface_List\n+     (N : Node_Id; Val : List_Id);            -- List2\n+\n+   procedure Set_Interface_Present\n+     (N : Node_Id; Val : Boolean := True);    -- Flag16\n+\n    procedure Set_Implicit_With\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n@@ -8326,17 +8403,14 @@ package Sinfo is\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n    procedure Set_Null_Exclusion_Present\n-     (N : Node_Id; Val : Boolean := True);    -- Flag9\n+     (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n    procedure Set_Null_Record_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n    procedure Set_Object_Definition\n      (N : Node_Id; Val : Node_Id);            -- Node4\n \n-   procedure Set_OK_For_Stream\n-     (N : Node_Id; Val : Boolean := True);    -- Flag4\n-\n    procedure Set_Original_Discriminant\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n@@ -8404,7 +8478,7 @@ package Sinfo is\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n    procedure Set_Protected_Present\n-     (N : Node_Id; Val : Boolean := True);    -- Flag15\n+     (N : Node_Id; Val : Boolean := True);    -- Flag6\n \n    procedure Set_Raises_Constraint_Error\n      (N : Node_Id; Val : Boolean := True);    -- Flag7\n@@ -8484,18 +8558,21 @@ package Sinfo is\n    procedure Set_Subtype_Marks\n      (N : Node_Id; Val : List_Id);            -- List2\n \n+   procedure Set_Synchronized_Present\n+     (N : Node_Id; Val : Boolean := True);    -- Flag7\n+\n    procedure Set_Tagged_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n    procedure Set_Target_Type\n      (N : Node_Id; Val : Entity_Id);          -- Node2\n \n-   procedure Set_Task_Body_Procedure\n-     (N : Node_Id; Val : Entity_Id);          -- Node2\n-\n    procedure Set_Task_Definition\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n+   procedure Set_Task_Present\n+     (N : Node_Id; Val : Boolean := True);    -- Flag5\n+\n    procedure Set_Then_Actions\n      (N : Node_Id; Val : List_Id);            -- List2\n \n@@ -8713,6 +8790,8 @@ package Sinfo is\n    pragma Inline (High_Bound);\n    pragma Inline (Identifier);\n    pragma Inline (Implicit_With);\n+   pragma Inline (Interface_List);\n+   pragma Inline (Interface_Present);\n    pragma Inline (Includes_Infinities);\n    pragma Inline (In_Present);\n    pragma Inline (Instance_Spec);\n@@ -8764,7 +8843,6 @@ package Sinfo is\n    pragma Inline (Null_Exclusion_Present);\n    pragma Inline (Null_Record_Present);\n    pragma Inline (Object_Definition);\n-   pragma Inline (OK_For_Stream);\n    pragma Inline (Original_Discriminant);\n    pragma Inline (Original_Entity);\n    pragma Inline (Others_Discrete_Choices);\n@@ -8814,10 +8892,11 @@ package Sinfo is\n    pragma Inline (Subtype_Indication);\n    pragma Inline (Subtype_Mark);\n    pragma Inline (Subtype_Marks);\n+   pragma Inline (Synchronized_Present);\n    pragma Inline (Tagged_Present);\n    pragma Inline (Target_Type);\n-   pragma Inline (Task_Body_Procedure);\n    pragma Inline (Task_Definition);\n+   pragma Inline (Task_Present);\n    pragma Inline (Then_Actions);\n    pragma Inline (Then_Statements);\n    pragma Inline (Triggering_Alternative);\n@@ -8976,6 +9055,8 @@ package Sinfo is\n    pragma Inline (Set_Identifier);\n    pragma Inline (Set_Implicit_With);\n    pragma Inline (Set_Includes_Infinities);\n+   pragma Inline (Set_Interface_List);\n+   pragma Inline (Set_Interface_Present);\n    pragma Inline (Set_In_Present);\n    pragma Inline (Set_Instance_Spec);\n    pragma Inline (Set_Intval);\n@@ -9025,7 +9106,6 @@ package Sinfo is\n    pragma Inline (Set_Null_Exclusion_Present);\n    pragma Inline (Set_Null_Record_Present);\n    pragma Inline (Set_Object_Definition);\n-   pragma Inline (Set_OK_For_Stream);\n    pragma Inline (Set_Original_Discriminant);\n    pragma Inline (Set_Original_Entity);\n    pragma Inline (Set_Others_Discrete_Choices);\n@@ -9075,10 +9155,11 @@ package Sinfo is\n    pragma Inline (Set_Subtype_Indication);\n    pragma Inline (Set_Subtype_Mark);\n    pragma Inline (Set_Subtype_Marks);\n+   pragma Inline (Set_Synchronized_Present);\n    pragma Inline (Set_Tagged_Present);\n    pragma Inline (Set_Target_Type);\n-   pragma Inline (Set_Task_Body_Procedure);\n    pragma Inline (Set_Task_Definition);\n+   pragma Inline (Set_Task_Present);\n    pragma Inline (Set_Then_Actions);\n    pragma Inline (Set_Then_Statements);\n    pragma Inline (Set_Triggering_Alternative);"}, {"sha": "6dedcabeca45185486f781df58aa76f76e98234c", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d8907c2025d9f9d29b96f236166389998a5a99/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=a9d8907c2025d9f9d29b96f236166389998a5a99", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,6 +26,7 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -169,11 +170,12 @@ package body Tbuild is\n \n       return\n         Unchecked_Convert_To (\n-          New_Occurrence_Of (Etype (Access_Disp_Table (Full_Type)), Loc),\n+          New_Occurrence_Of\n+            (Etype (Node (First_Elmt (Access_Disp_Table (Full_Type)))), Loc),\n           Make_Selected_Component (Loc,\n             Prefix => New_Copy (Rec),\n             Selector_Name =>\n-              New_Reference_To (Tag_Component (Full_Type), Loc)));\n+              New_Reference_To (First_Tag_Component (Full_Type), Loc)));\n    end Make_DT_Access;\n \n    -----------------------\n@@ -183,20 +185,22 @@ package body Tbuild is\n    function Make_DT_Component\n      (Loc : Source_Ptr;\n       Typ : Entity_Id;\n-      I   : Positive) return Node_Id\n+      N   : Positive) return Node_Id\n    is\n-      X : Node_Id;\n+      X         : Node_Id;\n       Full_Type : Entity_Id := Typ;\n \n    begin\n       if Is_Private_Type (Typ) then\n          Full_Type := Underlying_Type (Typ);\n       end if;\n \n-      X := First_Component (\n-             Designated_Type (Etype (Access_Disp_Table (Full_Type))));\n+      X :=\n+        First_Component\n+          (Designated_Type\n+             (Etype (Node (First_Elmt (Access_Disp_Table (Full_Type))))));\n \n-      for J in 2 .. I loop\n+      for J in 2 .. N loop\n          X := Next_Component (X);\n       end loop;\n \n@@ -216,6 +220,7 @@ package body Tbuild is\n    is\n    begin\n       Check_Restriction (No_Implicit_Conditionals, Node);\n+\n       return Make_If_Statement (Sloc (Node),\n         Condition,\n         Then_Statements,\n@@ -234,7 +239,6 @@ package body Tbuild is\n    is\n       N : constant Node_Id :=\n             Make_Implicit_Label_Declaration (Loc, Defining_Identifier);\n-\n    begin\n       Set_Label_Construct (N, Label_Construct);\n       return N;"}]}