{"sha": "20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhMmZiZTIwZTAxYTEyZDZiNDU3ODJlZDk4ZDA5MGVjZDE3Y2FmMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-11-26T23:54:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-26T23:54:30Z"}, "message": "configure.in (target frags): Add powerpc*-linux-gnulibc1.\n\n        * configure.in (target frags): Add powerpc*-linux-gnulibc1.\n        (stdio-lock): Similarly.\n\n        * configure.in (target frags): Add alpha*-linux-gnulibc1.\n        (pic frags): Its alpha*- not alpha-.\n        (stdio-lock): Kill everything.  Add alpha*-linux-gnulibc1.\n        * libio.h: Check __GLIBC_MINOR__ to find stdio-lock.h.  If not\n        _IO_MTSAFE_IO & GLIBC, make sure the lock pointer is still there.\n        * libioP.h: Check __GLIBC_MINOR__ to find libc-lock.h.\n\n        * config/linuxaxp1-libc-lock.h: New file.\n        * config/linuxaxp1-stdio-lock.h: New file.\n        * config/linuxaxp1.mt: New file.\n\n        * gen-params (va_list): Check for and use __gnuc_va_list.\n        (NULL): Work around some linux kernel headers and redefine NULL.\n\nFrom-SVN: r16769", "tree": {"sha": "ecb3a1ad37276540bbbf5b02dcf332f047b5bc19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecb3a1ad37276540bbbf5b02dcf332f047b5bc19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/comments", "author": null, "committer": null, "parents": [{"sha": "8fbd2dc7cbb6cd07133124ff9430a047f28f848b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fbd2dc7cbb6cd07133124ff9430a047f28f848b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fbd2dc7cbb6cd07133124ff9430a047f28f848b"}], "stats": {"total": 257, "additions": 224, "deletions": 33}, "files": [{"sha": "a9cf4d1e7365b84ed3a9df140f3eb22d71091c4f", "filename": "libio/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FChangeLog?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -1,3 +1,22 @@\n+Wed Nov 26 16:08:50 1997  Richard Henderson  (rth@cygnus.com)\n+\n+\t* configure.in (target frags): Add powerpc*-linux-gnulibc1.\n+\t(stdio-lock): Similarly.\n+\n+\t* configure.in (target frags): Add alpha*-linux-gnulibc1.\n+\t(pic frags): Its alpha*- not alpha-.\n+\t(stdio-lock): Kill everything.  Add alpha*-linux-gnulibc1.\n+\t* libio.h: Check __GLIBC_MINOR__ to find stdio-lock.h.  If not\n+\t_IO_MTSAFE_IO & GLIBC, make sure the lock pointer is still there.\n+\t* libioP.h: Check __GLIBC_MINOR__ to find libc-lock.h.\n+\n+\t* config/linuxaxp1-libc-lock.h: New file.\n+\t* config/linuxaxp1-stdio-lock.h: New file.\n+\t* config/linuxaxp1.mt: New file.\n+\n+\t* gen-params (va_list): Check for and use __gnuc_va_list.\n+\t(NULL): Work around some linux kernel headers and redefine NULL.\n+\n Tue Nov 18 09:53:58 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)\n \n \t* stdstrbufs.cc (DEF_STDFILE): Use STD_VTABLE."}, {"sha": "2523a0d5157b272898470b42c8888be1b290242d", "filename": "libio/config/linuxaxp1-libc-lock.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfig%2Flinuxaxp1-libc-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfig%2Flinuxaxp1-libc-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxaxp1-libc-lock.h?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -0,0 +1,112 @@\n+/* libc-internal interface for mutex locks.  LinuxThreads version.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _LIBC_LOCK_H\n+#define _LIBC_LOCK_H 1\n+\n+#include <pthread.h>\n+#define __libc_lock_t pthread_mutex_t\n+\n+/* Define a lock variable NAME with storage class CLASS.  The lock must be\n+   initialized with __libc_lock_init before it can be used (or define it\n+   with __libc_lock_define_initialized, below).  Use `extern' for CLASS to\n+   declare a lock defined in another module.  In public structure\n+   definitions you must use a pointer to the lock structure (i.e., NAME\n+   begins with a `*'), because its storage size will not be known outside\n+   of libc.  */\n+#define __libc_lock_define(CLASS,NAME) \\\n+  CLASS __libc_lock_t NAME;\n+\n+/* Define an initialized lock variable NAME with storage class CLASS.  */\n+#define __libc_lock_define_initialized(CLASS,NAME) \\\n+  CLASS __libc_lock_t NAME = PTHREAD_MUTEX_INITIALIZER;\n+\n+/* Initialize the named lock variable, leaving it in a consistent, unlocked\n+   state.  */\n+#define __libc_lock_init(NAME) \\\n+  (__pthread_mutex_init != NULL ? __pthread_mutex_init (&(NAME), NULL) : 0);\n+\n+/* Same as last but this time we initialize a recursive mutex.  */\n+#define __libc_lock_init_recursive(NAME) \\\n+  do {                                                                      \\\n+    if (__pthread_mutex_init != NULL)                                       \\\n+      {                                                                     \\\n+      pthread_mutexattr_t __attr;                                           \\\n+      __pthread_mutexattr_init (&__attr);                                   \\\n+      __pthread_mutexattr_setkind_np (&__attr, PTHREAD_MUTEX_RECURSIVE_NP); \\\n+      __pthread_mutex_init (&(NAME), &__attr);                              \\\n+      __pthread_mutexattr_destroy (&__attr);                                \\\n+      }                                                                             \\\n+  } while (0);\n+\n+/* Finalize the named lock variable, which must be locked.  It cannot be\n+   used again until __libc_lock_init is called again on it.  This must be\n+   called on a lock variable before the containing storage is reused.  */\n+#define __libc_lock_fini(NAME) \\\n+  (__pthread_mutex_destroy != NULL ? __pthread_mutex_destroy (&(NAME)) : 0);\n+\n+/* Lock the named lock variable.  */\n+#define __libc_lock_lock(NAME) \\\n+  (__pthread_mutex_lock != NULL ? __pthread_mutex_lock (&(NAME)) : 0);\n+\n+/* Try to lock the named lock variable.  */\n+#define __libc_lock_trylock(NAME) \\\n+  (__pthread_mutex_trylock != NULL ? __pthread_mutex_trylock (&(NAME)) : 0);\n+\n+/* Unlock the named lock variable.  */\n+#define __libc_lock_unlock(NAME) \\\n+  (__pthread_mutex_unlock != NULL ? __pthread_mutex_unlock (&(NAME)) : 0);\n+\n+/* Start critical region with cleanup.  */\n+#define __libc_cleanup_region_start(FCT, ARG) \\\n+  { struct _pthread_cleanup_buffer _buffer;                                 \\\n+    if (_pthread_cleanup_push_defer != NULL) {                              \\\n+      _pthread_cleanup_push_defer (&_buffer, (FCT), (ARG));                 \\\n+    }\n+\n+/* End critical region with cleanup.  */\n+#define __libc_cleanup_region_end(DOIT) \\\n+    if (_pthread_cleanup_push_defer != NULL) {                              \\\n+      _pthread_cleanup_pop_restore (&_buffer, (DOIT));                      \\\n+    }                                                                       \\\n+  }\n+\n+/* Make the pthread functions weak so that we can elide them from\n+   single-threaded processes.  */\n+#pragma weak __pthread_mutex_init\n+#pragma weak __pthread_mutex_destroy\n+#pragma weak __pthread_mutex_lock\n+#pragma weak __pthread_mutex_trylock\n+#pragma weak __pthread_mutex_unlock\n+#pragma weak __pthread_mutexattr_init\n+#pragma weak __pthread_mutexattr_destroy\n+#pragma weak __pthread_mutexattr_setkind_np\n+#pragma weak __pthread_key_create\n+#pragma weak __pthread_setspecific\n+#pragma weak __pthread_getspecific\n+#pragma weak __pthread_initialize\n+#pragma weak _pthread_cleanup_push_defer\n+#pragma weak _pthread_cleanup_pop_restore\n+\n+/* We need portable names for some functions.  E.g., when they are\n+   used as argument to __libc_cleanup_region_start.  */\n+#define __libc_mutex_unlock __pthread_mutex_unlock\n+\n+#endif        /* libc-lock.h */\n+"}, {"sha": "cbee76867d12053c57a68a34db5066ff844e408a", "filename": "libio/config/linuxaxp1-stdio-lock.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfig%2Flinuxaxp1-stdio-lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfig%2Flinuxaxp1-stdio-lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxaxp1-stdio-lock.h?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -0,0 +1,36 @@\n+/* Thread package specific definitions of stream lock type.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include <pthread.h>\n+\n+typedef pthread_mutex_t _IO_lock_t;\n+\n+/* We need recursive (counting) mutexes.  */\n+#define _IO_lock_initializer PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n+\n+\n+#define _IO_cleanup_region_start(_fct, _fp) \\\n+     __libc_cleanup_region_start (_fct, _fp)\n+#define _IO_cleanup_region_end(_doit) \\\n+     __libc_cleanup_region_end (_doit)\n+#define _IO_lock_init(_name) \\\n+     __libc_lock_init_recursive (_name)\n+#define _IO_lock_fini(_name) \\\n+     __libc_lock_fini_recursive (_name)\n+"}, {"sha": "ef1617b61811168515a9ac7b1414732cc92b83da", "filename": "libio/config/linuxaxp1.mt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfig%2Flinuxaxp1.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfig%2Flinuxaxp1.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxaxp1.mt?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -0,0 +1,10 @@\n+# We _do_ need a new _G_config.h\n+_G_CONFIG_H=_G_config.h\n+\n+# And the two bits files.\n+all:\n+install: install-axp-mt-headers\n+\n+install-axp-mt-headers:\n+\t$(INSTALL_DATA) libc-lock.h $(gxx_includedir)/libc-lock.h\n+\t$(INSTALL_DATA) stdio-lock.h $(gxx_includedir)/stdio-lock.h"}, {"sha": "5de2dc1113ba77d75a8fe1102c25b7c65b2dba97", "filename": "libio/configure.in", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfigure.in?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -16,6 +16,10 @@ frags=\n \n case \"${target}\" in\n   *-hpux*)       frags=hpux.mt ;;\n+  alpha*-*-linux-gnulibc1)\n+\t\t frags=\"linux.mt linuxaxp1.mt mtsafe.mt\" ;;\n+  powerpc*-*-linux-gnulibc1)\n+\t\t frags=\"linux.mt linuxaxp1.mt mtsafe.mt\" ;;\n   *-linux-gnulibc1)\n \t\t frags=linuxlibc1.mt ;;\n   *-linux-gnu)   frags=\"linux.mt mtsafe.mt\" ;;\n@@ -36,34 +40,29 @@ if [ \"${shared}\" = \"yes\" ]; then\n   case \"${target}\" in\n     hppa*-*)\t frags=\"${frags} ../../config/mh-papic\" ;;\n     i[3456]86-*) frags=\"${frags} ../../config/mh-x86pic\" ;;\n-    alpha-*-linux*)\n+    alpha*-*-linux*)\n \t\t frags=\"${frags} ../../config/mh-elfalphapic\" ;;\n     *)\t         frags=\"${frags} ../../config/mh-${target_cpu}pic\" ;;\n   esac\n fi\n \n-# Make a link for the correct stdio-lock.h file.\n+# Take care of header file lossage.\n case \"${target}\" in\n-  *-linux-gnu)\n-    # We have a correct file in glibc but the libioP.h file is written\n-    # with glibc 2.1 in mind which has the internals headers in special\n-    # directory while glibc 2.0 has them in /usr/include.  Create a wrapper\n-    # if necessary.\n-    (echo \"#include <bits/libc-lock.h>\" | ${CC-cc} -E -) >/dev/null 2>&1 ||\n-      {\n-\trm -fr bits\n-        mkdir bits\n-        echo \"#include <libc-lock.h>\" > bits/libc-lock.h\n-\techo 'asm (\".weak _pthread_cleanup_pop_restore\");' >> bits/libc-lock.h\n-\techo 'asm (\".weak _pthread_cleanup_push_defer\");' >> bits/libc-lock.h\n-\n-        echo \"#include <stdio-lock.h>\" > bits/stdio-lock.h\n-      }\n+  alpha*-*-linux-gnulibc1)\n+    # For some reason stdio-lock.h is not installed on Red Hat systems.\n+    # Further, libc-lock.h needs to define the pthreads stuff weak, and\n+    # fails to do this for other than _LIBC.  Install our own versions\n+    # of these files.\n+    cp ${srcdir}/config/linuxaxp1-libc-lock.h libc-lock.h\n+    cp ${srcdir}/config/linuxaxp1-stdio-lock.h stdio-lock.h\n     ;;\n-  *)\n-    rm -fr bits\n-    mkdir bits\n-    ln -s ${srcdir}/include/empty.h bits/stdio-lock.h\n+  powerpc*-*-linux-gnulibc1)\n+    # For some reason stdio-lock.h is not installed on Red Hat systems.\n+    # Further, libc-lock.h needs to define the pthreads stuff weak, and\n+    # fails to do this for other than _LIBC.  Install our own versions\n+    # of these files.\n+    cp ${srcdir}/config/linuxaxp1-libc-lock.h libc-lock.h\n+    cp ${srcdir}/config/linuxaxp1-stdio-lock.h stdio-lock.h\n     ;;\n esac\n "}, {"sha": "f23dfbf4532086e63945d7f33326e275f5a2ffd6", "filename": "libio/gen-params", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fgen-params", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Fgen-params", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fgen-params?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -487,9 +487,18 @@ if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n   # Ok: We have something that works.\n   echo \"typedef ${va_list-char* /* default */} ${macro_prefix}va_list;\"\n else\n-  # No, it breaks.  Indicate that <stdarg.h> must be included.\n-  echo \"#define ${macro_prefix}NEED_STDARG_H\n-#define ${macro_prefix}va_list va_list\"\n+  echo \"#define ${macro_prefix}NEED_STDARG_H\"\n+  # Check and see if we have __gnuc_va_list, as we might set up define\n+  # loops if we use va_list.\n+  cat >dummy.C <<!EOF!\n+#include <stdarg.h>\n+long foo(__gnuc_va_list ap) { return va_arg(ap, long); }\n+!EOF!\n+  if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n+    echo \"#define ${macro_prefix}va_list __gnuc_va_list\"\n+  else\n+    echo \"#define ${macro_prefix}va_list va_list\"\n+  fi\n fi\n \n cat >dummy.c <<!EOF!"}, {"sha": "b7f8af7c791eafc914c841a1ca72f555e52555f0", "filename": "libio/libio.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Flibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2Flibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Flibio.h?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -150,23 +150,25 @@ struct _IO_jump_t;  struct _IO_FILE;\n /* Handle lock.  */\n #ifdef _IO_MTSAFE_IO\n # if defined __GLIBC__ && __GLIBC__ >= 2\n-#  include <bits/stdio-lock.h>\n+#  if __GLIBC_MINOR__ > 0\n+#   include <bits/stdio-lock.h>\n+#  else\n+#   include <stdio-lock.h>\n+#  endif\n #  define _IO_LOCK_T _IO_lock_t *\n # else\n /*# include <comthread.h>*/\n # endif\n #else\n-/* XXX This will go away as soon as comthread is finished.  */\n-# if defined __GLIBC__ && __GLIBC__ >= 2\n+# if defined(__GLIBC__) && __GLIBC__ >= 2\n+   typedef void _IO_lock_t;\n #  define _IO_LOCK_T void *\n # else\n #  ifdef __linux__\n-struct _IO_lock_t {\n-  void *ptr;\n-  short int field1;\n-  short int field2;\n-};\n+    struct _IO_lock_t { void *ptr; short int field1; short int field2; };\n #   define _IO_LOCK_T struct _IO_lock_t\n+#  else\n+    typedef void _IO_lock_t;\n #  endif\n # endif\n #endif"}, {"sha": "bbe92a4cf16f2d6ce4f381302c6b11aab56c0dea", "filename": "libio/libioP.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2FlibioP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a2fbe20e01a12d6b45782ed98d090ecd17caf3/libio%2FlibioP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FlibioP.h?ref=20a2fbe20e01a12d6b45782ed98d090ecd17caf3", "patch": "@@ -28,7 +28,11 @@\n # define __set_errno(Val) errno = (Val)\n #endif\n #if defined __GLIBC__ && __GLIBC__ >= 2\n-# include <bits/libc-lock.h>\n+# if __GLIBC_MINOR__ > 0\n+#  include <bits/libc-lock.h>\n+# else\n+#  include <libc-lock.h>\n+# endif\n #else\n /*# include <comthread.h>*/\n #endif"}]}