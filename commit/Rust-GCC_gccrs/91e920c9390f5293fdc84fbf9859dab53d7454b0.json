{"sha": "91e920c9390f5293fdc84fbf9859dab53d7454b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlOTIwYzkzOTBmNTI5M2ZkYzg0ZmJmOTg1OWRhYjUzZDc0NTRiMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-31T16:46:58Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-31T16:46:58Z"}, "message": "cp-tree.h (lang_decl_slector): New enum.\n\n\t* cp-tree.h (lang_decl_slector): New enum.\n\t(lang_decl_base): Make selector an enum.  Drop decomposition_p\n\tfield.\n\t(lang_decl): Use enum for discrimination.\n\t(LANG_DECL_FN_CHECK, LANG_DECL_NS_CHECK, LANG_DECL_PARM_CHECK,\n\tLANG_DECL_DEOMP_CHECK): Use enum.\n\t(DECL_DECOMPOSITION_P): Use selector value.\n\t(SET_DECL_DECOMPOSITION_P): Delete.\n\t(retrofit_lang_decl): Lose SEL parm.\n\t(fit_decomposition_lang_decl): Declare.\n\t* decl.c (cp_finish_decomp, grokdeclarator): Use\n\tfit_decomposition_lang_decl.\n\t* lex.c (maybe_add_lang_decl_raw): New. Broken out of\n\tretrofit_lang_decl.\n\t(set_decl_linkage): New.  Broken out of retrofit_lang_decl.  Use\n\tenum.\n\t(fit_decomposition_lang_decl): Likewise.\n\t(retrofit_lang_decl): Use worker functions.\n\t(cxx_dup_lang_specific_decl): Use selector enum.\n\t(maybe_add_lang_type_raw): New.  Broken out of ...\n\t(cxx_make_type_name): ... here.  Call it.\n\nFrom-SVN: r248748", "tree": {"sha": "4c41fc434e3fb47d6867bccb8b227635de1ff46b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c41fc434e3fb47d6867bccb8b227635de1ff46b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91e920c9390f5293fdc84fbf9859dab53d7454b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e920c9390f5293fdc84fbf9859dab53d7454b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91e920c9390f5293fdc84fbf9859dab53d7454b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e920c9390f5293fdc84fbf9859dab53d7454b0/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3909991c7b89c99e28d4b8ed2a2de740adb1d432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3909991c7b89c99e28d4b8ed2a2de740adb1d432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3909991c7b89c99e28d4b8ed2a2de740adb1d432"}], "stats": {"total": 246, "additions": 162, "deletions": 84}, "files": [{"sha": "72a56f7553b3d1632cbeef57b44b1e5d8a700b5b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=91e920c9390f5293fdc84fbf9859dab53d7454b0", "patch": "@@ -1,3 +1,26 @@\n+2017-05-31  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (lang_decl_slector): New enum.\n+\t(lang_decl_base): Make selector an enum.  Drop decomposition_p\n+\tfield.\n+\t(lang_decl): Use enum for discrimination.\n+\t(LANG_DECL_FN_CHECK, LANG_DECL_NS_CHECK, LANG_DECL_PARM_CHECK,\n+\tLANG_DECL_DEOMP_CHECK): Use enum.\n+\t(DECL_DECOMPOSITION_P): Use selector value.\n+\t(SET_DECL_DECOMPOSITION_P): Delete.\n+\t(retrofit_lang_decl): Lose SEL parm.\n+\t(fit_decomposition_lang_decl): Declare.\n+\t* decl.c (cp_finish_decomp, grokdeclarator): Use\n+\tfit_decomposition_lang_decl.\n+\t* lex.c (maybe_add_lang_decl_raw): New. Broken out of\n+\tretrofit_lang_decl.\n+\t(set_decl_linkage): New.  Broken out of retrofit_lang_decl.  Use enum.\n+\t(fit_decomposition_lang_decl): Likewise.\n+\t(retrofit_lang_decl): Use worker functions.\n+\t(cxx_dup_lang_specific_decl): Use selector enum.\n+\t(maybe_add_lang_type_raw): New.  Broken out of ...\n+\t(cxx_make_type_name): ... here.  Call it.\n+\n 2017-05-30  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/80856 - ICE with local extern in template"}, {"sha": "1c3cce8963b80ea7d81d739a0f1b94dfdb9656eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=91e920c9390f5293fdc84fbf9859dab53d7454b0", "patch": "@@ -2423,13 +2423,25 @@ struct GTY(()) lang_type {\n #define NAMESPACE_LEVEL(NODE) \\\n   (LANG_DECL_NS_CHECK (NODE)->level)\n \f\n+/* Discriminator values for lang_decl.  */\n+\n+enum lang_decl_selector\n+{\n+  lds_min,\n+  lds_fn,\n+  lds_ns,\n+  lds_parm,\n+  lds_decomp\n+};\n+\n /* Flags shared by all forms of DECL_LANG_SPECIFIC.\n \n    Some of the flags live here only to make lang_decl_min/fn smaller.  Do\n    not make this struct larger than 32 bits; instead, make sel smaller.  */\n \n struct GTY(()) lang_decl_base {\n-  unsigned selector : 16;   /* Larger than necessary for faster access.  */\n+  /* Larger than necessary for faster access.  */\n+  ENUM_BITFIELD(lang_decl_selector) selector : 16;\n   ENUM_BITFIELD(languages) language : 1;\n   unsigned use_template : 2;\n   unsigned not_really_extern : 1;\t   /* var or fn */\n@@ -2444,8 +2456,7 @@ struct GTY(()) lang_decl_base {\n   unsigned u2sel : 1;\n   unsigned concept_p : 1;                  /* applies to vars and functions */\n   unsigned var_declared_inline_p : 1;\t   /* var */\n-  unsigned decomposition_p : 1;\t\t   /* var */\n-  /* 1 spare bit */\n+  /* 2 spare bits */\n };\n \n /* True for DECL codes which have template info and access.  */\n@@ -2577,12 +2588,13 @@ struct GTY(()) lang_decl_decomp {\n \n struct GTY(()) lang_decl {\n   union GTY((desc (\"%h.base.selector\"))) lang_decl_u {\n+     /* Nothing of only the base type exists.  */\n     struct lang_decl_base GTY ((default)) base;\n-    struct lang_decl_min GTY((tag (\"0\"))) min;\n-    struct lang_decl_fn GTY ((tag (\"1\"))) fn;\n-    struct lang_decl_ns GTY((tag (\"2\"))) ns;\n-    struct lang_decl_parm GTY((tag (\"3\"))) parm;\n-    struct lang_decl_decomp GTY((tag (\"4\"))) decomp;\n+    struct lang_decl_min GTY((tag (\"lds_min\"))) min;\n+    struct lang_decl_fn GTY ((tag (\"lds_fn\"))) fn;\n+    struct lang_decl_ns GTY((tag (\"lds_ns\"))) ns;\n+    struct lang_decl_parm GTY((tag (\"lds_parm\"))) parm;\n+    struct lang_decl_decomp GTY((tag (\"lds_decomp\"))) decomp;\n   } u;\n };\n \n@@ -2603,26 +2615,29 @@ struct GTY(()) lang_decl {\n    lang_decl_fn, look down through a TEMPLATE_DECL into its result.  */\n #define LANG_DECL_FN_CHECK(NODE) __extension__\t\t\t\t\\\n ({ struct lang_decl *lt = DECL_LANG_SPECIFIC (STRIP_TEMPLATE (NODE));\t\\\n-   if (!DECL_DECLARES_FUNCTION_P (NODE) || lt->u.base.selector != 1)\t\\\n+   if (!DECL_DECLARES_FUNCTION_P (NODE)\t\t\t\t\t\\\n+       || lt->u.base.selector != lds_fn)\t\t\t\t\\\n      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\t\\\n    &lt->u.fn; })\n \n #define LANG_DECL_NS_CHECK(NODE) __extension__\t\t\t\t\\\n ({ struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\t\\\n-   if (TREE_CODE (NODE) != NAMESPACE_DECL || lt->u.base.selector != 2)\t\\\n+   if (TREE_CODE (NODE) != NAMESPACE_DECL\t\t\t\t\\\n+       || lt->u.base.selector != lds_ns)\t\t\t\t\\\n      lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\t\\\n    &lt->u.ns; })\n \n #define LANG_DECL_PARM_CHECK(NODE) __extension__\t\t\\\n ({ struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n-  if (TREE_CODE (NODE) != PARM_DECL)\t\t\t\t\\\n+  if (TREE_CODE (NODE) != PARM_DECL\t\t\t\t\\\n+      || lt->u.base.selector != lds_parm)\t\t\t\\\n     lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n   &lt->u.parm; })\n \n #define LANG_DECL_DECOMP_CHECK(NODE) __extension__\t\t\\\n ({ struct lang_decl *lt = DECL_LANG_SPECIFIC (NODE);\t\t\\\n   if (!VAR_P (NODE)\t\t\t\t\t\t\\\n-      || lt->u.base.selector != 4)\t\t\t\t\\\n+      || lt->u.base.selector != lds_decomp)\t\t\t\\\n     lang_check_failed (__FILE__, __LINE__, __FUNCTION__);\t\\\n   &lt->u.decomp; })\n \n@@ -3893,11 +3908,8 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    declaration or one of VAR_DECLs for the user identifiers in it.  */\n #define DECL_DECOMPOSITION_P(NODE) \\\n   (VAR_P (NODE) && DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n-   ? DECL_LANG_SPECIFIC (NODE)->u.base.decomposition_p\t\t\\\n+   ? DECL_LANG_SPECIFIC (NODE)->u.base.selector == lds_decomp\t\t\\\n    : false)\n-#define SET_DECL_DECOMPOSITION_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))->u.base.decomposition_p \\\n-   = true)\n \n /* The underlying artificial VAR_DECL for structured binding.  */\n #define DECL_DECOMP_BASE(NODE) \\\n@@ -6338,7 +6350,8 @@ extern tree unqualified_name_lookup_error\t(tree,\n extern tree unqualified_fn_lookup_error\t\t(cp_expr);\n extern tree build_lang_decl\t\t\t(enum tree_code, tree, tree);\n extern tree build_lang_decl_loc\t\t\t(location_t, enum tree_code, tree, tree);\n-extern void retrofit_lang_decl\t\t\t(tree, int = 0);\n+extern void retrofit_lang_decl\t\t\t(tree);\n+extern void fit_decomposition_lang_decl\t\t(tree, tree);\n extern tree copy_decl\t\t\t\t(tree CXX_MEM_STAT_INFO);\n extern tree copy_type\t\t\t\t(tree CXX_MEM_STAT_INFO);\n extern tree cxx_make_type\t\t\t(enum tree_code);"}, {"sha": "e895fa7642e851d464d8e23dfcea15d7526e22c1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=91e920c9390f5293fdc84fbf9859dab53d7454b0", "patch": "@@ -7372,11 +7372,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n \t      DECL_HAS_VALUE_EXPR_P (first) = 1;\n \t    }\n \t  if (processing_template_decl)\n-\t    {\n-\t      retrofit_lang_decl (first, 4);\n-\t      SET_DECL_DECOMPOSITION_P (first);\n-\t      DECL_DECOMP_BASE (first) = decl;\n-\t    }\n+\t    fit_decomposition_lang_decl (first, decl);\n \t  first = DECL_CHAIN (first);\n \t}\n       return;\n@@ -7388,9 +7384,7 @@ cp_finish_decomp (tree decl, tree first, unsigned int count)\n   for (unsigned int i = 0; i < count; i++, d = DECL_CHAIN (d))\n     {\n       v[count - i - 1] = d;\n-      retrofit_lang_decl (d, 4);\n-      SET_DECL_DECOMPOSITION_P (d);\n-      DECL_DECOMP_BASE (d) = decl;\n+      fit_decomposition_lang_decl (d, decl);\n     }\n \n   tree type = TREE_TYPE (decl);\n@@ -12314,10 +12308,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t  {\n \t    gcc_assert (declarator && declarator->kind == cdk_decomp);\n \t    DECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n-\t    retrofit_lang_decl (decl, 4);\n \t    DECL_ARTIFICIAL (decl) = 1;\n-\t    SET_DECL_DECOMPOSITION_P (decl);\n-\t    DECL_DECOMP_BASE (decl) = NULL_TREE;\n+\t    fit_decomposition_lang_decl (decl, NULL_TREE);\n \t  }\n       }\n "}, {"sha": "5dc9eee6d52a70bef13f52b7f79d74bc702decb7", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 106, "deletions": 56, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e920c9390f5293fdc84fbf9859dab53d7454b0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=91e920c9390f5293fdc84fbf9859dab53d7454b0", "patch": "@@ -525,91 +525,132 @@ build_lang_decl_loc (location_t loc, enum tree_code code, tree name, tree type)\n   return t;\n }\n \n-/* Add DECL_LANG_SPECIFIC info to T.  Called from build_lang_decl\n-   and pushdecl (for functions generated by the back end).  */\n+/* Maybe add a raw lang_decl to T, a decl.  Return true if it needed\n+   one.  */\n \n-void\n-retrofit_lang_decl (tree t, int sel)\n+static bool\n+maybe_add_lang_decl_raw (tree t, bool decomp_p)\n {\n-  struct lang_decl *ld;\n   size_t size;\n-  size_t oldsize = 0;\n-\n-  if (DECL_LANG_SPECIFIC (t))\n-    {\n-      if (sel)\n-\t{\n-\t  if (DECL_LANG_SPECIFIC (t)->u.base.selector == sel)\n-\t    return;\n-\t  gcc_assert (DECL_LANG_SPECIFIC (t)->u.base.selector == 0);\n-\t  oldsize = sizeof (struct lang_decl_min);\n-\t}\n-      else\n-\treturn;\n-    }\n+  lang_decl_selector sel;\n \n-  if (sel == 4)\n-    size = sizeof (struct lang_decl_decomp);\n+  if (decomp_p)\n+    sel = lds_decomp, size = sizeof (struct lang_decl_decomp);\n   else if (TREE_CODE (t) == FUNCTION_DECL)\n-    sel = 1, size = sizeof (struct lang_decl_fn);\n+    sel = lds_fn, size = sizeof (struct lang_decl_fn);\n   else if (TREE_CODE (t) == NAMESPACE_DECL)\n-    sel = 2, size = sizeof (struct lang_decl_ns);\n+    sel = lds_ns, size = sizeof (struct lang_decl_ns);\n   else if (TREE_CODE (t) == PARM_DECL)\n-    sel = 3, size = sizeof (struct lang_decl_parm);\n+    sel = lds_parm, size = sizeof (struct lang_decl_parm);\n   else if (LANG_DECL_HAS_MIN (t))\n-    sel = 0, size = sizeof (struct lang_decl_min);\n+    sel = lds_min, size = sizeof (struct lang_decl_min);\n   else\n-    gcc_unreachable ();\n+    return false;\n \n-  ld = (struct lang_decl *) ggc_internal_cleared_alloc (size);\n-  if (oldsize)\n-    memcpy (ld, DECL_LANG_SPECIFIC (t), oldsize);\n+  struct lang_decl *ld\n+    = (struct lang_decl *) ggc_internal_cleared_alloc (size);\n \n   ld->u.base.selector = sel;\n   DECL_LANG_SPECIFIC (t) = ld;\n \n-  if (sel == 2)\n+  if (sel == lds_ns)\n     /* Who'd create a namespace, only to put nothing in it?  */\n     ld->u.ns.bindings = hash_map<lang_identifier *, tree>::create_ggc (499);\n \n+  if (GATHER_STATISTICS)\n+    {\n+      tree_node_counts[(int)lang_decl] += 1;\n+      tree_node_sizes[(int)lang_decl] += size;\n+    }\n+  return true;\n+}\n+\n+/* T has just had a decl_lang_specific added.  Initialize its\n+   linkage.  */\n+\n+static void\n+set_decl_linkage (tree t)\n+{\n   if (current_lang_name == lang_name_cplusplus\n       || decl_linkage (t) == lk_none)\n     SET_DECL_LANGUAGE (t, lang_cplusplus);\n   else if (current_lang_name == lang_name_c)\n     SET_DECL_LANGUAGE (t, lang_c);\n   else\n     gcc_unreachable ();\n+}\n \n-  if (GATHER_STATISTICS)\n+/* T is a VAR_DECL node that needs to be a decomposition of BASE.  */\n+\n+void\n+fit_decomposition_lang_decl (tree t, tree base)\n+{\n+  if (struct lang_decl *orig_ld = DECL_LANG_SPECIFIC (t))\n     {\n-      tree_node_counts[(int)lang_decl] += 1;\n-      tree_node_sizes[(int)lang_decl] += size;\n+      if (orig_ld->u.base.selector == lds_min)\n+\t{\n+\t  maybe_add_lang_decl_raw (t, true);\n+\t  memcpy (DECL_LANG_SPECIFIC (t), orig_ld,\n+\t\t  sizeof (struct lang_decl_min));\n+\t  /* Reset selector, which will have been bashed by the\n+\t     memcpy.  */\n+\t  DECL_LANG_SPECIFIC (t)->u.base.selector = lds_decomp;\n+\t}\n+      else\n+\tgcc_checking_assert (orig_ld->u.base.selector == lds_decomp);\n+    }\n+  else\n+    {\n+      maybe_add_lang_decl_raw (t, true);\n+      set_decl_linkage (t);\n     }\n+\n+  DECL_DECOMP_BASE (t) = base;\n+}\n+\n+/* Add DECL_LANG_SPECIFIC info to T, if it needs one.  Generally\n+   every C++ decl needs one, but C builtins etc do not.   */\n+\n+void\n+retrofit_lang_decl (tree t)\n+{\n+  if (DECL_LANG_SPECIFIC (t))\n+    return;\n+\n+  if (maybe_add_lang_decl_raw (t, false))\n+    set_decl_linkage (t);\n }\n \n void\n cxx_dup_lang_specific_decl (tree node)\n {\n   int size;\n-  struct lang_decl *ld;\n \n   if (! DECL_LANG_SPECIFIC (node))\n     return;\n \n-  if (TREE_CODE (node) == FUNCTION_DECL)\n-    size = sizeof (struct lang_decl_fn);\n-  else if (TREE_CODE (node) == NAMESPACE_DECL)\n-    size = sizeof (struct lang_decl_ns);\n-  else if (TREE_CODE (node) == PARM_DECL)\n-    size = sizeof (struct lang_decl_parm);\n-  else if (DECL_DECOMPOSITION_P (node))\n-    size = sizeof (struct lang_decl_decomp);\n-  else if (LANG_DECL_HAS_MIN (node))\n-    size = sizeof (struct lang_decl_min);\n-  else\n-    gcc_unreachable ();\n+  switch (DECL_LANG_SPECIFIC (node)->u.base.selector)\n+    {\n+    case lds_min:\n+      size = sizeof (struct lang_decl_min);\n+      break;\n+    case lds_fn:\n+      size = sizeof (struct lang_decl_fn);\n+      break;\n+    case lds_ns:\n+      size = sizeof (struct lang_decl_ns);\n+      break;\n+    case lds_parm:\n+      size = sizeof (struct lang_decl_parm);\n+      break;\n+    case lds_decomp:\n+      size = sizeof (struct lang_decl_decomp);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  ld = (struct lang_decl *) ggc_internal_alloc (size);\n+  struct lang_decl *ld = (struct lang_decl *) ggc_internal_alloc (size);\n   memcpy (ld, DECL_LANG_SPECIFIC (node), size);\n   DECL_LANG_SPECIFIC (node) = ld;\n \n@@ -670,18 +711,18 @@ copy_type (tree type MEM_STAT_DECL)\n   return copy;\n }\n \n-tree\n-cxx_make_type (enum tree_code code)\n-{\n-  tree t = make_node (code);\n+/* Add a raw lang_type to T, a type, should it need one.  */\n \n-  /* Create lang_type structure.  */\n-  if (RECORD_OR_UNION_CODE_P (code)\n-      || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n+static bool\n+maybe_add_lang_type_raw (tree t)\n+{\n+  bool add = (RECORD_OR_UNION_CODE_P (TREE_CODE (t))\n+\t      || TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM);\n+  if (add)\n     {\n       struct lang_type *pi\n-          = (struct lang_type *) ggc_internal_cleared_alloc\n-\t  (sizeof (struct lang_type));\n+\t= (struct lang_type *) ggc_internal_cleared_alloc\n+\t(sizeof (struct lang_type));\n \n       TYPE_LANG_SPECIFIC (t) = pi;\n       pi->u.c.h.is_lang_type_class = 1;\n@@ -692,6 +733,15 @@ cxx_make_type (enum tree_code code)\n \t  tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n \t}\n     }\n+  return add;\n+}\n+\n+tree\n+cxx_make_type (enum tree_code code)\n+{\n+  tree t = make_node (code);\n+\n+  maybe_add_lang_type_raw (t);\n \n   /* Set up some flags that give proper default behavior.  */\n   if (RECORD_OR_UNION_CODE_P (code))"}]}