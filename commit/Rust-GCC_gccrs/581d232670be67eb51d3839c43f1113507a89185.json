{"sha": "581d232670be67eb51d3839c43f1113507a89185", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxZDIzMjY3MGJlNjdlYjUxZDM4MzljNDNmMTExMzUwN2E4OTE4NQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-11-13T12:05:01Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-11-13T12:05:01Z"}, "message": "PR 60324 Unbounded stack allocations in libgfortran.\n\n2014-11-13  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libfortran/60324\n\t* configure: Regenerated.\n\t* configure.ac (AM_CFLAGS): Add Werror=vla.\n\t* libgfortran.h (gfc_alloca): Remove macro.\n\t(fc_strdup_notrim): New prototype.\n\t* intrinsics/access.c (access_func): Use fc_strdup rather than\n\tstack allocation.\n\t* intrinsics/chdir.c (chdir_i4_sub): Likewise.\n\t(chdir_i8_sub): Likewise.\n\t* intrinsics/chmod.c (chmod_internal): New function, move logic\n\there.\n\t(chmod_func): Call chmod_internal.\n\t* intrinsics/env.c (getenv): Use fc_strdup rather than stack\n\tallocation.\n\t(get_environment_variable_i4): Likewise.\n\t* intrinsics/execute_command_line.c (execute_command_line):\n\tLikewise.\n\t* intrinsics/hostnm.c (hostnm_0): New function, use static buffer\n\trather than VLA.\n\t(hostnm_i4_sub): Call hostnm_0.\n\t(hostnm_i8_sub): Likewise.\n\t(hostnm): Likewise.\n\t* intrinsics/link.c (link_internal): New function, use fc_strdup\n\trather than stack allocation.\n\t(link_i4_sub): Call link_internal.\n\t(link_i8_sub): Likewise.\n\t(link_i4): Likewise.\n\t(link_i8): Likewise.\n\t* intrinsics/perror.c (perror_sub): Use fc_strdup rather than\n\tstack allocation.\n\t* intrinsics/random.c (random_seed_i4): Use static buffer rather\n\tthan VLA, use _Static_assert to make sure it's big enough.\n\t* intrinsics/rename.c (rename_internal): New function, use\n\tfc_strdup rather than stack allocation.\n\t(rename_i4_sub): Call rename_internal.\n\t(rename_i8_sub): Likewise.\n\t(rename_i4): Likewise.\n\t(rename_i8): Likewise.\n\t* intrinsics/stat.c (stat_i4_sub_0): Use fc_strdup rather than\n\tstack allocation.\n\t(stat_i8_sub_0): Likewise.\n\t* intrinsics/symlink.c (symlnk_internal): New function, use\n\tfc_strdup rather than stack allocation.\n\t(symlnk_i4_sub): Call symlnk_internal.\n\t(symlnk_i8_sub): Likewise.\n\t(symlnk_i4): Likewise.\n\t(symlnk_i8): Likewise.\n\t* intrinsics/system.c (system_sub): Use fc_strdup rather than\n\tstack allocation.\n\t* intrinsics/unlink.c (unlink_i4_sub): Likewise.\n\t* io/file_pos.c (READ_CHUNK): Make it a macro rather than variable.\n\t* io/list_read.c (nml_get_obj_data): Use fixed stack buffer, fall\n\tback to xmalloc/free for large sizes.\n\t* io/read.c (read_f): Likewise.\n\t* io/transfer.c (MAX_READ): Make it a macro rather than variable.\n\t(WRITE_CHUNK): Likewise.\n\t* io/write_float.def (write_float): Use fixed stack buffer, fall\n\tback to xmalloc/free for large sizes.\n\t* runtime/string.c (fc_strdup_notrim): New function.\n\nFrom-SVN: r217480", "tree": {"sha": "c1593d21b75ed82f1d44f238217eb2c1724e03ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1593d21b75ed82f1d44f238217eb2c1724e03ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/581d232670be67eb51d3839c43f1113507a89185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581d232670be67eb51d3839c43f1113507a89185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581d232670be67eb51d3839c43f1113507a89185", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581d232670be67eb51d3839c43f1113507a89185/comments", "author": null, "committer": null, "parents": [{"sha": "95cc11e1634c8faa09ab161564a13c1ae9ec1794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cc11e1634c8faa09ab161564a13c1ae9ec1794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95cc11e1634c8faa09ab161564a13c1ae9ec1794"}], "stats": {"total": 566, "additions": 271, "deletions": 295}, "files": [{"sha": "119e1aef402a1924f5df37d134b5e6d723c66d03", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -1,3 +1,65 @@\n+2014-11-13  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/60324\n+\t* configure: Regenerated.\n+\t* configure.ac (AM_CFLAGS): Add Werror=vla.\n+\t* libgfortran.h (gfc_alloca): Remove macro.\n+\t(fc_strdup_notrim): New prototype.\n+\t* intrinsics/access.c (access_func): Use fc_strdup rather than\n+\tstack allocation.\n+\t* intrinsics/chdir.c (chdir_i4_sub): Likewise.\n+\t(chdir_i8_sub): Likewise.\n+\t* intrinsics/chmod.c (chmod_internal): New function, move logic\n+\there.\n+\t(chmod_func): Call chmod_internal.\n+\t* intrinsics/env.c (getenv): Use fc_strdup rather than stack\n+\tallocation.\n+\t(get_environment_variable_i4): Likewise.\n+\t* intrinsics/execute_command_line.c (execute_command_line):\n+\tLikewise.\n+\t* intrinsics/hostnm.c (hostnm_0): New function, use static buffer\n+\trather than VLA.\n+\t(hostnm_i4_sub): Call hostnm_0.\n+\t(hostnm_i8_sub): Likewise.\n+\t(hostnm): Likewise.\n+\t* intrinsics/link.c (link_internal): New function, use fc_strdup\n+\trather than stack allocation.\n+\t(link_i4_sub): Call link_internal.\n+\t(link_i8_sub): Likewise.\n+\t(link_i4): Likewise.\n+\t(link_i8): Likewise.\n+\t* intrinsics/perror.c (perror_sub): Use fc_strdup rather than\n+\tstack allocation.\n+\t* intrinsics/random.c (random_seed_i4): Use static buffer rather\n+\tthan VLA, use _Static_assert to make sure it's big enough.\n+\t* intrinsics/rename.c (rename_internal): New function, use\n+\tfc_strdup rather than stack allocation.\n+\t(rename_i4_sub): Call rename_internal.\n+\t(rename_i8_sub): Likewise.\n+\t(rename_i4): Likewise.\n+\t(rename_i8): Likewise.\n+\t* intrinsics/stat.c (stat_i4_sub_0): Use fc_strdup rather than\n+\tstack allocation.\n+\t(stat_i8_sub_0): Likewise.\n+\t* intrinsics/symlink.c (symlnk_internal): New function, use\n+\tfc_strdup rather than stack allocation.\n+\t(symlnk_i4_sub): Call symlnk_internal.\n+\t(symlnk_i8_sub): Likewise.\n+\t(symlnk_i4): Likewise.\n+\t(symlnk_i8): Likewise.\n+\t* intrinsics/system.c (system_sub): Use fc_strdup rather than\n+\tstack allocation.\n+\t* intrinsics/unlink.c (unlink_i4_sub): Likewise.\n+\t* io/file_pos.c (READ_CHUNK): Make it a macro rather than variable.\n+\t* io/list_read.c (nml_get_obj_data): Use fixed stack buffer, fall\n+\tback to xmalloc/free for large sizes.\n+\t* io/read.c (read_f): Likewise.\n+\t* io/transfer.c (MAX_READ): Make it a macro rather than variable.\n+\t(WRITE_CHUNK): Likewise.\n+\t* io/write_float.def (write_float): Use fixed stack buffer, fall\n+\tback to xmalloc/free for large sizes.\n+\t* runtime/string.c (fc_strdup_notrim): New function.\n+\n 2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR target/63610"}, {"sha": "17d7570e26c899d22442f2d6faffc82e1c2cdce8", "filename": "libgfortran/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -5783,7 +5783,7 @@ if test \"x$GCC\" = \"xyes\"; then\n   ## We like to use C11 and C99 routines when available.  This makes\n   ## sure that\n   ## __STDC_VERSION__ is set such that libc includes make them available.\n-  AM_CFLAGS=\"-std=gnu11 -Wall -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -Wextra -Wwrite-strings -Werror=implicit-function-declaration\"\n+  AM_CFLAGS=\"-std=gnu11 -Wall -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -Wextra -Wwrite-strings -Werror=implicit-function-declaration -Werror=vla\"\n   ## Compile the following tests with the same system header contents\n   ## that we'll encounter when compiling our own source files.\n   CFLAGS=\"-std=gnu11 $CFLAGS\""}, {"sha": "ada74e3318ab5c0285ba79f6bdbb01408a2a30eb", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -142,7 +142,7 @@ if test \"x$GCC\" = \"xyes\"; then\n   ## We like to use C11 and C99 routines when available.  This makes\n   ## sure that\n   ## __STDC_VERSION__ is set such that libc includes make them available.\n-  AM_CFLAGS=\"-std=gnu11 -Wall -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -Wextra -Wwrite-strings -Werror=implicit-function-declaration\"\n+  AM_CFLAGS=\"-std=gnu11 -Wall -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -Wextra -Wwrite-strings -Werror=implicit-function-declaration -Werror=vla\"\n   ## Compile the following tests with the same system header contents\n   ## that we'll encounter when compiling our own source files.\n   CFLAGS=\"-std=gnu11 $CFLAGS\""}, {"sha": "65a0a103e2513cf3e84d0e95ff04b47334740c3b", "filename": "libgfortran/intrinsics/access.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Faccess.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Faccess.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Faccess.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 2006-2014 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -43,7 +43,6 @@ int\n access_func (char *name, char *mode, gfc_charlen_type name_len,\n \t     gfc_charlen_type mode_len)\n {\n-  char * file;\n   gfc_charlen_type i;\n   int m;\n \n@@ -75,16 +74,12 @@ access_func (char *name, char *mode, gfc_charlen_type name_len,\n \t  break;\n       }\n \n-  /* Trim trailing spaces from NAME argument.  */\n-  while (name_len > 0 && name[name_len - 1] == ' ')\n-    name_len--;\n-\n-  /* Make a null terminated copy of the string.  */\n-  file = gfc_alloca (name_len + 1);\n-  memcpy (file, name, name_len);\n-  file[name_len] = '\\0';\n+  char *path = fc_strdup (name, name_len);\n \n   /* And make the call to access().  */\n-  return (access (file, m) == 0 ? 0 : errno);\n+  int res = (access (path, m) == 0 ? 0 : errno);\n+\n+  free (path);\n+  return res;\n }\n #endif"}, {"sha": "87419a82e3c88599f43246549e9ff79a20f78c45", "filename": "libgfortran/intrinsics/chdir.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fchdir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fchdir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchdir.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -44,18 +44,10 @@ void\n chdir_i4_sub (char *dir, GFC_INTEGER_4 *status, gfc_charlen_type dir_len)\n {\n   int val;\n-  char *str;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (dir_len > 0 && dir[dir_len - 1] == ' ')\n-    dir_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str = gfc_alloca (dir_len + 1);\n-  memcpy (str, dir, dir_len);\n-  str[dir_len] = '\\0';\n+  char *str = fc_strdup (dir, dir_len);\n \n   val = chdir (str);\n+  free (str);\n \n   if (status != NULL)\n     *status = (val == 0) ? 0 : errno;\n@@ -69,18 +61,10 @@ void\n chdir_i8_sub (char *dir, GFC_INTEGER_8 *status, gfc_charlen_type dir_len)\n {\n   int val;\n-  char *str;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (dir_len > 0 && dir[dir_len - 1] == ' ')\n-    dir_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str = gfc_alloca (dir_len + 1);\n-  memcpy (str, dir, dir_len);\n-  str[dir_len] = '\\0';\n+  char *str = fc_strdup (dir, dir_len);\n \n   val = chdir (str);\n+  free (str);\n \n   if (status != NULL)\n     *status = (val == 0) ? 0 : errno;"}, {"sha": "c42fa8c28fa388180ef1aa21fd0f27bf27d03085", "filename": "libgfortran/intrinsics/chmod.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fchmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fchmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchmod.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -61,14 +61,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    A return value of 0 indicates success, -1 an error of chmod() while 1\n    indicates a mode parsing error.  */\n \n-extern int chmod_func (char *, char *, gfc_charlen_type, gfc_charlen_type);\n-export_proto(chmod_func);\n \n-int\n-chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n-\t    gfc_charlen_type mode_len)\n+static int\n+chmod_internal (char *file, char *mode, gfc_charlen_type mode_len)\n {\n-  char * file;\n   int i;\n   bool ugo[3];\n   bool rwxXstugo[9];\n@@ -80,15 +76,6 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n   mode_t mode_mask, file_mode, new_mode;\n   struct stat stat_buf;\n \n-  /* Trim trailing spaces of the file name.  */\n-  while (name_len > 0 && name[name_len - 1] == ' ')\n-    name_len--;\n-\n-  /* Make a null terminated copy of the file name.  */\n-  file = gfc_alloca (name_len + 1);\n-  memcpy (file, name, name_len);\n-  file[name_len] = '\\0';\n-\n   if (mode_len == 0)\n     return 1;\n \n@@ -496,6 +483,20 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n }\n \n \n+extern int chmod_func (char *, char *, gfc_charlen_type, gfc_charlen_type);\n+export_proto(chmod_func);\n+\n+int\n+chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n+\t    gfc_charlen_type mode_len)\n+{\n+  char *cname = fc_strdup (name, name_len);\n+  int ret = chmod_internal (cname, mode, mode_len);\n+  free (cname);\n+  return ret;\n+}\n+\n+\n extern void chmod_i4_sub (char *, char *, GFC_INTEGER_4 *,\n \t\t\t  gfc_charlen_type, gfc_charlen_type);\n export_proto(chmod_i4_sub);"}, {"sha": "ffdc54ac42f7afefd6e94639ebe30043eb7664ea", "filename": "libgfortran/intrinsics/env.c", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fenv.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -52,27 +52,19 @@ PREFIX(getenv) (char * name, char * value, gfc_charlen_type name_len,\n   else\n     memset (value, ' ', value_len); /* Blank the string.  */\n \n-  /* Trim trailing spaces from name.  */\n-  while (name_len > 0 && name[name_len - 1] == ' ')\n-    name_len--;\n-\n   /* Make a null terminated copy of the string.  */\n-  name_nt = gfc_alloca (name_len + 1);\n-  memcpy (name_nt, name, name_len);\n-  name_nt[name_len] = '\\0'; \n+  name_nt = fc_strdup (name, name_len);\n \n   res = getenv(name_nt);\n \n+  free (name_nt);\n+\n   /* If res is NULL, it means that the environment variable didn't \n      exist, so just return.  */\n   if (res == NULL)\n     return;\n \n-  res_len = strlen(res);\n-  if (value_len < res_len)\n-    memcpy (value, res, value_len);\n-  else\n-    memcpy (value, res, res_len);\n+  cf_strcpy (value, value_len, res);\n }\n \n \n@@ -127,18 +119,14 @@ get_environment_variable_i4 (char *name, char *value, GFC_INTEGER_4 *length,\n     }\n \n   if ((!trim_name) || *trim_name)\n-    {\n-      /* Trim trailing spaces from name.  */\n-      while (name_len > 0 && name[name_len - 1] == ' ')\n-\tname_len--;\n-    }\n-  /* Make a null terminated copy of the name.  */\n-  name_nt = gfc_alloca (name_len + 1);\n-  memcpy (name_nt, name, name_len);\n-  name_nt[name_len] = '\\0'; \n+    name_nt = fc_strdup (name, name_len);\n+  else\n+    name_nt = fc_strdup_notrim (name, name_len);\n   \n   res = getenv(name_nt);\n \n+  free (name_nt);\n+\n   if (res == NULL)\n     stat = GFC_NAME_DOES_NOT_EXIST;\n   else"}, {"sha": "578b4e92658d7f63b81930caf864218f04b56ec0", "filename": "libgfortran/intrinsics/execute_command_line.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fexecute_command_line.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fexecute_command_line.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fexecute_command_line.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -61,9 +61,7 @@ execute_command_line (const char *command, bool wait, int *exitstat,\n \t\t      gfc_charlen_type cmdmsg_len)\n {\n   /* Transform the Fortran string to a C string.  */\n-  char cmd[command_len + 1];\n-  memcpy (cmd, command, command_len);\n-  cmd[command_len] = '\\0';\n+  char *cmd = fc_strdup (command, command_len);\n \n   /* Flush all I/O units before executing the command.  */\n   flush_all_units();\n@@ -110,6 +108,8 @@ execute_command_line (const char *command, bool wait, int *exitstat,\n \t}\n     }\n \n+  free (cmd);\n+\n   /* Now copy back to the Fortran string if needed.  */\n   if (cmdstat && *cmdstat > EXEC_NOERROR)\n     {"}, {"sha": "c94dd77532976304de7a8eb3ff379de329c66925", "filename": "libgfortran/intrinsics/hostnm.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fhostnm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fhostnm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fhostnm.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 2005-2014 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -32,6 +32,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <unistd.h> \n #endif\n \n+#include <limits.h>\n+\n+#ifndef HOST_NAME_MAX\n+#define HOST_NAME_MAX 255\n+#endif\n+\n \n /* Windows32 version */\n #if defined __MINGW32__ && !defined  HAVE_GETHOSTNAME\n@@ -79,19 +85,17 @@ w32_gethostname (char *name, size_t len)\n    INTEGER, INTENT(OUT), OPTIONAL :: STATUS  */\n \n #ifdef HAVE_GETHOSTNAME\n-extern void hostnm_i4_sub (char *, GFC_INTEGER_4 *, gfc_charlen_type);\n-iexport_proto(hostnm_i4_sub);\n-\n-void\n-hostnm_i4_sub (char *name, GFC_INTEGER_4 *status, gfc_charlen_type name_len)\n+static int\n+hostnm_0 (char *name, gfc_charlen_type name_len)\n {\n   int val, i;\n-  char *p;\n+  char p[HOST_NAME_MAX + 1];\n \n   memset (name, ' ', name_len);\n-  p = gfc_alloca (name_len + 1);\n \n-  val = gethostname (p, name_len);\n+  size_t reqlen = sizeof (p) > (size_t) name_len + 1\n+    ? (size_t) name_len + 1: sizeof (p);\n+  val = gethostname (p, reqlen);\n \n   if (val == 0)\n   {\n@@ -100,8 +104,18 @@ hostnm_i4_sub (char *name, GFC_INTEGER_4 *status, gfc_charlen_type name_len)\n       name[i] = p[i];\n   }\n \n+  return ((val == 0) ? 0 : errno);\n+}\n+\n+extern void hostnm_i4_sub (char *, GFC_INTEGER_4 *, gfc_charlen_type);\n+iexport_proto(hostnm_i4_sub);\n+\n+void\n+hostnm_i4_sub (char *name, GFC_INTEGER_4 *status, gfc_charlen_type name_len)\n+{\n+  int val = hostnm_0 (name, name_len);\n   if (status != NULL) \n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(hostnm_i4_sub);\n \n@@ -111,23 +125,9 @@ iexport_proto(hostnm_i8_sub);\n void\n hostnm_i8_sub (char *name, GFC_INTEGER_8 *status, gfc_charlen_type name_len)\n {\n-  int val, i;\n-  char *p;\n-\n-  memset (name, ' ', name_len);\n-  p = gfc_alloca (name_len + 1);\n-\n-  val = gethostname (p, name_len);\n-\n-  if (val == 0)\n-  {\n-    i = -1;\n-    while (i < name_len && p[++i] != '\\0')\n-      name[i] = p[i];\n-  }\n-\n+  int val = hostnm_0 (name, name_len);\n   if (status != NULL) \n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(hostnm_i8_sub);\n \n@@ -137,8 +137,6 @@ export_proto(hostnm);\n GFC_INTEGER_4\n hostnm (char *name, gfc_charlen_type name_len)\n {\n-  GFC_INTEGER_4 val;\n-  hostnm_i4_sub (name, &val, name_len);\n-  return val;\n+  return hostnm_0 (name, name_len);\n }\n #endif"}, {"sha": "c6084a1cc66804ac4537b9a17bd61f0ebf9fc4ce", "filename": "libgfortran/intrinsics/link.c", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Flink.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 2005-2014 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -37,36 +37,39 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    INTEGER, INTENT(OUT), OPTIONAL :: STATUS  */\n \n #ifdef HAVE_LINK\n-extern void link_i4_sub (char *, char *, GFC_INTEGER_4 *, gfc_charlen_type,\n-\t                 gfc_charlen_type);\n-iexport_proto(link_i4_sub);\n \n-void\n-link_i4_sub (char *path1, char *path2, GFC_INTEGER_4 *status,\n-             gfc_charlen_type path1_len, gfc_charlen_type path2_len)\n+static int\n+link_internal (char *path1, char *path2, gfc_charlen_type path1_len,\n+\t       gfc_charlen_type path2_len)\n {\n   int val;\n   char *str1, *str2;\n \n-  /* Trim trailing spaces from paths.  */\n-  while (path1_len > 0 && path1[path1_len - 1] == ' ')\n-    path1_len--;\n-  while (path2_len > 0 && path2[path2_len - 1] == ' ')\n-    path2_len--;\n-\n   /* Make a null terminated copy of the strings.  */\n-  str1 = gfc_alloca (path1_len + 1);\n-  memcpy (str1, path1, path1_len);\n-  str1[path1_len] = '\\0';\n-\n-  str2 = gfc_alloca (path2_len + 1);\n-  memcpy (str2, path2, path2_len);\n-  str2[path2_len] = '\\0';\n+  str1 = fc_strdup (path1, path1_len);\n+  str2 = fc_strdup (path2, path2_len);\n \n   val = link (str1, str2);\n \n+  free (str1);\n+  free (str2);\n+\n+  return ((val == 0) ? 0 : errno);\n+}\n+\n+\n+extern void link_i4_sub (char *, char *, GFC_INTEGER_4 *, gfc_charlen_type,\n+\t                 gfc_charlen_type);\n+iexport_proto(link_i4_sub);\n+\n+void\n+link_i4_sub (char *path1, char *path2, GFC_INTEGER_4 *status,\n+             gfc_charlen_type path1_len, gfc_charlen_type path2_len)\n+{\n+  int val = link_internal (path1, path2, path1_len, path2_len);\n+\n   if (status != NULL)\n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(link_i4_sub);\n \n@@ -78,28 +81,10 @@ void\n link_i8_sub (char *path1, char *path2, GFC_INTEGER_8 *status,\n              gfc_charlen_type path1_len, gfc_charlen_type path2_len)\n {\n-  int val;\n-  char *str1, *str2;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (path1_len > 0 && path1[path1_len - 1] == ' ')\n-    path1_len--;\n-  while (path2_len > 0 && path2[path2_len - 1] == ' ')\n-    path2_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str1 = gfc_alloca (path1_len + 1);\n-  memcpy (str1, path1, path1_len);\n-  str1[path1_len] = '\\0';\n-\n-  str2 = gfc_alloca (path2_len + 1);\n-  memcpy (str2, path2, path2_len);\n-  str2[path2_len] = '\\0';\n-\n-  val = link (str1, str2);\n+  int val = link_internal (path1, path2, path1_len, path2_len);\n \n   if (status != NULL)\n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(link_i8_sub);\n \n@@ -111,9 +96,7 @@ GFC_INTEGER_4\n link_i4 (char *path1, char *path2, gfc_charlen_type path1_len,\n          gfc_charlen_type path2_len)\n {\n-  GFC_INTEGER_4 val;\n-  link_i4_sub (path1, path2, &val, path1_len, path2_len);\n-  return val;\n+  return link_internal (path1, path2, path1_len, path2_len);\n }\n \n extern GFC_INTEGER_8 link_i8 (char *, char *, gfc_charlen_type,\n@@ -124,8 +107,6 @@ GFC_INTEGER_8\n link_i8 (char *path1, char *path2, gfc_charlen_type path1_len,\n \t gfc_charlen_type path2_len)\n {\n-  GFC_INTEGER_8 val;\n-  link_i8_sub (path1, path2, &val, path1_len, path2_len);\n-  return val;\n+  return link_internal (path1, path2, path1_len, path2_len);\n }\n #endif"}, {"sha": "a8f09728706eff8e4ee5475318c2b875cdfebd95", "filename": "libgfortran/intrinsics/perror.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fperror.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -37,17 +37,8 @@ iexport_proto(perror_sub);\n void\n perror_sub (char *string, gfc_charlen_type string_len)\n {\n-  char * str;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (string_len > 0 && string[string_len - 1] == ' ')\n-    string_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str = gfc_alloca (string_len + 1);\n-  memcpy (str, string, string_len);\n-  str[string_len] = '\\0';\n-\n+  char *str = fc_strdup (string, string_len);\n   perror (str);\n+  free (str);\n }\n iexport(perror_sub);"}, {"sha": "5e919292aabc4ccee44f0559909b9ff5e56e36fb", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -666,7 +666,11 @@ void\n random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n   int i;\n-  unsigned char seed[4*kiss_size];\n+\n+#define KISS_MAX_SIZE 12\n+  unsigned char seed[4 * KISS_MAX_SIZE];\n+  _Static_assert (kiss_size <= KISS_MAX_SIZE,\n+\t\t  \"kiss_size must <= KISS_MAX_SIZE\");\n \n   __gthread_mutex_lock (&random_lock);\n "}, {"sha": "aabf8211c70b88dc42a7305d23aa5b8809d32fca", "filename": "libgfortran/intrinsics/rename.c", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Frename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Frename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frename.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 2005-2014 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -28,6 +28,20 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <errno.h>\n #include <string.h>\n \n+\n+static int\n+rename_internal (char *path1, char *path2, gfc_charlen_type path1_len,\n+\t\t gfc_charlen_type path2_len)\n+{\n+  char *str1 = fc_strdup (path1, path1_len);\n+  char *str2 = fc_strdup (path2, path2_len);\n+  int val = rename (str1, str2);\n+  free (str1);\n+  free (str2);\n+  return ((val == 0) ? 0 : errno);\n+}\n+\n+\n /* SUBROUTINE RENAME(PATH1, PATH2, STATUS)\n    CHARACTER(len=*), INTENT(IN) :: PATH1, PATH2\n    INTEGER, INTENT(OUT), OPTIONAL :: STATUS  */\n@@ -40,28 +54,9 @@ void\n rename_i4_sub (char *path1, char *path2, GFC_INTEGER_4 *status,\n \t       gfc_charlen_type path1_len, gfc_charlen_type path2_len)\n {\n-  int val;\n-  char *str1, *str2;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (path1_len > 0 && path1[path1_len - 1] == ' ')\n-    path1_len--;\n-  while (path2_len > 0 && path2[path2_len - 1] == ' ')\n-    path2_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str1 = gfc_alloca (path1_len + 1);\n-  memcpy (str1, path1, path1_len);\n-  str1[path1_len] = '\\0'; \n-\n-  str2 = gfc_alloca (path2_len + 1);\n-  memcpy (str2, path2, path2_len);\n-  str2[path2_len] = '\\0'; \n-\n-  val = rename (str1, str2);\n-\n+  int val = rename_internal (path1, path2, path1_len, path2_len);\n   if (status != NULL) \n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(rename_i4_sub);\n \n@@ -73,28 +68,9 @@ void\n rename_i8_sub (char *path1, char *path2, GFC_INTEGER_8 *status,\n \t       gfc_charlen_type path1_len, gfc_charlen_type path2_len)\n {\n-  int val;\n-  char *str1, *str2;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (path1_len > 0 && path1[path1_len - 1] == ' ')\n-    path1_len--;\n-  while (path2_len > 0 && path2[path2_len - 1] == ' ')\n-    path2_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str1 = gfc_alloca (path1_len + 1);\n-  memcpy (str1, path1, path1_len);\n-  str1[path1_len] = '\\0'; \n-\n-  str2 = gfc_alloca (path2_len + 1);\n-  memcpy (str2, path2, path2_len);\n-  str2[path2_len] = '\\0'; \n-\n-  val = rename (str1, str2);\n-\n+  int val = rename_internal (path1, path2, path1_len, path2_len);\n   if (status != NULL) \n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(rename_i8_sub);\n \n@@ -106,9 +82,7 @@ GFC_INTEGER_4\n rename_i4 (char *path1, char *path2, gfc_charlen_type path1_len,\n \t   gfc_charlen_type path2_len)\n {\n-  GFC_INTEGER_4 val;\n-  rename_i4_sub (path1, path2, &val, path1_len, path2_len);\n-  return val;\n+  return rename_internal (path1, path2, path1_len, path2_len);\n }\n \n extern GFC_INTEGER_8 rename_i8 (char *, char *, gfc_charlen_type,\n@@ -119,7 +93,5 @@ GFC_INTEGER_8\n rename_i8 (char *path1, char *path2, gfc_charlen_type path1_len,\n \t   gfc_charlen_type path2_len)\n {\n-  GFC_INTEGER_8 val;\n-  rename_i8_sub (path1, path2, &val, path1_len, path2_len);\n-  return val;\n+  return rename_internal (path1, path2, path1_len, path2_len);\n }"}, {"sha": "a60664210ec5ea36ebabca9572a4068006b79ed9", "filename": "libgfortran/intrinsics/stat.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstat.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -67,14 +67,8 @@ stat_i4_sub_0 (char *name, gfc_array_i4 *sarray, GFC_INTEGER_4 *status,\n   if (GFC_DESCRIPTOR_EXTENT(sarray,0) < 13)\n     runtime_error (\"Array size of SARRAY is too small.\");\n \n-  /* Trim trailing spaces from name.  */\n-  while (name_len > 0 && name[name_len - 1] == ' ')\n-    name_len--;\n-\n   /* Make a null terminated copy of the string.  */\n-  str = gfc_alloca (name_len + 1);\n-  memcpy (str, name, name_len);\n-  str[name_len] = '\\0';\n+  str = fc_strdup (name, name_len);\n \n   /* On platforms that don't provide lstat(), we use stat() instead.  */\n #ifdef HAVE_LSTAT\n@@ -84,6 +78,8 @@ stat_i4_sub_0 (char *name, gfc_array_i4 *sarray, GFC_INTEGER_4 *status,\n #endif\n     val = stat(str, &sb);\n \n+  free (str);\n+\n   if (val == 0)\n     {\n       index_type stride = GFC_DESCRIPTOR_STRIDE(sarray,0);\n@@ -188,14 +184,8 @@ stat_i8_sub_0 (char *name, gfc_array_i8 *sarray, GFC_INTEGER_8 *status,\n   if (GFC_DESCRIPTOR_EXTENT(sarray,0) < 13)\n     runtime_error (\"Array size of SARRAY is too small.\");\n \n-  /* Trim trailing spaces from name.  */\n-  while (name_len > 0 && name[name_len - 1] == ' ')\n-    name_len--;\n-\n   /* Make a null terminated copy of the string.  */\n-  str = gfc_alloca (name_len + 1);\n-  memcpy (str, name, name_len);\n-  str[name_len] = '\\0';\n+  str = fc_strdup (name, name_len);\n \n   /* On platforms that don't provide lstat(), we use stat() instead.  */\n #ifdef HAVE_LSTAT\n@@ -205,6 +195,8 @@ stat_i8_sub_0 (char *name, gfc_array_i8 *sarray, GFC_INTEGER_8 *status,\n #endif\n     val = stat(str, &sb);\n \n+  free (str);\n+\n   if (val == 0)\n     {\n       index_type stride = GFC_DESCRIPTOR_STRIDE(sarray,0);"}, {"sha": "5c53cb75378b98bd9c24b8e3fbfa37653881e064", "filename": "libgfortran/intrinsics/symlnk.c", "status": "modified", "additions": 19, "deletions": 49, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fsymlnk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fsymlnk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsymlnk.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 2005-2014 Free Software Foundation, Inc.\n    Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -37,6 +37,18 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    INTEGER, INTENT(OUT), OPTIONAL :: STATUS  */\n \n #ifdef HAVE_SYMLINK\n+static int\n+symlnk_internal (char *path1, char *path2, gfc_charlen_type path1_len,\n+\t\t gfc_charlen_type path2_len)\n+{\n+  char *str1 = fc_strdup (path1, path1_len);\n+  char *str2 = fc_strdup (path2, path2_len);\n+  int val = symlink (str1, str2);\n+  free (str1);\n+  free (str2);\n+  return ((val == 0) ? 0 : errno);\n+}\n+\n extern void symlnk_i4_sub (char *, char *, GFC_INTEGER_4 *, gfc_charlen_type,\n \t                 gfc_charlen_type);\n iexport_proto(symlnk_i4_sub);\n@@ -45,28 +57,9 @@ void\n symlnk_i4_sub (char *path1, char *path2, GFC_INTEGER_4 *status,\n              gfc_charlen_type path1_len, gfc_charlen_type path2_len)\n {\n-  int val;\n-  char *str1, *str2;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (path1_len > 0 && path1[path1_len - 1] == ' ')\n-    path1_len--;\n-  while (path2_len > 0 && path2[path2_len - 1] == ' ')\n-    path2_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str1 = gfc_alloca (path1_len + 1);\n-  memcpy (str1, path1, path1_len);\n-  str1[path1_len] = '\\0';\n-\n-  str2 = gfc_alloca (path2_len + 1);\n-  memcpy (str2, path2, path2_len);\n-  str2[path2_len] = '\\0';\n-\n-  val = symlink (str1, str2);\n-\n+  int val = symlnk_internal (path1, path2, path1_len, path2_len);\n   if (status != NULL)\n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(symlnk_i4_sub);\n \n@@ -78,28 +71,9 @@ void\n symlnk_i8_sub (char *path1, char *path2, GFC_INTEGER_8 *status,\n              gfc_charlen_type path1_len, gfc_charlen_type path2_len)\n {\n-  int val;\n-  char *str1, *str2;\n-\n-  /* Trim trailing spaces from paths.  */\n-  while (path1_len > 0 && path1[path1_len - 1] == ' ')\n-    path1_len--;\n-  while (path2_len > 0 && path2[path2_len - 1] == ' ')\n-    path2_len--;\n-\n-  /* Make a null terminated copy of the strings.  */\n-  str1 = gfc_alloca (path1_len + 1);\n-  memcpy (str1, path1, path1_len);\n-  str1[path1_len] = '\\0';\n-\n-  str2 = gfc_alloca (path2_len + 1);\n-  memcpy (str2, path2, path2_len);\n-  str2[path2_len] = '\\0';\n-\n-  val = symlink (str1, str2);\n-\n+  int val = symlnk_internal (path1, path2, path1_len, path2_len);\n   if (status != NULL)\n-    *status = (val == 0) ? 0 : errno;\n+    *status = val;\n }\n iexport(symlnk_i8_sub);\n \n@@ -111,9 +85,7 @@ GFC_INTEGER_4\n symlnk_i4 (char *path1, char *path2, gfc_charlen_type path1_len,\n          gfc_charlen_type path2_len)\n {\n-  GFC_INTEGER_4 val;\n-  symlnk_i4_sub (path1, path2, &val, path1_len, path2_len);\n-  return val;\n+  return symlnk_internal (path1, path2, path1_len, path2_len);\n }\n \n extern GFC_INTEGER_8 symlnk_i8 (char *, char *, gfc_charlen_type,\n@@ -124,8 +96,6 @@ GFC_INTEGER_8\n symlnk_i8 (char *path1, char *path2, gfc_charlen_type path1_len,\n \t gfc_charlen_type path2_len)\n {\n-  GFC_INTEGER_8 val;\n-  symlnk_i8_sub (path1, path2, &val, path1_len, path2_len);\n-  return val;\n+  return symlnk_internal (path1, path2, path1_len, path2_len);\n }\n #endif"}, {"sha": "add6f4ff2183ffbb31c9bbe7c9046af6ad1564a7", "filename": "libgfortran/intrinsics/system.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fsystem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Fsystem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsystem.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -34,16 +34,14 @@ iexport_proto(system_sub);\n void\n system_sub (const char *fcmd, GFC_INTEGER_4 *status, gfc_charlen_type cmd_len)\n {\n-  char cmd[cmd_len + 1];\n+  char *cmd = fc_strdup (fcmd, cmd_len);\n   int stat;\n \n   /* Flush all I/O units before executing the command.  */\n   flush_all_units();\n \n-  memcpy (cmd, fcmd, cmd_len);\n-  cmd[cmd_len] = '\\0';\n-\n   stat = system (cmd);\n+  free (cmd);\n   if (status)\n     *status = stat;\n }"}, {"sha": "2971a62e7e079be0f65bf11c5612b658c6013a76", "filename": "libgfortran/intrinsics/unlink.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Funlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fintrinsics%2Funlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Funlink.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 2004-2014 Free Software Foundation, Inc.\n    Contributed by Steven G. Kargl <kargls@comcast.net>.\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public\n@@ -46,17 +46,13 @@ unlink_i4_sub (char *name, GFC_INTEGER_4 *status, gfc_charlen_type name_len)\n   char *str;\n   GFC_INTEGER_4 stat;\n \n-  /* Trim trailing spaces from name.  */\n-  while (name_len > 0 && name[name_len - 1] == ' ')\n-    name_len--;\n-\n   /* Make a null terminated copy of the string.  */\n-  str = gfc_alloca (name_len + 1);\n-  memcpy (str, name, name_len);\n-  str[name_len] = '\\0';\n+  str = fc_strdup (name, name_len);\n \n   stat = unlink (str);\n \n+  free (str);\n+\n   if (status != NULL)\n     *status = (stat == 0) ? stat : errno;\n }"}, {"sha": "061f42ea9be4b4fba150b9207070688182e00645", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -36,7 +36,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    record, and we have to sift backwards to find the newline before\n    that or the start of the file, whichever comes first.  */\n \n-static const int READ_CHUNK = 4096;\n+#define READ_CHUNK 4096\n \n static void\n formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)"}, {"sha": "20b2b83a5e69bdea525de464a05445bb69f7e1f0", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -3132,16 +3132,27 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n   if (component_flag)\n     {\n+#define EXT_STACK_SZ 100\n+      char ext_stack[EXT_STACK_SZ];\n+      char *ext_name;\n       size_t var_len = strlen (root_nl->var_name);\n       size_t saved_len\n \t= dtp->u.p.saved_string ? strlen (dtp->u.p.saved_string) : 0;\n-      char ext_name[var_len + saved_len + 1];\n+      size_t ext_size = var_len + saved_len + 1;\n+\n+      if (ext_size > EXT_STACK_SZ)\n+\text_name = xmalloc (ext_size);\n+      else\n+\text_name = ext_stack;\n \n       memcpy (ext_name, root_nl->var_name, var_len);\n       if (dtp->u.p.saved_string)\n \tmemcpy (ext_name + var_len, dtp->u.p.saved_string, saved_len);\n       ext_name[var_len + saved_len] = '\\0';\n       nl = find_nml_node (dtp, ext_name);\n+\n+      if (ext_size > EXT_STACK_SZ)\n+\tfree (ext_name);\n     }\n   else\n     nl = find_nml_node (dtp, dtp->u.p.saved_string);"}, {"sha": "5c56dc26e42f3e9c10dfdcc701d1fe9f4a293ae2", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -881,6 +881,9 @@ read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n void\n read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n+#define READF_TMP 50\n+  char tmp[READF_TMP];\n+  size_t buf_size = 0;\n   int w, seen_dp, exponent;\n   int exponent_sign;\n   const char *p;\n@@ -895,6 +898,7 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   exponent_sign = 1;\n   exponent = 0;\n   w = f->u.w;\n+  buffer = tmp;\n \n   /* Read in the next block.  */\n   p = read_block_form (dtp, &w);\n@@ -911,7 +915,10 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n      exponent because of an implicit decimal point or the like.  Thus allocating\n      strlen (\"+0.0e-1000\") == 10 characters plus one for NUL more than the\n      original buffer had should be enough.  */\n-  buffer = gfc_alloca (w + 11);\n+  buf_size = w + 11;\n+  if (buf_size > READF_TMP)\n+    buffer = xmalloc (buf_size);\n+\n   out = buffer;\n \n   /* Optional sign */\n@@ -984,6 +991,8 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n \tgoto bad_float;\n \n       convert_infnan (dtp, dest, buffer, length);\n+      if (buf_size > READF_TMP)\n+\tfree (buffer);\n       return;\n     }\n \n@@ -1170,7 +1179,8 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n \n   /* Do the actual conversion.  */\n   convert_real (dtp, dest, buffer, length);\n-\n+  if (buf_size > READF_TMP)\n+    free (buffer);\n   return;\n \n   /* The value read is zero.  */\n@@ -1203,6 +1213,8 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   return;\n \n bad_float:\n+  if (buf_size > READF_TMP)\n+    free (buffer);\n   generate_error (&dtp->common, LIBERROR_READ_VALUE,\n \t\t  \"Bad value during floating point read\");\n   next_record (dtp, 1);"}, {"sha": "71c60b6f41225842e1e68dd1d6e42f939bdb5def", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -2982,7 +2982,7 @@ static void\n skip_record (st_parameter_dt *dtp, ssize_t bytes)\n {\n   ssize_t rlength, readb;\n-  static const ssize_t MAX_READ = 4096;\n+#define MAX_READ 4096\n   char p[MAX_READ];\n \n   dtp->u.p.current_unit->bytes_left_subrecord += bytes;\n@@ -3282,7 +3282,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n static ssize_t\n sset (stream * s, int c, ssize_t nbyte)\n {\n-  static const int WRITE_CHUNK = 256;\n+#define WRITE_CHUNK 256\n   char p[WRITE_CHUNK];\n   ssize_t bytes_left, trans;\n "}, {"sha": "1b345f8fc4b0e7a5c6d587636c08f4a6624db765", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -1277,7 +1277,13 @@ write_float (st_parameter_dt *dtp, const fnode *f, const char *source, \\\n      trailing null, and finally some extra digits depending on the\n      requested precision.  */\n   const size_t size = 4932 + 3 + precision;\n-  char buffer[size];\n+#define BUF_STACK_SZ 5000\n+  char buf_stack[BUF_STACK_SZ];\n+  char *buffer;\n+  if (size > BUF_STACK_SZ)\n+     buffer = xmalloc (size);\n+  else\n+     buffer = buf_stack;\n \n   switch (len)\n     {\n@@ -1306,4 +1312,6 @@ write_float (st_parameter_dt *dtp, const fnode *f, const char *source, \\\n     default:\n       internal_error (NULL, \"bad real kind\");\n     }\n+  if (size > BUF_STACK_SZ)\n+     free (buffer);\n }"}, {"sha": "bf7442c405a783289d487727f94231db2d006c42", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -573,10 +573,6 @@ iexport_data_proto(line);\n extern char *filename;\n iexport_data_proto(filename);\n \n-/* Avoid conflicting prototypes of alloca() in system headers by using \n-   GCC's builtin alloca().  */\n-#define gfc_alloca(x)  __builtin_alloca(x)\n-\n \n /* The default value of record length for preconnected units is defined\n    here. This value can be overriden by an environment variable.\n@@ -851,6 +847,9 @@ export_proto(string_len_trim_char4);\n extern char *fc_strdup(const char *, gfc_charlen_type);\n internal_proto(fc_strdup);\n \n+extern char *fc_strdup_notrim(const char *, gfc_charlen_type);\n+internal_proto(fc_strdup_notrim);\n+\n /* io/intrinsics.c */\n \n extern void flush_all_units (void);"}, {"sha": "79f75b444585d7badc3e2219a83b0a7a98c06def", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581d232670be67eb51d3839c43f1113507a89185/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=581d232670be67eb51d3839c43f1113507a89185", "patch": "@@ -134,6 +134,20 @@ fc_strdup (const char *src, gfc_charlen_type src_len)\n }\n \n \n+/* Duplicate a non-null-terminated Fortran string to a malloced\n+   null-terminated C string, without getting rid of trailing\n+   blanks.  */\n+\n+char *\n+fc_strdup_notrim (const char *src, gfc_charlen_type src_len)\n+{\n+  char *p = strndup (src, src_len);\n+  if (!p)\n+    os_error (\"Memory allocation failed in fc_strdup\");\n+  return p;\n+}\n+\n+\n /* Given a fortran string and an array of st_option structures, search through\n    the array to find a match.  If the option is not found, we generate an error\n    if no default is provided.  */"}]}