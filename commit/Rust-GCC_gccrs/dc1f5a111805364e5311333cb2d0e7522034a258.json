{"sha": "dc1f5a111805364e5311333cb2d0e7522034a258", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxZjVhMTExODA1MzY0ZTUzMTEzMzNjYjJkMGU3NTIyMDM0YTI1OA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-01-06T13:56:53Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-01-06T13:56:53Z"}, "message": "ifcvt.c (cond_move_convert_if_block): New function, code factored out from...\n\n\t* ifcvt.c (cond_move_convert_if_block): New function, code\n\tfactored out from...\n\t(cond_move_process_if_block): ...here.  Call the new function\n\ton the THEN and ELSE blocks.\n\t(merge_if_block): Do not copy global_live_at_end, merge_blocks\n\talready takes care of this.\n\nFrom-SVN: r120524", "tree": {"sha": "2fc0af3f16201a5d3813eb323564312466a358f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fc0af3f16201a5d3813eb323564312466a358f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc1f5a111805364e5311333cb2d0e7522034a258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1f5a111805364e5311333cb2d0e7522034a258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc1f5a111805364e5311333cb2d0e7522034a258", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1f5a111805364e5311333cb2d0e7522034a258/comments", "author": null, "committer": null, "parents": [{"sha": "472017b355ded38484c1e957312791fef1965cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472017b355ded38484c1e957312791fef1965cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472017b355ded38484c1e957312791fef1965cfa"}], "stats": {"total": 161, "additions": 83, "deletions": 78}, "files": [{"sha": "2623d7fecf95e1b24976966bc4ee6a402bb18633", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1f5a111805364e5311333cb2d0e7522034a258/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1f5a111805364e5311333cb2d0e7522034a258/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc1f5a111805364e5311333cb2d0e7522034a258", "patch": "@@ -1,3 +1,12 @@\n+2007-01-06  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* ifcvt.c (cond_move_convert_if_block): New function, code\n+\tfactored out from...\n+\t(cond_move_process_if_block): ...here.  Call the new function\n+\ton the THEN and ELSE blocks.\n+\t(merge_if_block): Do not copy global_live_at_end, merge_blocks\n+\talready takes care of this.\n+\n 2007-01-05  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c/19978"}, {"sha": "553d69d26c3b6cafbc9913b765d27aed1f66fe37", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 74, "deletions": 78, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc1f5a111805364e5311333cb2d0e7522034a258/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc1f5a111805364e5311333cb2d0e7522034a258/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=dc1f5a111805364e5311333cb2d0e7522034a258", "patch": "@@ -2466,6 +2466,70 @@ check_cond_move_block (basic_block bb, rtx *vals, rtx cond)\n   return TRUE;\n }\n \n+/* Given a basic block BB suitable for conditional move conversion,\n+   a condition COND, and arrays THEN_VALS and ELSE_VALS containing the\n+   register values depending on COND, emit the insns in the block as\n+   conditional moves.  If ELSE_BLOCK is true, THEN_BB was already\n+   processed.  The caller has started a sequence for the conversion.\n+   Return true if successful, false if something goes wrong.  */\n+\n+static bool\n+cond_move_convert_if_block (struct noce_if_info *if_infop,\n+\t\t\t    basic_block bb, rtx cond,\n+\t\t\t    rtx *then_vals, rtx *else_vals,\n+\t\t\t    bool else_block_p)\n+{\n+  enum rtx_code code;\n+  rtx insn, cond_arg0, cond_arg1;\n+\n+  code = GET_CODE (cond);\n+  cond_arg0 = XEXP (cond, 0);\n+  cond_arg1 = XEXP (cond, 1);\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      rtx set, target, dest, t, e;\n+      unsigned int regno;\n+\n+      if (!INSN_P (insn) || JUMP_P (insn))\n+\tcontinue;\n+      set = single_set (insn);\n+      gcc_assert (set && REG_P (SET_DEST (set)));\n+\n+      dest = SET_DEST (set);\n+      regno = REGNO (dest);\n+\n+      t = then_vals[regno];\n+      e = else_vals[regno];\n+\n+      if (else_block_p)\n+\t{\n+\t  /* If this register was set in the then block, we already\n+\t     handled this case there.  */\n+\t  if (t)\n+\t    continue;\n+\t  t = dest;\n+\t  gcc_assert (e);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (t);\n+\t  if (!e)\n+\t    e = dest;\n+\t}\n+\n+      target = noce_emit_cmove (if_infop, dest, code, cond_arg0, cond_arg1,\n+\t\t\t\tt, e);\n+      if (!target)\n+\treturn false;\n+\n+      if (target != dest)\n+\tnoce_emit_move_insn (dest, target);\n+    }\n+\n+  return true;\n+}\n+\n /* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it\n    using only conditional moves.  Return TRUE if we were successful at\n    converting the block.  */\n@@ -2476,11 +2540,10 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n   basic_block then_bb = ce_info->then_bb;\n   basic_block else_bb = ce_info->else_bb;\n   struct noce_if_info if_info;\n-  rtx jump, cond, insn, seq, cond_arg0, cond_arg1, loc_insn;\n+  rtx jump, cond, insn, seq, loc_insn;\n   int max_reg, size, c, i;\n   rtx *then_vals;\n   rtx *else_vals;\n-  enum rtx_code code;\n \n   if (!HAVE_conditional_move || no_new_pseudos)\n     return FALSE;\n@@ -2537,78 +2600,18 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n   if (c > MAX_CONDITIONAL_EXECUTE)\n     return FALSE;\n \n-  /* Emit the conditional moves.  First do the then block, then do\n-     anything left in the else blocks.  */\n-\n-  code = GET_CODE (cond);\n-  cond_arg0 = XEXP (cond, 0);\n-  cond_arg1 = XEXP (cond, 1);\n-\n+  /* Try to emit the conditional moves.  First do the then block,\n+     then do anything left in the else blocks.  */\n   start_sequence ();\n-\n-  FOR_BB_INSNS (then_bb, insn)\n+  if (!cond_move_convert_if_block (&if_info, then_bb, cond,\n+\t\t\t\t   then_vals, else_vals, false)\n+      || (else_bb\n+\t  && !cond_move_convert_if_block (&if_info, else_bb, cond,\n+\t\t\t\t\t  then_vals, else_vals, true)))\n     {\n-      rtx set, target, dest, t, e;\n-      unsigned int regno;\n-\n-      if (!INSN_P (insn) || JUMP_P (insn))\n-\tcontinue;\n-      set = single_set (insn);\n-      gcc_assert (set && REG_P (SET_DEST (set)));\n-\n-      dest = SET_DEST (set);\n-      regno = REGNO (dest);\n-      t = then_vals[regno];\n-      e = else_vals[regno];\n-      gcc_assert (t);\n-      if (!e)\n-\te = dest;\n-      target = noce_emit_cmove (&if_info, dest, code, cond_arg0, cond_arg1,\n-\t\t\t\tt, e);\n-      if (!target)\n-\t{\n-\t  end_sequence ();\n-\t  return FALSE;\n-\t}\n-\n-      if (target != dest)\n-\tnoce_emit_move_insn (dest, target);\n-    }\n-\n-  if (else_bb)\n-    {\n-      FOR_BB_INSNS (else_bb, insn)\n-\t{\n-\t  rtx set, target, dest;\n-\t  unsigned int regno;\n-\n-\t  if (!INSN_P (insn) || JUMP_P (insn))\n-\t    continue;\n-\t  set = single_set (insn);\n-\t  gcc_assert (set && REG_P (SET_DEST (set)));\n-\n-\t  dest = SET_DEST (set);\n-\t  regno = REGNO (dest);\n-\n-\t  /* If this register was set in the then block, we already\n-\t     handled this case above.  */\n-\t  if (then_vals[regno])\n-\t    continue;\n-\t  gcc_assert (else_vals[regno]);\n-\n-\t  target = noce_emit_cmove (&if_info, dest, code, cond_arg0, cond_arg1,\n-\t\t\t\t    dest, else_vals[regno]);\n-\t  if (!target)\n-\t    {\n-\t      end_sequence ();\n-\t      return FALSE;\n-\t    }\n-\n-\t  if (target != dest)\n-\t    noce_emit_move_insn (dest, target);\n-\t}\n+      end_sequence ();\n+      return FALSE;\n     }\n-\n   seq = end_ifcvt_sequence (&if_info);\n   if (!seq)\n     return FALSE;\n@@ -2711,9 +2714,6 @@ merge_if_block (struct ce_if_block * ce_info)\n \n   if (then_bb)\n     {\n-      if (combo_bb->il.rtl->global_live_at_end)\n-\tCOPY_REG_SET (combo_bb->il.rtl->global_live_at_end,\n-\t\t      then_bb->il.rtl->global_live_at_end);\n       merge_blocks (combo_bb, then_bb);\n       num_true_changes++;\n     }\n@@ -2764,10 +2764,6 @@ merge_if_block (struct ce_if_block * ce_info)\n \t   && join_bb != EXIT_BLOCK_PTR)\n     {\n       /* We can merge the JOIN.  */\n-      if (combo_bb->il.rtl->global_live_at_end)\n-\tCOPY_REG_SET (combo_bb->il.rtl->global_live_at_end,\n-\t\t      join_bb->il.rtl->global_live_at_end);\n-\n       merge_blocks (combo_bb, join_bb);\n       num_true_changes++;\n     }"}]}