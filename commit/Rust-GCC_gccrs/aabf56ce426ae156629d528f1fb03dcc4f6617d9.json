{"sha": "aabf56ce426ae156629d528f1fb03dcc4f6617d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiZjU2Y2U0MjZhZTE1NjYyOWQ1MjhmMWZiMDNkY2M0ZjY2MTdkOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-17T00:24:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-17T00:24:06Z"}, "message": "(qty_n_refs): Make int, like reg_n_refs.\n\n(qty_first_reg, reg_next_in_qty): Make int, not short.\n(local_alloc): Allocate these as arrays of ints.\n(block_alloc, qty_compare_1): qty_order is now array of ints.\n\nFrom-SVN: r4167", "tree": {"sha": "2303c1e17ec96ed1100da473eaabd3cd5d24a215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2303c1e17ec96ed1100da473eaabd3cd5d24a215"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aabf56ce426ae156629d528f1fb03dcc4f6617d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabf56ce426ae156629d528f1fb03dcc4f6617d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aabf56ce426ae156629d528f1fb03dcc4f6617d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabf56ce426ae156629d528f1fb03dcc4f6617d9/comments", "author": null, "committer": null, "parents": [{"sha": "1d2310f397dedf7da48cdc9d24e50dc43887582f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2310f397dedf7da48cdc9d24e50dc43887582f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2310f397dedf7da48cdc9d24e50dc43887582f"}], "stats": {"total": 20, "additions": 10, "deletions": 10}, "files": [{"sha": "a5508d9d95cec8e009c147bc3c714598afd97e65", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabf56ce426ae156629d528f1fb03dcc4f6617d9/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabf56ce426ae156629d528f1fb03dcc4f6617d9/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=aabf56ce426ae156629d528f1fb03dcc4f6617d9", "patch": "@@ -116,7 +116,7 @@ static char *qty_phys_has_sugg;\n \n /* Element Q is the number of refs to quantity Q.  */\n \n-static short *qty_n_refs;\n+static int *qty_n_refs;\n \n /* Element Q is a reg class contained in (smaller than) the\n    preferred classes of all the pseudo regs that are tied in quantity Q.\n@@ -170,13 +170,13 @@ static rtx *qty_scratch_rtx;\n    reg_qty value is Q, or -1 is this quantity is for a SCRATCH.  This\n    register should be the head of the chain maintained in reg_next_in_qty.  */\n \n-static short *qty_first_reg;\n+static int *qty_first_reg;\n \n /* If (REG N) has been assigned a quantity number, is a register number\n    of another register assigned the same quantity number, or -1 for the\n    end of the chain.  qty_first_reg point to the head of this chain.  */\n \n-static short *reg_next_in_qty;\n+static int *reg_next_in_qty;\n \n /* reg_qty[N] (where N is a pseudo reg number) is the qty number of that reg\n    if it is >= 0,\n@@ -403,17 +403,17 @@ local_alloc ()\n   qty_birth = (int *) alloca (max_qty * sizeof (int));\n   qty_death = (int *) alloca (max_qty * sizeof (int));\n   qty_scratch_rtx = (rtx *) alloca (max_qty * sizeof (rtx));\n-  qty_first_reg = (short *) alloca (max_qty * sizeof (short));\n+  qty_first_reg = (int *) alloca (max_qty * sizeof (int));\n   qty_size = (int *) alloca (max_qty * sizeof (int));\n   qty_mode = (enum machine_mode *) alloca (max_qty * sizeof (enum machine_mode));\n   qty_n_calls_crossed = (int *) alloca (max_qty * sizeof (int));\n   qty_min_class = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n   qty_alternate_class = (enum reg_class *) alloca (max_qty * sizeof (enum reg_class));\n-  qty_n_refs = (short *) alloca (max_qty * sizeof (short));\n+  qty_n_refs = (int *) alloca (max_qty * sizeof (int));\n \n   reg_qty = (int *) alloca (max_regno * sizeof (int));\n   reg_offset = (char *) alloca (max_regno * sizeof (char));\n-  reg_next_in_qty = (short *) alloca (max_regno * sizeof (short));\n+  reg_next_in_qty = (int *) alloca (max_regno * sizeof (int));\n \n   reg_renumber = (short *) oballoc (max_regno * sizeof (short));\n   for (i = 0; i < max_regno; i++)\n@@ -1084,7 +1084,7 @@ block_alloc (b)\n   int insn_number = 0;\n   int insn_count = 0;\n   int max_uid = get_max_uid ();\n-  short *qty_order;\n+  int *qty_order;\n   int no_conflict_combined_regno = -1;\n \n   /* Count the instructions in the basic block.  */\n@@ -1367,7 +1367,7 @@ block_alloc (b)\n      decreasing length of life.  Normally call qsort, but if we \n      have only a very small number of quantities, sort them ourselves.  */\n \n-  qty_order = (short *) alloca (next_qty * sizeof (short));\n+  qty_order = (int *) alloca (next_qty * sizeof (int));\n   for (i = 0; i < next_qty; i++)\n     qty_order[i] = i;\n \n@@ -1397,7 +1397,7 @@ block_alloc (b)\n       break;\n \n     default:\n-      qsort (qty_order, next_qty, sizeof (short), qty_compare_1);\n+      qsort (qty_order, next_qty, sizeof (int), qty_compare_1);\n     }\n \n   /* Try to put each quantity in a suggested physical register, if it has one.\n@@ -1497,7 +1497,7 @@ qty_compare (q1, q2)\n \n static int\n qty_compare_1 (q1, q2)\n-     short *q1, *q2;\n+     int *q1, *q2;\n {\n   register int tem;\n "}]}