{"sha": "c50a01163c10c9467986f78e5a82cb4975556043", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUwYTAxMTYzYzEwYzk0Njc5ODZmNzhlNWE4MmNiNDk3NTU1NjA0Mw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-06-17T17:05:48Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-06-17T17:05:48Z"}, "message": "Bug 14610\n\n\tBug 14610\n\t* Makefile.in (min-insn-modes.o): Correct dependencies.\n\t* real.c (encode_ieee_extended, decode_ieee_extended): Always\n\tproduce/consume 12-byte little-endian Intel format.\n\t(encode_ieee_extended_128, decode_ieee_extended_128): Delete.\n\t(encode_ieee_extended_motorola, decode_ieee_extended_motorola)\n\t(encode_ieee_extended_intel_96, decode_ieee_extended_intel_96)\n\t(encode_ieee_extended_intel_128, decode_ieee_extended_intel_128):\n\tNew functions which convert between 12-byte little-endian Intel\n\tformat and the desired format.\n\t(ieee_extended_motorola_format, ieee_extended_intel_96_round_53_format)\n\t(ieee_extended_intel_96_format, ieee_extended_intel_128_format):\n\tUpdate.\ntestsuite:\n\t* gcc.dg/ia64-float80-1.c, gcc.dg/ia64-float80-2.c: New testcases.\n\nFrom-SVN: r83295", "tree": {"sha": "8200a0e864099ac8904e28f01d914f5e96ff26b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8200a0e864099ac8904e28f01d914f5e96ff26b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c50a01163c10c9467986f78e5a82cb4975556043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50a01163c10c9467986f78e5a82cb4975556043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c50a01163c10c9467986f78e5a82cb4975556043", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50a01163c10c9467986f78e5a82cb4975556043/comments", "author": null, "committer": null, "parents": [{"sha": "42eb30b557a129514aa76470115ea8bb1e35f027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42eb30b557a129514aa76470115ea8bb1e35f027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42eb30b557a129514aa76470115ea8bb1e35f027"}], "stats": {"total": 205, "additions": 166, "deletions": 39}, "files": [{"sha": "6c7e48588f1e588bbdc1950ed82c4467fe4eb0e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c50a01163c10c9467986f78e5a82cb4975556043", "patch": "@@ -1,3 +1,19 @@\n+2004-06-17  Zack Weinberg  <zack@codesourcery.com>\n+\n+\tBug 14610\n+\t* Makefile.in (min-insn-modes.o): Correct dependencies.\n+\t* real.c (encode_ieee_extended, decode_ieee_extended): Always\n+\tproduce/consume 12-byte little-endian Intel format.\n+\t(encode_ieee_extended_128, decode_ieee_extended_128): Delete.\n+\t(encode_ieee_extended_motorola, decode_ieee_extended_motorola)\n+\t(encode_ieee_extended_intel_96, decode_ieee_extended_intel_96)\n+\t(encode_ieee_extended_intel_128, decode_ieee_extended_intel_128):\n+\tNew functions which convert between 12-byte little-endian Intel\n+\tformat and the desired format.\n+\t(ieee_extended_motorola_format, ieee_extended_intel_96_round_53_format)\n+\t(ieee_extended_intel_96_format, ieee_extended_intel_128_format):\n+\tUpdate.\n+\n 2004-06-17  Zack Weinberg  <zack@codesourcery.com>\n \n \t* expmed.c (expand_mult_const): In sanity check, compare only\n@@ -43,7 +59,7 @@\n \t* tree-inline.c: Correct comment about this file's purpose.\n \t* tree-optimize.c: Likewise.\n \t* tree-tailcall.c: Likewise.\n-\t\n+\n \t* tree-alias-ander.h: Add standard top-of-file comment.\n \t* tree-alias-common.h: Likewise.\n \t* tree-alias-type.h: Likewise."}, {"sha": "3db6176f03d159a59edca5594193adedd1028cb5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c50a01163c10c9467986f78e5a82cb4975556043", "patch": "@@ -2561,7 +2561,7 @@ $(BUILD_PREFIX_1)ggc-none.o: ggc-none.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYST\n \tsed -e 's/config[.]h/bconfig.h/' $(srcdir)/ggc-none.c > $(BUILD_PREFIX)ggc-none.c\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)ggc-none.c $(OUTPUT_OPTION)\n \n-min-insn-modes.o: insn-modes.c $(BCONFIG_H) $(SYSTEM_H) $(MACHMODE_H)\n+min-insn-modes.o: min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H) $(MACHMODE_H)\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) \\\n \t    min-insn-modes.c $(OUTPUT_OPTION)\n "}, {"sha": "896aa9dd3e19a65112c516a112af295995e041f4", "filename": "gcc/real.c", "status": "modified", "additions": 116, "deletions": 35, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=c50a01163c10c9467986f78e5a82cb4975556043", "patch": "@@ -2912,20 +2912,14 @@ const struct real_format mips_double_format =\n   };\n \n \f\n-/* IEEE extended double precision format.  This comes in three\n-   flavors: Intel's as a 12 byte image, Intel's as a 16 byte image,\n-   and Motorola's.  */\n-\n-static void encode_ieee_extended (const struct real_format *fmt,\n-\t\t\t\t  long *, const REAL_VALUE_TYPE *);\n-static void decode_ieee_extended (const struct real_format *,\n-\t\t\t\t  REAL_VALUE_TYPE *, const long *);\n-\n-static void encode_ieee_extended_128 (const struct real_format *fmt,\n-\t\t\t\t      long *, const REAL_VALUE_TYPE *);\n-static void decode_ieee_extended_128 (const struct real_format *,\n-\t\t\t\t      REAL_VALUE_TYPE *, const long *);\n-\n+/* IEEE extended real format.  This comes in three flavors: Intel's as\n+   a 12 byte image, Intel's as a 16 byte image, and Motorola's.  Intel\n+   12- and 16-byte images may be big- or little endian; Motorola's is\n+   always big endian.  */\n+\n+/* Helper subroutine which converts from the internal format to the\n+   12-byte little-endian Intel format.  Functions below adjust this\n+   for the other possible formats.  */\n static void\n encode_ieee_extended (const struct real_format *fmt, long *buf,\n \t\t      const REAL_VALUE_TYPE *r)\n@@ -3033,20 +3027,65 @@ encode_ieee_extended (const struct real_format *fmt, long *buf,\n       abort ();\n     }\n \n+  buf[0] = sig_lo, buf[1] = sig_hi, buf[2] = image_hi;\n+}\n+\n+/* Convert from the internal format to the 12-byte Motorola format\n+   for an IEEE extended real.  */\n+static void\n+encode_ieee_extended_motorola (const struct real_format *fmt, long *buf,\n+\t\t\t       const REAL_VALUE_TYPE *r)\n+{\n+  long intermed[3];\n+  encode_ieee_extended (fmt, intermed, r);\n+\n+  /* Motorola chips are assumed always to be big-endian.  Also, the\n+     padding in a Motorola extended real goes between the exponent and\n+     the mantissa.  At this point the mantissa is entirely within\n+     elements 0 and 1 of intermed, and the exponent entirely within\n+     element 2, so all we have to do is swap the order around, and\n+     shift element 2 left 16 bits.  */\n+  buf[0] = intermed[2] << 16;\n+  buf[1] = intermed[1];\n+  buf[2] = intermed[0];\n+}\n+\n+/* Convert from the internal format to the 12-byte Intel format for\n+   an IEEE extended real.  */\n+static void\n+encode_ieee_extended_intel_96 (const struct real_format *fmt, long *buf,\n+\t\t\t       const REAL_VALUE_TYPE *r)\n+{\n   if (FLOAT_WORDS_BIG_ENDIAN)\n-    buf[0] = image_hi << 16, buf[1] = sig_hi, buf[2] = sig_lo;\n+    {\n+      /* All the padding in an Intel-format extended real goes at the high\n+\t end, which in this case is after the mantissa, not the exponent.\n+\t Therefore we must shift everything down 16 bits.  */\n+      long intermed[3];\n+      encode_ieee_extended (fmt, intermed, r);\n+      buf[0] = ((intermed[2] << 16) | ((unsigned long)(intermed[1] & 0xFFFF0000) >> 16));\n+      buf[1] = ((intermed[1] << 16) | ((unsigned long)(intermed[0] & 0xFFFF0000) >> 16));\n+      buf[2] =  (intermed[0] << 16);\n+    }\n   else\n-    buf[0] = sig_lo, buf[1] = sig_hi, buf[2] = image_hi;\n+    /* encode_ieee_extended produces what we want directly.  */\n+    encode_ieee_extended (fmt, buf, r);\n }\n \n+/* Convert from the internal format to the 16-byte Intel format for\n+   an IEEE extended real.  */\n static void\n-encode_ieee_extended_128 (const struct real_format *fmt, long *buf,\n-\t\t\t  const REAL_VALUE_TYPE *r)\n+encode_ieee_extended_intel_128 (const struct real_format *fmt, long *buf,\n+\t\t\t\tconst REAL_VALUE_TYPE *r)\n {\n-  buf[3 * !FLOAT_WORDS_BIG_ENDIAN] = 0;\n-  encode_ieee_extended (fmt, buf+!!FLOAT_WORDS_BIG_ENDIAN, r);\n+  /* All the padding in an Intel-format extended real goes at the high end.  */\n+  encode_ieee_extended_intel_96 (fmt, buf, r);\n+  buf[3] = 0;\n }\n \n+/* As above, we have a helper function which converts from 12-byte\n+   little-endian Intel format to internal format.  Functions below\n+   adjust for the other possible formats.  */\n static void\n decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n \t\t      const long *buf)\n@@ -3055,10 +3094,7 @@ decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n   bool sign;\n   int exp;\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    image_hi = buf[0] >> 16, sig_hi = buf[1], sig_lo = buf[2];\n-  else\n-    sig_lo = buf[0], sig_hi = buf[1], image_hi = buf[2];\n+  sig_lo = buf[0], sig_hi = buf[1], image_hi = buf[2];\n   sig_lo &= 0xffffffff;\n   sig_hi &= 0xffffffff;\n   image_hi &= 0xffffffff;\n@@ -3135,17 +3171,62 @@ decode_ieee_extended (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n     }\n }\n \n+/* Convert from the internal format to the 12-byte Motorola format\n+   for an IEEE extended real.  */\n+static void\n+decode_ieee_extended_motorola (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t\t       const long *buf)\n+{\n+  long intermed[3];\n+\n+  /* Motorola chips are assumed always to be big-endian.  Also, the\n+     padding in a Motorola extended real goes between the exponent and\n+     the mantissa; remove it.  */\n+  intermed[0] = buf[2];\n+  intermed[1] = buf[1];\n+  intermed[2] = (unsigned long)buf[0] >> 16;\n+\n+  decode_ieee_extended (fmt, r, intermed);\n+}\n+\n+/* Convert from the internal format to the 12-byte Intel format for\n+   an IEEE extended real.  */\n+static void\n+decode_ieee_extended_intel_96 (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t\t       const long *buf)\n+{\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      /* All the padding in an Intel-format extended real goes at the high\n+\t end, which in this case is after the mantissa, not the exponent.\n+\t Therefore we must shift everything up 16 bits.  */\n+      long intermed[3];\n+\n+      intermed[0] = (((unsigned long)buf[2] >> 16) | (buf[1] << 16));\n+      intermed[1] = (((unsigned long)buf[1] >> 16) | (buf[0] << 16));\n+      intermed[2] =  ((unsigned long)buf[0] >> 16);\n+\n+      decode_ieee_extended (fmt, r, intermed);\n+    }\n+  else\n+    /* decode_ieee_extended produces what we want directly.  */\n+    decode_ieee_extended (fmt, r, buf);\n+}\n+\n+/* Convert from the internal format to the 16-byte Intel format for\n+   an IEEE extended real.  */\n static void\n-decode_ieee_extended_128 (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n-\t\t\t  const long *buf)\n+decode_ieee_extended_intel_128 (const struct real_format *fmt, REAL_VALUE_TYPE *r,\n+\t\t\t\tconst long *buf)\n {\n-  decode_ieee_extended (fmt, r, buf+!!FLOAT_WORDS_BIG_ENDIAN);\n+  /* All the padding in an Intel-format extended real goes at the high end.  */\n+  decode_ieee_extended_intel_96 (fmt, r, buf);\n }\n \n const struct real_format ieee_extended_motorola_format =\n   {\n-    encode_ieee_extended,\n-    decode_ieee_extended,\n+    encode_ieee_extended_motorola,\n+    decode_ieee_extended_motorola,\n     2,\n     1,\n     64,\n@@ -3162,8 +3243,8 @@ const struct real_format ieee_extended_motorola_format =\n \n const struct real_format ieee_extended_intel_96_format =\n   {\n-    encode_ieee_extended,\n-    decode_ieee_extended,\n+    encode_ieee_extended_intel_96,\n+    decode_ieee_extended_intel_96,\n     2,\n     1,\n     64,\n@@ -3180,8 +3261,8 @@ const struct real_format ieee_extended_intel_96_format =\n \n const struct real_format ieee_extended_intel_128_format =\n   {\n-    encode_ieee_extended_128,\n-    decode_ieee_extended_128,\n+    encode_ieee_extended_intel_128,\n+    decode_ieee_extended_intel_128,\n     2,\n     1,\n     64,\n@@ -3200,8 +3281,8 @@ const struct real_format ieee_extended_intel_128_format =\n    to 53 bits instead of 64, e.g. FreeBSD.  */\n const struct real_format ieee_extended_intel_96_round_53_format =\n   {\n-    encode_ieee_extended,\n-    decode_ieee_extended,\n+    encode_ieee_extended_intel_96,\n+    decode_ieee_extended_intel_96,\n     2,\n     1,\n     53,"}, {"sha": "9411b50a1963d3d84460bc8d29498ba06f31406a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c50a01163c10c9467986f78e5a82cb4975556043", "patch": "@@ -1,3 +1,8 @@\n+2004-06-17  Zack Weinberg  <zack@codesourcery.com>\n+\n+\tBug 14610\n+\t* gcc.dg/ia64-float80-1.c, gcc.dg/ia64-float80-2.c: New testcases.\n+\n 2004-06-15  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/20001116-1.c: Move expected warning line.\n@@ -91,7 +96,7 @@\n \n \tPR fortran/14957\n \t* gfortran.fortran-torture/execute/stack_varsize.f90: Correct\n-        syntax errors in end statements of contained subroutines.\n+\tsyntax errors in end statements of contained subroutines.\n \n 2004-06-12  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n@@ -192,7 +197,7 @@\n \n 2004-06-09  Bud Davis  <bdavis9659@comcast.net>\n \n-        PR gfortran/15755\n+\tPR gfortran/15755\n \t* gfortran.fortran-torture/execute/backspace.c : New test.\n \n 2004-06-09  Paul Brook  <paul@codesourcery.com>"}, {"sha": "dd39f3eb59ac55a120cf0f13e6b6d68790ec2102", "filename": "gcc/testsuite/gcc.dg/ia64-float80-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-float80-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-float80-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-float80-1.c?ref=c50a01163c10c9467986f78e5a82cb4975556043", "patch": "@@ -0,0 +1,12 @@\n+/* Bug 14610 */\n+/* { dg-do run { target ia64-*-* } } */\n+\n+extern void abort(void);\n+volatile __float80 x = 30.0;\n+\n+int main(void)\n+{\n+  double d = x;\n+  if (d != 30.0) abort ();\n+  return 0;\n+}"}, {"sha": "629312425c2a7e5a068e685f623f365c72e22a30", "filename": "gcc/testsuite/gcc.dg/ia64-float80-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-float80-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50a01163c10c9467986f78e5a82cb4975556043/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-float80-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-float80-2.c?ref=c50a01163c10c9467986f78e5a82cb4975556043", "patch": "@@ -0,0 +1,13 @@\n+/* Bug 14610 */\n+/* { dg-do run { target ia64-*-* } } */\n+/* { dg-options \"-minline-int-divide-max-throughput\" } */\n+\n+extern void abort(void);\n+volatile int j = 30;\n+\n+int main(void)\n+{\n+  if (29 % j != 29) abort();\n+  if (30 % j != 0)  abort();\n+  return 0;\n+}"}]}