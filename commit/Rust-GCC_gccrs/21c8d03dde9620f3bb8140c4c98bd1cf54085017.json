{"sha": "21c8d03dde9620f3bb8140c4c98bd1cf54085017", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFjOGQwM2RkZTk2MjBmM2JiODE0MGM0Yzk4YmQxY2Y1NDA4NTAxNw==", "commit": {"author": {"name": "Matthias Klose", "email": "doko@cs.tu-berlin.de", "date": "1999-08-24T05:37:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-24T05:37:39Z"}, "message": "cpp.texi: Add a node documenting macro varargs (copied from extend.texi).\n\n        * cpp.texi: Add a node documenting macro varargs (copied\n        from extend.texi).\n\nFrom-SVN: r28814", "tree": {"sha": "b51b26c68fbd2ca76f07f6dcc96178e07a487204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b51b26c68fbd2ca76f07f6dcc96178e07a487204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21c8d03dde9620f3bb8140c4c98bd1cf54085017", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c8d03dde9620f3bb8140c4c98bd1cf54085017", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c8d03dde9620f3bb8140c4c98bd1cf54085017", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c8d03dde9620f3bb8140c4c98bd1cf54085017/comments", "author": null, "committer": null, "parents": [{"sha": "3ed4f5ed4bdc1ae8516d343e6107fd45dbda2bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ed4f5ed4bdc1ae8516d343e6107fd45dbda2bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ed4f5ed4bdc1ae8516d343e6107fd45dbda2bea"}], "stats": {"total": 71, "additions": 69, "deletions": 2}, "files": [{"sha": "cd9581e2198bb385ac0c7dd033b1cacdef384fc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c8d03dde9620f3bb8140c4c98bd1cf54085017/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c8d03dde9620f3bb8140c4c98bd1cf54085017/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21c8d03dde9620f3bb8140c4c98bd1cf54085017", "patch": "@@ -1,3 +1,8 @@\n+Mon Aug 23 23:35:52 1999  Matthias Klose  <doko@cs.tu-berlin.de>\n+\n+\t* cpp.texi: Add a node documenting macro varargs (copied\n+ \tfrom extend.texi).\n+\n 1999-08-23 22:23 -0700  Zack Weinberg  <zack@bitmover.com>\n \n \t* cppspec.c: Put a null pointer at the end of the new argv."}, {"sha": "5860f1cd6800e3e0225788eaf4f1b386fb2d3b60", "filename": "gcc/cpp.texi", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c8d03dde9620f3bb8140c4c98bd1cf54085017/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c8d03dde9620f3bb8140c4c98bd1cf54085017/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=21c8d03dde9620f3bb8140c4c98bd1cf54085017", "patch": "@@ -545,6 +545,7 @@ in the C preprocessor.\n * Simple Macros::    Macros that always expand the same way.\n * Argument Macros::  Macros that accept arguments that are substituted\n                        into the macro expansion.\n+* Macro Varargs::    Macros with variable number of arguments.\n * Predefined::       Predefined macros that are always available.\n * Stringification::  Macro arguments converted into string constants.\n * Concatenation::    Building tokens from parts taken from macro arguments.\n@@ -648,7 +649,7 @@ it too is the name of a macro.  It's only when you @emph{use} @samp{TABLESIZE}\n that the result of its expansion is checked for more macro names.\n @xref{Cascaded Macros}.\n \n-@node Argument Macros, Predefined, Simple Macros, Macros\n+@node Argument Macros, Macro Varargs, Simple Macros, Macros\n @subsection Macros with Arguments\n @cindex macros with argument\n @cindex arguments in macro definitions\n@@ -802,7 +803,68 @@ Note that the @emph{uses} of a macro with arguments can have spaces before\n the left parenthesis; it's the @emph{definition} where it matters whether\n there is a space.\n \n-@node Predefined, Stringification, Argument Macros, Macros\n+@node Macro Varargs, Predefined, Argument Macros, Macros\n+@subsection Macros with Variable Numbers of Arguments\n+@cindex variable number of arguments\n+@cindex macro with variable arguments\n+@cindex rest argument (in macro)\n+\n+In GNU C, a macro can accept a variable number of arguments, much as a\n+function can.  The syntax for defining the macro looks much like that\n+used for a function.  Here is an example:\n+\n+@example\n+#define eprintf(format, args...)  \\\n+ fprintf (stderr, format , ## args)\n+@end example\n+\n+Here @code{args} is a @dfn{rest argument}: it takes in zero or more\n+arguments, as many as the call contains.  All of them plus the commas\n+between them form the value of @code{args}, which is substituted into\n+the macro body where @code{args} is used.  Thus, we have this expansion:\n+\n+@example\n+eprintf (\"%s:%d: \", input_file_name, line_number)\n+@expansion{}\n+fprintf (stderr, \"%s:%d: \" , input_file_name, line_number)\n+@end example\n+\n+@noindent\n+Note that the comma after the string constant comes from the definition\n+of @code{eprintf}, whereas the last comma comes from the value of\n+@code{args}.\n+\n+The reason for using @samp{##} is to handle the case when @code{args}\n+matches no arguments at all.  In this case, @code{args} has an empty\n+value.  In this case, the second comma in the definition becomes an\n+embarrassment: if it got through to the expansion of the macro, we would\n+get something like this:\n+\n+@example\n+fprintf (stderr, \"success!\\n\" , )\n+@end example\n+\n+@noindent\n+which is invalid C syntax.  @samp{##} gets rid of the comma, so we get\n+the following instead:\n+\n+@example\n+fprintf (stderr, \"success!\\n\")\n+@end example\n+\n+This is a special feature of the GNU C preprocessor: @samp{##} before a\n+rest argument that is empty discards the preceding sequence of\n+non-whitespace characters from the macro definition.  (If another macro\n+argument precedes, none of it is discarded.)\n+\n+It might be better to discard the last preprocessor token instead of the\n+last preceding sequence of non-whitespace characters; in fact, we may\n+someday change this feature to do so.  We advise you to write the macro\n+definition so that the preceding sequence of non-whitespace characters\n+is just a single token, so that the meaning will not change if we change\n+the definition of this feature.\n+\n+@node Predefined, Stringification, Macro Varargs, Macros\n @subsection Predefined Macros\n \n @cindex predefined macros"}]}