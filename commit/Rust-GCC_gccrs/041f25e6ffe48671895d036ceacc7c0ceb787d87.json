{"sha": "041f25e6ffe48671895d036ceacc7c0ceb787d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQxZjI1ZTZmZmU0ODY3MTg5NWQwMzZjZWFjYzdjMGNlYjc4N2Q4Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-19T07:15:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-19T07:15:08Z"}, "message": "ia64.c (reg_or_5bit_operand): New.\n\n        * config/ia64/ia64.c (reg_or_5bit_operand): New.\n        (ia64_depz_field_mask): New.\n        * config/ia64/ia64.h (CONSTRAINT_OK_FOR_R): New.\n        (PREDICATE_CODES): Update.\n        * config/ia64/ia64.md: Update commentary.\n        (depz_internal): New.\n        (ashlsi3): Implement directly.\n        (ashrsi3, lshrsi3): Simplify; rely on extv and extzv for constants.\n        (ashldi3): Use shladd.\n        * config/ia64/ia64-protos.h: Update.\n\nFrom-SVN: r35802", "tree": {"sha": "929dd094095f12157e5bb6c52fb2d769017764e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/929dd094095f12157e5bb6c52fb2d769017764e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/041f25e6ffe48671895d036ceacc7c0ceb787d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041f25e6ffe48671895d036ceacc7c0ceb787d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041f25e6ffe48671895d036ceacc7c0ceb787d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041f25e6ffe48671895d036ceacc7c0ceb787d87/comments", "author": null, "committer": null, "parents": [{"sha": "17ed19cb314cf4aca3fce46bd174474c3adba59b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ed19cb314cf4aca3fce46bd174474c3adba59b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17ed19cb314cf4aca3fce46bd174474c3adba59b"}], "stats": {"total": 209, "additions": 120, "deletions": 89}, "files": [{"sha": "d7ca945af2d3ad5eead08373311f1ece8dc9215e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=041f25e6ffe48671895d036ceacc7c0ceb787d87", "patch": "@@ -1,3 +1,16 @@\n+2000-08-19  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64.c (reg_or_5bit_operand): New.\n+\t(ia64_depz_field_mask): New.\n+\t* config/ia64/ia64.h (CONSTRAINT_OK_FOR_R): New.\n+\t(PREDICATE_CODES): Update.\n+\t* config/ia64/ia64.md: Update commentary.\n+\t(depz_internal): New.\n+\t(ashlsi3): Implement directly.\n+\t(ashrsi3, lshrsi3): Simplify; rely on extv and extzv for constants.\n+\t(ashldi3): Use shladd.\n+\t* config/ia64/ia64-protos.h: Update.\n+\n 2000-08-18  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* toplev.c (independent_decode_option): Always process -g."}, {"sha": "180418d94355758dc8858b3f0ec343355f6d2e97", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=041f25e6ffe48671895d036ceacc7c0ceb787d87", "patch": "@@ -35,6 +35,7 @@ extern int function_operand PARAMS((rtx, enum machine_mode));\n extern int setjmp_operand PARAMS((rtx, enum machine_mode));\n extern int move_operand PARAMS((rtx, enum machine_mode));\n extern int reg_or_0_operand PARAMS((rtx, enum machine_mode));\n+extern int reg_or_5bit_operand PARAMS((rtx, enum machine_mode));\n extern int reg_or_6bit_operand PARAMS((rtx, enum machine_mode));\n extern int reg_or_8bit_operand PARAMS((rtx, enum machine_mode));\n extern int reg_or_8bit_adjusted_operand PARAMS((rtx, enum machine_mode));\n@@ -50,12 +51,6 @@ extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n extern int destination_operand PARAMS((rtx, enum machine_mode));\n-extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));\n-extern void ia64_expand_prologue PARAMS((void));\n-extern void ia64_expand_epilogue PARAMS((void));\n-extern void ia64_function_prologue PARAMS((FILE *, int));\n-extern void ia64_function_epilogue PARAMS((FILE *, int));\n-extern int ia64_direct_return PARAMS((void));\n extern int predicate_operator PARAMS((rtx, enum machine_mode));\n extern int ar_lc_reg_operand PARAMS((rtx, enum machine_mode));\n extern int ar_ccv_reg_operand PARAMS((rtx, enum machine_mode));\n@@ -64,10 +59,18 @@ extern int destination_tfmode_operand PARAMS((rtx, enum machine_mode));\n extern int tfreg_or_fp01_operand PARAMS((rtx, enum machine_mode));\n \n extern int ia64_move_ok PARAMS((rtx, rtx));\n+extern int ia64_depz_field_mask PARAMS((rtx, rtx));\n extern rtx ia64_gp_save_reg PARAMS((int));\n extern rtx ia64_split_timode PARAMS((rtx[], rtx, rtx));\n extern rtx spill_tfmode_operand PARAMS((rtx, int));\n \n+extern HOST_WIDE_INT ia64_initial_elimination_offset PARAMS((int, int));\n+extern void ia64_expand_prologue PARAMS((void));\n+extern void ia64_expand_epilogue PARAMS((void));\n+extern void ia64_function_prologue PARAMS((FILE *, int));\n+extern void ia64_function_epilogue PARAMS((FILE *, int));\n+\n+extern int ia64_direct_return PARAMS((void));\n extern void ia64_expand_load_address PARAMS((rtx, rtx));\n extern void ia64_expand_fetch_and_op PARAMS ((enum fetchop_code,\n \t\t\t\t\t      enum machine_mode, rtx []));"}, {"sha": "3088a82a02830d0ad146ffb7b78c07ac21ce21e0", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=041f25e6ffe48671895d036ceacc7c0ceb787d87", "patch": "@@ -316,6 +316,18 @@ reg_or_0_operand (op, mode)\n   return (op == const0_rtx || register_operand (op, mode));\n }\n \n+/* Return 1 if OP is a register operand, or a 5 bit immediate operand.  */\n+\n+int\n+reg_or_5bit_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 32)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX\n+\t  || register_operand (op, mode));\n+}\n+\n /* Return 1 if OP is a register operand, or a 6 bit immediate operand.  */\n \n int\n@@ -635,6 +647,23 @@ ia64_move_ok (dst, src)\n     return GET_CODE (src) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (src);\n }\n \n+/* Check if OP is a mask suitible for use with SHIFT in a dep.z instruction.\n+   Return the length of the field, or <= 0 on failure.  */\n+\n+int\n+ia64_depz_field_mask (rop, rshift)\n+     rtx rop, rshift;\n+{\n+  unsigned HOST_WIDE_INT op = INTVAL (rop);\n+  unsigned HOST_WIDE_INT shift = INTVAL (rshift);\n+\n+  /* Get rid of the zero bits we're shifting in.  */\n+  op >>= shift;\n+\n+  /* We must now have a solid block of 1's at bit 0.  */\n+  return exact_log2 (op + 1);\n+}\n+\n /* Expand a symbolic constant load.  */\n /* ??? Should generalize this, so that we can also support 32 bit pointers.  */\n "}, {"sha": "c327b6cf4ec4177bd57162a9f29f6666286eb441", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=041f25e6ffe48671895d036ceacc7c0ceb787d87", "patch": "@@ -1108,11 +1108,17 @@ enum reg_class\n    letters (`Q', `R', `S', `T', `U') that can be used to segregate specific\n    types of operands, usually memory references, for the target machine.  */\n \n+/* Non-volatile memory for FP_REG loads/stores.  */\n #define CONSTRAINT_OK_FOR_Q(VALUE) \\\n   (memory_operand((VALUE), VOIDmode) && ! MEM_VOLATILE_P (VALUE))\n+/* 1..4 for shladd arguments.  */\n+#define CONSTRAINT_OK_FOR_R(VALUE) \\\n+  (GET_CODE (VALUE) == CONST_INT && INTVAL (VALUE) >= 1 && INTVAL (VALUE) <= 4)\n \n #define EXTRA_CONSTRAINT(VALUE, C) \\\n-  ((C) == 'Q' ? CONSTRAINT_OK_FOR_Q (VALUE) : 0)\n+  ((C) == 'Q' ? CONSTRAINT_OK_FOR_Q (VALUE)\t\\\n+   : (C) == 'R' ? CONSTRAINT_OK_FOR_R (VALUE)\t\\\n+   : 0)\n \f\n /* Basic Stack Layout */\n \n@@ -2639,6 +2645,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"move_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n \t\t     CONSTANT_P_RTX, SYMBOL_REF, CONST, LABEL_REF}},\t\\\n { \"reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+{ \"reg_or_5bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n { \"reg_or_6bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n { \"reg_or_8bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n { \"reg_or_8bit_adjusted_operand\", {SUBREG, REG, CONST_INT,\t\t\\"}, {"sha": "e0173e6a34412eaa827adea1e175d3c2d36ba994", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 61, "deletions": 82, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041f25e6ffe48671895d036ceacc7c0ceb787d87/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=041f25e6ffe48671895d036ceacc7c0ceb787d87", "patch": "@@ -1113,9 +1113,6 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n-;; ??? It would be useful to have SImode versions of the extract and insert\n-;; patterns.\n-\n (define_insn \"extv\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(sign_extract:DI (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -1229,6 +1226,21 @@\n   \"dep %0 = %3, %0, %2, %1\"\n   [(set_attr \"type\" \"I\")])\n \n+;; Combine doesn't like to create bitfield insertions into zero.\n+(define_insn \"*depz_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:DI 3 \"const_int_operand\" \"n\")))]\n+  \"CONST_OK_FOR_M (INTVAL (operands[2]))\n+   && ia64_depz_field_mask (operands[3], operands[2]) > 0\"\n+  \"*\n+{\n+  operands[3] = GEN_INT (ia64_depz_field_mask (operands[3], operands[2]));\n+  return \\\"%,dep.z %0 = %1, %2, %3\\\";\n+}\"\n+  [(set_attr \"type\" \"I\")])\n+\n (define_insn \"shift_mix4left\"\n   [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"+r\")\n \t\t\t (const_int 32) (const_int 0))\n@@ -1238,9 +1250,6 @@\n   \"#\"\n   [(set_attr \"type\" \"unknown\")])\n \n-;; ??? Need to emit an instruction group barrier here because this gets split\n-;; after md_reorg.\n-\n (define_split\n   [(set (zero_extract:DI (match_operand:DI 0 \"register_operand\" \"\")\n \t\t\t (const_int 32) (const_int 0))\n@@ -2003,89 +2012,59 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n-;; There is no sign-extend form of dep, so we only get 32 bits of valid result\n-;; instead of 64 like the patterns below.\n-\n-;; Using a predicate that accepts only constants doesn't work, because optabs\n-;; will load the operand into a register and call the pattern if the predicate\n-;; did not accept it on the first try.  So we use nonmemory_operand and then\n-;; verify that we have an appropriate constant in the expander.\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (! shift_32bit_count_operand (operands[2], SImode))\n-    FAIL;\n-}\")\n-\n-(define_insn \"*ashlsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:SI 2 \"shift_32bit_count_operand\" \"n\")))]\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r,r\")\n+\t\t   (match_operand:SI 2 \"reg_or_5bit_operand\" \"R,n,r\")))]\n   \"\"\n-  \"dep.z %0 = %1, %2, %E2\"\n-  [(set_attr \"type\" \"I\")])\n-\n-;; This is really an extract, but this is how combine canonicalizes the\n-;; operation.\n+  \"@\n+   shladd %0 = %1, %2, r0\n+   dep.z %0 = %1, %2, %E2\n+   shl %0 = %1, %2\"\n+  [(set_attr \"type\" \"A,I,I\")])\n \n (define_expand \"ashrsi3\"\n-  [(set (match_dup 3)\n-\t(ashiftrt:DI (sign_extend:DI\n-\t\t      (match_operand:SI 1 \"register_operand\" \"\"))\n-\t\t     (match_operand:DI 2 \"nonmemory_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (match_dup 4))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"reg_or_5bit_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! shift_32bit_count_operand (operands[2], SImode))\n-    FAIL;\n-\n-  operands[3] = gen_reg_rtx (DImode);\n-  operands[4] = gen_lowpart (SImode, operands[3]);\n+  rtx subtarget = gen_reg_rtx (DImode);\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    emit_insn (gen_extv (subtarget, gen_lowpart (DImode, operands[1]),\n+\t\t\t GEN_INT (32 - INTVAL (operands[2])), operands[2]));\n+  else\n+    {\n+      emit_insn (gen_extendsidi2 (subtarget, operands[1]));\n+      emit_insn (gen_ashrdi3 (subtarget, subtarget,\n+\t\t\t      gen_lowpart (DImode, operands[2])));\n+    }\n+  emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);\n+  DONE;\n }\")\n \n-(define_insn \"*ashrsi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:DI (sign_extend:DI\n-\t\t      (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t     (match_operand:DI 2 \"shift_32bit_count_operand\" \"n\")))]\n-  \"\"\n-  \"extr %0 = %1, %2, %E2\"\n-  [(set_attr \"type\" \"I\")])\n-\n-;; This is really an extract, but this is how combine canonicalizes the\n-;; operation.\n-\n (define_expand \"lshrsi3\"\n-  [(set (match_dup 3)\n-\t(lshiftrt:DI (zero_extend:DI\n-\t\t      (match_operand:SI 1 \"register_operand\" \"\"))\n-\t\t     (match_operand:DI 2 \"nonmemory_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (match_dup 4))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"reg_or_5bit_operand\" \"\")))]\n   \"\"\n   \"\n {\n-  if (! shift_32bit_count_operand (operands[2], SImode))\n-    FAIL;\n-\n-  operands[3] = gen_reg_rtx (DImode);\n-  operands[4] = gen_lowpart (SImode, operands[3]);\n+  rtx subtarget = gen_reg_rtx (DImode);\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    emit_insn (gen_extzv (subtarget, gen_lowpart (DImode, operands[1]),\n+\t\t\t  GEN_INT (32 - INTVAL (operands[2])), operands[2]));\n+  else\n+    {\n+      emit_insn (gen_zero_extendsidi2 (subtarget, operands[1]));\n+      emit_insn (gen_lshrdi3 (subtarget, subtarget,\n+\t\t\t      gen_lowpart (DImode, operands[2])));\n+    }\n+  emit_move_insn (gen_lowpart (DImode, operands[0]), subtarget);\n+  DONE;\n }\")\n \n-(define_insn \"*lshrsi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:DI (zero_extend:DI\n-\t\t      (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t     (match_operand:DI 2 \"shift_32bit_count_operand\" \"n\")))]\n-  \"\"\n-  \"extr.u %0 = %1, %2, %E2\"\n-  [(set_attr \"type\" \"I\")])\n-\n ;; Use mix4.r/shr to implement rotrsi3.  We only get 32 bits of valid result\n ;; here, instead of 64 like the patterns above.\n \n@@ -2102,11 +2081,9 @@\n {\n   if (! shift_32bit_count_operand (operands[2], SImode))\n     FAIL;\n-\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_lowpart (SImode, operands[3]);\n }\")\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -2115,12 +2092,14 @@\n ;; ::::::::::::::::::::\n \n (define_insn \"ashldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:DI 2 \"reg_or_6bit_operand\" \"rM\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t   (match_operand:DI 2 \"reg_or_6bit_operand\" \"R,rM\")))]\n   \"\"\n-  \"shl %0 = %1, %2\"\n-  [(set_attr \"type\" \"I\")])\n+  \"@\n+   shladd %0 = %1, %2, r0\n+   shl %0 = %1, %2\"\n+  [(set_attr \"type\" \"A,I\")])\n \n ;; ??? Maybe combine this with the multiply and add instruction?\n "}]}