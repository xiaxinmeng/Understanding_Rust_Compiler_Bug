{"sha": "9fb32434113c28e3f8f2346be2609a4f6fd136ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiMzI0MzQxMTNjMjhlM2Y4ZjIzNDZiZTI2MDlhNGY2ZmQxMzZlYQ==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2004-08-18T16:22:08Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2004-08-18T16:22:08Z"}, "message": "Hot/cold partitioning update patch.\n\nHot/cold partitioning update patch.  The problems that this patch\nattemptd to address/fix are:\n\n- Fix places where adding in_unlikely_executed_text to the enum data\n  type \"in_section\"  threw off switch case statements.\n- Make it work correctly (by turning it off) for functions where user\n  specifies \"__attribute__ section\"\n- Make it work correctly (by turning it off) for linkonce sections\n- Make it work correctly with -ffunction-sections flag\n- Make it output correct cold section labels\n- Undo some changes to original assembly code generation\n- Turn off hot/cold partitioning in the presence of DWARF debugging (for\n  the moment)\n- Turn off hot/cold partitioning for architectures that do not support\n  named sections\n- Use variables rather than constants for cold section labels and names (to\n  work correctly with -ffunction-sections, among other things)\n\n\n2004-08-18  Caroline Tice  <ctice@apple.com>\n\n        * Makefile.in (STAGEFEEDBACK_FLAGS_TO_PASS) Add\n        \"-freorder-blocks-and-partition\" to the flags used in second\n        stage of profiledbootstrap.\n        * bb-reorder.c (push_to_next_round_p): Add new variable,\n        next_round_is_last; set and use variable to make sure, when\n        partitioning, that the last trace construction round consists\n        of all (and only) cold basic blocks.\n        (rotate_loop): Don't copy blocks that end in a section\n        crossing jump.\n        (copy_bb): Correctly initialize \"partition\" of duplicated bb.\n        (add_unlikely_executed_notes): Add a comment.\n        (find_rarely_executed_basic_blocks_and_crossing_edges): Modify\n        to make sure, if function contains hot blocks, that the\n        successors of ENTRY_BLOCK_PTR are hot; also, only look for\n        crossing edges if the architecture supports named sections.\n        (mark_bb_for_unlikely_executed_section): Modify to always\n        insert the NOTE_INSN_UNLIKELY_EXECUTED_CODE immediately after\n        the basic block note insn.\n        (fix_crossing_unconditional_branches): Remove extra space.\n        (fix_edges_for_rarely_executed_code): Modify to only do\n        partitioning work if the architecture supports named sections.\n        (reorder_basic_blocks): Modify to only add\n        NOTE_INSN_UNLIKELY_EXECUTED_CODE notes if the architecture\n        supports named sections.\n        * c-common.c (handle_section_attribute): Initialize new global\n        variable, user_defined_section_attribute, to true if user has\n        specified one.\n        * cfgcleanup.c (try_forward_edges): Modify to not attempt to\n        forward edges that cross section boundaries.\n        * cfglayout.c (fixup_reorder_chain): Modify to only fix up\n        partitioning information if the architecture supports named\n        sections.\n        * cfgrtl.c (target.h): Add statement to include this.\n        (rtl_split_block): Make sure newly created bb gets correct\n        partition.\n        (try_redirect_by_replacing_jump): Make sure redirection isn't\n        attempting to cross section boundaries.\n        (force_nonfallthru_and_redirect): Only do partition fix up if\n        architecture supports named sections.\n        (rtl_split_edge): Make sure newly created bb ends up in\n        correct partition.\n        (commit_one_edge_insertion): Remove code that incorrectly\n        updated basic block partition; Make sure partition fix up only\n        happens if architecture supports named sections and it's not\n        already done.\n        (rtl_verify_flow_info_1): Fix if-condition on test/error\n        condition that fallthru edges are not allowed to cross section\n        boundaries.\n        * defaults.h (NORMAL_TEXT_SECTION_NAME): Remove this.\n        * final.c (final_scan_insn): Remove redundant test from if-statement;\n        change calls to text_section into calls to function_section; add code\n        to only to partitioning fix up if architecture supports named\n        sections.\n        * ifcvt.c (find_if_case_1): Make sure newly created bb has correct\n        partition.\n        (if_convert): Add targetm.have_named_sections to test.\n        * output.h (unlikely_section_label): Extern declaration for new global\n        variable.\n        (unlikely_text_section_name): Likewise.\n        * opts.c (decode_options): If both partitioning and DWARF debugging\n        are turned on, issue a warning that this doesn't work, and change\n        partitiong to basic block reordering (without hot/cold partitions).\n        * passes.c (rest_of_handle_final): Re-set new global variable,\n        user_defined_section_attribute, to false.\n        (rest_of_compilation): Change options for calling partitioning\n        function: Don't call if the user defined the section attribute, and\n        don't call if DECL_ONE_ONLY is true for the current function.\n        * predict.c (choose_function_section): Return immediately if we\n        are doing hot/cold partitioning (i.e. let the basic block partitioning\n        determine where the function belongs).\n        * reg-stack.c (emit_swap_insn): Add condition to step over\n        NOTE_INSN_UNLIKELY_EXECUTED_CODE notes.\n        * toplev.c (user_defined_section_attribute): New global variable.\n        * toplev.h (user_defined_section_attribute): Extern declaration for new\n        global variable.\n        * varasm.c (unlikely_section_label): New global variable.\n        (unlikely_text_section_name): New global variable.\n        (unlikely_text_section): Add code to initialize unlikely_text_section_name\n        if necessary; modify to use unlikely_text_section_name and\n        unlikely_section_label; also to use named_section properly.\n        (in_unlikely_text_section):  Modify to work correctly with named_section\n        and to use unlikely_text_section_name.\n        (named_section):  Add code to work properly with cold section.\n        (function_section): Clean up if-statement.\n        * config/darwin.c (darwin_asm_named_section): Return to original code,\n        removing use of SECTION_FORMAT_STRING.\n        * config/arm/pe.h (switch_to_section):  Add case for\n        in_unlikely_executed_text to switch statement.\n        * config/i386/cygming.h (switch_to_section): Likewise.\n        * config/i386/darwin.h (NORMAL_TEXT_SECTION_NAME): Remove.\n        (SECTION_FORMAT_STRING): Likewise.\n        * config/mcore/mcore.h (switch_to_section): Likewise.\n        * config/rs6000/darwin.h (NORMAL_TEXT_SECTION_NAME): Remove.\n\nFrom-SVN: r86189", "tree": {"sha": "c63a7ba63b9528cef9f1bb15e12b69de24533c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c63a7ba63b9528cef9f1bb15e12b69de24533c51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb32434113c28e3f8f2346be2609a4f6fd136ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb32434113c28e3f8f2346be2609a4f6fd136ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb32434113c28e3f8f2346be2609a4f6fd136ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb32434113c28e3f8f2346be2609a4f6fd136ea/comments", "author": null, "committer": null, "parents": [{"sha": "b4b3435ecce4606416949432e6c5454b3b174c37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b3435ecce4606416949432e6c5454b3b174c37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4b3435ecce4606416949432e6c5454b3b174c37"}], "stats": {"total": 355, "additions": 246, "deletions": 109}, "files": [{"sha": "5bafc596ff4da009e3fded29476da23d331a41f0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -3593,7 +3593,7 @@ STAGEPROFILE_FLAGS_TO_PASS = \\\n # Files never linked into the final executable produces warnings about missing\n # profile.\n STAGEFEEDBACK_FLAGS_TO_PASS = \\\n-\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-use\"\n+\tCFLAGS=\"$(BOOT_CFLAGS) -fprofile-use -freorder-blocks-and-partition\"\n \n # Only build the C compiler for stage1, because that is the only one that\n # we can guarantee will build with the native compiler, and also it is the"}, {"sha": "32234b103f5e18bbe75ddbfa03125b442f0c6137", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 94, "deletions": 57, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -197,8 +197,10 @@ push_to_next_round_p (basic_block bb, int round, int number_of_rounds,\n   bool there_exists_another_round;\n   bool cold_block;\n   bool block_not_hot_enough;\n+  bool next_round_is_last;\n \n   there_exists_another_round = round < number_of_rounds - 1;\n+  next_round_is_last = round + 1 == number_of_rounds - 1;\n \n   cold_block = (flag_reorder_blocks_and_partition \n \t\t&& bb->partition == COLD_PARTITION);\n@@ -207,7 +209,11 @@ push_to_next_round_p (basic_block bb, int round, int number_of_rounds,\n \t\t\t  || bb->count < count_th\n \t\t\t  || probably_never_executed_bb_p (bb));\n \n-  if (there_exists_another_round\n+  if (flag_reorder_blocks_and_partition\n+      && next_round_is_last\n+      && bb->partition != COLD_PARTITION)\n+    return false;\n+  else if (there_exists_another_round\n       && (cold_block || block_not_hot_enough))\n     return true;\n   else \n@@ -383,7 +389,9 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \n \t      /* Duplicate HEADER if it is a small block containing cond jump\n \t\t in the end.  */\n-\t      if (any_condjump_p (BB_END (header)) && copy_bb_p (header, 0))\n+\t      if (any_condjump_p (BB_END (header)) && copy_bb_p (header, 0)\n+\t\t  && !find_reg_note (BB_END (header), REG_CROSSING_JUMP, \n+\t\t\t\t     NULL_RTX))\n \t\t{\n \t\t  copy_bb (header, prev_bb->succ, prev_bb, trace_n);\n \t\t}\n@@ -750,6 +758,8 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n   basic_block new_bb;\n \n   new_bb = duplicate_block (old_bb, e);\n+  new_bb->partition = old_bb->partition;\n+\n   if (e->dest != new_bb)\n     abort ();\n   if (e->dest->rbi->visited)\n@@ -1236,6 +1246,8 @@ add_unlikely_executed_notes (void)\n {\n   basic_block bb;\n \n+  /* Add the UNLIKELY_EXECUTED_NOTES to each cold basic block.  */\n+\n   FOR_EACH_BB (bb)\n     if (bb->partition == COLD_PARTITION)\n       mark_bb_for_unlikely_executed_section (bb);\n@@ -1251,6 +1263,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n \t\t\t\t\t\t      int *max_idx)\n {\n   basic_block bb;\n+  bool has_hot_blocks = false;\n   edge e;\n   int i;\n \n@@ -1261,32 +1274,49 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n       if (probably_never_executed_bb_p (bb))\n \tbb->partition = COLD_PARTITION;\n       else\n-\tbb->partition = HOT_PARTITION;\n+\t{\n+\t  bb->partition = HOT_PARTITION;\n+\t  has_hot_blocks = true;\n+\t}\n     }\n \n+  /* Since all \"hot\" basic blocks will eventually be scheduled before all\n+     cold basic blocks, make *sure* the real function entry block is in\n+     the hot partition (if there is one).  */\n+  \n+  if (has_hot_blocks)\n+    for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+      if (e->dest->index >= 0)\n+\t{\n+\t  e->dest->partition = HOT_PARTITION;\n+\t  break;\n+\t}\n+\n   /* Mark every edge that crosses between sections.  */\n \n   i = 0;\n-  FOR_EACH_BB (bb)\n-    for (e = bb->succ; e; e = e->succ_next)\n-      {\n-\tif (e->src != ENTRY_BLOCK_PTR\n-\t    && e->dest != EXIT_BLOCK_PTR\n-\t    && e->src->partition != e->dest->partition)\n+  if (targetm.have_named_sections)\n+    {\n+      FOR_EACH_BB (bb)\n+\tfor (e = bb->succ; e; e = e->succ_next)\n \t  {\n-\t    e->crossing_edge = true;\n-\t    if (i == *max_idx)\n+\t    if (e->src != ENTRY_BLOCK_PTR\n+\t\t&& e->dest != EXIT_BLOCK_PTR\n+\t\t&& e->src->partition != e->dest->partition)\n \t      {\n-\t\t*max_idx *= 2;\n-\t\tcrossing_edges = xrealloc (crossing_edges,\n-\t\t\t\t\t   (*max_idx) * sizeof (edge));\n+\t\te->crossing_edge = true;\n+\t\tif (i == *max_idx)\n+\t\t  {\n+\t\t    *max_idx *= 2;\n+\t\t    crossing_edges = xrealloc (crossing_edges,\n+\t\t\t\t\t       (*max_idx) * sizeof (edge));\n+\t\t  }\n+\t\tcrossing_edges[i++] = e;\n \t      }\n-\t    crossing_edges[i++] = e;\n+\t    else\n+\t      e->crossing_edge = false;\n \t  }\n-\telse\n-\t  e->crossing_edge = false;\n-      }\n-\n+    }\n   *n_crossing_edges = i;\n }\n \n@@ -1301,32 +1331,28 @@ mark_bb_for_unlikely_executed_section (basic_block bb)\n   rtx insert_insn = NULL;\n   rtx new_note;\n   \n-  /* Find first non-note instruction and insert new NOTE before it (as\n-     long as new NOTE is not first instruction in basic block).  */\n-  \n-  for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb)); \n+  /* Insert new NOTE immediately after  BASIC_BLOCK note.  */\n+\n+  for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb));\n        cur_insn = NEXT_INSN (cur_insn))\n-    if (!NOTE_P (cur_insn)\n-\t&& !LABEL_P (cur_insn))\n+    if (GET_CODE (cur_insn) == NOTE\n+\t&& NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_BASIC_BLOCK)\n       {\n \tinsert_insn = cur_insn;\n \tbreak;\n       }\n-  \n+    \n+  /* If basic block does not contain a NOTE_INSN_BASIC_BLOCK, there is\n+     a major problem.  */\n+\n+  if (!insert_insn)\n+    abort ();\n+\n   /* Insert note and assign basic block number to it.  */\n   \n-  if (insert_insn) \n-    {\n-      new_note = emit_note_before (NOTE_INSN_UNLIKELY_EXECUTED_CODE, \n- \t\t\t\t   insert_insn);\n-      NOTE_BASIC_BLOCK (new_note) = bb;\n-    }\n-  else\n-    {\n-      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n-\t\t\t\t  BB_END (bb));\n-      NOTE_BASIC_BLOCK (new_note) = bb;\n-    }\n+  new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE, \n+\t\t\t      insert_insn);\n+  NOTE_BASIC_BLOCK (new_note) = bb;\n }\n \n /* If any destination of a crossing edge does not have a label, add label;\n@@ -1754,7 +1780,7 @@ fix_crossing_unconditional_branches (void)\n   rtx new_reg;\n   rtx cur_insn;\n   edge succ;\n-  \n+\n   FOR_EACH_BB (cur_bb)\n     {\n       last_insn = BB_END (cur_bb);\n@@ -1886,26 +1912,36 @@ fix_edges_for_rarely_executed_code (edge *crossing_edges,\n   \n   fix_up_fall_thru_edges ();\n   \n-  /* If the architecture does not have conditional branches that can\n-     span all of memory, convert crossing conditional branches into\n-     crossing unconditional branches.  */\n-  \n-  if (!HAS_LONG_COND_BRANCH)\n-    fix_crossing_conditional_branches ();\n+  /* Only do the parts necessary for writing separate sections if\n+     the target architecture has the ability to write separate sections\n+     (i.e. it has named sections).  Otherwise, the hot/cold partitioning\n+     information will be used when reordering blocks to try to put all\n+     the hot blocks together, then all the cold blocks, but no actual\n+     section partitioning will be done.  */\n+\n+  if (targetm.have_named_sections)\n+    {\n+      /* If the architecture does not have conditional branches that can\n+\t span all of memory, convert crossing conditional branches into\n+\t crossing unconditional branches.  */\n   \n-  /* If the architecture does not have unconditional branches that\n-     can span all of memory, convert crossing unconditional branches\n-     into indirect jumps.  Since adding an indirect jump also adds\n-     a new register usage, update the register usage information as\n-     well.  */\n+      if (!HAS_LONG_COND_BRANCH)\n+\tfix_crossing_conditional_branches ();\n   \n-  if (!HAS_LONG_UNCOND_BRANCH)\n-    {\n-      fix_crossing_unconditional_branches ();\n-      reg_scan (get_insns(), max_reg_num (), 1);\n-    }\n+      /* If the architecture does not have unconditional branches that\n+\t can span all of memory, convert crossing unconditional branches\n+\t into indirect jumps.  Since adding an indirect jump also adds\n+\t a new register usage, update the register usage information as\n+\t well.  */\n+      \n+      if (!HAS_LONG_UNCOND_BRANCH)\n+\t{\n+\t  fix_crossing_unconditional_branches ();\n+\t  reg_scan (get_insns(), max_reg_num (), 1);\n+\t}\n \n-  add_reg_crossing_jump_notes ();\n+      add_reg_crossing_jump_notes ();\n+    }\n }\n \n /* Reorder basic blocks.  The main entry point to this file.  FLAGS is\n@@ -1957,7 +1993,8 @@ reorder_basic_blocks (unsigned int flags)\n   if (dump_file)\n     dump_flow_info (dump_file);\n \n-  if (flag_reorder_blocks_and_partition)\n+  if (flag_reorder_blocks_and_partition\n+      && targetm.have_named_sections)\n     add_unlikely_executed_notes ();\n \n   cfg_layout_finalize ();"}, {"sha": "6e07cfcbbdb9a720a5ef09f7db7854b09d6c8873", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -4357,6 +4357,8 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \n   if (targetm.have_named_sections)\n     {\n+      user_defined_section_attribute = true;\n+\n       if ((TREE_CODE (decl) == FUNCTION_DECL\n \t   || TREE_CODE (decl) == VAR_DECL)\n \t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)"}, {"sha": "d13e6be9babacc7cb4c824626e2024dcdcabc4a4", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -446,13 +446,22 @@ try_forward_edges (int mode, basic_block b)\n       target = first = e->dest;\n       counter = 0;\n \n+      /* If we are partitioning hot/cold basic_blocks, we don't want to mess\n+\t up jumps that cross between hot/cold sections.  */\n+\n+      if (flag_reorder_blocks_and_partition\n+\t  && first != EXIT_BLOCK_PTR\n+\t  && find_reg_note (BB_END (first), REG_CROSSING_JUMP, NULL_RTX))\n+\treturn false;\n+\n       while (counter < n_basic_blocks)\n \t{\n \t  basic_block new_target = NULL;\n \t  bool new_target_threaded = false;\n \t  may_thread |= target->flags & BB_DIRTY;\n \n \t  if (FORWARDER_BLOCK_P (target)\n+\t      && !target->succ->crossing_edge\n \t      && target->succ->dest != EXIT_BLOCK_PTR)\n \t    {\n \t      /* Bypass trivial infinite loops.  */"}, {"sha": "0cf7d8e513191a484b5d393dd9b0318f18c498d1", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -795,7 +795,8 @@ fixup_reorder_chain (void)\n \t  /* Make sure new bb is tagged for correct section (same as\n \t     fall-thru source).  */\n \t  e_fall->src->partition = bb->pred->src->partition;\n-\t  if (flag_reorder_blocks_and_partition)\n+\t  if (flag_reorder_blocks_and_partition\n+\t      && targetm.have_named_sections)\n \t    {\n \t      if (bb->pred->src->partition == COLD_PARTITION)\n \t\t{\n@@ -1107,6 +1108,7 @@ cfg_layout_duplicate_bb (basic_block bb)\n \t\t\t       insn ? get_last_insn () : NULL,\n \t\t\t       EXIT_BLOCK_PTR->prev_bb);\n \n+  new_bb->partition = bb->partition;\n   if (bb->rbi->header)\n     {\n       insn = bb->rbi->header;"}, {"sha": "f3618f07c970288b2dcc168caed64d371dd2937d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -56,6 +56,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"insn-config.h\"\n #include \"cfglayout.h\"\n #include \"expr.h\"\n+#include \"target.h\"\n \n \n /* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */\n@@ -488,6 +489,7 @@ rtl_split_block (basic_block bb, void *insnp)\n \n   /* Create the new basic block.  */\n   new_bb = create_basic_block (NEXT_INSN (insn), BB_END (bb), bb);\n+  new_bb->partition = bb->partition;\n   BB_END (bb) = insn;\n \n   /* Redirect the outgoing edges.  */\n@@ -681,7 +683,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n      and cold sections.  */\n   \n   if (flag_reorder_blocks_and_partition\n-      && find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX))\n+      && (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n+\t  || (src->partition != target->partition)))\n     return NULL;\n \n   /* Verify that all targets will be TARGET.  */\n@@ -1092,7 +1095,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n       /* Make sure new block ends up in correct hot/cold section.  */\n \n       jump_block->partition = e->src->partition;\n-      if (flag_reorder_blocks_and_partition)\n+      if (flag_reorder_blocks_and_partition\n+\t  && targetm.have_named_sections)\n \t{\n \t  if (e->src->partition == COLD_PARTITION)\n \t    {\n@@ -1350,9 +1354,13 @@ rtl_split_edge (edge edge_in)\n \t  && NOTE_LINE_NUMBER (before) == NOTE_INSN_LOOP_END)\n \tbefore = NEXT_INSN (before);\n       bb = create_basic_block (before, NULL, edge_in->src);\n+      bb->partition = edge_in->src->partition;\n     }\n   else\n-    bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n+    {\n+      bb = create_basic_block (before, NULL, edge_in->dest->prev_bb);\n+      bb->partition = edge_in->dest->partition;\n+    }\n \n   /* ??? This info is likely going to be out of date very soon.  */\n   if (edge_in->dest->global_live_at_start)\n@@ -1590,13 +1598,11 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t  bb = split_edge (e);\n \t  after = BB_END (bb);\n \n-\t  /* If we are partitioning hot/cold basic blocks, we must make sure\n-\t     that the new basic block ends up in the correct section.  */\n-\n-\t  bb->partition = e->src->partition;\n \t  if (flag_reorder_blocks_and_partition\n+\t      && targetm.have_named_sections\n \t      && e->src != ENTRY_BLOCK_PTR\n-\t      && e->src->partition == COLD_PARTITION)\n+\t      && e->src->partition == COLD_PARTITION\n+\t      && !e->crossing_edge)\n \t    {\n \t      rtx bb_note, new_note, cur_insn;\n \n@@ -1980,8 +1986,11 @@ rtl_verify_flow_info_1 (void)\n \t  if (e->flags & EDGE_FALLTHRU)\n \t    {\n \t      n_fallthru++, fallthru = e;\n-\t      if (e->crossing_edge)\n-\t\t{ \n+\t      if (e->crossing_edge\n+\t\t  || (e->src->partition != e->dest->partition\n+\t\t      && e->src != ENTRY_BLOCK_PTR\n+\t\t      && e->dest != EXIT_BLOCK_PTR))\n+\t    { \n \t\t  error (\"Fallthru edge crosses section boundary (bb %i)\",\n \t\t\t e->src->index);\n \t\t  err = 1;"}, {"sha": "63c127c1a617bea345184b9c1cb82c9f98855dac", "filename": "gcc/config/arm/pe.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Farm%2Fpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Farm%2Fpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -198,6 +198,7 @@ switch_to_section (enum in_section section, tree decl)\t\t\\\n   switch (section)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       case in_text: text_section (); break;\t\t\t\\\n+      case in_unlikely_executed_text: unlikely_text_section (); break; \\\n       case in_data: data_section (); break;\t\t\t\\\n       case in_named: named_section (decl, NULL, 0); break;\t\\\n       case in_readonly_data: readonly_data_section (); break;\t\\"}, {"sha": "1c308bb5eaceb229d217f7406921348a2856023c", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -1077,10 +1077,7 @@ darwin_globalize_label (FILE *stream, const char *name)\n void\n darwin_asm_named_section (const char *name, unsigned int flags ATTRIBUTE_UNUSED)\n {\n-  if (flag_reorder_blocks_and_partition)\n-    fprintf (asm_out_file, SECTION_FORMAT_STRING, name);\n-  else\n-    fprintf (asm_out_file, \".section %s\\n\", name);\n+  fprintf (asm_out_file, \".section %s\\n\", name);\n }\n \n unsigned int"}, {"sha": "cb0682010b85ea96c62f254855ecd8c099baae2a", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -162,6 +162,7 @@ switch_to_section (enum in_section section, tree decl)\t\t\\\n   switch (section)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       case in_text: text_section (); break;\t\t\t\\\n+      case in_unlikely_text_section: unlikely_text_section (); break; \\\n       case in_data: data_section (); break;\t\t\t\\\n       case in_readonly_data: readonly_data_section (); break;\t\\\n       case in_named: named_section (decl, NULL, 0); break;\t\\"}, {"sha": "0b3db813e6c4a712ab4445d93f91a39fdd100dc0", "filename": "gcc/config/i386/darwin.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fi386%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fi386%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdarwin.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -98,10 +98,8 @@ Boston, MA 02111-1307, USA.  */\n \n /* These are used by -fbranch-probabilities */\n #define HOT_TEXT_SECTION_NAME \"__TEXT,__text,regular,pure_instructions\"\n-#define NORMAL_TEXT_SECTION_NAME \"__TEXT,__text,regular,pure_instructions\"\n #define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \\\n                               \"__TEXT,__unlikely,regular,pure_instructions\"\n-#define SECTION_FORMAT_STRING \".section %s\\n\\t.align 2\\n\" \n \n /* Assembler pseudos to introduce constants of various size.  */\n "}, {"sha": "3ec2dd7c350de77040f4727a0b54fb4e320c67b8", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -968,6 +968,7 @@ switch_to_section (enum in_section section, tree decl)\t\t\\\n   switch (section)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       case in_text: text_section (); break;\t\t\t\\\n+      case in_unlikely_executed_text: unlikely_text_section (); break;   \\\n       case in_data: data_section (); break;\t\t\t\\\n       case in_named: named_section (decl, NULL, 0); break;\t\\\n       SUBTARGET_SWITCH_SECTIONS      \t\t\t\t\\"}, {"sha": "96e878bbcdef993031c201e707c2a16cc0930298", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -168,10 +168,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* These are used by -fbranch-probabilities */\n #define HOT_TEXT_SECTION_NAME \"__TEXT,__text,regular,pure_instructions\"\n-#define NORMAL_TEXT_SECTION_NAME \"__TEXT,__text,regular,pure_instructions\"\n #define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \\\n                               \"__TEXT,__unlikely,regular,pure_instructions\"\n-#define SECTION_FORMAT_STRING \".section %s\\n\\t.align 2\\n\"\n \n /* Define cutoff for using external functions to save floating point.\n    Currently on Darwin, always use inline stores.  */"}, {"sha": "82fce205724ed39f1992714d1682ab0ad096c090", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -654,10 +654,6 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define HOT_TEXT_SECTION_NAME \".text.hot\"\n #endif\n \n-#ifndef NORMAL_TEXT_SECTION_NAME\n-#define NORMAL_TEXT_SECTION_NAME \".text\"\n-#endif\n-\n #ifndef UNLIKELY_EXECUTED_TEXT_SECTION_NAME\n #define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \".text.unlikely\"\n #endif"}, {"sha": "4f5d824fed1ebb57c5ede777feb9ccbe62fd454a", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -1728,9 +1728,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t     are writing to appropriately.  */\n \t  \n \t  if (flag_reorder_blocks_and_partition\n-\t      && in_unlikely_text_section()\n \t      && !scan_ahead_for_unlikely_executed_note (insn))\n-\t    text_section ();\n+\t    function_section (current_function_decl);\n \n #ifdef TARGET_UNWIND_INFO\n \t  targetm.asm_out.unwind_emit (asm_out_file, insn);\n@@ -1923,7 +1922,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t basic blocks into separate sections of the .o file, we need\n \t to ensure the jump table ends up in the correct section...  */\n       \n-      if (flag_reorder_blocks_and_partition)\n+      if (flag_reorder_blocks_and_partition\n+\t  && targetm.have_named_sections)\n \t{\n \t  rtx tmp_table, tmp_label;\n \t  if (LABEL_P (insn)\n@@ -1933,11 +1933,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t    }\n \t  else if (scan_ahead_for_unlikely_executed_note (insn)) \n \t    unlikely_text_section ();\n-\t  else \n-\t    {\n-\t      if (in_unlikely_text_section ())\n-\t\ttext_section ();\n-\t    }\n+\t  else if (in_unlikely_text_section ())\n+\t    function_section (current_function_decl);\n \t}\n \n       if (app_on)"}, {"sha": "4b150d0e6612193469f3a8b225e261cdf5dcd814", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -2909,6 +2909,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n     {\n       new_bb->index = then_bb_index;\n       BASIC_BLOCK (then_bb_index) = new_bb;\n+      new_bb->partition = test_bb->partition;\n     }\n   /* We've possibly created jump to next insn, cleanup_cfg will solve that\n      later.  */\n@@ -3288,7 +3289,8 @@ if_convert (int x_life_data_ok)\n   life_data_ok = (x_life_data_ok != 0);\n \n   if ((! targetm.cannot_modify_jumps_p ())\n-      && (!flag_reorder_blocks_and_partition || !no_new_pseudos))\n+      && (!flag_reorder_blocks_and_partition || !no_new_pseudos\n+\t  || !targetm.have_named_sections))\n     mark_loop_exit_edges ();\n \n   /* Compute postdominators if we think we'll use them.  */"}, {"sha": "a6a7c337b217a1af7db65761c2001b9aaafa1c51", "filename": "gcc/opts.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -641,6 +641,21 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n+\n+  /* The optimization to partition hot and cold basic blocks into\n+     separate sections of the .o and executable files does not currently\n+     work correctly with DWARF debugging turned on.  Until this is fixed\n+     we will disable the optimization when DWARF debugging is set.  */\n+  \n+  if (flag_reorder_blocks_and_partition\n+      && (write_symbols == DWARF_DEBUG\n+\t  || write_symbols == DWARF2_DEBUG))\n+    {\n+      warning\n+\t(\"-freorder-blocks-and-partition does not work with -g (currently)\");\n+      flag_reorder_blocks_and_partition = 0;\n+      flag_reorder_blocks = 1;\n+    }\n }\n \n /* Handle target- and language-independent options.  Return zero to"}, {"sha": "e832eb3d706ca3917452febd1e6bb82bc03f125f", "filename": "gcc/output.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -392,6 +392,10 @@ extern const char *first_global_object_name;\n /* The first weak object in the file.  */\n extern const char *weak_global_object_name;\n \n+/* Label at start of unlikely section, when partitioning hot/cold basic\n+   blocks.  */\n+extern char *unlikely_section_label;\n+\n /* Nonzero if function being compiled doesn't contain any calls\n    (ignoring the prologue and epilogue).  This is set prior to\n    local register allocation and is valid for the remaining\n@@ -438,6 +442,12 @@ extern tree last_assemble_variable_decl;\n extern bool decl_readonly_section (tree, int);\n extern bool decl_readonly_section_1 (tree, int, int);\n \n+/* The following global variable indicates the section name to be used\n+   for the current cold section, when partitioning hot and cold basic\n+   blocks into separate sections.  */\n+\n+extern char *unlikely_text_section_name;\n+\n /* This can be used to compute RELOC for the function above, when\n    given a constant expression.  */\n extern int compute_reloc_for_constant (tree);"}, {"sha": "e8a93222c323c5f5fd7b5d87c1277bb4ec5e8ddc", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -454,6 +454,8 @@ rest_of_handle_final (void)\n     output_function_exception_table ();\n #endif\n \n+    user_defined_section_attribute = false;\n+\n     if (! quiet_flag)\n       fflush (asm_out_file);\n \n@@ -1857,7 +1859,9 @@ rest_of_compilation (void)\n      sections of the .o file does not work well with exception handling.\n      Don't call it if there are exceptions.  */\n \n-  if (optimize > 0 && flag_reorder_blocks_and_partition && !flag_exceptions)\n+  if (flag_reorder_blocks_and_partition \n+      && !DECL_ONE_ONLY (current_function_decl)\n+      && !user_defined_section_attribute)\n     rest_of_handle_partition_blocks ();\n \n   if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))"}, {"sha": "d0ab77015aca4e5f337051105404e12a2bf9defa", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -1441,6 +1441,13 @@ choose_function_section (void)\n \t of all instances.  For now just never set frequency for these.  */\n       || DECL_ONE_ONLY (current_function_decl))\n     return;\n+\n+  /* If we are doing the partitioning optimization, let the optimization\n+     choose the correct section into which to put things.  */\n+\n+  if (flag_reorder_blocks_and_partition)\n+    return;\n+\n   if (cfun->function_frequency == FUNCTION_FREQUENCY_HOT)\n     DECL_SECTION_NAME (current_function_decl) =\n       build_string (strlen (HOT_TEXT_SECTION_NAME), HOT_TEXT_SECTION_NAME);"}, {"sha": "04220bf0b2d794ecacdf2921a4d5f39879711b22", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -989,6 +989,8 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n \t  if (LABEL_P (tmp)\n \t      || CALL_P (tmp)\n \t      || NOTE_INSN_BASIC_BLOCK_P (tmp)\n+\t      || (NOTE_P (tmp)\n+\t\t  && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n \t      || (NONJUMP_INSN_P (tmp)\n \t\t  && stack_regs_mentioned (tmp)))\n \t    {"}, {"sha": "53f44185584e0246e5eb801a5da89ec8fdde22ad", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -340,6 +340,11 @@ enum pta_type flag_tree_points_to = PTA_NONE;\n    to optimize, debug_info_level and debug_hooks in process_options ().  */\n int flag_var_tracking = AUTODETECT_FLAG_VAR_TRACKING;\n \n+/* True if the user has tagged the function with the 'section'\n+   attribute.  */\n+\n+bool user_defined_section_attribute = false;\n+\n /* Values of the -falign-* flags: how much to align labels in code.\n    0 means `use default', 1 means `don't align'.\n    For each variable, there is an _log variant which is the power"}, {"sha": "fe588762a7d1610265d877d47796aca0eca168ea", "filename": "gcc/toplev.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -116,6 +116,11 @@ extern bool exit_after_options;\n \n extern int target_flags_explicit;\n \n+/* True if the user has tagged the function with the 'section'\n+   attribute.  */\n+\n+extern bool user_defined_section_attribute;\n+\n /* See toplev.c.  */\n extern int flag_loop_optimize;\n extern int flag_crossjumping;"}, {"sha": "5d02c570ae3553dba1bcb6400931a406e496f68f", "filename": "gcc/varasm.c", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb32434113c28e3f8f2346be2609a4f6fd136ea/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9fb32434113c28e3f8f2346be2609a4f6fd136ea", "patch": "@@ -222,18 +222,42 @@ text_section (void)\n void\n unlikely_text_section (void)\n {\n-  if ((in_section != in_unlikely_executed_text)\n-      &&  (in_section != in_named \n-\t   || strcmp (in_named_name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) != 0))\n+  const char *name;\n+  int len;\n+\n+  if (! unlikely_text_section_name)\n     {\n-      if (targetm.have_named_sections)\n-        named_section (NULL_TREE, UNLIKELY_EXECUTED_TEXT_SECTION_NAME, 0);\n+      if (DECL_SECTION_NAME (current_function_decl)\n+\t  && (strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME\n+\t\t\t\t\t   (current_function_decl)),\n+\t\t      HOT_TEXT_SECTION_NAME) != 0)\n+\t  && (strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME\n+\t\t\t\t\t   (current_function_decl)),\n+\t\t      UNLIKELY_EXECUTED_TEXT_SECTION_NAME) != 0))\n+\t{\n+\t  name = TREE_STRING_POINTER (DECL_SECTION_NAME \n+\t\t\t\t                   (current_function_decl));\n+\t  len = strlen (name);\n+\t  unlikely_text_section_name = xmalloc ((len + 10) * sizeof (char));\n+\t  strcpy (unlikely_text_section_name, name);\n+\t  strcat (unlikely_text_section_name, \"_unlikely\");\n+\t}\n       else\n \t{\n-\t  in_section = in_unlikely_executed_text;\n-\t  fprintf (asm_out_file, \"%s\\n\", TEXT_SECTION_ASM_OP);\n+\t  len = strlen (UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n+\t  unlikely_text_section_name = xmalloc (len+1 * sizeof (char));\n+\t  strcpy (unlikely_text_section_name, \n+\t\t  UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n \t}\n-      \n+    }\n+\n+  if ((in_section != in_unlikely_executed_text)\n+      &&  (in_section != in_named \n+\t   || strcmp (in_named_name, unlikely_text_section_name) != 0))\n+    {\n+      named_section (NULL_TREE, unlikely_text_section_name, 0);\n+      in_section = in_unlikely_executed_text;\n+\n       if (!unlikely_section_label_printed)\n \t{\n \t  ASM_OUTPUT_LABEL (asm_out_file, unlikely_section_label);\n@@ -289,7 +313,14 @@ in_text_section (void)\n int\n in_unlikely_text_section (void)\n {\n-  return in_section == in_unlikely_executed_text;\n+  bool ret_val;\n+\n+  ret_val = ((in_section == in_unlikely_executed_text)\n+\t     || (in_section == in_named\n+\t\t && unlikely_text_section_name\n+\t\t && strcmp (in_named_name, unlikely_text_section_name) == 0));\n+\n+  return ret_val;\n }\n \n /* Determine if we're in the data section.  */\n@@ -423,6 +454,16 @@ named_section (tree decl, const char *name, int reloc)\n   if (name == NULL)\n     name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n \n+  if (strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0\n+      && !unlikely_text_section_name)\n+    {\n+      unlikely_text_section_name = xmalloc \n+\t     (strlen (UNLIKELY_EXECUTED_TEXT_SECTION_NAME) + 1 \n+\t      * sizeof (char));\n+      strcpy (unlikely_text_section_name, \n+\t      UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n+    }\n+\n   flags = targetm.section_type_flags (decl, name, reloc);\n \n   /* Sanity check user variables for flag changes.  Non-user\n@@ -533,14 +574,11 @@ function_section (tree decl)\n {\n   if (scan_ahead_for_unlikely_executed_note (get_insns()))\n     unlikely_text_section ();\n+  else if (decl != NULL_TREE\n+\t   && DECL_SECTION_NAME (decl) != NULL_TREE)\n+    named_section (decl, (char *) 0, 0);\n   else\n-    {\n-      if (decl != NULL_TREE\n-\t  && DECL_SECTION_NAME (decl) != NULL_TREE)\n-\tnamed_section (decl, (char *) 0, 0);\n-      else\n-\ttext_section (); \n-    }\n+    text_section (); \n }\n \n /* Switch to read-only data section associated with function DECL.  */\n@@ -1153,7 +1191,7 @@ assemble_start_function (tree decl, const char *fnname)\n     free (unlikely_section_label);\n   unlikely_section_label = xmalloc ((strlen (fnname) + 18) * sizeof (char));\n   sprintf (unlikely_section_label, \"%s_unlikely_section\", fnname);\n-\n+  \n   /* The following code does not need preprocessing in the assembler.  */\n \n   app_disable ();\n@@ -4481,7 +4519,8 @@ default_section_type_flags_1 (tree decl, const char *name, int reloc,\n     flags = SECTION_CODE;\n   else if (decl && decl_readonly_section_1 (decl, reloc, shlib))\n     flags = 0;\n-  else if (strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0)\n+  else if (unlikely_text_section_name\n+\t   && strcmp (name, unlikely_text_section_name) == 0)\n     flags = SECTION_CODE;\n   else\n     flags = SECTION_WRITE;"}]}