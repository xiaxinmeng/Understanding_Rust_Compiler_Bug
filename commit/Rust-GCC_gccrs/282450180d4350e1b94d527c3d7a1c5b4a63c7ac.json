{"sha": "282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgyNDUwMTgwZDQzNTBlMWI5NGQ1MjdjM2Q3YTFjNWI0YTYzYzdhYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-09T21:44:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-09T21:44:17Z"}, "message": "alpha.c (alpha_gimplify_va_arg_1, [...]): New.\n\n        * config/alpha/alpha.c (alpha_gimplify_va_arg_1,\n        alpha_gimplify_va_arg, TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n\nFrom-SVN: r82858", "tree": {"sha": "8ac9425dcde52bd420e5b9e36294bf14b1ae34e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ac9425dcde52bd420e5b9e36294bf14b1ae34e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282450180d4350e1b94d527c3d7a1c5b4a63c7ac/comments", "author": null, "committer": null, "parents": [{"sha": "7338fc64dde8ab8315095e226c1b9e2469a4e369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7338fc64dde8ab8315095e226c1b9e2469a4e369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7338fc64dde8ab8315095e226c1b9e2469a4e369"}], "stats": {"total": 141, "additions": 141, "deletions": 0}, "files": [{"sha": "07072a3cd53db49501275189321c19abf5c5153d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282450180d4350e1b94d527c3d7a1c5b4a63c7ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282450180d4350e1b94d527c3d7a1c5b4a63c7ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "patch": "@@ -1,3 +1,8 @@\n+2004-06-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (alpha_gimplify_va_arg_1,\n+\talpha_gimplify_va_arg, TARGET_GIMPLIFY_VA_ARG_EXPR): New.\n+\n 2004-06-09  Richard Henderson  <rth@redhat.com>\n \n \t* expmed.c (emit_store_flag): Cope with FLOAT_STORE_FLAG_VALUE."}, {"sha": "b8bf569a51242adad424499566ddc5aadbae91e6", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/282450180d4350e1b94d527c3d7a1c5b4a63c7ac/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/282450180d4350e1b94d527c3d7a1c5b4a63c7ac/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=282450180d4350e1b94d527c3d7a1c5b4a63c7ac", "patch": "@@ -52,6 +52,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n #include <splay-tree.h>\n #include \"cfglayout.h\"\n+#include \"tree-gimple.h\"\n \n /* Specify which cpu to schedule for.  */\n \n@@ -6398,6 +6399,139 @@ alpha_va_arg (tree valist, tree type)\n \n   return addr;\n }\n+\n+static tree\n+alpha_gimplify_va_arg_1 (tree type, tree base, tree offset,\n+\t\t\t tree *pre_p, tree *post_p)\n+{\n+  tree type_size, rounded_size, ptr_type, addend, t, addr;\n+  bool indirect;\n+\n+  if (type == error_mark_node\n+      || (type_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type))) == NULL\n+      || TREE_OVERFLOW (type_size))\n+    rounded_size = size_zero_node;\n+  else\n+    rounded_size = fold (build (MULT_EXPR, sizetype,\n+\t\t\t\tfold (build (TRUNC_DIV_EXPR, sizetype,\n+\t\t\t\t\t     fold (build (PLUS_EXPR, sizetype,\n+\t\t\t\t\t\t\t  type_size,\n+\t\t\t\t\t\t\t  size_int (7))),\n+\t\t\t\t\t     size_int (8))),\n+\t\t\t\tsize_int (8)));\n+\n+  /* If the type could not be passed in registers, skip the block\n+     reserved for the registers.  */\n+  if (MUST_PASS_IN_STACK (TYPE_MODE (type), type))\n+    {\n+      t = fold_convert (TREE_TYPE (offset), build_int_2 (6*8, 0));\n+      t = build (MODIFY_EXPR, TREE_TYPE (offset), offset,\n+\t\t build (MAX_EXPR, TREE_TYPE (offset), offset, t));\n+      gimplify_and_add (t, pre_p);\n+    }\n+\n+  addend = offset;\n+  ptr_type = build_pointer_type (type);\n+  indirect = false;\n+\n+  if (TYPE_MODE (type) == TFmode || TYPE_MODE (type) == TCmode)\n+    {\n+      type = ptr_type;\n+      ptr_type = build_pointer_type (type);\n+      indirect = true;\n+      rounded_size = size_int (UNITS_PER_WORD);\n+    }\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      tree real_part, imag_part, real_temp;\n+\n+      real_part = alpha_gimplify_va_arg_1 (TREE_TYPE (type), base, offset,\n+\t\t\t\t\t   pre_p, post_p);\n+      append_to_statement_list (*post_p, pre_p);\n+      *post_p = NULL;\n+\n+      /* Copy the value into a temporary, lest the formal temporary\n+\t be reused out from under us.  */\n+      real_temp = create_tmp_var (TREE_TYPE (real_part), NULL);\n+      t = build (MODIFY_EXPR, void_type_node, real_temp, real_part);\n+      gimplify_and_add (t, pre_p);\n+\n+      imag_part = alpha_gimplify_va_arg_1 (TREE_TYPE (type), base, offset,\n+\t\t\t\t\t   pre_p, post_p);\n+\n+      return build (COMPLEX_EXPR, type, real_temp, imag_part);\n+    }\n+  else if (TREE_CODE (type) == REAL_TYPE)\n+    {\n+      tree fpaddend, cond, fourtyeight;\n+\n+      fourtyeight = fold_convert (TREE_TYPE (addend), build_int_2 (6*8, 0));\n+      fpaddend = fold (build (MINUS_EXPR, TREE_TYPE (addend),\n+\t\t\t      addend, fourtyeight));\n+      cond = fold (build (LT_EXPR, boolean_type_node, addend, fourtyeight));\n+      addend = fold (build (COND_EXPR, TREE_TYPE (addend), cond,\n+\t\t\t    fpaddend, addend));\n+    }\n+\n+  /* Build the final address and force that value into a temporary.  */\n+  addr = build (PLUS_EXPR, ptr_type, fold_convert (ptr_type, base),\n+\t        fold_convert (ptr_type, addend));\n+  if (indirect)\n+    addr = build (INDIRECT_REF, type, addr);\n+  gimplify_expr (&addr, pre_p, post_p, is_gimple_val, fb_rvalue);\n+  append_to_statement_list (*post_p, pre_p);\n+  *post_p = NULL;\n+\n+  /* Update the offset field.  */\n+  t = fold_convert (TREE_TYPE (offset), rounded_size);\n+  t = build (MODIFY_EXPR, void_type_node, offset,\n+\t     build (PLUS_EXPR, TREE_TYPE (offset), offset, t));\n+  gimplify_and_add (t, pre_p);\n+\n+  return build_fold_indirect_ref (addr);\n+}\n+\n+static void\n+alpha_gimplify_va_arg (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  tree valist, type, offset_field, base_field, offset, base, t;\n+\n+  if (TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK)\n+    {\n+      std_gimplify_va_arg_expr (expr_p, pre_p, post_p);\n+      return;\n+    }\n+\n+  valist = TREE_OPERAND (*expr_p, 0);\n+  type = TREE_TYPE (*expr_p);\n+\n+  base_field = TYPE_FIELDS (va_list_type_node);\n+  offset_field = TREE_CHAIN (base_field);\n+  base_field = build (COMPONENT_REF, TREE_TYPE (base_field),\n+\t\t      valist, base_field);\n+  offset_field = build (COMPONENT_REF, TREE_TYPE (offset_field),\n+\t\t\tvalist, offset_field);\n+\n+  base = create_tmp_var (TREE_TYPE (base_field), NULL);\n+  offset = create_tmp_var (lang_hooks.types.type_for_size (64, 0), NULL);\n+\n+  /* Pull the fields of the structure out into temporaries.  */\n+  t = build (MODIFY_EXPR, void_type_node, base, base_field);\n+  gimplify_and_add (t, pre_p);\n+\n+  t = build (MODIFY_EXPR, void_type_node, offset,\n+\t     fold_convert (TREE_TYPE (offset), offset_field));\n+  gimplify_and_add (t, pre_p);\n+\n+  /* Find the value.  Note that this will be a stable indirection, or\n+     a composite of stable indirections in the case of complex.  */\n+  *expr_p = alpha_gimplify_va_arg_1 (type, base, offset, pre_p, post_p);\n+\n+  /* Stuff the offset temporary back into its field.  */\n+  t = build (MODIFY_EXPR, void_type_node, offset_field,\n+\t     fold_convert (TREE_TYPE (offset_field), offset));\n+  gimplify_and_add (t, pre_p);\n+}\n \f\n /* Builtins.  */\n \n@@ -10231,6 +10365,8 @@ alpha_init_libfuncs (void)\n #define TARGET_PRETEND_OUTGOING_VARARGS_NAMED hook_bool_CUMULATIVE_ARGS_true\n #undef TARGET_SPLIT_COMPLEX_ARG\n #define TARGET_SPLIT_COMPLEX_ARG alpha_split_complex_arg\n+#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n+#define TARGET_GIMPLIFY_VA_ARG_EXPR alpha_gimplify_va_arg\n \n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST alpha_build_builtin_va_list"}]}