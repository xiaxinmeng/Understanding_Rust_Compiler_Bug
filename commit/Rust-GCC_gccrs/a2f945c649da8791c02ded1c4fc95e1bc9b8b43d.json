{"sha": "a2f945c649da8791c02ded1c4fc95e1bc9b8b43d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJmOTQ1YzY0OWRhODc5MWMwMmRlZDFjNGZjOTVlMWJjOWI4YjQzZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@loony.cygnus.com", "date": "1999-10-15T07:50:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-15T07:50:25Z"}, "message": "Makefile.in (CFILES): Add hashtab.c\n\n\n        * Makefile.in (CFILES): Add hashtab.c\n        (REQUIRED_OFILES): Add hashtab.o\n        (hashtab.o): Add dependencies.\n        * hashtab.c: New file\n\nFrom-SVN: r30012", "tree": {"sha": "0c93b9af214a58650be03b22ab6902891328de33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c93b9af214a58650be03b22ab6902891328de33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d/comments", "author": null, "committer": null, "parents": [{"sha": "005a696e186eb2c953e1993fc17da5c32d5c3156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005a696e186eb2c953e1993fc17da5c32d5c3156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005a696e186eb2c953e1993fc17da5c32d5c3156"}], "stats": {"total": 305, "additions": 302, "deletions": 3}, "files": [{"sha": "167e4630318579f94fd50b2ce72ecc3b6e6a9077", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a2f945c649da8791c02ded1c4fc95e1bc9b8b43d", "patch": "@@ -1,3 +1,10 @@\n+Fri Oct 15 01:47:51 1999  Vladimir Makarov  <vmakarov@loony.cygnus.com>\n+\n+\t* Makefile.in (CFILES): Add hashtab.c\n+\t(REQUIRED_OFILES): Add hashtab.o\n+\t(hashtab.o): Add dependencies.\n+\t* hashtab.c: New file\n+\n Wed Oct 13 01:16:47 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \n \t* basename.c (DIR_SEPARATOR): New macro."}, {"sha": "a42ea625ce51a755324fac9d8679a38e66b5e002", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=a2f945c649da8791c02ded1c4fc95e1bc9b8b43d", "patch": "@@ -123,7 +123,7 @@ HFILES = alloca-conf.h\n CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c \\\n \tbzero.c calloc.c choose-temp.c clock.c concat.c cplus-dem.c fdmatch.c \\\n \tfnmatch.c getcwd.c getpwd.c getopt.c getopt1.c getpagesize.c \\\n-\tgetruntime.c floatformat.c hex.c index.c insque.c memchr.c \\\n+\tgetruntime.c floatformat.c hashtab.c hex.c index.c insque.c memchr.c \\\n \tmemcmp.c memcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c \\\n \tpexecute.c putenv.c random.c rename.c rindex.c setenv.c sigsetmask.c \\\n \tspaces.c splay-tree.c strcasecmp.c strncasecmp.c strchr.c strdup.c \\\n@@ -133,8 +133,8 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c \\\n \n # These are always included in the library.\n REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o \\\n-  fdmatch.o fnmatch.o getopt.o getopt1.o getpwd.o getruntime.o hex.o \\\n-  floatformat.o objalloc.o obstack.o pexecute.o spaces.o \\\n+  fdmatch.o fnmatch.o getopt.o getopt1.o getpwd.o getruntime.o hashtab.o \\\n+  hex.o floatformat.o objalloc.o obstack.o pexecute.o spaces.o \\\n   splay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o \\\n   xmemdup.o xstrdup.o xstrerror.o\n \n@@ -273,3 +273,4 @@ xmalloc.o: $(INCDIR)/libiberty.h\n xmemdup.o: config.h $(INCDIR)/libiberty.h\n xstrdup.o: config.h $(INCDIR)/libiberty.h\n xstrerror.o: config.h $(INCDIR)/libiberty.h\n+hashtab.o: config.h $(INCDIR)/libiberty.h $(INCDIR)/hashtab.h $(INCDIR)/ansidecl.h"}, {"sha": "8137d77bc4e2dab1a3a13614e24ffea463ccc0cf", "filename": "libiberty/hashtab.c", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2f945c649da8791c02ded1c4fc95e1bc9b8b43d/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=a2f945c649da8791c02ded1c4fc95e1bc9b8b43d", "patch": "@@ -0,0 +1,291 @@\n+/* An expandable hash tables datatype.  \n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If\n+not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* This package implements basic hash table functionality.  It is possible\n+   to search for an entry, create an entry and destroy an entry.\n+\n+   Elements in the table are generic pointers.\n+\n+   The size of the table is not fixed; if the occupancy of the table\n+   grows too high the hash table will be expanded.\n+\n+   The abstract data implementation is based on generalized Algorithm D\n+   from Knuth's book \"The art of computer programming\".  Hash table is\n+   expanded by creation of new hash table and transferring elements from\n+   the old table to the new table. */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#include \"libiberty.h\"\n+#include \"hashtab.h\"\n+\n+/* The following variable is used for debugging. Its value is number\n+   of all calls of `find_hash_table_entry' for all hash tables. */\n+\n+static int all_searches = 0;\n+\n+/* The following variable is used for debugging. Its value is number\n+   of collisions fixed for time of work with all hash tables. */\n+\n+static int all_collisions = 0;\n+\n+/* The following variable is used for debugging. Its value is number\n+   of all table expansions fixed for time of work with all hash\n+   tables. */\n+\n+static int all_expansions = 0;\n+\n+/* This macro defines reserved value for empty table entry. */\n+\n+#define EMPTY_ENTRY    NULL\n+\n+/* This macro defines reserved value for table entry which contained\n+   a deleted element. */\n+\n+#define DELETED_ENTRY  ((void *) 1)\n+\n+/* The following function returns the nearest prime number which is\n+   greater than given source number. */\n+\n+static unsigned long\n+higher_prime_number (number)\n+     unsigned long number;\n+{\n+  unsigned long i;\n+\n+  for (number = (number / 2) * 2 + 3;; number += 2)\n+    {\n+      for (i = 3; i * i <= number; i += 2)\n+        if (number % i == 0)\n+          break;\n+      if (i * i > number)\n+        return number;\n+    }\n+}\n+\n+/* This function creates table with length slightly longer than given\n+   source length.  Created hash table is initiated as empty (all the\n+   hash table entries are EMPTY_ENTRY).  The function returns the\n+   created hash table. */\n+\n+hash_table_t\n+create_hash_table (size, hash_function, eq_function)\n+     size_t size;\n+     unsigned (*hash_function) PARAMS ((hash_table_entry_t));\n+     int (*eq_function) PARAMS ((hash_table_entry_t, hash_table_entry_t));\n+{\n+  hash_table_t result;\n+\n+  size = higher_prime_number (size);\n+  result = (hash_table_t) xmalloc (sizeof (*result));\n+  result->entries\n+    = (hash_table_entry_t *) xmalloc (size * sizeof (hash_table_entry_t));\n+  result->size = size;\n+  result->hash_function = hash_function;\n+  result->eq_function = eq_function;\n+  result->number_of_elements = 0;\n+  result->number_of_deleted_elements = 0;\n+  result->searches = 0;\n+  result->collisions = 0;\n+  memset (result->entries, 0, size * sizeof (hash_table_entry_t));\n+  return result;\n+}\n+\n+/* This function frees all memory allocated for given hash table.\n+   Naturally the hash table must already exist. */\n+\n+void\n+delete_hash_table (htab)\n+     hash_table_t htab;\n+{\n+  free (htab->entries);\n+  free (htab);\n+}\n+\n+/* This function clears all entries in the given hash table.  */\n+\n+void\n+empty_hash_table (htab)\n+     hash_table_t htab;\n+{\n+  memset (htab->entries, 0, htab->size * sizeof (hash_table_entry_t));\n+}\n+\n+/* The following function changes size of memory allocated for the\n+   entries and repeatedly inserts the table elements.  The occupancy\n+   of the table after the call will be about 50%.  Naturally the hash\n+   table must already exist.  Remember also that the place of the\n+   table entries is changed. */\n+\n+static void\n+expand_hash_table (htab)\n+     hash_table_t htab;\n+{\n+  hash_table_t new_htab;\n+  hash_table_entry_t *entry_ptr;\n+  hash_table_entry_t *new_entry_ptr;\n+\n+  new_htab = create_hash_table (htab->number_of_elements * 2,\n+                                htab->hash_function, htab->eq_function);\n+  for (entry_ptr = htab->entries; entry_ptr < htab->entries + htab->size;\n+       entry_ptr++)\n+    if (*entry_ptr != EMPTY_ENTRY && *entry_ptr != DELETED_ENTRY)\n+      {\n+        new_entry_ptr = find_hash_table_entry (new_htab, *entry_ptr, 1);\n+        *new_entry_ptr = (*entry_ptr);\n+      }\n+  free (htab->entries);\n+  *htab = (*new_htab);\n+  free (new_htab);\n+}\n+\n+/* This function searches for hash table entry which contains element\n+   equal to given value or empty entry in which given value can be\n+   placed (if the element with given value does not exist in the\n+   table).  The function works in two regimes.  The first regime is\n+   used only for search.  The second is used for search and\n+   reservation empty entry for given value.  The table is expanded if\n+   occupancy (taking into accout also deleted elements) is more than\n+   75%.  Naturally the hash table must already exist.  If reservation\n+   flag is TRUE then the element with given value should be inserted\n+   into the table entry before another call of\n+   `find_hash_table_entry'. */\n+\n+hash_table_entry_t *\n+find_hash_table_entry (htab, element, reserve)\n+     hash_table_t htab;\n+     hash_table_entry_t element;\n+     int reserve;\n+{\n+  hash_table_entry_t *entry_ptr;\n+  hash_table_entry_t *first_deleted_entry_ptr;\n+  unsigned index, hash_value, secondary_hash_value;\n+\n+  if (htab->size * 3 <= htab->number_of_elements * 4)\n+    {\n+      all_expansions++;\n+      expand_hash_table (htab);\n+    }\n+  hash_value = (*htab->hash_function) (element);\n+  secondary_hash_value = 1 + hash_value % (htab->size - 2);\n+  index = hash_value % htab->size;\n+  htab->searches++;\n+  all_searches++;\n+  first_deleted_entry_ptr = NULL;\n+  for (;;htab->collisions++, all_collisions++)\n+    {\n+      entry_ptr = htab->entries + index;\n+      if (*entry_ptr == EMPTY_ENTRY)\n+        {\n+          if (reserve)\n+\t    {\n+\t      htab->number_of_elements++;\n+\t      if (first_deleted_entry_ptr != NULL)\n+\t\t{\n+\t\t  entry_ptr = first_deleted_entry_ptr;\n+\t\t  *entry_ptr = DELETED_ENTRY;\n+\t\t}\n+\t    }\n+          break;\n+        }\n+      else if (*entry_ptr != DELETED_ENTRY)\n+        {\n+          if ((*htab->eq_function) (*entry_ptr, element))\n+            break;\n+        }\n+      else if (first_deleted_entry_ptr == NULL)\n+\tfirst_deleted_entry_ptr = entry_ptr;\n+      index += secondary_hash_value;\n+      if (index >= htab->size)\n+        index -= htab->size;\n+    }\n+  return entry_ptr;\n+}\n+\n+/* This function deletes element with given value from hash table.\n+   The hash table entry value will be `DELETED_ENTRY' after the\n+   function call.  Naturally the hash table must already exist.  Hash\n+   table entry for given value should be not empty (or deleted). */\n+\n+void\n+remove_element_from_hash_table_entry (htab, element)\n+     hash_table_t htab;\n+     hash_table_entry_t element;\n+{\n+  hash_table_entry_t *entry_ptr;\n+\n+  entry_ptr = find_hash_table_entry (htab, element, 0);\n+  *entry_ptr = DELETED_ENTRY;\n+  htab->number_of_deleted_elements++;\n+}\n+\n+/* The following function returns current size of given hash table. */\n+\n+size_t\n+hash_table_size (htab)\n+     hash_table_t htab;\n+{\n+  return htab->size;\n+}\n+\n+/* The following function returns current number of elements in given\n+   hash table. */\n+\n+size_t\n+hash_table_elements_number (htab)\n+     hash_table_t htab;\n+{\n+  return htab->number_of_elements - htab->number_of_deleted_elements;\n+}\n+\n+/* The following function returns number of percents of fixed\n+   collisions during all work with given hash table. */\n+\n+int\n+hash_table_collisions (htab)\n+     hash_table_t htab;\n+{\n+  int searches;\n+\n+  searches = htab->searches;\n+  if (searches == 0)\n+    searches++;\n+  return htab->collisions * 100 / searches;\n+}\n+\n+/* The following function returns number of percents of fixed\n+   collisions during all work with all hash tables. */\n+\n+int\n+all_hash_table_collisions ()\n+{\n+  int searches;\n+\n+  searches = all_searches;\n+  if (searches == 0)\n+    searches++;\n+  return all_collisions * 100 / searches;\n+}"}]}