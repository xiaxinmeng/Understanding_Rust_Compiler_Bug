{"sha": "bf1b77dd092bb694be6fb0b1fcc369327db6143f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxYjc3ZGQwOTJiYjY5NGJlNmZiMGIxZmNjMzY5MzI3ZGI2MTQzZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-04-09T19:37:57Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-04-09T19:37:57Z"}, "message": "re PR fortran/56852 (ICE on invalid: \"Bad array reference\" for an undeclared loop variable)\n\n2013-04-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/56852\n\t* primary.c (gfc_variable_attr): Avoid ICE on AR_UNKNOWN if any\n\tof the index variables are untyped and errors are present.\n\n2013-04-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/56852\n\t* gfortran.dg/pr56852.f90 : New test\n\nFrom-SVN: r221955", "tree": {"sha": "4c453d0397ef71ae8bf5dd7ebf86b1a311c6f1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c453d0397ef71ae8bf5dd7ebf86b1a311c6f1a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf1b77dd092bb694be6fb0b1fcc369327db6143f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1b77dd092bb694be6fb0b1fcc369327db6143f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1b77dd092bb694be6fb0b1fcc369327db6143f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1b77dd092bb694be6fb0b1fcc369327db6143f/comments", "author": null, "committer": null, "parents": [{"sha": "86c5a5c3bba487a03c0288c912641275e3df812b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c5a5c3bba487a03c0288c912641275e3df812b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86c5a5c3bba487a03c0288c912641275e3df812b"}], "stats": {"total": 80, "additions": 60, "deletions": 20}, "files": [{"sha": "78305a0f7bd0d5ff20f2ce6347f31ebaf3aa0f7c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bf1b77dd092bb694be6fb0b1fcc369327db6143f", "patch": "@@ -1,3 +1,9 @@\n+2013-04-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/56852\n+\t* primary.c (gfc_variable_attr): Avoid ICE on AR_UNKNOWN if any\n+\tof the index variables are untyped and errors are present.\n+\n 2015-04-07  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/65548\n@@ -63,7 +69,7 @@\n \tthen, which calls ->vptr->copy () with four arguments adding\n \tthe length information ->vptr->copy(from, to, from_len, to_cap).\n \t(gfc_conv_procedure_call): Switch to new function name for\n-\tgetting a class' vtab's field. \n+\tgetting a class' vtab's field.\n \t(alloc_scalar_allocatable_for_assignment): Use the string_length\n \tas computed by gfc_conv_expr and not the statically backend_decl\n \twhich may be incorrect when ref-ing.\n@@ -88,7 +94,7 @@\n \tAdded gfc_find_and_cut_at_last_class_ref () and\n \tgfc_reset_len () routine prototype.  Added flag to\n \tgfc_copy_class_to_class () prototype to signal an unlimited\n-\tpolymorphic entity to copy.    \n+\tpolymorphic entity to copy.\n \n 2015-03-24  Iain Sandoe  <iain@codesourcery.com>\n \t    Tobias Burnus  <burnus@net-b.de>"}, {"sha": "e9ced7e6f718d9ea7a9eebab68a136c6a258b856", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=bf1b77dd092bb694be6fb0b1fcc369327db6143f", "patch": "@@ -143,8 +143,8 @@ gfc_check_digit (char c, int radix)\n \n \n /* Match the digit string part of an integer if signflag is not set,\n-   the signed digit string part if signflag is set.  If the buffer \n-   is NULL, we just count characters for the resolution pass.  Returns \n+   the signed digit string part if signflag is set.  If the buffer\n+   is NULL, we just count characters for the resolution pass.  Returns\n    the number of characters matched, -1 for no match.  */\n \n static int\n@@ -192,7 +192,7 @@ match_digits (int signflag, int radix, char *buffer)\n }\n \n \n-/* Match an integer (digit string and optional kind).  \n+/* Match an integer (digit string and optional kind).\n    A sign will be accepted if signflag is set.  */\n \n static match\n@@ -259,7 +259,7 @@ match_hollerith_constant (gfc_expr **result)\n   gfc_expr *e = NULL;\n   const char *msg;\n   int num, pad;\n-  int i;  \n+  int i;\n \n   old_loc = gfc_current_locus;\n   gfc_gobble_whitespace ();\n@@ -518,7 +518,7 @@ match_real_constant (gfc_expr **result, int signflag)\n \t  if (seen_dp)\n \t    goto done;\n \n-\t  /* Check to see if \".\" goes with a following operator like \n+\t  /* Check to see if \".\" goes with a following operator like\n \t     \".eq.\".  */\n \t  temp_loc = gfc_current_locus;\n \t  c = gfc_next_ascii_char ();\n@@ -1504,7 +1504,7 @@ match_actual_arg (gfc_expr **result)\n \n \t  if (sym->attr.in_common && !sym->attr.proc_pointer)\n \t    {\n-\t      if (!gfc_add_flavor (&sym->attr, FL_VARIABLE, \n+\t      if (!gfc_add_flavor (&sym->attr, FL_VARIABLE,\n \t\t\t\t   sym->name, &sym->declared_at))\n \t\treturn MATCH_ERROR;\n \t      break;\n@@ -2138,7 +2138,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n symbol_attribute\n gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n {\n-  int dimension, codimension, pointer, allocatable, target;\n+  int dimension, codimension, pointer, allocatable, target, n;\n   symbol_attribute attr;\n   gfc_ref *ref;\n   gfc_symbol *sym;\n@@ -2195,7 +2195,25 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \t    break;\n \n \t  case AR_UNKNOWN:\n-\t    gfc_internal_error (\"gfc_variable_attr(): Bad array reference\");\n+\t    /* If any of start, end or stride is not integer, there will\n+\t       already have been an error issued.  */\n+\t    for (n = 0; n < ref->u.ar.as->rank; n++)\n+\t      {\n+\t\tint errors;\n+\t\tgfc_get_errors (NULL, &errors);\n+\t\tif (((ref->u.ar.start[n]\n+\t\t      && ref->u.ar.start[n]->ts.type == BT_UNKNOWN)\n+\t\t     ||\n+\t\t     (ref->u.ar.end[n]\n+\t\t      && ref->u.ar.end[n]->ts.type == BT_UNKNOWN)\n+\t\t     ||\n+\t\t     (ref->u.ar.stride[n]\n+\t\t      && ref->u.ar.stride[n]->ts.type == BT_UNKNOWN))\n+\t\t    && errors > 0)\n+\t\t  break;\n+\t      }\n+\t    if (n == ref->u.ar.as->rank)\n+\t      gfc_internal_error (\"gfc_variable_attr(): Bad array reference\");\n \t  }\n \n \tbreak;\n@@ -2347,8 +2365,8 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t\t\t\t\t\t      &gfc_current_locus);\n \t  value->ts = comp->ts;\n \n-\t  if (!build_actual_constructor (comp_head, \n-\t\t\t\t\t &value->value.constructor, \n+\t  if (!build_actual_constructor (comp_head,\n+\t\t\t\t\t &value->value.constructor,\n \t\t\t\t\t comp->ts.u.derived))\n \t    {\n \t      gfc_free_expr (value);\n@@ -2500,7 +2518,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n       actual->expr = NULL;\n \n       /* Check if this component is already given a value.  */\n-      for (comp_iter = comp_head; comp_iter != comp_tail; \n+      for (comp_iter = comp_head; comp_iter != comp_tail;\n \t   comp_iter = comp_iter->next)\n \t{\n \t  gcc_assert (comp_iter);\n@@ -2597,13 +2615,13 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n       expr->expr_type = EXPR_STRUCTURE;\n     }\n \n-  gfc_current_locus = old_locus; \n+  gfc_current_locus = old_locus;\n   if (parent)\n     *arglist = actual;\n   return true;\n \n   cleanup:\n-  gfc_current_locus = old_locus; \n+  gfc_current_locus = old_locus;\n \n   for (comp_iter = comp_head; comp_iter; )\n     {\n@@ -2770,7 +2788,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t      || sym->ns == gfc_current_ns->parent))\n \t{\n \t  gfc_entry_list *el = NULL;\n-\t  \n+\n \t  for (el = sym->ns->entries; el; el = el->next)\n \t    if (sym == el->sym)\n \t      goto variable;\n@@ -2800,7 +2818,7 @@ gfc_match_rvalue (gfc_expr **result)\n \n     case FL_PARAMETER:\n       /* A statement of the form \"REAL, parameter :: a(0:10) = 1\" will\n-\t end up here.  Unfortunately, sym->value->expr_type is set to \n+\t end up here.  Unfortunately, sym->value->expr_type is set to\n \t EXPR_CONSTANT, and so the if () branch would be followed without\n \t the !sym->as check.  */\n       if (sym->value && sym->value->expr_type != EXPR_ARRAY && !sym->as)\n@@ -3058,7 +3076,7 @@ gfc_match_rvalue (gfc_expr **result)\n       if (m2 != MATCH_YES)\n \t{\n \t  /* Try to figure out whether we're dealing with a character type.\n-\t     We're peeking ahead here, because we don't want to call \n+\t     We're peeking ahead here, because we don't want to call\n \t     match_substring if we're dealing with an implicitly typed\n \t     non-character variable.  */\n \t  implicit_char = false;\n@@ -3079,7 +3097,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t      e->expr_type = EXPR_VARIABLE;\n \n \t      if (sym->attr.flavor != FL_VARIABLE\n-\t\t  && !gfc_add_flavor (&sym->attr, FL_VARIABLE, \n+\t\t  && !gfc_add_flavor (&sym->attr, FL_VARIABLE,\n \t\t\t\t      sym->name, NULL))\n \t\t{\n \t\t  m = MATCH_ERROR;\n@@ -3300,7 +3318,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \timplicit_ns = gfc_current_ns;\n       else\n \timplicit_ns = sym->ns;\n-\t\n+\n       if (gfc_peek_ascii_char () == '%'\n \t  && sym->ts.type == BT_UNKNOWN\n \t  && gfc_get_default_type (sym->name, implicit_ns)->type == BT_DERIVED)"}, {"sha": "da590b1a389c353257ee668a4258158ffbd65873", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bf1b77dd092bb694be6fb0b1fcc369327db6143f", "patch": "@@ -1,3 +1,8 @@\n+2013-04-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/56852\n+\t* gfortran.dg/pr56852.f90 : New test\n+\n 2015-04-09  Marek Polacek  <polacek@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "bdf76e1f52187b298d8c033f2089c3f02b09e0c0", "filename": "gcc/testsuite/gfortran.dg/pr56852.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr56852.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1b77dd092bb694be6fb0b1fcc369327db6143f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr56852.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr56852.f90?ref=bf1b77dd092bb694be6fb0b1fcc369327db6143f", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! Test the fix for pr56852, where an ICE would occur after the error.\n+!\n+! Contributed by Lorenz Huedepohl  <bugs@stellardeath.org>\n+!\n+program test\n+  implicit none\n+  real :: a(4)\n+  ! integer :: i\n+  read(0) (a(i),i=1,4) ! { dg-error \"has no IMPLICIT type\" }\n+end program"}]}