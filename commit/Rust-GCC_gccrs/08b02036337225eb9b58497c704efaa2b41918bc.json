{"sha": "08b02036337225eb9b58497c704efaa2b41918bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhiMDIwMzYzMzcyMjVlYjliNTg0OTdjNzA0ZWZhYTJiNDE5MThiYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-14T06:13:19Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-14T06:13:19Z"}, "message": "re PR fortran/42481 (generic interface not recognized)\n\n2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42481\n\t* module.c (load_generic_interfaces): If a procedure that is\n\tuse associated but not generic is given an interface that\n\tincludes itself, then make it generic.\n\n2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42481\n\t* gfortran.dg/generic_19.f90 : New test.\n\nFrom-SVN: r155876", "tree": {"sha": "b784fe3aae3d08f0f6aa9bcc21ba10aa55db0bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b784fe3aae3d08f0f6aa9bcc21ba10aa55db0bb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08b02036337225eb9b58497c704efaa2b41918bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b02036337225eb9b58497c704efaa2b41918bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b02036337225eb9b58497c704efaa2b41918bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b02036337225eb9b58497c704efaa2b41918bc/comments", "author": null, "committer": null, "parents": [{"sha": "671ec5cbcf803430be2036af48e60bda961681f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671ec5cbcf803430be2036af48e60bda961681f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671ec5cbcf803430be2036af48e60bda961681f8"}], "stats": {"total": 81, "additions": 78, "deletions": 3}, "files": [{"sha": "be65b9ab58e4a848045ee1ac421995d9dcf291b7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=08b02036337225eb9b58497c704efaa2b41918bc", "patch": "@@ -1,3 +1,10 @@\n+2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42481\n+\t* module.c (load_generic_interfaces): If a procedure that is\n+\tuse associated but not generic is given an interface that\n+\tincludes itself, then make it generic.\n+\n 2010-01-11  Joseph Myers  <joseph@codesourcery.com>  \n \t    Shujing Zhao  <pearly.zhao@oracle.com>\n "}, {"sha": "667bab83c49712f29ec8058aeab0a61df6a75028", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=08b02036337225eb9b58497c704efaa2b41918bc", "patch": "@@ -1,6 +1,7 @@\n /* Handle modules, which amounts to loading and saving symbols and\n    their attendant structures.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -3750,8 +3751,9 @@ load_generic_interfaces (void)\n   const char *p;\n   char name[GFC_MAX_SYMBOL_LEN + 1], module[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n-  gfc_interface *generic = NULL;\n+  gfc_interface *generic = NULL, *gen = NULL;\n   int n, i, renamed;\n+  bool ambiguous_set = false;\n \n   mio_lparen ();\n \n@@ -3836,9 +3838,13 @@ load_generic_interfaces (void)\n \t      sym = st->n.sym;\n \n \t      if (st && !sym->attr.generic\n+\t\t     && !st->ambiguous\n \t\t     && sym->module\n \t\t     && strcmp(module, sym->module))\n-\t\tst->ambiguous = 1;\n+\t\t{\n+\t\t  ambiguous_set = true;\n+\t\t  st->ambiguous = 1;\n+\t\t}\n \t    }\n \n \t  sym->attr.use_only = only_flag;\n@@ -3854,6 +3860,26 @@ load_generic_interfaces (void)\n \t      sym->generic = generic;\n \t      sym->attr.generic_copy = 1;\n \t    }\n+\n+\t  /* If a procedure that is not generic has generic interfaces\n+\t     that include itself, it is generic! We need to take care\n+\t     to retain symbols ambiguous that were already so.  */\n+\t  if (sym->attr.use_assoc\n+\t\t&& !sym->attr.generic\n+\t\t&& sym->attr.flavor == FL_PROCEDURE)\n+\t    {\n+\t      for (gen = generic; gen; gen = gen->next)\n+\t\t{\n+\t\t  if (gen->sym == sym)\n+\t\t    {\n+\t\t      sym->attr.generic = 1;\n+\t\t      if (ambiguous_set)\n+\t\t        st->ambiguous = 0;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t}\n     }\n "}, {"sha": "2195d2e35ea7778d44bb57342c242717261a117e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08b02036337225eb9b58497c704efaa2b41918bc", "patch": "@@ -1,3 +1,8 @@\n+2010-01-14  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42481\n+\t* gfortran.dg/generic_19.f90 : New test.\n+\n 2010-01-13  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/42730"}, {"sha": "f023c5e63565acfd471a0066544b8569167b2805", "filename": "gcc/testsuite/gfortran.dg/generic_19.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b02036337225eb9b58497c704efaa2b41918bc/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_19.f90?ref=08b02036337225eb9b58497c704efaa2b41918bc", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! Test the fix for PR42481, in which 'sub' was not recognised as\n+! a generic interface.\n+!\n+! Contributed by William Mitchell < william.mitchell@nist.gov>\n+!\n+module mod1\n+contains\n+  subroutine sub(x, chr)\n+    real x\n+    character(8) chr\n+    if (trim (chr) .ne. \"real\") call abort\n+    if (int (x) .ne. 1) call abort\n+  end subroutine sub\n+end module mod1\n+\n+module mod2\n+  use mod1\n+  interface sub\n+    module procedure sub, sub_int\n+  end interface sub\n+contains\n+  subroutine sub_int(i, chr)\n+    character(8) chr\n+    integer i\n+    if (trim (chr) .ne. \"integer\") call abort\n+    if (i .ne. 1) call abort\n+  end subroutine sub_int\n+end module mod2\n+\n+program prog\n+  use mod1\n+  use mod2\n+  call sub(1, \"integer \")\n+  call sub(1.0, \"real    \")\n+end program prog\n+! { dg-final { cleanup-modules \"mod1 mod2\" } }"}]}