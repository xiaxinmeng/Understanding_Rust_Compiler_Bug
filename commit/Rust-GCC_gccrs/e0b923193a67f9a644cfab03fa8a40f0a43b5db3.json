{"sha": "e0b923193a67f9a644cfab03fa8a40f0a43b5db3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBiOTIzMTkzYTY3ZjlhNjQ0Y2ZhYjAzZmE4YTQwZjBhNDNiNWRiMw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2005-10-10T07:57:21Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2005-10-10T07:57:21Z"}, "message": "arm.c: Remove extraneous whitespace.\n\n* config/arm/arm.c: Remove extraneous whitespace.  Remove comment describing\n  the deleted arm_gen_rotated_half_load function.\n\nFrom-SVN: r105169", "tree": {"sha": "59cd9a796fd1c824184f8a51542a73cf21a40309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59cd9a796fd1c824184f8a51542a73cf21a40309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0b923193a67f9a644cfab03fa8a40f0a43b5db3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b923193a67f9a644cfab03fa8a40f0a43b5db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b923193a67f9a644cfab03fa8a40f0a43b5db3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b923193a67f9a644cfab03fa8a40f0a43b5db3/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5f5c6be7f24f51801ea13692e541aba3a34fac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f5c6be7f24f51801ea13692e541aba3a34fac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5f5c6be7f24f51801ea13692e541aba3a34fac8"}], "stats": {"total": 118, "additions": 57, "deletions": 61}, "files": [{"sha": "2ea73961926be52ddccffa0f9cad940e294381bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0b923193a67f9a644cfab03fa8a40f0a43b5db3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0b923193a67f9a644cfab03fa8a40f0a43b5db3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0b923193a67f9a644cfab03fa8a40f0a43b5db3", "patch": "@@ -1,3 +1,8 @@\n+2005-10-10  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/arm/arm.c: Remove extraneous whitespace.  Remove comment\n+\tdescribing the deleted arm_gen_rotated_half_load function.\n+\n 2005-10-09  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (emit_fpu_switch): Set TREE_PUBLIC for"}, {"sha": "1bb6149c568bff620dc00bd72c6f5b39c419a602", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0b923193a67f9a644cfab03fa8a40f0a43b5db3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0b923193a67f9a644cfab03fa8a40f0a43b5db3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e0b923193a67f9a644cfab03fa8a40f0a43b5db3", "patch": "@@ -481,7 +481,7 @@ int arm_arch_xscale = 0;\n /* Nonzero if tuning for XScale  */\n int arm_tune_xscale = 0;\n \n-/* Nonzero if we want to tune for stores that access the write-buffer. \n+/* Nonzero if we want to tune for stores that access the write-buffer.\n    This typically means an ARM6 or ARM7 with MMU or MPU.  */\n int arm_tune_wbuf = 0;\n \n@@ -867,7 +867,7 @@ arm_override_options (void)\n \t\t   options.  */\n \t\tif (i == ARM_OPT_SET_ARCH)\n \t\t  target_arch_cpu = sel->core;\n-\t\t\n+\n \t\tif (i != ARM_OPT_SET_TUNE)\n \t\t  {\n \t\t    /* If we have been given an architecture and a processor\n@@ -1514,7 +1514,7 @@ int\n const_ok_for_arm (HOST_WIDE_INT i)\n {\n   int lowbit;\n-  \n+\n   /* For machines with >32 bit HOST_WIDE_INT, the bits above bit 31 must\n      be all zero, or all one.  */\n   if ((i & ~(unsigned HOST_WIDE_INT) 0xffffffff) != 0\n@@ -1524,7 +1524,7 @@ const_ok_for_arm (HOST_WIDE_INT i)\n     return FALSE;\n \n   i &= (unsigned HOST_WIDE_INT) 0xffffffff;\n-  \n+\n   /* Fast return for 0 and small values.  We must do this for zero, since\n      the code below can't handle that one case.  */\n   if ((i & ~(unsigned HOST_WIDE_INT) 0xff) == 0)\n@@ -1766,10 +1766,10 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t\t\t\tgen_rtx_SET (VOIDmode, target, source));\n \t  return 1;\n \t}\n-      \n+\n       /* We don't know how to handle other cases yet.  */\n       gcc_assert (remainder == 0xffffffff);\n-      \n+\n       if (generate)\n \temit_constant_insn (cond,\n \t\t\t    gen_rtx_SET (VOIDmode, target,\n@@ -1913,7 +1913,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t    temp1 = 0x80000000 >> (topshift - 1);\n \n \t  temp2 = ARM_SIGN_EXTEND (temp1 - remainder);\n-\t  \n+\n \t  if (const_ok_for_arm (temp2))\n \t    {\n \t      if (generate)\n@@ -2416,11 +2416,11 @@ arm_function_value(tree type, tree func ATTRIBUTE_UNUSED)\n \t  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n \t}\n     }\n-  \n+\n   return LIBCALL_VALUE(mode);\n }\n \n-/* Determine the amount of memory needed to store the possible return \n+/* Determine the amount of memory needed to store the possible return\n    registers of an untyped call.  */\n int\n arm_apply_result_size (void)\n@@ -2870,10 +2870,10 @@ arm_handle_isr_attribute (tree *node, tree name, tree args, int flags,\n    attribute.  */\n \n static tree\n-arm_handle_notshared_attribute (tree *node, \n-\t\t\t\ttree name ATTRIBUTE_UNUSED, \n-\t\t\t\ttree args ATTRIBUTE_UNUSED, \n-\t\t\t\tint flags ATTRIBUTE_UNUSED, \n+arm_handle_notshared_attribute (tree *node,\n+\t\t\t\ttree name ATTRIBUTE_UNUSED,\n+\t\t\t\ttree args ATTRIBUTE_UNUSED,\n+\t\t\t\tint flags ATTRIBUTE_UNUSED,\n \t\t\t\tbool *no_add_attrs)\n {\n   tree decl = TYPE_NAME (*node);\n@@ -3189,7 +3189,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t}\n \n       gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n-      \n+\n       base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n       offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n \t\t\t\t       base == reg ? 0 : reg);\n@@ -3266,7 +3266,7 @@ thumb_find_work_register (unsigned long pushed_regs_mask)\n       && current_function_args_size <= (LAST_ARG_REGNUM * UNITS_PER_WORD)\n       && cfun->args_info.nregs < 4)\n     return LAST_ARG_REGNUM;\n-  \n+\n   /* Otherwise look for a call-saved register that is going to be pushed.  */\n   for (reg = LAST_LO_REGNUM; reg > LAST_ARG_REGNUM; reg --)\n     if (pushed_regs_mask & (1 << reg))\n@@ -3866,13 +3866,13 @@ thumb_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n }\n \n rtx\n-thumb_legitimize_reload_address(rtx *x_p,\n-\t\t\t\tenum machine_mode mode,\n-\t\t\t\tint opnum, int type,\n-\t\t\t\tint ind_levels ATTRIBUTE_UNUSED)\n+thumb_legitimize_reload_address (rtx *x_p,\n+\t\t\t\t enum machine_mode mode,\n+\t\t\t\t int opnum, int type,\n+\t\t\t\t int ind_levels ATTRIBUTE_UNUSED)\n {\n   rtx x = *x_p;\n-  \n+\n   if (GET_CODE (x) == PLUS\n       && GET_MODE_SIZE (mode) < 4\n       && REG_P (XEXP (x, 0))\n@@ -3907,9 +3907,7 @@ thumb_legitimize_reload_address(rtx *x_p,\n \n   return NULL;\n }\n-\n \f\n-\n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\\n   (GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n    || (GET_CODE (X) == SUBREG && GET_CODE (SUBREG_REG (X)) == REG))\n@@ -6114,10 +6112,6 @@ arm_gen_movmemqi (rtx *operands)\n   return 1;\n }\n \n-/* Generate a memory reference for a half word, such that it will be loaded\n-   into the top 16 bits of the word.  We can assume that the address is\n-   known to be alignable and of the form reg, or plus (reg, const).  */\n-\n /* Select a dominance comparison mode if possible for a test of the general\n    form (OP (COND_OR (X) (Y)) (const_int 0)).  We support three forms.\n    COND_OR == DOM_CC_X_AND_Y => (X && Y)\n@@ -6181,7 +6175,7 @@ arm_select_dominance_cc_mode (rtx x, rtx y, HOST_WIDE_INT cond_or)\n     case LT:\n       if (cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DLTmode;\n-      \n+\n       switch (cond2)\n \t{\n \tcase  LT:\n@@ -6229,7 +6223,7 @@ arm_select_dominance_cc_mode (rtx x, rtx y, HOST_WIDE_INT cond_or)\n     case GTU:\n       if (cond_or == DOM_CC_X_AND_Y)\n \treturn CC_DGTUmode;\n-      \n+\n       switch (cond2)\n \t{\n \tcase GTU:\n@@ -6749,7 +6743,6 @@ arm_pad_reg_upward (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return !BYTES_BIG_ENDIAN;\n }\n \n-\n \f\n /* Print a symbolic form of X to the debug file, F.  */\n static void\n@@ -7656,17 +7649,17 @@ arm_const_double_inline_cost (rtx val)\n {\n   rtx lowpart, highpart;\n   enum machine_mode mode;\n-  \n+\n   mode = GET_MODE (val);\n \n   if (mode == VOIDmode)\n     mode = DImode;\n \n   gcc_assert (GET_MODE_SIZE (mode) == 8);\n-  \n+\n   lowpart = gen_lowpart (SImode, val);\n   highpart = gen_highpart_mode (SImode, mode, val);\n-  \n+\n   gcc_assert (GET_CODE (lowpart) == CONST_INT);\n   gcc_assert (GET_CODE (highpart) == CONST_INT);\n \n@@ -7691,23 +7684,23 @@ arm_const_double_by_parts (rtx val)\n \n   if (mode == VOIDmode)\n     mode = DImode;\n-  \n+\n   part = gen_highpart_mode (SImode, mode, val);\n-  \n+\n   gcc_assert (GET_CODE (part) == CONST_INT);\n-  \n+\n   if (const_ok_for_arm (INTVAL (part))\n       || const_ok_for_arm (~INTVAL (part)))\n     return true;\n-  \n+\n   part = gen_lowpart (SImode, val);\n-  \n+\n   gcc_assert (GET_CODE (part) == CONST_INT);\n-  \n+\n   if (const_ok_for_arm (INTVAL (part))\n       || const_ok_for_arm (~INTVAL (part)))\n     return true;\n-  \n+\n   return false;\n }\n \n@@ -8344,31 +8337,31 @@ output_move_double (rtx *operands)\n \tcase REG:\n \t  output_asm_insn (\"ldm%?ia\\t%m1, %M0\", operands);\n \t  break;\n-\t  \n+\n \tcase PRE_INC:\n \t  gcc_assert (TARGET_LDRD);\n \t  output_asm_insn (\"ldr%?d\\t%0, [%m1, #8]!\", operands);\n \t  break;\n-\t  \n+\n \tcase PRE_DEC:\n \t  output_asm_insn (\"ldm%?db\\t%m1!, %M0\", operands);\n \t  break;\n-\t  \n+\n \tcase POST_INC:\n \t  output_asm_insn (\"ldm%?ia\\t%m1!, %M0\", operands);\n \t  break;\n-\t  \n+\n \tcase POST_DEC:\n \t  gcc_assert (TARGET_LDRD);\n \t  output_asm_insn (\"ldr%?d\\t%0, [%m1], #-8\", operands);\n \t  break;\n-\t  \n+\n \tcase PRE_MODIFY:\n \tcase POST_MODIFY:\n \t  otherops[0] = operands[0];\n \t  otherops[1] = XEXP (XEXP (XEXP (operands[1], 0), 1), 0);\n \t  otherops[2] = XEXP (XEXP (XEXP (operands[1], 0), 1), 1);\n-\t  \n+\n \t  if (GET_CODE (XEXP (operands[1], 0)) == PRE_MODIFY)\n \t    {\n \t      if (reg_overlap_mentioned_p (otherops[0], otherops[2]))\n@@ -8386,21 +8379,21 @@ output_move_double (rtx *operands)\n \t      output_asm_insn (\"ldr%?d\\t%0, [%1], %2\", otherops);\n \t    }\n \t  break;\n-\t  \n+\n \tcase LABEL_REF:\n \tcase CONST:\n \t  output_asm_insn (\"adr%?\\t%0, %1\", operands);\n \t  output_asm_insn (\"ldm%?ia\\t%0, %M0\", operands);\n \t  break;\n-\t  \n+\n \tdefault:\n \t  if (arm_add_operand (XEXP (XEXP (operands[1], 0), 1),\n \t\t\t       GET_MODE (XEXP (XEXP (operands[1], 0), 1))))\n \t    {\n \t      otherops[0] = operands[0];\n \t      otherops[1] = XEXP (XEXP (operands[1], 0), 0);\n \t      otherops[2] = XEXP (XEXP (operands[1], 0), 1);\n-\t      \n+\n \t      if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n \t\t{\n \t\t  if (GET_CODE (otherops[2]) == CONST_INT)\n@@ -8431,7 +8424,6 @@ output_move_double (rtx *operands)\n \t\t\t     avoid a conflict.  */\n \t\t\t  otherops[1] = XEXP (XEXP (operands[1], 0), 1);\n \t\t\t  otherops[2] = XEXP (XEXP (operands[1], 0), 0);\n-\t\t\t  \n \t\t\t}\n \t\t      /* If both registers conflict, it will usually\n \t\t\t have been fixed by a splitter.  */\n@@ -8445,7 +8437,7 @@ output_move_double (rtx *operands)\n \t\t\toutput_asm_insn (\"ldr%?d\\t%0, [%1, %2]\", otherops);\n \t\t      return \"\";\n \t\t    }\n-\t\t  \n+\n \t\t  if (GET_CODE (otherops[2]) == CONST_INT)\n \t\t    {\n \t\t      if (!(const_ok_for_arm (INTVAL (otherops[2]))))\n@@ -8865,7 +8857,7 @@ arm_compute_save_reg0_reg12_mask (void)\n       /* If we aren't loading the PIC register,\n \t don't stack it even though it may be live.  */\n       if (flag_pic\n-\t  && !TARGET_SINGLE_PIC_BASE \n+\t  && !TARGET_SINGLE_PIC_BASE\n \t  && (regs_ever_live[PIC_OFFSET_TABLE_REGNUM]\n \t      || current_function_uses_pic_offset_table))\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n@@ -11428,7 +11420,7 @@ arm_final_prescan_insn (rtx insn)\n \t  else\n \t    {\n \t      gcc_assert (seeking_return || arm_ccfsm_state == 2);\n-\t      \n+\n \t      while (this_insn && GET_CODE (PATTERN (this_insn)) == USE)\n \t        {\n \t\t  this_insn = next_nonnote_insn (this_insn);\n@@ -13345,7 +13337,7 @@ thumb_expand_prologue (void)\n   if (frame_pointer_needed)\n     {\n       amount = offsets->outgoing_args - offsets->locals_base;\n-      \n+\n       if (amount < 1024)\n \tinsn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n \t\t\t\t      stack_pointer_rtx, GEN_INT (amount)));\n@@ -13398,7 +13390,7 @@ thumb_expand_epilogue (void)\n       emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));\n       amount = offsets->locals_base - offsets->saved_regs;\n     }\n-  \n+\n   if (amount)\n     {\n       if (amount < 512)\n@@ -13697,7 +13689,7 @@ thumb_load_double_from_address (rtx *operands)\n     {\n     case REG:\n       operands[2] = adjust_address (operands[1], SImode, 4);\n-      \n+\n       if (REGNO (operands[0]) == REGNO (addr))\n \t{\n \t  output_asm_insn (\"ldr\\t%H0, %2\", operands);\n@@ -13713,7 +13705,7 @@ thumb_load_double_from_address (rtx *operands)\n     case CONST:\n       /* Compute <address> + 4 for the high order load.  */\n       operands[2] = adjust_address (operands[1], SImode, 4);\n-      \n+\n       output_asm_insn (\"ldr\\t%0, %1\", operands);\n       output_asm_insn (\"ldr\\t%H0, %2\", operands);\n       break;\n@@ -13755,7 +13747,6 @@ thumb_load_double_from_address (rtx *operands)\n \t{\n \t  /* Compute <address> + 4 for the high order load.  */\n \t  operands[2] = adjust_address (operands[1], SImode, 4);\n-\t  \n \n \t  /* If the computed address is held in the low order register\n \t     then load the high order register first, otherwise always\n@@ -14616,7 +14607,7 @@ arm_cxx_determine_class_data_visibility (tree decl)\n     DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n   DECL_VISIBILITY_SPECIFIED (decl) = 1;\n }\n-  \n+\n static bool\n arm_cxx_class_data_always_comdat (void)\n {\n@@ -14851,11 +14842,11 @@ arm_unwind_emit_stm (FILE * asm_out_file, rtx p)\n \t  || GET_CODE (XEXP (e, 0)) != MEM\n \t  || GET_CODE (XEXP (e, 1)) != REG)\n \tabort ();\n-      \n+\n       reg = REGNO (XEXP (e, 1));\n       if (reg < lastreg)\n \tabort ();\n-\t  \n+\n       if (i != 1)\n \tfprintf (asm_out_file, \", \");\n       /* We can't use %r for vfp because we need to use the\n@@ -14930,7 +14921,7 @@ arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n \t{\n \t  HOST_WIDE_INT offset;\n \t  unsigned reg;\n-\t  \n+\n \t  if (GET_CODE (e1) == PLUS)\n \t    {\n \t      if (GET_CODE (XEXP (e1, 0)) != REG"}]}