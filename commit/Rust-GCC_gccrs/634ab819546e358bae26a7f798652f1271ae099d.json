{"sha": "634ab819546e358bae26a7f798652f1271ae099d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM0YWI4MTk1NDZlMzU4YmFlMjZhN2Y3OTg2NTJmMTI3MWFlMDk5ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-09T22:53:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-09T22:53:00Z"}, "message": "cgraph.c (cgraph_resolve_speculation): Cut frequency to CGRAPH_FREQ_MAX.\n\n\t* cgraph.c (cgraph_resolve_speculation): Cut frequency to\n\tCGRAPH_FREQ_MAX.\n\t(dump_cgraph_node): Dump profile-id.\n\t* cgraph.h (cgraph_indirect_call_info): Add common_target_id\n\tand common_target_probability.\n\t* lto-cgraph.c (lto_output_edge): Stream common targets.\n\t(lto_output_node): Stream profile ids.\n\t(input_node): Stream profile ids.\n\t(input_edge): Stream common targets.\n\t* lto-streamer-in.c (fixup_call_stmt_edges_1): Fix formatting.\n\t* ipa.c: Include value-prof.h\n\t(ipa_profile_generate_summary): Turn indirect call statement histograms\n\tinto common targets.\n\t(ipa_profile): Turn common targets into speculative edges.\n\n\t* gcc.dg/tree-prof/crossmodule-indircall-1.c: New testcase.\n\t* gcc.dg/tree-prof/crossmodule-indircall-1a.c: New testcase.\n\nFrom-SVN: r201639", "tree": {"sha": "8a4fa2cb049df6b6085971ee7b7c3615601cc693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4fa2cb049df6b6085971ee7b7c3615601cc693"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/634ab819546e358bae26a7f798652f1271ae099d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634ab819546e358bae26a7f798652f1271ae099d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634ab819546e358bae26a7f798652f1271ae099d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634ab819546e358bae26a7f798652f1271ae099d/comments", "author": null, "committer": null, "parents": [{"sha": "537a6f7b4752b04a5ce4cb1fb96f1f1e9c407402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537a6f7b4752b04a5ce4cb1fb96f1f1e9c407402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/537a6f7b4752b04a5ce4cb1fb96f1f1e9c407402"}], "stats": {"total": 195, "additions": 189, "deletions": 6}, "files": [{"sha": "83b73b72c25040c5e6d63462e1606e13e52c0620", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -1,3 +1,20 @@\n+2013-08-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_resolve_speculation): Cut frequency to\n+\tCGRAPH_FREQ_MAX.\n+\t(dump_cgraph_node): Dump profile-id.\n+\t* cgraph.h (cgraph_indirect_call_info): Add common_target_id\n+\tand common_target_probability.\n+\t* lto-cgraph.c (lto_output_edge): Stream common targets.\n+\t(lto_output_node): Stream profile ids.\n+\t(input_node): Stream profile ids.\n+\t(input_edge): Stream common targets.\n+\t* lto-streamer-in.c (fixup_call_stmt_edges_1): Fix formatting.\n+\t* ipa.c: Include value-prof.h\n+\t(ipa_profile_generate_summary): Turn indirect call statement histograms\n+\tinto common targets.\n+\t(ipa_profile): Turn common targets into speculative edges.\n+\n 2013-08-09  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (cgraph_node): Add profile_id."}, {"sha": "b3b9e25862876bdbe83ecdc396da6c5626e571ec", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -1176,6 +1176,8 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n     }\n   edge->count += e2->count;\n   edge->frequency += e2->frequency;\n+  if (edge->frequency > CGRAPH_FREQ_MAX)\n+    edge->frequency = CGRAPH_FREQ_MAX;\n   edge->speculative = false;\n   e2->speculative = false;\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n@@ -1801,6 +1803,9 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \"  Availability: %s\\n\",\n \t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n \n+  if (node->profile_id)\n+    fprintf (f, \"  Profile id: %i\\n\",\n+\t     node->profile_id);\n   fprintf (f, \"  Function flags:\");\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\","}, {"sha": "e430533338302f366f571228f4323c8644455c2c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -435,6 +435,10 @@ struct GTY(()) cgraph_indirect_call_info\n   int param_index;\n   /* ECF flags determined from the caller.  */\n   int ecf_flags;\n+  /* Profile_id of common target obtrained from profile.  */\n+  int common_target_id;\n+  /* Probability that call will land in function with COMMON_TARGET_ID.  */\n+  int common_target_probability;\n \n   /* Set when the call is a virtual call with the parameter being the\n      associated object pointer rather than a simple direct call.  */"}, {"sha": "c870a6f067849073b7819a232924c482e2b36e9f", "filename": "gcc/ipa.c", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"lto-streamer.h\"\n #include \"data-streamer.h\"\n+#include \"value-prof.h\"\n \n /* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n \n@@ -1291,8 +1292,40 @@ ipa_profile_generate_summary (void)\n \tint size = 0;\n         for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t  {\n-\t    time += estimate_num_insns (gsi_stmt (gsi), &eni_time_weights);\n-\t    size += estimate_num_insns (gsi_stmt (gsi), &eni_size_weights);\n+\t    gimple stmt = gsi_stmt (gsi);\n+\t    if (gimple_code (stmt) == GIMPLE_CALL\n+\t\t&& !gimple_call_fndecl (stmt))\n+\t      {\n+\t\thistogram_value h;\n+\t\th = gimple_histogram_value_of_type\n+\t\t      (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t\t       stmt, HIST_TYPE_INDIR_CALL);\n+\t\t/* No need to do sanity check: gimple_ic_transform already\n+\t\t   takes away bad histograms.  */\n+\t\tif (h)\n+\t\t  {\n+\t\t    /* counter 0 is target, counter 1 is number of execution we called target,\n+\t\t       counter 2 is total number of executions.  */\n+\t\t    if (h->hvalue.counters[2])\n+\t\t      {\n+\t\t\tstruct cgraph_edge * e = cgraph_edge (node, stmt);\n+\t\t\te->indirect_info->common_target_id\n+\t\t\t  = h->hvalue.counters [0];\n+\t\t\te->indirect_info->common_target_probability\n+\t\t\t  = GCOV_COMPUTE_SCALE (h->hvalue.counters [1], h->hvalue.counters [2]);\n+\t\t\tif (e->indirect_info->common_target_probability > REG_BR_PROB_BASE)\n+\t\t\t  {\n+\t\t\t    if (dump_file)\n+\t\t\t      fprintf (dump_file, \"Probability capped to 1\\n\");\n+\t\t\t    e->indirect_info->common_target_probability = REG_BR_PROB_BASE;\n+\t\t\t  }\n+\t\t      }\n+\t\t    gimple_remove_histogram_value (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t\t\t\t\t\t    stmt, h);\n+\t\t  }\n+\t      }\n+\t    time += estimate_num_insns (stmt, &eni_time_weights);\n+\t    size += estimate_num_insns (stmt, &eni_size_weights);\n \t  }\n \taccount_time_size (hashtable, histogram, bb->count, time, size);\n       }\n@@ -1375,6 +1408,53 @@ ipa_profile (void)\n   int i;\n   gcov_type overall_time = 0, cutoff = 0, cumulated = 0, overall_size = 0;\n \n+  /* Produce speculative calls: we saved common traget from porfiling into\n+     e->common_target_id.  Now, at link time, we can look up corresponding\n+     function node and produce speculative call.  */\n+  if (in_lto_p)\n+    {\n+      struct cgraph_edge *e;\n+      struct cgraph_node *n,*n2;\n+\n+      init_node_map (false);\n+      FOR_EACH_DEFINED_FUNCTION (n)\n+\t{\n+\t  bool update = false;\n+\n+\t  for (e = n->indirect_calls; e; e = e->next_callee)\n+\t    if (e->indirect_info->common_target_id)\n+\t      {\n+\t\tn2 = find_func_by_profile_id (e->indirect_info->common_target_id);\n+\t\tif (n2)\n+\t\t  {\n+\t\t    if (dump_file)\n+\t\t      {\n+\t\t\tfprintf (dump_file, \"Indirect call -> direct call from\"\n+\t\t\t\t \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n+\t\t\t\t xstrdup (cgraph_node_name (n)), n->symbol.order,\n+\t\t\t\t xstrdup (cgraph_node_name (n2)), n2->symbol.order,\n+\t\t\t\t e->indirect_info->common_target_probability\n+\t\t\t\t / (float)REG_BR_PROB_BASE);\n+\t\t      }\n+\t\t    cgraph_turn_edge_to_speculative\n+\t\t      (e, n2,\n+\t\t       apply_scale (e->count,\n+\t\t\t\t    e->indirect_info->common_target_probability),\n+\t\t       apply_scale (e->frequency,\n+\t\t\t\t    e->indirect_info->common_target_probability));\n+\t\t    update = true;\n+\t\t  }\n+\t\telse\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Function with profile-id %i not found.\\n\",\n+\t\t\t     e->indirect_info->common_target_id);\n+\t       }\n+\t     if (update)\n+\t       inline_update_overall_summary (n);\n+\t   }\n+\tdel_node_map ();\n+    }\n+\n   if (dump_file)\n     dump_histogram (dump_file, histogram);\n   for (i = 0; i < (int)histogram.length (); i++)"}, {"sha": "fcba1b92acd0b9dbbd697164b7fafc09b042275f", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -299,6 +299,14 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n \t\t\t     | ECF_NOVOPS)));\n     }\n   streamer_write_bitpack (&bp);\n+  if (edge->indirect_unknown_callee)\n+    {\n+      streamer_write_hwi_stream (ob->main_stream,\n+\t\t\t         edge->indirect_info->common_target_id);\n+      if (edge->indirect_info->common_target_id)\n+\tstreamer_write_hwi_stream\n+\t   (ob->main_stream, edge->indirect_info->common_target_probability);\n+    }\n }\n \n /* Return if LIST contain references from other partitions.  */\n@@ -519,6 +527,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n     }\n+  streamer_write_hwi_stream (ob->main_stream, node->profile_id);\n }\n \n /* Output the varpool NODE to OB. \n@@ -1057,6 +1066,7 @@ input_node (struct lto_file_decl_data *file_data,\n     }\n   if (node->symbol.alias && !node->symbol.analyzed && node->symbol.weakref)\n     node->symbol.alias_target = get_alias_symbol (node->symbol.decl);\n+  node->profile_id = streamer_read_hwi (ib);\n   return node;\n }\n \n@@ -1205,6 +1215,9 @@ input_edge (struct lto_input_block *ib, vec<symtab_node> nodes,\n       if (bp_unpack_value (&bp, 1))\n \tecf_flags |= ECF_RETURNS_TWICE;\n       edge->indirect_info->ecf_flags = ecf_flags;\n+      edge->indirect_info->common_target_id = streamer_read_hwi (ib);\n+      if (edge->indirect_info->common_target_id)\n+        edge->indirect_info->common_target_probability = streamer_read_hwi (ib);\n     }\n }\n "}, {"sha": "643035932722bb8a8bce281e2d71a4b4ed34ce7c", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -765,18 +765,18 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n   for (cedge = node->callees; cedge; cedge = cedge->next_callee)\n     {\n       if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n-      fatal_error (\"Cgraph edge statement index out of range\");\n+        fatal_error (\"Cgraph edge statement index out of range\");\n       cedge->call_stmt = stmts[cedge->lto_stmt_uid - 1];\n       if (!cedge->call_stmt)\n-      fatal_error (\"Cgraph edge statement index not found\");\n+        fatal_error (\"Cgraph edge statement index not found\");\n     }\n   for (cedge = node->indirect_calls; cedge; cedge = cedge->next_callee)\n     {\n       if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n-      fatal_error (\"Cgraph edge statement index out of range\");\n+        fatal_error (\"Cgraph edge statement index out of range\");\n       cedge->call_stmt = stmts[cedge->lto_stmt_uid - 1];\n       if (!cedge->call_stmt)\n-      fatal_error (\"Cgraph edge statement index not found\");\n+        fatal_error (\"Cgraph edge statement index not found\");\n     }\n   for (i = 0;\n        ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref);"}, {"sha": "39fee31b1e684115fff99099490768bedac0248f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -1,3 +1,8 @@\n+2013-08-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-prof/crossmodule-indircall-1.c: New testcase.\n+\t* gcc.dg/tree-prof/crossmodule-indircall-1a.c: New testcase.\n+\n 2013-08-09  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* gcc.dg/lower-subreg-1.c: Skip aarch64*-*-*."}, {"sha": "3021425893f7b223834531d861086f166c820b2a", "filename": "gcc/testsuite/gcc.dg/tree-prof/crossmodule-indircall-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1.c?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-require-effective-target lto } */\n+/* { dg-additional-sources \"crossmodule-indircall-1a.c\" } */\n+/* { dg-options \"-O3 -flto -DDOJOB=1\" } */\n+\n+int a;\n+extern void (*p[2])(int n);\n+void abort (void);\n+main()\n+{ int i;\n+\n+  /* This call shall be converted.  */\n+  for (i = 0;i<1000;i++)\n+    p[0](1);\n+  /* This call shall not be converted.  */\n+  for (i = 0;i<1000;i++)\n+    p[i%2](2);\n+  if (a != 1000)\n+    abort ();\n+}"}, {"sha": "a94195cd95fefd61a7d9f7542d722096d1a5e670", "filename": "gcc/testsuite/gcc.dg/tree-prof/crossmodule-indircall-1a.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634ab819546e358bae26a7f798652f1271ae099d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcrossmodule-indircall-1a.c?ref=634ab819546e358bae26a7f798652f1271ae099d", "patch": "@@ -0,0 +1,40 @@\n+/* It seems there is no way to avoid the other source of mulitple\n+   source testcase from being compiled independently.  Just avoid\n+   error.  */\n+#ifdef DOJOB\n+extern int a;\n+void abort (void);\n+\n+#ifdef _PROFILE_USE\n+__attribute__ ((externally_visible))\n+int constval=1,constval2=2;\n+#else\n+__attribute__ ((externally_visible))\n+int constval=3,constval2=2;\n+#endif\n+\n+\n+void\n+add(int i)\n+{\n+  /* Verify that inlining happens for first case.  */\n+  if (i==constval && !__builtin_constant_p (i))\n+    abort ();\n+  /* Second case has no dominating target; it should not inline.  */\n+  if (i==constval2 && __builtin_constant_p (i))\n+    abort ();\n+  a += i;\n+}\n+void\n+sub(int i)\n+{\n+  a -= i;\n+}\n+__attribute__ ((externally_visible))\n+void (*p[2])(int)={add, sub};\n+#else\n+main()\n+{\n+  return 0;\n+}\n+#endif"}]}