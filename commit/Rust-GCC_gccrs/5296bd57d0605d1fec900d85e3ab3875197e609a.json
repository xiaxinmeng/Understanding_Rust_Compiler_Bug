{"sha": "5296bd57d0605d1fec900d85e3ab3875197e609a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI5NmJkNTdkMDYwNWQxZmVjOTAwZDg1ZTNhYjM4NzUxOTdlNjA5YQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-02-24T09:43:22Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-02-24T09:43:22Z"}, "message": "slp: fix sharing of SLP only patterns.\n\nThe attached testcase ICEs due to a couple of issues.\nIn the testcase you have two SLP instances that share the majority of their\ndefinition with each other.  One tree defines a COMPLEX_MUL sequence and the\nother tree a COMPLEX_FMA.\n\nThe ice happens because:\n\n1. the refcounts are wrong, in particular the FMA case doesn't correctly count\nthe references for the COMPLEX_MUL that it consumes.\n\n2. when the FMA is created it incorrectly assumes it can just tear apart the MUL\nnode that it's consuming.  This is wrong and should only be done when there is\nno more uses of the node, in which case the vector only pattern is no longer\nrelevant.\n\nTo fix the last part the SLP only pattern reset code was moved into\nvect_free_slp_tree which results in cleaner code.  I also think it does belong\nthere since that function knows when there are no more uses of the node and so\nthe pattern should be unmarked, so when the the vectorizer is inspecting the BB\nit doesn't find the now invalid vector only patterns.\n\nThe patch also clears the SLP_TREE_REPRESENTATIVE when stores are removed such\nthat we don't hit an error later trying to free the stmt_vec_info again.\n\nLastly it also tweaks the results of whether a pattern has been detected or not\nto return true when another SLP instance has created a pattern that is only used\nby a different instance (due to the trees being unshared).\n\nInstead of ICEing this code now produces\n\n        adrp    x1, .LANCHOR0\n        add     x2, x1, :lo12:.LANCHOR0\n        movi    v1.2s, 0\n        mov     w0, 0\n        ldr     x4, [x1, #:lo12:.LANCHOR0]\n        ldrsw   x3, [x2, 16]\n        ldr     x1, [x2, 8]\n        ldrsw   x2, [x2, 20]\n        ldr     d0, [x4]\n        ldr     d2, [x1, x3, lsl 3]\n        fcmla   v2.2s, v0.2s, v0.2s, #0\n        fcmla   v2.2s, v0.2s, v0.2s, #90\n        str     d2, [x1, x3, lsl 3]\n        fcmla   v1.2s, v0.2s, v0.2s, #0\n        fcmla   v1.2s, v0.2s, v0.2s, #90\n        str     d1, [x1, x2, lsl 3]\n        ret\n\nPS. This testcase actually shows that the codegen we get in these cases is not\noptimal. It should generate a MUL + ADD instead MUL + FMA.\n\nBut that's for GCC 12.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/99149\n\t* tree-vect-slp-patterns.c (vect_detect_pair_op): Don't recreate the\n\tbuffer.\n\t(vect_slp_reset_pattern): Remove.\n\t(complex_fma_pattern::matches): Remove call to vect_slp_reset_pattern.\n\t(complex_mul_pattern::build, complex_fma_pattern::build,\n\tcomplex_fms_pattern::build): Fix ref counts.\n\t* tree-vect-slp.c (vect_free_slp_tree): Undo SLP only pattern relevancy\n\twhen node is being deleted.\n\t(vect_match_slp_patterns_2): Correct result of cache hit on patterns.\n\t(vect_schedule_slp): Invalidate SLP_TREE_REPRESENTATIVE of removed\n\tstores.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Initialize value.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/99149\n\t* g++.dg/vect/pr99149.cc: New test.", "tree": {"sha": "73048a53e576417be37cf2b5c633efd5c2a27c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73048a53e576417be37cf2b5c633efd5c2a27c1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5296bd57d0605d1fec900d85e3ab3875197e609a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5296bd57d0605d1fec900d85e3ab3875197e609a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5296bd57d0605d1fec900d85e3ab3875197e609a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5296bd57d0605d1fec900d85e3ab3875197e609a/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e070b00ff327df3d7515222a4d85105c883d4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e070b00ff327df3d7515222a4d85105c883d4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e070b00ff327df3d7515222a4d85105c883d4a"}], "stats": {"total": 99, "additions": 67, "deletions": 32}, "files": [{"sha": "9002e3e5268a6c431d0de076d6768c12d79f39f0", "filename": "gcc/testsuite/g++.dg/vect/pr99149.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99149.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99149.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99149.cc?ref=5296bd57d0605d1fec900d85e3ab3875197e609a", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile { target { aarch64*-*-* } } } */\n+/* { dg-additional-options \"-w -O3 -march=armv8.3-a -fdump-tree-slp-all\" } */\n+\n+class a {\n+  float b;\n+  float c;\n+\n+public:\n+  a(float d, float e) : b(d), c(e) {}\n+  a operator+(a d) { return a(b + d.b, c + d.c); }\n+  a operator*(a d) { return a(b * b - c * c, b * c + c * d.b); }\n+};\n+int f, g;\n+class {\n+  a *h;\n+  a *i;\n+\n+public:\n+  void j() {\n+    a k = h[0], l = i[g], m = k * i[f];\n+    i[g] = l + m;\n+    i[f] = m;\n+  }\n+} n;\n+main() { n.j(); }\n+\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_MUL\" 1 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_FMA\" 1 \"slp2\" } } */"}, {"sha": "1e2769662a54229ab8e24390f97dfe206f17ab57", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=5296bd57d0605d1fec900d85e3ab3875197e609a", "patch": "@@ -407,9 +407,8 @@ vect_detect_pair_op (slp_tree node1, slp_tree node2, lane_permutation_t &lanes,\n \n   if (result != CMPLX_NONE && ops != NULL)\n     {\n-      ops->create (2);\n-      ops->quick_push (node1);\n-      ops->quick_push (node2);\n+      ops->safe_push (node1);\n+      ops->safe_push (node2);\n     }\n   return result;\n }\n@@ -1090,15 +1089,17 @@ complex_mul_pattern::build (vec_info *vinfo)\n {\n   slp_tree node;\n   unsigned i;\n+  slp_tree newnode\n+    = vect_build_combine_node (this->m_ops[0], this->m_ops[1], *this->m_node);\n+  SLP_TREE_REF_COUNT (this->m_ops[2])++;\n+\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (*this->m_node), i, node)\n     vect_free_slp_tree (node);\n \n   /* First re-arrange the children.  */\n   SLP_TREE_CHILDREN (*this->m_node).reserve_exact (2);\n   SLP_TREE_CHILDREN (*this->m_node)[0] = this->m_ops[2];\n-  SLP_TREE_CHILDREN (*this->m_node)[1] =\n-    vect_build_combine_node (this->m_ops[0], this->m_ops[1], *this->m_node);\n-  SLP_TREE_REF_COUNT (this->m_ops[2])++;\n+  SLP_TREE_CHILDREN (*this->m_node)[1] = newnode;\n \n   /* And then rewrite the node itself.  */\n   complex_pattern::build (vinfo);\n@@ -1133,18 +1134,6 @@ class complex_fma_pattern : public complex_pattern\n     }\n };\n \n-/* Helper function to \"reset\" a previously matched node and undo the changes\n-   made enough so that the node is treated as an irrelevant node.  */\n-\n-static inline void\n-vect_slp_reset_pattern (slp_tree node)\n-{\n-  stmt_vec_info stmt_info = vect_orig_stmt (SLP_TREE_REPRESENTATIVE (node));\n-  STMT_VINFO_IN_PATTERN_P (stmt_info) = false;\n-  STMT_SLP_TYPE (stmt_info) = pure_slp;\n-  SLP_TREE_REPRESENTATIVE (node) = stmt_info;\n-}\n-\n /* Pattern matcher for trying to match complex multiply and accumulate\n    and multiply and subtract patterns in SLP tree.\n    If the operation matches then IFN is set to the operation it matched and\n@@ -1208,15 +1197,6 @@ complex_fma_pattern::matches (complex_operation_t op,\n   if (!vect_pattern_validate_optab (ifn, vnode))\n     return IFN_LAST;\n \n-  /* FMA matched ADD + CMUL.  During the matching of CMUL the\n-     stmt that starts the pattern is marked as being in a pattern,\n-     namely the CMUL.  When replacing this with a CFMA we have to\n-     unmark this statement as being in a pattern.  This is because\n-     vect_mark_pattern_stmts will only mark the current stmt as being\n-     in a pattern.  Later on when the scalar stmts are examined the\n-     old statement which is supposed to be irrelevant will point to\n-     CMUL unless we undo the pattern relationship here.  */\n-  vect_slp_reset_pattern (node);\n   ops->truncate (0);\n   ops->create (3);\n \n@@ -1259,10 +1239,17 @@ complex_fma_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n void\n complex_fma_pattern::build (vec_info *vinfo)\n {\n+  slp_tree node = SLP_TREE_CHILDREN (*this->m_node)[1];\n+\n   SLP_TREE_CHILDREN (*this->m_node).release ();\n   SLP_TREE_CHILDREN (*this->m_node).create (3);\n   SLP_TREE_CHILDREN (*this->m_node).safe_splice (this->m_ops);\n \n+  SLP_TREE_REF_COUNT (this->m_ops[1])++;\n+  SLP_TREE_REF_COUNT (this->m_ops[2])++;\n+\n+  vect_free_slp_tree (node);\n+\n   complex_pattern::build (vinfo);\n }\n \n@@ -1427,6 +1414,11 @@ complex_fms_pattern::build (vec_info *vinfo)\n {\n   slp_tree node;\n   unsigned i;\n+  slp_tree newnode =\n+    vect_build_combine_node (this->m_ops[2], this->m_ops[3], *this->m_node);\n+  SLP_TREE_REF_COUNT (this->m_ops[0])++;\n+  SLP_TREE_REF_COUNT (this->m_ops[1])++;\n+\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (*this->m_node), i, node)\n     vect_free_slp_tree (node);\n \n@@ -1436,10 +1428,7 @@ complex_fms_pattern::build (vec_info *vinfo)\n   /* First re-arrange the children.  */\n   SLP_TREE_CHILDREN (*this->m_node).quick_push (this->m_ops[0]);\n   SLP_TREE_CHILDREN (*this->m_node).quick_push (this->m_ops[1]);\n-  SLP_TREE_CHILDREN (*this->m_node).quick_push (\n-    vect_build_combine_node (this->m_ops[2], this->m_ops[3], *this->m_node));\n-  SLP_TREE_REF_COUNT (this->m_ops[0])++;\n-  SLP_TREE_REF_COUNT (this->m_ops[1])++;\n+  SLP_TREE_CHILDREN (*this->m_node).quick_push (newnode);\n \n   /* And then rewrite the node itself.  */\n   complex_pattern::build (vinfo);"}, {"sha": "091e727bbc3e76d1f9591c2d29e3e8b10746fa0e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=5296bd57d0605d1fec900d85e3ab3875197e609a", "patch": "@@ -146,6 +146,16 @@ vect_free_slp_tree (slp_tree node)\n     if (child)\n       vect_free_slp_tree (child);\n \n+  /* If the node defines any SLP only patterns then those patterns are no\n+     longer valid and should be removed.  */\n+  stmt_vec_info rep_stmt_info = SLP_TREE_REPRESENTATIVE (node);\n+  if (rep_stmt_info && STMT_VINFO_SLP_VECT_ONLY_PATTERN (rep_stmt_info))\n+    {\n+      stmt_vec_info stmt_info = vect_orig_stmt (rep_stmt_info);\n+      STMT_VINFO_IN_PATTERN_P (stmt_info) = false;\n+      STMT_SLP_TYPE (stmt_info) = STMT_SLP_TYPE (rep_stmt_info);\n+    }\n+\n   delete node;\n }\n \n@@ -2395,7 +2405,9 @@ vect_match_slp_patterns_2 (slp_tree *ref_node, vec_info *vinfo,\n   slp_tree node = *ref_node;\n   bool found_p = false;\n   if (!node || visited->add (node))\n-    return false;\n+    return node\n+\t   && SLP_TREE_REPRESENTATIVE (node)\n+\t   && STMT_VINFO_SLP_VECT_ONLY_PATTERN (SLP_TREE_REPRESENTATIVE (node));\n \n   slp_tree child;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n@@ -6460,6 +6472,11 @@ vect_schedule_slp (vec_info *vinfo, vec<slp_instance> slp_instances)\n \t  store_info = vect_orig_stmt (store_info);\n \t  /* Free the attached stmt_vec_info and remove the stmt.  */\n \t  vinfo->remove_stmt (store_info);\n+\n+\t  /* Invalidate SLP_TREE_REPRESENTATIVE in case we released it\n+\t     to not crash in vect_free_slp_tree later.  */\n+\t  if (SLP_TREE_REPRESENTATIVE (root) == store_info)\n+\t    SLP_TREE_REPRESENTATIVE (root) = NULL;\n         }\n     }\n }"}, {"sha": "63ba594f2276850a00fc372072d98326891f19e6", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5296bd57d0605d1fec900d85e3ab3875197e609a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=5296bd57d0605d1fec900d85e3ab3875197e609a", "patch": "@@ -695,6 +695,7 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_REDUC_FN (res) = IFN_LAST;\n   STMT_VINFO_REDUC_IDX (res) = -1;\n   STMT_VINFO_SLP_VECT_ONLY (res) = false;\n+  STMT_VINFO_SLP_VECT_ONLY_PATTERN (res) = false;\n   STMT_VINFO_VEC_STMTS (res) = vNULL;\n \n   if (is_a <loop_vec_info> (this)"}]}