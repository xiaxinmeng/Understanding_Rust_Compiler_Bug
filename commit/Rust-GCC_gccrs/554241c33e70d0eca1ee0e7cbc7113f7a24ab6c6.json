{"sha": "554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU0MjQxYzMzZTcwZDBlY2ExZWUwZTdjYmM3MTEzZjdhMjRhYjZjNg==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@cygnus.com", "date": "1999-04-07T03:20:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-07T03:20:00Z"}, "message": "Bring over lost changes from Cygnus's directory.\n\n\t* Missing ChangeLog entries.\n\t* Whitespace fixes.\n\t* Enable multilib by default\n\t* One stl fix (#ifdef -> #if)\n\nFrom-SVN: r26234", "tree": {"sha": "ba0679a1cbf584be5f506cb6982eea4744180f4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba0679a1cbf584be5f506cb6982eea4744180f4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6/comments", "author": null, "committer": null, "parents": [{"sha": "5e62dee5a3ae4980296bb91a19579352277d97a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e62dee5a3ae4980296bb91a19579352277d97a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e62dee5a3ae4980296bb91a19579352277d97a0"}], "stats": {"total": 106, "additions": 62, "deletions": 44}, "files": [{"sha": "12a0e53039e3b40bdcf86ea0c899d9d7e9d99208", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6", "patch": "@@ -33,6 +33,20 @@ Thu Feb 18 19:53:17 1999  Marc Espie <espie@cvs.openbsd.org>\n \t* config/openbsd.ml: New file.\n \t* config/openbsd.mt: New file.\n \n+1999-02-04  Ulrich Drepper  <drepper@cygnus.com>\n+\n+\t* configure.in: Recognize --enable-threads=posix for all\n+\tplatforms.\n+\t* config/posix.mt: New file.\n+\n+\t* configure.in: Add fragments for Solaris defining macro specifying\n+\tthread library to be used.\n+\t* config/sol2pth.mt: New file\n+\t* config/sol2solth.mt: New file.\n+\t* stl/stl_alloc.h: Add support for Solaris thread library.\n+\t* stl/stl_config.h: Recognize _SOLTHREADS and define internal macros\n+\tappropriately.\n+\n 1999-01-28  Baron Roberts  <baron@sgi.com>\n \n \t* string: Uncomment wstring declaration."}, {"sha": "0f556cac551c0dcc83223f8a17cc1ce8d9e9a5ec", "filename": "libstdc++/configure.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6/libstdc%2B%2B%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6/libstdc%2B%2B%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fconfigure.in?ref=554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6", "patch": "@@ -176,6 +176,11 @@ if [ -n \"${with_cross_host}\" ] ; then\n     mv -f Makefile.tem Makefile\n fi\n \n+# enable multilib-ing by default.\n+if [ -z \"${enable_multilib}\" ]; then\n+    enable_multilib=yes\n+fi\n+\n . ${topsrcdir}/config-ml.in\n \n gxx_include_dir="}, {"sha": "36edf09659e86c282a322df253d217a23821fcc5", "filename": "libstdc++/stl/bitset", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6/libstdc%2B%2B%2Fstl%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6/libstdc%2B%2B%2Fstl%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Fbitset?ref=554241c33e70d0eca1ee0e7cbc7113f7a24ab6c6", "patch": "@@ -9,7 +9,7 @@\n  * in supporting documentation.  Silicon Graphics makes no\n  * representations about the suitability of this software for any\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n- */ \n+ */\n \n #ifndef __SGI_STL_BITSET\n #define __SGI_STL_BITSET\n@@ -19,12 +19,12 @@\n // THIS FEATURE*.  It is experimental, and it may be removed in\n // future releases.\n \n-// A bitset of size N, using words of type _WordT, will have \n+// A bitset of size N, using words of type _WordT, will have\n // N % (sizeof(_WordT) * CHAR_BIT) unused bits.  (They are the high-\n // order bits in the highest word.)  It is a class invariant\n // of class bitset<> that those unused bits are always zero.\n \n-// Most of the actual code isn't contained in bitset<> itself, but in the \n+// Most of the actual code isn't contained in bitset<> itself, but in the\n // base class _Base_bitset.  The base class works with whole words, not with\n // individual bits.  This allows us to specialize _Base_bitset for the\n // important special case where the bitset is only a single word.\n@@ -51,14 +51,14 @@ __STL_BEGIN_NAMESPACE\n #endif\n \n // structure to aid in counting bits\n-template<bool __dummy> \n+template<bool __dummy>\n struct _Bit_count {\n   static unsigned char _S_bit_count[256];\n };\n \n // Mapping from 8 bit unsigned integers to the index of the first one\n // bit:\n-template<bool __dummy> \n+template<bool __dummy>\n struct _First_one {\n   static unsigned char _S_first_one[256];\n };\n@@ -162,7 +162,7 @@ struct _Base_bitset {\n     return __result;\n   }\n \n-  unsigned long _M_do_to_ulong() const; \n+  unsigned long _M_do_to_ulong() const;\n \n   // find first \"on\" bit\n   size_t _M_do_find_first(size_t __not_found) const;\n@@ -173,7 +173,7 @@ struct _Base_bitset {\n \n //\n // Definitions of non-inline functions from _Base_bitset.\n-// \n+//\n \n template<size_t _Nw, class _WordT>\n _Base_bitset<_Nw, _WordT>::_Base_bitset(unsigned long __val)\n@@ -187,15 +187,15 @@ _Base_bitset<_Nw, _WordT>::_Base_bitset(unsigned long __val)\n }\n \n template<size_t _Nw, class _WordT>\n-void _Base_bitset<_Nw, _WordT>::_M_do_left_shift(size_t __shift) \n+void _Base_bitset<_Nw, _WordT>::_M_do_left_shift(size_t __shift)\n {\n   if (__shift != 0) {\n     const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n     const size_t __offset = __shift % __BITS_PER_WORDT(_WordT);\n     const size_t __sub_offset = __BITS_PER_WORDT(_WordT) - __offset;\n     size_t __n = _Nw - 1;\n     for ( ; __n > __wshift; --__n)\n-      _M_w[__n] = (_M_w[__n - __wshift] << __offset) | \n+      _M_w[__n] = (_M_w[__n - __wshift] << __offset) |\n                 (_M_w[__n - __wshift - 1] >> __sub_offset);\n     if (__n == __wshift)\n       _M_w[__n] = _M_w[0] << __offset;\n@@ -205,7 +205,7 @@ void _Base_bitset<_Nw, _WordT>::_M_do_left_shift(size_t __shift)\n }\n \n template<size_t _Nw, class _WordT>\n-void _Base_bitset<_Nw, _WordT>::_M_do_right_shift(size_t __shift) \n+void _Base_bitset<_Nw, _WordT>::_M_do_right_shift(size_t __shift)\n {\n   if (__shift != 0) {\n     const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n@@ -214,7 +214,7 @@ void _Base_bitset<_Nw, _WordT>::_M_do_right_shift(size_t __shift)\n     const size_t __limit = _Nw - __wshift - 1;\n     size_t __n = 0;\n     for ( ; __n < __limit; ++__n)\n-      _M_w[__n] = (_M_w[__n + __wshift] >> __offset) | \n+      _M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n                   (_M_w[__n + __wshift + 1] << __sub_offset);\n     _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n     for (size_t __n1 = __limit + 1; __n1 < _Nw; ++__n1)\n@@ -228,12 +228,12 @@ unsigned long _Base_bitset<_Nw, _WordT>::_M_do_to_ulong() const\n   const overflow_error __overflow(\"bitset\");\n \n   if (sizeof(_WordT) >= sizeof(unsigned long)) {\n-    for (size_t __i = 1; __i < _Nw; ++__i) \n-      if (_M_w[__i]) \n+    for (size_t __i = 1; __i < _Nw; ++__i)\n+      if (_M_w[__i])\n         __STL_THROW(__overflow);\n \n     const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n-    if (_M_w[0] & ~__mask) \n+    if (_M_w[0] & ~__mask)\n       __STL_THROW(__overflow);\n \n     return static_cast<unsigned long>(_M_w[0] & __mask);\n@@ -244,18 +244,18 @@ unsigned long _Base_bitset<_Nw, _WordT>::_M_do_to_ulong() const\n \n     size_t __min_nwords = __nwords;\n     if (_Nw > __nwords) {\n-      for (size_t __i = __nwords; __i < _Nw; ++__i) \n-        if (_M_w[__i]) \n+      for (size_t __i = __nwords; __i < _Nw; ++__i)\n+        if (_M_w[__i])\n           __STL_THROW(__overflow);\n     }\n-    else \n+    else\n       __min_nwords = _Nw;\n-      \n+\n     // If unsigned long is 8 bytes and _WordT is 6 bytes, then an unsigned\n     // long consists of all of one word plus 2 bytes from another word.\n     const size_t __part = sizeof(unsigned long) % sizeof(_WordT);\n \n-    if (__part != 0 && __nwords <= _Nw && \n+    if (__part != 0 && __nwords <= _Nw &&\n         (_M_w[__min_nwords - 1] >> ((sizeof(_WordT) - __part) * CHAR_BIT)) != 0)\n       __STL_THROW(__overflow);\n \n@@ -269,7 +269,7 @@ unsigned long _Base_bitset<_Nw, _WordT>::_M_do_to_ulong() const\n } // End _M_do_to_ulong\n \n template<size_t _Nw, class _WordT>\n-size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const \n+size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const\n {\n   for ( size_t __i = 0; __i < _Nw; __i++ ) {\n     _WordT __thisword = _M_w[__i];\n@@ -292,7 +292,7 @@ size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const\n \n template<size_t _Nw, class _WordT>\n size_t\n-_Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev, \n+_Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev,\n                                            size_t __not_found) const\n {\n   // make bound inclusive\n@@ -359,7 +359,7 @@ struct _Base_bitset<1, _WordT> {\n \n   _Base_bitset( void ) { _M_do_reset(); }\n \n-  _Base_bitset(unsigned long __val); \n+  _Base_bitset(unsigned long __val);\n \n   static size_t _S_whichword( size_t __pos ) {\n     return __pos / __BITS_PER_WORDT(_WordT);\n@@ -412,7 +412,7 @@ struct _Base_bitset<1, _WordT> {\n         return static_cast<unsigned long>(_M_w);\n     else {\n       const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n-      if (_M_w & ~__mask) \n+      if (_M_w & ~__mask)\n         __STL_THROW(overflow_error(\"bitset\"));\n       return static_cast<unsigned long>(_M_w);\n     }\n@@ -421,7 +421,7 @@ struct _Base_bitset<1, _WordT> {\n   size_t _M_do_find_first(size_t __not_found) const;\n \n   // find the next \"on\" bit that follows \"prev\"\n-  size_t _M_do_find_next(size_t __prev, size_t __not_found) const; \n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;\n \n };\n \n@@ -431,7 +431,7 @@ struct _Base_bitset<1, _WordT> {\n //\n \n template <class _WordT>\n-_Base_bitset<1, _WordT>::_Base_bitset(unsigned long __val) \n+_Base_bitset<1, _WordT>::_Base_bitset(unsigned long __val)\n {\n   _M_do_reset();\n   const size_t __n = min(sizeof(unsigned long)*CHAR_BIT,\n@@ -462,8 +462,8 @@ size_t _Base_bitset<1, _WordT>::_M_do_find_first(size_t __not_found) const\n }\n \n template <class _WordT>\n-size_t \n-_Base_bitset<1, _WordT>::_M_do_find_next(size_t __prev, \n+size_t\n+_Base_bitset<1, _WordT>::_M_do_find_next(size_t __prev,\n                                          size_t __not_found ) const\n {\n   // make bound inclusive\n@@ -499,12 +499,12 @@ _Base_bitset<1, _WordT>::_M_do_find_next(size_t __prev,\n \n //\n // One last specialization: _M_do_to_ulong() and the constructor from\n-// unsigned long are very simple if the bitset consists of a single \n+// unsigned long are very simple if the bitset consists of a single\n // word of type unsigned long.\n //\n \n template<>\n-inline unsigned long \n+inline unsigned long\n _Base_bitset<1, unsigned long>::_M_do_to_ulong() const { return _M_w; }\n \n template<>\n@@ -531,7 +531,7 @@ template <class _WordT> struct _Sanitize<_WordT, 0> {\n //   Type _WordT may be any unsigned integral type.\n \n template<size_t _Nb, class _WordT = unsigned long>\n-class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT> \n+class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>\n {\n private:\n   typedef _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT> _Base;\n@@ -620,16 +620,16 @@ public:\n \n   // 23.3.5.1 constructors:\n   bitset() {}\n-  bitset(unsigned long __val) : \n+  bitset(unsigned long __val) :\n     _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>(__val) {}\n \n   template<class _CharT, class _Traits, class _Alloc>\n   explicit bitset(const basic_string<_CharT,_Traits,_Alloc>& __s,\n                   size_t __pos = 0,\n-                  size_t __n = size_t(basic_string<_CharT,_Traits,_Alloc>::npos))\n-    : _Base() \n+                  size_t __n = basic_string<_CharT,_Traits,_Alloc>::npos)\n+    : _Base()\n   {\n-    if (__pos > __s.size()) \n+    if (__pos > __s.size())\n       __STL_THROW(out_of_range(\"bitset\"));\n     _M_copy_from_string(__s, __pos, __n);\n   }\n@@ -742,7 +742,7 @@ public:\n     return _Unchecked_flip(__pos);\n   }\n \n-  bitset<_Nb,_WordT> operator~() const { \n+  bitset<_Nb,_WordT> operator~() const {\n     return bitset<_Nb,_WordT>(*this).flip();\n   }\n \n@@ -753,7 +753,7 @@ public:\n \n   unsigned long to_ulong() const { return _M_do_to_ulong(); }\n \n-#ifdef __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n+#if __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n   template <class _CharT, class _Traits, class _Alloc>\n   basic_string<_CharT, _Traits, _Alloc> to_string() const {\n     basic_string<_CharT, _Traits, _Alloc> __result;\n@@ -802,14 +802,14 @@ public:\n   // EXTENSIONS: bit-find operations.  These operations are\n   // experimental, and are subject to change or removal in future\n   // versions.\n-  // \n+  //\n \n   // find the index of the first \"on\" bit\n-  size_t _Find_first() const \n+  size_t _Find_first() const\n     { return _M_do_find_first(_Nb); }\n \n   // find the index of the next \"on\" bit after prev\n-  size_t _Find_next( size_t __prev ) const \n+  size_t _Find_next( size_t __prev ) const\n     { return _M_do_find_next(__prev, _Nb); }\n \n };\n@@ -846,8 +846,8 @@ void bitset<_Nb, _WordT>\n   ::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n {\n   __s.assign(_Nb, '0');\n-  \n-  for (size_t __i = 0; __i < _Nb; ++__i) \n+\n+  for (size_t __i = 0; __i < _Nb; ++__i)\n     if (_Unchecked_test(__i))\n       __s[_Nb - 1 - __i] = '1';\n }\n@@ -894,7 +894,7 @@ operator>>(istream& __is, bitset<_Nb,_WordT>& __x) {\n   // In new templatized iostreams, use istream::sentry\n   if (__is.flags() & ios::skipws) {\n     char __c;\n-    do \n+    do\n       __is.get(__c);\n     while (__is && isspace(__c));\n     if (__is)\n@@ -915,7 +915,7 @@ operator>>(istream& __is, bitset<_Nb,_WordT>& __x) {\n       __tmp.push_back(__c);\n   }\n \n-  if (__tmp.empty()) \n+  if (__tmp.empty())\n     __is.clear(__is.rdstate() | ios::failbit);\n   else\n     __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n@@ -1061,4 +1061,3 @@ __STL_END_NAMESPACE\n // Local Variables:\n // mode:C++\n // End:\n-"}]}