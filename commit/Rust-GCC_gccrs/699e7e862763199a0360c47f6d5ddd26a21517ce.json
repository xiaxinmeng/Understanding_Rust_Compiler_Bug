{"sha": "699e7e862763199a0360c47f6d5ddd26a21517ce", "node_id": "C_kwDOANBUbNoAKDY5OWU3ZTg2Mjc2MzE5OWEwMzYwYzQ3ZjZkNWRkZDI2YTIxNTE3Y2U", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-19T17:02:36Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-21T11:36:40Z"}, "message": "gccrs: Closure support at CallExpr\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-context.h: Add new functions: `insert_closure_decl` and\n\t`lookup_closure_decl`.\n\t* backend/rust-compile-expr.cc (CompileExpr::visit): Start compiling Closures properly.\n\t(CompileExpr::generate_closure_function): New function.\n\t(CompileExpr::generate_closure_fntype): Likewise.\n\t* backend/rust-compile-expr.h: Declare `generate_closure_function` and\n\t`generate_closure_fntype`.\n\t* backend/rust-compile-type.cc (TyTyResolveCompile::visit): Visit closure types properly.\n\t* backend/rust-mangle.cc (legacy_mangle_name): Add support for closures.\n\t* backend/rust-tree.h (RS_CLOSURE_FLAG): Add new tree macro.\n\t(RS_CLOSURE_TYPE_P): And checking for it on tree nodes.\n\t* typecheck/rust-tyty.cc (ClosureType::is_equal): Add implementation.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/execute/torture/closure1.rs: New test.", "tree": {"sha": "8b45e8570e7f90bfa7d99a398ed04fdf34513ab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b45e8570e7f90bfa7d99a398ed04fdf34513ab6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/699e7e862763199a0360c47f6d5ddd26a21517ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/699e7e862763199a0360c47f6d5ddd26a21517ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/699e7e862763199a0360c47f6d5ddd26a21517ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/699e7e862763199a0360c47f6d5ddd26a21517ce/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "740a1997228d0b568afa11b1afe89128d9afff37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740a1997228d0b568afa11b1afe89128d9afff37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740a1997228d0b568afa11b1afe89128d9afff37"}], "stats": {"total": 373, "additions": 361, "deletions": 12}, "files": [{"sha": "d2d3a53f182f8e0ccfcd725ccba3a238865a2014", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -147,6 +147,35 @@ class Context\n     mono_fns[dId].push_back ({ref, fn});\n   }\n \n+  void insert_closure_decl (const TyTy::ClosureType *ref, tree fn)\n+  {\n+    auto dId = ref->get_def_id ();\n+    auto it = mono_closure_fns.find (dId);\n+    if (it == mono_closure_fns.end ())\n+      mono_closure_fns[dId] = {};\n+\n+    mono_closure_fns[dId].push_back ({ref, fn});\n+  }\n+\n+  tree lookup_closure_decl (const TyTy::ClosureType *ref)\n+  {\n+    auto dId = ref->get_def_id ();\n+    auto it = mono_closure_fns.find (dId);\n+    if (it == mono_closure_fns.end ())\n+      return error_mark_node;\n+\n+    for (auto &i : it->second)\n+      {\n+\tconst TyTy::ClosureType *t = i.first;\n+\ttree fn = i.second;\n+\n+\tif (ref->is_equal (*t))\n+\t  return fn;\n+      }\n+\n+    return error_mark_node;\n+  }\n+\n   bool lookup_function_decl (HirId id, tree *fn, DefId dId = UNKNOWN_DEFID,\n \t\t\t     const TyTy::BaseType *ref = nullptr,\n \t\t\t     const std::string &asm_name = std::string ())\n@@ -343,6 +372,8 @@ class Context\n   std::vector<tree> loop_begin_labels;\n   std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n+  std::map<DefId, std::vector<std::pair<const TyTy::ClosureType *, tree>>>\n+    mono_closure_fns;\n   std::map<HirId, tree> implicit_pattern_bindings;\n   std::map<hashval_t, tree> main_variants;\n "}, {"sha": "d2d9ae0a233478e67aff4b5ae5885add07ce19a5", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 272, "deletions": 8, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -1589,9 +1589,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     }\n \n   // must be a tuple constructor\n-  bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  bool is_adt_ctor = !is_fn;\n+  bool is_adt_ctor = tyty->get_kind () == TyTy::TypeKind::ADT;\n   if (is_adt_ctor)\n     {\n       rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n@@ -1692,20 +1690,71 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     return true;\n   };\n \n+  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+\n+  // is this a closure call?\n+  if (RS_CLOSURE_TYPE_P (TREE_TYPE (fn_address)))\n+    {\n+      rust_assert (tyty->get_kind () == TyTy::TypeKind::CLOSURE);\n+      TyTy::ClosureType *closure = static_cast<TyTy::ClosureType *> (tyty);\n+\n+      std::vector<tree> tuple_arg_vals;\n+      for (auto &argument : expr.get_arguments ())\n+\t{\n+\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+\t  tuple_arg_vals.push_back (rvalue);\n+\t}\n+\n+      tree tuple_args_tyty\n+\t= TyTyResolveCompile::compile (ctx, &closure->get_parameters ());\n+      tree tuple_args\n+\t= ctx->get_backend ()->constructor_expression (tuple_args_tyty, false,\n+\t\t\t\t\t\t       tuple_arg_vals, -1,\n+\t\t\t\t\t\t       expr.get_locus ());\n+\n+      // need to apply any autoderef's to the self argument\n+      HirId autoderef_mappings_id = expr.get_mappings ().get_hirid ();\n+      std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+      bool ok\n+\t= ctx->get_tyctx ()->lookup_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t\t\t\t&adjustments);\n+      rust_assert (ok);\n+\n+      // apply adjustments for the fn call\n+      tree self\n+\t= resolve_adjustements (*adjustments, fn_address, expr.get_locus ());\n+\n+      // args are always self, and the tuple of the args we are passing where\n+      // self is the path of the call-expr in this case the fn_address\n+      std::vector<tree> args;\n+      args.push_back (self);\n+      args.push_back (tuple_args);\n+\n+      // get the fn call address\n+      tree closure_call_site = ctx->lookup_closure_decl (closure);\n+      tree closure_call_address\n+\t= address_expression (closure_call_site, expr.get_locus ());\n+      translated\n+\t= ctx->get_backend ()->call_expression (closure_call_address, args,\n+\t\t\t\t\t\tnullptr /* static chain ?*/,\n+\t\t\t\t\t\texpr.get_locus ());\n+      return;\n+    }\n+\n   bool is_varadic = false;\n   if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n       is_varadic = fn->is_varadic ();\n     }\n \n-  size_t required_num_args;\n+  size_t required_num_args = expr.get_arguments ().size ();\n   if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n       required_num_args = fn->num_params ();\n     }\n-  else\n+  else if (tyty->get_kind () == TyTy::TypeKind::FNPTR)\n     {\n       const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n       required_num_args = fn->num_params ();\n@@ -1746,8 +1795,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       args.push_back (rvalue);\n     }\n \n-  // must be a call to a function\n-  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+  // must be a regular call to a function\n   translated = ctx->get_backend ()->call_expression (fn_address, args, nullptr,\n \t\t\t\t\t\t     expr.get_locus ());\n }\n@@ -2806,7 +2854,223 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n void\n CompileExpr::visit (HIR::ClosureExpr &expr)\n {\n-  gcc_unreachable ();\n+  TyTy::BaseType *closure_expr_ty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &closure_expr_ty))\n+    {\n+      rust_fatal_error (expr.get_locus (),\n+\t\t\t\"did not resolve type for this ClosureExpr\");\n+      return;\n+    }\n+  rust_assert (closure_expr_ty->get_kind () == TyTy::TypeKind::CLOSURE);\n+  TyTy::ClosureType *closure_tyty\n+    = static_cast<TyTy::ClosureType *> (closure_expr_ty);\n+  tree compiled_closure_tyty = TyTyResolveCompile::compile (ctx, closure_tyty);\n+\n+  // generate closure function\n+  generate_closure_function (expr, *closure_tyty, compiled_closure_tyty);\n+\n+  // lets ignore state capture for now we need to instantiate the struct anyway\n+  // then generate the function\n+\n+  std::vector<tree> vals;\n+  // TODO\n+  // setup argument captures based on the mode?\n+\n+  translated\n+    = ctx->get_backend ()->constructor_expression (compiled_closure_tyty, false,\n+\t\t\t\t\t\t   vals, -1, expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::generate_closure_function (HIR::ClosureExpr &expr,\n+\t\t\t\t\tTyTy::ClosureType &closure_tyty,\n+\t\t\t\t\ttree compiled_closure_tyty)\n+{\n+  TyTy::FnType *fn_tyty = nullptr;\n+  tree compiled_fn_type\n+    = generate_closure_fntype (expr, closure_tyty, compiled_closure_tyty,\n+\t\t\t       &fn_tyty);\n+  if (compiled_fn_type == error_mark_node)\n+    return error_mark_node;\n+\n+  const Resolver::CanonicalPath &parent_canonical_path\n+    = closure_tyty.get_ident ().path;\n+  Resolver::CanonicalPath path = parent_canonical_path.append (\n+    Resolver::CanonicalPath::new_seg (UNKNOWN_NODEID, \"{{closure}}\"));\n+\n+  std::string ir_symbol_name = path.get ();\n+  std::string asm_name = ctx->mangle_item (&closure_tyty, path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl\n+    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n+\t\t\t\t     flags, expr.get_locus ());\n+\n+  // insert into the context\n+  ctx->insert_function_decl (fn_tyty, fndecl);\n+  ctx->insert_closure_decl (&closure_tyty, fndecl);\n+\n+  // setup the parameters\n+  std::vector<Bvariable *> param_vars;\n+\n+  // closure self\n+  Bvariable *self_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"$closure\",\n+\t\t\t\t\t       compiled_closure_tyty,\n+\t\t\t\t\t       expr.get_locus ());\n+  DECL_ARTIFICIAL (self_param->get_decl ()) = 1;\n+  param_vars.push_back (self_param);\n+\n+  // setup the implicit argument captures\n+  // TODO\n+\n+  // args tuple\n+  tree args_type\n+    = TyTyResolveCompile::compile (ctx, &closure_tyty.get_parameters ());\n+  Bvariable *args_param\n+    = ctx->get_backend ()->parameter_variable (fndecl, \"args\", args_type,\n+\t\t\t\t\t       expr.get_locus ());\n+  param_vars.push_back (args_param);\n+\n+  // setup the implicit mappings for the arguments. Since argument passing to\n+  // closure functions is done via passing a tuple but the closure body expects\n+  // just normal arguments this means we need to destructure them similar to\n+  // what we do in MatchExpr's. This means when we have a closure-param of a we\n+  // actually setup the destructure to take from the args tuple\n+\n+  tree args_param_expr = args_param->get_tree (expr.get_locus ());\n+  size_t i = 0;\n+  for (auto &closure_param : expr.get_params ())\n+    {\n+      tree compiled_param_var = ctx->get_backend ()->struct_field_expression (\n+\targs_param_expr, i, closure_param.get_locus ());\n+\n+      const HIR::Pattern &param_pattern = *closure_param.get_pattern ();\n+      ctx->insert_pattern_binding (\n+\tparam_pattern.get_pattern_mappings ().get_hirid (), compiled_param_var);\n+      i++;\n+    }\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  // lookup locals\n+  HIR::Expr *function_body = expr.get_expr ().get ();\n+  auto body_mappings = function_body->get_mappings ();\n+  Resolver::Rib *rib = nullptr;\n+  bool ok\n+    = ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib);\n+  rust_assert (ok);\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = function_body->get_locus ();\n+  Location end_location = function_body->get_locus ();\n+  bool is_block_expr\n+    = function_body->get_expression_type () == HIR::Expr::ExprType::Block;\n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *body = static_cast<HIR::BlockExpr *> (function_body);\n+      start_location = body->get_locus ();\n+      end_location = body->get_end_locus ();\n+    }\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  TyTy::BaseType *tyret = &closure_tyty.get_result_type ();\n+  bool function_has_return = !closure_tyty.get_result_type ().is_unit ();\n+  Bvariable *return_address = nullptr;\n+  if (function_has_return)\n+    {\n+      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+\n+      return_address = ctx->get_backend ()->temporary_variable (\n+\tfndecl, code_block, return_type, NULL, address_is_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  ctx->push_fn (fndecl, return_address);\n+\n+  if (is_block_expr)\n+    {\n+      HIR::BlockExpr *body = static_cast<HIR::BlockExpr *> (function_body);\n+      compile_function_body (ctx, fndecl, *body, true);\n+    }\n+  else\n+    {\n+      tree value = CompileExpr::Compile (function_body, ctx);\n+      tree return_expr\n+\t= ctx->get_backend ()->return_statement (fndecl, {value},\n+\t\t\t\t\t\t function_body->get_locus ());\n+      ctx->add_statement (return_expr);\n+    }\n+\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n+tree\n+CompileExpr::generate_closure_fntype (HIR::ClosureExpr &expr,\n+\t\t\t\t      const TyTy::ClosureType &closure_tyty,\n+\t\t\t\t      tree compiled_closure_tyty,\n+\t\t\t\t      TyTy::FnType **fn_tyty)\n+{\n+  // grab the specified_bound\n+  rust_assert (closure_tyty.num_specified_bounds () == 1);\n+  const TyTy::TypeBoundPredicate &predicate\n+    = *closure_tyty.get_specified_bounds ().begin ();\n+\n+  // ensure the fn_once_output associated type is set\n+  closure_tyty.setup_fn_once_output ();\n+\n+  // the function signature is based on the trait bound that the closure\n+  // implements which is determined at the type resolution time\n+  //\n+  // https://github.com/rust-lang/rust/blob/7807a694c2f079fd3f395821bcc357eee8650071/library/core/src/ops/function.rs#L54-L71\n+\n+  TyTy::TypeBoundPredicateItem item = TyTy::TypeBoundPredicateItem::error ();\n+  if (predicate.get_name ().compare (\"FnOnce\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call_once\");\n+    }\n+  else if (predicate.get_name ().compare (\"FnMut\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call_mut\");\n+    }\n+  else if (predicate.get_name ().compare (\"Fn\") == 0)\n+    {\n+      item = predicate.lookup_associated_item (\"call\");\n+    }\n+  else\n+    {\n+      // FIXME error message?\n+      gcc_unreachable ();\n+      return error_mark_node;\n+    }\n+\n+  rust_assert (!item.is_error ());\n+\n+  TyTy::BaseType *item_tyty = item.get_tyty_for_receiver (&closure_tyty);\n+  rust_assert (item_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  *fn_tyty = static_cast<TyTy::FnType *> (item_tyty);\n+  return TyTyResolveCompile::compile (ctx, item_tyty);\n }\n \n } // namespace Compile"}, {"sha": "c734406e0dab158ab1a3023c2f11b88a835a6559", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -142,6 +142,16 @@ class CompileExpr : private HIRCompileBase, protected HIR::HIRExpressionVisitor\n \t\t\t  const TyTy::ArrayType &array_tyty, tree array_type,\n \t\t\t  HIR::ArrayElemsCopied &elems);\n \n+protected:\n+  tree generate_closure_function (HIR::ClosureExpr &expr,\n+\t\t\t\t  TyTy::ClosureType &closure_tyty,\n+\t\t\t\t  tree compiled_closure_tyty);\n+\n+  tree generate_closure_fntype (HIR::ClosureExpr &expr,\n+\t\t\t\tconst TyTy::ClosureType &closure_tyty,\n+\t\t\t\ttree compiled_closure_tyty,\n+\t\t\t\tTyTy::FnType **fn_tyty);\n+\n private:\n   CompileExpr (Context *ctx);\n "}, {"sha": "824cb3a56efb90ca2e6cd5cd42ed1f7218c0c46e", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -97,9 +97,15 @@ TyTyResolveCompile::visit (const TyTy::InferType &)\n }\n \n void\n-TyTyResolveCompile::visit (const TyTy::ClosureType &)\n+TyTyResolveCompile::visit (const TyTy::ClosureType &type)\n {\n-  gcc_unreachable ();\n+  std::vector<Backend::typed_identifier> fields;\n+  tree type_record = ctx->get_backend ()->struct_type (fields);\n+  RS_CLOSURE_FLAG (type_record) = 1;\n+\n+  std::string named_struct_str = type.get_ident ().path.get () + \"{{closure}}\";\n+  translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n }\n \n void"}, {"sha": "83aefa7997a84d16b77ffe018444ee117e7ec136", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -13,6 +13,8 @@ static const std::string kMangledRef = \"$RF$\";\n static const std::string kMangledPtr = \"$BP$\";\n static const std::string kMangledLeftSqParen = \"$u5b$\";\t // [\n static const std::string kMangledRightSqParen = \"$u5d$\"; // ]\n+static const std::string kMangledLeftBrace = \"$u7b$\";\t // {\n+static const std::string kMangledRightBrace = \"$u7d$\";\t // }\n static const std::string kQualPathBegin = \"_\" + kMangledSubstBegin;\n static const std::string kMangledComma = \"$C$\";\n \n@@ -66,6 +68,10 @@ legacy_mangle_name (const std::string &name)\n \tm = kMangledLeftSqParen;\n       else if (c == ']')\n \tm = kMangledRightSqParen;\n+      else if (c == '{')\n+\tm = kMangledLeftBrace;\n+      else if (c == '}')\n+\tm = kMangledRightBrace;\n       else if (c == ',')\n \tm = kMangledComma;\n       else if (c == ':')"}, {"sha": "284fd873c1c7a8cc5b8bd944993812dd293705da", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -82,6 +82,11 @@\n #define SLICE_TYPE_P(TYPE)                                                     \\\n   (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_0 (TYPE))\n \n+// lambda?\n+#define RS_CLOSURE_FLAG TREE_LANG_FLAG_1\n+#define RS_CLOSURE_TYPE_P(TYPE)                                                \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_1 (TYPE))\n+\n /* Returns true if NODE is a pointer to member function type.  */\n #define TYPE_PTRMEMFUNC_P(NODE)                                                \\\n   (TREE_CODE (NODE) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (NODE))"}, {"sha": "bdb2d909b86c6365d1c1c45bfef84d0ab379b470", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -1696,8 +1696,17 @@ ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n bool\n ClosureType::is_equal (const BaseType &other) const\n {\n-  gcc_unreachable ();\n-  return false;\n+  if (other.get_kind () != TypeKind::CLOSURE)\n+    return false;\n+\n+  const ClosureType &other2 = static_cast<const ClosureType &> (other);\n+  if (get_def_id () != other2.get_def_id ())\n+    return false;\n+\n+  if (!get_parameters ().is_equal (other2.get_parameters ()))\n+    return false;\n+\n+  return get_result_type ().is_equal (other2.get_result_type ());\n }\n \n BaseType *"}, {"sha": "62afa78a038d9a4f55d7f6c8dee138e01563ba11", "filename": "gcc/testsuite/rust/execute/torture/closure1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699e7e862763199a0360c47f6d5ddd26a21517ce/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fclosure1.rs?ref=699e7e862763199a0360c47f6d5ddd26a21517ce", "patch": "@@ -0,0 +1,18 @@\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+fn main() -> i32 {\n+    let closure_annotated = |i: i32| -> i32 { i + 1 };\n+\n+    let i = 1;\n+    closure_annotated(i) - 2\n+}"}]}