{"sha": "174b6f735019a11017284aaa23962cebd3943c99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0YjZmNzM1MDE5YTExMDE3Mjg0YWFhMjM5NjJjZWJkMzk0M2M5OQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-27T22:55:00Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-27T22:58:07Z"}, "message": "coroutines: Fix for uses of structured binding [PR94701]\n\nStructured binding makes use of the DECL_VALUE_EXPR fields\nin local variables.  We need to recognise these and only amend\nthe expression values, retaining the 'alias' value intact.\n\ngcc/cp/ChangeLog:\n\n2020-04-27  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94701\n\t* coroutines.cc (struct local_var_info): Add fields for static\n\tvariables and those with DECL_VALUE_EXPR redirection.\n\t(transform_local_var_uses):  Skip past typedefs and static vars\n\tand then account for redirected variables.\n\t(register_local_var_uses): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-27  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94701\n\t* g++.dg/coroutines/torture/local-var-06-structured-binding.C: New test.", "tree": {"sha": "b78b2db6fd38ea74975ece317e3488b08d485c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b78b2db6fd38ea74975ece317e3488b08d485c1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174b6f735019a11017284aaa23962cebd3943c99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174b6f735019a11017284aaa23962cebd3943c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174b6f735019a11017284aaa23962cebd3943c99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174b6f735019a11017284aaa23962cebd3943c99/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8df7c404e233abb1e26d8b8370c460732904531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8df7c404e233abb1e26d8b8370c460732904531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8df7c404e233abb1e26d8b8370c460732904531"}], "stats": {"total": 110, "additions": 99, "deletions": 11}, "files": [{"sha": "ae67a3e6c63361273f9442e15040fdbbc0bfe355", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=174b6f735019a11017284aaa23962cebd3943c99", "patch": "@@ -1,3 +1,12 @@\n+2020-04-27  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94701\n+\t* coroutines.cc (struct local_var_info): Add fields for static\n+\tvariables and those with DECL_VALUE_EXPR redirection.\n+\t(transform_local_var_uses): Skip past typedefs and static vars\n+\tand then account for redirected variables.\n+\t(register_local_var_uses): Likewise.\n+\n 2020-04-27  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/90750"}, {"sha": "36229c77b4e7212332e27c889d62982c4d32ed45", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=174b6f735019a11017284aaa23962cebd3943c99", "patch": "@@ -1774,6 +1774,8 @@ struct local_var_info\n   tree field_idx;\n   tree frame_type;\n   bool is_lambda_capture;\n+  bool is_static;\n+  bool has_value_expr_p;\n   location_t def_loc;\n };\n \n@@ -1819,7 +1821,7 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t\t\tNULL);\n \n \t/* For capture proxies, this could include the decl value expr.  */\n-\tif (local_var.is_lambda_capture)\n+\tif (local_var.is_lambda_capture || local_var.has_value_expr_p)\n \t  {\n \t    tree ve = DECL_VALUE_EXPR (lvar);\n \t    cp_walk_tree (&ve, transform_local_var_uses, d, NULL);\n@@ -1852,15 +1854,12 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \n \t  /* Leave lambda closure captures alone, we replace the *this\n \t     pointer with the frame version and let the normal process\n-\t     deal with the rest.  */\n-\t  if (local_var.is_lambda_capture)\n-\t    {\n-\t      pvar = &DECL_CHAIN (*pvar);\n-\t      continue;\n-\t    }\n-\n-\t  /* It's not used, but we can let the optimizer deal with that.  */\n-\t  if (local_var.field_id == NULL_TREE)\n+\t     deal with the rest.\n+\t     Likewise, variables with their value found elsewhere.\n+\t     Skip past unused ones too.  */\n+\t  if (local_var.is_lambda_capture\n+\t     || local_var.has_value_expr_p\n+\t     || local_var.field_id == NULL_TREE)\n \t    {\n \t      pvar = &DECL_CHAIN (*pvar);\n \t      continue;\n@@ -1894,10 +1893,13 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n      for the promise and coroutine handle(s), to global vars or to compiler\n      temporaries.  Skip past these, we will handle them later.  */\n   local_var_info *local_var_i = lvd->local_var_uses->get (var_decl);\n+\n   if (local_var_i == NULL)\n     return NULL_TREE;\n \n-  if (local_var_i->is_lambda_capture)\n+  if (local_var_i->is_lambda_capture\n+      || local_var_i->is_static\n+      || local_var_i->has_value_expr_p)\n     return NULL_TREE;\n \n   /* This is our revised 'local' i.e. a frame slot.  */\n@@ -3390,6 +3392,16 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  tree lvtype = TREE_TYPE (lvar);\n \t  local_var.frame_type = lvtype;\n \t  local_var.field_idx = local_var.field_id = NULL_TREE;\n+\n+\t  /* Make sure that we only present vars to the tests below.  */\n+\t  if (TREE_CODE (lvar) == TYPE_DECL)\n+\t    continue;\n+\n+\t  /* We don't move static vars into the frame. */\n+\t  local_var.is_static = TREE_STATIC (lvar);\n+\t  if (local_var.is_static)\n+\t    continue;\n+\n \t  lvd->local_var_seen = true;\n \t  /* If this var is a lambda capture proxy, we want to leave it alone,\n \t     and later rewrite the DECL_VALUE_EXPR to indirect through the\n@@ -3398,6 +3410,12 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  if (local_var.is_lambda_capture)\n \t    continue;\n \n+\t  /* If a variable has a value expression, then that's what needs\n+\t     to be processed.  */\n+\t  local_var.has_value_expr_p = DECL_HAS_VALUE_EXPR_P (lvar);\n+\t  if (local_var.has_value_expr_p)\n+\t    continue;\n+\n \t  /* Make names depth+index unique, so that we can support nested\n \t     scopes with identically named locals.  */\n \t  tree lvname = DECL_NAME (lvar);"}, {"sha": "b6e2f4f819f66f2e666b205a85a936f29f2cdc79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=174b6f735019a11017284aaa23962cebd3943c99", "patch": "@@ -1,3 +1,9 @@\n+2020-04-21  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94701\n+\t* g++.dg/coroutines/torture/local-var-06-structured-binding.C:\n+\tNew test.\n+\n 2020-04-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/93956"}, {"sha": "ef3ff47c16fa4f31998029b0450885054babb5eb", "filename": "gcc/testsuite/g++.dg/coroutines/torture/local-var-06-structured-binding.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-06-structured-binding.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174b6f735019a11017284aaa23962cebd3943c99/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-06-structured-binding.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Flocal-var-06-structured-binding.C?ref=174b6f735019a11017284aaa23962cebd3943c99", "patch": "@@ -0,0 +1,55 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct promise;\n+\n+struct future\n+{\n+  using promise_type = promise;\n+};\n+\n+struct promise\n+{\n+  template<typename... Args>\n+  promise (Args&... args) {}\n+ \n+  coro::suspend_never initial_suspend() { return {}; }\n+  coro::suspend_never final_suspend() { return {}; }\n+\n+  future get_return_object() { return {}; }\n+\n+  void return_value(int) {}\n+  void unhandled_exception() {}\n+};\n+\n+struct pair\n+{\n+  int i;\n+};\n+\n+pair \n+something ()\n+{\n+  return { 1 };\n+}\n+\n+future \n+my_coro ()\n+{   \n+  auto ret = something ();\n+\n+  if (ret.i != 1)\n+    abort ();\n+\n+  auto [ i ] = something ();\n+  if (i != 1)\n+    abort ();\n+\n+  co_return 1;\n+}\n+\n+int main ()\n+{\n+  my_coro ();\n+}"}]}