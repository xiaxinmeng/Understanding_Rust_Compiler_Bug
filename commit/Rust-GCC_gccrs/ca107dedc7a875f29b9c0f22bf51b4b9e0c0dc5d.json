{"sha": "ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ExMDdkZWRjN2E4NzVmMjliOWMwZjIyYmY1MWI0YjllMGMwZGM1ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-27T10:17:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-27T10:17:48Z"}, "message": "class.c (build_vbase_path): Use reverse_path.\n\n\t* class.c (build_vbase_path): Use reverse_path.\n\t(finish_base_struct): Move warnings for inaccessible bases to\n\tlayout_basetypes.\n\t(modify_one_vtable): Remove check of TREE_USED (binfo).\n\t(fixup_vtable_deltas1): Likewise.\n\t* cp-tree.h (BINFO_INHERITANCE_CHAIN): Document here.\n\t(xref_tag): Remove binfos parameter.\n\t(make_binfo): Remove chain parameter.\n\t(reverse_path): Add copy parameter.\n\t* decl.c (init_decl_processing): Change calls to xref_tag.\n\t(xref_tag): Remove binfos parameter.\n\t(xref_basetypes): Change calls to make_binfo.\n\t* decl2.c (grok_x_components): Change calls to xref_tag.\n\t(handle_class_head): Likewise.\n\t* friend.c (do_friend): Likewise.\n\t* lex.c (make_lang_type): Change calls to make_binfo.\n\t* parse.y (structsp): Change calls to xref_tag.\n\t(named_complex_class_head_sans_basetype): Likewise.\n\t(named_class_head): Likewise.\n\t* rtti.c (init_rtti_processing): Likewise.\n\t* search.c (compute_access): Change calls to reverse_path.\n\t(dfs_get_vbase_types): Change calls to make_binfo.\n\t(get_vbase_types): Remove dead code.\n\t* tree.c (unshare_base_binfos): Change calls to make_binfo.\n\t(layout_basetypes): Warn here about inaccessible bases.\n\t(make_binfo): Remove chain parameter.\n\t(reverse_path): Add copy parameter.\n\nFrom-SVN: r22021", "tree": {"sha": "814735a0488048628b7362fb35737f0ec358f145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/814735a0488048628b7362fb35737f0ec358f145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/comments", "author": null, "committer": null, "parents": [{"sha": "18337c03d5c8dba26b56121d7e0cb33700db152b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18337c03d5c8dba26b56121d7e0cb33700db152b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18337c03d5c8dba26b56121d7e0cb33700db152b"}], "stats": {"total": 241, "additions": 137, "deletions": 104}, "files": [{"sha": "7044d92c5378d6895fc78a3c4f7806ac28a6deec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -1,3 +1,33 @@\n+1998-08-27  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* class.c (build_vbase_path): Use reverse_path.\n+\t(finish_base_struct): Move warnings for inaccessible bases to\n+\tlayout_basetypes.\n+\t(modify_one_vtable): Remove check of TREE_USED (binfo).\n+\t(fixup_vtable_deltas1): Likewise.\n+\t* cp-tree.h (BINFO_INHERITANCE_CHAIN): Document here.\n+\t(xref_tag): Remove binfos parameter.\n+\t(make_binfo): Remove chain parameter.\n+\t(reverse_path): Add copy parameter.\n+\t* decl.c (init_decl_processing): Change calls to xref_tag.\n+\t(xref_tag): Remove binfos parameter.\n+\t(xref_basetypes): Change calls to make_binfo.\n+\t* decl2.c (grok_x_components): Change calls to xref_tag.\n+\t(handle_class_head): Likewise.\n+\t* friend.c (do_friend): Likewise.\n+\t* lex.c (make_lang_type): Change calls to make_binfo.\n+\t* parse.y (structsp): Change calls to xref_tag.\n+\t(named_complex_class_head_sans_basetype): Likewise.\n+\t(named_class_head): Likewise.\n+\t* rtti.c (init_rtti_processing): Likewise.\n+\t* search.c (compute_access): Change calls to reverse_path.\n+\t(dfs_get_vbase_types): Change calls to make_binfo.\n+\t(get_vbase_types): Remove dead code.\n+\t* tree.c (unshare_base_binfos): Change calls to make_binfo.\n+\t(layout_basetypes): Warn here about inaccessible bases.\n+\t(make_binfo): Remove chain parameter.\n+\t(reverse_path): Add copy parameter.\n+\t\n 1998-08-27  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* class.c: #if 0 complete_type_p."}, {"sha": "66b91436521cd884112f78b7a367b415b0627182", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -266,17 +266,8 @@ build_vbase_path (code, type, expr, path, nonnull)\n \n   if (BINFO_INHERITANCE_CHAIN (path))\n     {\n-      tree reverse_path = NULL_TREE;\n-\n       push_expression_obstack ();\n-      while (path)\n-\t{\n-\t  tree r = copy_node (path);\n-\t  BINFO_INHERITANCE_CHAIN (r) = reverse_path;\n-\t  reverse_path = r;\n-\t  path = BINFO_INHERITANCE_CHAIN (path);\n-\t}\n-      path = reverse_path;\n+      path = reverse_path (path, /*copy=*/1);\n       pop_obstacks ();\n     }\n \n@@ -1758,35 +1749,6 @@ finish_base_struct (t, b)\n \t}\n     }\n \n-  /* This comment said \"Must come after offsets are fixed for all bases.\"\n-     Well, now this happens before the offsets are fixed, but it seems to\n-     work fine.  Guess we'll see...  */\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree basetype = BINFO_TYPE (base_binfo);\n-\n-      if (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n-\t{\n-\t  cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t      basetype, t);\n-\t}\n-    }\n-  {\n-    tree v = get_vbase_types (t);\n-\n-    for (; v; v = TREE_CHAIN (v))\n-      {\n-\ttree basetype = BINFO_TYPE (v);\n-\tif (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n-\t  {\n-\t    if (extra_warnings)\n-\t      cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t\t  basetype, t);\n-\t  }\n-      }\n-  }    \n-\n   {\n     tree vfields;\n     /* Find the base class with the largest number of virtual functions.  */\n@@ -2413,10 +2375,6 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t\t\t\t    BINFO_OFFSET (binfo));\n \t  this_offset = ssize_binop (MINUS_EXPR, offset, base_offset);\n \n-\t  /* Make sure we can modify the derived association with immunity.  */\n-\t  if (TREE_USED (binfo))\n-\t    my_friendly_assert (0, 999);\n-\n \t  if (binfo == TYPE_BINFO (t))\n \t    {\n \t      /* In this case, it is *type*'s vtable we are modifying.\n@@ -2516,9 +2474,6 @@ fixup_vtable_deltas1 (binfo, t)\n \t  if (! tree_int_cst_equal (this_offset, delta))\n \t    {\n \t      /* Make sure we can modify the derived association with immunity.  */\n-\t      if (TREE_USED (binfo))\n-\t\tmy_friendly_assert (0, 999);\n-\n \t      if (binfo == TYPE_BINFO (t))\n \t\t{\n \t\t  /* In this case, it is *type*'s vtable we are modifying."}, {"sha": "532a5147c754ade62e7b1a823bfdcce68a55f34a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -966,6 +966,16 @@ struct lang_type\n \f\n /* Additional macros for inheritance information.  */\n \n+/* The BINFO_INHERITANCE_CHAIN is used opposite to the description in\n+   gcc/tree.h.  In particular if D is derived from B then the BINFO\n+   for B (in D) will have a BINFO_INHERITANCE_CHAIN pointing to\n+   D.  In tree.h, this pointer is described as pointing in other\n+   direction.  \n+\n+   After a call to get_vbase_types, the vbases are chained together in\n+   depth-first order via TREE_CHAIN.  Other than that, TREE_CHAIN is\n+   unused.  */\n+\n #ifdef MI_MATRIX\n /* When building a matrix to determine by a single lookup\n    whether one class is derived from another or not,\n@@ -2548,7 +2558,7 @@ extern int parmlist_is_exprlist\t\t\tPROTO((tree));\n extern int copy_args_p\t\t\t\tPROTO((tree));\n extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n extern void grok_op_properties\t\t\tPROTO((tree, int, int));\n-extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n+extern tree xref_tag\t\t\t\tPROTO((tree, tree, int));\n extern tree xref_tag_from_type\t\t\tPROTO((tree, tree, int));\n extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n@@ -3005,9 +3015,9 @@ extern tree hash_tree_cons\t\t\tPROTO((int, int, int, tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n extern tree hash_chainon\t\t\tPROTO((tree, tree));\n extern tree get_decl_list\t\t\tPROTO((tree));\n-extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n+extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree));\n extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n-extern tree reverse_path\t\t\tPROTO((tree));\n+extern tree reverse_path\t\t\tPROTO((tree, int));\n extern int count_functions\t\t\tPROTO((tree));\n extern int is_overloaded_fn\t\t\tPROTO((tree));\n extern tree get_first_fn\t\t\tPROTO((tree));"}, {"sha": "8e3b0722b86abd89cb84b93c68dacc7716a7393d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -6166,7 +6166,7 @@ init_decl_processing ()\n     if (flag_honor_std)\n       push_namespace (get_identifier (\"std\"));\n     bad_alloc_type_node = xref_tag\n-      (class_type_node, get_identifier (\"bad_alloc\"), NULL_TREE, 1);\n+      (class_type_node, get_identifier (\"bad_alloc\"), 1);\n     if (flag_honor_std)\n       pop_namespace ();\n     newtype = build_exception_variant\n@@ -11415,9 +11415,9 @@ grok_op_properties (decl, virtualp, friendp)\n    scope.)  */\n \n tree\n-xref_tag (code_type_node, name, binfo, globalize)\n+xref_tag (code_type_node, name, globalize)\n      tree code_type_node;\n-     tree name, binfo;\n+     tree name;\n      int globalize;\n {\n   enum tag_types tag_code;\n@@ -11623,9 +11623,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n \tredeclare_class_template (ref, current_template_parms);\n     }\n \n-  if (binfo)\n-    xref_basetypes (code_type_node, name, ref, binfo);\n-\n   /* Until the type is defined, tentatively accept whatever\n      structure tag the user hands us.  */\n   if (TYPE_SIZE (ref) == NULL_TREE\n@@ -11662,7 +11659,7 @@ xref_tag_from_type (old, id, globalize)\n   if (id == NULL_TREE)\n     id = TYPE_IDENTIFIER (old);\n \n-  return xref_tag (code_type_node, id, NULL_TREE, globalize);\n+  return xref_tag (code_type_node, id, globalize);\n }\n \n void\n@@ -11759,7 +11756,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n   \n \t  base_binfo = make_binfo (integer_zero_node, basetype,\n \t\t\t\t   TYPE_BINFO_VTABLE (basetype),\n-\t\t\t\t   TYPE_BINFO_VIRTUALS (basetype), NULL_TREE);\n+\t\t\t\t   TYPE_BINFO_VIRTUALS (basetype));\n  \n \t  TREE_VEC_ELT (binfos, i) = base_binfo;\n \t  TREE_VIA_PUBLIC (base_binfo) = via_public;"}, {"sha": "098c8435c9df2acb9f44659b053c819ebd8e00d5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -945,7 +945,7 @@ grok_x_components (specs, components)\n \t\tx = DECL_NAME (CLASSTYPE_TI_TEMPLATE (t));\n \t      else\n \t\tx = TYPE_IDENTIFIER (t);\n-\t      t = xref_tag (tcode, x, NULL_TREE, 0);\n+\t      t = xref_tag (tcode, x, 0);\n \t    }\n \n \t  if (ANON_UNION_TYPE_P (t))\n@@ -989,7 +989,7 @@ grok_x_components (specs, components)\n \n \tcase ENUMERAL_TYPE:\n \t  tcode = enum_type_node;\n-\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n+\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), 0);\n \t  x = grok_enum_decls (NULL_TREE);\n \t  return x;\n \t  break;\n@@ -4943,6 +4943,6 @@ handle_class_head (aggr, scope, id)\n     cp_error (\"no file-scope type named `%D'\", id);\n \n   id = xref_tag\n-    (aggr, make_anon_name (), NULL_TREE, 1);\n+    (aggr, make_anon_name (), 1);\n   return TYPE_MAIN_DECL (id);\n }"}, {"sha": "561c9d747b321beaaf2f1d86a6847d77c80dea9a", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -476,7 +476,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n       if (decl == NULL_TREE)\n \t{\n \t  cp_warning (\"implicitly declaring `%T' as struct\", declarator);\n-\t  decl = xref_tag (record_type_node, declarator, NULL_TREE, 1);\n+\t  decl = xref_tag (record_type_node, declarator, 1);\n \t  decl = TYPE_MAIN_DECL (decl);\n \t}\n "}, {"sha": "9d8f2d2ad06f207c9b382536e3454fa0d29383c6", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -4623,8 +4623,7 @@ make_lang_type (code)\n   CLASSTYPE_AS_LIST (t) = build_expr_list (NULL_TREE, t);\n   SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n   CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-  TYPE_BINFO (t) = make_binfo (integer_zero_node, t, NULL_TREE, NULL_TREE,\n-\t\t\t       NULL_TREE);\n+  TYPE_BINFO (t) = make_binfo (integer_zero_node, t, NULL_TREE, NULL_TREE);\n   CLASSTYPE_BINFO_AS_LIST (t) = build_tree_list (NULL_TREE, TYPE_BINFO (t));\n \n   /* Make sure this is laid out, for ease of use later."}, {"sha": "f64a24f8c80fe73a113d790e1438241f7f53798c", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -3589,7 +3589,7 @@ static const short yycheck[] = {     4,\n     77,    78,    79,    80,    81,    82,    83,    84\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -3782,7 +3782,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 196 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -6003,12 +6003,12 @@ case 470:\n     break;}\n case 471:\n #line 2086 \"parse.y\"\n-{ yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, NULL_TREE, 1); \n+{ yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 472:\n #line 2089 \"parse.y\"\n-{ yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, NULL_TREE, 1); \n+{ yyval.ftype.t = xref_tag (enum_type_node, yyvsp[0].ttype, 1); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 473:\n@@ -6130,11 +6130,11 @@ case 496:\n     break;}\n case 497:\n #line 2196 \"parse.y\"\n-{ yyval.ttype = xref_tag (current_aggr, yyvsp[0].ttype, NULL_TREE, 0); ;\n+{ yyval.ttype = xref_tag (current_aggr, yyvsp[0].ttype, 0); ;\n     break;}\n case 498:\n #line 2201 \"parse.y\"\n-{ yyval.ttype = xref_tag (current_aggr, yyvsp[0].ttype, NULL_TREE, 1); ;\n+{ yyval.ttype = xref_tag (current_aggr, yyvsp[0].ttype, 1); ;\n     break;}\n case 499:\n #line 2204 \"parse.y\"\n@@ -6163,7 +6163,7 @@ case 500:\n     break;}\n case 501:\n #line 2228 \"parse.y\"\n-{ yyval.ttype = xref_tag (yyval.ttype, make_anon_name (), NULL_TREE, 0);\n+{ yyval.ttype = xref_tag (yyval.ttype, make_anon_name (), 0);\n \t\t  yyungetc ('{', 1); ;\n     break;}\n case 504:\n@@ -7828,7 +7828,7 @@ case 870:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 498 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "022e50b2854f6130df631ce643c416d6f71d3fcb", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -2083,10 +2083,10 @@ structsp:\n \t\t  $$.new_type_flag = 1;\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM identifier\n-\t\t{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); \n+\t\t{ $$.t = xref_tag (enum_type_node, $2, 1); \n \t\t  $$.new_type_flag = 0; }\n \t| ENUM complex_type_name\n-\t\t{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); \n+\t\t{ $$.t = xref_tag (enum_type_node, $2, 1); \n \t\t  $$.new_type_flag = 0; }\n \t| TYPENAME_KEYWORD typename_sub\n \t\t{ $$.t = $2;\n@@ -2193,12 +2193,12 @@ named_complex_class_head_sans_basetype:\n \n do_xref_defn:\n \t  /* empty */  %prec EMPTY\n-\t\t{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 0); }\n+\t\t{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, 0); }\n \t;\n \n named_class_head:\n \t  named_class_head_sans_basetype  %prec EMPTY\n-\t\t{ $$ = xref_tag (current_aggr, $1, NULL_TREE, 1); }\n+\t\t{ $$ = xref_tag (current_aggr, $1, 1); }\n \t| named_class_head_sans_basetype_defn do_xref_defn\n           maybe_base_class_list  %prec EMPTY\n \t\t{ \n@@ -2225,7 +2225,7 @@ named_class_head:\n \n unnamed_class_head:\n \t  aggr '{'\n-\t\t{ $$ = xref_tag ($$, make_anon_name (), NULL_TREE, 0);\n+\t\t{ $$ = xref_tag ($$, make_anon_name (), 0);\n \t\t  yyungetc ('{', 1); }\n \t;\n "}, {"sha": "01c4a861ec25b0e1091c2369b0fdf013aea0382d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -60,7 +60,7 @@ init_rtti_processing ()\n   if (flag_honor_std)\n     push_namespace (get_identifier (\"std\"));\n   type_info_type_node = xref_tag\n-    (class_type_node, get_identifier (\"type_info\"), NULL_TREE, 1);\n+    (class_type_node, get_identifier (\"type_info\"), 1);\n   if (flag_honor_std)\n     pop_namespace ();\n   tinfo_fn_id = get_identifier (\"__tf\");"}, {"sha": "8e29bc1a2c576d216b4c4df36390b17eb8c0d7e5", "filename": "gcc/cp/search.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -1003,7 +1003,7 @@ compute_access (basetype_path, field)\n     }\n \n   /* must reverse more than one element */\n-  basetype_path = reverse_path (basetype_path);\n+  basetype_path = reverse_path (basetype_path, /*copy=*/0);\n   types = basetype_path;\n   via_protected = 0;\n   access = access_default_node;\n@@ -1049,7 +1049,7 @@ compute_access (basetype_path, field)\n       else\n \tbreak;\n     }\n-  reverse_path (basetype_path);\n+  reverse_path (basetype_path, /*copy=*/0);\n \n   /* No special visibilities apply.  Use normal rules.  */\n \n@@ -3196,10 +3196,12 @@ dfs_get_vbase_types (binfo)\n {\n   if (TREE_VIA_VIRTUAL (binfo) && ! BINFO_VBASE_MARKED (binfo))\n     {\n-      vbase_types = make_binfo (integer_zero_node, binfo,\n-\t\t\t\tBINFO_VTABLE (binfo),\n-\t\t\t\tBINFO_VIRTUALS (binfo), vbase_types);\n-      TREE_VIA_VIRTUAL (vbase_types) = 1;\n+      tree new_vbase = make_binfo (integer_zero_node, binfo,\n+\t\t\t\t   BINFO_VTABLE (binfo),\n+\t\t\t\t   BINFO_VIRTUALS (binfo));\n+      TREE_CHAIN (new_vbase) = vbase_types;\n+      TREE_VIA_VIRTUAL (new_vbase) = 1;\n+      vbase_types = new_vbase;\n       SET_BINFO_VBASE_MARKED (binfo);\n     }\n   SET_BINFO_MARKED (binfo);\n@@ -3214,11 +3216,7 @@ get_vbase_types (type)\n   tree vbases;\n   tree binfo;\n \n-  if (TREE_CODE (type) == TREE_VEC)\n-    binfo = type;\n-  else\n-    binfo = TYPE_BINFO (type);\n-\n+  binfo = TYPE_BINFO (type);\n   vbase_types = NULL_TREE;\n   dfs_walk (binfo, dfs_get_vbase_types, unmarkedp);\n   dfs_walk (binfo, dfs_unmark, markedp);\n@@ -4004,3 +4002,4 @@ types_overlap_p (empty_type, next_type)\n   dfs_walk (TYPE_BINFO (empty_type), dfs_check_overlap, dfs_no_overlap_yet);\n   return found_overlap;\n }\n+"}, {"sha": "feb1a44180f3590cbf2e6f563b8978253b134522", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -646,8 +646,7 @@ unshare_base_binfos (base_binfo)\n \t    = make_binfo (BINFO_OFFSET (base_base_binfo),\n \t\t\t  base_base_binfo,\n \t\t\t  BINFO_VTABLE (base_base_binfo),\n-\t\t\t  BINFO_VIRTUALS (base_base_binfo),\n-\t\t\t  chain);\n+\t\t\t  BINFO_VIRTUALS (base_base_binfo));\n \t  chain = TREE_VEC_ELT (base_binfos, j);\n \t  TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n \t  TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n@@ -677,9 +676,7 @@ layout_basetypes (rec, max)\n   tree binfos = TYPE_BINFO_BASETYPES (rec);\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n-  /* Get all the virtual base types that this type uses.\n-     The TREE_VALUE slot holds the virtual baseclass type.  */\n-  tree vbase_types = get_vbase_types (rec);\n+  tree vbase_types;\n \n   unsigned int record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n   unsigned int desired_align;\n@@ -694,7 +691,11 @@ layout_basetypes (rec, max)\n     record_align = MAX (record_align, STRUCTURE_SIZE_BOUNDARY);\n #endif\n \n-  CLASSTYPE_VBASECLASSES (rec) = vbase_types;\n+  /* Get all the virtual base types that this type uses.  The\n+     TREE_VALUE slot holds the virtual baseclass type.  Note that\n+     get_vbase_types makes copies of the virtual base BINFOs, so that\n+     the vbase_types are unshared.  */\n+  CLASSTYPE_VBASECLASSES (rec) = vbase_types = get_vbase_types (rec);\n \n   my_friendly_assert (TREE_CODE (TYPE_SIZE (rec)) == INTEGER_CST, 19970302);\n   const_size = TREE_INT_CST_LOW (TYPE_SIZE (rec));\n@@ -761,6 +762,11 @@ layout_basetypes (rec, max)\n       else\n \t{\n \t  my_friendly_assert (TREE_TYPE (field) == basetype, 23897);\n+\n+\t  if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n+\t    cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t\tbasetype, rec);\n+\n \t  BINFO_OFFSET (base_binfo)\n \t    = size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)),\n \t\t\t      BITS_PER_UNIT));\n@@ -774,6 +780,14 @@ layout_basetypes (rec, max)\n     {\n       BINFO_INHERITANCE_CHAIN (vbase_types) = TYPE_BINFO (rec);\n       unshare_base_binfos (vbase_types);\n+\n+      if (extra_warnings)\n+\t{\n+\t  tree basetype = BINFO_TYPE (vbase_types);\n+\t  if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n+\t    cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t\tbasetype, rec);\n+\t}\n     }\n \n   return max;\n@@ -1198,15 +1212,12 @@ get_decl_list (value)\n    VTABLE is the virtual function table with which to initialize\n    sub-objects of type TYPE.\n \n-   VIRTUALS are the virtual functions sitting in VTABLE.\n-\n-   CHAIN are more associations we must retain.  */\n+   VIRTUALS are the virtual functions sitting in VTABLE.  */\n \n tree\n-make_binfo (offset, binfo, vtable, virtuals, chain)\n+make_binfo (offset, binfo, vtable, virtuals)\n      tree offset, binfo;\n      tree vtable, virtuals;\n-     tree chain;\n {\n   tree new_binfo = make_tree_vec (7);\n   tree type;\n@@ -1219,10 +1230,6 @@ make_binfo (offset, binfo, vtable, virtuals, chain)\n       binfo = TYPE_BINFO (binfo);\n     }\n \n-  TREE_CHAIN (new_binfo) = chain;\n-  if (chain)\n-    TREE_USED (new_binfo) = TREE_USED (chain);\n-\n   TREE_TYPE (new_binfo) = TYPE_MAIN_VARIANT (type);\n   BINFO_OFFSET (new_binfo) = offset;\n   BINFO_VTABLE (new_binfo) = vtable;\n@@ -1251,13 +1258,22 @@ binfo_value (elem, type)\n   return get_binfo (elem, type, 0);\n }\n \n+/* Reverse the BINFO-chain given by PATH.  (If the \n+   BINFO_INHERITANCE_CHAIN points from base classes to derived\n+   classes, it will instead point from derived classes to base\n+   classes.)  Returns the first node in the reversed chain.  If COPY\n+   is non-zero, the nodes are copied as the chain is traversed.  */\n+\n tree\n-reverse_path (path)\n+reverse_path (path, copy)\n      tree path;\n+     int copy;\n {\n   register tree prev = 0, tmp, next;\n   for (tmp = path; tmp; tmp = next)\n     {\n+      if (copy) \n+\ttmp = copy_node (tmp);\n       next = BINFO_INHERITANCE_CHAIN (tmp);\n       BINFO_INHERITANCE_CHAIN (tmp) = prev;\n       prev = tmp;"}, {"sha": "0772399222dd1de9487d58abb6abd3e1ec95280c", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup2.C?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+\n+struct B { \n+  int i;\n+};\n+\n+struct D: virtual public B {\n+  int i;\n+};\n+\n+struct D2 : public D {\n+  void f() { i = 3; }\n+};"}, {"sha": "e38b222748724e42c9cf430997458253c45fe7d8", "filename": "gcc/testsuite/g++.old-deja/g++.pt/lookup5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup5.C?ref=ca107dedc7a875f29b9c0f22bf51b4b9e0c0dc5d", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+\n+struct B { \n+  int i;\n+};\n+\n+struct D: public B {\n+  int i;\n+};\n+\n+template <class T>\n+struct D2 : public D {\n+  void f() { i = 3; }\n+};"}]}