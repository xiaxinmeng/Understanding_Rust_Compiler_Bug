{"sha": "e9ffd4308d70da55b4c698b07b484063bcda0b01", "node_id": "C_kwDOANBUbNoAKGU5ZmZkNDMwOGQ3MGRhNTViNGM2OThiMDdiNDg0MDYzYmNkYTBiMDE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-13T15:58:34Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-14T12:32:49Z"}, "message": "Add HIR::ExprType get_expression_type() const", "tree": {"sha": "44e707326b0cd47aa0b8a2a7b57f4edcdc4d1863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44e707326b0cd47aa0b8a2a7b57f4edcdc4d1863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9ffd4308d70da55b4c698b07b484063bcda0b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ffd4308d70da55b4c698b07b484063bcda0b01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9ffd4308d70da55b4c698b07b484063bcda0b01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ffd4308d70da55b4c698b07b484063bcda0b01/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52780af6602763fac6297f7983878b38e0188bb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52780af6602763fac6297f7983878b38e0188bb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52780af6602763fac6297f7983878b38e0188bb9"}], "stats": {"total": 221, "additions": 176, "deletions": 45}, "files": [{"sha": "1d7d528b691a3c1b48bd1b997c6739d071005cea", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 121, "deletions": 31, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ffd4308d70da55b4c698b07b484063bcda0b01/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ffd4308d70da55b4c698b07b484063bcda0b01/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=e9ffd4308d70da55b4c698b07b484063bcda0b01", "patch": "@@ -47,14 +47,17 @@ class ExprWithBlock : public Expr\n     return clone_expr_with_block_impl ();\n   }\n \n-  bool is_expr_without_block () const final override { return false; };\n-\n public:\n   // Unique pointer custom clone function\n   std::unique_ptr<ExprWithBlock> clone_expr_with_block () const\n   {\n     return std::unique_ptr<ExprWithBlock> (clone_expr_with_block_impl ());\n   }\n+\n+  BlockType get_block_expr_type () const final override\n+  {\n+    return BlockType::WITH_BLOCK;\n+  };\n };\n \n // Literals? Or literal base?\n@@ -98,6 +101,8 @@ class LiteralExpr : public ExprWithoutBlock\n   Literal &get_literal () { return literal; }\n   const Literal &get_literal () const { return literal; }\n \n+  ExprType get_expression_type () const override final { return ExprType::Lit; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -167,6 +172,11 @@ class OperatorExpr : public ExprWithoutBlock\n   Location get_locus () const override final { return locus; }\n \n   std::unique_ptr<Expr> &get_expr () { return main_or_left_expr; }\n+\n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Operator;\n+  }\n };\n \n /* Unary prefix & or &mut (or && and &&mut) borrow operator. Cannot be\n@@ -795,6 +805,11 @@ class GroupedExpr : public ExprWithoutBlock\n     return expr_in_parens;\n   }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Grouped;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1006,6 +1021,11 @@ class ArrayExpr : public ExprWithoutBlock\n \n   ArrayElems *get_internal_elements () { return internal_elements.get (); };\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Array;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1019,11 +1039,6 @@ class ArrayExpr : public ExprWithoutBlock\n   }\n };\n \n-// Aka IndexExpr (also applies to slices)\n-/* Apparently a[b] is equivalent to *std::ops::Index::index(&a, b) or\n- * *std::ops::Index::index_mut(&mut a, b) */\n-/* Also apparently deref operations on a will be repeatedly applied to find an\n- * implementation */\n class ArrayIndexExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> array_expr;\n@@ -1072,6 +1087,11 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   Expr *get_array_expr () { return array_expr.get (); }\n   Expr *get_index_expr () { return index_expr.get (); }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::ArrayIndex;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1158,6 +1178,11 @@ class TupleExpr : public ExprWithoutBlock\n \n   bool is_unit () const { return tuple_elems.size () == 0; }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Tuple;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1171,18 +1196,12 @@ class TupleExpr : public ExprWithoutBlock\n   }\n };\n \n-// aka TupleIndexingExpr\n-// HIR representation of a tuple indexing expression\n class TupleIndexExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> tuple_expr;\n-  // TupleIndex is a decimal int literal with no underscores or suffix\n   TupleIndex tuple_index;\n-\n   Location locus;\n \n-  // i.e. pair.0\n-\n public:\n   std::string as_string () const override;\n \n@@ -1227,6 +1246,11 @@ class TupleIndexExpr : public ExprWithoutBlock\n     return tuple_expr;\n   }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::TupleIdx;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1260,6 +1284,11 @@ class StructExpr : public ExprWithoutBlock\n   PathInExpression &get_struct_name () { return struct_name; }\n \n   std::string as_string () const override;\n+\n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Struct;\n+  }\n };\n \n // Actual HIR node of the struct creator (with no fields). Not abstract!\n@@ -1648,7 +1677,6 @@ class CallExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> function;\n   std::vector<std::unique_ptr<Expr> > params;\n-\n   Location locus;\n \n public:\n@@ -1710,6 +1738,11 @@ class CallExpr : public ExprWithoutBlock\n     return params;\n   }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Call;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1729,7 +1762,6 @@ class MethodCallExpr : public ExprWithoutBlock\n   std::unique_ptr<Expr> receiver;\n   PathExprSegment method_name;\n   std::vector<std::unique_ptr<Expr> > params;\n-\n   Location locus;\n \n public:\n@@ -1794,6 +1826,11 @@ class MethodCallExpr : public ExprWithoutBlock\n     return params;\n   }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::MethodCall;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1865,6 +1902,11 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   Identifier get_field_name () const { return field; }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::FieldAccess;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1939,10 +1981,7 @@ struct ClosureParam\n class ClosureExpr : public ExprWithoutBlock\n {\n   bool has_move;\n-  std::vector<ClosureParam> params; // may be empty\n-  /* also note a double pipe \"||\" can be used for empty params - does not need a\n-   * space */\n-\n+  std::vector<ClosureParam> params;\n   Location locus;\n \n protected:\n@@ -1957,6 +1996,11 @@ class ClosureExpr : public ExprWithoutBlock\n   std::string as_string () const override;\n \n   Location get_locus () const override final { return locus; }\n+\n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Closure;\n+  }\n };\n \n // Represents a non-type-specified closure expression HIR node\n@@ -2022,10 +2066,8 @@ class BlockExpr : public ExprWithBlock\n {\n public:\n   AST::AttrVec inner_attrs;\n-\n   std::vector<std::unique_ptr<Stmt> > statements;\n-  std::unique_ptr<Expr> expr; // inlined from Statements\n-\n+  std::unique_ptr<Expr> expr;\n   bool tail_reachable;\n   Location locus;\n \n@@ -2109,6 +2151,11 @@ class BlockExpr : public ExprWithBlock\n \n   std::vector<std::unique_ptr<Stmt> > &get_statements () { return statements; }\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::Block;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2199,7 +2246,6 @@ class ClosureExprInnerTyped : public ClosureExpr\n // HIR node representing continue expression within loops\n class ContinueExpr : public ExprWithoutBlock\n {\n-  // bool has_label;\n   Lifetime label;\n   Location locus;\n \n@@ -2222,6 +2268,11 @@ class ContinueExpr : public ExprWithoutBlock\n \n   Lifetime &get_label () { return label; }\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::Continue;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2237,7 +2288,6 @@ class ContinueExpr : public ExprWithoutBlock\n     return new ContinueExpr (*this);\n   }\n };\n-// TODO: merge \"break\" and \"continue\"? Or even merge in \"return\"?\n \n // HIR node representing break expression within loops\n class BreakExpr : public ExprWithoutBlock\n@@ -2303,6 +2353,11 @@ class BreakExpr : public ExprWithoutBlock\n \n   std::unique_ptr<Expr> &get_expr () { return break_expr; }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Break;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2329,6 +2384,11 @@ class RangeExpr : public ExprWithoutBlock\n \n public:\n   Location get_locus () const override final { return locus; }\n+\n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Range;\n+  }\n };\n \n // Range from (inclusive) and to (exclusive) expression HIR node object\n@@ -2676,6 +2736,11 @@ class ReturnExpr : public ExprWithoutBlock\n \n   Expr *get_expr () { return return_expr.get (); }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::Return;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2697,7 +2762,6 @@ class UnsafeBlockExpr : public ExprWithBlock\n {\n   // Or just have it extend BlockExpr\n   std::unique_ptr<BlockExpr> expr;\n-\n   Location locus;\n \n public:\n@@ -2737,6 +2801,11 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   std::unique_ptr<BlockExpr> &get_block_expr () { return expr; }\n \n+  ExprType get_expression_type () const override final\n+  {\n+    return ExprType::UnsafeBlock;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2784,10 +2853,7 @@ class LoopLabel /*: public Node*/\n class BaseLoopExpr : public ExprWithBlock\n {\n protected:\n-  // protected to allow subclasses better use of them\n-  // bool has_loop_label;\n   LoopLabel loop_label;\n-\n   std::unique_ptr<BlockExpr> loop_block;\n \n private:\n@@ -2826,6 +2892,11 @@ class BaseLoopExpr : public ExprWithBlock\n   BaseLoopExpr (BaseLoopExpr &&other) = default;\n   BaseLoopExpr &operator= (BaseLoopExpr &&other) = default;\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::BaseLoop;\n+  }\n+\n public:\n   bool has_loop_label () const { return !loop_label.is_error (); }\n \n@@ -3128,6 +3199,8 @@ class IfExpr : public ExprWithBlock\n   Expr *get_if_condition () { return condition.get (); }\n   BlockExpr *get_if_block () { return if_block.get (); }\n \n+  ExprType get_expression_type () const final override { return ExprType::If; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3346,6 +3419,11 @@ class IfLetExpr : public ExprWithBlock\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::IfLet;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3898,6 +3976,11 @@ class MatchExpr : public ExprWithBlock\n   const std::vector<MatchCase> &get_match_cases () const { return match_arms; }\n   std::vector<MatchCase> &get_match_cases () { return match_arms; }\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::Match;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3915,7 +3998,6 @@ class MatchExpr : public ExprWithBlock\n class AwaitExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> awaited_expr;\n-\n   Location locus;\n \n public:\n@@ -3952,6 +4034,11 @@ class AwaitExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::Await;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3964,10 +4051,8 @@ class AwaitExpr : public ExprWithoutBlock\n // Async block expression HIR node (block expr that evaluates to a future)\n class AsyncBlockExpr : public ExprWithBlock\n {\n-  // TODO: should this extend BlockExpr rather than be a composite of it?\n   bool has_move;\n   std::unique_ptr<BlockExpr> block_expr;\n-\n   Location locus;\n \n public:\n@@ -4005,6 +4090,11 @@ class AsyncBlockExpr : public ExprWithBlock\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::AsyncBlock;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "de312eed8693a847b67c6105ec40f26bd4cfb665", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 55, "deletions": 14, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ffd4308d70da55b4c698b07b484063bcda0b01/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ffd4308d70da55b4c698b07b484063bcda0b01/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=e9ffd4308d70da55b4c698b07b484063bcda0b01", "patch": "@@ -166,12 +166,46 @@ class ExprWithoutBlock;\n // Base expression HIR node - abstract\n class Expr\n {\n-  // TODO: move outer attribute data to derived classes?\n   AST::AttrVec outer_attrs;\n-\n   Analysis::NodeMapping mappings;\n \n public:\n+  enum BlockType\n+  {\n+    WITH_BLOCK,\n+    WITHOUT_BLOCK,\n+  };\n+\n+  enum ExprType\n+  {\n+    Lit,\n+    Operator,\n+    Grouped,\n+    Array,\n+    ArrayIndex,\n+    Tuple,\n+    TupleIdx,\n+    Struct,\n+    Call,\n+    MethodCall,\n+    FieldAccess,\n+    Closure,\n+    Block,\n+    Continue,\n+    Break,\n+    Range,\n+    Return,\n+    UnsafeBlock,\n+    BaseLoop,\n+    If,\n+    IfLet,\n+    Match,\n+    Await,\n+    AsyncBlock,\n+    Ident,\n+    Path,\n+  };\n+\n   const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n \n   // Unique pointer custom clone function\n@@ -180,11 +214,6 @@ class Expr\n     return std::unique_ptr<Expr> (clone_expr_impl ());\n   }\n \n-  /* TODO: public methods that could be useful:\n-   *  - get_type() - returns type of expression. set_type() may also be useful\n-   * for some?\n-   *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n-\n   /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n    * overrided in subclasses of ExprWithoutBlock */\n   virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n@@ -196,16 +225,17 @@ class Expr\n \n   virtual Location get_locus () const = 0;\n \n-  // HACK: strictly not needed, but faster than full downcast clone\n-  virtual bool is_expr_without_block () const = 0;\n-\n   virtual void accept_vis (HIRFullVisitor &vis) = 0;\n \n   const Analysis::NodeMapping &get_mappings () const { return mappings; }\n \n   // Clone function implementation as pure virtual method\n   virtual Expr *clone_expr_impl () const = 0;\n \n+  virtual BlockType get_block_expr_type () const = 0;\n+\n+  virtual ExprType get_expression_type () const = 0;\n+\n protected:\n   // Constructor\n   Expr (Analysis::NodeMapping mappings,\n@@ -242,8 +272,6 @@ class ExprWithoutBlock : public Expr\n     return clone_expr_without_block_impl ();\n   }\n \n-  bool is_expr_without_block () const final override { return true; };\n-\n public:\n   // Unique pointer custom clone function\n   std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n@@ -257,6 +285,11 @@ class ExprWithoutBlock : public Expr\n   {\n     return clone_expr_without_block_impl ();\n   }\n+\n+  BlockType get_block_expr_type () const final override\n+  {\n+    return BlockType::WITHOUT_BLOCK;\n+  };\n };\n \n /* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n@@ -294,6 +327,11 @@ class IdentifierExpr : public ExprWithoutBlock\n \n   Identifier get_identifier () const { return ident; }\n \n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::Ident;\n+  }\n+\n protected:\n   // Clone method implementation\n   IdentifierExpr *clone_expr_without_block_impl () const override\n@@ -760,14 +798,17 @@ class PathExpr : public ExprWithoutBlock\n   {}\n \n public:\n-  // TODO: think of a better and less hacky way to allow this\n-\n   /* Replaces the outer attributes of this path expression with the given outer\n    * attributes. */\n   void replace_outer_attrs (AST::AttrVec outer_attrs)\n   {\n     set_outer_attrs (std::move (outer_attrs));\n   }\n+\n+  ExprType get_expression_type () const final override\n+  {\n+    return ExprType::Path;\n+  }\n };\n } // namespace HIR\n } // namespace Rust"}]}