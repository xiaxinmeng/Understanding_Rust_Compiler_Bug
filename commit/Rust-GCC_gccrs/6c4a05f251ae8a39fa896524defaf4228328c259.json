{"sha": "6c4a05f251ae8a39fa896524defaf4228328c259", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM0YTA1ZjI1MWFlOGEzOWZhODk2NTI0ZGVmYWY0MjI4MzI4YzI1OQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-04-10T04:38:53Z"}, "committer": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-04-10T04:53:00Z"}, "message": "Simplify co_await_expander.\n\ngcc/cp\n2020-04-10  Bin Cheng  <bin.cheng@linux.alibaba.com>\n\n    * coroutines.cc (co_await_expander): Simplify.\n\ngcc/testsuite\n2020-04-10  Bin Cheng  <bin.cheng@linux.alibaba.com>\n\n    * g++.dg/coroutines/co-await-syntax-10.C: New test.\n    * g++.dg/coroutines/co-await-syntax-11.C: New test.", "tree": {"sha": "760eeb443352afc5155a3ab456efb34a1ba2df3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/760eeb443352afc5155a3ab456efb34a1ba2df3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c4a05f251ae8a39fa896524defaf4228328c259", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c4a05f251ae8a39fa896524defaf4228328c259", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c4a05f251ae8a39fa896524defaf4228328c259", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c4a05f251ae8a39fa896524defaf4228328c259/comments", "author": null, "committer": null, "parents": [{"sha": "d79a22eddc694970316992927c669dd801e07557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79a22eddc694970316992927c669dd801e07557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79a22eddc694970316992927c669dd801e07557"}], "stats": {"total": 279, "additions": 257, "deletions": 22}, "files": [{"sha": "38f86cd3e87296a3a89a9545f8ce0ae53c6719c7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6c4a05f251ae8a39fa896524defaf4228328c259", "patch": "@@ -1,3 +1,7 @@\n+2020-04-10  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\t* coroutines.cc (co_await_expander): Simplify.\n+\n 2020-04-09  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/94523"}, {"sha": "ab06c0aef54a2fd2233167769febc6dcbe61051d", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=6c4a05f251ae8a39fa896524defaf4228328c259", "patch": "@@ -1389,34 +1389,13 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n     return NULL_TREE;\n \n   coro_aw_data *data = (coro_aw_data *) d;\n-\n   enum tree_code stmt_code = TREE_CODE (*stmt);\n   tree stripped_stmt = *stmt;\n-\n-  /* Look inside <(void) (expr)> cleanup */\n-  if (stmt_code == CLEANUP_POINT_EXPR)\n-    {\n-      stripped_stmt = TREE_OPERAND (*stmt, 0);\n-      stmt_code = TREE_CODE (stripped_stmt);\n-      if (stmt_code == EXPR_STMT\n-\t  && (TREE_CODE (EXPR_STMT_EXPR (stripped_stmt)) == CONVERT_EXPR\n-\t      || TREE_CODE (EXPR_STMT_EXPR (stripped_stmt)) == CAST_EXPR)\n-\t  && VOID_TYPE_P (TREE_TYPE (EXPR_STMT_EXPR (stripped_stmt))))\n-\t{\n-\t  stripped_stmt = TREE_OPERAND (EXPR_STMT_EXPR (stripped_stmt), 0);\n-\t  stmt_code = TREE_CODE (stripped_stmt);\n-\t}\n-    }\n-\n   tree *buried_stmt = NULL;\n   tree saved_co_await = NULL_TREE;\n   enum tree_code sub_code = NOP_EXPR;\n \n-  if (stmt_code == EXPR_STMT\n-      && TREE_CODE (EXPR_STMT_EXPR (stripped_stmt)) == CO_AWAIT_EXPR)\n-    saved_co_await\n-      = EXPR_STMT_EXPR (stripped_stmt); /* hopefully, a void exp.  */\n-  else if (stmt_code == MODIFY_EXPR || stmt_code == INIT_EXPR)\n+  if (stmt_code == MODIFY_EXPR || stmt_code == INIT_EXPR)\n     {\n       sub_code = TREE_CODE (TREE_OPERAND (stripped_stmt, 1));\n       if (sub_code == CO_AWAIT_EXPR)\n@@ -1435,6 +1414,8 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   else if ((stmt_code == CONVERT_EXPR || stmt_code == NOP_EXPR)\n \t   && TREE_CODE (TREE_OPERAND (stripped_stmt, 0)) == CO_AWAIT_EXPR)\n     saved_co_await = TREE_OPERAND (stripped_stmt, 0);\n+  else if (stmt_code == CO_AWAIT_EXPR)\n+    saved_co_await = stripped_stmt;\n \n   if (!saved_co_await)\n     return NULL_TREE;"}, {"sha": "72e0d519bb95d80d4f4f5a556250bec0fdb15ce2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c4a05f251ae8a39fa896524defaf4228328c259", "patch": "@@ -1,3 +1,8 @@\n+2020-04-10  Bin Cheng  <bin.cheng@linux.alibaba.com>\n+\n+\t* g++.dg/coroutines/co-await-syntax-10.C: New test.\n+\t* g++.dg/coroutines/co-await-syntax-11.C: New test.\n+\n 2020-04-09  Fritz Reese  <foreese@gcc.gnu.org>\n \n \tPR fortran/87923"}, {"sha": "8304344c826a439b793c1eab7ccc3548fb6ea50e", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-10.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-10.C?ref=6c4a05f251ae8a39fa896524defaf4228328c259", "patch": "@@ -0,0 +1,40 @@\n+//  { dg-additional-options \"-std=c++17 -w\" }\n+\n+#include \"coro.h\"\n+\n+class await {\n+public:\n+  class promise_type {\n+  public:\n+    std::suspend_always initial_suspend() const noexcept { return {}; }\n+    std::suspend_always final_suspend() const noexcept { return {}; }\n+    void unhandled_exception() noexcept { }\n+    await get_return_object() { return await{}; }\n+    void return_void() {}\n+  };\n+  bool await_ready() const noexcept { return false; }\n+  bool await_suspend(std::coroutine_handle<>) noexcept {return true;}\n+  void await_resume() { }\n+};\n+\n+class mycoro {\n+public:\n+  class promise_type {\n+  public:\n+    std::suspend_always initial_suspend() const noexcept { return {}; }\n+    std::suspend_always final_suspend() const noexcept { return {}; }\n+    void unhandled_exception() noexcept { }\n+    mycoro get_return_object() { return mycoro{}; }\n+    void return_void() {}\n+  };\n+};\n+mycoro foo(await awaitable) {\n+  co_return co_await awaitable;\n+}\n+\n+mycoro bar()\n+{\n+ auto t = [&]() -> await { co_return; }();\n+ return foo (t);\n+}\n+"}, {"sha": "69810ab5caaba7a8e2a4321ab5ee90216f63f83f", "filename": "gcc/testsuite/g++.dg/coroutines/co-await-syntax-11.C", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c4a05f251ae8a39fa896524defaf4228328c259/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-await-syntax-11.C?ref=6c4a05f251ae8a39fa896524defaf4228328c259", "patch": "@@ -0,0 +1,205 @@\n+//  { dg-additional-options \"-std=c++17 -w\" }\n+\n+#include <utility>\n+#include <type_traits>\n+#include <tuple>\n+#include <functional>\n+#include <coroutine>\n+\n+struct any {\n+  template <typename T> any(T &&) noexcept;\n+};\n+\n+template <typename T>\n+auto get_awaiter_impl(T &&value, int) noexcept\n+    -> decltype(static_cast<T &&>(value).operator co_await()) {\n+  return static_cast<T &&>(value).operator co_await();\n+}\n+template <typename T, int = 0>\n+T &&get_awaiter_impl(T &&value, any) noexcept;\n+template <typename T>\n+auto get_awaiter(T &&value) noexcept\n+    -> decltype(get_awaiter_impl(static_cast<T &&>(value), 123)) {\n+  return get_awaiter_impl(static_cast<T &&>(value), 123);\n+}\n+\n+template <typename T, typename = void> struct awaitable_traits {\n+  using awaiter_t = decltype(get_awaiter(std::declval<T>()));\n+  using await_result_t = decltype(std::declval<awaiter_t>().await_resume());\n+};\n+\n+template <typename TASK_CONTAINER> class when_all_ready_awaitable;\n+template <typename... TASKS>\n+class when_all_ready_awaitable<std::tuple<TASKS...>> {\n+public:\n+  explicit when_all_ready_awaitable(std::tuple<TASKS...> &&tasks) noexcept\n+    : m_tasks(std::move(tasks)) {}\n+  auto operator co_await() &&noexcept {\n+    struct awaiter {\n+      awaiter(when_all_ready_awaitable &awaitable) noexcept\n+        : m_awaitable(awaitable) {}\n+      bool await_ready() const noexcept { return false; }\n+      bool await_suspend() noexcept { return false; }\n+      std::tuple<TASKS...> &&await_resume() noexcept {\n+        return std::move(m_awaitable.m_tasks);\n+      }\n+      when_all_ready_awaitable& m_awaitable;\n+    };\n+    return awaiter{*this};\n+  }\n+  std::tuple<TASKS...> m_tasks;\n+};\n+\n+inline void *operator new(std::size_t, void *__p) noexcept;\n+\n+template <typename RESULT>\n+class when_all_task_promise final{\n+public:\n+  using coroutine_handle_t = std::coroutine_handle<when_all_task_promise>;\n+  RESULT &&result() &&;\n+};\n+template <typename RESULT> class when_all_task final {\n+public:\n+  using promise_type = when_all_task_promise<RESULT>;\n+  using coroutine_handle_t = typename promise_type::coroutine_handle_t;\n+  decltype(auto) result() &;\n+  decltype(auto) result() && {\n+    return std::move(m_coroutine.promise()).result();\n+  }\n+  decltype(auto) non_void_result() && {\n+    if constexpr (std::is_void_v<decltype(0)>)\n+      ;\n+    else\n+      return std::move(*this).result();\n+  }\n+  coroutine_handle_t m_coroutine;\n+};\n+class task;\n+template <typename AWAITABLE,\n+          typename RESULT = \n+              typename awaitable_traits<AWAITABLE &&>::await_result_t,\n+          std::enable_if_t<!std::is_void_v<RESULT>, int> = 0>\n+when_all_task<RESULT> make_when_all_task(AWAITABLE awaitable);\n+\n+template <typename... AWAITABLES>\n+inline auto when_all_ready(AWAITABLES &&... awaitables) {\n+  return when_all_ready_awaitable<\n+      std::tuple<when_all_task<typename awaitable_traits<\n+          std::remove_reference_t<AWAITABLES>>::await_result_t>...>>(\n+      std::make_tuple(\n+          make_when_all_task(std::forward<AWAITABLES>(awaitables))...));\n+}\n+\n+template <typename FUNC, typename AWAITABLE> class fmap_awaiter {\n+  using awaiter_t = typename awaitable_traits<AWAITABLE &&>::awaiter_t;\n+\n+public:\n+  fmap_awaiter(FUNC &&func, AWAITABLE &&awaitable) noexcept\n+      : m_func(static_cast<FUNC &&>(func)),\n+        m_awaiter(get_awaiter(static_cast<AWAITABLE &&>(awaitable))) {}\n+  decltype(auto) await_ready() noexcept {\n+    return static_cast<awaiter_t &&>(m_awaiter).await_ready();\n+  }\n+  template <typename PROMISE>\n+  decltype(auto) await_suspend(std::coroutine_handle<PROMISE> coro) noexcept {}\n+  template <typename AWAIT_RESULT =\n+                decltype(std::declval<awaiter_t>().await_resume()),\n+            std::enable_if_t<!std::is_void_v<AWAIT_RESULT>, int> = 0>\n+  decltype(auto) await_resume() noexcept {\n+    return std::invoke(static_cast<FUNC &&>(m_func),\n+                       static_cast<awaiter_t &&>(m_awaiter).await_resume());\n+  }\n+\n+private:\n+  FUNC &&m_func;\n+  awaiter_t m_awaiter;\n+};\n+template <typename FUNC, typename AWAITABLE> class fmap_awaitable {\n+public:\n+  template <\n+      typename FUNC_ARG, typename AWAITABLE_ARG,\n+      std::enable_if_t<std::is_constructible_v<FUNC, FUNC_ARG &&> &&\n+                           std::is_constructible_v<AWAITABLE, AWAITABLE_ARG &&>,\n+                       int> = 0>\n+  explicit fmap_awaitable(FUNC_ARG &&func, AWAITABLE_ARG &&awaitable) noexcept\n+      : m_func(static_cast<FUNC_ARG &&>(func)),\n+        m_awaitable(static_cast<AWAITABLE_ARG &&>(awaitable)) {}\n+  auto operator co_await() && {\n+    return fmap_awaiter(static_cast<FUNC &&>(m_func),\n+                        static_cast<AWAITABLE &&>(m_awaitable));\n+  }\n+\n+private:\n+  FUNC m_func;\n+  AWAITABLE m_awaitable;\n+};\n+\n+template <typename FUNC, typename AWAITABLE>\n+auto fmap(FUNC &&func, AWAITABLE &&awaitable) {\n+  return fmap_awaitable<std::remove_cv_t<std::remove_reference_t<FUNC>>,\n+                        std::remove_cv_t<std::remove_reference_t<AWAITABLE>>>(\n+      std::forward<FUNC>(func), std::forward<AWAITABLE>(awaitable));\n+}\n+template <typename... AWAITABLES>\n+auto when_all(AWAITABLES &&... awaitables) {\n+  return fmap(\n+      [](auto &&taskTuple) {\n+        decltype(auto) __trans_tmp_1 = std::apply(\n+            [](auto &&... tasks) {\n+              return std::make_tuple(\n+                  static_cast<decltype(tasks)>(tasks).non_void_result()...);\n+            },\n+            static_cast<decltype(taskTuple)>(taskTuple));\n+        return __trans_tmp_1;\n+      },\n+      when_all_ready(std::forward<AWAITABLES>(awaitables)...));\n+}\n+class async_mutex_scoped_lock_operation;\n+class async_mutex {\n+public:\n+  async_mutex() noexcept;\n+  async_mutex_scoped_lock_operation scoped_lock_async() noexcept;\n+};\n+class async_mutex_lock {\n+public:\n+  explicit async_mutex_lock();\n+  ~async_mutex_lock();\n+\n+private:\n+  async_mutex *m_mutex;\n+};\n+class async_mutex_scoped_lock_operation {\n+public:\n+  async_mutex_lock await_resume() const noexcept;\n+};\n+class task {\n+public:\n+  class promise_type {\n+  public:\n+    auto initial_suspend() noexcept { return std::suspend_always{}; }\n+    auto final_suspend() noexcept { return std::suspend_always{}; }\n+    task get_return_object() noexcept { return task{}; }\n+    void unhandled_exception() noexcept {}\n+    void return_value(int value) noexcept { v = value; }\n+    int result(){ return v; }\n+    int v = 0;\n+  };\n+public:\n+  task() noexcept {}\n+  auto operator co_await() const &noexcept {\n+    struct awaitable {\n+      std::coroutine_handle<promise_type> m_coroutine;\n+      decltype(auto) await_resume() {\n+        return this->m_coroutine.promise().result();\n+      }\n+    };\n+    return awaitable{};\n+  }\n+};\n+void foo() {\n+  (void) []() -> task {\n+    auto makeTask = [](int x) -> task { co_return x; };\n+    async_mutex_scoped_lock_operation op;\n+    co_await when_all(std::move(op), makeTask(123));\n+  }();\n+}"}]}