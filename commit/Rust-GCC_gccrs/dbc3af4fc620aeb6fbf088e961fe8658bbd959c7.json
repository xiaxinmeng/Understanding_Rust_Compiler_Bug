{"sha": "dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJjM2FmNGZjNjIwYWViNmZiZjA4OGU5NjFmZTg2NThiYmQ5NTljNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:56:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:56:52Z"}, "message": "SVE unwinding\n\nThis patch adds support for unwinding frames that use the SVE\npseudo VG register.  We want this register to act like a normal\nregister if the CFI explicitly sets it, but want to provide a\ndefault value otherwise.  Computing the default value requires\nan SVE target, so we only want to compute it on demand.\n\naarch64_vg uses a hard-coded .inst in order to avoid a build\ndependency on binutils 2.28 or later.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/tm.texi.in (DWARF_LAZY_REGISTER_VALUE): Document.\n\t* doc/tm.texi: Regenerate.\n\nlibgcc/\n\t* config/aarch64/value-unwind.h (aarch64_vg): New function.\n\t(DWARF_LAZY_REGISTER_VALUE): Define.\n\t* unwind-dw2.c (_Unwind_GetGR): Use DWARF_LAZY_REGISTER_VALUE\n\tto provide a fallback register value.\n\ngcc/testsuite/\n\t* g++.target/aarch64/sve/aarch64-sve.exp: New harness.\n\t* g++.target/aarch64/sve/catch_1.C: New test.\n\t* g++.target/aarch64/sve/catch_2.C: Likewise.\n\t* g++.target/aarch64/sve/catch_3.C: Likewise.\n\t* g++.target/aarch64/sve/catch_4.C: Likewise.\n\t* g++.target/aarch64/sve/catch_5.C: Likewise.\n\t* g++.target/aarch64/sve/catch_6.C: Likewise.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nFrom-SVN: r256615", "tree": {"sha": "cbbcda2f43cf257940616199a72d7b22c5d92a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbbcda2f43cf257940616199a72d7b22c5d92a50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/comments", "author": null, "committer": null, "parents": [{"sha": "825b856cd08968694085aa13d0b937520b67a19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825b856cd08968694085aa13d0b937520b67a19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825b856cd08968694085aa13d0b937520b67a19d"}], "stats": {"total": 353, "additions": 349, "deletions": 4}, "files": [{"sha": "64951e9d78c11fd6d7c9bac035b25100b2829c2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -1,3 +1,8 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/tm.texi.in (DWARF_LAZY_REGISTER_VALUE): Document.\n+\t* doc/tm.texi: Regenerate.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "4cd8dcea3951990289ee8efd7776f1abc12c923a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -3621,6 +3621,13 @@ defined and 0 otherwise.\n \n @end defmac\n \n+@defmac DWARF_LAZY_REGISTER_VALUE (@var{regno}, @var{value})\n+Define this macro if the target has pseudo DWARF registers whose\n+values need to be computed lazily on demand by the unwinder (such as when\n+referenced in a CFA expression).  The macro returns true if @var{regno}\n+is such a register and stores its value in @samp{*@var{value}} if so.\n+@end defmac\n+\n @node Elimination\n @subsection Eliminating Frame Pointer and Arg Pointer\n "}, {"sha": "3a2c2f26141711c66b31d8704380d99b88d97073", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -3002,6 +3002,13 @@ defined and 0 otherwise.\n \n @end defmac\n \n+@defmac DWARF_LAZY_REGISTER_VALUE (@var{regno}, @var{value})\n+Define this macro if the target has pseudo DWARF registers whose\n+values need to be computed lazily on demand by the unwinder (such as when\n+referenced in a CFA expression).  The macro returns true if @var{regno}\n+is such a register and stores its value in @samp{*@var{value}} if so.\n+@end defmac\n+\n @node Elimination\n @subsection Eliminating Frame Pointer and Arg Pointer\n "}, {"sha": "48f40dad147b560e06062d8ca3a4dfcf69950e06", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -1,3 +1,13 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* g++.target/aarch64/sve/aarch64-sve.exp: New harness.\n+\t* g++.target/aarch64/sve/catch_1.C: New test.\n+\t* g++.target/aarch64/sve/catch_2.C: Likewise.\n+\t* g++.target/aarch64/sve/catch_3.C: Likewise.\n+\t* g++.target/aarch64/sve/catch_4.C: Likewise.\n+\t* g++.target/aarch64/sve/catch_5.C: Likewise.\n+\t* g++.target/aarch64/sve/catch_6.C: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "7557aa67b58f1a6a51a951d164f57387634ae03c", "filename": "gcc/testsuite/g++.target/aarch64/sve/aarch64-sve.exp", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Faarch64-sve.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Faarch64-sve.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Faarch64-sve.exp?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -0,0 +1,45 @@\n+#  Specific regression driver for AArch64.\n+#  Copyright (C) 2009-2017 Free Software Foundation, Inc.\n+#  Contributed by ARM Ltd.\n+#\n+#  This file is part of GCC.\n+#\n+#  GCC is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by\n+#  the Free Software Foundation; either version 3, or (at your option)\n+#  any later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but\n+#  WITHOUT ANY WARRANTY; without even the implied warranty of\n+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+#  General Public License for more details.\n+#\n+#  You should have received a copy of the GNU General Public License\n+#  along with GCC; see the file COPYING3.  If not see\n+#  <http://www.gnu.org/licenses/>.  */\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an AArch64 target.\n+if {![istarget aarch64*-*-*] } then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Force SVE if we're not testing it already.\n+if { [check_effective_target_aarch64_sve] } {\n+    set sve_flags \"\"\n+} else {\n+    set sve_flags \"-march=armv8.2-a+sve\"\n+}\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] $sve_flags \"\"\n+\n+# All done.\n+dg-finish"}, {"sha": "39759cb00f9e88c802bc0316648e647b0f2479b7", "filename": "gcc/testsuite/g++.target/aarch64/sve/catch_1.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_1.C?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 -fopenmp-simd -fno-omit-frame-pointer\" } */\n+\n+/* Invoke X (P##n) for n in [0, 7].  */\n+#define REPEAT8(X, P) \\\n+  X (P##0) X (P##1) X (P##2) X (P##3) X (P##4) X (P##5) X (P##6) X (P##7)\n+\n+/* Invoke X (n) for all octal n in [0, 39].  */\n+#define REPEAT40(X) \\\n+  REPEAT8 (X, 0) REPEAT8 (X, 1)  REPEAT8 (X, 2) REPEAT8 (X, 3) REPEAT8 (X, 4)\n+\n+volatile int testi;\n+\n+/* Throw to f3.  */\n+void __attribute__ ((weak))\n+f1 (int x[40][100], int *y)\n+{\n+  /* A wild write to x and y.  */\n+  asm volatile (\"\" ::: \"memory\");\n+  if (y[testi] == x[testi][testi])\n+    throw 100;\n+}\n+\n+/* Expect vector work to be done, with spilling of vector registers.  */\n+void __attribute__ ((weak))\n+f2 (int x[40][100], int *y)\n+{\n+  /* Try to force some spilling.  */\n+#define DECLARE(N) int y##N = y[N];\n+  REPEAT40 (DECLARE);\n+  for (int j = 0; j < 20; ++j)\n+    {\n+      f1 (x, y);\n+#pragma omp simd\n+      for (int i = 0; i < 100; ++i)\n+\t{\n+#define INC(N) x[N][i] += y##N;\n+\t  REPEAT40 (INC);\n+\t}\n+    }\n+}\n+\n+/* Catch an exception thrown from f1, via f2.  */\n+void __attribute__ ((weak))\n+f3 (int x[40][100], int *y, int *z)\n+{\n+  volatile int extra = 111;\n+  try\n+    {\n+      f2 (x, y);\n+    }\n+  catch (int val)\n+    {\n+      *z = val + extra;\n+    }\n+}\n+\n+static int x[40][100];\n+static int y[40];\n+static int z;\n+\n+int\n+main (void)\n+{\n+  f3 (x, y, &z);\n+  if (z != 211)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "7722af187d8e8617b6ff86d7c19ab850da6e8364", "filename": "gcc/testsuite/g++.target/aarch64/sve/catch_2.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_2.C?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 -fopenmp-simd -fomit-frame-pointer\" } */\n+\n+#include \"catch_1.C\""}, {"sha": "7d170245ebd2482cc7f2f8be030b411a80c36ee2", "filename": "gcc/testsuite/g++.target/aarch64/sve/catch_3.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_3.C?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 -fopenmp-simd -fno-omit-frame-pointer\" } */\n+\n+/* Invoke X (P##n) for n in [0, 7].  */\n+#define REPEAT8(X, P) \\\n+  X (P##0) X (P##1) X (P##2) X (P##3) X (P##4) X (P##5) X (P##6) X (P##7)\n+\n+/* Invoke X (n) for all octal n in [0, 39].  */\n+#define REPEAT40(X) \\\n+  REPEAT8 (X, 0) REPEAT8 (X, 1)  REPEAT8 (X, 2) REPEAT8 (X, 3) REPEAT8 (X, 4)\n+\n+volatile int testi, sink;\n+\n+/* Take 2 stack arguments and throw to f3.  */\n+void __attribute__ ((weak))\n+f1 (int x[40][100], int *y, int z1, int z2, int z3, int z4,\n+    int z5, int z6, int z7, int z8)\n+{\n+  /* A wild write to x and y.  */\n+  sink = z1;\n+  sink = z2;\n+  sink = z3;\n+  sink = z4;\n+  sink = z5;\n+  sink = z6;\n+  sink = z7;\n+  sink = z8;\n+  asm volatile (\"\" ::: \"memory\");\n+  if (y[testi] == x[testi][testi])\n+    throw 100;\n+}\n+\n+/* Expect vector work to be done, with spilling of vector registers.  */\n+void __attribute__ ((weak))\n+f2 (int x[40][100], int *y)\n+{\n+  /* Try to force some spilling.  */\n+#define DECLARE(N) int y##N = y[N];\n+  REPEAT40 (DECLARE);\n+  for (int j = 0; j < 20; ++j)\n+    {\n+      f1 (x, y, 1, 2, 3, 4, 5, 6, 7, 8);\n+#pragma omp simd\n+      for (int i = 0; i < 100; ++i)\n+\t{\n+#define INC(N) x[N][i] += y##N;\n+\t  REPEAT40 (INC);\n+\t}\n+    }\n+}\n+\n+/* Catch an exception thrown from f1, via f2.  */\n+void __attribute__ ((weak))\n+f3 (int x[40][100], int *y, int *z)\n+{\n+  volatile int extra = 111;\n+  try\n+    {\n+      f2 (x, y);\n+    }\n+  catch (int val)\n+    {\n+      *z = val + extra;\n+    }\n+}\n+\n+static int x[40][100];\n+static int y[40];\n+static int z;\n+\n+int\n+main (void)\n+{\n+  f3 (x, y, &z);\n+  if (z != 211)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "07841acf6ee76012f9430b565e29c4a87f11c073", "filename": "gcc/testsuite/g++.target/aarch64/sve/catch_4.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_4.C?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 -fopenmp-simd -fomit-frame-pointer\" } */\n+\n+#include \"catch_3.C\""}, {"sha": "0eee6f022da943e762690ce4f0f97da45c5afe7a", "filename": "gcc/testsuite/g++.target/aarch64/sve/catch_5.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_5.C?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 -fopenmp-simd -fno-omit-frame-pointer\" } */\n+\n+/* Invoke X (P##n) for n in [0, 7].  */\n+#define REPEAT8(X, P) \\\n+  X (P##0) X (P##1) X (P##2) X (P##3) X (P##4) X (P##5) X (P##6) X (P##7)\n+\n+/* Invoke X (n) for all octal n in [0, 39].  */\n+#define REPEAT40(X) \\\n+  REPEAT8 (X, 0) REPEAT8 (X, 1)  REPEAT8 (X, 2) REPEAT8 (X, 3) REPEAT8 (X, 4)\n+\n+volatile int testi, sink;\n+volatile void *ptr;\n+\n+/* Take 2 stack arguments and throw to f3.  */\n+void __attribute__ ((weak))\n+f1 (int x[40][100], int *y, int z1, int z2, int z3, int z4,\n+    int z5, int z6, int z7, int z8)\n+{\n+  /* A wild write to x and y.  */\n+  sink = z1;\n+  sink = z2;\n+  sink = z3;\n+  sink = z4;\n+  sink = z5;\n+  sink = z6;\n+  sink = z7;\n+  sink = z8;\n+  asm volatile (\"\" ::: \"memory\");\n+  if (y[testi] == x[testi][testi])\n+    throw 100;\n+}\n+\n+/* Expect vector work to be done, with spilling of vector registers.  */\n+void __attribute__ ((weak))\n+f2 (int x[40][100], int *y)\n+{\n+  /* Create a true variable-sized frame.  */\n+  ptr = __builtin_alloca (testi + 40);\n+  /* Try to force some spilling.  */\n+#define DECLARE(N) int y##N = y[N];\n+  REPEAT40 (DECLARE);\n+  for (int j = 0; j < 20; ++j)\n+    {\n+      f1 (x, y, 1, 2, 3, 4, 5, 6, 7, 8);\n+#pragma omp simd\n+      for (int i = 0; i < 100; ++i)\n+\t{\n+#define INC(N) x[N][i] += y##N;\n+\t  REPEAT40 (INC);\n+\t}\n+    }\n+}\n+\n+/* Catch an exception thrown from f1, via f2.  */\n+void __attribute__ ((weak))\n+f3 (int x[40][100], int *y, int *z)\n+{\n+  volatile int extra = 111;\n+  try\n+    {\n+      f2 (x, y);\n+    }\n+  catch (int val)\n+    {\n+      *z = val + extra;\n+    }\n+}\n+\n+static int x[40][100];\n+static int y[40];\n+static int z;\n+\n+int\n+main (void)\n+{\n+  f3 (x, y, &z);\n+  if (z != 211)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "45f204a981424e504c79b7e7c87742065993a783", "filename": "gcc/testsuite/g++.target/aarch64/sve/catch_6.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fsve%2Fcatch_6.C?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 -fopenmp-simd -fomit-frame-pointer\" } */\n+\n+#include \"catch_5.C\""}, {"sha": "85738df894f2565c17e61c37e9119ce882e306c5", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -1,3 +1,10 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/aarch64/value-unwind.h (aarch64_vg): New function.\n+\t(DWARF_LAZY_REGISTER_VALUE): Define.\n+\t* unwind-dw2.c (_Unwind_GetGR): Use DWARF_LAZY_REGISTER_VALUE\n+\tto provide a fallback register value.\n+\n 2018-01-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/quad-float128.h (IBM128_TYPE): Explicitly use"}, {"sha": "e15396250b0ad04b6b58ff46bad23b9d51bb146d", "filename": "libgcc/config/aarch64/value-unwind.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/libgcc%2Fconfig%2Faarch64%2Fvalue-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/libgcc%2Fconfig%2Faarch64%2Fvalue-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Fvalue-unwind.h?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -23,3 +23,19 @@\n #if defined __aarch64__ && !defined __LP64__\n # define REG_VALUE_IN_UNWIND_CONTEXT\n #endif\n+\n+/* Return the value of the pseudo VG register.  This should only be\n+   called if we know this is an SVE host.  */\n+static inline int\n+aarch64_vg (void)\n+{\n+  register int vg asm (\"x0\");\n+  /* CNTD X0.  */\n+  asm (\".inst 0x04e0e3e0\" : \"=r\" (vg));\n+  return vg;\n+}\n+\n+/* Lazily provide a value for VG, so that we don't try to execute SVE\n+   instructions unless we know they're needed.  */\n+#define DWARF_LAZY_REGISTER_VALUE(REGNO, VALUE) \\\n+  ((REGNO) == AARCH64_DWARF_VG && ((*VALUE) = aarch64_vg (), 1))"}, {"sha": "de9310f524fc1f5103b6df2e024c50454a53a1c0", "filename": "libgcc/unwind-dw2.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/libgcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc3af4fc620aeb6fbf088e961fe8658bbd959c7/libgcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2.c?ref=dbc3af4fc620aeb6fbf088e961fe8658bbd959c7", "patch": "@@ -216,27 +216,35 @@ _Unwind_IsExtendedContext (struct _Unwind_Context *context)\n \t  || (context->flags & EXTENDED_CONTEXT_BIT));\n }\n \f\n-/* Get the value of register INDEX as saved in CONTEXT.  */\n+/* Get the value of register REGNO as saved in CONTEXT.  */\n \n inline _Unwind_Word\n-_Unwind_GetGR (struct _Unwind_Context *context, int index)\n+_Unwind_GetGR (struct _Unwind_Context *context, int regno)\n {\n-  int size;\n+  int size, index;\n   _Unwind_Context_Reg_Val val;\n \n #ifdef DWARF_ZERO_REG\n   if (index == DWARF_ZERO_REG)\n     return 0;\n #endif\n \n-  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n+  index = DWARF_REG_TO_UNWIND_COLUMN (regno);\n   gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n   size = dwarf_reg_size_table[index];\n   val = context->reg[index];\n \n   if (_Unwind_IsExtendedContext (context) && context->by_value[index])\n     return _Unwind_Get_Unwind_Word (val);\n \n+#ifdef DWARF_LAZY_REGISTER_VALUE\n+  {\n+    _Unwind_Word value;\n+    if (DWARF_LAZY_REGISTER_VALUE (regno, &value))\n+      return value;\n+  }\n+#endif\n+\n   /* This will segfault if the register hasn't been saved.  */\n   if (size == sizeof(_Unwind_Ptr))\n     return * (_Unwind_Ptr *) (_Unwind_Internal_Ptr) val;"}]}