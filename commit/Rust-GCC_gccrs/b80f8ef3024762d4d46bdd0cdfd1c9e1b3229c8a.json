{"sha": "b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgwZjhlZjMwMjQ3NjJkNGQ0NmJkZDBjZGZkMWM5ZTFiMzIyOWM4YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-02-04T07:23:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-02-04T07:23:14Z"}, "message": "re PR c++/7129 (ICE with min/max assignment operators (<?= and >?=))\n\n\n\tPR c++/7129\n\t* call.c (z_candidate): Add args.\n\t(convert_class_to_reference): Set it.\n\t(implicit_conversion): Tidy.\n\t(add_candidate): Add args parameter.\n\t(add_function_candidate): Adjust call to add_candidate.\n\t(add_conv_candidate): Likewise.\n\t(build_builtin_candidate): Likewise.\n\t(build_user_type_conversion_1): Eliminate wasteful tree_cons\n\tusage.\n\t(build_new_function_call): Likewise.\n\t(build_object_call): Likewise.\n\t(add_candidates): New function.\n\t(build_new_op): Use it.\n\t(covert_like_real): Adjust call to build_over_call.\n\t(build_over_call): Remove args parameter.\n\t* operators.def: Add <?= and >?=.\n\n\tPR c++/7129\n\t* testsuite/g++.dg/ext/max.C: New test.\n\nFrom-SVN: r62370", "tree": {"sha": "24fa99d18a5f9c7f599d81c1d05d6ed1cc2e1f5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24fa99d18a5f9c7f599d81c1d05d6ed1cc2e1f5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/comments", "author": null, "committer": null, "parents": [{"sha": "b3a8389d1892fa92870da786523894ad36c8f991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a8389d1892fa92870da786523894ad36c8f991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a8389d1892fa92870da786523894ad36c8f991"}], "stats": {"total": 345, "additions": 195, "deletions": 150}, "files": [{"sha": "78017c3ba5a0f143bb2b8472437c7451b26eee17", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "patch": "@@ -1,3 +1,23 @@\n+2003-02-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/7129\n+\t* call.c (z_candidate): Add args.\n+\t(convert_class_to_reference): Set it.\n+\t(implicit_conversion): Tidy.\n+\t(add_candidate): Add args parameter.\n+\t(add_function_candidate): Adjust call to add_candidate.\n+\t(add_conv_candidate): Likewise.\n+\t(build_builtin_candidate): Likewise.\n+\t(build_user_type_conversion_1): Eliminate wasteful tree_cons\n+\tusage.\n+\t(build_new_function_call): Likewise.\n+\t(build_object_call): Likewise.\n+\t(add_candidates): New function.\n+\t(build_new_op): Use it.\n+\t(covert_like_real): Adjust call to build_over_call.\n+\t(build_over_call): Remove args parameter.\n+\t* operators.def: Add <?= and >?=.\n+\n 2003-02-01  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* typeck.c (build_indirect_ref): Don't check flag_volatile."}, {"sha": "5a2f8f18a7dc832aad78ff592b3890f00e7044da", "filename": "gcc/cp/call.c", "status": "modified", "additions": 158, "deletions": 147, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "patch": "@@ -44,7 +44,7 @@ static struct z_candidate * tourney (struct z_candidate *);\n static int equal_functions (tree, tree);\n static int joust (struct z_candidate *, struct z_candidate *, bool);\n static int compare_ics (tree, tree);\n-static tree build_over_call (struct z_candidate *, tree, int);\n+static tree build_over_call (struct z_candidate *, int);\n static tree build_java_interface_fn_ref (tree, tree);\n #define convert_like(CONV, EXPR) \\\n   convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0)\n@@ -92,7 +92,7 @@ static bool is_subseq (tree, tree);\n static tree maybe_handle_ref_bind (tree *);\n static void maybe_handle_implicit_object (tree *);\n static struct z_candidate *add_candidate \n-        (struct z_candidate *, tree, tree, tree, tree, int);\n+        (struct z_candidate *, tree, tree, tree, tree, tree, int);\n static tree source_type (tree);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n static bool reference_related_p (tree, tree);\n@@ -104,6 +104,8 @@ static tree conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n static tree call_builtin_trap (void);\n static tree prep_operand (tree);\n+static struct z_candidate *add_candidates (tree, tree, tree, tree,\n+\t\t\t\t\t   int, struct z_candidate *);\n \n tree\n build_vfield_ref (tree datum, tree type)\n@@ -556,6 +558,8 @@ struct z_candidate GTY(()) {\n   /* The FUNCTION_DECL that will be called if this candidate is\n      selected by overload resolution.  */\n   tree fn;\n+  /* The arguments to use when calling this function.  */\n+  tree args;\n   tree convs;\n   tree second_conv;\n   int viable;\n@@ -1034,6 +1038,12 @@ convert_class_to_reference (tree t, tree s, tree expr)\n   if (!cand)\n     return NULL_TREE;\n \n+  /* Now that we know that this is the function we're going to use fix\n+     the dummy first argument.  */\n+  cand->args = tree_cons (NULL_TREE,\n+\t\t\t  build_this (expr),\n+\t\t\t  TREE_CHAIN (cand->args));\n+\n   conv = build1 (IDENTITY_CONV, s, expr);\n   conv = build_conv (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n \t\t     conv);\n@@ -1269,11 +1279,12 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n     conv = standard_conversion (to, from, expr);\n \n   if (conv)\n-    ;\n-  else if (expr != NULL_TREE\n-\t   && (IS_AGGR_TYPE (from)\n-\t       || IS_AGGR_TYPE (to))\n-\t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n+    return conv;\n+\n+  if (expr != NULL_TREE\n+      && (IS_AGGR_TYPE (from)\n+\t  || IS_AGGR_TYPE (to))\n+      && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n       cand = build_user_type_conversion_1\n \t(to, expr, LOOKUP_ONLYCONVERTING);\n@@ -1283,23 +1294,25 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n       /* We used to try to bind a reference to a temporary here, but that\n \t is now handled by the recursive call to this function at the end\n \t of reference_binding.  */\n+      return conv;\n     }\n \n-  return conv;\n+  return NULL_TREE;\n }\n \n /* Add a new entry to the list of candidates.  Used by the add_*_candidate\n    functions.  */\n \n static struct z_candidate *\n add_candidate (struct z_candidate *candidates, \n-\t       tree fn, tree convs, tree access_path, tree\n-\t       conversion_path, int viable)\n+\t       tree fn, tree args, tree convs, tree access_path, \n+\t       tree conversion_path, int viable)\n {\n   struct z_candidate *cand\n     = (struct z_candidate *) ggc_alloc_cleared (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n+  cand->args = args;\n   cand->convs = convs;\n   cand->access_path = access_path;\n   cand->conversion_path = conversion_path;\n@@ -1326,15 +1339,19 @@ add_function_candidate (struct z_candidate *candidates,\n   int i, len;\n   tree convs;\n   tree parmnode, argnode;\n+  tree orig_arglist;\n   int viable = 1;\n \n   /* The `this', `in_chrg' and VTT arguments to constructors are not\n      considered in overload resolution.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n       parmlist = skip_artificial_parms_for (fn, parmlist);\n+      orig_arglist = arglist;\n       arglist = skip_artificial_parms_for (fn, arglist);\n     }\n+  else \n+    orig_arglist = arglist;\n \n   len = list_length (arglist);\n   convs = make_tree_vec (len);\n@@ -1432,7 +1449,7 @@ add_function_candidate (struct z_candidate *candidates,\n     }\n \n  out:\n-  return add_candidate (candidates, fn, convs, access_path,\n+  return add_candidate (candidates, fn, orig_arglist, convs, access_path,\n \t\t\tconversion_path, viable);\n }\n \n@@ -1509,7 +1526,7 @@ add_conv_candidate (struct z_candidate *candidates, tree fn, tree obj,\n   if (!sufficient_parms_p (parmnode))\n     viable = 0;\n \n-  return add_candidate (candidates, totype, convs, access_path,\n+  return add_candidate (candidates, totype, arglist, convs, access_path,\n \t\t\tconversion_path, viable);\n }\n \n@@ -1556,7 +1573,7 @@ build_builtin_candidate (struct z_candidate *candidates, tree fnname,\n \tviable = 0;\n     }      \n \n-  return add_candidate (candidates, fnname, convs, \n+  return add_candidate (candidates, fnname, /*args=*/NULL_TREE, convs, \n \t\t\t/*access_path=*/NULL_TREE,\n \t\t\t/*conversion_path=*/NULL_TREE,\n \t\t\tviable);\n@@ -2396,7 +2413,6 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   tree fromtype = TREE_TYPE (expr);\n   tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n   tree args = NULL_TREE;\n-  tree templates = NULL_TREE;\n \n   /* We represent conversion within a hierarchy using RVALUE_CONV and\n      BASE_CONV, as specified by [over.best.ics]; these become plain\n@@ -2438,16 +2454,13 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \tcontinue;\n \n       if (TREE_CODE (ctor) == TEMPLATE_DECL) \n-\t{\n-\t  templates = tree_cons (NULL_TREE, ctor, templates);\n-\t  candidates = \n-\t    add_template_candidate (candidates, ctor, totype,\n-\t\t\t\t    NULL_TREE, args, NULL_TREE, \n-\t\t\t\t    TYPE_BINFO (totype),\n-\t\t\t\t    TYPE_BINFO (totype),\n-\t\t\t\t    flags,\n-\t\t\t\t    DEDUCE_CALL);\n-\t}\n+\tcandidates = \n+\t  add_template_candidate (candidates, ctor, totype,\n+\t\t\t\t  NULL_TREE, args, NULL_TREE, \n+\t\t\t\t  TYPE_BINFO (totype),\n+\t\t\t\t  TYPE_BINFO (totype),\n+\t\t\t\t  flags,\n+\t\t\t\t  DEDUCE_CALL);\n       else \n \tcandidates = add_function_candidate (candidates, ctor, totype,\n \t\t\t\t\t     args, TYPE_BINFO (totype), \n@@ -2487,15 +2500,12 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t     So we pass fromtype as CTYPE to add_*_candidate.  */\n \n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    {\n-\t      templates = tree_cons (NULL_TREE, fn, templates);\n-\t      candidates = \n-\t\tadd_template_candidate (candidates, fn, fromtype, NULL_TREE,\n-\t\t\t\t\targs, totype, TYPE_BINFO (fromtype), \n-\t\t\t\t\tconversion_path,\n-\t\t\t\t\tflags,\n-\t\t\t\t\tDEDUCE_CONV);\n-\t    } \n+\t    candidates = \n+\t      add_template_candidate (candidates, fn, fromtype, NULL_TREE,\n+\t\t\t\t      args, totype, TYPE_BINFO (fromtype), \n+\t\t\t\t      conversion_path,\n+\t\t\t\t      flags,\n+\t\t\t\t      DEDUCE_CONV);\n \t  else \n \t    candidates = add_function_candidate (candidates, fn, fromtype,\n \t\t\t\t\t\t args,\n@@ -2695,7 +2705,6 @@ build_new_function_call (tree fn, tree args)\n       || TREE_CODE (fn) == TEMPLATE_DECL)\n     {\n       tree t1;\n-      tree templates = NULL_TREE;\n \n       args = resolve_args (args);\n \n@@ -2709,14 +2718,11 @@ build_new_function_call (tree fn, tree args)\n \t  my_friendly_assert (!DECL_FUNCTION_MEMBER_P (t), 20020913);\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    {\n-\t      templates = tree_cons (NULL_TREE, t, templates);\n-\t      candidates = add_template_candidate\n-\t\t(candidates, t, NULL_TREE, explicit_targs, args, \n-\t\t NULL_TREE, /*access_path=*/NULL_TREE, \n-\t\t /*conversion_path=*/NULL_TREE,\n-\t\t LOOKUP_NORMAL, DEDUCE_CALL);  \n-\t    }\n+\t    candidates = add_template_candidate\n+\t      (candidates, t, NULL_TREE, explicit_targs, args, \n+\t       NULL_TREE, /*access_path=*/NULL_TREE, \n+\t       /*conversion_path=*/NULL_TREE,\n+\t       LOOKUP_NORMAL, DEDUCE_CALL);  \n \t  else if (! template_only)\n \t    candidates = add_function_candidate\n \t      (candidates, t, NULL_TREE, args, \n@@ -2745,7 +2751,7 @@ build_new_function_call (tree fn, tree args)\n \t  return error_mark_node;\n \t}\n \n-      return build_over_call (cand, args, LOOKUP_NORMAL);\n+      return build_over_call (cand, LOOKUP_NORMAL);\n     }\n \n   /* This is not really overloaded.  */\n@@ -2787,14 +2793,12 @@ build_object_call (tree obj, tree args)\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    {\n-\t      candidates \n-\t\t= add_template_candidate (candidates, fn, base, NULL_TREE,\n-\t\t\t\t\t  mem_args, NULL_TREE, \n-\t\t\t\t\t  TYPE_BINFO (type),\n-\t\t\t\t\t  TYPE_BINFO (type),\n-\t\t\t\t\t  LOOKUP_NORMAL, DEDUCE_CALL);\n-\t    }\n+\t    candidates \n+\t      = add_template_candidate (candidates, fn, base, NULL_TREE,\n+\t\t\t\t\tmem_args, NULL_TREE, \n+\t\t\t\t\tTYPE_BINFO (type),\n+\t\t\t\t\tTYPE_BINFO (type),\n+\t\t\t\t\tLOOKUP_NORMAL, DEDUCE_CALL);\n \t  else\n \t    candidates = add_function_candidate\n \t      (candidates, fn, base, mem_args, TYPE_BINFO (type),\n@@ -2855,7 +2859,7 @@ build_object_call (tree obj, tree args)\n      DECL_NAME here.  */\n   if (TREE_CODE (cand->fn) == FUNCTION_DECL\n       && DECL_OVERLOADED_OPERATOR_P (cand->fn) == CALL_EXPR)\n-    return build_over_call (cand, mem_args, LOOKUP_NORMAL);\n+    return build_over_call (cand, LOOKUP_NORMAL);\n \n   obj = convert_like_with_context\n           (TREE_VEC_ELT (cand->convs, 0), obj, cand->fn, -1);\n@@ -3317,13 +3321,78 @@ prep_operand (tree operand)\n   return operand;\n }\n \n+/* Add each of the viable functions in FNS (a FUNCTION_DECL or\n+   OVERLOAD) to the CANDIDATES, returning an updated list of\n+   CANDIDATES.  The ARGS are the arguments provided to the call,\n+   without any implicit object parameter.  CONVERSION_PATH,\n+   ACCESS_PATH, and FLAGS are as for add_function_candidate.  */\n+\n+static struct z_candidate *\n+add_candidates (tree fns, tree args,\n+\t\ttree conversion_path, tree access_path,\n+\t\tint flags,\n+\t\tstruct z_candidate *candidates)\n+{\n+  tree ctype;\n+  tree non_static_args;\n+\n+  ctype = conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE;\n+  /* Delay creating the implicit this parameter until it is needed.  */\n+  non_static_args = NULL_TREE;\n+\n+  while (fns) \n+    {\n+      tree fn;\n+      tree fn_args;\n+\n+      fn = OVL_CURRENT (fns);\n+      /* Figure out which set of arguments to use.  */\n+      if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+\t{\n+\t  /* If this function is a non-static member, prepend the implicit\n+\t     object parameter.  */\n+\t  if (!non_static_args)\n+\t    non_static_args = tree_cons (NULL_TREE,\n+\t\t\t\t\t build_this (TREE_VALUE (args)),\n+\t\t\t\t\t TREE_CHAIN (args));\n+\t  fn_args = non_static_args;\n+\t}\n+      else\n+\t/* Otherwise, just use the list of arguments provided.  */\n+\tfn_args = args;\n+\n+      if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\tcandidates = add_template_candidate (candidates, \n+\t\t\t\t\t     fn, \n+\t\t\t\t\t     ctype,\n+\t\t\t\t\t     NULL_TREE,\n+\t\t\t\t\t     fn_args,\n+\t\t\t\t\t     NULL_TREE,\n+\t\t\t\t\t     access_path,\n+\t\t\t\t\t     conversion_path,\n+\t\t\t\t\t     flags,\n+\t\t\t\t\t     DEDUCE_CALL);\n+      else\n+\tcandidates = add_function_candidate (candidates,\n+\t\t\t\t\t     fn,\n+\t\t\t\t\t     ctype,\n+\t\t\t\t\t     fn_args,\n+\t\t\t\t\t     access_path,\n+\t\t\t\t\t     conversion_path,\n+\t\t\t\t\t     flags);\n+      fns = OVL_NEXT (fns);\n+    }\n+\n+  return candidates;\n+}\n+\n tree\n build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n {\n   struct z_candidate *candidates = 0, *cand;\n-  tree fns, mem_arglist = NULL_TREE, arglist, fnname;\n+  tree arglist, fnname;\n+  tree args[3];\n   enum tree_code code2 = NOP_EXPR;\n-  tree templates = NULL_TREE;\n   tree conv;\n   bool viable_candidates;\n \n@@ -3385,98 +3454,45 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n     arglist = tree_cons (NULL_TREE, arg2, arglist);\n   arglist = tree_cons (NULL_TREE, arg1, arglist);\n \n-  fns = lookup_function_nonclass (fnname, arglist);\n-\n-  if (fns && TREE_CODE (fns) == TREE_LIST)\n-    fns = TREE_VALUE (fns);\n-  for (; fns; fns = OVL_NEXT (fns))\n+  /* Add namespace-scope operators to the list of functions to\n+     consider.  */\n+  candidates = add_candidates (lookup_function_nonclass (fnname, arglist),\n+\t\t\t       arglist, NULL_TREE, NULL_TREE,\n+\t\t\t       flags, candidates);\n+  /* Add class-member operators to the candidate set.  */\n+  if (CLASS_TYPE_P (TREE_TYPE (arg1)))\n     {\n-      tree fn = OVL_CURRENT (fns);\n-      if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t{\n-\t  templates = tree_cons (NULL_TREE, fn, templates);\n-\t  candidates \n-\t    = add_template_candidate (candidates, fn, NULL_TREE, NULL_TREE,\n-\t\t\t\t      arglist, TREE_TYPE (fnname),\n-\t\t\t\t      /*access_path=*/NULL_TREE,\n-\t\t\t\t      /*conversion_path=*/NULL_TREE,\n-\t\t\t\t      flags, DEDUCE_CALL); \n-\t}\n-      else\n-\tcandidates = add_function_candidate (candidates, fn, NULL_TREE,\n-\t\t\t\t\t     arglist,\n-\t\t\t\t\t     /*access_path=*/NULL_TREE,\n-\t\t\t\t\t     /*conversion_path=*/NULL_TREE,\n-\t\t\t\t\t     flags);\n-    }\n+      tree fns;\n \n-  if (IS_AGGR_TYPE (TREE_TYPE (arg1)))\n-    {\n       fns = lookup_fnfields (TYPE_BINFO (TREE_TYPE (arg1)), fnname, 1);\n       if (fns == error_mark_node)\n \treturn fns;\n+      if (fns)\n+\tcandidates = add_candidates (BASELINK_FUNCTIONS (fns), arglist, \n+\t\t\t\t     BASELINK_BINFO (fns),\n+\t\t\t\t     TYPE_BINFO (TREE_TYPE (arg1)),\n+\t\t\t\t     flags, candidates);\n     }\n-  else\n-    fns = NULL_TREE;\n \n-  if (fns)\n+  /* Rearrange the arguments for ?: so that add_builtin_candidate only has\n+     to know about two args; a builtin candidate will always have a first\n+     parameter of type bool.  We'll handle that in\n+     build_builtin_candidate.  */\n+  if (code == COND_EXPR)\n     {\n-      tree conversion_path = BASELINK_BINFO (fns);\n-\n-      mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n-      for (fns = BASELINK_FUNCTIONS (fns); fns; fns = OVL_NEXT (fns))\n-\t{\n-\t  tree fn = OVL_CURRENT (fns);\n-\t  tree this_arglist;\n-\t  tree access_path = TYPE_BINFO (TREE_TYPE (arg1));\n-\n-\t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n-\t    this_arglist = mem_arglist;\n-\t  else\n-\t    this_arglist = arglist;\n-\n-\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t    {\n-\t      /* A member template.  */\n-\t      templates = tree_cons (NULL_TREE, fn, templates);\n-\t      candidates \n-\t\t= add_template_candidate (candidates, fn, \n-\t\t\t\t\t  BINFO_TYPE (conversion_path),\n-\t\t\t\t\t  NULL_TREE,\n-\t\t\t\t\t  this_arglist,  TREE_TYPE (fnname),\n-\t\t\t\t\t  access_path, conversion_path,\n-\t\t\t\t\t  flags, DEDUCE_CALL); \n-\t    }\n-\t  else\n-\t    candidates = add_function_candidate\n-\t      (candidates, fn, BINFO_TYPE (conversion_path), this_arglist, \n-\t       access_path, conversion_path, flags);\n-\t}\n+      args[0] = arg2;\n+      args[1] = arg3;\n+      args[2] = arg1;\n+    }\n+  else\n+    {\n+      args[0] = arg1;\n+      args[1] = arg2;\n+      args[2] = NULL_TREE;\n     }\n \n-  {\n-    tree args[3];\n-\n-    /* Rearrange the arguments for ?: so that add_builtin_candidate only has\n-       to know about two args; a builtin candidate will always have a first\n-       parameter of type bool.  We'll handle that in\n-       build_builtin_candidate.  */\n-    if (code == COND_EXPR)\n-      {\n-\targs[0] = arg2;\n-\targs[1] = arg3;\n-\targs[2] = arg1;\n-      }\n-    else\n-      {\n-\targs[0] = arg1;\n-\targs[1] = arg2;\n-\targs[2] = NULL_TREE;\n-      }\n-\n-    candidates = add_builtin_candidates\n-      (candidates, code, code2, fnname, args, flags);\n-  }\n+  candidates = add_builtin_candidates\n+    (candidates, code, code2, fnname, args, flags);\n \n   switch (code)\n     {\n@@ -3559,11 +3575,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3)\n \t\t\t : candidates->fn);\n \t}\n \n-      return build_over_call\n-\t(cand,\n-\t TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n-\t ? mem_arglist : arglist,\n-\t LOOKUP_NORMAL);\n+      return build_over_call (cand, LOOKUP_NORMAL);\n     }\n \n   /* Check for comparison of different enum types.  */\n@@ -3907,7 +3919,7 @@ convert_like_real (tree convs, tree expr, tree fn, int argnum, int inner)\n \t  }\n \telse\n \t  args = build_this (expr);\n-\texpr = build_over_call (cand, args, LOOKUP_NORMAL);\n+\texpr = build_over_call (cand, LOOKUP_NORMAL);\n \n \t/* If this is a constructor or a function returning an aggr type,\n \t   we need to build up a TARGET_EXPR.  */\n@@ -4238,9 +4250,10 @@ convert_for_arg_passing (tree type, tree val)\n    bitmask of various LOOKUP_* flags which apply to the call itself.  */\n \n static tree\n-build_over_call (struct z_candidate *cand, tree args, int flags)\n+build_over_call (struct z_candidate *cand, int flags)\n {\n   tree fn = cand->fn;\n+  tree args = cand->args;\n   tree convs = cand->convs;\n   tree converted_args = NULL_TREE;\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n@@ -4702,7 +4715,6 @@ build_new_method_call (tree instance, tree fns, tree args,\n   tree mem_args = NULL_TREE, instance_ptr;\n   tree name;\n   tree user_args;\n-  tree templates = NULL_TREE;\n   tree call;\n   tree fn;\n   tree class_type;\n@@ -4807,7 +4819,6 @@ build_new_method_call (tree instance, tree fns, tree args,\n       if (TREE_CODE (t) == TEMPLATE_DECL)\n \t{\n \t  /* A member template.  */\n-\t  templates = tree_cons (NULL_TREE, t, templates);\n \t  candidates = \n \t    add_template_candidate (candidates, t, \n \t\t\t\t    class_type,\n@@ -4888,10 +4899,10 @@ build_new_method_call (tree instance, tree fns, tree args,\n     flags |= LOOKUP_NONVIRTUAL;\n \n   if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE)\n-    call = build_over_call (cand, mem_args, flags);\n+    call = build_over_call (cand, flags);\n   else\n     {\n-      call = build_over_call (cand, args, flags);\n+      call = build_over_call (cand, flags);\n       /* In an expression of the form `a->f()' where `f' turns out to\n \t be a static member function, `a' is none-the-less evaluated.  */\n       if (!is_dummy_object (instance_ptr) && TREE_SIDE_EFFECTS (instance))"}, {"sha": "98e317409287564df29f7d0c761a1e5b691b830e", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "patch": "@@ -5,7 +5,7 @@\n    non-overloadable operators (like the `?:' ternary operator).  \n    Written by Mark Mitchell <mark@codesourcery.com>\n \n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -40,7 +40,7 @@ Boston, MA 02111-1307, USA.  */\n      assignment operators, the same tree-codes are reused; i.e.,\n      `operator +' will also have PLUS_EXPR as its CODE.\n \n-   NEW_MANGLING\n+   MANGLING\n \n      The mangling prefix for the operator, as a C string, and as\n      mangled under the new ABI.  For `operator +', for example, this\n@@ -127,7 +127,7 @@ DEF_SIMPLE_OPERATOR (\"->\", COMPONENT_REF, \"pt\", 2)\n DEF_SIMPLE_OPERATOR (\"[]\", ARRAY_REF, \"ix\", 2)\n DEF_SIMPLE_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", 2)\n DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", 2)\n-/* These are extensions.  */\n+/* These operators are GNU extensions.  */\n DEF_SIMPLE_OPERATOR (\"<?\", MIN_EXPR, \"v23min\", 2)\n DEF_SIMPLE_OPERATOR (\">?\", MAX_EXPR, \"v23max\", 2)\n /* This one is needed for mangling.  */\n@@ -145,6 +145,9 @@ DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", 2)\n DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", 2)\n DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", 2)\n DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", 2)\n+/* These operators are GNU extensions.  */\n+DEF_ASSN_OPERATOR (\"<?=\", MIN_EXPR, \"v23miN\", 2);\n+DEF_ASSN_OPERATOR (\">?=\", MAX_EXPR, \"v23maX\", 2);\n \n /* Ternary operators.  */\n DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", 3)"}, {"sha": "6ed5733aa2126134af06f2bf25513468f7e048cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "patch": "@@ -1,3 +1,8 @@\n+2003-02-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/7129\n+\t* testsuite/g++.dg/ext/max.C: New test.\n+\n Mon Feb  3 16:05:11 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.c-torture/execute/20030203-1.c: New test."}, {"sha": "bc65f1f70279a26b3d96e6c040502e41bc396a42", "filename": "gcc/testsuite/g++.dg/ext/max.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fmax.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fmax.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fmax.C?ref=b80f8ef3024762d4d46bdd0cdfd1c9e1b3229c8a", "patch": "@@ -0,0 +1,6 @@\n+struct s_t { \n+};\n+void foo(void) {\n+  s_t s; int i;\n+  s<?=i; // { dg-error \"\" }\n+}"}]}