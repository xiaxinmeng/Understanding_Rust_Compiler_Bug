{"sha": "3a2bcffac602f5de56537a77db1062984bcefd45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EyYmNmZmFjNjAyZjVkZTU2NTM3YTc3ZGIxMDYyOTg0YmNlZmQ0NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-17T09:28:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-17T09:28:31Z"}, "message": "openmp: Add support for OpenMP 5.1 atomics for C++\n\nBesides the C++ FE changes, I've noticed that the C FE didn't reject\n  #pragma omp atomic capture compare\n  { v = x; x = y; }\nand other forms of atomic swap, this patch fixes that too.  And the\nc-family/ routine needed quite a few changes so that the new code\nin it works fine with both FEs.\n\n2021-09-17  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/c-family/\n\t* c-omp.c (c_finish_omp_atomic): Avoid creating\n\tTARGET_EXPR if test is true, use create_tmp_var_raw instead of\n\tcreate_tmp_var and add a zero initializer to TARGET_EXPRs that\n\thad NULL initializer.  When omitting operands after v = x,\n\tuse type of v rather than type of x.  Fix type of vtmp\n\tTARGET_EXPR.\ngcc/c/\n\t* c-parser.c (c_parser_omp_atomic): Reject atomic swap if capture\n\tis true.\ngcc/cp/\n\t* cp-tree.h (finish_omp_atomic): Add r and weak arguments.\n\t* parser.c (cp_parser_omp_atomic): Update function comment for\n\tOpenMP 5.1 atomics, parse OpenMP 5.1 atomics and fail, compare and\n\tweak clauses.\n\t* semantics.c (finish_omp_atomic): Add r and weak arguments, handle\n\tthem, handle COND_EXPRs.\n\t* pt.c (tsubst_expr): Adjust for COND_EXPR forms that\n\tfinish_omp_atomic can now produce.\ngcc/testsuite/\n\t* c-c++-common/gomp/atomic-18.c: Expect same diagnostics in C++ as in\n\tC.\n\t* c-c++-common/gomp/atomic-25.c: Drop c effective target.\n\t* c-c++-common/gomp/atomic-26.c: Likewise.\n\t* c-c++-common/gomp/atomic-27.c: Likewise.\n\t* c-c++-common/gomp/atomic-28.c: Likewise.\n\t* c-c++-common/gomp/atomic-29.c: Likewise.\n\t* c-c++-common/gomp/atomic-30.c: Likewise.  Adjust expected diagnostics\n\tfor C++ when it differs from C.\n\t(foo): Change return type from double to void.\n\t* g++.dg/gomp/atomic-5.C: Adjust expected diagnostics wording.\n\t* g++.dg/gomp/atomic-20.C: New test.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/atomic-19.c: Drop c effective target.\n\tUse /* */ comments instead of //.\n\t* testsuite/libgomp.c-c++-common/atomic-20.c: Likewise.\n\t* testsuite/libgomp.c-c++-common/atomic-21.c: Likewise.\n\t* testsuite/libgomp.c++/atomic-16.C: New test.\n\t* testsuite/libgomp.c++/atomic-17.C: New test.", "tree": {"sha": "ae688b9db0bfa75b79552f4d331ba4758e7a69cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae688b9db0bfa75b79552f4d331ba4758e7a69cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a2bcffac602f5de56537a77db1062984bcefd45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a2bcffac602f5de56537a77db1062984bcefd45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a2bcffac602f5de56537a77db1062984bcefd45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a2bcffac602f5de56537a77db1062984bcefd45/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48b3caffcacc99adf72ba1be189a7d9ebc4190be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b3caffcacc99adf72ba1be189a7d9ebc4190be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48b3caffcacc99adf72ba1be189a7d9ebc4190be"}], "stats": {"total": 1756, "additions": 1652, "deletions": 104}, "files": [{"sha": "476abc124b249388f13da95c42d5bb139c9c8f27", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -376,7 +376,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \treturn error_mark_node;\n       gcc_assert (TREE_CODE (rhs1) == EQ_EXPR);\n       tree cmptype = TREE_TYPE (TREE_OPERAND (rhs1, 0));\n-      if (SCALAR_FLOAT_TYPE_P (cmptype))\n+      if (SCALAR_FLOAT_TYPE_P (cmptype) && !test)\n \t{\n \t  bool clear_padding = false;\n \t  if (BITS_PER_UNIT == 8 && CHAR_BIT == 8)\n@@ -443,12 +443,14 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t}\n \t    }\n \t}\n-      if (r)\n+      if (r && test)\n+\trtmp = rhs1;\n+      else if (r)\n \t{\n-\t  tree var = create_tmp_var (boolean_type_node);\n+\t  tree var = create_tmp_var_raw (boolean_type_node);\n \t  DECL_CONTEXT (var) = current_function_decl;\n \t  rtmp = build4 (TARGET_EXPR, boolean_type_node, var,\n-\t\t\t NULL, NULL, NULL);\n+\t\t\t boolean_false_node, NULL, NULL);\n \t  save = in_late_binary_op;\n \t  in_late_binary_op = true;\n \t  x = build_modify_expr (loc, var, NULL_TREE, NOP_EXPR,\n@@ -529,14 +531,11 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t    }\n \t}\n       if (blhs)\n+\tx = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), x,\n+\t\t\tbitsize_int (bitsize), bitsize_int (bitpos));\n+      if (r && !test)\n \t{\n-\t  x = build3_loc (loc, BIT_FIELD_REF, TREE_TYPE (blhs), x,\n-\t\t\t  bitsize_int (bitsize), bitsize_int (bitpos));\n-\t  type = TREE_TYPE (blhs);\n-\t}\n-      if (r)\n-\t{\n-\t  vtmp = create_tmp_var (TREE_TYPE (x));\n+\t  vtmp = create_tmp_var_raw (TREE_TYPE (x));\n \t  DECL_CONTEXT (vtmp) = current_function_decl;\n \t}\n       else\n@@ -545,10 +544,11 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t\t     loc, x, NULL_TREE);\n       if (x == error_mark_node)\n \treturn error_mark_node;\n-      if (r)\n+      type = TREE_TYPE (x);\n+      if (r && !test)\n \t{\n-\t  vtmp = build4 (TARGET_EXPR, boolean_type_node, vtmp,\n-\t\t\t NULL, NULL, NULL);\n+\t  vtmp = build4 (TARGET_EXPR, TREE_TYPE (vtmp), vtmp,\n+\t\t\t build_zero_cst (TREE_TYPE (vtmp)), NULL, NULL);\n \t  gcc_assert (TREE_CODE (x) == MODIFY_EXPR\n \t\t      && TREE_OPERAND (x, 0) == TARGET_EXPR_SLOT (vtmp));\n \t  TREE_OPERAND (x, 0) = vtmp;"}, {"sha": "eba9bbf5ec79b908c8c8d3323ec145120eb06b88", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -18500,7 +18500,7 @@ c_parser_omp_atomic (location_t loc, c_parser *parser, bool openacc)\n \t\t  c_parser_consume_token (parser);\n \t\t  goto restart;\n \t\t}\n-\t      if (structured_block)\n+\t      if (structured_block && !compare)\n \t\t{\n \t\t  opcode = NOP_EXPR;\n \t\t  expr = default_function_array_read_conversion (eloc, expr);"}, {"sha": "fb0d5ec5efe0d961ea927267726083ba01527fab", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -7582,8 +7582,8 @@ extern tree finish_omp_for\t\t\t(location_t, enum tree_code,\n extern tree finish_omp_for_block\t\t(tree, tree);\n extern void finish_omp_atomic\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t enum tree_code, tree, tree,\n-\t\t\t\t\t\t tree, tree, tree, tree,\n-\t\t\t\t\t\t enum omp_memory_order);\n+\t\t\t\t\t\t tree, tree, tree, tree, tree,\n+\t\t\t\t\t\t enum omp_memory_order, bool);\n extern void finish_omp_barrier\t\t\t(void);\n extern void finish_omp_depobj\t\t\t(location_t, tree,\n \t\t\t\t\t\t enum omp_clause_depend_kind,"}, {"sha": "20f949edfe0fb4cc32a9a500882e4c3d1021b920", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 453, "deletions": 13, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -40082,19 +40082,56 @@ cp_parser_omp_allocate (cp_parser *parser, cp_token *pragma_tok)\n    capture-block:\n      { v = x; update-stmt; } | { update-stmt; v = x; } | { v = x; x = expr; }\n \n-  where x and v are lvalue expressions with scalar type.  */\n+   OpenMP 5.1:\n+   # pragma omp atomic compare new-line\n+     conditional-update-atomic\n+\n+   # pragma omp atomic compare capture new-line\n+     conditional-update-capture-atomic\n+\n+   conditional-update-atomic:\n+     cond-expr-stmt | cond-update-stmt\n+   cond-expr-stmt:\n+     x = expr ordop x ? expr : x;\n+     x = x ordop expr ? expr : x;\n+     x = x == e ? d : x;\n+   cond-update-stmt:\n+     if (expr ordop x) { x = expr; }\n+     if (x ordop expr) { x = expr; }\n+     if (x == e) { x = d; }\n+   ordop:\n+     <, >\n+   conditional-update-capture-atomic:\n+     v = cond-expr-stmt\n+     { v = x; cond-expr-stmt }\n+     { cond-expr-stmt v = x; }\n+     { v = x; cond-update-stmt }\n+     { cond-update-stmt v = x; }\n+     if (x == e) { x = d; } else { v = x; }\n+     { r = x == e; if (r) { x = d; } }\n+     { r = x == e; if (r) { x = d; } else { v = x; } }\n+\n+  where x, r and v are lvalue expressions with scalar type,\n+  expr, e and d are expressions with scalar type and e might be\n+  the same as v.  */\n \n static void\n cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n {\n   tree lhs = NULL_TREE, rhs = NULL_TREE, v = NULL_TREE, lhs1 = NULL_TREE;\n-  tree rhs1 = NULL_TREE, orig_lhs;\n+  tree rhs1 = NULL_TREE, orig_lhs, r = NULL_TREE;\n   location_t loc = pragma_tok->location;\n   enum tree_code code = ERROR_MARK, opcode = NOP_EXPR;\n   enum omp_memory_order memory_order = OMP_MEMORY_ORDER_UNSPECIFIED;\n   bool structured_block = false;\n   bool first = true;\n   tree clauses = NULL_TREE;\n+  bool capture = false;\n+  bool compare = false;\n+  bool weak = false;\n+  enum omp_memory_order fail = OMP_MEMORY_ORDER_UNSPECIFIED;\n+  bool no_semicolon = false;\n+  bool extra_scope = false;\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n@@ -40114,21 +40151,71 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t  enum tree_code new_code = ERROR_MARK;\n \t  enum omp_memory_order new_memory_order\n \t    = OMP_MEMORY_ORDER_UNSPECIFIED;\n+\t  bool new_capture = false;\n+\t  bool new_compare = false;\n+\t  bool new_weak = false;\n+\t  enum omp_memory_order new_fail = OMP_MEMORY_ORDER_UNSPECIFIED;\n \n \t  if (!strcmp (p, \"read\"))\n \t    new_code = OMP_ATOMIC_READ;\n \t  else if (!strcmp (p, \"write\"))\n \t    new_code = NOP_EXPR;\n \t  else if (!strcmp (p, \"update\"))\n \t    new_code = OMP_ATOMIC;\n-\t  else if (!strcmp (p, \"capture\"))\n+\t  else if (openacc && !strcmp (p, \"capture\"))\n \t    new_code = OMP_ATOMIC_CAPTURE_NEW;\n \t  else if (openacc)\n \t    {\n \t      p = NULL;\n \t      error_at (cloc, \"expected %<read%>, %<write%>, %<update%>, \"\n \t\t\t      \"or %<capture%> clause\");\n \t    }\n+\t  else if (!strcmp (p, \"capture\"))\n+\t    new_capture = true;\n+\t  else if (!strcmp (p, \"compare\"))\n+\t    new_compare = true;\n+\t  else if (!strcmp (p, \"weak\"))\n+\t    new_weak = true;\n+\t  else if (!strcmp (p, \"fail\"))\n+\t    {\n+\t      matching_parens parens;\n+\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      if (!parens.require_open (parser))\n+\t\tcontinue;\n+\n+\t      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t\t{\n+\t\t  id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  const char *q = IDENTIFIER_POINTER (id);\n+\n+\t\t  if (!strcmp (q, \"seq_cst\"))\n+\t\t    new_fail = OMP_MEMORY_ORDER_SEQ_CST;\n+\t\t  else if (!strcmp (q, \"acquire\"))\n+\t\t    new_fail = OMP_MEMORY_ORDER_ACQUIRE;\n+\t\t  else if (!strcmp (q, \"relaxed\"))\n+\t\t    new_fail = OMP_MEMORY_ORDER_RELAXED;\n+\t\t}\n+\n+\t      if (new_fail != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t{\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  if (fail != OMP_MEMORY_ORDER_UNSPECIFIED)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"fail\");\n+\t\t  else\n+\t\t    fail = new_fail;\n+\t\t}\n+\t      else\n+\t\tcp_parser_error (parser, \"expected %<seq_cst%>, %<acquire%> \"\n+\t\t\t\t\t \"or %<relaxed%>\");\n+\t      if (new_fail == OMP_MEMORY_ORDER_UNSPECIFIED\n+\t\t  || !parens.require_close (parser))\n+\t\tcp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t       /*recovering=*/true,\n+\t\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t\t       /*consume_paren=*/true);\n+\t      continue;\n+\t    }\n \t  else if (!strcmp (p, \"seq_cst\"))\n \t    new_memory_order = OMP_MEMORY_ORDER_SEQ_CST;\n \t  else if (!strcmp (p, \"acq_rel\"))\n@@ -40149,8 +40236,9 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t    {\n \t      p = NULL;\n \t      error_at (cloc, \"expected %<read%>, %<write%>, %<update%>, \"\n-\t\t\t      \"%<capture%>, %<seq_cst%>, %<acq_rel%>, \"\n-\t\t\t      \"%<release%>, %<relaxed%> or %<hint%> clause\");\n+\t\t\t      \"%<capture%>, %<compare%>, %<weak%>, %<fail%>, \"\n+\t\t\t      \"%<seq_cst%>, %<acq_rel%>, %<release%>, \"\n+\t\t\t      \"%<relaxed%> or %<hint%> clause\");\n \t    }\n \t  if (p)\n \t    {\n@@ -40173,6 +40261,27 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t\t  else\n \t\t    memory_order = new_memory_order;\n \t\t}\n+\t      else if (new_capture)\n+\t\t{\n+\t\t  if (capture)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"capture\");\n+\t\t  else\n+\t\t    capture = true;\n+\t\t}\n+\t      else if (new_compare)\n+\t\t{\n+\t\t  if (compare)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"compare\");\n+\t\t  else\n+\t\t    compare = true;\n+\t\t}\n+\t      else if (new_weak)\n+\t\t{\n+\t\t  if (weak)\n+\t\t    error_at (cloc, \"too many %qs clauses\", \"weak\");\n+\t\t  else\n+\t\t    weak = true;\n+\t\t}\n \t      cp_lexer_consume_token (parser->lexer);\n \t      continue;\n \t    }\n@@ -40183,6 +40292,30 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \n   if (code == ERROR_MARK)\n     code = OMP_ATOMIC;\n+  if (capture)\n+    {\n+      if (code != OMP_ATOMIC)\n+\terror_at (loc, \"%qs clause is incompatible with %<read%> or %<write%> \"\n+\t\t       \"clauses\", \"capture\");\n+      else\n+\tcode = OMP_ATOMIC_CAPTURE_NEW;\n+    }\n+  if (compare && code != OMP_ATOMIC && code != OMP_ATOMIC_CAPTURE_NEW)\n+    {\n+      error_at (loc, \"%qs clause is incompatible with %<read%> or %<write%> \"\n+\t\t     \"clauses\", \"compare\");\n+      compare = false;\n+    }\n+  if (fail != OMP_MEMORY_ORDER_UNSPECIFIED && !compare)\n+    {\n+      error_at (loc, \"%qs clause requires %qs clause\", \"fail\", \"compare\");\n+      fail = OMP_MEMORY_ORDER_UNSPECIFIED;\n+    }\n+  if (weak && !compare)\n+    {\n+      error_at (loc, \"%qs clause requires %qs clause\", \"weak\", \"compare\");\n+      weak = false;\n+    }\n   if (openacc)\n     memory_order = OMP_MEMORY_ORDER_RELAXED;\n   else if (memory_order == OMP_MEMORY_ORDER_UNSPECIFIED)\n@@ -40244,6 +40377,10 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n       default:\n \tbreak;\n       }\n+  if (fail != OMP_MEMORY_ORDER_UNSPECIFIED)\n+    memory_order\n+      = (enum omp_memory_order) (memory_order\n+\t\t\t\t | (fail << OMP_FAIL_MEMORY_ORDER_SHIFT));\n \n   switch (code)\n     {\n@@ -40276,19 +40413,189 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t  cp_lexer_consume_token (parser->lexer);\n \t  structured_block = true;\n \t}\n+      else if (compare\n+\t       && cp_lexer_next_token_is_keyword (parser->lexer, RID_IF))\n+\tbreak;\n       else\n \t{\n \t  v = cp_parser_unary_expression (parser);\n \t  if (v == error_mark_node)\n \t    goto saw_error;\n \t  if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n \t    goto saw_error;\n+\t  if (compare\n+\t      && cp_lexer_next_token_is_keyword (parser->lexer, RID_IF))\n+\t    {\n+\t      location_t eloc = cp_lexer_peek_token (parser->lexer)->location;\n+\t      error_at (eloc, \"expected expression\");\n+\t      goto saw_error;\n+\t    }\n \t}\n     default:\n       break;\n     }\n \n restart:\n+  if (compare && cp_lexer_next_token_is_keyword (parser->lexer, RID_IF))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n+\tgoto saw_error;\n+      location_t eloc = cp_lexer_peek_token (parser->lexer)->location;\n+      tree cmp_expr;\n+      if (r)\n+\tcmp_expr = cp_parser_unary_expression (parser);\n+      else\n+\tcmp_expr = cp_parser_binary_expression (parser, false, true,\n+\t\t\t\t\t\tPREC_NOT_OPERATOR, NULL);\n+      if (!parens.require_close (parser))\n+\tcp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n+      if (cmp_expr == error_mark_node)\n+\tgoto saw_error;\n+      if (r)\n+\t{\n+\t  if (!cp_tree_equal (cmp_expr, r))\n+\t    goto bad_if;\n+\t  cmp_expr = rhs;\n+\t  rhs = NULL_TREE;\n+\t  gcc_assert (TREE_CODE (cmp_expr) == EQ_EXPR);\n+\t}\n+      if (TREE_CODE (cmp_expr) == EQ_EXPR)\n+\t;\n+      else if (!structured_block && code == OMP_ATOMIC_CAPTURE_NEW)\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (cmp_expr, eloc),\n+\t\t    \"expected %<==%> comparison in %<if%> condition\");\n+\t  goto saw_error;\n+\t}\n+      else if (TREE_CODE (cmp_expr) != GT_EXPR\n+\t       && TREE_CODE (cmp_expr) != LT_EXPR)\n+\t{\n+\t  error_at (EXPR_LOC_OR_LOC (cmp_expr, eloc),\n+\t\t    \"expected %<==%>, %<<%> or %<>%> comparison in %<if%> \"\n+\t\t    \"condition\");\n+\t  goto saw_error;\n+\t}\n+      if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+\tgoto saw_error;\n+\n+      extra_scope = true;\n+      eloc = cp_lexer_peek_token (parser->lexer)->location;\n+      lhs = cp_parser_unary_expression (parser);\n+      orig_lhs = lhs;\n+      if (lhs == error_mark_node)\n+\tgoto saw_error;\n+      if (!cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+\t{\n+\t  cp_parser_error (parser, \"expected %<=%>\");\n+\t  goto saw_error;\n+\t}\n+      cp_lexer_consume_token (parser->lexer);\n+      eloc = cp_lexer_peek_token (parser->lexer)->location;\n+      if (TREE_CODE (cmp_expr) == EQ_EXPR)\n+\trhs1 = cp_parser_expression (parser);\n+      else\n+\trhs1 = cp_parser_simple_cast_expression (parser);\n+\n+      if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+\tgoto saw_error;\n+\n+      if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+\tgoto saw_error;\n+\n+      extra_scope = false;\n+      no_semicolon = true;\n+\n+      if (cp_tree_equal (TREE_OPERAND (cmp_expr, 0), lhs))\n+\t{\n+\t  if (TREE_CODE (cmp_expr) == EQ_EXPR)\n+\t    {\n+\t      opcode = COND_EXPR;\n+\t      rhs = TREE_OPERAND (cmp_expr, 1);\n+\t    }\n+\t  else if (cp_tree_equal (TREE_OPERAND (cmp_expr, 1), rhs1))\n+\t    {\n+\t      opcode = (TREE_CODE (cmp_expr) == GT_EXPR\n+\t\t\t? MIN_EXPR : MAX_EXPR);\n+\t      rhs = rhs1;\n+\t      rhs1 = TREE_OPERAND (cmp_expr, 0);\n+\t    }\n+\t  else\n+\t    goto bad_if;\n+\t}\n+      else if (TREE_CODE (cmp_expr) == EQ_EXPR)\n+\tgoto bad_if;\n+      else if (cp_tree_equal (TREE_OPERAND (cmp_expr, 1), lhs)\n+\t       && cp_tree_equal (TREE_OPERAND (cmp_expr, 0), rhs1))\n+\t{\n+\t  opcode = (TREE_CODE (cmp_expr) == GT_EXPR\n+\t\t    ? MAX_EXPR : MIN_EXPR);\n+\t  rhs = rhs1;\n+\t  rhs1 = TREE_OPERAND (cmp_expr, 1);\n+\t}\n+      else\n+\t{\n+\tbad_if:\n+\t  cp_parser_error (parser,\n+\t\t\t   \"invalid form of %<#pragma omp atomic compare%>\");\n+\t  goto saw_error;\n+\t}\n+\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ELSE))\n+\t{\n+\t  if (code != OMP_ATOMIC_CAPTURE_NEW\n+\t      || (structured_block && r == NULL_TREE)\n+\t      || TREE_CODE (cmp_expr) != EQ_EXPR)\n+\t    {\n+\t      eloc = cp_lexer_peek_token (parser->lexer)->location;\n+\t      error_at (eloc, \"unexpected %<else%>\");\n+\t      goto saw_error;\n+\t    }\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\n+\t  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+\t    goto saw_error;\n+\n+\t  extra_scope = true;\n+\t  v = cp_parser_unary_expression (parser);\n+\t  if (v == error_mark_node)\n+\t    goto saw_error;\n+\t  if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n+\t    goto saw_error;\n+\n+\t  tree expr = cp_parser_simple_cast_expression (parser);\n+\n+\t  if (!cp_tree_equal (expr, lhs))\n+\t    goto bad_if;\n+\n+\t  if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+\t    goto saw_error;\n+\n+\t  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+\t    goto saw_error;\n+\n+\t  extra_scope = false;\n+\t  code = OMP_ATOMIC_CAPTURE_OLD;\n+\t  if (r == NULL_TREE)\n+\t    /* Signal to c_finish_omp_atomic that in\n+\t       if (x == e) { x = d; } else { v = x; }\n+\t       case the store to v should be conditional.  */\n+\t    r = void_list_node;\n+\t}\n+      else if (code == OMP_ATOMIC_CAPTURE_NEW && !structured_block)\n+\t{\n+\t  cp_parser_error (parser, \"expected %<else%>\");\n+\t  goto saw_error;\n+\t}\n+      else if (code == OMP_ATOMIC_CAPTURE_NEW\n+\t       && r != NULL_TREE\n+\t       && v == NULL_TREE)\n+\tcode = OMP_ATOMIC;\n+      goto stmt_done;\n+    }\n   lhs = cp_parser_unary_expression (parser);\n   orig_lhs = lhs;\n   switch (TREE_CODE (lhs))\n@@ -40304,6 +40611,8 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n       lhs = TREE_OPERAND (lhs, 0);\n       opcode = PLUS_EXPR;\n       rhs = integer_one_node;\n+      if (compare)\n+\tgoto invalid_compare;\n       break;\n \n     case POSTDECREMENT_EXPR:\n@@ -40314,6 +40623,8 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n       lhs = TREE_OPERAND (lhs, 0);\n       opcode = MINUS_EXPR;\n       rhs = integer_one_node;\n+      if (compare)\n+\tgoto invalid_compare;\n       break;\n \n     case COMPOUND_EXPR:\n@@ -40342,11 +40653,18 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t\t  && !structured_block\n \t\t  && TREE_CODE (orig_lhs) == COMPOUND_EXPR)\n \t\tcode = OMP_ATOMIC_CAPTURE_OLD;\n+\t      if (compare)\n+\t\tgoto invalid_compare;\n \t      break;\n \t    }\n \t}\n       /* FALLTHRU */\n     default:\n+      if (compare && !cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+\t{\n+\t  cp_parser_error (parser, \"expected %<=%>\");\n+\t  goto saw_error;\n+\t}\n       switch (cp_lexer_peek_token (parser->lexer)->type)\n \t{\n \tcase CPP_MULT_EQ:\n@@ -40414,6 +40732,8 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t\tcase BIT_AND_EXPR:\n \t\tcase BIT_IOR_EXPR:\n \t\tcase BIT_XOR_EXPR:\n+\t\t  if (compare)\n+\t\t    break;\n \t\t  if (cp_tree_equal (lhs, TREE_OPERAND (rhs, 1)))\n \t\t    {\n \t\t      if (cp_parser_parse_definitely (parser))\n@@ -40427,11 +40747,91 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t\t\tgoto saw_error;\n \t\t    }\n \t\t  break;\n+\t\tcase EQ_EXPR:\n+\t\t  if (!compare\n+\t\t      || code != OMP_ATOMIC_CAPTURE_NEW\n+\t\t      || !structured_block\n+\t\t      || v\n+\t\t      || r)\n+\t\t    break;\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t\t      && cp_lexer_nth_token_is_keyword (parser->lexer,\n+\t\t\t\t\t\t\t2, RID_IF))\n+\t\t    {\n+\t\t      if (cp_parser_parse_definitely (parser))\n+\t\t\t{\n+\t\t\t  r = lhs;\n+\t\t\t  lhs = NULL_TREE;\n+\t\t\t  rhs1 = NULL_TREE;\n+\t\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t\t  goto restart;\n+\t\t\t}\n+\t\t    }\n+\t\t  break;\n+\t\tcase GT_EXPR:\n+\t\tcase LT_EXPR:\n+\t\t  if (compare\n+\t\t      && cp_lexer_next_token_is (parser->lexer, CPP_QUERY)\n+\t\t      && cp_tree_equal (lhs, TREE_OPERAND (rhs, 1))\n+\t\t      && cp_parser_parse_definitely (parser))\n+\t\t    {\n+\t\t      opcode = TREE_CODE (rhs);\n+\t\t      rhs1 = TREE_OPERAND (rhs, 0);\n+\t\t      rhs = TREE_OPERAND (rhs, 1);\n+\t\t     cond_expr:\n+\t\t      cp_lexer_consume_token (parser->lexer);\n+\t\t      bool saved_colon_corrects_to_scope_p\n+\t\t\t= parser->colon_corrects_to_scope_p;\n+\t\t      parser->colon_corrects_to_scope_p = false;\n+\t\t      tree e1 = cp_parser_expression (parser);\n+\t\t      parser->colon_corrects_to_scope_p\n+\t\t\t= saved_colon_corrects_to_scope_p;\n+\t\t      cp_parser_require (parser, CPP_COLON, RT_COLON);\n+\t\t      tree e2 = cp_parser_simple_cast_expression (parser);\n+\t\t      if (cp_tree_equal (lhs, e2))\n+\t\t\t{\n+\t\t\t  if (cp_tree_equal (lhs, rhs1))\n+\t\t\t    {\n+\t\t\t      if (opcode == EQ_EXPR)\n+\t\t\t\t{\n+\t\t\t\t  opcode = COND_EXPR;\n+\t\t\t\t  rhs1 = e1;\n+\t\t\t\t  goto stmt_done;\n+\t\t\t\t}\n+\t\t\t      if (cp_tree_equal (rhs, e1))\n+\t\t\t\t{\n+\t\t\t\t  opcode\n+\t\t\t\t    = opcode == GT_EXPR ? MIN_EXPR : MAX_EXPR;\n+\t\t\t\t  rhs = e1;\n+\t\t\t\t  goto stmt_done;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      gcc_assert (opcode != EQ_EXPR);\n+\t\t\t      if (cp_tree_equal (rhs1, e1))\n+\t\t\t\t{\n+\t\t\t\t  opcode\n+\t\t\t\t    = opcode == GT_EXPR ? MAX_EXPR : MIN_EXPR;\n+\t\t\t\t  rhs1 = rhs;\n+\t\t\t\t  rhs = e1;\n+\t\t\t\t  goto stmt_done;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t}\n+\t\t      cp_parser_error (parser,\n+\t\t\t\t       \"invalid form of \"\n+\t\t\t\t       \"%<#pragma omp atomic compare%>\");\n+\t\t      goto saw_error;\n+\t\t    }\n+\t\t  break;\n \t\tdefault:\n \t\t  break;\n \t\t}\n \t      cp_parser_abort_tentative_parse (parser);\n-\t      if (structured_block && code == OMP_ATOMIC_CAPTURE_OLD)\n+\t      if (structured_block\n+\t\t  && code == OMP_ATOMIC_CAPTURE_OLD\n+\t\t  && !compare)\n \t\t{\n \t\t  rhs = cp_parser_expression (parser);\n \t\t  if (rhs == error_mark_node)\n@@ -40459,7 +40859,7 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t  goto restart;\n \t\t}\n-\t      else if (structured_block)\n+\t      else if (structured_block && !compare)\n \t\t{\n \t\t  opcode = NOP_EXPR;\n \t\t  rhs = rhs1;\n@@ -40496,11 +40896,28 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t    case CPP_XOR:\n \t      opcode = BIT_XOR_EXPR;\n \t      break;\n+\t    case CPP_EQ_EQ:\n+\t      opcode = EQ_EXPR;\n+\t      break;\n+\t    case CPP_GREATER:\n+\t      opcode = GT_EXPR;\n+\t      break;\n+\t    case CPP_LESS:\n+\t      opcode = LT_EXPR;\n+\t      break;\n \t    default:\n \t      cp_parser_error (parser,\n \t\t\t       \"invalid operator for %<#pragma omp atomic%>\");\n \t      goto saw_error;\n \t    }\n+\t  if (compare\n+\t      && TREE_CODE_CLASS (opcode) != tcc_comparison)\n+\t    {\n+\t      cp_parser_error (parser,\n+\t\t\t       \"invalid form of \"\n+\t\t\t       \"%<#pragma omp atomic compare%>\");\n+\t      goto saw_error;\n+\t    }\n \t  oprec = TOKEN_PRECEDENCE (token);\n \t  gcc_assert (oprec != PREC_NOT_OPERATOR);\n \t  if (commutative_tree_code (opcode))\n@@ -40510,8 +40927,18 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n \t\t\t\t\t     oprec, NULL);\n \t  if (rhs == error_mark_node)\n \t    goto saw_error;\n+\t  if (compare)\n+\t    {\n+\t      if (!cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n+\t\t{\n+\t\t  cp_parser_error (parser,\n+\t\t\t\t   \"invalid form of \"\n+\t\t\t\t   \"%<#pragma omp atomic compare%>\");\n+\t\t  goto saw_error;\n+\t\t}\n+\t      goto cond_expr;\n+\t    }\n \t  goto stmt_done;\n-\t  /* FALLTHROUGH */\n \tdefault:\n \t  cp_parser_error (parser,\n \t\t\t   \"invalid operator for %<#pragma omp atomic%>\");\n@@ -40525,10 +40952,12 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n       break;\n     }\n stmt_done:\n-  if (structured_block && code == OMP_ATOMIC_CAPTURE_NEW)\n+  if (structured_block && code == OMP_ATOMIC_CAPTURE_NEW && r == NULL_TREE)\n     {\n-      if (!cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+      if (!no_semicolon\n+\t  && !cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n \tgoto saw_error;\n+      no_semicolon = false;\n       v = cp_parser_unary_expression (parser);\n       if (v == error_mark_node)\n \tgoto saw_error;\n@@ -40540,19 +40969,30 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok, bool openacc)\n     }\n   if (structured_block)\n     {\n-      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      if (!no_semicolon)\n+\tcp_parser_consume_semicolon_at_end_of_statement (parser);\n       cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n     }\n done:\n+  if (weak && opcode != COND_EXPR)\n+    {\n+      error_at (loc, \"%<weak%> clause requires atomic equality comparison\");\n+      weak = false;\n+    }\n   clauses = finish_omp_clauses (clauses, C_ORT_OMP);\n   finish_omp_atomic (pragma_tok->location, code, opcode, lhs, rhs, v, lhs1,\n-\t\t     rhs1, clauses, memory_order);\n-  if (!structured_block)\n+\t\t     rhs1, r, clauses, memory_order, weak);\n+  if (!structured_block && !no_semicolon)\n     cp_parser_consume_semicolon_at_end_of_statement (parser);\n   return;\n \n+ invalid_compare:\n+  error (\"invalid form of %<pragma omp atomic compare%>\");\n+  /* FALLTHRU */\n  saw_error:\n   cp_parser_skip_to_end_of_block_or_statement (parser);\n+  if (extra_scope && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+    cp_lexer_consume_token (parser->lexer);\n   if (structured_block)\n     {\n       if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))"}, {"sha": "12c8812d8b2c3f61b46c6c33f6a0ccf8570d5274", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -19030,23 +19030,42 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t{\n \t  tree op1 = TREE_OPERAND (t, 1);\n \t  tree rhs1 = NULL_TREE;\n+\t  tree r = NULL_TREE;\n \t  tree lhs, rhs;\n \t  if (TREE_CODE (op1) == COMPOUND_EXPR)\n \t    {\n \t      rhs1 = RECUR (TREE_OPERAND (op1, 0));\n \t      op1 = TREE_OPERAND (op1, 1);\n \t    }\n-\t  lhs = RECUR (TREE_OPERAND (op1, 0));\n-\t  rhs = RECUR (TREE_OPERAND (op1, 1));\n+\t  if (TREE_CODE (op1) == COND_EXPR)\n+\t    {\n+\t      gcc_assert (rhs1 == NULL_TREE);\n+\t      tree c = TREE_OPERAND (op1, 0);\n+\t      if (TREE_CODE (c) == MODIFY_EXPR)\n+\t\t{\n+\t\t  r = RECUR (TREE_OPERAND (c, 0));\n+\t\t  c = TREE_OPERAND (c, 1);\n+\t\t}\n+\t      gcc_assert (TREE_CODE (c) == EQ_EXPR);\n+\t      rhs = RECUR (TREE_OPERAND (c, 1));\n+\t      lhs = RECUR (TREE_OPERAND (op1, 2));\n+\t      rhs1 = RECUR (TREE_OPERAND (op1, 1));\n+\t    }\n+\t  else\n+\t    {\n+\t      lhs = RECUR (TREE_OPERAND (op1, 0));\n+\t      rhs = RECUR (TREE_OPERAND (op1, 1));\n+\t    }\n \t  finish_omp_atomic (EXPR_LOCATION (t), OMP_ATOMIC, TREE_CODE (op1),\n-\t\t\t     lhs, rhs, NULL_TREE, NULL_TREE, rhs1, tmp,\n-\t\t\t     OMP_ATOMIC_MEMORY_ORDER (t));\n+\t\t\t     lhs, rhs, NULL_TREE, NULL_TREE, rhs1, r,\n+\t\t\t     tmp, OMP_ATOMIC_MEMORY_ORDER (t),\n+\t\t\t     OMP_ATOMIC_WEAK (t));\n \t}\n       else\n \t{\n \t  tree op1 = TREE_OPERAND (t, 1);\n \t  tree v = NULL_TREE, lhs, rhs = NULL_TREE, lhs1 = NULL_TREE;\n-\t  tree rhs1 = NULL_TREE;\n+\t  tree rhs1 = NULL_TREE, r = NULL_TREE;\n \t  enum tree_code code = TREE_CODE (TREE_OPERAND (op1, 1));\n \t  enum tree_code opcode = NOP_EXPR;\n \t  if (code == OMP_ATOMIC_READ)\n@@ -19065,8 +19084,25 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t  rhs1 = RECUR (TREE_OPERAND (op11, 0));\n \t\t  op11 = TREE_OPERAND (op11, 1);\n \t\t}\n-\t      lhs = RECUR (TREE_OPERAND (op11, 0));\n-\t      rhs = RECUR (TREE_OPERAND (op11, 1));\n+\t      if (TREE_CODE (op11) == COND_EXPR)\n+\t\t{\n+\t\t  gcc_assert (rhs1 == NULL_TREE);\n+\t\t  tree c = TREE_OPERAND (op11, 0);\n+\t\t  if (TREE_CODE (c) == MODIFY_EXPR)\n+\t\t    {\n+\t\t      r = RECUR (TREE_OPERAND (c, 0));\n+\t\t      c = TREE_OPERAND (c, 1);\n+\t\t    }\n+\t\t  gcc_assert (TREE_CODE (c) == EQ_EXPR);\n+\t\t  rhs = RECUR (TREE_OPERAND (c, 1));\n+\t\t  lhs = RECUR (TREE_OPERAND (op11, 2));\n+\t\t  rhs1 = RECUR (TREE_OPERAND (op11, 1));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  lhs = RECUR (TREE_OPERAND (op11, 0));\n+\t\t  rhs = RECUR (TREE_OPERAND (op11, 1));\n+\t\t}\n \t      opcode = TREE_CODE (op11);\n \t      if (opcode == MODIFY_EXPR)\n \t\topcode = NOP_EXPR;\n@@ -19078,7 +19114,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t      rhs = RECUR (TREE_OPERAND (op1, 1));\n \t    }\n \t  finish_omp_atomic (EXPR_LOCATION (t), code, opcode, lhs, rhs, v,\n-\t\t\t     lhs1, rhs1, tmp, OMP_ATOMIC_MEMORY_ORDER (t));\n+\t\t\t     lhs1, rhs1, r, tmp,\n+\t\t\t     OMP_ATOMIC_MEMORY_ORDER (t), OMP_ATOMIC_WEAK (t));\n \t}\n       break;\n "}, {"sha": "35a7b9f7b838109ceab57153ea15f11344e951c5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -9877,14 +9877,15 @@ finish_omp_for_block (tree bind, tree omp_for)\n \n void\n finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n-\t\t   tree lhs, tree rhs, tree v, tree lhs1, tree rhs1,\n-\t\t   tree clauses, enum omp_memory_order mo)\n+\t\t   tree lhs, tree rhs, tree v, tree lhs1, tree rhs1, tree r,\n+\t\t   tree clauses, enum omp_memory_order mo, bool weak)\n {\n   tree orig_lhs;\n   tree orig_rhs;\n   tree orig_v;\n   tree orig_lhs1;\n   tree orig_rhs1;\n+  tree orig_r;\n   bool dependent_p;\n   tree stmt;\n \n@@ -9893,6 +9894,7 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n   orig_v = v;\n   orig_lhs1 = lhs1;\n   orig_rhs1 = rhs1;\n+  orig_r = r;\n   dependent_p = false;\n   stmt = NULL_TREE;\n \n@@ -9904,7 +9906,10 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n \t\t     || (rhs && type_dependent_expression_p (rhs))\n \t\t     || (v && type_dependent_expression_p (v))\n \t\t     || (lhs1 && type_dependent_expression_p (lhs1))\n-\t\t     || (rhs1 && type_dependent_expression_p (rhs1)));\n+\t\t     || (rhs1 && type_dependent_expression_p (rhs1))\n+\t\t     || (r\n+\t\t\t && r != void_list_node\n+\t\t\t && type_dependent_expression_p (r)));\n       if (clauses)\n \t{\n \t  gcc_assert (TREE_CODE (clauses) == OMP_CLAUSE\n@@ -9925,17 +9930,19 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n \t    lhs1 = build_non_dependent_expr (lhs1);\n \t  if (rhs1)\n \t    rhs1 = build_non_dependent_expr (rhs1);\n+\t  if (r && r != void_list_node)\n+\t    r = build_non_dependent_expr (r);\n \t}\n     }\n   if (!dependent_p)\n     {\n       bool swapped = false;\n-      if (rhs1 && cp_tree_equal (lhs, rhs))\n+      if (rhs1 && opcode != COND_EXPR && cp_tree_equal (lhs, rhs))\n \t{\n \t  std::swap (rhs, rhs1);\n \t  swapped = !commutative_tree_code (opcode);\n \t}\n-      if (rhs1 && !cp_tree_equal (lhs, rhs1))\n+      if (rhs1 && opcode != COND_EXPR && !cp_tree_equal (lhs, rhs1))\n \t{\n \t  if (code == OMP_ATOMIC)\n \t    error (\"%<#pragma omp atomic update%> uses two different \"\n@@ -9956,7 +9963,7 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n \t  return;\n \t}\n       stmt = c_finish_omp_atomic (loc, code, opcode, lhs, rhs,\n-\t\t\t\t  v, lhs1, rhs1, NULL_TREE, swapped, mo, false,\n+\t\t\t\t  v, lhs1, rhs1, r, swapped, mo, weak,\n \t\t\t\t  processing_template_decl != 0);\n       if (stmt == error_mark_node)\n \treturn;\n@@ -9973,6 +9980,16 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n \t{\n \t  if (opcode == NOP_EXPR)\n \t    stmt = build2 (MODIFY_EXPR, void_type_node, orig_lhs, orig_rhs);\n+\t  else if (opcode == COND_EXPR)\n+\t    {\n+\t      stmt = build2 (EQ_EXPR, boolean_type_node, orig_lhs, orig_rhs);\n+\t      if (orig_r)\n+\t\tstmt = build2 (MODIFY_EXPR, boolean_type_node, orig_r,\n+\t\t\t       stmt);\n+\t      stmt = build3 (COND_EXPR, void_type_node, stmt, orig_rhs1,\n+\t\t\t     orig_lhs);\n+\t      orig_rhs1 = NULL_TREE;\n+\t    }\n \t  else\n \t    stmt = build2 (opcode, void_type_node, orig_lhs, orig_rhs);\n \t  if (orig_rhs1)\n@@ -9982,12 +9999,14 @@ finish_omp_atomic (location_t loc, enum tree_code code, enum tree_code opcode,\n \t    {\n \t      stmt = build_min_nt_loc (loc, code, orig_lhs1, stmt);\n \t      OMP_ATOMIC_MEMORY_ORDER (stmt) = mo;\n+\t      OMP_ATOMIC_WEAK (stmt) = weak;\n \t      stmt = build2 (MODIFY_EXPR, void_type_node, orig_v, stmt);\n \t    }\n \t}\n       stmt = build2 (OMP_ATOMIC, void_type_node,\n \t\t     clauses ? clauses : integer_zero_node, stmt);\n       OMP_ATOMIC_MEMORY_ORDER (stmt) = mo;\n+      OMP_ATOMIC_WEAK (stmt) = weak;\n       SET_EXPR_LOCATION (stmt, loc);\n     }\n "}, {"sha": "a8ed3c7803e8bef4f0ce2ec2e7030d366f500a14", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-18.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-18.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -12,14 +12,12 @@ foo (int j)\n   v = i;\n   #pragma omp atomic acquire , write\t/* { dg-error \"incompatible with 'acquire' clause\" } */\n   i = v;\n-  #pragma omp atomic capture hint (0) capture\t/* { dg-error \"too many 'capture' clauses\" \"\" { target c } } */\n-\t\t\t\t\t/* { dg-error \"too many atomic clauses\" \"\" { target c++ } .-1 } */\n+  #pragma omp atomic capture hint (0) capture\t/* { dg-error \"too many 'capture' clauses\" } */\n   v = i = i + 1;\n   #pragma omp atomic hint(j + 2)\t/* { dg-error \"constant integer expression\" } */\n   i = i + 1;\n   #pragma omp atomic hint(f)\t\t/* { dg-error \"integ\" } */\n   i = i + 1;\n-  #pragma omp atomic foobar\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'compare', 'weak', 'fail', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target c } } */\n-\t\t\t\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target c++ } .-1 } */\n-  i = i + 1;\t\t\t\t/* { dg-error \"expected end of line before\" \"\" { target *-*-* } .-2 } */\n+  #pragma omp atomic foobar\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'compare', 'weak', 'fail', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" } */\n+  i = i + 1;\t\t\t\t/* { dg-error \"expected end of line before\" \"\" { target *-*-* } .-1 } */\n }"}, {"sha": "653ef187fc86319d987ec8da6ba9f185636e0642", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-25.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target c } } */\n+/* { dg-do compile } */\n \n int x, r, z;\n double d, v;"}, {"sha": "b7a4a1f623806350963585ec9e8e83c8fe81d907", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-26.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-26.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target c } } */\n+/* { dg-do compile } */\n \n int x;\n double d;"}, {"sha": "8f1e7e90000a72d3749bf7b8cd7a2928de30f08b", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-27.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-27.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,5 +1,5 @@\n /* PR middle-end/88968 */\n-/* { dg-do compile { target c } } */\n+/* { dg-do compile } */\n \n struct __attribute__((packed)) S {\n   unsigned int a : 16;"}, {"sha": "853ae1c1baf7897ffa693c7ee491a50dbb2cdc57", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-28.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-28.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target c } } */\n+/* { dg-do compile } */\n /* { dg-additional-options \"-O2 -fdump-tree-ompexp\" } */\n /* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 4, 5, 5\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */\n /* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 4, 4, 2\\\\\\);\" 1 \"ompexp\" { target sync_int_long } } } */"}, {"sha": "1081e430c38f02ab96b08e191c306cea219f0e8f", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-29.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-29.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target c } } */\n+/* { dg-do compile } */\n /* { dg-additional-options \"-O2 -fdump-tree-ompexp\" } */\n /* { dg-additional-options \"-march=pentium\" { target ia32 } } */\n /* { dg-final { scan-tree-dump-times \"\\.ATOMIC_COMPARE_EXCHANGE \\\\\\(\\[^\\n\\r]*, 8, 5, 5\\\\\\);\" 1 \"ompexp\" { target sync_long_long } } } */"}, {"sha": "37a30bb44bda3039a55e6515cdf4e5c9eab90277", "filename": "gcc/testsuite/c-c++-common/gomp/atomic-30.c", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fatomic-30.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,9 +1,9 @@\n-/* { dg-do compile { target c } } */\n+/* { dg-do compile } */\n \n int x;\n double d, g;\n \n-double\n+void\n foo (int y, double e, long double f)\n {\n   double v;\n@@ -21,18 +21,18 @@ foo (int y, double e, long double f)\n   #pragma omp atomic compare\n   if (d + e) { d = e; }\t\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n   #pragma omp atomic capture compare\n-  { r = d >= e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n-  #pragma omp atomic capture compare\n-  { r = d <= e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n-  #pragma omp atomic capture compare\n-  { r = d > e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n-  #pragma omp atomic capture compare\n-  { r = d < e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n-  #pragma omp atomic capture compare\n-  { r = d != e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n-  #pragma omp atomic capture compare\n-  { r = d + e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" } */\n-  #pragma omp atomic capture compare\n+  { r = d >= e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" \"\" { target c } } */\n+  #pragma omp atomic capture compare\t/* { dg-error \"invalid form of '#pragma omp atomic' before 'd'\" \"\" { target c++ } .-1 } */\n+  { r = d <= e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" \"\" { target c } } */\n+  #pragma omp atomic capture compare\t/* { dg-error \"invalid form of '#pragma omp atomic' before 'd'\" \"\" { target c++ } .-1 } */\n+  { r = d > e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" \"\" { target c } } */\n+  #pragma omp atomic capture compare\t/* { dg-error \"invalid form of '#pragma omp atomic' before 'd'\" \"\" { target c++ } .-1 } */\n+  { r = d < e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" \"\" { target c } } */\n+  #pragma omp atomic capture compare\t/* { dg-error \"invalid form of '#pragma omp atomic' before 'd'\" \"\" { target c++ } .-1 } */\n+  { r = d != e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" \"\" { target c } } */\n+  #pragma omp atomic capture compare\t/* { dg-error \"invalid form of '#pragma omp atomic' before 'd'\" \"\" { target c++ } .-1 } */\n+  { r = d + e; if (r) { d = f; } }\t/* { dg-error \"expected '==', '<' or '>' comparison in 'if' condition\" \"\" { target c } } */\n+  #pragma omp atomic capture compare\t/* { dg-error \"invalid form of '#pragma omp atomic' before 'd'\" \"\" { target c++ } .-1 } */\n   { r = d == e; if (r2) { d = f; } }\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before '\\{' token\" } */\n   #pragma omp atomic capture compare\n   if (d > e) { d = e; }\t\t\t/* { dg-error \"expected '==' comparison in 'if' condition\" } */\n@@ -97,41 +97,46 @@ foo (int y, double e, long double f)\n   #pragma omp atomic compare\n   x ^= 5;\t\t\t\t/* { dg-error \"expected '=' before '\\\\\\^=' token\" } */\n   #pragma omp atomic compare\n-  x = x + 3;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x - 5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = 2 * x;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = 5 | x;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x & ~5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x | 5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x >= 5 ? 5 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x <= 5 ? 5 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x != 5 ? 7 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = 5 == x ? 7 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x == 5 ? x : 7;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x == 5 ? 9 : 7;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x > 5 ? 6 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x < 5 ? 6 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x > 5 ? x : 6;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic compare\n-  x = x < 5 ? x : 6;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n-  #pragma omp atomic capture\n+  x = x + 3;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before '\\\\\\+' token\" \"\" { target c++ } .-1 } */\n+  x = x - 5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before '-' token\" \"\" { target c++ } .-1 } */\n+  x = 2 * x;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before numeric constant\" \"\" { target c++ } .-1 } */\n+  x = 5 | x;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before numeric constant\" \"\" { target c++ } .-1 } */\n+  x = x & ~5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before '\\\\\\&' token\" \"\" { target c++ } .-1 } */\n+  x = x | 5;\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before '\\\\\\|' token\" \"\" { target c++ } .-1 } */\n+  x = x >= 5 ? 5 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid operator for '#pragma omp atomic' before '>=' token\" \"\" { target c++ } .-1 } */\n+  x = x <= 5 ? 5 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid operator for '#pragma omp atomic' before '<=' token\" \"\" { target c++ } .-1 } */\n+  x = x != 5 ? 7 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid operator for '#pragma omp atomic' before '!=' token\" \"\" { target c++ } .-1 } */\n+  x = 5 == x ? 7 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before numeric constant\" \"\" { target c++ } .-1 } */\n+  x = x == 5 ? x : 7;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" \"\" { target c++ } .-1 } */\n+  x = x == 5 ? 9 : 7;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" \"\" { target c++ } .-1 } */\n+  x = x > 5 ? 6 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" \"\" { target c++ } .-1 } */\n+  x = x < 5 ? 6 : x;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" \"\" { target c++ } .-1 } */\n+  x = x > 5 ? x : 6;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic compare\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" \"\" { target c++ } .-1 } */\n+  x = x < 5 ? x : 6;\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+  #pragma omp atomic capture\t\t/* { dg-error \"invalid form of '#pragma omp atomic compare' before ';' token\" \"\" { target c++ } .-1 } */\n   r = x == 5;\t\t\t\t/* { dg-error \"invalid operator for '#pragma omp atomic' before '==' token\" } */\n   #pragma omp atomic capture compare\n   r = x == 5;\t\t\t\t/* { dg-error \"expected '=' before '==' token\" } */\n   #pragma omp atomic capture compare\t/* { dg-error \"'#pragma omp atomic compare capture' with non-integral comparison result\" } */\n   { v = x == 5; if (v) { x = 6; } }\n+  #pragma omp atomic compare capture\n+  { r2 = x; x = y; }\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" } */\n+  #pragma omp atomic compare capture\n+  { r2 = x; x = y == 7 ? 12 : y; }\t/* { dg-error \"invalid form of '#pragma omp atomic' before ';' token\" \"\" { target c } } */\n+\t\t\t\t\t/* { dg-error \"invalid form of '#pragma omp atomic' before 'y'\" \"\" { target c++ } .-1 } */\n }"}, {"sha": "cb7a37ba83ee601f78cc7551b46dbd88ee08ba71", "filename": "gcc/testsuite/g++.dg/gomp/atomic-20.C", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-20.C?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -0,0 +1,104 @@\n+// { dg-do compile }\n+\n+int x, r, z;\n+double d, v;\n+long double ld;\n+\n+template <int N>\n+void\n+foo (int y, double e, long double f)\n+{\n+  #pragma omp atomic compare update seq_cst\n+  x = x > y ? y : x;\n+  #pragma omp atomic compare relaxed\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare\n+  d = f < d ? f : d;\n+  #pragma omp atomic compare seq_cst fail(relaxed)\n+  x = 12U < x ? 12U : x;\n+  #pragma omp atomic compare\n+  x = x == 7 ? 24 : x;\n+  #pragma omp atomic compare\n+  x = x == 123UL ? 256LL : x;\n+  #pragma omp atomic compare\n+  ld = ld == f ? f + 5.0L : ld;\n+  #pragma omp atomic compare\n+  if (x == 9) { x = 5; }\n+  #pragma omp atomic compare\n+  if (x > 5) { x = 5; }\n+  #pragma omp atomic compare\n+  if (7 > x) { x = 7; }\n+  #pragma omp atomic compare update capture seq_cst fail(acquire)\n+  v = d = f > d ? f : d;\n+  #pragma omp atomic update capture compare\n+  v = x = x < 24ULL ? 24ULL : x;\n+  #pragma omp atomic compare, capture, update\n+  v = x = x == e ? f : x;\n+  #pragma omp atomic capture compare\n+  { v = d; if (d > e) { d = e; } }\n+  #pragma omp atomic compare capture\n+  { if (e < d) { d = e; } v = d; }\n+  #pragma omp atomic compare capture\n+  { y = x; if (x == 42) { x = 7; } }\n+  #pragma omp atomic capture compare weak\n+  { if (x == 42) { x = 7; } y = x; }\n+  #pragma omp atomic capture compare fail(seq_cst)\n+  if (d == 8.0) { d = 16.0; } else { v = d; }\n+  #pragma omp atomic capture compare\n+  { r = x == 8; if (r) { x = 24; } }\n+  #pragma omp atomic compare capture\n+  { r = x == y; if (r) { x = y + 6; } else { z = x; } }\n+}\n+\n+template <typename I, typename D, typename LD>\n+void\n+bar (I &x, I &r, I &z, D &d, D &v, LD &ld, I y, D e, LD f)\n+{\n+  #pragma omp atomic compare update seq_cst\n+  x = x > y ? y : x;\n+  #pragma omp atomic compare relaxed\n+  d = e > d ? e : d;\n+  #pragma omp atomic compare\n+  d = f < d ? f : d;\n+  #pragma omp atomic compare seq_cst fail(relaxed)\n+  x = 12U < x ? 12U : x;\n+  #pragma omp atomic compare\n+  x = x == 7 ? 24 : x;\n+  #pragma omp atomic compare\n+  x = x == 123UL ? 256LL : x;\n+  #pragma omp atomic compare\n+  ld = ld == f ? f + 5.0L : ld;\n+  #pragma omp atomic compare\n+  if (x == 9) { x = 5; }\n+  #pragma omp atomic compare\n+  if (x > 5) { x = 5; }\n+  #pragma omp atomic compare\n+  if (7 > x) { x = 7; }\n+  #pragma omp atomic compare update capture seq_cst fail(acquire)\n+  v = d = f > d ? f : d;\n+  #pragma omp atomic update capture compare\n+  v = x = x < 24ULL ? 24ULL : x;\n+  #pragma omp atomic compare, capture, update\n+  v = x = x == e ? f : x;\n+  #pragma omp atomic capture compare\n+  { v = d; if (d > e) { d = e; } }\n+  #pragma omp atomic compare capture\n+  { if (e < d) { d = e; } v = d; }\n+  #pragma omp atomic compare capture\n+  { y = x; if (x == 42) { x = 7; } }\n+  #pragma omp atomic capture compare weak\n+  { if (x == 42) { x = 7; } y = x; }\n+  #pragma omp atomic capture compare fail(seq_cst)\n+  if (d == 8.0) { d = 16.0; } else { v = d; }\n+  #pragma omp atomic capture compare\n+  { r = x == 8; if (r) { x = 24; } }\n+  #pragma omp atomic compare capture\n+  { r = x == y; if (r) { x = y + 6; } else { z = x; } }\n+}\n+\n+void\n+baz (int y, double e, long double f)\n+{\n+  foo <0> (y, e, f);\n+  bar (x, r, z, d, v, ld, y, e, f);\n+}"}, {"sha": "e2fd5915cf7edc254416530e49cb8c1ab0572f4f", "filename": "gcc/testsuite/g++.dg/gomp/atomic-5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -23,7 +23,7 @@ void f1(void)\n   #pragma omp atomic\n     bar() += 1;\t\t/* { dg-error \"lvalue required\" } */\n   #pragma omp atomic a\t/* { dg-error \"expected end of line\" } */\n-    x++;\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target *-*-* } .-1 } */\n+    x++;\t\t/* { dg-error \"expected 'read', 'write', 'update', 'capture', 'compare', 'weak', 'fail', 'seq_cst', 'acq_rel', 'release', 'relaxed' or 'hint' clause\" \"\" { target *-*-* } .-1 } */\n   #pragma omp atomic\n     ;\t\t\t/* { dg-error \"expected primary-expression\" } */\n   #pragma omp atomic"}, {"sha": "1bbd48a5ff85c7b80b34f3e0dae0b24375a9f1c7", "filename": "libgomp/testsuite/libgomp.c++/atomic-16.C", "status": "added", "additions": 538, "deletions": 0, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-16.C?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -0,0 +1,538 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+int x = 6;\n+int w, y;\n+\n+int *\n+foo (void)\n+{\n+  if (w)\n+    abort ();\n+  return &y;\n+}\n+\n+template <int N>\n+void\n+bar ()\n+{\n+  int v, r;\n+  #pragma omp atomic compare\n+  x = x > 8 ? 8 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x > 4 ? 4 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  v = x = x < 8 ? 8 : x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 12 ? 12 : x; }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 4 ? 4 : x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic write\n+  x = -32;\n+  #pragma omp atomic capture compare seq_cst fail(relaxed)\n+  { x = 12U < x ? 12U : x; v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x == 12 ? 16 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  v = x = x == 15 ? r + 7 : x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; x = x == 73ULL - r ? 12LL : x; }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { x = x == 69LL - r ? (unsigned char) 6 : x; v = x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 8) { x = 8; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 4) { x = 4; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  { if (x < 8) { x = 8; } v = x; }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 12) { x = 12; } }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 4) { x = 4; } }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic write\n+  x = -32;\n+  #pragma omp atomic capture compare seq_cst fail(relaxed)\n+  { if (12U < x) { x = 12U; } v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x == 12) { x = 16; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  { if (x == 15) { x = r + 7; } v = x; }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; if (x == 73ULL - r) { x = 12LL; } }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { if (x == 69LL - r) { x = (unsigned char) 6; } v = x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 24;\n+  #pragma omp atomic compare capture\n+  if (x == 12) { x = 16; } else { v = x; }\n+  if (v != 6)\n+    abort ();\n+  v = 32;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 147;\n+  #pragma omp atomic capture compare\n+  if (x == 6) { x = 57; } else { v = x; }\n+  if (v != 147)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic update, capture, compare, weak, seq_cst, fail (relaxed)\n+  { r = x == 137; if (r) { x = 174; } }\n+  if (r)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic compare capture fail (relaxed)\n+  { r = x == 57; if (r) { x = 6; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = -5;\n+  #pragma omp atomic capture compare\n+  { r = x == 17; if (r) { x = 25; } else { v = x; } }\n+  if (r || v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 15;\n+  #pragma omp atomic capture compare\n+  { r = x == 6; if (r) { x = 23; } else { v = x; } }\n+  if (r != 1 || v != 15)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  w = 1;\n+  #pragma omp atomic compare capture\n+  if (x == 23) { x = 57; } else { foo ()[0] = x; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic capture update compare\n+  { r = x == 57; if (r) { x = 23; } else { foo ()[0] = x; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  w = 0;\n+  #pragma omp atomic compare capture\n+  if (x == 24) { x = 57; } else { foo ()[0] = x; }\n+  if (y != 23)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  y = -5;\n+  #pragma omp atomic capture update compare\n+  {\n+    r = x == 57;\n+    if (r)\n+      {\n+\tx = 27;\n+      }\n+    else\n+      {\n+\tfoo ()[0] = x;\n+      }\n+  }\n+  if (r || y != 23)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+}\n+\n+template <typename T>\n+void\n+baz (T &x, T &w, T &y)\n+{\n+  T v, r;\n+  #pragma omp atomic compare\n+  x = x > 8 ? 8 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x > 4 ? 4 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  v = x = x < 8 ? 8 : x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 12 ? 12 : x; }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 4 ? 4 : x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic write\n+  x = -32;\n+  #pragma omp atomic capture compare seq_cst fail(relaxed)\n+  { x = 12U < x ? 12U : x; v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x == 12 ? 16 : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  v = x = x == 15 ? r + 7 : x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; x = x == 73ULL - r ? 12LL : x; }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { x = x == 69LL - r ? (unsigned char) 6 : x; v = x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 8) { x = 8; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 4) { x = 4; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  { if (x < 8) { x = 8; } v = x; }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 12) { x = 12; } }\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 4) { x = 4; } }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic write\n+  x = -32;\n+  #pragma omp atomic capture compare seq_cst fail(relaxed)\n+  { if (12U < x) { x = 12U; } v = x; }\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x == 12) { x = 16; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  { if (x == 15) { x = r + 7; } v = x; }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; if (x == 73ULL - r) { x = 12LL; } }\n+  if (v != 16)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { if (x == 69LL - r) { x = (unsigned char) 6; } v = x; }\n+  if (v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 24;\n+  #pragma omp atomic compare capture\n+  if (x == 12) { x = 16; } else { v = x; }\n+  if (v != 6)\n+    abort ();\n+  v = 32;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 147;\n+  #pragma omp atomic capture compare\n+  if (x == 6) { x = 57; } else { v = x; }\n+  if (v != 147)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic update, capture, compare, weak, seq_cst, fail (relaxed)\n+  { r = x == 137; if (r) { x = 174; } }\n+  if (r)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic compare capture fail (relaxed)\n+  { r = x == 57; if (r) { x = 6; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = -5;\n+  #pragma omp atomic capture compare\n+  { r = x == 17; if (r) { x = 25; } else { v = x; } }\n+  if (r || v != 6)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6)\n+    abort ();\n+  v = 15;\n+  #pragma omp atomic capture compare\n+  { r = x == 6; if (r) { x = 23; } else { v = x; } }\n+  if (r != 1 || v != 15)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  w = 1;\n+  #pragma omp atomic compare capture\n+  if (x == 23) { x = 57; } else { foo ()[0] = x; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57)\n+    abort ();\n+  #pragma omp atomic capture update compare\n+  { r = x == 57; if (r) { x = 23; } else { foo ()[0] = x; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  w = 0;\n+  #pragma omp atomic compare capture\n+  if (x == 24) { x = 57; } else { foo ()[0] = x; }\n+  if (y != 23)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+  y = -5;\n+  #pragma omp atomic capture update compare\n+  {\n+    r = x == 57;\n+    if (r)\n+      {\n+\tx = 27;\n+      }\n+    else\n+      {\n+\tfoo ()[0] = x;\n+      }\n+  }\n+  if (r || y != 23)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  bar <0> ();\n+  #pragma omp atomic write\n+  x = 6;\n+  y = 0;\n+  w = 0;\n+  baz (x, w, y);\n+}"}, {"sha": "68ae7fc30ab715f1e80904ece95673c586b90264", "filename": "libgomp/testsuite/libgomp.c++/atomic-17.C", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fatomic-17.C?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -0,0 +1,407 @@\n+// { dg-do run }\n+\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void abort (void);\n+float x = 6.0f;\n+\n+template <int N>\n+void\n+bar ()\n+{\n+  float v;\n+  int r;\n+  #pragma omp atomic compare\n+  x = x > 8.0f ? 8.0f : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x > 4.0f ? 4.0f : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4.0f)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  v = x = x < 8.0f ? 8.0f : x;\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 12.0f ? 12.0f : x; }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 4.0f ? 4.0f : x; }\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x == 12.0 ? 16.0L : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  v = x = x == 15.0f ? r + 7.0f : x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; x = x == 73.0L - r ? 12.0f : x; }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { x = x == 69.0 - r ? 6.0f : x; v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 8.0f) { x = 8.0f; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 4.0) { x = 4.0; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4.0f)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  { if (x < 8.0f) { x = 8.0f; } v = x; }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 12.0f) { x = 12.0f; } }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 4.0L) { x = 4.0L; } }\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x == 12.0f) { x = 16.0L; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  r = 57.0;\n+  #pragma omp atomic compare capture\n+  { if (x == 15.0f) { x = r + 7.0f; } v = x; }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; if (x == 73.0L - r) { x = 12.0L; } }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { if (x == 69.0L - r) { x = 6.0; } v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 24;\n+  #pragma omp atomic compare capture\n+  if (x == 12.0f) { x = 16.0f; } else { v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  v = 32.0f;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 147.0f;\n+  #pragma omp atomic capture compare\n+  if (x == 6.0f) { x = 57.0f; } else { v = x; }\n+  if (v != 147.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57.0f)\n+    abort ();\n+  #pragma omp atomic update, capture, compare, weak, seq_cst, fail (relaxed)\n+  { r = x == 137.0f; if (r) { x = 174.0f; } }\n+  if (r)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57.0f)\n+    abort ();\n+  #pragma omp atomic compare capture fail (relaxed)\n+  { r = x == 57.0f; if (r) { x = 6.0f; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = -5.0f;\n+  #pragma omp atomic capture compare\n+  { r = x == 17.0L; if (r) { x = 25.0; } else { v = x; } }\n+  if (r || v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 15.0f;\n+  #pragma omp atomic capture compare\n+  { r = x == 6.0f; if (r) { x = 23.0f; } else { v = x; } }\n+  if (r != 1 || v != 15.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23.0f)\n+    abort ();\n+}\n+\n+template <typename T, typename U>\n+void\n+baz (T &x)\n+{\n+  T v;\n+  U r;\n+  #pragma omp atomic compare\n+  x = x > 8.0f ? 8.0f : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x > 4.0f ? 4.0f : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4.0f)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  v = x = x < 8.0f ? 8.0f : x;\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 12.0f ? 12.0f : x; }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; x = x < 4.0f ? 4.0f : x; }\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  x = x == 12.0 ? 16.0L : x;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0)\n+    abort ();\n+  r = 57;\n+  #pragma omp atomic compare capture\n+  v = x = x == 15.0f ? r + 7.0f : x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; x = x == 73.0L - r ? 12.0f : x; }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { x = x == 69.0 - r ? 6.0f : x; v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 8.0f) { x = 8.0f; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x > 4.0) { x = 4.0; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 4.0f)\n+    abort ();\n+  #pragma omp atomic compare capture\n+  { if (x < 8.0f) { x = 8.0f; } v = x; }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 12.0f) { x = 12.0f; } }\n+  if (v != 8.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic capture compare\n+  { v = x; if (x < 4.0L) { x = 4.0L; } }\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic compare\n+  if (x == 12.0f) { x = 16.0L; }\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  r = 57.0;\n+  #pragma omp atomic compare capture\n+  { if (x == 15.0f) { x = r + 7.0f; } v = x; }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic capture, update, compare seq_cst fail(acquire)\n+  { v = x; if (x == 73.0L - r) { x = 12.0L; } }\n+  if (v != 16.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 12.0f)\n+    abort ();\n+  #pragma omp atomic update, compare, capture\n+  { if (x == 69.0L - r) { x = 6.0; } v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 24;\n+  #pragma omp atomic compare capture\n+  if (x == 12.0f) { x = 16.0f; } else { v = x; }\n+  if (v != 6.0f)\n+    abort ();\n+  v = 32.0f;\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 147.0f;\n+  #pragma omp atomic capture compare\n+  if (x == 6.0f) { x = 57.0f; } else { v = x; }\n+  if (v != 147.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57.0f)\n+    abort ();\n+  #pragma omp atomic update, capture, compare, weak, seq_cst, fail (relaxed)\n+  { r = x == 137.0f; if (r) { x = 174.0f; } }\n+  if (r)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 57.0f)\n+    abort ();\n+  #pragma omp atomic compare capture fail (relaxed)\n+  { r = x == 57.0f; if (r) { x = 6.0f; } }\n+  if (r != 1)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = -5.0f;\n+  #pragma omp atomic capture compare\n+  { r = x == 17.0L; if (r) { x = 25.0; } else { v = x; } }\n+  if (r || v != 6.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 6.0f)\n+    abort ();\n+  v = 15.0f;\n+  #pragma omp atomic capture compare\n+  { r = x == 6.0f; if (r) { x = 23.0f; } else { v = x; } }\n+  if (r != 1 || v != 15.0f)\n+    abort ();\n+  #pragma omp atomic read\n+  v = x;\n+  if (v != 23.0f)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  bar <0> ();\n+  #pragma omp atomic write\n+  x = 6.0f;\n+  baz <float, int> (x);\n+}"}, {"sha": "0437983d35bade2cb886001d2736214016ed42dd", "filename": "libgomp/testsuite/libgomp.c-c++-common/atomic-19.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-19.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c } }\n+/* { dg-do run } */\n \n extern\n #ifdef __cplusplus"}, {"sha": "245d7167fbb28c746aee0b2c09370f8d68d58a64", "filename": "libgomp/testsuite/libgomp.c-c++-common/atomic-20.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-20.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c } }\n+/* { dg-do run } */\n \n extern\n #ifdef __cplusplus"}, {"sha": "8f66c429a544e21962b67fe8bf78e55bb2840d74", "filename": "libgomp/testsuite/libgomp.c-c++-common/atomic-21.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2bcffac602f5de56537a77db1062984bcefd45/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fatomic-21.c?ref=3a2bcffac602f5de56537a77db1062984bcefd45", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c } }\n+/* { dg-do run } */\n \n double d;\n long double ld;"}]}