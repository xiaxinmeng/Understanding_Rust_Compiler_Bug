{"sha": "6f29feb107bb13375b45257759c77fc21759a009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYyOWZlYjEwN2JiMTMzNzViNDUyNTc3NTljNzdmYzIxNzU5YTAwOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1991-12-06T21:00:31Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1991-12-06T21:00:31Z"}, "message": "Initial revision\n\nFrom-SVN: r104", "tree": {"sha": "034a1c33b073c87abfc8b55105a51ea9e8bceb7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/034a1c33b073c87abfc8b55105a51ea9e8bceb7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f29feb107bb13375b45257759c77fc21759a009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f29feb107bb13375b45257759c77fc21759a009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f29feb107bb13375b45257759c77fc21759a009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f29feb107bb13375b45257759c77fc21759a009/comments", "author": null, "committer": null, "parents": [{"sha": "35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35d965d5c95e8c50c9cc5220f03db1fe774f78f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35d965d5c95e8c50c9cc5220f03db1fe774f78f4"}], "stats": {"total": 1567, "additions": 1567, "deletions": 0}, "files": [{"sha": "e623f63d0db07269c8d4a4371a8b88a5e5ca7bfe", "filename": "gcc/rtl.c", "status": "added", "additions": 819, "deletions": 0, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f29feb107bb13375b45257759c77fc21759a009/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f29feb107bb13375b45257759c77fc21759a009/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=6f29feb107bb13375b45257759c77fc21759a009", "patch": "@@ -0,0 +1,819 @@\n+/* Allocate and read RTL for GNU C Compiler.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include <ctype.h>\n+#include <stdio.h>\n+#include \"rtl.h\"\n+\n+#include \"obstack.h\"\n+#define\tobstack_chunk_alloc\txmalloc\n+#define\tobstack_chunk_free\tfree\n+extern int xmalloc ();\n+extern void free ();\n+\n+/* Obstack used for allocating RTL objects.\n+   Between functions, this is the permanent_obstack.\n+   While parsing and expanding a function, this is maybepermanent_obstack\n+   so we can save it if it is an inline function.\n+   During optimization and output, this is function_obstack.  */\n+\n+extern struct obstack *rtl_obstack;\n+\n+extern long ftell();\n+\f\n+/* Indexed by rtx code, gives number of operands for an rtx with that code.\n+   Does NOT include rtx header data (code and links).\n+   This array is initialized in init_rtl.  */\n+\n+int rtx_length[NUM_RTX_CODE + 1];\n+\n+/* Indexed by rtx code, gives the name of that kind of rtx, as a C string.  */\n+\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   NAME ,\n+\n+char *rtx_name[] = {\n+#include \"rtl.def\"\t\t/* rtl expressions are documented here */\n+};\n+\n+#undef DEF_RTL_EXPR\n+\n+/* Indexed by machine mode, gives the name of that machine mode.\n+   This name does not include the letters \"mode\".  */\n+\n+#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  NAME,\n+\n+char *mode_name[(int) MAX_MACHINE_MODE] = {\n+#include \"machmode.def\"\n+\n+#ifdef EXTRA_CC_MODES\n+  EXTRA_CC_NAMES\n+#endif\n+\n+};\n+\n+#undef DEF_MACHMODE\n+\n+/* Indexed by machine mode, gives the length of the mode, in bytes.\n+   GET_MODE_CLASS uses this.  */\n+\n+#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  CLASS,\n+\n+enum mode_class mode_class[(int) MAX_MACHINE_MODE] = {\n+#include \"machmode.def\"\n+};\n+\n+#undef DEF_MACHMODE\n+\n+/* Indexed by machine mode, gives the length of the mode, in bytes.\n+   GET_MODE_SIZE uses this.  */\n+\n+#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  SIZE,\n+\n+int mode_size[(int) MAX_MACHINE_MODE] = {\n+#include \"machmode.def\"\n+};\n+\n+#undef DEF_MACHMODE\n+\n+/* Indexed by machine mode, gives the length of the mode's subunit.\n+   GET_MODE_UNIT_SIZE uses this.  */\n+\n+#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  UNIT,\n+\n+int mode_unit_size[(int) MAX_MACHINE_MODE] = {\n+#include \"machmode.def\"\t\t/* machine modes are documented here */\n+};\n+\n+#undef DEF_MACHMODE\n+\n+/* Indexed by machine mode, gives next wider natural mode\n+   (QI -> HI -> SI -> DI, etc.)  Widening multiply instructions\n+   use this.  */\n+\n+#define DEF_MACHMODE(SYM, NAME, CLASS, SIZE, UNIT, WIDER)  \\\n+  (enum machine_mode) WIDER,\n+\n+enum machine_mode mode_wider_mode[(int) MAX_MACHINE_MODE] = {\n+#include \"machmode.def\"\t\t/* machine modes are documented here */\n+};\n+\n+#undef DEF_MACHMODE\n+\n+/* Indexed by rtx code, gives a sequence of operand-types for\n+   rtx's of that code.  The sequence is a C string in which\n+   each charcter describes one operand.  */\n+\n+char *rtx_format[] = {\n+  /* \"*\" undefined.\n+         can cause a warning message\n+     \"0\" field is unused (or used in a phase-dependent manner)\n+         prints nothing\n+     \"i\" an integer\n+         prints the integer\n+     \"n\" like \"i\", but prints entries from `note_insn_name'\n+     \"s\" a pointer to a string\n+         prints the string\n+     \"S\" like \"s\", but optional:\n+\t the containing rtx may end before this operand\n+     \"e\" a pointer to an rtl expression\n+         prints the expression\n+     \"E\" a pointer to a vector that points to a number of rtl expressions\n+         prints a list of the rtl expressions\n+     \"V\" like \"E\", but optional:\n+\t the containing rtx may end before this operand\n+     \"u\" a pointer to another insn\n+         prints the uid of the insn.  */\n+\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,\n+#include \"rtl.def\"\t\t/* rtl expressions are defined here */\n+#undef DEF_RTL_EXPR\n+};\n+\n+/* Indexed by rtx code, gives a character representing the \"class\" of\n+   that rtx code.  See rtl.def for documentation on the defined classes.  */\n+\n+char rtx_class[] = {\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   CLASS, \n+#include \"rtl.def\"\t\t/* rtl expressions are defined here */\n+#undef DEF_RTL_EXPR\n+};\n+\n+/* Names for kinds of NOTEs and REG_NOTEs.  */\n+\n+char *note_insn_name[] = { \"NOTE_INSN_FUNCTION_BEG\", \"NOTE_INSN_DELETED\",\n+\t\t\t   \"NOTE_INSN_BLOCK_BEG\", \"NOTE_INSN_BLOCK_END\",\n+\t\t\t   \"NOTE_INSN_LOOP_BEG\", \"NOTE_INSN_LOOP_END\",\n+\t\t\t   \"NOTE_INSN_FUNCTION_END\", \"NOTE_INSN_SETJMP\",\n+\t\t\t   \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\" };\n+\n+char *reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n+\t\t\t  \"REG_EQUAL\", \"REG_RETVAL\", \"REG_LIBCALL\",\n+\t\t\t  \"REG_NONNEG\", \"REG_NO_CONFLICT\", \"REG_UNUSED\",\n+\t\t\t  \"REG_CC_SETTER\", \"REG_CC_USER\", \"REG_LABEL\",\n+\t\t\t  \"REG_DEP_ANTI\", \"REG_DEP_OUTPUT\" };\n+\n+/* Allocate an rtx vector of N elements.\n+   Store the length, and initialize all elements to zero.  */\n+\n+rtvec\n+rtvec_alloc (n)\n+     int n;\n+{\n+  rtvec rt;\n+  int i;\n+\n+  rt = (rtvec) obstack_alloc (rtl_obstack,\n+\t\t\t      sizeof (struct rtvec_def)\n+\t\t\t      + (( n - 1) * sizeof (rtunion)));\n+\n+  /* clear out the vector */\n+  PUT_NUM_ELEM(rt, n);\n+  for (i=0; i < n; i++)\n+    rt->elem[i].rtvec = NULL;\t/* @@ not portable due to rtunion */\n+\n+  return rt;\n+}\n+\n+/* Allocate an rtx of code CODE.  The CODE is stored in the rtx;\n+   all the rest is initialized to zero.  */\n+\n+rtx\n+rtx_alloc (code)\n+  RTX_CODE code;\n+{\n+  rtx rt;\n+  register struct obstack *ob = rtl_obstack;\n+  register int nelts = GET_RTX_LENGTH (code);\n+  register int length = sizeof (struct rtx_def)\n+    + (nelts - 1) * sizeof (rtunion);\n+\n+  /* This function is called more than any other in GCC,\n+     so we manipulate the obstack directly.\n+\n+     Even though rtx objects are word aligned, we may be sharing an obstack\n+     with tree nodes, which may have to be double-word aligned.  So align\n+     our length to the alignment mask in the obstack.  */\n+\n+  length = (length + ob->alignment_mask) & ~ ob->alignment_mask;\n+\n+  if (ob->chunk_limit - ob->next_free < length)\n+    _obstack_newchunk (ob, length);\n+  rt = (rtx)ob->object_base;\n+  ob->next_free += length;\n+  ob->object_base = ob->next_free;\n+\n+  * (int *) rt = 0;\n+  PUT_CODE (rt, code);\n+\n+  return rt;\n+}\n+\f\n+/* Create a new copy of an rtx.\n+   Recursively copies the operands of the rtx,\n+   except for those few rtx codes that are sharable.  */\n+\n+rtx\n+copy_rtx (orig)\n+     register rtx orig;\n+{\n+  register rtx copy;\n+  register int i, j;\n+  register RTX_CODE code;\n+  register char *format_ptr;\n+\n+  code = GET_CODE (orig);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+      return orig;\n+    }\n+\n+  copy = rtx_alloc (code);\n+  PUT_MODE (copy, GET_MODE (orig));\n+  copy->in_struct = orig->in_struct;\n+  copy->volatil = orig->volatil;\n+  copy->unchanging = orig->unchanging;\n+  copy->integrated = orig->integrated;\n+  \n+  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  XEXP (copy, i) = XEXP (orig, i);\n+\t  if (XEXP (orig, i) != NULL)\n+\t    XEXP (copy, i) = copy_rtx (XEXP (orig, i));\n+\t  break;\n+\n+\tcase 'E':\n+\tcase 'V':\n+\t  XVEC (copy, i) = XVEC (orig, i);\n+\t  if (XVEC (orig, i) != NULL)\n+\t    {\n+\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t      for (j = 0; j < XVECLEN (copy, i); j++)\n+\t\tXVECEXP (copy, i, j) = copy_rtx (XVECEXP (orig, i, j));\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  XINT (copy, i) = XINT (orig, i);\n+\t  break;\n+\t}\n+    }\n+  return copy;\n+}\n+\n+/* Similar to `copy_rtx' except that if MAY_SHARE is present, it is\n+   placed in the result directly, rather than being copied.  */\n+\n+rtx\n+copy_most_rtx (orig, may_share)\n+     register rtx orig;\n+     register rtx may_share;\n+{\n+  register rtx copy;\n+  register int i, j;\n+  register RTX_CODE code;\n+  register char *format_ptr;\n+\n+  if (orig == may_share)\n+    return orig;\n+\n+  code = GET_CODE (orig);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+      return orig;\n+    }\n+\n+  copy = rtx_alloc (code);\n+  PUT_MODE (copy, GET_MODE (orig));\n+  copy->in_struct = orig->in_struct;\n+  copy->volatil = orig->volatil;\n+  copy->unchanging = orig->unchanging;\n+  copy->integrated = orig->integrated;\n+  \n+  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  XEXP (copy, i) = XEXP (orig, i);\n+\t  if (XEXP (orig, i) != NULL && XEXP (orig, i) != may_share)\n+\t    XEXP (copy, i) = copy_most_rtx (XEXP (orig, i), may_share);\n+\t  break;\n+\n+\tcase 'E':\n+\tcase 'V':\n+\t  XVEC (copy, i) = XVEC (orig, i);\n+\t  if (XVEC (orig, i) != NULL)\n+\t    {\n+\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t      for (j = 0; j < XVECLEN (copy, i); j++)\n+\t\tXVECEXP (copy, i, j)\n+\t\t  = copy_most_rtx (XVECEXP (orig, i, j), may_share);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  XINT (copy, i) = XINT (orig, i);\n+\t  break;\n+\t}\n+    }\n+  return copy;\n+}\n+\f\n+/* Helper functions for instruction scheduling.  */\n+\n+/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n+   LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type\n+   of dependence that this link represents.  */\n+\n+void\n+add_dependence (insn, elem, dep_type)\n+     rtx insn;\n+     rtx elem;\n+     enum reg_note dep_type;\n+{\n+  rtx link;\n+\n+  /* Don't depend an insn on itself.  */\n+  if (insn == elem)\n+    return;\n+\n+  /* If elem is part of a sequence that must be scheduled together, then\n+     make the dependence point to the last insn of the sequence.  */\n+  if (NEXT_INSN (elem) && SCHED_GROUP_P (NEXT_INSN (elem)))\n+    {\n+      while (NEXT_INSN (elem) && SCHED_GROUP_P (NEXT_INSN (elem)))\n+\telem = NEXT_INSN (elem);\n+      /* Again, don't depend an insn of itself.  */\n+      if (insn == elem)\n+\treturn;\n+    }\n+\n+  /* Check that we don't already have this dependence.  */\n+  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+    if (XEXP (link, 0) == elem)\n+      {\n+\t/* If this is a more restrictive type of dependence than the existing\n+\t   one, then change the existing dependence to this type.  */\n+\tif (dep_type < REG_NOTE_KIND (link))\n+\t  PUT_REG_NOTE_KIND (link, dep_type);\n+\treturn;\n+      }\n+  /* Might want to check one level of transitivity to save conses.  */\n+\n+  link = rtx_alloc (INSN_LIST);\n+  /* Insn dependency, not data dependency.  */\n+  PUT_REG_NOTE_KIND (link, dep_type);\n+  XEXP (link, 0) = elem;\n+  XEXP (link, 1) = LOG_LINKS (insn);\n+  LOG_LINKS (insn) = link;\n+}\n+\n+/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n+   of INSN.  Abort if not found.  */\n+void\n+remove_dependence (insn, elem)\n+     rtx insn;\n+     rtx elem;\n+{\n+  rtx prev, link;\n+  int found = 0;\n+\n+  for (prev = 0, link = LOG_LINKS (insn); link;\n+       prev = link, link = XEXP (link, 1))\n+    {\n+      if (XEXP (link, 0) == elem)\n+\t{\n+\t  if (prev)\n+\t    XEXP (prev, 1) = XEXP (link, 1);\n+\t  else\n+\t    LOG_LINKS (insn) = XEXP (link, 1);\n+\t  found = 1;\n+\t}\n+    }\n+\n+  if (! found)\n+    abort ();\n+  return;\n+}\n+\f\n+/* Subroutines of read_rtx.  */\n+\n+/* Dump code after printing a message.  Used when read_rtx finds\n+   invalid data.  */\n+\n+static void\n+dump_and_abort (expected_c, actual_c, infile)\n+     int expected_c, actual_c;\n+     FILE *infile;\n+{\n+  int c, i;\n+\n+  if (expected_c >= 0)\n+    fprintf (stderr,\n+\t     \"Expected character %c.  Found character %c.\",\n+\t     expected_c, actual_c);\n+  fprintf (stderr, \"  At file position: %ld\\n\", ftell (infile));\n+  fprintf (stderr, \"Following characters are:\\n\\t\");\n+  for (i = 0; i < 200; i++)\n+    {\n+      c = getc (infile);\n+      if (EOF == c) break;\n+      putc (c, stderr);\n+    }\n+  fprintf (stderr, \"Aborting.\\n\");\n+  abort ();\n+}\n+\n+/* Read chars from INFILE until a non-whitespace char\n+   and return that.  Comments, both Lisp style and C style,\n+   are treated as whitespace.\n+   Tools such as genflags use this function.  */\n+\n+int\n+read_skip_spaces (infile)\n+     FILE *infile;\n+{\n+  register int c;\n+  while (c = getc (infile))\n+    {\n+      if (c == ' ' || c == '\\n' || c == '\\t' || c == '\\f')\n+\t;\n+      else if (c == ';')\n+\t{\n+\t  while ((c = getc (infile)) && c != '\\n') ;\n+\t}\n+      else if (c == '/')\n+\t{\n+\t  register int prevc;\n+\t  c = getc (infile);\n+\t  if (c != '*')\n+\t    dump_and_abort ('*', c, infile);\n+\t  \n+\t  prevc = 0;\n+\t  while (c = getc (infile))\n+\t    {\n+\t      if (prevc == '*' && c == '/')\n+\t\tbreak;\n+\t      prevc = c;\n+\t    }\n+\t}\n+      else break;\n+    }\n+  return c;\n+}\n+\n+/* Read an rtx code name into the buffer STR[].\n+   It is terminated by any of the punctuation chars of rtx printed syntax.  */\n+\n+static void\n+read_name (str, infile)\n+     char *str;\n+     FILE *infile;\n+{\n+  register char *p;\n+  register int c;\n+\n+  c = read_skip_spaces(infile);\n+\n+  p = str;\n+  while (1)\n+    {\n+      if (c == ' ' || c == '\\n' || c == '\\t' || c == '\\f')\n+\tbreak;\n+      if (c == ':' || c == ')' || c == ']' || c == '\"' || c == '/'\n+\t  || c == '(' || c == '[')\n+\t{\n+\t  ungetc (c, infile);\n+\t  break;\n+\t}\n+      *p++ = c;\n+      c = getc (infile);\n+    }\n+  if (p == str)\n+    {\n+      fprintf (stderr, \"missing name or number\");\n+      dump_and_abort (-1, -1, infile);\n+    }\n+\n+  *p = 0;\n+}\n+\f\n+/* Read an rtx in printed representation from INFILE\n+   and return an actual rtx in core constructed accordingly.\n+   read_rtx is not used in the compiler proper, but rather in\n+   the utilities gen*.c that construct C code from machine descriptions.  */\n+\n+rtx\n+read_rtx (infile)\n+     FILE *infile;\n+{\n+  register int i, j, list_counter;\n+  RTX_CODE tmp_code;\n+  register char *format_ptr;\n+  /* tmp_char is a buffer used for reading decimal integers\n+     and names of rtx types and machine modes.\n+     Therefore, 256 must be enough.  */\n+  char tmp_char[256];\n+  rtx return_rtx;\n+  register int c;\n+  int tmp_int;\n+\n+  /* Linked list structure for making RTXs: */\n+  struct rtx_list\n+    {\n+      struct rtx_list *next;\n+      rtx value;\t\t/* Value of this node...\t\t*/\n+    };\n+\n+  c = read_skip_spaces (infile); /* Should be open paren.  */\n+  if (c != '(')\n+    dump_and_abort ('(', c, infile);\n+\n+  read_name (tmp_char, infile);\n+\n+  tmp_code = UNKNOWN;\n+\n+  for (i=0; i < NUM_RTX_CODE; i++) /* @@ might speed this search up */\n+    {\n+      if (!(strcmp (tmp_char, GET_RTX_NAME (i))))\n+\t{\n+\t  tmp_code = (RTX_CODE) i;\t/* get value for name */\n+\t  break;\n+\t}\n+    }\n+  if (tmp_code == UNKNOWN)\n+    {\n+      fprintf (stderr,\n+\t       \"Unknown rtx read in rtl.read_rtx(). Code name was %s .\",\n+\t       tmp_char);\n+    }\n+  /* (NIL) stands for an expression that isn't there.  */\n+  if (tmp_code == NIL)\n+    {\n+      /* Discard the closeparen.  */\n+      while ((c = getc (infile)) && c != ')');\n+      return 0;\n+    }\n+\n+  return_rtx = rtx_alloc (tmp_code); /* if we end up with an insn expression\n+\t\t\t\t       then we free this space below.  */\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (return_rtx));\n+\n+  /* If what follows is `: mode ', read it and\n+     store the mode in the rtx.  */\n+\n+  i = read_skip_spaces (infile);\n+  if (i == ':')\n+    {\n+      register int k;\n+      read_name (tmp_char, infile);\n+      for (k = 0; k < NUM_MACHINE_MODES; k++)\n+\tif (!strcmp (GET_MODE_NAME (k), tmp_char))\n+\t  break;\n+\n+      PUT_MODE (return_rtx, (enum machine_mode) k );\n+    }\n+  else\n+    ungetc (i, infile);\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (return_rtx)); i++)\n+    switch (*format_ptr++)\n+      {\n+\t/* 0 means a field for internal use only.\n+\t   Don't expect it to be present in the input.  */\n+      case '0':\n+\tbreak;\n+\n+      case 'e':\n+      case 'u':\n+\tXEXP (return_rtx, i) = read_rtx (infile);\n+\tbreak;\n+\n+      case 'V':\n+\t/* 'V' is an optional vector: if a closeparen follows,\n+\t   just store NULL for this element.  */\n+\tc = read_skip_spaces (infile);\n+\tungetc (c, infile);\n+\tif (c == ')')\n+\t  {\n+\t    XVEC (return_rtx, i) = 0;\n+\t    break;\n+ \t  }\n+\t/* Now process the vector.  */\n+  \n+      case 'E':\n+\t{\n+\t  register struct rtx_list *next_rtx, *rtx_list_link;\n+\t  struct rtx_list *list_rtx;\n+\n+\t  c = read_skip_spaces (infile);\n+\t  if (c != '[')\n+\t    dump_and_abort ('[', c, infile);\n+\n+\t  /* add expressions to a list, while keeping a count */\n+\t  next_rtx = NULL;\n+\t  list_counter = 0;\n+\t  while ((c = read_skip_spaces (infile)) && c != ']')\n+\t    {\n+\t      ungetc (c, infile);\n+\t      list_counter++;\n+\t      rtx_list_link = (struct rtx_list *)\n+\t\talloca (sizeof (struct rtx_list));\n+\t      rtx_list_link->value = read_rtx (infile);\n+\t      if (next_rtx == 0)\n+\t\tlist_rtx = rtx_list_link;\n+\t      else\n+\t\tnext_rtx->next = rtx_list_link;\n+\t      next_rtx = rtx_list_link;\n+\t      rtx_list_link->next = 0;\n+\t    }\n+\t  /* get vector length and allocate it */\n+\t  XVEC (return_rtx, i) = (list_counter\n+\t\t\t\t  ? rtvec_alloc (list_counter)\n+\t\t\t\t  : (struct rtvec_def *) NULL);\n+\t  if (list_counter > 0)\n+\t    {\n+\t      next_rtx = list_rtx;\n+\t      for (j = 0; j < list_counter; j++,\n+\t\t   next_rtx = next_rtx->next)\n+\t\tXVECEXP (return_rtx, i, j) = next_rtx->value;\n+\t    }\n+\t  /* close bracket gotten */\n+\t}\n+\tbreak;\n+\n+      case 'S':\n+\t/* 'S' is an optional string: if a closeparen follows,\n+\t   just store NULL for this element.  */\n+\tc = read_skip_spaces (infile);\n+\tungetc (c, infile);\n+\tif (c == ')')\n+\t  {\n+\t    XSTR (return_rtx, i) = 0;\n+\t    break;\n+\t  }\n+\n+      case 's':\n+\t{\n+\t  int saw_paren = 0;\n+\t  register char *stringbuf;\n+\t  int stringbufsize;\n+\n+\t  c = read_skip_spaces (infile);\n+\t  if (c == '(')\n+\t    {\n+\t      saw_paren = 1;\n+\t      c = read_skip_spaces (infile);\n+\t    }\n+\t  if (c != '\"')\n+\t    dump_and_abort ('\"', c, infile);\n+\t  j = 0;\n+\t  stringbufsize = 10;\n+\t  stringbuf = (char *) xmalloc (stringbufsize + 1);\n+\n+\t  while (1)\n+\t    {\n+\t      if (j >= stringbufsize - 4)\n+\t\t{\n+\t\t  stringbufsize *= 2;\n+\t\t  stringbuf = (char *) xrealloc (stringbuf, stringbufsize + 1);\n+\t\t}\n+\t      stringbuf[j] = getc (infile); /* Read the string  */\n+\t      if (stringbuf[j] == '\\\\')\n+\t\t{\n+\t\t  stringbuf[j] = getc (infile);\t/* Read the string  */\n+\t\t  /* \\; makes stuff for a C string constant containing\n+\t\t     newline and tab.  */\n+\t\t  if (stringbuf[j] == ';')\n+\t\t    {\n+\t\t      strcpy (&stringbuf[j], \"\\\\n\\\\t\");\n+\t\t      j += 3;\n+\t\t    }\n+\t\t}\n+\t      else if (stringbuf[j] == '\"')\n+\t\tbreak;\n+\t      j++;\n+\t    }\n+\n+\t  stringbuf[j] = 0;\t/* NUL terminate the string  */\n+\t  stringbuf = (char *) xrealloc (stringbuf, j + 1);\n+\n+\t  if (saw_paren)\n+\t    {\n+\t      c = read_skip_spaces (infile);\n+\t      if (c != ')')\n+\t\tdump_and_abort (')', c, infile);\n+\t    }\n+\t  XSTR (return_rtx, i) = stringbuf;\n+\t}\n+\tbreak;\n+\n+      case 'i':\n+      case 'n':\n+\tread_name (tmp_char, infile);\n+\ttmp_int = atoi (tmp_char);\n+\tXINT (return_rtx, i) = tmp_int;\n+\tbreak;\n+\n+      default:\n+\tfprintf (stderr,\n+\t\t \"switch format wrong in rtl.read_rtx(). format was: %c.\\n\",\n+\t\t format_ptr[-1]);\n+\tfprintf (stderr, \"\\tfile position: %ld\\n\", ftell (infile));\n+\tabort ();\n+      }\n+\n+  c = read_skip_spaces (infile);\n+  if (c != ')')\n+    dump_and_abort (')', c, infile);\n+\n+  return return_rtx;\n+}\n+\f\n+/* This is called once per compilation, before any rtx's are constructed.\n+   It initializes the vector `rtx_length' and the extra CC modes, if any.  */\n+\n+void\n+init_rtl ()\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    rtx_length[i] = strlen (rtx_format[i]);\n+\n+  /* Make CONST_DOUBLE bigger, if real values are bigger than\n+     it normally expects to have room for.\n+     Note that REAL_VALUE_TYPE is not defined by default,\n+     since tree.h is not included.  But the default dfn as `double'\n+     would do no harm.  */\n+#ifdef REAL_VALUE_TYPE\n+  i = sizeof (REAL_VALUE_TYPE) / sizeof (rtunion) + 2;\n+  if (rtx_length[(int) CONST_DOUBLE] < i)\n+    {\n+      char *s = (char *) xmalloc (i + 1);\n+      rtx_length[(int) CONST_DOUBLE] = i;\n+      rtx_format[(int) CONST_DOUBLE] = s;\n+      *s++ = 'e';\n+      *s++ = '0';\n+      /* Set the GET_RTX_FORMAT of CONST_DOUBLE to a string\n+\t of as many `i's as we now have elements.  */\n+      for (i = 0; i < rtx_length[(int) CONST_DOUBLE]; i++)\n+\t*s++ = 'i';\n+      *s++ = 0;\n+    }\n+#endif\n+\n+#ifdef EXTRA_CC_MODES\n+  for (i = (int) CCmode + 1; i < (int) MAX_MACHINE_MODE; i++)\n+    {\n+      mode_class[i] = MODE_CC;\n+      mode_size[i] = mode_size[(int) CCmode];\n+      mode_unit_size[i] = mode_unit_size[(int) CCmode];\n+      mode_wider_mode[i - 1] = (enum machine_mode) i;\n+      mode_wider_mode[i] = VOIDmode;\n+    }\n+#endif\n+}"}, {"sha": "fb5a14afe685ca54ecc6f76110ba47ded26e1b76", "filename": "gcc/rtl.h", "status": "added", "additions": 748, "deletions": 0, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f29feb107bb13375b45257759c77fc21759a009/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f29feb107bb13375b45257759c77fc21759a009/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6f29feb107bb13375b45257759c77fc21759a009", "patch": "@@ -0,0 +1,748 @@\n+/* Register Transfer Language (RTL) definitions for GNU C-Compiler\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"machmode.h\"\n+\n+#undef FFS  /* Some systems predefine this symbol; don't let it interfere.  */\n+\n+/* Register Transfer Language EXPRESSIONS CODES */\n+\n+#define RTX_CODE\tenum rtx_code\n+enum rtx_code  {\n+\n+#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   ENUM ,\n+#include \"rtl.def\"\t\t/* rtl expressions are documented here */\n+#undef DEF_RTL_EXPR\n+\n+  LAST_AND_UNUSED_RTX_CODE};\t/* A convienent way to get a value for\n+\t\t\t\t   NUM_RTX_CODE.\n+\t\t\t\t   Assumes default enum value assignement.  */\n+\n+#define NUM_RTX_CODE ((int)LAST_AND_UNUSED_RTX_CODE)\n+\t\t\t\t/* The cast here, saves many elsewhere.  */\n+\n+extern int rtx_length[];\n+#define GET_RTX_LENGTH(CODE)\t\t(rtx_length[(int)(CODE)])\n+\n+extern char *rtx_name[];\n+#define GET_RTX_NAME(CODE)\t\t(rtx_name[(int)(CODE)])\n+\n+extern char *rtx_format[];\n+#define GET_RTX_FORMAT(CODE)\t\t(rtx_format[(int)(CODE)])\n+\n+extern char rtx_class[];\n+#define GET_RTX_CLASS(CODE)\t\t(rtx_class[(int)(CODE)])\n+\f\n+/* Common union for an element of an rtx.  */\n+\n+typedef union rtunion_def\n+{\n+  int rtint;\n+  char *rtstr;\n+  struct rtx_def *rtx;\n+  struct rtvec_def *rtvec;\n+  enum machine_mode rttype;\n+} rtunion;\n+\n+/* RTL expression (\"rtx\").  */\n+\n+typedef struct rtx_def\n+{\n+#ifdef ONLY_INT_FIELDS\n+  unsigned short code;\n+#else\n+  /* The kind of expression this is.  */\n+  enum rtx_code code : 16;\n+#endif\n+  /* The kind of value the expression has.  */\n+#ifdef ONLY_INT_FIELDS\n+  int mode : 8;\n+#else\n+  enum machine_mode mode : 8;\n+#endif\n+  /* 1 in an INSN if it can alter flow of control\n+     within this function.  Not yet used!  */\n+  unsigned int jump : 1;\n+  /* 1 in an INSN if it can call another function.  Not yet used!  */\n+  unsigned int call : 1;\n+  /* 1 in a MEM or REG if value of this expression will never change\n+     during the current function, even though it is not\n+     manifestly constant.\n+     1 in a SYMBOL_REF if it addresses something in the per-function\n+     constants pool.\n+     1 in a CALL_INSN if it is a const call.\n+     1 in a JUMP_INSN if it is a branch that should be annulled.  Valid from\n+     reorg until end of compilation; cleared before used.  */\n+  unsigned int unchanging : 1;\n+  /* 1 in a MEM expression if contents of memory are volatile.\n+     1 in an INSN, CALL_INSN, JUMP_INSN, CODE_LABEL or BARRIER\n+     if it is deleted.\n+     1 in a REG expression if corresponds to a variable declared by the user.\n+     0 for an internally generated temporary.\n+     In a SYMBOL_REF, this flag is used for machine-specific purposes.  */\n+  unsigned int volatil : 1;\n+  /* 1 in a MEM referring to a field of a structure (not a union!).\n+     0 if the MEM was a variable or the result of a * operator in C;\n+     1 if it was the result of a . or -> operator (on a struct) in C.\n+     1 in a REG if the register is used only in exit code a loop.\n+     1 in a CODE_LABEL if the label is used for nonlocal gotos\n+     and must not be deleted even if its count is zero.\n+     1 in a LABEL_REF if this is a reference to a label outside the\n+     current loop.\n+     1 in an INSN, JUMP_INSN, or CALL_INSN if this insn must be scheduled\n+     together with the preceeding insn.  Valid only within sched.\n+     1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n+     from the target of a branch.  Valid from reorg until end of compilation;\n+     cleared before used.  */\n+  unsigned int in_struct : 1;\n+  /* 1 if this rtx is used.  This is used for copying shared structure.\n+     See `unshare_all_rtl'.\n+     In a REG, this is not needed for that purpose, and used instead \n+     in `leaf_renumber_regs_insn'.\n+     In a SYMBOL_REF, means that emit_library_call\n+     has used it as the function.  */\n+  unsigned int used : 1;\n+  /* Nonzero if this rtx came from procedure integration.\n+     In a REG, nonzero means this reg refers to the return value\n+     of the current function.  */\n+  unsigned integrated : 1;\n+  /* The first element of the operands of this rtx.\n+     The number of operands and their types are controlled\n+     by the `code' field, according to rtl.def.  */\n+  rtunion fld[1];\n+} *rtx;\n+\n+#define NULL_RTX (rtx) 0\n+\n+/* Define macros to access the `code' field of the rtx.  */\n+\n+#ifdef SHORT_ENUM_BUG\n+#define GET_CODE(RTX)\t\t((enum rtx_code) ((RTX)->code))\n+#define PUT_CODE(RTX, CODE)\t((RTX)->code = ((short) (CODE)))\n+#else\n+#define GET_CODE(RTX)\t\t((RTX)->code)\n+#define PUT_CODE(RTX, CODE)\t((RTX)->code = (CODE))\n+#endif\n+\n+#define GET_MODE(RTX)\t\t((RTX)->mode)\n+#define PUT_MODE(RTX, MODE)\t((RTX)->mode = (MODE))\n+\n+#define RTX_INTEGRATED_P(RTX) ((RTX)->integrated)\n+#define RTX_UNCHANGING_P(RTX) ((RTX)->unchanging)\n+\n+/* RTL vector.  These appear inside RTX's when there is a need\n+   for a variable number of things.  The principle use is inside\n+   PARALLEL expressions.  */\n+\n+typedef struct rtvec_def{\n+  unsigned num_elem;\t\t/* number of elements */\n+  rtunion elem[1];\n+} *rtvec;\n+\n+#define NULL_RTVEC (rtvec) 0\n+\n+#define GET_NUM_ELEM(RTVEC)\t\t((RTVEC)->num_elem)\n+#define PUT_NUM_ELEM(RTVEC, NUM)\t((RTVEC)->num_elem = (unsigned) NUM)\n+\n+#define RTVEC_ELT(RTVEC, I)  ((RTVEC)->elem[(I)].rtx)\n+\n+/* 1 if X is a REG.  */\n+\n+#define REG_P(X) (GET_CODE (X) == REG)\n+\n+/* 1 if X is a constant value that is an integer.  */\n+\n+#define CONSTANT_P(X)   \\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n+   || GET_CODE (X) == CONST || GET_CODE (X) == HIGH)\n+\n+/* General accessor macros for accessing the fields of an rtx.  */\n+\n+#define XEXP(RTX, N)\t((RTX)->fld[N].rtx)\n+#define XINT(RTX, N)\t((RTX)->fld[N].rtint)\n+#define XSTR(RTX, N)\t((RTX)->fld[N].rtstr)\n+#define XVEC(RTX, N)\t((RTX)->fld[N].rtvec)\n+#define XVECLEN(RTX, N)\t((RTX)->fld[N].rtvec->num_elem)\n+#define XVECEXP(RTX,N,M)((RTX)->fld[N].rtvec->elem[M].rtx)\n+\f\n+/* ACCESS MACROS for particular fields of insns.  */\n+\n+/* Holds a unique number for each insn.\n+   These are not necessarily sequentially increasing.  */\n+#define INSN_UID(INSN)\t((INSN)->fld[0].rtint)\n+\n+/* Chain insns together in sequence.  */\n+#define PREV_INSN(INSN)\t((INSN)->fld[1].rtx)\n+#define NEXT_INSN(INSN)\t((INSN)->fld[2].rtx)\n+\n+/* The body of an insn.  */\n+#define PATTERN(INSN)\t((INSN)->fld[3].rtx)\n+\n+/* Code number of instruction, from when it was recognized.\n+   -1 means this instruction has not been recognized yet.  */\n+#define INSN_CODE(INSN) ((INSN)->fld[4].rtint)\n+\n+/* Set up in flow.c; empty before then.\n+   Holds a chain of INSN_LIST rtx's whose first operands point at\n+   previous insns with direct data-flow connections to this one.\n+   That means that those insns set variables whose next use is in this insn.\n+   They are always in the same basic block as this insn.  */\n+#define LOG_LINKS(INSN)\t\t((INSN)->fld[5].rtx)\n+\n+/* 1 if insn has been deleted.  */\n+#define INSN_DELETED_P(INSN) ((INSN)->volatil)\n+\n+/* 1 if insn is a call to a const function.  */\n+#define CONST_CALL_P(INSN) ((INSN)->unchanging)\n+\n+/* 1 if insn is a branch that should not unconditionally execute its\n+   delay slots, i.e., it is an annulled branch.   */\n+#define INSN_ANNULLED_BRANCH_P(INSN) ((INSN)->unchanging)\n+\n+/* 1 if insn is in a delay slot and is from the target of the branch.  If\n+   the branch insn has INSN_ANULLED_BRANCH_P set, this insn should only be\n+   executed if the branch is taken.  For annulled branches with this bit\n+   clear, the insn should be executed only if the branch is not taken.  */\n+#define INSN_FROM_TARGET_P(INSN) ((INSN)->in_struct)\n+\n+/* Holds a list of notes on what this insn does to various REGs.\n+   It is a chain of EXPR_LIST rtx's, where the second operand\n+   is the chain pointer and the first operand is the REG being described.\n+   The mode field of the EXPR_LIST contains not a real machine mode\n+   but a value that says what this note says about the REG:\n+     REG_DEAD means that the value in REG dies in this insn (i.e., it is\n+   not needed past this insn).  If REG is set in this insn, the REG_DEAD\n+   note may, but need not, be omitted.\n+     REG_INC means that the REG is autoincremented or autodecremented.\n+     REG_EQUIV describes the insn as a whole; it says that the\n+   insn sets a register to a constant value or to be equivalent to\n+   a memory address.  If the\n+   register is spilled to the stack then the constant value\n+   should be substituted for it.  The contents of the REG_EQUIV\n+   is the constant value or memory address, which may be different\n+   from the source of the SET although it has the same value. \n+     REG_EQUAL is like REG_EQUIV except that the destination\n+   is only momentarily equal to the specified rtx.  Therefore, it\n+   cannot be used for substitution; but it can be used for cse.\n+     REG_RETVAL means that this insn copies the return-value of\n+   a library call out of the hard reg for return values.  This note\n+   is actually an INSN_LIST and it points to the first insn involved\n+   in setting up arguments for the call.  flow.c uses this to delete\n+   the entire library call when its result is dead.\n+     REG_LIBCALL is the inverse of REG_RETVAL: it goes on the first insn\n+   of the library call and points at the one that has the REG_RETVAL.\n+     REG_WAS_0 says that the register set in this insn held 0 before the insn.\n+   The contents of the note is the insn that stored the 0.\n+   If that insn is deleted or patched to a NOTE, the REG_WAS_0 is inoperative.\n+   The REG_WAS_0 note is actually an INSN_LIST, not an EXPR_LIST.\n+     REG_NONNEG means that the register is always nonnegative during\n+   the containing loop.  This is used in branches so that decrement and\n+   branch instructions terminating on zero can be matched.  There must be\n+   an insn pattern in the md file named `decrement_and_branch_until_zero'\n+   or else this will never be added to any instructions.\n+     REG_NO_CONFLICT means there is no conflict *after this insn*\n+   between the register in the note and the destination of this insn.\n+     REG_UNUSED identifies a register set in this insn and never used.\n+     REG_CC_SETTER and REG_CC_USER link a pair of insns that set and use\n+   CC0, respectively.  Normally, these are required to be consecutive insns,\n+   but we permit putting a cc0-setting insn in the delay slot of a branch\n+   as long as only one copy of the insn exists.  In that case, these notes\n+   point from one to the other to allow code generation to determine what\n+   any require information and to properly update CC_STATUS.\n+     REG_LABEL points to a CODE_LABEL.  Used by non-JUMP_INSNs to\n+   say that the CODE_LABEL contained in the REG_LABEL note is used\n+   by the insn.\n+    REG_DEP_ANTI is used in LOG_LINKS which represent anti (write after read)\n+   dependencies.  REG_DEP_OUTPUT is used in LOG_LINKS which represent output\n+   (write after write) dependencies.  Data dependencies, which are the only\n+   type of LOG_LINK created by flow, are represented by a 0 reg note kind.  */\n+\n+#define REG_NOTES(INSN)\t((INSN)->fld[6].rtx)\n+\n+/* Don't forget to change reg_note_name in rtl.c.  */\n+enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n+\t\tREG_EQUAL = 5, REG_RETVAL = 6, REG_LIBCALL = 7,\n+\t\tREG_NONNEG = 8, REG_NO_CONFLICT = 9, REG_UNUSED = 10,\n+\t\tREG_CC_SETTER = 11, REG_CC_USER = 12, REG_LABEL = 13,\n+\t\tREG_DEP_ANTI = 14, REG_DEP_OUTPUT = 15 };\n+\n+/* Define macros to extract and insert the reg-note kind in an EXPR_LIST.  */\n+#define REG_NOTE_KIND(LINK) ((enum reg_note) GET_MODE (LINK))\n+#define PUT_REG_NOTE_KIND(LINK,KIND) PUT_MODE(LINK, (enum machine_mode) (KIND))\n+\n+/* Names for REG_NOTE's in EXPR_LIST insn's.  */\n+\n+extern char *reg_note_name[];\n+#define GET_REG_NOTE_NAME(MODE) (reg_note_name[(int)(MODE)])\n+\n+/* The label-number of a code-label.  The assembler label\n+   is made from `L' and the label-number printed in decimal.\n+   Label numbers are unique in a compilation.  */\n+#define CODE_LABEL_NUMBER(INSN)\t((INSN)->fld[3].rtint)\n+\n+#define LINE_NUMBER NOTE\n+\n+/* In a NOTE that is a line number, this is a string for the file name\n+   that the line is in.  */\n+\n+#define NOTE_SOURCE_FILE(INSN)  ((INSN)->fld[3].rtstr)\n+\n+/* In a NOTE that is a line number, this is the line number.\n+   Other kinds of NOTEs are identified by negative numbers here.  */\n+#define NOTE_LINE_NUMBER(INSN) ((INSN)->fld[4].rtint)\n+\n+/* Codes that appear in the NOTE_LINE_NUMBER field\n+   for kinds of notes that are not line numbers.  */\n+\n+/* This note indicates the end of the real body of the function,\n+   after moving the parms into their homes, etc.  */\n+#define NOTE_INSN_FUNCTION_BEG 0\n+\n+/* This note is used to get rid of an insn\n+   when it isn't safe to patch the insn out of the chain.  */\n+#define NOTE_INSN_DELETED -1\n+#define NOTE_INSN_BLOCK_BEG -2\n+#define NOTE_INSN_BLOCK_END -3\n+#define NOTE_INSN_LOOP_BEG -4\n+#define NOTE_INSN_LOOP_END -5\n+/* This kind of note is generated at the end of the function body,\n+   just before the return insn or return label.\n+   In an optimizing compilation it is deleted by the first jump optimization,\n+   after enabling that optimizer to determine whether control can fall\n+   off the end of the function body without a return statement.  */\n+#define NOTE_INSN_FUNCTION_END -6\n+/* This kind of note is generated just after each call to `setjmp', et al.  */\n+#define NOTE_INSN_SETJMP -7\n+/* Generated at the place in a loop that `continue' jumps to.  */\n+#define NOTE_INSN_LOOP_CONT -8\n+/* Generated at the start of a duplicated exit test.  */\n+#define NOTE_INSN_LOOP_VTOP -9\n+/* Don't forget to change note_insn_name in rtl.c.  */\n+\n+#define NOTE_DECL_NAME(INSN) ((INSN)->fld[3].rtstr)\n+#define NOTE_DECL_CODE(INSN) ((INSN)->fld[4].rtint)\n+#define NOTE_DECL_RTL(INSN) ((INSN)->fld[5].rtx)\n+#define NOTE_DECL_IDENTIFIER(INSN) ((INSN)->fld[6].rtint)\n+#define NOTE_DECL_TYPE(INSN) ((INSN)->fld[7].rtint)\n+\n+/* Names for NOTE insn's other than line numbers.  */\n+\n+extern char *note_insn_name[];\n+#define GET_NOTE_INSN_NAME(NOTE_CODE) (note_insn_name[-(NOTE_CODE)])\n+\n+/* The name of a label, in case it corresponds to an explicit label\n+   in the input source code.  */\n+#define LABEL_NAME(LABEL) ((LABEL)->fld[4].rtstr)\n+\n+/* In jump.c, each label contains a count of the number\n+   of LABEL_REFs that point at it, so unused labels can be deleted.  */\n+#define LABEL_NUSES(LABEL) ((LABEL)->fld[5].rtint)\n+\n+/* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n+   so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n+   be decremented and possibly the label can be deleted.  */\n+#define JUMP_LABEL(INSN)   ((INSN)->fld[7].rtx)\n+\n+/* Once basic blocks are found in flow.c,\n+   each CODE_LABEL starts a chain that goes through\n+   all the LABEL_REFs that jump to that label.\n+   The chain eventually winds up at the CODE_LABEL; it is circular.  */\n+#define LABEL_REFS(LABEL) ((LABEL)->fld[5].rtx)\n+\f\n+/* This is the field in the LABEL_REF through which the circular chain\n+   of references to a particular label is linked.\n+   This chain is set up in flow.c.  */\n+\n+#define LABEL_NEXTREF(REF) ((REF)->fld[1].rtx)\n+\n+/* Once basic blocks are found in flow.c,\n+   Each LABEL_REF points to its containing instruction with this field.  */\n+\n+#define CONTAINING_INSN(RTX) ((RTX)->fld[2].rtx)\n+\n+/* For a REG rtx, REGNO extracts the register number.  */\n+\n+#define REGNO(RTX) ((RTX)->fld[0].rtint)\n+\n+/* For a REG rtx, REG_FUNCTION_VALUE_P is nonzero if the reg\n+   is the current function's return value.  */\n+\n+#define REG_FUNCTION_VALUE_P(RTX) ((RTX)->integrated)\n+\n+/* 1 in a REG rtx if it corresponds to a variable declared by the user.  */\n+#define REG_USERVAR_P(RTX) ((RTX)->volatil)\n+\n+/* For a CONST_INT rtx, INTVAL extracts the integer.  */\n+\n+#define INTVAL(RTX) ((RTX)->fld[0].rtint)\n+\n+/* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n+   SUBREG_WORD extracts the word-number.  */\n+\n+#define SUBREG_REG(RTX) ((RTX)->fld[0].rtx)\n+#define SUBREG_WORD(RTX) ((RTX)->fld[1].rtint)\n+\n+/* Access various components of an ASM_OPERANDS rtx.  */\n+\n+#define ASM_OPERANDS_TEMPLATE(RTX) XSTR ((RTX), 0)\n+#define ASM_OPERANDS_OUTPUT_CONSTRAINT(RTX) XSTR ((RTX), 1)\n+#define ASM_OPERANDS_OUTPUT_IDX(RTX) XINT ((RTX), 2)\n+#define ASM_OPERANDS_INPUT_VEC(RTX) XVEC ((RTX), 3)\n+#define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XVEC ((RTX), 4)\n+#define ASM_OPERANDS_INPUT(RTX, N) XVECEXP ((RTX), 3, (N))\n+#define ASM_OPERANDS_INPUT_LENGTH(RTX) XVECLEN ((RTX), 3)\n+#define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) XSTR (XVECEXP ((RTX), 4, (N)), 0)\n+#define ASM_OPERANDS_INPUT_MODE(RTX, N) GET_MODE (XVECEXP ((RTX), 4, (N)))\n+#define ASM_OPERANDS_SOURCE_FILE(RTX) XSTR ((RTX), 5)\n+#define ASM_OPERANDS_SOURCE_LINE(RTX) XINT ((RTX), 6)\n+\n+/* For a MEM rtx, 1 if it's a volatile reference.\n+   Also in an ASM_OPERANDS rtx.  */\n+#define MEM_VOLATILE_P(RTX) ((RTX)->volatil)\n+\n+/* For a MEM rtx, 1 if it refers to a structure or union component.  */\n+#define MEM_IN_STRUCT_P(RTX) ((RTX)->in_struct)\n+\n+/* For a LABEL_REF, 1 means that this reference is to a label outside the\n+   loop containing the reference.  */\n+#define LABEL_OUTSIDE_LOOP_P(RTX) ((RTX)->in_struct)\n+\n+/* For a CODE_LABEL, 1 means always consider this label to be needed.  */\n+#define LABEL_PRESERVE_P(RTX) ((RTX)->in_struct)\n+\n+/* For a REG, 1 means the register is used only in an exit test of a loop.  */\n+#define REG_LOOP_TEST_P(RTX) ((RTX)->in_struct)\n+\n+/* During sched, for an insn, 1 means that the insn must be scheduled together\n+   with the preceeding insn.  */\n+#define SCHED_GROUP_P(INSN) ((INSN)->in_struct)\n+\n+/* For a SET rtx, SET_DEST is the place that is set\n+   and SET_SRC is the value it is set to.  */\n+#define SET_DEST(RTX) ((RTX)->fld[0].rtx)\n+#define SET_SRC(RTX) ((RTX)->fld[1].rtx)\n+\n+/* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n+#define TRAP_CONDITION(RTX) ((RTX)->fld[0].rtx)\n+\n+/* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n+#define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n+\n+/* Flag in a SYMBOL_REF for machine-specific purposes.  */\n+#define SYMBOL_REF_FLAG(RTX) ((RTX)->volatil)\n+\n+/* 1 means a SYMBOL_REF has been the library function in emit_library_call.  */\n+#define SYMBOL_REF_USED(RTX) ((RTX)->used)\n+\n+/* For an INLINE_HEADER rtx, FIRST_FUNCTION_INSN is the first insn\n+   of the function that is not involved in copying parameters to\n+   pseudo-registers.  FIRST_PARM_INSN is the very first insn of\n+   the function, including the parameter copying.\n+   We keep this around in case we must splice\n+   this function into the assembly code at the end of the file.\n+   FIRST_LABELNO is the first label number used by the function (inclusive).\n+   LAST_LABELNO is the last label used by the function (exclusive).\n+   MAX_REGNUM is the largest pseudo-register used by that function.\n+   FUNCTION_ARGS_SIZE is the size of the argument block in the stack.\n+   POPS_ARGS is the number of bytes of input arguments popped by the function\n+   STACK_SLOT_LIST is the list of stack slots.\n+   FUNCTION_FLAGS are where single-bit flags are saved.\n+   OUTGOING_ARGS_SIZE is the size of the largest outgoing stack parameter list.\n+   ORIGINAL_ARG_VECTOR is a vector of the original DECL_RTX values\n+    for the function arguments.\n+   ORIGINAL_DECL_INITIAL is a pointer to the original DECL_INITIAL for the\n+    function.\n+\n+   We want this to lay down like an INSN.  The PREV_INSN field\n+   is always NULL.  The NEXT_INSN field always points to the\n+   first function insn of the function being squirreled away.  */\n+\n+#define FIRST_FUNCTION_INSN(RTX) ((RTX)->fld[2].rtx)\n+#define FIRST_PARM_INSN(RTX) ((RTX)->fld[3].rtx)\n+#define FIRST_LABELNO(RTX) ((RTX)->fld[4].rtint)\n+#define LAST_LABELNO(RTX) ((RTX)->fld[5].rtint)\n+#define MAX_PARMREG(RTX) ((RTX)->fld[6].rtint)\n+#define MAX_REGNUM(RTX) ((RTX)->fld[7].rtint)\n+#define FUNCTION_ARGS_SIZE(RTX) ((RTX)->fld[8].rtint)\n+#define POPS_ARGS(RTX) ((RTX)->fld[9].rtint)\n+#define STACK_SLOT_LIST(RTX) ((RTX)->fld[10].rtx)\n+#define FUNCTION_FLAGS(RTX) ((RTX)->fld[11].rtint)\n+#define OUTGOING_ARGS_SIZE(RTX) ((RTX)->fld[12].rtint)\n+#define ORIGINAL_ARG_VECTOR(RTX) ((RTX)->fld[13].rtvec)\n+#define ORIGINAL_DECL_INITIAL(RTX) ((RTX)->fld[14].rtx)\n+\n+/* In FUNCTION_FLAGS we save some variables computed when emitting the code\n+   for the function and which must be `or'ed into the current flag values when\n+   insns from that function are being inlined.  */\n+\n+/* These ought to be an enum, but non-ANSI compilers don't like that.  */\n+#define FUNCTION_FLAGS_CALLS_ALLOCA 01\n+#define FUNCTION_FLAGS_CALLS_SETJMP 02\n+#define FUNCTION_FLAGS_RETURNS_STRUCT 04\n+#define FUNCTION_FLAGS_RETURNS_PCC_STRUCT 010\n+#define FUNCTION_FLAGS_NEEDS_CONTEXT 020\n+#define FUNCTION_FLAGS_HAS_NONLOCAL_LABEL 040\n+#define FUNCTION_FLAGS_RETURNS_POINTER 0100\n+#define FUNCTION_FLAGS_USES_CONST_POOL 0200\n+#define FUNCTION_FLAGS_CALLS_LONGJMP 0400\n+#define FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE 01000\n+\n+/* Define a macro to look for REG_INC notes,\n+   but save time on machines where they never exist.  */\n+\n+#if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) \\\n+     || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n+#define FIND_REG_INC_NOTE(insn, reg) (find_reg_note ((insn), REG_INC, (reg)))\n+#else\n+#define FIND_REG_INC_NOTE(insn, reg) 0\n+#endif\n+\n+/* Indicate whether the machine has any sort of auto increment addressing.\n+   If not, we can avoid checking for REG_INC notes.  */\n+\n+#if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) \\\n+     || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n+#define AUTO_INC_DEC\n+#endif\n+\f\n+/* Generally useful functions.  */\n+\n+extern rtx rtx_alloc ();\n+extern rtvec rtvec_alloc ();\n+extern rtx find_reg_note ();\n+extern rtx find_regno_note ();\n+extern int get_integer_term ();\n+extern rtx get_related_value ();\n+extern rtx single_set ();\n+extern rtx find_last_value ();\n+extern rtx gen_rtx ();\n+extern rtx copy_rtx ();\n+extern rtx copy_rtx_if_shared ();\n+extern rtx copy_most_rtx ();\n+extern rtx replace_rtx ();\n+extern rtvec gen_rtvec ();\n+extern rtvec gen_rtvec_v ();\n+extern rtx gen_reg_rtx ();\n+extern rtx gen_label_rtx ();\n+extern rtx gen_inline_header_rtx ();\n+extern rtx gen_lowpart_common ();\n+extern rtx gen_lowpart ();\n+extern rtx gen_lowpart_if_possible ();\n+extern rtx operand_subword ();\n+extern rtx operand_subword_force ();\n+extern int subreg_lowpart_p ();\n+extern rtx make_safe_from ();\n+extern rtx memory_address ();\n+extern rtx get_insns ();\n+extern rtx get_last_insn ();\n+extern rtx get_last_insn_anywhere ();\n+extern void start_sequence ();\n+extern void push_to_sequence ();\n+extern void end_sequence ();\n+extern rtx gen_sequence ();\n+extern rtx expand_expr ();\n+extern rtx output_constant_def ();\n+extern rtx immed_real_const ();\n+extern rtx immed_real_const_1 ();\n+extern rtx immed_double_const ();\n+extern rtx force_const_mem ();\n+extern rtx get_pool_constant ();\n+extern enum machine_mode get_pool_mode ();\n+extern int get_pool_offset ();\n+extern rtx get_parm_real_loc ();\n+extern rtx assign_stack_local ();\n+extern rtx assign_stack_temp ();\n+extern rtx protect_from_queue ();\n+extern void emit_queue ();\n+extern rtx emit_move_insn ();\n+extern rtx emit_insn_before ();\n+extern rtx emit_jump_insn_before ();\n+extern rtx emit_call_insn_before ();\n+extern rtx emit_barrier_before ();\n+extern rtx emit_note_before ();\n+extern rtx emit_insn_after ();\n+extern rtx emit_jump_insn_after ();\n+extern rtx emit_barrier_after ();\n+extern rtx emit_label_after ();\n+extern rtx emit_note_after ();\n+extern rtx emit_line_note_after ();\n+extern rtx emit_insn ();\n+extern rtx emit_insns ();\n+extern rtx emit_insns_before ();\n+extern rtx emit_jump_insn ();\n+extern rtx emit_call_insn ();\n+extern rtx emit_label ();\n+extern rtx emit_barrier ();\n+extern rtx emit_line_note ();\n+extern rtx emit_note ();\n+extern rtx emit_line_note_force ();\n+extern rtx make_insn_raw ();\n+extern rtx previous_insn ();\n+extern rtx next_insn ();\n+extern rtx prev_nonnote_insn ();\n+extern rtx next_nonnote_insn ();\n+extern rtx prev_real_insn ();\n+extern rtx next_real_insn ();\n+extern rtx prev_active_insn ();\n+extern rtx next_active_insn ();\n+extern rtx prev_label ();\n+extern rtx next_label ();\n+extern rtx next_cc0_user ();\n+extern rtx prev_cc0_setter ();\n+extern rtx reg_set_last ();\n+extern rtx next_nondeleted_insn ();\n+extern enum rtx_code reverse_condition ();\n+extern enum rtx_code swap_condition ();\n+extern enum rtx_code unsigned_condition ();\n+extern enum rtx_code signed_condition ();\n+extern rtx plus_constant (), plus_constant_for_output ();\n+extern rtx find_equiv_reg ();\n+extern rtx delete_insn ();\n+extern void delete_jump ();\n+extern rtx get_label_before ();\n+extern rtx get_label_after ();\n+extern rtx follow_jumps ();\n+extern rtx adj_offsettable_operand ();\n+extern rtx try_split ();\n+extern rtx split_insns ();\n+extern rtx simplify_unary_operation (), simplify_binary_operation ();\n+extern rtx simplify_ternary_operation (), simplify_relational_operation ();\n+\n+/* Maximum number of parallel sets and clobbers in any insn in this fn.\n+   Always at least 3, since the combiner could put that many togetherm\n+   and we want this to remain correct for all the remaining passes.  */\n+\n+extern int max_parallel;\n+\n+extern int asm_noperands ();\n+extern char *decode_asm_operands ();\n+\n+#ifdef BITS_PER_WORD\n+/* Conditional is to detect when config.h has been included.  */\n+extern enum reg_class reg_preferred_class ();\n+#endif\n+\n+extern rtx get_first_nonparm_insn ();\n+\n+/* Standard pieces of rtx, to be substituted directly into things.  */\n+extern rtx pc_rtx;\n+extern rtx cc0_rtx;\n+extern rtx const0_rtx;\n+extern rtx const1_rtx;\n+extern rtx constm1_rtx;\n+extern rtx const_true_rtx;\n+extern rtx fconst0_rtx;\n+extern rtx fconst1_rtx;\n+extern rtx dconst0_rtx;\n+extern rtx dconst1_rtx;\n+\n+/* Returns a constant 0 rtx in mode MODE.  */\n+\n+#define CONST0_RTX(MODE) \\\n+ ((MODE == SFmode) ? fconst0_rtx\t\t\t\\\n+  : ((MODE == DFmode) ? dconst0_rtx\t\t\t\\\n+     : ((GET_MODE_CLASS (MODE) == MODE_INT) ? const0_rtx\t\\\n+        : (abort (), NULL_RTX))))\n+\n+/* All references to certain hard regs, except those created\n+   by allocating pseudo regs into them (when that's possible),\n+   go through these unique rtx objects.  */\n+extern rtx stack_pointer_rtx;\n+extern rtx frame_pointer_rtx;\n+extern rtx arg_pointer_rtx;\n+extern rtx pic_offset_table_rtx;\n+extern rtx struct_value_rtx;\n+extern rtx struct_value_incoming_rtx;\n+extern rtx static_chain_rtx;\n+extern rtx static_chain_incoming_rtx;\n+\n+/* Virtual registers are used during RTL generation to refer to locations into\n+   the stack frame when the actual location isn't known until RTL generation\n+   is complete.  The routine instantiate_virtual_regs replaces these with\n+   the proper value, which is normally {frame,arg,stack}_pointer_rtx plus\n+   a constant.  */\n+\n+#define FIRST_VIRTUAL_REGISTER\t(FIRST_PSEUDO_REGISTER)\n+\n+/* This points to the first word of the incoming arguments passed on the stack,\n+   either by the caller or by the callee when pretending it was passed by the\n+   caller.  */\n+\n+extern rtx virtual_incoming_args_rtx;\n+\n+#define VIRTUAL_INCOMING_ARGS_REGNUM\t(FIRST_VIRTUAL_REGISTER)\n+\n+/* If FRAME_GROWS_DOWNWARDS, this points to immediately above the first\n+   variable on the stack.  Otherwise, it points to the first variable on\n+   the stack.  */\n+\n+extern rtx virtual_stack_vars_rtx;\n+\n+#define VIRTUAL_STACK_VARS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 1)\n+\n+/* This points to the location of dynamically-allocated memory on the stack\n+   immediately after the stack pointer has been adjusted by the amount\n+   desired.  */\n+\n+extern rtx virtual_stack_dynamic_rtx;\n+\n+#define VIRTUAL_STACK_DYNAMIC_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 2)\n+\n+/* This points to the location in the stack at which outgoing arguments should\n+   be written when the stack is pre-pushed (arguments pushed using push\n+   insns always use sp).  */\n+\n+extern rtx virtual_outgoing_args_rtx;\n+\n+#define VIRTUAL_OUTGOING_ARGS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 3)\n+\n+#define LAST_VIRTUAL_REGISTER\t((FIRST_VIRTUAL_REGISTER) + 3)\n+\n+extern rtx find_next_ref ();\n+extern rtx *find_single_use ();\n+\n+/* Define a default value for STORE_FLAG_VALUE.  */\n+\n+#ifndef STORE_FLAG_VALUE\n+#define STORE_FLAG_VALUE 1\n+#endif\n+\n+/* Nonzero after end of reload pass.\n+   Set to 1 or 0 by toplev.c.  */\n+\n+extern int reload_completed;\n+\n+/* Set to 1 while reload_as_needed is operating.\n+   Required by some machines to handle any generated moves differently.  */\n+\n+extern int reload_in_progress;\n+\n+/* If this is nonzero, we do not bother generating VOLATILE\n+   around volatile memory references, and we are willing to\n+   output indirect addresses.  If cse is to follow, we reject\n+   indirect addresses so a useful potential cse is generated;\n+   if it is used only once, instruction combination will produce\n+   the same indirect address eventually.  */\n+extern int cse_not_expected;\n+\n+/* Indexed by pseudo register number, gives the rtx for that pseudo.\n+   Allocated in parallel with regno_pointer_flag.  */\n+extern rtx *regno_reg_rtx;"}]}