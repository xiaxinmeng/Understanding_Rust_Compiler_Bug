{"sha": "faf2ecc57e3ef478efebee6f83c440df073152c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFmMmVjYzU3ZTNlZjQ3OGVmZWJlZTZmODNjNDQwZGYwNzMxNTJjMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-06-29T15:44:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-06-29T15:44:00Z"}, "message": "tree-ssa-structalias.h (compute_points_to_sets): Adjust prototype.\n\n2008-06-29  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.h (compute_points_to_sets): Adjust\n\tprototype.\n\t(struct alias_info): Move ...\n\t* tree-ssa-alias.c: ... here.\n\t(update_alias_info): Declare.\n\t(compute_may_aliases): Call it.\n\t(update_alias_info): New function.\n\t* tree-ssa-structalias.c (update_alias_info): Move ...\n\t* tree-ssa-alias.c (update_alias_info_1): ... here.\n\t* tree-ssa-structalias.c (process_constraint_1): Remove\n\tunused from_call argument.  Rename to ...\n\t(process_constraint): ... this.  Delete old wrapper.\n\t(make_constraint_to): Adjust callers.\n\t(handle_const_call): Likewise.\n\t(handle_pure_call): Likewise.\n\t(init_base_vars): Likewise.\n\t(handle_lhs_call): Likewise.  Remove unnecessary constraint.\n\t(find_func_aliases): We don't need structure copies for\n\tcomplex types.\n\t(make_constraint_from_anything): Remove.\n\t(create_variable_info_for): For globals make constraints\n\tfrom escaped, not from anything.\n\t(compute_points_to_sets): Do not call update_alias_info.\n\t(ipa_pta_execute): Use make_constraint_from.\n\nFrom-SVN: r137252", "tree": {"sha": "38b5df5e06de9bf257f1600a6446d2b744b0ab56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38b5df5e06de9bf257f1600a6446d2b744b0ab56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faf2ecc57e3ef478efebee6f83c440df073152c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faf2ecc57e3ef478efebee6f83c440df073152c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faf2ecc57e3ef478efebee6f83c440df073152c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faf2ecc57e3ef478efebee6f83c440df073152c2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b03717765d0d62af54bdb3112ac90ca6d7dd7c75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03717765d0d62af54bdb3112ac90ca6d7dd7c75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b03717765d0d62af54bdb3112ac90ca6d7dd7c75"}], "stats": {"total": 711, "additions": 364, "deletions": 347}, "files": [{"sha": "99e5011cdbd41dca40d0ecf01dc3a8a24c2af4f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=faf2ecc57e3ef478efebee6f83c440df073152c2", "patch": "@@ -1,3 +1,30 @@\n+2008-06-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.h (compute_points_to_sets): Adjust\n+\tprototype.\n+\t(struct alias_info): Move ...\n+\t* tree-ssa-alias.c: ... here.\n+\t(update_alias_info): Declare.\n+\t(compute_may_aliases): Call it.\n+\t(update_alias_info): New function.\n+\t* tree-ssa-structalias.c (update_alias_info): Move ...\n+\t* tree-ssa-alias.c (update_alias_info_1): ... here.\n+\t* tree-ssa-structalias.c (process_constraint_1): Remove\n+\tunused from_call argument.  Rename to ...\n+\t(process_constraint): ... this.  Delete old wrapper.\n+\t(make_constraint_to): Adjust callers.\n+\t(handle_const_call): Likewise.\n+\t(handle_pure_call): Likewise.\n+\t(init_base_vars): Likewise.\n+\t(handle_lhs_call): Likewise.  Remove unnecessary constraint.\n+\t(find_func_aliases): We don't need structure copies for\n+\tcomplex types.\n+\t(make_constraint_from_anything): Remove.\n+\t(create_variable_info_for): For globals make constraints\n+\tfrom escaped, not from anything.\n+\t(compute_points_to_sets): Do not call update_alias_info.\n+\t(ipa_pta_execute): Use make_constraint_from.\n+\n 2008-06-29  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (CXX_COMPAT_WARN, cxx_compat_warn): Delete."}, {"sha": "ee0f4a7316a5c7986ad73da6f6afe69cc9fc1dd1", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 305, "deletions": 1, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=faf2ecc57e3ef478efebee6f83c440df073152c2", "patch": "@@ -166,6 +166,40 @@ along with GCC; see the file COPYING3.  If not see\n    Lastly, we delete partitions with no symbols, and clean up after\n    ourselves.  */\n \n+\n+/* Alias information used by compute_may_aliases and its helpers.  */\n+struct alias_info\n+{\n+  /* SSA names visited while collecting points-to information.  If bit I\n+     is set, it means that SSA variable with version I has already been\n+     visited.  */\n+  sbitmap ssa_names_visited;\n+\n+  /* Array of SSA_NAME pointers processed by the points-to collector.  */\n+  VEC(tree,heap) *processed_ptrs;\n+\n+  /* ADDRESSABLE_VARS contains all the global variables and locals that\n+     have had their address taken.  */\n+  struct alias_map_d **addressable_vars;\n+  size_t num_addressable_vars;\n+\n+  /* POINTERS contains all the _DECL pointers with unique memory tags\n+     that have been referenced in the program.  */\n+  struct alias_map_d **pointers;\n+  size_t num_pointers;\n+\n+  /* Variables that have been written to directly (i.e., not through a\n+     pointer dereference).  */\n+  struct pointer_set_t *written_vars;\n+\n+  /* Pointers that have been used in an indirect store operation.  */\n+  struct pointer_set_t *dereferenced_ptrs_store;\n+\n+  /* Pointers that have been used in an indirect load operation.  */\n+  struct pointer_set_t *dereferenced_ptrs_load;\n+};\n+\n+\n /* Structure to map a variable to its alias set.  */\n struct alias_map_d\n {\n@@ -205,6 +239,7 @@ static struct alias_info *init_alias_info (void);\n static void delete_alias_info (struct alias_info *);\n static void compute_flow_sensitive_aliasing (struct alias_info *);\n static void setup_pointers_and_addressables (struct alias_info *);\n+static void update_alias_info (struct alias_info *);\n static void create_global_var (void);\n static void maybe_create_global_var (void);\n static void set_pt_anything (tree);\n@@ -1722,7 +1757,12 @@ compute_may_aliases (void)\n      address of V escapes the current function, making V call-clobbered\n      (i.e., whether &V is stored in a global variable or if its passed as a\n      function call argument).  */\n-  compute_points_to_sets (ai);\n+  compute_points_to_sets ();\n+\n+  /* Update various related attributes like escaped addresses,\n+     pointer dereferences for loads and stores.  This is used\n+     when creating name tags and alias sets.  */\n+  update_alias_info (ai);\n \n   /* Collect all pointers and addressable variables, compute alias sets,\n      create memory tags for pointers and promote variables whose address is\n@@ -2438,6 +2478,270 @@ create_alias_map_for (tree var, struct alias_info *ai)\n }\n \n \n+/* Update related alias information kept in AI.  This is used when\n+   building name tags, alias sets and deciding grouping heuristics.\n+   STMT is the statement to process.  This function also updates\n+   ADDRESSABLE_VARS.  */\n+\n+static void\n+update_alias_info_1 (tree stmt, struct alias_info *ai)\n+{\n+  bitmap addr_taken;\n+  use_operand_p use_p;\n+  ssa_op_iter iter;\n+  bool stmt_dereferences_ptr_p;\n+  enum escape_type stmt_escape_type = is_escape_site (stmt);\n+  struct mem_ref_stats_d *mem_ref_stats = gimple_mem_ref_stats (cfun);\n+\n+  stmt_dereferences_ptr_p = false;\n+\n+  if (stmt_escape_type == ESCAPE_TO_CALL\n+      || stmt_escape_type == ESCAPE_TO_PURE_CONST)\n+    {\n+      mem_ref_stats->num_call_sites++;\n+      if (stmt_escape_type == ESCAPE_TO_PURE_CONST)\n+\tmem_ref_stats->num_pure_const_call_sites++;\n+    }\n+  else if (stmt_escape_type == ESCAPE_TO_ASM)\n+    mem_ref_stats->num_asm_sites++;\n+\n+  /* Mark all the variables whose address are taken by the statement.  */\n+  addr_taken = addresses_taken (stmt);\n+  if (addr_taken)\n+    bitmap_ior_into (gimple_addressable_vars (cfun), addr_taken);\n+\n+  /* Process each operand use.  For pointers, determine whether they\n+     are dereferenced by the statement, or whether their value\n+     escapes, etc.  */\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n+    {\n+      tree op, var;\n+      var_ann_t v_ann;\n+      struct ptr_info_def *pi;\n+      unsigned num_uses, num_loads, num_stores;\n+\n+      op = USE_FROM_PTR (use_p);\n+\n+      /* If STMT is a PHI node, OP may be an ADDR_EXPR.  If so, add it\n+\t to the set of addressable variables.  */\n+      if (TREE_CODE (op) == ADDR_EXPR)\n+\t{\n+\t  bitmap addressable_vars = gimple_addressable_vars (cfun);\n+\n+\t  gcc_assert (TREE_CODE (stmt) == PHI_NODE);\n+\t  gcc_assert (addressable_vars);\n+\n+\t  /* PHI nodes don't have annotations for pinning the set\n+\t     of addresses taken, so we collect them here.\n+\n+\t     FIXME, should we allow PHI nodes to have annotations\n+\t     so that they can be treated like regular statements?\n+\t     Currently, they are treated as second-class\n+\t     statements.  */\n+\t  add_to_addressable_set (TREE_OPERAND (op, 0), &addressable_vars);\n+\t  continue;\n+\t}\n+\n+      /* Ignore constants (they may occur in PHI node arguments).  */\n+      if (TREE_CODE (op) != SSA_NAME)\n+\tcontinue;\n+\n+      var = SSA_NAME_VAR (op);\n+      v_ann = var_ann (var);\n+\n+      /* The base variable of an SSA name must be a GIMPLE register, and thus\n+\t it cannot be aliased.  */\n+      gcc_assert (!may_be_aliased (var));\n+\n+      /* We are only interested in pointers.  */\n+      if (!POINTER_TYPE_P (TREE_TYPE (op)))\n+\tcontinue;\n+\n+      pi = get_ptr_info (op);\n+\n+      /* Add OP to AI->PROCESSED_PTRS, if it's not there already.  */\n+      if (!TEST_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (op)))\n+\t{\n+\t  SET_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (op));\n+\t  VEC_safe_push (tree, heap, ai->processed_ptrs, op);\n+\t}\n+\n+      /* If STMT is a PHI node, then it will not have pointer\n+\t dereferences and it will not be an escape point.  */\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\tcontinue;\n+\n+      /* Determine whether OP is a dereferenced pointer, and if STMT\n+\t is an escape point, whether OP escapes.  */\n+      count_uses_and_derefs (op, stmt, &num_uses, &num_loads, &num_stores);\n+\n+      /* For directly dereferenced pointers we can apply\n+\t TBAA-pruning to their points-to set.  We may not count the\n+\t implicit dereferences &PTR->FLD here.  */\n+      if (num_loads + num_stores > 0)\n+\tpi->is_dereferenced = 1;\n+\n+      /* Handle a corner case involving address expressions of the\n+\t form '&PTR->FLD'.  The problem with these expressions is that\n+\t they do not represent a dereference of PTR.  However, if some\n+\t other transformation propagates them into an INDIRECT_REF\n+\t expression, we end up with '*(&PTR->FLD)' which is folded\n+\t into 'PTR->FLD'.\n+\n+\t So, if the original code had no other dereferences of PTR,\n+\t the aliaser will not create memory tags for it, and when\n+\t &PTR->FLD gets propagated to INDIRECT_REF expressions, the\n+\t memory operations will receive no VDEF/VUSE operands.\n+\n+\t One solution would be to have count_uses_and_derefs consider\n+\t &PTR->FLD a dereference of PTR.  But that is wrong, since it\n+\t is not really a dereference but an offset calculation.\n+\n+\t What we do here is to recognize these special ADDR_EXPR\n+\t nodes.  Since these expressions are never GIMPLE values (they\n+\t are not GIMPLE invariants), they can only appear on the RHS\n+\t of an assignment and their base address is always an\n+\t INDIRECT_REF expression.  */\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ADDR_EXPR\n+\t  && !is_gimple_val (GIMPLE_STMT_OPERAND (stmt, 1)))\n+\t{\n+\t  /* If the RHS if of the form &PTR->FLD and PTR == OP, then\n+\t     this represents a potential dereference of PTR.  */\n+\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t  tree base = get_base_address (TREE_OPERAND (rhs, 0));\n+\t  if (TREE_CODE (base) == INDIRECT_REF\n+\t      && TREE_OPERAND (base, 0) == op)\n+\t    num_loads++;\n+\t}\n+\n+      if (num_loads + num_stores > 0)\n+\t{\n+\t  /* Mark OP as dereferenced.  In a subsequent pass,\n+\t     dereferenced pointers that point to a set of\n+\t     variables will be assigned a name tag to alias\n+\t     all the variables OP points to.  */\n+\t  pi->memory_tag_needed = 1;\n+\n+\t  /* ???  For always executed direct dereferences we can\n+\t     apply TBAA-pruning to their escape set.  */\n+\n+\t  /* If this is a store operation, mark OP as being\n+\t     dereferenced to store, otherwise mark it as being\n+\t     dereferenced to load.  */\n+\t  if (num_stores > 0)\n+\t    pointer_set_insert (ai->dereferenced_ptrs_store, var);\n+\t  else\n+\t    pointer_set_insert (ai->dereferenced_ptrs_load, var);\n+\n+\t  /* Update the frequency estimate for all the dereferences of\n+\t     pointer OP.  */\n+\t  update_mem_sym_stats_from_stmt (op, stmt, num_loads, num_stores);\n+\n+\t  /* Indicate that STMT contains pointer dereferences.  */\n+\t  stmt_dereferences_ptr_p = true;\n+\t}\n+\n+      if (stmt_escape_type != NO_ESCAPE && num_loads + num_stores < num_uses)\n+\t{\n+\t  /* If STMT is an escape point and STMT contains at\n+\t     least one direct use of OP, then the value of OP\n+\t     escapes and so the pointed-to variables need to\n+\t     be marked call-clobbered.  */\n+\t  pi->value_escapes_p = 1;\n+\t  pi->escape_mask |= stmt_escape_type;\n+\n+\t  /* If the statement makes a function call, assume\n+\t     that pointer OP will be dereferenced in a store\n+\t     operation inside the called function.  */\n+\t  if (get_call_expr_in (stmt)\n+\t      || stmt_escape_type == ESCAPE_STORED_IN_GLOBAL)\n+\t    {\n+\t      pointer_set_insert (ai->dereferenced_ptrs_store, var);\n+\t      pi->memory_tag_needed = 1;\n+\t    }\n+\t}\n+    }\n+\n+  if (TREE_CODE (stmt) == PHI_NODE)\n+    return;\n+\n+  /* Mark stored variables in STMT as being written to and update the\n+     memory reference stats for all memory symbols referenced by STMT.  */\n+  if (stmt_references_memory_p (stmt))\n+    {\n+      unsigned i;\n+      bitmap_iterator bi;\n+\n+      mem_ref_stats->num_mem_stmts++;\n+\n+      /* Notice that we only update memory reference stats for symbols\n+\t loaded and stored by the statement if the statement does not\n+\t contain pointer dereferences and it is not a call/asm site.\n+\t This is to avoid double accounting problems when creating\n+\t memory partitions.  After computing points-to information,\n+\t pointer dereference statistics are used to update the\n+\t reference stats of the pointed-to variables, so here we\n+\t should only update direct references to symbols.\n+\n+\t Indirect references are not updated here for two reasons: (1)\n+\t The first time we compute alias information, the sets\n+\t LOADED/STORED are empty for pointer dereferences, (2) After\n+\t partitioning, LOADED/STORED may have references to\n+\t partitions, not the original pointed-to variables.  So, if we\n+\t always counted LOADED/STORED here and during partitioning, we\n+\t would count many symbols more than once.\n+\n+\t This does cause some imprecision when a statement has a\n+\t combination of direct symbol references and pointer\n+\t dereferences (e.g., MEMORY_VAR = *PTR) or if a call site has\n+\t memory symbols in its argument list, but these cases do not\n+\t occur so frequently as to constitute a serious problem.  */\n+      if (STORED_SYMS (stmt))\n+\tEXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n+\t  {\n+\t    tree sym = referenced_var (i);\n+\t    pointer_set_insert (ai->written_vars, sym);\n+\t    if (!stmt_dereferences_ptr_p\n+\t\t&& stmt_escape_type != ESCAPE_TO_CALL\n+\t\t&& stmt_escape_type != ESCAPE_TO_PURE_CONST\n+\t\t&& stmt_escape_type != ESCAPE_TO_ASM)\n+\t      update_mem_sym_stats_from_stmt (sym, stmt, 0, 1);\n+\t  }\n+\n+      if (!stmt_dereferences_ptr_p\n+\t  && LOADED_SYMS (stmt)\n+\t  && stmt_escape_type != ESCAPE_TO_CALL\n+\t  && stmt_escape_type != ESCAPE_TO_PURE_CONST\n+\t  && stmt_escape_type != ESCAPE_TO_ASM)\n+\tEXECUTE_IF_SET_IN_BITMAP (LOADED_SYMS (stmt), 0, i, bi)\n+\t  update_mem_sym_stats_from_stmt (referenced_var (i), stmt, 1, 0);\n+    }\n+}\n+\n+/* Update various related attributes like escaped addresses,\n+   pointer dereferences for loads and stores.  This is used\n+   when creating name tags and alias sets.  */\n+\n+static void\n+update_alias_info (struct alias_info *ai)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      tree phi;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\tif (is_gimple_reg (PHI_RESULT (phi)))\n+\t  update_alias_info_1 (phi, ai);\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tupdate_alias_info_1 (bsi_stmt (bsi), ai);\n+    }\n+}\n+\n /* Create memory tags for all the dereferenced pointers and build the\n    ADDRESSABLE_VARS and POINTERS arrays used for building the may-alias\n    sets.  Based on the address escape and points-to information collected"}, {"sha": "b2ba20423b4278d209e5c1684e39c6b45014ca7b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 31, "deletions": 313, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=faf2ecc57e3ef478efebee6f83c440df073152c2", "patch": "@@ -2526,13 +2526,11 @@ get_constraint_exp_from_ssa_var (tree t)\n   return cexpr;\n }\n \n-/* Process a completed constraint T, and add it to the constraint\n-   list.  FROM_CALL is true if this is a constraint coming from a\n-   call, which means any DEREFs we see are \"may-deref's\", not\n-   \"must-deref\"'s.  */\n+/* Process constraint T, performing various simplifications and then\n+   adding it to our list of overall constraints.  */\n \n static void\n-process_constraint_1 (constraint_t t, bool from_call)\n+process_constraint (constraint_t t)\n {\n   struct constraint_expr rhs = t->rhs;\n   struct constraint_expr lhs = t->lhs;\n@@ -2556,7 +2554,7 @@ process_constraint_1 (constraint_t t, bool from_call)\n       rhs = t->lhs;\n       t->lhs = t->rhs;\n       t->rhs = rhs;\n-      process_constraint_1 (t, from_call);\n+      process_constraint (t);\n     }\n   /* This can happen in our IR with things like n->a = *p */\n   else if (rhs.type == DEREF && lhs.type == DEREF && rhs.var != anything_id)\n@@ -2574,8 +2572,8 @@ process_constraint_1 (constraint_t t, bool from_call)\n       gcc_assert (!AGGREGATE_TYPE_P (pointedtotype)\n \t\t  || get_varinfo (rhs.var)->is_unknown_size_var);\n \n-      process_constraint_1 (new_constraint (tmplhs, rhs), from_call);\n-      process_constraint_1 (new_constraint (lhs, tmplhs), from_call);\n+      process_constraint (new_constraint (tmplhs, rhs));\n+      process_constraint (new_constraint (lhs, tmplhs));\n     }\n   else if (rhs.type == ADDRESSOF && lhs.type == DEREF)\n     {\n@@ -2585,8 +2583,8 @@ process_constraint_1 (constraint_t t, bool from_call)\n       tree tmpvar = create_tmp_var_raw (pointertype, \"derefaddrtmp\");\n       struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n \n-      process_constraint_1 (new_constraint (tmplhs, rhs), from_call);\n-      process_constraint_1 (new_constraint (lhs, tmplhs), from_call);\n+      process_constraint (new_constraint (tmplhs, rhs));\n+      process_constraint (new_constraint (lhs, tmplhs));\n     }\n   else\n     {\n@@ -2595,16 +2593,6 @@ process_constraint_1 (constraint_t t, bool from_call)\n     }\n }\n \n-\n-/* Process constraint T, performing various simplifications and then\n-   adding it to our list of overall constraints.  */\n-\n-static void\n-process_constraint (constraint_t t)\n-{\n-  process_constraint_1 (t, false);\n-}\n-\n /* Return true if T is a variable of a type that could contain\n    pointers.  */\n \n@@ -3267,248 +3255,6 @@ do_structure_copy (tree lhsop, tree rhsop)\n }\n \n \n-/* Update related alias information kept in AI.  This is used when\n-   building name tags, alias sets and deciding grouping heuristics.\n-   STMT is the statement to process.  This function also updates\n-   ADDRESSABLE_VARS.  */\n-\n-static void\n-update_alias_info (tree stmt, struct alias_info *ai)\n-{\n-  bitmap addr_taken;\n-  use_operand_p use_p;\n-  ssa_op_iter iter;\n-  bool stmt_dereferences_ptr_p;\n-  enum escape_type stmt_escape_type = is_escape_site (stmt);\n-  struct mem_ref_stats_d *mem_ref_stats = gimple_mem_ref_stats (cfun);\n-\n-  stmt_dereferences_ptr_p = false;\n-\n-  if (stmt_escape_type == ESCAPE_TO_CALL\n-      || stmt_escape_type == ESCAPE_TO_PURE_CONST)\n-    {\n-      mem_ref_stats->num_call_sites++;\n-      if (stmt_escape_type == ESCAPE_TO_PURE_CONST)\n-\tmem_ref_stats->num_pure_const_call_sites++;\n-    }\n-  else if (stmt_escape_type == ESCAPE_TO_ASM)\n-    mem_ref_stats->num_asm_sites++;\n-\n-  /* Mark all the variables whose address are taken by the statement.  */\n-  addr_taken = addresses_taken (stmt);\n-  if (addr_taken)\n-    bitmap_ior_into (gimple_addressable_vars (cfun), addr_taken);\n-\n-  /* Process each operand use.  For pointers, determine whether they\n-     are dereferenced by the statement, or whether their value\n-     escapes, etc.  */\n-  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n-    {\n-      tree op, var;\n-      var_ann_t v_ann;\n-      struct ptr_info_def *pi;\n-      unsigned num_uses, num_loads, num_stores;\n-\n-      op = USE_FROM_PTR (use_p);\n-\n-      /* If STMT is a PHI node, OP may be an ADDR_EXPR.  If so, add it\n-\t to the set of addressable variables.  */\n-      if (TREE_CODE (op) == ADDR_EXPR)\n-\t{\n-\t  bitmap addressable_vars = gimple_addressable_vars (cfun);\n-\n-\t  gcc_assert (TREE_CODE (stmt) == PHI_NODE);\n-\t  gcc_assert (addressable_vars);\n-\n-\t  /* PHI nodes don't have annotations for pinning the set\n-\t     of addresses taken, so we collect them here.\n-\n-\t     FIXME, should we allow PHI nodes to have annotations\n-\t     so that they can be treated like regular statements?\n-\t     Currently, they are treated as second-class\n-\t     statements.  */\n-\t  add_to_addressable_set (TREE_OPERAND (op, 0), &addressable_vars);\n-\t  continue;\n-\t}\n-\n-      /* Ignore constants (they may occur in PHI node arguments).  */\n-      if (TREE_CODE (op) != SSA_NAME)\n-\tcontinue;\n-\n-      var = SSA_NAME_VAR (op);\n-      v_ann = var_ann (var);\n-\n-      /* The base variable of an SSA name must be a GIMPLE register, and thus\n-\t it cannot be aliased.  */\n-      gcc_assert (!may_be_aliased (var));\n-\n-      /* We are only interested in pointers.  */\n-      if (!POINTER_TYPE_P (TREE_TYPE (op)))\n-\tcontinue;\n-\n-      pi = get_ptr_info (op);\n-\n-      /* Add OP to AI->PROCESSED_PTRS, if it's not there already.  */\n-      if (!TEST_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (op)))\n-\t{\n-\t  SET_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (op));\n-\t  VEC_safe_push (tree, heap, ai->processed_ptrs, op);\n-\t}\n-\n-      /* If STMT is a PHI node, then it will not have pointer\n-\t dereferences and it will not be an escape point.  */\n-      if (TREE_CODE (stmt) == PHI_NODE)\n-\tcontinue;\n-\n-      /* Determine whether OP is a dereferenced pointer, and if STMT\n-\t is an escape point, whether OP escapes.  */\n-      count_uses_and_derefs (op, stmt, &num_uses, &num_loads, &num_stores);\n-\n-      /* For directly dereferenced pointers we can apply\n-\t TBAA-pruning to their points-to set.  We may not count the\n-\t implicit dereferences &PTR->FLD here.  */\n-      if (num_loads + num_stores > 0)\n-\tpi->is_dereferenced = 1;\n-\n-      /* Handle a corner case involving address expressions of the\n-\t form '&PTR->FLD'.  The problem with these expressions is that\n-\t they do not represent a dereference of PTR.  However, if some\n-\t other transformation propagates them into an INDIRECT_REF\n-\t expression, we end up with '*(&PTR->FLD)' which is folded\n-\t into 'PTR->FLD'.\n-\n-\t So, if the original code had no other dereferences of PTR,\n-\t the aliaser will not create memory tags for it, and when\n-\t &PTR->FLD gets propagated to INDIRECT_REF expressions, the\n-\t memory operations will receive no VDEF/VUSE operands.\n-\n-\t One solution would be to have count_uses_and_derefs consider\n-\t &PTR->FLD a dereference of PTR.  But that is wrong, since it\n-\t is not really a dereference but an offset calculation.\n-\n-\t What we do here is to recognize these special ADDR_EXPR\n-\t nodes.  Since these expressions are never GIMPLE values (they\n-\t are not GIMPLE invariants), they can only appear on the RHS\n-\t of an assignment and their base address is always an\n-\t INDIRECT_REF expression.  */\n-      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n-\t  && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 1)) == ADDR_EXPR\n-\t  && !is_gimple_val (GIMPLE_STMT_OPERAND (stmt, 1)))\n-\t{\n-\t  /* If the RHS if of the form &PTR->FLD and PTR == OP, then\n-\t     this represents a potential dereference of PTR.  */\n-\t  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-\t  tree base = get_base_address (TREE_OPERAND (rhs, 0));\n-\t  if (TREE_CODE (base) == INDIRECT_REF\n-\t      && TREE_OPERAND (base, 0) == op)\n-\t    num_loads++;\n-\t}\n-\n-      if (num_loads + num_stores > 0)\n-\t{\n-\t  /* Mark OP as dereferenced.  In a subsequent pass,\n-\t     dereferenced pointers that point to a set of\n-\t     variables will be assigned a name tag to alias\n-\t     all the variables OP points to.  */\n-\t  pi->memory_tag_needed = 1;\n-\n-\t  /* ???  For always executed direct dereferences we can\n-\t     apply TBAA-pruning to their escape set.  */\n-\n-\t  /* If this is a store operation, mark OP as being\n-\t     dereferenced to store, otherwise mark it as being\n-\t     dereferenced to load.  */\n-\t  if (num_stores > 0)\n-\t    pointer_set_insert (ai->dereferenced_ptrs_store, var);\n-\t  else\n-\t    pointer_set_insert (ai->dereferenced_ptrs_load, var);\n-\n-\t  /* Update the frequency estimate for all the dereferences of\n-\t     pointer OP.  */\n-\t  update_mem_sym_stats_from_stmt (op, stmt, num_loads, num_stores);\n-\n-\t  /* Indicate that STMT contains pointer dereferences.  */\n-\t  stmt_dereferences_ptr_p = true;\n-\t}\n-\n-      if (stmt_escape_type != NO_ESCAPE && num_loads + num_stores < num_uses)\n-\t{\n-\t  /* If STMT is an escape point and STMT contains at\n-\t     least one direct use of OP, then the value of OP\n-\t     escapes and so the pointed-to variables need to\n-\t     be marked call-clobbered.  */\n-\t  pi->value_escapes_p = 1;\n-\t  pi->escape_mask |= stmt_escape_type;\n-\n-\t  /* If the statement makes a function call, assume\n-\t     that pointer OP will be dereferenced in a store\n-\t     operation inside the called function.  */\n-\t  if (get_call_expr_in (stmt)\n-\t      || stmt_escape_type == ESCAPE_STORED_IN_GLOBAL)\n-\t    {\n-\t      pointer_set_insert (ai->dereferenced_ptrs_store, var);\n-\t      pi->memory_tag_needed = 1;\n-\t    }\n-\t}\n-    }\n-\n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    return;\n-\n-  /* Mark stored variables in STMT as being written to and update the\n-     memory reference stats for all memory symbols referenced by STMT.  */\n-  if (stmt_references_memory_p (stmt))\n-    {\n-      unsigned i;\n-      bitmap_iterator bi;\n-\n-      mem_ref_stats->num_mem_stmts++;\n-\n-      /* Notice that we only update memory reference stats for symbols\n-\t loaded and stored by the statement if the statement does not\n-\t contain pointer dereferences and it is not a call/asm site.\n-\t This is to avoid double accounting problems when creating\n-\t memory partitions.  After computing points-to information,\n-\t pointer dereference statistics are used to update the\n-\t reference stats of the pointed-to variables, so here we\n-\t should only update direct references to symbols.\n-\n-\t Indirect references are not updated here for two reasons: (1)\n-\t The first time we compute alias information, the sets\n-\t LOADED/STORED are empty for pointer dereferences, (2) After\n-\t partitioning, LOADED/STORED may have references to\n-\t partitions, not the original pointed-to variables.  So, if we\n-\t always counted LOADED/STORED here and during partitioning, we\n-\t would count many symbols more than once.\n-\n-\t This does cause some imprecision when a statement has a\n-\t combination of direct symbol references and pointer\n-\t dereferences (e.g., MEMORY_VAR = *PTR) or if a call site has\n-\t memory symbols in its argument list, but these cases do not\n-\t occur so frequently as to constitute a serious problem.  */\n-      if (STORED_SYMS (stmt))\n-\tEXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n-\t  {\n-\t    tree sym = referenced_var (i);\n-\t    pointer_set_insert (ai->written_vars, sym);\n-\t    if (!stmt_dereferences_ptr_p\n-\t\t&& stmt_escape_type != ESCAPE_TO_CALL\n-\t\t&& stmt_escape_type != ESCAPE_TO_PURE_CONST\n-\t\t&& stmt_escape_type != ESCAPE_TO_ASM)\n-\t      update_mem_sym_stats_from_stmt (sym, stmt, 0, 1);\n-\t  }\n-\n-      if (!stmt_dereferences_ptr_p\n-\t  && LOADED_SYMS (stmt)\n-\t  && stmt_escape_type != ESCAPE_TO_CALL\n-\t  && stmt_escape_type != ESCAPE_TO_PURE_CONST\n-\t  && stmt_escape_type != ESCAPE_TO_ASM)\n-\tEXECUTE_IF_SET_IN_BITMAP (LOADED_SYMS (stmt), 0, i, bi)\n-\t  update_mem_sym_stats_from_stmt (referenced_var (i), stmt, 1, 0);\n-    }\n-}\n-\n-\n /* Handle pointer arithmetic EXPR when creating aliasing constraints.\n    Expressions of the type PTR + CST can be handled in two ways:\n \n@@ -3598,7 +3344,7 @@ make_constraint_to (unsigned id, tree op)\n \n   get_constraint_for (op, &rhsc);\n   for (j = 0; VEC_iterate (ce_s, rhsc, j, c); j++)\n-    process_constraint_1 (new_constraint (includes, *c), true);\n+    process_constraint (new_constraint (includes, *c));\n   VEC_free (ce_s, heap, rhsc);\n }\n \n@@ -3643,16 +3389,11 @@ handle_lhs_call (tree lhs)\n   struct constraint_expr *lhsp;\n \n   get_constraint_for (lhs, &lhsc);\n-  rhsc.var = nonlocal_id;\n-  rhsc.offset = 0;\n-  rhsc.type = ADDRESSOF;\n-  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n   rhsc.var = escaped_id;\n   rhsc.offset = 0;\n   rhsc.type = ADDRESSOF;\n   for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+    process_constraint (new_constraint (*lhsp, rhsc));\n   VEC_free (ce_s, heap, lhsc);\n }\n \n@@ -3680,7 +3421,7 @@ handle_const_call (tree stmt)\n       rhsc.offset = 0;\n       rhsc.type = ADDRESSOF;\n       for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\tprocess_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+\tprocess_constraint (new_constraint (*lhsp, rhsc));\n       VEC_free (ce_s, heap, lhsc);\n       return;\n     }\n@@ -3690,7 +3431,7 @@ handle_const_call (tree stmt)\n   rhsc.offset = 0;\n   rhsc.type = ADDRESSOF;\n   for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+    process_constraint (new_constraint (*lhsp, rhsc));\n \n   /* May return arguments.  */\n   FOR_EACH_CALL_EXPR_ARG (arg, iter, call)\n@@ -3702,7 +3443,7 @@ handle_const_call (tree stmt)\n \tget_constraint_for (arg, &argc);\n \tfor (i = 0; VEC_iterate (ce_s, argc, i, argp); i++)\n \t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\t    process_constraint_1 (new_constraint (*lhsp, *argp), true);\n+\t    process_constraint (new_constraint (*lhsp, *argp));\n \tVEC_free (ce_s, heap, argc);\n       }\n \n@@ -3748,7 +3489,7 @@ handle_pure_call (tree stmt)\n \t  rhsc.offset = 0;\n \t  rhsc.type = ADDRESSOF;\n \t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\t    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+\t    process_constraint (new_constraint (*lhsp, rhsc));\n \t  VEC_free (ce_s, heap, lhsc);\n \t  return;\n \t}\n@@ -3759,7 +3500,7 @@ handle_pure_call (tree stmt)\n       rhsc.offset = 0;\n       rhsc.type = ADDRESSOF;\n       for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\tprocess_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+\tprocess_constraint (new_constraint (*lhsp, rhsc));\n       VEC_free (ce_s, heap, lhsc);\n     }\n }\n@@ -3957,10 +3698,8 @@ find_func_aliases (tree origt)\n       tree rhsop = GIMPLE_STMT_OPERAND (t, 1);\n       int i;\n \n-      if ((AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n-\t   || TREE_CODE (TREE_TYPE (lhsop)) == COMPLEX_TYPE)\n-\t  && (AGGREGATE_TYPE_P (TREE_TYPE (rhsop))\n-\t      || TREE_CODE (TREE_TYPE (lhsop)) == COMPLEX_TYPE))\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n+\t  && AGGREGATE_TYPE_P (TREE_TYPE (rhsop)))\n \t{\n \t  do_structure_copy (lhsop, rhsop);\n \t}\n@@ -4340,13 +4079,6 @@ make_constraint_from (varinfo_t vi, int from)\n   process_constraint (new_constraint (lhs, rhs));\n }\n \n-/* Create a constraint from ANYTHING variable to VI.  */\n-static void\n-make_constraint_from_anything (varinfo_t vi)\n-{\n-  make_constraint_from (vi, anything_id);\n-}\n-\n /* Count the number of arguments DECL has, and set IS_VARARGS to true\n    if it is a varargs function.  */\n \n@@ -4552,8 +4284,9 @@ create_variable_info_for (tree decl, const char *name)\n \n   insert_vi_for_tree (vi->decl, vi);\n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n-  if (is_global && (!flag_whole_program || !in_ipa_mode))\n-    make_constraint_from_anything (vi);\n+  if (is_global && (!flag_whole_program || !in_ipa_mode)\n+      && could_have_pointers (decl))\n+    make_constraint_from (vi, escaped_id);\n \n   stats.total_vars++;\n   if (use_field_sensitive\n@@ -4633,8 +4366,9 @@ create_variable_info_for (tree decl, const char *name)\n \t  newvi->fullsize = vi->fullsize;\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n-\t  if (is_global && (!flag_whole_program || !in_ipa_mode))\n-\t      make_constraint_from_anything (newvi);\n+\t  if (is_global && (!flag_whole_program || !in_ipa_mode)\n+\t      && (!fo->decl || could_have_pointers (fo->decl)))\n+\t    make_constraint_from (newvi, escaped_id);\n \n \t  stats.total_vars++;\n \t}\n@@ -5296,7 +5030,7 @@ init_base_vars (void)\n   rhs.type = DEREF;\n   rhs.var = escaped_id;\n   rhs.offset = 0;\n-  process_constraint_1 (new_constraint (lhs, rhs), true);\n+  process_constraint (new_constraint (lhs, rhs));\n \n   /* Create the NONLOCAL variable, used to represent the set of nonlocal\n      memory.  */\n@@ -5339,7 +5073,7 @@ init_base_vars (void)\n   rhs.type = DEREF;\n   rhs.var = callused_id;\n   rhs.offset = 0;\n-  process_constraint_1 (new_constraint (lhs, rhs), true);\n+  process_constraint (new_constraint (lhs, rhs));\n \n   /* Create the INTEGER variable, used to represent that a variable points\n      to an INTEGER.  */\n@@ -5372,7 +5106,7 @@ init_base_vars (void)\n   rhs.type = ADDRESSOF;\n   rhs.var = escaped_id;\n   rhs.offset = 0;\n-  process_constraint_1 (new_constraint (lhs, rhs), true);\n+  process_constraint (new_constraint (lhs, rhs));\n \n   /* *ESCAPED = &NONLOCAL.  This is true because we have to assume\n      everything pointed to by escaped can also point to nonlocal. */\n@@ -5382,7 +5116,7 @@ init_base_vars (void)\n   rhs.type = ADDRESSOF;\n   rhs.var = nonlocal_id;\n   rhs.offset = 0;\n-  process_constraint_1 (new_constraint (lhs, rhs), true);\n+  process_constraint (new_constraint (lhs, rhs));\n }\n \n /* Initialize things necessary to perform PTA */\n@@ -5581,7 +5315,7 @@ compute_tbaa_pruning (void)\n    at the start of the file for an algorithmic overview.  */\n \n void\n-compute_points_to_sets (struct alias_info *ai)\n+compute_points_to_sets (void)\n {\n   struct scc_info *si;\n   basic_block bb;\n@@ -5600,31 +5334,15 @@ compute_points_to_sets (struct alias_info *ai)\n       tree phi;\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  if (is_gimple_reg (PHI_RESULT (phi)))\n-\t    {\n-\t      find_func_aliases (phi);\n-\n-\t      /* Update various related attributes like escaped\n-\t\t addresses, pointer dereferences for loads and stores.\n-\t\t This is used when creating name tags and alias\n-\t\t sets.  */\n-\t      update_alias_info (phi, ai);\n-\t    }\n-\t}\n+\tif (is_gimple_reg (PHI_RESULT (phi)))\n+\t  find_func_aliases (phi);\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \n \t  find_func_aliases (stmt);\n \n-\t  /* Update various related attributes like escaped\n-\t     addresses, pointer dereferences for loads and stores.\n-\t     This is used when creating name tags and alias\n-\t     sets.  */\n-\t  update_alias_info (stmt, ai);\n-\n \t  /* The information in CHANGE_DYNAMIC_TYPE_EXPR nodes has now\n \t     been captured, and we can remove them.  */\n \t  if (TREE_CODE (stmt) == CHANGE_DYNAMIC_TYPE_EXPR)\n@@ -5761,7 +5479,7 @@ ipa_pta_execute (void)\n \t    {\n \t      varinfo_t fi = get_varinfo (varid);\n \t      for (; fi; fi = fi->next)\n-\t\tmake_constraint_from_anything (fi);\n+\t\tmake_constraint_from (fi, anything_id);\n \t    }\n \t}\n     }"}, {"sha": "7d468b42f9166b91e2813794f9487ec59aba3c88", "filename": "gcc/tree-ssa-structalias.h", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2Ftree-ssa-structalias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faf2ecc57e3ef478efebee6f83c440df073152c2/gcc%2Ftree-ssa-structalias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.h?ref=faf2ecc57e3ef478efebee6f83c440df073152c2", "patch": "@@ -24,44 +24,12 @@\n struct constraint;\n typedef struct constraint *constraint_t;\n \n-/* Alias information used by compute_may_aliases and its helpers.  */\n-struct alias_info\n-{\n-  /* SSA names visited while collecting points-to information.  If bit I\n-     is set, it means that SSA variable with version I has already been\n-     visited.  */\n-  sbitmap ssa_names_visited;\n-\n-  /* Array of SSA_NAME pointers processed by the points-to collector.  */\n-  VEC(tree,heap) *processed_ptrs;\n-\n-  /* ADDRESSABLE_VARS contains all the global variables and locals that\n-     have had their address taken.  */\n-  struct alias_map_d **addressable_vars;\n-  size_t num_addressable_vars;\n-\n-  /* POINTERS contains all the _DECL pointers with unique memory tags\n-     that have been referenced in the program.  */\n-  struct alias_map_d **pointers;\n-  size_t num_pointers;\n-\n-  /* Variables that have been written to directly (i.e., not through a\n-     pointer dereference).  */\n-  struct pointer_set_t *written_vars;\n-\n-  /* Pointers that have been used in an indirect store operation.  */\n-  struct pointer_set_t *dereferenced_ptrs_store;\n-\n-  /* Pointers that have been used in an indirect load operation.  */\n-  struct pointer_set_t *dereferenced_ptrs_load;\n-};\n-\n /* In tree-ssa-alias.c.  */\n enum escape_type is_escape_site (tree);\n void update_mem_sym_stats_from_stmt (tree, tree, long, long);\n \n /* In tree-ssa-structalias.c.  */\n-extern void compute_points_to_sets (struct alias_info *);\n+extern void compute_points_to_sets (void);\n extern void delete_points_to_sets (void);\n extern void dump_constraint (FILE *, constraint_t);\n extern void dump_constraints (FILE *);"}]}