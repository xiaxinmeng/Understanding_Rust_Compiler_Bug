{"sha": "cb4347e8d53257f108a8c963aad4506334d9d993", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I0MzQ3ZThkNTMyNTdmMTA4YThjOTYzYWFkNDUwNjMzNGQ5ZDk5Mw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2016-11-03T09:27:55Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2016-11-03T09:27:55Z"}, "message": "make targetm.gen_ccmp{first,next} take rtx_insn **\n\ngcc/ChangeLog:\n\n2016-11-03  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* ccmp.c (expand_ccmp_expr_1): Adjust.\n\t(expand_ccmp_expr): Likewise.\n\t(expand_ccmp_next): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_gen_ccmp_next): Likewise.\n\t(aarch64_gen_ccmp_first): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* target.def (gen_ccmp_first): Change argument types to rtx_insn *.\n\t(gen_ccmp_next): Likewise.\n\nFrom-SVN: r241811", "tree": {"sha": "c4efeda548eb43b98b12c05dd8592d8f7c9af180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4efeda548eb43b98b12c05dd8592d8f7c9af180"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb4347e8d53257f108a8c963aad4506334d9d993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4347e8d53257f108a8c963aad4506334d9d993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4347e8d53257f108a8c963aad4506334d9d993", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4347e8d53257f108a8c963aad4506334d9d993/comments", "author": null, "committer": null, "parents": [{"sha": "c12176d716a0121cafc296c36bc256ea79700d1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c12176d716a0121cafc296c36bc256ea79700d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c12176d716a0121cafc296c36bc256ea79700d1e"}], "stats": {"total": 50, "additions": 30, "deletions": 20}, "files": [{"sha": "ae117c82396389b26329f7bfe0033e0d34b68701", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb4347e8d53257f108a8c963aad4506334d9d993", "patch": "@@ -1,3 +1,14 @@\n+2016-11-03  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* ccmp.c (expand_ccmp_expr_1): Adjust.\n+\t(expand_ccmp_expr): Likewise.\n+\t(expand_ccmp_next): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_gen_ccmp_next): Likewise.\n+\t(aarch64_gen_ccmp_first): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* target.def (gen_ccmp_first): Change argument types to rtx_insn *.\n+\t(gen_ccmp_next): Likewise.\n+\n 2016-11-03  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-loop.c (destroy_loop_vec_info): Handle cond_expr."}, {"sha": "14222ca5942639cccde1fcfe3363873e8817e63f", "filename": "gcc/ccmp.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=cb4347e8d53257f108a8c963aad4506334d9d993", "patch": "@@ -122,7 +122,7 @@ ccmp_candidate_p (gimple *g)\n    GEN_SEQ returns all compare insns.  */\n static rtx\n expand_ccmp_next (gimple *g, tree_code code, rtx prev,\n-\t\t  rtx *prep_seq, rtx *gen_seq)\n+\t\t  rtx_insn **prep_seq, rtx_insn **gen_seq)\n {\n   rtx_code rcode;\n   int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)));\n@@ -149,10 +149,8 @@ expand_ccmp_next (gimple *g, tree_code code, rtx prev,\n    PREP_SEQ returns all insns to prepare opearand.\n    GEN_SEQ returns all compare insns.  */\n static rtx\n-expand_ccmp_expr_1 (gimple *g, rtx *prep_seq, rtx *gen_seq)\n+expand_ccmp_expr_1 (gimple *g, rtx_insn **prep_seq, rtx_insn **gen_seq)\n {\n-  rtx prep_seq_1, gen_seq_1;\n-  rtx prep_seq_2, gen_seq_2;\n   tree exp = gimple_assign_rhs_to_tree (g);\n   tree_code code = TREE_CODE (exp);\n   gimple *gs0 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 0));\n@@ -180,21 +178,23 @@ expand_ccmp_expr_1 (gimple *g, rtx *prep_seq, rtx *gen_seq)\n \t  rcode0 = get_rtx_code (code0, unsignedp0);\n \t  rcode1 = get_rtx_code (code1, unsignedp1);\n \n+\t  rtx_insn *prep_seq_1, *gen_seq_1;\n \t  tmp = targetm.gen_ccmp_first (&prep_seq_1, &gen_seq_1, rcode0,\n \t\t\t\t\tgimple_assign_rhs1 (gs0),\n \t\t\t\t\tgimple_assign_rhs2 (gs0));\n \n \t  if (tmp != NULL)\n \t    {\n \t      ret = expand_ccmp_next (gs1, code, tmp, &prep_seq_1, &gen_seq_1);\n-\t      cost1 = seq_cost (safe_as_a <rtx_insn *> (prep_seq_1), speed_p);\n-\t      cost1 += seq_cost (safe_as_a <rtx_insn *> (gen_seq_1), speed_p);\n+\t      cost1 = seq_cost (prep_seq_1, speed_p);\n+\t      cost1 += seq_cost (gen_seq_1, speed_p);\n \t    }\n \n \t  /* FIXME: Temporary workaround for PR69619.\n \t     Avoid exponential compile time due to expanding gs0 and gs1 twice.\n \t     If gs0 and gs1 are complex, the cost will be high, so avoid\n \t     reevaluation if above an arbitrary threshold.  */\n+\t  rtx_insn *prep_seq_2, *gen_seq_2;\n \t  if (tmp == NULL || cost1 < COSTS_N_INSNS (25))\n \t    tmp2 = targetm.gen_ccmp_first (&prep_seq_2, &gen_seq_2, rcode1,\n \t\t\t\t\t   gimple_assign_rhs1 (gs1),\n@@ -207,8 +207,8 @@ expand_ccmp_expr_1 (gimple *g, rtx *prep_seq, rtx *gen_seq)\n \t    {\n \t      ret2 = expand_ccmp_next (gs0, code, tmp2, &prep_seq_2,\n \t\t\t\t       &gen_seq_2);\n-\t      cost2 = seq_cost (safe_as_a <rtx_insn *> (prep_seq_2), speed_p);\n-\t      cost2 += seq_cost (safe_as_a <rtx_insn *> (gen_seq_2), speed_p);\n+\t      cost2 = seq_cost (prep_seq_2, speed_p);\n+\t      cost2 += seq_cost (gen_seq_2, speed_p);\n \t    }\n \n \t  if (cost2 < cost1)\n@@ -262,14 +262,13 @@ expand_ccmp_expr (gimple *g)\n {\n   rtx_insn *last;\n   rtx tmp;\n-  rtx prep_seq, gen_seq;\n-\n-  prep_seq = gen_seq = NULL_RTX;\n \n   if (!ccmp_candidate_p (g))\n     return NULL_RTX;\n \n   last = get_last_insn ();\n+\n+  rtx_insn *prep_seq = NULL, *gen_seq = NULL;\n   tmp = expand_ccmp_expr_1 (g, &prep_seq, &gen_seq);\n \n   if (tmp)"}, {"sha": "b7d4640826ac1eb8f67642a41fc19419caee9641", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=cb4347e8d53257f108a8c963aad4506334d9d993", "patch": "@@ -13234,7 +13234,7 @@ aarch64_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n }\n \n static rtx\n-aarch64_gen_ccmp_first (rtx *prep_seq, rtx *gen_seq,\n+aarch64_gen_ccmp_first (rtx_insn **prep_seq, rtx_insn **gen_seq,\n \t\t\tint code, tree treeop0, tree treeop1)\n {\n   machine_mode op_mode, cmp_mode, cc_mode = CCmode;\n@@ -13308,8 +13308,8 @@ aarch64_gen_ccmp_first (rtx *prep_seq, rtx *gen_seq,\n }\n \n static rtx\n-aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n-\t\t       tree treeop0, tree treeop1, int bit_code)\n+aarch64_gen_ccmp_next (rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev,\n+\t\t       int cmp_code, tree treeop0, tree treeop1, int bit_code)\n {\n   rtx op0, op1, target;\n   machine_mode op_mode, cmp_mode, cc_mode = CCmode;\n@@ -13318,7 +13318,7 @@ aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n   struct expand_operand ops[6];\n   int aarch64_cond;\n \n-  push_to_sequence ((rtx_insn*) *prep_seq);\n+  push_to_sequence (*prep_seq);\n   expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n \n   op_mode = GET_MODE (op0);\n@@ -13384,7 +13384,7 @@ aarch64_gen_ccmp_next (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code,\n   create_fixed_operand (&ops[4], prev);\n   create_fixed_operand (&ops[5], GEN_INT (aarch64_cond));\n \n-  push_to_sequence ((rtx_insn*) *gen_seq);\n+  push_to_sequence (*gen_seq);\n   if (!maybe_expand_insn (icode, 6, ops))\n     {\n       end_sequence ();"}, {"sha": "b4eb18cc89a11f6a6c62592af164c5abd23fd889", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=cb4347e8d53257f108a8c963aad4506334d9d993", "patch": "@@ -11550,7 +11550,7 @@ This target hook is required only when the target has several different\n modes and they have different conditional execution capability, such as ARM.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_FIRST (rtx *@var{prep_seq}, rtx *@var{gen_seq}, int @var{code}, tree @var{op0}, tree @var{op1})\n+@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_FIRST (rtx_insn **@var{prep_seq}, rtx_insn **@var{gen_seq}, int @var{code}, tree @var{op0}, tree @var{op1})\n This function prepares to emit a comparison insn for the first compare in a\n  sequence of conditional comparisions.  It returns an appropriate comparison\n  with @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\n@@ -11560,7 +11560,7 @@ This function prepares to emit a comparison insn for the first compare in a\n  @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\n @end deftypefn\n \n-@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_NEXT (rtx *@var{prep_seq}, rtx *@var{gen_seq}, rtx @var{prev}, int @var{cmp_code}, tree @var{op0}, tree @var{op1}, int @var{bit_code})\n+@deftypefn {Target Hook} rtx TARGET_GEN_CCMP_NEXT (rtx_insn **@var{prep_seq}, rtx_insn **@var{gen_seq}, rtx @var{prev}, int @var{cmp_code}, tree @var{op0}, tree @var{op1}, int @var{bit_code})\n This function prepares to emit a conditional comparison within a sequence\n  of conditional comparisons.  It returns an appropriate comparison with\n  @code{CC} for passing to @code{gen_ccmp_next} or @code{cbranch_optab}."}, {"sha": "3d5c179fd157045a497018e366033553f9ca2506", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4347e8d53257f108a8c963aad4506334d9d993/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=cb4347e8d53257f108a8c963aad4506334d9d993", "patch": "@@ -2627,7 +2627,7 @@ DEFHOOK\n  insns are saved in @var{gen_seq}.  They will be emitted when all the\\n\\\n  compares in the the conditional comparision are generated without error.\\n\\\n  @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\",\n- rtx, (rtx *prep_seq, rtx *gen_seq, int code, tree op0, tree op1),\n+ rtx, (rtx_insn **prep_seq, rtx_insn **gen_seq, int code, tree op0, tree op1),\n  NULL)\n \n DEFHOOK\n@@ -2644,7 +2644,7 @@ DEFHOOK\n  be appropriate for passing to @code{gen_ccmp_next} or @code{cbranch_optab}.\\n\\\n  @var{code} is the @code{rtx_code} of the compare for @var{op0} and @var{op1}.\\n\\\n  @var{bit_code} is @code{AND} or @code{IOR}, which is the op on the compares.\",\n- rtx, (rtx *prep_seq, rtx *gen_seq, rtx prev, int cmp_code, tree op0, tree op1, int bit_code),\n+ rtx, (rtx_insn **prep_seq, rtx_insn **gen_seq, rtx prev, int cmp_code, tree op0, tree op1, int bit_code),\n  NULL)\n \n /* Return a new value for loop unroll size.  */"}]}