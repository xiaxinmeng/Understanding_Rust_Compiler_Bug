{"sha": "9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJjODNmMjdhNzAzYmQ3ZDIzOTM2MzhlMGVmOTNmNTA2YWM4YmIwMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-02-26T20:36:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-02-26T20:36:29Z"}, "message": "re PR tree-optimization/89500 (ICE: tree check: expected integer_cst, have ssa_name in get_len, at tree.h:5653)\n\n\tPR tree-optimization/89500\n\t* tree-ssa-strlen.c (stridx_strlenloc): Adjust comment.\n\t(handle_builtin_strlen): Remove noncst_bound variable.  Always\n\toptimize strnlen (x, 0) to 0.  Optimize strnlen (x, cst) to\n\tcst if the first cst bytes starting at x are known to be non-zero,\n\teven if the string is not zero terminated.  Don't try to modify\n\t*si for strnlen.  Update strlen_to_stridx only for strlen or if\n\twe can prove strnlen returns the same value as strlen would.\n\n\t* gcc.dg/pr89500.c: New test.\n\t* gcc.dg/Wstringop-overflow-10.c: New test.\n\t* gcc.dg/strlenopt-60.c: New test.\n\nFrom-SVN: r269230", "tree": {"sha": "7312fc231be96058723ceb7b696e739b968d5eda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7312fc231be96058723ceb7b696e739b968d5eda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d7beb79e0631c7ca8532c497295af03822eeed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7beb79e0631c7ca8532c497295af03822eeed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7beb79e0631c7ca8532c497295af03822eeed2"}], "stats": {"total": 175, "additions": 155, "deletions": 20}, "files": [{"sha": "b7404cc99365932098fa16bd2c394ef93b9fca29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "patch": "@@ -1,3 +1,14 @@\n+2019-02-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/89500\n+\t* tree-ssa-strlen.c (stridx_strlenloc): Adjust comment.\n+\t(handle_builtin_strlen): Remove noncst_bound variable.  Always\n+\toptimize strnlen (x, 0) to 0.  Optimize strnlen (x, cst) to\n+\tcst if the first cst bytes starting at x are known to be non-zero,\n+\teven if the string is not zero terminated.  Don't try to modify\n+\t*si for strnlen.  Update strlen_to_stridx only for strlen or if\n+\twe can prove strnlen returns the same value as strlen would.\n+\n 2019-02-26  Martin Liska  <mliska@suse.cz>\n \n \t* alloc-pool.h (struct pool_usage): Remove extra"}, {"sha": "6e3c5f737024b22d5e792380793f0ab2bba2667e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "patch": "@@ -1,3 +1,10 @@\n+2019-02-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/89500\n+\t* gcc.dg/pr89500.c: New test.\n+\t* gcc.dg/Wstringop-overflow-10.c: New test.\n+\t* gcc.dg/strlenopt-60.c: New test.\n+\n 2019-02-26  Harald Anlauf  <anlauf@gmx.de>\n \n \tPR fortran/89492"}, {"sha": "2e22130fa7e741c69bda1a760503bb3a3d75b01f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-10.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-10.c?ref=9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstringop-overflow\" } */\n+\n+void\n+foo (char *a)\n+{\n+  char b[16] = \"abcdefg\";\n+  __builtin_strncpy (a, b, __builtin_strlen (b));\t/* { dg-warning \"specified bound depends on the length of the source argument\" } */\n+}\n+\n+void\n+bar (char *a)\n+{\n+  char b[16] = \"abcdefg\";\n+  __builtin_strncpy (a, b, __builtin_strnlen (b, 8));\t/* { dg-warning \"specified bound depends on the length of the source argument\" } */\n+}\n+\n+void\n+baz (char *a)\n+{\n+  char b[16] = \"abcdefg\";\n+  __builtin_strncpy (a, b, __builtin_strnlen (b, 7));\t/* { dg-bogus \"specified bound depends on the length of the source argument\" } */\n+}\n+\n+void fill (char *);\n+\n+void\n+qux (char *a)\n+{\n+  char b[16];\n+  fill (b);\n+  __builtin_memcpy (b, \"abcdefg\", 7);\n+  __builtin_strncpy (a, b, __builtin_strnlen (b, 8));\t/* { dg-bogus \"specified bound depends on the length of the source argument\" } */\n+}"}, {"sha": "db7c27bec05c7f2af3d5d181037f9cf33a3c2397", "filename": "gcc/testsuite/gcc.dg/pr89500.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89500.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89500.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr89500.c?ref=9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "patch": "@@ -0,0 +1,17 @@\n+/* PR tree-optimization/89500 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen (const char *);\n+extern size_t strnlen (const char *, size_t);\n+extern void bar (char *);\n+\n+void\n+foo (int *a)\n+{\n+  char c[64];\n+  bar (c);\n+  a[0] = strlen (c);\n+  a[1] = strnlen (c, 0);\n+}"}, {"sha": "a5811368408742fd5f3b5ba3c1f1d7dd9a58ce93", "filename": "gcc/testsuite/gcc.dg/strlenopt-60.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-60.c?ref=9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "patch": "@@ -0,0 +1,58 @@\n+/* PR tree-optimization/89500 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \"return 10;\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 5;\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"return 0;\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"strnlen \" 1 \"optimized\" } } */\n+\n+#include \"strlenopt.h\"\n+\n+void foo (char *);\n+\n+size_t\n+f1 (void)\n+{\n+  char a[10] = \"0123456789\";\n+  return strnlen (a, 10);\n+}\n+\n+size_t\n+f2 (void)\n+{\n+  char a[10] = \"0123456789\";\n+  return strnlen (a, 5);\n+}\n+\n+size_t\n+f3 (void)\n+{\n+  char a[10] = \"0123456789\";\n+  return strnlen (a, 0);\n+}\n+\n+size_t\n+f4 (void)\n+{\n+  char a[20];\n+  foo (a);\n+  memcpy (a, \"0123456789\", 10);\n+  return strnlen (a, 10);\n+}\n+\n+size_t\n+f5 (void)\n+{\n+  char a[20];\n+  foo (a);\n+  memcpy (a, \"0123456789\", 10);\n+  return strnlen (a, 14);\n+}\n+\n+size_t\n+f6 (void)\n+{\n+  char a[20];\n+  foo (a);\n+  return strnlen (a, 0);\n+}"}, {"sha": "721832e3f19aeaf022b1330f933ee95ed2b95d70", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc83f27a703bd7d2393638e0ef93f506ac8bb03/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=9bc83f27a703bd7d2393638e0ef93f506ac8bb03", "patch": "@@ -156,7 +156,8 @@ struct decl_stridxlist_map\n    mappings.  */\n static hash_map<tree_decl_hash, stridxlist> *decl_to_stridxlist_htab;\n \n-/* Hash table mapping strlen calls to stridx instances describing\n+/* Hash table mapping strlen (or strnlen with constant bound and return\n+   smaller than bound) calls to stridx instances describing\n    the calls' arguments.  Non-null only when warn_stringop_truncation\n    is non-zero.  */\n typedef std::pair<int, location_t> stridx_strlenloc;\n@@ -1269,19 +1270,33 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n   tree bound = (DECL_FUNCTION_CODE (callee) == BUILT_IN_STRNLEN\n \t\t? gimple_call_arg (stmt, 1) : NULL_TREE);\n   int idx = get_stridx (src);\n-  if (idx)\n+  if (idx || (bound && integer_zerop (bound)))\n     {\n       strinfo *si = NULL;\n       tree rhs;\n \n       if (idx < 0)\n \trhs = build_int_cst (TREE_TYPE (lhs), ~idx);\n+      else if (idx == 0)\n+\trhs = bound;\n       else\n \t{\n \t  rhs = NULL_TREE;\n \t  si = get_strinfo (idx);\n \t  if (si != NULL)\n-\t    rhs = get_string_length (si);\n+\t    {\n+\t      rhs = get_string_length (si);\n+\t      /* For strnlen, if bound is constant, even if si is not known\n+\t\t to be zero terminated, if we know at least bound bytes are\n+\t\t not zero, the return value will be bound.  */\n+\t      if (rhs == NULL_TREE\n+\t\t  && bound != NULL_TREE\n+\t\t  && TREE_CODE (bound) == INTEGER_CST\n+\t\t  && si->nonzero_chars != NULL_TREE\n+\t\t  && TREE_CODE (si->nonzero_chars) == INTEGER_CST\n+\t\t  && tree_int_cst_le (bound, si->nonzero_chars))\n+\t\trhs = bound;\n+\t    }\n \t}\n       if (rhs != NULL_TREE)\n \t{\n@@ -1294,18 +1309,8 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t    rhs = fold_convert_loc (loc, TREE_TYPE (lhs), rhs);\n \n-\t  /* Set for strnlen() calls with a non-constant bound.  */\n-\t  bool noncst_bound = false;\n \t  if (bound)\n-\t    {\n-\t      tree new_rhs\n-\t\t= fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (rhs), rhs, bound);\n-\n-\t      noncst_bound = (TREE_CODE (new_rhs) != INTEGER_CST\n-\t\t\t      || tree_int_cst_lt (new_rhs, rhs));\n-\n-\t      rhs = new_rhs;\n-\t    }\n+\t    rhs = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (rhs), rhs, bound);\n \n \t  if (!update_call_from_tree (gsi, rhs))\n \t    gimplify_and_update_call_from_tree (gsi, rhs);\n@@ -1317,12 +1322,9 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t    }\n \n-\t  /* Avoid storing the length for calls to strnlen() with\n-\t     a non-constant bound.  */\n-\t  if (noncst_bound)\n-\t    return;\n-\n \t  if (si != NULL\n+\t      /* Don't update anything for strnlen.  */\n+\t      && bound == NULL_TREE\n \t      && TREE_CODE (si->nonzero_chars) != SSA_NAME\n \t      && TREE_CODE (si->nonzero_chars) != INTEGER_CST\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n@@ -1332,7 +1334,13 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t      gcc_assert (si->full_string_p);\n \t    }\n \n-\t  if (strlen_to_stridx)\n+\t  if (strlen_to_stridx\n+\t      && (bound == NULL_TREE\n+\t\t  /* For strnlen record this only if the call is proven\n+\t\t     to return the same value as strlen would.  */\n+\t\t  || (TREE_CODE (bound) == INTEGER_CST\n+\t\t      && TREE_CODE (rhs) == INTEGER_CST\n+\t\t      && tree_int_cst_lt (rhs, bound))))\n \t    strlen_to_stridx->put (lhs, stridx_strlenloc (idx, loc));\n \n \t  return;"}]}