{"sha": "1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE1NWFlMDE1OTNiMGI4NGNkZGY1MDMxYjdhODVkNjg0ZmUwZGQwZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-07T09:40:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-07T09:40:16Z"}, "message": "[multiple changes]\n\n2017-09-07  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.adb (Find_Role): The Global_Seen flag\n\tis now consulted not only for abstract states and variables,\n\tbut for all kinds of items.\n\t(Collect_Subprogram_Inputs_Outputs): Do not process formal\n\tgeneric parameters, because unlike ordinary formal parameters,\n\tgeneric formals only act as input/ outputs if they are explicitly\n\tmentioned in a Global contract.\n\n2017-09-07  Yannick Moy  <moy@adacore.com>\n\n\t* ghost.adb (Check_Ghost_Context): Do not err on ghost code inside\n\tpredicate procedure. Check predicate pragma/aspect with Ghost entity.\n\t* exp_ch6.adb, par-ch6.adb, sem_ch13.adb, sem_prag.adb; Minor\n\treformatting.\n\n2017-09-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb: Move New_Copy_Tree_And_Dimensions to sem_dim\n\t(code cleanup);\n\t* sem_ch3.adb (Build_Derived_Record_Type):i Call\n\tCopy_Dimensions_Of_Components after creating the copy of the\n\trecord declaration.\n\t* sem_dim.ads, sem_dim.adb (Copy_Dimensions_Of_Components): For a\n\tderived recor type, copy the dikensions if any of each component\n\tof the parent record to the corresponding component declarations\n\tof the derived record. These expressions are used among other\n\tthings as default values in aggregates with box associations.\n\t* a-dirval-mingw.adb, g-cgi.adb, gnatcmd.adb, lib-xref.adb,\n\trepinfo.adb, sem_attr.adb, sem_ch10.adb, sem_ch6.adb, sem_prag.adb:\n\tMinor reformatting.\n\n2017-09-07  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_util.adb: Remove extra space after THEN.\n\n2017-09-07  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch7.adb (Has_Referencer): For a subprogram renaming,\n\talso mark the renamed subprogram as referenced.\n\nFrom-SVN: r251836", "tree": {"sha": "317aae64851186240dd41fa497b899b1e385b800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/317aae64851186240dd41fa497b899b1e385b800"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/comments", "author": null, "committer": null, "parents": [{"sha": "0691ed6bd62582c22a33c42aa8f5303815a032af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0691ed6bd62582c22a33c42aa8f5303815a032af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0691ed6bd62582c22a33c42aa8f5303815a032af"}], "stats": {"total": 458, "additions": 304, "deletions": 154}, "files": [{"sha": "157743b204bc9ee32e60c4321e3a4ac05da178fe", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -1,3 +1,45 @@\n+2017-09-07  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.adb (Find_Role): The Global_Seen flag\n+\tis now consulted not only for abstract states and variables,\n+\tbut for all kinds of items.\n+\t(Collect_Subprogram_Inputs_Outputs): Do not process formal\n+\tgeneric parameters, because unlike ordinary formal parameters,\n+\tgeneric formals only act as input/ outputs if they are explicitly\n+\tmentioned in a Global contract.\n+\n+2017-09-07  Yannick Moy  <moy@adacore.com>\n+\n+\t* ghost.adb (Check_Ghost_Context): Do not err on ghost code inside\n+\tpredicate procedure. Check predicate pragma/aspect with Ghost entity.\n+\t* exp_ch6.adb, par-ch6.adb, sem_ch13.adb, sem_prag.adb; Minor\n+\treformatting.\n+\n+2017-09-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb: Move New_Copy_Tree_And_Dimensions to sem_dim\n+\t(code cleanup);\n+\t* sem_ch3.adb (Build_Derived_Record_Type):i Call\n+\tCopy_Dimensions_Of_Components after creating the copy of the\n+\trecord declaration.\n+\t* sem_dim.ads, sem_dim.adb (Copy_Dimensions_Of_Components): For a\n+\tderived recor type, copy the dikensions if any of each component\n+\tof the parent record to the corresponding component declarations\n+\tof the derived record. These expressions are used among other\n+\tthings as default values in aggregates with box associations.\n+\t* a-dirval-mingw.adb, g-cgi.adb, gnatcmd.adb, lib-xref.adb,\n+\trepinfo.adb, sem_attr.adb, sem_ch10.adb, sem_ch6.adb, sem_prag.adb:\n+\tMinor reformatting.\n+\n+2017-09-07  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_util.adb: Remove extra space after THEN.\n+\n+2017-09-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch7.adb (Has_Referencer): For a subprogram renaming,\n+\talso mark the renamed subprogram as referenced.\n+\n 2017-09-07  Ed Schonberg  <schonberg@adacore.com>\n \n \t* par-ch6.adb (P_Subprogram): Improve error message on null"}, {"sha": "b0a9cc35c1d95823cd5c2c7aaa1fd3772ba69cdf", "filename": "gcc/ada/a-dirval-mingw.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fa-dirval-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fa-dirval-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval-mingw.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                            (Windows Version)                             --\n --                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -75,7 +75,7 @@ package body Ada.Directories.Validity is\n          --  A drive letter may be specified at the beginning\n \n          if Name'Length >= 2\n-           and then  Name (Start + 1) = ':'\n+           and then Name (Start + 1) = ':'\n            and then\n              (Name (Start) in 'A' .. 'Z' or else Name (Start) in 'a' .. 'z')\n          then"}, {"sha": "908338fd28ed5abb80f6bc1da7ea576521c37180", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -137,7 +137,8 @@ package body Exp_Ch6 is\n    --  there are no tasks.\n \n    function Caller_Known_Size\n-     (Func_Call : Node_Id; Result_Subt : Entity_Id) return Boolean;\n+     (Func_Call   : Node_Id;\n+      Result_Subt : Entity_Id) return Boolean;\n    --  True if result subtype is definite, or has a size that does not require\n    --  secondary stack usage (i.e. no variant part or components whose type\n    --  depends on discriminants). In particular, untagged types with only\n@@ -837,11 +838,14 @@ package body Exp_Ch6 is\n    -----------------------\n \n    function Caller_Known_Size\n-     (Func_Call : Node_Id; Result_Subt : Entity_Id) return Boolean is\n+     (Func_Call   : Node_Id;\n+      Result_Subt : Entity_Id) return Boolean\n+   is\n    begin\n-      return (Is_Definite_Subtype (Underlying_Type (Result_Subt))\n-              and then No (Controlling_Argument (Func_Call)))\n-          or else not Requires_Transient_Scope (Underlying_Type (Result_Subt));\n+      return\n+          (Is_Definite_Subtype (Underlying_Type (Result_Subt))\n+            and then No (Controlling_Argument (Func_Call)))\n+        or else not Requires_Transient_Scope (Underlying_Type (Result_Subt));\n    end Caller_Known_Size;\n \n    --------------------------------\n@@ -8081,7 +8085,8 @@ package body Exp_Ch6 is\n \n       declare\n          Definite : constant Boolean :=\n-           Caller_Known_Size (Func_Call, Result_Subt);\n+                      Caller_Known_Size (Func_Call, Result_Subt);\n+\n       begin\n          --  Create an access type designating the function's result subtype.\n          --  We use the type of the original call because it may be a call to"}, {"sha": "9d658e69db21a32b40e14fd4d93246347e803cd9", "filename": "gcc/ada/g-cgi.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fg-cgi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fg-cgi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-cgi.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                      Copyright (C) 2001-2010, AdaCore                    --\n+--                      Copyright (C) 2001-2017, AdaCore                    --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -110,7 +110,7 @@ package body GNAT.CGI is\n    begin\n       while K <= S'Last loop\n          if K + 2 <= S'Last\n-           and then  S (K) = '%'\n+           and then S (K) = '%'\n            and then Characters.Handling.Is_Hexadecimal_Digit (S (K + 1))\n            and then Characters.Handling.Is_Hexadecimal_Digit (S (K + 2))\n          then"}, {"sha": "78ba5f3e13367c1bc27ab2c1db0d12e0bfa67266", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -281,6 +281,13 @@ package body Ghost is\n                   if Chars (Subp_Id) = Name_uPostconditions then\n                      return True;\n \n+                  --  The context is the internally built predicate function,\n+                  --  which is OK because the real check was done before the\n+                  --  predicate function was generated.\n+\n+                  elsif Is_Predicate_Function (Subp_Id) then\n+                     return True;\n+\n                   else\n                      Subp_Decl :=\n                        Original_Node (Unit_Declaration_Node (Subp_Id));\n@@ -362,10 +369,12 @@ package body Ghost is\n                   return True;\n \n                --  An assertion expression pragma is Ghost when it contains a\n-               --  reference to a Ghost entity (SPARK RM 6.9(10)).\n-\n-               elsif Assertion_Expression_Pragma (Prag_Id) then\n+               --  reference to a Ghost entity (SPARK RM 6.9(10)), except for\n+               --  predicate pragmas (SPARK RM 6.9(11)).\n \n+               elsif Assertion_Expression_Pragma (Prag_Id)\n+                 and then Prag_Id /= Pragma_Predicate\n+               then\n                   --  Ensure that the assertion policy and the Ghost policy are\n                   --  compatible (SPARK RM 6.9(18)).\n \n@@ -464,9 +473,16 @@ package body Ghost is\n                   return True;\n \n                --  A reference to a Ghost entity can appear within an aspect\n-               --  specification (SPARK RM 6.9(10)).\n-\n-               elsif Nkind (Par) = N_Aspect_Specification then\n+               --  specification (SPARK RM 6.9(10)). The precise checking will\n+               --  occur when analyzing the corresponding pragma. We make an\n+               --  exception for predicate aspects that only allow referencing\n+               --  a Ghost entity when the corresponding type declaration is\n+               --  Ghost (SPARK RM 6.9(11)).\n+\n+               elsif Nkind (Par) = N_Aspect_Specification\n+                 and then not Same_Aspect\n+                                (Get_Aspect_Id (Par), Aspect_Predicate)\n+               then\n                   return True;\n \n                elsif Is_OK_Declaration (Par) then"}, {"sha": "55f79c355dfea135d998aeae09e2aea7a3c4f845", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -573,9 +573,9 @@ begin\n       --  report an error indicating that the command is no longer supporting\n       --  project files.\n \n-      if The_Command = Find or else  The_Command = Xref then\n+      if The_Command = Find or else The_Command = Xref then\n          declare\n-            Argv    : String_Access;\n+            Argv : String_Access;\n          begin\n             for Arg_Num in 1 .. Last_Switches.Last loop\n                Argv := Last_Switches.Table (Arg_Num);"}, {"sha": "edc955b15b4884f98479c9f6b79d8e12bdee3461", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -1079,7 +1079,7 @@ package body Lib.Xref is\n          --  original discriminant, which gets the reference.\n \n          elsif Ekind (E) = E_In_Parameter\n-           and then  Present (Discriminal_Link (E))\n+           and then Present (Discriminal_Link (E))\n          then\n             Ent := Discriminal_Link (E);\n             Set_Referenced (Ent);\n@@ -2702,7 +2702,7 @@ package body Lib.Xref is\n                   if XE.Key.Loc /= No_Location\n                     and then\n                       (XE.Key.Loc /= Crloc\n-                        or else (Prevt = 'm' and then  XE.Key.Typ = 'r'))\n+                        or else (Prevt = 'm' and then XE.Key.Typ = 'r'))\n                   then\n                      Crloc := XE.Key.Loc;\n                      Prevt := XE.Key.Typ;"}, {"sha": "83bb25118a406eafd883f912da013a6d23b51d15", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -855,13 +855,14 @@ package body Ch6 is\n \n                   if Is_Non_Empty_List (Aspects) then\n                      if Func then\n-                        Error_Msg (\"aspect specifications must come after \"\n-                          & \"parenthesized expression\",\n-                            Sloc (First (Aspects)));\n+                        Error_Msg\n+                          (\"aspect specifications must come after \"\n+                           & \"parenthesized expression\",\n+                           Sloc (First (Aspects)));\n                      else\n-                        Error_Msg (\"aspect specifications must come after \"\n-                          & \"subprogram specification\",\n-                            Sloc (First (Aspects)));\n+                        Error_Msg\n+                          (\"aspect specifications must come after subprogram \"\n+                           & \"specification\", Sloc (First (Aspects)));\n                      end if;\n                   end if;\n "}, {"sha": "57528d6069730f1fc3a545cb4dba3a0667201909", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -341,7 +341,7 @@ package body Repinfo is\n       begin\n          Decl := Parent (E);\n          while Present (Decl)\n-           and then  Nkind (Decl) /= N_Package_Body\n+           and then Nkind (Decl) /= N_Package_Body\n            and then Nkind (Decl) /= N_Subprogram_Declaration\n            and then Nkind (Decl) /= N_Subprogram_Body\n          loop"}, {"sha": "a7269048246393a334eed416d93acebeb05dc6c4", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -3279,14 +3279,6 @@ package body Sem_Aggr is\n       --  An error message is emitted if the components taking their value from\n       --  the others choice do not have same type.\n \n-      function New_Copy_Tree_And_Copy_Dimensions\n-        (Source    : Node_Id;\n-         Map       : Elist_Id   := No_Elist;\n-         New_Sloc  : Source_Ptr := No_Location;\n-         New_Scope : Entity_Id  := Empty) return Node_Id;\n-      --  Same as New_Copy_Tree (defined in Sem_Util), except that this routine\n-      --  also copies the dimensions of Source to the returned node.\n-\n       procedure Propagate_Discriminants\n         (Aggr       : Node_Id;\n          Assoc_List : List_Id);\n@@ -3733,26 +3725,6 @@ package body Sem_Aggr is\n          return Expr;\n       end Get_Value;\n \n-      ---------------------------------------\n-      -- New_Copy_Tree_And_Copy_Dimensions --\n-      ---------------------------------------\n-\n-      function New_Copy_Tree_And_Copy_Dimensions\n-        (Source    : Node_Id;\n-         Map       : Elist_Id   := No_Elist;\n-         New_Sloc  : Source_Ptr := No_Location;\n-         New_Scope : Entity_Id  := Empty) return Node_Id\n-      is\n-         New_Copy : constant Node_Id :=\n-                      New_Copy_Tree (Source, Map, New_Sloc, New_Scope);\n-\n-      begin\n-         --  Move the dimensions of Source to New_Copy\n-\n-         Copy_Dimensions (Source, New_Copy);\n-         return New_Copy;\n-      end New_Copy_Tree_And_Copy_Dimensions;\n-\n       -----------------------------\n       -- Propagate_Discriminants --\n       -----------------------------"}, {"sha": "09ca1fd0f7fe52aa09858cd47a79b31801a10890", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -3556,7 +3556,7 @@ package body Sem_Attr is\n \n          elsif Nkind (P) = N_Indexed_Component then\n             if not Is_Entity_Name (Prefix (P))\n-              or else  No (Entity (Prefix (P)))\n+              or else No (Entity (Prefix (P)))\n               or else Ekind (Entity (Prefix (P))) /= E_Entry_Family\n             then\n                if Nkind (Prefix (P)) = N_Selected_Component"}, {"sha": "332863966aac004f8c91e3dc95ea6391849b93fa", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -1748,7 +1748,7 @@ package body Sem_Ch10 is\n             --  body may not be available, in which case do not try analysis.\n \n             if Serious_Errors_Detected > 0\n-              and then  No (Library_Unit (Library_Unit (N)))\n+              and then No (Library_Unit (Library_Unit (N)))\n             then\n                return;\n             end if;\n@@ -2129,7 +2129,7 @@ package body Sem_Ch10 is\n                      --  attempt processing.\n \n                      if Serious_Errors_Detected > 0\n-                       and then  No (Entity (Name (Item)))\n+                       and then No (Entity (Name (Item)))\n                      then\n                         Set_Entity (Name (Item), Standard_Standard);\n                      end if;"}, {"sha": "124a4af08ea52dafc5c08b37095205625de07e8b", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -12649,7 +12649,6 @@ package body Sem_Ch13 is\n    --------------------------------\n \n    procedure Resolve_Aspect_Expressions (E : Entity_Id) is\n-\n       function Resolve_Name (N : Node_Id) return Traverse_Result;\n       --  Verify that all identifiers in the expression, with the exception\n       --  of references to the current entity, denote visible entities. This\n@@ -12668,6 +12667,7 @@ package body Sem_Ch13 is\n \n       function Resolve_Name (N : Node_Id) return Traverse_Result is\n          Dummy : Traverse_Result;\n+\n       begin\n          if Nkind (N) = N_Selected_Component then\n             if Nkind (Prefix (N)) = N_Identifier\n@@ -12700,6 +12700,8 @@ package body Sem_Ch13 is\n \n       procedure Resolve_Aspect_Expression is new Traverse_Proc (Resolve_Name);\n \n+      --  Local variables\n+\n       ASN : Node_Id := First_Rep_Item (E);\n \n    --  Start of processing for Resolve_Aspect_Expressions"}, {"sha": "41bf2a8671c534866ce391370d12014c15551778", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -9352,6 +9352,7 @@ package body Sem_Ch3 is\n          New_Decl :=\n            New_Copy_Tree\n              (Parent (Parent_Base), Map => Assoc_List, New_Sloc => Loc);\n+         Copy_Dimensions_Of_Components (Derived_Type);\n \n          --  Restore the fields saved prior to the New_Copy_Tree call\n          --  and compute the stored constraint.\n@@ -11883,7 +11884,7 @@ package body Sem_Ch3 is\n          --  or protected interfaces.\n \n          elsif Nkind (N) = N_Full_Type_Declaration\n-           and then  Protected_Present (Type_Def)\n+           and then Protected_Present (Type_Def)\n          then\n             if Limited_Present (Iface_Def)\n               or else Synchronized_Present (Iface_Def)\n@@ -16795,7 +16796,7 @@ package body Sem_Ch3 is\n \n    procedure Diagnose_Interface (N : Node_Id;  E : Entity_Id) is\n    begin\n-      if not Is_Interface (E) and then  E /= Any_Type then\n+      if not Is_Interface (E) and then E /= Any_Type then\n          Error_Msg_NE (\"(Ada 2005) & must be an interface\", N, E);\n       end if;\n    end Diagnose_Interface;\n@@ -21450,7 +21451,7 @@ package body Sem_Ch3 is\n                Constrain_Access (Def_Id, S, Related_Nod);\n \n                if Expander_Active\n-                 and then  Is_Itype (Designated_Type (Def_Id))\n+                 and then Is_Itype (Designated_Type (Def_Id))\n                  and then Nkind (Related_Nod) = N_Subtype_Declaration\n                  and then not Is_Incomplete_Type (Designated_Type (Def_Id))\n                then"}, {"sha": "16f4f340b68bb94209132f45d6d7e053dae27077", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -439,6 +439,23 @@ package body Sem_Ch7 is\n                   then\n                      Set_Is_Public (Decl_Id, False);\n                   end if;\n+\n+                  --  For a subprogram renaming, if the entity is referenced,\n+                  --  then so is the renamed subprogram. But there is an issue\n+                  --  with generic bodies because instantiations are not done\n+                  --  yet and, therefore, cannot be scanned for referencers.\n+                  --  That's why we use an approximation and test that we have\n+                  --  at least one subprogram referenced by an inlined body\n+                  --  instead of precisely the entity of this renaming.\n+\n+                  if Nkind (Decl) = N_Subprogram_Renaming_Declaration\n+                    and then Subprogram_Table.Get_First\n+                    and then Is_Entity_Name (Name (Decl))\n+                    and then Present (Entity (Name (Decl)))\n+                    and then Is_Subprogram (Entity (Name (Decl)))\n+                  then\n+                     Subprogram_Table.Set (Entity (Name (Decl)), True);\n+                  end if;\n                end if;\n \n                Prev (Decl);"}, {"sha": "6aae74b8ec86f7a97bef2d9b819d7624b0a15d5d", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -2405,6 +2405,25 @@ package body Sem_Dim is\n       end if;\n    end Copy_Dimensions;\n \n+   -----------------------------------\n+   -- Copy_Dimensions_Of_Components --\n+   -----------------------------------\n+\n+   procedure Copy_Dimensions_Of_Components (Rec : Entity_Id) is\n+      C : Entity_Id;\n+\n+   begin\n+      C := First_Component (Rec);\n+      while Present (C) loop\n+         if Nkind (Parent (C)) = N_Component_Declaration then\n+            Copy_Dimensions\n+              (Expression (Parent (Corresponding_Record_Component (C))),\n+               Expression (Parent (C)));\n+         end if;\n+         Next_Component (C);\n+      end loop;\n+   end Copy_Dimensions_Of_Components;\n+\n    --------------------------\n    -- Create_Rational_From --\n    --------------------------\n@@ -3483,6 +3502,26 @@ package body Sem_Dim is\n       Remove_Dimensions (From);\n    end Move_Dimensions;\n \n+   ---------------------------------------\n+   -- New_Copy_Tree_And_Copy_Dimensions --\n+   ---------------------------------------\n+\n+   function New_Copy_Tree_And_Copy_Dimensions\n+     (Source    : Node_Id;\n+      Map       : Elist_Id   := No_Elist;\n+      New_Sloc  : Source_Ptr := No_Location;\n+      New_Scope : Entity_Id  := Empty) return Node_Id\n+   is\n+      New_Copy : constant Node_Id :=\n+                   New_Copy_Tree (Source, Map, New_Sloc, New_Scope);\n+\n+   begin\n+      --  Move the dimensions of Source to New_Copy\n+\n+      Copy_Dimensions (Source, New_Copy);\n+      return New_Copy;\n+   end New_Copy_Tree_And_Copy_Dimensions;\n+\n    ------------\n    -- Reduce --\n    ------------"}, {"sha": "9452d7a84fb845a99b8ec968b43a40af04730caa", "filename": "gcc/ada/sem_dim.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.ads?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -189,6 +189,20 @@ package Sem_Dim is\n    --  node that is allowed to contain a dimension (see OK_For_Dimension in\n    --  body of Sem_Dim).\n \n+   procedure Copy_Dimensions_Of_Components (Rec : Entity_Id);\n+   --  Propagate the dimensions of the components of a record type T to the\n+   --  components of a record type derived from T. The derivation creates\n+   --  a full copy of the type declaration of the parent, and the dimension\n+   --  information of individual components must be transferred explicitly.\n+\n+   function New_Copy_Tree_And_Copy_Dimensions\n+     (Source    : Node_Id;\n+      Map       : Elist_Id   := No_Elist;\n+      New_Sloc  : Source_Ptr := No_Location;\n+      New_Scope : Entity_Id  := Empty) return Node_Id;\n+   --  Same as New_Copy_Tree (defined in Sem_Util), except that this routine\n+   --  also copies the dimensions of Source to the returned node.\n+\n    function Dimensions_Match (T1 : Entity_Id; T2 : Entity_Id) return Boolean;\n    --  If the common base type has a dimension system, verify that two\n    --  subtypes have the same dimensions. Used for conformance checking."}, {"sha": "6d838b3697c3d89213478c22a5c8a7d2895949f0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 132, "deletions": 91, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -1205,126 +1205,173 @@ package body Sem_Prag is\n             Item_Is_Output : out Boolean)\n          is\n          begin\n-            Item_Is_Input  := False;\n-            Item_Is_Output := False;\n+            case Ekind (Item_Id) is\n \n-            --  Abstract states\n+               --  Abstract states\n \n-            if Ekind (Item_Id) = E_Abstract_State then\n+               when E_Abstract_State =>\n \n-               --  When pragma Global is present, the mode of the state may be\n-               --  further constrained by setting a more restrictive mode.\n+                  --  When pragma Global is present it determines the mode of\n+                  --  the abstract state.\n \n-               if Global_Seen then\n-                  if Appears_In (Subp_Inputs, Item_Id) then\n-                     Item_Is_Input := True;\n-                  end if;\n+                  if Global_Seen then\n+                     Item_Is_Input  := Appears_In (Subp_Inputs, Item_Id);\n+                     Item_Is_Output := Appears_In (Subp_Outputs, Item_Id);\n+\n+                  --  Otherwise the state has a default IN OUT mode, because it\n+                  --  behaves as a variable.\n \n-                  if Appears_In (Subp_Outputs, Item_Id) then\n+                  else\n+                     Item_Is_Input  := True;\n                      Item_Is_Output := True;\n                   end if;\n \n-               --  Otherwise the state has a default IN OUT mode\n+               --  Constants and IN parameters\n \n-               else\n-                  Item_Is_Input  := True;\n-                  Item_Is_Output := True;\n-               end if;\n+               when E_Constant\n+                  | E_Generic_In_Parameter\n+                  | E_In_Parameter\n+                  | E_Loop_Parameter\n+               =>\n+                  --  When pragma Global is present it determines the mode\n+                  --  of constant objects as inputs (and such objects cannot\n+                  --  appear as outputs in the Global contract).\n \n-            --  Constants\n+                  if Global_Seen then\n+                     Item_Is_Input := Appears_In (Subp_Inputs, Item_Id);\n+                  else\n+                     Item_Is_Input := True;\n+                  end if;\n \n-            elsif Ekind_In (Item_Id, E_Constant,\n-                                     E_Loop_Parameter)\n-            then\n-               Item_Is_Input := True;\n+                  Item_Is_Output := False;\n \n-            --  Parameters\n+               --  Variables and IN OUT parameters\n \n-            elsif Ekind_In (Item_Id, E_Generic_In_Parameter,\n-                                     E_In_Parameter)\n-            then\n-               Item_Is_Input := True;\n+               when E_Generic_In_Out_Parameter\n+                  | E_In_Out_Parameter\n+                  | E_Variable\n+               =>\n+                  --  When pragma Global is present it determines the mode of\n+                  --  the object.\n \n-            elsif Ekind_In (Item_Id, E_Generic_In_Out_Parameter,\n-                                     E_In_Out_Parameter)\n-            then\n-               Item_Is_Input  := True;\n-               Item_Is_Output := True;\n+                  if Global_Seen then\n \n-            elsif Ekind (Item_Id) = E_Out_Parameter then\n-               if Scope (Item_Id) = Spec_Id then\n+                     --  A variable has mode IN when its type is unconstrained\n+                     --  or tagged because array bounds, discriminants or tags\n+                     --  can be read.\n \n-                  --  An OUT parameter of the related subprogram has mode IN\n-                  --  if its type is unconstrained or tagged because array\n-                  --  bounds, discriminants or tags can be read.\n+                     Item_Is_Input :=\n+                       Appears_In (Subp_Inputs, Item_Id)\n+                         or else Is_Unconstrained_Or_Tagged_Item (Item_Id);\n \n-                  if Is_Unconstrained_Or_Tagged_Item (Item_Id) then\n-                     Item_Is_Input := True;\n+                     Item_Is_Output := Appears_In (Subp_Outputs, Item_Id);\n+\n+                  --  Otherwise the variable has a default IN OUT mode\n+\n+                  else\n+                     Item_Is_Input  := True;\n+                     Item_Is_Output := True;\n                   end if;\n \n-                  Item_Is_Output := True;\n+               when E_Out_Parameter =>\n \n-               --  An OUT parameter of an enclosing subprogram behaves as a\n-               --  read-write variable in which case the mode is IN OUT.\n+                  --  An OUT parameter of the related subprogram; it cannot\n+                  --  appear in Global.\n \n-               else\n-                  Item_Is_Input  := True;\n-                  Item_Is_Output := True;\n-               end if;\n+                  if Scope (Item_Id) = Spec_Id then\n \n-            --  Protected types\n+                     --  The parameter has mode IN if its type is unconstrained\n+                     --  or tagged because array bounds, discriminants or tags\n+                     --  can be read.\n \n-            elsif Ekind (Item_Id) = E_Protected_Type then\n+                     Item_Is_Input :=\n+                       Is_Unconstrained_Or_Tagged_Item (Item_Id);\n \n-               --  A protected type acts as a formal parameter of mode IN when\n-               --  it applies to a protected function.\n+                     Item_Is_Output := True;\n \n-               if Ekind (Spec_Id) = E_Function then\n-                  Item_Is_Input := True;\n+                  --  An OUT parameter of an enclosing subprogram; it can\n+                  --  appear in Global and behaves as a read-write variable.\n \n-               --  Otherwise the protected type acts as a formal of mode IN OUT\n+                  else\n+                     --  When pragma Global is present it determines the mode\n+                     --  of the object.\n \n-               else\n-                  Item_Is_Input  := True;\n-                  Item_Is_Output := True;\n-               end if;\n+                     if Global_Seen then\n \n-            --  Task types\n+                        --  A variable has mode IN when its type is\n+                        --  unconstrained or tagged because array\n+                        --  bounds, discriminants or tags can be read.\n \n-            elsif Ekind (Item_Id) = E_Task_Type then\n-               Item_Is_Input  := True;\n-               Item_Is_Output := True;\n+                        Item_Is_Input :=\n+                          Appears_In (Subp_Inputs, Item_Id)\n+                            or else Is_Unconstrained_Or_Tagged_Item (Item_Id);\n \n-            --  Variable case\n+                        Item_Is_Output := Appears_In (Subp_Outputs, Item_Id);\n \n-            else pragma Assert (Ekind (Item_Id) = E_Variable);\n+                     --  Otherwise the variable has a default IN OUT mode\n \n-               --  When pragma Global is present, the mode of the variable may\n-               --  be further constrained by setting a more restrictive mode.\n+                     else\n+                        Item_Is_Input  := True;\n+                        Item_Is_Output := True;\n+                     end if;\n+                  end if;\n \n-               if Global_Seen then\n+               --  Protected types\n \n-                  --  A variable has mode IN when its type is unconstrained or\n-                  --  tagged because array bounds, discriminants or tags can be\n-                  --  read.\n+               when E_Protected_Type =>\n+                  if Global_Seen then\n \n-                  if Appears_In (Subp_Inputs, Item_Id)\n-                    or else Is_Unconstrained_Or_Tagged_Item (Item_Id)\n-                  then\n-                     Item_Is_Input := True;\n+                     --  A variable has mode IN when its type is unconstrained\n+                     --  or tagged because array bounds, discriminants or tags\n+                     --  can be read.\n+\n+                     Item_Is_Input :=\n+                       Appears_In (Subp_Inputs, Item_Id)\n+                         or else Is_Unconstrained_Or_Tagged_Item (Item_Id);\n+\n+                     Item_Is_Output := Appears_In (Subp_Outputs, Item_Id);\n+\n+                  else\n+                     --  A protected type acts as a formal parameter of mode IN\n+                     --  when it applies to a protected function.\n+\n+                     if Ekind (Spec_Id) = E_Function then\n+                        Item_Is_Input  := True;\n+                        Item_Is_Output := False;\n+\n+                     --  Otherwise the protected type acts as a formal of mode\n+                     --  IN OUT.\n+\n+                     else\n+                        Item_Is_Input  := True;\n+                        Item_Is_Output := True;\n+                     end if;\n                   end if;\n \n-                  if Appears_In (Subp_Outputs, Item_Id) then\n+               --  Task types\n+\n+               when E_Task_Type =>\n+\n+                  --  When pragma Global is present it determines the mode of\n+                  --  the object.\n+\n+                  if Global_Seen then\n+                     Item_Is_Input :=\n+                       Appears_In (Subp_Inputs, Item_Id)\n+                         or else Is_Unconstrained_Or_Tagged_Item (Item_Id);\n+\n+                     Item_Is_Output := Appears_In (Subp_Outputs, Item_Id);\n+\n+                  --  Otherwise task types act as IN OUT parameters\n+\n+                  else\n+                     Item_Is_Input  := True;\n                      Item_Is_Output := True;\n                   end if;\n \n-               --  Otherwise the variable has a default IN OUT mode\n-\n-               else\n-                  Item_Is_Input  := True;\n-                  Item_Is_Output := True;\n-               end if;\n-            end if;\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n          end Find_Role;\n \n          ----------------\n@@ -5069,7 +5116,7 @@ package body Sem_Prag is\n                --  pragma is inserted in its declarative part.\n \n                elsif From_Aspect_Specification (N)\n-                 and then  Ent = Current_Scope\n+                 and then Ent = Current_Scope\n                  and then\n                    Nkind (Unit_Declaration_Node (Ent)) = N_Subprogram_Body\n                then\n@@ -28300,7 +28347,7 @@ package body Sem_Prag is\n          if Nkind (Clause) = N_Null then\n             null;\n \n-         --  A dependency cause appears as component association\n+         --  A dependency clause appears as component association\n \n          elsif Nkind (Clause) = N_Component_Association then\n             Collect_Dependency_Item\n@@ -28424,21 +28471,15 @@ package body Sem_Prag is\n          Subp_Decl := Unit_Declaration_Node (Subp_Id);\n          Spec_Id   := Unique_Defining_Entity (Subp_Decl);\n \n-         --  Process all [generic] formal parameters\n+         --  Process all formal parameters\n \n          Formal := First_Entity (Spec_Id);\n          while Present (Formal) loop\n-            if Ekind_In (Formal, E_Generic_In_Parameter,\n-                                 E_In_Out_Parameter,\n-                                 E_In_Parameter)\n-            then\n+            if Ekind_In (Formal, E_In_Out_Parameter, E_In_Parameter) then\n                Append_New_Elmt (Formal, Subp_Inputs);\n             end if;\n \n-            if Ekind_In (Formal, E_Generic_In_Out_Parameter,\n-                                 E_In_Out_Parameter,\n-                                 E_Out_Parameter)\n-            then\n+            if Ekind_In (Formal, E_In_Out_Parameter, E_Out_Parameter) then\n                Append_New_Elmt (Formal, Subp_Outputs);\n \n                --  Out parameters can act as inputs when the related type is"}, {"sha": "5ea7b0b8b0337518e0898de96d6166e554781f63", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1155ae01593b0b84cddf5031b7a85d684fe0dd0d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1155ae01593b0b84cddf5031b7a85d684fe0dd0d", "patch": "@@ -764,7 +764,7 @@ package body Sem_Util is\n \n       if Inside_A_Generic then\n          Gen := Current_Scope;\n-         while Present (Gen) and then  Ekind (Gen) /= E_Generic_Package loop\n+         while Present (Gen) and then Ekind (Gen) /= E_Generic_Package loop\n             Gen := Scope (Gen);\n          end loop;\n "}]}