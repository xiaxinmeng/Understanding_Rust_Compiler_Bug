{"sha": "d3306a84a6cc954ff9d28d8a915a891fe15270f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMzMDZhODRhNmNjOTU0ZmY5ZDI4ZDhhOTE1YTg5MWZlMTUyNzBmNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-11-13T22:57:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-11-13T22:57:48Z"}, "message": "Fix incorrect assertion when deallocating big block\n\nSince a big_block rounds up the size to a multiple of big_block::min it\nis wrong to assert that the supplied number of bytes equals the\nbig_block's size(). Add big_block::alloc_size(size_t) to calculate the\nallocated size consistently, and add comments to the code.\n\n\t* src/c++17/memory_resource.cc (big_block): Improve comments.\n\t(big_block::all_ones): Remove.\n\t(big_block::big_block(size_t, size_t)): Use alloc_size.\n\t(big_block::size()): Add comment, replace all_ones with equivalent\n\texpression.\n\t(big_block::align()): Shift value of correct type.\n\t(big_block::alloc_size(size_t)): New function to round up size.\n\t(__pool_resource::allocate(size_t, size_t)): Add comment.\n\t(__pool_resource::deallocate(void*, size_t, size_t)): Likewise. Fix\n\tincorrect assertion by using big_block::alloc_size(size_t).\n\t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc: Add\n\tmore tests for unpooled allocations.\n\nFrom-SVN: r266088", "tree": {"sha": "5c1a34d3f20bf1fa6257f6e8a0b1c51e3dc04f6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c1a34d3f20bf1fa6257f6e8a0b1c51e3dc04f6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3306a84a6cc954ff9d28d8a915a891fe15270f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3306a84a6cc954ff9d28d8a915a891fe15270f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3306a84a6cc954ff9d28d8a915a891fe15270f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3306a84a6cc954ff9d28d8a915a891fe15270f5/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdd58f73a33cceba4da5966c17c356ecc22b0c6"}], "stats": {"total": 147, "additions": 133, "deletions": 14}, "files": [{"sha": "9b6a72d3104080112e0ef51b4aba05de0f998b5d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3306a84a6cc954ff9d28d8a915a891fe15270f5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3306a84a6cc954ff9d28d8a915a891fe15270f5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d3306a84a6cc954ff9d28d8a915a891fe15270f5", "patch": "@@ -1,5 +1,18 @@\n 2018-11-13  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* src/c++17/memory_resource.cc (big_block): Improve comments.\n+\t(big_block::all_ones): Remove.\n+\t(big_block::big_block(size_t, size_t)): Use alloc_size.\n+\t(big_block::size()): Add comment, replace all_ones with equivalent\n+\texpression.\n+\t(big_block::align()): Shift value of correct type.\n+\t(big_block::alloc_size(size_t)): New function to round up size.\n+\t(__pool_resource::allocate(size_t, size_t)): Add comment.\n+\t(__pool_resource::deallocate(void*, size_t, size_t)): Likewise. Fix\n+\tincorrect assertion by using big_block::alloc_size(size_t).\n+\t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc: Add\n+\tmore tests for unpooled allocations.\n+\n \t* src/c++17/memory_resource.cc (bitset::full()): Handle edge case\n \tfor _M_next_word maximum value.\n \t(bitset::get_first_unset(), bitset::set(size_type)): Use"}, {"sha": "719cb9f1d29327131f96a0ab7d870b8424f534b4", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3306a84a6cc954ff9d28d8a915a891fe15270f5/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3306a84a6cc954ff9d28d8a915a891fe15270f5/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=d3306a84a6cc954ff9d28d8a915a891fe15270f5", "patch": "@@ -537,36 +537,49 @@ namespace pmr\n   // An oversized allocation that doesn't fit in a pool.\n   struct big_block\n   {\n+    // Alignment must be a power-of-two so we only need to use enough bits\n+    // to store the power, not the actual value:\n     static constexpr unsigned _S_alignbits\n-      = std::__log2p1((unsigned)numeric_limits<size_t>::digits) - 1;\n+      = std::__log2p1((unsigned)numeric_limits<size_t>::digits - 1);\n+    // Use the remaining bits to store the size:\n     static constexpr unsigned _S_sizebits\n       = numeric_limits<size_t>::digits - _S_alignbits;\n     // The maximum value that can be stored in _S_size\n-    static constexpr size_t all_ones = (1ull << _S_sizebits) - 1u;\n-    // The minimum size of a big block\n+    static constexpr size_t all_ones = size_t(-1) >> _S_alignbits;\n+    // The minimum size of a big block (smaller sizes will be rounded up).\n     static constexpr size_t min = 1u << _S_alignbits;\n \n     big_block(size_t bytes, size_t alignment)\n-    : _M_size((bytes + min - 1u) >> _S_alignbits),\n+    : _M_size(alloc_size(bytes) >> _S_alignbits),\n       _M_align_exp(std::__log2p1(alignment) - 1u)\n-    {\n-      if (__builtin_expect(std::__countl_one(bytes) == _S_sizebits, false))\n-\t_M_size = all_ones;\n-    }\n+    { }\n \n     void* pointer = nullptr;\n     size_t _M_size : numeric_limits<size_t>::digits - _S_alignbits;\n     size_t _M_align_exp : _S_alignbits;\n \n     size_t size() const noexcept\n     {\n-      if (__builtin_expect(_M_size == all_ones, false))\n+      // If all bits are set in _M_size it means the maximum possible size:\n+      if (__builtin_expect(_M_size == (size_t(-1) >> _S_alignbits), false))\n \treturn (size_t)-1;\n       else\n \treturn _M_size << _S_alignbits;\n     }\n \n-    size_t align() const noexcept { return 1ul << _M_align_exp; }\n+    size_t align() const noexcept { return size_t(1) << _M_align_exp; }\n+\n+    // Calculate size to be allocated instead of requested number of bytes.\n+    // The requested value will be rounded up to a multiple of big_block::min,\n+    // so the low _S_alignbits bits are all zero and don't need to be stored.\n+    static constexpr size_t alloc_size(size_t bytes) noexcept\n+    {\n+      const size_t s = bytes + min - 1u;\n+      if (__builtin_expect(s < bytes, false))\n+\treturn size_t(-1); // addition wrapped past zero, return max value\n+      else\n+\treturn s & ~(min - 1u);\n+    }\n \n     friend bool operator<(void* p, const big_block& b) noexcept\n     { return less<void*>{}(p, b.pointer); }\n@@ -915,6 +928,7 @@ namespace pmr\n   {\n     auto& b = _M_unpooled.emplace_back(bytes, alignment);\n     __try {\n+      // N.B. need to allocate b.size(), which might be larger than bytes.\n       void* p = resource()->allocate(b.size(), alignment);\n       b.pointer = p;\n       if (_M_unpooled.size() > 1)\n@@ -932,18 +946,18 @@ namespace pmr\n   }\n \n   void\n-  __pool_resource::deallocate(void* p, size_t bytes [[maybe_unused]],\n-\t\t\t      size_t alignment [[maybe_unused]])\n+  __pool_resource::deallocate(void* p, size_t bytes, size_t alignment)\n   {\n     const auto it\n       = std::lower_bound(_M_unpooled.begin(), _M_unpooled.end(), p);\n     __glibcxx_assert(it != _M_unpooled.end() && it->pointer == p);\n     if (it != _M_unpooled.end() && it->pointer == p) // [[likely]]\n       {\n \tconst auto b = *it;\n-\t__glibcxx_assert(b.size() == bytes);\n+\t__glibcxx_assert(b.size() == b.alloc_size(bytes));\n \t__glibcxx_assert(b.align() == alignment);\n \t_M_unpooled.erase(it);\n+\t// N.B. need to deallocate b.size(), which might be larger than bytes.\n \tresource()->deallocate(p, b.size(), b.align());\n       }\n   }"}, {"sha": "749655b63c75de60f596601ef66b144065f21825", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3306a84a6cc954ff9d28d8a915a891fe15270f5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3306a84a6cc954ff9d28d8a915a891fe15270f5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc?ref=d3306a84a6cc954ff9d28d8a915a891fe15270f5", "patch": "@@ -128,7 +128,8 @@ test03()\n void\n test04()\n {\n-  std::pmr::unsynchronized_pool_resource r({256, 256});\n+  __gnu_test::memory_resource test_mr;\n+  std::pmr::unsynchronized_pool_resource r({256, 256}, &test_mr);\n   // Check alignment\n   void* p1 = r.allocate(2, 64);\n   VERIFY( (std::uintptr_t)p1 % 64 == 0 );\n@@ -145,11 +146,102 @@ test04()\n   r.deallocate(p4, 2 * largest_pool, 1024);\n }\n \n+void\n+test05()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  std::pmr::pool_options opts{};\n+  opts.max_blocks_per_chunk = 1;\n+  opts.largest_required_pool_block = 1;\n+  std::pmr::unsynchronized_pool_resource r(opts, &test_mr);\n+  opts = r.options();\n+  // Test unpooled allocations\n+  void** p = new void*[opts.largest_required_pool_block];\n+  for (unsigned a : {64, 128, 256, 512})\n+  {\n+    for (unsigned i = 0; i < opts.largest_required_pool_block; ++i)\n+      p[i] = r.allocate(i, a);\n+    for (unsigned i = 0; i < opts.largest_required_pool_block; ++i)\n+      r.deallocate(p[i], i, a);\n+  }\n+  delete[] p;\n+}\n+\n+void\n+test06()\n+{\n+  struct custom_mr : std::pmr::memory_resource\n+  {\n+    size_t expected_size = 0;\n+    size_t expected_alignment = 0;\n+\n+    struct bad_size { };\n+    struct bad_alignment { };\n+\n+    void* do_allocate(std::size_t b, std::size_t a)\n+    {\n+      if (expected_size != 0)\n+      {\n+\tif (b < expected_size)\n+\t  throw bad_size();\n+\telse if (a != expected_alignment)\n+\t  throw bad_alignment();\n+\t// Else just throw, don't try to allocate:\n+\tthrow std::bad_alloc();\n+      }\n+\n+      return std::pmr::new_delete_resource()->allocate(b, a);\n+    }\n+\n+    void do_deallocate(void* p, std::size_t b, std::size_t a)\n+    { std::pmr::new_delete_resource()->deallocate(p, b, a); }\n+\n+    bool do_is_equal(const memory_resource& r) const noexcept\n+    { return false; }\n+  };\n+\n+  custom_mr c;\n+  std::pmr::unsynchronized_pool_resource r({1, 1}, &c);\n+  std::pmr::pool_options opts = r.options();\n+  const std::size_t largest_pool = opts.largest_required_pool_block;\n+  const std::size_t large_alignment = 1024;\n+  // Ensure allocations won't fit in pools:\n+  VERIFY( largest_pool < large_alignment );\n+\n+  // Ensure the vector of large allocations has some capacity\n+  // and won't need to reallocate:\n+  r.deallocate(r.allocate(largest_pool + 1, 1), largest_pool + 1, 1);\n+\n+  // Try allocating various very large sizes and ensure the size requested\n+  // from the upstream allocator is at least as large as needed.\n+  for (int i = 1; i < 64; ++i)\n+  {\n+    for (auto b : { -1, 0, 1, 3 })\n+    {\n+      std::size_t bytes = std::size_t(1) << i;\n+      bytes += b;\n+      c.expected_size = bytes;\n+      c.expected_alignment = large_alignment;\n+      try {\n+\t(void) r.allocate(bytes, large_alignment);\n+      } catch (const std::bad_alloc&) {\n+\t// expect to catch bad_alloc\n+      } catch (custom_mr::bad_size) {\n+\tVERIFY(false);\n+      } catch (custom_mr::bad_alignment) {\n+\tVERIFY(false);\n+      }\n+    }\n+  }\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n   test04();\n+  test05();\n+  test06();\n }"}]}