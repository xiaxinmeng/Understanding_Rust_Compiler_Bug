{"sha": "aa4648eef474d7827b9ccf948ad4de128783e171", "node_id": "C_kwDOANBUbNoAKGFhNDY0OGVlZjQ3NGQ3ODI3YjljY2Y5NDhhZDRkZTEyODc4M2UxNzE", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-08-02T23:18:08Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-01T06:13:36Z"}, "message": "[Ada] Fix bug in inherited user-defined-literal aspects for tagged types\n\ngcc/ada/\n\n\t* sem_res.adb (Resolve): Two separate fixes. In the case where\n\tFind_Aspect for a literal aspect returns the aspect for a\n\tdifferent (ancestor) type, call Corresponding_Primitive_Op to\n\tget the right callee. In the case where a downward tagged type\n\tconversion appears to be needed, generate a null extension\n\taggregate instead, as per Ada RM 3.4(27).\n\t* sem_util.ads, sem_util.adb: Add new Corresponding_Primitive_Op\n\tfunction. It maps a primitive op of a tagged type and a\n\tdescendant type of that tagged type to the corresponding\n\tprimitive op of the descendant type. The body of this function\n\twas written by Javier Miranda.", "tree": {"sha": "73385a605f8ed74946f949e50943ca214a414422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73385a605f8ed74946f949e50943ca214a414422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4648eef474d7827b9ccf948ad4de128783e171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4648eef474d7827b9ccf948ad4de128783e171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4648eef474d7827b9ccf948ad4de128783e171", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4648eef474d7827b9ccf948ad4de128783e171/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6fe12b0a9a375e655945ff385810661d8bb494c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6fe12b0a9a375e655945ff385810661d8bb494c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6fe12b0a9a375e655945ff385810661d8bb494c"}], "stats": {"total": 115, "additions": 106, "deletions": 9}, "files": [{"sha": "7b9f8ab48d8ee32648b9113f7fb3d7ef008153f7", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4648eef474d7827b9ccf948ad4de128783e171/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4648eef474d7827b9ccf948ad4de128783e171/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=aa4648eef474d7827b9ccf948ad4de128783e171", "patch": "@@ -2920,6 +2920,16 @@ package body Sem_Res is\n                   Expr   : Node_Id;\n \n                begin\n+                  if Is_Derived_Type (Typ)\n+                    and then Is_Tagged_Type (Typ)\n+                    and then Base_Type (Etype (Callee)) /= Base_Type (Typ)\n+                  then\n+                     Callee :=\n+                       Corresponding_Primitive_Op\n+                         (Ancestor_Op     => Callee,\n+                          Descendant_Type => Base_Type (Typ));\n+                  end if;\n+\n                   if Nkind (N) = N_Identifier then\n                      Expr := Expression (Declaration_Node (Entity (N)));\n \n@@ -2990,16 +3000,23 @@ package body Sem_Res is\n \n                   Set_Etype (Call, Etype (Callee));\n \n-                  --  Conversion needed in case of an inherited aspect\n-                  --  of a derived type.\n-                  --\n-                  --  ??? Need to do something different here for downward\n-                  --  tagged conversion case (which is only possible in the\n-                  --  case of a null extension); the current call to\n-                  --  Convert_To results in an error message about an illegal\n-                  --  downward conversion.\n+                  if Base_Type (Etype (Call)) /= Base_Type (Typ) then\n+                     --  Conversion may be needed in case of an inherited\n+                     --  aspect of a derived type. For a null extension, we\n+                     --  use a null extension aggregate instead because the\n+                     --  downward type conversion would be illegal.\n \n-                  Call := Convert_To (Typ, Call);\n+                     if Is_Null_Extension_Of\n+                          (Descendant => Typ,\n+                           Ancestor   => Etype (Call))\n+                     then\n+                        Call := Make_Extension_Aggregate (Loc,\n+                                  Ancestor_Part       => Call,\n+                                  Null_Record_Present => True);\n+                     else\n+                        Call := Convert_To (Typ, Call);\n+                     end if;\n+                  end if;\n \n                   Rewrite (N, Call);\n                end;"}, {"sha": "816fb451fd0cf1349978dc69ce08b2e73443a982", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4648eef474d7827b9ccf948ad4de128783e171/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4648eef474d7827b9ccf948ad4de128783e171/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=aa4648eef474d7827b9ccf948ad4de128783e171", "patch": "@@ -7073,6 +7073,79 @@ package body Sem_Util is\n       end if;\n    end Corresponding_Generic_Type;\n \n+   --------------------------------\n+   -- Corresponding_Primitive_Op --\n+   --------------------------------\n+\n+   function Corresponding_Primitive_Op\n+     (Ancestor_Op     : Entity_Id;\n+      Descendant_Type : Entity_Id) return Entity_Id\n+   is\n+      Typ  : constant Entity_Id := Find_Dispatching_Type (Ancestor_Op);\n+      Elmt : Elmt_Id;\n+      Subp : Entity_Id;\n+      Prim : Entity_Id;\n+   begin\n+      pragma Assert (Is_Dispatching_Operation (Ancestor_Op));\n+      pragma Assert (Is_Ancestor (Typ, Descendant_Type)\n+                      or else Is_Progenitor (Typ, Descendant_Type));\n+\n+      Elmt := First_Elmt (Primitive_Operations (Descendant_Type));\n+\n+      while Present (Elmt) loop\n+         Subp := Node (Elmt);\n+\n+         --  For regular primitives we only need to traverse the chain of\n+         --  ancestors when the name matches the name of Ancestor_Op, but\n+         --  for predefined dispatching operations we cannot rely on the\n+         --  name of the primitive to identify a candidate since their name\n+         --  is internally built adding a suffix to the name of the tagged\n+         --  type.\n+\n+         if Chars (Subp) = Chars (Ancestor_Op)\n+           or else Is_Predefined_Dispatching_Operation (Subp)\n+         then\n+            --  Handle case where Ancestor_Op is a primitive of a progenitor.\n+            --  We rely on internal entities that map interface primitives:\n+            --  their attribute Interface_Alias references the interface\n+            --  primitive, and their Alias attribute references the primitive\n+            --  of Descendant_Type implementing that interface primitive.\n+\n+            if Present (Interface_Alias (Subp)) then\n+               if Interface_Alias (Subp) = Ancestor_Op then\n+                  return Alias (Subp);\n+               end if;\n+\n+            --  Traverse the chain of ancestors searching for Ancestor_Op.\n+            --  Overridden primitives have attribute Overridden_Operation;\n+            --  inherited primitives have attribute Alias.\n+\n+            else\n+               Prim := Subp;\n+\n+               while Present (Overridden_Operation (Prim))\n+                 or else Present (Alias (Prim))\n+               loop\n+                  if Present (Overridden_Operation (Prim)) then\n+                     Prim := Overridden_Operation (Prim);\n+                  else\n+                     Prim := Alias (Prim);\n+                  end if;\n+\n+                  if Prim = Ancestor_Op then\n+                     return Subp;\n+                  end if;\n+               end loop;\n+            end if;\n+         end if;\n+\n+         Next_Elmt (Elmt);\n+      end loop;\n+\n+      pragma Assert (False);\n+      return Empty;\n+   end Corresponding_Primitive_Op;\n+\n    --------------------\n    -- Current_Entity --\n    --------------------"}, {"sha": "4e896a3599f15cde42ec0a1e05c563418b6b477a", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4648eef474d7827b9ccf948ad4de128783e171/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4648eef474d7827b9ccf948ad4de128783e171/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=aa4648eef474d7827b9ccf948ad4de128783e171", "patch": "@@ -638,6 +638,13 @@ package Sem_Util is\n    --  attribute, except in the case of formal private and derived types.\n    --  Possible optimization???\n \n+   function Corresponding_Primitive_Op\n+       (Ancestor_Op     : Entity_Id;\n+        Descendant_Type : Entity_Id) return Entity_Id;\n+   --  Given a primitive subprogram of a tagged type and a (distinct)\n+   --  descendant type of that type, find the corresponding primitive\n+   --  subprogram of the descendant type.\n+\n    function Current_Entity (N : Node_Id) return Entity_Id;\n    pragma Inline (Current_Entity);\n    --  Find the currently visible definition for a given identifier, that is to"}]}