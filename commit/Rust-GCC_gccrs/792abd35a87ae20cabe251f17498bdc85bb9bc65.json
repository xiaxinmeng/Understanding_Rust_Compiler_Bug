{"sha": "792abd35a87ae20cabe251f17498bdc85bb9bc65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyYWJkMzVhODdhZTIwY2FiZTI1MWYxNzQ5OGJkYzg1YmI5YmM2NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-07-12T07:12:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-07-12T07:12:56Z"}, "message": "gcc_update (files_and_dependencies): Remove generated YACC files.\n\n\t* gcc_update (files_and_dependencies): Remove generated YACC files.\n\n\t* c-parse.c: Remove.\n\t* c-parse.h: Likewise.\n\t* c-parse.y: Likewise.\n\t* objc/objc-parse.c: Likewise.\n\t* objc/objc-pasre.y: Likewise.\n\n\t* Makefile.in ($(PARSE_H)): Depend directly on parse.y.\n\t* parse.c: Remove.\n\t* parse.h: Likewise.\n\n\t* parse-scan.c: Remove.\n\nFrom-SVN: r34982", "tree": {"sha": "69b1d697dce96c285d4df746a0bb55344f016270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69b1d697dce96c285d4df746a0bb55344f016270"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792abd35a87ae20cabe251f17498bdc85bb9bc65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792abd35a87ae20cabe251f17498bdc85bb9bc65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792abd35a87ae20cabe251f17498bdc85bb9bc65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792abd35a87ae20cabe251f17498bdc85bb9bc65/comments", "author": null, "committer": null, "parents": [{"sha": "e98da3dcf547827050a49d61ba26841c159b71d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98da3dcf547827050a49d61ba26841c159b71d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98da3dcf547827050a49d61ba26841c159b71d6"}], "stats": {"total": 25319, "additions": 23, "deletions": 25296}, "files": [{"sha": "8c5c1c6ae12793748732c7560a4b1934016dea44", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792abd35a87ae20cabe251f17498bdc85bb9bc65/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792abd35a87ae20cabe251f17498bdc85bb9bc65/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=792abd35a87ae20cabe251f17498bdc85bb9bc65", "patch": "@@ -1,3 +1,7 @@\n+2000-07-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc_update (files_and_dependencies): Remove generated YACC files.\n+\n 2000-06-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* newcvsroot: Handle filenames that contain spaces."}, {"sha": "3e42a78c67ed8b01f65423fb6a0cb595e3c604bb", "filename": "contrib/gcc_update", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792abd35a87ae20cabe251f17498bdc85bb9bc65/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792abd35a87ae20cabe251f17498bdc85bb9bc65/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=792abd35a87ae20cabe251f17498bdc85bb9bc65", "patch": "@@ -65,20 +65,12 @@ texinfo/util/Makefile.in: texinfo/util/Makefile.am texinfo/configure.in texinfo/\n gcc/configure: gcc/configure.in\n gcc/cstamp-h.in: gcc/configure.in gcc/acconfig.h\n gcc/config.in: gcc/cstamp-h.in\n-gcc/c-parse.y: gcc/c-parse.in\n-gcc/c-parse.c: gcc/c-parse.y\n-gcc/c-parse.h: gcc/c-parse.c\n gcc/c-gperf.h: gcc/c-parse.gperf\n gcc/fixinc/fixincl.x: gcc/fixinc/fixincl.tpl gcc/fixinc/inclhack.def\n gcc/tradcif.c: gcc/tradcif.y\n # And then, language-specific files\n-gcc/cp/parse.c: gcc/cp/parse.y\n-gcc/cp/parse.h: gcc/cp/parse.c\n-gcc/objc/objc-parse.y: gcc/c-parse.in\n-gcc/objc/objc-parse.c: gcc/objc/objc-parse.y\n gcc/java/parse.h: gcc/java/parse.y\n gcc/java/parse.c: gcc/java/parse.y gcc/java/lex.c gcc/java/parse.h gcc/java/lex.h\n-gcc/java/parse-scan.c: gcc/java/parse-scan.y gcc/java/lex.c gcc/java/parse.h gcc/java/lex.h\n # And libraries, at last\n libchill/configure: libchill/configure.in\n libf2c/configure: libf2c/configure.in"}, {"sha": "9b6f0dc062e000873473613a383b075d32de029f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=792abd35a87ae20cabe251f17498bdc85bb9bc65", "patch": "@@ -1,3 +1,11 @@\n+2000-07-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-parse.c: Remove.\n+\t* c-parse.h: Likewise.\n+\t* c-parse.y: Likewise.\n+\t* objc/objc-parse.c: Likewise.\n+\t* objc/objc-pasre.y: Likewise.\n+\t\n 2000-07-11  Rodney Brown  <RodneyBrown@pmsc.com>\n \n \t* gcc.texi: Fix minor typos"}, {"sha": "20e202463b10e8326e31319712b7d76646856d95", "filename": "gcc/c-parse.c", "status": "removed", "additions": 0, "deletions": 3903, "changes": 3903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=e98da3dcf547827050a49d61ba26841c159b71d6"}, {"sha": "f93aef0a566173d2c9a612cddfe86818c5901f45", "filename": "gcc/c-parse.h", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fc-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fc-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.h?ref=e98da3dcf547827050a49d61ba26841c159b71d6", "patch": "@@ -1,69 +0,0 @@\n-typedef union {long itype; tree ttype; enum tree_code code;\n-\tconst char *filename; int lineno; int ends_in_label; } YYSTYPE;\n-#define\tIDENTIFIER\t257\n-#define\tTYPENAME\t258\n-#define\tSCSPEC\t259\n-#define\tTYPESPEC\t260\n-#define\tTYPE_QUAL\t261\n-#define\tCONSTANT\t262\n-#define\tSTRING\t263\n-#define\tELLIPSIS\t264\n-#define\tSIZEOF\t265\n-#define\tENUM\t266\n-#define\tSTRUCT\t267\n-#define\tUNION\t268\n-#define\tIF\t269\n-#define\tELSE\t270\n-#define\tWHILE\t271\n-#define\tDO\t272\n-#define\tFOR\t273\n-#define\tSWITCH\t274\n-#define\tCASE\t275\n-#define\tDEFAULT\t276\n-#define\tBREAK\t277\n-#define\tCONTINUE\t278\n-#define\tRETURN\t279\n-#define\tGOTO\t280\n-#define\tASM_KEYWORD\t281\n-#define\tTYPEOF\t282\n-#define\tALIGNOF\t283\n-#define\tATTRIBUTE\t284\n-#define\tEXTENSION\t285\n-#define\tLABEL\t286\n-#define\tREALPART\t287\n-#define\tIMAGPART\t288\n-#define\tVA_ARG\t289\n-#define\tPTR_VALUE\t290\n-#define\tPTR_BASE\t291\n-#define\tPTR_EXTENT\t292\n-#define\tEND_OF_LINE\t293\n-#define\tASSIGN\t294\n-#define\tOROR\t295\n-#define\tANDAND\t296\n-#define\tEQCOMPARE\t297\n-#define\tARITHCOMPARE\t298\n-#define\tLSHIFT\t299\n-#define\tRSHIFT\t300\n-#define\tUNARY\t301\n-#define\tPLUSPLUS\t302\n-#define\tMINUSMINUS\t303\n-#define\tHYPERUNARY\t304\n-#define\tPOINTSAT\t305\n-#define\tINTERFACE\t306\n-#define\tIMPLEMENTATION\t307\n-#define\tEND\t308\n-#define\tSELECTOR\t309\n-#define\tDEFS\t310\n-#define\tENCODE\t311\n-#define\tCLASSNAME\t312\n-#define\tPUBLIC\t313\n-#define\tPRIVATE\t314\n-#define\tPROTECTED\t315\n-#define\tPROTOCOL\t316\n-#define\tOBJECTNAME\t317\n-#define\tCLASS\t318\n-#define\tALIAS\t319\n-#define\tOBJC_STRING\t320\n-\n-\n-extern YYSTYPE yylval;"}, {"sha": "11b06569acda8a07dc94057e0aaded03a7bc48cd", "filename": "gcc/c-parse.y", "status": "removed", "additions": 0, "deletions": 2054, "changes": 2054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=e98da3dcf547827050a49d61ba26841c159b71d6", "patch": "@@ -1,2054 +0,0 @@\n-/*WARNING: This file is automatically generated!*/\n-/* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996,\n-   1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This file defines the grammar of C and that of Objective C.\n-   ifobjc ... end ifobjc  conditionals contain code for Objective C only.\n-   ifc ... end ifc  conditionals contain code for C only.\n-   Sed commands in Makefile.in are used to convert this file into\n-   c-parse.y and into objc-parse.y.  */\n-\n-/* To whomever it may concern: I have heard that such a thing was once\n-   written by AT&T, but I have never seen it.  */\n-\n-%expect 53\n-\n-%{\n-#include \"config.h\"\n-#include \"system.h\"\n-#include <setjmp.h>\n-#include \"tree.h\"\n-#include \"input.h\"\n-#include \"c-lex.h\"\n-#include \"c-tree.h\"\n-#include \"flags.h\"\n-#include \"output.h\"\n-#include \"toplev.h\"\n-#include \"ggc.h\"\n-  \n-#ifdef MULTIBYTE_CHARS\n-#include <locale.h>\n-#endif\n-\n-\n-/* Since parsers are distinct for each language, put the language string\n-   definition here.  */\n-const char * const language_string = \"GNU C\";\n-\n-/* Like YYERROR but do call yyerror.  */\n-#define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n-\n-/* Cause the `yydebug' variable to be defined.  */\n-#define YYDEBUG 1\n-%}\n-\n-%start program\n-\n-%union {long itype; tree ttype; enum tree_code code;\n-\tconst char *filename; int lineno; int ends_in_label; }\n-\n-/* All identifiers that are not reserved words\n-   and are not declared typedefs in the current block */\n-%token IDENTIFIER\n-\n-/* All identifiers that are declared typedefs in the current block.\n-   In some contexts, they are treated just like IDENTIFIER,\n-   but they can also serve as typespecs in declarations.  */\n-%token TYPENAME\n-\n-/* Reserved words that specify storage class.\n-   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token SCSPEC\n-\n-/* Reserved words that specify type.\n-   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token TYPESPEC\n-\n-/* Reserved words that qualify type: \"const\", \"volatile\", or \"restrict\".\n-   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token TYPE_QUAL\n-\n-/* Character or numeric constants.\n-   yylval is the node for the constant.  */\n-%token CONSTANT\n-\n-/* String constants in raw form.\n-   yylval is a STRING_CST node.  */\n-%token STRING\n-\n-/* \"...\", used for functions with variable arglists.  */\n-%token ELLIPSIS\n-\n-/* the reserved words */\n-/* SCO include files test \"ASM\", so use something else. */\n-%token SIZEOF ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n-%token BREAK CONTINUE RETURN GOTO ASM_KEYWORD TYPEOF ALIGNOF\n-%token ATTRIBUTE EXTENSION LABEL\n-%token REALPART IMAGPART VA_ARG\n-%token PTR_VALUE PTR_BASE PTR_EXTENT\n-\n-/* Used in c-lex.c for parsing pragmas.  */\n-%token END_OF_LINE\n-\n-/* Add precedence rules to solve dangling else s/r conflict */\n-%nonassoc IF\n-%nonassoc ELSE\n-\n-/* Define the operator tokens and their precedences.\n-   The value is an integer because, if used, it is the tree code\n-   to use in the expression made from the operator.  */\n-\n-%right <code> ASSIGN '='\n-%right <code> '?' ':'\n-%left <code> OROR\n-%left <code> ANDAND\n-%left <code> '|'\n-%left <code> '^'\n-%left <code> '&'\n-%left <code> EQCOMPARE\n-%left <code> ARITHCOMPARE\n-%left <code> LSHIFT RSHIFT\n-%left <code> '+' '-'\n-%left <code> '*' '/' '%'\n-%right <code> UNARY PLUSPLUS MINUSMINUS\n-%left HYPERUNARY\n-%left <code> POINTSAT '.' '(' '['\n-\n-/* The Objective-C keywords.  These are included in C and in\n-   Objective C, so that the token codes are the same in both.  */\n-%token INTERFACE IMPLEMENTATION END SELECTOR DEFS ENCODE\n-%token CLASSNAME PUBLIC PRIVATE PROTECTED PROTOCOL OBJECTNAME CLASS ALIAS\n-\n-/* Objective-C string constants in raw form.\n-   yylval is an OBJC_STRING_CST node.  */\n-%token OBJC_STRING\n-\n-\n-%type <code> unop\n-\n-%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n-%type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n-%type <ttype> typed_declspecs reserved_declspecs\n-%type <ttype> typed_typespecs reserved_typespecquals\n-%type <ttype> declmods typespec typespecqual_reserved\n-%type <ttype> typed_declspecs_no_prefix_attr reserved_declspecs_no_prefix_attr\n-%type <ttype> declmods_no_prefix_attr\n-%type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n-%type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n-%type <ttype> init maybeasm\n-%type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n-%type <ttype> maybe_attribute attributes attribute attribute_list attrib\n-%type <ttype> any_word extension\n-\n-%type <ttype> compstmt compstmt_nostart compstmt_primary_start\n-\n-%type <ttype> declarator\n-%type <ttype> notype_declarator after_type_declarator\n-%type <ttype> parm_declarator\n-\n-%type <ttype> structsp component_decl_list component_decl_list2\n-%type <ttype> component_decl components component_declarator\n-%type <ttype> enumlist enumerator\n-%type <ttype> struct_head union_head enum_head\n-%type <ttype> typename absdcl absdcl1 type_quals\n-%type <ttype> xexpr parms parm identifiers\n-\n-%type <ttype> parmlist parmlist_1 parmlist_2\n-%type <ttype> parmlist_or_identifiers parmlist_or_identifiers_1\n-%type <ttype> identifiers_or_typenames\n-\n-%type <itype> setspecs\n-\n-%type <ends_in_label> lineno_stmt_or_label lineno_stmt_or_labels stmt_or_label\n-\n-%type <filename> save_filename\n-%type <lineno> save_lineno\n-\f\n-\f\n-%{\n-/* Number of statements (loosely speaking) and compound statements \n-   seen so far.  */\n-static int stmt_count;\n-static int compstmt_count;\n-  \n-/* Input file and line number of the end of the body of last simple_if;\n-   used by the stmt-rule immediately after simple_if returns.  */\n-static const char *if_stmt_file;\n-static int if_stmt_line;\n-\n-/* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs = NULL_TREE;\n-static tree prefix_attributes = NULL_TREE;\n-\n-/* Stack of saved values of current_declspecs and prefix_attributes.  */\n-static tree declspec_stack;\n-\n-/* For __extension__, save/restore the warning flags which are\n-   controlled by __extension__.  */\n-#define SAVE_WARN_FLAGS()\t\\\n-\tsize_int (pedantic | (warn_pointer_arith << 1))\n-#define RESTORE_WARN_FLAGS(tval) \\\n-  do {                                     \\\n-    int val = tree_low_cst (tval, 0);      \\\n-    pedantic = val & 1;                    \\\n-    warn_pointer_arith = (val >> 1) & 1;   \\\n-  } while (0)\n-\n-\n-/* Tell yyparse how to print a token's value, if yydebug is set.  */\n-\n-#define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n-\n-/* Add GC roots for variables local to this file.  */\n-void\n-c_parse_init ()\n-{\n-  ggc_add_tree_root (&declspec_stack, 1);\n-  ggc_add_tree_root (&current_declspecs, 1);\n-  ggc_add_tree_root (&prefix_attributes, 1);\n-}\n-\n-%}\n-\f\n-%%\n-program: /* empty */\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids an empty source file\");\n-\t\t  finish_file ();\n-\t\t}\n-\t| extdefs\n-\t\t{\n-\t\t  /* In case there were missing closebraces,\n-\t\t     get us back to the global binding level.  */\n-\t\t  while (! global_bindings_p ())\n-\t\t    poplevel (0, 0, 0);\n-\t\t  finish_file ();\n-\t\t}\n-\t;\n-\n-/* the reason for the strange actions in this rule\n- is so that notype_initdecls when reached via datadef\n- can find a valid list of type and sc specs in $0. */\n-\n-extdefs:\n-\t{$<ttype>$ = NULL_TREE; } extdef\n-\t| extdefs {$<ttype>$ = NULL_TREE; } extdef\n-\t;\n-\n-extdef:\n-\tfndef\n-\t| datadef\n-\t| ASM_KEYWORD '(' expr ')' ';'\n-\t\t{ STRIP_NOPS ($3);\n-\t\t  if ((TREE_CODE ($3) == ADDR_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND ($3, 0)) == STRING_CST)\n-\t\t      || TREE_CODE ($3) == STRING_CST)\n-\t\t    assemble_asm ($3);\n-\t\t  else\n-\t\t    error (\"argument of `asm' is not a constant string\"); }\n-\t| extension extdef\n-\t\t{ RESTORE_WARN_FLAGS ($1); }\n-\t;\n-\n-datadef:\n-\t  setspecs notype_initdecls ';'\n-\t\t{ if (pedantic)\n-\t\t    error (\"ANSI C forbids data definition with no type or storage class\");\n-\t\t  else if (!flag_traditional)\n-\t\t    warning (\"data definition has no type or storage class\"); \n-\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-        | declmods setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-        | declmods ';'\n-\t  { pedwarn (\"empty declaration\"); }\n-\t| typed_declspecs ';'\n-\t  { shadow_tag ($1); }\n-\t| error ';'\n-\t| error '}'\n-\t| ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C does not allow extra `;' outside of a function\"); }\n-\t;\n-\f\n-fndef:\n-\t  typed_declspecs setspecs declarator\n-\t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator\n-\t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| setspecs notype_declarator\n-\t\t{ if (! start_function (NULL_TREE, $2,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| setspecs notype_declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t;\n-\n-identifier:\n-\tIDENTIFIER\n-\t| TYPENAME\n-\t;\n-\n-unop:     '&'\n-\t\t{ $$ = ADDR_EXPR; }\n-\t| '-'\n-\t\t{ $$ = NEGATE_EXPR; }\n-\t| '+'\n-\t\t{ $$ = CONVERT_EXPR; }\n-\t| PLUSPLUS\n-\t\t{ $$ = PREINCREMENT_EXPR; }\n-\t| MINUSMINUS\n-\t\t{ $$ = PREDECREMENT_EXPR; }\n-\t| '~'\n-\t\t{ $$ = BIT_NOT_EXPR; }\n-\t| '!'\n-\t\t{ $$ = TRUTH_NOT_EXPR; }\n-\t;\n-\n-expr:\tnonnull_exprlist\n-\t\t{ $$ = build_compound_expr ($1); }\n-\t;\n-\n-exprlist:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| nonnull_exprlist\n-\t;\n-\n-nonnull_exprlist:\n-\texpr_no_commas\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| nonnull_exprlist ',' expr_no_commas\n-\t\t{ chainon ($1, build_tree_list (NULL_TREE, $3)); }\n-\t;\n-\n-unary_expr:\n-\tprimary\n-\t| '*' cast_expr   %prec UNARY\n-\t\t{ $$ = build_indirect_ref ($2, \"unary *\"); }\n-\t/* __extension__ turns off -pedantic for following primary.  */\n-\t| extension cast_expr\t  %prec UNARY\n-\t\t{ $$ = $2;\n-\t\t  RESTORE_WARN_FLAGS ($1); }\n-\t| unop cast_expr  %prec UNARY\n-\t\t{ $$ = build_unary_op ($1, $2, 0);\n-\t\t  overflow_warning ($$); }\n-\t/* Refer to the address of a label as a pointer.  */\n-\t| ANDAND identifier\n-\t\t{ tree label = lookup_label ($2);\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids `&&'\");\n-\t\t  if (label == 0)\n-\t\t    $$ = null_pointer_node;\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_USED (label) = 1;\n-\t\t      $$ = build1 (ADDR_EXPR, ptr_type_node, label);\n-\t\t      TREE_CONSTANT ($$) = 1;\n-\t\t    }\n-\t\t}\n-/* This seems to be impossible on some machines, so let's turn it off.\n-   You can use __builtin_next_arg to find the anonymous stack args.\n-\t| '&' ELLIPSIS\n-\t\t{ tree types = TYPE_ARG_TYPES (TREE_TYPE (current_function_decl));\n-\t\t  $$ = error_mark_node;\n-\t\t  if (TREE_VALUE (tree_last (types)) == void_type_node)\n-\t\t    error (\"`&...' used in function with fixed number of arguments\");\n-\t\t  else\n-\t\t    {\n-\t\t      if (pedantic)\n-\t\t\tpedwarn (\"ANSI C forbids `&...'\");\n-\t\t      $$ = tree_last (DECL_ARGUMENTS (current_function_decl));\n-\t\t      $$ = build_unary_op (ADDR_EXPR, $$, 0);\n-\t\t    } }\n-*/\n-\t| sizeof unary_expr  %prec UNARY\n-\t\t{ skip_evaluation--;\n-\t\t  if (TREE_CODE ($2) == COMPONENT_REF\n-\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2, 1)))\n-\t\t    error (\"`sizeof' applied to a bit-field\");\n-\t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n-\t| sizeof '(' typename ')'  %prec HYPERUNARY\n-\t\t{ skip_evaluation--;\n-\t\t  $$ = c_sizeof (groktypename ($3)); }\n-\t| alignof unary_expr  %prec UNARY\n-\t\t{ skip_evaluation--;\n-\t\t  $$ = c_alignof_expr ($2); }\n-\t| alignof '(' typename ')'  %prec HYPERUNARY\n-\t\t{ skip_evaluation--;\n-\t\t  $$ = c_alignof (groktypename ($3)); }\n-\t| REALPART cast_expr %prec UNARY\n-\t\t{ $$ = build_unary_op (REALPART_EXPR, $2, 0); }\n-\t| IMAGPART cast_expr %prec UNARY\n-\t\t{ $$ = build_unary_op (IMAGPART_EXPR, $2, 0); }\n-\t| VA_ARG '(' expr_no_commas ',' typename ')'\n-\t\t{ $$ = build_va_arg ($3, groktypename ($5)); }\n-\t;\n-\n-sizeof:\n-\tSIZEOF { skip_evaluation++; }\n-\t;\n-\n-alignof:\n-\tALIGNOF { skip_evaluation++; }\n-\t;\n-\n-cast_expr:\n-\tunary_expr\n-\t| '(' typename ')' cast_expr  %prec UNARY\n-\t\t{ tree type = groktypename ($2);\n-\t\t  $$ = build_c_cast (type, $4); }\n-\t| '(' typename ')' '{' \n-\t\t{ start_init (NULL_TREE, NULL, 0);\n-\t\t  $2 = groktypename ($2);\n-\t\t  really_start_incremental_init ($2); }\n-\t  initlist_maybe_comma '}'  %prec UNARY\n-\t\t{ const char *name;\n-\t\t  tree result = pop_init_level (0);\n-\t\t  tree type = $2;\n-\t\t  finish_init ();\n-\n-\t\t  if (pedantic && ! flag_isoc99)\n-\t\t    pedwarn (\"ANSI C forbids constructor expressions\");\n-\t\t  if (TYPE_NAME (type) != 0)\n-\t\t    {\n-\t\t      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\t\t\tname = IDENTIFIER_POINTER (TYPE_NAME (type));\n-\t\t      else\n-\t\t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-\t\t    }\n-\t\t  else\n-\t\t    name = \"\";\n-\t\t  $$ = result;\n-\t\t  if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n-\t\t    {\n-\t\t      int failure = complete_array_type (type, $$, 1);\n-\t\t      if (failure)\n-\t\t\tabort ();\n-\t\t    }\n-\t\t}\n-\t;\n-\n-expr_no_commas:\n-\t  cast_expr\n-\t| expr_no_commas '+' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '-' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '*' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '/' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '%' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas LSHIFT expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas RSHIFT expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas ARITHCOMPARE expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas EQCOMPARE expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '&' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '|' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '^' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas ANDAND\n-\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == boolean_false_node; }\n-\t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_false_node;\n-\t\t  $$ = parser_build_binary_op (TRUTH_ANDIF_EXPR, $1, $4); }\n-\t| expr_no_commas OROR\n-\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == boolean_true_node; }\n-\t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_true_node;\n-\t\t  $$ = parser_build_binary_op (TRUTH_ORIF_EXPR, $1, $4); }\n-\t| expr_no_commas '?'\n-\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == boolean_false_node; }\n-          expr ':'\n-\t\t{ skip_evaluation += (($1 == boolean_true_node)\n-\t\t\t\t      - ($1 == boolean_false_node)); }\n-\t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_true_node;\n-\t\t  $$ = build_conditional_expr ($1, $4, $7); }\n-\t| expr_no_commas '?'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids omitting the middle term of a ?: expression\");\n-\t\t  /* Make sure first operand is calculated only once.  */\n-\t\t  $<ttype>2 = save_expr ($1);\n-\t\t  $1 = truthvalue_conversion (default_conversion ($<ttype>2));\n-\t\t  skip_evaluation += $1 == boolean_true_node; }\n-\t  ':' expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_true_node;\n-\t\t  $$ = build_conditional_expr ($1, $<ttype>2, $5); }\n-\t| expr_no_commas '=' expr_no_commas\n-\t\t{ char class;\n-\t\t  $$ = build_modify_expr ($1, NOP_EXPR, $3);\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR);\n-\t\t}\n-\t| expr_no_commas ASSIGN expr_no_commas\n-\t\t{ char class;\n-\t\t  $$ = build_modify_expr ($1, $2, $3);\n-\t\t  /* This inhibits warnings in truthvalue_conversion.  */\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK);\n-\t\t}\n-\t;\n-\n-primary:\n-\tIDENTIFIER\n-\t\t{\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  $$ = build_external_ref ($1, yychar == '(');\n-\t\t}\n-\t| CONSTANT\n-\t| string\n-\t\t{ $$ = combine_strings ($1); }\n-\t| '(' expr ')'\n-\t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($2, ERROR_MARK);\n-\t\t  $$ = $2; }\n-\t| '(' error ')'\n-\t\t{ $$ = error_mark_node; }\n-\t| compstmt_primary_start compstmt_nostart ')'\n-\t\t{ tree rtl_exp;\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids braced-groups within expressions\");\n-\t\t  pop_iterator_stack ();\n-\t\t  pop_label_level ();\n-\t\t  rtl_exp = expand_end_stmt_expr ($1);\n-\t\t  /* The statements have side effects, so the group does.  */\n-\t\t  TREE_SIDE_EFFECTS (rtl_exp) = 1;\n-\n-\t\t  if (TREE_CODE ($2) == BLOCK)\n-\t\t    {\n-\t\t      /* Make a BIND_EXPR for the BLOCK already made.  */\n-\t\t      $$ = build (BIND_EXPR, TREE_TYPE (rtl_exp),\n-\t\t\t\t  NULL_TREE, rtl_exp, $2);\n-\t\t      /* Remove the block from the tree at this point.\n-\t\t\t It gets put back at the proper place\n-\t\t\t when the BIND_EXPR is expanded.  */\n-\t\t      delete_block ($2);\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = $2;\n-\t\t}\n-\t| compstmt_primary_start error ')'\n-\t\t{\n-\t\t  /* Make sure we call expand_end_stmt_expr.  Otherwise\n-\t\t     we are likely to lose sequences and crash later.  */\n-\t\t  pop_iterator_stack ();\n-\t\t  pop_label_level ();\n-\t\t  expand_end_stmt_expr ($1);\n-\t\t  $$ = error_mark_node;\n-\t\t}\n-\t| primary '(' exprlist ')'   %prec '.'\n-\t\t{ $$ = build_function_call ($1, $3); }\n-\t| primary '[' expr ']'   %prec '.'\n-\t\t{ $$ = build_array_ref ($1, $3); }\n-\t| primary '.' identifier\n-\t\t{\n-\t\t    $$ = build_component_ref ($1, $3);\n-\t\t}\n-\t| primary POINTSAT identifier\n-\t\t{\n-                  tree expr = build_indirect_ref ($1, \"->\");\n-\n-                    $$ = build_component_ref (expr, $3);\n-\t\t}\n-\t| primary PLUSPLUS\n-\t\t{ $$ = build_unary_op (POSTINCREMENT_EXPR, $1, 0); }\n-\t| primary MINUSMINUS\n-\t\t{ $$ = build_unary_op (POSTDECREMENT_EXPR, $1, 0); }\n-\t;\n-\n-/* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */\n-string:\n-\t  STRING\n-\t| string STRING\n-\t\t{ $$ = chainon ($1, $2);\n-\t\t  if (warn_traditional && !in_system_header)\n-\t\t    warning (\"Use of ANSI string concatenation\");\n-\t\t}\n-\t;\n-\n-\n-old_style_parm_decls:\n-\t/* empty */\n-\t| datadecls\n-\t| datadecls ELLIPSIS\n-\t\t/* ... is used here to indicate a varargs function.  */\n-\t\t{ c_mark_varargs ();\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C does not permit use of `varargs.h'\"); }\n-\t;\n-\n-/* The following are analogous to lineno_decl, decls and decl\n-   except that they do not allow nested functions.\n-   They are used for old-style parm decls.  */\n-lineno_datadecl:\n-\t  save_filename save_lineno datadecl\n-\t\t{ }\n-\t;\n-\n-datadecls:\n-\tlineno_datadecl\n-\t| errstmt\n-\t| datadecls lineno_datadecl\n-\t| lineno_datadecl errstmt\n-\t;\n-\n-/* We don't allow prefix attributes here because they cause reduce/reduce\n-   conflicts: we can't know whether we're parsing a function decl with\n-   attribute suffix, or function defn with attribute prefix on first old\n-   style parm.  */\n-datadecl:\n-\ttyped_declspecs_no_prefix_attr setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods_no_prefix_attr setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\t\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs_no_prefix_attr ';'\n-\t\t{ shadow_tag_warned ($1, 1);\n-\t\t  pedwarn (\"empty declaration\"); }\n-\t| declmods_no_prefix_attr ';'\n-\t\t{ pedwarn (\"empty declaration\"); }\n-\t;\n-\n-/* This combination which saves a lineno before a decl\n-   is the normal thing to use, rather than decl itself.\n-   This is to avoid shift/reduce conflicts in contexts\n-   where statement labels are allowed.  */\n-lineno_decl:\n-\t  save_filename save_lineno decl\n-\t\t{ }\n-\t;\n-\n-decls:\n-\tlineno_decl\n-\t| errstmt\n-\t| decls lineno_decl\n-\t| lineno_decl errstmt\n-\t;\n-\n-/* records the type and storage class specs to use for processing\n-   the declarators that follow.\n-   Maintains a stack of outer-level values of current_declspecs,\n-   for the sake of parm declarations nested in function declarators.  */\n-setspecs: /* empty */\n-\t\t{ pending_xref_error ();\n-\t\t  declspec_stack = tree_cons (prefix_attributes,\n-\t\t\t\t\t      current_declspecs,\n-\t\t\t\t\t      declspec_stack);\n-\t\t  split_specs_attrs ($<ttype>0,\n-\t\t\t\t     &current_declspecs, &prefix_attributes); }\n-\t;\n-\n-/* ??? Yuck.  See after_type_declarator.  */\n-setattrs: /* empty */\n-\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }\n-\t;\n-\n-decl:\n-\ttyped_declspecs setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs nested_function\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_nested_function\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs ';'\n-\t\t{ shadow_tag ($1); }\n-\t| declmods ';'\n-\t\t{ pedwarn (\"empty declaration\"); }\n-\t| extension decl\n-\t\t{ RESTORE_WARN_FLAGS ($1); }\n-\t;\n-\n-/* Declspecs which contain at least one type specifier or typedef name.\n-   (Just `const' or `volatile' is not enough.)\n-   A typedef'd name following these is taken as a name to be declared.\n-   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n-\n-typed_declspecs:\n-\t  typespec reserved_declspecs\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| declmods typespec reserved_declspecs\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n-\t;\n-\n-reserved_declspecs:  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_declspecs typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs SCSPEC\n-\t\t{ if (extra_warnings)\n-\t\t    warning (\"`%s' is not at beginning of declaration\",\n-\t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs attributes\n-\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n-\t;\n-\n-typed_declspecs_no_prefix_attr:\n-\t  typespec reserved_declspecs_no_prefix_attr\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| declmods_no_prefix_attr typespec reserved_declspecs_no_prefix_attr\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n-\t;\n-\n-reserved_declspecs_no_prefix_attr:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_declspecs_no_prefix_attr typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs_no_prefix_attr SCSPEC\n-\t\t{ if (extra_warnings)\n-\t\t    warning (\"`%s' is not at beginning of declaration\",\n-\t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-/* List of just storage classes, type modifiers, and prefix attributes.\n-   A declaration can start with just this, but then it cannot be used\n-   to redeclare a typedef-name.\n-   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n-\n-declmods:\n-\t  declmods_no_prefix_attr\n-\t\t{ $$ = $1; }\n-\t| attributes\n-\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE); }\n-\t| declmods declmods_no_prefix_attr\n-\t\t{ $$ = chainon ($2, $1); }\n-\t| declmods attributes\n-\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n-\t;\n-\n-declmods_no_prefix_attr:\n-\t  TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n-\t\t  TREE_STATIC ($$) = 1; }\n-\t| SCSPEC\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-\t| declmods_no_prefix_attr TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n-\t\t  TREE_STATIC ($$) = 1; }\n-\t| declmods_no_prefix_attr SCSPEC\n-\t\t{ if (extra_warnings && TREE_STATIC ($1))\n-\t\t    warning (\"`%s' is not at beginning of declaration\",\n-\t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n-\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n-\t;\n-\n-\n-/* Used instead of declspecs where storage classes are not allowed\n-   (that is, for typenames and structure components).\n-   Don't accept a typedef-name if anything but a modifier precedes it.  */\n-\n-typed_typespecs:\n-\t  typespec reserved_typespecquals\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| nonempty_type_quals typespec reserved_typespecquals\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n-\t;\n-\n-reserved_typespecquals:  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_typespecquals typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-/* A typespec (but not a type qualifier).\n-   Once we have seen one of these in a declaration,\n-   if a typedef name appears then it is being redeclared.  */\n-\n-typespec: TYPESPEC\n-\t| structsp\n-\t| TYPENAME\n-\t\t{ /* For a typedef name, record the meaning, not the name.\n-\t\t     In case of `foo foo, bar;'.  */\n-\t\t  $$ = lookup_name ($1); }\n-\t| TYPEOF '(' expr ')'\n-\t\t{ $$ = TREE_TYPE ($3); }\n-\t| TYPEOF '(' typename ')'\n-\t\t{ $$ = groktypename ($3); }\n-\t;\n-\n-/* A typespec that is a reserved word, or a type qualifier.  */\n-\n-typespecqual_reserved: TYPESPEC\n-\t| TYPE_QUAL\n-\t| structsp\n-\t;\n-\n-initdecls:\n-\tinitdcl\n-\t| initdecls ',' initdcl\n-\t;\n-\n-notype_initdecls:\n-\tnotype_initdcl\n-\t| notype_initdecls ',' initdcl\n-\t;\n-\n-maybeasm:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| ASM_KEYWORD '(' string ')'\n-\t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n-\t\t  $$ = $3;\n-\t\t}\n-\t;\n-\n-initdcl:\n-\t  declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n-\t\t\t\t\t  $3, prefix_attributes);\n-\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n-\t  init\n-/* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_init ();\n-\t\t  finish_decl ($<ttype>5, $6, $2); }\n-\t| declarator maybeasm maybe_attribute\n-\t\t{ tree d = start_decl ($1, current_declspecs, 0,\n-\t\t\t\t       $3, prefix_attributes);\n-\t\t  finish_decl (d, NULL_TREE, $2); \n-                }\n-\t;\n-\n-notype_initdcl:\n-\t  notype_declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n-\t\t\t\t\t  $3, prefix_attributes);\n-\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n-\t  init\n-/* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_init ();\n-\t\t  decl_attributes ($<ttype>5, $3, prefix_attributes);\n-\t\t  finish_decl ($<ttype>5, $6, $2); }\n-\t| notype_declarator maybeasm maybe_attribute\n-\t\t{ tree d = start_decl ($1, current_declspecs, 0,\n-\t\t\t\t       $3, prefix_attributes);\n-\t\t  finish_decl (d, NULL_TREE, $2); }\n-\t;\n-/* the * rules are dummies to accept the Apollo extended syntax\n-   so that the header files compile. */\n-maybe_attribute:\n-      /* empty */\n-  \t\t{ $$ = NULL_TREE; }\n-\t| attributes\n-\t\t{ $$ = $1; }\n-\t;\n- \n-attributes:\n-      attribute\n-\t\t{ $$ = $1; }\n-\t| attributes attribute\n-\t\t{ $$ = chainon ($1, $2); }\n-\t;\n-\n-attribute:\n-      ATTRIBUTE '(' '(' attribute_list ')' ')'\n-\t\t{ $$ = $4; }\n-\t;\n-\n-attribute_list:\n-      attrib\n-\t\t{ $$ = $1; }\n-\t| attribute_list ',' attrib\n-\t\t{ $$ = chainon ($1, $3); }\n-\t;\n- \n-attrib:\n-    /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| any_word\n-\t\t{ $$ = build_tree_list ($1, NULL_TREE); }\n-\t| any_word '(' IDENTIFIER ')'\n-\t\t{ $$ = build_tree_list ($1, build_tree_list (NULL_TREE, $3)); }\n-\t| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'\n-\t\t{ $$ = build_tree_list ($1, tree_cons (NULL_TREE, $3, $5)); }\n-\t| any_word '(' exprlist ')'\n-\t\t{ $$ = build_tree_list ($1, $3); }\n-\t;\n-\n-/* This still leaves out most reserved keywords,\n-   shouldn't we include them?  */\n-\n-any_word:\n-\t  identifier\n-\t| SCSPEC\n-\t| TYPESPEC\n-\t| TYPE_QUAL\n-\t;\n-\f\n-/* Initializers.  `init' is the entry point.  */\n-\n-init:\n-\texpr_no_commas\n-\t| '{'\n-\t\t{ really_start_incremental_init (NULL_TREE); }\n-\t  initlist_maybe_comma '}'\n-\t\t{ $$ = pop_init_level (0); }\n-\t| error\n-\t\t{ $$ = error_mark_node; }\n-\t;\n-\n-/* `initlist_maybe_comma' is the guts of an initializer in braces.  */\n-initlist_maybe_comma:\n-\t  /* empty */\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids empty initializer braces\"); }\n-\t| initlist1 maybecomma\n-\t;\n-\n-initlist1:\n-\t  initelt\n-\t| initlist1 ',' initelt\n-\t;\n-\n-/* `initelt' is a single element of an initializer.\n-   It may use braces.  */\n-initelt:\n-\t  designator_list '=' initval\n-\t| designator initval\n-\t| identifier ':'\n-\t\t{ set_init_label ($1); }\n-\t  initval\n-\t| initval\n-\t;\n-\n-initval:\n-\t  '{'\n-\t\t{ push_init_level (0); }\n-\t  initlist_maybe_comma '}'\n-\t\t{ process_init_element (pop_init_level (0)); }\n-\t| expr_no_commas\n-\t\t{ process_init_element ($1); }\n-\t| error\n-\t;\n-\n-designator_list:\n-\t  designator\n-\t| designator_list designator\n-\t;\n-\n-designator:\n-\t  '.' identifier\n-\t\t{ set_init_label ($2); }\n-\t/* These are for labeled elements.  The syntax for an array element\n-\t   initializer conflicts with the syntax for an Objective-C message,\n-\t   so don't include these productions in the Objective-C grammar.  */\n-\t| '[' expr_no_commas ELLIPSIS expr_no_commas ']'\n-\t\t{ set_init_index ($2, $4); }\n-\t| '[' expr_no_commas ']'\n-\t\t{ set_init_index ($2, NULL_TREE); }\n-\t;\n-\f\n-nested_function:\n-\t  declarator\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids nested functions\");\n-\n-\t\t  push_function_context ();\n-\t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    {\n-\t\t      pop_function_context ();\n-\t\t      YYERROR1;\n-\t\t    }\n-\t\t  reinit_parse_for_function (); }\n-\t   old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-/* This used to use compstmt_or_error.\n-   That caused a bug with input `f(g) int g {}',\n-   where the use of YYERROR1 above caused an error\n-   which then was handled by compstmt_or_error.\n-   There followed a repeated execution of that same rule,\n-   which called YYERROR1 again, and so on.  */\n-\t  compstmt\n-\t\t{ finish_function (1);\n-\t\t  pop_function_context (); }\n-\t;\n-\n-notype_nested_function:\n-\t  notype_declarator\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids nested functions\");\n-\n-\t\t  push_function_context ();\n-\t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    {\n-\t\t      pop_function_context ();\n-\t\t      YYERROR1;\n-\t\t    }\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-/* This used to use compstmt_or_error.\n-   That caused a bug with input `f(g) int g {}',\n-   where the use of YYERROR1 above caused an error\n-   which then was handled by compstmt_or_error.\n-   There followed a repeated execution of that same rule,\n-   which called YYERROR1 again, and so on.  */\n-\t  compstmt\n-\t\t{ finish_function (1);\n-\t\t  pop_function_context (); }\n-\t;\n-\n-/* Any kind of declarator (thus, all declarators allowed\n-   after an explicit typespec).  */\n-\n-declarator:\n-\t  after_type_declarator\n-\t| notype_declarator\n-\t;\n-\n-/* A declarator that is allowed only after an explicit typespec.  */\n-\n-after_type_declarator:\n-\t  '(' after_type_declarator ')'\n-\t\t{ $$ = $2; }\n-\t| after_type_declarator '(' parmlist_or_identifiers  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-/*\t| after_type_declarator '(' error ')'  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n-\t\t  poplevel (0, 0, 0); }  */\n-\t| after_type_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| after_type_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '*' type_quals after_type_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs after_type_declarator\n-\t\t{ $$ = $3; }\n-\t| TYPENAME\n-\t;\n-\n-/* Kinds of declarator that can appear in a parameter list\n-   in addition to notype_declarator.  This is like after_type_declarator\n-   but does not allow a typedef name in parentheses as an identifier\n-   (because it would conflict with a function with that typedef as arg).  */\n-\n-parm_declarator:\n-\t  parm_declarator '(' parmlist_or_identifiers  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-/*\t| parm_declarator '(' error ')'  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n-\t\t  poplevel (0, 0, 0); }  */\n-\t| parm_declarator '[' '*' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE);\n-\t\t  if (! flag_isoc99)\n-\t\t    error (\"`[*]' in parameter declaration only allowed in ISO C 99\");\n-\t\t}\n-\t| parm_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| parm_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '*' type_quals parm_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs parm_declarator\n-\t\t{ $$ = $3; }\n-\t| TYPENAME\n-\t;\n-\n-/* A declarator allowed whether or not there has been\n-   an explicit typespec.  These cannot redeclare a typedef-name.  */\n-\n-notype_declarator:\n-\t  notype_declarator '(' parmlist_or_identifiers  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-/*\t| notype_declarator '(' error ')'  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n-\t\t  poplevel (0, 0, 0); }  */\n-\t| '(' notype_declarator ')'\n-\t\t{ $$ = $2; }\n-\t| '*' type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| notype_declarator '[' '*' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE);\n-\t\t  if (! flag_isoc99)\n-\t\t    error (\"`[*]' in parameter declaration only allowed in ISO C 99\");\n-\t\t}\n-\t| notype_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| notype_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs notype_declarator\n-\t\t{ $$ = $3; }\n-\t| IDENTIFIER\n-\t;\n-\n-struct_head:\n-\t  STRUCT\n-\t\t{ $$ = NULL_TREE; }\n-\t| STRUCT attributes\n-\t\t{ $$ = $2; }\n-\t;\n-\n-union_head:\n-\t  UNION\n-\t\t{ $$ = NULL_TREE; }\n-\t| UNION attributes\n-\t\t{ $$ = $2; }\n-\t;\n-\n-enum_head:\n-\t  ENUM\n-\t\t{ $$ = NULL_TREE; }\n-\t| ENUM attributes\n-\t\t{ $$ = $2; }\n-\t;\n-\n-structsp:\n-\t  struct_head identifier '{'\n-\t\t{ $$ = start_struct (RECORD_TYPE, $2);\n-\t\t  /* Start scope of tag before parsing components.  */\n-\t\t}\n-\t  component_decl_list '}' maybe_attribute \n-\t\t{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }\n-\t| struct_head '{' component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n-\t\t\t\t      $3, chainon ($1, $5));\n-\t\t}\n-\t| struct_head identifier\n-\t\t{ $$ = xref_tag (RECORD_TYPE, $2); }\n-\t| union_head identifier '{'\n-\t\t{ $$ = start_struct (UNION_TYPE, $2); }\n-\t  component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }\n-\t| union_head '{' component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct (start_struct (UNION_TYPE, NULL_TREE),\n-\t\t\t\t      $3, chainon ($1, $5));\n-\t\t}\n-\t| union_head identifier\n-\t\t{ $$ = xref_tag (UNION_TYPE, $2); }\n-\t| enum_head identifier '{'\n-\t\t{ $$ = start_enum ($2); }\n-\t  enumlist maybecomma_warn '}' maybe_attribute\n-\t\t{ $$ = finish_enum ($<ttype>4, nreverse ($5),\n-\t\t\t\t    chainon ($1, $8)); }\n-\t| enum_head '{'\n-\t\t{ $$ = start_enum (NULL_TREE); }\n-\t  enumlist maybecomma_warn '}' maybe_attribute\n-\t\t{ $$ = finish_enum ($<ttype>3, nreverse ($4),\n-\t\t\t\t    chainon ($1, $7)); }\n-\t| enum_head identifier\n-\t\t{ $$ = xref_tag (ENUMERAL_TYPE, $2); }\n-\t;\n-\n-maybecomma:\n-\t  /* empty */\n-\t| ','\n-\t;\n-\n-maybecomma_warn:\n-\t  /* empty */\n-\t| ','\n-\t\t{ if (pedantic && ! flag_isoc99)\n-\t\t    pedwarn (\"comma at end of enumerator list\"); }\n-\t;\n-\n-component_decl_list:\n-\t  component_decl_list2\n-\t\t{ $$ = $1; }\n-\t| component_decl_list2 component_decl\n-\t\t{ $$ = chainon ($1, $2);\n-\t\t  pedwarn (\"no semicolon at end of struct or union\"); }\n-\t;\n-\n-component_decl_list2:\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| component_decl_list2 component_decl ';'\n-\t\t{ $$ = chainon ($1, $2); }\n-\t| component_decl_list2 ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"extra semicolon in struct or union specified\"); }\n-\t;\n-\n-/* There is a shift-reduce conflict here, because `components' may\n-   start with a `typename'.  It happens that shifting (the default resolution)\n-   does the right thing, because it treats the `typename' as part of\n-   a `typed_typespecs'.\n-\n-   It is possible that this same technique would allow the distinction\n-   between `notype_initdecls' and `initdecls' to be eliminated.\n-   But I am being cautious and not trying it.  */\n-\n-component_decl:\n-\t  typed_typespecs setspecs components\n-\t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_typespecs setspecs save_filename save_lineno maybe_attribute\n-\t\t{\n-\t\t  /* Support for unnamed structs or unions as members of \n-\t\t     structs or unions (which is [a] useful and [b] supports \n-\t\t     MS P-SDK).  */\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C doesn't support unnamed structs/unions\");\n-\n-\t\t  $$ = grokfield($3, $4, NULL, current_declspecs, NULL_TREE);\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n-\t\t}\n-    | nonempty_type_quals setspecs components\n-\t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| nonempty_type_quals\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids member declarations with no members\");\n-\t\t  shadow_tag($1);\n-\t\t  $$ = NULL_TREE; }\n-\t| error\n-\t\t{ $$ = NULL_TREE; }\n-\t| extension component_decl\n-\t\t{ $$ = $2;\n-\t\t  RESTORE_WARN_FLAGS ($1); }\n-\t;\n-\n-components:\n-\t  component_declarator\n-\t| components ',' component_declarator\n-\t\t{ $$ = chainon ($1, $3); }\n-\t;\n-\n-component_declarator:\n-\t  save_filename save_lineno declarator maybe_attribute\n-\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);\n-\t\t  decl_attributes ($$, $4, prefix_attributes); }\n-\t| save_filename save_lineno\n-\t  declarator ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);\n-\t\t  decl_attributes ($$, $6, prefix_attributes); }\n-\t| save_filename save_lineno ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);\n-\t\t  decl_attributes ($$, $5, prefix_attributes); }\n-\t;\n-\n-/* We chain the enumerators in reverse order.\n-   They are put in forward order where enumlist is used.\n-   (The order used to be significant, but no longer is so.\n-   However, we still maintain the order, just to be clean.)  */\n-\n-enumlist:\n-\t  enumerator\n-\t| enumlist ',' enumerator\n-\t\t{ if ($1 == error_mark_node)\n-\t\t    $$ = $1;\n-\t\t  else\n-\t\t    $$ = chainon ($3, $1); }\n-\t| error\n-\t\t{ $$ = error_mark_node; }\n-\t;\n-\n-\n-enumerator:\n-\t  identifier\n-\t\t{ $$ = build_enumerator ($1, NULL_TREE); }\n-\t| identifier '=' expr_no_commas\n-\t\t{ $$ = build_enumerator ($1, $3); }\n-\t;\n-\n-typename:\n-\ttyped_typespecs absdcl\n-\t\t{ $$ = build_tree_list ($1, $2); }\n-\t| nonempty_type_quals absdcl\n-\t\t{ $$ = build_tree_list ($1, $2); }\n-\t;\n-\n-absdcl:   /* an absolute declarator */\n-\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| absdcl1\n-\t;\n-\n-nonempty_type_quals:\n-\t  TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-\t| nonempty_type_quals TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-type_quals:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| type_quals TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-absdcl1:  /* a nonempty absolute declarator */\n-\t  '(' absdcl1 ')'\n-\t\t{ $$ = $2; }\n-\t  /* `(typedef)1' is `int'.  */\n-\t| '*' type_quals absdcl1  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '*' type_quals  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n-\t| absdcl1 '(' parmlist  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-\t| absdcl1 '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| absdcl1 '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '(' parmlist  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, NULL_TREE, $2, NULL_TREE); }\n-\t| '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, $2); }\n-\t| '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }\n-\t/* ??? It appears we have to support attributes here, however\n-\t   using prefix_attributes is wrong.  */\n-\t| attributes setattrs absdcl1\n-\t\t{ $$ = $3; }\n-\t;\n-\n-/* at least one statement, the first of which parses without error.  */\n-/* stmts is used only after decls, so an invalid first statement\n-   is actually regarded as an invalid decl and part of the decls.  */\n-\n-stmts:\n-\tlineno_stmt_or_labels\n-\t\t{\n-\t\t  if (pedantic && $1)\n-\t\t    pedwarn (\"ANSI C forbids label at end of compound statement\");\n-\t\t}\n-\t;\n-\n-lineno_stmt_or_labels:\n-\t  lineno_stmt_or_label\n-\t| lineno_stmt_or_labels lineno_stmt_or_label\n-\t\t{ $$ = $2; }\n-\t| lineno_stmt_or_labels errstmt\n-\t\t{ $$ = 0; }\n-\t;\n-\n-xstmts:\n-\t/* empty */\n-\t| stmts\n-\t;\n-\n-errstmt:  error ';'\n-\t;\n-\n-pushlevel:  /* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  pushlevel (0);\n-\t\t  clear_last_expr ();\n-\t\t  expand_start_bindings (0);\n-\t\t}\n-\t;\n-\n-/* Read zero or more forward-declarations for labels\n-   that nested functions can jump to.  */\n-maybe_label_decls:\n-\t  /* empty */\n-\t| label_decls\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids label declarations\"); }\n-\t;\n-\n-label_decls:\n-\t  label_decl\n-\t| label_decls label_decl\n-\t;\n-\n-label_decl:\n-\t  LABEL identifiers_or_typenames ';'\n-\t\t{ tree link;\n-\t\t  for (link = $2; link; link = TREE_CHAIN (link))\n-\t\t    {\n-\t\t      tree label = shadow_label (TREE_VALUE (link));\n-\t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t\t      declare_nonlocal_label (label);\n-\t\t    }\n-\t\t}\n-\t;\n-\n-/* This is the body of a function definition.\n-   It causes syntax errors to ignore to the next openbrace.  */\n-compstmt_or_error:\n-\t  compstmt\n-\t\t{}\n-\t| error compstmt\n-\t;\n-\n-compstmt_start: '{' { compstmt_count++; }\n-\n-compstmt_nostart: '}'\n-\t\t{ $$ = convert (void_type_node, integer_zero_node); }\n-\t| pushlevel maybe_label_decls decls xstmts '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), 1, 0);\n-\t\t  $$ = poplevel (1, 1, 0); }\n-\t| pushlevel maybe_label_decls error '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0); }\n-\t| pushlevel maybe_label_decls stmts '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0); }\n-\t;\n-\n-compstmt_primary_start:\n-\t'(' '{'\n-\t\t{ if (current_function_decl == 0)\n-\t\t    {\n-\t\t      error (\"braced-group within expression allowed only inside a function\");\n-\t\t      YYERROR;\n-\t\t    }\n-\t\t  /* We must force a BLOCK for this level\n-\t\t     so that, if it is not expanded later,\n-\t\t     there is a way to turn off the entire subtree of blocks\n-\t\t     that are contained in it.  */\n-\t\t  keep_next_level ();\n-\t\t  push_iterator_stack ();\n-\t\t  push_label_level ();\n-\t\t  $$ = expand_start_stmt_expr ();\n-\t\t  compstmt_count++;\n-\t\t}\n-\n-compstmt: compstmt_start compstmt_nostart\n-\t\t{ $$ = $2; }\n-\t;\n-\n-/* Value is number of statements counted as of the closeparen.  */\n-simple_if:\n-\t  if_prefix lineno_labeled_stmt\n-/* Make sure c_expand_end_cond is run once\n-   for each call to c_expand_start_cond.\n-   Otherwise a crash is likely.  */\n-\t| if_prefix error\n-\t;\n-\n-if_prefix:\n-\t  IF '(' expr ')'\n-\t\t{ emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_start_cond (truthvalue_conversion ($3), 0, \n-\t\t\t\t       compstmt_count);\n-\t\t  $<itype>$ = stmt_count;\n-\t\t  if_stmt_file = $<filename>-1;\n-\t\t  if_stmt_line = $<lineno>0;\n-\t\t  position_after_white_space (); }\n-\t;\n-\n-/* This is a subroutine of stmt.\n-   It is used twice, once for valid DO statements\n-   and once for catching errors in parsing the end test.  */\n-do_stmt_start:\n-\t  DO\n-\t\t{ stmt_count++;\n-\t\t  compstmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* See comment in `while' alternative, above.  */\n-\t\t  emit_nop ();\n-\t\t  expand_start_loop_continue_elsewhere (1);\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt WHILE\n-\t\t{ expand_loop_continue_here (); }\n-\t;\n-\n-save_filename:\n-\t\t{ $$ = input_filename; }\n-\t;\n-\n-save_lineno:\n-\t\t{ $$ = lineno; }\n-\t;\n-\n-lineno_labeled_stmt:\n-\t  save_filename save_lineno stmt\n-\t\t{ }\n-/*\t| save_filename save_lineno error\n-\t\t{ }\n-*/\n-\t| save_filename save_lineno label lineno_labeled_stmt\n-\t\t{ }\n-\t;\n-\n-lineno_stmt_or_label:\n-\t  save_filename save_lineno stmt_or_label\n-\t\t{ $$ = $3; }\n-\t;\n-\n-stmt_or_label:\n-\t  stmt\n-\t\t{ $$ = 0; }\n-\t| label\n-\t\t{ $$ = 1; }\n-\t;\n-\n-/* Parse a single real statement, not including any labels.  */\n-stmt:\n-\t  compstmt\n-\t\t{ stmt_count++; }\n-        | all_iter_stmt \n-\t| expr ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-/* It appears that this should not be done--that a non-lvalue array\n-   shouldn't get an error if the value isn't used.\n-   Section 3.2.2.1 says that an array lvalue gets converted to a pointer\n-   if it appears as a top-level expression,\n-   but says nothing about non-lvalue arrays.  */\n-#if 0\n-\t\t  /* Call default_conversion to get an error\n-\t\t     on referring to a register array if pedantic.  */\n-\t\t  if (TREE_CODE (TREE_TYPE ($1)) == ARRAY_TYPE\n-\t\t      || TREE_CODE (TREE_TYPE ($1)) == FUNCTION_TYPE)\n-\t\t    $1 = default_conversion ($1);\n-#endif\n-\t\t  iterator_expand ($1); }\n-\t| simple_if ELSE\n-\t\t{ c_expand_start_else ();\n-\t\t  $<itype>1 = stmt_count;\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ c_expand_end_cond ();\n-\t\t  if (extra_warnings && stmt_count == $<itype>1)\n-\t\t    warning (\"empty body in an else-statement\"); }\n-\t| simple_if %prec IF\n-\t\t{ c_expand_end_cond ();\n-\t\t  /* This warning is here instead of in simple_if, because we\n-\t\t     do not want a warning if an empty if is followed by an\n-\t\t     else statement.  Increment stmt_count so we don't\n-\t\t     give a second error if this is a nested `if'.  */\n-\t\t  if (extra_warnings && stmt_count++ == $<itype>1)\n-\t\t    warning_with_file_and_line (if_stmt_file, if_stmt_line,\n-\t\t\t\t\t\t\"empty body in an if-statement\"); }\n-/* Make sure c_expand_end_cond is run once\n-   for each call to c_expand_start_cond.\n-   Otherwise a crash is likely.  */\n-\t| simple_if ELSE error\n-\t\t{ c_expand_end_cond (); }\n-\t| WHILE\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* The emit_nop used to come before emit_line_note,\n-\t\t     but that made the nop seem like part of the preceding line.\n-\t\t     And that was confusing when the preceding line was\n-\t\t     inside of an if statement and was not really executed.\n-\t\t     I think it ought to work to put the nop after the line number.\n-\t\t     We will see.  --rms, July 15, 1991.  */\n-\t\t  emit_nop (); }\n-\t  '(' expr ')'\n-\t\t{ /* Don't start the loop till we have succeeded\n-\t\t     in parsing the end test.  This is to make sure\n-\t\t     that we end every loop we start.  */\n-\t\t  expand_start_loop (1);\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t     truthvalue_conversion ($4));\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ expand_end_loop (); }\n-\t| do_stmt_start\n-\t  '(' expr ')' ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t     truthvalue_conversion ($3));\n-\t\t  expand_end_loop (); }\n-/* This rule is needed to make sure we end every loop we start.  */\n-\t| do_stmt_start error\n-\t\t{ expand_end_loop (); }\n-\t| FOR\n-\t  '(' xexpr ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* See comment in `while' alternative, above.  */\n-\t\t  emit_nop ();\n-\t\t  if ($3) c_expand_expr_stmt ($3);\n-\t\t  /* Next step is to call expand_start_loop_continue_elsewhere,\n-\t\t     but wait till after we parse the entire for (...).\n-\t\t     Otherwise, invalid input might cause us to call that\n-\t\t     fn without calling expand_end_loop.  */\n-\t\t}\n-\t  xexpr ';'\n-\t\t/* Can't emit now; wait till after expand_start_loop...  */\n-\t\t{ $<lineno>7 = lineno;\n-\t\t  $<filename>$ = input_filename; }\n-\t  xexpr ')'\n-\t\t{ \n-\t\t  /* Start the loop.  Doing this after parsing\n-\t\t     all the expressions ensures we will end the loop.  */\n-\t\t  expand_start_loop_continue_elsewhere (1);\n-\t\t  /* Emit the end-test, with a line number.  */\n-\t\t  emit_line_note ($<filename>8, $<lineno>7);\n-\t\t  if ($6)\n-\t\t    expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t       truthvalue_conversion ($6));\n-\t\t  $<lineno>7 = lineno;\n-\t\t  $<filename>8 = input_filename;\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ /* Emit the increment expression, with a line number.  */\n-\t\t  emit_line_note ($<filename>8, $<lineno>7);\n-\t\t  expand_loop_continue_here ();\n-\t\t  if ($9)\n-\t\t    c_expand_expr_stmt ($9);\n-\t\t  expand_end_loop (); }\n-\t| SWITCH '(' expr ')'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_start_case ($3);\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ expand_end_case ($3); }\n-\t| BREAK ';'\n-\t        { tree break_stmt = build_break_stmt ();\n-\t\t  stmt_count++;\n-\t\t  genrtl_break_stmt (); }\n-\t| CONTINUE ';'\n-                { tree continue_stmt = build_continue_stmt ();\n-                  stmt_count++;\n-\t\t  genrtl_continue_stmt (); }\n-\t| RETURN ';'\n-                { tree return_stmt = build_return_stmt (NULL_TREE);\n-                  stmt_count++;\n-\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n-\t| RETURN expr ';'\n-                { tree return_stmt = build_return_stmt ($2);\n-                  stmt_count++;\n-\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  STRIP_NOPS ($4);\n-\t\t  if ((TREE_CODE ($4) == ADDR_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND ($4, 0)) == STRING_CST)\n-\t\t      || TREE_CODE ($4) == STRING_CST)\n-\t\t    expand_asm ($4);\n-\t\t  else\n-\t\t    error (\"argument of `asm' is not a constant string\"); }\n-\t/* This is the case with just output operands.  */\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n-\t/* This is the case with input operands as well.  */\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':' asm_operands ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_asm_operands ($4, $6, $8, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n-\t/* This is the case with clobbered registers as well.  */\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n-  \t  asm_operands ':' asm_clobbers ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_asm_operands ($4, $6, $8, $10,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n-\t| GOTO identifier ';'\n-\t\t{ tree decl;\n-\t\t  stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  decl = lookup_label ($2);\n-\t\t  if (decl != 0)\n-\t\t    {\n-\t\t      TREE_USED (decl) = 1;\n-\t\t      expand_goto (decl);\n-\t\t    }\n-\t\t}\n-\t| GOTO '*' expr ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids `goto *expr;'\");\n-\t\t  stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  expand_computed_goto (convert (ptr_type_node, $3)); }\n-\t| ';'\n-\t;\n-\n-all_iter_stmt:\n-\t  all_iter_stmt_simple\n-/*\t| all_iter_stmt_with_decl */\n-\t;\n-\n-all_iter_stmt_simple:\n-\t  FOR '(' primary ')' \n-\t  {\n-\t    /* The value returned by this action is  */\n-\t    /*      1 if everything is OK */ \n-\t    /*      0 in case of error or already bound iterator */\n-\n-\t    $<itype>$ = 0;\n-\t    if (TREE_CODE ($3) != VAR_DECL)\n-\t      error (\"invalid `for (ITERATOR)' syntax\");\n-\t    else if (! ITERATOR_P ($3))\n-\t      error (\"`%s' is not an iterator\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n-\t    else if (ITERATOR_BOUND_P ($3))\n-\t      error (\"`for (%s)' inside expansion of same iterator\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n-\t    else\n-\t      {\n-\t\t$<itype>$ = 1;\n-\t\titerator_for_loop_start ($3);\n-\t      }\n-\t  }\n-\t  lineno_labeled_stmt\n-\t  {\n-\t    if ($<itype>5)\n-\t      iterator_for_loop_end ($3);\n-\t  }\n-\n-/*  This really should allow any kind of declaration,\n-    for generality.  Fix it before turning it back on.\n-\n-all_iter_stmt_with_decl:\n-\t  FOR '(' ITERATOR pushlevel setspecs iterator_spec ')' \n-\t  {\n-*/\t    /* The value returned by this action is  */\n-\t    /*      1 if everything is OK */ \n-\t    /*      0 in case of error or already bound iterator */\n-/*\n-\t    iterator_for_loop_start ($6);\n-\t  }\n-\t  lineno_labeled_stmt\n-\t  {\n-\t    iterator_for_loop_end ($6);\n-\t    emit_line_note (input_filename, lineno);\n-\t    expand_end_bindings (getdecls (), 1, 0);\n-\t    $<ttype>$ = poplevel (1, 1, 0);\n-\t  }\n-*/\n-\n-/* Any kind of label, including jump labels and case labels.\n-   ANSI C accepts labels only before statements, but we allow them\n-   also at the end of a compound statement.  */\n-\n-label:\t  CASE expr_no_commas ':'\n-                { tree case_label_tree = build_case_label ($2, NULL_TREE);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n-\t\t}\n-\t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-                { tree case_label_tree = build_case_label ($2, $4);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n-\t\t}\n-\t| DEFAULT ':'\n-                { tree case_label_tree = build_case_label (NULL_TREE, NULL_TREE);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n-\t\t}\n-\t| identifier ':' maybe_attribute\n-\t\t{ tree label = define_label (input_filename, lineno, $1);\n-\t\t  stmt_count++;\n-\t\t  emit_nop ();\n-\t\t  if (label)\n-\t\t    {\n-\t\t      expand_label (label);\n-\t\t      decl_attributes (label, $3, NULL_TREE);\n-\t\t    }\n-\t\t  position_after_white_space (); }\n-\t;\n-\n-/* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */\n-\n-maybe_type_qual:\n-\t/* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  $$ = NULL_TREE; }\n-\t| TYPE_QUAL\n-\t\t{ emit_line_note (input_filename, lineno); }\n-\t;\n-\n-xexpr:\n-\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| expr\n-\t;\n-\n-/* These are the operands other than the first string and colon\n-   in  asm (\"addextend %2,%1\": \"=dm\" (x), \"0\" (y), \"g\" (*x))  */\n-asm_operands: /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| nonnull_asm_operands\n-\t;\n-\n-nonnull_asm_operands:\n-\t  asm_operand\n-\t| nonnull_asm_operands ',' asm_operand\n-\t\t{ $$ = chainon ($1, $3); }\n-\t;\n-\n-asm_operand:\n-\t  STRING '(' expr ')'\n-\t\t{ $$ = build_tree_list ($1, $3); }\n-\t;\n-\n-asm_clobbers:\n-\t  string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($1), NULL_TREE); }\n-\t| asm_clobbers ',' string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($3), $1); }\n-\t;\n-\f\n-/* This is what appears inside the parens in a function declarator.\n-   Its value is a list of ..._TYPE nodes.  */\n-parmlist:\n-\t\t{ pushlevel (0);\n-\t\t  clear_parm_order ();\n-\t\t  declare_parm_level (0); }\n-\t  parmlist_1\n-\t\t{ $$ = $2;\n-\t\t  parmlist_tags_warning ();\n-\t\t  poplevel (0, 0, 0); }\n-\t;\n-\n-parmlist_1:\n-\t  parmlist_2 ')'\n-\t| parms ';'\n-\t\t{ tree parm;\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids forward parameter declarations\");\n-\t\t  /* Mark the forward decls as such.  */\n-\t\t  for (parm = getdecls (); parm; parm = TREE_CHAIN (parm))\n-\t\t    TREE_ASM_WRITTEN (parm) = 1;\n-\t\t  clear_parm_order (); }\n-\t  parmlist_1\n-\t\t{ $$ = $4; }\n-\t| error ')'\n-\t\t{ $$ = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); }\n-\t;\n-\n-/* This is what appears inside the parens in a function declarator.\n-   Is value is represented in the format that grokdeclarator expects.  */\n-parmlist_2:  /* empty */\n-\t\t{ $$ = get_parm_info (0); }\n-\t| ELLIPSIS\n-\t\t{ $$ = get_parm_info (0);\n-\t\t  /* Gcc used to allow this as an extension.  However, it does\n-\t\t     not work for all targets, and thus has been disabled.\n-\t\t     Also, since func (...) and func () are indistinguishable,\n-\t\t     it caused problems with the code in expand_builtin which\n-\t\t     tries to verify that BUILT_IN_NEXT_ARG is being used\n-\t\t     correctly.  */\n-\t\t  error (\"ANSI C requires a named argument before `...'\");\n-\t\t}\n-\t| parms\n-\t\t{ $$ = get_parm_info (1); }\n-\t| parms ',' ELLIPSIS\n-\t\t{ $$ = get_parm_info (0); }\n-\t;\n-\n-parms:\n-\tparm\n-\t\t{ push_parm_decl ($1); }\n-\t| parms ',' parm\n-\t\t{ push_parm_decl ($3); }\n-\t;\n-\n-/* A single parameter declaration or parameter type name,\n-   as found in a parmlist.  */\n-parm:\n-\t  typed_declspecs setspecs parm_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs notype_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4)); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs absdcl maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\n-\t| declmods setspecs absdcl maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t;\n-\n-/* This is used in a function definition\n-   where either a parmlist or an identifier list is ok.\n-   Its value is a list of ..._TYPE nodes or a list of identifiers.  */\n-parmlist_or_identifiers:\n-\t\t{ pushlevel (0);\n-\t\t  clear_parm_order ();\n-\t\t  declare_parm_level (1); }\n-\t  parmlist_or_identifiers_1\n-\t\t{ $$ = $2;\n-\t\t  parmlist_tags_warning ();\n-\t\t  poplevel (0, 0, 0); }\n-\t;\n-\n-parmlist_or_identifiers_1:\n-\t  parmlist_1\n-\t| identifiers ')'\n-\t\t{ tree t;\n-\t\t  for (t = $1; t; t = TREE_CHAIN (t))\n-\t\t    if (TREE_VALUE (t) == NULL_TREE)\n-\t\t      error (\"`...' in old-style identifier list\");\n-\t\t  $$ = tree_cons (NULL_TREE, NULL_TREE, $1); }\n-\t;\n-\n-/* A nonempty list of identifiers.  */\n-identifiers:\n-\tIDENTIFIER\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| identifiers ',' IDENTIFIER\n-\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n-\t;\n-\n-/* A nonempty list of identifiers, including typenames.  */\n-identifiers_or_typenames:\n-\tidentifier\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| identifiers_or_typenames ',' identifier\n-\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n-\t;\n-\n-extension:\n-\tEXTENSION\n-\t\t{ $$ = SAVE_WARN_FLAGS();\n-\t\t  pedantic = 0;\n-\t\t  warn_pointer_arith = 0; }\n-\t;\n-\f\n-%%"}, {"sha": "923a1229a5d1a408af597959d7d79ba422ba3e37", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=792abd35a87ae20cabe251f17498bdc85bb9bc65", "patch": "@@ -1,3 +1,9 @@\n+2000-07-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in ($(PARSE_H)): Depend directly on parse.y.\n+\t* parse.c: Remove.\n+\t* parse.h: Likewise.\n+\n 2000-07-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (layout_class_type): Add pointers to virtual bases after"}, {"sha": "efd65bde3941fa3f07ec402d75e661b13136a436", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=792abd35a87ae20cabe251f17498bdc85bb9bc65", "patch": "@@ -220,8 +220,7 @@ parse.o : $(PARSE_C) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n CONFLICTS = expect 33 shift/reduce conflicts and 58 reduce/reduce conflicts.\n-$(PARSE_H) : $(PARSE_C)\n-$(PARSE_C) : $(srcdir)/parse.y\n+$(PARSE_H) $(PARSE_C) : $(srcdir)/parse.y\n \t@echo $(CONFLICTS)\n \tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n \tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h"}, {"sha": "c0a984474ee98b5ce7d9844eef6b280a2bcd3d39", "filename": "gcc/cp/parse.c", "status": "removed", "additions": 0, "deletions": 8709, "changes": 8709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=e98da3dcf547827050a49d61ba26841c159b71d6"}, {"sha": "67d0f575df165cefea84fe1d3bce8461d568a6be", "filename": "gcc/cp/parse.h", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fcp%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fcp%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.h?ref=e98da3dcf547827050a49d61ba26841c159b71d6", "patch": "@@ -1,97 +0,0 @@\n-typedef union {\n-  long itype; \n-  tree ttype; \n-  char *strtype; \n-  enum tree_code code; \n-  flagged_type_tree ftype; \n-  struct pending_inline *pi;\n-} YYSTYPE;\n-#define\tIDENTIFIER\t257\n-#define\tTYPENAME\t258\n-#define\tSELFNAME\t259\n-#define\tPFUNCNAME\t260\n-#define\tSCSPEC\t261\n-#define\tTYPESPEC\t262\n-#define\tCV_QUALIFIER\t263\n-#define\tCONSTANT\t264\n-#define\tSTRING\t265\n-#define\tELLIPSIS\t266\n-#define\tSIZEOF\t267\n-#define\tENUM\t268\n-#define\tIF\t269\n-#define\tELSE\t270\n-#define\tWHILE\t271\n-#define\tDO\t272\n-#define\tFOR\t273\n-#define\tSWITCH\t274\n-#define\tCASE\t275\n-#define\tDEFAULT\t276\n-#define\tBREAK\t277\n-#define\tCONTINUE\t278\n-#define\tRETURN_KEYWORD\t279\n-#define\tGOTO\t280\n-#define\tASM_KEYWORD\t281\n-#define\tTYPEOF\t282\n-#define\tALIGNOF\t283\n-#define\tSIGOF\t284\n-#define\tATTRIBUTE\t285\n-#define\tEXTENSION\t286\n-#define\tLABEL\t287\n-#define\tREALPART\t288\n-#define\tIMAGPART\t289\n-#define\tVA_ARG\t290\n-#define\tAGGR\t291\n-#define\tVISSPEC\t292\n-#define\tDELETE\t293\n-#define\tNEW\t294\n-#define\tTHIS\t295\n-#define\tOPERATOR\t296\n-#define\tCXX_TRUE\t297\n-#define\tCXX_FALSE\t298\n-#define\tNAMESPACE\t299\n-#define\tTYPENAME_KEYWORD\t300\n-#define\tUSING\t301\n-#define\tLEFT_RIGHT\t302\n-#define\tTEMPLATE\t303\n-#define\tTYPEID\t304\n-#define\tDYNAMIC_CAST\t305\n-#define\tSTATIC_CAST\t306\n-#define\tREINTERPRET_CAST\t307\n-#define\tCONST_CAST\t308\n-#define\tSCOPE\t309\n-#define\tEMPTY\t310\n-#define\tPTYPENAME\t311\n-#define\tNSNAME\t312\n-#define\tTHROW\t313\n-#define\tASSIGN\t314\n-#define\tOROR\t315\n-#define\tANDAND\t316\n-#define\tMIN_MAX\t317\n-#define\tEQCOMPARE\t318\n-#define\tARITHCOMPARE\t319\n-#define\tLSHIFT\t320\n-#define\tRSHIFT\t321\n-#define\tPOINTSAT_STAR\t322\n-#define\tDOT_STAR\t323\n-#define\tUNARY\t324\n-#define\tPLUSPLUS\t325\n-#define\tMINUSMINUS\t326\n-#define\tHYPERUNARY\t327\n-#define\tPOINTSAT\t328\n-#define\tTRY\t329\n-#define\tCATCH\t330\n-#define\tEXTERN_LANG_STRING\t331\n-#define\tALL\t332\n-#define\tPRE_PARSED_CLASS_DECL\t333\n-#define\tDEFARG\t334\n-#define\tDEFARG_MARKER\t335\n-#define\tPRE_PARSED_FUNCTION_DECL\t336\n-#define\tTYPENAME_DEFN\t337\n-#define\tIDENTIFIER_DEFN\t338\n-#define\tPTYPENAME_DEFN\t339\n-#define\tEND_OF_LINE\t340\n-#define\tEND_OF_SAVED_INPUT\t341\n-\n-\n-extern YYSTYPE yylval;\n-#define YYEMPTY\t\t-2"}, {"sha": "621fbcc8ca05291dce9a699585f966fd4bdff5d6", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792abd35a87ae20cabe251f17498bdc85bb9bc65/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=792abd35a87ae20cabe251f17498bdc85bb9bc65", "patch": "@@ -1,3 +1,7 @@\n+2000-07-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* parse-scan.c: Remove.\n+\n 2000-07-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* jcf-write.c (generate_classfile): Don't install ConstantValue"}, {"sha": "649c18160d71997dcf0e80505f5e96194358d16d", "filename": "gcc/java/parse-scan.c", "status": "removed", "additions": 0, "deletions": 2571, "changes": 2571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fjava%2Fparse-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fjava%2Fparse-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.c?ref=e98da3dcf547827050a49d61ba26841c159b71d6"}, {"sha": "ed1eb18bfe2134462012a914bd1fbd87d2657601", "filename": "gcc/objc/objc-parse.c", "status": "removed", "additions": 0, "deletions": 5102, "changes": 5102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fobjc%2Fobjc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fobjc%2Fobjc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.c?ref=e98da3dcf547827050a49d61ba26841c159b71d6"}, {"sha": "91324bb48b0d15ca9c85d78488df4d9b9bdb945f", "filename": "gcc/objc/objc-parse.y", "status": "removed", "additions": 0, "deletions": 2781, "changes": 2781, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fobjc%2Fobjc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e98da3dcf547827050a49d61ba26841c159b71d6/gcc%2Fobjc%2Fobjc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.y?ref=e98da3dcf547827050a49d61ba26841c159b71d6", "patch": "@@ -1,2781 +0,0 @@\n-/*WARNING: This file is automatically generated!*/\n-/* YACC parser for C syntax and for Objective C.  -*-c-*-\n-   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996,\n-   1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This file defines the grammar of C and that of Objective C.\n-   ifobjc ... end ifobjc  conditionals contain code for Objective C only.\n-   ifc ... end ifc  conditionals contain code for C only.\n-   Sed commands in Makefile.in are used to convert this file into\n-   c-parse.y and into objc-parse.y.  */\n-\n-/* To whomever it may concern: I have heard that such a thing was once\n-   written by AT&T, but I have never seen it.  */\n-\n-%expect 74\n-\n-%{\n-#include \"config.h\"\n-#include \"system.h\"\n-#include <setjmp.h>\n-#include \"tree.h\"\n-#include \"input.h\"\n-#include \"c-lex.h\"\n-#include \"c-tree.h\"\n-#include \"flags.h\"\n-#include \"output.h\"\n-#include \"toplev.h\"\n-#include \"ggc.h\"\n-  \n-#ifdef MULTIBYTE_CHARS\n-#include <locale.h>\n-#endif\n-\n-#include \"objc-act.h\"\n-\n-/* Since parsers are distinct for each language, put the language string\n-   definition here.  */\n-const char * const language_string = \"GNU Obj-C\";\n-\n-/* Like YYERROR but do call yyerror.  */\n-#define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n-\n-/* Cause the `yydebug' variable to be defined.  */\n-#define YYDEBUG 1\n-%}\n-\n-%start program\n-\n-%union {long itype; tree ttype; enum tree_code code;\n-\tconst char *filename; int lineno; int ends_in_label; }\n-\n-/* All identifiers that are not reserved words\n-   and are not declared typedefs in the current block */\n-%token IDENTIFIER\n-\n-/* All identifiers that are declared typedefs in the current block.\n-   In some contexts, they are treated just like IDENTIFIER,\n-   but they can also serve as typespecs in declarations.  */\n-%token TYPENAME\n-\n-/* Reserved words that specify storage class.\n-   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token SCSPEC\n-\n-/* Reserved words that specify type.\n-   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token TYPESPEC\n-\n-/* Reserved words that qualify type: \"const\", \"volatile\", or \"restrict\".\n-   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token TYPE_QUAL\n-\n-/* Character or numeric constants.\n-   yylval is the node for the constant.  */\n-%token CONSTANT\n-\n-/* String constants in raw form.\n-   yylval is a STRING_CST node.  */\n-%token STRING\n-\n-/* \"...\", used for functions with variable arglists.  */\n-%token ELLIPSIS\n-\n-/* the reserved words */\n-/* SCO include files test \"ASM\", so use something else. */\n-%token SIZEOF ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n-%token BREAK CONTINUE RETURN GOTO ASM_KEYWORD TYPEOF ALIGNOF\n-%token ATTRIBUTE EXTENSION LABEL\n-%token REALPART IMAGPART VA_ARG\n-%token PTR_VALUE PTR_BASE PTR_EXTENT\n-\n-/* Used in c-lex.c for parsing pragmas.  */\n-%token END_OF_LINE\n-\n-/* Add precedence rules to solve dangling else s/r conflict */\n-%nonassoc IF\n-%nonassoc ELSE\n-\n-/* Define the operator tokens and their precedences.\n-   The value is an integer because, if used, it is the tree code\n-   to use in the expression made from the operator.  */\n-\n-%right <code> ASSIGN '='\n-%right <code> '?' ':'\n-%left <code> OROR\n-%left <code> ANDAND\n-%left <code> '|'\n-%left <code> '^'\n-%left <code> '&'\n-%left <code> EQCOMPARE\n-%left <code> ARITHCOMPARE\n-%left <code> LSHIFT RSHIFT\n-%left <code> '+' '-'\n-%left <code> '*' '/' '%'\n-%right <code> UNARY PLUSPLUS MINUSMINUS\n-%left HYPERUNARY\n-%left <code> POINTSAT '.' '(' '['\n-\n-/* The Objective-C keywords.  These are included in C and in\n-   Objective C, so that the token codes are the same in both.  */\n-%token INTERFACE IMPLEMENTATION END SELECTOR DEFS ENCODE\n-%token CLASSNAME PUBLIC PRIVATE PROTECTED PROTOCOL OBJECTNAME CLASS ALIAS\n-\n-/* Objective-C string constants in raw form.\n-   yylval is an OBJC_STRING_CST node.  */\n-%token OBJC_STRING\n-\n-\n-%type <code> unop\n-\n-%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n-%type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n-%type <ttype> typed_declspecs reserved_declspecs\n-%type <ttype> typed_typespecs reserved_typespecquals\n-%type <ttype> declmods typespec typespecqual_reserved\n-%type <ttype> typed_declspecs_no_prefix_attr reserved_declspecs_no_prefix_attr\n-%type <ttype> declmods_no_prefix_attr\n-%type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n-%type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n-%type <ttype> init maybeasm\n-%type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n-%type <ttype> maybe_attribute attributes attribute attribute_list attrib\n-%type <ttype> any_word extension\n-\n-%type <ttype> compstmt compstmt_nostart compstmt_primary_start\n-\n-%type <ttype> declarator\n-%type <ttype> notype_declarator after_type_declarator\n-%type <ttype> parm_declarator\n-\n-%type <ttype> structsp component_decl_list component_decl_list2\n-%type <ttype> component_decl components component_declarator\n-%type <ttype> enumlist enumerator\n-%type <ttype> struct_head union_head enum_head\n-%type <ttype> typename absdcl absdcl1 type_quals\n-%type <ttype> xexpr parms parm identifiers\n-\n-%type <ttype> parmlist parmlist_1 parmlist_2\n-%type <ttype> parmlist_or_identifiers parmlist_or_identifiers_1\n-%type <ttype> identifiers_or_typenames\n-\n-%type <itype> setspecs\n-\n-%type <ends_in_label> lineno_stmt_or_label lineno_stmt_or_labels stmt_or_label\n-\n-%type <filename> save_filename\n-%type <lineno> save_lineno\n-\f\n-/* the Objective-C nonterminals */\n-\n-%type <ttype> ivar_decl_list ivar_decls ivar_decl ivars ivar_declarator\n-%type <ttype> methoddecl unaryselector keywordselector selector\n-%type <ttype> keyworddecl receiver objcmessageexpr messageargs\n-%type <ttype> keywordexpr keywordarglist keywordarg\n-%type <ttype> myparms myparm optparmlist reservedwords objcselectorexpr\n-%type <ttype> selectorarg keywordnamelist keywordname objcencodeexpr\n-%type <ttype> objc_string non_empty_protocolrefs protocolrefs identifier_list objcprotocolexpr\n-\n-%type <ttype> CLASSNAME OBJC_STRING OBJECTNAME\n-\f\n-%{\n-/* Number of statements (loosely speaking) and compound statements \n-   seen so far.  */\n-static int stmt_count;\n-static int compstmt_count;\n-  \n-/* Input file and line number of the end of the body of last simple_if;\n-   used by the stmt-rule immediately after simple_if returns.  */\n-static const char *if_stmt_file;\n-static int if_stmt_line;\n-\n-/* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs = NULL_TREE;\n-static tree prefix_attributes = NULL_TREE;\n-\n-/* Stack of saved values of current_declspecs and prefix_attributes.  */\n-static tree declspec_stack;\n-\n-/* For __extension__, save/restore the warning flags which are\n-   controlled by __extension__.  */\n-#define SAVE_WARN_FLAGS()\t\\\n-\tsize_int (pedantic | (warn_pointer_arith << 1))\n-#define RESTORE_WARN_FLAGS(tval) \\\n-  do {                                     \\\n-    int val = tree_low_cst (tval, 0);      \\\n-    pedantic = val & 1;                    \\\n-    warn_pointer_arith = (val >> 1) & 1;   \\\n-  } while (0)\n-\n-/* Objective-C specific information */\n-\n-tree objc_interface_context;\n-tree objc_implementation_context;\n-tree objc_method_context;\n-tree objc_ivar_chain;\n-tree objc_ivar_context;\n-enum tree_code objc_inherit_code;\n-int objc_receiver_context;\n-int objc_public_flag;\n-\n-\n-/* Tell yyparse how to print a token's value, if yydebug is set.  */\n-\n-#define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n-\n-/* Add GC roots for variables local to this file.  */\n-void\n-c_parse_init ()\n-{\n-  ggc_add_tree_root (&declspec_stack, 1);\n-  ggc_add_tree_root (&current_declspecs, 1);\n-  ggc_add_tree_root (&prefix_attributes, 1);\n-  ggc_add_tree_root (&objc_interface_context, 1);\n-  ggc_add_tree_root (&objc_implementation_context, 1);\n-  ggc_add_tree_root (&objc_method_context, 1);\n-  ggc_add_tree_root (&objc_ivar_chain, 1);\n-  ggc_add_tree_root (&objc_ivar_context, 1);\n-}\n-\n-%}\n-\f\n-%%\n-program: /* empty */\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids an empty source file\");\n-\t\t  finish_file ();\n-\t\t}\n-\t| extdefs\n-\t\t{\n-\t\t  /* In case there were missing closebraces,\n-\t\t     get us back to the global binding level.  */\n-\t\t  while (! global_bindings_p ())\n-\t\t    poplevel (0, 0, 0);\n-\t\t  finish_file ();\n-\t\t}\n-\t;\n-\n-/* the reason for the strange actions in this rule\n- is so that notype_initdecls when reached via datadef\n- can find a valid list of type and sc specs in $0. */\n-\n-extdefs:\n-\t{$<ttype>$ = NULL_TREE; } extdef\n-\t| extdefs {$<ttype>$ = NULL_TREE; } extdef\n-\t;\n-\n-extdef:\n-\tfndef\n-\t| datadef\n-\t| objcdef\n-\t| ASM_KEYWORD '(' expr ')' ';'\n-\t\t{ STRIP_NOPS ($3);\n-\t\t  if ((TREE_CODE ($3) == ADDR_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND ($3, 0)) == STRING_CST)\n-\t\t      || TREE_CODE ($3) == STRING_CST)\n-\t\t    assemble_asm ($3);\n-\t\t  else\n-\t\t    error (\"argument of `asm' is not a constant string\"); }\n-\t| extension extdef\n-\t\t{ RESTORE_WARN_FLAGS ($1); }\n-\t;\n-\n-datadef:\n-\t  setspecs notype_initdecls ';'\n-\t\t{ if (pedantic)\n-\t\t    error (\"ANSI C forbids data definition with no type or storage class\");\n-\t\t  else if (!flag_traditional)\n-\t\t    warning (\"data definition has no type or storage class\"); \n-\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-        | declmods setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-        | declmods ';'\n-\t  { pedwarn (\"empty declaration\"); }\n-\t| typed_declspecs ';'\n-\t  { shadow_tag ($1); }\n-\t| error ';'\n-\t| error '}'\n-\t| ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C does not allow extra `;' outside of a function\"); }\n-\t;\n-\f\n-fndef:\n-\t  typed_declspecs setspecs declarator\n-\t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator\n-\t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| setspecs notype_declarator\n-\t\t{ if (! start_function (NULL_TREE, $2,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-\t  compstmt_or_error\n-\t\t{ finish_function (0); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| setspecs notype_declarator error\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t;\n-\n-identifier:\n-\tIDENTIFIER\n-\t| TYPENAME\n-\t| OBJECTNAME\n-        | CLASSNAME\n-\t;\n-\n-unop:     '&'\n-\t\t{ $$ = ADDR_EXPR; }\n-\t| '-'\n-\t\t{ $$ = NEGATE_EXPR; }\n-\t| '+'\n-\t\t{ $$ = CONVERT_EXPR; }\n-\t| PLUSPLUS\n-\t\t{ $$ = PREINCREMENT_EXPR; }\n-\t| MINUSMINUS\n-\t\t{ $$ = PREDECREMENT_EXPR; }\n-\t| '~'\n-\t\t{ $$ = BIT_NOT_EXPR; }\n-\t| '!'\n-\t\t{ $$ = TRUTH_NOT_EXPR; }\n-\t;\n-\n-expr:\tnonnull_exprlist\n-\t\t{ $$ = build_compound_expr ($1); }\n-\t;\n-\n-exprlist:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| nonnull_exprlist\n-\t;\n-\n-nonnull_exprlist:\n-\texpr_no_commas\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| nonnull_exprlist ',' expr_no_commas\n-\t\t{ chainon ($1, build_tree_list (NULL_TREE, $3)); }\n-\t;\n-\n-unary_expr:\n-\tprimary\n-\t| '*' cast_expr   %prec UNARY\n-\t\t{ $$ = build_indirect_ref ($2, \"unary *\"); }\n-\t/* __extension__ turns off -pedantic for following primary.  */\n-\t| extension cast_expr\t  %prec UNARY\n-\t\t{ $$ = $2;\n-\t\t  RESTORE_WARN_FLAGS ($1); }\n-\t| unop cast_expr  %prec UNARY\n-\t\t{ $$ = build_unary_op ($1, $2, 0);\n-\t\t  overflow_warning ($$); }\n-\t/* Refer to the address of a label as a pointer.  */\n-\t| ANDAND identifier\n-\t\t{ tree label = lookup_label ($2);\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids `&&'\");\n-\t\t  if (label == 0)\n-\t\t    $$ = null_pointer_node;\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_USED (label) = 1;\n-\t\t      $$ = build1 (ADDR_EXPR, ptr_type_node, label);\n-\t\t      TREE_CONSTANT ($$) = 1;\n-\t\t    }\n-\t\t}\n-/* This seems to be impossible on some machines, so let's turn it off.\n-   You can use __builtin_next_arg to find the anonymous stack args.\n-\t| '&' ELLIPSIS\n-\t\t{ tree types = TYPE_ARG_TYPES (TREE_TYPE (current_function_decl));\n-\t\t  $$ = error_mark_node;\n-\t\t  if (TREE_VALUE (tree_last (types)) == void_type_node)\n-\t\t    error (\"`&...' used in function with fixed number of arguments\");\n-\t\t  else\n-\t\t    {\n-\t\t      if (pedantic)\n-\t\t\tpedwarn (\"ANSI C forbids `&...'\");\n-\t\t      $$ = tree_last (DECL_ARGUMENTS (current_function_decl));\n-\t\t      $$ = build_unary_op (ADDR_EXPR, $$, 0);\n-\t\t    } }\n-*/\n-\t| sizeof unary_expr  %prec UNARY\n-\t\t{ skip_evaluation--;\n-\t\t  if (TREE_CODE ($2) == COMPONENT_REF\n-\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2, 1)))\n-\t\t    error (\"`sizeof' applied to a bit-field\");\n-\t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n-\t| sizeof '(' typename ')'  %prec HYPERUNARY\n-\t\t{ skip_evaluation--;\n-\t\t  $$ = c_sizeof (groktypename ($3)); }\n-\t| alignof unary_expr  %prec UNARY\n-\t\t{ skip_evaluation--;\n-\t\t  $$ = c_alignof_expr ($2); }\n-\t| alignof '(' typename ')'  %prec HYPERUNARY\n-\t\t{ skip_evaluation--;\n-\t\t  $$ = c_alignof (groktypename ($3)); }\n-\t| REALPART cast_expr %prec UNARY\n-\t\t{ $$ = build_unary_op (REALPART_EXPR, $2, 0); }\n-\t| IMAGPART cast_expr %prec UNARY\n-\t\t{ $$ = build_unary_op (IMAGPART_EXPR, $2, 0); }\n-\t| VA_ARG '(' expr_no_commas ',' typename ')'\n-\t\t{ $$ = build_va_arg ($3, groktypename ($5)); }\n-\t;\n-\n-sizeof:\n-\tSIZEOF { skip_evaluation++; }\n-\t;\n-\n-alignof:\n-\tALIGNOF { skip_evaluation++; }\n-\t;\n-\n-cast_expr:\n-\tunary_expr\n-\t| '(' typename ')' cast_expr  %prec UNARY\n-\t\t{ tree type = groktypename ($2);\n-\t\t  $$ = build_c_cast (type, $4); }\n-\t| '(' typename ')' '{' \n-\t\t{ start_init (NULL_TREE, NULL, 0);\n-\t\t  $2 = groktypename ($2);\n-\t\t  really_start_incremental_init ($2); }\n-\t  initlist_maybe_comma '}'  %prec UNARY\n-\t\t{ const char *name;\n-\t\t  tree result = pop_init_level (0);\n-\t\t  tree type = $2;\n-\t\t  finish_init ();\n-\n-\t\t  if (pedantic && ! flag_isoc99)\n-\t\t    pedwarn (\"ANSI C forbids constructor expressions\");\n-\t\t  if (TYPE_NAME (type) != 0)\n-\t\t    {\n-\t\t      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\t\t\tname = IDENTIFIER_POINTER (TYPE_NAME (type));\n-\t\t      else\n-\t\t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-\t\t    }\n-\t\t  else\n-\t\t    name = \"\";\n-\t\t  $$ = result;\n-\t\t  if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n-\t\t    {\n-\t\t      int failure = complete_array_type (type, $$, 1);\n-\t\t      if (failure)\n-\t\t\tabort ();\n-\t\t    }\n-\t\t}\n-\t;\n-\n-expr_no_commas:\n-\t  cast_expr\n-\t| expr_no_commas '+' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '-' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '*' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '/' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '%' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas LSHIFT expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas RSHIFT expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas ARITHCOMPARE expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas EQCOMPARE expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '&' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '|' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas '^' expr_no_commas\n-\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n-\t| expr_no_commas ANDAND\n-\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == boolean_false_node; }\n-\t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_false_node;\n-\t\t  $$ = parser_build_binary_op (TRUTH_ANDIF_EXPR, $1, $4); }\n-\t| expr_no_commas OROR\n-\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == boolean_true_node; }\n-\t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_true_node;\n-\t\t  $$ = parser_build_binary_op (TRUTH_ORIF_EXPR, $1, $4); }\n-\t| expr_no_commas '?'\n-\t\t{ $1 = truthvalue_conversion (default_conversion ($1));\n-\t\t  skip_evaluation += $1 == boolean_false_node; }\n-          expr ':'\n-\t\t{ skip_evaluation += (($1 == boolean_true_node)\n-\t\t\t\t      - ($1 == boolean_false_node)); }\n-\t  expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_true_node;\n-\t\t  $$ = build_conditional_expr ($1, $4, $7); }\n-\t| expr_no_commas '?'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids omitting the middle term of a ?: expression\");\n-\t\t  /* Make sure first operand is calculated only once.  */\n-\t\t  $<ttype>2 = save_expr ($1);\n-\t\t  $1 = truthvalue_conversion (default_conversion ($<ttype>2));\n-\t\t  skip_evaluation += $1 == boolean_true_node; }\n-\t  ':' expr_no_commas\n-\t\t{ skip_evaluation -= $1 == boolean_true_node;\n-\t\t  $$ = build_conditional_expr ($1, $<ttype>2, $5); }\n-\t| expr_no_commas '=' expr_no_commas\n-\t\t{ char class;\n-\t\t  $$ = build_modify_expr ($1, NOP_EXPR, $3);\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR);\n-\t\t}\n-\t| expr_no_commas ASSIGN expr_no_commas\n-\t\t{ char class;\n-\t\t  $$ = build_modify_expr ($1, $2, $3);\n-\t\t  /* This inhibits warnings in truthvalue_conversion.  */\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK);\n-\t\t}\n-\t;\n-\n-primary:\n-\tIDENTIFIER\n-\t\t{\n-\t\t  if (yychar == YYEMPTY)\n-\t\t    yychar = YYLEX;\n-\t\t  $$ = build_external_ref ($1, yychar == '(');\n-\t\t}\n-\t| CONSTANT\n-\t| string\n-\t\t{ $$ = combine_strings ($1); }\n-\t| '(' expr ')'\n-\t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($2, ERROR_MARK);\n-\t\t  $$ = $2; }\n-\t| '(' error ')'\n-\t\t{ $$ = error_mark_node; }\n-\t| compstmt_primary_start compstmt_nostart ')'\n-\t\t{ tree rtl_exp;\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids braced-groups within expressions\");\n-\t\t  pop_iterator_stack ();\n-\t\t  pop_label_level ();\n-\t\t  rtl_exp = expand_end_stmt_expr ($1);\n-\t\t  /* The statements have side effects, so the group does.  */\n-\t\t  TREE_SIDE_EFFECTS (rtl_exp) = 1;\n-\n-\t\t  if (TREE_CODE ($2) == BLOCK)\n-\t\t    {\n-\t\t      /* Make a BIND_EXPR for the BLOCK already made.  */\n-\t\t      $$ = build (BIND_EXPR, TREE_TYPE (rtl_exp),\n-\t\t\t\t  NULL_TREE, rtl_exp, $2);\n-\t\t      /* Remove the block from the tree at this point.\n-\t\t\t It gets put back at the proper place\n-\t\t\t when the BIND_EXPR is expanded.  */\n-\t\t      delete_block ($2);\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = $2;\n-\t\t}\n-\t| compstmt_primary_start error ')'\n-\t\t{\n-\t\t  /* Make sure we call expand_end_stmt_expr.  Otherwise\n-\t\t     we are likely to lose sequences and crash later.  */\n-\t\t  pop_iterator_stack ();\n-\t\t  pop_label_level ();\n-\t\t  expand_end_stmt_expr ($1);\n-\t\t  $$ = error_mark_node;\n-\t\t}\n-\t| primary '(' exprlist ')'   %prec '.'\n-\t\t{ $$ = build_function_call ($1, $3); }\n-\t| primary '[' expr ']'   %prec '.'\n-\t\t{ $$ = build_array_ref ($1, $3); }\n-\t| primary '.' identifier\n-\t\t{\n-                  if (doing_objc_thang)\n-                    {\n-\t\t      if (is_public ($1, $3))\n-\t\t\t$$ = build_component_ref ($1, $3);\n-\t\t      else\n-\t\t\t$$ = error_mark_node;\n-\t\t    }\n-                  else\n-\t\t    $$ = build_component_ref ($1, $3);\n-\t\t}\n-\t| primary POINTSAT identifier\n-\t\t{\n-                  tree expr = build_indirect_ref ($1, \"->\");\n-\n-                  if (doing_objc_thang)\n-                    {\n-\t\t      if (is_public (expr, $3))\n-\t\t\t$$ = build_component_ref (expr, $3);\n-\t\t      else\n-\t\t\t$$ = error_mark_node;\n-\t\t    }\n-                  else\n-                    $$ = build_component_ref (expr, $3);\n-\t\t}\n-\t| primary PLUSPLUS\n-\t\t{ $$ = build_unary_op (POSTINCREMENT_EXPR, $1, 0); }\n-\t| primary MINUSMINUS\n-\t\t{ $$ = build_unary_op (POSTDECREMENT_EXPR, $1, 0); }\n-\t| objcmessageexpr\n-\t\t{ $$ = build_message_expr ($1); }\n-\t| objcselectorexpr\n-\t\t{ $$ = build_selector_expr ($1); }\n-\t| objcprotocolexpr\n-\t\t{ $$ = build_protocol_expr ($1); }\n-\t| objcencodeexpr\n-\t\t{ $$ = build_encode_expr ($1); }\n-\t| objc_string\n-\t\t{ $$ = build_objc_string_object ($1); }\n-\t;\n-\n-/* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */\n-string:\n-\t  STRING\n-\t| string STRING\n-\t\t{ $$ = chainon ($1, $2);\n-\t\t}\n-\t;\n-\n-/* Produces an OBJC_STRING_CST with perhaps more OBJC_STRING_CSTs chained\n-   onto it.  */\n-objc_string:\n-\t  OBJC_STRING\n-\t| objc_string OBJC_STRING\n-\t\t{ $$ = chainon ($1, $2); }\n-\t;\n-\n-old_style_parm_decls:\n-\t/* empty */\n-\t| datadecls\n-\t| datadecls ELLIPSIS\n-\t\t/* ... is used here to indicate a varargs function.  */\n-\t\t{ c_mark_varargs ();\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C does not permit use of `varargs.h'\"); }\n-\t;\n-\n-/* The following are analogous to lineno_decl, decls and decl\n-   except that they do not allow nested functions.\n-   They are used for old-style parm decls.  */\n-lineno_datadecl:\n-\t  save_filename save_lineno datadecl\n-\t\t{ }\n-\t;\n-\n-datadecls:\n-\tlineno_datadecl\n-\t| errstmt\n-\t| datadecls lineno_datadecl\n-\t| lineno_datadecl errstmt\n-\t;\n-\n-/* We don't allow prefix attributes here because they cause reduce/reduce\n-   conflicts: we can't know whether we're parsing a function decl with\n-   attribute suffix, or function defn with attribute prefix on first old\n-   style parm.  */\n-datadecl:\n-\ttyped_declspecs_no_prefix_attr setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods_no_prefix_attr setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\t\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs_no_prefix_attr ';'\n-\t\t{ shadow_tag_warned ($1, 1);\n-\t\t  pedwarn (\"empty declaration\"); }\n-\t| declmods_no_prefix_attr ';'\n-\t\t{ pedwarn (\"empty declaration\"); }\n-\t;\n-\n-/* This combination which saves a lineno before a decl\n-   is the normal thing to use, rather than decl itself.\n-   This is to avoid shift/reduce conflicts in contexts\n-   where statement labels are allowed.  */\n-lineno_decl:\n-\t  save_filename save_lineno decl\n-\t\t{ }\n-\t;\n-\n-decls:\n-\tlineno_decl\n-\t| errstmt\n-\t| decls lineno_decl\n-\t| lineno_decl errstmt\n-\t;\n-\n-/* records the type and storage class specs to use for processing\n-   the declarators that follow.\n-   Maintains a stack of outer-level values of current_declspecs,\n-   for the sake of parm declarations nested in function declarators.  */\n-setspecs: /* empty */\n-\t\t{ pending_xref_error ();\n-\t\t  declspec_stack = tree_cons (prefix_attributes,\n-\t\t\t\t\t      current_declspecs,\n-\t\t\t\t\t      declspec_stack);\n-\t\t  split_specs_attrs ($<ttype>0,\n-\t\t\t\t     &current_declspecs, &prefix_attributes); }\n-\t;\n-\n-/* ??? Yuck.  See after_type_declarator.  */\n-setattrs: /* empty */\n-\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }\n-\t;\n-\n-decl:\n-\ttyped_declspecs setspecs initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_initdecls ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs nested_function\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_nested_function\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs ';'\n-\t\t{ shadow_tag ($1); }\n-\t| declmods ';'\n-\t\t{ pedwarn (\"empty declaration\"); }\n-\t| extension decl\n-\t\t{ RESTORE_WARN_FLAGS ($1); }\n-\t;\n-\n-/* Declspecs which contain at least one type specifier or typedef name.\n-   (Just `const' or `volatile' is not enough.)\n-   A typedef'd name following these is taken as a name to be declared.\n-   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n-\n-typed_declspecs:\n-\t  typespec reserved_declspecs\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| declmods typespec reserved_declspecs\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n-\t;\n-\n-reserved_declspecs:  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_declspecs typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs SCSPEC\n-\t\t{ if (extra_warnings)\n-\t\t    warning (\"`%s' is not at beginning of declaration\",\n-\t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs attributes\n-\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n-\t;\n-\n-typed_declspecs_no_prefix_attr:\n-\t  typespec reserved_declspecs_no_prefix_attr\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| declmods_no_prefix_attr typespec reserved_declspecs_no_prefix_attr\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n-\t;\n-\n-reserved_declspecs_no_prefix_attr:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_declspecs_no_prefix_attr typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t| reserved_declspecs_no_prefix_attr SCSPEC\n-\t\t{ if (extra_warnings)\n-\t\t    warning (\"`%s' is not at beginning of declaration\",\n-\t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-/* List of just storage classes, type modifiers, and prefix attributes.\n-   A declaration can start with just this, but then it cannot be used\n-   to redeclare a typedef-name.\n-   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n-\n-declmods:\n-\t  declmods_no_prefix_attr\n-\t\t{ $$ = $1; }\n-\t| attributes\n-\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE); }\n-\t| declmods declmods_no_prefix_attr\n-\t\t{ $$ = chainon ($2, $1); }\n-\t| declmods attributes\n-\t\t{ $$ = tree_cons ($2, NULL_TREE, $1); }\n-\t;\n-\n-declmods_no_prefix_attr:\n-\t  TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n-\t\t  TREE_STATIC ($$) = 1; }\n-\t| SCSPEC\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-\t| declmods_no_prefix_attr TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n-\t\t  TREE_STATIC ($$) = 1; }\n-\t| declmods_no_prefix_attr SCSPEC\n-\t\t{ if (extra_warnings && TREE_STATIC ($1))\n-\t\t    warning (\"`%s' is not at beginning of declaration\",\n-\t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n-\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n-\t;\n-\n-\n-/* Used instead of declspecs where storage classes are not allowed\n-   (that is, for typenames and structure components).\n-   Don't accept a typedef-name if anything but a modifier precedes it.  */\n-\n-typed_typespecs:\n-\t  typespec reserved_typespecquals\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, $2); }\n-\t| nonempty_type_quals typespec reserved_typespecquals\n-\t\t{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }\n-\t;\n-\n-reserved_typespecquals:  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| reserved_typespecquals typespecqual_reserved\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-/* A typespec (but not a type qualifier).\n-   Once we have seen one of these in a declaration,\n-   if a typedef name appears then it is being redeclared.  */\n-\n-typespec: TYPESPEC\n-\t| structsp\n-\t| TYPENAME\n-\t\t{ /* For a typedef name, record the meaning, not the name.\n-\t\t     In case of `foo foo, bar;'.  */\n-\t\t  $$ = lookup_name ($1); }\n-\t| CLASSNAME protocolrefs\n-\t\t{ $$ = get_static_reference ($1, $2); }\n-\t| OBJECTNAME protocolrefs\n-\t\t{ $$ = get_object_reference ($2); }\n-\n-/* Make \"<SomeProtocol>\" equivalent to \"id <SomeProtocol>\"\n-   - nisse@lysator.liu.se */\n-        | non_empty_protocolrefs\n-                { $$ = get_object_reference ($1); }\n-\t| TYPEOF '(' expr ')'\n-\t\t{ $$ = TREE_TYPE ($3); }\n-\t| TYPEOF '(' typename ')'\n-\t\t{ $$ = groktypename ($3); }\n-\t;\n-\n-/* A typespec that is a reserved word, or a type qualifier.  */\n-\n-typespecqual_reserved: TYPESPEC\n-\t| TYPE_QUAL\n-\t| structsp\n-\t;\n-\n-initdecls:\n-\tinitdcl\n-\t| initdecls ',' initdcl\n-\t;\n-\n-notype_initdecls:\n-\tnotype_initdcl\n-\t| notype_initdecls ',' initdcl\n-\t;\n-\n-maybeasm:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| ASM_KEYWORD '(' string ')'\n-\t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n-\t\t  $$ = $3;\n-\t\t}\n-\t;\n-\n-initdcl:\n-\t  declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n-\t\t\t\t\t  $3, prefix_attributes);\n-\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n-\t  init\n-/* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_init ();\n-\t\t  finish_decl ($<ttype>5, $6, $2); }\n-\t| declarator maybeasm maybe_attribute\n-\t\t{ tree d = start_decl ($1, current_declspecs, 0,\n-\t\t\t\t       $3, prefix_attributes);\n-\t\t  finish_decl (d, NULL_TREE, $2); \n-                }\n-\t;\n-\n-notype_initdcl:\n-\t  notype_declarator maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n-\t\t\t\t\t  $3, prefix_attributes);\n-\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n-\t  init\n-/* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_init ();\n-\t\t  decl_attributes ($<ttype>5, $3, prefix_attributes);\n-\t\t  finish_decl ($<ttype>5, $6, $2); }\n-\t| notype_declarator maybeasm maybe_attribute\n-\t\t{ tree d = start_decl ($1, current_declspecs, 0,\n-\t\t\t\t       $3, prefix_attributes);\n-\t\t  finish_decl (d, NULL_TREE, $2); }\n-\t;\n-/* the * rules are dummies to accept the Apollo extended syntax\n-   so that the header files compile. */\n-maybe_attribute:\n-      /* empty */\n-  \t\t{ $$ = NULL_TREE; }\n-\t| attributes\n-\t\t{ $$ = $1; }\n-\t;\n- \n-attributes:\n-      attribute\n-\t\t{ $$ = $1; }\n-\t| attributes attribute\n-\t\t{ $$ = chainon ($1, $2); }\n-\t;\n-\n-attribute:\n-      ATTRIBUTE '(' '(' attribute_list ')' ')'\n-\t\t{ $$ = $4; }\n-\t;\n-\n-attribute_list:\n-      attrib\n-\t\t{ $$ = $1; }\n-\t| attribute_list ',' attrib\n-\t\t{ $$ = chainon ($1, $3); }\n-\t;\n- \n-attrib:\n-    /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| any_word\n-\t\t{ $$ = build_tree_list ($1, NULL_TREE); }\n-\t| any_word '(' IDENTIFIER ')'\n-\t\t{ $$ = build_tree_list ($1, build_tree_list (NULL_TREE, $3)); }\n-\t| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'\n-\t\t{ $$ = build_tree_list ($1, tree_cons (NULL_TREE, $3, $5)); }\n-\t| any_word '(' exprlist ')'\n-\t\t{ $$ = build_tree_list ($1, $3); }\n-\t;\n-\n-/* This still leaves out most reserved keywords,\n-   shouldn't we include them?  */\n-\n-any_word:\n-\t  identifier\n-\t| SCSPEC\n-\t| TYPESPEC\n-\t| TYPE_QUAL\n-\t;\n-\f\n-/* Initializers.  `init' is the entry point.  */\n-\n-init:\n-\texpr_no_commas\n-\t| '{'\n-\t\t{ really_start_incremental_init (NULL_TREE); }\n-\t  initlist_maybe_comma '}'\n-\t\t{ $$ = pop_init_level (0); }\n-\t| error\n-\t\t{ $$ = error_mark_node; }\n-\t;\n-\n-/* `initlist_maybe_comma' is the guts of an initializer in braces.  */\n-initlist_maybe_comma:\n-\t  /* empty */\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids empty initializer braces\"); }\n-\t| initlist1 maybecomma\n-\t;\n-\n-initlist1:\n-\t  initelt\n-\t| initlist1 ',' initelt\n-\t;\n-\n-/* `initelt' is a single element of an initializer.\n-   It may use braces.  */\n-initelt:\n-\t  designator_list '=' initval\n-\t| designator initval\n-\t| identifier ':'\n-\t\t{ set_init_label ($1); }\n-\t  initval\n-\t| initval\n-\t;\n-\n-initval:\n-\t  '{'\n-\t\t{ push_init_level (0); }\n-\t  initlist_maybe_comma '}'\n-\t\t{ process_init_element (pop_init_level (0)); }\n-\t| expr_no_commas\n-\t\t{ process_init_element ($1); }\n-\t| error\n-\t;\n-\n-designator_list:\n-\t  designator\n-\t| designator_list designator\n-\t;\n-\n-designator:\n-\t  '.' identifier\n-\t\t{ set_init_label ($2); }\n-\t/* These are for labeled elements.  The syntax for an array element\n-\t   initializer conflicts with the syntax for an Objective-C message,\n-\t   so don't include these productions in the Objective-C grammar.  */\n-\t;\n-\f\n-nested_function:\n-\t  declarator\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids nested functions\");\n-\n-\t\t  push_function_context ();\n-\t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    {\n-\t\t      pop_function_context ();\n-\t\t      YYERROR1;\n-\t\t    }\n-\t\t  reinit_parse_for_function (); }\n-\t   old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-/* This used to use compstmt_or_error.\n-   That caused a bug with input `f(g) int g {}',\n-   where the use of YYERROR1 above caused an error\n-   which then was handled by compstmt_or_error.\n-   There followed a repeated execution of that same rule,\n-   which called YYERROR1 again, and so on.  */\n-\t  compstmt\n-\t\t{ finish_function (1);\n-\t\t  pop_function_context (); }\n-\t;\n-\n-notype_nested_function:\n-\t  notype_declarator\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids nested functions\");\n-\n-\t\t  push_function_context ();\n-\t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tprefix_attributes, NULL_TREE))\n-\t\t    {\n-\t\t      pop_function_context ();\n-\t\t      YYERROR1;\n-\t\t    }\n-\t\t  reinit_parse_for_function (); }\n-\t  old_style_parm_decls\n-\t\t{ store_parm_decls (); }\n-/* This used to use compstmt_or_error.\n-   That caused a bug with input `f(g) int g {}',\n-   where the use of YYERROR1 above caused an error\n-   which then was handled by compstmt_or_error.\n-   There followed a repeated execution of that same rule,\n-   which called YYERROR1 again, and so on.  */\n-\t  compstmt\n-\t\t{ finish_function (1);\n-\t\t  pop_function_context (); }\n-\t;\n-\n-/* Any kind of declarator (thus, all declarators allowed\n-   after an explicit typespec).  */\n-\n-declarator:\n-\t  after_type_declarator\n-\t| notype_declarator\n-\t;\n-\n-/* A declarator that is allowed only after an explicit typespec.  */\n-\n-after_type_declarator:\n-\t  '(' after_type_declarator ')'\n-\t\t{ $$ = $2; }\n-\t| after_type_declarator '(' parmlist_or_identifiers  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-/*\t| after_type_declarator '(' error ')'  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n-\t\t  poplevel (0, 0, 0); }  */\n-\t| after_type_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| after_type_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '*' type_quals after_type_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs after_type_declarator\n-\t\t{ $$ = $3; }\n-\t| TYPENAME\n-\t| OBJECTNAME\n-\t;\n-\n-/* Kinds of declarator that can appear in a parameter list\n-   in addition to notype_declarator.  This is like after_type_declarator\n-   but does not allow a typedef name in parentheses as an identifier\n-   (because it would conflict with a function with that typedef as arg).  */\n-\n-parm_declarator:\n-\t  parm_declarator '(' parmlist_or_identifiers  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-/*\t| parm_declarator '(' error ')'  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n-\t\t  poplevel (0, 0, 0); }  */\n-\t| parm_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| parm_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '*' type_quals parm_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs parm_declarator\n-\t\t{ $$ = $3; }\n-\t| TYPENAME\n-\t;\n-\n-/* A declarator allowed whether or not there has been\n-   an explicit typespec.  These cannot redeclare a typedef-name.  */\n-\n-notype_declarator:\n-\t  notype_declarator '(' parmlist_or_identifiers  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-/*\t| notype_declarator '(' error ')'  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n-\t\t  poplevel (0, 0, 0); }  */\n-\t| '(' notype_declarator ')'\n-\t\t{ $$ = $2; }\n-\t| '*' type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| notype_declarator '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| notype_declarator '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t/* ??? Yuck.  setattrs is a quick hack.  We can't use\n-\t   prefix_attributes because $1 only applies to this\n-\t   declarator.  We assume setspecs has already been done.\n-\t   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple\n-\t   attributes could be recognized here or in `attributes').  */\n-\t| attributes setattrs notype_declarator\n-\t\t{ $$ = $3; }\n-\t| IDENTIFIER\n-\t;\n-\n-struct_head:\n-\t  STRUCT\n-\t\t{ $$ = NULL_TREE; }\n-\t| STRUCT attributes\n-\t\t{ $$ = $2; }\n-\t;\n-\n-union_head:\n-\t  UNION\n-\t\t{ $$ = NULL_TREE; }\n-\t| UNION attributes\n-\t\t{ $$ = $2; }\n-\t;\n-\n-enum_head:\n-\t  ENUM\n-\t\t{ $$ = NULL_TREE; }\n-\t| ENUM attributes\n-\t\t{ $$ = $2; }\n-\t;\n-\n-structsp:\n-\t  struct_head identifier '{'\n-\t\t{ $$ = start_struct (RECORD_TYPE, $2);\n-\t\t  /* Start scope of tag before parsing components.  */\n-\t\t}\n-\t  component_decl_list '}' maybe_attribute \n-\t\t{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }\n-\t| struct_head '{' component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n-\t\t\t\t      $3, chainon ($1, $5));\n-\t\t}\n-\t| struct_head identifier\n-\t\t{ $$ = xref_tag (RECORD_TYPE, $2); }\n-\t| union_head identifier '{'\n-\t\t{ $$ = start_struct (UNION_TYPE, $2); }\n-\t  component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }\n-\t| union_head '{' component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct (start_struct (UNION_TYPE, NULL_TREE),\n-\t\t\t\t      $3, chainon ($1, $5));\n-\t\t}\n-\t| union_head identifier\n-\t\t{ $$ = xref_tag (UNION_TYPE, $2); }\n-\t| enum_head identifier '{'\n-\t\t{ $$ = start_enum ($2); }\n-\t  enumlist maybecomma_warn '}' maybe_attribute\n-\t\t{ $$ = finish_enum ($<ttype>4, nreverse ($5),\n-\t\t\t\t    chainon ($1, $8)); }\n-\t| enum_head '{'\n-\t\t{ $$ = start_enum (NULL_TREE); }\n-\t  enumlist maybecomma_warn '}' maybe_attribute\n-\t\t{ $$ = finish_enum ($<ttype>3, nreverse ($4),\n-\t\t\t\t    chainon ($1, $7)); }\n-\t| enum_head identifier\n-\t\t{ $$ = xref_tag (ENUMERAL_TYPE, $2); }\n-\t;\n-\n-maybecomma:\n-\t  /* empty */\n-\t| ','\n-\t;\n-\n-maybecomma_warn:\n-\t  /* empty */\n-\t| ','\n-\t\t{ if (pedantic && ! flag_isoc99)\n-\t\t    pedwarn (\"comma at end of enumerator list\"); }\n-\t;\n-\n-component_decl_list:\n-\t  component_decl_list2\n-\t\t{ $$ = $1; }\n-\t| component_decl_list2 component_decl\n-\t\t{ $$ = chainon ($1, $2);\n-\t\t  pedwarn (\"no semicolon at end of struct or union\"); }\n-\t;\n-\n-component_decl_list2:\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| component_decl_list2 component_decl ';'\n-\t\t{ $$ = chainon ($1, $2); }\n-\t| component_decl_list2 ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"extra semicolon in struct or union specified\"); }\n-\t/* foo(sizeof(struct{ @defs(ClassName)})); */\n-\t| DEFS '(' CLASSNAME ')'\n-\t\t{\n-\t\t  tree interface = lookup_interface ($3);\n-\n-\t\t  if (interface)\n-\t\t    $$ = get_class_ivars (interface);\n-\t\t  else\n-\t\t    {\n-\t\t      error (\"Cannot find interface declaration for `%s'\",\n-\t\t\t     IDENTIFIER_POINTER ($3));\n-\t\t      $$ = NULL_TREE;\n-\t\t    }\n-\t\t}\n-\t;\n-\n-/* There is a shift-reduce conflict here, because `components' may\n-   start with a `typename'.  It happens that shifting (the default resolution)\n-   does the right thing, because it treats the `typename' as part of\n-   a `typed_typespecs'.\n-\n-   It is possible that this same technique would allow the distinction\n-   between `notype_initdecls' and `initdecls' to be eliminated.\n-   But I am being cautious and not trying it.  */\n-\n-component_decl:\n-\t  typed_typespecs setspecs components\n-\t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_typespecs setspecs save_filename save_lineno maybe_attribute\n-\t\t{\n-\t\t  /* Support for unnamed structs or unions as members of \n-\t\t     structs or unions (which is [a] useful and [b] supports \n-\t\t     MS P-SDK).  */\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C doesn't support unnamed structs/unions\");\n-\n-\t\t  $$ = grokfield($3, $4, NULL, current_declspecs, NULL_TREE);\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack);\n-\t\t}\n-    | nonempty_type_quals setspecs components\n-\t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| nonempty_type_quals\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids member declarations with no members\");\n-\t\t  shadow_tag($1);\n-\t\t  $$ = NULL_TREE; }\n-\t| error\n-\t\t{ $$ = NULL_TREE; }\n-\t| extension component_decl\n-\t\t{ $$ = $2;\n-\t\t  RESTORE_WARN_FLAGS ($1); }\n-\t;\n-\n-components:\n-\t  component_declarator\n-\t| components ',' component_declarator\n-\t\t{ $$ = chainon ($1, $3); }\n-\t;\n-\n-component_declarator:\n-\t  save_filename save_lineno declarator maybe_attribute\n-\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);\n-\t\t  decl_attributes ($$, $4, prefix_attributes); }\n-\t| save_filename save_lineno\n-\t  declarator ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);\n-\t\t  decl_attributes ($$, $6, prefix_attributes); }\n-\t| save_filename save_lineno ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);\n-\t\t  decl_attributes ($$, $5, prefix_attributes); }\n-\t;\n-\n-/* We chain the enumerators in reverse order.\n-   They are put in forward order where enumlist is used.\n-   (The order used to be significant, but no longer is so.\n-   However, we still maintain the order, just to be clean.)  */\n-\n-enumlist:\n-\t  enumerator\n-\t| enumlist ',' enumerator\n-\t\t{ if ($1 == error_mark_node)\n-\t\t    $$ = $1;\n-\t\t  else\n-\t\t    $$ = chainon ($3, $1); }\n-\t| error\n-\t\t{ $$ = error_mark_node; }\n-\t;\n-\n-\n-enumerator:\n-\t  identifier\n-\t\t{ $$ = build_enumerator ($1, NULL_TREE); }\n-\t| identifier '=' expr_no_commas\n-\t\t{ $$ = build_enumerator ($1, $3); }\n-\t;\n-\n-typename:\n-\ttyped_typespecs absdcl\n-\t\t{ $$ = build_tree_list ($1, $2); }\n-\t| nonempty_type_quals absdcl\n-\t\t{ $$ = build_tree_list ($1, $2); }\n-\t;\n-\n-absdcl:   /* an absolute declarator */\n-\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| absdcl1\n-\t;\n-\n-nonempty_type_quals:\n-\t  TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n-\t| nonempty_type_quals TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-type_quals:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| type_quals TYPE_QUAL\n-\t\t{ $$ = tree_cons (NULL_TREE, $2, $1); }\n-\t;\n-\n-absdcl1:  /* a nonempty absolute declarator */\n-\t  '(' absdcl1 ')'\n-\t\t{ $$ = $2; }\n-\t  /* `(typedef)1' is `int'.  */\n-\t| '*' type_quals absdcl1  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '*' type_quals  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n-\t| absdcl1 '(' parmlist  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n-\t| absdcl1 '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n-\t| absdcl1 '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n-\t| '(' parmlist  %prec '.'\n-\t\t{ $$ = build_nt (CALL_EXPR, NULL_TREE, $2, NULL_TREE); }\n-\t| '[' expr ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, $2); }\n-\t| '[' ']'  %prec '.'\n-\t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }\n-\t/* ??? It appears we have to support attributes here, however\n-\t   using prefix_attributes is wrong.  */\n-\t| attributes setattrs absdcl1\n-\t\t{ $$ = $3; }\n-\t;\n-\n-/* at least one statement, the first of which parses without error.  */\n-/* stmts is used only after decls, so an invalid first statement\n-   is actually regarded as an invalid decl and part of the decls.  */\n-\n-stmts:\n-\tlineno_stmt_or_labels\n-\t\t{\n-\t\t  if (pedantic && $1)\n-\t\t    pedwarn (\"ANSI C forbids label at end of compound statement\");\n-\t\t}\n-\t;\n-\n-lineno_stmt_or_labels:\n-\t  lineno_stmt_or_label\n-\t| lineno_stmt_or_labels lineno_stmt_or_label\n-\t\t{ $$ = $2; }\n-\t| lineno_stmt_or_labels errstmt\n-\t\t{ $$ = 0; }\n-\t;\n-\n-xstmts:\n-\t/* empty */\n-\t| stmts\n-\t;\n-\n-errstmt:  error ';'\n-\t;\n-\n-pushlevel:  /* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  pushlevel (0);\n-\t\t  clear_last_expr ();\n-\t\t  expand_start_bindings (0);\n-\t\t  if (objc_method_context)\n-\t\t    add_objc_decls ();\n-\t\t}\n-\t;\n-\n-/* Read zero or more forward-declarations for labels\n-   that nested functions can jump to.  */\n-maybe_label_decls:\n-\t  /* empty */\n-\t| label_decls\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids label declarations\"); }\n-\t;\n-\n-label_decls:\n-\t  label_decl\n-\t| label_decls label_decl\n-\t;\n-\n-label_decl:\n-\t  LABEL identifiers_or_typenames ';'\n-\t\t{ tree link;\n-\t\t  for (link = $2; link; link = TREE_CHAIN (link))\n-\t\t    {\n-\t\t      tree label = shadow_label (TREE_VALUE (link));\n-\t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t\t      declare_nonlocal_label (label);\n-\t\t    }\n-\t\t}\n-\t;\n-\n-/* This is the body of a function definition.\n-   It causes syntax errors to ignore to the next openbrace.  */\n-compstmt_or_error:\n-\t  compstmt\n-\t\t{}\n-\t| error compstmt\n-\t;\n-\n-compstmt_start: '{' { compstmt_count++; }\n-\n-compstmt_nostart: '}'\n-\t\t{ $$ = convert (void_type_node, integer_zero_node); }\n-\t| pushlevel maybe_label_decls decls xstmts '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), 1, 0);\n-\t\t  $$ = poplevel (1, 1, 0); }\n-\t| pushlevel maybe_label_decls error '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0); }\n-\t| pushlevel maybe_label_decls stmts '}'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-\t\t  $$ = poplevel (kept_level_p (), 0, 0); }\n-\t;\n-\n-compstmt_primary_start:\n-\t'(' '{'\n-\t\t{ if (current_function_decl == 0)\n-\t\t    {\n-\t\t      error (\"braced-group within expression allowed only inside a function\");\n-\t\t      YYERROR;\n-\t\t    }\n-\t\t  /* We must force a BLOCK for this level\n-\t\t     so that, if it is not expanded later,\n-\t\t     there is a way to turn off the entire subtree of blocks\n-\t\t     that are contained in it.  */\n-\t\t  keep_next_level ();\n-\t\t  push_iterator_stack ();\n-\t\t  push_label_level ();\n-\t\t  $$ = expand_start_stmt_expr ();\n-\t\t  compstmt_count++;\n-\t\t}\n-\n-compstmt: compstmt_start compstmt_nostart\n-\t\t{ $$ = $2; }\n-\t;\n-\n-/* Value is number of statements counted as of the closeparen.  */\n-simple_if:\n-\t  if_prefix lineno_labeled_stmt\n-/* Make sure c_expand_end_cond is run once\n-   for each call to c_expand_start_cond.\n-   Otherwise a crash is likely.  */\n-\t| if_prefix error\n-\t;\n-\n-if_prefix:\n-\t  IF '(' expr ')'\n-\t\t{ emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_start_cond (truthvalue_conversion ($3), 0, \n-\t\t\t\t       compstmt_count);\n-\t\t  $<itype>$ = stmt_count;\n-\t\t  if_stmt_file = $<filename>-1;\n-\t\t  if_stmt_line = $<lineno>0;\n-\t\t  position_after_white_space (); }\n-\t;\n-\n-/* This is a subroutine of stmt.\n-   It is used twice, once for valid DO statements\n-   and once for catching errors in parsing the end test.  */\n-do_stmt_start:\n-\t  DO\n-\t\t{ stmt_count++;\n-\t\t  compstmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* See comment in `while' alternative, above.  */\n-\t\t  emit_nop ();\n-\t\t  expand_start_loop_continue_elsewhere (1);\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt WHILE\n-\t\t{ expand_loop_continue_here (); }\n-\t;\n-\n-save_filename:\n-\t\t{ $$ = input_filename; }\n-\t;\n-\n-save_lineno:\n-\t\t{ $$ = lineno; }\n-\t;\n-\n-lineno_labeled_stmt:\n-\t  save_filename save_lineno stmt\n-\t\t{ }\n-/*\t| save_filename save_lineno error\n-\t\t{ }\n-*/\n-\t| save_filename save_lineno label lineno_labeled_stmt\n-\t\t{ }\n-\t;\n-\n-lineno_stmt_or_label:\n-\t  save_filename save_lineno stmt_or_label\n-\t\t{ $$ = $3; }\n-\t;\n-\n-stmt_or_label:\n-\t  stmt\n-\t\t{ $$ = 0; }\n-\t| label\n-\t\t{ $$ = 1; }\n-\t;\n-\n-/* Parse a single real statement, not including any labels.  */\n-stmt:\n-\t  compstmt\n-\t\t{ stmt_count++; }\n-        | all_iter_stmt \n-\t| expr ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-/* It appears that this should not be done--that a non-lvalue array\n-   shouldn't get an error if the value isn't used.\n-   Section 3.2.2.1 says that an array lvalue gets converted to a pointer\n-   if it appears as a top-level expression,\n-   but says nothing about non-lvalue arrays.  */\n-#if 0\n-\t\t  /* Call default_conversion to get an error\n-\t\t     on referring to a register array if pedantic.  */\n-\t\t  if (TREE_CODE (TREE_TYPE ($1)) == ARRAY_TYPE\n-\t\t      || TREE_CODE (TREE_TYPE ($1)) == FUNCTION_TYPE)\n-\t\t    $1 = default_conversion ($1);\n-#endif\n-\t\t  iterator_expand ($1); }\n-\t| simple_if ELSE\n-\t\t{ c_expand_start_else ();\n-\t\t  $<itype>1 = stmt_count;\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ c_expand_end_cond ();\n-\t\t  if (extra_warnings && stmt_count == $<itype>1)\n-\t\t    warning (\"empty body in an else-statement\"); }\n-\t| simple_if %prec IF\n-\t\t{ c_expand_end_cond ();\n-\t\t  /* This warning is here instead of in simple_if, because we\n-\t\t     do not want a warning if an empty if is followed by an\n-\t\t     else statement.  Increment stmt_count so we don't\n-\t\t     give a second error if this is a nested `if'.  */\n-\t\t  if (extra_warnings && stmt_count++ == $<itype>1)\n-\t\t    warning_with_file_and_line (if_stmt_file, if_stmt_line,\n-\t\t\t\t\t\t\"empty body in an if-statement\"); }\n-/* Make sure c_expand_end_cond is run once\n-   for each call to c_expand_start_cond.\n-   Otherwise a crash is likely.  */\n-\t| simple_if ELSE error\n-\t\t{ c_expand_end_cond (); }\n-\t| WHILE\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* The emit_nop used to come before emit_line_note,\n-\t\t     but that made the nop seem like part of the preceding line.\n-\t\t     And that was confusing when the preceding line was\n-\t\t     inside of an if statement and was not really executed.\n-\t\t     I think it ought to work to put the nop after the line number.\n-\t\t     We will see.  --rms, July 15, 1991.  */\n-\t\t  emit_nop (); }\n-\t  '(' expr ')'\n-\t\t{ /* Don't start the loop till we have succeeded\n-\t\t     in parsing the end test.  This is to make sure\n-\t\t     that we end every loop we start.  */\n-\t\t  expand_start_loop (1);\n-\t\t  emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t     truthvalue_conversion ($4));\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ expand_end_loop (); }\n-\t| do_stmt_start\n-\t  '(' expr ')' ';'\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t     truthvalue_conversion ($3));\n-\t\t  expand_end_loop (); }\n-/* This rule is needed to make sure we end every loop we start.  */\n-\t| do_stmt_start error\n-\t\t{ expand_end_loop (); }\n-\t| FOR\n-\t  '(' xexpr ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  /* See comment in `while' alternative, above.  */\n-\t\t  emit_nop ();\n-\t\t  if ($3) c_expand_expr_stmt ($3);\n-\t\t  /* Next step is to call expand_start_loop_continue_elsewhere,\n-\t\t     but wait till after we parse the entire for (...).\n-\t\t     Otherwise, invalid input might cause us to call that\n-\t\t     fn without calling expand_end_loop.  */\n-\t\t}\n-\t  xexpr ';'\n-\t\t/* Can't emit now; wait till after expand_start_loop...  */\n-\t\t{ $<lineno>7 = lineno;\n-\t\t  $<filename>$ = input_filename; }\n-\t  xexpr ')'\n-\t\t{ \n-\t\t  /* Start the loop.  Doing this after parsing\n-\t\t     all the expressions ensures we will end the loop.  */\n-\t\t  expand_start_loop_continue_elsewhere (1);\n-\t\t  /* Emit the end-test, with a line number.  */\n-\t\t  emit_line_note ($<filename>8, $<lineno>7);\n-\t\t  if ($6)\n-\t\t    expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t       truthvalue_conversion ($6));\n-\t\t  $<lineno>7 = lineno;\n-\t\t  $<filename>8 = input_filename;\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ /* Emit the increment expression, with a line number.  */\n-\t\t  emit_line_note ($<filename>8, $<lineno>7);\n-\t\t  expand_loop_continue_here ();\n-\t\t  if ($9)\n-\t\t    c_expand_expr_stmt ($9);\n-\t\t  expand_end_loop (); }\n-\t| SWITCH '(' expr ')'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_start_case ($3);\n-\t\t  position_after_white_space (); }\n-\t  lineno_labeled_stmt\n-\t\t{ expand_end_case ($3); }\n-\t| BREAK ';'\n-\t        { tree break_stmt = build_break_stmt ();\n-\t\t  stmt_count++;\n-\t\t  genrtl_break_stmt (); }\n-\t| CONTINUE ';'\n-                { tree continue_stmt = build_continue_stmt ();\n-                  stmt_count++;\n-\t\t  genrtl_continue_stmt (); }\n-\t| RETURN ';'\n-                { tree return_stmt = build_return_stmt (NULL_TREE);\n-                  stmt_count++;\n-\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n-\t| RETURN expr ';'\n-                { tree return_stmt = build_return_stmt ($2);\n-                  stmt_count++;\n-\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  STRIP_NOPS ($4);\n-\t\t  if ((TREE_CODE ($4) == ADDR_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND ($4, 0)) == STRING_CST)\n-\t\t      || TREE_CODE ($4) == STRING_CST)\n-\t\t    expand_asm ($4);\n-\t\t  else\n-\t\t    error (\"argument of `asm' is not a constant string\"); }\n-\t/* This is the case with just output operands.  */\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n-\t/* This is the case with input operands as well.  */\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':' asm_operands ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_asm_operands ($4, $6, $8, NULL_TREE,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n-\t/* This is the case with clobbered registers as well.  */\n-\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n-  \t  asm_operands ':' asm_clobbers ')' ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_asm_operands ($4, $6, $8, $10,\n-\t\t\t\t\t $2 == ridpointers[(int)RID_VOLATILE],\n-\t\t\t\t\t input_filename, lineno); }\n-\t| GOTO identifier ';'\n-\t\t{ tree decl;\n-\t\t  stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  decl = lookup_label ($2);\n-\t\t  if (decl != 0)\n-\t\t    {\n-\t\t      TREE_USED (decl) = 1;\n-\t\t      expand_goto (decl);\n-\t\t    }\n-\t\t}\n-\t| GOTO '*' expr ';'\n-\t\t{ if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids `goto *expr;'\");\n-\t\t  stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  expand_computed_goto (convert (ptr_type_node, $3)); }\n-\t| ';'\n-\t;\n-\n-all_iter_stmt:\n-\t  all_iter_stmt_simple\n-/*\t| all_iter_stmt_with_decl */\n-\t;\n-\n-all_iter_stmt_simple:\n-\t  FOR '(' primary ')' \n-\t  {\n-\t    /* The value returned by this action is  */\n-\t    /*      1 if everything is OK */ \n-\t    /*      0 in case of error or already bound iterator */\n-\n-\t    $<itype>$ = 0;\n-\t    if (TREE_CODE ($3) != VAR_DECL)\n-\t      error (\"invalid `for (ITERATOR)' syntax\");\n-\t    else if (! ITERATOR_P ($3))\n-\t      error (\"`%s' is not an iterator\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n-\t    else if (ITERATOR_BOUND_P ($3))\n-\t      error (\"`for (%s)' inside expansion of same iterator\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME ($3)));\n-\t    else\n-\t      {\n-\t\t$<itype>$ = 1;\n-\t\titerator_for_loop_start ($3);\n-\t      }\n-\t  }\n-\t  lineno_labeled_stmt\n-\t  {\n-\t    if ($<itype>5)\n-\t      iterator_for_loop_end ($3);\n-\t  }\n-\n-/*  This really should allow any kind of declaration,\n-    for generality.  Fix it before turning it back on.\n-\n-all_iter_stmt_with_decl:\n-\t  FOR '(' ITERATOR pushlevel setspecs iterator_spec ')' \n-\t  {\n-*/\t    /* The value returned by this action is  */\n-\t    /*      1 if everything is OK */ \n-\t    /*      0 in case of error or already bound iterator */\n-/*\n-\t    iterator_for_loop_start ($6);\n-\t  }\n-\t  lineno_labeled_stmt\n-\t  {\n-\t    iterator_for_loop_end ($6);\n-\t    emit_line_note (input_filename, lineno);\n-\t    expand_end_bindings (getdecls (), 1, 0);\n-\t    $<ttype>$ = poplevel (1, 1, 0);\n-\t  }\n-*/\n-\n-/* Any kind of label, including jump labels and case labels.\n-   ANSI C accepts labels only before statements, but we allow them\n-   also at the end of a compound statement.  */\n-\n-label:\t  CASE expr_no_commas ':'\n-                { tree case_label_tree = build_case_label ($2, NULL_TREE);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n-\t\t}\n-\t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-                { tree case_label_tree = build_case_label ($2, $4);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n-\t\t}\n-\t| DEFAULT ':'\n-                { tree case_label_tree = build_case_label (NULL_TREE, NULL_TREE);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n-\t\t}\n-\t| identifier ':' maybe_attribute\n-\t\t{ tree label = define_label (input_filename, lineno, $1);\n-\t\t  stmt_count++;\n-\t\t  emit_nop ();\n-\t\t  if (label)\n-\t\t    {\n-\t\t      expand_label (label);\n-\t\t      decl_attributes (label, $3, NULL_TREE);\n-\t\t    }\n-\t\t  position_after_white_space (); }\n-\t;\n-\n-/* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */\n-\n-maybe_type_qual:\n-\t/* empty */\n-\t\t{ emit_line_note (input_filename, lineno);\n-\t\t  $$ = NULL_TREE; }\n-\t| TYPE_QUAL\n-\t\t{ emit_line_note (input_filename, lineno); }\n-\t;\n-\n-xexpr:\n-\t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| expr\n-\t;\n-\n-/* These are the operands other than the first string and colon\n-   in  asm (\"addextend %2,%1\": \"=dm\" (x), \"0\" (y), \"g\" (*x))  */\n-asm_operands: /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| nonnull_asm_operands\n-\t;\n-\n-nonnull_asm_operands:\n-\t  asm_operand\n-\t| nonnull_asm_operands ',' asm_operand\n-\t\t{ $$ = chainon ($1, $3); }\n-\t;\n-\n-asm_operand:\n-\t  STRING '(' expr ')'\n-\t\t{ $$ = build_tree_list ($1, $3); }\n-\t;\n-\n-asm_clobbers:\n-\t  string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($1), NULL_TREE); }\n-\t| asm_clobbers ',' string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($3), $1); }\n-\t;\n-\f\n-/* This is what appears inside the parens in a function declarator.\n-   Its value is a list of ..._TYPE nodes.  */\n-parmlist:\n-\t\t{ pushlevel (0);\n-\t\t  clear_parm_order ();\n-\t\t  declare_parm_level (0); }\n-\t  parmlist_1\n-\t\t{ $$ = $2;\n-\t\t  parmlist_tags_warning ();\n-\t\t  poplevel (0, 0, 0); }\n-\t;\n-\n-parmlist_1:\n-\t  parmlist_2 ')'\n-\t| parms ';'\n-\t\t{ tree parm;\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids forward parameter declarations\");\n-\t\t  /* Mark the forward decls as such.  */\n-\t\t  for (parm = getdecls (); parm; parm = TREE_CHAIN (parm))\n-\t\t    TREE_ASM_WRITTEN (parm) = 1;\n-\t\t  clear_parm_order (); }\n-\t  parmlist_1\n-\t\t{ $$ = $4; }\n-\t| error ')'\n-\t\t{ $$ = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); }\n-\t;\n-\n-/* This is what appears inside the parens in a function declarator.\n-   Is value is represented in the format that grokdeclarator expects.  */\n-parmlist_2:  /* empty */\n-\t\t{ $$ = get_parm_info (0); }\n-\t| ELLIPSIS\n-\t\t{ $$ = get_parm_info (0);\n-\t\t  /* Gcc used to allow this as an extension.  However, it does\n-\t\t     not work for all targets, and thus has been disabled.\n-\t\t     Also, since func (...) and func () are indistinguishable,\n-\t\t     it caused problems with the code in expand_builtin which\n-\t\t     tries to verify that BUILT_IN_NEXT_ARG is being used\n-\t\t     correctly.  */\n-\t\t  error (\"ANSI C requires a named argument before `...'\");\n-\t\t}\n-\t| parms\n-\t\t{ $$ = get_parm_info (1); }\n-\t| parms ',' ELLIPSIS\n-\t\t{ $$ = get_parm_info (0); }\n-\t;\n-\n-parms:\n-\tparm\n-\t\t{ push_parm_decl ($1); }\n-\t| parms ',' parm\n-\t\t{ push_parm_decl ($3); }\n-\t;\n-\n-/* A single parameter declaration or parameter type name,\n-   as found in a parmlist.  */\n-parm:\n-\t  typed_declspecs setspecs parm_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs notype_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4)); \n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs setspecs absdcl maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| declmods setspecs notype_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\n-\t| declmods setspecs absdcl maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $3),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $4));\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t;\n-\n-/* This is used in a function definition\n-   where either a parmlist or an identifier list is ok.\n-   Its value is a list of ..._TYPE nodes or a list of identifiers.  */\n-parmlist_or_identifiers:\n-\t\t{ pushlevel (0);\n-\t\t  clear_parm_order ();\n-\t\t  declare_parm_level (1); }\n-\t  parmlist_or_identifiers_1\n-\t\t{ $$ = $2;\n-\t\t  parmlist_tags_warning ();\n-\t\t  poplevel (0, 0, 0); }\n-\t;\n-\n-parmlist_or_identifiers_1:\n-\t  parmlist_1\n-\t| identifiers ')'\n-\t\t{ tree t;\n-\t\t  for (t = $1; t; t = TREE_CHAIN (t))\n-\t\t    if (TREE_VALUE (t) == NULL_TREE)\n-\t\t      error (\"`...' in old-style identifier list\");\n-\t\t  $$ = tree_cons (NULL_TREE, NULL_TREE, $1); }\n-\t;\n-\n-/* A nonempty list of identifiers.  */\n-identifiers:\n-\tIDENTIFIER\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| identifiers ',' IDENTIFIER\n-\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n-\t;\n-\n-/* A nonempty list of identifiers, including typenames.  */\n-identifiers_or_typenames:\n-\tidentifier\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| identifiers_or_typenames ',' identifier\n-\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n-\t;\n-\n-extension:\n-\tEXTENSION\n-\t\t{ $$ = SAVE_WARN_FLAGS();\n-\t\t  pedantic = 0;\n-\t\t  warn_pointer_arith = 0; }\n-\t;\n-\f\n-/* Objective-C productions.  */\n-\n-objcdef:\n-\t  classdef\n-\t| classdecl\n-\t| aliasdecl\n-\t| protocoldef\n-\t| methoddef\n-\t| END\n-\t\t{\n-\t\t  if (objc_implementation_context)\n-                    {\n-\t\t      finish_class (objc_implementation_context);\n-\t\t      objc_ivar_chain = NULL_TREE;\n-\t\t      objc_implementation_context = NULL_TREE;\n-\t\t    }\n-\t\t  else\n-\t\t    warning (\"`@end' must appear in an implementation context\");\n-\t\t}\n-\t;\n-\n-/* A nonempty list of identifiers.  */\n-identifier_list:\n-\tidentifier\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n-\t| identifier_list ',' identifier\n-\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n-\t;\n-\n-classdecl:\n-\t  CLASS identifier_list ';'\n-\t\t{\n-\t\t  objc_declare_class ($2);\n-\t\t}\n-\n-aliasdecl:\n-\t  ALIAS identifier identifier ';'\n-\t\t{\n-\t\t  objc_declare_alias ($2, $3);\n-\t\t}\n-\n-classdef:\n-\t  INTERFACE identifier protocolrefs '{'\n-\t\t{\n-\t\t  objc_interface_context = objc_ivar_context\n-\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, NULL_TREE, $3);\n-                  objc_public_flag = 0;\n-\t\t}\n-\t  ivar_decl_list '}'\n-\t\t{\n-                  continue_class (objc_interface_context);\n-\t\t}\n-\t  methodprotolist\n-\t  END\n-\t\t{\n-\t\t  finish_class (objc_interface_context);\n-\t\t  objc_interface_context = NULL_TREE;\n-\t\t}\n-\n-\t| INTERFACE identifier protocolrefs\n-\t\t{\n-\t\t  objc_interface_context\n-\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, NULL_TREE, $3);\n-                  continue_class (objc_interface_context);\n-\t\t}\n-\t  methodprotolist\n-\t  END\n-\t\t{\n-\t\t  finish_class (objc_interface_context);\n-\t\t  objc_interface_context = NULL_TREE;\n-\t\t}\n-\n-\t| INTERFACE identifier ':' identifier protocolrefs '{'\n-\t\t{\n-\t\t  objc_interface_context = objc_ivar_context\n-\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, $4, $5);\n-                  objc_public_flag = 0;\n-\t\t}\n-\t  ivar_decl_list '}'\n-\t\t{\n-                  continue_class (objc_interface_context);\n-\t\t}\n-\t  methodprotolist\n-\t  END\n-\t\t{\n-\t\t  finish_class (objc_interface_context);\n-\t\t  objc_interface_context = NULL_TREE;\n-\t\t}\n-\n-\t| INTERFACE identifier ':' identifier protocolrefs\n-\t\t{\n-\t\t  objc_interface_context\n-\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, $4, $5);\n-                  continue_class (objc_interface_context);\n-\t\t}\n-\t  methodprotolist\n-\t  END\n-\t\t{\n-\t\t  finish_class (objc_interface_context);\n-\t\t  objc_interface_context = NULL_TREE;\n-\t\t}\n-\n-\t| IMPLEMENTATION identifier '{'\n-\t\t{\n-\t\t  objc_implementation_context = objc_ivar_context\n-\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, NULL_TREE, NULL_TREE);\n-                  objc_public_flag = 0;\n-\t\t}\n-\t  ivar_decl_list '}'\n-\t\t{\n-                  objc_ivar_chain\n-\t\t    = continue_class (objc_implementation_context);\n-\t\t}\n-\n-\t| IMPLEMENTATION identifier\n-\t\t{\n-\t\t  objc_implementation_context\n-\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, NULL_TREE, NULL_TREE);\n-                  objc_ivar_chain\n-\t\t    = continue_class (objc_implementation_context);\n-\t\t}\n-\n-\t| IMPLEMENTATION identifier ':' identifier '{'\n-\t\t{\n-\t\t  objc_implementation_context = objc_ivar_context\n-\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, $4, NULL_TREE);\n-                  objc_public_flag = 0;\n-\t\t}\n-\t  ivar_decl_list '}'\n-\t\t{\n-                  objc_ivar_chain\n-\t\t    = continue_class (objc_implementation_context);\n-\t\t}\n-\n-\t| IMPLEMENTATION identifier ':' identifier\n-\t\t{\n-\t\t  objc_implementation_context\n-\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, $4, NULL_TREE);\n-                  objc_ivar_chain\n-\t\t    = continue_class (objc_implementation_context);\n-\t\t}\n-\n-\t| INTERFACE identifier '(' identifier ')' protocolrefs\n-\t\t{\n-\t\t  objc_interface_context\n-\t\t    = start_class (CATEGORY_INTERFACE_TYPE, $2, $4, $6);\n-                  continue_class (objc_interface_context);\n-\t\t}\n-\t  methodprotolist\n-\t  END\n-\t\t{\n-\t\t  finish_class (objc_interface_context);\n-\t\t  objc_interface_context = NULL_TREE;\n-\t\t}\n-\n-\t| IMPLEMENTATION identifier '(' identifier ')'\n-\t\t{\n-\t\t  objc_implementation_context\n-\t\t    = start_class (CATEGORY_IMPLEMENTATION_TYPE, $2, $4, NULL_TREE);\n-                  objc_ivar_chain\n-\t\t    = continue_class (objc_implementation_context);\n-\t\t}\n-\t;\n-\n-protocoldef:\n-\t  PROTOCOL identifier protocolrefs\n-\t\t{\n-\t\t  remember_protocol_qualifiers ();\n-\t\t  objc_interface_context\n-\t\t    = start_protocol(PROTOCOL_INTERFACE_TYPE, $2, $3);\n-\t\t}\n-\t  methodprotolist END\n-\t\t{\n-\t\t  forget_protocol_qualifiers();\n-\t\t  finish_protocol(objc_interface_context);\n-\t\t  objc_interface_context = NULL_TREE;\n-\t\t}\n-\t;\n-\n-protocolrefs:\n-\t  /* empty */\n-\t\t{\n-\t\t  $$ = NULL_TREE;\n-\t\t}\n-\t| non_empty_protocolrefs\n-\t;\n-\n-non_empty_protocolrefs:\n-\t  ARITHCOMPARE identifier_list ARITHCOMPARE\n-\t\t{\n-\t\t  if ($1 == LT_EXPR && $3 == GT_EXPR)\n-\t\t    $$ = $2;\n-\t\t  else\n-\t\t    YYERROR1;\n-\t\t}\n-\t;\n-\n-ivar_decl_list:\n-          ivar_decl_list visibility_spec ivar_decls\n-        | ivar_decls\n-        ;\n-\n-visibility_spec:\n-\t  PRIVATE { objc_public_flag = 2; }\n-\t| PROTECTED { objc_public_flag = 0; }\n-\t| PUBLIC { objc_public_flag = 1; }\n-\t;\n-\n-ivar_decls:\n-          /* empty */\n-\t\t{\n-                  $$ = NULL_TREE;\n-                }\n-\t| ivar_decls ivar_decl ';'\n-\t| ivar_decls ';'\n-\t\t{\n-                  if (pedantic)\n-\t\t    pedwarn (\"extra semicolon in struct or union specified\");\n-                }\n-\t;\n-\n-\n-/* There is a shift-reduce conflict here, because `components' may\n-   start with a `typename'.  It happens that shifting (the default resolution)\n-   does the right thing, because it treats the `typename' as part of\n-   a `typed_typespecs'.\n-\n-   It is possible that this same technique would allow the distinction\n-   between `notype_initdecls' and `initdecls' to be eliminated.\n-   But I am being cautious and not trying it.  */\n-\n-ivar_decl:\n-\ttyped_typespecs setspecs ivars\n-\t        { $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| nonempty_type_quals setspecs ivars\n-\t\t{ $$ = $3;\n-\t\t  current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| error\n-\t\t{ $$ = NULL_TREE; }\n-\t;\n-\n-ivars:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| ivar_declarator\n-\t| ivars ',' ivar_declarator\n-\t;\n-\n-ivar_declarator:\n-\t  declarator\n-\t\t{\n-\t\t  $$ = add_instance_variable (objc_ivar_context,\n-\t\t\t\t\t      objc_public_flag,\n-\t\t\t\t\t      $1, current_declspecs,\n-\t\t\t\t\t      NULL_TREE);\n-                }\n-\t| declarator ':' expr_no_commas\n-\t\t{\n-\t\t  $$ = add_instance_variable (objc_ivar_context,\n-\t\t\t\t\t      objc_public_flag,\n-\t\t\t\t\t      $1, current_declspecs, $3);\n-                }\n-\t| ':' expr_no_commas\n-\t\t{\n-\t\t  $$ = add_instance_variable (objc_ivar_context,\n-\t\t\t\t\t      objc_public_flag,\n-\t\t\t\t\t      NULL_TREE,\n-\t\t\t\t\t      current_declspecs, $2);\n-                }\n-\t;\n-\n-methoddef:\n-\t  '+'\n-\t\t{\n-\t\t  remember_protocol_qualifiers ();\n-\t\t  if (objc_implementation_context)\n-\t\t    objc_inherit_code = CLASS_METHOD_DECL;\n-                  else\n-\t\t    fatal (\"method definition not in class context\");\n-\t\t}\n-\t  methoddecl\n-\t\t{\n-\t\t  forget_protocol_qualifiers ();\n-\t\t  add_class_method (objc_implementation_context, $3);\n-\t\t  start_method_def ($3);\n-\t\t  objc_method_context = $3;\n-\t\t}\n-\t  optarglist\n-\t\t{\n-\t\t  continue_method_def ();\n-\t\t}\n-\t  compstmt_or_error\n-\t\t{\n-\t\t  finish_method_def ();\n-\t\t  objc_method_context = NULL_TREE;\n-\t\t}\n-\n-\t| '-'\n-\t\t{\n-\t\t  remember_protocol_qualifiers ();\n-\t\t  if (objc_implementation_context)\n-\t\t    objc_inherit_code = INSTANCE_METHOD_DECL;\n-                  else\n-\t\t    fatal (\"method definition not in class context\");\n-\t\t}\n-\t  methoddecl\n-\t\t{\n-\t\t  forget_protocol_qualifiers ();\n-\t\t  add_instance_method (objc_implementation_context, $3);\n-\t\t  start_method_def ($3);\n-\t\t  objc_method_context = $3;\n-\t\t}\n-\t  optarglist\n-\t\t{\n-\t\t  continue_method_def ();\n-\t\t}\n-\t  compstmt_or_error\n-\t\t{\n-\t\t  finish_method_def ();\n-\t\t  objc_method_context = NULL_TREE;\n-\t\t}\n-\t;\n-\n-/* the reason for the strange actions in this rule\n- is so that notype_initdecls when reached via datadef\n- can find a valid list of type and sc specs in $0. */\n-\n-methodprotolist:\n-\t  /* empty  */\n-\t| {$<ttype>$ = NULL_TREE; } methodprotolist2\n-\t;\n-\n-methodprotolist2:\t\t /* eliminates a shift/reduce conflict */\n-\t   methodproto\n-\t|  datadef\n-\t| methodprotolist2 methodproto\n-\t| methodprotolist2 {$<ttype>$ = NULL_TREE; } datadef\n-\t;\n-\n-semi_or_error:\n-\t  ';'\n-\t| error\n-\t;\n-\n-methodproto:\n-\t  '+'\n-\t\t{\n-\t\t  /* Remember protocol qualifiers in prototypes.  */\n-\t\t  remember_protocol_qualifiers ();\n-\t\t  objc_inherit_code = CLASS_METHOD_DECL;\n-\t\t}\n-\t  methoddecl\n-\t\t{\n-\t\t  /* Forget protocol qualifiers here.  */\n-\t\t  forget_protocol_qualifiers ();\n-\t\t  add_class_method (objc_interface_context, $3);\n-\t\t}\n-\t  semi_or_error\n-\n-\t| '-'\n-\t\t{\n-\t\t  /* Remember protocol qualifiers in prototypes.  */\n-\t\t  remember_protocol_qualifiers ();\n-\t\t  objc_inherit_code = INSTANCE_METHOD_DECL;\n-\t\t}\n-\t  methoddecl\n-\t\t{\n-\t\t  /* Forget protocol qualifiers here.  */\n-\t\t  forget_protocol_qualifiers ();\n-\t\t  add_instance_method (objc_interface_context, $3);\n-\t\t}\n-\t  semi_or_error\n-\t;\n-\n-methoddecl:\n-\t  '(' typename ')' unaryselector\n-\t\t{\n-\t\t  $$ = build_method_decl (objc_inherit_code, $2, $4, NULL_TREE);\n-\t\t}\n-\n-\t| unaryselector\n-\t\t{\n-\t\t  $$ = build_method_decl (objc_inherit_code, NULL_TREE, $1, NULL_TREE);\n-\t\t}\n-\n-\t| '(' typename ')' keywordselector optparmlist\n-\t\t{\n-\t\t  $$ = build_method_decl (objc_inherit_code, $2, $4, $5);\n-\t\t}\n-\n-\t| keywordselector optparmlist\n-\t\t{\n-\t\t  $$ = build_method_decl (objc_inherit_code, NULL_TREE, $1, $2);\n-\t\t}\n-\t;\n-\n-/* \"optarglist\" assumes that start_method_def has already been called...\n-   if it is not, the \"xdecls\" will not be placed in the proper scope */\n-\n-optarglist:\n-\t  /* empty */\n-\t| ';' myxdecls\n-\t;\n-\n-/* to get around the following situation: \"int foo (int a) int b; {}\" that\n-   is synthesized when parsing \"- a:a b:b; id c; id d; { ... }\" */\n-\n-myxdecls:\n-\t  /* empty */\n-\t| mydecls\n-\t;\n-\n-mydecls:\n-\tmydecl\n-\t| errstmt\n-\t| mydecls mydecl\n-\t| mydecl errstmt\n-\t;\n-\n-mydecl:\n-\ttyped_declspecs setspecs myparms ';'\n-\t\t{ current_declspecs = TREE_VALUE (declspec_stack);\n-\t\t  prefix_attributes = TREE_PURPOSE (declspec_stack);\n-\t\t  declspec_stack = TREE_CHAIN (declspec_stack); }\n-\t| typed_declspecs ';'\n-\t\t{ shadow_tag ($1); }\n-\t| declmods ';'\n-\t\t{ pedwarn (\"empty declaration\"); }\n-\t;\n-\n-myparms:\n-\tmyparm\n-\t\t{ push_parm_decl ($1); }\n-\t| myparms ',' myparm\n-\t\t{ push_parm_decl ($3); }\n-\t;\n-\n-/* A single parameter declaration or parameter type name,\n-   as found in a parmlist. DOES NOT ALLOW AN INITIALIZER OR ASMSPEC */\n-\n-myparm:\n-\t  parm_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $1),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $2)); }\n-\t| notype_declarator maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $1),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $2)); }\n-\t| absdcl maybe_attribute\n-\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n-\t\t\t\t\t\t\t $1),\n-\t\t\t\t\tbuild_tree_list (prefix_attributes,\n-\t\t\t\t\t\t\t $2)); }\n-\t;\n-\n-optparmlist:\n-\t  /* empty */\n-\t\t{\n-\t    \t  $$ = NULL_TREE;\n-\t\t}\n-\t| ',' ELLIPSIS\n-\t\t{\n-\t\t  /* oh what a kludge! */\n-\t\t  $$ = objc_ellipsis_node;\n-\t\t}\n-\t| ','\n-\t\t{\n-\t\t  pushlevel (0);\n-\t\t}\n-\t  parmlist_2\n-\t\t{\n-\t  \t  /* returns a tree list node generated by get_parm_info */\n-\t\t  $$ = $3;\n-\t\t  poplevel (0, 0, 0);\n-\t\t}\n-\t;\n-\n-unaryselector:\n-\t  selector\n-\t;\n-\n-keywordselector:\n-\t  keyworddecl\n-\n-\t| keywordselector keyworddecl\n-\t\t{\n-\t\t  $$ = chainon ($1, $2);\n-\t\t}\n-\t;\n-\n-selector:\n-\t  IDENTIFIER\n-        | TYPENAME\n-  \t| OBJECTNAME\n-\t| reservedwords\n-\t;\n-\n-reservedwords:\n-\t  ENUM { $$ = get_identifier (token_buffer); }\n-\t| STRUCT { $$ = get_identifier (token_buffer); }\n-\t| UNION { $$ = get_identifier (token_buffer); }\n-\t| IF { $$ = get_identifier (token_buffer); }\n-\t| ELSE { $$ = get_identifier (token_buffer); }\n-\t| WHILE { $$ = get_identifier (token_buffer); }\n-\t| DO { $$ = get_identifier (token_buffer); }\n-\t| FOR { $$ = get_identifier (token_buffer); }\n-\t| SWITCH { $$ = get_identifier (token_buffer); }\n-\t| CASE { $$ = get_identifier (token_buffer); }\n-\t| DEFAULT { $$ = get_identifier (token_buffer); }\n-\t| BREAK { $$ = get_identifier (token_buffer); }\n-\t| CONTINUE { $$ = get_identifier (token_buffer); }\n-\t| RETURN  { $$ = get_identifier (token_buffer); }\n-\t| GOTO { $$ = get_identifier (token_buffer); }\n-\t| ASM_KEYWORD { $$ = get_identifier (token_buffer); }\n-        | SIZEOF { $$ = get_identifier (token_buffer); }\n-\t| TYPEOF { $$ = get_identifier (token_buffer); }\n-\t| ALIGNOF { $$ = get_identifier (token_buffer); }\n-\t| TYPESPEC | TYPE_QUAL\n-\t;\n-\n-keyworddecl:\n-\t  selector ':' '(' typename ')' identifier\n-\t\t{\n-\t\t  $$ = build_keyword_decl ($1, $4, $6);\n-\t\t}\n-\n-\t| selector ':' identifier\n-\t\t{\n-\t\t  $$ = build_keyword_decl ($1, NULL_TREE, $3);\n-\t\t}\n-\n-\t| ':' '(' typename ')' identifier\n-\t\t{\n-\t\t  $$ = build_keyword_decl (NULL_TREE, $3, $5);\n-\t\t}\n-\n-\t| ':' identifier\n-\t\t{\n-\t\t  $$ = build_keyword_decl (NULL_TREE, NULL_TREE, $2);\n-\t\t}\n-\t;\n-\n-messageargs:\n-\t  selector\n-        | keywordarglist\n-\t;\n-\n-keywordarglist:\n-\t  keywordarg\n-\t| keywordarglist keywordarg\n-\t\t{\n-\t\t  $$ = chainon ($1, $2);\n-\t\t}\n-\t;\n-\n-\n-keywordexpr:\n-\t  nonnull_exprlist\n-\t\t{\n-\t\t  if (TREE_CHAIN ($1) == NULL_TREE)\n-\t\t    /* just return the expr., remove a level of indirection */\n-\t\t    $$ = TREE_VALUE ($1);\n-                  else\n-\t\t    /* we have a comma expr., we will collapse later */\n-\t\t    $$ = $1;\n-\t\t}\n-\t;\n-\n-keywordarg:\n-\t  selector ':' keywordexpr\n-\t\t{\n-\t\t  $$ = build_tree_list ($1, $3);\n-\t\t}\n-\t| ':' keywordexpr\n-\t\t{\n-\t\t  $$ = build_tree_list (NULL_TREE, $2);\n-\t\t}\n-\t;\n-\n-receiver:\n-\t  expr\n-\t| CLASSNAME\n-\t\t{\n-\t\t  $$ = get_class_reference ($1);\n-\t\t}\n-\t;\n-\n-objcmessageexpr:\n-\t  '['\n-\t\t{ objc_receiver_context = 1; }\n-\t  receiver\n-\t\t{ objc_receiver_context = 0; }\n-\t  messageargs ']'\n-\t\t{\n-\t\t  $$ = build_tree_list ($3, $5);\n-\t\t}\n-\t;\n-\n-selectorarg:\n-\t  selector\n-        | keywordnamelist\n-\t;\n-\n-keywordnamelist:\n-\t  keywordname\n-\t| keywordnamelist keywordname\n-\t\t{\n-\t\t  $$ = chainon ($1, $2);\n-\t\t}\n-\t;\n-\n-keywordname:\n-\t  selector ':'\n-\t\t{\n-\t\t  $$ = build_tree_list ($1, NULL_TREE);\n-\t\t}\n-\t| ':'\n-\t\t{\n-\t\t  $$ = build_tree_list (NULL_TREE, NULL_TREE);\n-\t\t}\n-\t;\n-\n-objcselectorexpr:\n-\t  SELECTOR '(' selectorarg ')'\n-\t\t{\n-\t\t  $$ = $3;\n-\t\t}\n-\t;\n-\n-objcprotocolexpr:\n-\t  PROTOCOL '(' identifier ')'\n-\t\t{\n-\t\t  $$ = $3;\n-\t\t}\n-\t;\n-\n-/* extension to support C-structures in the archiver */\n-\n-objcencodeexpr:\n-\t  ENCODE '(' typename ')'\n-\t\t{\n-\t\t  $$ = groktypename ($3);\n-\t\t}\n-\t;\n-\n-%%"}]}