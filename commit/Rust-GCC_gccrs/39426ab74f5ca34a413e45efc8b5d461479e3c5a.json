{"sha": "39426ab74f5ca34a413e45efc8b5d461479e3c5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0MjZhYjc0ZjVjYTM0YTQxM2U0NWVmYzhiNWQ0NjE0NzllM2M1YQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2017-06-30T16:04:08Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2017-06-30T16:04:08Z"}, "message": "tree-cfg.c (group_case_labels_stmt): Merge scanning and compressing loops.\n\n\t* tree-cfg.c (group_case_labels_stmt): Merge scanning and compressing\n\tloops.  Remove now unneeded calls to gimple_switch_set_label() that\n\tjust set removed labels to NULL_TREE.\n\nFrom-SVN: r249847", "tree": {"sha": "d599649632c97851d238510fa14d8f2a2f8700ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d599649632c97851d238510fa14d8f2a2f8700ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39426ab74f5ca34a413e45efc8b5d461479e3c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39426ab74f5ca34a413e45efc8b5d461479e3c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39426ab74f5ca34a413e45efc8b5d461479e3c5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39426ab74f5ca34a413e45efc8b5d461479e3c5a/comments", "author": null, "committer": null, "parents": [{"sha": "059ab149148378662403798003b8f380c0a12588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059ab149148378662403798003b8f380c0a12588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059ab149148378662403798003b8f380c0a12588"}], "stats": {"total": 47, "additions": 24, "deletions": 23}, "files": [{"sha": "d5f94fb009f7e6fc9ebf71bf4d3e89c466cf2199", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39426ab74f5ca34a413e45efc8b5d461479e3c5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39426ab74f5ca34a413e45efc8b5d461479e3c5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39426ab74f5ca34a413e45efc8b5d461479e3c5a", "patch": "@@ -1,3 +1,9 @@\n+2017-06-30  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* tree-cfg.c (group_case_labels_stmt): Merge scanning and compressing\n+\tloops.  Remove now unneeded calls to gimple_switch_set_label() that\n+\tjust set removed labels to NULL_TREE.\n+\n 2017-06-30  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* tree-ssanames.c (set_range_info_raw): Abstract from ...\n@@ -16,7 +22,7 @@\n \tFor V16FI and V8SF_256 iterators, don't test if both operands are MEM\n \tif <mask_applied>.  For VI4F_256 iterator, use <store_mask_predicate>\n \tinstead of register_operand and <store_mask_constraint> instead of v for\n-        the input operand.  Make sure both operands aren't MEMs for if not\n+\tthe input operand.  Make sure both operands aren't MEMs for if not\n \t<mask_applied>.\n \n 2017-06-30  Sylvestre Ledru  <sylvestre@debian.org>"}, {"sha": "848b20f90d2b52cbae2c54b8158cc58b9f0ff597", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39426ab74f5ca34a413e45efc8b5d461479e3c5a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39426ab74f5ca34a413e45efc8b5d461479e3c5a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=39426ab74f5ca34a413e45efc8b5d461479e3c5a", "patch": "@@ -1679,13 +1679,13 @@ bool\n group_case_labels_stmt (gswitch *stmt)\n {\n   int old_size = gimple_switch_num_labels (stmt);\n-  int i, j, base_index, new_size = old_size;\n+  int i, next_index, new_size;\n   basic_block default_bb = NULL;\n \n   default_bb = label_to_block (CASE_LABEL (gimple_switch_default_label (stmt)));\n \n   /* Look for possible opportunities to merge cases.  */\n-  i = 1;\n+  new_size = i = 1;\n   while (i < old_size)\n     {\n       tree base_case, base_high;\n@@ -1699,23 +1699,21 @@ group_case_labels_stmt (gswitch *stmt)\n       /* Discard cases that have the same destination as the default case.  */\n       if (base_bb == default_bb)\n \t{\n-\t  gimple_switch_set_label (stmt, i, NULL_TREE);\n \t  i++;\n-\t  new_size--;\n \t  continue;\n \t}\n \n       base_high = CASE_HIGH (base_case)\n \t  ? CASE_HIGH (base_case)\n \t  : CASE_LOW (base_case);\n-      base_index = i++;\n+      next_index = i + 1;\n \n       /* Try to merge case labels.  Break out when we reach the end\n \t of the label vector or when we cannot merge the next case\n \t label with the current one.  */\n-      while (i < old_size)\n+      while (next_index < old_size)\n \t{\n-\t  tree merge_case = gimple_switch_label (stmt, i);\n+\t  tree merge_case = gimple_switch_label (stmt, next_index);\n \t  basic_block merge_bb = label_to_block (CASE_LABEL (merge_case));\n \t  wide_int bhp1 = wi::add (base_high, 1);\n \n@@ -1727,9 +1725,7 @@ group_case_labels_stmt (gswitch *stmt)\n \t      base_high = CASE_HIGH (merge_case) ?\n \t\t  CASE_HIGH (merge_case) : CASE_LOW (merge_case);\n \t      CASE_HIGH (base_case) = base_high;\n-\t      gimple_switch_set_label (stmt, i, NULL_TREE);\n-\t      new_size--;\n-\t      i++;\n+\t      next_index++;\n \t    }\n \t  else\n \t    break;\n@@ -1742,23 +1738,22 @@ group_case_labels_stmt (gswitch *stmt)\n \t  edge base_edge = find_edge (gimple_bb (stmt), base_bb);\n \t  if (base_edge != NULL)\n \t    remove_edge_and_dominated_blocks (base_edge);\n-\t  gimple_switch_set_label (stmt, base_index, NULL_TREE);\n-\t  new_size--;\n+\t  i = next_index;\n+\t  continue;\n \t}\n-    }\n \n-  /* Compress the case labels in the label vector, and adjust the\n-     length of the vector.  */\n-  for (i = 0, j = 0; i < new_size; i++)\n-    {\n-      while (! gimple_switch_label (stmt, j))\n-\tj++;\n-      gimple_switch_set_label (stmt, i,\n-\t\t\t       gimple_switch_label (stmt, j++));\n+      if (new_size < i)\n+\tgimple_switch_set_label (stmt, new_size,\n+\t\t\t\t gimple_switch_label (stmt, i));\n+      i = next_index;\n+      new_size++;\n     }\n \n   gcc_assert (new_size <= old_size);\n-  gimple_switch_set_num_labels (stmt, new_size);\n+\n+  if (new_size < old_size)\n+    gimple_switch_set_num_labels (stmt, new_size);\n+\n   return new_size < old_size;\n }\n "}]}