{"sha": "0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjMzNjM2MxNDY1MGZhNTVmNjBiMDhmZGZlNGFhZWJhNWMwYzliYw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-04-15T18:15:35Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-04-15T18:15:35Z"}, "message": "In gcc/c-family/: 2011-04-15 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/c-family/:\n2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* c-objc.h (objc_get_interface_ivars): Removed.\n\t(objc_detect_field_duplicates): New.\t\n\t* stub-objc.c: Likewise.\n\t\nIn gcc/:\n2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* c-decl.c (detect_field_duplicates): Call\n\tobjc_detect_field_duplicates instead of objc_get_interface_ivars.\n\nIn gcc/objc/:\n2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc-act.c (objc_get_interface_ivars): Removed.\n\t(objc_detect_field_duplicates): New.\n\t(hash_instance_variable): New.\n\t(eq_instance_variable): New.\n\t\nIn gcc/objcp/:\n2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objcp-decl.c (objcp_finish_struct): Use\n\tobjc_detect_field_duplicates instead of having a local\n\timplementation.\n\nIn gcc/testsuite/:\n2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc.dg/naming-4.m: Updated.\n\t* objc.dg/naming-5.m: Updated.\t\n\t* objc.dg/naming-6.m: New.\n\t* objc.dg/naming-7.m: New.\t\n\t* obj-c++.dg/naming-1.mm: Updated.\n\t* obj-c++.dg/naming-2.mm: Updated.\n\t* obj-c++.dg/naming-3.mm: New.\n\t* obj-c++.dg/naming-4.mm: New.\n\nFrom-SVN: r172511", "tree": {"sha": "4be690823fed9a5422c76137ffd4ee6054c70b90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4be690823fed9a5422c76137ffd4ee6054c70b90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9472124fb40edbebcd6283b8891e4524b400bdc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9472124fb40edbebcd6283b8891e4524b400bdc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9472124fb40edbebcd6283b8891e4524b400bdc1"}], "stats": {"total": 697, "additions": 634, "deletions": 63}, "files": [{"sha": "f047ac34c174a42f168b3d887f93b557fbec6516", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -1,3 +1,8 @@\n+2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-decl.c (detect_field_duplicates): Call\n+\tobjc_detect_field_duplicates instead of objc_get_interface_ivars.\n+\n 2011-04-15  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* gimple.h (gimple_asm_clobbers_memory_p): Declare."}, {"sha": "ce6fd2ab364f382ba025779fe7d3a75a061afa63", "filename": "gcc/c-decl.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -6829,15 +6829,19 @@ detect_field_duplicates (tree fieldlist)\n   int timeout = 10;\n \n   /* If the struct is the list of instance variables of an Objective-C\n-     class, then we need to add all the instance variables of\n-     superclasses before checking for duplicates (since you can't have\n+     class, then we need to check all the instance variables of\n+     superclasses when checking for duplicates (since you can't have\n      an instance variable in a subclass with the same name as an\n-     instance variable in a superclass).  objc_get_interface_ivars()\n-     leaves fieldlist unchanged if we are not in this case, so in that\n-     case nothing changes compared to C.\n-  */\n+     instance variable in a superclass).  We pass on this job to the\n+     Objective-C compiler.  objc_detect_field_duplicates() will return\n+     false if we are not checking the list of instance variables and\n+     the C frontend should proceed with the standard field duplicate\n+     checks.  If we are checking the list of instance variables, the\n+     ObjC frontend will do the check, emit the errors if needed, and\n+     then return true.  */\n   if (c_dialect_objc ())\n-    fieldlist = objc_get_interface_ivars (fieldlist);\n+    if (objc_detect_field_duplicates (false))\n+      return;\n \n   /* First, see if there are more than \"a few\" fields.\n      This is trivially true if there are zero or one fields.  */"}, {"sha": "f8f0b4b6707ec664821a2c3c5dd30a0ce0aef468", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -1,3 +1,9 @@\n+2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-objc.h (objc_get_interface_ivars): Removed.\n+\t(objc_detect_field_duplicates): New.\t\n+\t* stub-objc.c: Likewise.\n+\t\n 2011-04-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* stub-objc.c (objc_declare_protocols): Renamed to"}, {"sha": "33e9f9d66f1a5d38c4b272622a6f39bc5d76bfa9", "filename": "gcc/c-family/c-objc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-family%2Fc-objc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-family%2Fc-objc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-objc.h?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -62,7 +62,7 @@ extern tree objc_build_string_object (tree);\n extern tree objc_get_protocol_qualified_type (tree, tree);\n extern tree objc_get_class_reference (tree);\n extern tree objc_get_class_ivars (tree);\n-extern tree objc_get_interface_ivars (tree);\n+extern bool objc_detect_field_duplicates (bool);\n extern void objc_start_class_interface (tree, tree, tree, tree);\n extern void objc_start_category_interface (tree, tree, tree, tree);\n extern void objc_start_protocol (tree, tree, tree);"}, {"sha": "26ea3c87dab6ac5a9eb577877e809a532ac8a02b", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -275,10 +275,10 @@ objc_get_class_reference (tree ARG_UNUSED (name))\n   return 0;\n }\n \n-tree\n-objc_get_interface_ivars (tree ARG_UNUSED (fieldlist))\n+bool\n+objc_detect_field_duplicates (bool ARG_UNUSED (check_superclasses_only))\n {\n-  return 0;\n+  return false;\n }\n \n tree"}, {"sha": "9698eee1248497c20b4526966ede1ca9a0c55ed3", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -1,3 +1,10 @@\n+2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_get_interface_ivars): Removed.\n+\t(objc_detect_field_duplicates): New.\n+\t(hash_instance_variable): New.\n+\t(eq_instance_variable): New.\n+\t\n 2011-04-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_declare_protocols): Renamed to"}, {"sha": "ff4045379ddbc97b82476483c2d83b43d426cda9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 234, "deletions": 9, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -3813,6 +3813,8 @@ lookup_interface (tree ident)\n   }\n }\n \n+\n+\n /* Implement @defs (<classname>) within struct bodies.  */\n \n tree\n@@ -3829,19 +3831,242 @@ objc_get_class_ivars (tree class_name)\n   return error_mark_node;\n }\n \n+\n+/* Functions used by the hashtable for field duplicates in\n+   objc_detect_field_duplicates().  Ideally, we'd use a standard\n+   key-value dictionary hashtable , and store as keys the field names,\n+   and as values the actual declarations (used to print nice error\n+   messages with the locations).  But, the hashtable we are using only\n+   allows us to store keys in the hashtable, without values (it looks\n+   more like a set).  So, we store the DECLs, but define equality as\n+   DECLs having the same name, and hash as the hash of the name.  */\n+static hashval_t\n+hash_instance_variable (const PTR p)\n+{\n+  const_tree q = (const_tree)p;\n+  return (hashval_t) ((intptr_t)(DECL_NAME (q)) >> 3);\n+}\n+\n+static int\n+eq_instance_variable (const PTR p1, const PTR p2)\n+{\n+  const_tree a = (const_tree)p1;\n+  const_tree b = (const_tree)p2;\n+  return DECL_NAME (a) == DECL_NAME (b);\n+}\n+\n /* Called when checking the variables in a struct.  If we are not\n-   doing the ivars list inside an @interface context, then returns\n-   fieldlist unchanged.  Else, returns the list of class ivars.\n-*/\n-tree\n-objc_get_interface_ivars (tree fieldlist)\n+   doing the ivars list inside an @interface context, then return\n+   false.  Else, perform the check for duplicate ivars, then return\n+   true.  The check for duplicates checks if an instance variable with\n+   the same name exists in the class or in a superclass.  If\n+   'check_superclasses_only' is set to true, then it is assumed that\n+   checks for instance variables in the same class has already been\n+   performed (this is the case for ObjC++) and only the instance\n+   variables of superclasses are checked.  */\n+bool\n+objc_detect_field_duplicates (bool check_superclasses_only)\n {\n   if (!objc_collecting_ivars || !objc_interface_context \n-      || TREE_CODE (objc_interface_context) != CLASS_INTERFACE_TYPE\n-      || CLASS_SUPER_NAME (objc_interface_context) == NULL_TREE)\n-    return fieldlist;\n+      || TREE_CODE (objc_interface_context) != CLASS_INTERFACE_TYPE)\n+    return false;\n+\n+  /* We have two ways of doing this check:\n+     \n+  \"direct comparison\": we iterate over the instance variables and\n+  compare them directly.  This works great for small numbers of\n+  instance variables (such as 10 or 20), which are extremely common.\n+  But it will potentially take forever for the pathological case with\n+  a huge number (eg, 10k) of instance variables.\n+  \n+  \"hashtable\": we use a hashtable, which requires a single sweep\n+  through the list of instances variables.  This is much slower for a\n+  small number of variables, and we only use it for large numbers.\n \n-  return get_class_ivars (objc_interface_context, true);\n+  To decide which one to use, we need to get an idea of how many\n+  instance variables we have to compare.  */\n+  {\n+    unsigned int number_of_ivars_to_check = 0;\n+    {\n+      tree ivar;\n+      for (ivar = CLASS_RAW_IVARS (objc_interface_context);\n+\t   ivar; ivar = DECL_CHAIN (ivar))\n+\t{\n+\t  /* Ignore anonymous ivars.  */\n+\t  if (DECL_NAME (ivar))\n+\t    number_of_ivars_to_check++;\n+\t}\n+    }\n+\n+    /* Exit if there is nothing to do.  */\n+    if (number_of_ivars_to_check == 0)\n+      return true;\n+    \n+    /* In case that there are only 1 or 2 instance variables to check,\n+       we always use direct comparison.  If there are more, it is\n+       worth iterating over the instance variables in the superclass\n+       to count how many there are (note that this has the same cost\n+       as checking 1 instance variable by direct comparison, which is\n+       why we skip this check in the case of 1 or 2 ivars and just do\n+       the direct comparison) and then decide if it worth using a\n+       hashtable.  */\n+    if (number_of_ivars_to_check > 2)\n+      {\n+\tunsigned int number_of_superclass_ivars = 0;\n+\t{\n+\t  tree interface;\n+\t  for (interface = lookup_interface (CLASS_SUPER_NAME (objc_interface_context));\n+\t       interface; interface = lookup_interface (CLASS_SUPER_NAME (interface)))\n+\t    {\n+\t      tree ivar;\n+\t      for (ivar = CLASS_RAW_IVARS (interface);\n+\t\t   ivar; ivar = DECL_CHAIN (ivar))\n+\t\tnumber_of_superclass_ivars++;\n+\t    }\n+\t}\n+\n+\t/* We use a hashtable if we have over 10k comparisons.  */\n+\tif (number_of_ivars_to_check * (number_of_superclass_ivars \n+\t\t\t\t\t+ (number_of_ivars_to_check / 2))\n+\t    > 10000)\n+\t  {\n+\t    /* First, build the hashtable by putting all the instance\n+\t       variables of superclasses in it.  */\n+\t    htab_t htab = htab_create (37, hash_instance_variable,\n+\t\t\t\t       eq_instance_variable, NULL);\n+\t    tree interface;\n+\t    for (interface = lookup_interface (CLASS_SUPER_NAME\n+\t\t\t\t\t       (objc_interface_context));\n+\t\t interface; interface = lookup_interface\n+\t\t   (CLASS_SUPER_NAME (interface)))\n+\t      {\n+\t\ttree ivar;\n+\t\tfor (ivar = CLASS_RAW_IVARS (interface); ivar;\n+\t\t     ivar = DECL_CHAIN (ivar))\n+\t\t  {\n+\t\t    if (DECL_NAME (ivar) != NULL_TREE)\n+\t\t      {\n+\t\t\tvoid **slot = htab_find_slot (htab, ivar, INSERT);\n+\t\t\t/* Do not check for duplicate instance\n+\t\t\t   variables in superclasses.  Errors have\n+\t\t\t   already been generated.  */\n+\t\t\t*slot = ivar;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    \n+\t    /* Now, we go through all the instance variables in the\n+\t       class, and check that they are not in the\n+\t       hashtable.  */\n+\t    if (check_superclasses_only)\n+\t      {\n+\t\ttree ivar;\n+\t\tfor (ivar = CLASS_RAW_IVARS (objc_interface_context); ivar;\n+\t\t     ivar = DECL_CHAIN (ivar))\n+\t\t  {\n+\t\t    if (DECL_NAME (ivar) != NULL_TREE)\n+\t\t      {\n+\t\t\ttree duplicate_ivar = (tree)(htab_find (htab, ivar));\n+\t\t\tif (duplicate_ivar != HTAB_EMPTY_ENTRY)\n+\t\t\t  {\n+\t\t\t    error_at (DECL_SOURCE_LOCATION (ivar),\n+\t\t\t\t      \"duplicate instance variable %q+D\",\n+\t\t\t\t      ivar);\n+\t\t\t    inform (DECL_SOURCE_LOCATION (duplicate_ivar),\n+\t\t\t\t    \"previous declaration of %q+D\",\n+\t\t\t\t    duplicate_ivar);\n+\t\t\t    /* FIXME: Do we need the following ?  */\n+\t\t\t    /* DECL_NAME (ivar) = NULL_TREE; */\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* If we're checking for duplicates in the class as\n+\t\t   well, we insert variables in the hashtable as we\n+\t\t   check them, so if a duplicate follows, it will be\n+\t\t   caught.  */\n+\t\ttree ivar;\n+\t\tfor (ivar = CLASS_RAW_IVARS (objc_interface_context); ivar;\n+\t\t     ivar = DECL_CHAIN (ivar))\n+\t\t  {\n+\t\t    if (DECL_NAME (ivar) != NULL_TREE)\n+\t\t      {\n+\t\t\tvoid **slot = htab_find_slot (htab, ivar, INSERT);\n+\t\t\tif (*slot)\n+\t\t\t  {\n+\t\t\t    tree duplicate_ivar = (tree)(*slot);\n+\t\t\t    error_at (DECL_SOURCE_LOCATION (ivar),\n+\t\t\t\t      \"duplicate instance variable %q+D\",\n+\t\t\t\t      ivar);\n+\t\t\t    inform (DECL_SOURCE_LOCATION (duplicate_ivar),\n+\t\t\t\t    \"previous declaration of %q+D\",\n+\t\t\t\t    duplicate_ivar);\n+\t\t\t    /* FIXME: Do we need the following ?  */\n+\t\t\t    /* DECL_NAME (ivar) = NULL_TREE; */\n+\t\t\t  }\n+\t\t\t*slot = ivar;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    htab_delete (htab);\n+\t    return true;\n+\t  }\n+      }\n+  }\n+  \n+  /* This is the \"direct comparison\" approach, which is used in most\n+     non-pathological cases.  */\n+  {\n+    /* Walk up to class hierarchy, starting with this class (this is\n+       the external loop, because lookup_interface() is expensive, and\n+       we want to do it few times).  */\n+    tree interface = objc_interface_context;\n+\n+    if (check_superclasses_only)\n+      interface = lookup_interface (CLASS_SUPER_NAME (interface));\n+    \n+    for ( ; interface; interface = lookup_interface\n+\t    (CLASS_SUPER_NAME (interface)))\n+      {\n+\ttree ivar_being_checked;\n+\n+\tfor (ivar_being_checked = CLASS_RAW_IVARS (objc_interface_context);\n+\t     ivar_being_checked;\n+\t     ivar_being_checked = DECL_CHAIN (ivar_being_checked))\n+\t  {\n+\t    tree decl;\n+\t    \n+\t    /* Ignore anonymous ivars.  */\n+\t    if (DECL_NAME (ivar_being_checked) == NULL_TREE)\n+\t      continue;\n+\n+\t    /* Note how we stop when we find the ivar we are checking\n+\t       (this can only happen in the main class, not\n+\t       superclasses), to avoid comparing things twice\n+\t       (otherwise, for each ivar, you'd compare A to B then B\n+\t       to A, and get duplicated error messages).  */\n+\t    for (decl = CLASS_RAW_IVARS (interface);\n+\t\t decl && decl != ivar_being_checked;\n+\t\t decl = DECL_CHAIN (decl))\n+\t      {\n+\t\tif (DECL_NAME (ivar_being_checked) == DECL_NAME (decl))\n+\t\t  {\n+\t\t    error_at (DECL_SOURCE_LOCATION (ivar_being_checked),\n+\t\t\t      \"duplicate instance variable %q+D\",\n+\t\t\t      ivar_being_checked);\n+\t\t    inform (DECL_SOURCE_LOCATION (decl),\n+\t\t\t    \"previous declaration of %q+D\",\n+\t\t\t    decl);\n+\t\t    /* FIXME: Do we need the following ?  */\n+\t\t    /* DECL_NAME (ivar_being_checked) = NULL_TREE; */\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+  }\n+  return true;\n }\n \n /* Used by: build_private_template, continue_class,"}, {"sha": "dba3907fa76757626aaa5888d0b158271a28704c", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -1,3 +1,9 @@\n+2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objcp-decl.c (objcp_finish_struct): Use\n+\tobjc_detect_field_duplicates instead of having a local\n+\timplementation.\n+\n 2011-04-12  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* objcp-lang.c (objcxx_init_ts): Call objc_common_init_ts and"}, {"sha": "ecc2b2b3cbbde5e5ec607511f87c6d292f8c064c", "filename": "gcc/objcp/objcp-decl.c", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjcp%2Fobjcp-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Fobjcp%2Fobjcp-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.c?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -70,33 +70,7 @@ objcp_finish_struct (location_t loc ATTRIBUTE_UNUSED,\n      ivars, we need to check for duplicate ivars.\n   */\n   if (fieldlist)\n-    {\n-      tree original_fieldlist = fieldlist;\n-      fieldlist = objc_get_interface_ivars (fieldlist);\n-      if (fieldlist != original_fieldlist)\n-\t{\n-\t  /* Minimal implementation of the equivalent of the C\n-\t     front-end's detect_field_duplicates().\n-\t  */\n-\t  htab_t htab = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n-\t  tree x, y;\n-\t  void **slot;\n-\t  \n-\t  for (x = fieldlist; x ; x = DECL_CHAIN (x))\n-\t    if ((y = DECL_NAME (x)) != 0)\n-\t      {\n-\t\tslot = htab_find_slot (htab, y, INSERT);\n-\t\tif (*slot)\n-\t\t  {\n-\t\t    error (\"duplicate member %q+D\", x);\n-\t\t    DECL_NAME (x) = NULL_TREE;\n-\t\t  }\n-\t\t*slot = y;\n-\t      }\n-\t  \n-\t  htab_delete (htab);\n-\t}\n-    }\n+    objc_detect_field_duplicates (true);\n \n   pop_lang_context ();\n "}, {"sha": "29a9fa12b34d8d98ba5125a18af278d2ef8a7b6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -1,3 +1,14 @@\n+2011-04-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/naming-4.m: Updated.\n+\t* objc.dg/naming-5.m: Updated.\t\n+\t* objc.dg/naming-6.m: New.\n+\t* objc.dg/naming-7.m: New.\t\n+\t* obj-c++.dg/naming-1.mm: Updated.\n+\t* obj-c++.dg/naming-2.mm: Updated.\n+\t* obj-c++.dg/naming-3.mm: New.\n+\t* obj-c++.dg/naming-4.mm: New.\n+\t\n 2011-04-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/48589"}, {"sha": "164c8225bb3ec8885729022c8258932625927a43", "filename": "gcc/testsuite/obj-c++.dg/naming-1.mm", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-1.mm?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -5,13 +5,17 @@\n \n @interface A \n {\n-    NSDictionary * _userInfo;\n+    NSDictionary * _userInfo1; /* { dg-message \"previous declaration\" } */\n+    NSDictionary * _userInfo2; /* { dg-message \"previous declaration\" } */\n+    NSDictionary * _userInfo3; /* { dg-message \"previous declaration\" } */\n+    NSDictionary * _userInfo4; /* { dg-message \"previous declaration\" } */\n }\n @end\n \n @interface B : A\n {\n-    NSDictionary * _userInfo;\t/* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo1;\t/* { dg-error \"duplicate instance variable\" } */\n+    NSDictionary * _userInfo2;\t/* { dg-error \"duplicate instance variable\" } */\n }\n @end\n \n@@ -20,7 +24,8 @@ @interface C : A\n \n @interface D : C\n {\n-    NSDictionary * _userInfo;   /* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo3;  /* { dg-error \"duplicate instance variable\" } */\n+    NSDictionary * _userInfo4;  /* { dg-error \"duplicate instance variable\" } */\n }\n @end\n "}, {"sha": "49a83892f24205753362b277c33a389525f6b484", "filename": "gcc/testsuite/obj-c++.dg/naming-2.mm", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-2.mm?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -5,20 +5,21 @@\n \n @interface A \n {\n-    NSDictionary * _userInfo;\n+    NSDictionary * _userInfo; /* { dg-message \"previous declaration\" } */\n     int i1;\n     int i2;\n     int i3;\n     int i4;\n     int i5;\n     int i6;\n     int i7;\n+    NSDictionary * _userInfo1; /* { dg-message \"previous declaration\" } */\n }\n @end\n \n @interface B : A\n {\n-    NSDictionary * _userInfo;\t/* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo1; /* { dg-error \"duplicate instance variable\" } */\n     int ii1;\n     int ii2;\n     int ii3;\n@@ -34,7 +35,7 @@ @interface C : A\n \n @interface D : C\n {\n-    NSDictionary * _userInfo;   /* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo;   /* { dg-error \"duplicate instance variable\" } */\n }\n @end\n "}, {"sha": "ac812678e74790bcced63b6dc0c4290ad1c1d4d9", "filename": "gcc/testsuite/obj-c++.dg/naming-3.mm", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-3.mm?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -0,0 +1,15 @@\n+/* Testing for detecting duplicate ivars. */\n+/* { dg-do compile } */\n+\n+@interface A \n+{\n+  char x; /* { dg-error \"conflicts\" } */\n+  char x;\n+} /* { dg-error \"declaration\" } */\n+@end\n+\n+@interface B : A\n+{\n+  char y;\n+}\n+@end"}, {"sha": "4bb731206e5d1a733742cd7954ecfc9957872a17", "filename": "gcc/testsuite/obj-c++.dg/naming-4.mm", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fnaming-4.mm?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -0,0 +1,145 @@\n+/* Testing for detecting duplicate ivars. */\n+/* { dg-do compile } */\n+\n+/* This check wants to force the compiler to use a hashtable.  To do\n+   so, we need lots of instance variable.  */\n+\n+@interface A \n+{\n+  /* That's 200 instance variables, which is enough to trigger the\n+     hashtable check in the compiler.  */\n+  char a0; char a1; char a2; char a3; char a4; char a5; char a6; char a7; char a8; char a9;\n+  char b0; char b1; char b2; char b3; char b4; char b5; char b6; char b7; char b8; char b9;\n+  char c0; char c1; char c2; char c3; char c4; char c5; char c6; char c7; char c8; char c9;\n+  char d0; char d1; char d2; char d3; char d4; char d5; char d6; char d7; char d8; char d9;\n+  char e0; char e1; char e2; char e3; char e4; char e5; char e6; char e7; char e8; char e9;\n+  char f0; char f1; char f2; char f3; char f4; char f5; char f6; char f7; char f8; char f9;\n+  char g0; char g1; char g2; char g3; char g4; char g5; char g6; char g7; char g8; char g9;\n+  char h0; char h1; char h2; char h3; char h4; char h5; char h6; char h7; char h8; char h9;\n+  char i0; char i1; char i2; char i3; char i4; char i5; char i6; char i7; char i8; char i9;\n+  char j0; char j1; char j2; char j3; char j4; char j5; char j6; char j7; char j8; char j9;\n+  char k0; char k1; char k2; char k3; char k4; char k5; char k6; char k7; char k8; char k9;\n+  char l0; char l1; char l2; char l3; char l4; char l5; char l6; char l7; char l8; char l9;\n+  char m0; char m1; char m2; char m3; char m4; char m5; char m6; char m7; char m8; char m9;\n+  char n0; char n1; char n2; char n3; char n4; char n5; char n6; char n7; char n8; char n9;\n+  char o0; char o1; char o2; char o3; char o4; char o5; char o6; char o7; char o8; char o9;\n+  char p0; char p1; char p2; char p3; char p4; char p5; char p6; char p7; char p8; char p9;\n+  char q0; char q1; char q2; char q3; char q4; char q5; char q6; char q7; char q8; char q9;\n+  char r0; char r1; char r2; char r3; char r4; char r5; char r6; char r7; char r8; char r9;\n+  char s0; char s1; char s2; char s3; char s4; char s5; char s6; char s7; char s8; char s9;\n+\n+  char x; /* { dg-error \"conflicts\" } */\n+  char x;\n+\n+  char z; /* { dg-message \"previous declaration\" } */\n+  char k; /* { dg-message \"previous declaration\" } */\n+}  /* { dg-error \"declaration\" } */\n+@end\n+\n+@interface B : A\n+{\n+  /* That's another 200 instance variables, which should be enough to\n+     trigger the hashtable check in the compiler.  */\n+  char Ba0; char Ba1; char Ba2; char Ba3; char Ba4; char Ba5; char Ba6; char Ba7; char Ba8; char Ba9;\n+  char Bb0; char Bb1; char Bb2; char Bb3; char Bb4; char Bb5; char Bb6; char Bb7; char Bb8; char Bb9;\n+  char Bc0; char Bc1; char Bc2; char Bc3; char Bc4; char Bc5; char Bc6; char Bc7; char Bc8; char Bc9;\n+  char Bd0; char Bd1; char Bd2; char Bd3; char Bd4; char Bd5; char Bd6; char Bd7; char Bd8; char Bd9;\n+  char Be0; char Be1; char Be2; char Be3; char Be4; char Be5; char Be6; char Be7; char Be8; char Be9;\n+  char Bf0; char Bf1; char Bf2; char Bf3; char Bf4; char Bf5; char Bf6; char Bf7; char Bf8; char Bf9;\n+  char Bg0; char Bg1; char Bg2; char Bg3; char Bg4; char Bg5; char Bg6; char Bg7; char Bg8; char Bg9;\n+  char Bh0; char Bh1; char Bh2; char Bh3; char Bh4; char Bh5; char Bh6; char Bh7; char Bh8; char Bh9;\n+  char Bi0; char Bi1; char Bi2; char Bi3; char Bi4; char Bi5; char Bi6; char Bi7; char Bi8; char Bi9;\n+  char Bj0; char Bj1; char Bj2; char Bj3; char Bj4; char Bj5; char Bj6; char Bj7; char Bj8; char Bj9;\n+  char Bk0; char Bk1; char Bk2; char Bk3; char Bk4; char Bk5; char Bk6; char Bk7; char Bk8; char Bk9;\n+  char Bl0; char Bl1; char Bl2; char Bl3; char Bl4; char Bl5; char Bl6; char Bl7; char Bl8; char Bl9;\n+  char Bm0; char Bm1; char Bm2; char Bm3; char Bm4; char Bm5; char Bm6; char Bm7; char Bm8; char Bm9;\n+  char Bn0; char Bn1; char Bn2; char Bn3; char Bn4; char Bn5; char Bn6; char Bn7; char Bn8; char Bn9;\n+  char Bo0; char Bo1; char Bo2; char Bo3; char Bo4; char Bo5; char Bo6; char Bo7; char Bo8; char Bo9;\n+  char Bp0; char Bp1; char Bp2; char Bp3; char Bp4; char Bp5; char Bp6; char Bp7; char Bp8; char Bp9;\n+  char Bq0; char Bq1; char Bq2; char Bq3; char Bq4; char Bq5; char Bq6; char Bq7; char Bq8; char Bq9;\n+  char Br0; char Br1; char Br2; char Br3; char Br4; char Br5; char Br6; char Br7; char Br8; char Br9;\n+  char Bs0; char Bs1; char Bs2; char Bs3; char Bs4; char Bs5; char Bs6; char Bs7; char Bs8; char Bs9;\n+\n+  char y; /* { dg-message \"conflicts\" } */\n+  char y;\n+\n+  char z; /* { dg-error \"duplicate instance variable\" } */\n+} /* { dg-error \"declaration\" } */\n+@end\n+\n+@interface C : A\n+{\n+  char w; /* { dg-message \"previous declaration\" } */\n+}\n+@end\n+\n+@interface D : C\n+{\n+  /* That's another 200 instance variables, which should be enough to\n+     trigger the hashtable check in the compiler.  */\n+  char Da0; char Da1; char Da2; char Da3; char Da4; char Da5; char Da6; char Da7; char Da8; char Da9;\n+  char Db0; char Db1; char Db2; char Db3; char Db4; char Db5; char Db6; char Db7; char Db8; char Db9;\n+  char Dc0; char Dc1; char Dc2; char Dc3; char Dc4; char Dc5; char Dc6; char Dc7; char Dc8; char Dc9;\n+  char Dd0; char Dd1; char Dd2; char Dd3; char Dd4; char Dd5; char Dd6; char Dd7; char Dd8; char Dd9;\n+  char De0; char De1; char De2; char De3; char De4; char De5; char De6; char De7; char De8; char De9;\n+  char Df0; char Df1; char Df2; char Df3; char Df4; char Df5; char Df6; char Df7; char Df8; char Df9;\n+  char Dg0; char Dg1; char Dg2; char Dg3; char Dg4; char Dg5; char Dg6; char Dg7; char Dg8; char Dg9;\n+  char Dh0; char Dh1; char Dh2; char Dh3; char Dh4; char Dh5; char Dh6; char Dh7; char Dh8; char Dh9;\n+  char Di0; char Di1; char Di2; char Di3; char Di4; char Di5; char Di6; char Di7; char Di8; char Di9;\n+  char Dj0; char Dj1; char Dj2; char Dj3; char Dj4; char Dj5; char Dj6; char Dj7; char Dj8; char Dj9;\n+  char Dk0; char Dk1; char Dk2; char Dk3; char Dk4; char Dk5; char Dk6; char Dk7; char Dk8; char Dk9;\n+  char Dl0; char Dl1; char Dl2; char Dl3; char Dl4; char Dl5; char Dl6; char Dl7; char Dl8; char Dl9;\n+  char Dm0; char Dm1; char Dm2; char Dm3; char Dm4; char Dm5; char Dm6; char Dm7; char Dm8; char Dm9;\n+  char Dn0; char Dn1; char Dn2; char Dn3; char Dn4; char Dn5; char Dn6; char Dn7; char Dn8; char Dn9;\n+  char Do0; char Do1; char Do2; char Do3; char Do4; char Do5; char Do6; char Do7; char Do8; char Do9;\n+  char Dp0; char Dp1; char Dp2; char Dp3; char Dp4; char Dp5; char Dp6; char Dp7; char Dp8; char Dp9;\n+  char Dq0; char Dq1; char Dq2; char Dq3; char Dq4; char Dq5; char Dq6; char Dq7; char Dq8; char Dq9;\n+  char Dr0; char Dr1; char Dr2; char Dr3; char Dr4; char Dr5; char Dr6; char Dr7; char Dr8; char Dr9;\n+  char Ds0; char Ds1; char Ds2; char Ds3; char Ds4; char Ds5; char Ds6; char Ds7; char Ds8; char Ds9;\n+\n+  char y; /* { dg-message \"conflicts\" } */\n+  char y;\n+\n+  char w; /* { dg-error \"duplicate instance variable\" } */\n+  char k; /* { dg-error \"duplicate instance variable\" } */\n+}  /* { dg-error \"declaration\" } */\n+@end\n+\n+/* Finally, make sure that anonymous instance variables don't trigger\n+   warnings.  This is the same as the anon-1.m testcase, but forcing\n+   the hashtable check.  */\n+@interface E : D\n+{\n+  char : 1;\n+  char : 2;\n+}\n+@end\n+\n+@interface F : E\n+{\n+  /* That's another 200 instance variables, which should be enough to\n+     trigger the hashtable check in the compiler.  */\n+  char Fa0; char Fa1; char Fa2; char Fa3; char Fa4; char Fa5; char Fa6; char Fa7; char Fa8; char Fa9;\n+  char Fb0; char Fb1; char Fb2; char Fb3; char Fb4; char Fb5; char Fb6; char Fb7; char Fb8; char Fb9;\n+  char Fc0; char Fc1; char Fc2; char Fc3; char Fc4; char Fc5; char Fc6; char Fc7; char Fc8; char Fc9;\n+  char Fd0; char Fd1; char Fd2; char Fd3; char Fd4; char Fd5; char Fd6; char Fd7; char Fd8; char Fd9;\n+  char Fe0; char Fe1; char Fe2; char Fe3; char Fe4; char Fe5; char Fe6; char Fe7; char Fe8; char Fe9;\n+  char Ff0; char Ff1; char Ff2; char Ff3; char Ff4; char Ff5; char Ff6; char Ff7; char Ff8; char Ff9;\n+  char Fg0; char Fg1; char Fg2; char Fg3; char Fg4; char Fg5; char Fg6; char Fg7; char Fg8; char Fg9;\n+  char Fh0; char Fh1; char Fh2; char Fh3; char Fh4; char Fh5; char Fh6; char Fh7; char Fh8; char Fh9;\n+  char Fi0; char Fi1; char Fi2; char Fi3; char Fi4; char Fi5; char Fi6; char Fi7; char Fi8; char Fi9;\n+  char Fj0; char Fj1; char Fj2; char Fj3; char Fj4; char Fj5; char Fj6; char Fj7; char Fj8; char Fj9;\n+  char Fk0; char Fk1; char Fk2; char Fk3; char Fk4; char Fk5; char Fk6; char Fk7; char Fk8; char Fk9;\n+  char Fl0; char Fl1; char Fl2; char Fl3; char Fl4; char Fl5; char Fl6; char Fl7; char Fl8; char Fl9;\n+  char Fm0; char Fm1; char Fm2; char Fm3; char Fm4; char Fm5; char Fm6; char Fm7; char Fm8; char Fm9;\n+  char Fn0; char Fn1; char Fn2; char Fn3; char Fn4; char Fn5; char Fn6; char Fn7; char Fn8; char Fn9;\n+  char Fo0; char Fo1; char Fo2; char Fo3; char Fo4; char Fo5; char Fo6; char Fo7; char Fo8; char Fo9;\n+  char Fp0; char Fp1; char Fp2; char Fp3; char Fp4; char Fp5; char Fp6; char Fp7; char Fp8; char Fp9;\n+  char Fq0; char Fq1; char Fq2; char Fq3; char Fq4; char Fq5; char Fq6; char Fq7; char Fq8; char Fq9;\n+  char Fr0; char Fr1; char Fr2; char Fr3; char Fr4; char Fr5; char Fr6; char Fr7; char Fr8; char Fr9;\n+  char Fs0; char Fs1; char Fs2; char Fs3; char Fs4; char Fs5; char Fs6; char Fs7; char Fs8; char Fs9;  \n+\n+  char : 1;\n+  char : 2;\n+}\n+@end"}, {"sha": "6114f6ae6eb6dd83a29b3d7d89709028f706a6ca", "filename": "gcc/testsuite/objc.dg/naming-4.m", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-4.m?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -5,14 +5,17 @@\n \n @interface A \n {\n-    NSDictionary * _userInfo;\n+    NSDictionary * _userInfo1; /* { dg-message \"previous declaration\" } */\n+    NSDictionary * _userInfo2; /* { dg-message \"previous declaration\" } */\n+    NSDictionary * _userInfo3; /* { dg-message \"previous declaration\" } */\n+    NSDictionary * _userInfo4; /* { dg-message \"previous declaration\" } */\n }\n @end\n \n @interface B : A\n {\n-    NSDictionary * _userInfo;\t/* { dg-error \"duplicate member\" } */\n-    NSDictionary * _userInfo;\t/* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo1;\t/* { dg-error \"duplicate instance variable\" } */\n+    NSDictionary * _userInfo2;\t/* { dg-error \"duplicate instance variable\" } */\n }\n @end\n \n@@ -21,7 +24,7 @@ @interface C : A\n \n @interface D : C\n {\n-    NSDictionary * _userInfo;   /* { dg-error \"duplicate member\" } */\n-    NSDictionary * _userInfo;   /* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo3;  /* { dg-error \"duplicate instance variable\" } */\n+    NSDictionary * _userInfo4;  /* { dg-error \"duplicate instance variable\" } */\n }\n @end"}, {"sha": "7d6805f9329147ebd49eb9684d4f2051ed78ec88", "filename": "gcc/testsuite/objc.dg/naming-5.m", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-5.m?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -5,7 +5,7 @@\n \n @interface A \n {\n-    NSDictionary * _userInfo;\n+    NSDictionary * _userInfo; /* { dg-message \"previous declaration\" } */\n     int i1;\n     int i2;\n     int i3;\n@@ -18,15 +18,15 @@ @interface A\n \n @interface B : A\n {\n-    NSDictionary * _userInfo;\t/* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo1; /* { dg-message \"previous declaration\" } */\n     int ii1;\n     int ii2;\n     int ii3;\n     int ii4;\n     int ii5;\n     int ii6;\n     int ii7;\n-    NSDictionary * _userInfo;\t/* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo1; /* { dg-error \"duplicate instance variable\" } */\n }\n @end\n \n@@ -35,8 +35,7 @@ @interface C : A\n \n @interface D : C\n {\n-    NSDictionary * _userInfo;   /* { dg-error \"duplicate member\" } */\n-    NSDictionary * _userInfo;   /* { dg-error \"duplicate member\" } */\n+    NSDictionary * _userInfo;   /* { dg-error \"duplicate instance variable\" } */\n }\t\n @end\n "}, {"sha": "86e58e087b4f7ce0bc1f103fd40687d4dd5fa43f", "filename": "gcc/testsuite/objc.dg/naming-6.m", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-6.m?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -0,0 +1,20 @@\n+/* Testing for detecting duplicate ivars. */\n+/* { dg-do compile } */\n+\n+@interface A \n+{\n+  /* TODO: Have the testsuite check that these messages occur only once!  */\n+  char x; /* { dg-message \"previous declaration\" } */\n+  char x; /* { dg-error \"duplicate instance variable\" } */\n+}\n+@end\n+\n+/* In some versions of the compiler (eg, 4.6.x), having a subclass\n+   would generate additional, duplicate errors for the duplicate\n+   instance variable in the superclass, so adding the following would\n+   cause the error messages above to be duplicated.  */\n+@interface B : A\n+{\n+  char y;\n+}\n+@end"}, {"sha": "aa703176db02f17b31fd7b37c9f8e1c22ea3f136", "filename": "gcc/testsuite/objc.dg/naming-7.m", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-7.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-7.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fnaming-7.m?ref=0dc33c3c14650fa55f60b08fdfe4aaeba5c0c9bc", "patch": "@@ -0,0 +1,145 @@\n+/* Testing for detecting duplicate ivars. */\n+/* { dg-do compile } */\n+\n+/* This check wants to force the compiler to use a hashtable.  To do\n+   so, we need lots of instance variable.  */\n+\n+@interface A \n+{\n+  /* That's 200 instance variables, which is enough to trigger the\n+     hashtable check in the compiler.  */\n+  char a0; char a1; char a2; char a3; char a4; char a5; char a6; char a7; char a8; char a9;\n+  char b0; char b1; char b2; char b3; char b4; char b5; char b6; char b7; char b8; char b9;\n+  char c0; char c1; char c2; char c3; char c4; char c5; char c6; char c7; char c8; char c9;\n+  char d0; char d1; char d2; char d3; char d4; char d5; char d6; char d7; char d8; char d9;\n+  char e0; char e1; char e2; char e3; char e4; char e5; char e6; char e7; char e8; char e9;\n+  char f0; char f1; char f2; char f3; char f4; char f5; char f6; char f7; char f8; char f9;\n+  char g0; char g1; char g2; char g3; char g4; char g5; char g6; char g7; char g8; char g9;\n+  char h0; char h1; char h2; char h3; char h4; char h5; char h6; char h7; char h8; char h9;\n+  char i0; char i1; char i2; char i3; char i4; char i5; char i6; char i7; char i8; char i9;\n+  char j0; char j1; char j2; char j3; char j4; char j5; char j6; char j7; char j8; char j9;\n+  char k0; char k1; char k2; char k3; char k4; char k5; char k6; char k7; char k8; char k9;\n+  char l0; char l1; char l2; char l3; char l4; char l5; char l6; char l7; char l8; char l9;\n+  char m0; char m1; char m2; char m3; char m4; char m5; char m6; char m7; char m8; char m9;\n+  char n0; char n1; char n2; char n3; char n4; char n5; char n6; char n7; char n8; char n9;\n+  char o0; char o1; char o2; char o3; char o4; char o5; char o6; char o7; char o8; char o9;\n+  char p0; char p1; char p2; char p3; char p4; char p5; char p6; char p7; char p8; char p9;\n+  char q0; char q1; char q2; char q3; char q4; char q5; char q6; char q7; char q8; char q9;\n+  char r0; char r1; char r2; char r3; char r4; char r5; char r6; char r7; char r8; char r9;\n+  char s0; char s1; char s2; char s3; char s4; char s5; char s6; char s7; char s8; char s9;\n+\n+  char x; /* { dg-message \"previous declaration\" } */\n+  char x; /* { dg-error \"duplicate instance variable\" } */\n+\n+  char z; /* { dg-message \"previous declaration\" } */\n+  char k; /* { dg-message \"previous declaration\" } */\n+}\n+@end\n+\n+@interface B : A\n+{\n+  /* That's another 200 instance variables, which should be enough to\n+     trigger the hashtable check in the compiler.  */\n+  char Ba0; char Ba1; char Ba2; char Ba3; char Ba4; char Ba5; char Ba6; char Ba7; char Ba8; char Ba9;\n+  char Bb0; char Bb1; char Bb2; char Bb3; char Bb4; char Bb5; char Bb6; char Bb7; char Bb8; char Bb9;\n+  char Bc0; char Bc1; char Bc2; char Bc3; char Bc4; char Bc5; char Bc6; char Bc7; char Bc8; char Bc9;\n+  char Bd0; char Bd1; char Bd2; char Bd3; char Bd4; char Bd5; char Bd6; char Bd7; char Bd8; char Bd9;\n+  char Be0; char Be1; char Be2; char Be3; char Be4; char Be5; char Be6; char Be7; char Be8; char Be9;\n+  char Bf0; char Bf1; char Bf2; char Bf3; char Bf4; char Bf5; char Bf6; char Bf7; char Bf8; char Bf9;\n+  char Bg0; char Bg1; char Bg2; char Bg3; char Bg4; char Bg5; char Bg6; char Bg7; char Bg8; char Bg9;\n+  char Bh0; char Bh1; char Bh2; char Bh3; char Bh4; char Bh5; char Bh6; char Bh7; char Bh8; char Bh9;\n+  char Bi0; char Bi1; char Bi2; char Bi3; char Bi4; char Bi5; char Bi6; char Bi7; char Bi8; char Bi9;\n+  char Bj0; char Bj1; char Bj2; char Bj3; char Bj4; char Bj5; char Bj6; char Bj7; char Bj8; char Bj9;\n+  char Bk0; char Bk1; char Bk2; char Bk3; char Bk4; char Bk5; char Bk6; char Bk7; char Bk8; char Bk9;\n+  char Bl0; char Bl1; char Bl2; char Bl3; char Bl4; char Bl5; char Bl6; char Bl7; char Bl8; char Bl9;\n+  char Bm0; char Bm1; char Bm2; char Bm3; char Bm4; char Bm5; char Bm6; char Bm7; char Bm8; char Bm9;\n+  char Bn0; char Bn1; char Bn2; char Bn3; char Bn4; char Bn5; char Bn6; char Bn7; char Bn8; char Bn9;\n+  char Bo0; char Bo1; char Bo2; char Bo3; char Bo4; char Bo5; char Bo6; char Bo7; char Bo8; char Bo9;\n+  char Bp0; char Bp1; char Bp2; char Bp3; char Bp4; char Bp5; char Bp6; char Bp7; char Bp8; char Bp9;\n+  char Bq0; char Bq1; char Bq2; char Bq3; char Bq4; char Bq5; char Bq6; char Bq7; char Bq8; char Bq9;\n+  char Br0; char Br1; char Br2; char Br3; char Br4; char Br5; char Br6; char Br7; char Br8; char Br9;\n+  char Bs0; char Bs1; char Bs2; char Bs3; char Bs4; char Bs5; char Bs6; char Bs7; char Bs8; char Bs9;\n+\n+  char y; /* { dg-message \"previous declaration\" } */\n+  char y; /* { dg-error \"duplicate instance variable\" } */\n+\n+  char z; /* { dg-error \"duplicate instance variable\" } */\n+}\n+@end\n+\n+@interface C : A\n+{\n+  char w; /* { dg-message \"previous declaration\" } */\n+}\n+@end\n+\n+@interface D : C\n+{\n+  /* That's another 200 instance variables, which should be enough to\n+     trigger the hashtable check in the compiler.  */\n+  char Da0; char Da1; char Da2; char Da3; char Da4; char Da5; char Da6; char Da7; char Da8; char Da9;\n+  char Db0; char Db1; char Db2; char Db3; char Db4; char Db5; char Db6; char Db7; char Db8; char Db9;\n+  char Dc0; char Dc1; char Dc2; char Dc3; char Dc4; char Dc5; char Dc6; char Dc7; char Dc8; char Dc9;\n+  char Dd0; char Dd1; char Dd2; char Dd3; char Dd4; char Dd5; char Dd6; char Dd7; char Dd8; char Dd9;\n+  char De0; char De1; char De2; char De3; char De4; char De5; char De6; char De7; char De8; char De9;\n+  char Df0; char Df1; char Df2; char Df3; char Df4; char Df5; char Df6; char Df7; char Df8; char Df9;\n+  char Dg0; char Dg1; char Dg2; char Dg3; char Dg4; char Dg5; char Dg6; char Dg7; char Dg8; char Dg9;\n+  char Dh0; char Dh1; char Dh2; char Dh3; char Dh4; char Dh5; char Dh6; char Dh7; char Dh8; char Dh9;\n+  char Di0; char Di1; char Di2; char Di3; char Di4; char Di5; char Di6; char Di7; char Di8; char Di9;\n+  char Dj0; char Dj1; char Dj2; char Dj3; char Dj4; char Dj5; char Dj6; char Dj7; char Dj8; char Dj9;\n+  char Dk0; char Dk1; char Dk2; char Dk3; char Dk4; char Dk5; char Dk6; char Dk7; char Dk8; char Dk9;\n+  char Dl0; char Dl1; char Dl2; char Dl3; char Dl4; char Dl5; char Dl6; char Dl7; char Dl8; char Dl9;\n+  char Dm0; char Dm1; char Dm2; char Dm3; char Dm4; char Dm5; char Dm6; char Dm7; char Dm8; char Dm9;\n+  char Dn0; char Dn1; char Dn2; char Dn3; char Dn4; char Dn5; char Dn6; char Dn7; char Dn8; char Dn9;\n+  char Do0; char Do1; char Do2; char Do3; char Do4; char Do5; char Do6; char Do7; char Do8; char Do9;\n+  char Dp0; char Dp1; char Dp2; char Dp3; char Dp4; char Dp5; char Dp6; char Dp7; char Dp8; char Dp9;\n+  char Dq0; char Dq1; char Dq2; char Dq3; char Dq4; char Dq5; char Dq6; char Dq7; char Dq8; char Dq9;\n+  char Dr0; char Dr1; char Dr2; char Dr3; char Dr4; char Dr5; char Dr6; char Dr7; char Dr8; char Dr9;\n+  char Ds0; char Ds1; char Ds2; char Ds3; char Ds4; char Ds5; char Ds6; char Ds7; char Ds8; char Ds9;\n+\n+  char y; /* { dg-message \"previous declaration\" } */\n+  char y; /* { dg-error \"duplicate instance variable\" } */\n+\n+  char w; /* { dg-error \"duplicate instance variable\" } */\n+  char k; /* { dg-error \"duplicate instance variable\" } */\n+}\n+@end\n+\n+/* Finally, make sure that anonymous instance variables don't trigger\n+   warnings.  This is the same as the anon-1.m testcase, but forcing\n+   the hashtable check.  */\n+@interface E : D\n+{\n+  char : 1;\n+  char : 2;\n+}\n+@end\n+\n+@interface F : E\n+{\n+  /* That's another 200 instance variables, which should be enough to\n+     trigger the hashtable check in the compiler.  */\n+  char Fa0; char Fa1; char Fa2; char Fa3; char Fa4; char Fa5; char Fa6; char Fa7; char Fa8; char Fa9;\n+  char Fb0; char Fb1; char Fb2; char Fb3; char Fb4; char Fb5; char Fb6; char Fb7; char Fb8; char Fb9;\n+  char Fc0; char Fc1; char Fc2; char Fc3; char Fc4; char Fc5; char Fc6; char Fc7; char Fc8; char Fc9;\n+  char Fd0; char Fd1; char Fd2; char Fd3; char Fd4; char Fd5; char Fd6; char Fd7; char Fd8; char Fd9;\n+  char Fe0; char Fe1; char Fe2; char Fe3; char Fe4; char Fe5; char Fe6; char Fe7; char Fe8; char Fe9;\n+  char Ff0; char Ff1; char Ff2; char Ff3; char Ff4; char Ff5; char Ff6; char Ff7; char Ff8; char Ff9;\n+  char Fg0; char Fg1; char Fg2; char Fg3; char Fg4; char Fg5; char Fg6; char Fg7; char Fg8; char Fg9;\n+  char Fh0; char Fh1; char Fh2; char Fh3; char Fh4; char Fh5; char Fh6; char Fh7; char Fh8; char Fh9;\n+  char Fi0; char Fi1; char Fi2; char Fi3; char Fi4; char Fi5; char Fi6; char Fi7; char Fi8; char Fi9;\n+  char Fj0; char Fj1; char Fj2; char Fj3; char Fj4; char Fj5; char Fj6; char Fj7; char Fj8; char Fj9;\n+  char Fk0; char Fk1; char Fk2; char Fk3; char Fk4; char Fk5; char Fk6; char Fk7; char Fk8; char Fk9;\n+  char Fl0; char Fl1; char Fl2; char Fl3; char Fl4; char Fl5; char Fl6; char Fl7; char Fl8; char Fl9;\n+  char Fm0; char Fm1; char Fm2; char Fm3; char Fm4; char Fm5; char Fm6; char Fm7; char Fm8; char Fm9;\n+  char Fn0; char Fn1; char Fn2; char Fn3; char Fn4; char Fn5; char Fn6; char Fn7; char Fn8; char Fn9;\n+  char Fo0; char Fo1; char Fo2; char Fo3; char Fo4; char Fo5; char Fo6; char Fo7; char Fo8; char Fo9;\n+  char Fp0; char Fp1; char Fp2; char Fp3; char Fp4; char Fp5; char Fp6; char Fp7; char Fp8; char Fp9;\n+  char Fq0; char Fq1; char Fq2; char Fq3; char Fq4; char Fq5; char Fq6; char Fq7; char Fq8; char Fq9;\n+  char Fr0; char Fr1; char Fr2; char Fr3; char Fr4; char Fr5; char Fr6; char Fr7; char Fr8; char Fr9;\n+  char Fs0; char Fs1; char Fs2; char Fs3; char Fs4; char Fs5; char Fs6; char Fs7; char Fs8; char Fs9;  \n+\n+  char : 1;\n+  char : 2;\n+}\n+@end"}]}