{"sha": "8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQzYzA3NmYzZGRjMTFkZjQxOGFmM2FjNTRkMjhhNGEyZDE5ZWYzYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-04-15T16:04:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-04-15T16:04:11Z"}, "message": "re PR rtl-optimization/56965 (nonoverlapping_component_refs_p is bogus and slow)\n\n2014-04-15  Richard Biener  <rguenther@suse.de>\n\n\tPR rtl-optimization/56965\n\t* alias.c (ncr_compar, nonoverlapping_component_refs_p): Move ...\n\t* tree-ssa-alias.c (ncr_compar, nonoverlapping_component_refs_p):\n\t... here.\n\t* alias.c (true_dependence_1): Do not call\n\tnonoverlapping_component_refs_p.\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Call\n\tnonoverlapping_component_refs_p.\n\t(indirect_refs_may_alias_p): Likewise.\n\n\t* gcc.dg/torture/pr56965-1.c: New testcase.\n\t* gcc.dg/torture/pr56965-2.c: Likewise.\n\nFrom-SVN: r209423", "tree": {"sha": "ac84e759ec57e0db2ae1879fdf728930ca885649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac84e759ec57e0db2ae1879fdf728930ca885649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4803acceb2e0e70449ad1b251466a4625f702299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4803acceb2e0e70449ad1b251466a4625f702299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4803acceb2e0e70449ad1b251466a4625f702299"}], "stats": {"total": 344, "additions": 217, "deletions": 127}, "files": [{"sha": "de72b92c556e6833c39947292049b7bdcad9567b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "patch": "@@ -1,3 +1,15 @@\n+2014-04-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/56965\n+\t* alias.c (ncr_compar, nonoverlapping_component_refs_p): Move ...\n+\t* tree-ssa-alias.c (ncr_compar, nonoverlapping_component_refs_p):\n+\t... here.\n+\t* alias.c (true_dependence_1): Do not call\n+\tnonoverlapping_component_refs_p.\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Call\n+\tnonoverlapping_component_refs_p.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\n 2014-04-15  Teresa Johnson  <tejohnson@google.com>\n \n \t* cfg.c (dump_bb_info): Fix flags check."}, {"sha": "5f37402919340cf2281219fa3adefe819637b1b8", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "patch": "@@ -157,7 +157,6 @@ static rtx find_base_value (rtx);\n static int mems_in_disjoint_alias_sets_p (const_rtx, const_rtx);\n static int insert_subset_children (splay_tree_node, void*);\n static alias_set_entry get_alias_set_entry (alias_set_type);\n-static bool nonoverlapping_component_refs_p (const_rtx, const_rtx);\n static tree decl_for_component_ref (tree);\n static int write_dependence_p (const_rtx,\n \t\t\t       const_rtx, enum machine_mode, rtx,\n@@ -2248,126 +2247,6 @@ read_dependence (const_rtx mem, const_rtx x)\n   return false;\n }\n \n-/* qsort compare function to sort FIELD_DECLs after their\n-   DECL_FIELD_CONTEXT TYPE_UID.  */\n-\n-static inline int\n-ncr_compar (const void *field1_, const void *field2_)\n-{\n-  const_tree field1 = *(const_tree *) const_cast <void *>(field1_);\n-  const_tree field2 = *(const_tree *) const_cast <void *>(field2_);\n-  unsigned int uid1\n-    = TYPE_UID (TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field1)));\n-  unsigned int uid2\n-    = TYPE_UID (TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field2)));\n-  if (uid1 < uid2)\n-    return -1;\n-  else if (uid1 > uid2)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Return true if we can determine that the fields referenced cannot\n-   overlap for any pair of objects.  */\n-\n-static bool\n-nonoverlapping_component_refs_p (const_rtx rtlx, const_rtx rtly)\n-{\n-  const_tree x = MEM_EXPR (rtlx), y = MEM_EXPR (rtly);\n-\n-  if (!flag_strict_aliasing\n-      || !x || !y\n-      || TREE_CODE (x) != COMPONENT_REF\n-      || TREE_CODE (y) != COMPONENT_REF)\n-    return false;\n-\n-  auto_vec<const_tree, 16> fieldsx;\n-  while (TREE_CODE (x) == COMPONENT_REF)\n-    {\n-      tree field = TREE_OPERAND (x, 1);\n-      tree type = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field));\n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\tfieldsx.safe_push (field);\n-      x = TREE_OPERAND (x, 0);\n-    }\n-  if (fieldsx.length () == 0)\n-    return false;\n-  auto_vec<const_tree, 16> fieldsy;\n-  while (TREE_CODE (y) == COMPONENT_REF)\n-    {\n-      tree field = TREE_OPERAND (y, 1);\n-      tree type = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field));\n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\tfieldsy.safe_push (TREE_OPERAND (y, 1));\n-      y = TREE_OPERAND (y, 0);\n-    }\n-  if (fieldsy.length () == 0)\n-    return false;\n-\n-  /* Most common case first.  */\n-  if (fieldsx.length () == 1\n-      && fieldsy.length () == 1)\n-    return ((TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldsx[0]))\n-\t     == TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldsy[0])))\n-\t    && fieldsx[0] != fieldsy[0]\n-\t    && !(DECL_BIT_FIELD (fieldsx[0]) && DECL_BIT_FIELD (fieldsy[0])));\n-\n-  if (fieldsx.length () == 2)\n-    {\n-      if (ncr_compar (&fieldsx[0], &fieldsx[1]) == 1)\n-\t{\n-\t  const_tree tem = fieldsx[0];\n-\t  fieldsx[0] = fieldsx[1];\n-\t  fieldsx[1] = tem;\n-\t}\n-    }\n-  else\n-    fieldsx.qsort (ncr_compar);\n-\n-  if (fieldsy.length () == 2)\n-    {\n-      if (ncr_compar (&fieldsy[0], &fieldsy[1]) == 1)\n-\t{\n-\t  const_tree tem = fieldsy[0];\n-\t  fieldsy[0] = fieldsy[1];\n-\t  fieldsy[1] = tem;\n-\t}\n-    }\n-  else\n-    fieldsy.qsort (ncr_compar);\n-\n-  unsigned i = 0, j = 0;\n-  do\n-    {\n-      const_tree fieldx = fieldsx[i];\n-      const_tree fieldy = fieldsy[j];\n-      tree typex = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldx));\n-      tree typey = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldy));\n-      if (typex == typey)\n-\t{\n-\t  /* We're left with accessing different fields of a structure,\n-\t     no possible overlap, unless they are both bitfields.  */\n-\t  if (fieldx != fieldy)\n-\t    return !(DECL_BIT_FIELD (fieldx) && DECL_BIT_FIELD (fieldy));\n-\t}\n-      if (TYPE_UID (typex) < TYPE_UID (typey))\n-\t{\n-\t  i++;\n-\t  if (i == fieldsx.length ())\n-\t    break;\n-\t}\n-      else\n-\t{\n-\t  j++;\n-\t  if (j == fieldsy.length ())\n-\t    break;\n-\t}\n-    }\n-  while (1);\n-\n-  return false;\n-}\n-\n /* Look at the bottom of the COMPONENT_REF list for a DECL, and return it.  */\n \n static tree\n@@ -2643,9 +2522,6 @@ true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (nonoverlapping_memrefs_p (mem, x, false))\n     return 0;\n \n-  if (nonoverlapping_component_refs_p (mem, x))\n-    return 0;\n-\n   return rtx_refs_may_alias_p (x, mem, true);\n }\n "}, {"sha": "78c21b4e914dd74873c85579fef9f76a4eac769d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "patch": "@@ -1,3 +1,9 @@\n+2014-04-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/56965\n+\t* gcc.dg/torture/pr56965-1.c: New testcase.\n+\t* gcc.dg/torture/pr56965-2.c: Likewise.\n+\n 2014-04-15  Teresa Johnson  <tejohnson@google.com>\n \n \t* gcc.dg/tree-prof/update-loopch.c: Update expected output."}, {"sha": "2512db3965dd44ab95a5b082eafc0fde30dbbc7d", "filename": "gcc/testsuite/gcc.dg/torture/pr56965-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56965-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56965-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56965-1.c?ref=8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fschedule-insns\" { target scheduling } } */\n+\n+extern void abort (void);\n+\n+struct S {\n+    int i;\n+    int j;\n+};\n+\n+struct U {\n+    struct S s;\n+} __attribute__((may_alias));\n+\n+int __attribute__((noinline,noclone))\n+foo (struct U *p, struct U *q)\n+{\n+  int i;\n+  q->s.j = 1;\n+  i = p->s.i;\n+  return i;\n+}\n+\n+int main()\n+{\n+  int a[3];\n+  int *p = a;\n+  p[1] = 0;\n+  if (foo ((struct U *)(p + 1), (struct U *)p) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "04f55914e9c67420d5df570034e270f24a83032c", "filename": "gcc/testsuite/gcc.dg/torture/pr56965-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56965-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56965-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr56965-2.c?ref=8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "patch": "@@ -0,0 +1,34 @@\n+extern void abort (void);\n+\n+struct S { int i; int j; };\n+struct X { struct S s; int k; };\n+struct Y { int k; struct S s; };\n+union U { struct X x; struct Y y; } __attribute__((may_alias));\n+\n+int __attribute__((noinline))\n+foo (union U *p, union U *q)\n+{\n+  p->x.s.j = 1;\n+  q->y.s.i = 0;\n+  return p->x.s.j;\n+}\n+\n+struct R { int i; int j; } __attribute__((may_alias));\n+\n+int __attribute__((noinline))\n+bar (struct R *p, struct R *q)\n+{\n+  p->i = 1;\n+  q->j = 0;\n+  return p->i;\n+}\n+\n+int main()\n+{\n+  int a[3];\n+  if (foo ((union U *)&a[0], (union U *)&a[0]) != 0)\n+    abort ();\n+  if (bar ((struct R *)&a[1], (struct R *)&a[0]) != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "2c57a17f53e64e14a1b4e3367243a9177399508c", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 133, "deletions": 3, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8d3c076f3ddc11df418af3ac54d28a4a2d19ef3b", "patch": "@@ -858,6 +858,125 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n   return false;\n }\n \n+/* qsort compare function to sort FIELD_DECLs after their\n+   DECL_FIELD_CONTEXT TYPE_UID.  */\n+\n+static inline int\n+ncr_compar (const void *field1_, const void *field2_)\n+{\n+  const_tree field1 = *(const_tree *) const_cast <void *>(field1_);\n+  const_tree field2 = *(const_tree *) const_cast <void *>(field2_);\n+  unsigned int uid1\n+    = TYPE_UID (TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field1)));\n+  unsigned int uid2\n+    = TYPE_UID (TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field2)));\n+  if (uid1 < uid2)\n+    return -1;\n+  else if (uid1 > uid2)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return true if we can determine that the fields referenced cannot\n+   overlap for any pair of objects.  */\n+\n+static bool\n+nonoverlapping_component_refs_p (const_tree x, const_tree y)\n+{\n+  if (!flag_strict_aliasing\n+      || !x || !y\n+      || TREE_CODE (x) != COMPONENT_REF\n+      || TREE_CODE (y) != COMPONENT_REF)\n+    return false;\n+\n+  auto_vec<const_tree, 16> fieldsx;\n+  while (TREE_CODE (x) == COMPONENT_REF)\n+    {\n+      tree field = TREE_OPERAND (x, 1);\n+      tree type = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field));\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\tfieldsx.safe_push (field);\n+      x = TREE_OPERAND (x, 0);\n+    }\n+  if (fieldsx.length () == 0)\n+    return false;\n+  auto_vec<const_tree, 16> fieldsy;\n+  while (TREE_CODE (y) == COMPONENT_REF)\n+    {\n+      tree field = TREE_OPERAND (y, 1);\n+      tree type = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (field));\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\tfieldsy.safe_push (TREE_OPERAND (y, 1));\n+      y = TREE_OPERAND (y, 0);\n+    }\n+  if (fieldsy.length () == 0)\n+    return false;\n+\n+  /* Most common case first.  */\n+  if (fieldsx.length () == 1\n+      && fieldsy.length () == 1)\n+    return ((TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldsx[0]))\n+\t     == TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldsy[0])))\n+\t    && fieldsx[0] != fieldsy[0]\n+\t    && !(DECL_BIT_FIELD (fieldsx[0]) && DECL_BIT_FIELD (fieldsy[0])));\n+\n+  if (fieldsx.length () == 2)\n+    {\n+      if (ncr_compar (&fieldsx[0], &fieldsx[1]) == 1)\n+\t{\n+\t  const_tree tem = fieldsx[0];\n+\t  fieldsx[0] = fieldsx[1];\n+\t  fieldsx[1] = tem;\n+\t}\n+    }\n+  else\n+    fieldsx.qsort (ncr_compar);\n+\n+  if (fieldsy.length () == 2)\n+    {\n+      if (ncr_compar (&fieldsy[0], &fieldsy[1]) == 1)\n+\t{\n+\t  const_tree tem = fieldsy[0];\n+\t  fieldsy[0] = fieldsy[1];\n+\t  fieldsy[1] = tem;\n+\t}\n+    }\n+  else\n+    fieldsy.qsort (ncr_compar);\n+\n+  unsigned i = 0, j = 0;\n+  do\n+    {\n+      const_tree fieldx = fieldsx[i];\n+      const_tree fieldy = fieldsy[j];\n+      tree typex = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldx));\n+      tree typey = TYPE_MAIN_VARIANT (DECL_FIELD_CONTEXT (fieldy));\n+      if (typex == typey)\n+\t{\n+\t  /* We're left with accessing different fields of a structure,\n+\t     no possible overlap, unless they are both bitfields.  */\n+\t  if (fieldx != fieldy)\n+\t    return !(DECL_BIT_FIELD (fieldx) && DECL_BIT_FIELD (fieldy));\n+\t}\n+      if (TYPE_UID (typex) < TYPE_UID (typey))\n+\t{\n+\t  i++;\n+\t  if (i == fieldsx.length ())\n+\t    break;\n+\t}\n+      else\n+\t{\n+\t  j++;\n+\t  if (j == fieldsy.length ())\n+\t    break;\n+\t}\n+    }\n+  while (1);\n+\n+  return false;\n+}\n+\n+\n /* Return true if two memory references based on the variables BASE1\n    and BASE2 constrained to [OFFSET1, OFFSET1 + MAX_SIZE1) and\n    [OFFSET2, OFFSET2 + MAX_SIZE2) may alias.  REF1 and REF2\n@@ -1023,6 +1142,10 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (dbase2)) == 1)\n     return ranges_overlap_p (doffset1, max_size1, doffset2, max_size2);\n \n+  if (ref1 && ref2\n+      && nonoverlapping_component_refs_p (ref1, ref2))\n+    return false;\n+\n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n       && (handled_component_p (ref1) || handled_component_p (ref2)))\n@@ -1144,11 +1267,18 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       && !alias_sets_conflict_p (base1_alias_set, base2_alias_set))\n     return false;\n \n+  /* If either reference is view-converted, give up now.  */\n+  if (same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) != 1\n+      || same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) != 1)\n+    return true;\n+\n+  if (ref1 && ref2\n+      && nonoverlapping_component_refs_p (ref1, ref2))\n+    return false;\n+\n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n-      && (handled_component_p (ref1) || handled_component_p (ref2))\n-      && same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1\n-      && same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) == 1)\n+      && (handled_component_p (ref1) || handled_component_p (ref2)))\n     return aliasing_component_refs_p (ref1,\n \t\t\t\t      ref1_alias_set, base1_alias_set,\n \t\t\t\t      offset1, max_size1,"}]}