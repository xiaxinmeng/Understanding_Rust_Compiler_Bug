{"sha": "176c9e6beb33949a252109a2efefbed9045f9c7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2YzllNmJlYjMzOTQ5YTI1MjEwOWEyZWZlZmJlZDkwNDVmOWM3Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-10-06T17:46:02Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-10-06T17:46:02Z"}, "message": "(try_combine): New variable i3_subst_into_i2.\n\nSet it for special case of substituting i3 into i2.  Use it near\nend to detect when special case succeeded.  Move i2notes to\ni3notes for this special case.\n(distribute_notes, REG_UNUSED case): Ignore all REG_UNUSED notes\nexcept those from I3.\n\nFrom-SVN: r5639", "tree": {"sha": "b25129e2ba4a7dd3e6c345a2a8a505589c0d8a10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b25129e2ba4a7dd3e6c345a2a8a505589c0d8a10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/176c9e6beb33949a252109a2efefbed9045f9c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176c9e6beb33949a252109a2efefbed9045f9c7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176c9e6beb33949a252109a2efefbed9045f9c7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176c9e6beb33949a252109a2efefbed9045f9c7b/comments", "author": null, "committer": null, "parents": [{"sha": "f8ece31752c9e0c8ac28afbdc0cffdf7a4d2ad03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ece31752c9e0c8ac28afbdc0cffdf7a4d2ad03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ece31752c9e0c8ac28afbdc0cffdf7a4d2ad03"}], "stats": {"total": 71, "additions": 54, "deletions": 17}, "files": [{"sha": "8f9efb86caacd1558be6b15071cc31c44140b0d8", "filename": "gcc/combine.c", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/176c9e6beb33949a252109a2efefbed9045f9c7b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/176c9e6beb33949a252109a2efefbed9045f9c7b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=176c9e6beb33949a252109a2efefbed9045f9c7b", "patch": "@@ -1152,6 +1152,8 @@ try_combine (i3, i2, i1)\n   int i1_feeds_i3 = 0;\n   /* Notes that must be added to REG_NOTES in I3 and I2.  */\n   rtx new_i3_notes, new_i2_notes;\n+  /* Notes that we substituted I3 into I2 instead of the normal case.  */\n+  int i3_subst_into_i2 = 0;\n \n   int maxreg;\n   rtx temp;\n@@ -1254,6 +1256,7 @@ try_combine (i3, i2, i1)\n \t\t     SET_DEST (PATTERN (i3)));\n \n \t      newpat = p2;\n+\t      i3_subst_into_i2 = 1;\n \t      goto validate_replacement;\n \t    }\n     }\n@@ -2040,22 +2043,39 @@ try_combine (i3, i2, i1)\n     /* We had one special case above where I2 had more than one set and\n        we replaced a destination of one of those sets with the destination\n        of I3.  In that case, we have to update LOG_LINKS of insns later\n-       in this basic block.  Note that this (expensive) case is rare.  */\n-\n-    if (GET_CODE (PATTERN (i2)) == PARALLEL)\n-      for (i = 0; i < XVECLEN (PATTERN (i2), 0); i++)\n-\tif (GET_CODE (SET_DEST (XVECEXP (PATTERN (i2), 0, i))) == REG\n-\t    && SET_DEST (XVECEXP (PATTERN (i2), 0, i)) != i2dest\n-\t    && ! find_reg_note (i2, REG_UNUSED,\n-\t\t\t\tSET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n-\t  for (temp = NEXT_INSN (i2);\n-\t       temp && (this_basic_block == n_basic_blocks - 1\n-\t\t\t|| basic_block_head[this_basic_block] != temp);\n-\t       temp = NEXT_INSN (temp))\n-\t    if (temp != i3 && GET_RTX_CLASS (GET_CODE (temp)) == 'i')\n-\t      for (link = LOG_LINKS (temp); link; link = XEXP (link, 1))\n-\t\tif (XEXP (link, 0) == i2)\n-\t\t  XEXP (link, 0) = i3;\n+       in this basic block.  Note that this (expensive) case is rare.\n+\n+       Also, in this case, we must pretend that all REG_NOTEs for I2\n+       actually came from I3, so that REG_UNUSED notes from I2 will be\n+       properly handled.  */\n+\n+    if (i3_subst_into_i2)\n+      {\n+\tfor (i = 0; i < XVECLEN (PATTERN (i2), 0); i++)\n+\t  if (GET_CODE (SET_DEST (XVECEXP (PATTERN (i2), 0, i))) == REG\n+\t      && SET_DEST (XVECEXP (PATTERN (i2), 0, i)) != i2dest\n+\t      && ! find_reg_note (i2, REG_UNUSED,\n+\t\t\t\t  SET_DEST (XVECEXP (PATTERN (i2), 0, i))))\n+\t    for (temp = NEXT_INSN (i2);\n+\t\t temp && (this_basic_block == n_basic_blocks - 1\n+\t\t\t  || basic_block_head[this_basic_block] != temp);\n+\t\t temp = NEXT_INSN (temp))\n+\t      if (temp != i3 && GET_RTX_CLASS (GET_CODE (temp)) == 'i')\n+\t\tfor (link = LOG_LINKS (temp); link; link = XEXP (link, 1))\n+\t\t  if (XEXP (link, 0) == i2)\n+\t\t    XEXP (link, 0) = i3;\n+\n+\tif (i3notes)\n+\t  {\n+\t    rtx link = i3notes;\n+\t    while (XEXP (link, 1))\n+\t      link = XEXP (link, 1);\n+\t    XEXP (link, 1) = i2notes;\n+\t  }\n+\telse\n+\t  i3notes = i2notes;\n+\ti2notes = 0;\n+      }\n \n     LOG_LINKS (i3) = 0;\n     REG_NOTES (i3) = 0;\n@@ -9857,9 +9877,26 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n       switch (REG_NOTE_KIND (note))\n \t{\n \tcase REG_UNUSED:\n+\t  /* If this note is from any insn other than i3, then we have no\n+\t     use for it, and must ignore it.\n+\n+\t     Any clobbers for i3 may still exist, and so we must process\n+\t     REG_UNUSED notes from that insn.\n+\n+\t     Any clobbers from i2 or i1 can only exist if they were added by\n+\t     recog_for_combine.  In that case, recog_for_combine created the\n+\t     necessary REG_UNUSED notes.  Trying to keep any original\n+\t     REG_UNUSED notes from these insns can cause incorrect output\n+\t     if it is for the same register as the original i3 dest.\n+\t     In that case, we will notice that the register is set in i3,\n+\t     and then add a REG_UNUSED note for the destination of i3, which\n+\t     is wrong.  */\n+\t  if (from_insn != i3)\n+\t    break;\n+\n \t  /* If this register is set or clobbered in I3, put the note there\n \t     unless there is one already.  */\n-\t  if (reg_set_p (XEXP (note, 0), PATTERN (i3)))\n+\t  else if (reg_set_p (XEXP (note, 0), PATTERN (i3)))\n \t    {\n \t      if (! (GET_CODE (XEXP (note, 0)) == REG\n \t\t     ? find_regno_note (i3, REG_UNUSED, REGNO (XEXP (note, 0)))"}]}