{"sha": "bdee76844adbb5159029f0572d0fe0228c7b7b38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlZTc2ODQ0YWRiYjUxNTkwMjlmMDU3MmQwZmUwMjI4YzdiN2IzOA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-07-02T18:47:29Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-07-02T18:47:29Z"}, "message": "tree-ssa-pre.c (bitmap_set_t): New.\n\n2004-07-02  Daniel Berlin  <dberlin@dberlin.org)\n\n\t* tree-ssa-pre.c (bitmap_set_t): New.\n\t(bb_value_sets): avail_out is now a bitmap_set_t.\n\t(bitmap_find_leader): New function.\n\t(bitmap_value_insert_into_set): Ditto.\n\t(bitmap_set_copy): Ditto.\n\t(bitmap_value_replace_in_set): Ditto.\n\t(bitmap_set_contains_value): Ditto.\n\t(bitmap_set_new): Ditto.\n\t(bitmap_set_pool): New pool.\n\t(find_or_generate_expression): Use bitmap_ functions on AVAIL sets.\n\t(insert_aux): Ditto.\n\t(add_to_sets): Ditto.\n\t(compute_avail): Ditto\n\t(eliminate): Ditto.\n\t(init_pre): Ditto.\n\t(fini_pre): Ditto.\n\t(execute_pre): Ditto.\n\nFrom-SVN: r84025", "tree": {"sha": "6bb17172d892d86e609d78837ce2bb4385baafc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bb17172d892d86e609d78837ce2bb4385baafc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdee76844adbb5159029f0572d0fe0228c7b7b38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdee76844adbb5159029f0572d0fe0228c7b7b38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdee76844adbb5159029f0572d0fe0228c7b7b38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdee76844adbb5159029f0572d0fe0228c7b7b38/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b897cfa9cb21e1576cfb46d2b18a6139a312cb0"}], "stats": {"total": 262, "additions": 211, "deletions": 51}, "files": [{"sha": "fe15ad002bf333d16e6d362e435a4728b74ca226", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdee76844adbb5159029f0572d0fe0228c7b7b38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdee76844adbb5159029f0572d0fe0228c7b7b38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdee76844adbb5159029f0572d0fe0228c7b7b38", "patch": "@@ -1,3 +1,23 @@\n+2004-07-02  Daniel Berlin  <dberlin@dberlin.org)\n+\n+\t* tree-ssa-pre.c (bitmap_set_t): New.\n+\t(bb_value_sets): avail_out is now a bitmap_set_t.\n+\t(bitmap_find_leader): New function.\n+\t(bitmap_value_insert_into_set): Ditto.\n+\t(bitmap_set_copy): Ditto.\n+\t(bitmap_value_replace_in_set): Ditto.\n+\t(bitmap_set_contains_value): Ditto.\n+\t(bitmap_set_new): Ditto.\n+\t(bitmap_set_pool): New pool.\n+\t(find_or_generate_expression): Use bitmap_ functions on AVAIL sets.\n+\t(insert_aux): Ditto.\n+\t(add_to_sets): Ditto.\n+\t(compute_avail): Ditto\n+\t(eliminate): Ditto.\n+\t(init_pre): Ditto.\n+\t(fini_pre): Ditto.\n+\t(execute_pre): Ditto.\n+\n 2004-07-02  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/rs6000/rs6000.c (struct processor_costs): New structure"}, {"sha": "30112ba8e42766261c717e080070f49766754232", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 191, "deletions": 51, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdee76844adbb5159029f0572d0fe0228c7b7b38/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdee76844adbb5159029f0572d0fe0228c7b7b38/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=bdee76844adbb5159029f0572d0fe0228c7b7b38", "patch": "@@ -47,19 +47,16 @@ Boston, MA 02111-1307, USA.  */\n \n /* TODO:\n    \n-   1. Implement load value numbering.\n-   2. Speed up insert_aux so that we can use it all the time.  It\n-      spends most of it's time in quadratic value replacement.\n-   3. Avail sets can be shared by making an avail_find_leader that\n+   1. Avail sets can be shared by making an avail_find_leader that\n       walks up the dominator tree and looks in those avail sets.\n       This might affect code optimality, it's unclear right now.\n-   4. Load motion can be performed by value numbering the loads the\n+   2. Load motion can be performed by value numbering the loads the\n       same as we do other expressions.  This requires iterative\n       hashing the vuses into the values.  Right now we simply assign\n       a new value every time we see a statement with a vuse.\n-   5. Strength reduction can be performed by anticipating expressions\n+   3. Strength reduction can be performed by anticipating expressions\n       we can repair later on.\n-   6. Our canonicalization of expressions during lookups don't take\n+   4. Our canonicalization of expressions during lookups don't take\n       constants into account very well.  In particular, we don't fold\n       anywhere, so we can get situations where we stupidly think\n       something is a new value (a + 1 + 1 vs a + 2).  This is somewhat\n@@ -166,7 +163,13 @@ Boston, MA 02111-1307, USA.  */\n \n /* Representation of sets:\n \n-   Sets are represented as doubly linked lists kept in topological\n+   There are currently two types of sets used, hopefully to be unified soon.\n+   The AVAIL sets do not need to be sorted in any particular order,\n+   and thus, are simply represented as two bitmaps, one that keeps\n+   track of values present in the set, and one that keeps track of\n+   expressions present in the set.\n+   \n+   The other sets are represented as doubly linked lists kept in topological\n    order, with an optional supporting bitmap of values present in the\n    set.  The sets represent values, and the elements can be values or\n    expressions.  The elements can appear in different sets, but each\n@@ -220,6 +223,15 @@ typedef struct value_set\n   \n } *value_set_t;\n \n+\n+/* An unordered bitmap set.  One bitmap tracks values, the other,\n+   expressions. */\n+typedef struct bitmap_set\n+{\n+  bitmap expressions;\n+  bitmap values;\n+} *bitmap_set_t;\n+\n /* All of the following sets, except for TMP_GEN, are indexed.\n    TMP_GEN is only ever iterated over, we never check what values\n    exist in it.  */\n@@ -240,7 +252,7 @@ typedef struct bb_value_sets\n \n   /* The AVAIL_OUT set, which represents which values are available in\n      a given basic block.  */\n-  value_set_t avail_out;\n+  bitmap_set_t avail_out;\n \n   /* The ANTIC_IN set, which represents which values are anticiptable\n      in a given basic block.  */\n@@ -273,22 +285,30 @@ static struct\n   int phis;\n } pre_stats;\n \n+\n+static tree bitmap_find_leader (bitmap_set_t, tree);\n static tree find_leader (value_set_t, tree);\n static void value_insert_into_set (value_set_t, tree);\n+static void bitmap_value_insert_into_set (bitmap_set_t, tree);\n+static void bitmap_value_replace_in_set (bitmap_set_t, tree);\n static void insert_into_set (value_set_t, tree);\n+static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);\n+static bool bitmap_set_contains_value (bitmap_set_t, tree);\n+static bitmap_set_t bitmap_set_new (void);\n static value_set_t set_new  (bool);\n static bool is_undefined_value (tree);\n static tree create_expression_by_pieces (basic_block, tree, tree);\n \n+\n /* We can add and remove elements and entries to and from sets\n    and hash tables, so we use alloc pools for them.  */\n \n static alloc_pool value_set_pool;\n+static alloc_pool bitmap_set_pool;\n static alloc_pool value_set_node_pool;\n static alloc_pool binary_node_pool;\n static alloc_pool unary_node_pool;\n \n-\n /* The phi_translate_table caches phi translations for a given\n    expression and predecessor.  */\n \n@@ -454,6 +474,19 @@ value_insert_into_set_bitmap (value_set_t set, tree v)\n }\n \n \n+/* Create a new bitmap set and return it.  */\n+\n+static bitmap_set_t \n+bitmap_set_new (void)\n+{\n+  bitmap_set_t ret = pool_alloc (bitmap_set_pool);\n+  ret->expressions = BITMAP_GGC_ALLOC ();\n+  ret->values = BITMAP_GGC_ALLOC ();\n+  bitmap_clear (ret->expressions);\n+  bitmap_clear (ret->values);\n+  return ret;\n+}\n+\n /* Create a new set.  */\n \n static value_set_t\n@@ -468,6 +501,23 @@ set_new  (bool indexed)\n   return ret;\n }\n \n+/* Insert an expression, EXPR, into a bitmapped set.  */\n+\n+static void\n+bitmap_insert_into_set (bitmap_set_t set, tree expr)\n+{\n+  tree val;\n+  /* XXX: For now, we only let SSA_NAMES into the bitmap sets.  */\n+  if (TREE_CODE (expr) != SSA_NAME)\n+    abort ();\n+  val = get_value_handle (expr);\n+  \n+  if (val == NULL)\n+    abort ();\n+\n+  bitmap_set_bit (set->values, VALUE_HANDLE_ID (val));\n+  bitmap_set_bit (set->expressions, SSA_NAME_VERSION (expr));\n+}\n \n /* Insert EXPR into SET.  */\n \n@@ -500,6 +550,15 @@ insert_into_set (value_set_t set, tree expr)\n     }\n }\n \n+/* Copy a bitmapped set ORIG, into bitmapped set DEST.  */\n+\n+static void\n+bitmap_set_copy (bitmap_set_t dest, bitmap_set_t orig)\n+{\n+  bitmap_copy (dest->expressions, orig->expressions);\n+  bitmap_copy (dest->values, orig->values);\n+}\n+\n /* Copy the set ORIG to the set DEST.  */\n \n static void\n@@ -564,26 +623,38 @@ set_contains_value (value_set_t set, tree val)\n   return value_exists_in_set_bitmap (set, val);\n }\n \n-/* Replace the leader for the value LOOKFOR in SET with EXPR.  */\n+/* Return true if bitmapped set SET contains the value VAL.  */\n \n-static void\n-set_replace_value (value_set_t set, tree lookfor, tree expr)\n+static bool\n+bitmap_set_contains_value (bitmap_set_t set, tree val)\n {\n-  value_set_node_t node = set->head;\n+  if (is_gimple_min_invariant (val))\n+    return true;\n+  return bitmap_bit_p (set->values, VALUE_HANDLE_ID (val));\n+}\n \n-  /* The lookup is probably more expensive than walking the linked\n-     list when we have only a small number of nodes.  */\n-  if (!set_contains_value (set, lookfor))\n-    return;\n+/* Replace an instance of value LOOKFOR with expression EXPR in SET.  */\n \n-  for (node = set->head;\n-       node;\n-       node = node->next)\n+static void\n+bitmap_set_replace_value (bitmap_set_t set, tree lookfor, tree expr)\n+{\n+  value_set_t exprset;\n+  value_set_node_t node;\n+  if (is_gimple_min_invariant (lookfor))\n+    return;\n+  if (!bitmap_set_contains_value (set, lookfor))\n+    return;\n+  exprset = VALUE_HANDLE_EXPR_SET (lookfor);\n+  for (node = exprset->head; node; node = node->next)\n     {\n-      if (get_value_handle (node->expr) == lookfor)\n+      if (TREE_CODE (node->expr) == SSA_NAME)\n \t{\n-\t  node->expr = expr;\n-\t  return;\n+\t  if (bitmap_bit_p (set->expressions, SSA_NAME_VERSION (node->expr)))\n+\t    {\n+\t      bitmap_clear_bit (set->expressions, SSA_NAME_VERSION (node->expr));\n+\t      bitmap_set_bit (set->expressions, SSA_NAME_VERSION (expr));\n+\t      return;\n+\t    }\n \t}\n     }\n }\n@@ -641,16 +712,27 @@ set_equal (value_set_t a, value_set_t b)\n   return true;\n }\n \n-/* Replace the value for EXPR in SET with EXPR.  */\n+/* Replace an instance of EXPR's VALUE with EXPR in SET.  */\n+\n static void\n-value_replace_in_set (value_set_t set, tree expr)\n+bitmap_value_replace_in_set (bitmap_set_t set, tree expr)\n {\n   tree val = get_value_handle (expr);\n+  bitmap_set_replace_value (set, val, expr);\n+}\n \n-  if (set->length == 0)\n+/* Insert EXPR into SET if EXPR's value is not already present in\n+   SET.  */\n+\n+static void\n+bitmap_value_insert_into_set (bitmap_set_t set, tree expr)\n+{\n+  tree val = get_value_handle (expr);\n+  if (is_gimple_min_invariant (val))\n     return;\n   \n-  set_replace_value (set, val, expr);\n+  if (!bitmap_set_contains_value (set, val))\n+    bitmap_insert_into_set (set, expr);\n }\n \n /* Insert the value for EXPR into SET, if it doesn't exist already.  */\n@@ -670,6 +752,29 @@ value_insert_into_set (value_set_t set, tree expr)\n }\n \n \n+/* Print out SET to OUTFILE.  */\n+\n+static void\n+bitmap_print_value_set (FILE *outfile, bitmap_set_t set,\n+\t\t\tconst char *setname, int blockindex)\n+{\n+  fprintf (outfile, \"%s[%d] := { \", setname, blockindex);\n+  if (set)\n+    {\n+      int i;\n+      EXECUTE_IF_SET_IN_BITMAP (set->expressions, 0, i,\n+      {\n+\tprint_generic_expr (outfile, ssa_name (i), 0);\n+\t\n+\tfprintf (outfile, \" (\");\n+\tprint_generic_expr (outfile, get_value_handle (ssa_name (i)), 0);\n+\tfprintf (outfile, \") \");\n+\tif (bitmap_last_set_bit (set->expressions) != i)\n+\t  fprintf (outfile, \", \");\n+      });\n+    }\n+  fprintf (outfile, \" }\\n\");\n+}\n /* Print out the value_set SET to OUTFILE.  */\n \n static void\n@@ -851,6 +956,32 @@ phi_translate_set (value_set_t dest, value_set_t set, basic_block pred,\n     } \n }\n \n+/* Find the leader for a value (i.e., the name representing that\n+   value) in a given set, and return it.  Return NULL if no leader is\n+   found.  */\n+\n+static tree\n+bitmap_find_leader (bitmap_set_t set, tree val)\n+{\n+  if (val == NULL)\n+    return NULL;\n+  \n+  if (is_gimple_min_invariant (val))\n+    return val;\n+  if (bitmap_set_contains_value (set, val))\n+    {\n+      int i;\n+      EXECUTE_IF_SET_IN_BITMAP (set->expressions, 0, i,\n+      {\n+\tif (get_value_handle (ssa_name (i)) == val)\n+\t  return ssa_name (i);\n+      });\n+      \n+    }\n+  return NULL;\n+}\n+\n+\t\n /* Find the leader for a value (i.e., the name representing that\n    value) in a given set, and return it.  Return NULL if no leader is\n    found.  */\n@@ -1129,7 +1260,7 @@ static tree\n find_or_generate_expression (basic_block block, tree expr, tree stmts)\n {\n   tree genop;\n-  genop = find_leader (AVAIL_OUT (block), expr);\n+  genop = bitmap_find_leader (AVAIL_OUT (block), expr);\n   /* Depending on the order we process DOM branches in, the value\n      may not have propagated to all the dom children yet during\n      this iteration.  In this case, the value will always be in\n@@ -1225,7 +1356,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   v = get_value_handle (expr);\n   vn_add (name, v, NULL);\n   insert_into_set (NEW_SETS (block), name);\n-  value_insert_into_set (AVAIL_OUT (block), name);\n+  bitmap_value_insert_into_set (AVAIL_OUT (block), name);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\t\t\t\t    \n       fprintf (dump_file, \"Inserted \");\n@@ -1266,7 +1397,7 @@ insert_aux (basic_block block)\n \t  while (e)\n \t    {\n \t      insert_into_set (NEW_SETS (block), e->expr);\n-\t      value_replace_in_set (AVAIL_OUT (block), e->expr);\n+\t      bitmap_value_replace_in_set (AVAIL_OUT (block), e->expr);\n \t      e = e->next;\n \t    }\n \t  if (block->pred->pred_next)\n@@ -1292,7 +1423,7 @@ insert_aux (basic_block block)\n \t\t      val = get_value_handle (node->expr);\n \t\t      if (set_contains_value (PHI_GEN (block), val))\n \t\t\tcontinue; \n-\t\t      if (set_contains_value (AVAIL_OUT (dom), val))\n+\t\t      if (bitmap_set_contains_value (AVAIL_OUT (dom), val))\n \t\t\t{\n \t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t    fprintf (dump_file, \"Found fully redundant value\\n\");\n@@ -1329,8 +1460,8 @@ insert_aux (basic_block block)\n \t\t\t  vprime = get_value_handle (eprime);\n \t\t\t  if (!vprime)\n \t\t\t    abort ();\t\t\t  \n-\t\t\t  edoubleprime = find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t      vprime);\n+\t\t\t  edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n+\t\t\t\t\t\t\t     vprime);\n \t\t\t  if (edoubleprime == NULL)\n \t\t\t    {\n \t\t\t      avail[bprime->index] = eprime;\n@@ -1396,8 +1527,8 @@ insert_aux (basic_block block)\n \t\t\t\t\t     PHI_RESULT (temp));\n \t\t\t  else\n #endif\n-\t\t\t    value_replace_in_set (AVAIL_OUT (block), \n-\t\t\t\t\t\t PHI_RESULT (temp));\n+\t\t\t    bitmap_value_replace_in_set (AVAIL_OUT (block), \n+\t\t\t\t\t\t\t PHI_RESULT (temp));\n \t\t\t  for (pred = block->pred;\n \t\t\t       pred;\n \t\t\t       pred = pred->pred_next)\n@@ -1443,7 +1574,7 @@ insert (void)\n   bool new_stuff = true;\n   basic_block bb;\n   int num_iterations = 0;\n-\n+  \n   FOR_ALL_BB (bb)\n     NEW_SETS (bb) = set_new (true);\n   \n@@ -1482,7 +1613,7 @@ is_undefined_value (tree expr)\n \n static inline void\n add_to_sets (tree var, tree expr, vuse_optype vuses, value_set_t s1,\n-\t     value_set_t s2)\n+\t     bitmap_set_t s2)\n {\n   tree val = vn_lookup_or_add (expr, vuses);\n \n@@ -1494,7 +1625,7 @@ add_to_sets (tree var, tree expr, vuse_optype vuses, value_set_t s1,\n     vn_add (var, val, vuses);\n \n   insert_into_set (s1, var);\n-  value_insert_into_set (s2, var);\n+  bitmap_value_insert_into_set (s2, var);\n }\n \n \n@@ -1529,10 +1660,14 @@ create_value_expr_from (tree expr, basic_block block, vuse_optype vuses)\n   for (i = 0; i < TREE_CODE_LENGTH (code); i++)\n     {\n       tree op = TREE_OPERAND (expr, i);\n-      tree val = vn_lookup_or_add (op, vuses);\n-      if (!is_undefined_value (op))\n-\tvalue_insert_into_set (EXP_GEN (block), op);\n-      TREE_OPERAND (vexpr, i) = val;\n+      if (op != NULL)\n+\t{\n+\t  tree val = vn_lookup_or_add (op, vuses);\n+\t  if (!is_undefined_value (op))\n+\t    value_insert_into_set (EXP_GEN (block), op);\n+\t  TREE_TYPE (val) = TREE_TYPE (TREE_OPERAND (vexpr, i));\n+\t  TREE_OPERAND (vexpr, i) = val;\n+\t}\n     }\n \n   return vexpr;\n@@ -1568,7 +1703,7 @@ compute_avail (basic_block block)\n \t      tree def = default_def (param);\n \t      val = vn_lookup_or_add (def, NULL);\n \t      insert_into_set (TMP_GEN (block), def);\n-\t      value_insert_into_set (AVAIL_OUT (block), def);\n+\t      bitmap_value_insert_into_set (AVAIL_OUT (block), def);\n \t    }\n \t}\n     }\n@@ -1582,7 +1717,7 @@ compute_avail (basic_block block)\n \t its immediate dominator.  */\n       dom = get_immediate_dominator (CDI_DOMINATORS, block);\n       if (dom)\n-\tset_copy (AVAIL_OUT (block), AVAIL_OUT (dom));\n+\tbitmap_set_copy (AVAIL_OUT (block), AVAIL_OUT (dom));\n \n       /* Generate values for PHI nodes.  */\n       for (phi = phi_nodes (block); phi; phi = PHI_CHAIN (phi))\n@@ -1618,9 +1753,10 @@ compute_avail (basic_block block)\n \t      if (TREE_CODE_CLASS (TREE_CODE (rhs)) == '1'\n \t\t  || TREE_CODE_CLASS (TREE_CODE (rhs)) == '2')\n \t\t{\n-\t\t  /* For binary and unary expressions, create a duplicate\n-\t\t     expression with the operands replaced with the value\n-\t\t     handles of the original RHS.  */\n+\t\t  /* For binary, unary, and reference expressions,\n+\t\t     create a duplicate expression with the operands\n+\t\t     replaced with the value handles of the original\n+\t\t     RHS.  */\n \t\t  tree newt = create_value_expr_from (rhs, block, vuses);\n \t\t  add_to_sets (lhs, newt, vuses, TMP_GEN (block),\n \t\t\t       AVAIL_OUT (block));\n@@ -1699,7 +1835,7 @@ eliminate (void)\n \t      tree sprime;\n \t      vuse_optype vuses = STMT_VUSE_OPS (stmt);\n \n-\t      sprime = find_leader (AVAIL_OUT (b), vn_lookup (lhs, vuses));\n+\t      sprime = bitmap_find_leader (AVAIL_OUT (b), vn_lookup (lhs, vuses));\n \t      if (sprime \n \t\t  && sprime != lhs\n \t\t  && (TREE_CODE (*rhs_p) != SSA_NAME\n@@ -1744,6 +1880,8 @@ init_pre (void)\n \t\t\t\t     expr_pred_trans_eq, free);\n   value_set_pool = create_alloc_pool (\"Value sets\",\n \t\t\t\t      sizeof (struct value_set), 30);\n+  bitmap_set_pool = create_alloc_pool (\"Bitmap sets\",\n+\t\t\t\t       sizeof (struct bitmap_set), 30);\n   value_set_node_pool = create_alloc_pool (\"Value set nodes\",\n \t\t\t\t           sizeof (struct value_set_node), 30);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n@@ -1758,7 +1896,7 @@ init_pre (void)\n       EXP_GEN (bb) = set_new (true);\n       PHI_GEN (bb) = set_new (true);\n       TMP_GEN (bb) = set_new (false);\n-      AVAIL_OUT (bb) = set_new (true);\n+      AVAIL_OUT (bb) = bitmap_set_new ();\n     }\n }\n \n@@ -1771,6 +1909,7 @@ fini_pre (void)\n   basic_block bb;\n \n   free_alloc_pool (value_set_pool);\n+  free_alloc_pool (bitmap_set_pool);\n   free_alloc_pool (value_set_node_pool);\n   free_alloc_pool (binary_node_pool);\n   free_alloc_pool (unary_node_pool);\n@@ -1806,7 +1945,8 @@ execute_pre (bool do_fre)\n \t{\n \t  print_value_set (dump_file, EXP_GEN (bb), \"exp_gen\", bb->index);\n \t  print_value_set (dump_file, TMP_GEN (bb), \"tmp_gen\", bb->index);\n-\t  print_value_set (dump_file, AVAIL_OUT (bb), \"avail_out\", bb->index);\n+\t  bitmap_print_value_set (dump_file, AVAIL_OUT (bb), \"avail_out\", \n+\t\t\t\t  bb->index);\n \t}\n     }\n "}]}