{"sha": "03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkMGY0YWYyZDU2MDdkYWNjNTZiOTQ2YjQ5ZTAyNGU3MWRkN2ZiNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-23T12:47:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-23T12:47:24Z"}, "message": "iomanip.h: Use __extension__ for `extern' explicit template instantiations.\n\n\t* iomanip.h: Use __extension__ for `extern' explicit template\n\tinstantiations.\n\t* sinst.cc: Don't explicitly instantiation string_char_traits<char>.\n\t* cinst.cc: Likewiwse, for complex<float>, complex<double>,\n\tcomplex<long double>.\n\t* extend.texi: Remove description of extension to explicit\n\tinstantiation that is now endorsed by standard C++.\n\t* decl2.c (grok_array_decl): Add comment.\n\t(mark_used): Don't instantiate an explicit instantiation.\n\t* friend.c (make_friend_class): Remove bogus comment.  Fix check\n\tfor partial specializations.\n\t* pt.c (check_explicit_specialization): Don't\n\tSET_DECL_EXPLICIT_INSTANTIATION here.\n\t(mark_decl_instantiated): Or here.\n\t(do_decl_instantiation): Do it here, instead.  Add checks for\n\tduplicate explicit instantiations, etc.  Tidy.\n\t(do_type_instantiation): Likewise.\n\t(instantiate_decl): Improve comments.  Complain about explicit\n\tinstantiations where no definition is available.\n\t* cp-tree.h (ansi_null_node): Remove.\n\t* call.c (build_over_call): Warn about converting NULL to an\n\tarithmetic type.\n\t* cvt.c (build_expr_type_conversion): Likewise.  Use\n\tnull_ptr_cst_p instead of expanding it inline.\n\t* decl.c (ansi_null_node): Remove.\n\t(init_decl_processing): Make null_node always have integral type.\n\t* except.c (build_throw): Warn about converting NULL to an\n\tarithmetic type.\n\t* lex.c (init_parse): Remove handling of ansi_null_node.\n\t* pt.c (type_unification_real): Don't convert NULL to void* type.\n\t* typeck.c (build_binary_op_nodefault): Fix NULL warnings.\n\t(convert_for_assignment): Warn about converting NULL to an\n\tarithmetic type.\n\t(convert_for_initialization): Likewise.\n\nFrom-SVN: r21915", "tree": {"sha": "1a569fd48a34a3e468b6fe1fcacbc60c724d1626", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a569fd48a34a3e468b6fe1fcacbc60c724d1626"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/comments", "author": null, "committer": null, "parents": [{"sha": "5d7045be13252dfa6c183863cbe1a3335d34fec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7045be13252dfa6c183863cbe1a3335d34fec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7045be13252dfa6c183863cbe1a3335d34fec5"}], "stats": {"total": 483, "additions": 346, "deletions": 137}, "files": [{"sha": "f059d699c75dcd3a30938db547b781580154d154", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1,3 +1,8 @@\n+Sun Aug 23 11:56:08 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* extend.texi: Remove description of extension to explicit\n+\tinstantiation that is now endorsed by standard C++.\n+\n Sun Aug 23 09:39:09 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \n \t* config/arc/arc.c (arc_initialize_pic): Remove."}, {"sha": "bf714bf06f7adb663b9f5cdbe77c47accc1facfa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1,3 +1,34 @@\n+1998-08-23  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* decl2.c (grok_array_decl): Add comment.\n+\t(mark_used): Don't instantiate an explicit instantiation.\n+\t* friend.c (make_friend_class): Remove bogus comment.  Fix check\n+\tfor partial specializations.\n+\t* pt.c (check_explicit_specialization): Don't\n+\tSET_DECL_EXPLICIT_INSTANTIATION here.\n+\t(mark_decl_instantiated): Or here.\n+\t(do_decl_instantiation): Do it here, instead.  Add checks for\n+\tduplicate explicit instantiations, etc.  Tidy.\n+\t(do_type_instantiation): Likewise.\n+\t(instantiate_decl): Improve comments.  Complain about explicit\n+\tinstantiations where no definition is available.\n+\t\n+\t* cp-tree.h (ansi_null_node): Remove.\n+\t* call.c (build_over_call): Warn about converting NULL to an\n+\tarithmetic type.\n+\t* cvt.c (build_expr_type_conversion): Likewise.  Use\n+\tnull_ptr_cst_p instead of expanding it inline.\n+\t* decl.c (ansi_null_node): Remove. \n+\t(init_decl_processing): Make null_node always have integral type.\n+\t* except.c (build_throw): Warn about converting NULL to an\n+\tarithmetic type.\n+\t* lex.c (init_parse): Remove handling of ansi_null_node.\n+\t* pt.c (type_unification_real): Don't convert NULL to void* type.\n+\t* typeck.c (build_binary_op_nodefault): Fix NULL warnings.\n+\t(convert_for_assignment): Warn about converting NULL to an\n+\tarithmetic type.\n+\t(convert_for_initialization): Likewise.\n+\t\n 1998-08-20  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tree.c (search_tree, no_linkage_helper, no_linkage_check): New fn."}, {"sha": "3eb0817868304bb8691ee789a0b1323aa6585644", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -3331,7 +3331,14 @@ build_over_call (cand, args, flags)\n \t     \"argument passing\", fn, i - is_method);\n \t}\n       else\n-\tval = convert_like (conv, TREE_VALUE (arg));\n+\t{\n+\t  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+\t  if (ARITHMETIC_TYPE_P (TREE_VALUE (parm))\n+\t      && TREE_VALUE (arg) == null_node)\n+\t    cp_warning (\"converting NULL to non-pointer type\");\n+\t    \n+\t  val = convert_like (conv, TREE_VALUE (arg));\n+\t}\n \n #ifdef PROMOTE_PROTOTYPES\n       if ((TREE_CODE (type) == INTEGER_TYPE"}, {"sha": "82dc430bb2ed3c606958f70d04218e0bf51f073d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1918,7 +1918,6 @@ extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n extern tree integer_two_node, integer_three_node;\n extern tree boolean_type_node, boolean_true_node, boolean_false_node;\n \n-extern tree ansi_null_node;\n extern tree null_node;\n \n /* in pt.c  */"}, {"sha": "99289e824e36efd742467462a87044fb8515ad43", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -946,6 +946,11 @@ build_expr_type_conversion (desires, expr, complain)\n   tree conv;\n   tree winner = NULL_TREE;\n \n+  if (expr == null_node \n+      && (desires & WANT_INT) \n+      && !(desires & WANT_NULL))\n+    cp_warning (\"converting NULL to non-pointer type\");\n+    \n   if (TREE_CODE (basetype) == OFFSET_TYPE)\n     expr = resolve_offset_ref (expr);\n   expr = convert_from_reference (expr);\n@@ -955,8 +960,7 @@ build_expr_type_conversion (desires, expr, complain)\n     switch (TREE_CODE (basetype))\n       {\n       case INTEGER_TYPE:\n-\tif ((desires & WANT_NULL) && TREE_CODE (expr) == INTEGER_CST\n-\t    && integer_zerop (expr))\n+\tif ((desires & WANT_NULL) && null_ptr_cst_p (expr))\n \t  return expr;\n \t/* else fall through...  */\n "}, {"sha": "a93685d810cdd92c984d67754a2cc35ef2f3d311", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -429,13 +429,8 @@ tree static_aggregates;\n tree integer_zero_node;\n tree null_pointer_node;\n \n-/* The value for __null (NULL), when -ansi is specified.  As per the\n-   standard, this is an implementation-defined null pointer constant.  */\n-tree ansi_null_node;\n-\n-/* The value for __null (NULL).  With -ansi, this is just\n-   ansi_null_node.  Without -ansi, this is a zero-valued pointer\n-   constant of type `{unknown type}*'.  */\n+/* The value for __null (NULL), namely, a zero of an integer type with\n+   the same number of bits as a pointer.  */\n tree null_node;\n \n /* A node for the integer constants 1, 2, and 3.  */\n@@ -6035,9 +6030,7 @@ init_decl_processing ()\n   /* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */\n   TREE_TYPE (unknown_type_node) = unknown_type_node;\n \n-  TREE_TYPE (ansi_null_node) = type_for_size (POINTER_SIZE, 0);\n-  if (!flag_ansi)\n-    TREE_TYPE (null_node) = build_pointer_type (unknown_type_node);\n+  TREE_TYPE (null_node) = type_for_size (POINTER_SIZE, 0);\n \n   /* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same\n      result.  */"}, {"sha": "8d923be461ca445fa1189e674104d0f03463baba", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1223,7 +1223,9 @@ grok_array_decl (array_expr, index_exp)\n     return build_opfncall (ARRAY_REF, LOOKUP_NORMAL,\n \t\t\t   array_expr, index_exp, NULL_TREE);\n \n-  /* Otherwise, create an ARRAY_REF for a pointer or array type.  */\n+  /* Otherwise, create an ARRAY_REF for a pointer or array type.  It\n+     is a little-known fact that, if `a' is an array and `i' is an\n+     int, you can write `i[a]', which means the same thing as `a[i]'.  */\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     p1 = array_expr;\n@@ -4900,9 +4902,11 @@ mark_used (decl)\n      template, we now know that we will need to actually do the\n      instantiation.  A TEMPLATE_DECL may also have DECL_TEMPLATE_INFO,\n      if it's a partial instantiation, but there's no need to\n-     instantiate such a thing.  */\n+     instantiate such a thing.  We check that DECL is not an explicit\n+     instantiation because that is not checked in instantiate_decl.  */\n   if (TREE_CODE (decl) != TEMPLATE_DECL\n-      && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n+      && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n+      && !DECL_EXPLICIT_INSTANTIATION (decl))\n     instantiate_decl (decl);\n }\n "}, {"sha": "b441c6b628d09ac395bd6f29ca7076dc4cb0c8ce", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1278,10 +1278,7 @@ build_throw (e)\n     return build_min (THROW_EXPR, void_type_node, e);\n \n   if (e == null_node)\n-    {\n-      cp_warning (\"throwing NULL, which has integral, not pointer type\");\n-      e = ansi_null_node;\n-    }\n+    cp_warning (\"throwing NULL, which has integral, not pointer type\");\n \n   e = build1 (THROW_EXPR, void_type_node, e);\n   TREE_SIDE_EFFECTS (e) = 1;"}, {"sha": "a566d0504f570747d213a37ddf92a9e4e3f75305", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -262,15 +262,13 @@ make_friend_class (type, friend_type)\n       return;\n     }\n \n-  if (CLASSTYPE_TEMPLATE_SPECIALIZATION (friend_type)) \n+  if (CLASSTYPE_TEMPLATE_SPECIALIZATION (friend_type)\n+      && uses_template_parms (friend_type))\n     {\n       /* [temp.friend]\n \t \n \t Friend declarations shall not declare partial\n-\t specializations.  \n-\n-         Note that CLASSTYPE_TEMPLATE_SPECIALIZATION is not set for\n-\t full specializations.  */ \n+\t specializations.  */\n       cp_error (\"partial specialization `%T' declared `friend'\",\n \t\tfriend_type);\n       return;"}, {"sha": "8ded741b576e540bbc6d424fdabdf2abba8518b8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -781,11 +781,7 @@ init_parse (filename)\n      type_for_size here because integer_type_node and so forth are not\n      set up.  Therefore, we don't set the type of these nodes until\n      init_decl_processing.  */\n-  ansi_null_node = build_int_2 (0, 0);\n-  if (flag_ansi)\n-    null_node = ansi_null_node;\n-  else\n-    null_node = build_int_2 (0, 0);\n+  null_node = build_int_2 (0, 0);\n   ridpointers[RID_NULL] = null_node;\n \n   opname_tab[(int) COMPONENT_REF] = \"->\";"}, {"sha": "f156fe186bb8ba85332aee9f2652ae8d94d140c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 139, "deletions": 67, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1299,14 +1299,9 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n \t  if (explicit_instantiation)\n \t    {\n+\t      /* We don't set DECL_EXPLICIT_INSTANTIATION here; that\n+\t\t is done by do_decl_instantiation later.  */\n \t      decl = instantiate_template (tmpl, innermost_args (targs));\n-\t      if (!DECL_TEMPLATE_SPECIALIZATION (decl))\n-\t\t/* There doesn't seem to be anything in the draft to\n-\t\t   prevent a specialization from being explicitly\n-\t\t   instantiated.  We're careful not to destroy the\n-\t\t   information indicating that this is a\n-\t\t   specialization here.  */\n-\t\tSET_DECL_EXPLICIT_INSTANTIATION (decl);\n \t      return decl;\n \t    }\n \t  \n@@ -6595,12 +6590,6 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t  arg = TREE_TYPE (arg);\n \t}\n #endif\n-      if (! flag_ansi && arg == TREE_TYPE (null_node))\n-\t{\n-\t  warning (\"using type void* for NULL\");\n-\t  arg = ptr_type_node;\n-\t}\n-\n       if (!subr)\n \tmaybe_adjust_types_for_deduction (strict, &parm, &arg);\n \n@@ -7109,14 +7098,15 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n     }\n }\n \f\n+/* Called if RESULT is explicitly instantiated, or is a member of an\n+   explicitly instantiated class, or if using -frepo and the\n+   instantiation of RESULT has been assigned to this file.  */\n+\n void\n mark_decl_instantiated (result, extern_p)\n      tree result;\n      int extern_p;\n {\n-  if (DECL_TEMPLATE_INSTANTIATION (result))\n-    SET_DECL_EXPLICIT_INSTANTIATION (result);\n-\n   if (TREE_CODE (result) != FUNCTION_DECL)\n     /* The TREE_PUBLIC flag for function declarations will have been\n        set correctly by tsubst.  */\n@@ -7458,39 +7448,69 @@ do_decl_instantiation (declspecs, declarator, storage)\n       cp_error (\"explicit instantiation of non-template `%#D'\", decl);\n       return;\n     }\n-\n-  /* If we've already seen this template instance, use it.  */\n-  if (TREE_CODE (decl) == VAR_DECL)\n-    {\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      /* There is an asymmetry here in the way VAR_DECLs and\n+\t FUNCTION_DECLs are handled by grokdeclarator.  In the case of\n+\t the latter, the DECL we get back will be marked as a\n+\t template instantiation, and the appropriate\n+\t DECL_TEMPLATE_INFO will be set up.  This does not happen for\n+\t VAR_DECLs so we do the lookup here.  Probably, grokdeclarator\n+\t should handle VAR_DECLs as it currently handles\n+\t FUNCTION_DECLs.  */\n       result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, 0);\n       if (result && TREE_CODE (result) != VAR_DECL)\n-\tresult = NULL_TREE;\n+\t{\n+\t  cp_error (\"no matching template for `%D' found\", result);\n+\t  return;\n+\t}\n     }\n   else if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n       cp_error (\"explicit instantiation of `%#D'\", decl);\n       return;\n     }\n-  else if (DECL_TEMPLATE_SPECIALIZATION (decl))\n-    /* [temp.spec]\n+  else\n+    result = decl;\n+\n+  /* Check for various error cases.  Note that if the explicit\n+     instantiation is legal the RESULT will currently be marked as an\n+     *implicit* instantiation; DECL_EXPLICIT_INSTANTIATION is not set\n+     until we get here.  */\n \n-       No program shall both explicitly instantiate and explicitly\n-       specialize a template.  */\n+  if (DECL_TEMPLATE_SPECIALIZATION (result))\n     {\n-      cp_error (\"explicit instantiation of `%#D' after\", decl);\n-      cp_error_at (\"explicit specialization here\", decl);\n+      /* [temp.spec]\n+\n+\t No program shall both explicitly instantiate and explicitly\n+\t specialize a template.  */\n+      cp_error (\"explicit instantiation of `%#D' after\", result);\n+      cp_error_at (\"explicit specialization here\", result);\n       return;\n     }\n-  else if (DECL_TEMPLATE_INSTANTIATION (decl))\n-    result = decl;\n+  else if (DECL_EXPLICIT_INSTANTIATION (result))\n+    {\n+      /* [temp.spec]\n+\n+\t No program shall explicitly instantiate any template more\n+\t than once.  \n \n-  if (! result)\n+\t We check DECL_INTERFACE_KNOWN so as not to complain when the\n+\t first instantiation was `extern' and the second is not, and\n+\t EXTERN_P for the opposite case.  */\n+      if (DECL_INTERFACE_KNOWN (result) && !extern_p)\n+\tcp_error (\"duplicate explicit instantiation of `%#D'\", result);\n+\n+      /* If we've already instantiated the template, just return now.  */\n+      if (DECL_INTERFACE_KNOWN (result))\n+\treturn;\n+    }\n+  else if (!DECL_IMPLICIT_INSTANTIATION (result))\n     {\n-      cp_error (\"no matching template for `%D' found\", decl);\n+      cp_error (\"no matching template for `%D' found\", result);\n       return;\n     }\n-\n-  if (! DECL_TEMPLATE_INFO (result))\n+  else if (!DECL_TEMPLATE_INFO (result))\n     {\n       cp_pedwarn (\"explicit instantiation of non-template `%#D'\", result);\n       return;\n@@ -7502,11 +7522,16 @@ do_decl_instantiation (declspecs, declarator, storage)\n   if (storage == NULL_TREE)\n     ;\n   else if (storage == ridpointers[(int) RID_EXTERN])\n-    extern_p = 1;\n+    {\n+      if (pedantic)\n+\tcp_pedwarn (\"ANSI C++ forbids the use of `extern' on explicit instantiations\");\n+      extern_p = 1;\n+    }\n   else\n     cp_error (\"storage class `%D' applied to template instantiation\",\n \t      storage);\n \n+  SET_DECL_EXPLICIT_INSTANTIATION (result);\n   mark_decl_instantiated (result, extern_p);\n   repo_template_instantiated (result, extern_p);\n   if (! extern_p)\n@@ -7561,38 +7586,82 @@ do_type_instantiation (t, storage)\n       return;\n     }\n \n-  if (storage == NULL_TREE)\n-    /* OK */;\n-  else if (storage == ridpointers[(int) RID_INLINE])\n-    nomem_p = 1;\n-  else if (storage == ridpointers[(int) RID_EXTERN])\n-    extern_p = 1;\n-  else if (storage == ridpointers[(int) RID_STATIC])\n-    static_p = 1;\n-  else\n+  if (storage != NULL_TREE)\n     {\n-      cp_error (\"storage class `%D' applied to template instantiation\",\n-\t\tstorage);\n-      extern_p = 0;\n+      if (pedantic)\n+\tcp_pedwarn(\"ANSI C++ forbids the use of `%s' on explicit instantiations\", \n+\t\t   IDENTIFIER_POINTER (storage));\n+\n+      if (storage == ridpointers[(int) RID_INLINE])\n+\tnomem_p = 1;\n+      else if (storage == ridpointers[(int) RID_EXTERN])\n+\textern_p = 1;\n+      else if (storage == ridpointers[(int) RID_STATIC])\n+\tstatic_p = 1;\n+      else\n+\t{\n+\t  cp_error (\"storage class `%D' applied to template instantiation\",\n+\t\t    storage);\n+\t  extern_p = 0;\n+\t}\n     }\n \n-  /* We've already instantiated this.  */\n-  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && ! CLASSTYPE_INTERFACE_ONLY (t)\n-      && extern_p)\n-    return;\n+  if (CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n+    {\n+      /* [temp.spec]\n \n-  if (! CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n+\t No program shall both explicitly instantiate and explicitly\n+\t specialize a template.  */\n+      cp_error (\"explicit instantiation of `%#T' after\", t);\n+      cp_error_at (\"explicit specialization here\", t);\n+      return;\n+    }\n+  else if (CLASSTYPE_EXPLICIT_INSTANTIATION (t))\n     {\n-      mark_class_instantiated (t, extern_p);\n-      repo_template_instantiated (t, extern_p);\n+      /* [temp.spec]\n+\n+\t No program shall explicitly instantiate any template more\n+\t than once.  \n+\n+         If CLASSTYPE_INTERFACE_ONLY, then the first explicit\n+\t instantiation was `extern', and if EXTERN_P then the second\n+\t is.  Both cases are OK.  */\n+      if (!CLASSTYPE_INTERFACE_ONLY (t) && !extern_p)\n+\tcp_error (\"duplicate explicit instantiation of `%#T'\", t);\n+      \n+      /* If we've already instantiated the template, just return now.  */\n+      if (!CLASSTYPE_INTERFACE_ONLY (t))\n+\treturn;\n     }\n \n+  mark_class_instantiated (t, extern_p);\n+  repo_template_instantiated (t, extern_p);\n+\n   if (nomem_p)\n     return;\n \n   {\n     tree tmp;\n \n+    /* In contrast to implicit instantiation, where only the\n+       declarations, and not the definitions, of members are\n+       instantiated, we have here:\n+\n+         [temp.explicit]\n+\n+\t The explicit instantiation of a class template specialization\n+\t implies the instantiation of all of its members not\n+\t previously explicitly specialized in the translation unit\n+\t containing the explicit instantiation.  \n+\n+       Of course, we can't instantiate member template classes, since\n+       we don't have any arguments for them.  Note that the standard\n+       is unclear on whether the instatiation of the members are\n+       *explicit* instantiations or not.  We choose to be generous,\n+       and not set DECL_EXPLICIT_INSTANTIATION.  Therefore, we allow\n+       the explicit instantiation of a class where some of the members\n+       have no definition in the current translation unit.  */\n+\n     if (! static_p)\n       for (tmp = TYPE_METHODS (t); tmp; tmp = TREE_CHAIN (tmp))\n \tif (TREE_CODE (tmp) == FUNCTION_DECL\n@@ -7613,19 +7682,6 @@ do_type_instantiation (t, storage)\n \t    instantiate_decl (tmp);\n \t}\n \n-    /* In contrast to implicit instantiation, where only the\n-       declarations, and not the definitions, of members are\n-       instantiated, we have here:\n-\n-         [temp.explicit]\n-\n-\t The explicit instantiation of a class template specialization\n-\t implies the instantiation of all of its members not\n-\t previously explicitly specialized in the translation unit\n-\t containing the explicit instantiation.  \n-\n-       Of course, we can't instantiate member template classes, since\n-       we don't have any arguments for them.  */\n     for (tmp = CLASSTYPE_TAGS (t); tmp; tmp = TREE_CHAIN (tmp))\n       if (IS_AGGR_TYPE (TREE_VALUE (tmp))\n \t  && !uses_template_parms (CLASSTYPE_TI_ARGS (TREE_VALUE (tmp))))\n@@ -7783,7 +7839,11 @@ instantiate_decl (d)\n \n   if ((TREE_CODE (d) == FUNCTION_DECL && DECL_INITIAL (d))\n       || (TREE_CODE (d) == VAR_DECL && !DECL_IN_AGGR_P (d)))\n-    /* D has already been instantiated.  */\n+    /* D has already been instantiated.  It might seem reasonable to\n+       check whether or not D is an explict instantiation, and, if so,\n+       stop here.  But when an explicit instantiation is deferred\n+       until the end of the compilation, DECL_EXPLICIT_INSTANTIATION\n+       is set, even though we still need to do the instantiation.  */\n     return d;\n \n   /* If we already have a specialization of this declaration, then\n@@ -7911,6 +7971,18 @@ instantiate_decl (d)\n       lineno = line;\n       input_filename = file;\n \n+      if (at_eof && !pattern_defined \n+\t  && DECL_EXPLICIT_INSTANTIATION (d))\n+\t/* [temp.explicit]\n+\n+\t   The definition of a non-exported function template, a\n+\t   non-exported member function template, or a non-exported\n+\t   member function or static data member of a class template\n+\t   shall be present in every translation unit in which it is\n+\t   explicitly instantiated.  */\n+\tcp_error (\"explicit instantiation of `%D' but no definition available\",\n+\t\t  d);\n+\n       add_pending_template (d);\n       goto out;\n     }"}, {"sha": "3f7995311cbac16a0b7bcaf9cfda1296daf48669", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -3244,25 +3244,18 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n   /* Nonzero means set RESULT_TYPE to the common type of the args.  */\n   int common = 0;\n \n-  /* Unless -ansi is specified, __null has pointer type.  But, then,\n-     things like `7 != NULL' result in errors about comparisons\n-     between pointers and integers.  So, here, we replace __null with\n-     an appropriate null pointer constant.  */\n-  op0 = (orig_op0 == null_node) ? ansi_null_node : orig_op0;\n-  op1 = (orig_op1 == null_node) ? ansi_null_node : orig_op1;\n-\n   /* Apply default conversions.  */\n   if (code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR\n       || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR\n       || code == TRUTH_XOR_EXPR)\n     {\n-      op0 = decay_conversion (op0);\n-      op1 = decay_conversion (op1);\n+      op0 = decay_conversion (orig_op0);\n+      op1 = decay_conversion (orig_op1);\n     }\n   else\n     {\n-      op0 = default_conversion (op0);\n-      op1 = default_conversion (op1);\n+      op0 = default_conversion (orig_op0);\n+      op1 = default_conversion (orig_op1);\n     }\n \n   type0 = TREE_TYPE (op0);\n@@ -3961,15 +3954,19 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       return error_mark_node;\n     }\n \n-  if (/* If OP0 is NULL and OP1 is not a pointer, or vice versa.  */\n-      (orig_op0 == null_node\n-       && TREE_CODE (TREE_TYPE (orig_op1)) != POINTER_TYPE)\n-      /* Or vice versa.  */\n-      || (orig_op1 == null_node\n-\t  && TREE_CODE (TREE_TYPE (orig_op0)) != POINTER_TYPE)\n-      /* Or, both are NULL and the operation was not a comparison.  */\n-      || (orig_op0 == null_node && orig_op1 == null_node \n-\t  && code != EQ_EXPR && code != NE_EXPR))\n+  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+  if (/* It's reasonable to use pointer values as operands of &&\n+\t and ||, so NULL is no exception.  */\n+      !(code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n+      && (/* If OP0 is NULL and OP1 is not a pointer, or vice versa.  */\n+\t  (orig_op0 == null_node\n+\t   && TREE_CODE (TREE_TYPE (op1)) != POINTER_TYPE)\n+\t  /* Or vice versa.  */\n+\t  || (orig_op1 == null_node\n+\t      && TREE_CODE (TREE_TYPE (op0)) != POINTER_TYPE)\n+\t  /* Or, both are NULL and the operation was not a comparison.  */\n+\t  || (orig_op0 == null_node && orig_op1 == null_node \n+\t      && code != EQ_EXPR && code != NE_EXPR)))\n     /* Some sort of arithmetic operation involving NULL was\n        performed.  Note that pointer-difference and pointer-addition\n        have already been handled above, and so we don't end up here in\n@@ -6593,6 +6590,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   register tree rhstype;\n   register enum tree_code coder = TREE_CODE (TREE_TYPE (rhs));\n \n+  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+  if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n+    cp_warning (\"converting NULL to non-pointer type\");\n+\n   if (coder == UNKNOWN_TYPE)\n     rhs = instantiate_type (type, rhs, 1);\n \n@@ -7046,6 +7047,10 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n   register tree rhstype;\n   register enum tree_code coder;\n \n+  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+  if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n+    cp_warning (\"converting NULL to non-pointer type\");\n+\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs, since RHS is used in non-lvalue context.  */\n   if (TREE_CODE (rhs) == NOP_EXPR"}, {"sha": "45b31b823221dd37606c2d12f945408645d8f331", "filename": "gcc/extend.texi", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -3330,14 +3330,12 @@ instances required by your explicit instantiations (but not by any\n other files) without having to specify them as well.\n \n g++ has extended the template instantiation syntax outlined in the\n-Working Paper to allow forward declaration of explicit instantiations,\n-explicit instantiation of members of template classes and instantiation\n-of the compiler support data for a template class (i.e. the vtable)\n-without instantiating any of its members:\n+Working Paper to allow forward declaration of explicit instantiations\n+and instantiation of the compiler support data for a template class\n+(i.e. the vtable) without instantiating any of its members:\n \n @example\n extern template int max (int, int);\n-template void Foo<int>::f ();\n inline template class Foo<int>;\n @end example\n "}, {"sha": "1c72d1cf8f80d2d6e6f4649472093413e8ed2a5d", "filename": "gcc/testsuite/g++.old-deja/g++.other/null1.C", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull1.C?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1,12 +1,40 @@\n-// Build don't link:\n+// Build don't run:\n \n #include <cstddef>\n \n-void f()\n+void g(int) {}\n+extern void g(void*);\n+\n+template <int I>\n+void h() {}\n+\n+void k(int) {}\n+\n+template <class T>\n+void l(T);\n+\n+template <>\n+void l(int) {}\n+\n+int main()\n {\n-  int i;\n-  float f;\n+  int i = NULL; // WARNING - converting NULL to non-pointer type\n+  float z = NULL; // WARNING - converting NULL to non-pointer type\n+  int a[2];\n \n   i != NULL; // WARNING - NULL used in arithmetic\n-  f != NULL; // WARNING - NULL used in arithmetic\n+  NULL != z; // WARNING - NULL used in arithmetic\n+  k != NULL; // No warning: decay conversion\n+  NULL != a; // Likewise.\n+  -NULL;     // WARNING - converting NULL to non-pointer type\n+  +NULL;     // WARNING - converting NULL to non-pointer type\n+  ~NULL;     // WARNING - converting NULL to non-pointer type\n+  a[NULL] = 3; // WARNING - converting NULL to non-pointer-type\n+  i = NULL;  // WARNING - converting NULL to non-pointer type\n+  z = NULL;  // WARNING - converting NULL to non-pointer type\n+  k(NULL);   // WARNING - converting NULL to int\n+  g(NULL);   // WARNING - converting NULL to int\n+  h<NULL>(); // WARNING - NULL bound to integer template parameter\n+  l(NULL);   // WARNING - converting NULL to int\n+  NULL && NULL; // No warning: converting NULL to bool is OK\n }"}, {"sha": "ade83fdc443010cbf203f09d89b500f0527da0c2", "filename": "gcc/testsuite/g++.old-deja/g++.pt/explicit70.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit70.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit70.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexplicit70.C?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -0,0 +1,43 @@\n+// Build don't link:\n+\n+template <class T>\n+void f(T) {}\n+\n+template <class T>\n+struct S {\n+  static T t;\n+};\n+\n+template <class T>\n+T S<T>::t;\n+\n+template void f(int);\n+template void f(int); // ERROR - duplicate explicit instantiation \n+template int S<int>::t;\n+template int S<int>::t; // ERROR - duplicate explicit instantiation \n+template class S<double>;\n+template class S<double>; // ERROR - duplicate explicit instantiation \n+\n+extern template void f(double); // WARNING - extern not allowed\n+inline template class S<float>; // WARNING - inline not allowed\n+\n+template <class T>\n+struct S<T*> {};\n+\n+template class S<void*>; // OK - explicit instantiation of partial\n+                         // specialization\n+\n+template <>\n+struct S<long double> {};  // ERROR - explicit specialization\n+\n+template class S<long double>; // ERROR - explicit instantiation after\n+\n+template <>\n+void f(long double) {}        // ERROR - explicit specialization\n+\n+template void f(long double); // ERROR - explicit instantiation after\n+\n+template <class T>\n+void g(T);\n+\n+template void g(int); // ERROR - no definition of g."}, {"sha": "15a380b462a102729ac4b45cf5c9c1e1a0142e14", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend31.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend31.C?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S1 {\n+};\n+\n+template <>\n+struct S1<int> {};\n+\n+struct S2 {\n+  friend class S1<int>;\n+};"}, {"sha": "11f9c781988d3ed8ef0aa43c963273cc85278b20", "filename": "gcc/testsuite/g++.old-deja/g++.pt/instantiate1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate1.C?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1,7 +1,7 @@\n // Build don't link:\n \n template <class T>\n-void f(T t);\n+void f(T t) {}\n \n template void f<int>(int);\n template void f<>(long);"}, {"sha": "ee9ce72478e2666aeea7c1ede4b502946163a072", "filename": "libio/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FChangeLog?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1,3 +1,8 @@\n+1998-08-23  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* iomanip.h: Use __extension__ for `extern' explicit template\n+\tinstantiations.\n+\n 1998-08-17  Ulrich Drepper  <drepper@cygnus.com>\n \n \t* strfile.h: Define __PMT if not already defined."}, {"sha": "7c0232ed1e166727b2d51d574e92dc84680db207", "filename": "libio/iomanip.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libio%2Fiomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libio%2Fiomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiomanip.h?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -68,8 +68,8 @@ template <class TP> class smanip {\n };\n \n #ifdef __GNUG__\n-extern template class smanip<int>;\n-extern template class smanip<ios::fmtflags>;\n+__extension__ extern template class smanip<int>;\n+__extension__ extern template class smanip<ios::fmtflags>;\n #endif\n \n template<class TP>\n@@ -81,10 +81,14 @@ inline ostream& operator<<(ostream& o, const smanip<TP>& m)\n { (*m._f)(o, m._a); return o;}\n \n #ifdef __GNUG__\n-extern template istream& operator>>(istream&, const smanip<int>&);\n-extern template istream& operator>>(istream&, const smanip<ios::fmtflags>&);\n-extern template ostream& operator<<(ostream&, const smanip<int>&);\n-extern template ostream& operator<<(ostream&, const smanip<ios::fmtflags>&);\n+__extension__ extern \n+template istream& operator>>(istream&, const smanip<int>&);\n+__extension__ extern \n+template istream& operator>>(istream&, const smanip<ios::fmtflags>&);\n+__extension__ extern \n+template ostream& operator<<(ostream&, const smanip<int>&);\n+__extension__ extern \n+template ostream& operator<<(ostream&, const smanip<ios::fmtflags>&);\n #endif\n \n //-----------------------------------------------------------------------------"}, {"sha": "2cb0d0a9255401b0ec0644f75f841c40b67b715a", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -1,3 +1,9 @@\n+1998-08-23  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* sinst.cc: Don't explicitly instantiation string_char_traits<char>.\n+\t* cinst.cc: Likewiwse, for complex<float>, complex<double>,\n+\tcomplex<long double>.\n+\t\n 1998-08-17  Mark Mitchell  <mark@markmitchell.com>\n \n \t* stdexcept: Put things in the std namespace, if appropriate."}, {"sha": "983e8a9caa7699981dca8d54ef5872a446897b97", "filename": "libstdc++/cinst.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libstdc%2B%2B%2Fcinst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libstdc%2B%2B%2Fcinst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fcinst.cc?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -32,7 +32,6 @@ typedef complex<f> c;\n typedef const c& ccr;\n \n #ifdef MAIN\n-template class complex<f>;\n template c& __doapl (c*, ccr);\n template c& __doaml (c*, ccr);\n template c& __doami (c*, ccr);"}, {"sha": "0b3617ece6204d159ca1e22f7754b194cd04593c", "filename": "libstdc++/sinst.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libstdc%2B%2B%2Fsinst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03d0f4af2d5607dacc56b946b49e024e71dd7fb7/libstdc%2B%2B%2Fsinst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fsinst.cc?ref=03d0f4af2d5607dacc56b946b49e024e71dd7fb7", "patch": "@@ -42,8 +42,11 @@ typedef char c;\n typedef wchar_t c;\n #endif\n \n-#ifdef TRAITS\n+#if defined(TRAITS) && !defined(C)\n template class string_char_traits <c>;\n+#else\n+/* string_char_traits<char> is already explicitly specialized in\n+   std/straits.h.  */\n #endif\n \n typedef basic_string <c> s;"}]}