{"sha": "a584cf65fa83edcdbcf903b479414b04ddcd07ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU4NGNmNjVmYTgzZWRjZGJjZjkwM2I0Nzk0MTRiMDRkZGNkMDdlZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-03-29T02:08:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-03-29T02:08:46Z"}, "message": "pex-common.c: New file.\n\nlibiberty:\n\t* pex-common.c: New file.\n\t* pex-one.c: New file.\n\t* pexecute.c: New file.\n\t* pex-common.h: Include <stdio.h>.\n\t(struct pex_obj): Define.\n\t(struct pex_funcs): Define.\n\t(pex_init_common): Declare.\n\t* pex-unix.c: Rewrite.\n\t* pex-win32.c: Rewrite.\n\t* pex-djgpp.c: Rewrite.\n\t* pex-msdos.c: Rewrite.\n\t* testsuite/text-pexecute.c: New file.\n\t* pexecute.txh: Rewrite.\n\t* configure.ac: Check for wait3 and wait4.  Set CHECK to\n\treally-check rather than check-cplus-dem.\n\t* functions.texi: Rebuild.\n\t* Makefile.in: Rebuild dependencies.\n\t(CFILES): Add pexecute.c, pex-common.c, pex-one.c.\n\t(REQUIRED_OFILES): Add pexecute.o, pex-common.o, pex-one.o.\n\t* testsuite/Makefile.in (really-check): New target.\n\t(check-pexecute, test-pexecute): New targets.\n\t* configure: Rebuild.\ninclude:\n\t* libiberty.h: Include <stdio.h>.\n\t(PEX_RECORD_TIMES, PEX_USE_PIPES, PEX_SAVE_TEMPS): Define.\n\t(PEX_LAST, PEX_SEARCH, PEX_SUFFIX, PEX_STDERR_TO_STDOUT): Define.\n\t(PEX_BINARY_INPUT, PEX_BINARY_OUTPUT): Define.\n\t(pex_init, pex_run, pex_read_output): Declare.\n\t(pex_get_status, pex_get_times, pex_free, pex_one): Declare.\n\t(struct pex_time): Define.\n\nFrom-SVN: r97148", "tree": {"sha": "26b232669dd7ed86ad0e9e62006f8dd008a03e14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26b232669dd7ed86ad0e9e62006f8dd008a03e14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a584cf65fa83edcdbcf903b479414b04ddcd07ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a584cf65fa83edcdbcf903b479414b04ddcd07ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a584cf65fa83edcdbcf903b479414b04ddcd07ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a584cf65fa83edcdbcf903b479414b04ddcd07ee/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f78c1452ea50e6f950bc0d6f3d64ba43be1cf021", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f78c1452ea50e6f950bc0d6f3d64ba43be1cf021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f78c1452ea50e6f950bc0d6f3d64ba43be1cf021"}], "stats": {"total": 3470, "additions": 3030, "deletions": 440}, "files": [{"sha": "cc6700d699405a6b25d4fc9b35b57116b7b649ed", "filename": "include/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -1,3 +1,13 @@\n+2005-03-28  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* libiberty.h: Include <stdio.h>.\n+\t(PEX_RECORD_TIMES, PEX_USE_PIPES, PEX_SAVE_TEMPS): Define.\n+\t(PEX_LAST, PEX_SEARCH, PEX_SUFFIX, PEX_STDERR_TO_STDOUT): Define.\n+\t(PEX_BINARY_INPUT, PEX_BINARY_OUTPUT): Define.\n+\t(pex_init, pex_run, pex_read_output): Declare.\n+\t(pex_get_status, pex_get_times, pex_free, pex_one): Declare.\n+\t(struct pex_time): Define.\n+\n 2005-03-28  Mark Mitchell <mark@codesourcery.com>\n \n \t* libiberty.h (ffs): Declare, if necessary."}, {"sha": "1bdf0ce8f7251b1be9d01eb6b985cc7946d315b8", "filename": "include/libiberty.h", "status": "modified", "additions": 163, "deletions": 1, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -1,6 +1,6 @@\n /* Function declarations for libiberty.\n \n-   Copyright 2001, 2002 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2005 Free Software Foundation, Inc.\n    \n    Note - certain prototypes declared in this header file are for\n    functions whoes implementation copyright does not belong to the\n@@ -46,6 +46,8 @@ extern \"C\" {\n /* Get a definition for va_list.  */\n #include <stdarg.h>\n \n+#include <stdio.h>\n+\n /* Build an argument vector from a string.  Allocates memory using\n    malloc.  Use freeargv to free the vector.  */\n \n@@ -314,6 +316,166 @@ extern void hex_init (void);\n    the argument being performed exactly once.  */\n #define hex_value(c)\t((unsigned int) _hex_value[(unsigned char) (c)])\n \n+/* Flags for pex_init.  These are bits to be or'ed together.  */\n+\n+/* Record subprocess times, if possible.  */\n+#define PEX_RECORD_TIMES\t0x1\n+\n+/* Use pipes for communication between processes, if possible.  */\n+#define PEX_USE_PIPES\t\t0x2\n+\n+/* Save files used for communication between processes.  */\n+#define PEX_SAVE_TEMPS\t\t0x4\n+\n+/* Prepare to execute one or more programs, with standard output of\n+   each program fed to standard input of the next.\n+   FLAGS\tAs above.\n+   PNAME\tThe name of the program to report in error messages.\n+   TEMPBASE\tA base name to use for temporary files; may be NULL to\n+   \t\tuse a random name.\n+   Returns NULL on error.  */\n+\n+extern struct pex_obj *pex_init (int flags, const char *pname,\n+\t\t\t\t const char *tempbase);\n+\n+/* Flags for pex_run.  These are bits to be or'ed together.  */\n+\n+/* Last program in pipeline.  Standard output of program goes to\n+   OUTNAME, or, if OUTNAME is NULL, to standard output of caller.  Do\n+   not set this if you want to call pex_read_output.  After this is\n+   set, pex_run may no longer be called with the same struct\n+   pex_obj.  */\n+#define PEX_LAST\t\t0x1\n+\n+/* Search for program in executable search path.  */\n+#define PEX_SEARCH\t\t0x2\n+\n+/* OUTNAME is a suffix.  */\n+#define PEX_SUFFIX\t\t0x4\n+\n+/* Send program's standard error to standard output.  */\n+#define PEX_STDERR_TO_STDOUT\t0x8\n+\n+/* Input file should be opened in binary mode.  This flag is ignored\n+   on Unix.  */\n+#define PEX_BINARY_INPUT\t0x10\n+\n+/* Output file should be opened in binary mode.  This flag is ignored\n+   on Unix.  For proper behaviour PEX_BINARY_INPUT and\n+   PEX_BINARY_OUTPUT have to match appropriately--i.e., a call using\n+   PEX_BINARY_OUTPUT should be followed by a call using\n+   PEX_BINARY_INPUT.  */\n+#define PEX_BINARY_OUTPUT\t0x20\n+\n+/* Execute one program.  Returns NULL on success.  On error returns an\n+   error string (typically just the name of a system call); the error\n+   string is statically allocated.\n+\n+   OBJ\t\tReturned by pex_init.\n+\n+   FLAGS\tAs above.\n+\n+   EXECUTABLE\tThe program to execute.\n+\n+   ARGV\t\tNULL terminated array of arguments to pass to the program.\n+\n+   OUTNAME\tSets the output file name as follows:\n+\n+\t\tPEX_SUFFIX set (OUTNAME may not be NULL):\n+\t\t  TEMPBASE parameter to pex_init not NULL:\n+\t\t    Output file name is the concatenation of TEMPBASE\n+\t\t    and OUTNAME.\n+\t\t  TEMPBASE is NULL:\n+\t\t    Output file name is a random file name ending in\n+\t\t    OUTNAME.\n+\t\tPEX_SUFFIX not set:\n+\t\t  OUTNAME not NULL:\n+\t\t    Output file name is OUTNAME.\n+\t\t  OUTNAME NULL, TEMPBASE not NULL:\n+\t\t    Output file name is randomly chosen using\n+\t\t    TEMPBASE.\n+\t\t  OUTNAME NULL, TEMPBASE NULL:\n+\t\t    Output file name is randomly chosen.\n+\n+\t\tIf PEX_LAST is not set, the output file name is the\n+   \t\tname to use for a temporary file holding stdout, if\n+   \t\tany (there will not be a file if PEX_USE_PIPES is set\n+   \t\tand the system supports pipes).  If a file is used, it\n+   \t\twill be removed when no longer needed unless\n+   \t\tPEX_SAVE_TEMPS is set.\n+\n+\t\tIf PEX_LAST is set, and OUTNAME is not NULL, standard\n+   \t\toutput is written to the output file name.  The file\n+   \t\twill not be removed.  If PEX_LAST and PEX_SUFFIX are\n+   \t\tboth set, TEMPBASE may not be NULL.\n+\n+   ERRNAME\tIf not NULL, this is the name of a file to which\n+\t\tstandard error is written.  If NULL, standard error of\n+\t\tthe program is standard error of the caller.\n+\n+   ERR\t\tOn an error return, *ERR is set to an errno value, or\n+   \t\tto 0 if there is no relevant errno.\n+*/\n+\n+extern const char *pex_run (struct pex_obj *obj, int flags,\n+\t\t\t    const char *executable, char * const *argv,\n+\t\t\t    const char *outname, const char *errname,\n+\t\t\t    int *err);\n+\n+/* Read the standard output of the last program to be executed.\n+   pex_run can not be called after this.  BINARY should be non-zero if\n+   the file should be opened in binary mode; this is ignored on Unix.\n+   Returns NULL on error.  Don't call fclose on the returned FILE; it\n+   will be closed by pex_free.  */\n+\n+extern FILE *pex_read_output (struct pex_obj *, int binary);\n+\n+/* Return exit status of all programs in VECTOR.  COUNT indicates the\n+   size of VECTOR.  The status codes in the vector are in the order of\n+   the calls to pex_run.  Returns 0 on error, 1 on success.  */\n+\n+extern int pex_get_status (struct pex_obj *, int count, int *vector);\n+\n+/* Return times of all programs in VECTOR.  COUNT indicates the size\n+   of VECTOR.  struct pex_time is really just struct timeval, but that\n+   is not portable to all systems.  Returns 0 on error, 1 on\n+   success.  */\n+\n+struct pex_time\n+{\n+  unsigned long user_seconds;\n+  unsigned long user_microseconds;\n+  unsigned long system_seconds;\n+  unsigned long system_microseconds;\n+};\n+\n+extern int pex_get_times (struct pex_obj *, int count,\n+\t\t\t  struct pex_time *vector);\n+\n+/* Clean up a pex_obj.  */\n+\n+  extern void pex_free (struct pex_obj *);\n+\n+/* Just execute one program.  Return value is as for pex_run.\n+   FLAGS\tCombination of PEX_SEARCH and PEX_STDERR_TO_STDOUT.\n+   EXECUTABLE\tAs for pex_run.\n+   ARGV\t\tAs for pex_run.\n+   PNAME\tAs for pex_init.\n+   OUTNAME\tAs for pex_run when PEX_LAST is set.\n+   ERRNAME\tAs for pex_run.\n+   STATUS\tSet to exit status on success.\n+   ERR\t\tAs for pex_run.\n+*/\n+\n+extern const char *pex_one (int flags, const char *executable,\n+\t\t\t    char * const *argv, const char *pname,\n+\t\t\t    const char *outname, const char *errname,\n+\t\t\t    int *status, int *err);\n+\n+/* pexecute and pwait are the old pexecute interface, still here for\n+   backward compatibility.  Don't use these for new code.  Instead,\n+   use pex_init/pex_run/pex_get_status/pex_free, or pex_one.  */\n+\n /* Definitions used by the pexecute routine.  */\n \n #define PEXECUTE_FIRST   1"}, {"sha": "412a4aaa5d8c1247cc9e999c3fe5f2a54452ea3f", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -1,3 +1,28 @@\n+2005-03-28  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* pex-common.c: New file.\n+\t* pex-one.c: New file.\n+\t* pexecute.c: New file.\n+\t* pex-common.h: Include <stdio.h>.\n+\t(struct pex_obj): Define.\n+\t(struct pex_funcs): Define.\n+\t(pex_init_common): Declare.\n+\t* pex-unix.c: Rewrite.\n+\t* pex-win32.c: Rewrite.\n+\t* pex-djgpp.c: Rewrite.\n+\t* pex-msdos.c: Rewrite.\n+\t* testsuite/text-pexecute.c: New file.\n+\t* pexecute.txh: Rewrite.\n+\t* configure.ac: Check for wait3 and wait4.  Set CHECK to\n+\treally-check rather than check-cplus-dem.\n+\t* functions.texi: Rebuild.\n+\t* Makefile.in: Rebuild dependencies.\n+\t(CFILES): Add pexecute.c, pex-common.c, pex-one.c.\n+\t(REQUIRED_OFILES): Add pexecute.o, pex-common.o, pex-one.o.\n+\t* testsuite/Makefile.in (really-check): New target.\n+\t(check-pexecute, test-pexecute): New targets.\n+\t* configure: Rebuild.\n+\n 2005-03-28  Mark Kettenis  <kettenis@gnu.org>\n \t\n \t* unlink-if-ordinary.c: Include <sys/types.h>."}, {"sha": "78957ee466298c29a1d52e1865134d15aa73de26", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -142,8 +142,8 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \tmake-temp-file.c md5.c memchr.c memcmp.c memcpy.c memmove.c\t\\\n \t mempcpy.c memset.c mkstemps.c\t\t\t\t\t\\\n \tobjalloc.c obstack.c\t\t\t\t\t\t\\\n-\tpartition.c\t\t\t\t\t\t\t\\\n-\t pex-djgpp.c pex-msdos.c\t\t\t\t\t\\\n+\tpartition.c pexecute.c\t\t\t\t\t\t\\\n+\t pex-common.c pex-djgpp.c pex-msdos.c pex-one.c\t\t\t\\\n \t pex-unix.c pex-win32.c\t\t\t\t\t\t\\\n          physmem.c putenv.c\t\t\t\t\t\t\\\n \trandom.c regex.c rename.c rindex.c\t\t\t\t\\\n@@ -170,7 +170,8 @@ REQUIRED_OFILES = ./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o\t\\\n \t./lbasename.o ./lrealpath.o\t\t\t\t\t\\\n \t./make-relative-prefix.o ./make-temp-file.o\t\t\t\\\n \t./objalloc.o ./obstack.o\t\t\t\t\t\\\n-\t./partition.o ./physmem.o @pexecute@\t\t\t\t\\\n+\t./partition.o ./pexecute.o ./physmem.o\t\t\t\t\\\n+\t./pex-common.o ./pex-one.o @pexecute@\t\t\t\t\\\n \t./safe-ctype.o ./sort.o ./spaces.o ./splay-tree.o ./strerror.o\t\\\n \t ./strsignal.o\t\t\t\t\t\t\t\\\n \t./ternary.o\t\t\t\t\t\t\t\\\n@@ -756,6 +757,13 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/partition.c $(OUTPUT_OPTION)\n \n+./pex-common.o: $(srcdir)/pex-common.c config.h $(INCDIR)/ansidecl.h \\\n+\t$(INCDIR)/libiberty.h $(srcdir)/pex-common.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-common.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/pex-common.c $(OUTPUT_OPTION)\n+\n ./pex-djgpp.o: $(srcdir)/pex-djgpp.c config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h $(srcdir)/pex-common.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n@@ -771,6 +779,13 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/pex-msdos.c $(OUTPUT_OPTION)\n \n+./pex-one.o: $(srcdir)/pex-one.c config.h $(INCDIR)/ansidecl.h \\\n+\t$(INCDIR)/libiberty.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-one.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/pex-one.c $(OUTPUT_OPTION)\n+\n ./pex-unix.o: $(srcdir)/pex-unix.c config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h $(srcdir)/pex-common.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n@@ -785,6 +800,13 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/pex-win32.c $(OUTPUT_OPTION)\n \n+./pexecute.o: $(srcdir)/pexecute.c config.h $(INCDIR)/ansidecl.h \\\n+\t$(INCDIR)/libiberty.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/pexecute.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/pexecute.c $(OUTPUT_OPTION)\n+\n ./physmem.o: $(srcdir)/physmem.c config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\"}, {"sha": "f76d3c5732f4e18490a2a8a0a44749a8153275f2", "filename": "libiberty/configure", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -4818,7 +4818,7 @@ vars=\"sys_errlist sys_nerr sys_siglist\"\n \n checkfuncs=\"getrusage on_exit psignal strerror strsignal sysconf times sbrk gettimeofday\"\n checkfuncs=\"$checkfuncs realpath canonicalize_file_name pstat_getstatic pstat_getdynamic sysmp\"\n-checkfuncs=\"$checkfuncs getsysinfo table sysctl\"\n+checkfuncs=\"$checkfuncs getsysinfo table sysctl wait3 wait4\"\n \n # These are neither executed nor required, but they help keep\n # autoheader happy without adding a bunch of text to acconfig.h.\n@@ -4895,7 +4895,7 @@ for ac_func in asprintf atexit basename bcmp bcopy bsearch bzero calloc clock \\\n   strtod strtol strtoul tmpnam vasprintf vfprintf vprintf \\\n   vsprintf waitpid getrusage on_exit psignal strerror strsignal \\\n   sysconf times sbrk gettimeofday ffs snprintf vsnprintf \\\n-  pstat_getstatic pstat_getdynamic sysmp getsysinfo table sysctl \\\n+  pstat_getstatic pstat_getdynamic sysmp getsysinfo table sysctl wait3 wait4 \\\n   realpath canonicalize_file_name\n do\n as_ac_var=`echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n@@ -5133,7 +5133,7 @@ fi;\n else\n \n    # Not a target library, so we set things up to run the test suite.\n-   CHECK=check-cplus-dem\n+   CHECK=really-check\n \n fi\n "}, {"sha": "6c4347da36c6141f6ae5e63dea8e4d2afed0438e", "filename": "libiberty/configure.ac", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.ac?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -268,7 +268,7 @@ vars=\"sys_errlist sys_nerr sys_siglist\"\n \n checkfuncs=\"getrusage on_exit psignal strerror strsignal sysconf times sbrk gettimeofday\"\n checkfuncs=\"$checkfuncs realpath canonicalize_file_name pstat_getstatic pstat_getdynamic sysmp\"\n-checkfuncs=\"$checkfuncs getsysinfo table sysctl\"\n+checkfuncs=\"$checkfuncs getsysinfo table sysctl wait3 wait4\"\n \n # These are neither executed nor required, but they help keep\n # autoheader happy without adding a bunch of text to acconfig.h.\n@@ -280,7 +280,7 @@ if test \"x\" = \"y\"; then\n   strtod strtol strtoul tmpnam vasprintf vfprintf vprintf \\\n   vsprintf waitpid getrusage on_exit psignal strerror strsignal \\\n   sysconf times sbrk gettimeofday ffs snprintf vsnprintf \\\n-  pstat_getstatic pstat_getdynamic sysmp getsysinfo table sysctl \\\n+  pstat_getstatic pstat_getdynamic sysmp getsysinfo table sysctl wait3 wait4 \\\n   realpath canonicalize_file_name)\n   AC_DEFINE(HAVE_SYS_ERRLIST, 1, [Define if you have the sys_errlist variable.])\n   AC_DEFINE(HAVE_SYS_NERR,    1, [Define if you have the sys_nerr variable.])\n@@ -357,7 +357,7 @@ if test -n \"${with_target_subdir}\"; then\n else\n \n    # Not a target library, so we set things up to run the test suite.\n-   CHECK=check-cplus-dem\n+   CHECK=really-check\n \n fi\n "}, {"sha": "a886b8857040cb125e4687106330cb164778f73c", "filename": "libiberty/functions.texi", "status": "modified", "additions": 197, "deletions": 61, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -3,7 +3,7 @@\n @c Edit the *.c files, configure with --enable-maintainer-mode,\n @c and let gather-docs build you a new copy.\n \n-@c safe-ctype.c:24\n+@c safe-ctype.c:25\n @defvr Extension HOST_CHARSET\n This macro indicates the basic character set and encoding used by the\n host: more precisely, the encoding used for character constants in\n@@ -25,6 +25,139 @@ nineteen EBCDIC varying characters is tested; exercise caution.)\n @end ftable\n @end defvr\n \n+@c pexecute.txh:1\n+@deftypefn Extension struct pex_obj *pex_init (int @var{flags}, const char *@var{pname}, const char *@var{tempbase})\n+\n+Prepare to execute one or more programs, with standard output of each\n+program fed to standard input of the next.  This is a system\n+independent interface to execute a pipeline.\n+\n+@var{flags} is a bitwise combination of the following:\n+\n+@table @code\n+\n+@vindex PEX_RECORD_TIMES\n+@item PEX_RECORD_TIMES\n+Record subprocess times if possible.\n+\n+@vindex PEX_USE_PIPES\n+@item PEX_USE_PIPES\n+Use pipes for communication between processes, if possible.\n+\n+@vindex PEX_SAVE_TEMPS\n+@item PEX_SAVE_TEMPS\n+Don't delete temporary files used for communication between\n+processes.\n+\n+@end table\n+\n+@var{pname} is the name of program to be executed, used in error\n+messages.  @var{tempbase} is a base name to use for any required\n+temporary files; it may be @code{NULL} to use a randomly chosen name.\n+\n+@end deftypefn\n+\n+@c pexecute.txh:161\n+@deftypefn Extension const char *pex_one (int @var{flags}, const char *@var{executable}, char * const *@var{argv}, const char *@var{pname}, const char *@var{outname}, const char *@var{errname}, int *@var{status}, int *@var{err})\n+\n+An interface to @code{pex_init} to permit the easy execution of a\n+single program.  The return value and most of the parameters are as\n+for a call to @code{pex_run}.  @var{flags} is restricted to a\n+combination of @code{PEX_SEARCH}, @code{PEX_STDERR_TO_STDOUT}, and\n+@code{PEX_BINARY_OUTPUT}.  @var{outname} is interpreted as if\n+@code{PEX_LAST} were set.  On a successful return, *@var{status} will\n+be set to the exit status of the program.\n+\n+@end deftypefn\n+\n+@c pexecute.txh:32\n+@deftypefn Extension const char *pex_run (struct pex_obj *@var{obj}, int @var{flags}, const char *@var{executable}, char * const *@var{argv}, const char *@var{outname}, const char *@var{errname}, int *@var{err})\n+\n+Execute one program in a pipeline.  On success this returns\n+@code{NULL}.  On failure it returns an error message, a statically\n+allocated string.\n+\n+@var{obj} is returned by a previous call to @code{pex_init}.\n+\n+@var{flags} is a bitwise combination of the following:\n+\n+@table @code\n+\n+@vindex PEX_LAST\n+@item PEX_LAST\n+This must be set on the last program in the pipeline.  In particular,\n+it should be set when executing a single program.  The standard output\n+of the program will be sent to @var{outname}, or, if @var{outname} is\n+@code{NULL}, to the standard output of the calling program.  This\n+should not be set if you want to call @code{pex_read_output}\n+(described below).  After a call to @code{pex_run} with this bit set,\n+@var{pex_run} may no longer be called with the same @var{obj}.\n+\n+@vindex PEX_SEARCH\n+@item PEX_SEARCH\n+Search for the program using the user's executable search path.\n+\n+@vindex PEX_SUFFIX\n+@item PEX_SUFFIX\n+@var{outname} is a suffix.  See the description of @var{outname},\n+below.\n+\n+@vindex PEX_STDERR_TO_STDOUT\n+@item PEX_STDERR_TO_STDOUT\n+Send the program's standard error to standard output, if possible.\n+\n+@vindex PEX_BINARY_INPUT\n+@vindex PEX_BINARY_OUTPUT\n+@item PEX_BINARY_INPUT\n+@itemx PEX_BINARY_OUTPUT\n+The standard input (output) of the program should be read (written) in\n+binary mode rather than text mode.  These flags are ignored on systems\n+which do not distinguish binary mode and text mode, such as Unix.  For\n+proper behavior these flags should match appropriately--a call to\n+@code{pex_run} using @code{PEX_BINARY_OUTPUT} should be followed by a\n+call using @code{PEX_BINARY_INPUT}.\n+@end table\n+\n+@var{executable} is the program to execute.  @var{argv} is the set of\n+arguments to pass to the program; normally @code{@var{argv}[0]} will\n+be a copy of @var{executable}.\n+\n+@var{outname} is used to set the name of the file to use for standard\n+output.  There are two cases in which no output file will be used: 1)\n+if @code{PEX_LAST} is not set in @var{flags}, and @code{PEX_USE_PIPES}\n+was set in the call to @code{pex_init}, and the system supports pipes;\n+2) if @code{PEX_LAST} is set in @var{flags}, and @var{outname} is\n+@code{NULL}.  Otherwise the code will use a file to hold standard\n+output.  If @code{PEX_LAST} is not set, this file is considered to be\n+a temporary file, and it will be removed when no longer needed, unless\n+@code{PEX_SAVE_TEMPS} was set in the call to @code{pex_init}.\n+\n+There are two cases to consider when setting the name of the file to\n+hold standard output.\n+\n+First case: @code{PEX_SUFFIX} is set in @var{flags}.  In this case\n+@var{outname} may not be @code{NULL}.  If the @var{tempbase} parameter\n+to @code{pex_init} was not @code{NULL}, then the output file name is\n+the concatenation of @var{tempbase} and @var{outname}.  If\n+@var{tempbase} was @code{NULL}, then the output file name is a random\n+file name ending in @var{outname}.\n+\n+Second case: @code{PEX_SUFFIX} was not set in @var{flags}.  In this\n+case, if @var{outname} is not @code{NULL}, it is used as the output\n+file name.  If @var{outname} is @code{NULL}, and @var{tempbase} was\n+not NULL, the output file name is randomly chosen using\n+@var{tempbase}.  Otherwise the output file name is chosen completely\n+at random.\n+\n+@var{errname} is the file name to use for standard error output.  If\n+it is @code{NULL}, standard error is the same as the caller.\n+Otherwise, standard error is written to the named file.\n+\n+On an error return, the code sets @code{*@var{err}} to an @code{errno}\n+value, or to 0 if there is no relevant @code{errno}.\n+\n+@end deftypefn\n+\n @c alloca.c:26\n @deftypefn Replacement void* alloca (size_t @var{size})\n \n@@ -43,7 +176,7 @@ the possibility of a GCC built-in function.\n \n @end deftypefn\n \n-@c asprintf.c:33\n+@c asprintf.c:29\n @deftypefn Extension int asprintf (char **@var{resptr}, const char *@var{format}, ...)\n \n Like @code{sprintf}, but instead of passing a pointer to a buffer, you\n@@ -104,7 +237,7 @@ is respectively less than, matching, or greater than the array member.\n \n @end deftypefn\n \n-@c argv.c:139\n+@c argv.c:121\n @deftypefn Extension char** buildargv (char *@var{sp})\n \n Given a pointer to a string, parse the string extracting fields\n@@ -158,7 +291,7 @@ not recommended.\n \n @end deftypefn\n \n-@c make-temp-file.c:88\n+@c make-temp-file.c:87\n @deftypefn Replacement char* choose_tmpdir ()\n \n Returns a pointer to a directory path suitable for creating temporary\n@@ -185,7 +318,7 @@ pointer encountered.  Pointers to empty strings are ignored.\n \n @end deftypefn\n \n-@c argv.c:65\n+@c argv.c:49\n @deftypefn Extension char** dupargv (char **@var{vector})\n \n Duplicate an argument vector.  Simply scans through @var{vector},\n@@ -288,7 +421,7 @@ Ignores case when performing the comparison.\n \n @end deftypefn\n \n-@c argv.c:111\n+@c argv.c:94\n @deftypefn Extension void freeargv (char **@var{vector})\n \n Free an argument vector that was built using @code{buildargv}.  Simply\n@@ -412,7 +545,7 @@ struct qelem @{\n \n @end deftypefn\n \n-@c safe-ctype.c:45\n+@c safe-ctype.c:46\n @deffn  Extension ISALPHA  (@var{c})\n @deffnx Extension ISALNUM  (@var{c})\n @deffnx Extension ISBLANK  (@var{c})\n@@ -462,7 +595,7 @@ false for characters with numeric values from 128 to 255.\n @end itemize\n @end deffn\n \n-@c safe-ctype.c:94\n+@c safe-ctype.c:95\n @deffn  Extension ISIDNUM         (@var{c})\n @deffnx Extension ISIDST          (@var{c})\n @deffnx Extension IS_VSPACE       (@var{c})\n@@ -535,7 +668,7 @@ relative prefix can be found, return @code{NULL}.\n \n @end deftypefn\n \n-@c make-temp-file.c:138\n+@c make-temp-file.c:137\n @deftypefn Replacement char* make_temp_file (const char *@var{suffix})\n \n Return a temporary file name (as a string) or @code{NULL} if unable to\n@@ -618,46 +751,62 @@ reading and writing.\n \n @end deftypefn\n \n-@c pexecute.txh:1\n-@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n+@c pexecute.txh:155\n+@deftypefn Extension void pex_free (struct pex_obj @var{obj})\n \n-Executes a program.\n+Clean up and free all data associated with @var{obj}.\n \n-@var{program} and @var{argv} are the arguments to\n-@code{execv}/@code{execvp}.\n+@end deftypefn\n \n-@var{this_pname} is name of the calling program (i.e., @code{argv[0]}).\n+@c pexecute.txh:131\n+@deftypefn Extension int pex_get_status (struct pex_obj *@var{obj}, int @var{count}, int *@var{vector})\n \n-@var{temp_base} is the path name, sans suffix, of a temporary file to\n-use if needed.  This is currently only needed for MS-DOS ports that\n-don't use @code{go32} (do any still exist?).  Ports that don't need it\n-can pass @code{NULL}.\n+Returns the exit status of all programs run using @var{obj}.\n+@var{count} is the number of results expected.  The results will be\n+placed into @var{vector}.  The results are in the order of the calls\n+to @code{pex_run}.  Returns 0 on error, 1 on success.\n \n-(@code{@var{flags} & PEXECUTE_SEARCH}) is non-zero if @env{PATH}\n-should be searched (??? It's not clear that GCC passes this flag\n-correctly).  (@code{@var{flags} & PEXECUTE_FIRST}) is nonzero for the\n-first process in chain.  (@code{@var{flags} & PEXECUTE_FIRST}) is\n-nonzero for the last process in chain.  The first/last flags could be\n-simplified to only mark the last of a chain of processes but that\n-requires the caller to always mark the last one (and not give up\n-early if some error occurs).  It's more robust to require the caller\n-to mark both ends of the chain.\n+@end deftypefn\n \n-The result is the pid on systems like Unix where we\n-@code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we\n-use @code{spawn}.  It is up to the caller to wait for the child.\n+@c pexecute.txh:140\n+@deftypefn Extension int pex_get_times (struct pex_obj *@var{obj}, int @var{count}, struct pex_time *@var{vector})\n \n-The result is the @code{WEXITSTATUS} on systems like MS-DOS where we\n-@code{spawn} and wait for the child here.\n+Returns the process execution times of all programs run using\n+@var{obj}.  @var{count} is the number of results expected.  The\n+results will be placed into @var{vector}.  The results are in the\n+order of the calls to @code{pex_run}.  Returns 0 on error, 1 on\n+success.\n \n-Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the\n-text of the error message with an optional argument (if not needed,\n-@var{errmsg_arg} is set to @code{NULL}), and @minus{}1 is returned.\n-@code{errno} is available to the caller to use.\n+@code{struct pex_time} has the following fields: @code{user_seconds},\n+@code{user_microseconds}, @code{system_seconds},\n+@code{system_microseconds}.  On systems which do not support reporting\n+process times, all the fields will be set to @code{0}.\n \n @end deftypefn\n \n-@c strsignal.c:546\n+@c pexecute.txh:119\n+@deftypefn Extension FILE * pex_read_output (struct pex_obj *@var{obj}, int @var{binary})\n+\n+Returns a @code{FILE} pointer which may be used to read the standard\n+output of the last program in the pipeline.  When this is used,\n+@code{PEX_LAST} should not be used in a call to @code{pex_run}.  After\n+this is called, @code{pex_run} may no longer be called with the same\n+@var{obj}.  @var{binary} should be non-zero if the file should be\n+opened in binary mode.  Don't call @code{fclose} on the returned file;\n+it will be closed by @code{pex_free}.\n+\n+@end deftypefn\n+\n+@c pexecute.txh:173\n+@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n+\n+This is the old interface to execute one or more programs.  It is\n+still supported for compatibility purposes, but is no longer\n+documented.\n+\n+@end deftypefn\n+\n+@c strsignal.c:539\n @deftypefn Supplemental void psignal (unsigned @var{signo}, char *@var{message})\n \n Print @var{message} to the standard error, followed by a colon,\n@@ -676,23 +825,10 @@ name is unset/removed.\n \n @end deftypefn\n \n-@c pexecute.txh:39\n+@c pexecute.txh:181\n @deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n \n-Waits for a program started by @code{pexecute} to finish.\n-\n-@var{pid} is the process id of the task to wait for. @var{status} is\n-the `status' argument to wait. @var{flags} is currently unused\n-(allows future enhancement without breaking upward compatibility).\n-Pass 0 for now.\n-\n-The result is the pid of the child reaped, or -1 for failure\n-(@code{errno} says why).\n-\n-On systems that don't support waiting for a particular child,\n-@var{pid} is ignored.  On systems like MS-DOS that don't really\n-multitask @code{pwait} is just a mechanism to provide a consistent\n-interface for the caller.\n+Another part of the old execution interface.\n \n @end deftypefn\n \n@@ -711,7 +847,7 @@ control over the state of the random number generator.\n \n @end deftypefn\n \n-@c concat.c:177\n+@c concat.c:167\n @deftypefn Extension char* reconcat (char *@var{optr}, const char *@var{s1}, @dots{}, @code{NULL})\n \n Same as @code{concat}, except that if @var{optr} is not @code{NULL} it\n@@ -754,7 +890,7 @@ environment.  This implementation is not safe for multithreaded code.\n \n @end deftypefn\n \n-@c strsignal.c:352\n+@c strsignal.c:348\n @deftypefn Extension int signo_max (void)\n \n Returns the maximum signal value for which a corresponding symbolic\n@@ -845,7 +981,7 @@ Returns a pointer to a copy of @var{s} in memory obtained from\n \n @end deftypefn\n \n-@c strerror.c:671\n+@c strerror.c:670\n @deftypefn Replacement {const char*} strerrno (int @var{errnum})\n \n Given an error number returned from a system call (typically returned\n@@ -919,7 +1055,7 @@ null character, the results are undefined.\n \n @end deftypefn\n \n-@c strsignal.c:387\n+@c strsignal.c:383\n @deftypefn Supplemental {const char *} strsignal (int @var{signo})\n \n Maps an signal number to an signal message string, the contents of\n@@ -940,7 +1076,7 @@ call to @code{strsignal}.\n \n @end deftypefn\n \n-@c strsignal.c:451\n+@c strsignal.c:446\n @deftypefn Extension {const char*} strsigno (int @var{signo})\n \n Given an signal number, returns a pointer to a string containing the\n@@ -982,7 +1118,7 @@ the location referenced by @var{endptr}.\n \n @end deftypefn\n \n-@c strerror.c:731\n+@c strerror.c:729\n @deftypefn Extension int strtoerrno (const char *@var{name})\n \n Given the symbolic name of a error number (e.g., @code{EACCES}), map it\n@@ -1006,7 +1142,7 @@ that the converted value is unsigned.\n \n @end deftypefn\n \n-@c strsignal.c:506\n+@c strsignal.c:500\n @deftypefn Extension int strtosigno (const char *@var{name})\n \n Given the symbolic name of a signal, map it to a signal number.  If no\n@@ -1035,7 +1171,7 @@ was made to unlink the file because it is special.\n \n @end deftypefn\n \n-@c vasprintf.c:51\n+@c vasprintf.c:47\n @deftypefn Extension int vasprintf (char **@var{resptr}, const char *@var{format}, va_list @var{args})\n \n Like @code{vsprintf}, but instead of passing a pointer to a buffer,"}, {"sha": "e02dcedbd9e356a6a6bb212311c241950f408748", "filename": "libiberty/pex-common.c", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-common.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -0,0 +1,472 @@\n+/* Common code for executing a program in a sub-process.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor <ian@airs.com>.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+#include \"pex-common.h\"\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#ifdef NEED_DECLARATION_ERRNO\n+extern int errno;\n+#endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+extern int mkstemps (char *, int);\n+\n+/* This file contains subroutines for the program execution routines\n+   (pex_init, pex_run, etc.).  This file is compiled on all\n+   systems.  */\n+\n+static void pex_add_remove (struct pex_obj *, const char *, int);\n+static int pex_get_status_and_time (struct pex_obj *, int, const char **,\n+\t\t\t\t    int *);\n+\n+/* Initialize a pex_obj structure.  */\n+\n+struct pex_obj *\n+pex_init_common (int flags, const char *pname, const char *tempbase,\n+\t\t const struct pex_funcs *funcs)\n+{\n+  struct pex_obj *obj;\n+\n+  obj = xmalloc (sizeof (*obj));\n+  obj->flags = flags;\n+  obj->pname = pname;\n+  obj->tempbase = tempbase;\n+  obj->next_input = STDIN_FILE_NO;\n+  obj->next_input_name = NULL;\n+  obj->next_input_name_allocated = 0;\n+  obj->count = 0;\n+  obj->children = NULL;\n+  obj->status = NULL;\n+  obj->time = NULL;\n+  obj->number_waited = 0;\n+  obj->read_output = NULL;\n+  obj->remove_count = 0;\n+  obj->remove = NULL;\n+  obj->funcs = funcs;\n+  obj->sysdep = NULL;\n+  return obj;\n+}\n+\n+/* Add a file to be removed when we are done.  */\n+\n+static void\n+pex_add_remove (struct pex_obj *obj, const char *name, int allocated)\n+{\n+  char *add;\n+\n+  ++obj->remove_count;\n+  obj->remove = xrealloc (obj->remove, obj->remove_count * sizeof (char *));\n+  if (allocated)\n+    add = (char *) name;\n+  else\n+    add = xstrdup (name);\n+  obj->remove[obj->remove_count - 1] = add;\n+}\n+\n+/* Run a program.  */\n+\n+const char *\n+pex_run (struct pex_obj *obj, int flags, const char *executable,\n+\t char * const * argv, const char *orig_outname, const char *errname,\n+\t int *err)\n+{\n+  const char *errmsg;\n+  int in, out, errdes;\n+  char *outname;\n+  int outname_allocated;\n+  int p[2];\n+  long pid;\n+\n+  in = -1;\n+  out = -1;\n+  errdes = -1;\n+  outname = (char *) orig_outname;\n+  outname_allocated = 0;\n+\n+  /* Set IN.  */\n+\n+  if (obj->next_input_name != NULL)\n+    {\n+      /* We have to make sure that the previous process has completed\n+\t before we try to read the file.  */\n+      if (!pex_get_status_and_time (obj, 0, &errmsg, err))\n+\tgoto error_exit;\n+\n+      in = obj->funcs->open_read (obj, obj->next_input_name,\n+\t\t\t\t  (flags & PEX_BINARY_INPUT) != 0);\n+      if (in < 0)\n+\t{\n+\t  *err = errno;\n+\t  errmsg = \"open temporary file\";\n+\t  goto error_exit;\n+\t}\n+      if (obj->next_input_name_allocated)\n+\t{\n+\t  free (obj->next_input_name);\n+\t  obj->next_input_name_allocated = 0;\n+\t}\n+      obj->next_input_name = NULL;\n+    }\n+  else\n+    {\n+      in = obj->next_input;\n+      if (in < 0)\n+\t{\n+\t  *err = 0;\n+\t  errmsg = \"pipeline already complete\";\n+\t  goto error_exit;\n+\t}\n+    }\n+\n+  /* Set OUT and OBJ->NEXT_INPUT/OBJ->NEXT_INPUT_NAME.  */\n+\n+  if ((flags & PEX_LAST) != 0)\n+    {\n+      if (outname == NULL)\n+\tout = STDOUT_FILE_NO;\n+      else if ((flags & PEX_SUFFIX) != 0)\n+\t{\n+\t  outname = concat (obj->tempbase, outname, NULL);\n+\t  outname_allocated = 1;\n+\t}\n+      obj->next_input = -1;\n+    }\n+  else if ((obj->flags & PEX_USE_PIPES) == 0)\n+    {\n+      if (outname == NULL)\n+\t{\n+\t  if (obj->tempbase == NULL)\n+\t    {\n+\t      outname = make_temp_file (NULL);\n+\t      outname_allocated = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      int len = strlen (obj->tempbase);\n+\n+\t      if (len >= 6\n+\t\t  && strcmp (obj->tempbase + len - 6, \"XXXXXX\") == 0)\n+\t\toutname = xstrdup (obj->tempbase);\n+\t      else\n+\t\toutname = concat (obj->tempbase, \"XXXXXX\", NULL);\n+\n+\t      outname_allocated = 1;\n+\n+\t      out = mkstemps (outname, 0);\n+\t      if (out < 0)\n+\t\t{\n+\t\t  *err = 0;\n+\t\t  errmsg = \"could not create temporary output file\";\n+\t\t  goto error_exit;\n+\t\t}\n+\n+\t      /* This isn't obj->funcs->close because we got the\n+\t\t descriptor from mkstemps, not from a function in\n+\t\t obj->funcs.  Calling close here is just like what\n+\t\t make_temp_file does.  */\n+\t      close (out);\n+\t      out = -1;\n+\t    }\n+\t}\n+      else if ((flags & PEX_SUFFIX) != 0)\n+\t{\n+\t  if (obj->tempbase == NULL)\n+\t    outname = make_temp_file (outname);\n+\t  else\n+\t    outname = concat (obj->tempbase, outname, NULL);\n+\t  outname_allocated = 1;\n+\t}\n+\n+      if ((obj->flags & PEX_SAVE_TEMPS) == 0)\n+\t{\n+\t  pex_add_remove (obj, outname, outname_allocated);\n+\t  outname_allocated = 0;\n+\t}\n+\n+      if (!outname_allocated)\n+\t{\n+\t  obj->next_input_name = outname;\n+\t  obj->next_input_name_allocated = 0;\n+\t}\n+      else\n+\t{\n+\t  obj->next_input_name = outname;\n+\t  outname_allocated = 0;\n+\t  obj->next_input_name_allocated = 1;\n+\t}\n+    }\n+  else\n+    {\n+      if (obj->funcs->pipe (obj, p, (flags & PEX_BINARY_OUTPUT) != 0) < 0)\n+\t{\n+\t  *err = errno;\n+\t  errmsg = \"pipe\";\n+\t  goto error_exit;\n+\t}\n+\n+      out = p[WRITE_PORT];\n+      obj->next_input = p[READ_PORT];\n+    }\n+\n+  if (out < 0)\n+    {\n+      out = obj->funcs->open_write (obj, outname,\n+\t\t\t\t    (flags & PEX_BINARY_OUTPUT) != 0);\n+      if (out < 0)\n+\t{\n+\t  *err = errno;\n+\t  errmsg = \"open temporary output file\";\n+\t  goto error_exit;\n+\t}\n+    }\n+\n+  if (outname_allocated)\n+    {\n+      free (outname);\n+      outname_allocated = 0;\n+    }\n+\n+  /* Set ERRDES.  */\n+\n+  if (errname == NULL)\n+    errdes = STDERR_FILE_NO;\n+  else\n+    {\n+      /* We assume that stderr is in text mode--it certainly shouldn't\n+\t be controlled by PEX_BINARY_OUTPUT.  If necessary, we can add\n+\t a PEX_BINARY_STDERR flag.  */\n+      errdes = obj->funcs->open_write (obj, errname, 0);\n+      if (errdes < 0)\n+\t{\n+\t  *err = errno;\n+\t  errmsg = \"open error file\";\n+\t  goto error_exit;\n+\t}\n+    }\n+\n+  /* Run the program.  */\n+\n+  pid = obj->funcs->exec_child (obj, flags, executable, argv, in, out, errdes,\n+\t\t\t\t&errmsg, err);\n+  if (pid < 0)\n+    goto error_exit;\n+\n+  ++obj->count;\n+  obj->children = xrealloc (obj->children, obj->count * sizeof (long));\n+  obj->children[obj->count - 1] = pid;\n+\n+  return NULL;\n+\n+ error_exit:\n+  if (in >= 0 && in != STDIN_FILE_NO)\n+    obj->funcs->close (obj, in);\n+  if (out >= 0 && out != STDOUT_FILE_NO)\n+    obj->funcs->close (obj, out);\n+  if (errdes >= 0 && errdes != STDERR_FILE_NO)\n+    obj->funcs->close (obj, errdes);\n+  if (outname_allocated)\n+    free (outname);\n+  return errmsg;\n+}\n+\n+/* Return a FILE pointer for the output of the last program\n+   executed.  */\n+\n+FILE *\n+pex_read_output (struct pex_obj *obj, int binary)\n+{\n+  if (obj->next_input_name != NULL)\n+    {\n+      const char *errmsg;\n+      int err;\n+\n+      /* We have to make sure that the process has completed before we\n+\t try to read the file.  */\n+      if (!pex_get_status_and_time (obj, 0, &errmsg, &err))\n+\t{\n+\t  errno = err;\n+\t  return NULL;\n+\t}\n+\n+      obj->read_output = fopen (obj->next_input_name, binary ? \"rb\" : \"r\");\n+\n+      if (obj->next_input_name_allocated)\n+\t{\n+\t  free (obj->next_input_name);\n+\t  obj->next_input_name_allocated = 0;\n+\t}\n+      obj->next_input_name = NULL;\n+    }\n+  else\n+    {\n+      int o;\n+\n+      o = obj->next_input;\n+      if (o < 0 || o == STDIN_FILE_NO)\n+\treturn NULL;\n+      obj->read_output = obj->funcs->fdopenr (obj, o, binary);\n+      obj->next_input = -1;\n+    }\n+\n+  return obj->read_output;\n+}\n+\n+/* Get the exit status and, if requested, the resource time for all\n+   the child processes.  Return 0 on failure, 1 on success.  */\n+\n+static int\n+pex_get_status_and_time (struct pex_obj *obj, int done, const char **errmsg,\n+\t\t\t int *err)\n+{\n+  int ret;\n+  int i;\n+\n+  if (obj->number_waited == obj->count)\n+    return 1;\n+\n+  obj->status = xrealloc (obj->status, obj->count * sizeof (int));\n+  if ((obj->flags & PEX_RECORD_TIMES) != 0)\n+    obj->time = xrealloc (obj->time, obj->count * sizeof (struct pex_time));\n+\n+  ret = 1;\n+  for (i = obj->number_waited; i < obj->count; ++i)\n+    {\n+      if (obj->funcs->wait (obj, obj->children[i], &obj->status[i],\n+\t\t\t    obj->time == NULL ? NULL : &obj->time[i],\n+\t\t\t    done, errmsg, err) < 0)\n+\tret = 0;\n+    }\n+  obj->number_waited = i;\n+\n+  return ret;\n+}\n+\n+/* Get exit status of executed programs.  */\n+\n+int\n+pex_get_status (struct pex_obj *obj, int count, int *vector)\n+{\n+  if (obj->status == NULL)\n+    {\n+      const char *errmsg;\n+      int err;\n+\n+      if (!pex_get_status_and_time (obj, 0, &errmsg, &err))\n+\treturn 0;\n+    }\n+\n+  if (count > obj->count)\n+    {\n+      memset (vector + obj->count, 0, (count - obj->count) * sizeof (int));\n+      count = obj->count;\n+    }\n+\n+  memcpy (vector, obj->status, count * sizeof (int));\n+\n+  return 1;\n+}\n+\n+/* Get process times of executed programs.  */\n+\n+int\n+pex_get_times (struct pex_obj *obj, int count, struct pex_time *vector)\n+{\n+  if (obj->status == NULL)\n+    {\n+      const char *errmsg;\n+      int err;\n+\n+      if (!pex_get_status_and_time (obj, 0, &errmsg, &err))\n+\treturn 0;\n+    }\n+\n+  if (obj->time == NULL)\n+    return 0;\n+\n+  if (count > obj->count)\n+    {\n+      memset (vector + obj->count, 0,\n+\t      (count - obj->count) * sizeof (struct pex_time));\n+      count = obj->count;\n+    }\n+\n+  memcpy (vector, obj->time, count * sizeof (struct pex_time));\n+\n+  return 1;\n+}\n+\n+/* Free a pex_obj structure.  */\n+\n+void\n+pex_free (struct pex_obj *obj)\n+{\n+  if (obj->next_input >= 0 && obj->next_input != STDIN_FILE_NO)\n+    obj->funcs->close (obj, obj->next_input);\n+\n+  /* If the caller forgot to wait for the children, we do it here, to\n+     avoid zombies.  */\n+  if (obj->status == NULL)\n+    {\n+      const char *errmsg;\n+      int err;\n+\n+      obj->flags &= ~ PEX_RECORD_TIMES;\n+      pex_get_status_and_time (obj, 1, &errmsg, &err);\n+    }\n+\n+  if (obj->next_input_name_allocated)\n+    free (obj->next_input_name);\n+  if (obj->children != NULL)\n+    free (obj->children);\n+  if (obj->status != NULL)\n+    free (obj->status);\n+  if (obj->time != NULL)\n+    free (obj->time);\n+  if (obj->read_output != NULL)\n+    fclose (obj->read_output);\n+\n+  if (obj->remove_count > 0)\n+    {\n+      int i;\n+\n+      for (i = 0; i < obj->remove_count; ++i)\n+\t{\n+\t  remove (obj->remove[i]);\n+\t  free (obj->remove[i]);\n+\t}\n+      free (obj->remove);\n+    }\n+\n+  if (obj->funcs->cleanup != NULL)\n+    obj->funcs->cleanup (obj);\n+\n+  free (obj);\n+}"}, {"sha": "c0b47fe348edfbe068ed1129e0a4c015f6c886a9", "filename": "libiberty/pex-common.h", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-common.h?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"libiberty.h\"\n+#include <stdio.h>\n \n #define install_error_msg \"installation problem, cannot exec `%s'\"\n \n@@ -42,4 +43,87 @@ Boston, MA 02111-1307, USA.  */\n /* value of `pipe': port index for writing.  */\n #define WRITE_PORT 1\n \n+/* The structure used by pex_init and friends.  */\n+\n+struct pex_obj\n+{\n+  /* Flags.  */\n+  int flags;\n+  /* Name of calling program, for error messages.  */\n+  const char *pname;\n+  /* Base name to use for temporary files.  */\n+  const char *tempbase;\n+  /* Pipe to use as stdin for next process.  */\n+  int next_input;\n+  /* File name to use as stdin for next process.  */\n+  char *next_input_name;\n+  /* Whether next_input_name was allocated using malloc.  */\n+  int next_input_name_allocated;\n+  /* Number of child processes.  */\n+  int count;\n+  /* PIDs of child processes; array allocated using maloc.  */\n+  long *children;\n+  /* Exit statuses of child processes; array allocated using malloc.  */\n+  int *status;\n+  /* Time used by child processes; array allocated using malloc.  */\n+  struct pex_time *time;\n+  /* Number of children we have already waited for.  */\n+  int number_waited;\n+  /* FILE created by pex_read_output.  */\n+  FILE *read_output;\n+  /* Number of temporary files to remove.  */\n+  int remove_count;\n+  /* List of temporary files to remove; array allocated using malloc\n+     of strings allocated using malloc.  */\n+  char **remove;\n+  /* Pointers to system dependent functions.  */\n+  const struct pex_funcs *funcs;\n+  /* For use by system dependent code.  */\n+  void *sysdep;\n+};\n+\n+/* Functions passed to pex_run_common.  */\n+\n+struct pex_funcs\n+{\n+  /* Open file NAME for reading.  If BINARY is non-zero, open in\n+     binary mode.  Return >= 0 on success, -1 on error.  */\n+  int (*open_read) (struct pex_obj *, const char *name, int binary);\n+  /* Open file NAME for writing.  If BINARY is non-zero, open in\n+     binary mode.  Return >= 0 on success, -1 on error.  */\n+  int (*open_write) (struct pex_obj *, const char *name, int binary);\n+  /* Execute a child process.  FLAGS, EXECUTABLE, ARGV, ERR are from\n+     pex_run.  IN, OUT, ERRDES are each a descriptor, from open_read,\n+     open_write, or pipe, or they are one of STDIN_FILE_NO,\n+     STDOUT_FILE_NO or STDERR_FILE_NO; if not STD*_FILE_NO, they\n+     should be closed.  The function should handle the\n+     PEX_STDERR_TO_STDOUT flag.  Return >= 0 on success, or -1 on\n+     error and set *ERRMSG and *ERR.  */\n+  long (*exec_child) (struct pex_obj *, int flags, const char *executable,\n+\t\t      char * const * argv, int in, int out, int errdes,\n+\t\t      const char **errmsg, int *err);\n+  /* Close a descriptor.  Return 0 on success, -1 on error.  */\n+  int (*close) (struct pex_obj *, int);\n+  /* Wait for a child to complete, returning exit status in *STATUS\n+     and time in *TIME (if it is not null).  CHILD is from fork.  DONE\n+     is 1 if this is called via pex_free.  ERRMSG and ERR are as in\n+     fork.  Return 0 on success, -1 on error.  */\n+  int (*wait) (struct pex_obj *, long, int *status, struct pex_time *time,\n+\t       int done, const char **errmsg, int *err);\n+  /* Create a pipe (only called if PEX_USE_PIPES is set) storing two\n+     descriptin in *P.  If BINARY is non-zero, open in binary mode.\n+     Return 0 on success, -1 on error.  */\n+  int (*pipe) (struct pex_obj *, int *p, int binary);\n+  /* Get a FILE pointer to read from a file descriptor (only called if\n+     PEX_USE_PIPES is set).  If BINARY is non-zero, open in binary\n+     mode.  Return pointer on success, NULL on error.  */\n+  FILE * (*fdopenr) (struct pex_obj *, int fd, int binary);\n+  /* Free any system dependent data associated with OBJ.  May be\n+     NULL if there is nothing to do.  */\n+  void (*cleanup) (struct pex_obj *);\n+};\n+\n+extern struct pex_obj *pex_init_common (int, const char *, const char *,\n+\t\t\t\t\tconst struct pex_funcs *);\n+\n #endif"}, {"sha": "c15f576f79a24fddf6a5fe3172d0fa033cc64c77", "filename": "libiberty/pex-djgpp.c", "status": "modified", "additions": 230, "deletions": 43, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-djgpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-djgpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-djgpp.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -1,6 +1,6 @@\n /* Utilities to execute a program in a subprocess (possibly linked by pipes\n    with other subprocesses), and wait for it.  DJGPP specialization.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005\n    Free Software Foundation, Inc.\n \n This file is part of the libiberty library.\n@@ -38,59 +38,246 @@ extern int errno;\n #define PWAIT_ERROR EINVAL\n #endif\n \n-/* MSDOS doesn't multitask, but for the sake of a consistent interface\n-   the code behaves like it does.  pexecute runs the program, tucks the\n-   exit code away, and returns a \"pid\".  pwait must be called to fetch the\n-   exit code.  */\n+static int pex_djgpp_open_read (struct pex_obj *, const char *, int);\n+static int pex_djgpp_open_write (struct pex_obj *, const char *, int);\n+static long pex_djgpp_exec_child (struct pex_obj *, int, const char *,\n+\t\t\t\t  char * const *, int, int, int,\n+\t\t\t\t  const char **, int *);\n+static int pex_djgpp_close (struct pex_obj *, int);\n+static int pex_djgpp_wait (struct pex_obj *, long, int *, struct pex_time *,\n+\t\t\t   int, const char **, int *);\n \n-/* For communicating information from pexecute to pwait.  */\n-static int last_pid = 0;\n-static int last_status = 0;\n-static int last_reaped = 0;\n+/* The list of functions we pass to the common routines.  */\n \n-int\n-pexecute (const char *program, char * const *argv, const char *this_pname,\n-          const char *temp_base, char **errmsg_fmt,\n-          char **errmsg_arg, int flags)\n+const struct pex_funcs funcs =\n {\n-  int rc;\n+  pex_djgpp_open_read,\n+  pex_djgpp_open_write,\n+  pex_djgpp_exec_child,\n+  pex_djgpp_close,\n+  pex_djgpp_wait,\n+  NULL, /* pipe */\n+  NULL, /* fdopenr */\n+  NULL  /* cleanup */\n+};\n \n-  last_pid++;\n-  if (last_pid < 0)\n-    last_pid = 1;\n+/* Return a newly initialized pex_obj structure.  */\n \n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n-    abort ();\n+struct pex_obj *\n+pex_init (int flags, const char *pname, const char *tempbase)\n+{\n+  /* DJGPP does not support pipes.  */\n+  flags &= ~ PEX_USE_PIPES;\n+  return pex_init_common (flags, pname, tempbase, funcs);\n+}\n \n-  /* ??? What are the possible return values from spawnv?  */\n-  rc = (flags & PEXECUTE_SEARCH ? spawnvp : spawnv) (P_WAIT, program, argv);\n+/* Open a file for reading.  */\n \n-  if (rc == -1)\n-    {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = (char *)program;\n-      return -1;\n-    }\n+static int\n+pex_djgpp_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED,\n+\t\t     const char *name, int binary)\n+{\n+  return open (name, O_RDONLY | (binary ? O_BINARY : O_TEXT));\n+}\n+\n+/* Open a file for writing.  */\n+\n+static int\n+pex_djgpp_open_write (struct pex_obj *obj ATTRIBUTE_UNUSED,\n+\t\t      const char *name, int binary)\n+{\n+  /* Note that we can't use O_EXCL here because gcc may have already\n+     created the temporary file via make_temp_file.  */\n+  return open (name,\n+\t       (O_WRONLY | O_CREAT | O_TRUNC\n+\t\t| (binary ? O_BINARY : O_TEXT)),\n+\t       S_IRUSR | S_IWUSR);\n+}\n+\n+/* Close a file.  */\n \n-  /* Tuck the status away for pwait, and return a \"pid\".  */\n-  last_status = rc << 8;\n-  return last_pid;\n+static int\n+pex_djgpp_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)\n+{\n+  return close (fd);\n }\n \n-int\n-pwait (int pid, int *status, int flags)\n+/* Execute a child.  */\n+\n+static long\n+pex_djgpp_exec_child (struct pex_obj *obj, int flags, const char *executable,\n+\t\t      char * const * argv, int in, int out, int errdes,\n+\t\t      const char **errmsg, int *err)\n {\n-  /* On MSDOS each pexecute must be followed by its associated pwait.  */\n-  if (pid != last_pid\n-      /* Called twice for the same child?  */\n-      || pid == last_reaped)\n+  int org_in, org_out, org_errdes;\n+  int status;\n+  int *statuses;\n+\n+  org_in = -1;\n+  org_out = -1;\n+  org_errdes = -1;\n+\n+  if (in != STDIN_FILE_NO)\n+    {\n+      org_in = _dup (STDIN_FILE_NO);\n+      if (org_in < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup\";\n+\t  return -1;\n+\t}\n+      if (_dup2 (in, STDIN_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (in) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n+    }\n+\n+  if (out != STDOUT_FILE_NO)\n+    {\n+      org_out = _dup (STDOUT_FILE_NO);\n+      if (org_out < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup\";\n+\t  return -1;\n+\t}\n+      if (_dup2 (out, STDOUT_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (out) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n+    }\n+\n+  if (errdes != STDERR_FILE_NO\n+      || (flags & PEX_STDERR_TO_STDOUT) != 0)\n+    {\n+      int e;\n+\n+      org_errdes = _dup (STDERR_FILE_NO);\n+      if (org_errdes < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup\";\n+\t  return -1;\n+\t}\n+      if (_dup2 ((flags & PEX_STDERR_TO_STDOUT) != 0 ? STDOUT_FILE_NO : errdes,\n+\t\t STDERR_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (errdes != STDERR_FILE_NO)\n+\t{\n+\t  if (_close (errdes) < 0)\n+\t    {\n+\t      *err = errno;\n+\t      *errmsg = \"_close\";\n+\t      return -1;\n+\t    }\n+\t}\n+    }\n+\n+  status = (((flags & PEX_SEARCH) != 0 ? _spawnvp : _spawnv)\n+\t    (P_WAIT, program, (const char **) argv));\n+\n+  if (status == -1)\n+    {\n+      *err = errno;\n+      *errmsg = ((flags & PEX_SEARCH) != 0) ? \"_spawnvp\" : \"_spawnv\";\n+    }\n+\n+  if (in != STDIN_FILE_NO)\n+    {\n+      if (_dup2 (org_in, STDIN_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (org_in) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n+    }\n+\n+  if (out != STDOUT_FILE_NO)\n+    {\n+      if (_dup2 (org_out, STDOUT_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (org_out) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n+    }\n+\n+  if (errdes != STDERR_FILE_NO\n+      || (flags & PEX_STDERR_TO_STDOUT) != 0)\n     {\n-      errno = PWAIT_ERROR;\n-      return -1;\n+      if (_dup2 (org_errdes, STDERR_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (org_errdes) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n     }\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-  *status = (last_status >> 8);\n-  last_reaped = last_pid;\n-  return last_pid;\n+\n+  /* Save the exit status for later.  When we are called, obj->count\n+     is the number of children which have executed before this\n+     one.  */\n+  statuses = (int *) obj->sysdep;\n+  statuses = xrealloc (statuses, (obj->count + 1) * sizeof (int));\n+  statuses[obj->count] = status;\n+  obj->sysdep = (void *) statuses;\n+\n+  return obj->count;\n+}\n+\n+/* Wait for a child process to complete.  Actually the child process\n+   has already completed, and we just need to return the exit\n+   status.  */\n+\n+static int\n+pex_djgpp_wait (struct pex_obj *obj, long pid, int *status,\n+\t\tstruct pex_time *time, int done, const char **errmsg,\n+\t\tint *err)\n+{\n+  int *statuses;\n+\n+  if (time != NULL)\n+    memset (time, 0, sizeof *time);\n+\n+  statuses = (int *) obj->sysdep;\n+  *status = statuses[pid];\n+\n+  return 0;\n }"}, {"sha": "e2d76ee07a9468013454b65629066855955cd0ea", "filename": "libiberty/pex-msdos.c", "status": "modified", "additions": 250, "deletions": 74, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-msdos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-msdos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-msdos.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -1,6 +1,6 @@\n /* Utilities to execute a program in a subprocess (possibly linked by pipes\n    with other subprocesses), and wait for it.  Generic MSDOS specialization.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005\n    Free Software Foundation, Inc.\n \n This file is part of the libiberty library.\n@@ -36,105 +36,281 @@ extern int errno;\n #include \"safe-ctype.h\"\n #include <process.h>\n \n-/* MSDOS doesn't multitask, but for the sake of a consistent interface\n-   the code behaves like it does.  pexecute runs the program, tucks the\n-   exit code away, and returns a \"pid\".  pwait must be called to fetch the\n-   exit code.  */\n+/* The structure we keep in obj->sysdep.  */\n \n-/* For communicating information from pexecute to pwait.  */\n-static int last_pid = 0;\n-static int last_status = 0;\n-static int last_reaped = 0;\n+#define PEX_MSDOS_FILE_COUNT 3\n \n-int\n-pexecute (const char *program, char * const *argv, const char *this_pname,\n-          const char *temp_base, char **errmsg_fmt, char **errmsg_arg,\n-          int flags)\n+#define PEX_MSDOS_FD_OFFSET 10\n+\n+struct pex_msdos\n {\n-  int rc;\n-  char *scmd, *rf;\n-  FILE *argfile;\n-  int i, el = flags & PEXECUTE_SEARCH ? 4 : 0;\n+  /* An array of file names.  We refer to these using file descriptors\n+     of 10 + array index.  */\n+  const char *files[PEX_MSDOS_FILE_COUNT];\n+  /* Exit statuses of programs which have been run.  */\n+  int *statuses;\n+};\n+\n+static int pex_msdos_open (struct pex_obj *, const char *, int);\n+static int pex_msdos_open (struct pex_obj *, const char *, int);\n+static int pex_msdos_fdindex (struct pex_msdos *, int);\n+static long pex_msdos_exec_child (struct pex_obj *, int, const char *,\n+\t\t\t\t  char * const *, int, int, int,\n+\t\t\t\t  const char **, int *);\n+static int pex_msdos_close (struct pex_obj *, int);\n+static int pex_msdos_wait (struct pex_obj *, long, int *, struct pex_time *,\n+\t\t\t   int, const char **, int *);\n+static void pex_msdos_cleanup (struct pex_obj *);\n+\n+/* The list of functions we pass to the common routines.  */\n+\n+const struct pex_funcs funcs =\n+{\n+  pex_msdos_open,\n+  pex_msdos_open,\n+  pex_msdos_exec_child,\n+  pex_msdos_close,\n+  pex_msdos_wait,\n+  NULL, /* pipe */\n+  NULL, /* fdopenr */\n+  pex_msdos_cleanup\n+};\n+\n+/* Return a newly initialized pex_obj structure.  */\n+\n+struct pex_obj *\n+pex_init (int flags, const char *pname, const char *tempbase)\n+{\n+  struct pex_obj *ret;\n+  int i;\n+\n+  /* MSDOS does not support pipes.  */\n+  flags &= ~ PEX_USE_PIPES;\n \n-  last_pid++;\n-  if (last_pid < 0)\n-    last_pid = 1;\n+  ret = pex_init_common (flags, pname, tempbase, funcs);\n \n-  if ((flags & PEXECUTE_ONE) != PEXECUTE_ONE)\n+  ret->sysdep = xmalloc (sizeof (struct pex_msdos));\n+  for (i = 0; i < PEX_MSDOS_FILE_COUNT; ++i)\n+    ret->files[i] = NULL;\n+  ret->statuses = NULL;\n+\n+  return ret;\n+}\n+\n+/* Open a file.  FIXME: We ignore the binary argument, since we have\n+   no way to handle it.  */\n+\n+static int\n+pex_msdos_open (struct pex_obj *obj, const char *name,\n+\t\tint binary ATTRIBUTE_UNUSED)\n+{\n+  struct pex_msdos *ms;\n+  int i;\n+\n+  ms = (struct pex_msdos *) obj->sysdep;\n+\n+  for (i = 0; i < PEX_MSDOS_FILE_COUNT; ++i)\n+    {\n+      if (ms->files[i] == NULL)\n+\t{\n+\t  ms->files[i] = xstrdup (name);\n+\t  return i + PEX_MSDOS_FD_OFFSET;\n+\t}\n+    }\n+\n+  abort ();\n+}\n+\n+/* Get the index into msdos->files associated with an open file\n+   descriptor.  */\n+\n+static int\n+pex_msdos_fdindex (struct pex_msdos *ms, int fd)\n+{\n+  fd -= PEX_MSDOS_FD_OFFSET;\n+  if (fd < 0 || fd >= PEX_MSDOS_FILE_COUNT || ms->files[fd] == NULL)\n     abort ();\n+  return fd;\n+}\n+\n+\n+/* Close a file.  */\n+\n+static int\n+pex_msdos_close (struct pex_obj *obj, int fd)\n+{\n+  struct pex_msdos *ms;\n+  int fdinex;\n+\n+  ms = (struct pex_msdos *) obj->sysdep;\n+  fdindex = pe_msdos_fdindex (ms, fd);\n+  free (ms->files[fdindex]);\n+  ms->files[fdindex] = NULL;\n+}\n+\n+/* Execute a child.  */\n+\n+static long\n+pex_msdos_exec_child (struct pex_obj *obj, int flags, const char *executable,\n+\t\t      char * const * argv, int in, int out,\n+\t\t      int errdes ATTRIBUTE_UNUSED, const char **errmsg,\n+\t\t      int *err)\n+{\n+  struct pex_msdos *ms;\n+  char *temp_base;\n+  int temp_base_allocated;\n+  char *rf;\n+  int inindex;\n+  char *infile;\n+  int outindex;\n+  char *outfile;\n+  char *scmd;\n+  FILE *argfile;\n+  int i;\n+  int status;\n+\n+  ms = (struct pex_msdos *) obj->sysdep;\n+\n+  /* FIXME: I don't know how to redirect stderr, so we ignore ERRDES\n+     and PEX_STDERR_TO_STDOUT.  */\n+\n+  temp_base = obj->temp_base;\n+  if (temp_base != NULL)\n+    temp_base_allocated = 0;\n+  else\n+    {\n+      temp_base = choose_temp_base ();\n+      temp_base_allocated = 1;\n+    }\n+\n+  rf = concat (temp_base, \".gp\", NULL);\n+\n+  if (temp_base_allocated)\n+    free (temp_base);\n+\n+  if (in == STDIN_FILE_NO)\n+    {\n+      inindex = -1;\n+      infile = \"\";\n+    }\n+  else\n+    {\n+      inindex = pex_msdos_fdindex (ms, in);\n+      infile = ms->files[inindex];\n+    }\n+\n+  if (out == STDOUT_FILE_NO)\n+    {\n+      outindex = -1;\n+      outfile = \"\";\n+    }\n+  else\n+    {\n+      outindex = pex_msdos_fdindex (ms, out);\n+      outfile = ms->files[outindex];\n+    }\n+\n+  scmd = xmalloc (strlen (program)\n+\t\t  + ((flags & PEXECUTE_SEARCH) != 0 ? 4 : 0)\n+\t\t  + strlen (rf)\n+\t\t  + strlen (infile)\n+\t\t  + strlen (outfile)\n+\t\t  + 10);\n+  sprintf (scmd, \"%s%s @%s%s%s%s%s\",\n+\t   program,\n+\t   (flags & PEXECUTE_SEARCH) != 0 ? \".exe\" : \"\",\n+\t   rf,\n+\t   inindex != -1 ? \" <\" : \"\",\n+\t   infile,\n+\t   outindex != -1 ? \" >\" : \"\",\n+\t   outfile);\n \n-  if (temp_base == 0)\n-    temp_base = choose_temp_base ();\n-  scmd = (char *) xmalloc (strlen (program) + strlen (temp_base) + 6 + el);\n-  rf = scmd + strlen(program) + 2 + el;\n-  sprintf (scmd, \"%s%s @%s.gp\", program,\n-\t   (flags & PEXECUTE_SEARCH ? \".exe\" : \"\"), temp_base);\n   argfile = fopen (rf, \"w\");\n-  if (argfile == 0)\n+  if (argfile == NULL)\n     {\n-      int errno_save = errno;\n+      *err = errno;\n       free (scmd);\n-      errno = errno_save;\n-      *errmsg_fmt = \"cannot open `%s.gp'\";\n-      *errmsg_arg = temp_base;\n+      free (rf);\n+      *errmsg = \"cannot open temporary command file\";\n       return -1;\n     }\n \n-  for (i=1; argv[i]; i++)\n+  for (i = 1; argv[i] != NULL; ++i)\n     {\n-      char *cp;\n-      for (cp = argv[i]; *cp; cp++)\n+      char *p;\n+\n+      for (p = argv[i]; *p != '\\0'; ++p)\n \t{\n-\t  if (*cp == '\"' || *cp == '\\'' || *cp == '\\\\' || ISSPACE (*cp))\n-\t    fputc ('\\\\', argfile);\n-\t  fputc (*cp, argfile);\n+\t  if (*p == '\"' || *p == '\\'' || *p == '\\\\' || ISSPACE (*p))\n+\t    putc ('\\\\', argfile);\n+\t  putc (*p, argfile);\n \t}\n-      fputc ('\\n', argfile);\n+      putc ('\\n', argfile);\n     }\n-  fclose (argfile);\n \n-  rc = system (scmd);\n+  fclose (argfile);\n \n-  {\n-    int errno_save = errno;\n-    remove (rf);\n-    free (scmd);\n-    errno = errno_save;\n-  }\n+  status = system (scmd);\n \n-  if (rc == -1)\n+  if (status == -1)\n     {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = (char *)program;\n+      *err = errno;\n+      remove (rf);\n+      free (scmd);\n+      free (rf);\n+      *errmsg = \"system\";\n       return -1;\n     }\n \n-  /* Tuck the status away for pwait, and return a \"pid\".  */\n-  last_status = rc << 8;\n-  return last_pid;\n+  remove (rf);\n+  free (scmd);\n+  free (rf);\n+\n+  /* Save the exit status for later.  When we are called, obj->count\n+     is the number of children which have executed before this\n+     one.  */\n+  ms->statuses = xrealloc (ms->statuses, (obj->count + 1) * sizeof (int));\n+  ms->statuses[obj->count] = status;\n+\n+  return obj->count;\n }\n \n-/* Use ECHILD if available, otherwise use EINVAL.  */\n-#ifdef ECHILD\n-#define PWAIT_ERROR ECHILD\n-#else\n-#define PWAIT_ERROR EINVAL\n-#endif\n+/* Wait for a child process to complete.  Actually the child process\n+   has already completed, and we just need to return the exit\n+   status.  */\n \n-int\n-pwait (int pid, int *status, int flags)\n+static int\n+pex_msdos_wait (struct pex_obj *obj, long pid, int *status,\n+\t\tstruct pex_time *time, int done ATTRIBUTE_UNUSED,\n+\t\tconst char **errmsg ATTRIBUTE_UNUSED,\n+\t\tint *err ATTRIBUTE_UNUSED)\n {\n-  /* On MSDOS each pexecute must be followed by its associated pwait.  */\n-  if (pid != last_pid\n-      /* Called twice for the same child?  */\n-      || pid == last_reaped)\n-    {\n-      errno = PWAIT_ERROR;\n-      return -1;\n-    }\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-  *status = last_status;\n-  last_reaped = last_pid;\n-  return last_pid;\n+  struct pex_msdos *ms;\n+\n+  ms = (struct pex_msdos *) obj->sysdep;\n+\n+  if (time != NULL)\n+    memset (time, 0, sizeof *time);\n+\n+  *status = ms->statuses[pid];\n+\n+  return 0;\n+}\n+\n+/* Clean up the pex_msdos structure.  */\n+\n+static void\n+pex_msdos_cleanup (struct pex_obj  *obj)\n+{\n+  struct pex_msdos *ms;\n+  int i;\n+\n+  ms = (struct pex_msdos *) obj->sysdep;\n+  for (i = 0; i < PEX_MSDOS_FILE_COUNT; ++i)\n+    if (msdos->files[i] != NULL)\n+      free (msdos->files[i]);\n+  if (msdos->statuses != NULL)\n+    free (msdos->statuses);\n+  free (msdos);\n+  obj->sysdep = NULL;\n }"}, {"sha": "84f1bec070ffc5f61d6eb5a860629abfca36c578", "filename": "libiberty/pex-one.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-one.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-one.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-one.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -0,0 +1,43 @@\n+/* Execute a program and wait for a result.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+\n+const char *\n+pex_one (int flags, const char *executable, char * const *argv,\n+\t const char *pname, const char *outname, const char *errname,\n+\t int *status, int *err)\n+{\n+  struct pex_obj *obj;\n+  const char *errmsg;\n+\n+  obj = pex_init (0, pname, NULL);\n+  errmsg = pex_run (obj, flags, executable, argv, outname, errname, err);\n+  if (errmsg == NULL)\n+    {\n+      if (!pex_get_status (obj, 1, status))\n+\t{\n+\t  *err = 0;\n+\t  errmsg = \"pex_get_status failed\";\n+\t}\n+    }\n+  pex_free (obj);\n+  return errmsg;  \n+}"}, {"sha": "b9654fca9f8129719006a06c4e38282b2e237123", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 418, "deletions": 112, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -20,30 +20,43 @@ License along with libiberty; see the file COPYING.LIB.  If not,\n write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#include \"config.h\"\n+#include \"libiberty.h\"\n #include \"pex-common.h\"\n \n #include <stdio.h>\n+#include <signal.h>\n #include <errno.h>\n #ifdef NEED_DECLARATION_ERRNO\n extern int errno;\n #endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n #ifdef HAVE_STRING_H\n #include <string.h>\n #endif\n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n #endif\n-#ifdef HAVE_STDLIB_H\n-#include <stdlib.h>\n+\n+#include <sys/types.h>\n+\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n #endif\n #ifdef HAVE_SYS_WAIT_H\n #include <sys/wait.h>\n #endif\n-\n-#ifndef HAVE_WAITPID\n-#define waitpid(pid, status, flags) wait(status)\n+#ifdef HAVE_GETRUSAGE\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+#endif\n+#ifdef HAVE_SYS_STAT_H\n+#include <sys/stat.h>\n #endif\n \n+\n #ifdef vfork /* Autoconf may define this to fork for us. */\n # define VFORK_STRING \"fork\"\n #else\n@@ -57,80 +70,300 @@ extern int errno;\n                lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)\n #endif /* VMS */\n \n-/* Execute a program, possibly setting up pipes to programs executed\n-   via other calls to this function.\n-\n-   This version of the function uses vfork.  In general vfork is\n-   similar to setjmp/longjmp, in that any variable which is modified by\n-   the child process has an indeterminate value in the parent process.\n-   We follow a safe approach here by not modifying any variables at\n-   all in the child process (with the possible exception of variables\n-   modified by xstrerror if exec fails, but this is unlikely to be\n-   detectable).\n-\n-   We work a little bit harder to avoid gcc warnings.  gcc will warn\n-   about any automatic variable which is live at the time of the\n-   vfork, which is non-volatile, and which is either set more than\n-   once or is an argument to the function.  This warning isn't quite\n-   right, since what we really care about is whether the variable is\n-   live at the time of the vfork and set afterward by the child\n-   process, but gcc only checks whether the variable is set more than\n-   once.  To avoid this warning, we ensure that any variable which is\n-   live at the time of the vfork (i.e., used after the vfork) is set\n-   exactly once and is not an argument, or is marked volatile.  */\n-\n-int\n-pexecute (const char *program, char * const *argv, const char *this_pname,\n-          const char *temp_base ATTRIBUTE_UNUSED,\n-          char **errmsg_fmt, char **errmsg_arg, int flagsarg)\n-{\n-  int pid;\n-  int pdes[2];\n-  int out;\n-  int input_desc, output_desc;\n-  int flags;\n-  /* We declare these to be volatile to avoid warnings from gcc about\n-     them being clobbered by vfork.  */\n-  volatile int retries, sleep_interval;\n-  /* Pipe waiting from last process, to be used as input for the next one.\n-     Value is STDIN_FILE_NO if no pipe is waiting\n-     (i.e. the next command is the first of a group).  */\n-  static int last_pipe_input;\n \n-  flags = flagsarg;\n+/* File mode to use for private and world-readable files.  */\n+\n+#if defined (S_IRUSR) && defined (S_IWUSR) && defined (S_IRGRP) && defined (S_IWGRP) && defined (S_IROTH) && defined (S_IWOTH)\n+#define PUBLIC_MODE  \\\n+    (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)\n+#else\n+#define PUBLIC_MODE 0666\n+#endif\n+\n+/* Get the exit status of a particular process, and optionally get the\n+   time that it took.  This is simple if we have wait4, slightly\n+   harder if we have waitpid, and is a pain if we only have wait.  */\n+\n+static pid_t pex_wait (struct pex_obj *, pid_t, int *, struct pex_time *);\n+\n+#ifdef HAVE_WAIT4\n+\n+static pid_t\n+pex_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid, int *status,\n+\t  struct pex_time *time)\n+{\n+  pid_t ret;\n+  struct rusage r;\n+\n+#ifdef HAVE_WAITPID\n+  if (time == NULL)\n+    return waitpid (pid, status, 0);\n+#endif\n+\n+  ret = wait4 (pid, status, 0, &r);\n+\n+  if (time != NULL)\n+    {\n+      time->user_seconds = r.ru_utime.tv_sec;\n+      time->user_microseconds= r.ru_utime.tv_usec;\n+      time->system_seconds = r.ru_stime.tv_sec;\n+      time->system_microseconds= r.ru_stime.tv_usec;\n+    }\n+\n+  return ret;\n+}\n+\n+#else /* ! defined (HAVE_WAIT4) */\n+\n+#ifdef HAVE_WAITPID\n+\n+#ifndef HAVE_GETRUSAGE\n+\n+static pid_t\n+pex_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid, int *status,\n+\t  struct pex_time *time)\n+{\n+  if (time != NULL)\n+    memset (time, 0, sizeof (struct pex_time));\n+  return waitpid (pid, status, 0);\n+}\n+\n+#else /* defined (HAVE_GETRUSAGE) */\n+\n+static pid_t\n+pex_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, pid_t pid, int *status,\n+\t  struct pex_time *time)\n+{\n+  struct rusage r1, r2;\n+  pid_t ret;\n+\n+  if (time == NULL)\n+    return waitpid (pid, status, 0);\n+\n+  getrusage (RUSAGE_CHILDREN, &r1);\n+\n+  ret = waitpid (pid, status, 0);\n+  if (ret < 0)\n+    return ret;\n+\n+  getrusage (RUSAGE_CHILDREN, &r2);\n+\n+  time->user_seconds = r2.ru_utime.tv_sec - r1.ru_utime.tv_sec;\n+  time->user_microseconds = r2.ru_utime.tv_usec - r1.ru_utime.tv_usec;\n+  if (r2.ru_utime.tv_usec < r1.ru_utime.tv_usec)\n+    {\n+      --time->user_seconds;\n+      time->user_microseconds += 1000000;\n+    }\n+\n+  time->system_seconds = r2.ru_stime.tv_sec - r1.ru_stime.tv_sec;\n+  time->system_microseconds = r2.ru_stime.tv_usec - r1.ru_stime.tv_usec;\n+  if (r2.ru_stime.tv_usec < r1.ru_stime.tv_usec)\n+    {\n+      --time->system_seconds;\n+      time->system_microseconds += 1000000;\n+    }\n \n-  /* If this is the first process, initialize.  */\n-  if (flags & PEXECUTE_FIRST)\n-    last_pipe_input = STDIN_FILE_NO;\n+  return ret;\n+}\n \n-  input_desc = last_pipe_input;\n+#endif /* defined (HAVE_GETRUSAGE) */\n \n-  /* If this isn't the last process, make a pipe for its output,\n-     and record it as waiting to be the input to the next process.  */\n-  if (! (flags & PEXECUTE_LAST))\n+#else /* ! defined (HAVE_WAITPID) */\n+\n+struct status_list\n+{\n+  struct status_list *next;\n+  pid_t pid;\n+  int status;\n+  struct pex_time time;\n+};\n+\n+static pid_t\n+pex_wait (struct pex_obj *obj, pid_t pid, int *status, struct pex_time *time)\n+{\n+  struct status_list **pp;\n+\n+  for (pp = (struct status_list **) &obj->sysdep;\n+       *pp != NULL;\n+       pp = &(*pp)->next)\n     {\n-      if (pipe (pdes) < 0)\n+      if ((*pp)->pid == pid)\n \t{\n-\t  *errmsg_fmt = \"pipe\";\n-\t  *errmsg_arg = NULL;\n-\t  return -1;\n+\t  struct status_list *p;\n+\n+\t  p = *pp;\n+\t  *status = p->status;\n+\t  if (time != NULL)\n+\t    *time = p->time;\n+\t  *pp = p->next;\n+\t  free (p);\n+\t  return pid;\n \t}\n-      out = pdes[WRITE_PORT];\n-      last_pipe_input = pdes[READ_PORT];\n     }\n-  else\n+\n+  while (1)\n     {\n-      /* Last process.  */\n-      out = STDOUT_FILE_NO;\n-      last_pipe_input = STDIN_FILE_NO;\n+      pid_t cpid;\n+      struct status_list *psl;\n+      struct pex_time pt;\n+#ifdef HAVE_GETRUSAGE\n+      struct rusage r1, r2;\n+#endif\n+\n+      if (time != NULL)\n+\t{\n+#ifdef HAVE_GETRUSAGE\n+\t  getrusage (RUSAGE_CHILDREN, &r1);\n+#else\n+\t  memset (&pt, 0, sizeof (struct pex_time));\n+#endif\n+\t}\n+\n+      cpid = wait (status);\n+\n+#ifdef HAVE_GETRUSAGE\n+      if (time != NULL && cpid >= 0)\n+\t{\n+\t  getrusage (RUSAGE_CHILDREN, &r2);\n+\n+\t  pt.user_seconds = r2.ru_utime.tv_sec - r1.ru_utime.tv_sec;\n+\t  pt.user_microseconds = r2.ru_utime.tv_usec - r1.ru_utime.tv_usec;\n+\t  if (pt.user_microseconds < 0)\n+\t    {\n+\t      --pt.user_seconds;\n+\t      pt.user_microseconds += 1000000;\n+\t    }\n+\n+\t  pt.system_seconds = r2.ru_stime.tv_sec - r1.ru_stime.tv_sec;\n+\t  pt.system_microseconds = r2.ru_stime.tv_usec - r1.ru_stime.tv_usec;\n+\t  if (pt.system_microseconds < 0)\n+\t    {\n+\t      --pt.system_seconds;\n+\t      pt.system_microseconds += 1000000;\n+\t    }\n+\t}\n+#endif\n+\n+      if (cpid < 0 || cpid == pid)\n+\t{\n+\t  if (time != NULL)\n+\t    *time = pt;\n+\t  return cpid;\n+\t}\n+\n+      psl = xmalloc (sizeof (struct status_list));\n+      psl->pid = cpid;\n+      psl->status = *status;\n+      if (time != NULL)\n+\tpsl->time = pt;\n+      psl->next = (struct status_list *) obj->sysdep;\n+      obj->sysdep = (void *) psl;\n     }\n+}\n+\n+#endif /* ! defined (HAVE_WAITPID) */\n+#endif /* ! defined (HAVE_WAIT4) */\n+\n+static void pex_child_error (struct pex_obj *, const char *, const char *, int)\n+     ATTRIBUTE_NORETURN;\n+static int pex_unix_open_read (struct pex_obj *, const char *, int);\n+static int pex_unix_open_write (struct pex_obj *, const char *, int);\n+static long pex_unix_exec_child (struct pex_obj *, int, const char *,\n+\t\t\t\t char * const *, int, int, int,\n+\t\t\t\t const char **, int *);\n+static int pex_unix_close (struct pex_obj *, int);\n+static int pex_unix_wait (struct pex_obj *, long, int *, struct pex_time *,\n+\t\t\t  int, const char **, int *);\n+static int pex_unix_pipe (struct pex_obj *, int *, int);\n+static FILE *pex_unix_fdopenr (struct pex_obj *, int, int);\n+static void pex_unix_cleanup (struct pex_obj *);\n+\n+/* The list of functions we pass to the common routines.  */\n+\n+const struct pex_funcs funcs =\n+{\n+  pex_unix_open_read,\n+  pex_unix_open_write,\n+  pex_unix_exec_child,\n+  pex_unix_close,\n+  pex_unix_wait,\n+  pex_unix_pipe,\n+  pex_unix_fdopenr,\n+  pex_unix_cleanup\n+};\n+\n+/* Return a newly initialized pex_obj structure.  */\n+\n+struct pex_obj *\n+pex_init (int flags, const char *pname, const char *tempbase)\n+{\n+  return pex_init_common (flags, pname, tempbase, &funcs);\n+}\n+\n+/* Open a file for reading.  */\n+\n+static int\n+pex_unix_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,\n+\t\t    int binary ATTRIBUTE_UNUSED)\n+{\n+  return open (name, O_RDONLY);\n+}\n+\n+/* Open a file for writing.  */\n+\n+static int\n+pex_unix_open_write (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,\n+\t\t     int binary ATTRIBUTE_UNUSED)\n+{\n+  /* Note that we can't use O_EXCL here because gcc may have already\n+     created the temporary file via make_temp_file.  */\n+  return open (name, O_WRONLY | O_CREAT | O_TRUNC, PUBLIC_MODE);\n+}\n \n-  output_desc = out;\n+/* Close a file.  */\n+\n+static int\n+pex_unix_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)\n+{\n+  return close (fd);\n+}\n+\n+/* Report an error from a child process.  We don't use stdio routines,\n+   because we might be here due to a vfork call.  */\n+\n+static void\n+pex_child_error (struct pex_obj *obj, const char *executable,\n+\t\t const char *errmsg, int err)\n+{\n+#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))\n+  writeerr (obj->pname);\n+  writeerr (\": error trying to exec '\");\n+  writeerr (executable);\n+  writeerr (\"': \");\n+  writeerr (errmsg);\n+  writeerr (\": \");\n+  writeerr (xstrerror (err));\n+  writeerr (\"\\n\");\n+  _exit (-1);\n+}\n+\n+/* Execute a child.  */\n+\n+static long\n+pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n+\t\t     char * const * argv, int in, int out, int errdes,\n+\t\t     const char **errmsg, int *err)\n+{\n+  pid_t pid;\n+  /* We declare these to be volatile to avoid warnings from gcc about\n+     them being clobbered by vfork.  */\n+  volatile int sleep_interval;\n+  volatile int retries;\n \n-  /* Fork a subprocess; wait and retry if it fails.  */\n   sleep_interval = 1;\n   pid = -1;\n-  for (retries = 0; retries < 4; retries++)\n+  for (retries = 0; retries < 4; ++retries)\n     {\n       pid = vfork ();\n       if (pid >= 0)\n@@ -142,66 +375,139 @@ pexecute (const char *program, char * const *argv, const char *this_pname,\n   switch (pid)\n     {\n     case -1:\n-      *errmsg_fmt = \"fork\";\n-      *errmsg_arg = NULL;\n+      *err = errno;\n+      *errmsg = VFORK_STRING;\n       return -1;\n \n-    case 0: /* child */\n-      /* Move the input and output pipes into place, if necessary.  */\n-      if (input_desc != STDIN_FILE_NO)\n+    case 0:\n+      /* Child process.  */\n+      if (in != STDIN_FILE_NO)\n \t{\n-\t  close (STDIN_FILE_NO);\n-\t  dup (input_desc);\n-\t  close (input_desc);\n+\t  if (dup2 (in, STDIN_FILE_NO) < 0)\n+\t    pex_child_error (obj, executable, \"dup2\", errno);\n+\t  if (close (in) < 0)\n+\t    pex_child_error (obj, executable, \"close\", errno);\n \t}\n-      if (output_desc != STDOUT_FILE_NO)\n+      if (out != STDOUT_FILE_NO)\n \t{\n-\t  close (STDOUT_FILE_NO);\n-\t  dup (output_desc);\n-\t  close (output_desc);\n+\t  if (dup2 (out, STDOUT_FILE_NO) < 0)\n+\t    pex_child_error (obj, executable, \"dup2\", errno);\n+\t  if (close (out) < 0)\n+\t    pex_child_error (obj, executable, \"close\", errno);\n+\t}\n+      if (errdes != STDERR_FILE_NO)\n+\t{\n+\t  if (dup2 (errdes, STDERR_FILE_NO) < 0)\n+\t    pex_child_error (obj, executable, \"dup2\", errno);\n+\t  if (close (errdes) < 0)\n+\t    pex_child_error (obj, executable, \"close\", errno);\n+\t}\n+      if ((flags & PEX_STDERR_TO_STDOUT) != 0)\n+\t{\n+\t  if (dup2 (STDOUT_FILE_NO, STDERR_FILE_NO) < 0)\n+\t    pex_child_error (obj, executable, \"dup2\", errno);\n+\t}\n+      if ((flags & PEX_SEARCH) != 0)\n+\t{\n+\t  execvp (executable, argv);\n+\t  pex_child_error (obj, executable, \"execvp\", errno);\n \t}\n-\n-      /* Close the parent's descs that aren't wanted here.  */\n-      if (last_pipe_input != STDIN_FILE_NO)\n-\tclose (last_pipe_input);\n-\n-      /* Exec the program.  */\n-      if (flags & PEXECUTE_SEARCH)\n-\texecvp (program, argv);\n       else\n-\texecv (program, argv);\n+\t{\n+\t  execv (executable, argv);\n+\t  pex_child_error (obj, executable, \"execv\", errno);\n+\t}\n \n-      /* We don't want to call fprintf after vfork.  */\n-#define writeerr(s) write (STDERR_FILE_NO, s, strlen (s))\n-      writeerr (this_pname);\n-      writeerr (\": \");\n-      writeerr (\"installation problem, cannot exec '\");\n-      writeerr (program);\n-      writeerr (\"': \");\n-      writeerr (xstrerror (errno));\n-      writeerr (\"\\n\");\n-      _exit (-1);\n       /* NOTREACHED */\n-      return 0;\n+      return -1;\n \n     default:\n-      /* In the parent, after forking.\n-\t Close the descriptors that we made for this child.  */\n-      if (input_desc != STDIN_FILE_NO)\n-\tclose (input_desc);\n-      if (output_desc != STDOUT_FILE_NO)\n-\tclose (output_desc);\n-\n-      /* Return child's process number.  */\n-      return pid;\n+      /* Parent process.  */\n+      if (in != STDIN_FILE_NO)\n+\t{\n+\t  if (close (in) < 0)\n+\t    {\n+\t      *err = errno;\n+\t      *errmsg = \"close\";\n+\t      return -1;\n+\t    }\n+\t}\n+      if (out != STDOUT_FILE_NO)\n+\t{\n+\t  if (close (out) < 0)\n+\t    {\n+\t      *err = errno;\n+\t      *errmsg = \"close\";\n+\t      return -1;\n+\t    }\n+\t}\n+      if (errdes != STDERR_FILE_NO)\n+\t{\n+\t  if (close (errdes) < 0)\n+\t    {\n+\t      *err = errno;\n+\t      *errmsg = \"close\";\n+\t      return -1;\n+\t    }\n+\t}\n+\n+      return (long) pid;\n     }\n }\n \n-int\n-pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)\n+/* Wait for a child process to complete.  */\n+\n+static int\n+pex_unix_wait (struct pex_obj *obj, long pid, int *status,\n+\t       struct pex_time *time, int done, const char **errmsg,\n+\t       int *err)\n {\n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n-  pid = waitpid (pid, status, 0);\n-  return pid;\n+  /* If we are cleaning up when the caller didn't retrieve process\n+     status for some reason, encourage the process to go away.  */\n+  if (done)\n+    kill (pid, SIGTERM);\n+\n+  if (pex_wait (obj, pid, status, time) < 0)\n+    {\n+      *err = errno;\n+      *errmsg = \"wait\";\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Create a pipe.  */\n+\n+static int\n+pex_unix_pipe (struct pex_obj *obj ATTRIBUTE_UNUSED, int *p,\n+\t       int binary ATTRIBUTE_UNUSED)\n+{\n+  return pipe (p);\n+}\n+\n+/* Get a FILE pointer to read from a file descriptor.  */\n+\n+static FILE *\n+pex_unix_fdopenr (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,\n+\t\t  int binary ATTRIBUTE_UNUSED)\n+{\n+  return fdopen (fd, \"r\");\n+}\n+\n+static void\n+pex_unix_cleanup (struct pex_obj *obj ATTRIBUTE_UNUSED)\n+{\n+#if !defined (HAVE_WAIT4) && !defined (HAVE_WAITPID)\n+  while (obj->sysdep != NULL)\n+    {\n+      struct status_list *this;\n+      struct status_list *next;\n+\n+      this = (struct status_list *) obj->sysdep;\n+      next = this->next;\n+      free (this);\n+      obj->sysdep = (void *) next;\n+    }\n+#endif\n }"}, {"sha": "2a3607df79235b14df06e856403d091c22f12727", "filename": "libiberty/pex-win32.c", "status": "modified", "additions": 289, "deletions": 97, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpex-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-win32.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -21,6 +21,9 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"pex-common.h\"\n \n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n #ifdef HAVE_STRING_H\n #include <string.h>\n #endif\n@@ -35,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include <io.h>\n #include <fcntl.h>\n #include <signal.h>\n+#include <sys/stat.h>\n \n /* mingw32 headers may not define the following.  */\n \n@@ -53,27 +57,49 @@ Boston, MA 02111-1307, USA.  */\n    to remove the outermost set of double quotes from all arguments.  */\n \n static const char * const *\n-fix_argv (char **argvec)\n+fix_argv (char * const *argvec)\n {\n+  char **argv;\n   int i;\n-  char * command0 = argvec[0];\n+  char *command0;\n+\n+  /* See whether we need to change anything.  */\n+  for (command0 = argvec[0]; *command0 != '\\0'; command0++)\n+    if (*command0 == '/')\n+      break;\n+  if (*command0 == '\\0')\n+    {\n+      for (i = 1; argvec[i] != NULL; i++)\n+\tif (strpbrk (argvec[i], \"\\\" \\t\") != NULL)\n+\t  break;\n+\n+      if (argvec[i] == NULL)\n+\treturn (const char * const *) argvec;\n+    }\n+\n+  for (i = 0; argvec[i] != NULL; i++)\n+    ;\n+  argv = xmalloc ((i + 1) * sizeof (char *));\n+  for (i = 0; argvec[i] != NULL; i++)\n+    argv[i] = xstrdup (argvec[i]);\n+  argv[i] = NULL;\n \n   /* Ensure that the executable pathname uses Win32 backslashes. This\n-     is not necessary on NT, but on W9x, forward slashes causes failure\n-     of spawn* and exec* functions (and probably any function that\n-     calls CreateProcess) *iff* the executable pathname (argvec[0]) is\n-     a quoted string.  And quoting is necessary in case a pathname\n-     contains  embedded white space. You can't win.  */\n-  for (; *command0 != '\\0'; command0++)\n+     is not necessary on NT, but on W9x, forward slashes causes\n+     failure of spawn* and exec* functions (and probably any function\n+     that calls CreateProcess) *iff* the executable pathname (argv[0])\n+     is a quoted string.  And quoting is necessary in case a pathname\n+     contains embedded white space.  You can't win.  */\n+  for (command0 = argv[0]; *command0 != '\\0'; command0++)\n     if (*command0 == '/')\n       *command0 = '\\\\';\n- \n-  for (i = 1; argvec[i] != 0; i++)\n+\n+  for (i = 1; argv[i] != 0; i++)\n     {\n       int len, j;\n       char *temp, *newtemp;\n \n-      temp = argvec[i];\n+      temp = argv[i];\n       len = strlen (temp);\n       for (j = 0; j < len; j++)\n         {\n@@ -90,17 +116,21 @@ fix_argv (char **argvec)\n             }\n         }\n \n-        argvec[i] = temp;\n-      }\n+      if (argv[i] != temp)\n+\t{\n+\t  free (argv[i]);\n+\t  argv[i] = temp;\n+\t}\n+    }\n \n-  for (i = 0; argvec[i] != 0; i++)\n+  for (i = 0; argv[i] != 0; i++)\n     {\n-      if (strpbrk (argvec[i], \" \\t\"))\n+      if (strpbrk (argv[i], \" \\t\"))\n         {\n \t  int len, trailing_backslash;\n \t  char *temp;\n \n-\t  len = strlen (argvec[i]);\n+\t  len = strlen (argv[i]);\n \t  trailing_backslash = 0;\n \n \t  /* There is an added complication when an arg with embedded white\n@@ -111,8 +141,8 @@ fix_argv (char **argvec)\n \t     We handle this case by escaping the trailing backslash, provided\n \t     it was not escaped in the first place.  */\n \t  if (len > 1 \n-\t      && argvec[i][len-1] == '\\\\' \n-\t      && argvec[i][len-2] != '\\\\')\n+\t      && argv[i][len-1] == '\\\\' \n+\t      && argv[i][len-2] != '\\\\')\n \t    {\n \t      trailing_backslash = 1;\n \t      ++len;\t\t\t/* to escape the final backslash. */\n@@ -122,127 +152,289 @@ fix_argv (char **argvec)\n \n \t  temp = xmalloc (len + 1);\n \t  temp[0] = '\"';\n-\t  strcpy (temp + 1, argvec[i]);\n+\t  strcpy (temp + 1, argv[i]);\n \t  if (trailing_backslash)\n-\t    temp[len-2] = '\\\\';\n-\t  temp[len-1] = '\"';\n+\t    temp[len - 2] = '\\\\';\n+\t  temp[len - 1] = '\"';\n \t  temp[len] = '\\0';\n \n-\t  argvec[i] = temp;\n+\t  free (argv[i]);\n+\t  argv[i] = temp;\n \t}\n     }\n \n-  return (const char * const *) argvec;\n+  return (const char * const *) argv;\n }\n \n-/* Win32 supports pipes */\n-int\n-pexecute (const char *program, char * const *argv,\n-          const char *this_pname ATTRIBUTE_UNUSED,\n-          const char *temp_base ATTRIBUTE_UNUSED,\n-          char **errmsg_fmt, char **errmsg_arg, int flags)\n+static int pex_win32_open_read (struct pex_obj *, const char *, int);\n+static int pex_win32_open_write (struct pex_obj *, const char *, int);\n+static long pex_win32_exec_child (struct pex_obj *, int, const char *,\n+\t\t\t\t  char * const *, int, int, int,\n+\t\t\t\t  const char **, int *);\n+static int pex_win32_close (struct pex_obj *, int);\n+static int pex_win32_wait (struct pex_obj *, long, int *,\n+\t\t\t   struct pex_time *, int, const char **, int *);\n+static int pex_win32_pipe (struct pex_obj *, int *, int);\n+static FILE *pex_win32_fdopenr (struct pex_obj *, int, int);\n+\n+/* The list of functions we pass to the common routines.  */\n+\n+const struct pex_funcs funcs =\n {\n-  int pid;\n-  int pdes[2];\n-  int org_stdin = -1;\n-  int org_stdout = -1;\n-  int input_desc, output_desc;\n-\n-  /* Pipe waiting from last process, to be used as input for the next one.\n-     Value is STDIN_FILE_NO if no pipe is waiting\n-     (i.e. the next command is the first of a group).  */\n-  static int last_pipe_input;\n-\n-  /* If this is the first process, initialize.  */\n-  if (flags & PEXECUTE_FIRST)\n-    last_pipe_input = STDIN_FILE_NO;\n-\n-  input_desc = last_pipe_input;\n-\n-  /* If this isn't the last process, make a pipe for its output,\n-     and record it as waiting to be the input to the next process.  */\n-  if (! (flags & PEXECUTE_LAST))\n+  pex_win32_open_read,\n+  pex_win32_open_write,\n+  pex_win32_exec_child,\n+  pex_win32_close,\n+  pex_win32_wait,\n+  pex_win32_pipe,\n+  pex_win32_fdopenr,\n+  NULL /* cleanup */\n+};\n+\n+/* Return a newly initialized pex_obj structure.  */\n+\n+struct pex_obj *\n+pex_init (int flags, const char *pname, const char *tempbase)\n+{\n+  return pex_init_common (flags, pname, tempbase, &funcs);\n+}\n+\n+/* Open a file for reading.  */\n+\n+static int\n+pex_win32_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,\n+\t\t     int binary)\n+{\n+  return _open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));\n+}\n+\n+/* Open a file for writing.  */\n+\n+static int\n+pex_win32_open_write (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,\n+\t\t      int binary)\n+{\n+  /* Note that we can't use O_EXCL here because gcc may have already\n+     created the temporary file via make_temp_file.  */\n+  return _open (name,\n+\t\t(_O_WRONLY | _O_CREAT | _O_TRUNC\n+\t\t | (binary ? _O_BINARY : _O_TEXT)),\n+\t\t_S_IREAD | _S_IWRITE);\n+}\n+\n+/* Close a file.  */\n+\n+static int\n+pex_win32_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)\n+{\n+  return _close (fd);\n+}\n+\n+/* Execute a child.  */\n+\n+static long\n+pex_win32_exec_child (struct pex_obj *obj ATTRIBUTE_UNUSED, int flags,\n+\t\t      const char *executable, char * const * argv,\n+\t\t      int in, int out, int errdes, const char **errmsg,\n+\t\t      int *err)\n+{\n+  int org_in, org_out, org_errdes;\n+  long pid;\n+\n+  org_in = -1;\n+  org_out = -1;\n+  org_errdes = -1;\n+\n+  if (in != STDIN_FILE_NO)\n     {\n-      if (_pipe (pdes, 256, O_BINARY) < 0)\n+      org_in = _dup (STDIN_FILE_NO);\n+      if (org_in < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup\";\n+\t  return -1;\n+\t}\n+      if (_dup2 (in, STDIN_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (in) < 0)\n \t{\n-\t  *errmsg_fmt = \"pipe\";\n-\t  *errmsg_arg = NULL;\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n \t  return -1;\n \t}\n-      output_desc = pdes[WRITE_PORT];\n-      last_pipe_input = pdes[READ_PORT];\n     }\n-  else\n+\n+  if (out != STDOUT_FILE_NO)\n     {\n-      /* Last process.  */\n-      output_desc = STDOUT_FILE_NO;\n-      last_pipe_input = STDIN_FILE_NO;\n+      org_out = _dup (STDOUT_FILE_NO);\n+      if (org_out < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup\";\n+\t  return -1;\n+\t}\n+      if (_dup2 (out, STDOUT_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (out) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n     }\n \n-  if (input_desc != STDIN_FILE_NO)\n+  if (errdes != STDERR_FILE_NO\n+      || (flags & PEX_STDERR_TO_STDOUT) != 0)\n     {\n-      org_stdin = dup (STDIN_FILE_NO);\n-      dup2 (input_desc, STDIN_FILE_NO);\n-      close (input_desc); \n+      org_errdes = _dup (STDERR_FILE_NO);\n+      if (org_errdes < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup\";\n+\t  return -1;\n+\t}\n+      if (_dup2 ((flags & PEX_STDERR_TO_STDOUT) != 0 ? STDOUT_FILE_NO : errdes,\n+\t\t STDERR_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (errdes != STDERR_FILE_NO)\n+\t{\n+\t  if (_close (errdes) < 0)\n+\t    {\n+\t      *err = errno;\n+\t      *errmsg = \"_close\";\n+\t      return -1;\n+\t    }\n+\t}\n     }\n \n-  if (output_desc != STDOUT_FILE_NO)\n+  pid = (((flags & PEX_SEARCH) != 0 ? _spawnvp : _spawnv)\n+\t (_P_NOWAIT, executable, fix_argv (argv)));\n+\n+  if (pid == -1)\n     {\n-      org_stdout = dup (STDOUT_FILE_NO);\n-      dup2 (output_desc, STDOUT_FILE_NO);\n-      close (output_desc);\n+      *err = errno;\n+      *errmsg = ((flags & PEX_SEARCH) != 0) ? \"_spawnvp\" : \"_spawnv\";\n     }\n \n-  pid = (flags & PEXECUTE_SEARCH ? _spawnvp : _spawnv)\n-    (_P_NOWAIT, program, fix_argv(argv));\n-\n-  if (input_desc != STDIN_FILE_NO)\n+  if (in != STDIN_FILE_NO)\n     {\n-      dup2 (org_stdin, STDIN_FILE_NO);\n-      close (org_stdin);\n+      if (_dup2 (org_in, STDIN_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (org_in) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n     }\n \n-  if (output_desc != STDOUT_FILE_NO)\n+  if (out != STDOUT_FILE_NO)\n     {\n-      dup2 (org_stdout, STDOUT_FILE_NO);\n-      close (org_stdout);\n+      if (_dup2 (org_out, STDOUT_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (org_out) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n     }\n \n-  if (pid == -1)\n+  if (errdes != STDERR_FILE_NO\n+      || (flags & PEX_STDERR_TO_STDOUT) != 0)\n     {\n-      *errmsg_fmt = install_error_msg;\n-      *errmsg_arg = (char*) program;\n-      return -1;\n+      if (_dup2 (org_errdes, STDERR_FILE_NO) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_dup2\";\n+\t  return -1;\n+\t}\n+      if (_close (org_errdes) < 0)\n+\t{\n+\t  *err = errno;\n+\t  *errmsg = \"_close\";\n+\t  return -1;\n+\t}\n     }\n \n   return pid;\n }\n \n-/* MS CRTDLL doesn't return enough information in status to decide if the\n-   child exited due to a signal or not, rather it simply returns an\n-   integer with the exit code of the child; eg., if the child exited with \n-   an abort() call and didn't have a handler for SIGABRT, it simply returns\n-   with status = 3. We fix the status code to conform to the usual WIF*\n-   macros. Note that WIFSIGNALED will never be true under CRTDLL. */\n-\n-int\n-pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)\n+/* Wait for a child process to complete.  MS CRTDLL doesn't return\n+   enough information in status to decide if the child exited due to a\n+   signal or not, rather it simply returns an integer with the exit\n+   code of the child; eg., if the child exited with an abort() call\n+   and didn't have a handler for SIGABRT, it simply returns with\n+   status == 3.  We fix the status code to conform to the usual WIF*\n+   macros.  Note that WIFSIGNALED will never be true under CRTDLL. */\n+\n+static int\n+pex_win32_wait (struct pex_obj *obj ATTRIBUTE_UNUSED, long pid,\n+\t\tint *status, struct pex_time *time, int done ATTRIBUTE_UNUSED,\n+\t\tconst char **errmsg, int *err)\n {\n   int termstat;\n \n-  pid = _cwait (&termstat, pid, WAIT_CHILD);\n+  if (time != NULL)\n+    memset (time, 0, sizeof *time);\n+\n+  /* FIXME: If done is non-zero, we should probably try to kill the\n+     process.  */\n+\n+  if (_cwait (&termstat, pid, WAIT_CHILD) < 0)\n+    {\n+      *err = errno;\n+      *errmsg = \"_cwait\";\n+      return -1;\n+    }\n \n-  /* ??? Here's an opportunity to canonicalize the values in STATUS.\n-     Needed?  */\n+  /* cwait returns the child process exit code in termstat.  A value\n+     of 3 indicates that the child caught a signal, but not which one.\n+     Since only SIGABRT, SIGFPE and SIGINT do anything, we report\n+     SIGABRT.  */\n \n-  /* cwait returns the child process exit code in termstat.\n-     A value of 3 indicates that the child caught a signal, but not\n-     which one.  Since only SIGABRT, SIGFPE and SIGINT do anything, we\n-     report SIGABRT.  */\n   if (termstat == 3)\n     *status = SIGABRT;\n   else\n-    *status = (((termstat) & 0xff) << 8);\n+    *status = ((termstat & 0xff) << 8);\n \n-  return pid;\n+  return 0;\n+}\n+\n+/* Create a pipe.  */\n+\n+static int\n+pex_win32_pipe (struct pex_obj *obj ATTRIBUTE_UNUSED, int *p,\n+\t\tint binary)\n+{\n+  return _pipe (p, 256, binary ? _O_BINARY : _O_TEXT);\n+}\n+\n+/* Get a FILE pointer to read from a file descriptor.  */\n+\n+static FILE *\n+pex_win32_fdopenr (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd,\n+\t\t   int binary)\n+{\n+  return fdopen (fd, binary ? \"rb\" : \"r\");\n }"}, {"sha": "df061107cf3bf48fb483d0fff0fce23828aee00a", "filename": "libiberty/pexecute.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -0,0 +1,121 @@\n+/* Utilities to execute a program in a subprocess (possibly linked by pipes\n+   with other subprocesses), and wait for it.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* pexecute is an old routine.  This implementation uses the newer\n+   pex_init/pex_run/pex_get_status/pex_free routines.  Don't use\n+   pexecute in new code.  Use the newer routines instead.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+/* We only permit a single pexecute chain to execute at a time.  This\n+   was always true anyhow, though it wasn't documented.  */\n+\n+static struct pex_obj *pex;\n+static int idx;\n+\n+int\n+pexecute (const char *program, char * const *argv, const char *pname,\n+\t  const char *temp_base, char **errmsg_fmt, char **errmsg_arg,\n+\t  int flags)\n+{\n+  const char *errmsg;\n+  int err;\n+\n+  if ((flags & PEXECUTE_FIRST) != 0)\n+    {\n+      if (pex != NULL)\n+\t{\n+\t  *errmsg_fmt = \"pexecute already in progress\";\n+\t  *errmsg_arg = NULL;\n+\t  return -1;\n+\t}\n+      pex = pex_init (PEX_USE_PIPES, pname, temp_base);\n+      idx = 0;\n+    }\n+  else\n+    {\n+      if (pex == NULL)\n+\t{\n+\t  *errmsg_fmt = \"pexecute not in progress\";\n+\t  *errmsg_arg = NULL;\n+\t  return -1;\n+\t}\n+    }\n+\n+  errmsg = pex_run (pex,\n+\t\t    (((flags & PEXECUTE_LAST) != 0 ? PEX_LAST : 0)\n+\t\t     | ((flags & PEXECUTE_SEARCH) != 0 ? PEX_SEARCH : 0)),\n+\t\t    program, argv, NULL, NULL, &err);\n+  if (errmsg != NULL)\n+    {\n+      *errmsg_fmt = (char *) errmsg;\n+      *errmsg_arg = NULL;\n+      return -1;\n+    }\n+\n+  /* Instead of a PID, we just return a one-based index into the\n+     status values.  We avoid zero just because the old pexecute would\n+     never return it.  */\n+  return ++idx;\n+}\n+\n+int\n+pwait (int pid, int *status, int flags ATTRIBUTE_UNUSED)\n+{\n+  /* The PID returned by pexecute is one-based.  */\n+  --pid;\n+\n+  if (pex == NULL || pid < 0 || pid >= idx)\n+    return -1;\n+\n+  if (pid == 0 && idx == 1)\n+    {\n+      if (!pex_get_status (pex, 1, status))\n+\treturn -1;\n+    }\n+  else\n+    {\n+      int *vector;\n+\n+      vector = xmalloc (idx * sizeof (int));\n+      if (!pex_get_status (pex, idx, vector))\n+\treturn -1;\n+      *status = vector[pid];\n+      free (vector);\n+    }\n+\n+  /* Assume that we are done after the caller has retrieved the last\n+     exit status.  The original implementation did not require that\n+     the exit statuses be retrieved in order, but this implementation\n+     does.  */\n+  if (pid + 1 == idx)\n+    {\n+      pex_free (pex);\n+      pex = NULL;\n+      idx = 0;\n+    }\n+\n+  return pid + 1;\n+}"}, {"sha": "c06d55cd315c762f7d09491f377f44970f48716b", "filename": "libiberty/pexecute.txh", "status": "modified", "additions": 165, "deletions": 43, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpexecute.txh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Fpexecute.txh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpexecute.txh?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -1,63 +1,185 @@\n-@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n+@deftypefn Extension struct pex_obj *pex_init (int @var{flags}, const char *@var{pname}, const char *@var{tempbase})\n \n-Executes a program.\n+Prepare to execute one or more programs, with standard output of each\n+program fed to standard input of the next.  This is a system\n+independent interface to execute a pipeline.\n \n-@var{program} and @var{argv} are the arguments to\n-@code{execv}/@code{execvp}.\n+@var{flags} is a bitwise combination of the following:\n \n-@var{this_pname} is name of the calling program (i.e., @code{argv[0]}).\n+@table @code\n \n-@var{temp_base} is the path name, sans suffix, of a temporary file to\n-use if needed.  This is currently only needed for MS-DOS ports that\n-don't use @code{go32} (do any still exist?).  Ports that don't need it\n-can pass @code{NULL}.\n+@vindex PEX_RECORD_TIMES\n+@item PEX_RECORD_TIMES\n+Record subprocess times if possible.\n \n-(@code{@var{flags} & PEXECUTE_SEARCH}) is non-zero if @env{PATH}\n-should be searched (??? It's not clear that GCC passes this flag\n-correctly).  (@code{@var{flags} & PEXECUTE_FIRST}) is nonzero for the\n-first process in chain.  (@code{@var{flags} & PEXECUTE_FIRST}) is\n-nonzero for the last process in chain.  The first/last flags could be\n-simplified to only mark the last of a chain of processes but that\n-requires the caller to always mark the last one (and not give up\n-early if some error occurs).  It's more robust to require the caller\n-to mark both ends of the chain.\n+@vindex PEX_USE_PIPES\n+@item PEX_USE_PIPES\n+Use pipes for communication between processes, if possible.\n \n-The result is the pid on systems like Unix where we\n-@code{fork}/@code{exec} and on systems like WIN32 and OS/2 where we\n-use @code{spawn}.  It is up to the caller to wait for the child.\n+@vindex PEX_SAVE_TEMPS\n+@item PEX_SAVE_TEMPS\n+Don't delete temporary files used for communication between\n+processes.\n \n-The result is the @code{WEXITSTATUS} on systems like MS-DOS where we\n-@code{spawn} and wait for the child here.\n+@end table\n \n-Upon failure, @var{errmsg_fmt} and @var{errmsg_arg} are set to the\n-text of the error message with an optional argument (if not needed,\n-@var{errmsg_arg} is set to @code{NULL}), and @minus{}1 is returned.\n-@code{errno} is available to the caller to use.\n+@var{pname} is the name of program to be executed, used in error\n+messages.  @var{tempbase} is a base name to use for any required\n+temporary files; it may be @code{NULL} to use a randomly chosen name.\n \n @end deftypefn\n \n-@deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n+@deftypefn Extension const char *pex_run (struct pex_obj *@var{obj}, int @var{flags}, const char *@var{executable}, char * const *@var{argv}, const char *@var{outname}, const char *@var{errname}, int *@var{err})\n+\n+Execute one program in a pipeline.  On success this returns\n+@code{NULL}.  On failure it returns an error message, a statically\n+allocated string.\n+\n+@var{obj} is returned by a previous call to @code{pex_init}.\n+\n+@var{flags} is a bitwise combination of the following:\n+\n+@table @code\n+\n+@vindex PEX_LAST\n+@item PEX_LAST\n+This must be set on the last program in the pipeline.  In particular,\n+it should be set when executing a single program.  The standard output\n+of the program will be sent to @var{outname}, or, if @var{outname} is\n+@code{NULL}, to the standard output of the calling program.  This\n+should not be set if you want to call @code{pex_read_output}\n+(described below).  After a call to @code{pex_run} with this bit set,\n+@var{pex_run} may no longer be called with the same @var{obj}.\n+\n+@vindex PEX_SEARCH\n+@item PEX_SEARCH\n+Search for the program using the user's executable search path.\n+\n+@vindex PEX_SUFFIX\n+@item PEX_SUFFIX\n+@var{outname} is a suffix.  See the description of @var{outname},\n+below.\n+\n+@vindex PEX_STDERR_TO_STDOUT\n+@item PEX_STDERR_TO_STDOUT\n+Send the program's standard error to standard output, if possible.\n+\n+@vindex PEX_BINARY_INPUT\n+@vindex PEX_BINARY_OUTPUT\n+@item PEX_BINARY_INPUT\n+@itemx PEX_BINARY_OUTPUT\n+The standard input (output) of the program should be read (written) in\n+binary mode rather than text mode.  These flags are ignored on systems\n+which do not distinguish binary mode and text mode, such as Unix.  For\n+proper behavior these flags should match appropriately--a call to\n+@code{pex_run} using @code{PEX_BINARY_OUTPUT} should be followed by a\n+call using @code{PEX_BINARY_INPUT}.\n+@end table\n+\n+@var{executable} is the program to execute.  @var{argv} is the set of\n+arguments to pass to the program; normally @code{@var{argv}[0]} will\n+be a copy of @var{executable}.\n+\n+@var{outname} is used to set the name of the file to use for standard\n+output.  There are two cases in which no output file will be used: 1)\n+if @code{PEX_LAST} is not set in @var{flags}, and @code{PEX_USE_PIPES}\n+was set in the call to @code{pex_init}, and the system supports pipes;\n+2) if @code{PEX_LAST} is set in @var{flags}, and @var{outname} is\n+@code{NULL}.  Otherwise the code will use a file to hold standard\n+output.  If @code{PEX_LAST} is not set, this file is considered to be\n+a temporary file, and it will be removed when no longer needed, unless\n+@code{PEX_SAVE_TEMPS} was set in the call to @code{pex_init}.\n+\n+There are two cases to consider when setting the name of the file to\n+hold standard output.\n+\n+First case: @code{PEX_SUFFIX} is set in @var{flags}.  In this case\n+@var{outname} may not be @code{NULL}.  If the @var{tempbase} parameter\n+to @code{pex_init} was not @code{NULL}, then the output file name is\n+the concatenation of @var{tempbase} and @var{outname}.  If\n+@var{tempbase} was @code{NULL}, then the output file name is a random\n+file name ending in @var{outname}.\n+\n+Second case: @code{PEX_SUFFIX} was not set in @var{flags}.  In this\n+case, if @var{outname} is not @code{NULL}, it is used as the output\n+file name.  If @var{outname} is @code{NULL}, and @var{tempbase} was\n+not NULL, the output file name is randomly chosen using\n+@var{tempbase}.  Otherwise the output file name is chosen completely\n+at random.\n+\n+@var{errname} is the file name to use for standard error output.  If\n+it is @code{NULL}, standard error is the same as the caller.\n+Otherwise, standard error is written to the named file.\n+\n+On an error return, the code sets @code{*@var{err}} to an @code{errno}\n+value, or to 0 if there is no relevant @code{errno}.\n+\n+@end deftypefn\n+\n+@deftypefn Extension FILE * pex_read_output (struct pex_obj *@var{obj}, int @var{binary})\n+\n+Returns a @code{FILE} pointer which may be used to read the standard\n+output of the last program in the pipeline.  When this is used,\n+@code{PEX_LAST} should not be used in a call to @code{pex_run}.  After\n+this is called, @code{pex_run} may no longer be called with the same\n+@var{obj}.  @var{binary} should be non-zero if the file should be\n+opened in binary mode.  Don't call @code{fclose} on the returned file;\n+it will be closed by @code{pex_free}.\n+\n+@end deftypefn\n+\n+@deftypefn Extension int pex_get_status (struct pex_obj *@var{obj}, int @var{count}, int *@var{vector})\n+\n+Returns the exit status of all programs run using @var{obj}.\n+@var{count} is the number of results expected.  The results will be\n+placed into @var{vector}.  The results are in the order of the calls\n+to @code{pex_run}.  Returns 0 on error, 1 on success.\n+\n+@end deftypefn\n+\n+@deftypefn Extension int pex_get_times (struct pex_obj *@var{obj}, int @var{count}, struct pex_time *@var{vector})\n \n-Waits for a program started by @code{pexecute} to finish.\n+Returns the process execution times of all programs run using\n+@var{obj}.  @var{count} is the number of results expected.  The\n+results will be placed into @var{vector}.  The results are in the\n+order of the calls to @code{pex_run}.  Returns 0 on error, 1 on\n+success.\n \n-@var{pid} is the process id of the task to wait for. @var{status} is\n-the `status' argument to wait. @var{flags} is currently unused\n-(allows future enhancement without breaking upward compatibility).\n-Pass 0 for now.\n+@code{struct pex_time} has the following fields: @code{user_seconds},\n+@code{user_microseconds}, @code{system_seconds},\n+@code{system_microseconds}.  On systems which do not support reporting\n+process times, all the fields will be set to @code{0}.\n \n-The result is the pid of the child reaped, or -1 for failure\n-(@code{errno} says why).\n+@end deftypefn\n+\n+@deftypefn Extension void pex_free (struct pex_obj @var{obj})\n \n-On systems that don't support waiting for a particular child,\n-@var{pid} is ignored.  On systems like MS-DOS that don't really\n-multitask @code{pwait} is just a mechanism to provide a consistent\n-interface for the caller.\n+Clean up and free all data associated with @var{obj}.\n \n @end deftypefn\n \n-@undocumented pfinish\n+@deftypefn Extension const char *pex_one (int @var{flags}, const char *@var{executable}, char * const *@var{argv}, const char *@var{pname}, const char *@var{outname}, const char *@var{errname}, int *@var{status}, int *@var{err})\n+\n+An interface to @code{pex_init} to permit the easy execution of a\n+single program.  The return value and most of the parameters are as\n+for a call to @code{pex_run}.  @var{flags} is restricted to a\n+combination of @code{PEX_SEARCH}, @code{PEX_STDERR_TO_STDOUT}, and\n+@code{PEX_BINARY_OUTPUT}.  @var{outname} is interpreted as if\n+@code{PEX_LAST} were set.  On a successful return, *@var{status} will\n+be set to the exit status of the program.\n+\n+@end deftypefn\n+\n+@deftypefn Extension int pexecute (const char *@var{program}, char * const *@var{argv}, const char *@var{this_pname}, const char *@var{temp_base}, char **@var{errmsg_fmt}, char **@var{errmsg_arg}, int flags)\n \n-pfinish: finish generation of script\n+This is the old interface to execute one or more programs.  It is\n+still supported for compatibility purposes, but is no longer\n+documented.\n \n-pfinish is necessary for systems like MPW where a script is generated\n-that runs the requested programs.\n+@end deftypefn\n+\n+@deftypefn Extension int pwait (int @var{pid}, int *@var{status}, int @var{flags})\n+\n+Another part of the old execution interface.\n+\n+@end deftypefn"}, {"sha": "e15f6fa191acd455774e9b3f5410de288023b0ec", "filename": "libiberty/testsuite/Makefile.in", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2FMakefile.in?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -42,17 +42,28 @@ INCDIR=$(srcdir)/../$(MULTISRCTOP)../include\n \n all:\n \n+# CHECK is set to \"really_check\" or the empty string by configure.\n check: @CHECK@\n \n+really-check: check-cplus-dem check-pexecute\n+\n # Run some tests of the demangler.\n check-cplus-dem: test-demangle $(srcdir)/demangle-expected\n \t./test-demangle < $(srcdir)/demangle-expected\n \n+# Check the pexecute code.\n+check-pexecute: test-pexecute\n+\t./test-pexecute\n+\n TEST_COMPILE = $(CC) @DEFS@ $(LIBCFLAGS) -I.. -I$(INCDIR) $(HDEFINES)\n test-demangle: $(srcdir)/test-demangle.c ../libiberty.a\n \t$(TEST_COMPILE) -o test-demangle \\\n \t\t$(srcdir)/test-demangle.c ../libiberty.a\n \n+test-pexecute: $(srcdir)/test-pexecute.c ../libiberty.a\n+\t$(TEST_COMPILE) -DHAVE_CONFIG_H -I.. -o test-pexecute \\\n+\t\t$(srcdir)/test-pexecute.c ../libiberty.a\n+\n # Standard (either GNU or Cygnus) rules we don't use.\n info install-info clean-info dvi install etags tags installcheck:\n "}, {"sha": "c67bcefb8f680ec889b5627f902a219fbb0bee23", "filename": "libiberty/testsuite/test-pexecute.c", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Ftestsuite%2Ftest-pexecute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a584cf65fa83edcdbcf903b479414b04ddcd07ee/libiberty%2Ftestsuite%2Ftest-pexecute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Ftest-pexecute.c?ref=a584cf65fa83edcdbcf903b479414b04ddcd07ee", "patch": "@@ -0,0 +1,521 @@\n+/* Pexecute test program,\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor <ian@airs.com>.\n+\n+   This file is part of GNU libiberty.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. \n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+#include \"ansidecl.h\"\n+#include \"libiberty.h\"\n+#include <stdio.h>\n+#include <signal.h>\n+#include <errno.h>\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#include <sys/types.h>\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_SYS_WAIT_H\n+#include <sys/wait.h>\n+#endif\n+#ifdef HAVE_SYS_TIME_H\n+#include <sys/time.h>\n+#endif\n+#ifdef HAVE_SYS_RESOURCE_H\n+#include <sys/resource.h>\n+#endif\n+\n+#ifndef WIFSIGNALED\n+#define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)\n+#endif\n+#ifndef WTERMSIG\n+#define WTERMSIG(S) ((S) & 0x7f)\n+#endif\n+#ifndef WIFEXITED\n+#define WIFEXITED(S) (((S) & 0xff) == 0)\n+#endif\n+#ifndef WEXITSTATUS\n+#define WEXITSTATUS(S) (((S) & 0xff00) >> 8)\n+#endif\n+#ifndef WSTOPSIG\n+#define WSTOPSIG WEXITSTATUS\n+#endif\n+#ifndef WCOREDUMP\n+#define WCOREDUMP(S) ((S) & WCOREFLG)\n+#endif\n+#ifndef WCOREFLG\n+#define WCOREFLG 0200\n+#endif\n+\n+#ifndef EXIT_SUCCESS\n+#define EXIT_SUCCESS 0\n+#endif\n+\n+#ifndef EXIT_FAILURE\n+#define EXIT_FAILURE 1\n+#endif\n+\n+/* When this program is run with no arguments, it runs some tests of\n+   the libiberty pexecute functions.  As a test program, it simply\n+   invokes itself with various arguments.\n+\n+   argv[1]:\n+     *empty string*      Run tests, exit with success status\n+     exit                Exit success\n+     error               Exit error\n+     abort               Abort\n+     echo                Echo remaining arguments, exit success\n+     echoerr             Echo next arg to stdout, next to stderr, repeat\n+     copy                Copy stdin to stdout\n+     write               Write stdin to file named in next argument\n+*/\n+\n+static void fatal_error (int, const char *, int) ATTRIBUTE_NORETURN;\n+static void error (int, const char *);\n+static void check_line (int, FILE *, const char *);\n+static void do_cmd (int, char **) ATTRIBUTE_NORETURN;\n+\n+/* The number of errors we have seen.  */\n+\n+static int error_count;\n+\n+/* Print a fatal error and exit.  LINE is the line number where we\n+   detected the error, ERRMSG is the error message to print, and ERR\n+   is 0 or an errno value to print.  */\n+\n+static void\n+fatal_error (int line, const char *errmsg, int err)\n+{\n+  fprintf (stderr, \"test-pexecute:%d: %s\", line, errmsg);\n+  if (errno != 0)\n+    fprintf (stderr, \": %s\", xstrerror (err));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}\n+\n+#define FATAL_ERROR(ERRMSG, ERR) fatal_error (__LINE__, ERRMSG, ERR)\n+\n+/* Print an error message and bump the error count.  LINE is the line\n+   number where we detected the error, ERRMSG is the error to\n+   print.  */\n+\n+static void\n+error (int line, const char *errmsg)\n+{\n+  fprintf (stderr, \"test-pexecute:%d: %s\\n\", line, errmsg);\n+  ++error_count;\n+}\n+\n+#define ERROR(ERRMSG) error (__LINE__, ERRMSG)\n+\n+/* Check a line in a file.  */\n+\n+static void\n+check_line (int line, FILE *e, const char *str)\n+{\n+  const char *p;\n+  int c;\n+  char buf[1000];\n+\n+  p = str;\n+  while (1)\n+    {\n+      c = getc (e);\n+\n+      if (*p == '\\0')\n+\t{\n+\t  if (c != '\\n')\n+\t    {\n+\t      snprintf (buf, sizeof buf, \"got '%c' when expecting newline\", c);\n+\t      fatal_error (line, buf, 0);\n+\t    }\n+\t  c = getc (e);\n+\t  if (c != EOF)\n+\t    {\n+\t      snprintf (buf, sizeof buf, \"got '%c' when expecting EOF\", c);\n+\t      fatal_error (line, buf, 0);\n+\t    }\n+\t  return;\n+\t}\n+\n+      if (c != *p)\n+\t{\n+\t  snprintf (buf, sizeof buf, \"expected '%c', got '%c'\", *p, c);\n+\t  fatal_error (line, buf, 0);\n+\t}\n+\n+      ++p;\n+    }\n+}\n+\n+#define CHECK_LINE(E, STR) check_line (__LINE__, E, STR)\n+\n+/* Main function for the pexecute tester.  Run the tests.  */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int trace;\n+  struct pex_obj *test_pex_tmp;\n+  int test_pex_status;\n+  FILE *test_pex_file;\n+  struct pex_obj *pex1;\n+  char *subargv[10];\n+  int status;\n+  FILE *e;\n+  int statuses[10];\n+\n+  trace = 0;\n+  if (argc > 1 && strcmp (argv[1], \"-t\") == 0)\n+    {\n+      trace = 1;\n+      --argc;\n+      ++argv;\n+    }\n+\n+  if (argc > 1)\n+    do_cmd (argc, argv);\n+\n+#define TEST_PEX_INIT(FLAGS, TEMPBASE)\t\t\t\t\t\\\n+  (((test_pex_tmp = pex_init (FLAGS, \"test-pexecute\", TEMPBASE))\t\\\n+    != NULL)\t\t\t\t\t\t\t\t\\\n+   ? test_pex_tmp\t\t\t\t\t\t\t\\\n+   : (FATAL_ERROR (\"pex_init failed\", 0), NULL))\n+\n+#define TEST_PEX_RUN(PEXOBJ, FLAGS, EXECUTABLE, ARGV, OUTNAME, ERRNAME)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int err;\t\t\t\t\t\t\t\t\\\n+      if (trace)\t\t\t\t\t\t\t\\\n+\tfprintf (stderr, \"Line %d: running %s %s\\n\",\t\t\t\\\n+\t\t __LINE__, EXECUTABLE, ARGV[0]);\t\t\t\\\n+      const char *pex_run_err = pex_run (PEXOBJ, FLAGS, EXECUTABLE,\t\\\n+\t\t\t\t\t ARGV, OUTNAME, ERRNAME, &err);\t\\\n+      if (pex_run_err != NULL)\t\t\t\t\t\t\\\n+\tFATAL_ERROR (pex_run_err, err);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_PEX_GET_STATUS_1(PEXOBJ)\t\t\t\t\t\\\n+  (pex_get_status (PEXOBJ, 1, &test_pex_status)\t\t\t\t\\\n+   ? test_pex_status\t\t\t\t\t\t\t\\\n+   : (FATAL_ERROR (\"pex_get_status failed\", errno), 1))\n+\n+#define TEST_PEX_GET_STATUS(PEXOBJ, COUNT, VECTOR)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (!pex_get_status (PEXOBJ, COUNT, VECTOR))\t\t\t\\\n+\tFATAL_ERROR (\"pex_get_status failed\", errno);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_PEX_READ_OUTPUT(PEXOBJ)\t\t\t\t\t\\\n+  ((test_pex_file = pex_read_output (PEXOBJ, 0)) != NULL\t\t\\\n+   ? test_pex_file\t\t\t\t\t\t\t\\\n+   : (FATAL_ERROR (\"pex_read_output failed\", errno), NULL))\n+\n+  remove (\"temp.x\");\n+  remove (\"temp.y\");\n+\n+  memset (subargv, 0, sizeof subargv);\n+\n+  subargv[0] = \"./test-pexecute\";\n+\n+  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, NULL);\n+  subargv[1] = \"exit\";\n+  subargv[2] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_LAST, \"./test-pexecute\", subargv, NULL, NULL);\n+  status = TEST_PEX_GET_STATUS_1 (pex1);\n+  if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_SUCCESS)\n+    ERROR (\"exit failed\");\n+  pex_free (pex1);\n+\n+  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, NULL);\n+  subargv[1] = \"error\";\n+  subargv[2] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_LAST, \"./test-pexecute\", subargv, NULL, NULL);\n+  status = TEST_PEX_GET_STATUS_1 (pex1);\n+  if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_FAILURE)\n+    ERROR (\"error test failed\");\n+  pex_free (pex1);\n+\n+  /* We redirect stderr to a file to avoid an error message which is\n+     printed on mingw32 when the child calls abort.  */\n+  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, NULL);\n+  subargv[1] = \"abort\";\n+  subargv[2] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_LAST, \"./test-pexecute\", subargv, NULL, \"temp.z\");\n+  status = TEST_PEX_GET_STATUS_1 (pex1);\n+  if (!WIFSIGNALED (status) || WTERMSIG (status) != SIGABRT)\n+    ERROR (\"abort failed\");\n+  pex_free (pex1);\n+  remove (\"temp.z\");\n+\n+  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, \"temp\");\n+  subargv[1] = \"echo\";\n+  subargv[2] = \"foo\";\n+  subargv[3] = NULL;\n+  TEST_PEX_RUN (pex1, 0, \"./test-pexecute\", subargv, NULL, NULL);\n+  e = TEST_PEX_READ_OUTPUT (pex1);\n+  CHECK_LINE (e, \"foo\");\n+  if (TEST_PEX_GET_STATUS_1 (pex1) != 0)\n+    ERROR (\"echo exit status failed\");\n+  pex_free (pex1);\n+\n+  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, \"temp\");\n+  subargv[1] = \"echo\";\n+  subargv[2] = \"bar\";\n+  subargv[3] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", NULL);\n+  subargv[1] = \"copy\";\n+  subargv[2] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n+  e = TEST_PEX_READ_OUTPUT (pex1);\n+  CHECK_LINE (e, \"bar\");\n+  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n+  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n+      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n+    ERROR (\"copy exit status failed\");\n+  pex_free (pex1);\n+  if (fopen (\"temp.x\", \"r\") != NULL || fopen (\"temp.y\", \"r\") != NULL)\n+    ERROR (\"temporary files exist\");\n+\n+  pex1 = TEST_PEX_INIT (0, \"temp\");\n+  subargv[1] = \"echo\";\n+  subargv[2] = \"bar\";\n+  subargv[3] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", NULL);\n+  subargv[1] = \"copy\";\n+  subargv[2] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n+  e = TEST_PEX_READ_OUTPUT (pex1);\n+  CHECK_LINE (e, \"bar\");\n+  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n+  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n+      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n+    ERROR (\"copy exit status failed\");\n+  pex_free (pex1);\n+  if (fopen (\"temp.x\", \"r\") != NULL || fopen (\"temp.y\", \"r\") != NULL)\n+    ERROR (\"temporary files exist\");\n+\n+  pex1 = TEST_PEX_INIT (PEX_SAVE_TEMPS, \"temp\");\n+  subargv[1] = \"echo\";\n+  subargv[2] = \"quux\";\n+  subargv[3] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", NULL);\n+  subargv[1] = \"copy\";\n+  subargv[2] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n+  e = TEST_PEX_READ_OUTPUT (pex1);\n+  CHECK_LINE (e, \"quux\");\n+  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n+  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n+      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n+    ERROR (\"copy temp exit status failed\");\n+  e = fopen (\"temp.x\", \"r\");\n+  if (e == NULL)\n+    FATAL_ERROR (\"fopen temp.x failed in copy temp\", errno);\n+  CHECK_LINE (e, \"quux\");\n+  fclose (e);\n+  e = fopen (\"temp.y\", \"r\");\n+  if (e == NULL)\n+    FATAL_ERROR (\"fopen temp.y failed in copy temp\", errno);\n+  CHECK_LINE (e, \"quux\");\n+  fclose (e);\n+  pex_free (pex1);\n+  remove (\"temp.x\");\n+  remove (\"temp.y\");\n+\n+  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, \"temp\");\n+  subargv[1] = \"echoerr\";\n+  subargv[2] = \"one\";\n+  subargv[3] = \"two\";\n+  subargv[4] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".x\", \"temp2.x\");\n+  subargv[1] = \"write\";\n+  subargv[2] = \"temp2.y\";\n+  subargv[3] = NULL;\n+  TEST_PEX_RUN (pex1, PEX_SUFFIX, \"./test-pexecute\", subargv, \".y\", NULL);\n+  TEST_PEX_GET_STATUS (pex1, 2, statuses);\n+  if (!WIFEXITED (statuses[0]) || WEXITSTATUS (statuses[0]) != EXIT_SUCCESS\n+      || !WIFEXITED (statuses[1]) || WEXITSTATUS (statuses[1]) != EXIT_SUCCESS)\n+    ERROR (\"echoerr exit status failed\");\n+  pex_free (pex1);\n+  if (fopen (\"temp.x\", \"r\") != NULL || fopen (\"temp.y\", \"r\") != NULL)\n+    ERROR (\"temporary files exist\");\n+  e = fopen (\"temp2.x\", \"r\");\n+  if (e == NULL)\n+    FATAL_ERROR (\"fopen temp2.x failed in echoerr\", errno);\n+  CHECK_LINE (e, \"two\");\n+  fclose (e);\n+  e = fopen (\"temp2.y\", \"r\");\n+  if (e == NULL)\n+    FATAL_ERROR (\"fopen temp2.y failed in echoerr\", errno);\n+  CHECK_LINE (e, \"one\");\n+  fclose (e);\n+  remove (\"temp2.x\");\n+  remove (\"temp2.y\");\n+\n+  /* Test the old pexecute interface.  */\n+  {\n+    int pid1, pid2;\n+    char *errmsg_fmt;\n+    char *errmsg_arg;\n+    char errbuf1[1000];\n+    char errbuf2[1000];\n+\n+    subargv[1] = \"echo\";\n+    subargv[2] = \"oldpexecute\";\n+    subargv[3] = NULL;\n+    pid1 = pexecute (\"./test-pexecute\", subargv, \"test-pexecute\", \"temp\",\n+\t\t     &errmsg_fmt, &errmsg_arg, PEXECUTE_FIRST);\n+    if (pid1 < 0)\n+      {\n+\tsnprintf (errbuf1, sizeof errbuf1, errmsg_fmt, errmsg_arg);\n+\tsnprintf (errbuf2, sizeof errbuf2, \"pexecute 1 failed: %s\", errbuf1);\n+\tFATAL_ERROR (errbuf2, 0);\n+      }\n+\n+    subargv[1] = \"write\";\n+    subargv[2] = \"temp.y\";\n+    subargv[3] = NULL;\n+    pid2 = pexecute (\"./test-pexecute\", subargv, \"test-pexecute\", \"temp\",\n+\t\t     &errmsg_fmt, &errmsg_arg, PEXECUTE_LAST);\n+    if (pid2 < 0)\n+      {\n+\tsnprintf (errbuf1, sizeof errbuf1, errmsg_fmt, errmsg_arg);\n+\tsnprintf (errbuf2, sizeof errbuf2, \"pexecute 2 failed: %s\", errbuf1);\n+\tFATAL_ERROR (errbuf2, 0);\n+      }\n+\n+    if (pwait (pid1, &status, 0) < 0)\n+      FATAL_ERROR (\"write pwait 1 failed\", errno);\n+    if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_SUCCESS)\n+      ERROR (\"write exit status 1 failed\");\n+\n+    if (pwait (pid2, &status, 0) < 0)\n+      FATAL_ERROR (\"write pwait 1 failed\", errno);\n+    if (!WIFEXITED (status) || WEXITSTATUS (status) != EXIT_SUCCESS)\n+      ERROR (\"write exit status 2 failed\");\n+\n+    e = fopen (\"temp.y\", \"r\");\n+    if (e == NULL)\n+      FATAL_ERROR (\"fopen temp.y failed in copy temp\", errno);\n+    CHECK_LINE (e, \"oldpexecute\");\n+    fclose (e);\n+\n+    remove (\"temp.y\");\n+  }\n+\n+  if (trace)\n+    fprintf (stderr, \"Exiting with status %d\\n\", error_count);\n+\n+  return error_count;\n+}\n+\n+/* Execute one of the special testing commands.  */\n+\n+static void\n+do_cmd (int argc, char **argv)\n+{\n+  const char *s;\n+\n+  /* Try to prevent generating a core dump.  */\n+#ifdef RLIMIT_CORE\n+ {\n+   struct rlimit r;\n+\n+   r.rlim_cur = 0;\n+   r.rlim_max = 0;\n+   setrlimit (RLIMIT_CORE, &r);\n+ }\n+#endif\n+\n+  s = argv[1];\n+  if (strcmp (s, \"exit\") == 0)\n+    exit (EXIT_SUCCESS);\n+  else if (strcmp (s, \"echo\") == 0)\n+    {\n+      int i;\n+\n+      for (i = 2; i < argc; ++i)\n+\t{\n+\t  if (i > 2)\n+\t    putchar (' ');\n+\t  fputs (argv[i], stdout);\n+\t}\n+      putchar ('\\n');\n+      exit (EXIT_SUCCESS);\n+    }\n+  else if (strcmp (s, \"echoerr\") == 0)\n+    {\n+      int i;\n+\n+      for (i = 2; i < argc; ++i)\n+\t{\n+\t  if (i > 3)\n+\t    putc (' ', (i & 1) == 0 ? stdout : stderr);\n+\t  fputs (argv[i], (i & 1) == 0 ? stdout : stderr);\n+\t}\n+      putc ('\\n', stdout);\n+      putc ('\\n', stderr);\n+      exit (EXIT_SUCCESS);\n+    }\n+  else if (strcmp (s, \"error\") == 0)\n+    exit (EXIT_FAILURE);\n+  else if (strcmp (s, \"abort\") == 0)\n+    abort ();\n+  else if (strcmp (s, \"copy\") == 0)\n+    {\n+      int c;\n+\n+      while ((c = getchar ()) != EOF)\n+\tputchar (c);\n+      exit (EXIT_SUCCESS);\n+    }\n+  else if (strcmp (s, \"write\") == 0)\n+    {\n+      FILE *e;\n+      int c;\n+\n+      e = fopen (argv[2], \"w\");\n+      if (e == NULL)\n+\tFATAL_ERROR (\"fopen for write failed\", errno);\n+      while ((c = getchar ()) != EOF)\n+\tputc (c, e);\n+      if (fclose (e) != 0)\n+\tFATAL_ERROR (\"fclose for write failed\", errno);\n+      exit (EXIT_SUCCESS);\n+    }\n+  else\n+    {\n+      char buf[1000];\n+\n+      snprintf (buf, sizeof buf, \"unrecognized command %s\", argv[1]);\n+      FATAL_ERROR (buf, 0);\n+    }\n+\n+  exit (EXIT_FAILURE);\n+}"}]}