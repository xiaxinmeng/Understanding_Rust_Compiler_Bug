{"sha": "da9e0b98ac9d41b41520b5e587621707d59ae0f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE5ZTBiOThhYzlkNDFiNDE1MjBiNWU1ODc2MjE3MDdkNTlhZTBmNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-06T06:34:27Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-06T06:34:27Z"}, "message": "Use backend interface for interface types.\n\nFrom-SVN: r173469", "tree": {"sha": "5d9e279daaee3f18d0afe7674faf5644be1e3d4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d9e279daaee3f18d0afe7674faf5644be1e3d4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da9e0b98ac9d41b41520b5e587621707d59ae0f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9e0b98ac9d41b41520b5e587621707d59ae0f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9e0b98ac9d41b41520b5e587621707d59ae0f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9e0b98ac9d41b41520b5e587621707d59ae0f6/comments", "author": null, "committer": null, "parents": [{"sha": "3d528853ba1106b3cbd6eca4316ab2825416b9a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d528853ba1106b3cbd6eca4316ab2825416b9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d528853ba1106b3cbd6eca4316ab2825416b9a6"}], "stats": {"total": 205, "additions": 91, "deletions": 114}, "files": [{"sha": "a03ab1fbe11ecaf5f991ad4a68e06c01b347d1bc", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 89, "deletions": 104, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9e0b98ac9d41b41520b5e587621707d59ae0f6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9e0b98ac9d41b41520b5e587621707d59ae0f6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=da9e0b98ac9d41b41520b5e587621707d59ae0f6", "patch": "@@ -6003,124 +6003,99 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n   return true;\n }\n \n-// Return a tree for an interface type.  An interface is a pointer to\n-// a struct.  The struct has three fields.  The first field is a\n-// pointer to the type descriptor for the dynamic type of the object.\n-// The second field is a pointer to a table of methods for the\n-// interface to be used with the object.  The third field is the value\n-// of the object itself.\n+// Return the backend representation of the empty interface type.  We\n+// use the same struct for all empty interfaces.\n \n-tree\n-Interface_type::do_get_tree(Gogo* gogo)\n+Btype*\n+Interface_type::get_backend_empty_interface_type(Gogo* gogo)\n {\n-  if (this->methods_ == NULL)\n-    return Interface_type::empty_type_tree(gogo);\n-  else\n+  static Btype* empty_interface_type;\n+  if (empty_interface_type == NULL)\n     {\n-      tree t = Interface_type::non_empty_type_tree(this->location_);\n-      return this->fill_in_tree(gogo, t);\n-    }\n-}\n+      std::vector<Backend::Btyped_identifier> bfields(2);\n \n-// Return a singleton struct for an empty interface type.  We use the\n-// same type for all empty interfaces.  This lets us assign them to\n-// each other directly without triggering GIMPLE type errors.\n+      Type* pdt = Type::make_type_descriptor_ptr_type();\n+      bfields[0].name = \"__type_descriptor\";\n+      bfields[0].btype = tree_to_type(pdt->get_tree(gogo));\n+      bfields[0].location = UNKNOWN_LOCATION;\n \n-tree\n-Interface_type::empty_type_tree(Gogo* gogo)\n-{\n-  static tree empty_interface;\n-  if (empty_interface != NULL_TREE)\n-    return empty_interface;\n+      Type* vt = Type::make_pointer_type(Type::make_void_type());\n+      bfields[1].name = \"__object\";\n+      bfields[1].btype = tree_to_type(vt->get_tree(gogo));\n+      bfields[1].location = UNKNOWN_LOCATION;\n \n-  tree dtype = Type::make_type_descriptor_type()->get_tree(gogo);\n-  dtype = build_pointer_type(build_qualified_type(dtype, TYPE_QUAL_CONST));\n-  return Gogo::builtin_struct(&empty_interface, \"__go_empty_interface\",\n-\t\t\t      NULL_TREE, 2,\n-\t\t\t      \"__type_descriptor\",\n-\t\t\t      dtype,\n-\t\t\t      \"__object\",\n-\t\t\t      ptr_type_node);\n+      empty_interface_type = gogo->backend()->struct_type(bfields);\n+    }\n+  return empty_interface_type;\n }\n \n-// Return a new struct for a non-empty interface type.  The correct\n-// values are filled in by fill_in_tree.\n+// Return the fields of a non-empty interface type.  This is not\n+// declared in types.h so that types.h doesn't have to #include\n+// backend.h.\n \n-tree\n-Interface_type::non_empty_type_tree(source_location location)\n+static void\n+get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n+\t\t\t     std::vector<Backend::Btyped_identifier>* bfields)\n {\n-  tree ret = make_node(RECORD_TYPE);\n+  source_location loc = type->location();\n+\n+  std::vector<Backend::Btyped_identifier> mfields(type->methods()->size() + 1);\n \n-  tree field_trees = NULL_TREE;\n-  tree* pp = &field_trees;\n+  Type* pdt = Type::make_type_descriptor_ptr_type();\n+  mfields[0].name = \"__type_descriptor\";\n+  mfields[0].btype = tree_to_type(pdt->get_tree(gogo));\n+  mfields[0].location = loc;\n \n-  tree name_tree = get_identifier(\"__methods\");\n-  tree field = build_decl(location, FIELD_DECL, name_tree, ptr_type_node);\n-  DECL_CONTEXT(field) = ret;\n-  *pp = field;\n-  pp = &DECL_CHAIN(field);\n+  std::string last_name = \"\";\n+  size_t i = 1;\n+  for (Typed_identifier_list::const_iterator p = type->methods()->begin();\n+       p != type->methods()->end();\n+       ++p, ++i)\n+    {\n+      mfields[i].name = Gogo::unpack_hidden_name(p->name());\n+      mfields[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+      mfields[i].location = loc;\n+      // Sanity check: the names should be sorted.\n+      go_assert(p->name() > last_name);\n+      last_name = p->name();\n+    }\n \n-  name_tree = get_identifier(\"__object\");\n-  field = build_decl(location, FIELD_DECL, name_tree, ptr_type_node);\n-  DECL_CONTEXT(field) = ret;\n-  *pp = field;\n+  Btype* methods = gogo->backend()->struct_type(mfields);\n \n-  TYPE_FIELDS(ret) = field_trees;\n+  bfields->resize(2);\n \n-  layout_type(ret);\n+  (*bfields)[0].name = \"__methods\";\n+  (*bfields)[0].btype = gogo->backend()->pointer_type(methods);\n+  (*bfields)[0].location = loc;\n \n-  return ret;\n+  Type* vt = Type::make_pointer_type(Type::make_void_type());\n+  (*bfields)[1].name = \"__object\";\n+  (*bfields)[1].btype = tree_to_type(vt->get_tree(gogo));\n+  (*bfields)[1].location = UNKNOWN_LOCATION;\n }\n \n-// Fill in the tree for an interface type.  This is used for named\n-// interface types.\n+// Return a tree for an interface type.  An interface is a pointer to\n+// a struct.  The struct has three fields.  The first field is a\n+// pointer to the type descriptor for the dynamic type of the object.\n+// The second field is a pointer to a table of methods for the\n+// interface to be used with the object.  The third field is the value\n+// of the object itself.\n \n tree\n-Interface_type::fill_in_tree(Gogo* gogo, tree type)\n+Interface_type::do_get_tree(Gogo* gogo)\n {\n-  go_assert(this->methods_ != NULL);\n-\n-  // Build the type of the table of methods.\n-\n-  tree method_table = make_node(RECORD_TYPE);\n-\n-  // The first field is a pointer to the type descriptor.\n-  tree name_tree = get_identifier(\"__type_descriptor\");\n-  tree dtype = Type::make_type_descriptor_type()->get_tree(gogo);\n-  dtype = build_pointer_type(build_qualified_type(dtype, TYPE_QUAL_CONST));\n-  tree field = build_decl(this->location_, FIELD_DECL, name_tree, dtype);\n-  DECL_CONTEXT(field) = method_table;\n-  TYPE_FIELDS(method_table) = field;\n-\n-  std::string last_name = \"\";\n-  tree* pp = &DECL_CHAIN(field);\n-  for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n-       p != this->methods_->end();\n-       ++p)\n+  if (this->methods_ == NULL)\n     {\n-      std::string name = Gogo::unpack_hidden_name(p->name());\n-      name_tree = get_identifier_with_length(name.data(), name.length());\n-      tree field_type = p->type()->get_tree(gogo);\n-      if (field_type == error_mark_node)\n-\treturn error_mark_node;\n-      field = build_decl(this->location_, FIELD_DECL, name_tree, field_type);\n-      DECL_CONTEXT(field) = method_table;\n-      *pp = field;\n-      pp = &DECL_CHAIN(field);\n-      // Sanity check: the names should be sorted.\n-      go_assert(p->name() > last_name);\n-      last_name = p->name();\n+      Btype* bt = Interface_type::get_backend_empty_interface_type(gogo);\n+      return type_to_tree(bt);\n+    }\n+  else\n+    {\n+      std::vector<Backend::Btyped_identifier> bfields;\n+      get_backend_interface_fields(gogo, this, &bfields);\n+      Btype* bt = gogo->backend()->struct_type(bfields);\n+      return type_to_tree(bt);\n     }\n-  layout_type(method_table);\n-\n-  // Update the type of the __methods field from a generic pointer to\n-  // a pointer to the method table.\n-  field = TYPE_FIELDS(type);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\") == 0);\n-\n-  TREE_TYPE(field) = build_pointer_type(method_table);\n-\n-  return type;\n }\n \n // Initialization value.\n@@ -7089,6 +7064,7 @@ Named_type::convert(Gogo* gogo)\n       break;\n \n     case TYPE_ARRAY:\n+      // Slice types were completed in create_placeholder.\n       if (!base->is_open_array_type())\n \t{\n \t  Btype* bet = base->array_type()->get_backend_element(gogo);\n@@ -7099,11 +7075,7 @@ Named_type::convert(Gogo* gogo)\n       break;\n \n     case TYPE_INTERFACE:\n-      if (!base->interface_type()->is_empty())\n-\t{\n-\t  tree t = type_to_tree(bt);\n-\t  bt = tree_to_type(base->interface_type()->fill_in_tree(gogo, t));\n-\t}\n+      // Interface types were completed in create_placeholder.\n       break;\n \n     case TYPE_ERROR:\n@@ -7194,11 +7166,12 @@ Named_type::create_placeholder(Gogo* gogo)\n \n     case TYPE_INTERFACE:\n       if (base->interface_type()->is_empty())\n-\tbt = tree_to_type(Interface_type::empty_type_tree(gogo));\n+\tbt = Interface_type::get_backend_empty_interface_type(gogo);\n       else\n \t{\n-\t  source_location loc = base->interface_type()->location();\n-\t  bt = tree_to_type(Interface_type::non_empty_type_tree(loc));\n+\t  bt = gogo->backend()->placeholder_struct_type(this->name(),\n+\t\t\t\t\t\t\tthis->location_);\n+\t  set_name = false;\n \t}\n       break;\n \n@@ -7218,12 +7191,24 @@ Named_type::create_placeholder(Gogo* gogo)\n   if (base->is_open_array_type())\n     {\n       // We do not record slices as dependencies of other types,\n-      // because we can fill them in completely here.\n+      // because we can fill them in completely here with the final\n+      // size.\n       std::vector<Backend::Btyped_identifier> bfields;\n       get_backend_slice_fields(gogo, base->array_type(), &bfields);\n       if (!gogo->backend()->set_placeholder_struct_type(bt, bfields))\n \tthis->named_btype_ = gogo->backend()->error_type();\n     }\n+  else if (base->interface_type() != NULL\n+\t   && !base->interface_type()->is_empty())\n+    {\n+      // We do not record interfaces as dependencies of other types,\n+      // because we can fill them in completely here with the final\n+      // size.\n+      std::vector<Backend::Btyped_identifier> bfields;\n+      get_backend_interface_fields(gogo, base->interface_type(), &bfields);\n+      if (!gogo->backend()->set_placeholder_struct_type(bt, bfields))\n+\tthis->named_btype_ = gogo->backend()->error_type();\n+    }\n }\n \n // Get a tree for a named type."}, {"sha": "d8a0f71a7b97ee3362f2049de6fff61a1578d116", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9e0b98ac9d41b41520b5e587621707d59ae0f6/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9e0b98ac9d41b41520b5e587621707d59ae0f6/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=da9e0b98ac9d41b41520b5e587621707d59ae0f6", "patch": "@@ -2369,16 +2369,8 @@ class Interface_type : public Type\n   do_import(Import*);\n \n   // Make a struct for an empty interface type.\n-  static tree\n-  empty_type_tree(Gogo*);\n-\n-  // Make a struct for non-empty interface type.\n-  static tree\n-  non_empty_type_tree(source_location);\n-\n-  // Fill in the fields for a named interface type.\n-  tree\n-  fill_in_tree(Gogo*, tree);\n+  static Btype*\n+  get_backend_empty_interface_type(Gogo*);\n \n   static Type*\n   make_interface_type_descriptor_type();"}]}