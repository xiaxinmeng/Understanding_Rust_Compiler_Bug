{"sha": "68a813322bd01742d80aed81cd3ed013b054499b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhhODEzMzIyYmQwMTc0MmQ4MGFlZDgxY2QzZWQwMTNiMDU0NDk5Yg==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2005-04-20T22:31:30Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2005-04-20T22:31:30Z"}, "message": "predicates.md: New file.\n\n\t* config/cris/predicates.md: New file.\n\t* config/cris/cris-protos.h (cris_store_multiple_op_p)\n\t(cris_movem_load_rest_p): Declare.\n\t* config/cris/cris.c (cris_store_multiple_op): Return bool, not int.\n\t(cris_movem_load_rest_p): Ditto.  Globalize.\n\t(cris_bdap_operand, cris_bdap_biap_operand,\n\tcris_orthogonal_operator, cris_commutative_orth_op,\n\tcris_operand_extend_operator,\n\tcris_additive_operand_extend_operator, cris_extend_operator,\n\tcris_plus_or_bound_operator, cris_mem_op,\n\tcris_general_operand_or_symbol,\n\tcris_general_operand_or_gotless_symbol,\n\tcris_general_operand_or_plt_symbol, cris_mem_call_operand,\n\tcris_load_multiple_op): Remove predicate functions.\n\t(cris_symbol, cris_gotless_symbol) <case UNSPEC>: Return 0, don't\n\tabort, for UNSPECs other than CRIS_UNSPEC_PLT.\n\t* config/cris/cris.h (PREDICATE_CODES): Don't define.\n\t* config/cris/cris.md: Include predicates.md.\n\t(\"call\", \"call_value\"): Generate CONSTs of Pmode, not VOIDmode.\n\nFrom-SVN: r98471", "tree": {"sha": "a50dd2a98abe6c7622a96c1e2f6c340f7871b5bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50dd2a98abe6c7622a96c1e2f6c340f7871b5bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68a813322bd01742d80aed81cd3ed013b054499b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68a813322bd01742d80aed81cd3ed013b054499b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68a813322bd01742d80aed81cd3ed013b054499b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68a813322bd01742d80aed81cd3ed013b054499b/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c3e5898be3e730343aa0803f62c1c432f9b1949e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e5898be3e730343aa0803f62c1c432f9b1949e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e5898be3e730343aa0803f62c1c432f9b1949e"}], "stats": {"total": 560, "additions": 221, "deletions": 339}, "files": [{"sha": "89f57e8298dded02be6ccb224aee0aa58fac0dbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68a813322bd01742d80aed81cd3ed013b054499b", "patch": "@@ -1,3 +1,25 @@\n+2005-04-21  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* config/cris/predicates.md: New file.\n+\t* config/cris/cris-protos.h (cris_store_multiple_op_p)\n+\t(cris_movem_load_rest_p): Declare.\n+\t* config/cris/cris.c (cris_store_multiple_op): Return bool, not int.\n+\t(cris_movem_load_rest_p): Ditto.  Globalize.\n+\t(cris_bdap_operand, cris_bdap_biap_operand,\n+\tcris_orthogonal_operator, cris_commutative_orth_op,\n+\tcris_operand_extend_operator,\n+\tcris_additive_operand_extend_operator, cris_extend_operator,\n+\tcris_plus_or_bound_operator, cris_mem_op,\n+\tcris_general_operand_or_symbol,\n+\tcris_general_operand_or_gotless_symbol,\n+\tcris_general_operand_or_plt_symbol, cris_mem_call_operand,\n+\tcris_load_multiple_op): Remove predicate functions.\n+\t(cris_symbol, cris_gotless_symbol) <case UNSPEC>: Return 0, don't\n+\tabort, for UNSPECs other than CRIS_UNSPEC_PLT.\n+\t* config/cris/cris.h (PREDICATE_CODES): Don't define.\n+\t* config/cris/cris.md: Include predicates.md.\n+\t(\"call\", \"call_value\"): Generate CONSTs of Pmode, not VOIDmode.\n+\n 2005-04-20  Ian Lance Taylor  <ian@airs.com>\n \n \t* c-common.def: Remove STMT_EXPR (moved to cp/cp-tree.def)."}, {"sha": "23911c0f1306918085cd9c891225d7ddf3cb9822", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=68a813322bd01742d80aed81cd3ed013b054499b", "patch": "@@ -41,6 +41,8 @@ extern int cris_legitimate_pic_operand (rtx);\n extern int cris_gotless_symbol (rtx);\n extern int cris_got_symbol (rtx);\n extern int cris_symbol (rtx);\n+extern bool cris_store_multiple_op_p (rtx);\n+extern bool cris_movem_load_rest_p (rtx, int);\n extern void cris_asm_output_symbol_ref (FILE *, rtx);\n extern bool cris_output_addr_const_extra (FILE *, rtx);\n extern int cris_cfun_uses_pic_table (void);"}, {"sha": "eb5047d54e0df729b8ef3fedeb648241a746fa90", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 21, "deletions": 299, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=68a813322bd01742d80aed81cd3ed013b054499b", "patch": "@@ -120,8 +120,6 @@ static void cris_operand_lossage (const char *, rtx);\n \n static int cris_reg_saved_in_regsave_area  (unsigned int, bool);\n \n-static int cris_movem_load_rest_p (rtx, int);\n-\n static void cris_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n \n@@ -205,280 +203,9 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n-/* Predicate functions.  */\n-\n-/* This checks a part of an address, the one that is not a plain register\n-   for an addressing mode using BDAP.\n-   Allowed operands is either:\n-   a) a register\n-   b) a CONST operand (but not a symbol when generating PIC)\n-   c) a [r] or [r+] in SImode, or sign-extend from HI or QI.  */\n-\n-int\n-cris_bdap_operand (rtx op, enum machine_mode mode)\n-{\n-  register enum rtx_code code = GET_CODE (op);\n-\n-  if (mode != SImode && (mode != VOIDmode || GET_MODE (op) != VOIDmode))\n-    return 0;\n-\n-  /* Just return whether this is a simple register or constant.  */\n-  if (register_operand (op, mode)\n-      || (CONSTANT_P (op) && !(flag_pic && cris_symbol (op))))\n-    return 1;\n-\n-  /* Is it a [r] or possibly a [r+]?  */\n-  if (code == MEM)\n-    {\n-      rtx tem = XEXP (op, 0);\n-\n-      if (mode == SImode\n-\t  && (register_operand (tem, SImode)\n-\t      || (GET_CODE (tem) == POST_INC\n-\t\t  && register_operand (XEXP (tem, 0), SImode))))\n-\treturn 1;\n-      else\n-\treturn 0;\n-    }\n-\n-  /* Perhaps a sign-extended mem: [r].(b|w) or [r+].(b|w)?  */\n-  if (code == SIGN_EXTEND)\n-    {\n-      rtx tem = XEXP (op, 0);\n-\n-      if (GET_CODE (tem) != MEM)\n-\treturn 0;\n-\n-      tem = XEXP (tem, 0);\n-      if (mode == SImode\n-\t  && (register_operand (tem, SImode)\n-\t      || (GET_CODE (tem) == POST_INC\n-\t\t  && register_operand (XEXP (tem, 0), SImode))))\n-\treturn 1;\n-      else\n-\treturn 0;\n-    }\n-\n-  return 0;\n-}\n-\n-/* This is similar to cris_bdap_operand:\n-   It checks a part of an address, the one that is not a plain register\n-   for an addressing mode using BDAP *or* BIAP.\n-   Allowed operands is either:\n-   a) a register\n-   b) a CONST operand (but not a symbol when generating PIC)\n-   c) a mult of (1, 2 or 4) and a register\n-   d) a [r] or [r+] in SImode, or sign-extend from HI or QI.  */\n-\n-int\n-cris_bdap_biap_operand (rtx op, enum machine_mode mode)\n-{\n-  register enum rtx_code code = GET_CODE (op);\n-  rtx reg;\n-  rtx val;\n-\n-  /* Check for bdap operand.  */\n-  if (cris_bdap_operand (op, mode))\n-    return 1;\n-\n-  if (mode != SImode && (mode != VOIDmode || GET_MODE (op) != VOIDmode))\n-    return 0;\n-\n-  /* Check that we're looking at a BIAP operand.  */\n-  if (code != MULT)\n-    return 0;\n-\n-  /* Canonicalize register and multiplicand.  */\n-  if (GET_CODE (XEXP (op, 0)) == CONST_INT)\n-    {\n-      val = XEXP (op, 0);\n-      reg = XEXP (op, 1);\n-    }\n-  else\n-    {\n-      val = XEXP (op, 1);\n-      reg = XEXP (op, 0);\n-    }\n-\n-  /* Check that the operands are correct after canonicalization.  */\n-  if (! register_operand (reg, SImode) || GET_CODE (val) != CONST_INT)\n-    return 0;\n-\n-  /* Check that the multiplicand has a valid value.  */\n-  if ((code == MULT\n-       && (INTVAL (val) == 1 || INTVAL (val) == 2 || INTVAL (val) == 4)))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Check if MODE is same as mode for X, and X is PLUS, MINUS, IOR or\n-   AND or UMIN.  */\n-\n-int\n-cris_orthogonal_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  return (GET_MODE (x) == mode\n-\t  && (code == PLUS || code == MINUS\n-\t      || code == IOR || code == AND || code == UMIN));\n-}\n-\n-/* Check if MODE is same as mode for X, and X is PLUS, IOR or AND or\n-   UMIN.  */\n-\n-int\n-cris_commutative_orth_op (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  return (GET_MODE (x) == mode &&\n-\t  (code == PLUS\n-\t   || code == IOR || code == AND || code == UMIN));\n-}\n-\n-/* Check if MODE is same as mode for X, and X is PLUS or MINUS or UMIN.\n-   By the name, you might think we should include MULT.  We don't because\n-   it doesn't accept the same addressing modes as the others (ony\n-   registers) and there's also the problem of handling TARGET_MUL_BUG.  */\n-\n-int\n-cris_operand_extend_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  return (GET_MODE (x) == mode\n-\t  && (code == PLUS || code == MINUS || code == UMIN));\n-}\n-\n-/* Check if MODE is same as mode for X, and X is PLUS or MINUS.  */\n-\n-int\n-cris_additive_operand_extend_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  return (GET_MODE (x) == mode\n-\t  && (code == PLUS || code == MINUS));\n-}\n-\n-/* Check to see if MODE is same as mode for X, and X is SIGN_EXTEND or\n-   ZERO_EXTEND.  */\n-\n-int\n-cris_extend_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  return\n-    (GET_MODE (x) == mode && (code == SIGN_EXTEND || code == ZERO_EXTEND));\n-}\n-\n-/* Check to see if MODE is same as mode for X, and X is PLUS or BOUND.  */\n-\n-int\n-cris_plus_or_bound_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  return\n-    (GET_MODE (x) == mode && (code == UMIN || code == PLUS));\n-}\n-\n-/* Used as an operator to get a handle on a already-known-valid MEM rtx:es\n-   (no need to validate the address), where some address expression parts\n-   have their own match_operand.  */\n-\n-int\n-cris_mem_op (rtx x, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (x);\n-\n-  return GET_MODE (x) == mode && GET_CODE (x) == MEM;\n-}\n-\n-/* Since with -fPIC, not all symbols are valid PIC symbols or indeed\n-   general_operands, we have to have a predicate that matches it for the\n-   \"movsi\" expander.  */\n-\n-int\n-cris_general_operand_or_symbol (rtx op, enum machine_mode mode)\n-{\n-  return general_operand (op, mode)\n-    || (CONSTANT_P (op) && cris_symbol (op));\n-}\n-\n-/* Since a PIC symbol without a GOT entry is not a general_operand, we\n-   have to have a predicate that matches it.  We use this in the expanded\n-   \"movsi\" anonymous pattern.  */\n-\n-int\n-cris_general_operand_or_gotless_symbol (rtx op, enum machine_mode mode)\n-{\n-  return general_operand (op, mode)\n-    || (GET_CODE (op) == UNSPEC && XINT (op, 1) == CRIS_UNSPEC_GOT)\n-    || (CONSTANT_P (op) && cris_gotless_symbol (op));\n-}\n-\n-/* Since a PLT symbol is not a general_operand, we have to have a\n-   predicate that matches it when we need it.  We use this in the expanded\n-   \"call\" and \"call_value\" anonymous patterns.  */\n-\n-int\n-cris_general_operand_or_plt_symbol (rtx op, enum machine_mode mode)\n-{\n-  return general_operand (op, mode)\n-    || (GET_CODE (op) == CONST\n-\t&& GET_CODE (XEXP (op, 0)) == UNSPEC\n-\t&& !TARGET_AVOID_GOTPLT);\n-}\n-\n-/* This matches a (MEM (general_operand)) or\n-   (MEM (cris_general_operand_or_symbol)).  The second one isn't a valid\n-   memory_operand, so we need this predicate to recognize call\n-   destinations before we change them to a PLT operand (by wrapping in\n-   UNSPEC CRIS_UNSPEC_PLT).  */\n-\n-int\n-cris_mem_call_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx xmem;\n-\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  if (memory_operand (op, mode))\n-    return 1;\n-\n-  xmem = XEXP (op, 0);\n-\n-  return cris_general_operand_or_symbol (xmem, GET_MODE (op));\n-}\n-\n /* Helper for cris_load_multiple_op and cris_ret_movem_op.  */\n \n-static int\n+bool\n cris_movem_load_rest_p (rtx op, int offs)\n {\n   unsigned int reg_count = XVECLEN (op, 0) - offs;\n@@ -495,7 +222,7 @@ cris_movem_load_rest_p (rtx op, int offs)\n       || GET_CODE (XVECEXP (op, 0, offs)) != SET\n       || GET_CODE (SET_DEST (XVECEXP (op, 0, offs))) != REG\n       || GET_CODE (SET_SRC (XVECEXP (op, 0, offs))) != MEM)\n-    return 0;\n+    return false;\n \n   /* Check a possible post-inc indicator.  */\n   if (GET_CODE (SET_SRC (XVECEXP (op, 0, offs + 1))) == PLUS)\n@@ -511,7 +238,7 @@ cris_movem_load_rest_p (rtx op, int offs)\n \t  || REGNO (reg) != REGNO (SET_DEST (XVECEXP (op, 0, offs + 1)))\n \t  || GET_CODE (inc) != CONST_INT\n \t  || INTVAL (inc) != (HOST_WIDE_INT) reg_count * 4)\n-\treturn 0;\n+\treturn false;\n       i = offs + 2;\n     }\n   else\n@@ -531,7 +258,7 @@ cris_movem_load_rest_p (rtx op, int offs)\n       || GET_CODE (SET_SRC (elt)) != MEM\n       || GET_MODE (SET_SRC (elt)) != SImode\n       || !memory_address_p (SImode, src_addr))\n-    return 0;\n+    return false;\n \n   for (setno = 1; i < XVECLEN (op, 0); setno++, i++)\n     {\n@@ -548,24 +275,17 @@ cris_movem_load_rest_p (rtx op, int offs)\n \t  || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n \t  || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n \t  || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != setno * 4)\n-\treturn 0;\n+\treturn false;\n     }\n \n-  return 1;\n-}\n-\n-/* Predicate for the parallel contents in a movem from-memory.  */\n-\n-int\n-cris_load_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return cris_movem_load_rest_p (op, 0);\n+  return true;\n }\n \n-/* Predicate for the parallel contents in a movem to-memory.  */\n+/* Worker function for predicate for the parallel contents in a movem\n+   to-memory.  */\n \n-int\n-cris_store_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+bool\n+cris_store_multiple_op_p (rtx op)\n {\n   int reg_count = XVECLEN (op, 0);\n   rtx dest;\n@@ -581,18 +301,18 @@ cris_store_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   /* Perform a quick check so we don't blow up below.  FIXME: Adjust for\n      other than (MEM reg) and (MEM (PLUS reg const)).  */\n   if (reg_count <= 1)\n-    return 0;\n+    return false;\n \n   elt = XVECEXP (op, 0, 0);\n \n   if (GET_CODE (elt) != SET)\n-    return  0;\n+    return  false;\n \n   dest = SET_DEST (elt);\n \n   if (GET_CODE (SET_SRC (elt)) != REG\n       || GET_CODE (dest) != MEM)\n-    return 0;\n+    return false;\n \n   dest_addr = XEXP (dest, 0);\n \n@@ -620,7 +340,7 @@ cris_store_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t\t   && REGNO (XEXP (dest_addr, 0)) == REGNO (reg)\n \t\t   && GET_CODE (XEXP (dest_addr, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (dest_addr, 1)) == INTVAL (inc))))\n-\treturn 0;\n+\treturn false;\n \n       i = 2;\n     }\n@@ -637,7 +357,7 @@ cris_store_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       || REGNO (SET_SRC (elt)) != (unsigned int) regno\n       || GET_CODE (SET_DEST (elt)) != MEM\n       || GET_MODE (SET_DEST (elt)) != SImode)\n-    return 0;\n+    return false;\n \n   if (REG_P (dest_addr))\n     {\n@@ -652,7 +372,7 @@ cris_store_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       offset = INTVAL (XEXP (dest_addr, 1));\n     }\n   else\n-    return 0;\n+    return false;\n \n   for (setno = 1; i < XVECLEN (op, 0); setno++, i++)\n     {\n@@ -669,10 +389,10 @@ cris_store_multiple_op (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t  || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_base)\n \t  || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n \t  || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != setno * 4 + offset)\n-\treturn 0;\n+\treturn false;\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* The CONDITIONAL_REGISTER_USAGE worker.  */\n@@ -2176,7 +1896,7 @@ cris_symbol (rtx x)\n       return 1;\n \n     case UNSPEC:\n-      if (XINT (x, 1) == CRIS_UNSPEC_GOT)\n+      if (XINT (x, 1) == CRIS_UNSPEC_GOT || XINT (x, 1) != CRIS_UNSPEC_PLT)\n \treturn 0;\n       /* A PLT reference.  */\n       ASSERT_PLT_UNSPEC (x);\n@@ -2218,6 +1938,8 @@ cris_gotless_symbol (rtx x)\n     case UNSPEC:\n       if (XINT (x, 1) == CRIS_UNSPEC_GOT)\n \treturn 1;\n+      if (XINT (x, 1) != CRIS_UNSPEC_PLT)\n+\treturn 0;\n       ASSERT_PLT_UNSPEC (x);\n       return 1;\n "}, {"sha": "0c169ecbf1d57935326de4eeca5083bbe2d9a785", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=68a813322bd01742d80aed81cd3ed013b054499b", "patch": "@@ -1616,44 +1616,6 @@ struct cum_args {int regs;};\n \n /* Node: Misc */\n \n-/* FIXME: Check this one more time.  */\n-#define PREDICATE_CODES\t\t\t\t\t\\\n- {\"cris_orthogonal_operator\",\t\t\t\t\\\n-  {PLUS, MINUS, IOR, AND, UMIN}},\t\t\t\\\n- {\"cris_commutative_orth_op\",\t\t\t\t\\\n-  {PLUS, IOR, AND, UMIN}},\t\t\t\t\\\n- {\"cris_operand_extend_operator\",\t\t\t\\\n-  {PLUS, MINUS, UMIN}},\t\t\t\t\t\\\n- {\"cris_additive_operand_extend_operator\",\t\t\\\n-  {PLUS, MINUS}},\t\t\t\t\t\\\n- {\"cris_extend_operator\",\t\t\t\t\\\n-  {ZERO_EXTEND, SIGN_EXTEND}},\t\t\t\t\\\n- {\"cris_plus_or_bound_operator\",\t\t\t\\\n-  {PLUS, UMIN}},\t\t\t\t\t\\\n- {\"cris_mem_op\",\t\t\t\t\t\\\n-  {MEM}},\t\t\t\t\t\t\\\n- {\"cris_load_multiple_op\",\t\t\t\t\\\n-  {PARALLEL}},\t\t\t\t\t\t\\\n- {\"cris_store_multiple_op\",\t\t\t\t\\\n-  {PARALLEL}},\t\t\t\t\t\t\\\n- {\"cris_bdap_operand\",\t\t\t\t\t\\\n-  {SUBREG, REG, LABEL_REF, SYMBOL_REF, MEM, CONST_INT,\t\\\n-   CONST_DOUBLE, CONST, SIGN_EXTEND}},\t\t\t\\\n- {\"cris_bdap_biap_operand\",\t\t\t\t\\\n-  {SUBREG, REG, LABEL_REF, SYMBOL_REF, MEM, CONST_INT,\t\\\n-   CONST_DOUBLE, CONST, SIGN_EXTEND, MULT}},\t\t\\\n- {\"cris_general_operand_or_gotless_symbol\",\t\t\\\n-  {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n-   LABEL_REF, SUBREG, REG, MEM, UNSPEC}},\t\t\\\n- {\"cris_general_operand_or_symbol\",\t\t\t\\\n-  {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n-   LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n- {\"cris_general_operand_or_plt_symbol\",\t\t\t\\\n-  {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n-   LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n- {\"cris_mem_call_operand\",\t\t\t\t\\\n-  {MEM}},\n-\n /* A combination of the bound (umin) insn together with a\n    sign-extended add via the table to PC seems optimal.\n    If the table overflows, the assembler will take care of it."}, {"sha": "c68cb8a0e5aa8a85a0abfe1b72aefc936a39cebf", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=68a813322bd01742d80aed81cd3ed013b054499b", "patch": "@@ -141,6 +141,10 @@\n (define_delay (eq_attr \"slottable\" \"has_slot\")\n   [(eq_attr \"slottable\" \"yes\") (nil) (nil)])\n \f\n+;; Operand and operator predicates.\n+\n+(include \"predicates.md\")\n+\f\n ;; Test insns.\n \n ;; DImode\n@@ -3944,7 +3948,7 @@\n \t       for the symbol cause bad recombinatorial effects?  */\n \t    op0 = force_reg (Pmode,\n \t\t\t     gen_rtx_CONST\n-\t\t\t     (VOIDmode,\n+\t\t\t     (Pmode,\n \t\t\t      gen_rtx_UNSPEC (VOIDmode,\n \t\t\t\t\t      gen_rtvec (1, op0),\n \t\t\t\t\t      CRIS_UNSPEC_PLT)));\n@@ -4009,7 +4013,7 @@\n \t       for the symbol cause bad recombinatorial effects?  */\n \t    op1 = force_reg (Pmode,\n \t\t\t     gen_rtx_CONST\n-\t\t\t     (VOIDmode,\n+\t\t\t     (Pmode,\n \t\t\t      gen_rtx_UNSPEC (VOIDmode,\n \t\t\t\t\t      gen_rtvec (1, op1),\n \t\t\t\t\t      CRIS_UNSPEC_PLT)));"}, {"sha": "2d5ef19f02e53d41048642333ce2431b53061fad", "filename": "gcc/config/cris/predicates.md", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68a813322bd01742d80aed81cd3ed013b054499b/gcc%2Fconfig%2Fcris%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fpredicates.md?ref=68a813322bd01742d80aed81cd3ed013b054499b", "patch": "@@ -0,0 +1,170 @@\n+;; Operand and operator predicates for the GCC CRIS port.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+\n+;; Operator predicates.\n+\n+(define_predicate \"cris_orthogonal_operator\"\n+  (match_code \"plus, minus, ior, and, umin\"))\n+\n+(define_predicate \"cris_commutative_orth_op\"\n+  (match_code \"plus, ior, and, umin\"))\n+\n+;; By the name, you might think we should include MULT.  We don't because\n+;; it doesn't accept the same addressing modes as the others (only\n+;; registers) and there's also the problem of handling TARGET_MUL_BUG.\n+\n+(define_predicate \"cris_operand_extend_operator\"\n+  (match_code \"plus, minus, umin\"))\n+\n+(define_predicate \"cris_additive_operand_extend_operator\"\n+  (match_code \"plus, minus\"))\n+\n+(define_predicate \"cris_extend_operator\"\n+  (match_code \"zero_extend, sign_extend\"))\n+\n+(define_predicate \"cris_plus_or_bound_operator\"\n+  (match_code \"plus, umin\"))\n+\n+;; Used as an operator to get a handle on a already-known-valid MEM rtx:es\n+;; (no need to validate the address), where some address expression parts\n+;; have their own match_operand.\n+\n+(define_predicate \"cris_mem_op\"\n+  (match_code \"mem\"))\n+\n+(define_predicate \"cris_load_multiple_op\"\n+  (and (match_code \"parallel\")\n+       (match_test \"cris_movem_load_rest_p (op, 0)\")))\n+\n+(define_predicate \"cris_store_multiple_op\"\n+  (and (match_code \"parallel\")\n+       (match_test \"cris_store_multiple_op_p (op)\")))\n+\n+\n+;; Operand helper predicates.\n+\n+(define_predicate \"cris_bdap_const_operand\"\n+  (and (match_code \"label_ref, symbol_ref, const_int, const_double, const\")\n+       (not (and (match_test \"flag_pic\")\n+\t\t (match_test \"cris_symbol (op)\")))))\n+\n+(define_predicate \"cris_simple_address_operand\"\n+  (ior (match_operand:SI 0 \"register_operand\")\n+       (and (match_code \"post_inc\")\n+\t    (match_test \"register_operand (XEXP (op, 0), Pmode)\"))))\n+\n+(define_predicate \"cris_simple_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"mem\")\n+\t    (match_test \"cris_simple_address_operand (XEXP (op, 0),\n+\t\t\t\t\t\t      Pmode)\"))))\n+\n+;; The caller needs to use :SI.\n+(define_predicate \"cris_bdap_sign_extend_operand\"\n+  (and (match_code \"sign_extend\")\n+       (and (match_test \"MEM_P (XEXP (op, 0))\")\n+\t    (match_test \"cris_simple_address_operand (XEXP (XEXP (op, 0), 0),\n+\t\t\t\t\t\t      Pmode)\"))))\n+\n+;; FIXME: Should not have to test for 1.\n+(define_predicate \"cris_scale_int_operand\"\n+  (and (match_code \"const_int\")\n+       (ior (ior (match_test \"op == GEN_INT (4)\")\n+\t\t (match_test \"op == const2_rtx\"))\n+\t    (match_test \"op == const1_rtx\"))))\n+\n+;; FIXME: Should be able to assume (reg int).\n+(define_predicate \"cris_biap_mult_operand\"\n+  (and (match_code \"mult\")\n+       (ior (and (match_test \"register_operand (XEXP (op, 0), Pmode)\")\n+\t\t (match_test \"cris_scale_int_operand (XEXP (op, 1), Pmode)\"))\n+\t    (and (match_test \"cris_scale_int_operand (XEXP (op, 0), Pmode)\")\n+\t\t (match_test \"register_operand (XEXP (op, 1), Pmode)\")))))\n+\n+\n+;; Operand predicates.\n+\n+;; This checks a part of an address, the one that is not a plain register\n+;; for an addressing mode using BDAP.\n+;; Allowed operands are either:\n+;; a) a register\n+;; b) a CONST operand (but not a symbol when generating PIC)\n+;; c) a [r] or [r+] in SImode, or sign-extend from HI or QI.\n+\n+(define_predicate \"cris_bdap_operand\"\n+  (ior (match_operand 0 \"cris_bdap_const_operand\")\n+       (ior (match_operand:SI 0 \"cris_simple_operand\")\n+\t    (match_operand:SI 0 \"cris_bdap_sign_extend_operand\"))))\n+\n+;; This is similar to cris_bdap_operand:\n+;; It checks a part of an address, the one that is not a plain register\n+;; for an addressing mode using BDAP or BIAP.\n+;; Allowed operands are either:\n+;; a) a register\n+;; b) a CONST operand (but not a symbol when generating PIC)\n+;; c) a mult of (1, 2 or 4) and a register\n+;; d) a [r] or [r+] in SImode, or sign-extend from HI or QI.  */\n+\n+(define_predicate \"cris_bdap_biap_operand\"\n+  (ior (match_operand 0 \"cris_bdap_operand\")\n+       (match_operand 0 \"cris_biap_mult_operand\")))\n+\n+;; Since a PIC symbol without a GOT entry is not a general_operand, we\n+;; have to have a predicate that matches it.  We use this in the expanded\n+;; \"movsi\" anonymous pattern.\n+;; FIXME: Can s/special_// when PR 20413 is fixed.\n+\n+(define_special_predicate \"cris_general_operand_or_gotless_symbol\"\n+  (ior (match_operand 0 \"general_operand\")\n+       (and (match_code \"const, symbol_ref, label_ref, unspec\")\n+\t    (match_test \"cris_gotless_symbol (op)\"))))\n+\n+;; Since with -fPIC, not all symbols are valid PIC symbols or indeed\n+;; general_operands, we have to have a predicate that matches it for the\n+;; \"movsi\" expander.\n+;; FIXME: Can s/special_// when PR 20413 is fixed.\n+\n+(define_special_predicate \"cris_general_operand_or_symbol\"\n+  (ior (match_operand 0 \"general_operand\")\n+       (and (match_code \"const, symbol_ref, label_ref\")\n+\t    (match_test \"cris_symbol (op)\"))))\n+\n+;; Since a PLT symbol is not a general_operand, we have to have a\n+;; predicate that matches it when we need it.  We use this in the expanded\n+;; \"call\" and \"call_value\" anonymous patterns.\n+\n+(define_predicate \"cris_general_operand_or_plt_symbol\"\n+  (ior (match_operand 0 \"general_operand\")\n+       (and (match_code \"const\")\n+\t    (and (match_test \"GET_CODE (XEXP (op, 0)) == UNSPEC\")\n+\t\t (not (match_test \"TARGET_AVOID_GOTPLT\"))))))\n+\n+;; This matches a (MEM (general_operand)) or\n+;; (MEM (cris_general_operand_or_symbol)).  The second one isn't a valid\n+;; memory_operand, so we need this predicate to recognize call\n+;; destinations before we change them to a PLT operand (by wrapping in\n+;; UNSPEC CRIS_UNSPEC_PLT).\n+\n+(define_predicate \"cris_mem_call_operand\"\n+  (and (match_code \"mem\")\n+       (ior (match_operand 0 \"memory_operand\")\n+\t    (match_test \"cris_general_operand_or_symbol (XEXP (op, 0),\n+\t\t\t\t\t\t\t Pmode)\"))))"}]}