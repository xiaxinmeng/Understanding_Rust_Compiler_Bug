{"sha": "cef6cac8bcacc3314760686dfae7b23efdf7db07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VmNmNhYzhiY2FjYzMzMTQ3NjA2ODZkZmFlN2IyM2VmZGY3ZGIwNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:25:43Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:25:43Z"}, "message": "[35/46] Alter interfaces within vect_pattern_recog\n\nvect_pattern_recog_1 took a gimple_stmt_iterator as argument, but was\nonly interested in the gsi_stmt, not anything else.  This patch makes\nthe associated routines operate directly on stmt_vec_infos.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (vect_mark_pattern_stmts): Take the\n\toriginal stmt as a stmt_vec_info rather than a gimple stmt.\n\t(vect_pattern_recog_1): Take the statement directly as a\n\tstmt_vec_info, rather than via a gimple_stmt_iterator.\n\tUpdate call to vect_mark_pattern_stmts.\n\t(vect_pattern_recog): Update calls accordingly.\n\nFrom-SVN: r263150", "tree": {"sha": "4cad03106d4a1ccd3dfbfe0391ac0480edaa5f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cad03106d4a1ccd3dfbfe0391ac0480edaa5f82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cef6cac8bcacc3314760686dfae7b23efdf7db07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cef6cac8bcacc3314760686dfae7b23efdf7db07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cef6cac8bcacc3314760686dfae7b23efdf7db07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cef6cac8bcacc3314760686dfae7b23efdf7db07/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4057a3920490abb69bb22237ebe380ac4fd64f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4057a3920490abb69bb22237ebe380ac4fd64f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4057a3920490abb69bb22237ebe380ac4fd64f5"}], "stats": {"total": 60, "additions": 37, "deletions": 23}, "files": [{"sha": "ebe33a136072e4bd40e7c896d2cbca087a8afbd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef6cac8bcacc3314760686dfae7b23efdf7db07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef6cac8bcacc3314760686dfae7b23efdf7db07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cef6cac8bcacc3314760686dfae7b23efdf7db07", "patch": "@@ -1,3 +1,12 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (vect_mark_pattern_stmts): Take the\n+\toriginal stmt as a stmt_vec_info rather than a gimple stmt.\n+\t(vect_pattern_recog_1): Take the statement directly as a\n+\tstmt_vec_info, rather than via a gimple_stmt_iterator.\n+\tUpdate call to vect_mark_pattern_stmts.\n+\t(vect_pattern_recog): Update calls accordingly.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_get_vec_defs_for_stmt_copy)"}, {"sha": "0f710e5b23ca7403afd01e7f37fd7d5f584dd8bc", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cef6cac8bcacc3314760686dfae7b23efdf7db07/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cef6cac8bcacc3314760686dfae7b23efdf7db07/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=cef6cac8bcacc3314760686dfae7b23efdf7db07", "patch": "@@ -4720,29 +4720,29 @@ const unsigned int NUM_PATTERNS = ARRAY_SIZE (vect_vect_recog_func_ptrs);\n /* Mark statements that are involved in a pattern.  */\n \n static inline void\n-vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n+vect_mark_pattern_stmts (stmt_vec_info orig_stmt_info, gimple *pattern_stmt,\n                          tree pattern_vectype)\n {\n-  stmt_vec_info orig_stmt_info = vinfo_for_stmt (orig_stmt);\n   gimple *def_seq = STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt_info);\n \n-  bool old_pattern_p = is_pattern_stmt_p (orig_stmt_info);\n-  if (old_pattern_p)\n+  gimple *orig_pattern_stmt = NULL;\n+  if (is_pattern_stmt_p (orig_stmt_info))\n     {\n       /* We're replacing a statement in an existing pattern definition\n \t sequence.  */\n+      orig_pattern_stmt = orig_stmt_info->stmt;\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"replacing earlier pattern \");\n-\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, orig_stmt, 0);\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, orig_pattern_stmt, 0);\n \t}\n \n       /* To keep the book-keeping simple, just swap the lhs of the\n \t old and new statements, so that the old one has a valid but\n \t unused lhs.  */\n-      tree old_lhs = gimple_get_lhs (orig_stmt);\n-      gimple_set_lhs (orig_stmt, gimple_get_lhs (pattern_stmt));\n+      tree old_lhs = gimple_get_lhs (orig_pattern_stmt);\n+      gimple_set_lhs (orig_pattern_stmt, gimple_get_lhs (pattern_stmt));\n       gimple_set_lhs (pattern_stmt, old_lhs);\n \n       if (dump_enabled_p ())\n@@ -4755,21 +4755,23 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n       orig_stmt_info = STMT_VINFO_RELATED_STMT (orig_stmt_info);\n \n       /* We shouldn't be replacing the main pattern statement.  */\n-      gcc_assert (STMT_VINFO_RELATED_STMT (orig_stmt_info) != orig_stmt);\n+      gcc_assert (STMT_VINFO_RELATED_STMT (orig_stmt_info)->stmt\n+\t\t  != orig_pattern_stmt);\n     }\n \n   if (def_seq)\n     for (gimple_stmt_iterator si = gsi_start (def_seq);\n \t !gsi_end_p (si); gsi_next (&si))\n       vect_init_pattern_stmt (gsi_stmt (si), orig_stmt_info, pattern_vectype);\n \n-  if (old_pattern_p)\n+  if (orig_pattern_stmt)\n     {\n       vect_init_pattern_stmt (pattern_stmt, orig_stmt_info, pattern_vectype);\n \n       /* Insert all the new pattern statements before the original one.  */\n       gimple_seq *orig_def_seq = &STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt_info);\n-      gimple_stmt_iterator gsi = gsi_for_stmt (orig_stmt, orig_def_seq);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (orig_pattern_stmt,\n+\t\t\t\t\t       orig_def_seq);\n       gsi_insert_seq_before_without_update (&gsi, def_seq, GSI_SAME_STMT);\n       gsi_insert_before_without_update (&gsi, pattern_stmt, GSI_SAME_STMT);\n \n@@ -4785,12 +4787,12 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n    Input:\n    PATTERN_RECOG_FUNC: A pointer to a function that detects a certain\n         computation pattern.\n-   STMT: A stmt from which the pattern search should start.\n+   STMT_INFO: A stmt from which the pattern search should start.\n \n    If PATTERN_RECOG_FUNC successfully detected the pattern, it creates\n    a sequence of statements that has the same functionality and can be\n-   used to replace STMT.  It returns the last statement in the sequence\n-   and adds any earlier statements to STMT's STMT_VINFO_PATTERN_DEF_SEQ.\n+   used to replace STMT_INFO.  It returns the last statement in the sequence\n+   and adds any earlier statements to STMT_INFO's STMT_VINFO_PATTERN_DEF_SEQ.\n    PATTERN_RECOG_FUNC also sets *TYPE_OUT to the vector type of the final\n    statement, having first checked that the target supports the new operation\n    in that type.\n@@ -4799,24 +4801,23 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n    for vect_recog_pattern.  */\n \n static void\n-vect_pattern_recog_1 (vect_recog_func *recog_func, gimple_stmt_iterator si)\n+vect_pattern_recog_1 (vect_recog_func *recog_func, stmt_vec_info stmt_info)\n {\n-  gimple *stmt = gsi_stmt (si), *pattern_stmt;\n-  stmt_vec_info stmt_info;\n+  vec_info *vinfo = stmt_info->vinfo;\n+  gimple *pattern_stmt;\n   loop_vec_info loop_vinfo;\n   tree pattern_vectype;\n \n   /* If this statement has already been replaced with pattern statements,\n      leave the original statement alone, since the first match wins.\n      Instead try to match against the definition statements that feed\n      the main pattern statement.  */\n-  stmt_info = vinfo_for_stmt (stmt);\n   if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n     {\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));\n \t   !gsi_end_p (gsi); gsi_next (&gsi))\n-\tvect_pattern_recog_1 (recog_func, gsi);\n+\tvect_pattern_recog_1 (recog_func, vinfo->lookup_stmt (gsi_stmt (gsi)));\n       return;\n     }\n \n@@ -4841,7 +4842,7 @@ vect_pattern_recog_1 (vect_recog_func *recog_func, gimple_stmt_iterator si)\n     }\n \n   /* Mark the stmts that are involved in the pattern. */\n-  vect_mark_pattern_stmts (stmt, pattern_stmt, pattern_vectype);\n+  vect_mark_pattern_stmts (stmt_info, pattern_stmt, pattern_vectype);\n \n   /* Patterns cannot be vectorized using SLP, because they change the order of\n      computation.  */\n@@ -4957,9 +4958,13 @@ vect_pattern_recog (vec_info *vinfo)\n \t{\n \t  basic_block bb = bbs[i];\n \t  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-\t    /* Scan over all generic vect_recog_xxx_pattern functions.  */\n-\t    for (j = 0; j < NUM_PATTERNS; j++)\n-\t      vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si);\n+\t    {\n+\t      stmt_vec_info stmt_info = vinfo->lookup_stmt (gsi_stmt (si));\n+\t      /* Scan over all generic vect_recog_xxx_pattern functions.  */\n+\t      for (j = 0; j < NUM_PATTERNS; j++)\n+\t\tvect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j],\n+\t\t\t\t      stmt_info);\n+\t    }\n \t}\n     }\n   else\n@@ -4975,7 +4980,7 @@ vect_pattern_recog (vec_info *vinfo)\n \n \t  /* Scan over all generic vect_recog_xxx_pattern functions.  */\n \t  for (j = 0; j < NUM_PATTERNS; j++)\n-\t    vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], si);\n+\t    vect_pattern_recog_1 (&vect_vect_recog_func_ptrs[j], stmt_info);\n \t}\n     }\n }"}]}