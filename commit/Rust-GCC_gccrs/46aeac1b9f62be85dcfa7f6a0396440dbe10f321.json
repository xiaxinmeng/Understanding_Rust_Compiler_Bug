{"sha": "46aeac1b9f62be85dcfa7f6a0396440dbe10f321", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZhZWFjMWI5ZjYyYmU4NWRjZmE3ZjZhMDM5NjQ0MGRiZTEwZjMyMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2013-05-23T19:10:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2013-05-23T19:10:56Z"}, "message": "re PR rtl-optimization/56742 (Optimization bug lead to uncaught throw)\n\nPR target/56742\n\n        * config/i386/i386.c (ix86_seh_fixup_eh_fallthru): New.\n        (ix86_reorg): Call it.\n\nFrom-SVN: r199264", "tree": {"sha": "498276e14359ea52894d65e4ff522d07b13b392e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/498276e14359ea52894d65e4ff522d07b13b392e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46aeac1b9f62be85dcfa7f6a0396440dbe10f321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46aeac1b9f62be85dcfa7f6a0396440dbe10f321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46aeac1b9f62be85dcfa7f6a0396440dbe10f321", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46aeac1b9f62be85dcfa7f6a0396440dbe10f321/comments", "author": null, "committer": null, "parents": [{"sha": "70cc153622fa089431478a774653cc816eda20af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70cc153622fa089431478a774653cc816eda20af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70cc153622fa089431478a774653cc816eda20af"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "51e7b9e91d52527afd9b8e9fb8049d6567d1ab47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46aeac1b9f62be85dcfa7f6a0396440dbe10f321/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46aeac1b9f62be85dcfa7f6a0396440dbe10f321/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46aeac1b9f62be85dcfa7f6a0396440dbe10f321", "patch": "@@ -1,3 +1,9 @@\n+2013-05-23  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/56742\n+\t* config/i386/i386.c (ix86_seh_fixup_eh_fallthru): New.\n+\t(ix86_reorg): Call it.\n+\n 2013-05-23  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/57379"}, {"sha": "20163b1a8a1bf4a56fb3a4a1d6508d401c28e0d5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46aeac1b9f62be85dcfa7f6a0396440dbe10f321/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46aeac1b9f62be85dcfa7f6a0396440dbe10f321/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=46aeac1b9f62be85dcfa7f6a0396440dbe10f321", "patch": "@@ -35564,6 +35564,46 @@ ix86_pad_short_function (void)\n     }\n }\n \n+/* Fix up a Windows system unwinder issue.  If an EH region falls thru into\n+   the epilogue, the Windows system unwinder will apply epilogue logic and\n+   produce incorrect offsets.  This can be avoided by adding a nop between\n+   the last insn that can throw and the first insn of the epilogue.  */\n+\n+static void\n+ix86_seh_fixup_eh_fallthru (void)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+    {\n+      rtx insn, next;\n+\n+      /* Find the beginning of the epilogue.  */\n+      for (insn = BB_END (e->src); insn != NULL; insn = PREV_INSN (insn))\n+\tif (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t  break;\n+      if (insn == NULL)\n+\tcontinue;\n+\n+      /* We only care about preceeding insns that can throw.  */\n+      insn = prev_active_insn (insn);\n+      if (insn == NULL || !can_throw_internal (insn))\n+\tcontinue;\n+\n+      /* Do not separate calls from their debug information.  */\n+      for (next = NEXT_INSN (insn); next != NULL; next = NEXT_INSN (next))\n+\tif (NOTE_P (next)\n+            && (NOTE_KIND (next) == NOTE_INSN_VAR_LOCATION\n+                || NOTE_KIND (next) == NOTE_INSN_CALL_ARG_LOCATION))\n+\t  insn = next;\n+\telse\n+\t  break;\n+\n+      emit_insn_after (gen_nops (const1_rtx), insn);\n+    }\n+}\n+\n /* Implement machine specific optimizations.  We implement padding of returns\n    for K8 CPUs and pass to avoid 4 jumps in the single 16 byte window.  */\n static void\n@@ -35573,6 +35613,9 @@ ix86_reorg (void)\n      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n   compute_bb_for_insn ();\n \n+  if (TARGET_SEH && current_function_has_exception_handlers ())\n+    ix86_seh_fixup_eh_fallthru ();\n+\n   if (optimize && optimize_function_for_speed_p (cfun))\n     {\n       if (TARGET_PAD_SHORT_FUNCTION)"}]}