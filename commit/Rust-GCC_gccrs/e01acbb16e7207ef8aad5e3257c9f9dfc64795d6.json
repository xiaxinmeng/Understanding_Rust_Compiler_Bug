{"sha": "e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxYWNiYjE2ZTcyMDdlZjhhYWQ1ZTMyNTdjOWY5ZGZjNjQ3OTVkNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-15T11:09:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-15T11:09:07Z"}, "message": "alpha.c (alpha_expand_unaligned_load): Force all AND addresses into alias set 0.\n\n        * config/alpha/alpha.c (alpha_expand_unaligned_load): Force all\n        AND addresses into alias set 0.\n        (alpha_expand_unaligned_store): Likewise.\n        (alpha_expand_unaligned_load_words): Likewise.\n        (alpha_expand_unaligned_store_words): Likewise.\n\nFrom-SVN: r36430", "tree": {"sha": "43fdac90284e6b60ea7e083fe5193e0d869c2a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43fdac90284e6b60ea7e083fe5193e0d869c2a7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6/comments", "author": null, "committer": null, "parents": [{"sha": "dd193c7921912d50eb6bbeba2819c896ddab2ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd193c7921912d50eb6bbeba2819c896ddab2ca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd193c7921912d50eb6bbeba2819c896ddab2ca0"}], "stats": {"total": 90, "additions": 57, "deletions": 33}, "files": [{"sha": "e7decce40e5227a00c6b85e1ac6927abce3cd755", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "patch": "@@ -1,3 +1,11 @@\n+2000-09-15  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/alpha/alpha.c (alpha_expand_unaligned_load): Force all\n+\tAND addresses into alias set 0.\n+\t(alpha_expand_unaligned_store): Likewise.\n+\t(alpha_expand_unaligned_load_words): Likewise.\n+\t(alpha_expand_unaligned_store_words): Likewise.\n+\n 2000-09-15  Bernd Schmidt  <bernds@redhat.co.uk>\n \n \t* config/sh/sh.h (CPP_SPEC): For -m4-nofpu, define __SH4_NOFPU__."}, {"sha": "f14c3cf1430ada5b5dc46eb7ab2c7e16be8ce94d", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "patch": "@@ -2292,7 +2292,7 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n      HOST_WIDE_INT size, ofs;\n      int sign;\n {\n-  rtx meml, memh, addr, extl, exth;\n+  rtx meml, memh, addr, extl, exth, tmp;\n   enum machine_mode mode;\n \n   meml = gen_reg_rtx (DImode);\n@@ -2301,19 +2301,24 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n   extl = gen_reg_rtx (DImode);\n   exth = gen_reg_rtx (DImode);\n \n-  emit_move_insn (meml,\n-\t\t  change_address (mem, DImode,\n-\t\t\t\t  gen_rtx_AND (DImode, \n-\t\t\t\t\t       plus_constant (XEXP (mem, 0),\n-\t\t\t\t\t\t\t      ofs),\n-\t\t\t\t\t       GEN_INT (-8))));\n-\n-  emit_move_insn (memh,\n-\t\t  change_address (mem, DImode,\n-\t\t\t\t  gen_rtx_AND (DImode, \n-\t\t\t\t\t       plus_constant (XEXP (mem, 0),\n-\t\t\t\t\t\t\t      ofs + size - 1),\n-\t\t\t\t\t       GEN_INT (-8))));\n+  /* AND addresses cannot be in any alias set, since they may implicitly\n+     alias surrounding code.  Ideally we'd have some alias set that \n+     covered all types except those with alignment 8 or higher.  */\n+\n+  tmp = change_address (mem, DImode,\n+\t\t\tgen_rtx_AND (DImode, \n+\t\t\t\t     plus_constant (XEXP (mem, 0), ofs),\n+\t\t\t\t     GEN_INT (-8)));\n+  MEM_ALIAS_SET (tmp) = 0;\n+  emit_move_insn (meml, tmp);\n+\n+  tmp = change_address (mem, DImode,\n+\t\t\tgen_rtx_AND (DImode, \n+\t\t\t\t     plus_constant (XEXP (mem, 0),\n+\t\t\t\t\t\t    ofs + size - 1),\n+\t\t\t\t     GEN_INT (-8)));\n+  MEM_ALIAS_SET (tmp) = 0;\n+  emit_move_insn (memh, tmp);\n \n   if (sign && size == 2)\n     {\n@@ -2377,15 +2382,22 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n   insl = gen_reg_rtx (DImode);\n   insh = gen_reg_rtx (DImode);\n \n+  /* AND addresses cannot be in any alias set, since they may implicitly\n+     alias surrounding code.  Ideally we'd have some alias set that \n+     covered all types except those with alignment 8 or higher.  */\n+\n   meml = change_address (dst, DImode,\n \t\t\t gen_rtx_AND (DImode, \n \t\t\t\t      plus_constant (XEXP (dst, 0), ofs),\n \t\t\t\t      GEN_INT (-8)));\n+  MEM_ALIAS_SET (meml) = 0;\n+\n   memh = change_address (dst, DImode,\n \t\t\t gen_rtx_AND (DImode, \n \t\t\t\t      plus_constant (XEXP (dst, 0),\n \t\t\t\t\t\t     ofs+size-1),\n \t\t\t\t      GEN_INT (-8)));\n+  MEM_ALIAS_SET (memh) = 0;\n \n   emit_move_insn (dsth, memh);\n   emit_move_insn (dstl, meml);\n@@ -2462,7 +2474,7 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n   rtx const im8 = GEN_INT (-8);\n   rtx const i64 = GEN_INT (64);\n   rtx ext_tmps[MAX_MOVE_WORDS], data_regs[MAX_MOVE_WORDS+1];\n-  rtx sreg, areg;\n+  rtx sreg, areg, tmp;\n   HOST_WIDE_INT i;\n \n   /* Generate all the tmp registers we need.  */\n@@ -2480,19 +2492,20 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n   /* Load up all of the source data.  */\n   for (i = 0; i < words; ++i)\n     {\n-      emit_move_insn (data_regs[i],\n-\t\t      change_address (smem, DImode,\n-\t\t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t\t   plus_constant (XEXP(smem,0),\n-\t\t\t\t\t\t\t\t  8*i),\n-\t\t\t\t\t\t   im8)));\n+      tmp = change_address (smem, DImode,\n+\t\t\t    gen_rtx_AND (DImode,\n+\t\t\t\t\t plus_constant (XEXP(smem,0), 8*i),\n+\t\t\t\t\t im8));\n+      MEM_ALIAS_SET (tmp) = 0;\n+      emit_move_insn (data_regs[i], tmp);\n     }\n-  emit_move_insn (data_regs[words],\n-\t\t  change_address (smem, DImode,\n-\t\t\t\t  gen_rtx_AND (DImode,\n-\t\t\t\t\t       plus_constant (XEXP(smem,0),\n-\t\t\t\t\t\t\t      8*words - 1),\n-\t\t\t\t\t       im8)));\n+\n+  tmp = change_address (smem, DImode,\n+\t\t\tgen_rtx_AND (DImode,\n+\t\t\t\t     plus_constant (XEXP(smem,0), 8*words - 1),\n+\t\t\t\t     im8));\n+  MEM_ALIAS_SET (tmp) = 0;\n+  emit_move_insn (data_regs[words], tmp);\n \n   /* Extract the half-word fragments.  Unfortunately DEC decided to make\n      extxh with offset zero a noop instead of zeroing the register, so \n@@ -2559,10 +2572,13 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n \t\t\t\t\t   plus_constant (XEXP(dmem,0),\n \t\t\t\t\t\t\t  words*8 - 1),\n \t\t\t\t       im8));\n+  MEM_ALIAS_SET (st_addr_2) = 0;\n+\n   st_addr_1 = change_address (dmem, DImode,\n \t\t\t      gen_rtx_AND (DImode, \n \t\t\t\t\t   XEXP (dmem, 0),\n \t\t\t\t\t   im8));\n+  MEM_ALIAS_SET (st_addr_1) = 0;\n \n   /* Load up the destination end bits.  */\n   emit_move_insn (st_tmp_2, st_addr_2);\n@@ -2601,12 +2617,12 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n   emit_move_insn (st_addr_2, st_tmp_2);\n   for (i = words-1; i > 0; --i)\n     {\n-      emit_move_insn (change_address (dmem, DImode,\n-\t\t\t\t      gen_rtx_AND (DImode,\n-\t\t\t\t\t\t   plus_constant(XEXP (dmem,0),\n-\t\t\t\t\t\t\t\t i*8),\n-\t\t\t\t\t       im8)),\n-\t\t      data_regs ? ins_tmps[i-1] : const0_rtx);\n+      rtx tmp = change_address (dmem, DImode,\n+\t\t\t\tgen_rtx_AND (DImode,\n+\t\t\t\t\t     plus_constant(XEXP (dmem,0), i*8),\n+\t\t\t\t\t     im8));\n+      MEM_ALIAS_SET (tmp) = 0;\n+      emit_move_insn (tmp, data_regs ? ins_tmps[i-1] : const0_rtx);\n     }\n   emit_move_insn (st_addr_1, st_tmp_1);\n }"}]}