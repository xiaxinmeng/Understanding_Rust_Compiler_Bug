{"sha": "b9821af87bd0348e0fde50a235dedfde7d5389dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4MjFhZjg3YmQwMzQ4ZTBmZGU1MGEyMzVkZWRmZGU3ZDUzODlkZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-07T20:40:06Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-07T20:40:06Z"}, "message": "pa.c (pa_adjust_insn_length): Rewrite so that it only adjusts insns which really need adjustment.\n\n        * pa.c (pa_adjust_insn_length): Rewrite so that it only adjusts\n        insns which really need adjustment.\n        (output_cbranch): Rework so that output templates are simpler.\n        Use shorter sequence for long backwards conditional branches with\n        a filled delay slot that is nullified.  More agressively use \"skip\"\n        instructions.  More agressively nullify the delay slot if nothing\n        useful could be placed there.\n        (output_bb): Likewise.\n\t(forward_branch_p): New function.\n\nFrom-SVN: r4875", "tree": {"sha": "3ccd605c6a5e37058bb0f6f9e6b69d9e03e1b75b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ccd605c6a5e37058bb0f6f9e6b69d9e03e1b75b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9821af87bd0348e0fde50a235dedfde7d5389dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9821af87bd0348e0fde50a235dedfde7d5389dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9821af87bd0348e0fde50a235dedfde7d5389dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9821af87bd0348e0fde50a235dedfde7d5389dd/comments", "author": null, "committer": null, "parents": [{"sha": "f65590a907e9fb63f59f762f0fdde2b6c63d6d4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65590a907e9fb63f59f762f0fdde2b6c63d6d4f"}], "stats": {"total": 237, "additions": 153, "deletions": 84}, "files": [{"sha": "478ca9ef3112deb41876dc8f2342992b52249e71", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 153, "deletions": 84, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9821af87bd0348e0fde50a235dedfde7d5389dd/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9821af87bd0348e0fde50a235dedfde7d5389dd/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b9821af87bd0348e0fde50a235dedfde7d5389dd", "patch": "@@ -2492,27 +2492,33 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n /* Return any length adjustment needed by INSN which already has its length\n    computed as LENGTH.   Return zero if no adjustment is necessary. \n \n-   For the PA: function calls, millicode calls, and short conditional branches\n-   with unfilled delay slots need an adjustment by +1 (to account for\n-   the NOP which will be inserted into the instruction stream).\n+   For the PA: function calls, millicode calls, and backwards short\n+   conditional branches with unfilled delay slots need an adjustment by +1 \n+   (to account for the NOP which will be inserted into the instruction stream).\n \n    Also compute the length of an inline block move here as it is too\n-   complicated to express as a length attribute in pa.md.\n-\n-   (For 2.5) Indirect calls do not need length adjustment as their\n-   delay slot is filled internally in the output template.\n-\n-   (For 2.5) No adjustment is necessary for jump tables or casesi insns.  */\n+   complicated to express as a length attribute in pa.md.  */\n int\n pa_adjust_insn_length (insn, length)\n     rtx insn;\n     int length;\n {\n   rtx pat = PATTERN (insn);\n \n-  /* Call insn with an unfilled delay slot.  */ \n+  /* Call insns which are *not* indirect and have unfilled delay slots.  */\n   if (GET_CODE (insn) == CALL_INSN)\n-    return 1;\n+    {\n+\n+      if (GET_CODE (XVECEXP (pat, 0, 0)) == CALL\n+\t  && GET_CODE (XEXP (XEXP (XVECEXP (pat, 0, 0), 0), 0)) == SYMBOL_REF)\n+\treturn 1;\n+      else if (GET_CODE (XVECEXP (pat, 0, 0)) == SET\n+\t       && GET_CODE (XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0), 0))\n+\t\t  == SYMBOL_REF)\n+\treturn 1;\n+      else\n+\treturn 0;\n+    }\n   /* Millicode insn with an unfilled delay slot.  */\n   else if (GET_CODE (insn) == INSN\n \t   && GET_CODE (pat) != SEQUENCE\n@@ -2529,9 +2535,24 @@ pa_adjust_insn_length (insn, length)\n \t   && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 1)) == BLKmode)\n     return compute_movstrsi_length (insn) - 1;\n   /* Conditional branch with an unfilled delay slot.  */\n-  else if (GET_CODE (insn) == JUMP_INSN && ! simplejump_p (insn)\n-\t   && length != 2 && length != 4)\n-    return 1;\n+  else if (GET_CODE (insn) == JUMP_INSN && ! simplejump_p (insn))\n+    {\n+      /* Adjust a short backwards conditional with an unfilled delay slot.  */\n+      if (GET_CODE (pat) == SET\n+\t  && length == 1\n+\t  && ! forward_branch_p (insn))\n+\treturn 1;\n+      /* Adjust dbra insn with short backwards conditional branch with\n+\t unfilled delay slot -- only for case where counter is in a register. */\n+      else if (GET_CODE (pat) == PARALLEL\n+\t       && GET_CODE (XVECEXP (pat, 0, 1)) == SET\n+\t       && GET_CODE (XEXP (XVECEXP (pat, 0, 1), 0)) == REG\n+\t       && length == 1\n+\t       && ! forward_branch_p (insn))\n+\treturn 1;\n+      else\n+\treturn 0;\n+    }\n   else\n     return 0;\n }\n@@ -3233,19 +3254,30 @@ output_cbranch (operands, nullify, length, negated, insn)\n   static char buf[100];\n   int useskip = 0;\n \n+  /* If this is a long branch with its delay slot unfilled, set `nullify'\n+     as it can nullify the delay slot and save a nop.  */\n+  if (length == 2 && dbr_sequence_length () == 0)\n+    nullify = 1;\n+\n+  /* If this is a short forward conditional branch which did not get\n+     its delay slot filled, the delay slot can still be nullified.  */\n+  if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+    nullify = forward_branch_p (insn);\n+\n   /* A forward branch over a single nullified insn can be done with a \n      comclr instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n-\n   if (length == 1\n-      && JUMP_LABEL (insn) == next_nonnote_insn (NEXT_INSN (insn))\n+      && next_real_insn (insn) != 0\n+      && get_attr_length (next_real_insn (insn)) == 1\n+      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n       && nullify)\n     useskip = 1;\n \n   switch (length)\n     {\n-\n-      /* Short conditional branch.  May nullify either direction.  */\n+      /* All short conditional branches except backwards with an unfilled\n+\t delay slot.  */\n       case 1:\n \tif (useskip)\n \t  strcpy (buf, \"com%I2clr,\");\n@@ -3260,41 +3292,43 @@ output_cbranch (operands, nullify, length, negated, insn)\n \telse if (nullify)\n \t  strcat (buf, \",n %2,%1,%0\");\n \telse \n-\t  strcat (buf, \" %2,%1,%0%#\");\n+\t  strcat (buf, \" %2,%1,%0\");\n \tbreak;\n \n-     /* Long conditional branch, possible forward nullification.  Also\n-\tnote all conditional branches have a length of 4 when not\n-\toptimizing!  */ \n+     /* All long conditionals.  Note an short backward branch with an \n+\tunfilled delay slot is treated just like a long backward branch\n+\twith an unfilled delay slot.  */\n       case 2:\n-      case 4:\n-\tstrcpy (buf, \"com%I2clr,\");\n-\tif (negated)\n-\t  strcat (buf, \"%S3\");\n-\telse\n-\t  strcat (buf, \"%B3\");\n-\t/* Nullify the delay slot if the delay slot was explicitly\n-\t   nullified by the delay branch scheduler or if no insn\n-\t   could be placed in the delay slot.  */\n-\tif (nullify)\n-\t  strcat (buf, \" %2,%1,0\\n\\tbl,n %0,0\");\n-\telse\n-\t  strcat (buf, \" %2,%1,0\\n\\tbl%* %0,0\");\n-\tbreak;\n-\n-      /* Long backward conditional branch with nullification.  */\n-      case 3:\n-\tstrcpy (buf, \"com%I2b,\");\n-\tif (negated)\n-\t  strcat (buf, \"%S3\");\n+\t/* Handle weird backwards branch with a filled delay slot\n+\t   with is nullified.  */\n+\tif (dbr_sequence_length () != 0\n+\t    && ! forward_branch_p (insn)\n+\t    && nullify)\n+\t  {\n+\t    strcpy (buf, \"com%I2b,\");\n+\t    if (negated)\n+\t      strcat (buf, \"%S3\");\n+\t    else\n+\t      strcat (buf, \"%B3\");\n+\t    strcat (buf, \",n %2,%1,.+12\\n\\tbl %0,0\");\n+\t  }\n \telse\n-\t  strcat (buf, \"%B3\");\n-\tstrcat (buf, \" %2,%1,.+16\\n\\tnop\\n\\t bl %0,0\");\n+\t  {\n+\t    strcpy (buf, \"com%I2clr,\");\n+\t    if (negated)\n+\t      strcat (buf, \"%S3\");\n+\t    else\n+\t      strcat (buf, \"%B3\");\n+\t    if (nullify)\n+\t      strcat (buf, \" %2,%1,0\\n\\tbl,n %0,0\");\n+\t    else\n+\t      strcat (buf, \" %2,%1,0\\n\\tbl %0,0\");\n+\t  }\n \tbreak;\n \n       default:\n \tabort();\n-        }\n+    }\n   return buf;\n }\n \n@@ -3313,19 +3347,32 @@ output_bb (operands, nullify, length, negated, insn, which)\n   static char buf[100];\n   int useskip = 0;\n \n+  /* If this is a long branch with its delay slot unfilled, set `nullify'\n+     as it can nullify the delay slot and save a nop.  */\n+  if (length == 2 && dbr_sequence_length () == 0)\n+    nullify = 1;\n+\n+  /* If this is a short forward conditional branch which did not get\n+     its delay slot filled, the delay slot can still be nullified.  */\n+  if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+    nullify = forward_branch_p (insn);\n+\n   /* A forward branch over a single nullified insn can be done with a \n      extrs instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n \n   if (length == 1\n-      && JUMP_LABEL (insn) == next_nonnote_insn (NEXT_INSN (insn))\n+      && next_real_insn (insn) != 0\n+      && get_attr_length (next_real_insn (insn)) == 1\n+      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n       && nullify)\n     useskip = 1;\n \n   switch (length)\n     {\n \n-      /* Short conditional branch.  May nullify either direction.  */\n+      /* All short conditional branches except backwards with an unfilled\n+\t delay slot.  */\n       case 1:\n \tif (useskip)\n \t  strcpy (buf, \"extrs,\");\n@@ -3343,52 +3390,54 @@ output_bb (operands, nullify, length, negated, insn, which)\n \telse if (nullify && ! negated)\n \t  strcat (buf, \",n %0,%1,%2\");\n \telse if (! nullify && negated)\n-\t  strcat (buf, \"%0,%1,%3%#\");\n+\t  strcat (buf, \"%0,%1,%3\");\n \telse if (! nullify && ! negated)\n-\t  strcat (buf, \" %0,%1,%2%#\");\n+\t  strcat (buf, \" %0,%1,%2\");\n \tbreak;\n \n-     /* Long conditional branch, possible forward nullification.  Also\n-\tnote all conditional branches have a length of 4 when not\n-\toptimizing!  */ \n+     /* All long conditionals.  Note an short backward branch with an \n+\tunfilled delay slot is treated just like a long backward branch\n+\twith an unfilled delay slot.  */\n       case 2:\n-      case 4:\n-\tstrcpy (buf, \"extrs,\");\n-\tif ((which == 0 && negated)\n-\t     || (which == 1 && ! negated))\n-\t  strcat (buf, \"<\");\n-\telse\n-\t  strcat (buf, \">=\");\n-\t/* Nullify the delay slot if the delay slot was explicitly\n-\t   nullified by the delay branch scheduler or if no insn\n-\t   could be placed in the delay slot.  */\n-\tif (nullify && negated)\n-\t  strcat (buf, \" %0,%1,1,0\\n\\tbl,n %3,0\");\n-\telse if (nullify && ! negated)\n-\t  strcat (buf, \" %0,%1,1,0\\n\\tbl,n %2,0\");\n-\telse if (negated)\n-\t  strcat (buf, \" %0,%1,1,0\\n\\tbl%* %3,0\");\n-\telse \n-\t  strcat (buf, \" %0,%1,1,0\\n\\tbl%* %2,0\");\n-\tbreak;\n-\n-      /* Long backward conditional branch with nullification.  */\n-      case 3:\n-\tstrcpy (buf, \"bb,\");\n-\tif ((which == 0 && negated)\n-\t     || (which == 1 && ! negated))\n-\t  strcat (buf, \"<\");\n-\telse\n-\t  strcat (buf, \">=\");\n-\tif (negated)\n-\t  strcat (buf, \" %0,%1,.+16\\n\\tnop\\n\\t bl %3,0\");\n+\t/* Handle weird backwards branch with a filled delay slot\n+\t   with is nullified.  */\n+\tif (dbr_sequence_length () != 0\n+\t    && ! forward_branch_p (insn)\n+\t    && nullify)\n+\t  {\n+\t    strcpy (buf, \"bb,\");\n+\t    if ((which == 0 && negated)\n+\t\t|| (which == 1 && ! negated))\n+\t      strcat (buf, \"<\");\n+\t    else\n+\t      strcat (buf, \">=\");\n+\t    if (negated)\n+\t      strcat (buf, \" %0,%1,.+12\\n\\tbl %3,0\");\n+\t    else\n+\t      strcat (buf, \" %0,%1,.+12\\n\\tbl %2,0\");\n+\t  }\n \telse\n-\t  strcat (buf, \" %0,%1,.+16\\n\\tnop\\n\\t bl %2,0\");\n+\t  {\n+\t    strcpy (buf, \"extrs,\");\n+\t    if ((which == 0 && negated)\n+\t\t|| (which == 1 && ! negated))\n+\t      strcat (buf, \"<\");\n+\t    else\n+\t      strcat (buf, \">=\");\n+\t    if (nullify && negated)\n+\t      strcat (buf, \" %0,%1,1,0\\n\\tbl,n %3,0\");\n+\t    else if (nullify && ! negated)\n+\t      strcat (buf, \" %0,%1,1,0\\n\\tbl,n %2,0\");\n+\t    else if (negated)\n+\t      strcat (buf, \" %0,%1,1,0\\n\\tbl %3,0\");\n+\t    else \n+\t      strcat (buf, \" %0,%1,1,0\\n\\tbl %2,0\");\n+\t  }\n \tbreak;\n \n       default:\n \tabort();\n-        }\n+    }\n   return buf;\n }\n \n@@ -3534,3 +3583,23 @@ shadd_operand (op, mode)\n {\n   return (GET_CODE (op) == CONST_INT && shadd_constant_p (INTVAL (op)));\n }\n+\n+/* Return 1 if INSN branches forward.  Should be using insn_addresses\n+   to avoid walking through all the insns... */\n+int\n+forward_branch_p (insn)\n+     rtx insn;\n+{\n+  rtx label = JUMP_LABEL (insn);\n+\n+  while (insn)\n+    {\n+      if (insn == label)\n+\tbreak;\n+      else\n+\tinsn = NEXT_INSN (insn);\n+    }\n+\n+  return (insn == label);\n+}\n+"}]}