{"sha": "61f275ffe786a4003baf23a4dae8b044a59ea8fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmMjc1ZmZlNzg2YTQwMDNiYWYyM2E0ZGFlOGIwNDRhNTllYThmZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-03T12:59:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-01-03T12:59:59Z"}, "message": "(truth_value_p): New function.\n\n(fold): Use it to see when we should make a TRUTH_{AND,OR}_EXPR.\n(fold, case TRUTH_{AND,OR,ANDIF,ORIF}_EXPR): Use distributive law on\nexpressions such as (A && B) || (A && C).\n\nFrom-SVN: r6352", "tree": {"sha": "9dbc2abf91e363027a8c16d70686b7b96ea35edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dbc2abf91e363027a8c16d70686b7b96ea35edb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f275ffe786a4003baf23a4dae8b044a59ea8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f275ffe786a4003baf23a4dae8b044a59ea8fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f275ffe786a4003baf23a4dae8b044a59ea8fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f275ffe786a4003baf23a4dae8b044a59ea8fd/comments", "author": null, "committer": null, "parents": [{"sha": "64812ded25619668c8451f65c284de94a8e402ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64812ded25619668c8451f65c284de94a8e402ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64812ded25619668c8451f65c284de94a8e402ed"}], "stats": {"total": 59, "additions": 51, "deletions": 8}, "files": [{"sha": "e1d106d91cf1ed823d59b142ef2a0cadd73e5bdb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f275ffe786a4003baf23a4dae8b044a59ea8fd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f275ffe786a4003baf23a4dae8b044a59ea8fd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=61f275ffe786a4003baf23a4dae8b044a59ea8fd", "patch": "@@ -1,5 +1,5 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n-   Copyright (C) 1987, 1988, 1992, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -60,6 +60,7 @@ static tree const_binop PROTO((enum tree_code, tree, tree, int));\n static tree fold_convert PROTO((tree, tree));\n static enum tree_code invert_tree_comparison PROTO((enum tree_code));\n static enum tree_code swap_tree_comparison PROTO((enum tree_code));\n+static int truth_value_p PROTO((enum tree_code));\n static int operand_equal_for_comparison_p PROTO((tree, tree, tree));\n static int twoval_comparison_p PROTO((tree, tree *, tree *, int *));\n static tree eval_subst\tPROTO((tree, tree, tree, tree, tree));\n@@ -1737,6 +1738,18 @@ swap_tree_comparison (code)\n       abort ();\n     }\n }\n+\n+/* Return nonzero if CODE is a tree code that represents a truth value.  */\n+\n+static int\n+truth_value_p (code)\n+     enum tree_code code;\n+{\n+  return (TREE_CODE_CLASS (code) == '<'\n+\t  || code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR\n+\t  || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR\n+\t  || code == TRUTH_XOR_EXPR || code == TRUTH_NOT_EXPR);\n+}\n \f\n /* Return nonzero if two operands are necessarily equal.\n    If ONLY_CONST is non-zero, only return non-zero for constants.\n@@ -3191,20 +3204,20 @@ fold (expr)\n      expand_expr.\n \n      Before we do that, see if this is a BIT_AND_EXPR or a BIT_OR_EXPR,\n-     one of the operands is a comparison and the other is either a comparison\n-     or a BIT_AND_EXPR with the constant 1.  In that case, the code below\n-     would make the expression more complex.  Change it to a\n+     one of the operands is a comparison and the other is a comparison, a\n+     BIT_AND_EXPR with the constant 1, or a truth value.  In that case, the\n+     code below would make the expression more complex.  Change it to a\n      TRUTH_{AND,OR}_EXPR.  Likewise, convert a similar NE_EXPR to \n      TRUTH_XOR_EXPR and an EQ_EXPR to the inversion of a TRUTH_XOR_EXPR.  */\n \n   if ((code == BIT_AND_EXPR || code == BIT_IOR_EXPR\n        || code == EQ_EXPR || code == NE_EXPR)\n-      && ((TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n-\t   && (TREE_CODE_CLASS (TREE_CODE (arg1)) == '<'\n+      && ((truth_value_p (TREE_CODE (arg0))\n+\t   && (truth_value_p (TREE_CODE (arg1))\n \t       || (TREE_CODE (arg1) == BIT_AND_EXPR\n \t\t   && integer_onep (TREE_OPERAND (arg1, 1)))))\n-\t  || (TREE_CODE_CLASS (TREE_CODE (arg1)) == '<'\n-\t      && (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+\t  || (truth_value_p (TREE_CODE (arg1))\n+\t      && (truth_value_p (TREE_CODE (arg0))\n \t\t  || (TREE_CODE (arg0) == BIT_AND_EXPR\n \t\t      && integer_onep (TREE_OPERAND (arg0, 1)))))))\n     {\n@@ -4121,6 +4134,36 @@ fold (expr)\n \t\treturn fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n \t    }\n \n+\t  /* Check for things like (A || B) && (A || C).  We can convert\n+\t     this to A || (B && C).  Note that either operator can be any of\n+\t     the four truth and/or operations and the transformation will\n+\t     still be valid.  */\n+\t  if (TREE_CODE (arg0) == TREE_CODE (arg1)\n+\t      && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR\n+\t\t  || TREE_CODE (arg0) == TRUTH_ORIF_EXPR\n+\t\t  || TREE_CODE (arg0) == TRUTH_AND_EXPR\n+\t\t  || TREE_CODE (arg0) == TRUTH_OR_EXPR))\n+\t    {\n+\t      tree a00 = TREE_OPERAND (arg0, 0);\n+\t      tree a01 = TREE_OPERAND (arg0, 1);\n+\t      tree a10 = TREE_OPERAND (arg1, 0);\n+\t      tree a11 = TREE_OPERAND (arg1, 1);\n+\t      tree common = 0, op0, op1;\n+\n+\t      if (operand_equal_p (a00, a10, 0))\n+\t\tcommon = a00, op0 = a01, op1 = a11;\n+\t      else if (operand_equal_p (a00, a11, 0))\n+\t\tcommon = a00, op0 = a01, op1 = a10;\n+\t      else if (operand_equal_p (a01, a10, 0))\n+\t\tcommon = a01, op0 = a00, op1 = a11;\n+\t      else if (operand_equal_p (a01, a11, 0))\n+\t\tcommon = a01, op0 = a00, op1 = a10;\n+\n+\t      if (common)\n+\t\treturn fold (build (TREE_CODE (arg0), type, common,\n+\t\t\t\t    fold (build (code, type, op0, op1))));\n+\t    }\n+\n \t  tem = fold_truthop (code, type, arg0, arg1);\n \t  if (tem)\n \t    return tem;"}]}