{"sha": "f2423e1975946cbe71f9302c38e84de26e1789b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI0MjNlMTk3NTk0NmNiZTcxZjkzMDJjMzhlODRkZTI2ZTE3ODliMg==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1995-09-19T23:28:37Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1995-09-19T23:28:37Z"}, "message": "Initial revision\n\nFrom-SVN: r10378", "tree": {"sha": "193f20b9409e7e941982edb0b7c281fbaa2bb161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/193f20b9409e7e941982edb0b7c281fbaa2bb161"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2423e1975946cbe71f9302c38e84de26e1789b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2423e1975946cbe71f9302c38e84de26e1789b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2423e1975946cbe71f9302c38e84de26e1789b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2423e1975946cbe71f9302c38e84de26e1789b2/comments", "author": null, "committer": null, "parents": [{"sha": "0eb68617cea3b36d7a066c586da3ef6a028ecb63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb68617cea3b36d7a066c586da3ef6a028ecb63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb68617cea3b36d7a066c586da3ef6a028ecb63"}], "stats": {"total": 482, "additions": 482, "deletions": 0}, "files": [{"sha": "6f59c5c4ffdfd8d0872f095d7425efa1bbda96f0", "filename": "gcc/config/i370/i370.c", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2423e1975946cbe71f9302c38e84de26e1789b2/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2423e1975946cbe71f9302c38e84de26e1789b2/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=f2423e1975946cbe71f9302c38e84de26e1789b2", "patch": "@@ -0,0 +1,482 @@\n+/* Subroutines for insn-output.c for System/370.\n+   Copyright (C) 1989, 1993, 1995 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for MVS C/370 by Dave Pitts (dpitts@nyx.cs.du.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+\n+\n+/* Label node, this structure is used to keep track of labels on the\n+   current page.  */\n+typedef struct label_node\n+  {\n+    struct label_node *label_next;\n+    int label_id;\n+    int label_page;\n+  }\n+label_node_t;\n+\n+/* Is 1 when a label has been generated and the base register must be\n+   reloaded.  */\n+int mvs_label_emitted = 0;\n+\n+/* Current function starting base page.  */\n+int function_base_page;\n+\n+/* Length of the current page code.  */\n+int mvs_page_code;\n+\n+/* Length of the current page literals.  */\n+int mvs_page_lit;\n+\n+/* Current function name.  */\n+char *mvs_function_name = 0;\n+\n+/* Current function name length.  */\n+int mvs_function_name_length = 0;\n+\n+/* Page number for multi-page functions.  */\n+int mvs_page_num = 0;\n+\n+/* Label node list anchor.  */\n+static label_node_t *label_anchor = 0;\n+\n+/* Label node free list anchor.  */\n+static label_node_t *free_anchor = 0;\n+\n+/* Assembler source file descriptor.  */\n+static FILE *assembler_source = 0;\n+\n+/* Define the length of the internal MVS function table.  */\n+#define MVS_FUNCTION_TABLE_LENGTH 32\n+\n+/* C/370 internal function table.  These functions use non-standard linkage\n+   and must handled in a special manner.  */\n+static char *mvs_function_table[MVS_FUNCTION_TABLE_LENGTH] =\n+{\n+   \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_ata2\", \"edc_atan\", \"edc_cos\",\n+   \"edc_cosh\", \"edc_erf\",  \"edc_erfc\", \"edc_exp\",  \"edc_gamm\", \"edc_lg10\",\n+   \"edc_log\",  \"edc_sin\",  \"edc_sinh\", \"edc_sqrt\", \"edc_tan\",  \"edc_tanh\",\n+   \"fabs\",     \"floor\",    \"fmod\",     \"frexp\",    \"hypot\",    \"j0\",\n+   \"j1\",       \"jn\",       \"ldexp\",    \"modf\",     \"pow\",      \"y0\",\n+   \"y1\",       \"yn\"\n+};\n+\n+/* ASCII to EBCDIC conversion table.  */\n+#if defined(TARGET_EBCDIC) && !defined(HOST_EBCDIC)\n+static unsigned char ascebc[256] =\n+{\n+ /*00  NL    SH    SX    EX    ET    NQ    AK    BL */\n+     0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n+ /*08  BS    HT    LF    VT    FF    CR    SO    SI */\n+     0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+ /*10  DL    D1    D2    D3    D4    NK    SN    EB */\n+     0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,\n+ /*18  CN    EM    SB    EC    FS    GS    RS    US */\n+     0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,\n+ /*20  SP     !     \"     #     $     %     &     ' */\n+     0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,\n+ /*28   (     )     *     +     ,     -    .      / */\n+     0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,\n+ /*30   0     1     2     3     4     5     6     7 */\n+     0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\n+ /*38   8     9     :     ;     <     =     >     ? */\n+     0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,\n+ /*40   @     A     B     C     D     E     F     G */\n+     0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n+ /*48   H     I     J     K     L     M     N     O */\n+     0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,\n+ /*50   P     Q     R     S     T     U     V     W */\n+     0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n+ /*58   X     Y     Z     [     \\     ]     ^     _ */\n+     0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,\n+ /*60   `     a     b     c     d     e     f     g */\n+     0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+ /*68   h     i     j     k     l     m     n     o */\n+     0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,\n+ /*70   p     q     r     s     t     u     v     w */\n+     0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,\n+ /*78   x     y     z     {     |     }     ~    DL */\n+     0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n+     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0xFF\n+};\n+#endif\n+\n+/* EBCDIC to ASCII conversion table.  */\n+#if defined(HOST_EBCDIC) && !defined(TARGET_EBCDIC)\n+unsigned char ebcasc[256] =\n+{\n+ /*00  NU    SH    SX    EX    PF    HT    LC    DL */\n+     0x00, 0x01, 0x02, 0x03, 0x00, 0x09, 0x00, 0x7F,\n+ /*08              SM    VT    FF    CR    SO    SI */\n+     0x00, 0x00, 0x00, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n+ /*10  DE    D1    D2    TM    RS    NL    BS    IL */\n+     0x10, 0x11, 0x12, 0x13, 0x14, 0x0A, 0x08, 0x00,\n+ /*18  CN    EM    CC    C1    FS    GS    RS    US */\n+     0x18, 0x19, 0x00, 0x00, 0x1C, 0x1D, 0x1E, 0x1F,\n+ /*20  DS    SS    FS          BP    LF    EB    EC */\n+     0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x17, 0x1B,\n+ /*28              SM    C2    EQ    AK    BL       */\n+     0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x00,\n+ /*30              SY          PN    RS    UC    ET */\n+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,\n+ /*38                    C3    D4    NK          SU */\n+     0x00, 0x00, 0x00, 0x00, 0x14, 0x15, 0x00, 0x1A,\n+ /*40  SP                                           */\n+     0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*48                     .     <     (     +     | */\n+     0x00, 0x00, 0x00, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,\n+ /*50   &                                           */\n+     0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*58               !     $     *     )     ;     ^ */\n+     0x00, 0x00, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,\n+ /*60   -     /                                     */\n+     0x2D, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*68                     ,     %     _     >     ? */\n+     0x00, 0x00, 0x00, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,\n+ /*70                                               */\n+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*78         `     :     #     @     '     =     \" */\n+     0x00, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,\n+ /*80         a     b     c     d     e     f     g */\n+     0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+ /*88   h     i           {                         */\n+     0x68, 0x69, 0x00, 0x7B, 0x00, 0x00, 0x00, 0x00,\n+ /*90         j     k     l     m     n     o     p */\n+     0x00, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,\n+ /*98   q     r           }                         */\n+     0x71, 0x72, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00,\n+ /*A0         ~     s     t     u     v     w     x */\n+     0x00, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n+ /*A8   y     z                       [             */\n+     0x79, 0x7A, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00,\n+ /*B0                                               */\n+     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*B8                                 ]             */\n+     0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00,\n+ /*C0   {     A     B     C     D     E     F     G */\n+     0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+ /*C8   H     I                                     */\n+     0x48, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*D0   }     J     K     L     M     N     O     P */\n+     0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n+ /*D8   Q     R                                     */\n+     0x51, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*E0   \\           S     T     U     V     W     X */\n+     0x5C, 0x00, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n+ /*E8   Y     Z                                     */\n+     0x59, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+ /*F0   0     1     2     3     4     5     6     7 */\n+     0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+ /*F8   8     9                                     */\n+     0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF\n+};\n+#endif\n+\n+/* Map characters from one character set to another.\n+   C is the character to be translated.  */\n+\n+char\n+mvs_map_char (c)\n+     char c;\n+{\n+#if defined(TARGET_EBCDIC) && !defined(HOST_EBCDIC)\n+  return ascebc[c];\n+#else\n+#if defined(HOST_EBCDIC) && !defined(TARGET_EBCDIC)\n+  return ebcasc[c];\n+#else\n+  return c;\n+#endif\n+#endif\n+}\n+\n+/* Emit reload of base register if indicated.  This is to eliminate multiple\n+   reloads when several labels are generated pointing to the same place\n+   in the code.  */\n+\n+int\n+check_label_emit (void)\n+{\n+  if (mvs_label_emitted)\n+    {\n+      mvs_label_emitted = 0;\n+      mvs_page_code += 4;\n+      fprintf (assembler_source, \"\\tL\\t%d,%d(,%d)\\n\",\n+\t  BASE_REGISTER, (mvs_page_num - function_base_page) * 4,\n+\t  PAGE_REGISTER);\n+    }\n+}\n+\n+/* Add the label to the current page label list.  If a free element is available\n+   it will be used for the new label.  Otherwise, a label element will be\n+   allocated from memory.\n+   ID is the label number of the label being added to the list.  */\n+\n+int\n+mvs_add_label (id)\n+     int id;\n+{\n+  label_node_t *lp;\n+\n+  if (free_anchor)\n+    {\n+      lp = free_anchor;\n+      free_anchor = lp->label_next;\n+    }\n+  else\n+    {\n+      lp = (label_node_t *) malloc (sizeof (label_node_t));\n+      if (lp == 0)\n+\t{\n+\t  fatal (\"virtual memory exhausted\\n\");\n+\t  abort ();\n+\t}\n+    }\n+  lp->label_id = id;\n+  lp->label_page = mvs_page_num;\n+  lp->label_next = label_anchor;\n+  label_anchor = lp;\n+}\n+\n+/* Check to see if the label is in the list.  If 1 is returned then a load \n+   and branch on register must be generated.\n+   ID is the label number of the label being checked.  */\n+\n+int\n+mvs_check_label (id)\n+     int id;\n+{\n+  label_node_t *lp;\n+\n+  for (lp = label_anchor; lp; lp = lp->label_next)\n+    {\n+      if (lp->label_id == id)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* The label list for the current page freed by linking the list onto the free\n+   label element chain.  */\n+\n+int\n+mvs_free_label (void)\n+{\n+  if (label_anchor)\n+    {\n+      if (free_anchor)\n+\tlabel_anchor->label_next = free_anchor;\n+      free_anchor = label_anchor;\n+    }\n+  label_anchor = 0;\n+}\n+\n+/* If the page size limit is reached a new code page is started, and the base\n+   register is set to it.  This page break point is counted conservatively,\n+   most literals that have the same value are collapsed by the assembler.\n+   True is returned when a new page is started.\n+   FILE is the assembler output file descriptor.\n+   CODE is the length, in bytes, of the instruction to be emitted.\n+   LIT is the length of the literal to be emitted.  */\n+\n+int\n+mvs_check_page (file, code, lit)\n+     FILE *file;\n+     int code, lit;\n+{\n+  if (file)\n+    assembler_source = file;\n+\n+  if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)\n+    {\n+      fprintf (assembler_source, \"\\tB\\tPGE%d\\n\", mvs_page_num);\n+      fprintf (assembler_source, \"\\tDS\\t0F\\n\");\n+      fprintf (assembler_source, \"\\tLTORG\\n\");\n+      fprintf (assembler_source, \"\\tDS\\t0F\\n\");\n+      fprintf (assembler_source, \"PGE%d\\tEQU\\t*\\n\", mvs_page_num);\n+      fprintf (assembler_source, \"\\tDROP\\t%d\\n\", BASE_REGISTER);\n+      mvs_page_num++;\n+      fprintf (assembler_source, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n+      fprintf (assembler_source, \"PG%d\\tEQU\\t*\\n\", mvs_page_num);\n+      fprintf (assembler_source, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n+      mvs_free_label ();\n+      mvs_page_code = code;\n+      mvs_page_lit = lit;\n+      return 1;\n+    }\n+  mvs_page_code += code;\n+  mvs_page_lit += lit;\n+  return 0;\n+}\n+\n+/* Check for C/370 runtime function, they don't use standard calling\n+   conventions.  True is returned if the function is in the table.\n+   NAME is the name of the current function.  */\n+\n+int\n+mvs_function_check (name)\n+     char *name;\n+{\n+  int lower, middle, upper;\n+  int i;\n+\n+  lower = 0;\n+  upper = MVS_FUNCTION_TABLE_LENGTH - 1;\n+  while (lower <= upper)\n+    {\n+      middle = (lower + upper) / 2;\n+      i = strcmp (name, mvs_function_table[middle]);\n+      if (i == 0)\n+\treturn 1;\n+      if (i < 0)\n+\tupper = middle - 1;\n+      else\n+\tlower = middle + 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* Return 1 if OP is a valid S operand for an RS, SI or SS type instruction.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n+\n+int\n+s_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  extern int volatile_ok;\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  if (CONSTANT_ADDRESS_P (op))\n+    return 1;\n+  if (mode == VOIDmode || GET_MODE (op) != mode)\n+    return 0;\n+  if (code == MEM)\n+    {\n+      register rtx x = XEXP (op, 0);\n+\n+      if (!volatile_ok && op->volatil)\n+\treturn 0;\n+      if (REG_P (x) && REG_OK_FOR_BASE_P (x))\n+\treturn 1;\n+      if (GET_CODE (x) == PLUS\n+\t  && REG_P (XEXP (x, 0)) && REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (unsigned) INTVAL (XEXP (x, 1)) < 4096)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* Return 1 if OP is a valid R or S operand for an RS, SI or SS type\n+   instruction.\n+   OP is the current operation.\n+   MODE is the current operation mode.  */\n+\n+int\n+r_or_s_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  extern int volatile_ok;\n+  register enum rtx_code code = GET_CODE (op);\n+\n+  if (CONSTANT_ADDRESS_P (op))\n+    return 1;\n+  if (mode == VOIDmode || GET_MODE (op) != mode)\n+    return 0;\n+  if (code == REG)\n+    return 1;\n+  else if (code == MEM)\n+    {\n+      register rtx x = XEXP (op, 0);\n+\n+      if (!volatile_ok && op->volatil)\n+\treturn 0;\n+      if (REG_P (x) && REG_OK_FOR_BASE_P (x))\n+\treturn 1;\n+      if (GET_CODE (x) == PLUS\n+\t  && REG_P (XEXP (x, 0)) && REG_OK_FOR_BASE_P (XEXP (x, 0))\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (unsigned) INTVAL (XEXP (x, 1)) < 4096)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* Return 1 if the next instruction is an unsigned jump instruction.\n+   INSN is the current instruction.  */\n+\n+unsigned_jump_follows_p (insn)\n+     register rtx insn;\n+{\n+  insn = NEXT_INSN (insn);\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    return 0;\n+\n+  insn = XEXP (insn, 3);\n+  if (GET_CODE (insn) != SET)\n+    return 0;\n+\n+  if (GET_CODE (XEXP (insn, 0)) != PC)\n+    return 0;\n+\n+  insn = XEXP (insn, 1);\n+  if (GET_CODE (insn) != IF_THEN_ELSE)\n+    return 0;\n+\n+  insn = XEXP (insn, 0);\n+  return GET_CODE (insn) != GE && GET_CODE (insn) != GT\n+    && GET_CODE (insn) != LE && GET_CODE (insn) != LT;\n+}"}]}