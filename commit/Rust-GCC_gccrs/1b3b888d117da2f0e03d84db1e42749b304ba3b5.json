{"sha": "1b3b888d117da2f0e03d84db1e42749b304ba3b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIzYjg4OGQxMTdkYTJmMGUwM2Q4NGRiMWU0Mjc0OWIzMDRiYTNiNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-07-30T17:12:44Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-07-30T17:12:44Z"}, "message": "Add workaround for aligned_alloc bug on AIX\n\n20_util/memory_resource/2.cc FAILs on AIX 7.2.0.0, because aligned_alloc\nincorrectly requires the alignment to be a multiple of sizeof(void*).\n\nThis adds a workaround to the operator new overload taking an alignment\nvalue, to increase the alignment (and size) if needed.\n\n\t* libsupc++/new_opa.cc (operator new(size_t, align_val_t)): Add\n\tworkaround for aligned_alloc bug on AIX.\n\t* testsuite/18_support/new_aligned.cc: New test.\n\nFrom-SVN: r263073", "tree": {"sha": "07acab6e28a1021cced45532f4b25b59a52ca0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07acab6e28a1021cced45532f4b25b59a52ca0c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b3b888d117da2f0e03d84db1e42749b304ba3b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b3b888d117da2f0e03d84db1e42749b304ba3b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b3b888d117da2f0e03d84db1e42749b304ba3b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b3b888d117da2f0e03d84db1e42749b304ba3b5/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81bdfc1e2940fc93bcd0bba4416daff47f04f3b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bdfc1e2940fc93bcd0bba4416daff47f04f3b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81bdfc1e2940fc93bcd0bba4416daff47f04f3b3"}], "stats": {"total": 131, "additions": 131, "deletions": 0}, "files": [{"sha": "b1653f16a6a20cd492f460fa72d85d089201cd59", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3b888d117da2f0e03d84db1e42749b304ba3b5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3b888d117da2f0e03d84db1e42749b304ba3b5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1b3b888d117da2f0e03d84db1e42749b304ba3b5", "patch": "@@ -1,3 +1,9 @@\n+2018-07-30  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* libsupc++/new_opa.cc (operator new(size_t, align_val_t)): Add\n+\tworkaround for aligned_alloc bug on AIX.\n+\t* testsuite/18_support/new_aligned.cc: New test.\n+\n 2018-07-26  Marek Polacek  <polacek@redhat.com>\n \n \t* testsuite/30_threads/condition_variable_any/cond.cc: New."}, {"sha": "7c4bb79cdab798cd2936fe229aba050c5769865d", "filename": "libstdc++-v3/libsupc++/new_opa.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3b888d117da2f0e03d84db1e42749b304ba3b5/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3b888d117da2f0e03d84db1e42749b304ba3b5/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc?ref=1b3b888d117da2f0e03d84db1e42749b304ba3b5", "patch": "@@ -95,6 +95,12 @@ operator new (std::size_t sz, std::align_val_t al)\n     sz = 1;\n \n #if _GLIBCXX_HAVE_ALIGNED_ALLOC\n+# ifdef _AIX\n+  /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign's requirement\n+   * that alignment is a multiple of sizeof(void*).  */\n+  if (align < sizeof(void*))\n+    align = sizeof(void*);\n+# endif\n   /* C11: the value of size shall be an integral multiple of alignment.  */\n   if (std::size_t rem = sz & (align - 1))\n     sz += align - rem;"}, {"sha": "a9f539d36e830644b8bf2b2ac172a328f340f0b6", "filename": "libstdc++-v3/testsuite/18_support/new_aligned.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b3b888d117da2f0e03d84db1e42749b304ba3b5/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnew_aligned.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b3b888d117da2f0e03d84db1e42749b304ba3b5/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnew_aligned.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnew_aligned.cc?ref=1b3b888d117da2f0e03d84db1e42749b304ba3b5", "patch": "@@ -0,0 +1,119 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <new>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct Test\n+{\n+  Test(std::size_t size, std::size_t a)\n+  : size(size), alignment(std::align_val_t{a}),\n+    p(::operator new(size, alignment))\n+  { }\n+\n+  ~Test() { ::operator delete(p, size, alignment); }\n+\n+  std::size_t size;\n+  std::align_val_t alignment;\n+  void* p;\n+\n+  bool valid() const { return p != nullptr; }\n+\n+  bool aligned() const\n+  {\n+    auto ptr = p;\n+    auto space = size;\n+    return std::align((std::size_t)alignment, size, ptr, space) == p;\n+  }\n+};\n+\n+// operator new(size_t size, align_val_t alignment) has\n+// undefined behaviour if the alignment argument is not\n+// a valid alignment value (i.e. not a power of two).\n+//\n+// Unlike posix_memalign there is no requirement that\n+// alignment >= sizeof(void*).\n+//\n+// Unlike aligned_alloc there is no requirement that\n+// size is an integer multiple of alignment.\n+\n+void\n+test01()\n+{\n+  // Test small values that would not be valid for\n+  // posix_memalign or aligned_alloc.\n+\n+  Test t11{1, 1};\n+  VERIFY( t11.valid() );\n+  VERIFY( t11.aligned() );\n+\n+  Test t21{2, 1};\n+  VERIFY( t21.valid() );\n+  VERIFY( t21.aligned() );\n+\n+  Test t12{1, 2};\n+  VERIFY( t12.valid() );\n+  VERIFY( t12.aligned() );\n+\n+  Test t22{2, 2};\n+  VERIFY( t22.valid() );\n+  VERIFY( t22.aligned() );\n+\n+  Test t32{3, 2};\n+  VERIFY( t32.valid() );\n+  VERIFY( t32.aligned() );\n+\n+  Test t42{4, 2};\n+  VERIFY( t42.valid() );\n+  VERIFY( t42.aligned() );\n+\n+  Test t24{2, 4};\n+  VERIFY( t24.valid() );\n+  VERIFY( t24.aligned() );\n+\n+  Test t34{3, 4};\n+  VERIFY( t34.valid() );\n+  VERIFY( t34.aligned() );\n+\n+  Test t44{4, 4};\n+  VERIFY( t44.valid() );\n+  VERIFY( t44.aligned() );\n+\n+  // Test some larger values.\n+\n+  Test t128_16{128, 16};\n+  VERIFY( t128_16.valid() );\n+  VERIFY( t128_16.aligned() );\n+\n+  Test t128_64{128, 64};\n+  VERIFY( t128_64.valid() );\n+  VERIFY( t128_64.aligned() );\n+\n+  Test t64_128{64, 128};\n+  VERIFY( t64_128.valid() );\n+  VERIFY( t64_128.aligned() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}