{"sha": "fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUxMDgxYjAxNzI4NDcxNmI2YjFlNjlmYjZlZjMwNjdiM2Q3NGJjNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2004-01-23T02:49:57Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-01-23T02:49:57Z"}, "message": "re PR libgcj/13107 (Wrong verification error in gij: recursive subroutine call)\n\n\tPR libgcj/13107:\n\t* testsuite/libjava.lang/pr13107_2.xfail: New file.\n\t* testsuite/libjava.lang/pr13107_3.xfail: New file.\n\t* testsuite/libjava.lang/pr13107_3.java: New file.\n\t* testsuite/libjava.lang/pr13107_3.out: New file.\n\t* testsuite/libjava.lang/pr13107_2.java: New file.\n\t* testsuite/libjava.lang/pr13107_2.out: New file.\n\t* testsuite/libjava.lang/pr13107.java: New file.\n\t* testsuite/libjava.lang/pr13107.out: New file.\n\t* verify.cc (jsr_ptrs): Removed.\n\t(entry_points): Likewise.\n\t(struct subr_info): Likewise.\n\t(struct subr_entry_info): Likewise.\n\t(type_val::unused_by_subroutine_type): Likewise.\n\t(type::merge): Don't handle unused_by_subroutine_type.\n\t(type::print): Likewise.\n\t(state::flags): Removed.\n\t(state::subroutine): Likewise.\n\t(state::seen_subrs): Likewise.\n\t(state::NO_STACK): Likewise.\n\t(state::FLAG_CHANGED, state::FLAG_UNUSED): Likewise.\n\t(state): Updated all methods.\n\t(state::clean_subrs): Removed.\n\t(state::state): Removed `ret_semantics' flag.\n\t(state::copy): Likewise.\n\t(state::add_subr): Removed.\n\t(state::enter_subroutine): Likewise.\n\t(type::set_return_address): New method.\n\t(handle_jsr_insn): Set return address on the type.  Always\n\tinvalidate PC after call.\n\t(check_nonrecursive_call): Removed.\n\t(~_Jv_BytecodeVerifier): Updated.\n\t(branch_prepass): Removed special handling of jsr.\n\t(note_branch_target): Likewise.\n\t(get_subroutine): Removed.\n\t(state::merge): Don't merge subroutines and don't handle\n\tNO_STACK.  Removed ret_semantics and jsr_semantics arguments.\n\t(state::note_variable): Removed.\n\t(state::is_unmerged_ret_state): Likewise.\n\t(state::print): Updated.\n\t(set_variable): Likewise.\n\t(merge_into): Renamed from push_jump_merge.  Removed ret_semantics\n\tand jsr_semantics arguments.  Updated for new reverification\n\tlist.\n\t(pop_jump): Rewrote.\n\t(construct_primitive_array_type): Updated.\n\t(state::next): Removed.\n\t(INVALID_STATE): New define.\n\t(state::INVALID): Removed.\n\t(state::NO_NEXT): New value.\n\t(state::pc, state::next): New fields.\n\t(state::get_pc): New method.\n\t(next_verify_pc): Removed.\n\t(next_verify_state): New field.\n\t(verify_instructions_0): Always check for falling off end.\n\t(linked): New type.\n\t(linked_utf8): Removed.\n\t(states): Changed type.\n\t(type::state_mergeable_p): New method.\n\t(state::state_mergeable_p): Likewise.\n\t(handle_ret_insn): Removed most code.\n\t(state::reverify): New method.\n\t(add_new_state): Likewise.\n\t(state::set_pc): Likewise.\n\nFrom-SVN: r76395", "tree": {"sha": "a34a3a3b3092687f2b6ecc36d7a319d4084924c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a34a3a3b3092687f2b6ecc36d7a319d4084924c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/comments", "author": null, "committer": null, "parents": [{"sha": "4c442790ef8625f6e6f5dfda20648f055be114e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c442790ef8625f6e6f5dfda20648f055be114e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c442790ef8625f6e6f5dfda20648f055be114e2"}], "stats": {"total": 1086, "additions": 470, "deletions": 616}, "files": [{"sha": "e408e21d0348dda66bd335ab1d28038ffdb35456", "filename": "libjava/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -1,3 +1,70 @@\n+2004-01-22  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/13107:\n+\t* testsuite/libjava.lang/pr13107_2.xfail: New file.\n+\t* testsuite/libjava.lang/pr13107_3.xfail: New file.\n+\t* testsuite/libjava.lang/pr13107_3.java: New file.\n+\t* testsuite/libjava.lang/pr13107_3.out: New file.\n+\t* testsuite/libjava.lang/pr13107_2.java: New file.\n+\t* testsuite/libjava.lang/pr13107_2.out: New file.\n+\t* testsuite/libjava.lang/pr13107.java: New file.\n+\t* testsuite/libjava.lang/pr13107.out: New file.\n+\t* verify.cc (jsr_ptrs): Removed.\n+\t(entry_points): Likewise.\n+\t(struct subr_info): Likewise.\n+\t(struct subr_entry_info): Likewise.\n+\t(type_val::unused_by_subroutine_type): Likewise.\n+\t(type::merge): Don't handle unused_by_subroutine_type.\n+\t(type::print): Likewise.\n+\t(state::flags): Removed.\n+\t(state::subroutine): Likewise.\n+\t(state::seen_subrs): Likewise.\n+\t(state::NO_STACK): Likewise.\n+\t(state::FLAG_CHANGED, state::FLAG_UNUSED): Likewise.\n+\t(state): Updated all methods.\n+\t(state::clean_subrs): Removed.\n+\t(state::state): Removed `ret_semantics' flag.\n+\t(state::copy): Likewise.\n+\t(state::add_subr): Removed.\n+\t(state::enter_subroutine): Likewise.\n+\t(type::set_return_address): New method.\n+\t(handle_jsr_insn): Set return address on the type.  Always\n+\tinvalidate PC after call.\n+\t(check_nonrecursive_call): Removed.\n+\t(~_Jv_BytecodeVerifier): Updated.\n+\t(branch_prepass): Removed special handling of jsr.\n+\t(note_branch_target): Likewise.\n+\t(get_subroutine): Removed.\n+\t(state::merge): Don't merge subroutines and don't handle\n+\tNO_STACK.  Removed ret_semantics and jsr_semantics arguments.\n+\t(state::note_variable): Removed.\n+\t(state::is_unmerged_ret_state): Likewise.\n+\t(state::print): Updated.\n+\t(set_variable): Likewise.\n+\t(merge_into): Renamed from push_jump_merge.  Removed ret_semantics\n+\tand jsr_semantics arguments.  Updated for new reverification\n+\tlist.\n+\t(pop_jump): Rewrote.\n+\t(construct_primitive_array_type): Updated.\n+\t(state::next): Removed.\n+\t(INVALID_STATE): New define.\n+\t(state::INVALID): Removed.\n+\t(state::NO_NEXT): New value.\n+\t(state::pc, state::next): New fields.\n+\t(state::get_pc): New method.\n+\t(next_verify_pc): Removed.\n+\t(next_verify_state): New field.\n+\t(verify_instructions_0): Always check for falling off end.\n+\t(linked): New type.\n+\t(linked_utf8): Removed.\n+\t(states): Changed type.\n+\t(type::state_mergeable_p): New method.\n+\t(state::state_mergeable_p): Likewise.\n+\t(handle_ret_insn): Removed most code.\n+\t(state::reverify): New method.\n+\t(add_new_state): Likewise.\n+\t(state::set_pc): Likewise.\n+\n 2004-01-22  Jeff Sturm  <jsturm@one-point.com>\n \n \tPR java/13733"}, {"sha": "06d4c54bbb318ab0b31395231c0bf6b9b129baaf", "filename": "libjava/testsuite/libjava.lang/pr13107.java", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107.java?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -0,0 +1,25 @@\n+class pr13107\n+{\n+  public static void main(String[] args)\n+  {\n+    for (int i = 0; i < 1; i++) {\n+      String s = \"A\";\n+\n+      if (s == \"A\")\n+        continue;\n+      \n+      try{\n+\ttry{\n+          System.out.println(s);\n+\t}\n+\tfinally{\n+\t  if (s != \"A\")\n+\t    throw new Error();\n+\t}\n+      }\n+      catch(Exception e){\n+\ts = \"B\";\n+      }\n+    }\n+  }\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libjava/testsuite/libjava.lang/pr13107.out", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107.out?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4"}, {"sha": "dba3b249e3142d2d2ee85ce4cfccc40a605e3109", "filename": "libjava/testsuite/libjava.lang/pr13107_2.java", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.java?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -0,0 +1,19 @@\n+public class pr13107_2\n+{\n+  public static int foo (boolean b)\n+  {\n+    int i;\n+    try {\n+\tif (b) return 1;\n+\ti= 2;\n+      }\n+    finally {\n+      if (b) i = 3;\n+    }\n+    return i;\n+  }\n+\n+  public static void main(String[] args)\n+  {\n+  }\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libjava/testsuite/libjava.lang/pr13107_2.out", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.out?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4"}, {"sha": "81d6df0a027e812369e541719d0731f41584e5f2", "filename": "libjava/testsuite/libjava.lang/pr13107_2.xfail", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.xfail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.xfail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_2.xfail?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -0,0 +1 @@\n+xfail-byte"}, {"sha": "5ec9146051bb3a0007db13cbea6a36f90faf175a", "filename": "libjava/testsuite/libjava.lang/pr13107_3.java", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.java?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -0,0 +1,16 @@\n+public class pr13107_3\n+{\n+  public static void main(String[] args)\n+  {\n+    for (int i = 0; i < 1; i++)\n+      {\n+\ttry {\n+\t  System.out.println(i);\n+\t}\n+\tfinally {\n+\t  if (i == 3)\n+\t    continue;\n+\t}\n+      }\n+  }\n+}"}, {"sha": "573541ac9702dd3969c9bc859d2b91ec1f7e6e56", "filename": "libjava/testsuite/libjava.lang/pr13107_3.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.out?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -0,0 +1 @@\n+0"}, {"sha": "81d6df0a027e812369e541719d0731f41584e5f2", "filename": "libjava/testsuite/libjava.lang/pr13107_3.xfail", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.xfail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.xfail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fpr13107_3.xfail?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -0,0 +1 @@\n+xfail-byte"}, {"sha": "8c037ed6381ac7e8857b0b2c59dabb95a2da46b3", "filename": "libjava/verify.cc", "status": "modified", "additions": 340, "deletions": 616, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1081b017284716b6b1e69fb6ef3067b3d74bc4/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=fe1081b017284716b6b1e69fb6ef3067b3d74bc4", "patch": "@@ -1,6 +1,6 @@\n // verify.cc - verify bytecode\n \n-/* Copyright (C) 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 2001, 2002, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -32,6 +32,10 @@ details.  */\n #endif /* VERIFY_DEBUG */\n \n \n+// This is used to mark states which are not scheduled for\n+// verification.\n+#define INVALID_STATE ((state *) -1)\n+\n static void debug_print (const char *fmt, ...)\n   __attribute__ ((format (printf, 1, 2)));\n \n@@ -46,6 +50,78 @@ debug_print (const char *fmt, ...)\n #endif /* VERIFY_DEBUG */\n }\n \n+// This started as a fairly ordinary verifier, and for the most part\n+// it remains so.  It works in the obvious way, by modeling the effect\n+// of each opcode as it is encountered.  For most opcodes, this is a\n+// straightforward operation.\n+//\n+// This verifier does not do type merging.  It used to, but this\n+// results in difficulty verifying some relatively simple code\n+// involving interfaces, and it pushed some verification work into the\n+// interpreter.\n+//\n+// Instead of merging reference types, when we reach a point where two\n+// flows of control merge, we simply keep the union of reference types\n+// from each branch.  Then, when we need to verify a fact about a\n+// reference on the stack (e.g., that it is compatible with the\n+// argument type of a method), we check to ensure that all possible\n+// types satisfy the requirement.\n+//\n+// Another area this verifier differs from the norm is in its handling\n+// of subroutines.  The JVM specification has some confusing things to\n+// say about subroutines.  For instance, it makes claims about not\n+// allowing subroutines to merge and it rejects recursive subroutines.\n+// For the most part these are red herrings; we used to try to follow\n+// these things but they lead to problems.  For example, the notion of\n+// \"being in a subroutine\" is not well-defined: is an exception\n+// handler in a subroutine?  If you never execute the `ret' but\n+// instead `goto 1' do you remain in the subroutine?\n+//\n+// For clarity on what is really required for type safety, read\n+// \"Simple Verification Technique for Complex Java Bytecode\n+// Subroutines\" by Alessandro Coglio.  Among other things this paper\n+// shows that recursive subroutines are not harmful to type safety.\n+// We implement something similar to what he proposes.  Note that this\n+// means that this verifier will accept code that is rejected by some\n+// other verifiers.\n+//\n+// For those not wanting to read the paper, the basic observation is\n+// that we can maintain split states in subroutines.  We maintain one\n+// state for each calling `jsr'.  In other words, we re-verify a\n+// subroutine once for each caller, using the exact types held by the\n+// callers (as opposed to the old approach of merging types and\n+// keeping a bitmap registering what did or did not change).  This\n+// approach lets us continue to verify correctly even when a\n+// subroutine is exited via `goto' or `athrow' and not `ret'.\n+//\n+// In some other areas the JVM specification is (mildly) incorrect,\n+// but we still implement what is specified.  For instance, you cannot\n+// violate type safety by allocating an object with `new' and then\n+// failing to initialize it, no matter how one branches or where one\n+// stores the uninitialized reference.  See \"Improving the official\n+// specification of Java bytecode verification\" by Alessandro Coglio.\n+// Similarly, there's no real point in enforcing that padding bytes or\n+// the mystery byte of invokeinterface must be 0, but we do that too.\n+//\n+// The verifier is currently neither completely lazy nor eager when it\n+// comes to loading classes.  It tries to represent types by name when\n+// possible, and then loads them when it needs to verify a fact about\n+// the type.  Checking types by name is valid because we only use\n+// names which come from the current class' constant pool.  Since all\n+// such names are looked up using the same class loader, there is no\n+// danger that we might be fooled into comparing different types with\n+// the same name.\n+//\n+// In the future we plan to allow for a completely lazy mode of\n+// operation, where the verifier will construct a list of type\n+// assertions to be checked later.\n+//\n+// Some test cases for the verifier live in the \"verify\" module of the\n+// Mauve test suite.  However, some of these are presently\n+// (2004-01-20) believed to be incorrect.  (More precisely the notion\n+// of \"correct\" is not well-defined, and this verifier differs from\n+// others while remaining type-safe.)  Some other tests live in the\n+// libgcj test suite.\n class _Jv_BytecodeVerifier\n {\n private:\n@@ -55,11 +131,16 @@ class _Jv_BytecodeVerifier\n \n   struct state;\n   struct type;\n-  struct subr_info;\n-  struct subr_entry_info;\n   struct linked_utf8;\n   struct ref_intersection;\n \n+  template<typename T>\n+  struct linked\n+  {\n+    T *val;\n+    linked<T> *next;\n+  };\n+\n   // The current PC.\n   int PC;\n   // The PC corresponding to the start of the current instruction.\n@@ -68,29 +149,21 @@ class _Jv_BytecodeVerifier\n   // The current state of the stack, locals, etc.\n   state *current_state;\n \n-  // We store the state at branch targets, for merging.  This holds\n-  // such states.\n-  state **states;\n+  // At each branch target we keep a linked list of all the states we\n+  // can process at that point.  We'll only have multiple states at a\n+  // given PC if they both have different return-address types in the\n+  // same stack or local slot.  This array is indexed by PC and holds\n+  // the list of all such states.\n+  linked<state> **states;\n \n-  // We keep a linked list of all the PCs which we must reverify.\n-  // The link is done using the PC values.  This is the head of the\n-  // list.\n-  int next_verify_pc;\n+  // We keep a linked list of all the states which we must reverify.\n+  // This is the head of the list.\n+  state *next_verify_state;\n \n   // We keep some flags for each instruction.  The values are the\n-  // FLAG_* constants defined above.\n+  // FLAG_* constants defined above.  This is an array indexed by PC.\n   char *flags;\n \n-  // We need to keep track of which instructions can call a given\n-  // subroutine.  FIXME: this is inefficient.  We keep a linked list\n-  // of all calling `jsr's at at each jsr target.\n-  subr_info **jsr_ptrs;\n-\n-  // We keep a linked list of entries which map each `ret' instruction\n-  // to its unique subroutine entry point.  We expect that there won't\n-  // be many `ret' instructions, so a linked list is ok.\n-  subr_entry_info *entry_points;\n-\n   // The bytecode itself.\n   unsigned char *bytecode;\n   // The exceptions.\n@@ -103,17 +176,14 @@ class _Jv_BytecodeVerifier\n \n   // A linked list of utf8 objects we allocate.  This is really ugly,\n   // but without this our utf8 objects would be collected.\n-  linked_utf8 *utf8_list;\n+  linked<_Jv_Utf8Const> *utf8_list;\n \n   // A linked list of all ref_intersection objects we allocate.\n   ref_intersection *isect_list;\n \n-  struct linked_utf8\n-  {\n-    _Jv_Utf8Const *val;\n-    linked_utf8 *next;\n-  };\n-\n+  // Create a new Utf-8 constant and return it.  We do this to avoid\n+  // having our Utf-8 constants prematurely collected.  FIXME this is\n+  // ugly.\n   _Jv_Utf8Const *make_utf8_const (char *s, int len)\n   {\n     _Jv_Utf8Const *val = _Jv_makeUtf8Const (s, len);\n@@ -124,7 +194,8 @@ class _Jv_BytecodeVerifier\n     r->hash = val->hash;\n     memcpy (r->data, val->data, val->length + 1);\n \n-    linked_utf8 *lu = (linked_utf8 *) _Jv_Malloc (sizeof (linked_utf8));\n+    linked<_Jv_Utf8Const> *lu\n+      = (linked<_Jv_Utf8Const> *) _Jv_Malloc (sizeof (linked<_Jv_Utf8Const>));\n     lu->val = r;\n     lu->next = utf8_list;\n     utf8_list = lu;\n@@ -183,13 +254,10 @@ class _Jv_BytecodeVerifier\n     // to indicate an unusable value.\n     unsuitable_type,\n     return_address_type,\n+    // This is the second word of a two-word value, i.e., a double or\n+    // a long.\n     continuation_type,\n \n-    // There is an obscure special case which requires us to note when\n-    // a local variable has not been used by a subroutine.  See\n-    // push_jump_merge for more information.\n-    unused_by_subroutine_type,\n-\n     // Everything after `reference_type' must be a reference type.\n     reference_type,\n     null_type,\n@@ -497,28 +565,6 @@ class _Jv_BytecodeVerifier\n     return false;\n   }\n \n-  // This is used to keep track of which `jsr's correspond to a given\n-  // jsr target.\n-  struct subr_info\n-  {\n-    // PC of the instruction just after the jsr.\n-    int pc;\n-    // Link.\n-    subr_info *next;\n-  };\n-\n-  // This is used to keep track of which subroutine entry point\n-  // corresponds to which `ret' instruction.\n-  struct subr_entry_info\n-  {\n-    // PC of the subroutine entry point.\n-    int pc;\n-    // PC of the `ret' instruction.\n-    int ret_pc;\n-    // Link.\n-    subr_entry_info *next;\n-  };\n-\n   // The `type' class is used to represent a single type in the\n   // verifier.\n   struct type\n@@ -529,11 +575,16 @@ class _Jv_BytecodeVerifier\n     // For reference types, the representation of the type.\n     ref_intersection *klass;\n \n-    // This is used when constructing a new object.  It is the PC of the\n+    // This is used in two situations.\n+    //\n+    // First, when constructing a new object, it is the PC of the\n     // `new' instruction which created the object.  We use the special\n-    // value -2 to mean that this is uninitialized, and the special\n-    // value -1 for the case where the current method is itself the\n-    // <init> method.\n+    // value UNINIT to mean that this is uninitialized, and the\n+    // special value SELF for the case where the current method is\n+    // itself the <init> method.\n+    //\n+    // Second, when the key is return_address_type, this holds the PC\n+    // of the instruction following the `jsr'.\n     int pc;\n \n     static const int UNINIT = -2;\n@@ -640,6 +691,23 @@ class _Jv_BytecodeVerifier\n \t}\n     }\n \n+    // Mark this type as a particular return address.\n+    void set_return_address (int npc)\n+    {\n+      pc = npc;\n+    }\n+\n+    // Return true if this type and type OTHER are considered\n+    // mergeable for the purposes of state merging.  This is related\n+    // to subroutine handling.  For this purpose two types are\n+    // considered unmergeable if they are both return-addresses but\n+    // have different PCs.\n+    bool state_mergeable_p (const type &other) const\n+    {\n+      return (key != return_address_type\n+\t      || other.key != return_address_type\n+\t      || pc == other.pc);\n+    }\n \n     // Return true if an object of type K can be assigned to a variable\n     // of type *THIS.  Handle various special cases too.  Might modify\n@@ -780,13 +848,16 @@ class _Jv_BytecodeVerifier\n     {\n       // The way this is written, we don't need to check isarray().\n       if (key != reference_type)\n-\tverifier->verify_fail (\"internal error in verify_dimensions: not a reference type\");\n+\tverifier->verify_fail (\"internal error in verify_dimensions:\"\n+\t\t\t       \" not a reference type\");\n \n       if (klass->count_dimensions () < ndims)\n-\tverifier->verify_fail (\"array type has fewer dimensions than required\");\n+\tverifier->verify_fail (\"array type has fewer dimensions\"\n+\t\t\t       \" than required\");\n     }\n \n-    // Merge OLD_TYPE into this.  On error throw exception.\n+    // Merge OLD_TYPE into this.  On error throw exception.  Return\n+    // true if the merge caused a type change.\n     bool merge (type& old_type, bool local_semantics,\n \t\t_Jv_BytecodeVerifier *verifier)\n     {\n@@ -829,20 +900,9 @@ class _Jv_BytecodeVerifier\n \t{\n \t  if (local_semantics)\n \t    {\n-\t      // If we're merging into an \"unused\" slot, then we\n-\t      // simply accept whatever we're merging from.\n-\t      if (key == unused_by_subroutine_type)\n-\t\t{\n-\t\t  *this = old_type;\n-\t\t  changed = true;\n-\t\t}\n-\t      else if (old_type.key == unused_by_subroutine_type)\n-\t\t{\n-\t\t  // Do nothing.\n-\t\t}\n \t      // If we already have an `unsuitable' type, then we\n \t      // don't need to change again.\n-\t      else if (key != unsuitable_type)\n+\t      if (key != unsuitable_type)\n \t\t{\n \t\t  key = unsuitable_type;\n \t\t  changed = true;\n@@ -872,7 +932,6 @@ class _Jv_BytecodeVerifier\n \tcase unsuitable_type: c = '-'; break;\n \tcase return_address_type: c = 'r'; break;\n \tcase continuation_type: c = '+'; break;\n-\tcase unused_by_subroutine_type: c = '_'; break;\n \tcase reference_type: c = 'L'; break;\n \tcase null_type: c = '@'; break;\n \tcase uninitialized_reference_type: c = 'U'; break;\n@@ -895,57 +954,34 @@ class _Jv_BytecodeVerifier\n     type *stack;\n     // The local variables.\n     type *locals;\n-    // Flags are used in subroutines to keep track of which local\n-    // variables have been accessed.  They are also used after \n-    char *flags;\n-    // If not 0, then we are in a subroutine.  The value is the PC of\n-    // the subroutine's entry point.  We can use 0 as an exceptional\n-    // value because PC=0 can never be a subroutine.\n-    int subroutine;\n-    // This is used to keep a linked list of all the states which\n-    // require re-verification.  We use the PC to keep track.\n-    int next;\n     // We keep track of the type of `this' specially.  This is used to\n     // ensure that an instance initializer invokes another initializer\n     // on `this' before returning.  We must keep track of this\n     // specially because otherwise we might be confused by code which\n     // assigns to locals[0] (overwriting `this') and then returns\n     // without really initializing.\n     type this_type;\n-    // This is a list of all subroutines that have been seen at this\n-    // point.  Ordinarily this is NULL; it is only allocated and used\n-    // in relatively weird situations involving non-ret exit from a\n-    // subroutine.  We have to keep track of this in this way to avoid\n-    // endless recursion in these cases.\n-    subr_info *seen_subrs;\n-\n-    // INVALID marks a state which is not on the linked list of states\n-    // requiring reverification.\n-    static const int INVALID = -1;\n-    // NO_NEXT marks the state at the end of the reverification list.\n-    static const int NO_NEXT = -2;\n-\n-    // This is used to mark the stack depth at the instruction just\n-    // after a `jsr' when we haven't yet processed the corresponding\n-    // `ret'.  See handle_jsr_insn for more information.\n-    static const int NO_STACK = -1;\n-\n-    // This flag indicates that the local was changed in this\n-    // subroutine.\n-    static const int FLAG_CHANGED = 1;\n-    // This is set only on the flags of the state of an instruction\n-    // directly following a \"jsr\".  It indicates that the local\n-    // variable was changed by the subroutine corresponding to the\n-    // \"jsr\".\n-    static const int FLAG_USED = 2;\n+\n+    // The PC for this state.  This is only valid on states which are\n+    // permanently attached to a given PC.  For an object like\n+    // `current_state', which is used transiently, this has no\n+    // meaning.\n+    int pc;\n+    // We keep a linked list of all states requiring reverification.\n+    // If this is the special value INVALID_STATE then this state is\n+    // not on the list.  NULL marks the end of the linked list.\n+    state *next;\n+\n+    // NO_NEXT is the PC value meaning that a new state must be\n+    // acquired from the verification list.\n+    static const int NO_NEXT = -1;\n \n     state ()\n       : this_type ()\n     {\n       stack = NULL;\n       locals = NULL;\n-      flags = NULL;\n-      seen_subrs = NULL;\n+      next = INVALID_STATE;\n     }\n \n     state (int max_stack, int max_locals)\n@@ -957,26 +993,19 @@ class _Jv_BytecodeVerifier\n       for (int i = 0; i < max_stack; ++i)\n \tstack[i] = unsuitable_type;\n       locals = new type[max_locals];\n-      flags = (char *) _Jv_Malloc (sizeof (char) * max_locals);\n-      seen_subrs = NULL;\n       for (int i = 0; i < max_locals; ++i)\n-\t{\n-\t  locals[i] = unsuitable_type;\n-\t  flags[i] = 0;\n-\t}\n-      next = INVALID;\n-      subroutine = 0;\n+\tlocals[i] = unsuitable_type;\n+      pc = NO_NEXT;\n+      next = INVALID_STATE;\n     }\n \n-    state (const state *orig, int max_stack, int max_locals,\n-\t   bool ret_semantics = false)\n+    state (const state *orig, int max_stack, int max_locals)\n     {\n       stack = new type[max_stack];\n       locals = new type[max_locals];\n-      flags = (char *) _Jv_Malloc (sizeof (char) * max_locals);\n-      seen_subrs = NULL;\n-      copy (orig, max_stack, max_locals, ret_semantics);\n-      next = INVALID;\n+      copy (orig, max_stack, max_locals);\n+      pc = NO_NEXT;\n+      next = INVALID_STATE;\n     }\n \n     ~state ()\n@@ -985,9 +1014,6 @@ class _Jv_BytecodeVerifier\n \tdelete[] stack;\n       if (locals)\n \tdelete[] locals;\n-      if (flags)\n-\t_Jv_Free (flags);\n-      clean_subrs ();\n     }\n \n     void *operator new[] (size_t bytes)\n@@ -1010,65 +1036,17 @@ class _Jv_BytecodeVerifier\n       _Jv_Free (mem);\n     }\n \n-    void clean_subrs ()\n-    {\n-      subr_info *info = seen_subrs;\n-      while (info != NULL)\n-\t{\n-\t  subr_info *next = info->next;\n-\t  _Jv_Free (info);\n-\t  info = next;\n-\t}\n-      seen_subrs = NULL;\n-    }\n-\n-    void copy (const state *copy, int max_stack, int max_locals,\n-\t       bool ret_semantics = false)\n+    void copy (const state *copy, int max_stack, int max_locals)\n     {\n       stacktop = copy->stacktop;\n       stackdepth = copy->stackdepth;\n-      subroutine = copy->subroutine;\n       for (int i = 0; i < max_stack; ++i)\n \tstack[i] = copy->stack[i];\n       for (int i = 0; i < max_locals; ++i)\n-\t{\n-\t  // See push_jump_merge to understand this case.\n-\t  if (ret_semantics)\n-\t    {\n-\t      if ((copy->flags[i] & FLAG_CHANGED))\n-\t\t{\n-\t\t  // Changed in the subroutine, so we copy it here.\n-\t\t  locals[i] = copy->locals[i];\n-\t\t  flags[i] |= FLAG_USED;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  // Not changed in the subroutine.  Use a special\n-\t\t  // type so the coming merge will overwrite.\n-\t\t  locals[i] = type (unused_by_subroutine_type);\n-\t\t}\n-\t    }\n-\t  else\n-\t    locals[i] = copy->locals[i];\n-\n-\t  // Clear the flag unconditionally just so printouts look ok,\n-\t  // then only set it if we're still in a subroutine and it\n-\t  // did in fact change.\n-\t  flags[i] &= ~FLAG_CHANGED;\n-\t  if (subroutine && (copy->flags[i] & FLAG_CHANGED) != 0)\n-\t    flags[i] |= FLAG_CHANGED;\n-\t}\n-\n-      clean_subrs ();\n-      if (copy->seen_subrs)\n-\t{\n-\t  for (subr_info *info = copy->seen_subrs;\n-\t       info != NULL; info = info->next)\n-\t    add_subr (info->pc);\n-\t}\n+\tlocals[i] = copy->locals[i];\n \n       this_type = copy->this_type;\n-      // Don't modify `next'.\n+      // Don't modify `next' or `pc'.\n     }\n \n     // Modify this state to reflect entry to an exception handler.\n@@ -1081,33 +1059,21 @@ class _Jv_BytecodeVerifier\n \tstack[i] = unsuitable_type;\n     }\n \n-    // Modify this state to reflect entry into a subroutine.\n-    void enter_subroutine (int npc, int max_locals)\n+    inline int get_pc () const\n     {\n-      subroutine = npc;\n-      // Mark all items as unchanged.  Each subroutine needs to keep\n-      // track of its `changed' state independently.  In the case of\n-      // nested subroutines, this information will be merged back into\n-      // parent by the `ret'.\n-      for (int i = 0; i < max_locals; ++i)\n-\tflags[i] &= ~FLAG_CHANGED;\n+      return pc;\n     }\n \n-    // Indicate that we've been in this this subroutine.\n-    void add_subr (int pc)\n+    void set_pc (int npc)\n     {\n-      subr_info *n = (subr_info *) _Jv_Malloc (sizeof (subr_info));\n-      n->pc = pc;\n-      n->next = seen_subrs;\n-      seen_subrs = n;\n+      pc = npc;\n     }\n \n     // Merge STATE_OLD into this state.  Destructively modifies this\n     // state.  Returns true if the new state was in fact changed.\n     // Will throw an exception if the states are not mergeable.\n-    bool merge (state *state_old, bool ret_semantics,\n-\t\tint max_locals, _Jv_BytecodeVerifier *verifier,\n-\t\tbool jsr_semantics = false)\n+    bool merge (state *state_old, int max_locals,\n+\t\t_Jv_BytecodeVerifier *verifier)\n     {\n       bool changed = false;\n \n@@ -1116,135 +1082,20 @@ class _Jv_BytecodeVerifier\n       if (this_type.isinitialized ())\n \tthis_type = state_old->this_type;\n \n-      // Merge subroutine states.  Here we just keep track of what\n-      // subroutine we think we're in.  We only check for a merge\n-      // (which is invalid) when we see a `ret'.\n-      if (subroutine == state_old->subroutine)\n-\t{\n-\t  // Nothing.\n-\t}\n-      else if (subroutine == 0)\n-\t{\n-\t  subroutine = state_old->subroutine;\n-\t  changed = true;\n-\t}\n-      else\n-\t{\n-\t  // If the subroutines differ, and we haven't seen this\n-\t  // subroutine before, indicate that the state changed.  This\n-\t  // is needed to detect when subroutines have merged.\n-\t  bool found = false;\n-\t  for (subr_info *info = seen_subrs; info != NULL; info = info->next)\n-\t    {\n-\t      if (info->pc == state_old->subroutine)\n-\t\t{\n-\t\t  found = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (! found)\n-\t    {\n-\t      add_subr (state_old->subroutine);\n-\t      changed = true;\n-\t    }\n-\t}\n-\n-      // Merge stacks, including special handling for NO_STACK case.\n-      // If the destination is NO_STACK, this means it is the\n-      // instruction following a \"jsr\" and has not yet been processed\n-      // in any way.  In this situation, if we are currently\n-      // processing a \"ret\", then we must *copy* any locals changed in\n-      // the subroutine into the current state.  Merging in this\n-      // situation is incorrect because the locals we've noted didn't\n-      // come real program flow, they are just an artifact of how\n-      // we've chosen to handle the post-jsr state.\n-      bool copy_in_locals = ret_semantics && stacktop == NO_STACK;\n-\n-      if (state_old->stacktop == NO_STACK)\n-\t{\n-\t  // This can happen if we're doing a pass-through jsr merge.\n-\t  // Here we can just ignore the stack.\n-\t}\n-      else if (stacktop == NO_STACK)\n-\t{\n-\t  stacktop = state_old->stacktop;\n-\t  stackdepth = state_old->stackdepth;\n-\t  for (int i = 0; i < stacktop; ++i)\n-\t    stack[i] = state_old->stack[i];\n-\t  changed = true;\n-\t}\n-      else if (state_old->stacktop != stacktop)\n+      // Merge stacks.\n+      if (state_old->stacktop != stacktop)  // FIXME stackdepth instead?\n \tverifier->verify_fail (\"stack sizes differ\");\n-      else\n+      for (int i = 0; i < state_old->stacktop; ++i)\n \t{\n-\t  for (int i = 0; i < state_old->stacktop; ++i)\n-\t    {\n-\t      if (stack[i].merge (state_old->stack[i], false, verifier))\n-\t\tchanged = true;\n-\t    }\n+\t  if (stack[i].merge (state_old->stack[i], false, verifier))\n+\t    changed = true;\n \t}\n \n       // Merge local variables.\n       for (int i = 0; i < max_locals; ++i)\n \t{\n-\t  // If we're not processing a `ret', then we merge every\n-\t  // local variable.  If we are processing a `ret', then we\n-\t  // only merge locals which changed in the subroutine.  When\n-\t  // processing a `ret', STATE_OLD is the state at the point\n-\t  // of the `ret', and THIS is the state just after the `jsr'.\n-\t  // See comment above for explanation of COPY_IN_LOCALS.\n-\t  if (copy_in_locals)\n-\t    {\n-\t      if ((state_old->flags[i] & FLAG_CHANGED) != 0)\n-\t\t{\n-\t\t  locals[i] = state_old->locals[i];\n-\t\t  changed = true;\n-\t\t  // There's no point in calling note_variable here,\n-\t\t  // since we call it under the same condition before\n-\t\t  // the loop ends.\n-\t\t}\n-\t    }\n-\t  else if (jsr_semantics && (flags[i] & FLAG_USED) != 0)\n-\t    {\n-\t      // We are processing the \"pass-through\" part of a jsr\n-\t      // statement.  In this particular case, the local was\n-\t      // changed by the subroutine.  So, we have no work to\n-\t      // do, as the pre-jsr value does not survive the\n-\t      // subroutine call.\n-\t    }\n-\t  else if (! ret_semantics\n-\t\t   || (state_old->flags[i] & FLAG_CHANGED) != 0)\n-\t    {\n-\t      // If we have ordinary (not ret) semantics, then we have\n-\t      // merging flow control, so we merge types.  Or, we have\n-\t      // jsr pass-through semantics and the type survives the\n-\t      // subroutine (see above), so again we merge.  Or,\n-\t      // finally, we have ret semantics and this value did\n-\t      // change, in which case we merge the change from the\n-\t      // subroutine into the post-jsr instruction.\n-\t      if (locals[i].merge (state_old->locals[i], true, verifier))\n-\t\t{\n-\t\t  // Note that we don't call `note_variable' here.\n-\t\t  // This change doesn't represent a real change to a\n-\t\t  // local, but rather a merge artifact.  If we're in\n-\t\t  // a subroutine which is called with two\n-\t\t  // incompatible types in a slot that is unused by\n-\t\t  // the subroutine, then we don't want to mark that\n-\t\t  // variable as having been modified.\n-\t\t  changed = true;\n-\t\t}\n-\t    }\n-\n-\t  // If we're in a subroutine, we must compute the union of\n-\t  // all the changed local variables.\n-\t  if ((state_old->flags[i] & FLAG_CHANGED) != 0)\n-\t    note_variable (i);\n-\n-\t  // If we're returning from a subroutine, we must mark the\n-\t  // post-jsr instruction with information about what changed,\n-\t  // so that future \"pass-through\" jsr merges work correctly.\n-\t  if (ret_semantics && (state_old->flags[i] & FLAG_CHANGED) != 0)\n-\t    flags[i] |= FLAG_USED;\n+\t  if (locals[i].merge (state_old->locals[i], true, verifier))\n+\t    changed = true;\n \t}\n \n       return changed;\n@@ -1285,13 +1136,6 @@ class _Jv_BytecodeVerifier\n       this_type = k;\n     }\n \n-    // Note that a local variable was modified.\n-    void note_variable (int index)\n-    {\n-      if (subroutine > 0)\n-\tflags[index] |= FLAG_CHANGED;\n-    }\n-\n     // Mark each `new'd object we know of that was allocated at PC as\n     // initialized.\n     void set_initialized (int pc, int max_locals)\n@@ -1303,17 +1147,36 @@ class _Jv_BytecodeVerifier\n       this_type.set_initialized (pc);\n     }\n \n-    // Return true if this state is the unmerged result of a `ret'.\n-    bool is_unmerged_ret_state (int max_locals) const\n+    // This tests to see whether two states can be considered \"merge\n+    // compatible\".  If both states have a return-address in the same\n+    // slot, and the return addresses are different, then they are not\n+    // compatible and we must not try to merge them.\n+    bool state_mergeable_p (state *other, int max_locals,\n+\t\t\t    _Jv_BytecodeVerifier *verifier)\n     {\n-      if (stacktop == NO_STACK)\n-\treturn true;\n+      // This is tricky: if the stack sizes differ, then not only are\n+      // these not mergeable, but in fact we should give an error, as\n+      // we've found two execution paths that reach a branch target\n+      // with different stack depths.  FIXME stackdepth instead?\n+      if (stacktop != other->stacktop)\n+\tverifier->verify_fail (\"stack sizes differ\");\n+\n+      for (int i = 0; i < stacktop; ++i)\n+\tif (! stack[i].state_mergeable_p (other->stack[i]))\n+\t  return false;\n       for (int i = 0; i < max_locals; ++i)\n+\tif (! locals[i].state_mergeable_p (other->locals[i]))\n+\t  return false;\n+      return true;\n+    }\n+\n+    void reverify (_Jv_BytecodeVerifier *verifier)\n+    {\n+      if (next == INVALID_STATE)\n \t{\n-\t  if (locals[i].key == unused_by_subroutine_type)\n-\t    return true;\n+\t  next = verifier->next_verify_state;\n+\t  verifier->next_verify_state = this;\n \t}\n-      return false;\n     }\n \n #ifdef VERIFY_DEBUG\n@@ -1328,17 +1191,7 @@ class _Jv_BytecodeVerifier\n \tdebug_print (\".\");\n       debug_print (\"    [local] \");\n       for (i = 0; i < max_locals; ++i)\n-\t{\n-\t  locals[i].print ();\n-\t  if ((flags[i] & FLAG_USED) != 0)\n-\t    debug_print ((flags[i] & FLAG_CHANGED) ? \">\" : \"<\");\n-\t  else\n-\t    debug_print ((flags[i] & FLAG_CHANGED) ? \"+\" : \" \");\n-\t}\n-      if (subroutine == 0)\n-\tdebug_print (\"   | None\");\n-      else\n-\tdebug_print (\"   | %4d\", subroutine);\n+\tlocals[i].print ();\n       debug_print (\" | %p\\n\", this);\n     }\n #else\n@@ -1419,18 +1272,11 @@ class _Jv_BytecodeVerifier\n     if (index > current_method->max_locals - depth)\n       verify_fail (\"invalid local variable\");\n     current_state->locals[index] = t;\n-    current_state->note_variable (index);\n \n     if (depth == 2)\n-      {\n-\tcurrent_state->locals[index + 1] = continuation_type;\n-\tcurrent_state->note_variable (index + 1);\n-      }\n+      current_state->locals[index + 1] = continuation_type;\n     if (index > 0 && current_state->locals[index - 1].iswide ())\n-      {\n-\tcurrent_state->locals[index - 1] = unsuitable_type;\n-\t// There's no need to call note_variable here.\n-      }\n+      current_state->locals[index - 1] = unsuitable_type;\n   }\n \n   type get_variable (int index, type t)\n@@ -1520,56 +1366,71 @@ class _Jv_BytecodeVerifier\n     return npc;\n   }\n \n+  // Add a new state to the state list at NPC.\n+  state *add_new_state (int npc, state *old_state)\n+  {\n+    state *new_state = new state (old_state, current_method->max_stack,\n+\t\t\t\t  current_method->max_locals);\n+    debug_print (\"== New state in add_new_state\\n\");\n+    new_state->print (\"New\", npc, current_method->max_stack,\n+\t\t      current_method->max_locals);\n+    linked<state> *nlink\n+      = (linked<state> *) _Jv_Malloc (sizeof (linked<state>));\n+    nlink->val = new_state;\n+    nlink->next = states[npc];\n+    states[npc] = nlink;\n+    new_state->set_pc (npc);\n+    return new_state;\n+  }\n+\n   // Merge the indicated state into the state at the branch target and\n-  // schedule a new PC if there is a change.  If RET_SEMANTICS is\n-  // true, then we are merging from a `ret' instruction into the\n-  // instruction after a `jsr'.  This is a special case with its own\n-  // modified semantics.  If JSR_SEMANTICS is true, then we're merging\n-  // some type information from a \"jsr\" instruction to the immediately\n-  // following instruction.  In this situation we have to be careful\n-  // not to merge local variables whose values are modified by the\n-  // subroutine we're about to call.\n-  void push_jump_merge (int npc, state *nstate,\n-\t\t\tbool ret_semantics = false,\n-\t\t\tbool jsr_semantics = false)\n+  // schedule a new PC if there is a change.  NPC is the PC of the\n+  // branch target, and FROM_STATE is the state at the source of the\n+  // branch.  This method returns true if the destination state\n+  // changed and requires reverification, false otherwise.\n+  void merge_into (int npc, state *from_state)\n   {\n-    bool changed = true;\n-    if (states[npc] == NULL)\n+    // Iterate over all target states and merge our state into each,\n+    // if applicable.  FIXME one improvement we could make here is\n+    // \"state destruction\".  Merging a new state into an existing one\n+    // might cause a return_address_type to be merged to\n+    // unsuitable_type.  In this case the resulting state may now be\n+    // mergeable with other states currently held in parallel at this\n+    // location.  So in this situation we could pairwise compare and\n+    // reduce the number of parallel states.\n+    bool applicable = false;\n+    for (linked<state> *iter = states[npc]; iter != NULL; iter = iter->next)\n       {\n-\t// There's a weird situation here.  If are examining the\n-\t// branch that results from a `ret', and there is not yet a\n-\t// state available at the branch target (the instruction just\n-\t// after the `jsr'), then we have to construct a special kind\n-\t// of state at that point for future merging.  This special\n-\t// state has the type `unused_by_subroutine_type' in each slot\n-\t// which was not modified by the subroutine.\n-\tstates[npc] = new state (nstate, current_method->max_stack,\n-\t\t\t\t current_method->max_locals, ret_semantics);\n-\tdebug_print (\"== New state in push_jump_merge (ret_semantics = %s)\\n\",\n-\t\t     ret_semantics ? \"true\" : \"false\");\n-\tstates[npc]->print (\"New\", npc, current_method->max_stack,\n-\t\t\t    current_method->max_locals);\n-      }\n-    else\n-      {\n-\tdebug_print (\"== Merge states in push_jump_merge\\n\");\n-\tnstate->print (\"Frm\", start_PC, current_method->max_stack,\n-\t\t       current_method->max_locals);\n-\tstates[npc]->print (\" To\", npc, current_method->max_stack,\n-\t\t\t    current_method->max_locals);\n-\tchanged = states[npc]->merge (nstate, ret_semantics,\n-\t\t\t\t      current_method->max_locals, this,\n-\t\t\t\t      jsr_semantics);\n-\tstates[npc]->print (\"New\", npc, current_method->max_stack,\n-\t\t\t    current_method->max_locals);\n+\tstate *new_state = iter->val;\n+\tif (new_state->state_mergeable_p (from_state,\n+\t\t\t\t\t  current_method->max_locals, this))\n+\t  {\n+\t    applicable = true;\n+\n+\t    debug_print (\"== Merge states in merge_into\\n\");\n+\t    from_state->print (\"Frm\", start_PC, current_method->max_stack,\n+\t\t\t       current_method->max_locals);\n+\t    new_state->print (\" To\", npc, current_method->max_stack,\n+\t\t\t      current_method->max_locals);\n+\t    bool changed = new_state->merge (from_state,\n+\t\t\t\t\t     current_method->max_locals,\n+\t\t\t\t\t     this);\n+\t    new_state->print (\"New\", npc, current_method->max_stack,\n+\t\t\t      current_method->max_locals);\n+\n+\t    if (changed)\n+\t      new_state->reverify (this);\n+\t  }\n       }\n \n-    if (changed && states[npc]->next == state::INVALID)\n+    if (! applicable)\n       {\n-\t// The merge changed the state, and the new PC isn't yet on our\n-\t// list of PCs to re-verify.\n-\tstates[npc]->next = next_verify_pc;\n-\tnext_verify_pc = npc;\n+\t// Either we don't yet have a state at NPC, or we have a\n+\t// return-address type that is in conflict with all existing\n+\t// state.  So, we need to create a new entry.\n+\tstate *new_state = add_new_state (npc, from_state);\n+\t// A new state added in this way must always be reverified.\n+\tnew_state->reverify (this);\n       }\n   }\n \n@@ -1578,7 +1439,7 @@ class _Jv_BytecodeVerifier\n     int npc = compute_jump (offset);\n     if (npc < PC)\n       current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n-    push_jump_merge (npc, current_state);\n+    merge_into (npc, current_state);\n   }\n \n   void push_exception_jump (type t, int pc)\n@@ -1590,60 +1451,35 @@ class _Jv_BytecodeVerifier\n     if (current_method->max_stack < 1)\n       verify_fail (\"stack overflow at exception handler\");\n     s.set_exception (t, current_method->max_stack);\n-    push_jump_merge (pc, &s);\n+    merge_into (pc, &s);\n   }\n \n-  int pop_jump ()\n+  state *pop_jump ()\n   {\n-    int *prev_loc = &next_verify_pc;\n-    int npc = next_verify_pc;\n-\n-    while (npc != state::NO_NEXT)\n+    state *new_state = next_verify_state;\n+    if (new_state == INVALID_STATE)\n+      verify_fail (\"programmer error in pop_jump\");\n+    if (new_state != NULL)\n       {\n-\t// If the next available PC is an unmerged `ret' state, then\n-\t// we aren't yet ready to handle it.  That's because we would\n-\t// need all kind of special cases to do so.  So instead we\n-\t// defer this jump until after we've processed it via a\n-\t// fall-through.  This has to happen because the instruction\n-\t// before this one must be a `jsr'.\n-\tif (! states[npc]->is_unmerged_ret_state (current_method->max_locals))\n-\t  {\n-\t    *prev_loc = states[npc]->next;\n-\t    states[npc]->next = state::INVALID;\n-\t    return npc;\n-\t  }\n-\n-\tprev_loc = &states[npc]->next;\n-\tnpc = states[npc]->next;\n+\tnext_verify_state = new_state->next;\n+\tnew_state->next = INVALID_STATE;\n       }\n-\n-    // Note that we might have gotten here even when there are\n-    // remaining states to process.  That can happen if we find a\n-    // `jsr' without a `ret'.\n-    return state::NO_NEXT;\n+    return new_state;\n   }\n \n   void invalidate_pc ()\n   {\n     PC = state::NO_NEXT;\n   }\n \n-  void note_branch_target (int pc, bool is_jsr_target = false)\n+  void note_branch_target (int pc)\n   {\n     // Don't check `pc <= PC', because we've advanced PC after\n     // fetching the target and we haven't yet checked the next\n     // instruction.\n     if (pc < PC && ! (flags[pc] & FLAG_INSN_START))\n       verify_fail (\"branch not to instruction start\", start_PC);\n     flags[pc] |= FLAG_BRANCH_TARGET;\n-    if (is_jsr_target)\n-      {\n-\t// Record the jsr which called this instruction.\n-\tsubr_info *info = (subr_info *) _Jv_Malloc (sizeof (subr_info));\n-\tinfo->pc = PC;\n-\tinfo->next = jsr_ptrs[pc];\n-\tjsr_ptrs[pc] = info;\n-      }\n   }\n \n   void skip_padding ()\n@@ -1653,108 +1489,43 @@ class _Jv_BytecodeVerifier\n \tverify_fail (\"found nonzero padding byte\");\n   }\n \n-  // Return the subroutine to which the instruction at PC belongs.\n-  int get_subroutine (int pc)\n-  {\n-    if (states[pc] == NULL)\n-      return 0;\n-    return states[pc]->subroutine;\n-  }\n-\n   // Do the work for a `ret' instruction.  INDEX is the index into the\n   // local variables.\n   void handle_ret_insn (int index)\n   {\n-    get_variable (index, return_address_type);\n-\n-    int csub = current_state->subroutine;\n-    if (csub == 0)\n-      verify_fail (\"no subroutine\");\n+    type ret_addr = get_variable (index, return_address_type);\n+    // It would be nice if we could do this.  However, the JVM Spec\n+    // doesn't say that this is what happens.  It is implied that\n+    // reusing a return address is invalid, but there's no actual\n+    // prohibition against it.\n+    // set_variable (index, unsuitable_type);\n+\n+    int npc = ret_addr.get_pc ();\n+    // We might be returning to a `jsr' that is at the end of the\n+    // bytecode.  This is ok if we never return from the called\n+    // subroutine, but if we see this here it is an error.\n+    if (npc >= current_method->code_length)\n+      verify_fail (\"fell off end\");\n \n-    // Check to see if we've merged subroutines.\n-    subr_entry_info *entry;\n-    for (entry = entry_points; entry != NULL; entry = entry->next)\n-      {\n-\tif (entry->ret_pc == start_PC)\n-\t  break;\n-      }\n-    if (entry == NULL)\n-      {\n-\tentry = (subr_entry_info *) _Jv_Malloc (sizeof (subr_entry_info));\n-\tentry->pc = csub;\n-\tentry->ret_pc = start_PC;\n-\tentry->next = entry_points;\n-\tentry_points = entry;\n-      }\n-    else if (entry->pc != csub)\n-      verify_fail (\"subroutines merged\");\n-\n-    for (subr_info *subr = jsr_ptrs[csub]; subr != NULL; subr = subr->next)\n-      {\n-\t// We might be returning to a `jsr' that is at the end of the\n-\t// bytecode.  This is ok if we never return from the called\n-\t// subroutine, but if we see this here it is an error.\n-\tif (subr->pc >= current_method->code_length)\n-\t  verify_fail (\"fell off end\");\n-\n-\t// Temporarily modify the current state so it looks like we're\n-\t// in the enclosing context.\n-\tcurrent_state->subroutine = get_subroutine (subr->pc);\n-\tif (subr->pc < PC)\n-\t  current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n-\tpush_jump_merge (subr->pc, current_state, true);\n-      }\n-\n-    current_state->subroutine = csub;\n+    if (npc < PC)\n+      current_state->check_no_uninitialized_objects (current_method->max_locals,\n+\t\t\t\t\t\t     this);\n+    merge_into (npc, current_state);\n     invalidate_pc ();\n   }\n \n-  // We're in the subroutine SUB, calling a subroutine at DEST.  Make\n-  // sure this subroutine isn't already on the stack.\n-  void check_nonrecursive_call (int sub, int dest)\n-  {\n-    if (sub == 0)\n-      return;\n-    if (sub == dest)\n-      verify_fail (\"recursive subroutine call\");\n-    for (subr_info *info = jsr_ptrs[sub]; info != NULL; info = info->next)\n-      check_nonrecursive_call (get_subroutine (info->pc), dest);\n-  }\n-\n   void handle_jsr_insn (int offset)\n   {\n     int npc = compute_jump (offset);\n \n     if (npc < PC)\n       current_state->check_no_uninitialized_objects (current_method->max_locals, this);\n-    check_nonrecursive_call (current_state->subroutine, npc);\n \n     // Modify our state as appropriate for entry into a subroutine.\n-    push_type (return_address_type);\n-    push_jump_merge (npc, current_state);\n-    // Clean up.\n-    pop_type (return_address_type);\n-\n-    // On entry to the subroutine, the subroutine number must be set\n-    // and the locals must be marked as cleared.  We do this after\n-    // merging state so that we don't erroneously \"notice\" a variable\n-    // change merely on entry.\n-    states[npc]->enter_subroutine (npc, current_method->max_locals);\n-\n-    // Indicate that we don't know the stack depth of the instruction\n-    // following the `jsr'.  The idea here is that we need to merge\n-    // the local variable state across the jsr, but the subroutine\n-    // might change the stack depth, so we can't make any assumptions\n-    // about it.  So we have yet another special case.  We know that\n-    // at this point PC points to the instruction after the jsr.  Note\n-    // that it is ok to have a `jsr' at the end of the bytecode,\n-    // provided that the called subroutine never returns.  So, we have\n-    // a special case here and another one when we handle the ret.\n-    if (PC < current_method->code_length)\n-      {\n-\tcurrent_state->stacktop = state::NO_STACK;\n-\tpush_jump_merge (PC, current_state, false, true);\n-      }\n+    type ret_addr (return_address_type);\n+    ret_addr.set_return_address (PC);\n+    push_type (ret_addr);\n+    merge_into (npc, current_state);\n     invalidate_pc ();\n   }\n \n@@ -1794,7 +1565,6 @@ class _Jv_BytecodeVerifier\n       case unsuitable_type:\n       case return_address_type:\n       case continuation_type:\n-      case unused_by_subroutine_type:\n       case reference_type:\n       case null_type:\n       case uninitialized_reference_type:\n@@ -1810,16 +1580,9 @@ class _Jv_BytecodeVerifier\n   void branch_prepass ()\n   {\n     flags = (char *) _Jv_Malloc (current_method->code_length);\n-    jsr_ptrs = (subr_info **) _Jv_Malloc (sizeof (subr_info *)\n-\t\t\t\t\t  * current_method->code_length);\n \n     for (int i = 0; i < current_method->code_length; ++i)\n-      {\n-\tflags[i] = 0;\n-\tjsr_ptrs[i] = NULL;\n-      }\n-\n-    bool last_was_jsr = false;\n+      flags[i] = 0;\n \n     PC = 0;\n     while (PC < current_method->code_length)\n@@ -1829,13 +1592,6 @@ class _Jv_BytecodeVerifier\n \tstart_PC = PC;\n \tflags[PC] |= FLAG_INSN_START;\n \n-\t// If the previous instruction was a jsr, then the next\n-\t// instruction is a branch target -- the branch being the\n-\t// corresponding `ret'.\n-\tif (last_was_jsr)\n-\t  note_branch_target (PC);\n-\tlast_was_jsr = false;\n-\n \tjava_opcode opcode = (java_opcode) bytecode[PC++];\n \tswitch (opcode)\n \t  {\n@@ -2029,8 +1785,6 @@ class _Jv_BytecodeVerifier\n \t    break;\n \n \t  case op_jsr:\n-\t    last_was_jsr = true;\n-\t    // Fall through.\n \t  case op_ifeq:\n \t  case op_ifne:\n \t  case op_iflt:\n@@ -2048,7 +1802,7 @@ class _Jv_BytecodeVerifier\n \t  case op_ifnull:\n \t  case op_ifnonnull:\n \t  case op_goto:\n-\t    note_branch_target (compute_jump (get_short ()), last_was_jsr);\n+\t    note_branch_target (compute_jump (get_short ()));\n \t    break;\n \n \t  case op_tableswitch:\n@@ -2095,10 +1849,8 @@ class _Jv_BytecodeVerifier\n \t    break;\n \n \t  case op_jsr_w:\n-\t    last_was_jsr = true;\n-\t    // Fall through.\n \t  case op_goto_w:\n-\t    note_branch_target (compute_jump (get_int ()), last_was_jsr);\n+\t    note_branch_target (compute_jump (get_int ()));\n \t    break;\n \n \t  // These are unused here, but we call them out explicitly\n@@ -2375,77 +2127,61 @@ class _Jv_BytecodeVerifier\n     // True if we are verifying an instance initializer.\n     bool this_is_init = initialize_stack ();\n \n-    states = (state **) _Jv_Malloc (sizeof (state *)\n-\t\t\t\t    * current_method->code_length);\n+    states = (linked<state> **) _Jv_Malloc (sizeof (linked<state> *)\n+\t\t\t\t\t    * current_method->code_length);\n     for (int i = 0; i < current_method->code_length; ++i)\n       states[i] = NULL;\n \n-    next_verify_pc = state::NO_NEXT;\n+    next_verify_state = NULL;\n \n     while (true)\n       {\n \t// If the PC was invalidated, get a new one from the work list.\n \tif (PC == state::NO_NEXT)\n \t  {\n-\t    PC = pop_jump ();\n-\t    if (PC == state::INVALID)\n-\t      verify_fail (\"can't happen: saw state::INVALID\");\n-\t    if (PC == state::NO_NEXT)\n+\t    state *new_state = pop_jump ();\n+\t    // If it is null, we're done.\n+\t    if (new_state == NULL)\n \t      break;\n+\n+\t    PC = new_state->get_pc ();\n \t    debug_print (\"== State pop from pending list\\n\");\n \t    // Set up the current state.\n-\t    current_state->copy (states[PC], current_method->max_stack,\n+\t    current_state->copy (new_state, current_method->max_stack,\n \t\t\t\t current_method->max_locals);\n \t  }\n \telse\n \t  {\n-\t    // Control can't fall off the end of the bytecode.  We\n-\t    // only need to check this in the fall-through case,\n-\t    // because branch bounds are checked when they are\n-\t    // pushed.\n-\t    if (PC >= current_method->code_length)\n-\t      verify_fail (\"fell off end\");\n-\n \t    // We only have to do this checking in the situation where\n \t    // control flow falls through from the previous\n \t    // instruction.  Otherwise merging is done at the time we\n \t    // push the branch.\n \t    if (states[PC] != NULL)\n \t      {\n \t\t// We've already visited this instruction.  So merge\n-\t\t// the states together.  If this yields no change then\n-\t\t// we don't have to re-verify.  However, if the new\n-\t\t// state is an the result of an unmerged `ret', we\n-\t\t// must continue through it.\n-\t\tdebug_print (\"== Fall through merge\\n\");\n-\t\tstates[PC]->print (\"Old\", PC, current_method->max_stack,\n-\t\t\t\t   current_method->max_locals);\n-\t\tcurrent_state->print (\"Cur\", PC, current_method->max_stack,\n-\t\t\t\t      current_method->max_locals);\n-\t\tif (! current_state->merge (states[PC], false,\n-\t\t\t\t\t    current_method->max_locals, this)\n-\t\t    && ! states[PC]->is_unmerged_ret_state (current_method->max_locals))\n-\t\t  {\n-\t\t    debug_print (\"== Fall through optimization\\n\");\n-\t\t    invalidate_pc ();\n-\t\t    continue;\n-\t\t  }\n-\t\t// Save a copy of it for later.\n-\t\tstates[PC]->copy (current_state, current_method->max_stack,\n-\t\t\t\t  current_method->max_locals);\n-\t\tcurrent_state->print (\"New\", PC, current_method->max_stack,\n-\t\t\t\t      current_method->max_locals);\n+\t\t// the states together.  It is simplest, but not most\n+\t\t// efficient, to just always invalidate the PC here.\n+\t\tmerge_into (PC, current_state);\n+\t\tinvalidate_pc ();\n+\t\tcontinue;\n \t      }\n \t  }\n \n+\t// Control can't fall off the end of the bytecode.  We need to\n+\t// check this in both cases, not just the fall-through case,\n+\t// because we don't check to see whether a `jsr' appears at\n+\t// the end of the bytecode until we process a `ret'.\n+\tif (PC >= current_method->code_length)\n+\t  verify_fail (\"fell off end\");\n+\n \t// We only have to keep saved state at branch targets.  If\n \t// we're at a branch target and the state here hasn't been set\n-\t// yet, we set it now.\n+\t// yet, we set it now.  You might notice that `ret' targets\n+\t// won't necessarily have FLAG_BRANCH_TARGET set.  This\n+\t// doesn't matter, since those states will be filled in by\n+\t// merge_into.\n \tif (states[PC] == NULL && (flags[PC] & FLAG_BRANCH_TARGET))\n-\t  {\n-\t    states[PC] = new state (current_state, current_method->max_stack,\n-\t\t\t\t    current_method->max_locals);\n-\t  }\n+\t  add_new_state (PC, current_state);\n \n \t// Set this before handling exceptions so that debug output is\n \t// sane.\n@@ -3328,58 +3064,45 @@ class _Jv_BytecodeVerifier\n \n     states = NULL;\n     flags = NULL;\n-    jsr_ptrs = NULL;\n     utf8_list = NULL;\n     isect_list = NULL;\n-    entry_points = NULL;\n   }\n \n   ~_Jv_BytecodeVerifier ()\n   {\n-    if (states)\n-      _Jv_Free (states);\n     if (flags)\n       _Jv_Free (flags);\n \n-    if (jsr_ptrs)\n-      {\n-\tfor (int i = 0; i < current_method->code_length; ++i)\n-\t  {\n-\t    if (jsr_ptrs[i] != NULL)\n-\t      {\n-\t\tsubr_info *info = jsr_ptrs[i];\n-\t\twhile (info != NULL)\n-\t\t  {\n-\t\t    subr_info *next = info->next;\n-\t\t    _Jv_Free (info);\n-\t\t    info = next;\n-\t\t  }\n-\t      }\n-\t  }\n-\t_Jv_Free (jsr_ptrs);\n-      }\n-\n     while (utf8_list != NULL)\n       {\n-\tlinked_utf8 *n = utf8_list->next;\n+\tlinked<_Jv_Utf8Const> *n = utf8_list->next;\n \t_Jv_Free (utf8_list->val);\n \t_Jv_Free (utf8_list);\n \tutf8_list = n;\n       }\n \n-    while (entry_points != NULL)\n-      {\n-\tsubr_entry_info *next = entry_points->next;\n-\t_Jv_Free (entry_points);\n-\tentry_points = next;\n-      }\n-\n     while (isect_list != NULL)\n       {\n \tref_intersection *next = isect_list->alloc_next;\n \tdelete isect_list;\n \tisect_list = next;\n       }\n+\n+    if (states)\n+      {\n+\tfor (int i = 0; i < current_method->code_length; ++i)\n+\t  {\n+\t    linked<state> *iter = states[i];\n+\t    while (iter != NULL)\n+\t      {\n+\t\tlinked<state> *next = iter->next;\n+\t\tdelete iter->val;\n+\t\t_Jv_Free (iter);\n+\t\titer = next;\n+\t      }\n+\t  }\n+\t_Jv_Free (states);\n+      }\n   }\n };\n \n@@ -3389,4 +3112,5 @@ _Jv_VerifyMethod (_Jv_InterpMethod *meth)\n   _Jv_BytecodeVerifier v (meth);\n   v.verify_instructions ();\n }\n+\n #endif\t/* INTERPRETER */"}]}