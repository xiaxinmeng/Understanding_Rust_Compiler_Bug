{"sha": "9f88b919e0b01c429ac064c44338ef55a8484fee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY4OGI5MTllMGIwMWM0MjlhYzA2NGM0NDMzOGVmNTVhODQ4NGZlZQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-12-28T21:30:45Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-28T21:30:45Z"}, "message": "2003-12-28  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/net/protocol/http/Connection.java\n\t(inputStream): Made it a DataInputStream.\n\t(requestProperties): Removed.\n\t(hdrHash): Removed.\n\t(hdrVec): Removed.\n\t(headers): New field to store headers.\n\t(connect): Initialize inputStream.\n\t(receiveReply): Merged from classpath. The new algorithm is line based\n\tinstead of character based.\n\t(getHeaderField): Use headers.\n\t(getHeaderFields): Use headers.\n\t(getKey): Removed.\n\t(getField): Removed.\n\t* gnu/java/net/HeaderFieldHelper.java: New file.\n\t* Makefile.am (ordinary_java_source_files):\n\tAdded gnu/java/net/HeaderFieldHelper.java.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r75183", "tree": {"sha": "189d9e556c36e719574f3e5a75467e75c0cf830f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/189d9e556c36e719574f3e5a75467e75c0cf830f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f88b919e0b01c429ac064c44338ef55a8484fee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f88b919e0b01c429ac064c44338ef55a8484fee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f88b919e0b01c429ac064c44338ef55a8484fee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f88b919e0b01c429ac064c44338ef55a8484fee/comments", "author": null, "committer": null, "parents": [{"sha": "315d849ab2c0a8dde1b517aee18bc67176be5b35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315d849ab2c0a8dde1b517aee18bc67176be5b35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315d849ab2c0a8dde1b517aee18bc67176be5b35"}], "stats": {"total": 346, "additions": 257, "deletions": 89}, "files": [{"sha": "a0d172557ae10dcd960674933a066c6414ff815e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9f88b919e0b01c429ac064c44338ef55a8484fee", "patch": "@@ -1,3 +1,23 @@\n+2003-12-28  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/net/protocol/http/Connection.java\n+\t(inputStream): Made it a DataInputStream.\n+\t(requestProperties): Removed.\n+\t(hdrHash): Removed.\n+\t(hdrVec): Removed.\n+\t(headers): New field to store headers.\n+\t(connect): Initialize inputStream.\n+\t(receiveReply): Merged from classpath. The new algorithm is line based\n+\tinstead of character based.\n+\t(getHeaderField): Use headers.\n+\t(getHeaderFields): Use headers.\n+\t(getKey): Removed.\n+\t(getField): Removed.\n+\t* gnu/java/net/HeaderFieldHelper.java: New file.\n+\t* Makefile.am (ordinary_java_source_files):\n+\tAdded gnu/java/net/HeaderFieldHelper.java.\n+\t* Makefile.in: Regenerated.\n+\n 2003-12-28  Guilhem Lavaux <guilhem@kaffe.org>\n \n \t* java/io/LineNumberReader.java"}, {"sha": "70c9cb52a2ecf8d0440997d9a2fe07ddf4ec8631", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=9f88b919e0b01c429ac064c44338ef55a8484fee", "patch": "@@ -2238,6 +2238,7 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/net/HeaderFieldHelper.java \\\n gnu/java/net/PlainDatagramSocketImpl.java \\\n gnu/java/net/PlainSocketImpl.java \\\n gnu/java/net/URLParseError.java \\"}, {"sha": "9702b28a3ec9eeb5bcfc287b89157f2d249045bb", "filename": "libjava/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=9f88b919e0b01c429ac064c44338ef55a8484fee", "patch": "@@ -1945,6 +1945,7 @@ gnu/java/locale/LocaleInformation_zh_HK.java \\\n gnu/java/locale/LocaleInformation_zh_SG.java \\\n gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n+gnu/java/net/HeaderFieldHelper.java \\\n gnu/java/net/PlainDatagramSocketImpl.java \\\n gnu/java/net/PlainSocketImpl.java \\\n gnu/java/net/URLParseError.java \\\n@@ -3085,7 +3086,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_HK.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_SG.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_TW.P \\\n-.deps/gnu/java/math/MPN.P .deps/gnu/java/net/PlainDatagramSocketImpl.P \\\n+.deps/gnu/java/math/MPN.P .deps/gnu/java/net/HeaderFieldHelper.P \\\n+.deps/gnu/java/net/PlainDatagramSocketImpl.P \\\n .deps/gnu/java/net/PlainSocketImpl.P .deps/gnu/java/net/URLParseError.P \\\n .deps/gnu/java/net/natPlainDatagramSocketImpl.P \\\n .deps/gnu/java/net/natPlainSocketImpl.P \\"}, {"sha": "2bcfd17fd7d803b042100eefb59f7501896cbdda", "filename": "libjava/gnu/java/net/HeaderFieldHelper.java", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2Fgnu%2Fjava%2Fnet%2FHeaderFieldHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2Fgnu%2Fjava%2Fnet%2FHeaderFieldHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FHeaderFieldHelper.java?ref=9f88b919e0b01c429ac064c44338ef55a8484fee", "patch": "@@ -0,0 +1,138 @@\n+/* HeaderFieldHelper.java -- Helps manage headers fields \n+   Copyright (C) 1998, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.net;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Vector;\n+\n+/**\n+ * This class manages header field keys and values.\n+ *\n+ * @author Aaron M. Renn <arenn@urbanophile.com>\n+ */\n+public class HeaderFieldHelper\n+{\n+  private Vector headerFieldKeys;\n+  private Vector headerFieldValues;\n+\n+  public HeaderFieldHelper()\n+  {\n+    this (10);\n+  }\n+\n+  public HeaderFieldHelper (int size)\n+  {\n+    headerFieldKeys = new Vector (size);\n+    headerFieldValues = new Vector (size);\n+  }\n+\n+  public void addHeaderField (String key, String value)\n+  {\n+    headerFieldKeys.addElement (key);\n+    headerFieldValues.addElement (value);\n+  }\n+\n+  public String getHeaderFieldKeyByIndex (int index)\n+  {\n+    String key = null;\n+\n+    try\n+      {\n+        key = (String) headerFieldKeys.elementAt (index);\n+      }\n+    catch (ArrayIndexOutOfBoundsException e)\n+      {\n+      }\n+\n+    return key;\n+  }\n+\n+  public String getHeaderFieldValueByIndex(int index)\n+  {\n+    String value = null;\n+\n+    try\n+      {\n+        value = (String) headerFieldValues.elementAt (index);\n+      }\n+    catch (ArrayIndexOutOfBoundsException e)\n+      {\n+      }\n+\n+    return value;\n+  }\n+\n+  public String getHeaderFieldValueByKey(String key)\n+  {\n+    String value = null;\n+\n+    try\n+      {\n+\tvalue = (String) headerFieldValues.elementAt\n+\t\t\t   (headerFieldKeys.indexOf(key));\n+      }\n+    catch (ArrayIndexOutOfBoundsException e)\n+      {\n+      }\n+    \n+    return value;\n+  }\n+\n+  public Map getHeaderFields()\n+  {\n+    HashMap headers = new HashMap();\n+    int max = headerFieldKeys.size();\n+\n+    for (int index = 0; index < max; index++)\n+      {\n+\theaders.put(headerFieldKeys.elementAt(index),\n+\t\t    headerFieldValues.elementAt(index));\n+      }\n+\n+    return headers;\n+  }\n+\n+  public int getNumberOfEntries()\n+  {\n+    return headerFieldKeys.size();\n+  }\n+\n+} // class HeaderFieldHelper\n+"}, {"sha": "5cced5cf0a2925b3fd3133838719b949c0593b92", "filename": "libjava/gnu/java/net/protocol/http/Connection.java", "status": "modified", "additions": 95, "deletions": 88, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f88b919e0b01c429ac064c44338ef55a8484fee/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java?ref=9f88b919e0b01c429ac064c44338ef55a8484fee", "patch": "@@ -39,6 +39,7 @@\n package gnu.java.net.protocol.http;\n \n import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n import java.io.InputStream;\n import java.io.IOException;\n import java.io.OutputStream;\n@@ -50,8 +51,7 @@\n import java.net.URLConnection;\n import java.util.Iterator;\n import java.util.Map;\n-import java.util.Vector;\n-import java.util.Hashtable;\n+import gnu.java.net.HeaderFieldHelper;\n \n /**\n  * This subclass of java.net.URLConnection models a URLConnection via\n@@ -102,14 +102,12 @@ public final class Connection extends HttpURLConnection\n   /**\n    * The InputStream for this connection.\n    */\n-  private BufferedInputStream inputStream;\n+  private DataInputStream inputStream;\n \n   /**\n    * This is the object that holds the header field information\n    */\n-  private Hashtable requestProperties = new Hashtable();\n-  private Hashtable hdrHash = new Hashtable();\n-  private Vector hdrVec = new Vector();\n+  private HeaderFieldHelper headers = new HeaderFieldHelper();\n \n   /**\n    * Calls superclass constructor to initialize\n@@ -147,13 +145,8 @@ public void connect() throws IOException\n \tsocket = new Socket(url.getHost(), port);\n       }\n \n-    // Originally tried using a BufferedReader here to take advantage of\n-    // the readLine method and avoid the following, but the buffer read\n-    // past the end of the headers so the first part of the content was lost.\n-    // It is probably more robust than it needs to be, e.g. the byte[]\n-    // is unlikely to overflow and a '\\r' should always be followed by a '\\n',\n-    // but it is better to be safe just in case.\n-    inputStream = new BufferedInputStream(socket.getInputStream());\n+    inputStream =\n+      new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n \n     sendRequest();\n     receiveReply();\n@@ -215,54 +208,94 @@ void sendRequest() throws IOException\n    */\n   private void receiveReply() throws IOException\n   {\n-    int buflen = 100;\n-    byte[] buf = new byte[buflen];\n-    String line = \"\";\n-    boolean gotnl = false;\n-    byte[] ch = new byte[1];\n-    ch[0] = (byte) '\\n';\n+    // Parse the reply\n+    String line = inputStream.readLine();\n+    String saveline = line;\n+    int idx = line.indexOf (\" \");\n \n-    while (true)\n-      {\n-\t// Check for leftover byte from non-'\\n' after a '\\r'.\n-\tif (ch[0] != '\\n')\n-\t  line = line + '\\r' + new String(ch, 0, 1);\n+    if ((idx == -1)\n+        || (line.length() < (idx + 6)))\n+      throw new IOException (\"Server reply was unparseable: \" + saveline);\n \n-\tint i;\n-\t// FIXME: This is rather inefficient.\n-\tfor (i = 0; i < buflen; i++)\n-\t  {\n-\t    buf[i] = (byte) inputStream.read();\n-\t    if (buf[i] == -1)\n-\t      throw new IOException(\"Malformed HTTP header\");\n-\t    if (buf[i] == '\\r')\n-\t      {\n-\t        inputStream.read(ch, 0, 1);\n-\t\tif (ch[0] == '\\n')\n-\t\t  gotnl = true;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tline = line + new String(buf, 0, i);\n+    headers.addHeaderField (null, line);\n \n-\t// A '\\r' '\\n' combo indicates the end of the header entry.\n-\t// If it wasn't found, cycle back through the loop and append\n-\t// to 'line' until one is found.\n-\tif (gotnl)\n-\t  {\n-\t    // A zero length entry signals the end of the headers.\n-\t    if (line.length() == 0)\n-\t      break;\n-\n-\t    // Store the header and reinitialize for next cycle.\n-\t    hdrVec.addElement(line);\n-\t    String key = getKey(line);\n-\t    if (key != null)\n-\t      hdrHash.put(key.toLowerCase(), getField(line));\n-\t    line = \"\";\n-\t    ch[0] = (byte) '\\n';\n-\t    gotnl = false;\n-\t  }\n+    line = line.substring (idx + 1);\n+    String code = line.substring (0, 3);\n+    \n+    try\n+      {\n+        responseCode = Integer.parseInt (code);\n+      }\n+    catch (NumberFormatException e)\n+      {\n+        throw new IOException (\"Server reply was unparseable: \" + saveline);\n+      }\n+    \n+    responseMessage = line.substring (4);\n+\n+    // Now read the header lines\n+    String key = null, value = null;\n+    \n+    while (true)\n+      {\n+        line = inputStream.readLine();\n+        \n+        if (line.equals(\"\"))\n+          break;\n+\n+        // Check for folded lines\n+        if (line.startsWith (\" \")\n+            || line.startsWith(\"\\t\"))\n+          {\n+            // Trim off leading space\n+            do\n+              {\n+                if (line.length() == 1)\n+                  throw new IOException(\"Server header lines were unparseable: \"\n+                                        + line);\n+\n+                line = line.substring (1);\n+              }\n+            while (line.startsWith(\" \")\n+                   || line.startsWith(\"\\t\"));\n+\n+            value = value + \" \" + line;\n+          }\n+        else \n+          {\n+            if (key != null)\n+              {\n+                headers.addHeaderField (key.toLowerCase(), value);\n+                key = null;\n+                value = null;\n+              }\n+\n+            // Parse out key and value\n+            idx = line.indexOf (\":\");\n+            if ((idx == -1)\n+                || (line.length() < (idx + 2)))\n+              throw new IOException (\"Server header lines were unparseable: \"\n+                                     + line);\n+\n+            key = line.substring (0, idx);\n+            value = line.substring (idx + 1);\n+\n+            // Trim off leading space\n+            while (value.startsWith (\" \")\n+                   || value.startsWith (\"\\t\"))\n+              {\n+                if (value.length() == 1)\n+                  throw new IOException (\"Server header lines were unparseable: \"\n+                                         + line);\n+\n+                value = value.substring (1);\n+              }\n+          }\n+      }\n+    \n+    if (key != null)\n+      {\n+        headers.addHeaderField (key.toLowerCase(), value.toLowerCase());\n       }\n   }\n \n@@ -347,7 +380,7 @@ public String getHeaderField(String name)\n \t  return null;\n \t}\n \n-    return (String) hdrHash.get(name.toLowerCase());\n+    return (String) headers.getHeaderFieldValueByKey(name.toLowerCase());\n   }\n \n   public Map getHeaderFields()\n@@ -362,7 +395,7 @@ public Map getHeaderFields()\n \t  return null;\n \t}\n \n-    return hdrHash;\n+    return headers.getHeaderFields();\n   }\n \n   /**\n@@ -386,9 +419,7 @@ public String getHeaderField(int n)\n \t  return null;\n \t}\n \n-    if (n < hdrVec.size())\n-      return getField ((String) hdrVec.elementAt(n));\n-    return null;\n+    return headers.getHeaderFieldValueByIndex (n);\n   }\n \n   /**\n@@ -412,30 +443,6 @@ public String getHeaderFieldKey(int n)\n \t  return null;\n \t}\n \n-    if (n < hdrVec.size())\n-      return getKey ((String) hdrVec.elementAt(n));\n-    return null;\n-  }\n-\n-  private String getKey(String str)\n-  {\n-    if (str == null)\n-      return null;\n-    int index = str.indexOf(':');\n-    if (index >= 0)\n-      return str.substring(0, index);\n-    else\n-      return null;\n-  }\n-\n-  private String getField(String str)\n-  {\n-    if (str == null)\n-      return null;\n-    int index = str.indexOf(':');\n-    if (index >= 0)\n-      return str.substring(index + 1).trim();\n-    else\n-      return str;\n+    return headers.getHeaderFieldKeyByIndex (n);\n   }\n }"}]}