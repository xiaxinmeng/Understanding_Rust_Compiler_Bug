{"sha": "28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg2MzNiYmQxMGQ2ZDcyOTcwOGM3YmY0ZGUyYzFhZWFlM2I0ZTc1ZQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2016-04-28T11:53:46Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2016-04-28T11:53:46Z"}, "message": "[ARC] Add TLS support.\n\ngcc/\n2016-04-28  Claudiu Zissulescu  <claziss@synopsys.com>\n\t    Joern Rennecke  <joern.rennecke@embecosm.com>\n\n\t* config/arc/arc-protos.h (arc_legitimize_pic_address): Remove\n\tdeclaration.\n\t(emit_pic_move): Remove.\n\t(arc_eh_uses, insn_is_tls_gd_dispatch): Declare.\n\t* config/arc/arc.c (emit_pic_move): Removed.\n\t(TARGET_HAVE_TLS): Define.\n\t(arc_conditional_register_usage): Test for arc_tp_regno.\n\t(arc_print_operand, arc_print_operand_address): Handle TLS\n\tunspecs.\n\t(arc_needs_pcl_p): New function.\n\t(arc_legitimate_pc_offset_p): Use arc_needs_pcl_p.\n\t(arc_legitimate_pic_addr_p): Handle TLS unspecs.\n\t(arc_raw_symbolic_reference_mentioned_p): Likewise.\n\t(arc_get_tp, arc_emit_call_tls_get_addr): New function.\n\t(arc_legitimize_tls_address): Likewise.\n\t(DTPOFF_ZERO_SYM): Define.\n\t(arc_legitimize_pic_address): Make it static, handle TLS cases.\n\t(arc_output_pic_addr_const): Print TLS unspecs.\n\t(prepare_pic_move): New function, replaces emit_pic_move.\n\t(arc_legitimate_constant_p): Handle TLS unspecs.\n\t(arc_legitimate_address_p): Likewise.\n\t(arc_rewrite_small_data_p): Use assert for TLS constants.\n\t(prepare_move_operands): Use prepare_pic_move.\n\t(arc_legitimize_address): Legitimize tls addresses.\n\t(arc_epilogue_uses): Check for arc_tp_regno.\n\t(arc_eh_uses, insn_is_tls_gd_dispatch): New function.\n\t* config/arc/arc.h [DEFAULT_LIBC != LIBC_UCLIBC] (EXTRA_SPECS):\n\tDefine.\n\t[DEFAULT_LIBC != LIBC_UCLIBC] (ARC_TLS_EXTRA_START_SPEC):\n\tLikewise.\n\t[DEFAULT_LIBC != LIBC_UCLIBC] (STARTFILE_SPEC): Add\n\t%(arc_tls_extra_start_spec).\n\t(TARGET_CPU_CPP_BUILTINS): Define __ARC_TLS_REGNO__.\n\t(REGNO_OK_FOR_BASE_P): Check for arc_tp_regno.\n\t(EH_USES): Define.\n\t(INSN_REFERENCES_ARE_DELAYED): Use insn_is_tls_gd_dispatch.\n\t* config/arc/arc.md (UNSPEC_TLS_GD, UNSPEC_TLS_LD, UNSPEC_TLS_IE)\n\t(UNSPEC_TLS_OFF): Add.\n\t(R10_REG): Define.\n\t(tls_load_tp_soft, tls_gd_load, tls_gd_get_addr, tls_gd_dispatch)\n\t(get_thread_pointersi): New patterns.\n\t* config/arc/arc.opt (mtp-regno): New option.\n\t* config/arc/predicates.md (move_src_operand): Handle TLS symbols.\n\t(move_dest_operand): Likewise.\n\t* configure: Regenerate.\n\t* configure.ac: Add arc*-*-* case to test for tls.\n\t* doc/invoke.texi (ARC options): Document mtp-regno.\n\nCo-Authored-By: Joern Rennecke <joern.rennecke@embecosm.com>\n\nFrom-SVN: r235559", "tree": {"sha": "ab5e739e6e70fe88058986a5610bcd6e72648938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab5e739e6e70fe88058986a5610bcd6e72648938"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b48923bacb16526d4c719b2adfdfc1f2cf3551c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b48923bacb16526d4c719b2adfdfc1f2cf3551c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b48923bacb16526d4c719b2adfdfc1f2cf3551c"}], "stats": {"total": 693, "additions": 545, "deletions": 148}, "files": [{"sha": "367eb8bff75a46f9646c24428e710f7dbb84fbd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -1,3 +1,54 @@\n+2016-04-28  Claudiu Zissulescu  <claziss@synopsys.com>\n+\t    Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* config/arc/arc-protos.h (arc_legitimize_pic_address): Remove\n+\tdeclaration.\n+\t(emit_pic_move): Remove.\n+\t(arc_eh_uses, insn_is_tls_gd_dispatch): Declare.\n+\t* config/arc/arc.c (emit_pic_move): Removed.\n+\t(TARGET_HAVE_TLS): Define.\n+\t(arc_conditional_register_usage): Test for arc_tp_regno.\n+\t(arc_print_operand, arc_print_operand_address): Handle TLS\n+\tunspecs.\n+\t(arc_needs_pcl_p): New function.\n+\t(arc_legitimate_pc_offset_p): Use arc_needs_pcl_p.\n+\t(arc_legitimate_pic_addr_p): Handle TLS unspecs.\n+\t(arc_raw_symbolic_reference_mentioned_p): Likewise.\n+\t(arc_get_tp, arc_emit_call_tls_get_addr): New function.\n+\t(arc_legitimize_tls_address): Likewise.\n+\t(DTPOFF_ZERO_SYM): Define.\n+\t(arc_legitimize_pic_address): Make it static, handle TLS cases.\n+\t(arc_output_pic_addr_const): Print TLS unspecs.\n+\t(prepare_pic_move): New function, replaces emit_pic_move.\n+\t(arc_legitimate_constant_p): Handle TLS unspecs.\n+\t(arc_legitimate_address_p): Likewise.\n+\t(arc_rewrite_small_data_p): Use assert for TLS constants.\n+\t(prepare_move_operands): Use prepare_pic_move.\n+\t(arc_legitimize_address): Legitimize tls addresses.\n+\t(arc_epilogue_uses): Check for arc_tp_regno.\n+\t(arc_eh_uses, insn_is_tls_gd_dispatch): New function.\n+\t* config/arc/arc.h [DEFAULT_LIBC != LIBC_UCLIBC] (EXTRA_SPECS):\n+\tDefine.\n+\t[DEFAULT_LIBC != LIBC_UCLIBC] (ARC_TLS_EXTRA_START_SPEC):\n+\tLikewise.\n+\t[DEFAULT_LIBC != LIBC_UCLIBC] (STARTFILE_SPEC): Add\n+\t%(arc_tls_extra_start_spec).\n+\t(TARGET_CPU_CPP_BUILTINS): Define __ARC_TLS_REGNO__.\n+\t(REGNO_OK_FOR_BASE_P): Check for arc_tp_regno.\n+\t(EH_USES): Define.\n+\t(INSN_REFERENCES_ARE_DELAYED): Use insn_is_tls_gd_dispatch.\n+\t* config/arc/arc.md (UNSPEC_TLS_GD, UNSPEC_TLS_LD, UNSPEC_TLS_IE)\n+\t(UNSPEC_TLS_OFF): Add.\n+\t(R10_REG): Define.\n+\t(tls_load_tp_soft, tls_gd_load, tls_gd_get_addr, tls_gd_dispatch)\n+\t(get_thread_pointersi): New patterns.\n+\t* config/arc/arc.opt (mtp-regno): New option.\n+\t* config/arc/predicates.md (move_src_operand): Handle TLS symbols.\n+\t(move_dest_operand): Likewise.\n+\t* configure: Regenerate.\n+\t* configure.ac: Add arc*-*-* case to test for tls.\n+\t* doc/invoke.texi (ARC options): Document mtp-regno.\n+\n 2016-04-28  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.c (arc_vector_mode_supported_p): Add support for"}, {"sha": "3bf28a088bd936bdd43705099bee8fca74ae270c", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -57,7 +57,6 @@ extern unsigned int arc_compute_frame_size (int);\n extern bool arc_ccfsm_branch_deleted_p (void);\n extern void arc_ccfsm_record_branch_deleted (void);\n \n-extern rtx arc_legitimize_pic_address (rtx, rtx);\n void arc_asm_output_aligned_decl_local (FILE *, tree, const char *,\n \t\t\t\t\tunsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT,\n@@ -68,7 +67,6 @@ extern bool check_if_valid_sleep_operand (rtx *, int);\n extern bool arc_legitimate_constant_p (machine_mode, rtx);\n extern bool arc_legitimate_pc_offset_p (rtx);\n extern bool arc_legitimate_pic_addr_p (rtx);\n-extern void emit_pic_move (rtx *, machine_mode);\n extern bool arc_raw_symbolic_reference_mentioned_p (rtx, bool);\n extern bool arc_legitimate_pic_operand_p (rtx);\n extern bool arc_is_longcall_p (rtx);\n@@ -118,8 +116,10 @@ extern bool arc_text_label (rtx_insn *insn);\n extern int arc_decl_pretend_args (tree decl);\n extern bool arc_short_comparison_p (rtx, int);\n extern bool arc_epilogue_uses (int regno);\n+extern bool arc_eh_uses (int regno);\n /* insn-attrtab.c doesn't include reload.h, which declares regno_clobbered_p. */\n extern int regno_clobbered_p (unsigned int, rtx_insn *, machine_mode, int);\n extern int arc_return_slot_offset (void);\n extern bool arc_legitimize_reload_address (rtx *, machine_mode, int, int);\n extern void arc_secondary_reload_conv (rtx, rtx, rtx, bool);\n+extern bool insn_is_tls_gd_dispatch (rtx_insn *);"}, {"sha": "d40d54deb34a263e6a296766c32073912b1a31b1", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 366, "deletions": 139, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -217,7 +217,6 @@ static rtx arc_expand_builtin (tree, rtx, rtx, machine_mode, int);\n static int branch_dest (rtx);\n \n static void  arc_output_pic_addr_const (FILE *,  rtx, int);\n-void emit_pic_move (rtx *, machine_mode);\n bool arc_legitimate_pic_operand_p (rtx);\n static bool arc_function_ok_for_sibcall (tree, tree);\n static rtx arc_function_value (const_tree, const_tree, bool);\n@@ -457,6 +456,11 @@ static void arc_finalize_pic (void);\n #undef TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n \n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS HAVE_AS_TLS\n+#endif\n+\n #undef TARGET_DWARF_REGISTER_SPAN\n #define TARGET_DWARF_REGISTER_SPAN arc_dwarf_register_span\n \n@@ -1322,6 +1326,14 @@ arc_conditional_register_usage (void)\n       strcpy (rname58, TARGET_BIG_ENDIAN ? \"mhi\" : \"mlo\");\n       strcpy (rname59, TARGET_BIG_ENDIAN ? \"mlo\" : \"mhi\");\n     }\n+\n+  /* The nature of arc_tp_regno is actually something more like a global\n+     register, however globalize_reg requires a declaration.\n+     We use EPILOGUE_USES to compensate so that sets from\n+     __builtin_set_frame_pointer are not deleted.  */\n+  if (arc_tp_regno != -1)\n+    fixed_regs[arc_tp_regno] = call_used_regs[arc_tp_regno] = 1;\n+\n   if (TARGET_MULMAC_32BY16_SET)\n     {\n       fix_start = 56;\n@@ -3411,7 +3423,16 @@ arc_print_operand (FILE *file, rtx x, int code)\n \t}\n       /* Fall through.  Let output_addr_const deal with it.  */\n     default :\n-      if (flag_pic)\n+      if (flag_pic\n+\t  || (GET_CODE (x) == CONST\n+\t      && GET_CODE (XEXP (x, 0)) == UNSPEC\n+\t      && (XINT (XEXP (x, 0), 1) == UNSPEC_TLS_OFF\n+\t\t  || XINT (XEXP (x, 0), 1) == UNSPEC_TLS_GD))\n+\t  || (GET_CODE (x) == CONST\n+\t      && GET_CODE (XEXP (x, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == UNSPEC\n+\t      && (XINT (XEXP (XEXP (x, 0), 0), 1) == UNSPEC_TLS_OFF\n+\t\t  || XINT (XEXP (XEXP (x, 0), 0), 1) == UNSPEC_TLS_GD)))\n \tarc_output_pic_addr_const (file, x, code);\n       else\n \t{\n@@ -3476,6 +3497,17 @@ arc_print_operand_address (FILE *file , rtx addr)\n       {\n \trtx c = XEXP (addr, 0);\n \n+\tif ((GET_CODE (c) == UNSPEC\n+\t     && (XINT (c, 1) == UNSPEC_TLS_OFF\n+\t\t || XINT (c, 1) == UNSPEC_TLS_IE))\n+\t    || (GET_CODE (c) == PLUS\n+\t\t&& GET_CODE (XEXP (c, 0)) == UNSPEC\n+\t\t&& (XINT (XEXP (c, 0), 1) == UNSPEC_TLS_OFF)))\n+\t  {\n+\t    arc_output_pic_addr_const (file, c, 0);\n+\t    break;\n+\t  }\n+\tgcc_assert (GET_CODE (c) == PLUS);\n \tgcc_assert (GET_CODE (XEXP (c, 0)) == SYMBOL_REF);\n \tgcc_assert (GET_CODE (XEXP (c, 1)) == CONST_INT);\n \n@@ -4547,6 +4579,44 @@ arc_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     }\n }\n \n+/* Helper used by arc_legitimate_pc_offset_p.  */\n+\n+static bool\n+arc_needs_pcl_p (rtx x)\n+{\n+  register const char *fmt;\n+  register int i, j;\n+\n+  if ((GET_CODE (x) == UNSPEC)\n+      && (XVECLEN (x, 0) == 1)\n+      && (GET_CODE (XVECEXP (x, 0, 0)) == SYMBOL_REF))\n+    switch (XINT (x, 1))\n+      {\n+      case ARC_UNSPEC_GOT:\n+      case UNSPEC_TLS_GD:\n+      case UNSPEC_TLS_IE:\n+\treturn true;\n+      default:\n+\tbreak;\n+      }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (arc_needs_pcl_p (XEXP (x, i)))\n+\t    return true;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (arc_needs_pcl_p (XVECEXP (x, i, j)))\n+\t    return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Return true if ADDR is an address that needs to be expressed as an\n    explicit sum of pcl + offset.  */\n \n@@ -4555,17 +4625,8 @@ arc_legitimate_pc_offset_p (rtx addr)\n {\n   if (GET_CODE (addr) != CONST)\n     return false;\n-  addr = XEXP (addr, 0);\n-  if (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 1)) != CONST_INT)\n-\treturn false;\n-      addr = XEXP (addr, 0);\n-    }\n-  return (GET_CODE (addr) == UNSPEC\n-\t  && XVECLEN (addr, 0) == 1\n-\t  && XINT (addr, 1) == ARC_UNSPEC_GOT\n-\t  && GET_CODE (XVECEXP (addr, 0, 0)) == SYMBOL_REF);\n+\n+  return arc_needs_pcl_p (addr);\n }\n \n /* Return true if ADDR is a valid pic address.\n@@ -4594,9 +4655,11 @@ arc_legitimate_pic_addr_p (rtx addr)\n       || XVECLEN (addr, 0) != 1)\n     return false;\n \n-  /* Must be @GOT or @GOTOFF.  */\n+  /* Must be one of @GOT, @GOTOFF, @tlsgd, tlsie.  */\n   if (XINT (addr, 1) != ARC_UNSPEC_GOT\n-      && XINT (addr, 1) != ARC_UNSPEC_GOTOFF)\n+      && XINT (addr, 1) != ARC_UNSPEC_GOTOFF\n+      && XINT (addr, 1) != UNSPEC_TLS_GD\n+      && XINT (addr, 1) != UNSPEC_TLS_IE)\n     return false;\n \n   if (GET_CODE (XVECEXP (addr, 0, 0)) != SYMBOL_REF\n@@ -4654,6 +4717,10 @@ arc_raw_symbolic_reference_mentioned_p (rtx op, bool skip_local)\n \n   if (GET_CODE (op) == SYMBOL_REF)\n     {\n+      if (SYMBOL_REF_TLS_MODEL (op))\n+\treturn true;\n+      if (!flag_pic)\n+\treturn false;\n       tree decl = SYMBOL_REF_DECL (op);\n       return !skip_local || !decl || !default_binds_local_p (decl);\n     }\n@@ -4680,11 +4747,114 @@ arc_raw_symbolic_reference_mentioned_p (rtx op, bool skip_local)\n   return false;\n }\n \n+/* Get the thread pointer.  */\n+\n+static rtx\n+arc_get_tp (void)\n+{\n+   /* If arc_tp_regno has been set, we can use that hard register\n+      directly as a base register.  */\n+  if (arc_tp_regno != -1)\n+    return gen_rtx_REG (Pmode, arc_tp_regno);\n+\n+  /* Otherwise, call __read_tp.  Copy the result to a pseudo to avoid\n+     conflicts with function arguments / results.  */\n+  rtx reg = gen_reg_rtx (Pmode);\n+  emit_insn (gen_tls_load_tp_soft ());\n+  emit_move_insn (reg, gen_rtx_REG (Pmode, R0_REG));\n+  return reg;\n+}\n+\n+/* Helper to be used by TLS Global dynamic model.  */\n+\n+static rtx\n+arc_emit_call_tls_get_addr (rtx sym, int reloc, rtx eqv)\n+{\n+  rtx r0 = gen_rtx_REG (Pmode, R0_REG);\n+  rtx insns;\n+  rtx call_fusage = NULL_RTX;\n+\n+  start_sequence ();\n+\n+  rtx x = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), reloc);\n+  x = gen_rtx_CONST (Pmode, x);\n+  emit_move_insn (r0, x);\n+  use_reg (&call_fusage, r0);\n+\n+  gcc_assert (reloc == UNSPEC_TLS_GD);\n+  rtx call_insn = emit_call_insn (gen_tls_gd_get_addr (sym));\n+  /* Should we set RTL_CONST_CALL_P?  We read memory, but not in a\n+     way that the application should care.  */\n+  RTL_PURE_CALL_P (call_insn) = 1;\n+  add_function_usage_to (call_insn, call_fusage);\n+\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  rtx dest = gen_reg_rtx (Pmode);\n+  emit_libcall_block (insns, dest, r0, eqv);\n+  return dest;\n+}\n+\n+#define DTPOFF_ZERO_SYM \".tdata\"\n+\n+/* Return a legitimized address for ADDR,\n+   which is a SYMBOL_REF with tls_model MODEL.  */\n+\n+static rtx\n+arc_legitimize_tls_address (rtx addr, enum tls_model model)\n+{\n+  if (!flag_pic && model == TLS_MODEL_LOCAL_DYNAMIC)\n+    model = TLS_MODEL_LOCAL_EXEC;\n+\n+  switch (model)\n+    {\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n+      rtx base;\n+      tree decl;\n+      const char *base_name;\n+      rtvec v;\n+\n+      decl = SYMBOL_REF_DECL (addr);\n+      base_name = DTPOFF_ZERO_SYM;\n+      if (decl && bss_initializer_p (decl))\n+\tbase_name = \".tbss\";\n+\n+      base = gen_rtx_SYMBOL_REF (Pmode, base_name);\n+      if (strcmp (base_name, DTPOFF_ZERO_SYM) == 0)\n+\t{\n+\t  if (!flag_pic)\n+\t    goto local_exec;\n+\t  v = gen_rtvec (1, addr);\n+\t}\n+      else\n+\tv = gen_rtvec (2, addr, base);\n+      addr = gen_rtx_UNSPEC (Pmode, v, UNSPEC_TLS_OFF);\n+      addr = gen_rtx_CONST (Pmode, addr);\n+      base = arc_legitimize_tls_address (base, TLS_MODEL_GLOBAL_DYNAMIC);\n+      return gen_rtx_PLUS (Pmode, force_reg (Pmode, base), addr);\n+    case TLS_MODEL_GLOBAL_DYNAMIC:\n+      return arc_emit_call_tls_get_addr (addr, UNSPEC_TLS_GD, addr);\n+    case TLS_MODEL_INITIAL_EXEC:\n+      addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_TLS_IE);\n+      addr = gen_rtx_CONST (Pmode, addr);\n+      addr = copy_to_mode_reg (Pmode, gen_const_mem (Pmode, addr));\n+      return gen_rtx_PLUS (Pmode, arc_get_tp (), addr);\n+    case TLS_MODEL_LOCAL_EXEC:\n+    local_exec:\n+      addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_TLS_OFF);\n+      addr = gen_rtx_CONST (Pmode, addr);\n+      return gen_rtx_PLUS (Pmode, arc_get_tp (), addr);\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Legitimize a pic address reference in ORIG.\n    The return value is the legitimated address.\n    If OLDX is non-zero, it is the target to assign the address to first.  */\n \n-rtx\n+static rtx\n arc_legitimize_pic_address (rtx orig, rtx oldx)\n {\n   rtx addr = orig;\n@@ -4696,40 +4866,36 @@ arc_legitimize_pic_address (rtx orig, rtx oldx)\n \n   if (GET_CODE (addr) == LABEL_REF)\n     ; /* Do nothing.  */\n-  else if (GET_CODE (addr) == SYMBOL_REF\n-\t   && (CONSTANT_POOL_ADDRESS_P (addr)\n-\t       || SYMBOL_REF_LOCAL_P (addr)))\n+  else if (GET_CODE (addr) == SYMBOL_REF)\n     {\n-      /* This symbol may be referenced via a displacement from the PIC\n-\t base address (@GOTOFF).  */\n-\n-      /* FIXME: if we had a way to emit pc-relative adds that don't\n-\t create a GOT entry, we could do without the use of the gp register.  */\n-      crtl->uses_pic_offset_table = 1;\n-      pat = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), ARC_UNSPEC_GOTOFF);\n-      pat = gen_rtx_CONST (Pmode, pat);\n-      pat = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pat);\n-\n-      if (oldx == NULL)\n-\toldx = gen_reg_rtx (Pmode);\n-\n-      if (oldx != 0)\n+      enum tls_model model = SYMBOL_REF_TLS_MODEL (addr);\n+      if (model != 0)\n+\treturn arc_legitimize_tls_address (addr, model);\n+      else if (!flag_pic)\n+\treturn orig;\n+      else if (CONSTANT_POOL_ADDRESS_P (addr) || SYMBOL_REF_LOCAL_P (addr))\n \t{\n-\t  emit_move_insn (oldx, pat);\n-\t  pat = oldx;\n+\t  /* This symbol may be referenced via a displacement from the\n+\t     PIC base address (@GOTOFF).  */\n+\n+\t  /* FIXME: if we had a way to emit pc-relative adds that\n+\t     don't create a GOT entry, we could do without the use of\n+\t     the gp register.  */\n+\t  crtl->uses_pic_offset_table = 1;\n+\t  pat = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), ARC_UNSPEC_GOTOFF);\n+\t  pat = gen_rtx_CONST (Pmode, pat);\n+\t  pat = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pat);\n+\t}\n+      else\n+\t{\n+\t  /* This symbol must be referenced via a load from the\n+\t     Global Offset Table (@GOTPC).  */\n+\t  pat = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), ARC_UNSPEC_GOT);\n+\t  pat = gen_rtx_CONST (Pmode, pat);\n+\t  pat = gen_const_mem (Pmode, pat);\n \t}\n \n-    }\n-  else if (GET_CODE (addr) == SYMBOL_REF)\n-    {\n-      /* This symbol must be referenced via a load from the\n-\t Global Offset Table (@GOTPC).  */\n-\n-      pat = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), ARC_UNSPEC_GOT);\n-      pat = gen_rtx_CONST (Pmode, pat);\n-      pat = gen_const_mem (Pmode, pat);\n-\n-      if (oldx == 0)\n+      if (oldx == NULL)\n \toldx = gen_reg_rtx (Pmode);\n \n       emit_move_insn (oldx, pat);\n@@ -4752,45 +4918,23 @@ arc_legitimize_pic_address (rtx orig, rtx oldx)\n \t{\n \t  rtx op0 = XEXP (addr, 0), op1 = XEXP (addr, 1);\n \n-\t  /* Check first to see if this is a constant offset from a @GOTOFF\n-\t     symbol reference.  */\n-\t  if ((GET_CODE (op0) == LABEL_REF\n-\t       || (GET_CODE (op0) == SYMBOL_REF\n-\t\t   && (CONSTANT_POOL_ADDRESS_P (op0)\n-\t\t       || SYMBOL_REF_LOCAL_P (op0))))\n-\t      && GET_CODE (op1) == CONST_INT)\n-\t    {\n-\t      /* FIXME: like above, could do without gp reference.  */\n-\t      crtl->uses_pic_offset_table = 1;\n-\t      pat\n-\t\t= gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), ARC_UNSPEC_GOTOFF);\n-\t      pat = gen_rtx_PLUS (Pmode, pat, op1);\n-\t      pat = gen_rtx_CONST (Pmode, pat);\n-\t      pat = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, pat);\n-\n-\t      if (oldx != 0)\n-\t\t{\n-\t\t  emit_move_insn (oldx, pat);\n-\t\t  pat = oldx;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      base = arc_legitimize_pic_address (XEXP (addr, 0), oldx);\n-\t      pat  = arc_legitimize_pic_address (XEXP (addr, 1),\n+\t  base = arc_legitimize_pic_address (op0, oldx);\n+\t  pat  = arc_legitimize_pic_address (op1,\n \t\t\t\t\t     base == oldx ? NULL_RTX : oldx);\n \n-\t      if (GET_CODE (pat) == CONST_INT)\n-\t\tpat = plus_constant (Pmode, base, INTVAL (pat));\n-\t      else\n+\t  if (base == op0 && pat == op1)\n+\t    return orig;\n+\n+\t  if (GET_CODE (pat) == CONST_INT)\n+\t    pat = plus_constant (Pmode, base, INTVAL (pat));\n+\t  else\n+\t    {\n+\t      if (GET_CODE (pat) == PLUS && CONSTANT_P (XEXP (pat, 1)))\n \t\t{\n-\t\t  if (GET_CODE (pat) == PLUS && CONSTANT_P (XEXP (pat, 1)))\n-\t\t    {\n-\t\t      base = gen_rtx_PLUS (Pmode, base, XEXP (pat, 0));\n-\t\t      pat = XEXP (pat, 1);\n-\t\t    }\n-\t\t  pat = gen_rtx_PLUS (Pmode, base, pat);\n+\t\t  base = gen_rtx_PLUS (Pmode, base, XEXP (pat, 0));\n+\t\t  pat = XEXP (pat, 1);\n \t\t}\n+\t      pat = gen_rtx_PLUS (Pmode, base, pat);\n \t    }\n \t}\n     }\n@@ -4906,26 +5050,47 @@ arc_output_pic_addr_const (FILE * file, rtx x, int code)\n \n \n     case UNSPEC:\n-      gcc_assert (XVECLEN (x, 0) == 1);\n-      if (XINT (x, 1) == ARC_UNSPEC_GOT)\n-\tfputs (\"pcl,\", file);\n-      arc_output_pic_addr_const (file, XVECEXP (x, 0, 0), code);\n+      const char *suffix;\n+      bool pcrel; pcrel = false;\n+      rtx base; base = NULL;\n+      gcc_assert (XVECLEN (x, 0) >= 1);\n       switch (XINT (x, 1))\n \t{\n \tcase ARC_UNSPEC_GOT:\n-\t  fputs (\"@gotpc\", file);\n+\t  suffix = \"@gotpc\", pcrel = true;\n \t  break;\n \tcase ARC_UNSPEC_GOTOFF:\n-\t  fputs (\"@gotoff\", file);\n+\t  suffix = \"@gotoff\";\n \t  break;\n \tcase ARC_UNSPEC_PLT:\n-\t  fputs (\"@plt\", file);\n+\t  suffix = \"@plt\";\n+\t  break;\n+\tcase UNSPEC_TLS_GD:\n+\t  suffix = \"@tlsgd\", pcrel = true;\n+\t  break;\n+\tcase UNSPEC_TLS_IE:\n+\t  suffix = \"@tlsie\", pcrel = true;\n+\t  break;\n+\tcase UNSPEC_TLS_OFF:\n+\t  if (XVECLEN (x, 0) == 2)\n+\t    base = XVECEXP (x, 0, 1);\n+\t  if (SYMBOL_REF_TLS_MODEL (XVECEXP (x, 0, 0)) == TLS_MODEL_LOCAL_EXEC\n+\t      || (!flag_pic && !base))\n+\t    suffix = \"@tpoff\";\n+\t  else\n+\t    suffix = \"@dtpoff\";\n \t  break;\n \tdefault:\n \t  output_operand_lossage (\"invalid UNSPEC as operand: %d\", XINT (x,1));\n \t  break;\n \t}\n-       break;\n+      if (pcrel)\n+\tfputs (\"pcl,\", file);\n+      arc_output_pic_addr_const (file, XVECEXP (x, 0, 0), code);\n+      fputs (suffix, file);\n+      if (base)\n+\tarc_output_pic_addr_const (file, base, code);\n+      break;\n \n     default:\n       output_operand_lossage (\"invalid expression as operand\");\n@@ -4939,15 +5104,18 @@ arc_output_pic_addr_const (FILE * file, rtx x, int code)\n \n /* Emit insns to move operands[1] into operands[0].  */\n \n-void\n-emit_pic_move (rtx *operands, machine_mode)\n+static void\n+prepare_pic_move (rtx *operands, machine_mode)\n {\n-  rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n-\n-  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n+  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1])\n+      && flag_pic)\n     operands[1] = force_reg (Pmode, operands[1]);\n   else\n-    operands[1] = arc_legitimize_pic_address (operands[1], temp);\n+    {\n+      rtx temp = (reload_in_progress ? operands[0]\n+\t\t  : flag_pic? gen_reg_rtx (Pmode) : NULL_RTX);\n+      operands[1] = arc_legitimize_pic_address (operands[1], temp);\n+    }\n }\n \n \n@@ -5149,9 +5317,12 @@ arc_legitimate_pic_operand_p (rtx x)\n    satisfies CONSTANT_P.  */\n \n bool\n-arc_legitimate_constant_p (machine_mode, rtx x)\n+arc_legitimate_constant_p (machine_mode mode, rtx x)\n {\n-  if (!flag_pic)\n+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x))\n+    return false;\n+\n+  if (!flag_pic && mode != Pmode)\n     return true;\n \n   switch (GET_CODE (x))\n@@ -5161,7 +5332,9 @@ arc_legitimate_constant_p (machine_mode, rtx x)\n \n       if (GET_CODE (x) == PLUS)\n \t{\n-\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t  if (flag_pic\n+\t      ? GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t      : !arc_legitimate_constant_p (mode, XEXP (x, 1)))\n \t    return false;\n \t  x = XEXP (x, 0);\n \t}\n@@ -5173,6 +5346,9 @@ arc_legitimate_constant_p (machine_mode, rtx x)\n \t  case ARC_UNSPEC_PLT:\n \t  case ARC_UNSPEC_GOTOFF:\n \t  case ARC_UNSPEC_GOT:\n+\t  case UNSPEC_TLS_GD:\n+\t  case UNSPEC_TLS_IE:\n+\t  case UNSPEC_TLS_OFF:\n \t  case UNSPEC_PROF:\n \t    return true;\n \n@@ -5187,9 +5363,14 @@ arc_legitimate_constant_p (machine_mode, rtx x)\n       /* Return true.  */\n       break;\n \n-    case LABEL_REF:\n     case SYMBOL_REF:\n-      return false;\n+      if (SYMBOL_REF_TLS_MODEL (x))\n+\treturn false;\n+      /* Fall through.  */\n+    case LABEL_REF:\n+      if (flag_pic)\n+\treturn false;\n+      /* Fall through.  */\n \n     default:\n       break;\n@@ -5212,12 +5393,29 @@ arc_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n      return true;\n   if (GET_CODE (x) == CONST_INT && LARGE_INT (INTVAL (x)))\n      return true;\n-  if ((GET_MODE_SIZE (mode) != 16)\n-      && (GET_CODE (x) == SYMBOL_REF\n-\t  || GET_CODE (x) == LABEL_REF\n-\t  || GET_CODE (x) == CONST))\n+\n+  /* When we compile for size avoid const (@sym + offset)\n+     addresses.  */\n+  if (!flag_pic && optimize_size && !reload_completed\n+      && (GET_CODE (x) == CONST)\n+      && (GET_CODE (XEXP (x, 0)) == PLUS)\n+      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF)\n+      && SYMBOL_REF_TLS_MODEL (XEXP (XEXP (x, 0), 0)) == 0\n+      && !SYMBOL_REF_FUNCTION_P (XEXP (XEXP (x, 0), 0)))\n     {\n-      if (!flag_pic || arc_legitimate_pic_addr_p (x))\n+      rtx addend = XEXP (XEXP (x, 0), 1);\n+      gcc_assert (CONST_INT_P (addend));\n+      HOST_WIDE_INT offset = INTVAL (addend);\n+\n+      /* Allow addresses having a large offset to pass.  Anyhow they\n+\t will end in a limm.  */\n+      return !(offset > -1024 && offset < 1020);\n+    }\n+\n+  if ((GET_MODE_SIZE (mode) != 16) && CONSTANT_P (x))\n+    {\n+      if (flag_pic ? arc_legitimate_pic_addr_p (x)\n+\t  : arc_legitimate_constant_p (Pmode, x))\n \treturn true;\n     }\n   if ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == PRE_INC\n@@ -6860,8 +7058,12 @@ arc_rewrite_small_data_p (const_rtx x)\n \tx = XEXP (x, 0);\n     }\n \n-  return (GET_CODE (x) ==  SYMBOL_REF\n-\t  && SYMBOL_REF_SMALL_P(x));\n+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_SMALL_P (x))\n+    {\n+      gcc_assert (SYMBOL_REF_TLS_MODEL (x) == 0);\n+      return true;\n+    }\n+  return false;\n }\n \n /* If possible, rewrite OP so that it refers to small data using\n@@ -7280,40 +7482,39 @@ prepare_move_operands (rtx *operands, machine_mode mode)\n {\n   /* We used to do this only for MODE_INT Modes, but addresses to floating\n      point variables may well be in the small data section.  */\n-  if (1)\n+  if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[0], Pmode))\n+    operands[0] = arc_rewrite_small_data (operands[0]);\n+\n+  if (mode == SImode && SYMBOLIC_CONST (operands[1]))\n     {\n-      if (!TARGET_NO_SDATA_SET && small_data_pattern (operands[0], Pmode))\n-\toperands[0] = arc_rewrite_small_data (operands[0]);\n-      else if (mode == SImode && flag_pic && SYMBOLIC_CONST (operands[1]))\n-\t{\n-\t  emit_pic_move (operands, SImode);\n+      prepare_pic_move (operands, SImode);\n \n-\t  /* Disable any REG_EQUALs associated with the symref\n-\t     otherwise the optimization pass undoes the work done\n-\t     here and references the variable directly.  */\n-\t}\n-      else if (GET_CODE (operands[0]) != MEM\n-\t       && !TARGET_NO_SDATA_SET\n-\t       && small_data_pattern (operands[1], Pmode))\n-       {\n-\t  /* This is to take care of address calculations involving sdata\n-\t     variables.  */\n-\t  operands[1] = arc_rewrite_small_data (operands[1]);\n-\n-\t  emit_insn (gen_rtx_SET (operands[0],operands[1]));\n-\t  /* ??? This note is useless, since it only restates the set itself.\n-\t     We should rather use the original SYMBOL_REF.  However, there is\n-\t     the problem that we are lying to the compiler about these\n-\t     SYMBOL_REFs to start with.  symbol@sda should be encoded specially\n-\t     so that we can tell it apart from an actual symbol.  */\n-\t  set_unique_reg_note (get_last_insn (), REG_EQUAL, operands[1]);\n-\n-\t  /* Take care of the REG_EQUAL note that will be attached to mark the\n-\t     output reg equal to the initial symbol_ref after this code is\n-\t     executed.  */\n-\t  emit_move_insn (operands[0], operands[0]);\n-\t  return true;\n-\t}\n+      /* Disable any REG_EQUALs associated with the symref\n+\t otherwise the optimization pass undoes the work done\n+\t here and references the variable directly.  */\n+    }\n+\n+  if (GET_CODE (operands[0]) != MEM\n+      && !TARGET_NO_SDATA_SET\n+      && small_data_pattern (operands[1], Pmode))\n+    {\n+      /* This is to take care of address calculations involving sdata\n+\t variables.  */\n+      operands[1] = arc_rewrite_small_data (operands[1]);\n+\n+      emit_insn (gen_rtx_SET (operands[0],operands[1]));\n+      /* ??? This note is useless, since it only restates the set itself.\n+\t We should rather use the original SYMBOL_REF.  However, there is\n+\t the problem that we are lying to the compiler about these\n+\t SYMBOL_REFs to start with.  symbol@sda should be encoded specially\n+\t so that we can tell it apart from an actual symbol.  */\n+      set_unique_reg_note (get_last_insn (), REG_EQUAL, operands[1]);\n+\n+      /* Take care of the REG_EQUAL note that will be attached to mark the\n+\t output reg equal to the initial symbol_ref after this code is\n+\t executed.  */\n+      emit_move_insn (operands[0], operands[0]);\n+      return true;\n     }\n \n   if (MEM_P (operands[0])\n@@ -8311,6 +8512,13 @@ arc_legitimize_address_0 (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n static rtx\n arc_legitimize_address (rtx orig_x, rtx oldx, machine_mode mode)\n {\n+  if (GET_CODE (orig_x) == SYMBOL_REF)\n+    {\n+      enum tls_model model = SYMBOL_REF_TLS_MODEL (orig_x);\n+      if (model != 0)\n+\treturn arc_legitimize_tls_address (orig_x, model);\n+    }\n+\n   rtx new_x = arc_legitimize_address_0 (orig_x, oldx, mode);\n \n   if (new_x)\n@@ -9070,6 +9278,8 @@ arc_can_follow_jump (const rtx_insn *follower, const rtx_insn *followee)\n bool\n arc_epilogue_uses (int regno)\n {\n+  if (regno == arc_tp_regno)\n+    return true;\n   if (reload_completed)\n     {\n       if (ARC_INTERRUPT_P (cfun->machine->fn_type))\n@@ -9085,6 +9295,16 @@ arc_epilogue_uses (int regno)\n     return regno == arc_return_address_regs[arc_compute_function_type (cfun)];\n }\n \n+/* Helper for EH_USES macro.  */\n+\n+bool\n+arc_eh_uses (int regno)\n+{\n+  if (regno == arc_tp_regno)\n+    return true;\n+  return false;\n+}\n+\n #ifndef TARGET_NO_LRA\n #define TARGET_NO_LRA !TARGET_LRA\n #endif\n@@ -9590,6 +9810,13 @@ arc_dwarf_register_span (rtx rtl)\n    return p;\n }\n \n+/* We can't inline this in INSN_REFERENCES_ARE_DELAYED because\n+   resource.h doesn't include the required header files.  */\n+bool\n+insn_is_tls_gd_dispatch (rtx_insn *insn)\n+{\n+  return recog_memoized (insn) == CODE_FOR_tls_gd_dispatch;\n+}\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "de6c6d11974a41be44a330e8ba278c848e2ec2a5", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -109,6 +109,8 @@ along with GCC; see the file COPYING3.  If not see\n       builtin_define (\"__ARC_SIMD__\");\t\\\n     if (TARGET_BARREL_SHIFTER)\t\t\\\n       builtin_define (\"__Xbarrel_shifter\");\\\n+    builtin_define_with_int_value (\"__ARC_TLS_REGNO__\", \\\n+\t\t\t\t   arc_tp_regno);\t\\\n     builtin_assert (\"cpu=arc\");\t\t\\\n     builtin_assert (\"machine=arc\");\t\\\n     builtin_define (TARGET_BIG_ENDIAN\t\\\n@@ -201,7 +203,13 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n #if DEFAULT_LIBC != LIBC_UCLIBC\n-#define STARTFILE_SPEC \"%{!shared:crt0.o%s} crti%O%s %{pg|p:crtg.o%s} crtbegin.o%s\"\n+#define ARC_TLS_EXTRA_START_SPEC \"crttls.o%s\"\n+\n+#define EXTRA_SPECS \\\n+  { \"arc_tls_extra_start_spec\", ARC_TLS_EXTRA_START_SPEC }, \\\n+\n+#define STARTFILE_SPEC \"%{!shared:crt0.o%s} crti%O%s %{pg|p:crtg.o%s} \" \\\n+  \"%(arc_tls_extra_start_spec) crtbegin.o%s\"\n #else\n #define STARTFILE_SPEC   \"%{!shared:%{!mkernel:crt1.o%s}} crti.o%s \\\n   %{!shared:%{pg|p|profile:crtg.o%s} crtbegin.o%s} %{shared:crtbeginS.o%s}\"\n@@ -748,9 +756,10 @@ extern enum reg_class arc_regno_reg_class[];\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-((REGNO) < 29 || ((REGNO) == ARG_POINTER_REGNUM) || ((REGNO) == 63) ||\\\n- (unsigned) reg_renumber[REGNO] < 29)\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\t\\\n+  ((REGNO) < 29 || ((REGNO) == ARG_POINTER_REGNUM) || ((REGNO) == 63)\t\\\n+   || ((unsigned) reg_renumber[REGNO] < 29)\t\t\t\t\\\n+   || ((unsigned) (REGNO) == (unsigned) arc_tp_regno))\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n \n@@ -937,6 +946,8 @@ arc_return_addr_rtx(COUNT,FRAME)\n \n #define EPILOGUE_USES(REGNO) arc_epilogue_uses ((REGNO))\n \n+#define EH_USES(REGNO) arc_eh_uses((REGNO))\n+\n /* Definitions for register eliminations.\n \n    This is an array of structures.  Each structure initializes one pair\n@@ -1657,7 +1668,8 @@ extern enum arc_function_type arc_compute_function_type (struct function *);\n    && GET_CODE (PATTERN (X)) != CLOBBER\t\t\\\n    && (get_attr_type (X) == TYPE_CALL || get_attr_type (X) == TYPE_SFUNC))\n \n-#define INSN_REFERENCES_ARE_DELAYED(insn) INSN_SETS_ARE_DELAYED (insn)\n+#define INSN_REFERENCES_ARE_DELAYED(insn)\t\t\t\t\\\n+  (INSN_SETS_ARE_DELAYED (insn) && !insn_is_tls_gd_dispatch (insn))\n \n #define CALL_ATTR(X, NAME) \\\n   ((CALL_P (X) || NONJUMP_INSN_P (X)) \\"}, {"sha": "4a7287b053654618ddff115356646d2bb86c9dc1", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -111,6 +111,10 @@\n   ARC_UNSPEC_PLT\n   ARC_UNSPEC_GOT\n   ARC_UNSPEC_GOTOFF\n+  UNSPEC_TLS_GD\n+  UNSPEC_TLS_LD\n+  UNSPEC_TLS_IE\n+  UNSPEC_TLS_OFF\n   UNSPEC_ARC_NORM\n   UNSPEC_ARC_NORMW\n   UNSPEC_ARC_SWAP\n@@ -169,6 +173,7 @@\n    (R1_REG 1)\n    (R2_REG 2)\n    (R3_REG 3)\n+   (R10_REG 10)\n    (R12_REG 12)\n    (SP_REG 28)\n    (ILINK1_REGNUM 29)\n@@ -5277,6 +5282,72 @@\n   [(set_attr \"type\" \"call\")\n    (set_attr \"is_SIBCALL\" \"yes\")])\n \n+(define_insn \"tls_load_tp_soft\"\n+  [(set (reg:SI R0_REG) (unspec:SI [(const_int 0)] UNSPEC_TLS_OFF))\n+   (clobber (reg:SI RETURN_ADDR_REGNUM))]\n+  \"\"\n+  \"*return arc_output_libcall (\\\"__read_tp\\\");\"\n+  [(set_attr \"is_sfunc\" \"yes\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"tls_gd_load\"\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcq#q,c\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"Rcq#q,c\")\n+\t\t    (match_operand:SI 2 \"symbolic_operand\" \"X,X\")]\n+\t UNSPEC_TLS_GD))]\n+  \"\"\n+  \".tls_gd_ld %2`ld%? %0,[%1]\"\n+  [(set_attr \"type\" \"load\")\n+   ; if the linker has to patch this into IE, we need a long insn\n+   ; (FIXME: or two short insn, ld_s / jl_s.  missing -Os optimization.)\n+   (set_attr_alternative \"iscompact\"\n+     [(cond [(ne (symbol_ref \"arc_tp_regno == 30\") (const_int 0))\n+\t     (const_string \"*\")] (const_string \"maybe\"))\n+      (const_string \"*\")])])\n+\n+(define_insn \"tls_gd_get_addr\"\n+  [(set (reg:SI R0_REG)\n+\t(call:SI (mem:SI (unspec:SI [(match_operand:SI 0\n+\t\t\t\t      \"symbolic_operand\" \"X,X\")]\n+\t\t\t  UNSPEC_TLS_GD))\n+\t\t (const_int 0)))\n+   (clobber (reg:SI RETURN_ADDR_REGNUM))]\n+  \"\"\n+  \".tls_gd_ld %0`bl%* __tls_get_addr@plt\"\n+  [(set_attr \"type\" \"call\")\n+   ; With TARGET_MEDIUM_CALLS, plt calls are not predicable.\n+   (set_attr \"predicable\" \"no\")])\n+\n+; We make this call specific to the tls symbol to avoid commoning this\n+; with calls for other symbols; we want the linker to be able to\n+(define_insn \"tls_gd_dispatch\"\n+  [(set (reg:SI R0_REG)\n+\t(unspec:SI\n+\t  [(reg:SI R0_REG)\n+\t   (call (mem:SI (match_operand:SI 0 \"register_operand\" \"Rcq,q,c\"))\n+\t\t (const_int 0))\n+\t   (match_operand:SI 1 \"symbolic_operand\" \"X,X,X\")]\n+\t UNSPEC_TLS_GD))\n+   (clobber (reg:SI RETURN_ADDR_REGNUM))\n+   (clobber (reg:DI R10_REG))\n+   (clobber (reg:SI R12_REG))]\n+  \"\"\n+  \".tls_gd_call %1`jl%!%* [%0]\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"iscompact\" \"maybe,false,*\")\n+   (set_attr \"predicable\" \"no,no,yes\")])\n+\n+;; For thread pointer builtins\n+(define_expand \"get_thread_pointersi\"\n+  [(set (match_operand:SI 0 \"register_operand\") (match_dup 1))]\n+ \"\"\n+ \"operands[1] = gen_rtx_REG (Pmode, arc_tp_regno);\")\n+\n+(define_expand \"set_thread_pointersi\"\n+  [(set (match_dup 1) (match_operand:SI 0 \"register_operand\"))]\n+ \"\"\n+ \"operands[1] = gen_rtx_REG (Pmode, arc_tp_regno);\")\n+\n ;; If hardware floating point is available, don't define a negdf pattern;\n ;; it would be something like:\n ;;(define_insn \"negdf2\""}, {"sha": "76f66a2988b2fd2cdc34d1e7885cd3d177d1dce1", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -456,3 +456,10 @@ Enum(arc_fpu) String(fpus_all) Value(FPU_SP | FPU_SC | FPU_SF | FPU_SD)\n \n EnumValue\n Enum(arc_fpu) String(fpud_all) Value(FPU_SP | FPU_SC | FPU_SF | FPU_SD | FPU_DP | FPU_DC | FPU_DF | FPU_DD)\n+\n+mtp-regno=\n+Target RejectNegative Joined UInteger Var(arc_tp_regno) Init(25)\n+Specify thread pointer register number\n+\n+mtp-regno=none\n+Target RejectNegative Var(arc_tp_regno,-1)"}, {"sha": "3c657c67f0d3433c9d6942ee20d975dfadaa48ef", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -351,9 +351,12 @@\n   switch (GET_CODE (op))\n     {\n     case SYMBOL_REF :\n+      if (SYMBOL_REF_TLS_MODEL (op))\n+\treturn 0;\n     case LABEL_REF :\n+      return 1;\n     case CONST :\n-      return (!flag_pic || arc_legitimate_pic_operand_p(op));\n+      return arc_legitimate_constant_p (mode, op);\n     case CONST_INT :\n       return (LARGE_INT (INTVAL (op)));\n     case CONST_DOUBLE :\n@@ -451,6 +454,16 @@\n \t    && (GET_CODE (XEXP (addr, 1)) != PLUS\n \t\t|| !CONST_INT_P (XEXP (XEXP (addr, 1), 1))))\n \t  return 0;\n+\t/* CONST_INT / CONST_DOUBLE is fine, but the PIC CONST ([..] UNSPEC))\n+\t   constructs are effectively indexed.  */\n+\tif (flag_pic)\n+\t  {\n+\t    rtx ad0 = addr;\n+\t    while (GET_CODE (ad0) == PLUS)\n+\t      ad0 = XEXP (ad0, 0);\n+\t    if (GET_CODE (ad0) == CONST || GET_CODE (ad0) == UNSPEC)\n+\t      return 0;\n+\t  }\n \treturn address_operand (addr, mode);\n       }\n     default :"}, {"sha": "99fdea172f6402607a8376c62d2949df0a1e8fea", "filename": "gcc/configure", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -23855,6 +23855,12 @@ foo:\t.long\t25\n \ttls_first_minor=13\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  arc*-*-*)\n+    conftest_s='\n+\tadd_s r0,r0, @foo@tpoff'\n+\ttls_first_major=2\n+\ttls_first_minor=23\n+\t;;\n   cris-*-*|crisv32-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}, {"sha": "e40d82a8306044209ec05a5e7bdbca9ea67ba21d", "filename": "gcc/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -3086,6 +3086,12 @@ foo:\t.long\t25\n \ttls_first_minor=13\n \ttls_as_opt=--fatal-warnings\n \t;;\n+  arc*-*-*)\n+    conftest_s='\n+\tadd_s r0,r0, @foo@tpoff'\n+\ttls_first_major=2\n+\ttls_first_minor=23\n+\t;;\n   cris-*-*|crisv32-*-*)\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits"}, {"sha": "515d948ce710a2fba98c586ea2efa05d4cf60979", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -593,7 +593,7 @@ Objective-C and Objective-C++ Dialects}.\n -mcrc -mdsp-packa -mdvbf -mlock -mmac-d16 -mmac-24 -mrtsc -mswape @gol\n -mtelephony -mxy -misize -mannotate-align -marclinux -marclinux_prof @gol\n -mlong-calls -mmedium-calls -msdata @gol\n--mucb-mcount -mvolatile-cache @gol\n+-mucb-mcount -mvolatile-cache -mtp-regno=@var{regno} @gol\n -malign-call -mauto-modify-reg -mbbit-peephole -mno-brcc @gol\n -mcase-vector-pcrel -mcompact-casesi -mno-cond-exec -mearly-cbranchsi @gol\n -mexpand-adddi -mindexed-loads -mlra -mlra-priority-none @gol\n@@ -13360,6 +13360,10 @@ Enable code density instructions for ARC EM, default on for ARC HS.\n @opindex mll64\n Enable double load/store operations for ARC HS cores.\n \n+@item -mtp-regno=@var{regno}\n+@opindex mtp-regno\n+Specify thread pointer register number.\n+\n @item -mmpy-option=@var{multo}\n @opindex mmpy-option\n Compile ARCv2 code with a multiplier design option.  @samp{wlh1} is"}]}