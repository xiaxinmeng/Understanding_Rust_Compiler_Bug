{"sha": "653da906036b7c3bd8c573fed889ddc151fce7c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzZGE5MDYwMzZiN2MzYmQ4YzU3M2ZlZDg4OWRkYzE1MWZjZTdjNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-12-09T17:19:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:19:49Z"}, "message": "einfo.adb (Itype_Printed): New flag\n\n2005-12-05  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Itype_Printed): New flag\n\t(Is_Limited_Type): Derived types do not inherit limitedness from\n\tinterface progenitors.\n\t(Is_Return_By_Reference_Type): Predicate does not apply to limited\n\tinterfaces.\n\n\t* einfo.ads (Itype_Printed): New flag\n\tMove Is_Wrapper_Package to proper section\n\tAdd missing Inline for Is_Volatile\n\n\t* output.ads, output.adb (Write_Erase_Char): New procedure\n\t(Save/Restore_Output_Buffer): New procedures\n\t(Save/Restore_Output_Buffer): New procedures\n\n\t* sprint.ads, sprint.adb (Write_Itype): Handle case of record itypes\n\tAdd missing support for anonymous access type\n\t(Write_Id): Insert calls to Write_Itype\n\t(Write_Itype): New procedure to output itypes\n\n\t* par-ch12.adb (P_Formal_Derived_Type_Definition): In Ada 2005, handle\n\tuse of \"limited\" in declaration.\n\n\t* sinfo.ads, sinfo.adb: \n\tFormal derived types can carry an explicit \"limited\" indication.\n\n\t* sem_ch3.adb: Add with and use of Targparm.\n\t(Create_Component): If Frontend_Layout_On_Target is True and the\n\tcopied component does not have a known static Esize, then reset\n\tthe size and positional fields of the new component.\n\t(Analyze_Component_Declaration): A limited component is\n\tlegal within a protected type that implements an interface.\n\t(Collect_Interfaces): Do not add to the list the interfaces that\n\tare implemented by the ancestors.\n\t(Derived_Type_Declaration): If the parent of the full-view is an\n\tinterface perform a transformation of the tree to ensure that it has\n\tthe same parent than the partial-view. This simplifies the job of the\n\texpander in order to generate the correct object layout, and it is\n\tneeded because the list of interfaces of the full-view can be given in\n\tany order.\n\t(Process_Full_View): The parent of the full-view does not need to be\n\ta descendant of the parent of the partial view if both parents are\n\tinterfaces.\n\t(Analyze_Private_Extension_Declaration): If declaration has an explicit\n\t\"limited\" the parent must be a limited type.\n\t(Build_Derived_Record_Type): A derived type that is explicitly limited\n\tmust have limited ancestor and progenitors.\n\t(Build_Derived_Type): Ditto.\n\t(Process_Full_View): Verify that explicit uses of \"limited\" in partial\n\tand full declarations are consistent.\n\t(Find_Ancestor_Interface): Remove function.\n\t(Collect_Implemented_Interfaces): New procedure used to gather all\n\timplemented interfaces by a type.\n\t(Contain_Interface): New function used to check whether an interface is\n\tpresent in a list.\n\t(Find_Hidden_Interface): New function used to determine whether two\n\tlists of interfaces constitute a set equality. If not, the first\n\tdiffering interface is returned.\n\t(Process_Full_View): Improve the check for the \"no hidden interface\"\n\trule as defined by AI-396.\n\nFrom-SVN: r108295", "tree": {"sha": "55fe007ea4d3250009db6cfbba847208f8c1e982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55fe007ea4d3250009db6cfbba847208f8c1e982"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/653da906036b7c3bd8c573fed889ddc151fce7c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653da906036b7c3bd8c573fed889ddc151fce7c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/653da906036b7c3bd8c573fed889ddc151fce7c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653da906036b7c3bd8c573fed889ddc151fce7c6/comments", "author": null, "committer": null, "parents": [{"sha": "ea985d95427f210e627541b70dd56bb4b21ed838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea985d95427f210e627541b70dd56bb4b21ed838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea985d95427f210e627541b70dd56bb4b21ed838"}], "stats": {"total": 2509, "additions": 1585, "deletions": 924}, "files": [{"sha": "4a9eb8b8881b74b72e179b705d89581f06b71172", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -452,8 +452,8 @@ package body Einfo is\n    --    Is_Task_Interface              Flag200\n \n    --    Has_Anon_Block_Suffix          Flag201\n+   --    Itype_Printed                  Flag202\n \n-   --    (unused)                       Flag202\n    --    (unused)                       Flag203\n    --    (unused)                       Flag204\n    --    (unused)                       Flag205\n@@ -1877,13 +1877,20 @@ package body Einfo is\n    function Is_Volatile (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n+\n       if Is_Type (Id) then\n          return Flag16 (Base_Type (Id));\n       else\n          return Flag16 (Id);\n       end if;\n    end Is_Volatile;\n \n+   function Itype_Printed (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Itype (Id));\n+      return Flag202 (Id);\n+   end Itype_Printed;\n+\n    function Kill_Elaboration_Checks (Id : E) return B is\n    begin\n       return Flag32 (Id);\n@@ -4016,6 +4023,12 @@ package body Einfo is\n       Set_Flag16 (Id, V);\n    end Set_Is_Volatile;\n \n+   procedure Set_Itype_Printed (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Itype (Id));\n+      Set_Flag202 (Id, V);\n+   end Set_Itype_Printed;\n+\n    procedure Set_Kill_Elaboration_Checks (Id : E; V : B := True) is\n    begin\n       Set_Flag32 (Id, V);\n@@ -5722,6 +5735,7 @@ package body Einfo is\n \n    function Is_Limited_Type (Id : E) return B is\n       Btype : constant E := Base_Type (Id);\n+      Rtype : constant E := Root_Type (Btype);\n \n    begin\n       if not Is_Type (Id) then\n@@ -5744,11 +5758,17 @@ package body Einfo is\n          return False;\n \n       elsif Is_Record_Type (Btype) then\n-         if Is_Limited_Record (Root_Type (Btype)) then\n-            return True;\n+\n+         --  AI-419: limitedness is not inherited from a limited interface\n+\n+         if Is_Limited_Record (Rtype) then\n+            return not Is_Interface (Rtype)\n+              or else Is_Protected_Interface (Rtype)\n+              or else Is_Synchronized_Interface (Rtype)\n+              or else Is_Task_Interface (Rtype);\n \n          elsif Is_Class_Wide_Type (Btype) then\n-            return Is_Limited_Type (Root_Type (Btype));\n+            return Is_Limited_Type (Rtype);\n \n          else\n             declare\n@@ -5813,14 +5833,15 @@ package body Einfo is\n    -- Is_Return_By_Reference_Type --\n    ---------------------------------\n \n+   --  Note: this predicate has disappeared from Ada 2005: see AI-318-2\n+\n    function Is_Return_By_Reference_Type (Id : E) return B is\n       Btype : constant Entity_Id := Base_Type (Id);\n \n    begin\n       if Is_Private_Type (Btype) then\n          declare\n             Utyp : constant Entity_Id := Underlying_Type (Btype);\n-\n          begin\n             if No (Utyp) then\n                return False;\n@@ -5834,7 +5855,10 @@ package body Einfo is\n \n       elsif Is_Record_Type (Btype) then\n          if Is_Limited_Record (Btype) then\n-            return True;\n+            return not Is_Interface (Btype)\n+              or else Is_Protected_Interface (Btype)\n+              or else Is_Synchronized_Interface (Btype)\n+              or else Is_Task_Interface (Btype);\n \n          elsif Is_Class_Wide_Type (Btype) then\n             return Is_Return_By_Reference_Type (Root_Type (Btype));\n@@ -6700,6 +6724,7 @@ package body Einfo is\n       W (\"Is_Valued_Procedure\",           Flag127 (Id));\n       W (\"Is_Visible_Child_Unit\",         Flag116 (Id));\n       W (\"Is_Volatile\",                   Flag16  (Id));\n+      W (\"Itype_Printed\",                 Flag202 (Id));\n       W (\"Kill_Elaboration_Checks\",       Flag32  (Id));\n       W (\"Kill_Range_Checks\",             Flag33  (Id));\n       W (\"Kill_Tag_Checks\",               Flag34  (Id));"}, {"sha": "290fd44c15d84d4f9317291b0ece7216552acd87", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -2469,6 +2469,10 @@ package Einfo is\n --       Present in package entities. Indicates that the package has been\n --       created as a wrapper for a subprogram instantiation.\n \n+--    Itype_Printed (Flag202)\n+--       Set in Itypes if the Itype has been printed by Sprint. This is used to\n+--       avoid printing an Itype more than once.\n+\n --    Kill_Elaboration_Checks (Flag32)\n --       Present in all entities. Set by the expander to kill elaboration\n --       checks which are known not to be needed. Equivalent in effect to\n@@ -4166,6 +4170,7 @@ package Einfo is\n    --    Is_Tagged_Type                (Flag55)\n    --    Is_Unsigned_Type              (Flag144)\n    --    Is_Volatile                   (Flag16)\n+   --    Itype_Printed                 (Flag202)  (itypes only)\n    --    Must_Be_On_Byte_Boundary      (Flag183)\n    --    Size_Depends_On_Discriminant  (Flag177)\n    --    Size_Known_At_Compile_Time    (Flag92)\n@@ -5363,7 +5368,6 @@ package Einfo is\n    function Is_Potentially_Use_Visible         (Id : E) return B;\n    function Is_Preelaborated                   (Id : E) return B;\n    function Is_Primitive_Wrapper               (Id : E) return B;\n-\n    function Is_Private_Composite               (Id : E) return B;\n    function Is_Private_Descendant              (Id : E) return B;\n    function Is_Protected_Interface             (Id : E) return B;\n@@ -5387,7 +5391,7 @@ package Einfo is\n    function Is_Valued_Procedure                (Id : E) return B;\n    function Is_Visible_Child_Unit              (Id : E) return B;\n    function Is_Volatile                        (Id : E) return B;\n-   function Is_Wrapper_Package                 (Id : E) return B;\n+   function Itype_Printed                      (Id : E) return B;\n    function Kill_Elaboration_Checks            (Id : E) return B;\n    function Kill_Range_Checks                  (Id : E) return B;\n    function Kill_Tag_Checks                    (Id : E) return B;\n@@ -5567,6 +5571,7 @@ package Einfo is\n    function Is_Return_By_Reference_Type        (Id : E) return B;\n    function Is_String_Type                     (Id : E) return B;\n    function Is_Task_Record_Type                (Id : E) return B;\n+   function Is_Wrapper_Package                 (Id : E) return B;\n    function Next_Component                     (Id : E) return E;\n    function Next_Discriminant                  (Id : E) return E;\n    function Next_Formal                        (Id : E) return E;\n@@ -5890,6 +5895,7 @@ package Einfo is\n    procedure Set_Is_Valued_Procedure           (Id : E; V : B := True);\n    procedure Set_Is_Visible_Child_Unit         (Id : E; V : B := True);\n    procedure Set_Is_Volatile                   (Id : E; V : B := True);\n+   procedure Set_Itype_Printed                 (Id : E; V : B := True);\n    procedure Set_Kill_Elaboration_Checks       (Id : E; V : B := True);\n    procedure Set_Kill_Range_Checks             (Id : E; V : B := True);\n    procedure Set_Kill_Tag_Checks               (Id : E; V : B := True);\n@@ -6445,7 +6451,6 @@ package Einfo is\n    pragma Inline (Is_Potentially_Use_Visible);\n    pragma Inline (Is_Preelaborated);\n    pragma Inline (Is_Primitive_Wrapper);\n-\n    pragma Inline (Is_Private_Composite);\n    pragma Inline (Is_Private_Descendant);\n    pragma Inline (Is_Private_Type);\n@@ -6477,6 +6482,7 @@ package Einfo is\n    pragma Inline (Is_VMS_Exception);\n    pragma Inline (Is_Valued_Procedure);\n    pragma Inline (Is_Visible_Child_Unit);\n+   pragma Inline (Itype_Printed);\n    pragma Inline (Kill_Elaboration_Checks);\n    pragma Inline (Kill_Range_Checks);\n    pragma Inline (Kill_Tag_Checks);\n@@ -6788,7 +6794,6 @@ package Einfo is\n    pragma Inline (Set_Is_Potentially_Use_Visible);\n    pragma Inline (Set_Is_Preelaborated);\n    pragma Inline (Set_Is_Primitive_Wrapper);\n-\n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n    pragma Inline (Set_Is_Protected_Interface);\n@@ -6812,6 +6817,7 @@ package Einfo is\n    pragma Inline (Set_Is_Valued_Procedure);\n    pragma Inline (Set_Is_Visible_Child_Unit);\n    pragma Inline (Set_Is_Volatile);\n+   pragma Inline (Set_Itype_Printed);\n    pragma Inline (Set_Kill_Elaboration_Checks);\n    pragma Inline (Set_Kill_Range_Checks);\n    pragma Inline (Set_Kill_Tag_Checks);\n@@ -6909,6 +6915,7 @@ package Einfo is\n    --  access/set format that can be handled by xeinfo.\n \n    pragma Inline (Is_Package_Or_Generic_Package);\n+   pragma Inline (Is_Volatile);\n    pragma Inline (Is_Wrapper_Package);\n    pragma Inline (Known_RM_Size);\n    pragma Inline (Known_Static_Component_Bit_Offset);"}, {"sha": "e7e7ea0406471fcde2dc23d08638d27ec4d0f995", "filename": "gcc/ada/output.adb", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Foutput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Foutput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.adb?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -42,29 +42,6 @@ package body Output is\n    --  Record argument to last call to Set_Special_Output. If this is\n    --  non-null, then we are in special output mode.\n \n-   -------------------------\n-   -- Line Buffer Control --\n-   -------------------------\n-\n-   --  Note: the following buffer and column position are maintained by\n-   --  the subprograms defined in this package, and are not normally\n-   --  directly modified or accessed by a client. However, a client is\n-   --  permitted to modify these values, using the knowledge that only\n-   --  Write_Eol actually generates any output.\n-\n-   Buffer_Max : constant := 8192;\n-   Buffer     : String (1 .. Buffer_Max + 1);\n-   --  Buffer used to build output line. We do line buffering because it\n-   --  is needed for the support of the debug-generated-code option (-gnatD).\n-   --  Historically it was first added because on VMS, line buffering is\n-   --  needed with certain file formats. So in any case line buffering must\n-   --  be retained for this purpose, even if other reasons disappear. Note\n-   --  any attempt to write more output to a line than can fit in the buffer\n-   --  will be silently ignored.\n-\n-   Next_Column : Pos range 1 .. Buffer'Length + 1 := 1;\n-   --  Column about to be written\n-\n    -----------------------\n    -- Local_Subprograms --\n    -----------------------\n@@ -86,7 +63,7 @@ package body Output is\n    ------------------\n \n    procedure Flush_Buffer is\n-      Len : constant Natural := Natural (Next_Column - 1);\n+      Len : constant Natural := Next_Col - 1;\n \n    begin\n       if Len /= 0 then\n@@ -111,27 +88,50 @@ package body Output is\n \n             else\n                Current_FD := Standerr;\n-               Next_Column := 1;\n+               Next_Col := 1;\n                Write_Line (\"fatal error: disk full\");\n                OS_Exit (2);\n             end if;\n          end if;\n \n          --  Buffer is now empty\n \n-         Next_Column := 1;\n+         Next_Col := 1;\n       end if;\n    end Flush_Buffer;\n \n    ------------\n    -- Column --\n    ------------\n \n-   function Column return Nat is\n+   function Column return Pos is\n    begin\n-      return Next_Column;\n+      return Pos (Next_Col);\n    end Column;\n \n+   ---------------------------\n+   -- Restore_Output_Buffer --\n+   ---------------------------\n+\n+   procedure Restore_Output_Buffer (S : Saved_Output_Buffer) is\n+   begin\n+      Next_Col := S.Next_Col;\n+      Buffer (1 .. Next_Col - 1) := S.Buffer (1 .. Next_Col - 1);\n+   end Restore_Output_Buffer;\n+\n+   ------------------------\n+   -- Save_Output_Buffer --\n+   ------------------------\n+\n+   function Save_Output_Buffer return Saved_Output_Buffer is\n+      S : Saved_Output_Buffer;\n+   begin\n+      S.Buffer (1 .. Next_Col - 1) := Buffer (1 .. Next_Col - 1);\n+      S.Next_Col := Next_Col;\n+      Next_Col := 1;\n+      return S;\n+   end Save_Output_Buffer;\n+\n    ------------------------\n    -- Set_Special_Output --\n    ------------------------\n@@ -149,7 +149,7 @@ package body Output is\n    begin\n       if Special_Output_Proc = null then\n          Flush_Buffer;\n-         Next_Column := 1;\n+         Next_Col := 1;\n       end if;\n \n       Current_FD := Standerr;\n@@ -163,7 +163,7 @@ package body Output is\n    begin\n       if Special_Output_Proc = null then\n          Flush_Buffer;\n-         Next_Column := 1;\n+         Next_Col := 1;\n       end if;\n \n       Current_FD := Standout;\n@@ -236,12 +236,12 @@ package body Output is\n \n    procedure Write_Char (C : Character) is\n    begin\n-      if Next_Column = Buffer'Length then\n+      if Next_Col = Buffer'Length then\n          Write_Eol;\n       end if;\n \n-      Buffer (Natural (Next_Column)) := C;\n-      Next_Column := Next_Column + 1;\n+      Buffer (Next_Col) := C;\n+      Next_Col := Next_Col + 1;\n    end Write_Char;\n \n    ---------------\n@@ -250,11 +250,22 @@ package body Output is\n \n    procedure Write_Eol is\n    begin\n-      Buffer (Natural (Next_Column)) := ASCII.LF;\n-      Next_Column := Next_Column + 1;\n+      Buffer (Next_Col) := ASCII.LF;\n+      Next_Col := Next_Col + 1;\n       Flush_Buffer;\n    end Write_Eol;\n \n+   ----------------------\n+   -- Write_Erase_Char --\n+   ----------------------\n+\n+   procedure Write_Erase_Char (C : Character) is\n+   begin\n+      if Next_Col /= 1 and then Buffer (Next_Col - 1) = C then\n+         Next_Col := Next_Col - 1;\n+      end if;\n+   end Write_Erase_Char;\n+\n    ---------------\n    -- Write_Int --\n    ---------------"}, {"sha": "10df65578442f5facd0f7c1c23f1f0475d89f241", "filename": "gcc/ada/output.ads", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Foutput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Foutput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Foutput.ads?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,7 +35,8 @@\n --  for writing error messages and informational output. It is also used\n --  by the debug source file output routines (see Sprintf.Print_Eol).\n \n-with Types; use Types;\n+with Hostparm; use Hostparm;\n+with Types;    use Types;\n \n package Output is\n    pragma Elaborate_Body;\n@@ -86,6 +87,9 @@ package Output is\n    --  Write one character to the standard output file. Note that the\n    --  character should not be LF or CR (use Write_Eol for end of line)\n \n+   procedure Write_Erase_Char (C : Character);\n+   --  If last character in buffer matches C, erase it, otherwise no effect\n+\n    procedure Write_Eol;\n    --  Write an end of line (whatever is required by the system in use,\n    --  e.g. CR/LF for DOS, or LF for Unix) to the standard output file.\n@@ -106,11 +110,30 @@ package Output is\n    procedure Write_Line (S : String);\n    --  Equivalent to Write_Str (S) followed by Write_Eol;\n \n-   function Column return Nat;\n+   function Column return Pos;\n    pragma Inline (Column);\n    --  Returns the number of the column about to be written (e.g. a value\n    --  of 1 means the current line is empty).\n \n+   -------------------------\n+   -- Buffer Save/Restore --\n+   -------------------------\n+\n+   --  This facility allows the current line buffer to be saved and restored\n+\n+   type Saved_Output_Buffer is private;\n+   --  Type used for Save/Restore_Buffer\n+\n+   Buffer_Max : constant := Hostparm.Max_Line_Length;\n+   --  Maximal size of a buffered output line\n+\n+   function Save_Output_Buffer return Saved_Output_Buffer;\n+   --  Save current line buffer and reset line buffer to empty\n+\n+   procedure Restore_Output_Buffer (S : Saved_Output_Buffer);\n+   --  Restore previously saved output buffer. The value in S is not affected\n+   --  so it is legtimate to restore a buffer more than once.\n+\n    --------------------------\n    -- Debugging Procedures --\n    --------------------------\n@@ -144,4 +167,28 @@ package Output is\n    procedure w (L : String; B : Boolean);\n    --  Dump contents of string followed by blank, Boolean, line return\n \n+private\n+   --  Note: the following buffer and column position are maintained by the\n+   --  subprograms defined in this package, and cannot be directly modified or\n+   --  accessed by a client.\n+\n+   Buffer : String (1 .. Buffer_Max + 1);\n+   for Buffer'Alignment use 4;\n+   --  Buffer used to build output line. We do line buffering because it\n+   --  is needed for the support of the debug-generated-code option (-gnatD).\n+   --  Historically it was first added because on VMS, line buffering is\n+   --  needed with certain file formats. So in any case line buffering must\n+   --  be retained for this purpose, even if other reasons disappear. Note\n+   --  any attempt to write more output to a line than can fit in the buffer\n+   --  will be silently ignored. The alignment clause improves the efficiency\n+   --  of the save/restore procedures.\n+\n+   Next_Col : Positive range 1 .. Buffer'Length + 1 := 1;\n+   --  Column about to be written\n+\n+   type Saved_Output_Buffer is record\n+      Buffer   : String (1 .. Buffer_Max + 1);\n+      Next_Col : Positive;\n+   end record;\n+\n end Output;"}, {"sha": "cff5ac44fa1ee644988adc17dff520c747e42647", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -519,6 +519,9 @@ package body Ch12 is\n          --  exception is ABSTRACT, where we have to scan ahead to see if we\n          --  have a formal derived type or a formal private type definition.\n \n+         --  In addition, in Ada 2005 LIMITED may appear after abstract, so\n+         --  that the lookahead must be extended by one more token.\n+\n          when Tok_Abstract =>\n             Save_Scan_State (Scan_State);\n             Scan; -- past ABSTRACT\n@@ -527,6 +530,18 @@ package body Ch12 is\n                Restore_Scan_State (Scan_State); -- to ABSTRACT\n                return P_Formal_Derived_Type_Definition;\n \n+            elsif Token = Tok_Limited then\n+               Scan;  --  past LIMITED\n+\n+               if Token = Tok_New then\n+                  Restore_Scan_State (Scan_State); -- to ABSTRACT\n+                  return P_Formal_Derived_Type_Definition;\n+\n+               else\n+                  Restore_Scan_State (Scan_State); -- to ABSTRACT\n+                  return P_Formal_Private_Type_Definition;\n+               end if;\n+\n             else\n                Restore_Scan_State (Scan_State); -- to ABSTRACT\n                return P_Formal_Private_Type_Definition;\n@@ -560,7 +575,25 @@ package body Ch12 is\n                Set_Limited_Present (Typedef_Node);\n                return Typedef_Node;\n \n+            elsif Token = Tok_New then\n+               Restore_Scan_State (Scan_State); -- to LIMITED\n+               return P_Formal_Derived_Type_Definition;\n+\n             else\n+               if Token = Tok_Abstract then\n+                  Error_Msg_SC (\"ABSTRACT must come before LIMITED\");\n+                  Scan;  --  past improper ABSTRACT\n+\n+                  if Token = Tok_New then\n+                     Restore_Scan_State (Scan_State); -- to LIMITED\n+                     return P_Formal_Derived_Type_Definition;\n+\n+                  else\n+                     Restore_Scan_State (Scan_State);\n+                     return P_Formal_Private_Type_Definition;\n+                  end if;\n+               end if;\n+\n                Restore_Scan_State (Scan_State);\n                return P_Formal_Private_Type_Definition;\n             end if;\n@@ -666,6 +699,20 @@ package body Ch12 is\n          Scan; -- past LIMITED\n       end if;\n \n+      if Token = Tok_Abstract then\n+         if Prev_Token = Tok_Tagged then\n+            Error_Msg_SC (\"ABSTRACT must come before TAGGED\");\n+         elsif Prev_Token = Tok_Limited then\n+            Error_Msg_SC (\"ABSTRACT must come before LIMITED\");\n+         end if;\n+\n+         Resync_Past_Semicolon;\n+\n+      elsif Token = Tok_Tagged then\n+         Error_Msg_SC (\"TAGGED must come before LIMITED\");\n+         Resync_Past_Semicolon;\n+      end if;\n+\n       Set_Sloc (Def_Node, Token_Ptr);\n       T_Private;\n       return Def_Node;\n@@ -676,9 +723,11 @@ package body Ch12 is\n    --------------------------------------------\n \n    --  FORMAL_DERIVED_TYPE_DEFINITION ::=\n-   --    [abstract] new SUBTYPE_MARK [[AND interface_list] with private]\n+   --    [abstract] [limited]\n+   --         new SUBTYPE_MARK [[AND interface_list] with private]\n \n-   --  The caller has checked the initial token(s) is/are NEW or ASTRACT NEW\n+   --  The caller has checked the initial token(s) is/are NEW, ASTRACT NEW\n+   --  LIMITED NEW, or ABSTRACT LIMITED NEW\n \n    --  Error recovery: cannot raise Error_Resync\n \n@@ -693,6 +742,22 @@ package body Ch12 is\n          Scan; -- past ABSTRACT\n       end if;\n \n+      if Token = Tok_Limited then\n+         Set_Limited_Present (Def_Node);\n+         Scan;  --  past Limited\n+\n+         if Ada_Version < Ada_05 then\n+            Error_Msg_SP\n+              (\"LIMITED in derived type is an Ada 2005 extension\");\n+            Error_Msg_SP\n+              (\"\\unit must be compiled with -gnat05 switch\");\n+         end if;\n+\n+         if Token = Tok_Abstract then\n+            Scan;  --  past ABSTRACT. diagnosed already in caller.\n+         end if;\n+      end if;\n+\n       Scan; -- past NEW;\n       Set_Subtype_Mark (Def_Node, P_Subtype_Mark);\n       No_Constraint;"}, {"sha": "d2442b44baddbba5fb9b6a3c3dfad59e01254e04", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 322, "deletions": 91, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -65,6 +65,7 @@ with Sem_Warn; use Sem_Warn;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n@@ -1416,6 +1417,7 @@ package body Sem_Ch3 is\n \n          elsif not Is_Derived_Type (Current_Scope)\n            and then not Is_Limited_Record (Current_Scope)\n+           and then not Is_Concurrent_Type (Current_Scope)\n          then\n             Error_Msg_N\n               (\"nonlimited tagged type cannot have limited components\", N);\n@@ -2654,6 +2656,15 @@ package body Sem_Ch3 is\n       end if;\n \n       Build_Derived_Record_Type (N, Parent_Type, T);\n+\n+      if Limited_Present (N) then\n+         Set_Is_Limited_Record (T);\n+\n+         if not Is_Limited_Type (Parent_Type) then\n+            Error_Msg_NE (\"parent type& of limited extension must be limited\",\n+              N, Parent_Type);\n+         end if;\n+      end if;\n    end Analyze_Private_Extension_Declaration;\n \n    ---------------------------------\n@@ -5703,8 +5714,12 @@ package body Sem_Ch3 is\n       --  are only specified for limited records. For completeness, these\n       --  flags are also initialized along with all the other flags below.\n \n+      --  AI-419:  limitedness is not inherited from an interface parent\n+\n       Set_Is_Tagged_Type    (Derived_Type, Is_Tagged);\n-      Set_Is_Limited_Record (Derived_Type, Is_Limited_Record (Parent_Type));\n+      Set_Is_Limited_Record (Derived_Type,\n+        Is_Limited_Record (Parent_Type)\n+          and then not Is_Interface (Parent_Type));\n \n       --  STEP 2a: process discriminants of derived type if any\n \n@@ -5887,7 +5902,9 @@ package body Sem_Ch3 is\n       Set_Is_Limited_Composite\n         (Derived_Type, Is_Limited_Composite     (Parent_Type));\n       Set_Is_Limited_Record\n-        (Derived_Type, Is_Limited_Record        (Parent_Type));\n+        (Derived_Type,\n+           Is_Limited_Record        (Parent_Type)\n+             and then not Is_Interface (Parent_Type));\n       Set_Is_Private_Composite\n         (Derived_Type, Is_Private_Composite     (Parent_Type));\n \n@@ -7646,7 +7663,7 @@ package body Sem_Ch3 is\n          end if;\n       end Add_Interface;\n \n-   --  Start of processing for Add_Interface\n+   --  Start of processing for Collect_Interfaces\n \n    begin\n       pragma Assert (False\n@@ -7682,29 +7699,6 @@ package body Sem_Ch3 is\n \n             Next (Intf);\n          end loop;\n-\n-      --  A type extension may be written as a derivation from an interface.\n-      --  The completion will have to implement the same, or derive from a\n-      --  type that implements it as well.\n-\n-      elsif Nkind (N) = N_Private_Extension_Declaration\n-        and then Is_Interface (Etype (Derived_Type))\n-      then\n-         Add_Interface (Etype (Derived_Type));\n-      end if;\n-\n-      --  Same for task and protected types, that can derive directly from\n-      --  an interface (and implement additional interfaces that will be\n-      --  present in the interface list of the declaration).\n-\n-      if Nkind (N) = N_Task_Type_Declaration\n-        or else Nkind (N) = N_Protected_Type_Declaration\n-        or else Nkind (N) = N_Single_Protected_Declaration\n-        or else Nkind (N) = N_Single_Task_Declaration\n-      then\n-         if Is_Interface (Etype (Derived_Type)) then\n-            Add_Interface (Etype (Derived_Type));\n-         end if;\n       end if;\n    end Collect_Interfaces;\n \n@@ -9719,24 +9713,42 @@ package body Sem_Ch3 is\n          New_Compon : constant Entity_Id := New_Copy (Old_Compon);\n \n       begin\n-         --  Set the parent so we have a proper link for freezing etc. This\n-         --  is not a real parent pointer, since of course our parent does\n-         --  not own up to us and reference us, we are an illegitimate\n-         --  child of the original parent!\n+         --  Set the parent so we have a proper link for freezing etc. This is\n+         --  not a real parent pointer, since of course our parent does not own\n+         --  up to us and reference us, we are an illegitimate child of the\n+         --  original parent!\n \n          Set_Parent (New_Compon, Parent (Old_Compon));\n \n+         --  If the old component's Esize was already determined and is a\n+         --  static value, then the new component simply inherits it. Otherwise\n+         --  the old component's size may require run-time determination, but\n+         --  the new component's size still might be statically determinable\n+         --  (if, for example it has a static constraint). In that case we want\n+         --  Layout_Type to recompute the component's size, so we reset its\n+         --  size and positional fields.\n+\n+         if Frontend_Layout_On_Target\n+           and then not Known_Static_Esize (Old_Compon)\n+         then\n+            Set_Esize (New_Compon, Uint_0);\n+            Init_Normalized_First_Bit    (New_Compon);\n+            Init_Normalized_Position     (New_Compon);\n+            Init_Normalized_Position_Max (New_Compon);\n+         end if;\n+\n          --  We do not want this node marked as Comes_From_Source, since\n-         --  otherwise it would get first class status and a separate\n-         --  cross-reference line would be generated. Illegitimate\n-         --  children do not rate such recognition.\n+         --  otherwise it would get first class status and a separate cross-\n+         --  reference line would be generated. Illegitimate children do not\n+         --  rate such recognition.\n \n          Set_Comes_From_Source (New_Compon, False);\n \n-         --  But it is a real entity, and a birth certificate must be\n-         --  properly registered by entering it into the entity list.\n+         --  But it is a real entity, and a birth certificate must be properly\n+         --  registered by entering it into the entity list.\n \n          Enter_Name (New_Compon);\n+\n          return New_Compon;\n       end Create_Component;\n \n@@ -10749,6 +10761,13 @@ package body Sem_Ch3 is\n \n                if not Is_Interface (T) then\n                   Error_Msg_NE (\"(Ada 2005) & must be an interface\", Intf, T);\n+\n+               elsif Limited_Present (Def)\n+                 and then not Is_Limited_Interface (T)\n+               then\n+                  Error_Msg_NE\n+                   (\"progenitor interface& of limited type must be limited\",\n+                     N, T);\n                end if;\n \n                Next (Intf);\n@@ -10782,6 +10801,100 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n+      --  Ada 2005 (AI-251): The case in which the parent of the full-view is\n+      --  an interface is special because the list of interfaces in the full\n+      --  view can be given in any order. For example:\n+\n+      --     type A is interface;\n+      --     type B is interface and A;\n+      --     type D is new B with private;\n+      --   private\n+      --     type D is new A and B with null record; -- 1 --\n+\n+      --  In this case we perform the following transformation of -1-:\n+\n+      --     type D is new B and A with null record;\n+\n+      --  If the parent of the full-view covers the parent of the partial-view\n+      --  we have two possible cases:\n+\n+      --     1) They have the same parent\n+      --     2) The parent of the full-view implements some further interfaces\n+\n+      --  In both cases we do not need to perform the transformation. In the\n+      --  first case the source program is correct and the transformation is\n+      --  not needed; in the second case the source program does not fulfill\n+      --  the no-hidden interfaces rule (AI-396) and the error will be reported\n+      --  later.\n+\n+      --  This transformation not only simplifies the rest of the analysis of\n+      --  this type declaration but also simplifies the correct generation of\n+      --  the object layout to the expander.\n+\n+      if In_Private_Part (Current_Scope)\n+        and then Is_Interface (Parent_Type)\n+      then\n+         declare\n+            Iface               : Node_Id;\n+            Partial_View        : Entity_Id;\n+            Partial_View_Parent : Entity_Id;\n+            New_Iface           : Node_Id;\n+\n+         begin\n+            --  Look for the associated private type declaration\n+\n+            Partial_View := First_Entity (Current_Scope);\n+            loop\n+               exit when not Present (Partial_View)\n+                 or else (Has_Private_Declaration (Partial_View)\n+                           and then Full_View (Partial_View) = T);\n+\n+               Next_Entity (Partial_View);\n+            end loop;\n+\n+            --  If the partial view was not found then the source code has\n+            --  errors and the transformation is not needed.\n+\n+            if Present (Partial_View) then\n+               Partial_View_Parent := Etype (Partial_View);\n+\n+               --  If the parent of the full-view covers the parent of the\n+               --  partial-view we have nothing else to do.\n+\n+               if Interface_Present_In_Ancestor\n+                    (Parent_Type, Partial_View_Parent)\n+               then\n+                  null;\n+\n+               --  Traverse the list of interfaces of the full-view to look\n+               --  for the parent of the partial-view and perform the tree\n+               --  transformation.\n+\n+               else\n+                  Iface := First (Interface_List (Def));\n+                  while Present (Iface) loop\n+                     if Etype (Iface) = Etype (Partial_View) then\n+                        Rewrite (Subtype_Indication (Def),\n+                          New_Copy (Subtype_Indication\n+                                     (Parent (Partial_View))));\n+\n+                        New_Iface := Make_Identifier (Sloc (N),\n+                                       Chars (Parent_Type));\n+                        Append (New_Iface, Interface_List (Def));\n+\n+                        --  Analyze the transformed code\n+\n+                        Derived_Type_Declaration (T, N, Is_Completion);\n+                        return;\n+                     end if;\n+\n+                     Next (Iface);\n+                  end loop;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Only composite types other than array types are allowed to have\n       --  discriminants.\n \n@@ -10905,6 +11018,20 @@ package body Sem_Ch3 is\n       end if;\n \n       Build_Derived_Type (N, Parent_Type, T, Is_Completion);\n+\n+      --  AI-419:  the parent type of an explicitly limited derived type must\n+      --  be limited. Interface progenitors were checked earlier.\n+\n+      if Limited_Present (Def) then\n+         Set_Is_Limited_Record (T);\n+\n+         if not Is_Limited_Type (Parent_Type)\n+           and then not Is_Interface (Parent_Type)\n+         then\n+            Error_Msg_NE (\"parent type& of limited type must be limited\",\n+              N, Parent_Type);\n+         end if;\n+      end if;\n    end Derived_Type_Declaration;\n \n    ----------------------------------\n@@ -13186,36 +13313,136 @@ package body Sem_Ch3 is\n       Full_Parent : Entity_Id;\n       Full_Indic  : Node_Id;\n \n-      function Find_Ancestor_Interface\n-        (Typ : Entity_Id) return Entity_Id;\n-      --  Find an implemented interface in the derivation chain of Typ\n+      procedure Collect_Implemented_Interfaces\n+        (Typ    : Entity_Id;\n+         Ifaces : Elist_Id);\n+      --  Ada 2005: Gather all the interfaces that Typ directly or\n+      --  inherently implements. Duplicate entries are not added to\n+      --  the list Ifaces.\n+\n+      function Contain_Interface\n+        (Iface  : Entity_Id;\n+         Ifaces : Elist_Id) return Boolean;\n+      --  Ada 2005: Determine whether Iface is present in the list Ifaces\n+\n+      function Find_Hidden_Interface\n+        (Src  : Elist_Id;\n+         Dest : Elist_Id) return Entity_Id;\n+      --  Ada 2005: Determine whether the interfaces in list Src are all\n+      --  present in the list Dest. Return the first differing interface,\n+      --  or Empty otherwise.\n \n-      -----------------------------\n-      -- Find_Ancestor_Interface --\n-      -----------------------------\n+      ------------------------------------\n+      -- Collect_Implemented_Interfaces --\n+      ------------------------------------\n \n-      function Find_Ancestor_Interface\n-        (Typ : Entity_Id) return Entity_Id\n+      procedure Collect_Implemented_Interfaces\n+        (Typ    : Entity_Id;\n+         Ifaces : Elist_Id)\n       is\n-         T : Entity_Id;\n+         Iface      : Entity_Id;\n+         Iface_Elmt : Elmt_Id;\n \n       begin\n-         T := Typ;\n-         while T /= Etype (T) loop\n-            if Is_Interface (Etype (T)) then\n-               return Etype (T);\n-            end if;\n+         --  Implementations of the form:\n+         --    type Typ is new Iface ...\n \n-            T := Etype (T);\n+         if Is_Interface (Etype (Typ))\n+           and then not Contain_Interface (Etype (Typ), Ifaces)\n+         then\n+            Append_Elmt (Etype (Typ), Ifaces);\n+         end if;\n \n-            --  Protect us against erroneous code that has a large\n-            --  chain of circularity dependencies\n+         --  Implementations of the form:\n+         --    type Typ is ... and Iface ...\n \n-            exit when T = Typ;\n-         end loop;\n+         if Present (Abstract_Interfaces (Typ)) then\n+            Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+            while Present (Iface_Elmt) loop\n+               Iface := Node (Iface_Elmt);\n+\n+               if Is_Interface (Iface)\n+                 and then not Contain_Interface (Iface, Ifaces)\n+               then\n+                  Append_Elmt (Iface, Ifaces);\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n+\n+         --  Implementations of the form:\n+         --    type Typ is new Parent_Typ and ...\n+\n+         if Ekind (Typ) = E_Record_Type\n+           and then Present (Parent_Subtype (Typ))\n+         then\n+            Collect_Implemented_Interfaces (Parent_Subtype (Typ), Ifaces);\n+\n+         --  Implementations of the form:\n+         --    type Typ is ... with private;\n+\n+         elsif Ekind (Typ) = E_Record_Type_With_Private\n+           and then Present (Full_View (Typ))\n+           and then Etype (Typ) /= Full_View (Typ)\n+           and then Etype (Typ) /= Typ\n+         then\n+            Collect_Implemented_Interfaces (Etype (Typ), Ifaces);\n+         end if;\n+      end Collect_Implemented_Interfaces;\n+\n+      -----------------------\n+      -- Contain_Interface --\n+      -----------------------\n+\n+      function Contain_Interface\n+        (Iface  : Entity_Id;\n+         Ifaces : Elist_Id) return Boolean\n+      is\n+         Iface_Elmt : Elmt_Id;\n+\n+      begin\n+         if Present (Ifaces) then\n+            Iface_Elmt := First_Elmt (Ifaces);\n+            while Present (Iface_Elmt) loop\n+               if Node (Iface_Elmt) = Iface then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Contain_Interface;\n+\n+      ---------------------------\n+      -- Find_Hidden_Interface --\n+      ---------------------------\n+\n+      function Find_Hidden_Interface\n+        (Src  : Elist_Id;\n+         Dest : Elist_Id) return Entity_Id\n+      is\n+         Iface      : Entity_Id;\n+         Iface_Elmt : Elmt_Id;\n+\n+      begin\n+         if Present (Src) and then Present (Dest) then\n+            Iface_Elmt := First_Elmt (Src);\n+            while Present (Iface_Elmt) loop\n+               Iface := Node (Iface_Elmt);\n+\n+               if not Contain_Interface (Iface, Dest) then\n+                  return Iface;\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n \n          return Empty;\n-      end Find_Ancestor_Interface;\n+      end Find_Hidden_Interface;\n \n    --  Start of processing for Process_Full_View\n \n@@ -13255,49 +13482,28 @@ package body Sem_Ch3 is\n          Error_Msg_N (\"generic type cannot have a completion\", Full_T);\n       end if;\n \n-      --  Ada 2005 (AI-396): A full view shall be a descendant of an\n-      --  interface type if and only if the corresponding partial view\n-      --  (if any) is also a descendant of the interface type, or if\n-      --  the partial view is untagged.\n-\n       if Ada_Version >= Ada_05\n+        and then Is_Tagged_Type (Priv_T)\n         and then Is_Tagged_Type (Full_T)\n       then\n          declare\n-            Iface     : Entity_Id;\n-            Iface_Def : Node_Id;\n+            Iface         : Entity_Id;\n+            Priv_T_Ifaces : constant Elist_Id := New_Elmt_List;\n+            Full_T_Ifaces : constant Elist_Id := New_Elmt_List;\n \n          begin\n-            Iface := Find_Ancestor_Interface (Full_T);\n-\n-            if Present (Iface) then\n-               Iface_Def := Type_Definition (Parent (Iface));\n-\n-               --  The full view derives from an interface descendant, but the\n-               --  partial view does not share the same tagged type.\n+            Collect_Implemented_Interfaces (Priv_T, Priv_T_Ifaces);\n+            Collect_Implemented_Interfaces (Full_T, Full_T_Ifaces);\n \n-               if Is_Tagged_Type (Priv_T)\n-                 and then Etype (Priv_T) /= Etype (Full_T)\n-                 and then Etype (Priv_T) /= Iface\n-               then\n-                  Error_Msg_N (\"(Ada 2005) tagged partial view cannot be \" &\n-                               \"completed by a type that implements an \" &\n-                               \"interface\", Priv_T);\n-               end if;\n+            --  Ada 2005 (AI-396): The partial view shall be a descendant of\n+            --  an interface type if and only if the full view is a descendant\n+            --  of the interface type.\n \n-               --  The full view derives from a limited, protected,\n-               --  synchronized or task interface descendant, but the\n-               --  partial view is not labeled as limited.\n+            Iface := Find_Hidden_Interface (Full_T_Ifaces, Priv_T_Ifaces);\n \n-               if (Limited_Present               (Iface_Def)\n-                    or else Protected_Present    (Iface_Def)\n-                    or else Synchronized_Present (Iface_Def)\n-                    or else Task_Present         (Iface_Def))\n-                 and then not Limited_Present (Parent (Priv_T))\n-               then\n-                  Error_Msg_N (\"(Ada 2005) non-limited private type cannot be \"\n-                               & \"completed by a limited type\", Priv_T);\n-               end if;\n+            if Present (Iface) then\n+               Error_Msg_NE (\"interface & not implemented by partial view \" &\n+                             \"('R'M'-2005 7.3(9))\", Full_T, Iface);\n             end if;\n          end;\n       end if;\n@@ -13328,6 +13534,15 @@ package body Sem_Ch3 is\n          if Priv_Parent = Any_Type or else Full_Parent = Any_Type then\n             return;\n \n+         --  Ada 2005 (AI-251): Interfaces in the full-typ can be given in\n+         --  any order. Therefore we don't have to check that its parent must\n+         --  be a descendant of the parent of the private type declaration.\n+\n+         elsif Is_Interface (Priv_Parent)\n+           and then Is_Interface (Full_Parent)\n+         then\n+            null;\n+\n          elsif not Is_Ancestor (Base_Type (Priv_Parent), Full_Parent) then\n             Error_Msg_N\n               (\"parent of full type must descend from parent\"\n@@ -13428,6 +13643,23 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  AI-419: verify that the use of \"limited\" is consistent\n+\n+      declare\n+         Orig_Decl : constant Node_Id := Original_Node (N);\n+      begin\n+         if Nkind (Parent (Priv_T)) = N_Private_Extension_Declaration\n+           and then not Limited_Present (Parent (Priv_T))\n+           and then Nkind (Orig_Decl) = N_Full_Type_Declaration\n+           and then Nkind\n+             (Type_Definition (Orig_Decl)) = N_Derived_Type_Definition\n+           and then Limited_Present (Type_Definition (Orig_Decl))\n+         then\n+            Error_Msg_N\n+              (\"full view of non-limited extension cannot be limited\", N);\n+         end if;\n+      end;\n+\n       --  Ada 2005 AI-363: if the full view has discriminants with\n       --  defaults, it is illegal to declare constrained access subtypes\n       --  whose designated type is the current type. This allows objects\n@@ -14072,8 +14304,7 @@ package body Sem_Ch3 is\n          if Nkind (Parent (S)) /= N_Access_To_Object_Definition\n            and then not\n             (Nkind (Parent (S)) = N_Subtype_Declaration\n-              and then\n-             Is_Itype (Defining_Identifier (Parent (S))))\n+              and then Is_Itype (Defining_Identifier (Parent (S))))\n          then\n             Check_Incomplete (Subtype_Mark (S));\n          end if;"}, {"sha": "dc53ec01a8b508bfbab9830e5624bcc6b77e3b9d", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -1692,6 +1692,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Formal_Derived_Type_Definition\n         or else NT (N).Nkind = N_Formal_Private_Type_Definition\n         or else NT (N).Nkind = N_Private_Extension_Declaration\n         or else NT (N).Nkind = N_Private_Type_Declaration\n@@ -4278,6 +4279,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Derived_Type_Definition\n+        or else NT (N).Nkind = N_Formal_Derived_Type_Definition\n         or else NT (N).Nkind = N_Formal_Private_Type_Definition\n         or else NT (N).Nkind = N_Private_Extension_Declaration\n         or else NT (N).Nkind = N_Private_Type_Declaration"}, {"sha": "bf5edbc4e65c5eb689b1136382e6abaaa3b51de1", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 759, "deletions": 773, "changes": 1532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=653da906036b7c3bd8c573fed889ddc151fce7c6"}, {"sha": "08e6cf892a6680913746adcc055acd512bd891ae", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 296, "deletions": 10, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -193,7 +193,7 @@ package body Sprint is\n    --  declarations that can have discriminants.\n \n    procedure Write_Ekind (E : Entity_Id);\n-   --  Write the String corresponding to the Ekind without \"E_\".\n+   --  Write the String corresponding to the Ekind without \"E_\"\n \n    procedure Write_Id (N : Node_Id);\n    --  N is a node with a Chars field. This procedure writes the name that\n@@ -203,7 +203,8 @@ package body Sprint is\n    --  the name associated with the entity (since it may have been encoded).\n    --  One other special case is that an entity has an active external name\n    --  (i.e. an external name present with no address clause), then this\n-   --  external name is output.\n+   --  external name is output. This procedure also deals with outputting\n+   --  declarations of referenced itypes, if not output earlier.\n \n    function Write_Identifiers (Node : Node_Id) return Boolean;\n    --  Handle node where the grammar has a list of defining identifiers, but\n@@ -238,6 +239,10 @@ package body Sprint is\n    --  the Sloc of the current node is set to the first non-blank character\n    --  in the string S.\n \n+   procedure Write_Itype (Typ : Entity_Id);\n+   --  If Typ is an Itype that has not been written yet, write it. If Typ is\n+   --  any other kind of entity or tree node, the call is ignored.\n+\n    procedure Write_Name_With_Col_Check (N : Name_Id);\n    --  Write name (using Write_Name) with initial column check, and possible\n    --  initial Write_Indent (to get new line) if current line is too full.\n@@ -272,6 +277,11 @@ package body Sprint is\n    --  Like Write_Str_WIth_Col_Check, but sets debug Sloc of current debug\n    --  node to first non-blank character if a current debug node is active.\n \n+   procedure Write_Uint_With_Col_Check (U : Uint; Format : UI_Format);\n+   --  Write Uint (using UI_Write) with initial column check, and possible\n+   --  initial Write_Indent (to get new line) if current line is too full.\n+   --  The format parameter determines the output format (see UI_Write).\n+\n    procedure Write_Uint_With_Col_Check_Sloc (U : Uint; Format : UI_Format);\n    --  Write Uint (using UI_Write) with initial column check, and possible\n    --  initial Write_Indent (to get new line) if current line is too full.\n@@ -417,7 +427,7 @@ package body Sprint is\n          Write_Eol;\n       end Underline;\n \n-   --  Start of processing for Tree_Dump.\n+   --  Start of processing for Tree_Dump\n \n    begin\n       Dump_Generated_Only := Debug_Flag_G or\n@@ -1078,7 +1088,6 @@ package body Sprint is\n                Condition : constant Node_Id := First (Expressions (Node));\n                Then_Expr : constant Node_Id := Next (Condition);\n                Else_Expr : constant Node_Id := Next (Then_Expr);\n-\n             begin\n                Write_Str_With_Col_Check_Sloc (\"(if \");\n                Sprint_Node (Condition);\n@@ -2344,7 +2353,6 @@ package body Sprint is\n \n             declare\n                Alt_Node : Node_Id;\n-\n             begin\n                Alt_Node := First (Select_Alternatives (Node));\n                loop\n@@ -2607,7 +2615,6 @@ package body Sprint is\n \n             declare\n                Node1 : Node_Id;\n-\n             begin\n                Node1 := First (Subtype_Marks (Node));\n                loop\n@@ -2808,9 +2815,7 @@ package body Sprint is\n \n          if Dump_Original_Only then\n             N := First (List);\n-\n             while Present (N) loop\n-\n                if not Is_Rewrite_Insertion (N) then\n                   Node_Exists := True;\n                   exit;\n@@ -2944,6 +2949,19 @@ package body Sprint is\n \n    procedure Write_Id (N : Node_Id) is\n    begin\n+      --  Deal with outputting Itype\n+\n+      --  Note: if we are printing the full tree with -gnatds, then we may\n+      --  end up picking up the Associated_Node link from a generic template\n+      --  here which overlaps the Entity field, but as documented, Write_Itype\n+      --  is defended against junk calls.\n+\n+      if Nkind (N) in N_Entity then\n+         Write_Itype (N);\n+      elsif Nkind (N) in N_Has_Entity then\n+         Write_Itype (Entity (N));\n+      end if;\n+\n       --  Case of a defining identifier\n \n       if Nkind (N) = N_Defining_Identifier then\n@@ -3022,7 +3040,6 @@ package body Sprint is\n             Write_Str_With_Col_Check (\" (\");\n \n             Ind := First_Index (E);\n-\n             while Present (Ind) loop\n                Sprint_Node (Ind);\n                Next_Index (Ind);\n@@ -3153,6 +3170,266 @@ package body Sprint is\n       Write_Str_Sloc (S);\n    end Write_Indent_Str_Sloc;\n \n+   -----------------\n+   -- Write_Itype --\n+   -----------------\n+\n+   procedure Write_Itype (Typ : Entity_Id) is\n+\n+      procedure Write_Header (T : Boolean := True);\n+      --  Write type if T is True, subtype if T is false\n+\n+      ------------------\n+      -- Write_Header --\n+      ------------------\n+\n+      procedure Write_Header (T : Boolean := True) is\n+      begin\n+         if T then\n+            Write_Str (\"[type \");\n+         else\n+            Write_Str (\"[subtype \");\n+         end if;\n+\n+         Write_Name_With_Col_Check (Chars (Typ));\n+         Write_Str (\" is \");\n+      end Write_Header;\n+\n+   --  Start of processing for Write_Itype\n+\n+   begin\n+      if Nkind (Typ) in N_Entity\n+        and then Is_Itype (Typ)\n+        and then not Itype_Printed (Typ)\n+      then\n+         --  Itype to be printed\n+\n+         declare\n+            B : constant Node_Id := Etype (Typ);\n+            X : Node_Id;\n+            P : constant Node_Id := Parent (Typ);\n+\n+            S : constant Saved_Output_Buffer := Save_Output_Buffer;\n+            --  Save current output buffer\n+\n+         begin\n+            --  Write indentation at start of line\n+\n+            for J in 1 .. Indent loop\n+               Write_Char (' ');\n+            end loop;\n+\n+            --  If we have a constructed declaration, print it\n+\n+            if Present (P) and then Nkind (P) in N_Declaration then\n+\n+               --  We must set Itype_Printed true before the recursive call to\n+               --  print the node, otherwise we get an infinite recursion!\n+\n+               Set_Itype_Printed (Typ, True);\n+\n+               --  Write the declaration enclosed in [], avoiding new line\n+               --  at start of declaration, and semicolon at end.\n+\n+               Write_Char ('[');\n+               Indent_Annull_Flag := True;\n+               Sprint_Node (P);\n+               Write_Erase_Char (';');\n+\n+            --  If no constructed declaration, then we have to concoct the\n+            --  source corresponding to the type entity that we have at hand.\n+\n+            else\n+               case Ekind (Typ) is\n+\n+                  --  Access types and subtypes\n+\n+                  when Access_Kind =>\n+                     Write_Header (Ekind (Typ) = E_Access_Type);\n+                     Write_Str (\"access \");\n+\n+                     if Is_Access_Constant (Typ) then\n+                        Write_Str (\"constant \");\n+                     elsif Can_Never_Be_Null (Typ) then\n+                        Write_Str (\"not null \");\n+                     end if;\n+\n+                     Write_Id (Directly_Designated_Type (Typ));\n+\n+                     --  Array types and string types\n+\n+                  when E_Array_Type | E_String_Type =>\n+                     Write_Header;\n+                     Write_Str (\"array (\");\n+\n+                     X := First_Index (Typ);\n+                     loop\n+                        Sprint_Node (X);\n+\n+                        if not Is_Constrained (Typ) then\n+                           Write_Str (\" range <>\");\n+                        end if;\n+\n+                        Next_Index (X);\n+                        exit when No (X);\n+                        Write_Str (\", \");\n+                     end loop;\n+\n+                     Write_Str (\") of \");\n+                     Sprint_Node (Component_Type (Typ));\n+\n+                     --  Array subtypes and string subtypes\n+\n+                  when E_Array_Subtype | E_String_Subtype =>\n+                     Write_Header (False);\n+                     Write_Id (Etype (Typ));\n+                     Write_Str (\" (\");\n+\n+                     X := First_Index (Typ);\n+                     loop\n+                        Sprint_Node (X);\n+                        Next_Index (X);\n+                        exit when No (X);\n+                        Write_Str (\", \");\n+                     end loop;\n+\n+                     Write_Char (')');\n+\n+                     --  Signed integer types, and modular integer subtypes\n+\n+                  when E_Signed_Integer_Type     |\n+                       E_Signed_Integer_Subtype  |\n+                       E_Modular_Integer_Subtype =>\n+\n+                     Write_Header (Ekind (Typ) = E_Signed_Integer_Type);\n+\n+                     if Ekind (Typ) = E_Signed_Integer_Type then\n+                        Write_Str (\"new \");\n+                     end if;\n+\n+                     Write_Id (B);\n+\n+                     --  Print bounds if not different from base type\n+\n+                     declare\n+                        L  : constant Node_Id := Type_Low_Bound (Typ);\n+                        H  : constant Node_Id := Type_High_Bound (Typ);\n+                        LE : constant Node_Id := Type_Low_Bound (B);\n+                        HE : constant Node_Id := Type_High_Bound (B);\n+\n+                     begin\n+                        if Nkind (L) = N_Integer_Literal\n+                          and then Nkind (H) = N_Integer_Literal\n+                          and then Nkind (LE) = N_Integer_Literal\n+                          and then Nkind (HE) = N_Integer_Literal\n+                          and then UI_Eq (Intval (L), Intval (LE))\n+                          and then UI_Eq (Intval (H), Intval (HE))\n+                        then\n+                           null;\n+\n+                        else\n+                           Write_Str (\" range \");\n+                           Sprint_Node (Type_Low_Bound (Typ));\n+                           Write_Str (\" .. \");\n+                           Sprint_Node (Type_High_Bound (Typ));\n+                        end if;\n+                     end;\n+\n+                     --  Modular integer types\n+\n+                  when E_Modular_Integer_Type =>\n+                     Write_Header;\n+                     Write_Str (\" mod \");\n+                     Write_Uint_With_Col_Check (Modulus (Typ), Auto);\n+\n+                     --  Floating point types and subtypes\n+\n+                  when E_Floating_Point_Type    |\n+                       E_Floating_Point_Subtype =>\n+\n+                     Write_Header (Ekind (Typ) = E_Floating_Point_Type);\n+\n+                     if Ekind (Typ) = E_Floating_Point_Type then\n+                        Write_Str (\"new \");\n+                     end if;\n+\n+                     Write_Id (Etype (Typ));\n+\n+                     if Digits_Value (Typ) /= Digits_Value (Etype (Typ)) then\n+                        Write_Str (\" digits \");\n+                        Write_Uint_With_Col_Check\n+                          (Digits_Value (Typ), Decimal);\n+                     end if;\n+\n+                     --  Print bounds if not different from base type\n+\n+                     declare\n+                        L  : constant Node_Id := Type_Low_Bound (Typ);\n+                        H  : constant Node_Id := Type_High_Bound (Typ);\n+                        LE : constant Node_Id := Type_Low_Bound (B);\n+                        HE : constant Node_Id := Type_High_Bound (B);\n+\n+                     begin\n+                        if Nkind (L) = N_Real_Literal\n+                          and then Nkind (H) = N_Real_Literal\n+                          and then Nkind (LE) = N_Real_Literal\n+                          and then Nkind (HE) = N_Real_Literal\n+                          and then UR_Eq (Realval (L), Realval (LE))\n+                          and then UR_Eq (Realval (H), Realval (HE))\n+                        then\n+                           null;\n+\n+                        else\n+                           Write_Str (\" range \");\n+                           Sprint_Node (Type_Low_Bound (Typ));\n+                           Write_Str (\" .. \");\n+                           Sprint_Node (Type_High_Bound (Typ));\n+                        end if;\n+                     end;\n+\n+                  --  Record subtypes\n+\n+                  when E_Record_Subtype =>\n+                     Write_Header (False);\n+                     Write_Str (\"record\");\n+                     Indent_Begin;\n+\n+                     declare\n+                        C : Entity_Id;\n+                     begin\n+                        C := First_Entity (Typ);\n+                        while Present (C) loop\n+                           Write_Indent;\n+                           Write_Id (C);\n+                           Write_Str (\" : \");\n+                           Write_Id (Etype (C));\n+                           Next_Entity (C);\n+                        end loop;\n+                     end;\n+\n+                     Indent_End;\n+                     Write_Indent_Str (\" end record\");\n+\n+                     --  For all other Itypes, print ??? (fill in later)\n+\n+                  when others =>\n+                     Write_Header (True);\n+                     Write_Str (\"???\");\n+\n+               end case;\n+            end if;\n+\n+            --  Add terminating bracket and restore output buffer\n+\n+            Write_Char (']');\n+            Write_Eol;\n+            Restore_Output_Buffer (S);\n+         end;\n+\n+         Set_Itype_Printed (Typ);\n+      end if;\n+   end Write_Itype;\n+\n    -------------------------------\n    -- Write_Name_With_Col_Check --\n    -------------------------------\n@@ -3167,7 +3444,6 @@ package body Sprint is\n       --  name by three dots (e.g. R7b becomes R...b).\n \n       if Debug_Flag_II and then Name_Buffer (1) in 'A' .. 'Z' then\n-\n          J := 2;\n          while J < Name_Len loop\n             exit when Name_Buffer (J) not in 'A' .. 'Z';\n@@ -3355,6 +3631,16 @@ package body Sprint is\n       end if;\n    end Write_Str_With_Col_Check_Sloc;\n \n+   -------------------------------\n+   -- Write_Uint_With_Col_Check --\n+   -------------------------------\n+\n+   procedure Write_Uint_With_Col_Check (U : Uint; Format : UI_Format) is\n+   begin\n+      Col_Check (UI_Decimal_Digits_Hi (U));\n+      UI_Write (U, Format);\n+   end Write_Uint_With_Col_Check;\n+\n    ------------------------------------\n    -- Write_Uint_With_Col_Check_Sloc --\n    ------------------------------------"}, {"sha": "997e7a4bd222a9f81fa18ff210f749a3026df7a7", "filename": "gcc/ada/sprint.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsprint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/653da906036b7c3bd8c573fed889ddc151fce7c6/gcc%2Fada%2Fsprint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.ads?ref=653da906036b7c3bd8c573fed889ddc151fce7c6", "patch": "@@ -58,6 +58,7 @@ package Sprint is\n    --    Freeze entity with freeze actions   freeze entityname [ actions ]\n    --    Interpretation                      interpretation type [, entity]\n    --    Intrinsic calls                     function-name!(arg, arg, arg)\n+   --    Itype declaration                   [(sub)type declaration without ;]\n    --    Itype reference                     reference itype\n    --    Label declaration                   labelname : label\n    --    Mod wi Treat_Fixed_As_Integer       x #mod y"}]}