{"sha": "d406b663d0e9973eeb9211409fe35d70b973db34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQwNmI2NjNkMGU5OTczZWViOTIxMTQwOWZlMzVkNzBiOTczZGIzNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-07-09T19:32:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-07-09T19:32:54Z"}, "message": "gimplify.c (struct gimplify_ctx): Move to tree-gimple.h.\n\n\t* gimplify.c (struct gimplify_ctx): Move to tree-gimple.h.\n\t(push_gimplify_context): Don't allocate temp_htab nor c itself here.\n\tAdd c argument.\n\t(pop_gimplify_context): Check c->temp_htab instead of optimize whether\n\thtab_delete should be called.  Don't free c.\n\t(lookup_tmp_var): Create temp_htab lazily.\n\t(gimplify_scan_omp_clauses, gimplify_omp_parallel, gimplify_omp_task,\n\tgimplify_body, force_gimple_operand): Adjust push_gimplify_context\n\tcallers.\n\t* omp-low.c (lower_omp_sections, lower_omp_single, lower_omp_master,\n\tlower_omp_ordered, lower_omp_critical, lower_omp_for,\n\tcreate_task_copyfn, lower_omp_taskreg, execute_lower_omp): \n\t* tree-ssa-ccp.c (convert_to_gimple_builtin): Likewise.\n\t* tree-sra.c (generate_element_init): Likewise.\n\t* tree-mudflap.c (execute_mudflap_function_ops,\n\texecute_mudflap_function_decls): Likewise.\n\t* tree-inline.c (setup_one_parameter, optimize_inline_calls): Likewise.\n\t* tree-gimple.h (struct gimplify_ctx): New type.\n\t(push_gimplify_context): Adjust prototype.\n\nFrom-SVN: r137666", "tree": {"sha": "36739d69af4b92f19e771bb69a776ef920375013", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36739d69af4b92f19e771bb69a776ef920375013"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d406b663d0e9973eeb9211409fe35d70b973db34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d406b663d0e9973eeb9211409fe35d70b973db34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d406b663d0e9973eeb9211409fe35d70b973db34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d406b663d0e9973eeb9211409fe35d70b973db34/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0a0ab2d51723c6f19db57f9732d4c4ca7278f3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0a0ab2d51723c6f19db57f9732d4c4ca7278f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0a0ab2d51723c6f19db57f9732d4c4ca7278f3d"}], "stats": {"total": 147, "additions": 95, "deletions": 52}, "files": [{"sha": "4cb2caea99f0acf3ddb3b2d08715e73243ff28e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -1,3 +1,25 @@\n+2008-07-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (struct gimplify_ctx): Move to tree-gimple.h.\n+\t(push_gimplify_context): Don't allocate temp_htab nor c itself here.\n+\tAdd c argument.\n+\t(pop_gimplify_context): Check c->temp_htab instead of optimize whether\n+\thtab_delete should be called.  Don't free c.\n+\t(lookup_tmp_var): Create temp_htab lazily.\n+\t(gimplify_scan_omp_clauses, gimplify_omp_parallel, gimplify_omp_task,\n+\tgimplify_body, force_gimple_operand): Adjust push_gimplify_context\n+\tcallers.\n+\t* omp-low.c (lower_omp_sections, lower_omp_single, lower_omp_master,\n+\tlower_omp_ordered, lower_omp_critical, lower_omp_for,\n+\tcreate_task_copyfn, lower_omp_taskreg, execute_lower_omp): \n+\t* tree-ssa-ccp.c (convert_to_gimple_builtin): Likewise.\n+\t* tree-sra.c (generate_element_init): Likewise.\n+\t* tree-mudflap.c (execute_mudflap_function_ops,\n+\texecute_mudflap_function_decls): Likewise.\n+\t* tree-inline.c (setup_one_parameter, optimize_inline_calls): Likewise.\n+\t* tree-gimple.h (struct gimplify_ctx): New type.\n+\t(push_gimplify_context): Adjust prototype.\n+\n 2008-07-09  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-pre.c (phi_translate_1): Update placement of"}, {"sha": "b6bc9ca79a592b7a6248ca21e11c7cc2ea59defa", "filename": "gcc/gimplify.c", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -85,26 +85,6 @@ struct gimplify_omp_ctx\n   enum omp_region_type region_type;\n };\n \n-struct gimplify_ctx\n-{\n-  struct gimplify_ctx *prev_context;\n-\n-  tree current_bind_expr;\n-  tree temps;\n-  tree conditional_cleanups;\n-  tree exit_label;\n-  tree return_temp;\n-  \n-  VEC(tree,heap) *case_labels;\n-  /* The formal temporary table.  Should this be persistent?  */\n-  htab_t temp_htab;\n-\n-  int conditions;\n-  bool save_stack;\n-  bool into_ssa;\n-  bool allow_rhs_cond_expr;\n-};\n-\n static struct gimplify_ctx *gimplify_ctxp;\n static struct gimplify_omp_ctx *gimplify_omp_ctxp;\n \n@@ -169,15 +149,10 @@ gimple_tree_eq (const void *p1, const void *p2)\n /* Set up a context for the gimplifier.  */\n \n void\n-push_gimplify_context (void)\n+push_gimplify_context (struct gimplify_ctx *c)\n {\n-  struct gimplify_ctx *c;\n-\n-  c = (struct gimplify_ctx *) xcalloc (1, sizeof (struct gimplify_ctx));\n+  memset (c, '\\0', sizeof (*c));\n   c->prev_context = gimplify_ctxp;\n-  if (optimize)\n-    c->temp_htab = htab_create (1000, gimple_tree_hash, gimple_tree_eq, free);\n-\n   gimplify_ctxp = c;\n }\n \n@@ -202,9 +177,8 @@ pop_gimplify_context (tree body)\n   else\n     record_vars (c->temps);\n \n-  if (optimize)\n+  if (c->temp_htab)\n     htab_delete (c->temp_htab);\n-  free (c);\n }\n \n static void\n@@ -575,6 +549,9 @@ lookup_tmp_var (tree val, bool is_formal)\n       void **slot;\n \n       elt.val = val;\n+      if (gimplify_ctxp->temp_htab == NULL)\n+        gimplify_ctxp->temp_htab\n+\t  = htab_create (1000, gimple_tree_hash, gimple_tree_eq, free);\n       slot = htab_find_slot (gimplify_ctxp->temp_htab, (void *)&elt, INSERT);\n       if (*slot == NULL)\n \t{\n@@ -5105,6 +5082,7 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p,\n \t\t\t   enum omp_region_type region_type)\n {\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n+  struct gimplify_ctx gctx;\n   tree c;\n \n   ctx = new_omp_context (region_type);\n@@ -5161,10 +5139,10 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p,\n \t      omp_add_variable (ctx, OMP_CLAUSE_REDUCTION_PLACEHOLDER (c),\n \t\t\t\tGOVD_LOCAL | GOVD_SEEN);\n \t      gimplify_omp_ctxp = ctx;\n-\t      push_gimplify_context ();\n+\t      push_gimplify_context (&gctx);\n \t      gimplify_stmt (&OMP_CLAUSE_REDUCTION_INIT (c));\n \t      pop_gimplify_context (OMP_CLAUSE_REDUCTION_INIT (c));\n-\t      push_gimplify_context ();\n+\t      push_gimplify_context (&gctx);\n \t      gimplify_stmt (&OMP_CLAUSE_REDUCTION_MERGE (c));\n \t      pop_gimplify_context (OMP_CLAUSE_REDUCTION_MERGE (c));\n \t      gimplify_omp_ctxp = outer_ctx;\n@@ -5173,7 +5151,7 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p,\n \t\t   && OMP_CLAUSE_LASTPRIVATE_STMT (c))\n \t    {\n \t      gimplify_omp_ctxp = ctx;\n-\t      push_gimplify_context ();\n+\t      push_gimplify_context (&gctx);\n \t      if (TREE_CODE (OMP_CLAUSE_LASTPRIVATE_STMT (c)) != BIND_EXPR)\n \t\t{\n \t\t  tree bind = build3 (BIND_EXPR, void_type_node, NULL,\n@@ -5396,13 +5374,14 @@ static enum gimplify_status\n gimplify_omp_parallel (tree *expr_p, tree *pre_p)\n {\n   tree expr = *expr_p;\n+  struct gimplify_ctx gctx;\n \n   gimplify_scan_omp_clauses (&OMP_PARALLEL_CLAUSES (expr), pre_p,\n \t\t\t     OMP_PARALLEL_COMBINED (expr)\n \t\t\t     ? ORT_COMBINED_PARALLEL\n \t\t\t     : ORT_PARALLEL);\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   gimplify_stmt (&OMP_PARALLEL_BODY (expr));\n \n@@ -5425,10 +5404,11 @@ static enum gimplify_status\n gimplify_omp_task (tree *expr_p, tree *pre_p)\n {\n   tree expr = *expr_p;\n+  struct gimplify_ctx gctx;\n \n   gimplify_scan_omp_clauses (&OMP_TASK_CLAUSES (expr), pre_p, ORT_TASK);\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   gimplify_stmt (&OMP_TASK_BODY (expr));\n \n@@ -6653,11 +6633,12 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n {\n   location_t saved_location = input_location;\n   tree body, parm_stmts;\n+  struct gimplify_ctx gctx;\n \n   timevar_push (TV_TREE_GIMPLIFY);\n \n   gcc_assert (gimplify_ctxp == NULL);\n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   /* Unshare most shared trees in the body and in that of any nested functions.\n      It would seem we don't have to do this for nested functions because\n@@ -6799,6 +6780,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n   tree t;\n   enum gimplify_status ret;\n   gimple_predicate gimple_test_f;\n+  struct gimplify_ctx gctx;\n \n   *stmts = NULL_TREE;\n \n@@ -6807,7 +6789,7 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n \n   gimple_test_f = simple ? is_gimple_val : is_gimple_reg_rhs;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n   gimplify_ctxp->into_ssa = gimple_in_ssa_p (cfun);\n   gimplify_ctxp->allow_rhs_cond_expr = true;\n "}, {"sha": "4378c43d402b45cbdf4976cd2757f1e44a44d57b", "filename": "gcc/omp-low.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -5281,10 +5281,11 @@ lower_omp_sections (tree *stmt_p, omp_context *ctx)\n   tree t, dlist;\n   tree_stmt_iterator tsi;\n   unsigned i, len;\n+  struct gimplify_ctx gctx;\n \n   stmt = *stmt_p;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   dlist = NULL;\n   ilist = NULL;\n@@ -5482,8 +5483,9 @@ static void\n lower_omp_single (tree *stmt_p, omp_context *ctx)\n {\n   tree t, bind, block, single_stmt = *stmt_p, dlist;\n+  struct gimplify_ctx gctx;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   block = make_node (BLOCK);\n   *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n@@ -5526,8 +5528,9 @@ static void\n lower_omp_master (tree *stmt_p, omp_context *ctx)\n {\n   tree bind, block, stmt = *stmt_p, lab = NULL, x;\n+  struct gimplify_ctx gctx;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   block = make_node (BLOCK);\n   *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n@@ -5565,8 +5568,9 @@ static void\n lower_omp_ordered (tree *stmt_p, omp_context *ctx)\n {\n   tree bind, block, stmt = *stmt_p, x;\n+  struct gimplify_ctx gctx;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   block = make_node (BLOCK);\n   *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n@@ -5609,6 +5613,7 @@ lower_omp_critical (tree *stmt_p, omp_context *ctx)\n {\n   tree bind, block, stmt = *stmt_p;\n   tree t, lock, unlock, name;\n+  struct gimplify_ctx gctx;\n \n   name = OMP_CRITICAL_NAME (stmt);\n   if (name)\n@@ -5658,7 +5663,7 @@ lower_omp_critical (tree *stmt_p, omp_context *ctx)\n       unlock = build_call_expr (unlock, 0);\n     }\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   block = make_node (BLOCK);\n   *stmt_p = bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, block);\n@@ -5743,10 +5748,11 @@ lower_omp_for (tree *stmt_p, omp_context *ctx)\n   tree t, stmt, ilist, dlist, new_stmt, block, *body_p, *rhs_p;\n   struct omp_for_data fd;\n   int i;\n+  struct gimplify_ctx gctx;\n \n   stmt = *stmt_p;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   lower_omp (&OMP_FOR_PRE_BODY (stmt), ctx);\n   lower_omp (&OMP_FOR_BODY (stmt), ctx);\n@@ -5909,6 +5915,7 @@ create_task_copyfn (tree task_stmt, omp_context *ctx)\n   bool record_needs_remap = false, srecord_needs_remap = false;\n   splay_tree_node n;\n   struct omp_taskcopy_context tcctx;\n+  struct gimplify_ctx gctx;\n \n   child_fn = OMP_TASK_COPYFN (task_stmt);\n   child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n@@ -5921,7 +5928,7 @@ create_task_copyfn (tree task_stmt, omp_context *ctx)\n     DECL_CONTEXT (t) = child_fn;\n \n   /* Populate the function.  */\n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n   current_function_decl = child_fn;\n \n   bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n@@ -6138,6 +6145,7 @@ lower_omp_taskreg (tree *stmt_p, omp_context *ctx)\n   tree clauses, par_bind, par_body, new_body, bind;\n   tree olist, ilist, par_olist, par_ilist;\n   tree stmt, child_fn, t;\n+  struct gimplify_ctx gctx;\n \n   stmt = *stmt_p;\n \n@@ -6161,7 +6169,7 @@ lower_omp_taskreg (tree *stmt_p, omp_context *ctx)\n   if (ctx->srecord_type)\n     create_task_copyfn (stmt, ctx);\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   par_olist = NULL_TREE;\n   par_ilist = NULL_TREE;\n@@ -6422,8 +6430,10 @@ execute_lower_omp (void)\n \n   if (all_contexts->root)\n     {\n+      struct gimplify_ctx gctx;\n+\n       if (task_shared_vars)\n-\tpush_gimplify_context ();\n+\tpush_gimplify_context (&gctx);\n       lower_omp (&DECL_SAVED_TREE (current_function_decl), NULL);\n       if (task_shared_vars)\n \tpop_gimplify_context (NULL);"}, {"sha": "3691cbc56314b73487dee354cd8a6eacb232609a", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -118,14 +118,34 @@ enum gimplify_status {\n   GS_ALL_DONE\t= 1\t/* The expression is fully gimplified.  */\n };\n \n+struct gimplify_ctx\n+{\n+  struct gimplify_ctx *prev_context;\n+\n+  tree current_bind_expr;\n+  tree temps;\n+  tree conditional_cleanups;\n+  tree exit_label;\n+  tree return_temp;\n+  \n+  VEC(tree,heap) *case_labels;\n+  /* The formal temporary table.  Should this be persistent?  */\n+  htab_t temp_htab;\n+\n+  int conditions;\n+  bool save_stack;\n+  bool into_ssa;\n+  bool allow_rhs_cond_expr;\n+};\n+\n extern enum gimplify_status gimplify_expr (tree *, tree *, tree *,\n \t\t\t\t\t   bool (*) (tree), fallback_t);\n extern void gimplify_type_sizes (tree, tree *);\n extern void gimplify_one_sizepos (tree *, tree *);\n extern void gimplify_stmt (tree *);\n extern void gimplify_to_stmt_list (tree *);\n extern void gimplify_body (tree *, tree, bool);\n-extern void push_gimplify_context (void);\n+extern void push_gimplify_context (struct gimplify_ctx *);\n extern void pop_gimplify_context (tree);\n extern void gimplify_and_add (tree, tree *);\n "}, {"sha": "c0f4c880f7fb4ac9f7305b3796b09a3fdf56e158", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -1590,8 +1590,9 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t  || !is_gimple_reg (var))\n \t{\n           tree_stmt_iterator i;\n+          struct gimplify_ctx gctx;\n \n-\t  push_gimplify_context ();\n+\t  push_gimplify_context (&gctx);\n \t  gimplify_stmt (&init_stmt);\n \t  if (gimple_in_ssa_p (cfun)\n               && init_stmt && TREE_CODE (init_stmt) == STATEMENT_LIST)\n@@ -2986,6 +2987,8 @@ optimize_inline_calls (tree fn)\n   tree prev_fn;\n   basic_block bb;\n   int last = n_basic_blocks;\n+  struct gimplify_ctx gctx;\n+\n   /* There is no point in performing inlining if errors have already\n      occurred -- and we might crash if we try to inline invalid\n      code.  */\n@@ -3012,7 +3015,7 @@ optimize_inline_calls (tree fn)\n   id.transform_lang_insert_block = NULL;\n   id.statements_to_fold = pointer_set_create ();\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   /* We make no attempts to keep dominance info up-to-date.  */\n   free_dominance_info (CDI_DOMINATORS);"}, {"sha": "46650b37dd4f8347ffd4ba072e88e5ff62890593", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -421,13 +421,15 @@ mudflap_init (void)\n static unsigned int\n execute_mudflap_function_ops (void)\n {\n+  struct gimplify_ctx gctx;\n+\n   /* Don't instrument functions such as the synthetic constructor\n      built during mudflap_finish_file.  */\n   if (mf_marked_p (current_function_decl) ||\n       DECL_ARTIFICIAL (current_function_decl))\n     return 0;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   /* In multithreaded mode, don't cache the lookup cache parameters.  */\n   if (! flag_mudflap_threads)\n@@ -958,13 +960,15 @@ mf_xform_derefs (void)\n static unsigned int\n execute_mudflap_function_decls (void)\n {\n+  struct gimplify_ctx gctx;\n+\n   /* Don't instrument functions such as the synthetic constructor\n      built during mudflap_finish_file.  */\n   if (mf_marked_p (current_function_decl) ||\n       DECL_ARTIFICIAL (current_function_decl))\n     return 0;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n \n   mf_xform_decls (DECL_SAVED_TREE (current_function_decl),\n                   DECL_ARGUMENTS (current_function_decl));"}, {"sha": "21cf367b23a78e19b6f157bc6b12a8c7b00ebd6c", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -2832,8 +2832,9 @@ static bool\n generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n {\n   bool ret;\n+  struct gimplify_ctx gctx;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n   ret = generate_element_init_1 (elt, init, list_p);\n   pop_gimplify_context (NULL);\n "}, {"sha": "3b90da4ddc8fe545b3714220fef7aa606d06f5d6", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d406b663d0e9973eeb9211409fe35d70b973db34/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=d406b663d0e9973eeb9211409fe35d70b973db34", "patch": "@@ -2825,8 +2825,9 @@ convert_to_gimple_builtin (block_stmt_iterator *si_p, tree expr, bool ignore)\n   tree_stmt_iterator ti;\n   tree stmt = bsi_stmt (*si_p);\n   tree tmp, stmts = NULL;\n+  struct gimplify_ctx gctx;\n \n-  push_gimplify_context ();\n+  push_gimplify_context (&gctx);\n   if (ignore)\n     {\n       tmp = build_empty_stmt ();"}]}