{"sha": "36d59cf798c2bf339594ca6917851b9689f84b5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZkNTljZjc5OGMyYmYzMzk1OTRjYTY5MTc4NTFiOTY4OWY4NGI1ZA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-08-26T17:10:50Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-08-26T17:10:50Z"}, "message": "[multiple changes]\n\n2004-08-26  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* Makefile.in (lambda-code.o): New.\n\t(lambda-trans.o): Ditto.\n\t(TREE_DATA_REF_H): Ditto.\n\t(LAMBDA_H): Ditto.\n\t(lambda-mat.o): Use LAMBDA_H.\n\t(tree-data-ref.o): Ditto.\n\t* lambda-code.c: New file.  Lambda code generation algorithm.\n\t* lambda-trans.c: Ditto. Lambda transformation matrix support.\n\t* lambda.h: Add lambda loop structures.\n\tAdd lambda loopnest structures.\n\tAdd lambda body vector structure.\n\tAdd lambda linear expression structures.\n\tAdd prototypes for functions in new files.\n\t* lambda-mat.c: Include tree.h\n\n2004-08-26  Daniel Berlin <dberlin@dberlin.org>\n\t    Sebastian Pop  <pop@cri.ensmp.fr>\n\n\t* tree-data-ref.h: Include lambda.h\n\t(free_dependence_relation): Declared here.\n\t(free_dependence_relations): Ditto.\n\t(free_data_refs): Ditto.\n\t* tree-data-ref.c (free_dependence_relation): New function.\n\t(free_dependence_relations): Ditto.\n\t(free_data_refs): Ditot.\n\t(analyze_all_data_dependences): Free datarefs and dependence_relations.\n\t(build_classic_dist_vector): Store in the dependence_relations the\n\tinformation. Each arc in the dependence_relations graph is labelled\n\twith the distance and direction vectors.\n\t(build_classic_dir_vector): Ditto.\n\t(compute_rw_wr_ww_dependences): Renamed again compute_all_dependences.\n\tNow computes again the whole dependence graph including read-read\n\trelations.\n\t(compute_data_dependences_for_loop): Now dependence_relations contains\n\tall the data, and thus it doesn't need to initialize the classic_dir\n\tand classic_dist vectors.\n\t(analyze_all_data_dependences): Adjusted for using the new interface of\n\tcompute_data_dependences_for_loop.  Remove the statistics dump.\n\nCo-Authored-By: Sebastian Pop <pop@cri.ensmp.fr>\n\nFrom-SVN: r86627", "tree": {"sha": "ed90480c751c97e7942fbc20064d66ab11f4b7bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed90480c751c97e7942fbc20064d66ab11f4b7bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36d59cf798c2bf339594ca6917851b9689f84b5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d59cf798c2bf339594ca6917851b9689f84b5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d59cf798c2bf339594ca6917851b9689f84b5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d59cf798c2bf339594ca6917851b9689f84b5d/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a46bbb5a39813fee56e20d11d90f91dc4319ad95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a46bbb5a39813fee56e20d11d90f91dc4319ad95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a46bbb5a39813fee56e20d11d90f91dc4319ad95"}], "stats": {"total": 2420, "additions": 2320, "deletions": 100}, "files": [{"sha": "e6ca31f22bb94028c4bc48ffcefc7b6275c48166", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -1,3 +1,44 @@\n+2004-08-26  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* Makefile.in (lambda-code.o): New.\n+\t(lambda-trans.o): Ditto.\n+\t(TREE_DATA_REF_H): Ditto.\n+\t(LAMBDA_H): Ditto.\n+\t(lambda-mat.o): Use LAMBDA_H.\n+\t(tree-data-ref.o): Ditto.\n+\t* lambda-code.c: New file.  Lambda code generation algorithm.\n+\t* lambda-trans.c: Ditto. Lambda transformation matrix support.\n+\t* lambda.h: Add lambda loop structures.\n+\tAdd lambda loopnest structures.\n+\tAdd lambda body vector structure.\n+\tAdd lambda linear expression structures.\n+\tAdd prototypes for functions in new files.\n+\t* lambda-mat.c: Include tree.h\n+\n+2004-08-26  Daniel Berlin <dberlin@dberlin.org>\n+\t    Sebastian Pop  <pop@cri.ensmp.fr>\t\n+\t\n+\t* tree-data-ref.h: Include lambda.h\t\n+\t(free_dependence_relation): Declared here.\n+\t(free_dependence_relations): Ditto.\t\n+\t(free_data_refs): Ditto.\n+\t* tree-data-ref.c (free_dependence_relation): New function.\n+\t(free_dependence_relations): Ditto.\n+\t(free_data_refs): Ditot.\n+\t(analyze_all_data_dependences): Free datarefs and dependence_relations.\n+\t(build_classic_dist_vector): Store in the dependence_relations the\n+\tinformation. Each arc in the dependence_relations graph is labelled\n+\twith the distance and direction vectors.\n+\t(build_classic_dir_vector): Ditto.\n+\t(compute_rw_wr_ww_dependences): Renamed again compute_all_dependences.\n+\tNow computes again the whole dependence graph including read-read\n+\trelations.\n+\t(compute_data_dependences_for_loop): Now dependence_relations contains\n+\tall the data, and thus it doesn't need to initialize the classic_dir\n+\tand classic_dist vectors.\n+\t(analyze_all_data_dependences): Adjusted for using the new interface of\n+\tcompute_data_dependences_for_loop.  Remove the statistics dump.\n+\t\n 2004-08-26  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.c (xtensa_ld_opcodes, xtensa_st_opcodes): Delete."}, {"sha": "795029d870fb1d28a53196dec83c1978037a92af", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -723,6 +723,8 @@ PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)\n C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h\n+LAMBDA_H = lambda.h tree.h vec.h $(GGC_H)\n+TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H)\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -915,7 +917,8 @@ OBJS-common = \\\n  targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n- rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o\n+ rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n+ lambda-trans.o\tlambda-code.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1737,7 +1740,7 @@ tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h \\\n-   tree-data-ref.h $(SCEV_H) tree-pass.h lambda.h\n+   tree-data-ref.h $(SCEV_H) tree-pass.h $(LAMBDA_H)\n tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h tree-pass.h \\\n@@ -2137,7 +2140,12 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) toplev.h $(FLAGS_H) insn-config.h function.h $(RECOG_H) $(TARGET_H) \\\n    $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) real.h $(OPTABS_H) \\\n    $(CFGLOOP_H)\n-lambda-mat.o : lambda-mat.c lambda.h $(GGC_H) $(SYSTEM_H) $(CONFIG_H) $(TM_H)\n+lambda-mat.o : lambda-mat.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) $(TM_H)\n+lambda-trans.o: lambda-trans.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) $(TM_H)\n+lambda-code.o: lambda-code.c $(LAMBDA_H) $(GGC_H) $(SYSTEM_H) $(CONFIG_H) \\\n+   errors.h $(TM_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h \\\n+   $(TREE_DATA_REF_H) $(SCEV_H)\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) toplev.h\n hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)\n pretty-print.o: $(CONFIG_H) $(SYSTEM_H) pretty-print.c $(PRETTY_PRINT_H)"}, {"sha": "664092797ea757672e5288c44ad40e0a305a6ee7", "filename": "gcc/lambda-code.c", "status": "added", "additions": 1972, "deletions": 0, "changes": 1972, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -0,0 +1,1972 @@\n+/*  Loop transformation code generation\n+    Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+    Contributed by Daniel Berlin <dberlin@dberlin.org>\n+\n+    This file is part of GCC.\n+    \n+    GCC is free software; you can redistribute it and/or modify it under\n+    the terms of the GNU General Public License as published by the Free\n+    Software Foundation; either version 2, or (at your option) any later\n+    version.\n+    \n+    GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+    WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+    for more details.\n+    \n+    You should have received a copy of the GNU General Public License\n+    along with GCC; see the file COPYING.  If not, write to the Free\n+    Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+    02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"vec.h\"\n+#include \"lambda.h\"\n+\n+/* This loop nest code generation is based on non-singular matrix\n+   math.\n+ \n+ A little terminology and a general sketch of the algorithm.  See \"A singular\n+ loop transformatrion framework based on non-singular matrices\" by Wei Li and\n+ Keshav Pingali for formal proofs that the various statements below are\n+ correct. \n+\n+ A loop iteration space are the points traversed by the loop.  A point in the\n+ iteration space can be represented by a vector of size <loop depth>.  You can\n+ therefore represent the iteration space as a integral combinations of a set\n+ of basis vectors. \n+\n+ A loop iteration space is dense if every integer point between the loop\n+ bounds is a point in the iteration space.  Every loop with a step of 1\n+ therefore has a dense iteration space.\n+\n+ for i = 1 to 3, step 1 is a dense iteration space.\n+   \n+ A loop iteration space is sparse if it is not dense.  That is, the iteration\n+ space skips integer points that are within the loop bounds.  \n+\n+ for i = 1 to 3, step 2 is a sparse iteration space, because the integer point\n+ 2 is skipped.\n+\n+ Dense source spaces are easy to transform, because they don't skip any\n+ points to begin with.  Thus we can compute the exact bounds of the target\n+ space using min/max and floor/ceil.\n+\n+ For a dense source space, we take the transformation matrix, decompose it\n+ into a lower triangular part (H) and a unimodular part (U). \n+ We then compute the auxillary space from the unimodular part (source loop\n+ nest . U = auxillary space) , which has two important properties:\n+  1. It traverses the iterations in the same lexicographic order as the source\n+  space.\n+  2. It is a dense space when the source is a dense space (even if the target\n+  space is going to be sparse).\n+ \n+ Given the auxillary space, we use the lower triangular part to compute the\n+ bounds in the target space by simple matrix multiplication.\n+ The gaps in the target space (IE the new loop step sizes) will be the\n+ diagonals of the H matrix.\n+\n+ Sparse source spaces require another step, because you can't directly compute\n+ the exact bounds of the auxillary and target space from the sparse space.\n+ Rather than try to come up with a separate algorithm to handle sparse source\n+ spaces directly, we just find a legal transformation matrix that gives you\n+ the sparse source space, from a dense space, and then transform the dense\n+ space.\n+\n+ For a regular sparse space, you can represent the source space as an integer\n+ lattice, and the base space of that lattice will always be dense.  Thus, we\n+ effectively use the lattice to figure out the transformation from the lattice\n+ base space, to the sparse iteration space (IE what transform was applied to\n+ the dense space to make it sparse).  We then compose this transform with the\n+ transformation matrix specified by the user (since our matrix transformations\n+ are closed under composition, this is okay).  We can then use the base space\n+ (which is dense) plus the composed transformation matrix, to compute the rest\n+ of the transform using the dense space algorithm above.\n+ \n+ In other words, our sparse source space (B) is decomposed into a dense base\n+ space (A), and a matrix (L) that transforms A into B, such that A.L = B.\n+ We then compute the composition of L and the user transformation matrix (T),\n+ so that T is now a transform from A to the result, instead of from B to the\n+ result. \n+ IE A.(LT) = result instead of B.T = result\n+ Since A is now a dense source space, we can use the dense source space\n+ algorithm above to compute the result of applying transform (LT) to A.\n+\n+ Fourier-Motzkin elimination is used to compute the bounds of the base space\n+ of the lattice.  */\n+\n+/* Lattice stuff that is internal to the code generation algorithm.  */\n+\n+typedef struct\n+{\n+  /* Lattice base matrix.  */\n+  lambda_matrix base;\n+  /* Lattice dimension.  */\n+  int dimension;\n+  /* Origin vector for the coefficients.  */\n+  lambda_vector origin;\n+  /* Origin matrix for the invariants.  */\n+  lambda_matrix origin_invariants;\n+  /* Number of invariants.  */\n+  int invariants;\n+} *lambda_lattice;\n+\n+#define LATTICE_BASE(T) ((T)->base)\n+#define LATTICE_DIMENSION(T) ((T)->dimension)\n+#define LATTICE_ORIGIN(T) ((T)->origin)\n+#define LATTICE_ORIGIN_INVARIANTS(T) ((T)->origin_invariants)\n+#define LATTICE_INVARIANTS(T) ((T)->invariants)\n+\n+static bool lle_equal (lambda_linear_expression, lambda_linear_expression,\n+\t\t       int, int);\n+static lambda_lattice lambda_lattice_new (int, int);\n+static lambda_lattice lambda_lattice_compute_base (lambda_loopnest);\n+\n+static tree find_induction_var_from_exit_cond (struct loop *);\n+\n+/* Create a new lambda body vector.  */\n+\n+lambda_body_vector\n+lambda_body_vector_new (int size)\n+{\n+  lambda_body_vector ret;\n+\n+  ret = ggc_alloc (sizeof (*ret));\n+  LBV_COEFFICIENTS (ret) = lambda_vector_new (size);\n+  LBV_SIZE (ret) = size;\n+  LBV_DENOMINATOR (ret) = 1;\n+  return ret;\n+}\n+\n+/* Compute the new coefficients for the vector based on the\n+  *inverse* of the transformation matrix.  */\n+\n+lambda_body_vector\n+lambda_body_vector_compute_new (lambda_trans_matrix transform,\n+\t\t\t\tlambda_body_vector vect)\n+{\n+  lambda_body_vector temp;\n+  int depth;\n+\n+  /* Make sure the matrix is square.  */\n+  if (LTM_ROWSIZE (transform) != LTM_COLSIZE (transform))\n+    abort ();\n+\n+  depth = LTM_ROWSIZE (transform);\n+\n+  temp = lambda_body_vector_new (depth);\n+  LBV_DENOMINATOR (temp) =\n+    LBV_DENOMINATOR (vect) * LTM_DENOMINATOR (transform);\n+  lambda_vector_matrix_mult (LBV_COEFFICIENTS (vect), depth,\n+\t\t\t     LTM_MATRIX (transform), depth,\n+\t\t\t     LBV_COEFFICIENTS (temp));\n+  LBV_SIZE (temp) = LBV_SIZE (vect);\n+  return temp;\n+}\n+\n+/* Print out a lambda body vector.  */\n+\n+void\n+print_lambda_body_vector (FILE * outfile, lambda_body_vector body)\n+{\n+  print_lambda_vector (outfile, LBV_COEFFICIENTS (body), LBV_SIZE (body));\n+}\n+\n+/* Return TRUE if two linear expressions are equal.  */\n+\n+static bool\n+lle_equal (lambda_linear_expression lle1, lambda_linear_expression lle2,\n+\t   int depth, int invariants)\n+{\n+  int i;\n+\n+  if (lle1 == NULL || lle2 == NULL)\n+    return false;\n+  if (LLE_CONSTANT (lle1) != LLE_CONSTANT (lle2))\n+    return false;\n+  if (LLE_DENOMINATOR (lle1) != LLE_DENOMINATOR (lle2))\n+    return false;\n+  for (i = 0; i < depth; i++)\n+    if (LLE_COEFFICIENTS (lle1)[i] != LLE_COEFFICIENTS (lle2)[i])\n+      return false;\n+  for (i = 0; i < invariants; i++)\n+    if (LLE_INVARIANT_COEFFICIENTS (lle1)[i] !=\n+\tLLE_INVARIANT_COEFFICIENTS (lle2)[i])\n+      return false;\n+  return true;\n+}\n+\n+/* Create a new linear expression with dimension DIM, and total number\n+   of invariants INVARIANTS.  */\n+\n+lambda_linear_expression\n+lambda_linear_expression_new (int dim, int invariants)\n+{\n+  lambda_linear_expression ret;\n+\n+  ret = ggc_alloc_cleared (sizeof (*ret));\n+\n+  LLE_COEFFICIENTS (ret) = lambda_vector_new (dim);\n+  LLE_CONSTANT (ret) = 0;\n+  LLE_INVARIANT_COEFFICIENTS (ret) = lambda_vector_new (invariants);\n+  LLE_DENOMINATOR (ret) = 1;\n+  LLE_NEXT (ret) = NULL;\n+\n+  return ret;\n+}\n+\n+/* Print out a linear expression EXPR, with SIZE coefficients, to OUTFILE.\n+   The starting letter used for variable names is START.  */\n+\n+static void\n+print_linear_expression (FILE * outfile, lambda_vector expr, int size,\n+\t\t\t char start)\n+{\n+  int i;\n+  bool first = true;\n+  for (i = 0; i < size; i++)\n+    {\n+      if (expr[i] != 0)\n+\t{\n+\t  if (first)\n+\t    {\n+\t      if (expr[i] < 0)\n+\t\tfprintf (outfile, \"-\");\n+\t      first = false;\n+\t    }\n+\t  else if (expr[i] > 0)\n+\t    fprintf (outfile, \" + \");\n+\t  else\n+\t    fprintf (outfile, \" - \");\n+\t  if (abs (expr[i]) == 1)\n+\t    fprintf (outfile, \"%c\", start + i);\n+\t  else\n+\t    fprintf (outfile, \"%d%c\", abs (expr[i]), start + i);\n+\t}\n+    }\n+}\n+\n+/* Print out a lambda linear expression structure, EXPR, to OUTFILE. The\n+   depth/number of coefficients is given by DEPTH, the number of invariants is\n+   given by INVARIANTS, and the character to start variable names with is given\n+   by START.  */\n+\n+void\n+print_lambda_linear_expression (FILE * outfile,\n+\t\t\t\tlambda_linear_expression expr,\n+\t\t\t\tint depth, int invariants, char start)\n+{\n+  fprintf (outfile, \"\\tLinear expression: \");\n+  print_linear_expression (outfile, LLE_COEFFICIENTS (expr), depth, start);\n+  fprintf (outfile, \" constant: %d \", LLE_CONSTANT (expr));\n+  fprintf (outfile, \"  invariants: \");\n+  print_linear_expression (outfile, LLE_INVARIANT_COEFFICIENTS (expr),\n+\t\t\t   invariants, 'A');\n+  fprintf (outfile, \"  denominator: %d\\n\", LLE_DENOMINATOR (expr));\n+}\n+\n+/* Print a lambda loop structure LOOP to OUTFILE.  The depth/number of\n+   coefficients is given by DEPTH, the number of invariants is \n+   given by INVARIANTS, and the character to start variable names with is given\n+   by START. */\n+\n+void\n+print_lambda_loop (FILE * outfile, lambda_loop loop, int depth,\n+\t\t   int invariants, char start)\n+{\n+  int step;\n+  lambda_linear_expression expr;\n+\n+  if (!loop)\n+    abort ();\n+\n+  expr = LL_LINEAR_OFFSET (loop);\n+  step = LL_STEP (loop);\n+  fprintf (outfile, \"  step size = %d \\n\", step);\n+\n+  if (expr)\n+    {\n+      fprintf (outfile, \"  linear offset: \\n\");\n+      print_lambda_linear_expression (outfile, expr, depth, invariants,\n+\t\t\t\t      start);\n+    }\n+\n+  fprintf (outfile, \"  lower bound: \\n\");\n+  for (expr = LL_LOWER_BOUND (loop); expr != NULL; expr = LLE_NEXT (expr))\n+    print_lambda_linear_expression (outfile, expr, depth, invariants, start);\n+  fprintf (outfile, \"  upper bound: \\n\");\n+  for (expr = LL_UPPER_BOUND (loop); expr != NULL; expr = LLE_NEXT (expr))\n+    print_lambda_linear_expression (outfile, expr, depth, invariants, start);\n+}\n+\n+/* Create a new loop nest structure with DEPTH loops, and INVARIANTS as the\n+   number of invariants.  */\n+\n+lambda_loopnest\n+lambda_loopnest_new (int depth, int invariants)\n+{\n+  lambda_loopnest ret;\n+  ret = ggc_alloc (sizeof (*ret));\n+\n+  LN_LOOPS (ret) = ggc_alloc_cleared (depth * sizeof (lambda_loop));\n+  LN_DEPTH (ret) = depth;\n+  LN_INVARIANTS (ret) = invariants;\n+\n+  return ret;\n+}\n+\n+/* Print a lambda loopnest structure, NEST, to OUTFILE.  The starting\n+   character to use for loop names is given by START.  */\n+\n+void\n+print_lambda_loopnest (FILE * outfile, lambda_loopnest nest, char start)\n+{\n+  int i;\n+  for (i = 0; i < LN_DEPTH (nest); i++)\n+    {\n+      fprintf (outfile, \"Loop %c\\n\", start + i);\n+      print_lambda_loop (outfile, LN_LOOPS (nest)[i], LN_DEPTH (nest),\n+\t\t\t LN_INVARIANTS (nest), 'i');\n+      fprintf (outfile, \"\\n\");\n+    }\n+}\n+\n+/* Allocate a new lattice structure of DEPTH x DEPTH, with INVARIANTS number\n+   of invariants.    */\n+\n+static lambda_lattice\n+lambda_lattice_new (int depth, int invariants)\n+{\n+  lambda_lattice ret;\n+  ret = ggc_alloc (sizeof (*ret));\n+  LATTICE_BASE (ret) = lambda_matrix_new (depth, depth);\n+  LATTICE_ORIGIN (ret) = lambda_vector_new (depth);\n+  LATTICE_ORIGIN_INVARIANTS (ret) = lambda_matrix_new (depth, invariants);\n+  LATTICE_DIMENSION (ret) = depth;\n+  LATTICE_INVARIANTS (ret) = invariants;\n+  return ret;\n+}\n+\n+/* Compute the lattice base for NEST.  The lattice base is essentially a\n+   non-singular transform from a dense base space to a sparse iteration space.\n+   We use it so that we don't have to specially handle the case of a sparse\n+   iteration space in other parts of the algorithm.  As a result, this routine\n+   only does something interesting (IE produce a matrix that isn't the\n+   identity matrix) if NEST is a sparse space.  */\n+\n+static lambda_lattice\n+lambda_lattice_compute_base (lambda_loopnest nest)\n+{\n+  lambda_lattice ret;\n+  int depth, invariants;\n+  lambda_matrix base;\n+\n+  int i, j, step;\n+  lambda_loop loop;\n+  lambda_linear_expression expression;\n+\n+  depth = LN_DEPTH (nest);\n+  invariants = LN_INVARIANTS (nest);\n+\n+  ret = lambda_lattice_new (depth, invariants);\n+  base = LATTICE_BASE (ret);\n+  for (i = 0; i < depth; i++)\n+    {\n+      loop = LN_LOOPS (nest)[i];\n+      if (!loop)\n+\tabort ();\n+      step = LL_STEP (loop);\n+      /* If we have a step of 1, then the base is one, and the\n+         origin and invariant coefficients are 0.  */\n+      if (step == 1)\n+\t{\n+\t  for (j = 0; j < depth; j++)\n+\t    base[i][j] = 0;\n+\t  base[i][i] = 1;\n+\t  LATTICE_ORIGIN (ret)[i] = 0;\n+\t  for (j = 0; j < invariants; j++)\n+\t    LATTICE_ORIGIN_INVARIANTS (ret)[i][j] = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we need the lower bound expression (which must\n+\t     be an affine function)  to determine the base.  */\n+\t  expression = LL_LOWER_BOUND (loop);\n+\t  if (!expression\n+\t      || LLE_NEXT (expression) || LLE_DENOMINATOR (expression) != 1)\n+\t    abort ();\n+\n+\t  /* The lower triangular portion of the base is going to be the\n+\t     coefficient times the step */\n+\t  for (j = 0; j < i; j++)\n+\t    base[i][j] = LLE_COEFFICIENTS (expression)[j]\n+\t      * LL_STEP (LN_LOOPS (nest)[j]);\n+\t  base[i][i] = step;\n+\t  for (j = i + 1; j < depth; j++)\n+\t    base[i][j] = 0;\n+\n+\t  /* Origin for this loop is the constant of the lower bound\n+\t     expression.  */\n+\t  LATTICE_ORIGIN (ret)[i] = LLE_CONSTANT (expression);\n+\n+\t  /* Coefficient for the invariants are equal to the invariant\n+\t     coefficients in the expression.  */\n+\t  for (j = 0; j < invariants; j++)\n+\t    LATTICE_ORIGIN_INVARIANTS (ret)[i][j] =\n+\t      LLE_INVARIANT_COEFFICIENTS (expression)[j];\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Compute the greatest common denominator of two numbers (A and B) using\n+   Euclid's algorithm.  */\n+\n+static int\n+gcd (int a, int b)\n+{\n+\n+  int x, y, z;\n+\n+  x = abs (a);\n+  y = abs (b);\n+\n+  while (x > 0)\n+    {\n+      z = y % x;\n+      y = x;\n+      x = z;\n+    }\n+\n+  return (y);\n+}\n+\n+/* Compute the greatest common denominator of a VECTOR of SIZE numbers.  */\n+\n+static int\n+gcd_vector (lambda_vector vector, int size)\n+{\n+  int i;\n+  int gcd1 = 0;\n+\n+  if (size > 0)\n+    {\n+      gcd1 = vector[0];\n+      for (i = 1; i < size; i++)\n+\tgcd1 = gcd (gcd1, vector[i]);\n+    }\n+  return gcd1;\n+}\n+\n+/* Compute the least common multiple of two numbers A and B .  */\n+\n+static int\n+lcm (int a, int b)\n+{\n+  return (abs (a) * abs (b) / gcd (a, b));\n+}\n+\n+/* Compute the loop bounds for the auxiliary space NEST.\n+   Input system used is Ax <= b.  TRANS is the unimodular transformation. */\n+\n+static lambda_loopnest\n+lambda_compute_auxillary_space (lambda_loopnest nest,\n+\t\t\t\tlambda_trans_matrix trans)\n+{\n+  lambda_matrix A, B, A1, B1, temp0;\n+  lambda_vector a, a1, temp1;\n+  lambda_matrix invertedtrans;\n+  int determinant, depth, invariants, size, newsize;\n+  int i, j, k;\n+  lambda_loopnest auxillary_nest;\n+  lambda_loop loop;\n+  lambda_linear_expression expression;\n+  lambda_lattice lattice;\n+\n+  int multiple, f1, f2;\n+\n+  depth = LN_DEPTH (nest);\n+  invariants = LN_INVARIANTS (nest);\n+\n+  /* Unfortunately, we can't know the number of constraints we'll have\n+     ahead of time, but this should be enough even in ridiculous loop nest\n+     cases. We abort if we go over this limit.  */\n+  A = lambda_matrix_new (128, depth);\n+  B = lambda_matrix_new (128, invariants);\n+  a = lambda_vector_new (128);\n+\n+  A1 = lambda_matrix_new (128, depth);\n+  B1 = lambda_matrix_new (128, invariants);\n+  a1 = lambda_vector_new (128);\n+\n+  /* Store the bounds in the equation matrix A, constant vector a, and\n+     invariant matrix B, so that we have Ax <= a + B.\n+     This requires a little equation rearranging so that everything is on the\n+     correct side of the inequality.  */\n+  size = 0;\n+  for (i = 0; i < depth; i++)\n+    {\n+      loop = LN_LOOPS (nest)[i];\n+\n+      /* First we do the lower bound.  */\n+      if (LL_STEP (loop) > 0)\n+\texpression = LL_LOWER_BOUND (loop);\n+      else\n+\texpression = LL_UPPER_BOUND (loop);\n+\n+      for (; expression != NULL; expression = LLE_NEXT (expression))\n+\t{\n+\t  /* Fill in the coefficient.  */\n+\t  for (j = 0; j < i; j++)\n+\t    A[size][j] = LLE_COEFFICIENTS (expression)[j];\n+\n+\t  /* And the invariant coefficient.  */\n+\t  for (j = 0; j < invariants; j++)\n+\t    B[size][j] = LLE_INVARIANT_COEFFICIENTS (expression)[j];\n+\n+\t  /* And the constant.  */\n+\t  a[size] = LLE_CONSTANT (expression);\n+\n+\t  /* Convert (2x+3y+2+b)/4 <= z to 2x+3y-4z <= -2-b.  IE put all\n+\t     constants and single variables on   */\n+\t  A[size][i] = -1 * LLE_DENOMINATOR (expression);\n+\t  a[size] *= -1;\n+\t  for (j = 0; j < invariants; j++)\n+\t    B[size][j] *= -1;\n+\n+\t  size++;\n+\t  /* Need to increase matrix sizes above.  */\n+\t  if (size > 127)\n+\t    abort ();\n+\t}\n+\n+      /* Then do the exact same thing for the upper bounds.  */\n+      if (LL_STEP (loop) > 0)\n+\texpression = LL_UPPER_BOUND (loop);\n+      else\n+\texpression = LL_LOWER_BOUND (loop);\n+\n+      for (; expression != NULL; expression = LLE_NEXT (expression))\n+\t{\n+\t  /* Fill in the coefficient.  */\n+\t  for (j = 0; j < i; j++)\n+\t    A[size][j] = LLE_COEFFICIENTS (expression)[j];\n+\n+\t  /* And the invariant coefficient.  */\n+\t  for (j = 0; j < invariants; j++)\n+\t    B[size][j] = LLE_INVARIANT_COEFFICIENTS (expression)[j];\n+\n+\t  /* And the constant.  */\n+\t  a[size] = LLE_CONSTANT (expression);\n+\n+\t  /* Convert z <= (2x+3y+2+b)/4 to -2x-3y+4z <= 2+b.  */\n+\t  for (j = 0; j < i; j++)\n+\t    A[size][j] *= -1;\n+\t  A[size][i] = LLE_DENOMINATOR (expression);\n+\t  size++;\n+\t  /* Need to increase matrix sizes above.  */\n+\t  if (size > 127)\n+\t    abort ();\n+\t}\n+    }\n+\n+  /* Compute the lattice base x = base * y + origin, where y is the\n+     base space.  */\n+  lattice = lambda_lattice_compute_base (nest);\n+\n+  /* Ax <= a + B then becomes ALy <= a+B - A*origin.  L is the lattice base  */\n+\n+  /* A1 = A * L */\n+  lambda_matrix_mult (A, LATTICE_BASE (lattice), A1, size, depth, depth);\n+\n+  /* a1 = a - A * origin constant.  */\n+  lambda_matrix_vector_mult (A, size, depth, LATTICE_ORIGIN (lattice), a1);\n+  lambda_vector_add_mc (a, 1, a1, -1, a1, size);\n+\n+  /* B1 = B - A * origin invariant.  */\n+  lambda_matrix_mult (A, LATTICE_ORIGIN_INVARIANTS (lattice), B1, size, depth,\n+\t\t      invariants);\n+  lambda_matrix_add_mc (B, 1, B1, -1, B1, size, invariants);\n+\n+  /* Now compute the auxiliary space bounds by first inverting U, multiplying\n+     it by A1, then performing fourier motzkin.  */\n+\n+  invertedtrans = lambda_matrix_new (depth, depth);\n+\n+  /* Compute the inverse of U.  */\n+  determinant = lambda_matrix_inverse (LTM_MATRIX (trans),\n+\t\t\t\t       invertedtrans, depth);\n+\n+  /* A = A1 inv(U).  */\n+  lambda_matrix_mult (A1, invertedtrans, A, size, depth, depth);\n+\n+  /* Perform Fourier-Motzkin elimination to calculate the bounds of the\n+     auxillary nest.\n+     Fourier-Motzkin is a way of reducing systems of linear inequality so that\n+     it is easy to calculate the answer and bounds.\n+     A sketch of how it works:\n+     Given a system of linear inequalities, ai * xj >= bk, you can always\n+     rewrite the constraints so they are all of the form\n+     a <= x, or x <= b, or x >= constant for some x in x1 ... xj (and some b\n+     in b1 ... bk, and some a in a1...ai)\n+     You can then eliminate this x from the non-constant inequalities by\n+     rewriting these as a <= b, x >= constant, and delete the x variable.\n+     You can then repeat this for any remaining x variables, and then we have\n+     an easy to use variable <= constant (or no variables at all) form that we\n+     can construct our bounds from. \n+\n+     In our case, each time we eliminate, we construct part of the bound from\n+     the ith variable, then delete the ith variable. \n+\n+     Remember the constant are in our vector a, our coefficient matrix is A,\n+     and our invariant coefficient matrix is B  */\n+\n+  /* Swap B and B1, and a1 and a */\n+  temp0 = B1;\n+  B1 = B;\n+  B = temp0;\n+\n+  temp1 = a1;\n+  a1 = a;\n+  a = temp1;\n+\n+  auxillary_nest = lambda_loopnest_new (depth, invariants);\n+\n+  for (i = depth - 1; i >= 0; i--)\n+    {\n+      loop = lambda_loop_new ();\n+      LN_LOOPS (auxillary_nest)[i] = loop;\n+      LL_STEP (loop) = 1;\n+\n+      for (j = 0; j < size; j++)\n+\t{\n+\t  if (A[j][i] < 0)\n+\t    {\n+\t      /* Lower bound.  */\n+\t      expression = lambda_linear_expression_new (depth, invariants);\n+\n+\t      for (k = 0; k < i; k++)\n+\t\tLLE_COEFFICIENTS (expression)[k] = A[j][k];\n+\t      for (k = 0; k < invariants; k++)\n+\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = -1 * B[j][k];\n+\t      LLE_DENOMINATOR (expression) = -1 * A[j][i];\n+\t      LLE_CONSTANT (expression) = -1 * a[j];\n+\t      /* Ignore if identical to the existing lower bound.  */\n+\t      if (!lle_equal (LL_LOWER_BOUND (loop),\n+\t\t\t      expression, depth, invariants))\n+\t\t{\n+\t\t  LLE_NEXT (expression) = LL_LOWER_BOUND (loop);\n+\t\t  LL_LOWER_BOUND (loop) = expression;\n+\t\t}\n+\n+\t    }\n+\t  else if (A[j][i] > 0)\n+\t    {\n+\t      /* Upper bound.  */\n+\t      expression = lambda_linear_expression_new (depth, invariants);\n+\t      for (k = 0; k < i; k++)\n+\t\tLLE_COEFFICIENTS (expression)[k] = -1 * A[j][k];\n+\t      LLE_CONSTANT (expression) = a[j];\n+\n+\t      for (k = 0; k < invariants; k++)\n+\t\tLLE_INVARIANT_COEFFICIENTS (expression)[k] = B[j][k];\n+\n+\t      LLE_DENOMINATOR (expression) = A[j][i];\n+\t      /* Ignore if identical to the existing upper bound.  */\n+\t      if (!lle_equal (LL_UPPER_BOUND (loop),\n+\t\t\t      expression, depth, invariants))\n+\t\t{\n+\t\t  LLE_NEXT (expression) = LL_UPPER_BOUND (loop);\n+\t\t  LL_UPPER_BOUND (loop) = expression;\n+\t\t}\n+\n+\t    }\n+\t}\n+      /* creates a new system by deleting the i'th variable. */\n+      newsize = 0;\n+      for (j = 0; j < size; j++)\n+\t{\n+\t  if (A[j][i] == 0)\n+\t    {\n+\t      lambda_vector_copy (A[j], A1[newsize], depth);\n+\t      lambda_vector_copy (B[j], B1[newsize], invariants);\n+\t      a1[newsize] = a[j];\n+\t      newsize++;\n+\t    }\n+\t  else if (A[j][i] > 0)\n+\t    {\n+\t      for (k = 0; k < size; k++)\n+\t\t{\n+\t\t  if (A[k][i] < 0)\n+\t\t    {\n+\t\t      multiple = lcm (A[j][i], A[k][i]);\n+\t\t      f1 = multiple / A[j][i];\n+\t\t      f2 = -1 * multiple / A[k][i];\n+\n+\t\t      lambda_vector_add_mc (A[j], f1, A[k], f2,\n+\t\t\t\t\t    A1[newsize], depth);\n+\t\t      lambda_vector_add_mc (B[j], f1, B[k], f2,\n+\t\t\t\t\t    B1[newsize], invariants);\n+\t\t      a1[newsize] = f1 * a[j] + f2 * a[k];\n+\t\t      newsize++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      temp0 = A;\n+      A = A1;\n+      A1 = temp0;\n+\n+      temp0 = B;\n+      B = B1;\n+      B1 = temp0;\n+\n+      temp1 = a;\n+      a = a1;\n+      a1 = temp1;\n+\n+      size = newsize;\n+    }\n+\n+  return auxillary_nest;\n+}\n+\n+/* Compute the loop bounds for the target space, using the bounds of\n+   the auxillary nest AUXILLARY_NEST, and the triangular matrix H.  This is\n+   done by matrix multiplication and then transformation of the new matrix\n+   back into linear expression form.\n+   Return the target loopnest.  */\n+\n+static lambda_loopnest\n+lambda_compute_target_space (lambda_loopnest auxillary_nest,\n+\t\t\t     lambda_trans_matrix H, lambda_vector stepsigns)\n+{\n+  lambda_matrix inverse, H1;\n+  int determinant, i, j;\n+  int gcd1, gcd2;\n+  int factor;\n+\n+  lambda_loopnest target_nest;\n+  int depth, invariants;\n+  lambda_matrix target;\n+\n+  lambda_loop auxillary_loop, target_loop;\n+  lambda_linear_expression expression, auxillary_expr, target_expr, tmp_expr;\n+\n+  depth = LN_DEPTH (auxillary_nest);\n+  invariants = LN_INVARIANTS (auxillary_nest);\n+\n+  inverse = lambda_matrix_new (depth, depth);\n+  determinant = lambda_matrix_inverse (LTM_MATRIX (H), inverse, depth);\n+\n+  /* H1 is H excluding its diagonal.  */\n+  H1 = lambda_matrix_new (depth, depth);\n+  lambda_matrix_copy (LTM_MATRIX (H), H1, depth, depth);\n+\n+  for (i = 0; i < depth; i++)\n+    H1[i][i] = 0;\n+\n+  /* Computes the linear offsets of the loop bounds.  */\n+  target = lambda_matrix_new (depth, depth);\n+  lambda_matrix_mult (H1, inverse, target, depth, depth, depth);\n+\n+  target_nest = lambda_loopnest_new (depth, invariants);\n+\n+  for (i = 0; i < depth; i++)\n+    {\n+\n+      /* Get a new loop structure.  */\n+      target_loop = lambda_loop_new ();\n+      LN_LOOPS (target_nest)[i] = target_loop;\n+\n+      /* Computes the gcd of the coefficients of the linear part.  */\n+      gcd1 = gcd_vector (target[i], i);\n+\n+      /* Include the denominator in the GCD  */\n+      gcd1 = gcd (gcd1, determinant);\n+\n+      /* Now divide through by the gcd  */\n+      for (j = 0; j < i; j++)\n+\ttarget[i][j] = target[i][j] / gcd1;\n+\n+      expression = lambda_linear_expression_new (depth, invariants);\n+      lambda_vector_copy (target[i], LLE_COEFFICIENTS (expression), depth);\n+      LLE_DENOMINATOR (expression) = determinant / gcd1;\n+      LLE_CONSTANT (expression) = 0;\n+      lambda_vector_clear (LLE_INVARIANT_COEFFICIENTS (expression),\n+\t\t\t   invariants);\n+      LL_LINEAR_OFFSET (target_loop) = expression;\n+    }\n+\n+  /* For each loop, compute the new bounds from H */\n+  for (i = 0; i < depth; i++)\n+    {\n+      auxillary_loop = LN_LOOPS (auxillary_nest)[i];\n+      target_loop = LN_LOOPS (target_nest)[i];\n+      LL_STEP (target_loop) = LTM_MATRIX (H)[i][i];\n+      factor = LTM_MATRIX (H)[i][i];\n+\n+      /* First we do the lower bound.  */\n+      auxillary_expr = LL_LOWER_BOUND (auxillary_loop);\n+\n+      for (; auxillary_expr != NULL;\n+\t   auxillary_expr = LLE_NEXT (auxillary_expr))\n+\t{\n+\t  target_expr = lambda_linear_expression_new (depth, invariants);\n+\t  lambda_vector_matrix_mult (LLE_COEFFICIENTS (auxillary_expr),\n+\t\t\t\t     depth, inverse, depth,\n+\t\t\t\t     LLE_COEFFICIENTS (target_expr));\n+\t  lambda_vector_mult_const (LLE_COEFFICIENTS (target_expr),\n+\t\t\t\t    LLE_COEFFICIENTS (target_expr), depth,\n+\t\t\t\t    factor);\n+\n+\t  LLE_CONSTANT (target_expr) = LLE_CONSTANT (auxillary_expr) * factor;\n+\t  lambda_vector_copy (LLE_INVARIANT_COEFFICIENTS (auxillary_expr),\n+\t\t\t      LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t      invariants);\n+\t  lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t\t    LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t\t    invariants, factor);\n+\t  LLE_DENOMINATOR (target_expr) = LLE_DENOMINATOR (auxillary_expr);\n+\n+\t  if (!lambda_vector_zerop (LLE_COEFFICIENTS (target_expr), depth))\n+\t    {\n+\t      LLE_CONSTANT (target_expr) = LLE_CONSTANT (target_expr)\n+\t\t* determinant;\n+\t      lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS\n+\t\t\t\t\t(target_expr),\n+\t\t\t\t\tLLE_INVARIANT_COEFFICIENTS\n+\t\t\t\t\t(target_expr), invariants,\n+\t\t\t\t\tdeterminant);\n+\t      LLE_DENOMINATOR (target_expr) =\n+\t\tLLE_DENOMINATOR (target_expr) * determinant;\n+\t    }\n+\t  /* Find the gcd and divide by it here, rather than doing it\n+\t     at the tree level.  */\n+\t  gcd1 = gcd_vector (LLE_COEFFICIENTS (target_expr), depth);\n+\t  gcd2 = gcd_vector (LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t     invariants);\n+\t  gcd1 = gcd (gcd1, gcd2);\n+\t  gcd1 = gcd (gcd1, LLE_CONSTANT (target_expr));\n+\t  gcd1 = gcd (gcd1, LLE_DENOMINATOR (target_expr));\n+\t  for (j = 0; j < depth; j++)\n+\t    LLE_COEFFICIENTS (target_expr)[j] /= gcd1;\n+\t  for (j = 0; j < invariants; j++)\n+\t    LLE_INVARIANT_COEFFICIENTS (target_expr)[j] /= gcd1;\n+\t  LLE_CONSTANT (target_expr) /= gcd1;\n+\t  LLE_DENOMINATOR (target_expr) /= gcd1;\n+\t  /* Ignore if identical to existing bound.  */\n+\t  if (!lle_equal (LL_LOWER_BOUND (target_loop), target_expr, depth,\n+\t\t\t  invariants))\n+\t    {\n+\t      LLE_NEXT (target_expr) = LL_LOWER_BOUND (target_loop);\n+\t      LL_LOWER_BOUND (target_loop) = target_expr;\n+\t    }\n+\t}\n+      /* Now do the upper bound.  */\n+      auxillary_expr = LL_UPPER_BOUND (auxillary_loop);\n+\n+      for (; auxillary_expr != NULL;\n+\t   auxillary_expr = LLE_NEXT (auxillary_expr))\n+\t{\n+\t  target_expr = lambda_linear_expression_new (depth, invariants);\n+\t  lambda_vector_matrix_mult (LLE_COEFFICIENTS (auxillary_expr),\n+\t\t\t\t     depth, inverse, depth,\n+\t\t\t\t     LLE_COEFFICIENTS (target_expr));\n+\t  lambda_vector_mult_const (LLE_COEFFICIENTS (target_expr),\n+\t\t\t\t    LLE_COEFFICIENTS (target_expr), depth,\n+\t\t\t\t    factor);\n+\t  LLE_CONSTANT (target_expr) = LLE_CONSTANT (auxillary_expr) * factor;\n+\t  lambda_vector_copy (LLE_INVARIANT_COEFFICIENTS (auxillary_expr),\n+\t\t\t      LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t      invariants);\n+\t  lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t\t    LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t\t    invariants, factor);\n+\t  LLE_DENOMINATOR (target_expr) = LLE_DENOMINATOR (auxillary_expr);\n+\n+\t  if (!lambda_vector_zerop (LLE_COEFFICIENTS (target_expr), depth))\n+\t    {\n+\t      LLE_CONSTANT (target_expr) = LLE_CONSTANT (target_expr)\n+\t\t* determinant;\n+\t      lambda_vector_mult_const (LLE_INVARIANT_COEFFICIENTS\n+\t\t\t\t\t(target_expr),\n+\t\t\t\t\tLLE_INVARIANT_COEFFICIENTS\n+\t\t\t\t\t(target_expr), invariants,\n+\t\t\t\t\tdeterminant);\n+\t      LLE_DENOMINATOR (target_expr) =\n+\t\tLLE_DENOMINATOR (target_expr) * determinant;\n+\t    }\n+\t  /* Find the gcd and divide by it here, instead of at the\n+\t     tree level.  */\n+\t  gcd1 = gcd_vector (LLE_COEFFICIENTS (target_expr), depth);\n+\t  gcd2 = gcd_vector (LLE_INVARIANT_COEFFICIENTS (target_expr),\n+\t\t\t     invariants);\n+\t  gcd1 = gcd (gcd1, gcd2);\n+\t  gcd1 = gcd (gcd1, LLE_CONSTANT (target_expr));\n+\t  gcd1 = gcd (gcd1, LLE_DENOMINATOR (target_expr));\n+\t  for (j = 0; j < depth; j++)\n+\t    LLE_COEFFICIENTS (target_expr)[j] /= gcd1;\n+\t  for (j = 0; j < invariants; j++)\n+\t    LLE_INVARIANT_COEFFICIENTS (target_expr)[j] /= gcd1;\n+\t  LLE_CONSTANT (target_expr) /= gcd1;\n+\t  LLE_DENOMINATOR (target_expr) /= gcd1;\n+\t  /* Ignore if equal to existing bound.  */\n+\t  if (!lle_equal (LL_UPPER_BOUND (target_loop), target_expr, depth,\n+\t\t\t  invariants))\n+\t    {\n+\t      LLE_NEXT (target_expr) = LL_UPPER_BOUND (target_loop);\n+\t      LL_UPPER_BOUND (target_loop) = target_expr;\n+\t    }\n+\t}\n+    }\n+  for (i = 0; i < depth; i++)\n+    {\n+      target_loop = LN_LOOPS (target_nest)[i];\n+      /* If necessary, exchange the upper and lower bounds and negate\n+         the step size.  */\n+      if (stepsigns[i] < 0)\n+\t{\n+\t  LL_STEP (target_loop) *= -1;\n+\t  tmp_expr = LL_LOWER_BOUND (target_loop);\n+\t  LL_LOWER_BOUND (target_loop) = LL_UPPER_BOUND (target_loop);\n+\t  LL_UPPER_BOUND (target_loop) = tmp_expr;\n+\t}\n+    }\n+  return target_nest;\n+}\n+\n+/* Compute the step signs of TRANS, using TRANS and stepsigns.  Return the new\n+   result.  */\n+\n+static lambda_vector\n+lambda_compute_step_signs (lambda_trans_matrix trans, lambda_vector stepsigns)\n+{\n+  lambda_matrix matrix, H;\n+  int size;\n+  lambda_vector newsteps;\n+  int i, j, factor, minimum_column;\n+  int temp;\n+\n+  matrix = LTM_MATRIX (trans);\n+  size = LTM_ROWSIZE (trans);\n+  H = lambda_matrix_new (size, size);\n+\n+  newsteps = lambda_vector_new (size);\n+  lambda_vector_copy (stepsigns, newsteps, size);\n+\n+  lambda_matrix_copy (matrix, H, size, size);\n+\n+  for (j = 0; j < size; j++)\n+    {\n+      lambda_vector row;\n+      row = H[j];\n+      for (i = j; i < size; i++)\n+\tif (row[i] < 0)\n+\t  lambda_matrix_col_negate (H, size, i);\n+      while (lambda_vector_first_nz (row, size, j + 1) < size)\n+\t{\n+\t  minimum_column = lambda_vector_min_nz (row, size, j);\n+\t  lambda_matrix_col_exchange (H, size, j, minimum_column);\n+\n+\t  temp = newsteps[j];\n+\t  newsteps[j] = newsteps[minimum_column];\n+\t  newsteps[minimum_column] = temp;\n+\n+\t  for (i = j + 1; i < size; i++)\n+\t    {\n+\t      factor = row[i] / row[j];\n+\t      lambda_matrix_col_add (H, size, j, i, -1 * factor);\n+\t    }\n+\t}\n+    }\n+  return newsteps;\n+}\n+\n+/* Transform NEST according to TRANS, and return the new loopnest.\n+   This involves\n+   1. Computing a lattice base for the transformation\n+   2. Composing the dense base with the specified transformation (TRANS)\n+   3. Decomposing the combined transformation into a lower triangular portion,\n+   and a unimodular portion. \n+   4. Computing the auxillary nest using the unimodular portion.\n+   5. Computing the target nest using the auxillary nest and the lower\n+   triangular portion.  */ \n+\n+lambda_loopnest\n+lambda_loopnest_transform (lambda_loopnest nest, lambda_trans_matrix trans)\n+{\n+  lambda_loopnest auxillary_nest, target_nest;\n+\n+  int depth, invariants;\n+  int i, j;\n+  lambda_lattice lattice;\n+  lambda_trans_matrix trans1, H, U;\n+  lambda_loop loop;\n+  lambda_linear_expression expression;\n+  lambda_vector origin;\n+  lambda_matrix origin_invariants;\n+  lambda_vector stepsigns;\n+  int f;\n+\n+  depth = LN_DEPTH (nest);\n+  invariants = LN_INVARIANTS (nest);\n+\n+  /* Keep track of the signs of the loop steps.  */\n+  stepsigns = lambda_vector_new (depth);\n+  for (i = 0; i < depth; i++)\n+    {\n+      if (LL_STEP (LN_LOOPS (nest)[i]) > 0)\n+\tstepsigns[i] = 1;\n+      else\n+\tstepsigns[i] = -1;\n+    }\n+\n+  /* Compute the lattice base.  */\n+  lattice = lambda_lattice_compute_base (nest);\n+  trans1 = lambda_trans_matrix_new (depth, depth);\n+\n+  /* Multiply the transformation matrix by the lattice base.  */\n+\n+  lambda_matrix_mult (LTM_MATRIX (trans), LATTICE_BASE (lattice),\n+\t\t      LTM_MATRIX (trans1), depth, depth, depth);\n+\n+  /* Compute the Hermite normal form for the new transformation matrix.  */\n+  H = lambda_trans_matrix_new (depth, depth);\n+  U = lambda_trans_matrix_new (depth, depth);\n+  lambda_matrix_hermite (LTM_MATRIX (trans1), depth, LTM_MATRIX (H),\n+\t\t\t LTM_MATRIX (U));\n+\n+  /* Compute the auxiliary loop nest's space from the unimodular\n+     portion.  */\n+  auxillary_nest = lambda_compute_auxillary_space (nest, U);\n+\n+  /* Compute the loop step signs from the old step signs and the\n+     transformation matrix.  */\n+  stepsigns = lambda_compute_step_signs (trans1, stepsigns);\n+\n+  /* Compute the target loop nest space from the auxiliary nest and\n+     the lower triangular matrix H.  */\n+  target_nest = lambda_compute_target_space (auxillary_nest, H, stepsigns);\n+  origin = lambda_vector_new (depth);\n+  origin_invariants = lambda_matrix_new (depth, invariants);\n+  lambda_matrix_vector_mult (LTM_MATRIX (trans), depth, depth,\n+\t\t\t     LATTICE_ORIGIN (lattice), origin);\n+  lambda_matrix_mult (LTM_MATRIX (trans), LATTICE_ORIGIN_INVARIANTS (lattice),\n+\t\t      origin_invariants, depth, depth, invariants);\n+\n+  for (i = 0; i < depth; i++)\n+    {\n+      loop = LN_LOOPS (target_nest)[i];\n+      expression = LL_LINEAR_OFFSET (loop);\n+      if (lambda_vector_zerop (LLE_COEFFICIENTS (expression), depth))\n+\tf = 1;\n+      else\n+\tf = LLE_DENOMINATOR (expression);\n+\n+      LLE_CONSTANT (expression) += f * origin[i];\n+\n+      for (j = 0; j < invariants; j++)\n+\tLLE_INVARIANT_COEFFICIENTS (expression)[j] +=\n+\t  f * origin_invariants[i][j];\n+    }\n+\n+  return target_nest;\n+\n+}\n+\n+/* Convert a gcc tree expression EXPR to a lambda linear expression, and\n+   return the new expression.  DEPTH is the depth of the loopnest.\n+   OUTERINDUCTIONVARS is an array of the induction variables for outer loops\n+   in this nest.  INVARIANTS is the array of invariants for the loop.  EXTRA\n+   is the amount we have to add/subtract from the expression because of the\n+   type of comparison it is used in.  */\n+\n+static lambda_linear_expression\n+gcc_tree_to_linear_expression (int depth, tree expr,\n+\t\t\t       VEC(tree) *outerinductionvars,\n+\t\t\t       VEC(tree) *invariants, int extra)\n+{\n+  lambda_linear_expression lle = NULL;\n+  switch (TREE_CODE (expr))\n+    {\n+    case INTEGER_CST:\n+      {\n+\tlle = lambda_linear_expression_new (depth, 2 * depth);\n+\tLLE_CONSTANT (lle) = TREE_INT_CST_LOW (expr);\n+\tif (extra != 0)\n+\t  LLE_CONSTANT (lle) = extra;\n+\n+\tLLE_DENOMINATOR (lle) = 1;\n+      }\n+      break;\n+    case SSA_NAME:\n+      {\n+\ttree iv, invar;\n+\tsize_t i;\n+\tfor (i = 0; VEC_iterate (tree, outerinductionvars, i, iv); i++)\n+\t  if (iv != NULL)\n+\t    {\n+\t      if (SSA_NAME_VAR (iv) == SSA_NAME_VAR (expr))\n+\t\t{\n+\t\t  lle = lambda_linear_expression_new (depth, 2 * depth);\n+\t\t  LLE_COEFFICIENTS (lle)[i] = 1;\n+\t\t  if (extra != 0)\n+\t\t    LLE_CONSTANT (lle) = extra;\n+\n+\t\t  LLE_DENOMINATOR (lle) = 1;\n+\t\t}\n+\t    }\n+\tfor (i = 0; VEC_iterate (tree, invariants, i, invar); i++)\n+\t  if (invar != NULL)\n+\t    {\n+\t      if (SSA_NAME_VAR (invar) == SSA_NAME_VAR (expr))\n+\t\t{\n+\t\t  lle = lambda_linear_expression_new (depth, 2 * depth);\n+\t\t  LLE_INVARIANT_COEFFICIENTS (lle)[i] = 1;\n+\t\t  if (extra != 0)\n+\t\t    LLE_CONSTANT (lle) = extra;\n+\t\t  LLE_DENOMINATOR (lle) = 1;\n+\t\t}\n+\t    }\n+      }\n+      break;\n+    default:\n+      return NULL;\n+    }\n+\n+  return lle;\n+}\n+\n+/* Return true if OP is invariant in LOOP and all outer loops.  */\n+\n+static bool\n+invariant_in_loop (struct loop *loop, tree op)\n+{\n+  if (loop->depth == 0)\n+    return true;\n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      if (TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL\n+\t  && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (op)))\n+\treturn true;\n+      if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (op)))\n+\treturn false;\n+      if (loop->outer)\n+\tif (!invariant_in_loop (loop->outer, op))\n+\t  return false;\n+      return !flow_bb_inside_loop_p (loop,\n+\t\t\t\t     bb_for_stmt (SSA_NAME_DEF_STMT (op)));\n+    }\n+  return false;\n+}\n+\n+/* Generate a lambda loop from a gcc loop LOOP.  Return the new lambda loop,\n+   or NULL if it could not be converted.\n+   DEPTH is the depth of the loop.\n+   INVARIANTS is a pointer to the array of loop invariants.\n+   The induction variable for this loop should be stored in the parameter\n+   OURINDUCTIONVAR.\n+   OUTERINDUCTIONVARS is an array of induction variables for outer loops.  */\n+\n+static lambda_loop\n+gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n+\t\t\t VEC (tree) ** invariants,\n+\t\t\t tree * ourinductionvar,\n+\t\t\t VEC (tree) * outerinductionvars)\n+{\n+  tree phi;\n+  tree exit_cond;\n+  tree access_fn, inductionvar;\n+  tree step;\n+  lambda_loop lloop = NULL;\n+  lambda_linear_expression lbound, ubound;\n+  tree test;\n+  int stepint;\n+  int extra = 0;\n+\n+  use_optype uses;\n+\n+  /* Find out induction var and set the pointer so that the caller can\n+     append it to the outerinductionvars array later.  */\n+\n+  inductionvar = find_induction_var_from_exit_cond (loop);\n+  *ourinductionvar = inductionvar;\n+\n+  exit_cond = get_loop_exit_condition (loop);\n+\n+  if (inductionvar == NULL || exit_cond == NULL)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: Cannot determine exit condition or induction variable for loop.\\n\");\n+      return NULL;\n+    }\n+\n+  test = TREE_OPERAND (exit_cond, 0);\n+  if (TREE_CODE (test) != LE_EXPR\n+      && TREE_CODE (test) != LT_EXPR && TREE_CODE (test) != NE_EXPR)\n+    {\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"Unable to convert loop: Loop exit test uses unhandled test condition:\");\n+\t  print_generic_stmt (dump_file, test, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return NULL;\n+    }\n+  if (SSA_NAME_DEF_STMT (inductionvar) == NULL_TREE)\n+    {\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: Cannot find PHI node for induction variable\\n\");\n+\n+      return NULL;\n+    }\n+\n+  phi = SSA_NAME_DEF_STMT (inductionvar);\n+  if (TREE_CODE (phi) != PHI_NODE)\n+    {\n+      get_stmt_operands (phi);\n+      uses = STMT_USE_OPS (phi);\n+\n+      if (!uses)\n+\t{\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Unable to convert loop: Cannot find PHI node for induction variable\\n\");\n+\n+\t  return NULL;\n+\t}\n+\n+      phi = USE_OP (uses, 0);\n+      phi = SSA_NAME_DEF_STMT (phi);\n+      if (TREE_CODE (phi) != PHI_NODE)\n+\t{\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Unable to convert loop: Cannot find PHI node for induction variable\\n\");\n+\t  return NULL;\n+\t}\n+\n+    }\n+\n+  access_fn = instantiate_parameters\n+    (loop, analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n+  if (!access_fn)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: Access function for induction variable phi is NULL\\n\");\n+\n+      return NULL;\n+    }\n+\n+  step = evolution_part_in_loop_num (access_fn, loop->num);\n+  if (!step || step == chrec_dont_know)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: Cannot determine step of loop.\\n\");\n+\n+      return NULL;\n+    }\n+  if (TREE_CODE (step) != INTEGER_CST)\n+    {\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: Step of loop is not integer.\\n\");\n+      return NULL;\n+    }\n+\n+  stepint = TREE_INT_CST_LOW (step);\n+\n+  /* Only want phis for induction vars, which will have two\n+     arguments.  */\n+  if (PHI_NUM_ARGS (phi) != 2)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: PHI node for induction variable has >2 arguments\\n\");\n+      return NULL;\n+    }\n+\n+  /* Another induction variable check. One argument's source should be\n+     in the loop, one outside the loop.  */\n+  if (flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, 0)->src)\n+      && flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, 1)->src))\n+    {\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: PHI edges both inside loop, or both outside loop.\\n\");\n+\n+      return NULL;\n+    }\n+\n+  if (flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, 0)->src))\n+\n+    lbound = gcc_tree_to_linear_expression (depth, PHI_ARG_DEF (phi, 1),\n+\t\t\t\t\t    outerinductionvars, *invariants,\n+\t\t\t\t\t    0);\n+  else\n+    lbound = gcc_tree_to_linear_expression (depth, PHI_ARG_DEF (phi, 0),\n+\t\t\t\t\t    outerinductionvars, *invariants,\n+\t\t\t\t\t    0);\n+  if (!lbound)\n+    {\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: Cannot convert lower bound to linear expression\\n\");\n+\n+      return NULL;\n+    }\n+  if (TREE_CODE (TREE_OPERAND (test, 1)) == SSA_NAME)\n+    if (invariant_in_loop (loop, TREE_OPERAND (test, 1)))\n+      VEC_safe_push (tree, *invariants, TREE_OPERAND (test, 1));\n+\n+  /* We only size the vectors assuming we have, at max, 2 times as many\n+     invariants as we do loops (one for each bound).\n+     This is just an arbitrary number, but it has to be matched against the\n+     code below.  */\n+  if (VEC_length (tree, *invariants) > (unsigned int) (2 * depth))\n+    abort ();\n+\n+  /* We might have some leftover. */\n+  if (TREE_CODE (test) == LT_EXPR)\n+    extra = -1 * stepint;\n+  else if (TREE_CODE (test) == NE_EXPR)\n+    extra = -1 * stepint;\n+\n+  ubound = gcc_tree_to_linear_expression (depth,\n+\t\t\t\t\t  TREE_OPERAND (test, 1),\n+\t\t\t\t\t  outerinductionvars,\n+\t\t\t\t\t  *invariants, extra);\n+  if (!ubound)\n+    {\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Unable to convert loop: Cannot convert upper bound to linear expression\\n\");\n+      return NULL;\n+    }\n+\n+  lloop = lambda_loop_new ();\n+  LL_STEP (lloop) = stepint;\n+  LL_LOWER_BOUND (lloop) = lbound;\n+  LL_UPPER_BOUND (lloop) = ubound;\n+  return lloop;\n+}\n+\n+/* Given a LOOP, find the induction variable it is testing against in the exit\n+   condition.  Return the induction variable if found, NULL otherwise.  */\n+\n+static tree\n+find_induction_var_from_exit_cond (struct loop *loop)\n+{\n+  tree expr = get_loop_exit_condition (loop);\n+  tree test;\n+  if (expr == NULL_TREE)\n+    return NULL_TREE;\n+  if (TREE_CODE (expr) != COND_EXPR)\n+    return NULL_TREE;\n+  test = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE_CLASS (TREE_CODE (test)) != '<')\n+    return NULL_TREE;\n+  if (TREE_CODE (TREE_OPERAND (test, 0)) != SSA_NAME)\n+    return NULL_TREE;\n+  return TREE_OPERAND (test, 0);\n+}\n+\n+DEF_VEC_P(lambda_loop);\n+/* Generate a lambda loopnest from a gcc loopnest LOOP_NEST.\n+   Return the new loop nest.  \n+   INDUCTIONVARS is a pointer to an array of induction variables for the\n+   loopnest that will be filled in during this process.\n+   INVARIANTS is a pointer to an array of invariants that will be filled in\n+   during this process.  */\n+\n+lambda_loopnest\n+gcc_loopnest_to_lambda_loopnest (struct loop * loop_nest,\n+\t\t\t\t VEC (tree) **inductionvars,\n+\t\t\t\t VEC (tree) **invariants)\n+{\n+  lambda_loopnest ret;\n+  struct loop *temp;\n+  int depth = 0;\n+  size_t i;\n+  VEC (lambda_loop) *loops;\n+  lambda_loop newloop;\n+  tree inductionvar = NULL;\n+\n+  temp = loop_nest;\n+  while (temp)\n+    {\n+      depth++;\n+      temp = temp->inner;\n+    }\n+  loops = VEC_alloc (lambda_loop, 1);\n+  *inductionvars = VEC_alloc (tree, 1);\n+  *invariants = VEC_alloc (tree, 1);\n+  temp = loop_nest;\n+  while (temp)\n+    {\n+      newloop = gcc_loop_to_lambda_loop (temp, depth, invariants,\n+\t\t\t\t\t &inductionvar, *inductionvars);\n+      if (!newloop)\n+\treturn NULL;\n+      VEC_safe_push (tree, *inductionvars, inductionvar);\n+      VEC_safe_push (lambda_loop, loops, newloop);\n+      temp = temp->inner;\n+    }\n+\n+  ret = lambda_loopnest_new (depth, 2 * depth);\n+  for (i = 0; VEC_iterate (lambda_loop, loops, i, newloop); i++)\n+    LN_LOOPS (ret)[i] = newloop;\n+\n+  return ret;\n+\n+}\n+\n+/* Convert a lambda body vector LBV to a gcc tree, and return the new tree. \n+   STMTS_TO_INSERT is a pointer to a tree where the statements we need to be\n+   inserted for us are stored.  INDUCTION_VARS is the array of induction\n+   variables for the loop this LBV is from.  */\n+\n+static tree\n+lbv_to_gcc_expression (lambda_body_vector lbv,\n+\t\t       VEC (tree) *induction_vars, tree * stmts_to_insert)\n+{\n+  tree stmts, stmt, resvar, name;\n+  size_t i;\n+  tree_stmt_iterator tsi;\n+\n+  /* Create a statement list and a linear expression temporary.  */\n+  stmts = alloc_stmt_list ();\n+  resvar = create_tmp_var (integer_type_node, \"lletmp\");\n+  add_referenced_tmp_var (resvar);\n+\n+  /* Start at 0.  */\n+  stmt = build (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n+  name = make_ssa_name (resvar, stmt);\n+  TREE_OPERAND (stmt, 0) = name;\n+  tsi = tsi_last (stmts);\n+  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\n+  for (i = 0; i < VEC_length (tree ,induction_vars) ; i++)\n+    {\n+      if (LBV_COEFFICIENTS (lbv)[i] != 0)\n+\t{\n+\t  tree newname;\n+\n+\t  /* newname = coefficient * induction_variable */\n+\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\tfold (build (MULT_EXPR, integer_type_node,\n+\t\t\t\t     VEC_index (tree, induction_vars, i),\n+\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t    LBV_COEFFICIENTS (lbv)[i]))));\n+\t  newname = make_ssa_name (resvar, stmt);\n+\t  TREE_OPERAND (stmt, 0) = newname;\n+\t  tsi = tsi_last (stmts);\n+\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\t  /* name = name + newname */\n+\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\tbuild (PLUS_EXPR, integer_type_node, name, newname));\n+\t  name = make_ssa_name (resvar, stmt);\n+\t  TREE_OPERAND (stmt, 0) = name;\n+\t  tsi = tsi_last (stmts);\n+\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\t}\n+    }\n+\n+  /* Handle any denominator that occurs.  */\n+  if (LBV_DENOMINATOR (lbv) != 1)\n+    {\n+      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t    build (CEIL_DIV_EXPR, integer_type_node,\n+\t\t\t   name, build_int_cst (integer_type_node,\n+\t\t\t\t\t\tLBV_DENOMINATOR (lbv))));\n+      name = make_ssa_name (resvar, stmt);\n+      TREE_OPERAND (stmt, 0) = name;\n+      tsi = tsi_last (stmts);\n+      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+    }\n+  *stmts_to_insert = stmts;\n+  return name;\n+}\n+\n+/* Convert a linear expression from coefficient and constant form to a\n+   gcc tree.\n+   Return the tree that represents the final value of the expression.\n+   LLE is the linear expression to convert.\n+   OFFSET is the linear offset to apply to the expression.\n+   INDUCTION_VARS is a vector of induction variables for the loops.\n+   INVARIANTS is a vector of the loop nest invariants.\n+   WRAP specifies what tree code to wrap the results in, if there is more than\n+   one (it is either MAX_EXPR, or MIN_EXPR).\n+   STMTS_TO_INSERT Is a pointer to the statement list we fill in with\n+   statements that need to be inserted for the linear expression.  */\n+\n+static tree\n+lle_to_gcc_expression (lambda_linear_expression lle,\n+\t\t       lambda_linear_expression offset,\n+\t\t       VEC(tree) *induction_vars,\n+\t\t       VEC(tree) *invariants,\n+\t\t       enum tree_code wrap, tree * stmts_to_insert)\n+{\n+  tree stmts, stmt, resvar, name;\n+  size_t i;\n+  tree_stmt_iterator tsi;\n+  VEC(tree) *results;\n+\n+  name = NULL_TREE;\n+  /* Create a statement list and a linear expression temporary.  */\n+  stmts = alloc_stmt_list ();\n+  resvar = create_tmp_var (integer_type_node, \"lletmp\");\n+  add_referenced_tmp_var (resvar);\n+  results = VEC_alloc (tree, 1);\n+\n+  /* Build up the linear expressions, and put the variable representing the\n+     result in the results array.  */\n+  for (; lle != NULL; lle = LLE_NEXT (lle))\n+    {\n+      /* Start at name = 0.  */\n+      stmt = build (MODIFY_EXPR, void_type_node, resvar, integer_zero_node);\n+      name = make_ssa_name (resvar, stmt);\n+      TREE_OPERAND (stmt, 0) = name;\n+      tsi = tsi_last (stmts);\n+      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\n+      /* First do the induction variables.  \n+         at the end, name = name + all the induction variables added\n+         together.  */\n+      for (i = 0; i < VEC_length (tree ,induction_vars); i++)\n+\t{\n+\t  if (LLE_COEFFICIENTS (lle)[i] != 0)\n+\t    {\n+\t      tree newname;\n+\t      tree mult;\n+\t      tree coeff;\n+\n+\t      /* mult = induction variable * coefficient.  */\n+\t      if (LLE_COEFFICIENTS (lle)[i] == 1)\n+\t\t{\n+\t\t  mult = VEC_index (tree, induction_vars, i);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  coeff = build_int_cst (integer_type_node,\n+\t\t\t\t\t LLE_COEFFICIENTS (lle)[i]);\n+\t\t  mult = fold (build (MULT_EXPR, integer_type_node,\n+\t\t\t\t      VEC_index (tree, induction_vars, i),\n+\t\t\t\t      coeff));\n+\t\t}\n+\n+\t      /* newname = mult */\n+\t      stmt = build (MODIFY_EXPR, void_type_node, resvar, mult);\n+\t      newname = make_ssa_name (resvar, stmt);\n+\t      TREE_OPERAND (stmt, 0) = newname;\n+\t      tsi = tsi_last (stmts);\n+\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\n+\t      /* name = name + newname */\n+\t      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t    build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t   name, newname));\n+\t      name = make_ssa_name (resvar, stmt);\n+\t      TREE_OPERAND (stmt, 0) = name;\n+\t      tsi = tsi_last (stmts);\n+\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\t    }\n+\t}\n+\n+      /* Handle our invariants.\n+         At the end, we have name = name + result of adding all multiplied\n+         invariants.  */\n+      for (i = 0; i < VEC_length (tree, invariants); i++)\n+\t{\n+\t  if (LLE_INVARIANT_COEFFICIENTS (lle)[i] != 0)\n+\t    {\n+\t      tree newname;\n+\t      tree mult;\n+\t      tree coeff;\n+\n+\t      /* mult = invariant * coefficient  */\n+\t      if (LLE_INVARIANT_COEFFICIENTS (lle)[i] == 1)\n+\t\t{\n+\t\t  mult = VEC_index (tree, invariants, i);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  coeff = build_int_cst (integer_type_node,\n+\t\t\t\t\t LLE_INVARIANT_COEFFICIENTS (lle)[i]);\n+\t\t  mult = fold (build (MULT_EXPR, integer_type_node,\n+\t\t\t\t      VEC_index (tree, invariants, i),\n+\t\t\t\t      coeff));\n+\t\t}\n+\n+\t      /* newname = mult */\n+\t      stmt = build (MODIFY_EXPR, void_type_node, resvar, mult);\n+\t      newname = make_ssa_name (resvar, stmt);\n+\t      TREE_OPERAND (stmt, 0) = newname;\n+\t      tsi = tsi_last (stmts);\n+\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\n+\t      /* name = name + newname */\n+\t      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t    build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t   name, newname));\n+\t      name = make_ssa_name (resvar, stmt);\n+\t      TREE_OPERAND (stmt, 0) = name;\n+\t      tsi = tsi_last (stmts);\n+\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\t    }\n+\t}\n+\n+      /* Now handle the constant.\n+         name = name + constant.  */\n+      if (LLE_CONSTANT (lle) != 0)\n+\t{\n+\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\tbuild (PLUS_EXPR, integer_type_node,\n+\t\t\t       name, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t    LLE_CONSTANT (lle))));\n+\t  name = make_ssa_name (resvar, stmt);\n+\t  TREE_OPERAND (stmt, 0) = name;\n+\t  tsi = tsi_last (stmts);\n+\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\t}\n+\n+      /* Now handle the offset.\n+         name = name + linear offset.  */\n+      if (LLE_CONSTANT (offset) != 0)\n+\t{\n+\t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\tbuild (PLUS_EXPR, integer_type_node,\n+\t\t\t       name, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t    LLE_CONSTANT (offset))));\n+\t  name = make_ssa_name (resvar, stmt);\n+\t  TREE_OPERAND (stmt, 0) = name;\n+\t  tsi = tsi_last (stmts);\n+\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\t}\n+\n+      /* Handle any denominator that occurs.  */\n+      if (LLE_DENOMINATOR (lle) != 1)\n+\t{\n+\t  if (wrap == MAX_EXPR)\n+\t    stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t  build (CEIL_DIV_EXPR, integer_type_node,\n+\t\t\t\t name, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t      LLE_DENOMINATOR (lle))));\n+\t  else if (wrap == MIN_EXPR)\n+\t    stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t\t  build (FLOOR_DIV_EXPR, integer_type_node,\n+\t\t\t\t name, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t      LLE_DENOMINATOR (lle))));\n+\t  else\n+\t    abort ();\n+\n+\t  /* name = {ceil, floor}(name/denominator) */\n+\t  name = make_ssa_name (resvar, stmt);\n+\t  TREE_OPERAND (stmt, 0) = name;\n+\t  tsi = tsi_last (stmts);\n+\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+\t}\n+      VEC_safe_push (tree, results, name);\n+    }\n+\n+  /* Again, out of laziness, we don't handle this case yet.  It's not\n+     hard, it just hasn't occurred.  */\n+  if (VEC_length (tree, results) > 2)\n+    abort ();\n+\n+  /* We may need to wrap the results in a MAX_EXPR or MIN_EXPR.  */\n+  if (VEC_length (tree, results) > 1)\n+    {\n+      tree op1 = VEC_index (tree, results, 0);\n+      tree op2 = VEC_index (tree, results, 1);\n+      stmt = build (MODIFY_EXPR, void_type_node, resvar,\n+\t\t    build (wrap, integer_type_node, op1, op2));\n+      name = make_ssa_name (resvar, stmt);\n+      TREE_OPERAND (stmt, 0) = name;\n+      tsi = tsi_last (stmts);\n+      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+    }\n+\n+  *stmts_to_insert = stmts;\n+  return name;\n+}\n+\n+/* Transform a lambda loopnest NEW_LOOPNEST, which had TRANSFORM applied to\n+   it, back into gcc code.  This changes the\n+   loops, their induction variables, and their bodies, so that they\n+   match the transformed loopnest.  \n+   OLD_LOOPNEST is the loopnest before we've replaced it with the new\n+   loopnest.\n+   OLD_IVS is a vector of induction variables from the old loopnest.\n+   INVARIANTS is a vector of loop invariants from the old loopnest.\n+   NEW_LOOPNEST is the new lambda loopnest to replace OLD_LOOPNEST with.\n+   TRANSFORM is the matrix transform that was applied to OLD_LOOPNEST to get \n+   NEW_LOOPNEST.  */\n+void\n+lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n+\t\t\t\t VEC(tree) *old_ivs,\n+\t\t\t\t VEC(tree) *invariants,\n+\t\t\t\t lambda_loopnest new_loopnest,\n+\t\t\t\t lambda_trans_matrix transform)\n+{\n+\n+  struct loop *temp;\n+  size_t i = 0;\n+  size_t depth = 0;\n+  VEC(tree) *new_ivs;\n+  block_stmt_iterator bsi;\n+  basic_block *bbs;\n+\n+  if (dump_file)\n+    {\n+      transform = lambda_trans_matrix_inverse (transform);\n+      fprintf (dump_file, \"Inverse of transformation matrix:\\n\");\n+      print_lambda_trans_matrix (dump_file, transform);\n+    }\n+  temp = old_loopnest;\n+  new_ivs = VEC_alloc (tree, 1);\n+  while (temp)\n+    {\n+      temp = temp->inner;\n+      depth++;\n+    }\n+  temp = old_loopnest;\n+\n+  while (temp)\n+    {\n+      lambda_loop newloop;\n+      basic_block bb;\n+      tree ivvar, ivvarinced, exitcond, stmts;\n+      enum tree_code testtype;\n+      tree newupperbound, newlowerbound;\n+      lambda_linear_expression offset;\n+      /* First, build the new induction variable temporary  */\n+\n+      ivvar = create_tmp_var (integer_type_node, \"lnivtmp\");\n+      add_referenced_tmp_var (ivvar);\n+\n+      VEC_safe_push (tree, new_ivs, ivvar);\n+\n+      newloop = LN_LOOPS (new_loopnest)[i];\n+\n+      /* Linear offset is a bit tricky to handle.  Punt on the unhandled\n+         cases for now. */\n+      offset = LL_LINEAR_OFFSET (newloop);\n+\n+      if (LLE_DENOMINATOR (offset) != 1\n+\t  || !lambda_vector_zerop (LLE_COEFFICIENTS (offset), depth))\n+\tabort ();\n+\n+      /* Now build the  new lower bounds, and insert the statements\n+         necessary to generate it on the loop preheader. */\n+      newlowerbound = lle_to_gcc_expression (LL_LOWER_BOUND (newloop),\n+\t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n+\t\t\t\t\t     new_ivs,\n+\t\t\t\t\t     invariants, MAX_EXPR, &stmts);\n+      bsi_insert_on_edge (loop_preheader_edge (temp), stmts);\n+      bsi_commit_edge_inserts (NULL);\n+      /* Build the new upper bound and insert its statements in the\n+         basic block of the exit condition */\n+      newupperbound = lle_to_gcc_expression (LL_UPPER_BOUND (newloop),\n+\t\t\t\t\t     LL_LINEAR_OFFSET (newloop),\n+\t\t\t\t\t     new_ivs,\n+\t\t\t\t\t     invariants, MIN_EXPR, &stmts);\n+      exitcond = get_loop_exit_condition (temp);\n+      bb = bb_for_stmt (exitcond);\n+      bsi = bsi_start (bb);\n+      bsi_insert_after (&bsi, stmts, BSI_NEW_STMT);\n+\n+      /* Create the new iv, and insert it's increment on the latch\n+         block.  */\n+\n+      bb = temp->latch->pred->src;\n+      bsi = bsi_last (bb);\n+      create_iv (newlowerbound,\n+\t\t build_int_cst (integer_type_node, LL_STEP (newloop)),\n+\t\t ivvar, temp, &bsi, false, &ivvar,\n+\t\t &ivvarinced);\n+\n+      /* Replace the exit condition with the new upper bound\n+         comparison.  */\n+      testtype = LL_STEP (newloop) >= 0 ? LE_EXPR : GE_EXPR;\n+      COND_EXPR_COND (exitcond) = build (testtype,\n+\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t ivvarinced, newupperbound);\n+      modify_stmt (exitcond);\n+      VEC_replace (tree, new_ivs, i, ivvar);\n+\n+      i++;\n+      temp = temp->inner;\n+    }\n+\n+  /* Go through the loop and make iv replacements.  */\n+  bbs = get_loop_body (old_loopnest);\n+  for (i = 0; i < old_loopnest->num_nodes; i++)\n+    for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree stmt = bsi_stmt (bsi);\n+\tuse_optype uses;\n+\tsize_t j;\n+\n+\tget_stmt_operands (stmt);\n+\tuses = STMT_USE_OPS (stmt);\n+\tfor (j = 0; j < NUM_USES (uses); j++)\n+\t  {\n+\t    size_t k;\n+\t    use_operand_p use = USE_OP_PTR (uses, j);\n+\t    for (k = 0; k <  VEC_length (tree, old_ivs); k++)\n+\t      {\n+\t\ttree oldiv = VEC_index (tree, old_ivs, k);\n+\t\tif (USE_FROM_PTR (use) == oldiv)\n+\t\t  {\n+\t\t    tree newiv, stmts;\n+\t\t    lambda_body_vector lbv;\n+\n+\t\t    /* Compute the new expression for the induction\n+\t\t       variable.  */\n+\t\t    depth = VEC_length (tree, new_ivs);\n+\t\t    lbv = lambda_body_vector_new (depth);\n+\t\t    LBV_COEFFICIENTS (lbv)[k] = 1;\n+\t\t    lbv = lambda_body_vector_compute_new (transform, lbv);\n+\t\t    newiv = lbv_to_gcc_expression (lbv, new_ivs, &stmts);\n+\n+\t\t    /* Insert the statements to build that\n+\t\t       expression.  */\n+\t\t    bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\n+\t\t    /* Replace the use with the result of that\n+\t\t       expression.  */\n+\t\t    if (dump_file)\n+\t\t      {\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"Replacing induction variable use of \");\n+\t\t\tprint_generic_stmt (dump_file, USE_FROM_PTR (use), 0);\n+\t\t\tfprintf (dump_file, \" with \");\n+\t\t\tprint_generic_stmt (dump_file, newiv, 0);\n+\t\t\tfprintf (dump_file, \"\\n\");\n+\t\t      }\n+\t\t    SET_USE (use, newiv);\n+\t\t  }\n+\t      }\n+\n+\t  }\n+      }\n+}\n+\n+/* Returns true when the vector V is lexicographically positive, in\n+   other words, when the first non zero element is positive.  */\n+\n+static bool\n+lambda_vector_lexico_pos (lambda_vector v, unsigned n)\n+{\n+  unsigned i;\n+  for (i = 0; i < n; i++)\n+    {\n+      if (v[i] == 0)\n+\tcontinue;\n+      if (v[i] < 0)\n+\treturn false;\n+      if (v[i] > 0)\n+\treturn true;\n+    }\n+  return true;\n+}\n+\n+/* Return true if TRANS is a legal transformation matrix that respects\n+   the dependence vectors in DISTS and DIRS.  The conservative answer\n+   is false.\n+\n+   \"Wolfe proves that a unimodular transformation represented by the\n+   matrix T is legal when applied to a loop nest with a set of\n+   lexicographically non-negative distance vectors RDG if and only if\n+   for each vector d in RDG, (T.d >= 0) is lexicographically positive.\n+   ie.: if and only if it transforms the lexicographically positive\n+   distance vectors to lexicographically positive vectors.  Note that\n+   a unimodular matrix must transform the zero vector (and only it) to\n+   the zero vector.\" S.Muchnick.  */\n+\n+bool\n+lambda_transform_legal_p (lambda_trans_matrix trans,\n+\t\t\t  int nb_loops, varray_type dependence_relations)\n+{\n+  unsigned int i;\n+  lambda_vector distres;\n+  struct data_dependence_relation *ddr;\n+\n+#if defined ENABLE_CHECKING\n+  if (LTM_COLSIZE (trans) != nb_loops || LTM_ROWSIZE (trans) != nb_loops)\n+    abort ();\n+#endif\n+\n+  /* When there is an unknown relation in the dependence_relations, we\n+     know that it is no worth looking at this loop nest: give up.  */\n+  ddr = (struct data_dependence_relation *)\n+    VARRAY_GENERIC_PTR (dependence_relations, 0);\n+  if (ddr == NULL)\n+    return true;\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+    return false;\n+\n+  distres = lambda_vector_new (nb_loops);\n+\n+  /* For each distance vector in the dependence graph.  */\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+    {\n+      ddr = (struct data_dependence_relation *)\n+\tVARRAY_GENERIC_PTR (dependence_relations, i);\n+\n+      /* Don't care about relations for which we know that there is no\n+         dependence, nor about read-read (aka. output-dependences):\n+         these data accesses can happen in any order.  */\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_known\n+\t  || (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr))))\n+\tcontinue;\n+      /* Conservatively answer: \"this transformation is not valid\".  */\n+      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+\treturn false;\n+\n+      /* Compute trans.dist_vect */\n+      lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops,\n+\t\t\t\t DDR_DIST_VECT (ddr), distres);\n+\n+      if (!lambda_vector_lexico_pos (distres, nb_loops))\n+\treturn false;\n+    }\n+\n+  return true;\n+}"}, {"sha": "dddfd3a01101a87e7a7a5e62a16e23975e0933f3", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -24,6 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"varray.h\"\n+#include \"tree.h\"\n #include \"lambda.h\"\n \n static void lambda_matrix_get_column (lambda_matrix, int, int, "}, {"sha": "5195bb61c8fe0cd5fcce2ed31ae6b5e3f4ff4b61", "filename": "gcc/lambda-trans.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-trans.c?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -0,0 +1,71 @@\n+/* Lambda matrix transformations.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dberlin@dberlin.org>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"target.h\"\n+#include \"varray.h\"\n+#include \"lambda.h\"\n+\n+/* Allocate a new transformation matrix.  */\n+\n+lambda_trans_matrix\n+lambda_trans_matrix_new (int colsize, int rowsize)\n+{\n+  lambda_trans_matrix ret;\n+  \n+  ret = ggc_alloc (sizeof (*ret));\n+  LTM_MATRIX (ret) = lambda_matrix_new (rowsize, colsize);\n+  LTM_ROWSIZE (ret) = rowsize;\n+  LTM_COLSIZE (ret) = colsize;\n+  LTM_DENOMINATOR (ret) = 1;\n+  return ret;\n+}\n+\n+/* Compute the inverse of the transformation.  */\n+\n+lambda_trans_matrix \n+lambda_trans_matrix_inverse (lambda_trans_matrix mat)\n+{\n+  lambda_trans_matrix inverse;\n+  int determinant;\n+  \n+  inverse = lambda_trans_matrix_new (LTM_ROWSIZE (mat), LTM_COLSIZE (mat));\n+  determinant = lambda_matrix_inverse (LTM_MATRIX (mat), LTM_MATRIX (inverse), \n+\t\t\t\t       LTM_ROWSIZE (mat));\n+  LTM_DENOMINATOR (inverse) = determinant;\n+  return inverse;\n+}\n+\n+\n+/* Print out a transformation matrix.  */\n+\n+void\n+print_lambda_trans_matrix (FILE *outfile, lambda_trans_matrix mat)\n+{\n+  print_lambda_matrix (outfile, LTM_MATRIX (mat), LTM_ROWSIZE (mat), \n+\t\t       LTM_COLSIZE (mat));\n+}"}, {"sha": "ec48ea44a7ddb5be35614196b931da18a9a49b70", "filename": "gcc/lambda.h", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -22,6 +22,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef LAMBDA_H\n #define LAMBDA_H\n \n+#include \"vec.h\"\n+\n /* An integer vector.  A vector formally consists of an element of a vector\n    space. A vector space is a set that is closed under vector addition\n    and scalar multiplication.  In this vector space, an element is a list of\n@@ -31,6 +33,86 @@ typedef int *lambda_vector;\n    all vectors are the same length).  */\n typedef lambda_vector *lambda_matrix;\n \n+/* A transformation matrix.  */\n+typedef struct\n+{\n+  lambda_matrix matrix;\n+  int rowsize;\n+  int colsize;\n+  int denominator;\n+} *lambda_trans_matrix;\n+#define LTM_MATRIX(T) ((T)->matrix)\n+#define LTM_ROWSIZE(T) ((T)->rowsize)\n+#define LTM_COLSIZE(T) ((T)->colsize)\n+#define LTM_DENOMINATOR(T) ((T)->denominator)\n+\n+/* A vector representing a statement in the body of a loop.  */\n+typedef struct\n+{\n+  lambda_vector coefficients;\n+  int size;\n+  int denominator;\n+} *lambda_body_vector;\n+#define LBV_COEFFICIENTS(T) ((T)->coefficients)\n+#define LBV_SIZE(T) ((T)->size)\n+#define LBV_DENOMINATOR(T) ((T)->denominator)\n+\n+/* Piecewise linear expression.  */\n+typedef struct lambda_linear_expression_s\n+{\n+  lambda_vector coefficients;\n+  int constant;\n+  lambda_vector invariant_coefficients;\n+  int denominator;\n+  struct lambda_linear_expression_s *next;\n+} *lambda_linear_expression;\n+\n+#define LLE_COEFFICIENTS(T) ((T)->coefficients)\n+#define LLE_CONSTANT(T) ((T)->constant)\n+#define LLE_INVARIANT_COEFFICIENTS(T) ((T)->invariant_coefficients)\n+#define LLE_DENOMINATOR(T) ((T)->denominator)\n+#define LLE_NEXT(T) ((T)->next)\n+\n+lambda_linear_expression lambda_linear_expression_new (int, int);\n+void print_lambda_linear_expression (FILE *, lambda_linear_expression, int,\n+\t\t\t\t     int, char);\n+\n+/* Loop structure.  */\n+typedef struct lambda_loop_s\n+{\n+  lambda_linear_expression lower_bound;\n+  lambda_linear_expression upper_bound;\n+  lambda_linear_expression linear_offset;\n+  int step;\n+} *lambda_loop;\n+\n+#define LL_LOWER_BOUND(T) ((T)->lower_bound)\n+#define LL_UPPER_BOUND(T) ((T)->upper_bound)\n+#define LL_LINEAR_OFFSET(T) ((T)->linear_offset)\n+#define LL_STEP(T)   ((T)->step)\n+\n+/* Loop nest structure.  */\n+typedef struct\n+{\n+  lambda_loop *loops;\n+  int depth;\n+  int invariants;\n+} *lambda_loopnest;\n+\n+#define LN_LOOPS(T) ((T)->loops)\n+#define LN_DEPTH(T) ((T)->depth)\n+#define LN_INVARIANTS(T) ((T)->invariants)\n+\n+lambda_loopnest lambda_loopnest_new (int, int);\n+lambda_loopnest lambda_loopnest_transform (lambda_loopnest, lambda_trans_matrix);\n+\n+bool lambda_transform_legal_p (lambda_trans_matrix, int, varray_type);\n+void print_lambda_loopnest (FILE *, lambda_loopnest, char);\n+\n+#define lambda_loop_new() (lambda_loop) ggc_alloc_cleared (sizeof (struct lambda_loop_s))\n+\n+void print_lambda_loop (FILE *, lambda_loop, int, int, char);\n+\n lambda_matrix lambda_matrix_new (int, int);\n \n void lambda_matrix_id (lambda_matrix, int);\n@@ -61,9 +143,32 @@ void lambda_matrix_project_to_null (lambda_matrix, int, int, int,\n \t\t\t\t    lambda_vector);\n void print_lambda_matrix (FILE *, lambda_matrix, int, int);\n \n+lambda_trans_matrix lambda_trans_matrix_new (int, int);\n+bool lambda_trans_matrix_nonsingular_p (lambda_trans_matrix);\n+bool lambda_trans_matrix_fullrank_p (lambda_trans_matrix);\n+int lambda_trans_matrix_rank (lambda_trans_matrix);\n+lambda_trans_matrix lambda_trans_matrix_basis (lambda_trans_matrix);\n+lambda_trans_matrix lambda_trans_matrix_padding (lambda_trans_matrix);\n+lambda_trans_matrix lambda_trans_matrix_inverse (lambda_trans_matrix);\n+void print_lambda_trans_matrix (FILE *, lambda_trans_matrix);\n void lambda_matrix_vector_mult (lambda_matrix, int, int, lambda_vector, \n \t\t\t\tlambda_vector);\n \n+lambda_body_vector lambda_body_vector_new (int);\n+lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix, \n+\t\t\t\t\t\t   lambda_body_vector);\n+void print_lambda_body_vector (FILE *, lambda_body_vector);\n+struct loop;\n+\n+lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loop *,\n+\t\t\t\t\t\t VEC(tree) **,\n+\t\t\t\t\t\t VEC(tree) **);\n+void lambda_loopnest_to_gcc_loopnest (struct loop *, VEC(tree) *,\n+\t\t\t\t      VEC(tree) *,\n+\t\t\t\t      lambda_loopnest, \n+\t\t\t\t      lambda_trans_matrix);\n+\n+\n static inline void lambda_vector_negate (lambda_vector, lambda_vector, int);\n static inline void lambda_vector_mult_const (lambda_vector, lambda_vector, int, int);\n static inline void lambda_vector_add (lambda_vector, lambda_vector,"}, {"sha": "401bac62626bc4edcb5843cebb9e36f8f04573ed", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 103, "deletions": 83, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -96,8 +96,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-pass.h\"\n #include \"lambda.h\"\n \n-static unsigned int data_ref_id = 0;\n-\n \f\n /* This is the simplest data dependence test: determines whether the\n    data references A and B access the same array/region. If can't determine -\n@@ -352,7 +350,7 @@ dump_data_reference (FILE *outf,\n {\n   unsigned int i;\n   \n-  fprintf (outf, \"(Data Ref %d: \\n  stmt: \", DR_ID (dr));\n+  fprintf (outf, \"(Data Ref: \\n  stmt: \");\n   print_generic_stmt (outf, DR_STMT (dr), 0);\n   fprintf (outf, \"  ref: \");\n   print_generic_stmt (outf, DR_REF (dr), 0);\n@@ -380,7 +378,7 @@ dump_data_dependence_relation (FILE *outf,\n   drb = DDR_B (ddr);\n   \n   if (dra && drb)\n-    fprintf (outf, \"(Data Dep (A = %d, B = %d):\", DR_ID (dra), DR_ID (drb));\n+    fprintf (outf, \"(Data Dep:\");\n   else\n     fprintf (outf, \"(Data Dep:\");\n \n@@ -547,9 +545,8 @@ analyze_array (tree stmt, tree ref, bool is_read)\n       fprintf (dump_file, \")\\n\");\n     }\n   \n-  res = ggc_alloc (sizeof (struct data_reference));\n+  res = xmalloc (sizeof (struct data_reference));\n   \n-  DR_ID (res) = data_ref_id++;\n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n   VARRAY_TREE_INIT (DR_ACCESS_FNS (res), 3, \"access_fns\");\n@@ -583,9 +580,8 @@ init_data_ref (tree stmt,\n       fprintf (dump_file, \")\\n\");\n     }\n   \n-  res = ggc_alloc (sizeof (struct data_reference));\n+  res = xmalloc (sizeof (struct data_reference));\n   \n-  DR_ID (res) = data_ref_id++;\n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n   VARRAY_TREE_INIT (DR_ACCESS_FNS (res), 5, \"access_fns\");\n@@ -640,7 +636,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n   struct data_dependence_relation *res;\n   bool differ_p;\n   \n-  res = ggc_alloc (sizeof (struct data_dependence_relation));\n+  res = xmalloc (sizeof (struct data_dependence_relation));\n   DDR_A (res) = a;\n   DDR_B (res) = b;\n \n@@ -665,13 +661,12 @@ initialize_data_dependence_relation (struct data_reference *a,\n \t{\n \t  struct subscript *subscript;\n \t  \n-\t  subscript = ggc_alloc (sizeof (struct subscript));\n+\t  subscript = xmalloc (sizeof (struct subscript));\n \t  SUB_CONFLICTS_IN_A (subscript) = chrec_dont_know;\n \t  SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n \t  SUB_LAST_CONFLICT_IN_A (subscript) = chrec_dont_know;\n \t  SUB_LAST_CONFLICT_IN_B (subscript) = chrec_dont_know;\n \t  SUB_DISTANCE (subscript) = chrec_dont_know;\n-\t  SUB_DIRECTION (subscript) = dir_star;\n \t  VARRAY_PUSH_GENERIC_PTR (DDR_SUBSCRIPTS (res), subscript);\n \t}\n     }\n@@ -686,6 +681,13 @@ static inline void\n finalize_ddr_dependent (struct data_dependence_relation *ddr, \n \t\t\ttree chrec)\n {\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(dependence classified: \");\n+      print_generic_expr (dump_file, chrec, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+\n   DDR_ARE_DEPENDENT (ddr) = chrec;  \n   varray_clear (DDR_SUBSCRIPTS (ddr));\n }\n@@ -1429,14 +1431,12 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n \n /* Compute the classic per loop distance vector.\n \n-   RES is the data dependence relation to build a vector from.\n-   CLASSIC_DIST is the varray to place the vector in.\n+   DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n    FIRST_LOOP is the loop->num of the first loop.  */\n \n static void\n-build_classic_dist_vector (struct data_dependence_relation *res, \n-\t\t\t   varray_type *classic_dist, \n+build_classic_dist_vector (struct data_dependence_relation *ddr, \n \t\t\t   int nb_loops, unsigned int first_loop)\n {\n   unsigned i;\n@@ -1447,12 +1447,12 @@ build_classic_dist_vector (struct data_dependence_relation *res,\n   lambda_vector_clear (dist_v, nb_loops);\n   lambda_vector_clear (init_v, nb_loops);\n   \n-  if (DDR_ARE_DEPENDENT (res) != NULL_TREE)\n+  if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n     return;\n   \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (res); i++)\n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n-      struct subscript *subscript = DDR_SUBSCRIPT (res, i);\n+      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n \n       if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n \treturn;\n@@ -1479,7 +1479,7 @@ build_classic_dist_vector (struct data_dependence_relation *res,\n \t  if (init_v[loop_nb] != 0\n \t      && dist_v[loop_nb] != dist)\n \t    {\n-\t      finalize_ddr_dependent (res, chrec_known);\n+\t      finalize_ddr_dependent (ddr, chrec_known);\n \t      return;\n \t    }\n \n@@ -1497,8 +1497,8 @@ build_classic_dist_vector (struct data_dependence_relation *res,\n   */\n   {\n     struct loop *lca, *loop_a, *loop_b;\n-    struct data_reference *a = DDR_A (res);\n-    struct data_reference *b = DDR_B (res);\n+    struct data_reference *a = DDR_A (ddr);\n+    struct data_reference *b = DDR_B (ddr);\n     int lca_nb;\n     loop_a = loop_containing_stmt (DR_STMT (a));\n     loop_b = loop_containing_stmt (DR_STMT (b));\n@@ -1535,19 +1535,17 @@ build_classic_dist_vector (struct data_dependence_relation *res,\n       }\n   }\n   \n-  VARRAY_PUSH_GENERIC_PTR (*classic_dist, dist_v);\n+  DDR_DIST_VECT (ddr) = dist_v;\n }\n \n /* Compute the classic per loop direction vector.  \n \n-   RES is the data dependence relation to build a vector from.\n-   CLASSIC_DIR is the varray to place the vector in.\n+   DDR is the data dependence relation to build a vector from.\n    NB_LOOPS is the total number of loops we are considering.\n    FIRST_LOOP is the loop->num of the first loop.  */\n \n static void\n-build_classic_dir_vector (struct data_dependence_relation *res, \n-\t\t\t  varray_type *classic_dir, \n+build_classic_dir_vector (struct data_dependence_relation *ddr, \n \t\t\t  int nb_loops, unsigned int first_loop)\n {\n   unsigned i;\n@@ -1558,12 +1556,12 @@ build_classic_dir_vector (struct data_dependence_relation *res,\n   lambda_vector_clear (dir_v, nb_loops);\n   lambda_vector_clear (init_v, nb_loops);\n   \n-  if (DDR_ARE_DEPENDENT (res) != NULL_TREE)\n+  if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE)\n     return;\n   \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (res); i++)\n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n     {\n-      struct subscript *subscript = DDR_SUBSCRIPT (res, i);\n+      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n \n       if (TREE_CODE (SUB_CONFLICTS_IN_A (subscript)) == POLYNOMIAL_CHREC\n \t  && TREE_CODE (SUB_CONFLICTS_IN_B (subscript)) == POLYNOMIAL_CHREC)\n@@ -1606,7 +1604,7 @@ build_classic_dir_vector (struct data_dependence_relation *res,\n \t      && (enum data_dependence_direction) dir_v[loop_nb] != dir\n \t      && (enum data_dependence_direction) dir_v[loop_nb] != dir_star)\n \t    {\n-\t      finalize_ddr_dependent (res, chrec_known);\n+\t      finalize_ddr_dependent (ddr, chrec_known);\n \t      return;\n \t    }\n \t  \n@@ -1624,8 +1622,8 @@ build_classic_dir_vector (struct data_dependence_relation *res,\n   */\n   {\n     struct loop *lca, *loop_a, *loop_b;\n-    struct data_reference *a = DDR_A (res);\n-    struct data_reference *b = DDR_B (res);\n+    struct data_reference *a = DDR_A (ddr);\n+    struct data_reference *b = DDR_B (ddr);\n     int lca_nb;\n     loop_a = loop_containing_stmt (DR_STMT (a));\n     loop_b = loop_containing_stmt (DR_STMT (b));\n@@ -1660,7 +1658,7 @@ build_classic_dir_vector (struct data_dependence_relation *res,\n       }\n   }\n   \n-  VARRAY_PUSH_GENERIC_PTR (*classic_dir, dir_v);\n+  DDR_DIR_VECT (ddr) = dir_v;\n }\n \n /* Returns true when all the access functions of A are affine or\n@@ -1697,8 +1695,7 @@ compute_affine_dependence (struct data_dependence_relation *ddr)\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"(compute_affine_dependence (%d, %d)\\n\", \n-\t       DR_ID (dra), DR_ID (drb));\n+      fprintf (dump_file, \"(compute_affine_dependence\\n\");\n       fprintf (dump_file, \"  (stmt_a = \\n\");\n       print_generic_expr (dump_file, DR_STMT (dra), 0);\n       fprintf (dump_file, \")\\n  (stmt_b = \\n\");\n@@ -1731,8 +1728,8 @@ compute_affine_dependence (struct data_dependence_relation *ddr)\n    in DEPENDENCE_RELATIONS.  */\n \n static void \n-compute_rw_wr_ww_dependences (varray_type datarefs, \n-\t\t\t      varray_type *dependence_relations)\n+compute_all_dependences (varray_type datarefs, \n+\t\t\t varray_type *dependence_relations)\n {\n   unsigned int i, j, N;\n \n@@ -1747,10 +1744,6 @@ compute_rw_wr_ww_dependences (varray_type datarefs,\n \ta = VARRAY_GENERIC_PTR (datarefs, i);\n \tb = VARRAY_GENERIC_PTR (datarefs, j);\n \n-\t/* Don't compute the \"read-read\" relations.  */\n-\tif (DR_IS_READ (a) && DR_IS_READ (b))\n-\t  continue;\n-\n \tddr = initialize_data_dependence_relation (a, b);\n \n \tVARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n@@ -1818,17 +1811,13 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \n /* Given a loop nest LOOP, the following vectors are returned:\n    *DATAREFS is initialized to all the array elements contained in this loop, \n-   *DEPENDENCE_RELATIONS contains the relations between the data references, \n-   *CLASSIC_DIST contains the set of distance vectors,\n-   *CLASSIC_DIR contains the set of direction vectors.  */\n+   *DEPENDENCE_RELATIONS contains the relations between the data references.  */\n \n void\n compute_data_dependences_for_loop (unsigned nb_loops, \n \t\t\t\t   struct loop *loop,\n \t\t\t\t   varray_type *datarefs,\n-\t\t\t\t   varray_type *dependence_relations,\n-\t\t\t\t   varray_type *classic_dist, \n-\t\t\t\t   varray_type *classic_dir)\n+\t\t\t\t   varray_type *dependence_relations)\n {\n   unsigned int i;\n \n@@ -1842,19 +1831,19 @@ compute_data_dependences_for_loop (unsigned nb_loops,\n \t chrec_dont_know.  */\n       ddr = initialize_data_dependence_relation (NULL, NULL);\n       VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-      build_classic_dist_vector (ddr, classic_dist, nb_loops, loop->num);\n-      build_classic_dir_vector (ddr, classic_dir, nb_loops, loop->num);\n+      build_classic_dist_vector (ddr, nb_loops, loop->num);\n+      build_classic_dir_vector (ddr, nb_loops, loop->num);\n       return;\n     }\n \n-  compute_rw_wr_ww_dependences (*datarefs, dependence_relations);\n+  compute_all_dependences (*datarefs, dependence_relations);\n \n   for (i = 0; i < VARRAY_ACTIVE_SIZE (*dependence_relations); i++)\n     {\n       struct data_dependence_relation *ddr;\n       ddr = VARRAY_GENERIC_PTR (*dependence_relations, i);\n-      build_classic_dist_vector (ddr, classic_dist, nb_loops, loop->num);\n-      build_classic_dir_vector (ddr, classic_dir, nb_loops, loop->num);    \n+      build_classic_dist_vector (ddr, nb_loops, loop->num);\n+      build_classic_dir_vector (ddr, nb_loops, loop->num);    \n     }\n }\n \n@@ -1886,20 +1875,16 @@ analyze_all_data_dependences (struct loops *loops)\n   unsigned int i;\n   varray_type datarefs;\n   varray_type dependence_relations;\n-  varray_type classic_dist, classic_dir;\n   int nb_data_refs = 10;\n \n-  VARRAY_GENERIC_PTR_INIT (classic_dist, 10, \"classic_dist\");\n-  VARRAY_GENERIC_PTR_INIT (classic_dir, 10, \"classic_dir\");\n   VARRAY_GENERIC_PTR_INIT (datarefs, nb_data_refs, \"datarefs\");\n   VARRAY_GENERIC_PTR_INIT (dependence_relations, \n \t\t\t   nb_data_refs * nb_data_refs,\n \t\t\t   \"dependence_relations\");\n \n   /* Compute DDs on the whole function.  */\n   compute_data_dependences_for_loop (loops->num, loops->parray[0], \n-\t\t\t\t     &datarefs, &dependence_relations, \n-\t\t\t\t     &classic_dist, &classic_dir);\n+\t\t\t\t     &datarefs, &dependence_relations);\n \n   if (dump_file)\n     {\n@@ -1911,21 +1896,20 @@ analyze_all_data_dependences (struct loops *loops)\n      testsuite.  */\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (classic_dist); i++)\n-\t{\n-\t  fprintf (dump_file, \"DISTANCE_V (\");\n-\t  print_lambda_vector (dump_file, \n-\t\t\t       VARRAY_GENERIC_PTR (classic_dist, i),\n-\t\t\t       loops->num);\n-\t  fprintf (dump_file, \")\\n\");\n-\t}\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (classic_dir); i++)\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n \t{\n-\t  fprintf (dump_file, \"DIRECTION_V (\");\n-\t  print_lambda_vector (dump_file, \n-\t\t\t       VARRAY_GENERIC_PTR (classic_dir, i),\n-\t\t\t       loops->num);\n-\t  fprintf (dump_file, \")\\n\");\n+\t  struct data_dependence_relation *ddr = \n+\t    (struct data_dependence_relation *) \n+\t    VARRAY_GENERIC_PTR (dependence_relations, i);\n+\t  if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+\t    {\n+\t      fprintf (dump_file, \"DISTANCE_V (\");\n+\t      print_lambda_vector (dump_file, DDR_DIST_VECT (ddr), loops->num);\n+\t      fprintf (dump_file, \")\\n\");\n+\t      fprintf (dump_file, \"DIRECTION_V (\");\n+\t      print_lambda_vector (dump_file, DDR_DIR_VECT (ddr), loops->num);\n+\t      fprintf (dump_file, \")\\n\");\n+\t    }\n \t}\n       fprintf (dump_file, \"\\n\\n\");\n     }\n@@ -1962,21 +1946,57 @@ analyze_all_data_dependences (struct loops *loops)\n \t    nb_chrec_relations++;\n \t}\n       \n-      fprintf (dump_file, \"\\n(\\n\");\n-      fprintf (dump_file, \"%d\\tnb_top_relations\\n\", nb_top_relations);\n-      fprintf (dump_file, \"%d\\tnb_bot_relations\\n\", nb_bot_relations);\n-      fprintf (dump_file, \"%d\\tnb_basename_differ\\n\", nb_basename_differ);\n-      fprintf (dump_file, \"%d\\tnb_distance_relations\\n\", (int) VARRAY_ACTIVE_SIZE (classic_dist));\n-      fprintf (dump_file, \"%d\\tnb_chrec_relations\\n\", nb_chrec_relations);\n-      fprintf (dump_file, \"\\n)\\n\");\n-      \n       gather_stats_on_scev_database ();\n     }\n-  \n+\n+  free_dependence_relations (dependence_relations);\n+  free_data_refs (datarefs);\n+}\n+\n+/* Free the memory used by a data dependence relation DDR.  */\n+\n+void\n+free_dependence_relation (struct data_dependence_relation *ddr)\n+{\n+  if (ddr == NULL)\n+    return;\n+\n+  if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE && DDR_SUBSCRIPTS (ddr))\n+    varray_clear (DDR_SUBSCRIPTS (ddr));\n+  free (ddr);\n+}\n+\n+/* Free the memory used by the data dependence relations from\n+   DEPENDENCE_RELATIONS.  */\n+\n+void \n+free_dependence_relations (varray_type dependence_relations)\n+{\n+  unsigned int i;\n+  if (dependence_relations == NULL)\n+    return;\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+    free_dependence_relation (VARRAY_GENERIC_PTR (dependence_relations, i));\n   varray_clear (dependence_relations);\n-  varray_clear (datarefs);\n-  varray_clear (classic_dist);\n-  varray_clear (classic_dir);\n }\n \n+/* Free the memory used by the data references from DATAREFS.  */\n+\n+void\n+free_data_refs (varray_type datarefs)\n+{\n+  unsigned int i;\n+  \n+  if (datarefs == NULL)\n+    return;\n \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+    {\n+      struct data_reference *dr = (struct data_reference *) \n+\tVARRAY_GENERIC_PTR (datarefs, i);\n+      if (dr && DR_ACCESS_FNS (dr))\n+\tvarray_clear (DR_ACCESS_FNS (dr));\n+    }\n+  varray_clear (datarefs);\n+}"}, {"sha": "5dacb3ec75f0ca6d0f8e9a6f981ab1c12ab5804b", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d59cf798c2bf339594ca6917851b9689f84b5d/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=36d59cf798c2bf339594ca6917851b9689f84b5d", "patch": "@@ -22,11 +22,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_TREE_DATA_REF_H\n #define GCC_TREE_DATA_REF_H\n \n-struct data_reference GTY(())\n+#include \"lambda.h\"\n+\n+struct data_reference\n {\n-  /* An identifier.  */\n-  unsigned int id;\n-  \n   /* A pointer to the statement that contains this DR.  */\n   tree stmt;\n   \n@@ -47,7 +46,6 @@ struct data_reference GTY(())\n \n };\n \n-#define DR_ID(DR) DR->id\n #define DR_STMT(DR) DR->stmt\n #define DR_REF(DR) DR->ref\n #define DR_BASE_NAME(DR) DR->base_name\n@@ -74,7 +72,7 @@ enum data_dependence_direction {\n    are stored in the data_dependence_relation structure under the form\n    of an array of subscripts.  */\n \n-struct subscript GTY(()) \n+struct subscript\n {\n   /* A description of the iterations for which the elements are\n      accessed twice.  */\n@@ -91,24 +89,18 @@ struct subscript GTY(())\n      B.  The distance is a tree scalar expression, ie. a constant or a\n      symbolic expression, but certainly not a chrec function.  */\n   tree distance;\n-  \n-  /* Direction (or sign) of the distance.  This more abstract (less\n-     precise) information is extracted from the distance field, for\n-     the convenience of some analyzers.  */\n-  enum data_dependence_direction direction;\n };\n \n #define SUB_CONFLICTS_IN_A(SUB) SUB->conflicting_iterations_in_a\n #define SUB_CONFLICTS_IN_B(SUB) SUB->conflicting_iterations_in_b\n #define SUB_LAST_CONFLICT_IN_A(SUB) SUB->last_conflict_in_a\n #define SUB_LAST_CONFLICT_IN_B(SUB) SUB->last_conflict_in_b\n #define SUB_DISTANCE(SUB) SUB->distance\n-#define SUB_DIRECTION(SUB) SUB->direction\n \n /* A data_dependence_relation represents a relation between two\n    data_references A and B.  */\n \n-struct data_dependence_relation GTY(())\n+struct data_dependence_relation\n {\n   \n   struct data_reference *a;\n@@ -131,6 +123,12 @@ struct data_dependence_relation GTY(())\n      this array.  This is the attribute that labels the edge A->B of\n      the data_dependence_relation.  */\n   varray_type subscripts;\n+\n+  /* The classic direction vector.  */\n+  lambda_vector dir_vect;\n+\n+  /* The classic distance vector.  */\n+  lambda_vector dist_vect;\n };\n \n #define DDR_A(DDR) DDR->a\n@@ -141,6 +139,8 @@ struct data_dependence_relation GTY(())\n   VARRAY_GENERIC_PTR_INIT (DDR_SUBSCRIPTS (DDR), N, \"subscripts_vector\");\n #define DDR_SUBSCRIPT(DDR, I) VARRAY_GENERIC_PTR (DDR_SUBSCRIPTS (DDR), I)\n #define DDR_NUM_SUBSCRIPTS(DDR) VARRAY_ACTIVE_SIZE (DDR_SUBSCRIPTS (DDR))\n+#define DDR_DIR_VECT(DDR) DDR->dir_vect\n+#define DDR_DIST_VECT(DDR) DDR->dist_vect\n \n \f\n \n@@ -149,7 +149,6 @@ struct data_dependence_relation *initialize_data_dependence_relation\n void compute_affine_dependence (struct data_dependence_relation *);\n extern void analyze_all_data_dependences (struct loops *);\n extern void compute_data_dependences_for_loop (unsigned, struct loop *, \n-\t\t\t\t\t       varray_type *, varray_type *, \n \t\t\t\t\t       varray_type *, varray_type *);\n extern struct data_reference * init_data_ref (tree, tree, tree, tree, bool);\n extern struct data_reference *analyze_array (tree, tree, bool);\n@@ -163,6 +162,9 @@ extern void dump_data_dependence_direction (FILE *,\n \t\t\t\t\t    enum data_dependence_direction);\n extern bool array_base_name_differ_p (struct data_reference *, \n \t\t\t\t      struct data_reference *, bool *p);\n+extern void free_dependence_relation (struct data_dependence_relation *);\n+extern void free_dependence_relations (varray_type);\n+extern void free_data_refs (varray_type);\n \n \f\n "}]}