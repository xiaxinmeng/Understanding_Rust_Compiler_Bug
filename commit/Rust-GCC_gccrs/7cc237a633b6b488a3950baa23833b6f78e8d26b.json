{"sha": "7cc237a633b6b488a3950baa23833b6f78e8d26b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjMjM3YTYzM2I2YjQ4OGEzOTUwYmFhMjM4MzNiNmY3OGU4ZDI2Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:14:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:14:32Z"}, "message": "[37/77] Use scalar_int_mode when emitting cstores\n\ncstore patterns always have a scalar integer result, which has the\nvalue 0 for \"false\" and STORE_FLAG_VALUE for \"true\".  This patch\nmakes that explicit using scalar_int_mode.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (cstore_mode): Return a scalar_int_mode.\n\t* doc/tm.texi: Regenerate.\n\t* config/sparc/sparc.c (sparc_cstore_mode): Return a scalar_int_mode.\n\t* targhooks.h (default_cstore_mode): Likewise.\n\t* targhooks.c (default_cstore_mode): Likewise, using a forced\n\tconversion.\n\t* expmed.c (emit_cstore): Expect the target of the cstore to be\n\ta scalar_int_mode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251489", "tree": {"sha": "a44951b09715e6d11e52b297f2d81e762123ae4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a44951b09715e6d11e52b297f2d81e762123ae4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cc237a633b6b488a3950baa23833b6f78e8d26b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc237a633b6b488a3950baa23833b6f78e8d26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc237a633b6b488a3950baa23833b6f78e8d26b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc237a633b6b488a3950baa23833b6f78e8d26b/comments", "author": null, "committer": null, "parents": [{"sha": "3d88d1cdf217be025628d77588e2d247feeebcb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d88d1cdf217be025628d77588e2d247feeebcb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d88d1cdf217be025628d77588e2d247feeebcb3"}], "stats": {"total": 44, "additions": 30, "deletions": 14}, "files": [{"sha": "fb5ddf548f7b50778baffbd70bbbbed464c9bc23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cc237a633b6b488a3950baa23833b6f78e8d26b", "patch": "@@ -1,3 +1,16 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (cstore_mode): Return a scalar_int_mode.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/sparc/sparc.c (sparc_cstore_mode): Return a scalar_int_mode.\n+\t* targhooks.h (default_cstore_mode): Likewise.\n+\t* targhooks.c (default_cstore_mode): Likewise, using a forced\n+\tconversion.\n+\t* expmed.c (emit_cstore): Expect the target of the cstore to be\n+\ta scalar_int_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "54adb4657688ddab90788172b785f6e8931f10a6", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7cc237a633b6b488a3950baa23833b6f78e8d26b", "patch": "@@ -671,7 +671,7 @@ static void sparc_print_operand_address (FILE *, machine_mode, rtx);\n static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t   machine_mode,\n \t\t\t\t\t   secondary_reload_info *);\n-static machine_mode sparc_cstore_mode (enum insn_code icode);\n+static scalar_int_mode sparc_cstore_mode (enum insn_code icode);\n static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n static bool sparc_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static unsigned int sparc_min_arithmetic_precision (void);\n@@ -13170,7 +13170,7 @@ sparc_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n \n /* Implement TARGET_CSTORE_MODE.  */\n \n-static machine_mode\n+static scalar_int_mode\n sparc_cstore_mode (enum insn_code icode ATTRIBUTE_UNUSED)\n {\n   return (TARGET_ARCH64 ? DImode : SImode);"}, {"sha": "59c26677457ff47db9f0732f8bccd3c0fdfc7c85", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7cc237a633b6b488a3950baa23833b6f78e8d26b", "patch": "@@ -2902,7 +2902,7 @@ This hook defines a class of registers which could be used for spilling  pseudos\n This hook should return @code{true} if given class of registers should  be an allocno class in any way.  Usually RA uses only one register  class from all classes containing the same register set.  In some  complicated cases, you need to have two or more such classes as  allocno ones for RA correct work.  Not defining this hook is  equivalent to returning @code{false} for all inputs.\n @end deftypefn\n \n-@deftypefn {Target Hook} machine_mode TARGET_CSTORE_MODE (enum insn_code @var{icode})\n+@deftypefn {Target Hook} scalar_int_mode TARGET_CSTORE_MODE (enum insn_code @var{icode})\n This hook defines the machine mode to use for the boolean result of  conditional store patterns.  The ICODE argument is the instruction code  for the cstore being performed.  Not definiting this hook is the same  as accepting the mode encoded into operand 0 of the cstore expander  patterns.\n @end deftypefn\n "}, {"sha": "8292d40b4e50a67ba2cfb02817d64da88eeba5bb", "filename": "gcc/expmed.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=7cc237a633b6b488a3950baa23833b6f78e8d26b", "patch": "@@ -5291,7 +5291,8 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n   struct expand_operand ops[4];\n   rtx op0, comparison, subtarget;\n   rtx_insn *last;\n-  machine_mode result_mode = targetm.cstore_mode (icode);\n+  scalar_int_mode result_mode = targetm.cstore_mode (icode);\n+  scalar_int_mode int_target_mode;\n \n   last = get_last_insn ();\n   x = prepare_operand (icode, x, 2, mode, compare_mode, unsignedp);\n@@ -5303,9 +5304,11 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n     }\n \n   if (target_mode == VOIDmode)\n-    target_mode = result_mode;\n+    int_target_mode = result_mode;\n+  else\n+    int_target_mode = as_a <scalar_int_mode> (target_mode);\n   if (!target)\n-    target = gen_reg_rtx (target_mode);\n+    target = gen_reg_rtx (int_target_mode);\n \n   comparison = gen_rtx_fmt_ee (code, result_mode, x, y);\n \n@@ -5321,20 +5324,20 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n   subtarget = ops[0].value;\n \n   /* If we are converting to a wider mode, first convert to\n-     TARGET_MODE, then normalize.  This produces better combining\n+     INT_TARGET_MODE, then normalize.  This produces better combining\n      opportunities on machines that have a SIGN_EXTRACT when we are\n      testing a single bit.  This mostly benefits the 68k.\n \n      If STORE_FLAG_VALUE does not have the sign bit set when\n      interpreted in MODE, we can do this conversion as unsigned, which\n      is usually more efficient.  */\n-  if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (result_mode))\n+  if (GET_MODE_SIZE (int_target_mode) > GET_MODE_SIZE (result_mode))\n     {\n       convert_move (target, subtarget,\n \t\t    val_signbit_known_clear_p (result_mode,\n \t\t\t\t\t       STORE_FLAG_VALUE));\n       op0 = target;\n-      result_mode = target_mode;\n+      result_mode = int_target_mode;\n     }\n   else\n     op0 = subtarget;\n@@ -5370,7 +5373,7 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n     }\n \n   /* If we were converting to a smaller mode, do the conversion now.  */\n-  if (target_mode != result_mode)\n+  if (int_target_mode != result_mode)\n     {\n       convert_move (target, op0, 0);\n       return target;"}, {"sha": "ba8b8a2769309c56366aa5fb12816f13d3f07bad", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=7cc237a633b6b488a3950baa23833b6f78e8d26b", "patch": "@@ -5093,7 +5093,7 @@ DEFHOOK\n   for the cstore being performed.  Not definiting this hook is the same\\\n   as accepting the mode encoded into operand 0 of the cstore expander\\\n   patterns.\",\n-  machine_mode, (enum insn_code icode),\n+  scalar_int_mode, (enum insn_code icode),\n   default_cstore_mode)\n \n /* This target hook allows the backend to compute the register pressure"}, {"sha": "ebc2e9cda2b0d8340c0906a2bdc9ca3f8bc601ea", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=7cc237a633b6b488a3950baa23833b6f78e8d26b", "patch": "@@ -1870,10 +1870,10 @@ default_pch_valid_p (const void *data_p, size_t len)\n \n /* Default version of cstore_mode.  */\n \n-machine_mode\n+scalar_int_mode\n default_cstore_mode (enum insn_code icode)\n {\n-  return insn_data[(int) icode].operand[0].mode;\n+  return as_a <scalar_int_mode> (insn_data[(int) icode].operand[0].mode);\n }\n \n /* Default version of member_type_forces_blk.  */"}, {"sha": "7c7e748815594576cf593bf3ab7a3a2396081e7a", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc237a633b6b488a3950baa23833b6f78e8d26b/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=7cc237a633b6b488a3950baa23833b6f78e8d26b", "patch": "@@ -232,7 +232,7 @@ extern const char *default_pch_valid_p (const void *, size_t);\n \n extern void default_asm_output_ident_directive (const char*);\n \n-extern machine_mode default_cstore_mode (enum insn_code);\n+extern scalar_int_mode default_cstore_mode (enum insn_code);\n extern bool default_member_type_forces_blk (const_tree, machine_mode);\n extern void default_atomic_assign_expand_fenv (tree *, tree *, tree *);\n extern tree build_va_arg_indirect_ref (tree);"}]}