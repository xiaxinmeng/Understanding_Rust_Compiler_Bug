{"sha": "2de7c792569d7a227426aaeb124686a856614da7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlN2M3OTI1NjlkN2EyMjc0MjZhYWViMTI0Njg2YTg1NjYxNGRhNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-04-29T01:01:40Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-04-29T01:05:41Z"}, "message": "Move pass free_lang_data to its own file.\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add ipa-free-lang-data.o.\n\t* ipa-free-lang-data.cc: New file.\n\t* tree.c: Move pass free_lang_data to file above.\n\t (build_array_type_1): Declare extern.\n\t* tree.h (build_array_type_1): Declare.", "tree": {"sha": "20e4f8fd06cff9097a8c4696e918f39584b2ddc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20e4f8fd06cff9097a8c4696e918f39584b2ddc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2de7c792569d7a227426aaeb124686a856614da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de7c792569d7a227426aaeb124686a856614da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de7c792569d7a227426aaeb124686a856614da7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de7c792569d7a227426aaeb124686a856614da7/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc806126215c3f4dc187eff3bf923458d8cc6b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc806126215c3f4dc187eff3bf923458d8cc6b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc806126215c3f4dc187eff3bf923458d8cc6b4f"}], "stats": {"total": 2702, "additions": 1374, "deletions": 1328}, "files": [{"sha": "81c0d608b736463fd9c82d54aa7a2c37e272c004", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7c792569d7a227426aaeb124686a856614da7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7c792569d7a227426aaeb124686a856614da7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2de7c792569d7a227426aaeb124686a856614da7", "patch": "@@ -1446,6 +1446,7 @@ OBJS = \\\n \tipa-split.o \\\n \tipa-inline.o \\\n \tipa-comdats.o \\\n+\tipa-free-lang-data.o \\\n \tipa-visibility.o \\\n \tipa-inline-analysis.o \\\n \tipa-inline-transform.o \\"}, {"sha": "0f2d43b25f17b561f69771d903fd14e88bb48649", "filename": "gcc/ipa-free-lang-data.cc", "status": "added", "additions": 1188, "deletions": 0, "changes": 1188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7c792569d7a227426aaeb124686a856614da7/gcc%2Fipa-free-lang-data.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7c792569d7a227426aaeb124686a856614da7/gcc%2Fipa-free-lang-data.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-free-lang-data.cc?ref=2de7c792569d7a227426aaeb124686a856614da7", "patch": "@@ -0,0 +1,1188 @@\n+/* Pass to free or clear language-specific data structures from\n+   the IL before they reach the middle end.\n+\n+   Copyright (C) 1987-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains the low level primitives for operating on tree nodes,\n+   including allocation, list operations, interning of identifiers,\n+   construction of data type nodes and statement nodes,\n+   and construction of type conversion nodes.  It also contains\n+   tables index by tree code that describe how to take apart\n+   nodes of that code.\n+\n+   It is intended to be language-independent but can occasionally\n+   calls language-dependent routines.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+#include \"alias.h\"\n+#include \"attribs.h\"\n+#include \"langhooks.h\"\n+#include \"gimple-iterator.h\"\n+#include \"langhooks-def.h\"\n+#include \"tree-diagnostic.h\"\n+#include \"except.h\"\n+#include \"ipa-utils.h\"\n+\n+namespace {\n+\n+/* Data used when collecting DECLs and TYPEs for language data removal.  */\n+\n+class free_lang_data_d\n+{\n+public:\n+  free_lang_data_d () : decls (100), types (100) {}\n+\n+  /* Worklist to avoid excessive recursion.  */\n+  auto_vec<tree> worklist;\n+\n+  /* Set of traversed objects.  Used to avoid duplicate visits.  */\n+  hash_set<tree> pset;\n+\n+  /* Array of symbols to process with free_lang_data_in_decl.  */\n+  auto_vec<tree> decls;\n+\n+  /* Array of types to process with free_lang_data_in_type.  */\n+  auto_vec<tree> types;\n+};\n+\n+\n+/* Add type or decl T to one of the list of tree nodes that need their\n+   language data removed.  The lists are held inside FLD.  */\n+\n+static void\n+add_tree_to_fld_list (tree t, class free_lang_data_d *fld)\n+{\n+  if (DECL_P (t))\n+    fld->decls.safe_push (t);\n+  else if (TYPE_P (t))\n+    fld->types.safe_push (t);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Push tree node T into FLD->WORKLIST.  */\n+\n+static inline void\n+fld_worklist_push (tree t, class free_lang_data_d *fld)\n+{\n+  if (t && !is_lang_specific (t) && !fld->pset.contains (t))\n+    fld->worklist.safe_push ((t));\n+}\n+\n+\n+\f\n+/* Return simplified TYPE_NAME of TYPE.  */\n+\n+static tree\n+fld_simplified_type_name (tree type)\n+{\n+  if (!TYPE_NAME (type) || TREE_CODE (TYPE_NAME (type)) != TYPE_DECL)\n+    return TYPE_NAME (type);\n+  /* Drop TYPE_DECLs in TYPE_NAME in favor of the identifier in the\n+     TYPE_DECL if the type doesn't have linkage.\n+     this must match fld_  */\n+  if (type != TYPE_MAIN_VARIANT (type)\n+      || (!DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type))\n+\t  && (TREE_CODE (type) != RECORD_TYPE\n+\t      || !TYPE_BINFO (type)\n+\t      || !BINFO_VTABLE (TYPE_BINFO (type)))))\n+    return DECL_NAME (TYPE_NAME (type));\n+  return TYPE_NAME (type);\n+}\n+\n+/* Do same comparsion as check_qualified_type skipping lang part of type\n+   and be more permissive about type names: we only care that names are\n+   same (for diagnostics) and that ODR names are the same.\n+   If INNER_TYPE is non-NULL, be sure that TREE_TYPE match it.  */\n+\n+static bool\n+fld_type_variant_equal_p (tree t, tree v, tree inner_type)\n+{\n+  if (TYPE_QUALS (t) != TYPE_QUALS (v)\n+      /* We want to match incomplete variants with complete types.\n+\t In this case we need to ignore alignment.   */\n+      || ((!RECORD_OR_UNION_TYPE_P (t) || COMPLETE_TYPE_P (v))\n+\t  && (TYPE_ALIGN (t) != TYPE_ALIGN (v)\n+\t      || TYPE_USER_ALIGN (t) != TYPE_USER_ALIGN (v)))\n+      || fld_simplified_type_name (t) != fld_simplified_type_name (v)\n+      || !attribute_list_equal (TYPE_ATTRIBUTES (t),\n+\t\t\t        TYPE_ATTRIBUTES (v))\n+      || (inner_type && TREE_TYPE (v) != inner_type))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Find variant of FIRST that match T and create new one if necessary.\n+   Set TREE_TYPE to INNER_TYPE if non-NULL.  */\n+\n+static tree\n+fld_type_variant (tree first, tree t, class free_lang_data_d *fld,\n+\t\t  tree inner_type = NULL)\n+{\n+  if (first == TYPE_MAIN_VARIANT (t))\n+    return t;\n+  for (tree v = first; v; v = TYPE_NEXT_VARIANT (v))\n+    if (fld_type_variant_equal_p (t, v, inner_type))\n+      return v;\n+  tree v = build_variant_type_copy (first);\n+  TYPE_READONLY (v) = TYPE_READONLY (t);\n+  TYPE_VOLATILE (v) = TYPE_VOLATILE (t);\n+  TYPE_ATOMIC (v) = TYPE_ATOMIC (t);\n+  TYPE_RESTRICT (v) = TYPE_RESTRICT (t);\n+  TYPE_ADDR_SPACE (v) = TYPE_ADDR_SPACE (t);\n+  TYPE_NAME (v) = TYPE_NAME (t);\n+  TYPE_ATTRIBUTES (v) = TYPE_ATTRIBUTES (t);\n+  TYPE_CANONICAL (v) = TYPE_CANONICAL (t);\n+  /* Variants of incomplete types should have alignment\n+     set to BITS_PER_UNIT.  Do not copy the actual alignment.  */\n+  if (!RECORD_OR_UNION_TYPE_P (v) || COMPLETE_TYPE_P (v))\n+    {\n+      SET_TYPE_ALIGN (v, TYPE_ALIGN (t));\n+      TYPE_USER_ALIGN (v) = TYPE_USER_ALIGN (t);\n+    }\n+  if (inner_type)\n+    TREE_TYPE (v) = inner_type;\n+  gcc_checking_assert (fld_type_variant_equal_p (t,v, inner_type));\n+  if (!fld->pset.add (v))\n+    add_tree_to_fld_list (v, fld);\n+  return v;\n+}\n+\n+/* Map complete types to incomplete types.  */\n+\n+static hash_map<tree, tree> *fld_incomplete_types;\n+\n+/* Map types to simplified types.  */\n+\n+static hash_map<tree, tree> *fld_simplified_types;\n+\n+/* Produce variant of T whose TREE_TYPE is T2. If it is main variant,\n+   use MAP to prevent duplicates.  */\n+\n+static tree\n+fld_process_array_type (tree t, tree t2, hash_map<tree, tree> *map,\n+\t\t\tclass free_lang_data_d *fld)\n+{\n+  if (TREE_TYPE (t) == t2)\n+    return t;\n+\n+  if (TYPE_MAIN_VARIANT (t) != t)\n+    {\n+      return fld_type_variant\n+\t(fld_process_array_type (TYPE_MAIN_VARIANT (t),\n+\t\t\t\t TYPE_MAIN_VARIANT (t2), map, fld),\n+\t t, fld, t2);\n+    }\n+\n+  bool existed;\n+  tree &array\n+    = map->get_or_insert (t, &existed);\n+  if (!existed)\n+    {\n+      array\n+\t= build_array_type_1 (t2, TYPE_DOMAIN (t), TYPE_TYPELESS_STORAGE (t),\n+\t\t\t      false, false);\n+      TYPE_CANONICAL (array) = TYPE_CANONICAL (t);\n+      if (!fld->pset.add (array))\n+\tadd_tree_to_fld_list (array, fld);\n+    }\n+  return array;\n+}\n+\n+/* Return CTX after removal of contexts that are not relevant  */\n+\n+static tree\n+fld_decl_context (tree ctx)\n+{\n+  /* Variably modified types are needed for tree_is_indexable to decide\n+     whether the type needs to go to local or global section.\n+     This code is semi-broken but for now it is easiest to keep contexts\n+     as expected.  */\n+  if (ctx && TYPE_P (ctx)\n+      && !variably_modified_type_p (ctx, NULL_TREE))\n+    {\n+      while (ctx && TYPE_P (ctx))\n+\tctx = TYPE_CONTEXT (ctx);\n+    }\n+  return ctx;\n+}\n+\n+/* For T being aggregate type try to turn it into a incomplete variant.\n+   Return T if no simplification is possible.  */\n+\n+static tree\n+fld_incomplete_type_of (tree t, class free_lang_data_d *fld)\n+{\n+  if (!t)\n+    return NULL;\n+  if (POINTER_TYPE_P (t))\n+    {\n+      tree t2 = fld_incomplete_type_of (TREE_TYPE (t), fld);\n+      if (t2 != TREE_TYPE (t))\n+\t{\n+\t  tree first;\n+\t  if (TREE_CODE (t) == POINTER_TYPE)\n+\t    first = build_pointer_type_for_mode (t2, TYPE_MODE (t),\n+\t\t\t\t\t\t TYPE_REF_CAN_ALIAS_ALL (t));\n+\t  else\n+\t    first = build_reference_type_for_mode (t2, TYPE_MODE (t),\n+\t\t\t\t\t\t   TYPE_REF_CAN_ALIAS_ALL (t));\n+\t  gcc_assert (TYPE_CANONICAL (t2) != t2\n+\t\t      && TYPE_CANONICAL (t2) == TYPE_CANONICAL (TREE_TYPE (t)));\n+\t  if (!fld->pset.add (first))\n+\t    add_tree_to_fld_list (first, fld);\n+\t  return fld_type_variant (first, t, fld);\n+\t}\n+      return t;\n+    }\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return fld_process_array_type (t,\n+\t\t\t\t   fld_incomplete_type_of (TREE_TYPE (t), fld),\n+\t\t\t\t   fld_incomplete_types, fld);\n+  if ((!RECORD_OR_UNION_TYPE_P (t) && TREE_CODE (t) != ENUMERAL_TYPE)\n+      || !COMPLETE_TYPE_P (t))\n+    return t;\n+  if (TYPE_MAIN_VARIANT (t) == t)\n+    {\n+      bool existed;\n+      tree &copy\n+\t= fld_incomplete_types->get_or_insert (t, &existed);\n+\n+      if (!existed)\n+\t{\n+\t  copy = build_distinct_type_copy (t);\n+\n+\t  /* It is possible that type was not seen by free_lang_data yet.  */\n+\t  if (!fld->pset.add (copy))\n+\t    add_tree_to_fld_list (copy, fld);\n+\t  TYPE_SIZE (copy) = NULL;\n+\t  TYPE_USER_ALIGN (copy) = 0;\n+\t  TYPE_SIZE_UNIT (copy) = NULL;\n+\t  TYPE_CANONICAL (copy) = TYPE_CANONICAL (t);\n+\t  TREE_ADDRESSABLE (copy) = 0;\n+\t  if (AGGREGATE_TYPE_P (t))\n+\t    {\n+\t      SET_TYPE_MODE (copy, VOIDmode);\n+\t      SET_TYPE_ALIGN (copy, BITS_PER_UNIT);\n+\t      TYPE_TYPELESS_STORAGE (copy) = 0;\n+\t      TYPE_FIELDS (copy) = NULL;\n+\t      TYPE_BINFO (copy) = NULL;\n+\t      TYPE_FINAL_P (copy) = 0;\n+\t      TYPE_EMPTY_P (copy) = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      TYPE_VALUES (copy) = NULL;\n+\t      ENUM_IS_OPAQUE (copy) = 0;\n+\t      ENUM_IS_SCOPED (copy) = 0;\n+\t    }\n+\n+\t  /* Build copy of TYPE_DECL in TYPE_NAME if necessary.\n+\t     This is needed for ODR violation warnings to come out right (we\n+\t     want duplicate TYPE_DECLs whenever the type is duplicated because\n+\t     of ODR violation.  Because lang data in the TYPE_DECL may not\n+\t     have been freed yet, rebuild it from scratch and copy relevant\n+\t     fields.  */\n+\t  TYPE_NAME (copy) = fld_simplified_type_name (copy);\n+\t  tree name = TYPE_NAME (copy);\n+\n+\t  if (name && TREE_CODE (name) == TYPE_DECL)\n+\t    {\n+\t      gcc_checking_assert (TREE_TYPE (name) == t);\n+\t      tree name2 = build_decl (DECL_SOURCE_LOCATION (name), TYPE_DECL,\n+\t\t\t\t       DECL_NAME (name), copy);\n+\t      if (DECL_ASSEMBLER_NAME_SET_P (name))\n+\t\tSET_DECL_ASSEMBLER_NAME (name2, DECL_ASSEMBLER_NAME (name));\n+\t      SET_DECL_ALIGN (name2, 0);\n+\t      DECL_CONTEXT (name2) = fld_decl_context\n+\t\t(DECL_CONTEXT (name));\n+\t      TYPE_NAME (copy) = name2;\n+\t    }\n+\t}\n+      return copy;\n+    }\n+  return (fld_type_variant\n+\t  (fld_incomplete_type_of (TYPE_MAIN_VARIANT (t), fld), t, fld));\n+}\n+\n+/* Simplify type T for scenarios where we do not need complete pointer\n+   types.  */\n+\n+static tree\n+fld_simplified_type (tree t, class free_lang_data_d *fld)\n+{\n+  if (!t)\n+    return t;\n+  if (POINTER_TYPE_P (t))\n+    return fld_incomplete_type_of (t, fld);\n+  /* FIXME: This triggers verification error, see PR88140.  */\n+#if 0\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return fld_process_array_type (t, fld_simplified_type (TREE_TYPE (t), fld),\n+\t\t\t\t   fld_simplified_types, fld);\n+#endif\n+  return t;\n+}\n+\n+/* Reset the expression *EXPR_P, a size or position.\n+\n+   ??? We could reset all non-constant sizes or positions.  But it's cheap\n+   enough to not do so and refrain from adding workarounds to dwarf2out.c.\n+\n+   We need to reset self-referential sizes or positions because they cannot\n+   be gimplified and thus can contain a CALL_EXPR after the gimplification\n+   is finished, which will run afoul of LTO streaming.  And they need to be\n+   reset to something essentially dummy but not constant, so as to preserve\n+   the properties of the object they are attached to.  */\n+\n+static inline void\n+free_lang_data_in_one_sizepos (tree *expr_p)\n+{\n+  tree expr = *expr_p;\n+  if (CONTAINS_PLACEHOLDER_P (expr))\n+    *expr_p = build0 (PLACEHOLDER_EXPR, TREE_TYPE (expr));\n+}\n+\n+\n+/* Reset all the fields in a binfo node BINFO.  We only keep\n+   BINFO_VTABLE, which is used by gimple_fold_obj_type_ref.  */\n+\n+static void\n+free_lang_data_in_binfo (tree binfo)\n+{\n+  unsigned i;\n+  tree t;\n+\n+  gcc_assert (TREE_CODE (binfo) == TREE_BINFO);\n+\n+  BINFO_VIRTUALS (binfo) = NULL_TREE;\n+  BINFO_BASE_ACCESSES (binfo) = NULL;\n+  BINFO_INHERITANCE_CHAIN (binfo) = NULL_TREE;\n+  BINFO_SUBVTT_INDEX (binfo) = NULL_TREE;\n+  BINFO_VPTR_FIELD (binfo) = NULL_TREE;\n+  TREE_PUBLIC (binfo) = 0;\n+\n+  FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (binfo), i, t)\n+    free_lang_data_in_binfo (t);\n+}\n+\n+\n+/* Reset all language specific information still present in TYPE.  */\n+\n+static void\n+free_lang_data_in_type (tree type, class free_lang_data_d *fld)\n+{\n+  gcc_assert (TYPE_P (type));\n+\n+  /* Give the FE a chance to remove its own data first.  */\n+  lang_hooks.free_lang_data (type);\n+\n+  TREE_LANG_FLAG_0 (type) = 0;\n+  TREE_LANG_FLAG_1 (type) = 0;\n+  TREE_LANG_FLAG_2 (type) = 0;\n+  TREE_LANG_FLAG_3 (type) = 0;\n+  TREE_LANG_FLAG_4 (type) = 0;\n+  TREE_LANG_FLAG_5 (type) = 0;\n+  TREE_LANG_FLAG_6 (type) = 0;\n+\n+  TYPE_NEEDS_CONSTRUCTING (type) = 0;\n+\n+  /* Purge non-marked variants from the variants chain, so that they\n+     don't reappear in the IL after free_lang_data.  */\n+  while (TYPE_NEXT_VARIANT (type)\n+\t && !fld->pset.contains (TYPE_NEXT_VARIANT (type)))\n+    {\n+      tree t = TYPE_NEXT_VARIANT (type);\n+      TYPE_NEXT_VARIANT (type) = TYPE_NEXT_VARIANT (t);\n+      /* Turn the removed types into distinct types.  */\n+      TYPE_MAIN_VARIANT (t) = t;\n+      TYPE_NEXT_VARIANT (t) = NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      TREE_TYPE (type) = fld_simplified_type (TREE_TYPE (type), fld);\n+      /* Remove the const and volatile qualifiers from arguments.  The\n+\t C++ front end removes them, but the C front end does not,\n+\t leading to false ODR violation errors when merging two\n+\t instances of the same function signature compiled by\n+\t different front ends.  */\n+      for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n+\t{\n+\t  TREE_VALUE (p) = fld_simplified_type (TREE_VALUE (p), fld);\n+\t  tree arg_type = TREE_VALUE (p);\n+\n+\t  if (TYPE_READONLY (arg_type) || TYPE_VOLATILE (arg_type))\n+\t    {\n+\t      int quals = TYPE_QUALS (arg_type)\n+\t\t& ~TYPE_QUAL_CONST\n+\t\t& ~TYPE_QUAL_VOLATILE;\n+\t      TREE_VALUE (p) = build_qualified_type (arg_type, quals);\n+\t      if (!fld->pset.add (TREE_VALUE (p)))\n+\t\tfree_lang_data_in_type (TREE_VALUE (p), fld);\n+\t    }\n+\t  /* C++ FE uses TREE_PURPOSE to store initial values.  */\n+\t  TREE_PURPOSE (p) = NULL;\n+\t}\n+    }\n+  else if (TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      TREE_TYPE (type) = fld_simplified_type (TREE_TYPE (type), fld);\n+      for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n+\t{\n+\t  /* C++ FE uses TREE_PURPOSE to store initial values.  */\n+\t  TREE_VALUE (p) = fld_simplified_type (TREE_VALUE (p), fld);\n+\t  TREE_PURPOSE (p) = NULL;\n+\t}\n+    }\n+  else if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      /* Remove members that are not FIELD_DECLs from the field list\n+\t of an aggregate.  These occur in C++.  */\n+      for (tree *prev = &TYPE_FIELDS (type), member; (member = *prev);)\n+\tif (TREE_CODE (member) == FIELD_DECL)\n+\t  prev = &DECL_CHAIN (member);\n+\telse\n+\t  *prev = DECL_CHAIN (member);\n+\n+      TYPE_VFIELD (type) = NULL_TREE;\n+\n+      if (TYPE_BINFO (type))\n+\t{\n+\t  free_lang_data_in_binfo (TYPE_BINFO (type));\n+\t  /* We need to preserve link to bases and virtual table for all\n+\t     polymorphic types to make devirtualization machinery working.  */\n+\t  if (!BINFO_VTABLE (TYPE_BINFO (type)))\n+\t    TYPE_BINFO (type) = NULL;\n+\t}\n+    }\n+  else if (INTEGRAL_TYPE_P (type)\n+\t   || SCALAR_FLOAT_TYPE_P (type)\n+\t   || FIXED_POINT_TYPE_P (type))\n+    {\n+      if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t{\n+\t  ENUM_IS_OPAQUE (type) = 0;\n+\t  ENUM_IS_SCOPED (type) = 0;\n+\t  /* Type values are used only for C++ ODR checking.  Drop them\n+\t     for all type variants and non-ODR types.\n+\t     For ODR types the data is freed in free_odr_warning_data.  */\n+\t  if (!TYPE_VALUES (type))\n+\t    ;\n+\t  else if (TYPE_MAIN_VARIANT (type) != type\n+\t\t   || !type_with_linkage_p (type)\n+\t\t   || type_in_anonymous_namespace_p (type))\n+\t    TYPE_VALUES (type) = NULL;\n+\t  else\n+\t    register_odr_enum (type);\n+\t}\n+      free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n+      free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));\n+    }\n+\n+  TYPE_LANG_SLOT_1 (type) = NULL_TREE;\n+\n+  free_lang_data_in_one_sizepos (&TYPE_SIZE (type));\n+  free_lang_data_in_one_sizepos (&TYPE_SIZE_UNIT (type));\n+\n+  if (TYPE_CONTEXT (type)\n+      && TREE_CODE (TYPE_CONTEXT (type)) == BLOCK)\n+    {\n+      tree ctx = TYPE_CONTEXT (type);\n+      do\n+\t{\n+\t  ctx = BLOCK_SUPERCONTEXT (ctx);\n+\t}\n+      while (ctx && TREE_CODE (ctx) == BLOCK);\n+      TYPE_CONTEXT (type) = ctx;\n+    }\n+\n+  TYPE_STUB_DECL (type) = NULL;\n+  TYPE_NAME (type) = fld_simplified_type_name (type);\n+}\n+\n+/* Reset all language specific information still present in symbol\n+   DECL.  */\n+\n+static void\n+free_lang_data_in_decl (tree decl, class free_lang_data_d *fld)\n+{\n+  gcc_assert (DECL_P (decl));\n+\n+  /* Give the FE a chance to remove its own data first.  */\n+  lang_hooks.free_lang_data (decl);\n+\n+  TREE_LANG_FLAG_0 (decl) = 0;\n+  TREE_LANG_FLAG_1 (decl) = 0;\n+  TREE_LANG_FLAG_2 (decl) = 0;\n+  TREE_LANG_FLAG_3 (decl) = 0;\n+  TREE_LANG_FLAG_4 (decl) = 0;\n+  TREE_LANG_FLAG_5 (decl) = 0;\n+  TREE_LANG_FLAG_6 (decl) = 0;\n+\n+  free_lang_data_in_one_sizepos (&DECL_SIZE (decl));\n+  free_lang_data_in_one_sizepos (&DECL_SIZE_UNIT (decl));\n+  if (TREE_CODE (decl) == FIELD_DECL)\n+    {\n+      DECL_FCONTEXT (decl) = NULL;\n+      free_lang_data_in_one_sizepos (&DECL_FIELD_OFFSET (decl));\n+      if (TREE_CODE (DECL_CONTEXT (decl)) == QUAL_UNION_TYPE)\n+\tDECL_QUALIFIER (decl) = NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      struct cgraph_node *node;\n+      /* Frontends do not set TREE_ADDRESSABLE on public variables even though\n+\t the address may be taken in other unit, so this flag has no practical\n+\t use for middle-end.\n+\n+\t It would make more sense if frontends set TREE_ADDRESSABLE to 0 only\n+\t for public objects that indeed cannot be adressed, but it is not\n+\t the case.  Set the flag to true so we do not get merge failures for\n+\t i.e. virtual tables between units that take address of it and\n+\t units that don't.  */\n+      if (TREE_PUBLIC (decl))\n+\tTREE_ADDRESSABLE (decl) = true;\n+      TREE_TYPE (decl) = fld_simplified_type (TREE_TYPE (decl), fld);\n+      if (!(node = cgraph_node::get (decl))\n+\t  || (!node->definition && !node->clones))\n+\t{\n+\t  if (node && !node->declare_variant_alt)\n+\t    node->release_body ();\n+\t  else\n+\t    {\n+\t      release_function_body (decl);\n+\t      DECL_ARGUMENTS (decl) = NULL;\n+\t      DECL_RESULT (decl) = NULL;\n+\t      DECL_INITIAL (decl) = error_mark_node;\n+\t    }\n+\t}\n+      if (gimple_has_body_p (decl) || (node && node->thunk))\n+\t{\n+\t  tree t;\n+\n+\t  /* If DECL has a gimple body, then the context for its\n+\t     arguments must be DECL.  Otherwise, it doesn't really\n+\t     matter, as we will not be emitting any code for DECL.  In\n+\t     general, there may be other instances of DECL created by\n+\t     the front end and since PARM_DECLs are generally shared,\n+\t     their DECL_CONTEXT changes as the replicas of DECL are\n+\t     created.  The only time where DECL_CONTEXT is important\n+\t     is for the FUNCTION_DECLs that have a gimple body (since\n+\t     the PARM_DECL will be used in the function's body).  */\n+\t  for (t = DECL_ARGUMENTS (decl); t; t = TREE_CHAIN (t))\n+\t    DECL_CONTEXT (t) = decl;\n+\t  if (!DECL_FUNCTION_SPECIFIC_TARGET (decl))\n+\t    DECL_FUNCTION_SPECIFIC_TARGET (decl)\n+\t      = target_option_default_node;\n+\t  if (!DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl))\n+\t    DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl)\n+\t      = optimization_default_node;\n+\t}\n+\n+      /* DECL_SAVED_TREE holds the GENERIC representation for DECL.\n+\t At this point, it is not needed anymore.  */\n+      DECL_SAVED_TREE (decl) = NULL_TREE;\n+\n+      /* Clear the abstract origin if it refers to a method.\n+         Otherwise dwarf2out.c will ICE as we splice functions out of\n+         TYPE_FIELDS and thus the origin will not be output\n+         correctly.  */\n+      if (DECL_ABSTRACT_ORIGIN (decl)\n+\t  && DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))\n+\t  && RECORD_OR_UNION_TYPE_P\n+\t  (DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))))\n+\tDECL_ABSTRACT_ORIGIN (decl) = NULL_TREE;\n+\n+      DECL_VINDEX (decl) = NULL_TREE;\n+    }\n+  else if (VAR_P (decl))\n+    {\n+      /* See comment above why we set the flag for functions.  */\n+      if (TREE_PUBLIC (decl))\n+\tTREE_ADDRESSABLE (decl) = true;\n+      if ((DECL_EXTERNAL (decl)\n+\t   && (!TREE_STATIC (decl) || !TREE_READONLY (decl)))\n+\t  || (decl_function_context (decl) && !TREE_STATIC (decl)))\n+\tDECL_INITIAL (decl) = NULL_TREE;\n+    }\n+  else if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n+      DECL_VISIBILITY_SPECIFIED (decl) = 0;\n+      TREE_PUBLIC (decl) = 0;\n+      TREE_PRIVATE (decl) = 0;\n+      DECL_ARTIFICIAL (decl) = 0;\n+      TYPE_DECL_SUPPRESS_DEBUG (decl) = 0;\n+      DECL_INITIAL (decl) = NULL_TREE;\n+      DECL_ORIGINAL_TYPE (decl) = NULL_TREE;\n+      DECL_MODE (decl) = VOIDmode;\n+      SET_DECL_ALIGN (decl, 0);\n+      /* TREE_TYPE is cleared at WPA time in free_odr_warning_data.  */\n+    }\n+  else if (TREE_CODE (decl) == FIELD_DECL)\n+    {\n+      TREE_TYPE (decl) = fld_simplified_type (TREE_TYPE (decl), fld);\n+      DECL_INITIAL (decl) = NULL_TREE;\n+    }\n+  else if (TREE_CODE (decl) == TRANSLATION_UNIT_DECL\n+           && DECL_INITIAL (decl)\n+           && TREE_CODE (DECL_INITIAL (decl)) == BLOCK)\n+    {\n+      /* Strip builtins from the translation-unit BLOCK.  We still have targets\n+\t without builtin_decl_explicit support and also builtins are shared\n+\t nodes and thus we can't use TREE_CHAIN in multiple lists.  */\n+      tree *nextp = &BLOCK_VARS (DECL_INITIAL (decl));\n+      while (*nextp)\n+\t{\n+\t  tree var = *nextp;\n+\t  if (TREE_CODE (var) == FUNCTION_DECL\n+\t      && fndecl_built_in_p (var))\n+\t    *nextp = TREE_CHAIN (var);\n+\t  else\n+\t    nextp = &TREE_CHAIN (var);\n+        }\n+    }\n+  /* We need to keep field decls associated with their trees. Otherwise tree\n+     merging may merge some fileds and keep others disjoint wich in turn will\n+     not do well with TREE_CHAIN pointers linking them.\n+\n+     Also do not drop containing types for virtual methods and tables because\n+     these are needed by devirtualization.\n+     C++ destructors are special because C++ frontends sometimes produces\n+     virtual destructor as an alias of non-virtual destructor.  In\n+     devirutalization code we always walk through aliases and we need\n+     context to be preserved too.  See PR89335  */\n+  if (TREE_CODE (decl) != FIELD_DECL\n+      && ((TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n+          || (!DECL_VIRTUAL_P (decl)\n+\t      && (TREE_CODE (decl) != FUNCTION_DECL\n+\t\t  || !DECL_CXX_DESTRUCTOR_P (decl)))))\n+    DECL_CONTEXT (decl) = fld_decl_context (DECL_CONTEXT (decl));\n+}\n+\n+\n+/* Operand callback helper for free_lang_data_in_node.  *TP is the\n+   subtree operand being considered.  */\n+\n+static tree\n+find_decls_types_r (tree *tp, int *ws, void *data)\n+{\n+  tree t = *tp;\n+  class free_lang_data_d *fld = (class free_lang_data_d *) data;\n+\n+  if (TREE_CODE (t) == TREE_LIST)\n+    return NULL_TREE;\n+\n+  /* Language specific nodes will be removed, so there is no need\n+     to gather anything under them.  */\n+  if (is_lang_specific (t))\n+    {\n+      *ws = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (DECL_P (t))\n+    {\n+      /* Note that walk_tree does not traverse every possible field in\n+\t decls, so we have to do our own traversals here.  */\n+      add_tree_to_fld_list (t, fld);\n+\n+      fld_worklist_push (DECL_NAME (t), fld);\n+      fld_worklist_push (DECL_CONTEXT (t), fld);\n+      fld_worklist_push (DECL_SIZE (t), fld);\n+      fld_worklist_push (DECL_SIZE_UNIT (t), fld);\n+\n+      /* We are going to remove everything under DECL_INITIAL for\n+\t TYPE_DECLs.  No point walking them.  */\n+      if (TREE_CODE (t) != TYPE_DECL)\n+\tfld_worklist_push (DECL_INITIAL (t), fld);\n+\n+      fld_worklist_push (DECL_ATTRIBUTES (t), fld);\n+      fld_worklist_push (DECL_ABSTRACT_ORIGIN (t), fld);\n+\n+      if (TREE_CODE (t) == FUNCTION_DECL)\n+\t{\n+\t  fld_worklist_push (DECL_ARGUMENTS (t), fld);\n+\t  fld_worklist_push (DECL_RESULT (t), fld);\n+\t}\n+      else if (TREE_CODE (t) == FIELD_DECL)\n+\t{\n+\t  fld_worklist_push (DECL_FIELD_OFFSET (t), fld);\n+\t  fld_worklist_push (DECL_BIT_FIELD_TYPE (t), fld);\n+\t  fld_worklist_push (DECL_FIELD_BIT_OFFSET (t), fld);\n+\t  fld_worklist_push (DECL_FCONTEXT (t), fld);\n+\t}\n+\n+      if ((VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n+\t  && DECL_HAS_VALUE_EXPR_P (t))\n+\tfld_worklist_push (DECL_VALUE_EXPR (t), fld);\n+\n+      if (TREE_CODE (t) != FIELD_DECL\n+\t  && TREE_CODE (t) != TYPE_DECL)\n+\tfld_worklist_push (TREE_CHAIN (t), fld);\n+      *ws = 0;\n+    }\n+  else if (TYPE_P (t))\n+    {\n+      /* Note that walk_tree does not traverse every possible field in\n+\t types, so we have to do our own traversals here.  */\n+      add_tree_to_fld_list (t, fld);\n+\n+      if (!RECORD_OR_UNION_TYPE_P (t))\n+\tfld_worklist_push (TYPE_CACHED_VALUES (t), fld);\n+      fld_worklist_push (TYPE_SIZE (t), fld);\n+      fld_worklist_push (TYPE_SIZE_UNIT (t), fld);\n+      fld_worklist_push (TYPE_ATTRIBUTES (t), fld);\n+      fld_worklist_push (TYPE_POINTER_TO (t), fld);\n+      fld_worklist_push (TYPE_REFERENCE_TO (t), fld);\n+      fld_worklist_push (TYPE_NAME (t), fld);\n+      /* While we do not stream TYPE_POINTER_TO and TYPE_REFERENCE_TO\n+\t lists, we may look types up in these lists and use them while\n+\t optimizing the function body.  Thus we need to free lang data\n+\t in them.  */\n+      if (TREE_CODE (t) == POINTER_TYPE)\n+\tfld_worklist_push (TYPE_NEXT_PTR_TO (t), fld);\n+      if (TREE_CODE (t) == REFERENCE_TYPE)\n+\tfld_worklist_push (TYPE_NEXT_REF_TO (t), fld);\n+      if (!POINTER_TYPE_P (t))\n+\tfld_worklist_push (TYPE_MIN_VALUE_RAW (t), fld);\n+      /* TYPE_MAX_VALUE_RAW is TYPE_BINFO for record types.  */\n+      if (!RECORD_OR_UNION_TYPE_P (t))\n+\tfld_worklist_push (TYPE_MAX_VALUE_RAW (t), fld);\n+      fld_worklist_push (TYPE_MAIN_VARIANT (t), fld);\n+      /* Do not walk TYPE_NEXT_VARIANT.  We do not stream it and thus\n+\t do not and want not to reach unused variants this way.  */\n+      if (TYPE_CONTEXT (t))\n+\t{\n+\t  tree ctx = TYPE_CONTEXT (t);\n+\t  /* We adjust BLOCK TYPE_CONTEXTs to the innermost non-BLOCK one.\n+\t     So push that instead.  */\n+\t  while (ctx && TREE_CODE (ctx) == BLOCK)\n+\t    ctx = BLOCK_SUPERCONTEXT (ctx);\n+\t  fld_worklist_push (ctx, fld);\n+\t}\n+      fld_worklist_push (TYPE_CANONICAL (t), fld);\n+\n+      if (RECORD_OR_UNION_TYPE_P (t) && TYPE_BINFO (t))\n+\t{\n+\t  unsigned i;\n+\t  tree tem;\n+\t  FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (TYPE_BINFO (t)), i, tem)\n+\t    fld_worklist_push (TREE_TYPE (tem), fld);\n+\t  fld_worklist_push (BINFO_TYPE (TYPE_BINFO (t)), fld);\n+\t  fld_worklist_push (BINFO_VTABLE (TYPE_BINFO (t)), fld);\n+\t}\n+      if (RECORD_OR_UNION_TYPE_P (t))\n+\t{\n+\t  tree tem;\n+\t  /* Push all TYPE_FIELDS - there can be interleaving interesting\n+\t     and non-interesting things.  */\n+\t  tem = TYPE_FIELDS (t);\n+\t  while (tem)\n+\t    {\n+\t      if (TREE_CODE (tem) == FIELD_DECL)\n+\t\tfld_worklist_push (tem, fld);\n+\t      tem = TREE_CHAIN (tem);\n+\t    }\n+\t}\n+      if (FUNC_OR_METHOD_TYPE_P (t))\n+\tfld_worklist_push (TYPE_METHOD_BASETYPE (t), fld);\n+\n+      fld_worklist_push (TYPE_STUB_DECL (t), fld);\n+      *ws = 0;\n+    }\n+  else if (TREE_CODE (t) == BLOCK)\n+    {\n+      for (tree *tem = &BLOCK_VARS (t); *tem; )\n+\t{\n+\t  if (TREE_CODE (*tem) != LABEL_DECL\n+\t      && (TREE_CODE (*tem) != VAR_DECL\n+\t\t  || !auto_var_in_fn_p (*tem, DECL_CONTEXT (*tem))))\n+\t    {\n+\t      gcc_assert (TREE_CODE (*tem) != RESULT_DECL\n+\t\t\t  && TREE_CODE (*tem) != PARM_DECL);\n+\t      *tem = TREE_CHAIN (*tem);\n+\t    }\n+\t  else\n+\t    {\n+\t      fld_worklist_push (*tem, fld);\n+\t      tem = &TREE_CHAIN (*tem);\n+\t    }\n+\t}\n+      for (tree tem = BLOCK_SUBBLOCKS (t); tem; tem = BLOCK_CHAIN (tem))\n+\tfld_worklist_push (tem, fld);\n+      fld_worklist_push (BLOCK_ABSTRACT_ORIGIN (t), fld);\n+    }\n+\n+  if (TREE_CODE (t) != IDENTIFIER_NODE\n+      && CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_TYPED))\n+    fld_worklist_push (TREE_TYPE (t), fld);\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Find decls and types in T.  */\n+\n+static void\n+find_decls_types (tree t, class free_lang_data_d *fld)\n+{\n+  while (1)\n+    {\n+      if (!fld->pset.contains (t))\n+\twalk_tree (&t, find_decls_types_r, fld, &fld->pset);\n+      if (fld->worklist.is_empty ())\n+\tbreak;\n+      t = fld->worklist.pop ();\n+    }\n+}\n+\n+/* Translate all the types in LIST with the corresponding runtime\n+   types.  */\n+\n+static tree\n+get_eh_types_for_runtime (tree list)\n+{\n+  tree head, prev;\n+\n+  if (list == NULL_TREE)\n+    return NULL_TREE;\n+\n+  head = build_tree_list (0, lookup_type_for_runtime (TREE_VALUE (list)));\n+  prev = head;\n+  list = TREE_CHAIN (list);\n+  while (list)\n+    {\n+      tree n = build_tree_list (0, lookup_type_for_runtime (TREE_VALUE (list)));\n+      TREE_CHAIN (prev) = n;\n+      prev = TREE_CHAIN (prev);\n+      list = TREE_CHAIN (list);\n+    }\n+\n+  return head;\n+}\n+\n+\n+/* Find decls and types referenced in EH region R and store them in\n+   FLD->DECLS and FLD->TYPES.  */\n+\n+static void\n+find_decls_types_in_eh_region (eh_region r, class free_lang_data_d *fld)\n+{\n+  switch (r->type)\n+    {\n+    case ERT_CLEANUP:\n+      break;\n+\n+    case ERT_TRY:\n+      {\n+\teh_catch c;\n+\n+\t/* The types referenced in each catch must first be changed to the\n+\t   EH types used at runtime.  This removes references to FE types\n+\t   in the region.  */\n+\tfor (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n+\t  {\n+\t    c->type_list = get_eh_types_for_runtime (c->type_list);\n+\t    walk_tree (&c->type_list, find_decls_types_r, fld, &fld->pset);\n+\t  }\n+      }\n+      break;\n+\n+    case ERT_ALLOWED_EXCEPTIONS:\n+      r->u.allowed.type_list\n+\t= get_eh_types_for_runtime (r->u.allowed.type_list);\n+      walk_tree (&r->u.allowed.type_list, find_decls_types_r, fld, &fld->pset);\n+      break;\n+\n+    case ERT_MUST_NOT_THROW:\n+      walk_tree (&r->u.must_not_throw.failure_decl,\n+\t\t find_decls_types_r, fld, &fld->pset);\n+      break;\n+    }\n+}\n+\n+\n+/* Find decls and types referenced in cgraph node N and store them in\n+   FLD->DECLS and FLD->TYPES.  Unlike pass_referenced_vars, this will\n+   look for *every* kind of DECL and TYPE node reachable from N,\n+   including those embedded inside types and decls (i.e,, TYPE_DECLs,\n+   NAMESPACE_DECLs, etc).  */\n+\n+static void\n+find_decls_types_in_node (struct cgraph_node *n, class free_lang_data_d *fld)\n+{\n+  basic_block bb;\n+  struct function *fn;\n+  unsigned ix;\n+  tree t;\n+\n+  find_decls_types (n->decl, fld);\n+\n+  if (!gimple_has_body_p (n->decl))\n+    return;\n+\n+  gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n+\n+  fn = DECL_STRUCT_FUNCTION (n->decl);\n+\n+  /* Traverse locals. */\n+  FOR_EACH_LOCAL_DECL (fn, ix, t)\n+    find_decls_types (t, fld);\n+\n+  /* Traverse EH regions in FN.  */\n+  {\n+    eh_region r;\n+    FOR_ALL_EH_REGION_FN (r, fn)\n+      find_decls_types_in_eh_region (r, fld);\n+  }\n+\n+  /* Traverse every statement in FN.  */\n+  FOR_EACH_BB_FN (bb, fn)\n+    {\n+      gphi_iterator psi;\n+      gimple_stmt_iterator si;\n+      unsigned i;\n+\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+\t{\n+\t  gphi *phi = psi.phi ();\n+\n+\t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\t    {\n+\t      tree *arg_p = gimple_phi_arg_def_ptr (phi, i);\n+\t      find_decls_types (*arg_p, fld);\n+\t    }\n+\t}\n+\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple *stmt = gsi_stmt (si);\n+\n+\t  if (is_gimple_call (stmt))\n+\t    find_decls_types (gimple_call_fntype (stmt), fld);\n+\n+\t  for (i = 0; i < gimple_num_ops (stmt); i++)\n+\t    {\n+\t      tree arg = gimple_op (stmt, i);\n+\t      find_decls_types (arg, fld);\n+\t      /* find_decls_types doesn't walk TREE_PURPOSE of TREE_LISTs,\n+\t\t which we need for asm stmts.  */\n+\t      if (arg\n+\t\t  && TREE_CODE (arg) == TREE_LIST\n+\t\t  && TREE_PURPOSE (arg)\n+\t\t  && gimple_code (stmt) == GIMPLE_ASM)\n+\t\tfind_decls_types (TREE_PURPOSE (arg), fld);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Find decls and types referenced in varpool node N and store them in\n+   FLD->DECLS and FLD->TYPES.  Unlike pass_referenced_vars, this will\n+   look for *every* kind of DECL and TYPE node reachable from N,\n+   including those embedded inside types and decls (i.e,, TYPE_DECLs,\n+   NAMESPACE_DECLs, etc).  */\n+\n+static void\n+find_decls_types_in_var (varpool_node *v, class free_lang_data_d *fld)\n+{\n+  find_decls_types (v->decl, fld);\n+}\n+\n+/* Free language specific information for every operand and expression\n+   in every node of the call graph.  This process operates in three stages:\n+\n+   1- Every callgraph node and varpool node is traversed looking for\n+   decls and types embedded in them.  This is a more exhaustive\n+   search than that done by find_referenced_vars, because it will\n+   also collect individual fields, decls embedded in types, etc.\n+\n+   2- All the decls found are sent to free_lang_data_in_decl.\n+\n+   3- All the types found are sent to free_lang_data_in_type.\n+\n+   The ordering between decls and types is important because\n+   free_lang_data_in_decl sets assembler names, which includes\n+   mangling.  So types cannot be freed up until assembler names have\n+   been set up.  */\n+\n+static void\n+free_lang_data_in_cgraph (class free_lang_data_d *fld)\n+{\n+  struct cgraph_node *n;\n+  varpool_node *v;\n+  tree t;\n+  unsigned i;\n+  alias_pair *p;\n+\n+  /* Find decls and types in the body of every function in the callgraph.  */\n+  FOR_EACH_FUNCTION (n)\n+    find_decls_types_in_node (n, fld);\n+\n+  FOR_EACH_VEC_SAFE_ELT (alias_pairs, i, p)\n+    find_decls_types (p->decl, fld);\n+\n+  /* Find decls and types in every varpool symbol.  */\n+  FOR_EACH_VARIABLE (v)\n+    find_decls_types_in_var (v, fld);\n+\n+  /* Set the assembler name on every decl found.  We need to do this\n+     now because free_lang_data_in_decl will invalidate data needed\n+     for mangling.  This breaks mangling on interdependent decls.  */\n+  FOR_EACH_VEC_ELT (fld->decls, i, t)\n+    assign_assembler_name_if_needed (t);\n+\n+  /* Traverse every decl found freeing its language data.  */\n+  FOR_EACH_VEC_ELT (fld->decls, i, t)\n+    free_lang_data_in_decl (t, fld);\n+\n+  /* Traverse every type found freeing its language data.  */\n+  FOR_EACH_VEC_ELT (fld->types, i, t)\n+    free_lang_data_in_type (t, fld);\n+}\n+\n+\n+/* Free resources that are used by FE but are not needed once they are done. */\n+\n+static unsigned\n+free_lang_data (void)\n+{\n+  unsigned i;\n+  class free_lang_data_d fld;\n+\n+  /* If we are the LTO frontend we have freed lang-specific data already.  */\n+  if (in_lto_p\n+      || (!flag_generate_lto && !flag_generate_offload))\n+    {\n+      /* Rebuild type inheritance graph even when not doing LTO to get\n+\t consistent profile data.  */\n+      rebuild_type_inheritance_graph ();\n+      return 0;\n+    }\n+\n+  fld_incomplete_types = new hash_map<tree, tree>;\n+  fld_simplified_types = new hash_map<tree, tree>;\n+\n+  /* Provide a dummy TRANSLATION_UNIT_DECL if the FE failed to provide one.  */\n+  if (vec_safe_is_empty (all_translation_units))\n+    build_translation_unit_decl (NULL_TREE);\n+\n+  /* Allocate and assign alias sets to the standard integer types\n+     while the slots are still in the way the frontends generated them.  */\n+  for (i = 0; i < itk_none; ++i)\n+    if (integer_types[i])\n+      TYPE_ALIAS_SET (integer_types[i]) = get_alias_set (integer_types[i]);\n+\n+  /* Traverse the IL resetting language specific information for\n+     operands, expressions, etc.  */\n+  free_lang_data_in_cgraph (&fld);\n+\n+  /* Create gimple variants for common types.  */\n+  for (unsigned i = 0;\n+       i < sizeof (builtin_structptr_types) / sizeof (builtin_structptr_type);\n+       ++i)\n+    builtin_structptr_types[i].node = builtin_structptr_types[i].base;\n+\n+  /* Reset some langhooks.  Do not reset types_compatible_p, it may\n+     still be used indirectly via the get_alias_set langhook.  */\n+  lang_hooks.dwarf_name = lhd_dwarf_name;\n+  lang_hooks.decl_printable_name = gimple_decl_printable_name;\n+  lang_hooks.gimplify_expr = lhd_gimplify_expr;\n+  lang_hooks.overwrite_decl_assembler_name = lhd_overwrite_decl_assembler_name;\n+  lang_hooks.print_xnode = lhd_print_tree_nothing;\n+  lang_hooks.print_decl = lhd_print_tree_nothing;\n+  lang_hooks.print_type = lhd_print_tree_nothing;\n+  lang_hooks.print_identifier = lhd_print_tree_nothing;\n+\n+  lang_hooks.tree_inlining.var_mod_type_p = hook_bool_tree_tree_false;\n+\n+  if (flag_checking)\n+    {\n+      int i;\n+      tree t;\n+\n+      FOR_EACH_VEC_ELT (fld.types, i, t)\n+\tverify_type (t);\n+    }\n+\n+  /* We do not want the default decl_assembler_name implementation,\n+     rather if we have fixed everything we want a wrapper around it\n+     asserting that all non-local symbols already got their assembler\n+     name and only produce assembler names for local symbols.  Or rather\n+     make sure we never call decl_assembler_name on local symbols and\n+     devise a separate, middle-end private scheme for it.  */\n+\n+  /* Reset diagnostic machinery.  */\n+  tree_diagnostics_defaults (global_dc);\n+\n+  rebuild_type_inheritance_graph ();\n+\n+  delete fld_incomplete_types;\n+  delete fld_simplified_types;\n+\n+  return 0;\n+}\n+\n+const pass_data pass_data_ipa_free_lang_data =\n+  {\n+   SIMPLE_IPA_PASS, /* type */\n+   \"*free_lang_data\", /* name */\n+   OPTGROUP_NONE, /* optinfo_flags */\n+   TV_IPA_FREE_LANG_DATA, /* tv_id */\n+   0, /* properties_required */\n+   0, /* properties_provided */\n+   0, /* properties_destroyed */\n+   0, /* todo_flags_start */\n+   0, /* todo_flags_finish */\n+  };\n+\n+class pass_ipa_free_lang_data : public simple_ipa_opt_pass\n+{\n+public:\n+  pass_ipa_free_lang_data (gcc::context *ctxt)\n+    : simple_ipa_opt_pass (pass_data_ipa_free_lang_data, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *) { return free_lang_data (); }\n+\n+}; // class pass_ipa_free_lang_data\n+\n+} // anon namespace\n+\n+simple_ipa_opt_pass *\n+make_pass_ipa_free_lang_data (gcc::context *ctxt)\n+{\n+  return new pass_ipa_free_lang_data (ctxt);\n+}"}, {"sha": "c5506a005bbfc9f6ac2dac389a3f02787dd9a3d2", "filename": "gcc/tree.c", "status": "modified", "additions": 184, "deletions": 1328, "changes": 1512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7c792569d7a227426aaeb124686a856614da7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7c792569d7a227426aaeb124686a856614da7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2de7c792569d7a227426aaeb124686a856614da7", "patch": "@@ -266,8 +266,6 @@ static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n \n-static tree build_array_type_1 (tree, tree, bool, bool, bool);\n-\n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n \n@@ -722,6 +720,112 @@ overwrite_decl_assembler_name (tree decl, tree name)\n     lang_hooks.overwrite_decl_assembler_name (decl, name);\n }\n \n+/* Return true if DECL may need an assembler name to be set.  */\n+\n+static inline bool\n+need_assembler_name_p (tree decl)\n+{\n+  /* We use DECL_ASSEMBLER_NAME to hold mangled type names for One Definition\n+     Rule merging.  This makes type_odr_p to return true on those types during\n+     LTO and by comparing the mangled name, we can say what types are intended\n+     to be equivalent across compilation unit.\n+\n+     We do not store names of type_in_anonymous_namespace_p.\n+\n+     Record, union and enumeration type have linkage that allows use\n+     to check type_in_anonymous_namespace_p. We do not mangle compound types\n+     that always can be compared structurally.\n+\n+     Similarly for builtin types, we compare properties of their main variant.\n+     A special case are integer types where mangling do make differences\n+     between char/signed char/unsigned char etc.  Storing name for these makes\n+     e.g.  -fno-signed-char/-fsigned-char mismatches to be handled well.\n+     See cp/mangle.c:write_builtin_type for details.  */\n+\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      if (DECL_NAME (decl)\n+\t  && decl == TYPE_NAME (TREE_TYPE (decl))\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (decl)) == TREE_TYPE (decl)\n+\t  && !TYPE_ARTIFICIAL (TREE_TYPE (decl))\n+\t  && ((TREE_CODE (TREE_TYPE (decl)) != RECORD_TYPE\n+\t       && TREE_CODE (TREE_TYPE (decl)) != UNION_TYPE)\n+\t      || TYPE_CXX_ODR_P (TREE_TYPE (decl)))\n+\t  && (type_with_linkage_p (TREE_TYPE (decl))\n+\t      || TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE)\n+\t  && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+\treturn !DECL_ASSEMBLER_NAME_SET_P (decl);\n+      return false;\n+    }\n+  /* Only FUNCTION_DECLs and VAR_DECLs are considered.  */\n+  if (!VAR_OR_FUNCTION_DECL_P (decl))\n+    return false;\n+\n+  /* If DECL already has its assembler name set, it does not need a\n+     new one.  */\n+  if (!HAS_DECL_ASSEMBLER_NAME_P (decl)\n+      || DECL_ASSEMBLER_NAME_SET_P (decl))\n+    return false;\n+\n+  /* Abstract decls do not need an assembler name.  */\n+  if (DECL_ABSTRACT_P (decl))\n+    return false;\n+\n+  /* For VAR_DECLs, only static, public and external symbols need an\n+     assembler name.  */\n+  if (VAR_P (decl)\n+      && !TREE_STATIC (decl)\n+      && !TREE_PUBLIC (decl)\n+      && !DECL_EXTERNAL (decl))\n+    return false;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      /* Do not set assembler name on builtins.  Allow RTL expansion to\n+\t decide whether to expand inline or via a regular call.  */\n+      if (fndecl_built_in_p (decl)\n+\t  && DECL_BUILT_IN_CLASS (decl) != BUILT_IN_FRONTEND)\n+\treturn false;\n+\n+      /* Functions represented in the callgraph need an assembler name.  */\n+      if (cgraph_node::get (decl) != NULL)\n+\treturn true;\n+\n+      /* Unused and not public functions don't need an assembler name.  */\n+      if (!TREE_USED (decl) && !TREE_PUBLIC (decl))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* If T needs an assembler name, have one created for it.  */\n+\n+void\n+assign_assembler_name_if_needed (tree t)\n+{\n+  if (need_assembler_name_p (t))\n+    {\n+      /* When setting DECL_ASSEMBLER_NAME, the C++ mangler may emit\n+\t diagnostics that use input_location to show locus\n+\t information.  The problem here is that, at this point,\n+\t input_location is generally anchored to the end of the file\n+\t (since the parser is long gone), so we don't have a good\n+\t position to pin it to.\n+\n+\t To alleviate this problem, this uses the location of T's\n+\t declaration.  Examples of this are\n+\t testsuite/g++.dg/template/cond2.C and\n+\t testsuite/g++.dg/template/pr35240.C.  */\n+      location_t saved_location = input_location;\n+      input_location = DECL_SOURCE_LOCATION (t);\n+\n+      decl_assembler_name (t);\n+\n+      input_location = saved_location;\n+    }\n+}\n+\n /* When the target supports COMDAT groups, this indicates which group the\n    DECL is associated with.  This can be either an IDENTIFIER_NODE or a\n    decl, in which case its DECL_ASSEMBLER_NAME identifies the group.  */\n@@ -5245,1365 +5349,117 @@ protected_set_expr_location_if_unset (tree t, location_t loc)\n   if (t && !EXPR_HAS_LOCATION (t))\n     protected_set_expr_location (t, loc);\n }\n-\n-/* Data used when collecting DECLs and TYPEs for language data removal.  */\n-\n-class free_lang_data_d\n-{\n-public:\n-  free_lang_data_d () : decls (100), types (100) {}\n-\n-  /* Worklist to avoid excessive recursion.  */\n-  auto_vec<tree> worklist;\n-\n-  /* Set of traversed objects.  Used to avoid duplicate visits.  */\n-  hash_set<tree> pset;\n-\n-  /* Array of symbols to process with free_lang_data_in_decl.  */\n-  auto_vec<tree> decls;\n-\n-  /* Array of types to process with free_lang_data_in_type.  */\n-  auto_vec<tree> types;\n-};\n-\n-\n-/* Add type or decl T to one of the list of tree nodes that need their\n-   language data removed.  The lists are held inside FLD.  */\n+\f\n+/* Set the type qualifiers for TYPE to TYPE_QUALS, which is a bitmask\n+   of the various TYPE_QUAL values.  */\n \n static void\n-add_tree_to_fld_list (tree t, class free_lang_data_d *fld)\n+set_type_quals (tree type, int type_quals)\n {\n-  if (DECL_P (t))\n-    fld->decls.safe_push (t);\n-  else if (TYPE_P (t))\n-    fld->types.safe_push (t);\n-  else\n-    gcc_unreachable ();\n+  TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;\n+  TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n+  TYPE_RESTRICT (type) = (type_quals & TYPE_QUAL_RESTRICT) != 0;\n+  TYPE_ATOMIC (type) = (type_quals & TYPE_QUAL_ATOMIC) != 0;\n+  TYPE_ADDR_SPACE (type) = DECODE_QUAL_ADDR_SPACE (type_quals);\n }\n \n-/* Push tree node T into FLD->WORKLIST.  */\n+/* Returns true iff CAND and BASE have equivalent language-specific\n+   qualifiers.  */\n \n-static inline void\n-fld_worklist_push (tree t, class free_lang_data_d *fld)\n+bool\n+check_lang_type (const_tree cand, const_tree base)\n {\n-  if (t && !is_lang_specific (t) && !fld->pset.contains (t))\n-    fld->worklist.safe_push ((t));\n-}\n-\n-\n-\f\n-/* Return simplified TYPE_NAME of TYPE.  */\n-\n-static tree\n-fld_simplified_type_name (tree type)\n-{\n-  if (!TYPE_NAME (type) || TREE_CODE (TYPE_NAME (type)) != TYPE_DECL)\n-    return TYPE_NAME (type);\n-  /* Drop TYPE_DECLs in TYPE_NAME in favor of the identifier in the\n-     TYPE_DECL if the type doesn't have linkage.\n-     this must match fld_  */\n-  if (type != TYPE_MAIN_VARIANT (type)\n-      || (!DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (type))\n-\t  && (TREE_CODE (type) != RECORD_TYPE\n-\t      || !TYPE_BINFO (type)\n-\t      || !BINFO_VTABLE (TYPE_BINFO (type)))))\n-    return DECL_NAME (TYPE_NAME (type));\n-  return TYPE_NAME (type);\n-}\n-\n-/* Do same comparsion as check_qualified_type skipping lang part of type\n-   and be more permissive about type names: we only care that names are\n-   same (for diagnostics) and that ODR names are the same.\n-   If INNER_TYPE is non-NULL, be sure that TREE_TYPE match it.  */\n-\n-static bool\n-fld_type_variant_equal_p (tree t, tree v, tree inner_type)\n-{\n-  if (TYPE_QUALS (t) != TYPE_QUALS (v)\n-      /* We want to match incomplete variants with complete types.\n-\t In this case we need to ignore alignment.   */\n-      || ((!RECORD_OR_UNION_TYPE_P (t) || COMPLETE_TYPE_P (v))\n-\t  && (TYPE_ALIGN (t) != TYPE_ALIGN (v)\n-\t      || TYPE_USER_ALIGN (t) != TYPE_USER_ALIGN (v)))\n-      || fld_simplified_type_name (t) != fld_simplified_type_name (v)\n-      || !attribute_list_equal (TYPE_ATTRIBUTES (t),\n-\t\t\t        TYPE_ATTRIBUTES (v))\n-      || (inner_type && TREE_TYPE (v) != inner_type))\n-    return false;\n-\n-  return true;\n+  if (lang_hooks.types.type_hash_eq == NULL)\n+    return true;\n+  /* type_hash_eq currently only applies to these types.  */\n+  if (TREE_CODE (cand) != FUNCTION_TYPE\n+      && TREE_CODE (cand) != METHOD_TYPE)\n+    return true;\n+  return lang_hooks.types.type_hash_eq (cand, base);\n }\n \n-/* Find variant of FIRST that match T and create new one if necessary.\n-   Set TREE_TYPE to INNER_TYPE if non-NULL.  */\n+/* This function checks to see if TYPE matches the size one of the built-in \n+   atomic types, and returns that core atomic type.  */\n \n static tree\n-fld_type_variant (tree first, tree t, class free_lang_data_d *fld,\n-\t\t  tree inner_type = NULL)\n+find_atomic_core_type (const_tree type)\n {\n-  if (first == TYPE_MAIN_VARIANT (t))\n-    return t;\n-  for (tree v = first; v; v = TYPE_NEXT_VARIANT (v))\n-    if (fld_type_variant_equal_p (t, v, inner_type))\n-      return v;\n-  tree v = build_variant_type_copy (first);\n-  TYPE_READONLY (v) = TYPE_READONLY (t);\n-  TYPE_VOLATILE (v) = TYPE_VOLATILE (t);\n-  TYPE_ATOMIC (v) = TYPE_ATOMIC (t);\n-  TYPE_RESTRICT (v) = TYPE_RESTRICT (t);\n-  TYPE_ADDR_SPACE (v) = TYPE_ADDR_SPACE (t);\n-  TYPE_NAME (v) = TYPE_NAME (t);\n-  TYPE_ATTRIBUTES (v) = TYPE_ATTRIBUTES (t);\n-  TYPE_CANONICAL (v) = TYPE_CANONICAL (t);\n-  /* Variants of incomplete types should have alignment \n-     set to BITS_PER_UNIT.  Do not copy the actual alignment.  */\n-  if (!RECORD_OR_UNION_TYPE_P (v) || COMPLETE_TYPE_P (v))\n-    {\n-      SET_TYPE_ALIGN (v, TYPE_ALIGN (t));\n-      TYPE_USER_ALIGN (v) = TYPE_USER_ALIGN (t);\n-    }\n-  if (inner_type)\n-    TREE_TYPE (v) = inner_type;\n-  gcc_checking_assert (fld_type_variant_equal_p (t,v, inner_type));\n-  if (!fld->pset.add (v))\n-    add_tree_to_fld_list (v, fld);\n-  return v;\n-}\n-\n-/* Map complete types to incomplete types.  */\n+  tree base_atomic_type;\n \n-static hash_map<tree, tree> *fld_incomplete_types;\n+  /* Only handle complete types.  */\n+  if (!tree_fits_uhwi_p (TYPE_SIZE (type)))\n+    return NULL_TREE;\n \n-/* Map types to simplified types.  */\n+  switch (tree_to_uhwi (TYPE_SIZE (type)))\n+    {\n+    case 8:\n+      base_atomic_type = atomicQI_type_node;\n+      break;\n \n-static hash_map<tree, tree> *fld_simplified_types;\n+    case 16:\n+      base_atomic_type = atomicHI_type_node;\n+      break;\n \n-/* Produce variant of T whose TREE_TYPE is T2. If it is main variant,\n-   use MAP to prevent duplicates.  */\n+    case 32:\n+      base_atomic_type = atomicSI_type_node;\n+      break;\n \n-static tree\n-fld_process_array_type (tree t, tree t2, hash_map<tree, tree> *map,\n-\t\t\tclass free_lang_data_d *fld)\n-{\n-  if (TREE_TYPE (t) == t2)\n-    return t;\n+    case 64:\n+      base_atomic_type = atomicDI_type_node;\n+      break;\n \n-  if (TYPE_MAIN_VARIANT (t) != t)\n-    {\n-      return fld_type_variant\n-\t       (fld_process_array_type (TYPE_MAIN_VARIANT (t),\n-\t\t\t\t\tTYPE_MAIN_VARIANT (t2), map, fld),\n-\t\tt, fld, t2);\n-    }\n+    case 128:\n+      base_atomic_type = atomicTI_type_node;\n+      break;\n \n-  bool existed;\n-  tree &array\n-     = map->get_or_insert (t, &existed);\n-  if (!existed)\n-    {\n-      array\n-\t= build_array_type_1 (t2, TYPE_DOMAIN (t), TYPE_TYPELESS_STORAGE (t),\n-\t\t\t      false, false);\n-      TYPE_CANONICAL (array) = TYPE_CANONICAL (t);\n-      if (!fld->pset.add (array))\n-\tadd_tree_to_fld_list (array, fld);\n+    default:\n+      base_atomic_type = NULL_TREE;\n     }\n-  return array;\n-}\n \n-/* Return CTX after removal of contexts that are not relevant  */\n-\n-static tree\n-fld_decl_context (tree ctx)\n-{\n-  /* Variably modified types are needed for tree_is_indexable to decide\n-     whether the type needs to go to local or global section.\n-     This code is semi-broken but for now it is easiest to keep contexts\n-     as expected.  */\n-  if (ctx && TYPE_P (ctx)\n-      && !variably_modified_type_p (ctx, NULL_TREE))\n-     {\n-       while (ctx && TYPE_P (ctx))\n-\t ctx = TYPE_CONTEXT (ctx);\n-     }\n-  return ctx;\n+  return base_atomic_type;\n }\n \n-/* For T being aggregate type try to turn it into a incomplete variant.\n-   Return T if no simplification is possible.  */\n+/* Returns true iff unqualified CAND and BASE are equivalent.  */\n \n-static tree\n-fld_incomplete_type_of (tree t, class free_lang_data_d *fld)\n+bool\n+check_base_type (const_tree cand, const_tree base)\n {\n-  if (!t)\n-    return NULL;\n-  if (POINTER_TYPE_P (t))\n+  if (TYPE_NAME (cand) != TYPE_NAME (base)\n+      /* Apparently this is needed for Objective-C.  */\n+      || TYPE_CONTEXT (cand) != TYPE_CONTEXT (base)\n+      || !attribute_list_equal (TYPE_ATTRIBUTES (cand),\n+\t\t\t        TYPE_ATTRIBUTES (base)))\n+    return false;\n+  /* Check alignment.  */\n+  if (TYPE_ALIGN (cand) == TYPE_ALIGN (base)\n+      && TYPE_USER_ALIGN (cand) == TYPE_USER_ALIGN (base))\n+    return true;\n+  /* Atomic types increase minimal alignment.  We must to do so as well\n+     or we get duplicated canonical types. See PR88686.  */\n+  if ((TYPE_QUALS (cand) & TYPE_QUAL_ATOMIC))\n     {\n-      tree t2 = fld_incomplete_type_of (TREE_TYPE (t), fld);\n-      if (t2 != TREE_TYPE (t))\n-\t{\n-\t  tree first;\n-\t  if (TREE_CODE (t) == POINTER_TYPE)\n-\t    first = build_pointer_type_for_mode (t2, TYPE_MODE (t),\n-\t\t\t\t\t\tTYPE_REF_CAN_ALIAS_ALL (t));\n-\t  else\n-\t    first = build_reference_type_for_mode (t2, TYPE_MODE (t),\n-\t\t\t\t\t\tTYPE_REF_CAN_ALIAS_ALL (t));\n-\t  gcc_assert (TYPE_CANONICAL (t2) != t2\n-\t\t      && TYPE_CANONICAL (t2) == TYPE_CANONICAL (TREE_TYPE (t)));\n-\t  if (!fld->pset.add (first))\n-\t    add_tree_to_fld_list (first, fld);\n-\t  return fld_type_variant (first, t, fld);\n-\t}\n-      return t;\n+      /* See if this object can map to a basic atomic type.  */\n+      tree atomic_type = find_atomic_core_type (cand);\n+      if (atomic_type && TYPE_ALIGN (atomic_type) == TYPE_ALIGN (cand))\n+       return true;\n     }\n-  if (TREE_CODE (t) == ARRAY_TYPE)\n-    return fld_process_array_type (t,\n-\t\t\t\t   fld_incomplete_type_of (TREE_TYPE (t), fld),\n-\t\t\t\t   fld_incomplete_types, fld);\n-  if ((!RECORD_OR_UNION_TYPE_P (t) && TREE_CODE (t) != ENUMERAL_TYPE)\n-      || !COMPLETE_TYPE_P (t))\n-    return t;\n-  if (TYPE_MAIN_VARIANT (t) == t)\n-    {\n-      bool existed;\n-      tree &copy\n-\t = fld_incomplete_types->get_or_insert (t, &existed);\n-\n-      if (!existed)\n-\t{\n-\t  copy = build_distinct_type_copy (t);\n-\n-\t  /* It is possible that type was not seen by free_lang_data yet.  */\n-\t  if (!fld->pset.add (copy))\n-\t    add_tree_to_fld_list (copy, fld);\n-\t  TYPE_SIZE (copy) = NULL;\n-\t  TYPE_USER_ALIGN (copy) = 0;\n-\t  TYPE_SIZE_UNIT (copy) = NULL;\n-\t  TYPE_CANONICAL (copy) = TYPE_CANONICAL (t);\n-\t  TREE_ADDRESSABLE (copy) = 0;\n-\t  if (AGGREGATE_TYPE_P (t))\n-\t    {\n-\t      SET_TYPE_MODE (copy, VOIDmode);\n-\t      SET_TYPE_ALIGN (copy, BITS_PER_UNIT);\n-\t      TYPE_TYPELESS_STORAGE (copy) = 0;\n-\t      TYPE_FIELDS (copy) = NULL;\n-\t      TYPE_BINFO (copy) = NULL;\n-\t      TYPE_FINAL_P (copy) = 0;\n-\t      TYPE_EMPTY_P (copy) = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      TYPE_VALUES (copy) = NULL;\n-\t      ENUM_IS_OPAQUE (copy) = 0;\n-\t      ENUM_IS_SCOPED (copy) = 0;\n-\t    }\n-\n-\t  /* Build copy of TYPE_DECL in TYPE_NAME if necessary.\n-\t     This is needed for ODR violation warnings to come out right (we\n-\t     want duplicate TYPE_DECLs whenever the type is duplicated because\n-\t     of ODR violation.  Because lang data in the TYPE_DECL may not\n-\t     have been freed yet, rebuild it from scratch and copy relevant\n-\t     fields.  */\n-\t  TYPE_NAME (copy) = fld_simplified_type_name (copy);\n-\t  tree name = TYPE_NAME (copy);\n-\n-\t  if (name && TREE_CODE (name) == TYPE_DECL)\n-\t    {\n-\t      gcc_checking_assert (TREE_TYPE (name) == t);\n-\t      tree name2 = build_decl (DECL_SOURCE_LOCATION (name), TYPE_DECL,\n-\t\t\t\t       DECL_NAME (name), copy);\n-\t      if (DECL_ASSEMBLER_NAME_SET_P (name))\n-\t        SET_DECL_ASSEMBLER_NAME (name2, DECL_ASSEMBLER_NAME (name));\n-\t      SET_DECL_ALIGN (name2, 0);\n-\t      DECL_CONTEXT (name2) = fld_decl_context\n-\t\t\t\t\t (DECL_CONTEXT (name));\n-\t      TYPE_NAME (copy) = name2;\n-\t    }\n-\t}\n-      return copy;\n-   }\n-  return (fld_type_variant\n-\t    (fld_incomplete_type_of (TYPE_MAIN_VARIANT (t), fld), t, fld));\n+  return false;\n }\n \n-/* Simplify type T for scenarios where we do not need complete pointer\n-   types.  */\n+/* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */\n \n-static tree\n-fld_simplified_type (tree t, class free_lang_data_d *fld)\n+bool\n+check_qualified_type (const_tree cand, const_tree base, int type_quals)\n {\n-  if (!t)\n-    return t;\n-  if (POINTER_TYPE_P (t))\n-    return fld_incomplete_type_of (t, fld);\n-  /* FIXME: This triggers verification error, see PR88140.  */\n-#if 0\n-  if (TREE_CODE (t) == ARRAY_TYPE)\n-    return fld_process_array_type (t, fld_simplified_type (TREE_TYPE (t), fld),\n-\t\t\t\t   fld_simplified_types, fld);\n-#endif\n-  return t;\n+  return (TYPE_QUALS (cand) == type_quals\n+\t  && check_base_type (cand, base)\n+\t  && check_lang_type (cand, base));\n }\n \n-/* Reset the expression *EXPR_P, a size or position.\n-\n-   ??? We could reset all non-constant sizes or positions.  But it's cheap\n-   enough to not do so and refrain from adding workarounds to dwarf2out.c.\n-\n-   We need to reset self-referential sizes or positions because they cannot\n-   be gimplified and thus can contain a CALL_EXPR after the gimplification\n-   is finished, which will run afoul of LTO streaming.  And they need to be\n-   reset to something essentially dummy but not constant, so as to preserve\n-   the properties of the object they are attached to.  */\n+/* Returns true iff CAND is equivalent to BASE with ALIGN.  */\n \n-static inline void\n-free_lang_data_in_one_sizepos (tree *expr_p)\n-{\n-  tree expr = *expr_p;\n-  if (CONTAINS_PLACEHOLDER_P (expr))\n-    *expr_p = build0 (PLACEHOLDER_EXPR, TREE_TYPE (expr));\n-}\n-\n-\n-/* Reset all the fields in a binfo node BINFO.  We only keep\n-   BINFO_VTABLE, which is used by gimple_fold_obj_type_ref.  */\n-\n-static void\n-free_lang_data_in_binfo (tree binfo)\n-{\n-  unsigned i;\n-  tree t;\n-\n-  gcc_assert (TREE_CODE (binfo) == TREE_BINFO);\n-\n-  BINFO_VIRTUALS (binfo) = NULL_TREE;\n-  BINFO_BASE_ACCESSES (binfo) = NULL;\n-  BINFO_INHERITANCE_CHAIN (binfo) = NULL_TREE;\n-  BINFO_SUBVTT_INDEX (binfo) = NULL_TREE;\n-  BINFO_VPTR_FIELD (binfo) = NULL_TREE;\n-  TREE_PUBLIC (binfo) = 0;\n-\n-  FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (binfo), i, t)\n-    free_lang_data_in_binfo (t);\n-}\n-\n-\n-/* Reset all language specific information still present in TYPE.  */\n-\n-static void\n-free_lang_data_in_type (tree type, class free_lang_data_d *fld)\n-{\n-  gcc_assert (TYPE_P (type));\n-\n-  /* Give the FE a chance to remove its own data first.  */\n-  lang_hooks.free_lang_data (type);\n-\n-  TREE_LANG_FLAG_0 (type) = 0;\n-  TREE_LANG_FLAG_1 (type) = 0;\n-  TREE_LANG_FLAG_2 (type) = 0;\n-  TREE_LANG_FLAG_3 (type) = 0;\n-  TREE_LANG_FLAG_4 (type) = 0;\n-  TREE_LANG_FLAG_5 (type) = 0;\n-  TREE_LANG_FLAG_6 (type) = 0;\n-\n-  TYPE_NEEDS_CONSTRUCTING (type) = 0;\n-\n-  /* Purge non-marked variants from the variants chain, so that they\n-     don't reappear in the IL after free_lang_data.  */\n-  while (TYPE_NEXT_VARIANT (type)\n-\t && !fld->pset.contains (TYPE_NEXT_VARIANT (type)))\n-    {\n-      tree t = TYPE_NEXT_VARIANT (type);\n-      TYPE_NEXT_VARIANT (type) = TYPE_NEXT_VARIANT (t);\n-      /* Turn the removed types into distinct types.  */\n-      TYPE_MAIN_VARIANT (t) = t;\n-      TYPE_NEXT_VARIANT (t) = NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (type) == FUNCTION_TYPE)\n-    {\n-      TREE_TYPE (type) = fld_simplified_type (TREE_TYPE (type), fld);\n-      /* Remove the const and volatile qualifiers from arguments.  The\n-\t C++ front end removes them, but the C front end does not,\n-\t leading to false ODR violation errors when merging two\n-\t instances of the same function signature compiled by\n-\t different front ends.  */\n-      for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n-\t{\n-          TREE_VALUE (p) = fld_simplified_type (TREE_VALUE (p), fld);\n-\t  tree arg_type = TREE_VALUE (p);\n-\n-\t  if (TYPE_READONLY (arg_type) || TYPE_VOLATILE (arg_type))\n-\t    {\n-\t      int quals = TYPE_QUALS (arg_type)\n-\t\t\t  & ~TYPE_QUAL_CONST\n-\t\t\t  & ~TYPE_QUAL_VOLATILE;\n-\t      TREE_VALUE (p) = build_qualified_type (arg_type, quals);\n-\t      if (!fld->pset.add (TREE_VALUE (p)))\n-\t\tfree_lang_data_in_type (TREE_VALUE (p), fld);\n-\t    }\n-\t  /* C++ FE uses TREE_PURPOSE to store initial values.  */\n-\t  TREE_PURPOSE (p) = NULL;\n-\t}\n-    }\n-  else if (TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      TREE_TYPE (type) = fld_simplified_type (TREE_TYPE (type), fld);\n-      for (tree p = TYPE_ARG_TYPES (type); p; p = TREE_CHAIN (p))\n-\t{\n-\t  /* C++ FE uses TREE_PURPOSE to store initial values.  */\n-\t  TREE_VALUE (p) = fld_simplified_type (TREE_VALUE (p), fld);\n-\t  TREE_PURPOSE (p) = NULL;\n-\t}\n-    }\n-  else if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      /* Remove members that are not FIELD_DECLs from the field list\n-\t of an aggregate.  These occur in C++.  */\n-      for (tree *prev = &TYPE_FIELDS (type), member; (member = *prev);)\n-\tif (TREE_CODE (member) == FIELD_DECL)\n-\t  prev = &DECL_CHAIN (member);\n-\telse\n-\t  *prev = DECL_CHAIN (member);\n-\n-      TYPE_VFIELD (type) = NULL_TREE;\n-\n-      if (TYPE_BINFO (type))\n-\t{\n-\t  free_lang_data_in_binfo (TYPE_BINFO (type));\n-\t  /* We need to preserve link to bases and virtual table for all\n-\t     polymorphic types to make devirtualization machinery working.  */\n-\t  if (!BINFO_VTABLE (TYPE_BINFO (type)))\n-\t    TYPE_BINFO (type) = NULL;\n-\t}\n-    }\n-  else if (INTEGRAL_TYPE_P (type)\n-\t   || SCALAR_FLOAT_TYPE_P (type)\n-\t   || FIXED_POINT_TYPE_P (type))\n-    {\n-      if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t{\n-\t  ENUM_IS_OPAQUE (type) = 0;\n-\t  ENUM_IS_SCOPED (type) = 0;\n-\t  /* Type values are used only for C++ ODR checking.  Drop them\n-\t     for all type variants and non-ODR types.\n-\t     For ODR types the data is freed in free_odr_warning_data.  */\n-\t  if (!TYPE_VALUES (type))\n-\t    ;\n-\t  else if (TYPE_MAIN_VARIANT (type) != type\n-\t\t   || !type_with_linkage_p (type)\n-\t\t   || type_in_anonymous_namespace_p (type))\n-\t    TYPE_VALUES (type) = NULL;\n-\t  else\n-\t    register_odr_enum (type);\n-\t}\n-      free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n-      free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));\n-    }\n-\n-  TYPE_LANG_SLOT_1 (type) = NULL_TREE;\n-\n-  free_lang_data_in_one_sizepos (&TYPE_SIZE (type));\n-  free_lang_data_in_one_sizepos (&TYPE_SIZE_UNIT (type));\n-\n-  if (TYPE_CONTEXT (type)\n-      && TREE_CODE (TYPE_CONTEXT (type)) == BLOCK)\n-    {\n-      tree ctx = TYPE_CONTEXT (type);\n-      do\n-\t{\n-\t  ctx = BLOCK_SUPERCONTEXT (ctx);\n-\t}\n-      while (ctx && TREE_CODE (ctx) == BLOCK);\n-      TYPE_CONTEXT (type) = ctx;\n-    }\n-\n-  TYPE_STUB_DECL (type) = NULL;\n-  TYPE_NAME (type) = fld_simplified_type_name (type);\n-}\n-\n-\n-/* Return true if DECL may need an assembler name to be set.  */\n-\n-static inline bool\n-need_assembler_name_p (tree decl)\n-{\n-  /* We use DECL_ASSEMBLER_NAME to hold mangled type names for One Definition\n-     Rule merging.  This makes type_odr_p to return true on those types during\n-     LTO and by comparing the mangled name, we can say what types are intended\n-     to be equivalent across compilation unit.\n-\n-     We do not store names of type_in_anonymous_namespace_p.\n-\n-     Record, union and enumeration type have linkage that allows use\n-     to check type_in_anonymous_namespace_p. We do not mangle compound types\n-     that always can be compared structurally.\n-\n-     Similarly for builtin types, we compare properties of their main variant.\n-     A special case are integer types where mangling do make differences\n-     between char/signed char/unsigned char etc.  Storing name for these makes\n-     e.g.  -fno-signed-char/-fsigned-char mismatches to be handled well.\n-     See cp/mangle.c:write_builtin_type for details.  */\n-\n-  if (TREE_CODE (decl) == TYPE_DECL)\n-    {\n-      if (DECL_NAME (decl)\n-\t  && decl == TYPE_NAME (TREE_TYPE (decl))\n-\t  && TYPE_MAIN_VARIANT (TREE_TYPE (decl)) == TREE_TYPE (decl)\n-\t  && !TYPE_ARTIFICIAL (TREE_TYPE (decl))\n-\t  && ((TREE_CODE (TREE_TYPE (decl)) != RECORD_TYPE\n-\t       && TREE_CODE (TREE_TYPE (decl)) != UNION_TYPE)\n-\t      || TYPE_CXX_ODR_P (TREE_TYPE (decl)))\n-\t  && (type_with_linkage_p (TREE_TYPE (decl))\n-\t      || TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE)\n-\t  && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n-\treturn !DECL_ASSEMBLER_NAME_SET_P (decl);\n-      return false;\n-    }\n-  /* Only FUNCTION_DECLs and VAR_DECLs are considered.  */\n-  if (!VAR_OR_FUNCTION_DECL_P (decl))\n-    return false;\n-\n-  /* If DECL already has its assembler name set, it does not need a\n-     new one.  */\n-  if (!HAS_DECL_ASSEMBLER_NAME_P (decl)\n-      || DECL_ASSEMBLER_NAME_SET_P (decl))\n-    return false;\n-\n-  /* Abstract decls do not need an assembler name.  */\n-  if (DECL_ABSTRACT_P (decl))\n-    return false;\n-\n-  /* For VAR_DECLs, only static, public and external symbols need an\n-     assembler name.  */\n-  if (VAR_P (decl)\n-      && !TREE_STATIC (decl)\n-      && !TREE_PUBLIC (decl)\n-      && !DECL_EXTERNAL (decl))\n-    return false;\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      /* Do not set assembler name on builtins.  Allow RTL expansion to\n-\t decide whether to expand inline or via a regular call.  */\n-      if (fndecl_built_in_p (decl)\n-\t  && DECL_BUILT_IN_CLASS (decl) != BUILT_IN_FRONTEND)\n-\treturn false;\n-\n-      /* Functions represented in the callgraph need an assembler name.  */\n-      if (cgraph_node::get (decl) != NULL)\n-\treturn true;\n-\n-      /* Unused and not public functions don't need an assembler name.  */\n-      if (!TREE_USED (decl) && !TREE_PUBLIC (decl))\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-\n-/* Reset all language specific information still present in symbol\n-   DECL.  */\n-\n-static void\n-free_lang_data_in_decl (tree decl, class free_lang_data_d *fld)\n-{\n-  gcc_assert (DECL_P (decl));\n-\n-  /* Give the FE a chance to remove its own data first.  */\n-  lang_hooks.free_lang_data (decl);\n-\n-  TREE_LANG_FLAG_0 (decl) = 0;\n-  TREE_LANG_FLAG_1 (decl) = 0;\n-  TREE_LANG_FLAG_2 (decl) = 0;\n-  TREE_LANG_FLAG_3 (decl) = 0;\n-  TREE_LANG_FLAG_4 (decl) = 0;\n-  TREE_LANG_FLAG_5 (decl) = 0;\n-  TREE_LANG_FLAG_6 (decl) = 0;\n-\n-  free_lang_data_in_one_sizepos (&DECL_SIZE (decl));\n-  free_lang_data_in_one_sizepos (&DECL_SIZE_UNIT (decl));\n-  if (TREE_CODE (decl) == FIELD_DECL)\n-    {\n-      DECL_FCONTEXT (decl) = NULL;\n-      free_lang_data_in_one_sizepos (&DECL_FIELD_OFFSET (decl));\n-      if (TREE_CODE (DECL_CONTEXT (decl)) == QUAL_UNION_TYPE)\n-\tDECL_QUALIFIER (decl) = NULL_TREE;\n-    }\n-\n- if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      struct cgraph_node *node;\n-      /* Frontends do not set TREE_ADDRESSABLE on public variables even though\n-\t the address may be taken in other unit, so this flag has no practical\n-\t use for middle-end.\n-\n-\t It would make more sense if frontends set TREE_ADDRESSABLE to 0 only\n-\t for public objects that indeed cannot be adressed, but it is not\n-\t the case.  Set the flag to true so we do not get merge failures for\n-\t i.e. virtual tables between units that take address of it and\n-\t units that don't.  */\n-      if (TREE_PUBLIC (decl))\n-\tTREE_ADDRESSABLE (decl) = true;\n-      TREE_TYPE (decl) = fld_simplified_type (TREE_TYPE (decl), fld);\n-      if (!(node = cgraph_node::get (decl))\n-\t  || (!node->definition && !node->clones))\n-\t{\n-\t  if (node && !node->declare_variant_alt)\n-\t    node->release_body ();\n-\t  else\n-\t    {\n-\t      release_function_body (decl);\n-\t      DECL_ARGUMENTS (decl) = NULL;\n-\t      DECL_RESULT (decl) = NULL;\n-\t      DECL_INITIAL (decl) = error_mark_node;\n-\t    }\n-\t}\n-      if (gimple_has_body_p (decl) || (node && node->thunk))\n-\t{\n-\t  tree t;\n-\n-\t  /* If DECL has a gimple body, then the context for its\n-\t     arguments must be DECL.  Otherwise, it doesn't really\n-\t     matter, as we will not be emitting any code for DECL.  In\n-\t     general, there may be other instances of DECL created by\n-\t     the front end and since PARM_DECLs are generally shared,\n-\t     their DECL_CONTEXT changes as the replicas of DECL are\n-\t     created.  The only time where DECL_CONTEXT is important\n-\t     is for the FUNCTION_DECLs that have a gimple body (since\n-\t     the PARM_DECL will be used in the function's body).  */\n-\t  for (t = DECL_ARGUMENTS (decl); t; t = TREE_CHAIN (t))\n-\t    DECL_CONTEXT (t) = decl;\n-\t  if (!DECL_FUNCTION_SPECIFIC_TARGET (decl))\n-\t    DECL_FUNCTION_SPECIFIC_TARGET (decl)\n-\t      = target_option_default_node;\n-\t  if (!DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl))\n-\t    DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl)\n-\t      = optimization_default_node;\n-\t}\n-\n-      /* DECL_SAVED_TREE holds the GENERIC representation for DECL.\n-\t At this point, it is not needed anymore.  */\n-      DECL_SAVED_TREE (decl) = NULL_TREE;\n-\n-      /* Clear the abstract origin if it refers to a method.\n-         Otherwise dwarf2out.c will ICE as we splice functions out of\n-         TYPE_FIELDS and thus the origin will not be output\n-         correctly.  */\n-      if (DECL_ABSTRACT_ORIGIN (decl)\n-\t  && DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))\n-\t  && RECORD_OR_UNION_TYPE_P\n-\t       (DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))))\n-\tDECL_ABSTRACT_ORIGIN (decl) = NULL_TREE;\n-\n-      DECL_VINDEX (decl) = NULL_TREE;\n-    }\n-  else if (VAR_P (decl))\n-    {\n-      /* See comment above why we set the flag for functions.  */\n-      if (TREE_PUBLIC (decl))\n-\tTREE_ADDRESSABLE (decl) = true;\n-      if ((DECL_EXTERNAL (decl)\n-\t   && (!TREE_STATIC (decl) || !TREE_READONLY (decl)))\n-\t  || (decl_function_context (decl) && !TREE_STATIC (decl)))\n-\tDECL_INITIAL (decl) = NULL_TREE;\n-    }\n-  else if (TREE_CODE (decl) == TYPE_DECL)\n-    {\n-      DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;\n-      DECL_VISIBILITY_SPECIFIED (decl) = 0;\n-      TREE_PUBLIC (decl) = 0;\n-      TREE_PRIVATE (decl) = 0;\n-      DECL_ARTIFICIAL (decl) = 0;\n-      TYPE_DECL_SUPPRESS_DEBUG (decl) = 0;\n-      DECL_INITIAL (decl) = NULL_TREE;\n-      DECL_ORIGINAL_TYPE (decl) = NULL_TREE;\n-      DECL_MODE (decl) = VOIDmode;\n-      SET_DECL_ALIGN (decl, 0);\n-      /* TREE_TYPE is cleared at WPA time in free_odr_warning_data.  */\n-    }\n-  else if (TREE_CODE (decl) == FIELD_DECL)\n-    {\n-      TREE_TYPE (decl) = fld_simplified_type (TREE_TYPE (decl), fld);\n-      DECL_INITIAL (decl) = NULL_TREE;\n-    }\n-  else if (TREE_CODE (decl) == TRANSLATION_UNIT_DECL\n-           && DECL_INITIAL (decl)\n-           && TREE_CODE (DECL_INITIAL (decl)) == BLOCK)\n-    {\n-      /* Strip builtins from the translation-unit BLOCK.  We still have targets\n-\t without builtin_decl_explicit support and also builtins are shared\n-\t nodes and thus we can't use TREE_CHAIN in multiple lists.  */\n-      tree *nextp = &BLOCK_VARS (DECL_INITIAL (decl));\n-      while (*nextp)\n-\t{\n-\t  tree var = *nextp;\n-\t  if (TREE_CODE (var) == FUNCTION_DECL\n-\t      && fndecl_built_in_p (var))\n-\t    *nextp = TREE_CHAIN (var);\n-\t  else\n-\t    nextp = &TREE_CHAIN (var);\n-        }\n-    }\n-  /* We need to keep field decls associated with their trees. Otherwise tree\n-     merging may merge some fileds and keep others disjoint wich in turn will\n-     not do well with TREE_CHAIN pointers linking them.\n-\n-     Also do not drop containing types for virtual methods and tables because\n-     these are needed by devirtualization.\n-     C++ destructors are special because C++ frontends sometimes produces\n-     virtual destructor as an alias of non-virtual destructor.  In\n-     devirutalization code we always walk through aliases and we need\n-     context to be preserved too.  See PR89335  */\n-  if (TREE_CODE (decl) != FIELD_DECL\n-      && ((TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n-          || (!DECL_VIRTUAL_P (decl)\n-\t      && (TREE_CODE (decl) != FUNCTION_DECL\n-\t\t  || !DECL_CXX_DESTRUCTOR_P (decl)))))\n-    DECL_CONTEXT (decl) = fld_decl_context (DECL_CONTEXT (decl));\n-}\n-\n-\n-/* Operand callback helper for free_lang_data_in_node.  *TP is the\n-   subtree operand being considered.  */\n-\n-static tree\n-find_decls_types_r (tree *tp, int *ws, void *data)\n-{\n-  tree t = *tp;\n-  class free_lang_data_d *fld = (class free_lang_data_d *) data;\n-\n-  if (TREE_CODE (t) == TREE_LIST)\n-    return NULL_TREE;\n-\n-  /* Language specific nodes will be removed, so there is no need\n-     to gather anything under them.  */\n-  if (is_lang_specific (t))\n-    {\n-      *ws = 0;\n-      return NULL_TREE;\n-    }\n-\n-  if (DECL_P (t))\n-    {\n-      /* Note that walk_tree does not traverse every possible field in\n-\t decls, so we have to do our own traversals here.  */\n-      add_tree_to_fld_list (t, fld);\n-\n-      fld_worklist_push (DECL_NAME (t), fld);\n-      fld_worklist_push (DECL_CONTEXT (t), fld);\n-      fld_worklist_push (DECL_SIZE (t), fld);\n-      fld_worklist_push (DECL_SIZE_UNIT (t), fld);\n-\n-      /* We are going to remove everything under DECL_INITIAL for\n-\t TYPE_DECLs.  No point walking them.  */\n-      if (TREE_CODE (t) != TYPE_DECL)\n-\tfld_worklist_push (DECL_INITIAL (t), fld);\n-\n-      fld_worklist_push (DECL_ATTRIBUTES (t), fld);\n-      fld_worklist_push (DECL_ABSTRACT_ORIGIN (t), fld);\n-\n-      if (TREE_CODE (t) == FUNCTION_DECL)\n-\t{\n-\t  fld_worklist_push (DECL_ARGUMENTS (t), fld);\n-\t  fld_worklist_push (DECL_RESULT (t), fld);\n-\t}\n-      else if (TREE_CODE (t) == FIELD_DECL)\n-\t{\n-\t  fld_worklist_push (DECL_FIELD_OFFSET (t), fld);\n-\t  fld_worklist_push (DECL_BIT_FIELD_TYPE (t), fld);\n-\t  fld_worklist_push (DECL_FIELD_BIT_OFFSET (t), fld);\n-\t  fld_worklist_push (DECL_FCONTEXT (t), fld);\n-\t}\n-\n-      if ((VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n-\t  && DECL_HAS_VALUE_EXPR_P (t))\n-\tfld_worklist_push (DECL_VALUE_EXPR (t), fld);\n-\n-      if (TREE_CODE (t) != FIELD_DECL\n-\t  && TREE_CODE (t) != TYPE_DECL)\n-\tfld_worklist_push (TREE_CHAIN (t), fld);\n-      *ws = 0;\n-    }\n-  else if (TYPE_P (t))\n-    {\n-      /* Note that walk_tree does not traverse every possible field in\n-\t types, so we have to do our own traversals here.  */\n-      add_tree_to_fld_list (t, fld);\n-\n-      if (!RECORD_OR_UNION_TYPE_P (t))\n-\tfld_worklist_push (TYPE_CACHED_VALUES (t), fld);\n-      fld_worklist_push (TYPE_SIZE (t), fld);\n-      fld_worklist_push (TYPE_SIZE_UNIT (t), fld);\n-      fld_worklist_push (TYPE_ATTRIBUTES (t), fld);\n-      fld_worklist_push (TYPE_POINTER_TO (t), fld);\n-      fld_worklist_push (TYPE_REFERENCE_TO (t), fld);\n-      fld_worklist_push (TYPE_NAME (t), fld);\n-      /* While we do not stream TYPE_POINTER_TO and TYPE_REFERENCE_TO\n-\t lists, we may look types up in these lists and use them while\n-\t optimizing the function body.  Thus we need to free lang data\n-\t in them.  */\n-      if (TREE_CODE (t) == POINTER_TYPE)\n-        fld_worklist_push (TYPE_NEXT_PTR_TO (t), fld);\n-      if (TREE_CODE (t) == REFERENCE_TYPE)\n-        fld_worklist_push (TYPE_NEXT_REF_TO (t), fld);\n-      if (!POINTER_TYPE_P (t))\n-\tfld_worklist_push (TYPE_MIN_VALUE_RAW (t), fld);\n-      /* TYPE_MAX_VALUE_RAW is TYPE_BINFO for record types.  */\n-      if (!RECORD_OR_UNION_TYPE_P (t))\n-\tfld_worklist_push (TYPE_MAX_VALUE_RAW (t), fld);\n-      fld_worklist_push (TYPE_MAIN_VARIANT (t), fld);\n-      /* Do not walk TYPE_NEXT_VARIANT.  We do not stream it and thus\n-         do not and want not to reach unused variants this way.  */\n-      if (TYPE_CONTEXT (t))\n-\t{\n-\t  tree ctx = TYPE_CONTEXT (t);\n-\t  /* We adjust BLOCK TYPE_CONTEXTs to the innermost non-BLOCK one.\n-\t     So push that instead.  */\n-\t  while (ctx && TREE_CODE (ctx) == BLOCK)\n-\t    ctx = BLOCK_SUPERCONTEXT (ctx);\n-\t  fld_worklist_push (ctx, fld);\n-\t}\n-      fld_worklist_push (TYPE_CANONICAL (t), fld);\n-\n-      if (RECORD_OR_UNION_TYPE_P (t) && TYPE_BINFO (t))\n-\t{\n-\t  unsigned i;\n-\t  tree tem;\n-\t  FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (TYPE_BINFO (t)), i, tem)\n-\t    fld_worklist_push (TREE_TYPE (tem), fld);\n-\t  fld_worklist_push (BINFO_TYPE (TYPE_BINFO (t)), fld);\n-\t  fld_worklist_push (BINFO_VTABLE (TYPE_BINFO (t)), fld);\n-\t}\n-      if (RECORD_OR_UNION_TYPE_P (t))\n-\t{\n-\t  tree tem;\n-\t  /* Push all TYPE_FIELDS - there can be interleaving interesting\n-\t     and non-interesting things.  */\n-\t  tem = TYPE_FIELDS (t);\n-\t  while (tem)\n-\t    {\n-\t      if (TREE_CODE (tem) == FIELD_DECL)\n-\t\tfld_worklist_push (tem, fld);\n-\t      tem = TREE_CHAIN (tem);\n-\t    }\n-\t}\n-      if (FUNC_OR_METHOD_TYPE_P (t))\n-\tfld_worklist_push (TYPE_METHOD_BASETYPE (t), fld);\n-\n-      fld_worklist_push (TYPE_STUB_DECL (t), fld);\n-      *ws = 0;\n-    }\n-  else if (TREE_CODE (t) == BLOCK)\n-    {\n-      for (tree *tem = &BLOCK_VARS (t); *tem; )\n-\t{\n-\t  if (TREE_CODE (*tem) != LABEL_DECL\n-\t      && (TREE_CODE (*tem) != VAR_DECL\n-\t\t  || !auto_var_in_fn_p (*tem, DECL_CONTEXT (*tem))))\n-\t    {\n-\t      gcc_assert (TREE_CODE (*tem) != RESULT_DECL\n-\t\t\t  && TREE_CODE (*tem) != PARM_DECL);\n-\t      *tem = TREE_CHAIN (*tem);\n-\t    }\n-\t  else \n-\t    {\n-\t      fld_worklist_push (*tem, fld);\n-\t      tem = &TREE_CHAIN (*tem);\n-\t    }\n-\t}\n-      for (tree tem = BLOCK_SUBBLOCKS (t); tem; tem = BLOCK_CHAIN (tem))\n-\tfld_worklist_push (tem, fld);\n-      fld_worklist_push (BLOCK_ABSTRACT_ORIGIN (t), fld);\n-    }\n-\n-  if (TREE_CODE (t) != IDENTIFIER_NODE\n-      && CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_TYPED))\n-    fld_worklist_push (TREE_TYPE (t), fld);\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* Find decls and types in T.  */\n-\n-static void\n-find_decls_types (tree t, class free_lang_data_d *fld)\n-{\n-  while (1)\n-    {\n-      if (!fld->pset.contains (t))\n-\twalk_tree (&t, find_decls_types_r, fld, &fld->pset);\n-      if (fld->worklist.is_empty ())\n-\tbreak;\n-      t = fld->worklist.pop ();\n-    }\n-}\n-\n-/* Translate all the types in LIST with the corresponding runtime\n-   types.  */\n-\n-static tree\n-get_eh_types_for_runtime (tree list)\n-{\n-  tree head, prev;\n-\n-  if (list == NULL_TREE)\n-    return NULL_TREE;\n-\n-  head = build_tree_list (0, lookup_type_for_runtime (TREE_VALUE (list)));\n-  prev = head;\n-  list = TREE_CHAIN (list);\n-  while (list)\n-    {\n-      tree n = build_tree_list (0, lookup_type_for_runtime (TREE_VALUE (list)));\n-      TREE_CHAIN (prev) = n;\n-      prev = TREE_CHAIN (prev);\n-      list = TREE_CHAIN (list);\n-    }\n-\n-  return head;\n-}\n-\n-\n-/* Find decls and types referenced in EH region R and store them in\n-   FLD->DECLS and FLD->TYPES.  */\n-\n-static void\n-find_decls_types_in_eh_region (eh_region r, class free_lang_data_d *fld)\n-{\n-  switch (r->type)\n-    {\n-    case ERT_CLEANUP:\n-      break;\n-\n-    case ERT_TRY:\n-      {\n-\teh_catch c;\n-\n-\t/* The types referenced in each catch must first be changed to the\n-\t   EH types used at runtime.  This removes references to FE types\n-\t   in the region.  */\n-\tfor (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n-\t  {\n-\t    c->type_list = get_eh_types_for_runtime (c->type_list);\n-\t    walk_tree (&c->type_list, find_decls_types_r, fld, &fld->pset);\n-\t  }\n-      }\n-      break;\n-\n-    case ERT_ALLOWED_EXCEPTIONS:\n-      r->u.allowed.type_list\n-\t= get_eh_types_for_runtime (r->u.allowed.type_list);\n-      walk_tree (&r->u.allowed.type_list, find_decls_types_r, fld, &fld->pset);\n-      break;\n-\n-    case ERT_MUST_NOT_THROW:\n-      walk_tree (&r->u.must_not_throw.failure_decl,\n-\t\t find_decls_types_r, fld, &fld->pset);\n-      break;\n-    }\n-}\n-\n-\n-/* Find decls and types referenced in cgraph node N and store them in\n-   FLD->DECLS and FLD->TYPES.  Unlike pass_referenced_vars, this will\n-   look for *every* kind of DECL and TYPE node reachable from N,\n-   including those embedded inside types and decls (i.e,, TYPE_DECLs,\n-   NAMESPACE_DECLs, etc).  */\n-\n-static void\n-find_decls_types_in_node (struct cgraph_node *n, class free_lang_data_d *fld)\n-{\n-  basic_block bb;\n-  struct function *fn;\n-  unsigned ix;\n-  tree t;\n-\n-  find_decls_types (n->decl, fld);\n-\n-  if (!gimple_has_body_p (n->decl))\n-    return;\n-\n-  gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n-\n-  fn = DECL_STRUCT_FUNCTION (n->decl);\n-\n-  /* Traverse locals. */\n-  FOR_EACH_LOCAL_DECL (fn, ix, t)\n-    find_decls_types (t, fld);\n-\n-  /* Traverse EH regions in FN.  */\n-  {\n-    eh_region r;\n-    FOR_ALL_EH_REGION_FN (r, fn)\n-      find_decls_types_in_eh_region (r, fld);\n-  }\n-\n-  /* Traverse every statement in FN.  */\n-  FOR_EACH_BB_FN (bb, fn)\n-    {\n-      gphi_iterator psi;\n-      gimple_stmt_iterator si;\n-      unsigned i;\n-\n-      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-\t{\n-\t  gphi *phi = psi.phi ();\n-\n-\t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-\t    {\n-\t      tree *arg_p = gimple_phi_arg_def_ptr (phi, i);\n-\t      find_decls_types (*arg_p, fld);\n-\t    }\n-\t}\n-\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-\t{\n-\t  gimple *stmt = gsi_stmt (si);\n-\n-\t  if (is_gimple_call (stmt))\n-\t    find_decls_types (gimple_call_fntype (stmt), fld);\n-\n-\t  for (i = 0; i < gimple_num_ops (stmt); i++)\n-\t    {\n-\t      tree arg = gimple_op (stmt, i);\n-\t      find_decls_types (arg, fld);\n-\t      /* find_decls_types doesn't walk TREE_PURPOSE of TREE_LISTs,\n-\t\t which we need for asm stmts.  */\n-\t      if (arg\n-\t\t  && TREE_CODE (arg) == TREE_LIST\n-\t\t  && TREE_PURPOSE (arg)\n-\t\t  && gimple_code (stmt) == GIMPLE_ASM)\n-\t\tfind_decls_types (TREE_PURPOSE (arg), fld);\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-/* Find decls and types referenced in varpool node N and store them in\n-   FLD->DECLS and FLD->TYPES.  Unlike pass_referenced_vars, this will\n-   look for *every* kind of DECL and TYPE node reachable from N,\n-   including those embedded inside types and decls (i.e,, TYPE_DECLs,\n-   NAMESPACE_DECLs, etc).  */\n-\n-static void\n-find_decls_types_in_var (varpool_node *v, class free_lang_data_d *fld)\n-{\n-  find_decls_types (v->decl, fld);\n-}\n-\n-/* If T needs an assembler name, have one created for it.  */\n-\n-void\n-assign_assembler_name_if_needed (tree t)\n-{\n-  if (need_assembler_name_p (t))\n-    {\n-      /* When setting DECL_ASSEMBLER_NAME, the C++ mangler may emit\n-\t diagnostics that use input_location to show locus\n-\t information.  The problem here is that, at this point,\n-\t input_location is generally anchored to the end of the file\n-\t (since the parser is long gone), so we don't have a good\n-\t position to pin it to.\n-\n-\t To alleviate this problem, this uses the location of T's\n-\t declaration.  Examples of this are\n-\t testsuite/g++.dg/template/cond2.C and\n-\t testsuite/g++.dg/template/pr35240.C.  */\n-      location_t saved_location = input_location;\n-      input_location = DECL_SOURCE_LOCATION (t);\n-\n-      decl_assembler_name (t);\n-\n-      input_location = saved_location;\n-    }\n-}\n-\n-\n-/* Free language specific information for every operand and expression\n-   in every node of the call graph.  This process operates in three stages:\n-\n-   1- Every callgraph node and varpool node is traversed looking for\n-      decls and types embedded in them.  This is a more exhaustive\n-      search than that done by find_referenced_vars, because it will\n-      also collect individual fields, decls embedded in types, etc.\n-\n-   2- All the decls found are sent to free_lang_data_in_decl.\n-\n-   3- All the types found are sent to free_lang_data_in_type.\n-\n-   The ordering between decls and types is important because\n-   free_lang_data_in_decl sets assembler names, which includes\n-   mangling.  So types cannot be freed up until assembler names have\n-   been set up.  */\n-\n-static void\n-free_lang_data_in_cgraph (class free_lang_data_d *fld)\n-{\n-  struct cgraph_node *n;\n-  varpool_node *v;\n-  tree t;\n-  unsigned i;\n-  alias_pair *p;\n-\n-  /* Find decls and types in the body of every function in the callgraph.  */\n-  FOR_EACH_FUNCTION (n)\n-    find_decls_types_in_node (n, fld);\n-\n-  FOR_EACH_VEC_SAFE_ELT (alias_pairs, i, p)\n-    find_decls_types (p->decl, fld);\n-\n-  /* Find decls and types in every varpool symbol.  */\n-  FOR_EACH_VARIABLE (v)\n-    find_decls_types_in_var (v, fld);\n-\n-  /* Set the assembler name on every decl found.  We need to do this\n-     now because free_lang_data_in_decl will invalidate data needed\n-     for mangling.  This breaks mangling on interdependent decls.  */\n-  FOR_EACH_VEC_ELT (fld->decls, i, t)\n-    assign_assembler_name_if_needed (t);\n-\n-  /* Traverse every decl found freeing its language data.  */\n-  FOR_EACH_VEC_ELT (fld->decls, i, t)\n-    free_lang_data_in_decl (t, fld);\n-\n-  /* Traverse every type found freeing its language data.  */\n-  FOR_EACH_VEC_ELT (fld->types, i, t)\n-    free_lang_data_in_type (t, fld);\n-}\n-\n-\n-/* Free resources that are used by FE but are not needed once they are done. */\n-\n-static unsigned\n-free_lang_data (void)\n-{\n-  unsigned i;\n-  class free_lang_data_d fld;\n-\n-  /* If we are the LTO frontend we have freed lang-specific data already.  */\n-  if (in_lto_p\n-      || (!flag_generate_lto && !flag_generate_offload))\n-    {\n-      /* Rebuild type inheritance graph even when not doing LTO to get\n-\t consistent profile data.  */\n-      rebuild_type_inheritance_graph ();\n-      return 0;\n-    }\n-\n-  fld_incomplete_types = new hash_map<tree, tree>;\n-  fld_simplified_types = new hash_map<tree, tree>;\n-\n-  /* Provide a dummy TRANSLATION_UNIT_DECL if the FE failed to provide one.  */\n-  if (vec_safe_is_empty (all_translation_units))\n-    build_translation_unit_decl (NULL_TREE);\n-\n-  /* Allocate and assign alias sets to the standard integer types\n-     while the slots are still in the way the frontends generated them.  */\n-  for (i = 0; i < itk_none; ++i)\n-    if (integer_types[i])\n-      TYPE_ALIAS_SET (integer_types[i]) = get_alias_set (integer_types[i]);\n-\n-  /* Traverse the IL resetting language specific information for\n-     operands, expressions, etc.  */\n-  free_lang_data_in_cgraph (&fld);\n-\n-  /* Create gimple variants for common types.  */\n-  for (unsigned i = 0;\n-       i < sizeof (builtin_structptr_types) / sizeof (builtin_structptr_type);\n-       ++i)\n-    builtin_structptr_types[i].node = builtin_structptr_types[i].base;\n-\n-  /* Reset some langhooks.  Do not reset types_compatible_p, it may\n-     still be used indirectly via the get_alias_set langhook.  */\n-  lang_hooks.dwarf_name = lhd_dwarf_name;\n-  lang_hooks.decl_printable_name = gimple_decl_printable_name;\n-  lang_hooks.gimplify_expr = lhd_gimplify_expr;\n-  lang_hooks.overwrite_decl_assembler_name = lhd_overwrite_decl_assembler_name;\n-  lang_hooks.print_xnode = lhd_print_tree_nothing;\n-  lang_hooks.print_decl = lhd_print_tree_nothing;\n-  lang_hooks.print_type = lhd_print_tree_nothing;\n-  lang_hooks.print_identifier = lhd_print_tree_nothing;\n-\n-  lang_hooks.tree_inlining.var_mod_type_p = hook_bool_tree_tree_false;\n-\n-  if (flag_checking)\n-    {\n-      int i;\n-      tree t;\n-\n-      FOR_EACH_VEC_ELT (fld.types, i, t)\n-\tverify_type (t);\n-    }\n-\n-  /* We do not want the default decl_assembler_name implementation,\n-     rather if we have fixed everything we want a wrapper around it\n-     asserting that all non-local symbols already got their assembler\n-     name and only produce assembler names for local symbols.  Or rather\n-     make sure we never call decl_assembler_name on local symbols and\n-     devise a separate, middle-end private scheme for it.  */\n-\n-  /* Reset diagnostic machinery.  */\n-  tree_diagnostics_defaults (global_dc);\n-\n-  rebuild_type_inheritance_graph ();\n-\n-  delete fld_incomplete_types;\n-  delete fld_simplified_types;\n-\n-  return 0;\n-}\n-\n-\n-namespace {\n-\n-const pass_data pass_data_ipa_free_lang_data =\n-{\n-  SIMPLE_IPA_PASS, /* type */\n-  \"*free_lang_data\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_IPA_FREE_LANG_DATA, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_ipa_free_lang_data : public simple_ipa_opt_pass\n-{\n-public:\n-  pass_ipa_free_lang_data (gcc::context *ctxt)\n-    : simple_ipa_opt_pass (pass_data_ipa_free_lang_data, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual unsigned int execute (function *) { return free_lang_data (); }\n-\n-}; // class pass_ipa_free_lang_data\n-\n-} // anon namespace\n-\n-simple_ipa_opt_pass *\n-make_pass_ipa_free_lang_data (gcc::context *ctxt)\n-{\n-  return new pass_ipa_free_lang_data (ctxt);\n-}\n-\f\n-/* Set the type qualifiers for TYPE to TYPE_QUALS, which is a bitmask\n-   of the various TYPE_QUAL values.  */\n-\n-static void\n-set_type_quals (tree type, int type_quals)\n-{\n-  TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;\n-  TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n-  TYPE_RESTRICT (type) = (type_quals & TYPE_QUAL_RESTRICT) != 0;\n-  TYPE_ATOMIC (type) = (type_quals & TYPE_QUAL_ATOMIC) != 0;\n-  TYPE_ADDR_SPACE (type) = DECODE_QUAL_ADDR_SPACE (type_quals);\n-}\n-\n-/* Returns true iff CAND and BASE have equivalent language-specific\n-   qualifiers.  */\n-\n-bool\n-check_lang_type (const_tree cand, const_tree base)\n-{\n-  if (lang_hooks.types.type_hash_eq == NULL)\n-    return true;\n-  /* type_hash_eq currently only applies to these types.  */\n-  if (TREE_CODE (cand) != FUNCTION_TYPE\n-      && TREE_CODE (cand) != METHOD_TYPE)\n-    return true;\n-  return lang_hooks.types.type_hash_eq (cand, base);\n-}\n-\n-/* This function checks to see if TYPE matches the size one of the built-in \n-   atomic types, and returns that core atomic type.  */\n-\n-static tree\n-find_atomic_core_type (const_tree type)\n-{\n-  tree base_atomic_type;\n-\n-  /* Only handle complete types.  */\n-  if (!tree_fits_uhwi_p (TYPE_SIZE (type)))\n-    return NULL_TREE;\n-\n-  switch (tree_to_uhwi (TYPE_SIZE (type)))\n-    {\n-    case 8:\n-      base_atomic_type = atomicQI_type_node;\n-      break;\n-\n-    case 16:\n-      base_atomic_type = atomicHI_type_node;\n-      break;\n-\n-    case 32:\n-      base_atomic_type = atomicSI_type_node;\n-      break;\n-\n-    case 64:\n-      base_atomic_type = atomicDI_type_node;\n-      break;\n-\n-    case 128:\n-      base_atomic_type = atomicTI_type_node;\n-      break;\n-\n-    default:\n-      base_atomic_type = NULL_TREE;\n-    }\n-\n-  return base_atomic_type;\n-}\n-\n-/* Returns true iff unqualified CAND and BASE are equivalent.  */\n-\n-bool\n-check_base_type (const_tree cand, const_tree base)\n-{\n-  if (TYPE_NAME (cand) != TYPE_NAME (base)\n-      /* Apparently this is needed for Objective-C.  */\n-      || TYPE_CONTEXT (cand) != TYPE_CONTEXT (base)\n-      || !attribute_list_equal (TYPE_ATTRIBUTES (cand),\n-\t\t\t        TYPE_ATTRIBUTES (base)))\n-    return false;\n-  /* Check alignment.  */\n-  if (TYPE_ALIGN (cand) == TYPE_ALIGN (base)\n-      && TYPE_USER_ALIGN (cand) == TYPE_USER_ALIGN (base))\n-    return true;\n-  /* Atomic types increase minimal alignment.  We must to do so as well\n-     or we get duplicated canonical types. See PR88686.  */\n-  if ((TYPE_QUALS (cand) & TYPE_QUAL_ATOMIC))\n-    {\n-      /* See if this object can map to a basic atomic type.  */\n-      tree atomic_type = find_atomic_core_type (cand);\n-      if (atomic_type && TYPE_ALIGN (atomic_type) == TYPE_ALIGN (cand))\n-       return true;\n-    }\n-  return false;\n-}\n-\n-/* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */\n-\n-bool\n-check_qualified_type (const_tree cand, const_tree base, int type_quals)\n-{\n-  return (TYPE_QUALS (cand) == type_quals\n-\t  && check_base_type (cand, base)\n-\t  && check_lang_type (cand, base));\n-}\n-\n-/* Returns true iff CAND is equivalent to BASE with ALIGN.  */\n-\n-static bool\n-check_aligned_type (const_tree cand, const_tree base, unsigned int align)\n+static bool\n+check_aligned_type (const_tree cand, const_tree base, unsigned int align)\n {\n   return (TYPE_QUALS (cand) == TYPE_QUALS (base)\n \t  && TYPE_NAME (cand) == TYPE_NAME (base)\n@@ -8263,7 +7119,7 @@ subrange_type_for_debug_p (const_tree type, tree *lowval, tree *highval)\n    If SHARED is true, reuse such a type that has already been constructed.\n    If SET_CANONICAL is true, compute TYPE_CANONICAL from the element type.  */\n \n-static tree\n+tree\n build_array_type_1 (tree elt_type, tree index_type, bool typeless_storage,\n \t\t    bool shared, bool set_canonical)\n {"}, {"sha": "5a609b98b4c650e08c935cec1e01dac95354f210", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7c792569d7a227426aaeb124686a856614da7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7c792569d7a227426aaeb124686a856614da7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2de7c792569d7a227426aaeb124686a856614da7", "patch": "@@ -4528,6 +4528,7 @@ extern tree build_vector_type (tree, poly_int64);\n extern tree build_truth_vector_type_for_mode (poly_uint64, machine_mode);\n extern tree build_opaque_vector_type (tree, poly_int64);\n extern tree build_index_type (tree);\n+extern tree build_array_type_1 (tree, tree, bool, bool, bool);\n extern tree build_array_type (tree, tree, bool = false);\n extern tree build_nonshared_array_type (tree, tree);\n extern tree build_array_type_nelts (tree, poly_uint64);"}]}