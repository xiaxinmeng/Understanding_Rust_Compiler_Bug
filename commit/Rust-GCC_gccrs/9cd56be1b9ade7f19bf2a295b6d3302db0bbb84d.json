{"sha": "9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNkNTZiZTFiOWFkZTdmMTliZjJhMjk1YjZkMzMwMmRiMGJiYjg0ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-12-03T15:22:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-03T15:22:47Z"}, "message": "gcse.c (delete_null_pointer_checks_1): Do not use delelete_list; call purge_dead_edges after removing.\n\n\t* gcse.c (delete_null_pointer_checks_1): Do not use delelete_list;\n\tcall purge_dead_edges after removing.\n\t(delete_null_pointer_checks): Do not handle delete_list.\n\n\t* cfgbuild.c (inside_basic_block_p, control_flow_insn_p): Break out from ...\n\t(count_basic_blocks): ... here.\n\t(find_basic_blocks, find_bb_boundaries): Cleanup.\n\n\t* stor-layout.c (fixup_signed_type, fixup_unsigned_type): Avoid\n\toverflow for types greater then 2 * HOST_WIDE_INT.\n\n\t* reload.c (find_reloads): Update the duplicates after swapingg.\n\nFrom-SVN: r47551", "tree": {"sha": "f50e6822ef00b12e31e63af407c46260d2f638b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f50e6822ef00b12e31e63af407c46260d2f638b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/comments", "author": null, "committer": null, "parents": [{"sha": "63658a9aaa0e8e7a16548f505c4c6ebd21a56c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63658a9aaa0e8e7a16548f505c4c6ebd21a56c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63658a9aaa0e8e7a16548f505c4c6ebd21a56c1d"}], "stats": {"total": 382, "additions": 190, "deletions": 192}, "files": [{"sha": "7e87c7589d2c18547d86fc90f92929f024c25e05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "patch": "@@ -1,3 +1,18 @@\n+Mon Dec  3 16:16:37 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcse.c (delete_null_pointer_checks_1): Do not use delelete_list;\n+\tcall purge_dead_edges after removing.\n+\t(delete_null_pointer_checks): Do not handle delete_list.\n+\n+\t* cfgbuild.c (inside_basic_block_p, control_flow_insn_p): Break out from ...\n+\t(count_basic_blocks): ... here.\n+\t(find_basic_blocks, find_bb_boundaries): Cleanup.\n+\n+\t* stor-layout.c (fixup_signed_type, fixup_unsigned_type): Avoid\n+\toverflow for types greater then 2 * HOST_WIDE_INT.\n+\n+\t* reload.c (find_reloads): Update the duplicates after swapingg.\n+\n Mon Dec  3 13:52:19 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (movabsqi*): Use 'b' prefix instead of 'q'."}, {"sha": "d96911f2f9c1f0b3a2358ccaf0a2a546a41ed72a", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 145, "deletions": 174, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "patch": "@@ -57,56 +57,120 @@ static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n static void find_bb_boundaries\t\tPARAMS ((basic_block));\n static void compute_outgoing_frequencies PARAMS ((basic_block));\n+static bool inside_basic_block_p\tPARAMS ((rtx));\n+static bool control_flow_insn_p\t\tPARAMS ((rtx));\n+\n+/* Return true if insn is something that should be contained inside basic\n+   block.  */\n+\n+static bool\n+inside_basic_block_p (insn)\n+     rtx insn;\n+{\n+  switch (GET_CODE (insn))\n+    {\n+    case CODE_LABEL:\n+      /* Avoid creating of basic block for jumptables.  */\n+      if (NEXT_INSN (insn)\n+\t  && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t  && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n+\t      || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+\treturn false;\n+      return true;\n+\n+    case JUMP_INSN:\n+      if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+\treturn false;\n+      return true;\n+\n+    case CALL_INSN:\n+    case INSN:\n+      return true;\n+\n+    case BARRIER:\n+    case NOTE:\n+      return false;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Return true if INSN may cause control flow transfer, so \n+   it should be last in the basic block.  */\n+\n+static bool\n+control_flow_insn_p (insn)\n+     rtx insn;\n+{\n+  rtx note;\n+  switch (GET_CODE (insn))\n+    {\n+      case NOTE:\n+      case CODE_LABEL:\n+\treturn false;\n+\n+      case JUMP_INSN:\n+\t/* Jump insn always causes control transfer except for tablejumps.  */\n+\tif (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t    || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+\t  return false;\n+\treturn true;\n+\n+      case CALL_INSN:\n+\t/* Call insn may return to the nonlocal goto handler.  */\n+\tif (nonlocal_goto_handler_labels\n+\t    && ((note = find_reg_note (insn, REG_EH_REGION, NULL_RTX)) == 0\n+\t\t|| INTVAL (XEXP (note, 0)) >= 0))\n+\t  return true;\n+\t/* Or may trap.  */\n+\treturn can_throw_internal (insn);\n+\n+      case INSN:\n+\treturn (flag_non_call_exceptions\n+\t\t&& can_throw_internal (insn));\n+\n+      case BARRIER:\n+\t/* It is nonsence to reach barrier when looking for the\n+\t   end of basic block, but before dead code is elliminated\n+\t   this may happen.  */\n+\treturn false;\n+\n+      default:\n+\tabort ();\n+    }\n+}\n \n /* Count the basic blocks of the function.  */\n \n static int\n count_basic_blocks (f)\n      rtx f;\n {\n-  rtx insn;\n-  RTX_CODE prev_code;\n   int count = 0;\n-  int saw_abnormal_edge = 0;\n+  bool saw_insn = false;\n+  rtx insn;\n \n-  prev_code = JUMP_INSN;\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n-      enum rtx_code code = GET_CODE (insn);\n-\n-      if (code == CODE_LABEL\n-\t  || (GET_RTX_CLASS (code) == 'i'\n-\t      && (prev_code == JUMP_INSN\n-\t\t  || prev_code == BARRIER\n-\t\t  || saw_abnormal_edge)))\n-\t{\n-\t  saw_abnormal_edge = 0;\n-\t  count++;\n-\t}\n-\n-      /* Record whether this insn created an edge.  */\n-      if (code == CALL_INSN)\n-\t{\n-\t  rtx note;\n+      /* Code labels and barriers causes curent basic block to be\n+         terminated at previous real insn.  */\n \n-\t  /* If there is a nonlocal goto label and the specified\n-\t     region number isn't -1, we have an edge.  */\n-\t  if (nonlocal_goto_handler_labels\n-\t      && ((note = find_reg_note (insn, REG_EH_REGION, NULL_RTX)) == 0\n-\t\t  || INTVAL (XEXP (note, 0)) >= 0))\n-\t    saw_abnormal_edge = 1;\n+      if ((GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == BARRIER)\n+\t  && saw_insn)\n+\tcount++, saw_insn = false;\n \n-\t  else if (can_throw_internal (insn))\n-\t    saw_abnormal_edge = 1;\n-\t}\n-      else if (flag_non_call_exceptions\n-\t       && code == INSN\n-\t       && can_throw_internal (insn))\n-\tsaw_abnormal_edge = 1;\n+      /* Start basic block if needed.  */\n+      if (!saw_insn && inside_basic_block_p (insn))\n+\tsaw_insn = true;\n \n-      if (code != NOTE)\n-\tprev_code = code;\n+      /* Control flow insn causes current basic block to be terminated.  */\n+      if (saw_insn && control_flow_insn_p (insn))\n+\tcount++, saw_insn = false;\n     }\n+  if (saw_insn)\n+    count++;\n \n   /* The rest of the compiler works a bit smoother when we don't have to\n      check for the edge case of do-nothing functions with no basic blocks.  */\n@@ -430,6 +494,26 @@ find_basic_blocks_1 (f)\n \n       next = NEXT_INSN (insn);\n \n+      if ((GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == BARRIER)\n+\t  && head)\n+\t{\n+\t  create_basic_block_structure (i++, head, end, bb_note);\n+\t  head = end = NULL_RTX;\n+\t  bb_note = NULL_RTX;\n+\t}\n+      if (inside_basic_block_p (insn))\n+\t{\n+\t  if (head == NULL_RTX)\n+\t    head = insn;\n+\t  end = insn;\n+\t}\n+      if (head && control_flow_insn_p (insn))\n+\t{\n+\t  create_basic_block_structure (i++, head, end, bb_note);\n+\t  head = end = NULL_RTX;\n+\t  bb_note = NULL_RTX;\n+\t}\n+\n       switch (code)\n \t{\n \tcase NOTE:\n@@ -451,97 +535,22 @@ find_basic_blocks_1 (f)\n \t  }\n \n \tcase CODE_LABEL:\n-\t  /* A basic block starts at a label.  If we've closed one off due\n-\t     to a barrier or some such, no need to do it again.  */\n-\t  if (head != NULL_RTX)\n-\t    {\n-\t      create_basic_block_structure (i++, head, end, bb_note);\n-\t      bb_note = NULL_RTX;\n-\t    }\n-\n-\t  head = end = insn;\n-\t  break;\n-\n \tcase JUMP_INSN:\n-\t  /* A basic block ends at a jump.  */\n-\t  if (head == NULL_RTX)\n-\t    head = insn;\n-\t  else\n-\t    {\n-\t      /* ??? Make a special check for table jumps.  The way this\n-\t\t happens is truly and amazingly gross.  We are about to\n-\t\t create a basic block that contains just a code label and\n-\t\t an addr*vec jump insn.  Worse, an addr_diff_vec creates\n-\t\t its own natural loop.\n-\n-\t\t Prevent this bit of brain damage, pasting things together\n-\t\t correctly in make_edges.\n-\n-\t\t The correct solution involves emitting the table directly\n-\t\t on the tablejump instruction as a note, or JUMP_LABEL.  */\n-\n-\t      if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t\t{\n-\t\t  head = end = NULL;\n-\t\t  n_basic_blocks--;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  end = insn;\n-\t  goto new_bb_inclusive;\n-\n+\tcase INSN:\n \tcase BARRIER:\n-\t  /* A basic block ends at a barrier.  It may be that an unconditional\n-\t     jump already closed the basic block -- no need to do it again.  */\n-\t  if (head == NULL_RTX)\n-\t    break;\n-\t  goto new_bb_exclusive;\n+\t  break;\n \n \tcase CALL_INSN:\n-\t  {\n-\t    /* Record whether this call created an edge.  */\n-\t    rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t    int region = (note ? INTVAL (XEXP (note, 0)) : 0);\n-\n-\t    if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t      {\n-\t\t/* Scan each of the alternatives for label refs.  */\n-\t\tlvl = find_label_refs (XEXP (PATTERN (insn), 0), lvl);\n-\t\tlvl = find_label_refs (XEXP (PATTERN (insn), 1), lvl);\n-\t\tlvl = find_label_refs (XEXP (PATTERN (insn), 2), lvl);\n-\t\t/* Record its tail recursion label, if any.  */\n-\t\tif (XEXP (PATTERN (insn), 3) != NULL_RTX)\n-\t\t  trll = alloc_EXPR_LIST (0, XEXP (PATTERN (insn), 3), trll);\n-\t      }\n-\n-\t    /* A basic block ends at a call that can either throw or\n-\t       do a non-local goto.  */\n-\t    if ((nonlocal_goto_handler_labels && region >= 0)\n-\t\t|| can_throw_internal (insn))\n-\t      {\n-\t      new_bb_inclusive:\n-\t\tif (head == NULL_RTX)\n-\t\t  head = insn;\n-\t\tend = insn;\n-\n-\t      new_bb_exclusive:\n-\t\tcreate_basic_block_structure (i++, head, end, bb_note);\n-\t\thead = end = NULL_RTX;\n-\t\tbb_note = NULL_RTX;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\t  /* Fall through.  */\n-\n-\tcase INSN:\n-\t  /* Non-call exceptions generate new blocks just like calls.  */\n-\t  if (flag_non_call_exceptions && can_throw_internal (insn))\n-\t    goto new_bb_inclusive;\n-\n-\t  if (head == NULL_RTX)\n-\t    head = insn;\n-\t  end = insn;\n+\t  if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n+\t    {\n+\t      /* Scan each of the alternatives for label refs.  */\n+\t      lvl = find_label_refs (XEXP (PATTERN (insn), 0), lvl);\n+\t      lvl = find_label_refs (XEXP (PATTERN (insn), 1), lvl);\n+\t      lvl = find_label_refs (XEXP (PATTERN (insn), 2), lvl);\n+\t      /* Record its tail recursion label, if any.  */\n+\t      if (XEXP (PATTERN (insn), 3) != NULL_RTX)\n+\t\ttrll = alloc_EXPR_LIST (0, XEXP (PATTERN (insn), 3), trll);\n+\t    }\n \t  break;\n \n \tdefault:\n@@ -699,15 +708,9 @@ find_bb_boundaries (bb)\n     {\n       enum rtx_code code = GET_CODE (insn);\n \n-      switch (code)\n+      /* On code label, split current basic block.  */\n+      if (code == CODE_LABEL)\n \t{\n-\tcase BARRIER:\n-\t  if (!flow_transfer_insn)\n-\t    abort ();\n-\t  break;\n-\n-\t  /* On code label, split current basic block.  */\n-\tcase CODE_LABEL:\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n \t  if (flow_transfer_insn)\n \t    bb->end = flow_transfer_insn;\n@@ -716,51 +719,19 @@ find_bb_boundaries (bb)\n \t  flow_transfer_insn = NULL_RTX;\n \t  if (LABEL_ALTERNATE_NAME (insn))\n \t    make_edge (ENTRY_BLOCK_PTR, bb, 0);\n-\t  break;\n-\n-\tcase INSN:\n-\tcase JUMP_INSN:\n-\tcase CALL_INSN:\n-\t  /* In case we've previously split an insn that effects a control\n-\t     flow transfer, move the block header to proper place.  */\n-\t  if (flow_transfer_insn)\n-\t    {\n-\t      fallthru = split_block (bb, PREV_INSN (insn));\n-\t      bb->end = flow_transfer_insn;\n-\t      bb = fallthru->dest;\n-\t      remove_edge (fallthru);\n-\t      flow_transfer_insn = NULL_RTX;\n-\t    }\n-\n-\t  /* We need some special care for those expressions.  */\n-\t  if (code == JUMP_INSN)\n-\t    {\n-\t      if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t\tabort ();\n-\t      flow_transfer_insn = insn;\n-\t    }\n-\t  else if (code == CALL_INSN)\n-\t    {\n-\t      rtx note;\n-\t      if (nonlocal_goto_handler_labels\n-\t\t  && (!(note = find_reg_note (insn, REG_EH_REGION, NULL_RTX))\n-\t\t      || INTVAL (XEXP (note, 0)) >= 0))\n-\t\tflow_transfer_insn = insn;\n-\t      else if (can_throw_internal (insn))\n-\t\tflow_transfer_insn = insn;\n-\t      else if (SIBLING_CALL_P (insn))\n-\t\tflow_transfer_insn = insn;\n-\t      else if (find_reg_note (insn, REG_NORETURN, 0))\n-\t\tflow_transfer_insn = insn;\n-\t    }\n-\t  else if (flag_non_call_exceptions && can_throw_internal (insn))\n-\t    flow_transfer_insn = insn;\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n \t}\n+      /* In case we've previously seen an insn that effects a control\n+\t flow transfer, split the block.  */\n+      if (flow_transfer_insn && inside_basic_block_p (insn))\n+\t{\n+\t  fallthru = split_block (bb, PREV_INSN (insn));\n+\t  bb->end = flow_transfer_insn;\n+\t  bb = fallthru->dest;\n+\t  remove_edge (fallthru);\n+\t  flow_transfer_insn = NULL_RTX;\n+\t}\n+      if (control_flow_insn_p (insn))\n+\tflow_transfer_insn = insn;\n       if (insn == end)\n \tbreak;\n       insn = NEXT_INSN (insn);"}, {"sha": "e6cc5132606b41c62cbacc6d6760aca6b8165d8e", "filename": "gcc/gcse.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "patch": "@@ -656,7 +656,7 @@ static int handle_avail_expr\tPARAMS ((rtx, struct expr *));\n static int classic_gcse\t\tPARAMS ((void));\n static int one_classic_gcse_pass PARAMS ((int));\n static void invalidate_nonnull_info PARAMS ((rtx, rtx, void *));\n-static void delete_null_pointer_checks_1 PARAMS ((varray_type *, unsigned int *,\n+static void delete_null_pointer_checks_1 PARAMS ((unsigned int *,\n \t\t\t\t\t\t  sbitmap *, sbitmap *,\n \t\t\t\t\t\t  struct null_pointer_info *));\n static rtx process_insert_insn\tPARAMS ((struct expr *));\n@@ -5194,9 +5194,8 @@ invalidate_nonnull_info (x, setter, data)\n    they are not our responsibility to free.  */\n \n static void\n-delete_null_pointer_checks_1 (delete_list, block_reg, nonnull_avin,\n+delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t\t\t      nonnull_avout, npi)\n-     varray_type *delete_list;\n      unsigned int *block_reg;\n      sbitmap *nonnull_avin;\n      sbitmap *nonnull_avout;\n@@ -5326,12 +5325,11 @@ delete_null_pointer_checks_1 (delete_list, block_reg, nonnull_avin,\n \t  LABEL_NUSES (JUMP_LABEL (new_jump))++;\n \t  emit_barrier_after (new_jump);\n \t}\n-      if (!*delete_list)\n-\tVARRAY_RTX_INIT (*delete_list, 10, \"delete_list\");\n \n-      VARRAY_PUSH_RTX (*delete_list, last_insn);\n+      delete_insn (last_insn);\n       if (compare_and_branch == 2)\n-\tVARRAY_PUSH_RTX (*delete_list, earliest);\n+        delete_insn (earliest);\n+      purge_dead_edges (BASIC_BLOCK (bb));\n \n       /* Don't check this block again.  (Note that BLOCK_END is\n \t invalid here; we deleted the last instruction in the \n@@ -5370,12 +5368,10 @@ delete_null_pointer_checks (f)\n {\n   sbitmap *nonnull_avin, *nonnull_avout;\n   unsigned int *block_reg;\n-  varray_type delete_list = NULL;\n   int bb;\n   int reg;\n   int regs_per_pass;\n   int max_reg;\n-  unsigned int i;\n   struct null_pointer_info npi;\n \n   /* If we have only a single block, then there's nothing to do.  */\n@@ -5444,18 +5440,10 @@ delete_null_pointer_checks (f)\n     {\n       npi.min_reg = reg;\n       npi.max_reg = MIN (reg + regs_per_pass, max_reg);\n-      delete_null_pointer_checks_1 (&delete_list, block_reg, nonnull_avin,\n+      delete_null_pointer_checks_1 (block_reg, nonnull_avin,\n \t\t\t\t    nonnull_avout, &npi);\n     }\n \n-  /* Now delete the instructions all at once.  This breaks the CFG.  */\n-  if (delete_list)\n-    {\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (delete_list); i++)\n-\tdelete_related_insns (VARRAY_RTX (delete_list, i));\n-      VARRAY_FREE (delete_list);\n-    }\n-\n   /* Free the table of registers compared at the end of every block.  */\n   free (block_reg);\n "}, {"sha": "e8adcfafac904e5fbbe34f0b6619426aaf50d4fa", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "patch": "@@ -3510,6 +3510,12 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t  recog_data.operand[commutative] = substed_operand[commutative + 1];\n \t  recog_data.operand[commutative + 1] = substed_operand[commutative];\n+\t  /* Swap the duplicates too.  */\n+\t  for (i = 0; i < recog_data.n_dups; i++)\n+\t    if (recog_data.dup_num[i] == commutative\n+\t\t|| recog_data.dup_num[i] == commutative + 1)\n+\t      *recog_data.dup_loc[i]\n+\t\t = recog_data.operand[(int) recog_data.dup_num[i]];\n \n \t  tclass = preferred_class[commutative];\n \t  preferred_class[commutative] = preferred_class[commutative + 1];\n@@ -3528,6 +3534,12 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  recog_data.operand[commutative] = substed_operand[commutative];\n \t  recog_data.operand[commutative + 1]\n \t    = substed_operand[commutative + 1];\n+\t  /* Unswap the duplicates too.  */\n+\t  for (i = 0; i < recog_data.n_dups; i++)\n+\t    if (recog_data.dup_num[i] == commutative\n+\t\t|| recog_data.dup_num[i] == commutative + 1)\n+\t      *recog_data.dup_loc[i]\n+\t\t = recog_data.operand[(int) recog_data.dup_num[i]];\n \t}\n     }\n "}, {"sha": "a3d122f050042168c987402695db4f32c7d60dda", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9cd56be1b9ade7f19bf2a295b6d3302db0bbb84d", "patch": "@@ -1755,6 +1755,12 @@ fixup_signed_type (type)\n {\n   int precision = TYPE_PRECISION (type);\n \n+  /* We can not represent properly constants greater then\n+     2 * HOST_BITS_PER_WIDE_INT, still we need the types\n+     as they are used by i386 vector extensions and friends.  */\n+  if (precision > HOST_BITS_PER_WIDE_INT * 2)\n+    precision = HOST_BITS_PER_WIDE_INT * 2;\n+\n   TYPE_MIN_VALUE (type)\n     = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n \t\t    ? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n@@ -1787,6 +1793,12 @@ fixup_unsigned_type (type)\n {\n   int precision = TYPE_PRECISION (type);\n \n+  /* We can not represent properly constants greater then\n+     2 * HOST_BITS_PER_WIDE_INT, still we need the types\n+     as they are used by i386 vector extensions and friends.  */\n+  if (precision > HOST_BITS_PER_WIDE_INT * 2)\n+    precision = HOST_BITS_PER_WIDE_INT * 2;\n+\n   TYPE_MIN_VALUE (type) = build_int_2 (0, 0);\n   TYPE_MAX_VALUE (type)\n     = build_int_2 (precision - HOST_BITS_PER_WIDE_INT >= 0"}]}