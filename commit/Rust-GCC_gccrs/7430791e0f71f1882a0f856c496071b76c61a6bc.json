{"sha": "7430791e0f71f1882a0f856c496071b76c61a6bc", "node_id": "C_kwDOANBUbNoAKDc0MzA3OTFlMGY3MWYxODgyYTBmODU2YzQ5NjA3MWI3NmM2MWE2YmM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-12T14:32:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-12T14:32:53Z"}, "message": "Merge #1082\n\n1082: Add base for privacy visitor r=CohenArthur a=CohenArthur\n\nThis PR is extremely early and implements some building blocks for privacy visitors. I'd like to get some feedback on the architecture and, if satisfactory, merge this first \"visitor\" which only takes care of visiting HIR struct definitions, to make reviewing easier. We could also merge it to a different branch for now, in order to not add an incomplete pass to the compiler.\r\n\r\nThanks!\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "4c285160c182b314feafef54912e80b2e7e9750f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c285160c182b314feafef54912e80b2e7e9750f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7430791e0f71f1882a0f856c496071b76c61a6bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVY2VCRBK7hj4Ov3rIwAAnt8IACpQrb9YB/8PiG3aW2w0Do2C\nWf6bkoqC1+Or8PfNfqN6REENYhEfmaC0IN41eAUWwxpen94G4qwTpFX20gkOEemT\n70hU89+rweMvtgRoIW2etKcpk/kCyd9O9u1FL49r1WF1lehHXoiPwqAIAiXiJj5W\nIXB3ndBeJAr0dgNrPUwsSULakv4tB2hCBeTCt2EIMqHQMUZoQOnHO6BFVBxiZ78Y\nDXoTkX97C273POQ2jo6iijG1rXrtKA1tUH2rgFsYiQ1SaVwPGpDXDqtOBMjNU23b\nwm62K1LlPAMY6oxu3GrrRabwNUDT809xl6sL8Qneckeq8X4mZqYwxEpLoQSxXbA=\n=k6EG\n-----END PGP SIGNATURE-----\n", "payload": "tree 4c285160c182b314feafef54912e80b2e7e9750f\nparent 2076e69bf92fae8efb0ee11a205a69ad8b4854a8\nparent 1e5126022d8db1adaa925a810dbe0f8f0a13d1fa\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649773973 +0000\ncommitter GitHub <noreply@github.com> 1649773973 +0000\n\nMerge #1082\n\n1082: Add base for privacy visitor r=CohenArthur a=CohenArthur\n\nThis PR is extremely early and implements some building blocks for privacy visitors. I'd like to get some feedback on the architecture and, if satisfactory, merge this first \"visitor\" which only takes care of visiting HIR struct definitions, to make reviewing easier. We could also merge it to a different branch for now, in order to not add an incomplete pass to the compiler.\r\n\r\nThanks!\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7430791e0f71f1882a0f856c496071b76c61a6bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7430791e0f71f1882a0f856c496071b76c61a6bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7430791e0f71f1882a0f856c496071b76c61a6bc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2076e69bf92fae8efb0ee11a205a69ad8b4854a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2076e69bf92fae8efb0ee11a205a69ad8b4854a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2076e69bf92fae8efb0ee11a205a69ad8b4854a8"}, {"sha": "1e5126022d8db1adaa925a810dbe0f8f0a13d1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e5126022d8db1adaa925a810dbe0f8f0a13d1fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e5126022d8db1adaa925a810dbe0f8f0a13d1fa"}], "stats": {"total": 600, "additions": 591, "deletions": 9}, "files": [{"sha": "840a2452f96d3fdc2aa1a4f27aa70a5e950ef25e", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -89,6 +89,9 @@ GRS_OBJS = \\\n     rust/rust-ast-resolve-expr.o \\\n     rust/rust-ast-resolve-type.o \\\n     rust/rust-hir-type-check.o \\\n+    rust/rust-privacy-check.o \\\n+    rust/rust-privacy-ctx.o \\\n+    rust/rust-reachability.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n     rust/rust-tyty-bounds.o \\\n@@ -278,6 +281,7 @@ RUST_INCLUDES = -I $(srcdir)/rust \\\n \t-I $(srcdir)/rust/resolve \\\n \t-I $(srcdir)/rust/util \\\n \t-I $(srcdir)/rust/typecheck \\\n+\t-I $(srcdir)/rust/privacy \\\n \t-I $(srcdir)/rust/lint\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n@@ -339,6 +343,11 @@ rust/%.o: rust/typecheck/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n+# build rust/privacy files in rust folder\n+rust/%.o: rust/privacy/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n # build rust/lint files in rust folder\n rust/%.o: rust/lint/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<"}, {"sha": "bc26725ff0b1d71a641e8370ec2d01adef3723a0", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -576,6 +576,9 @@ struct Visibility\n   // Returns whether visibility is in an error state.\n   bool is_error () const { return vis_type == ERROR; }\n \n+  // Does the current visibility refer to a simple `pub <item>` entirely public\n+  bool is_public () const { return vis_type == PUBLIC; }\n+\n   // Creates an error visibility.\n   static Visibility create_error ()\n   {\n@@ -621,6 +624,8 @@ class VisItem : public Item\n public:\n   using HIR::Stmt::accept_vis;\n \n+  BaseKind get_hir_kind () override final { return VIS_ITEM; }\n+\n   /* Does the item have some kind of public visibility (non-default\n    * visibility)? */\n   bool has_visibility () const { return !visibility.is_error (); }\n@@ -1458,6 +1463,8 @@ struct StructField\n   Analysis::NodeMapping get_mappings () const { return mappings; }\n \n   Location get_locus () { return locus; }\n+\n+  Visibility &get_visibility () { return visibility; }\n };\n \n // Rust struct declaration with true struct type HIR node\n@@ -2744,7 +2751,7 @@ class ImplBlock : public VisItem\n };\n \n // Abstract base class for an item used inside an extern block\n-class ExternalItem\n+class ExternalItem : public Node\n {\n   Analysis::NodeMapping mappings;\n   AST::AttrVec outer_attrs;\n@@ -2755,6 +2762,8 @@ class ExternalItem\n public:\n   virtual ~ExternalItem () {}\n \n+  BaseKind get_hir_kind () override final { return EXTERNAL; }\n+\n   // Returns whether item has outer attributes.\n   bool has_outer_attrs () const { return !outer_attrs.empty (); }\n "}, {"sha": "67cfb3ae423336bc642b5664b985477b51aaaad2", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -45,6 +45,41 @@ class HIRTypeVisitor;\n // forward decl for use in token tree method\n class Token;\n \n+class Node\n+{\n+public:\n+  // Kind for downcasting various HIR nodes to other base classes when visiting\n+  // them\n+  enum BaseKind\n+  {\n+    /* class ExternalItem */\n+    EXTERNAL,\n+    /* class TraitItem */\n+    TRAIT_ITEM,\n+    /* class VisItem */\n+    VIS_ITEM,\n+    /* class Item */\n+    ITEM,\n+    /* class ImplItem */\n+    IMPL,\n+    /* class Type */\n+    TYPE,\n+    /* class Stmt */\n+    STMT,\n+    /* class Expr */\n+    EXPR,\n+    /* class Pattern */\n+    PATTERN,\n+  };\n+\n+  /**\n+   * Get the kind of HIR node we are dealing with. This is useful for\n+   * downcasting to more precise types when necessary, i.e going from an `Item*`\n+   * to a `VisItem*`\n+   */\n+  virtual BaseKind get_hir_kind () = 0;\n+};\n+\n // A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n struct Literal\n {\n@@ -91,7 +126,7 @@ struct Literal\n \n /* Base statement abstract class. Note that most \"statements\" are not allowed in\n  * top-level module scope - only a subclass of statements called \"items\" are. */\n-class Stmt\n+class Stmt : public Node\n {\n public:\n   // Unique pointer custom clone function\n@@ -100,6 +135,8 @@ class Stmt\n     return std::unique_ptr<Stmt> (clone_stmt_impl ());\n   }\n \n+  BaseKind get_hir_kind () override { return STMT; }\n+\n   virtual ~Stmt () {}\n \n   virtual std::string as_string () const = 0;\n@@ -138,6 +175,8 @@ class Item : public Stmt\n     return std::unique_ptr<Item> (clone_item_impl ());\n   }\n \n+  BaseKind get_hir_kind () override { return ITEM; }\n+\n   std::string as_string () const override;\n \n   /* Adds crate names to the vector passed by reference, if it can\n@@ -171,7 +210,7 @@ class Item : public Stmt\n class ExprWithoutBlock;\n \n // Base expression HIR node - abstract\n-class Expr\n+class Expr : public Node\n {\n   AST::AttrVec outer_attrs;\n   Analysis::NodeMapping mappings;\n@@ -213,6 +252,8 @@ class Expr\n     Path,\n   };\n \n+  BaseKind get_hir_kind () override final { return EXPR; }\n+\n   const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n \n   // Unique pointer custom clone function\n@@ -358,7 +399,7 @@ class IdentifierExpr : public ExprWithoutBlock\n };\n \n // Pattern base HIR node\n-class Pattern\n+class Pattern : public Node\n {\n public:\n   enum PatternType\n@@ -376,6 +417,8 @@ class Pattern\n     SLICE,\n   };\n \n+  BaseKind get_hir_kind () override final { return PATTERN; }\n+\n   // Unique pointer custom clone function\n   std::unique_ptr<Pattern> clone_pattern () const\n   {\n@@ -406,7 +449,7 @@ class Pattern\n class TraitBound;\n \n // Base class for types as represented in HIR - abstract\n-class Type\n+class Type : public Node\n {\n public:\n   // Unique pointer custom clone function\n@@ -418,6 +461,8 @@ class Type\n   // virtual destructor\n   virtual ~Type () {}\n \n+  BaseKind get_hir_kind () override final { return TYPE; }\n+\n   virtual std::string as_string () const = 0;\n \n   /* HACK: convert to trait bound. Virtual method overriden by classes that\n@@ -686,7 +731,7 @@ class LifetimeParam : public GenericParam\n };\n \n // Item used in trait declarations - abstract base class\n-class TraitItem\n+class TraitItem : public Node\n {\n public:\n   enum TraitItemKind\n@@ -696,6 +741,8 @@ class TraitItem\n     TYPE\n   };\n \n+  BaseKind get_hir_kind () override final { return TRAIT_ITEM; }\n+\n protected:\n   // Constructor\n   TraitItem (Analysis::NodeMapping mappings) : mappings (mappings) {}\n@@ -728,7 +775,7 @@ class TraitItem\n   virtual const AST::AttrVec &get_outer_attrs () const = 0;\n };\n \n-class ImplItem\n+class ImplItem : public Node\n {\n public:\n   enum ImplItemType\n@@ -740,6 +787,8 @@ class ImplItem\n \n   virtual ~ImplItem () {}\n \n+  BaseKind get_hir_kind () override final { return IMPL; }\n+\n   // Unique pointer custom clone function\n   std::unique_ptr<ImplItem> clone_inherent_impl_item () const\n   {"}, {"sha": "ccef318ed1154230357a545b168009d36d1e708e", "filename": "gcc/rust/privacy/rust-privacy-check.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-privacy-check.h\"\n+#include \"rust-reachability.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+extern bool\n+saw_errors (void);\n+\n+namespace Rust {\n+namespace Privacy {\n+void\n+Resolver::resolve (HIR::Crate &crate)\n+{\n+  PrivacyContext ctx;\n+  auto ty_ctx = ::Rust::Resolver::TypeCheckContext::get ();\n+  auto visitor = ReachabilityVisitor (ctx, *ty_ctx);\n+\n+  const auto &items = crate.items;\n+  for (auto &item : items)\n+    {\n+      if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n+\t{\n+\t  auto vis_item = static_cast<HIR::VisItem *> (item.get ());\n+\t  vis_item->accept_vis (visitor);\n+\t}\n+    }\n+\n+  if (saw_errors ())\n+    return;\n+}\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "47fe7dfcf48f8866a47beb4a00703586022ca44b", "filename": "gcc/rust/privacy/rust-privacy-check.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-check.h?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -0,0 +1,45 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PRIVACY_CHECK_H\n+#define RUST_PRIVACY_CHECK_H\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+class Resolver\n+{\n+public:\n+  /**\n+   * Perform the full privacy resolving pass on a crate.\n+   *\n+   * This resolver first computes the reachability of all items in a crate,\n+   * before checking for privacy violations.\n+   */\n+  static void resolve (HIR::Crate &crate);\n+};\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_PRIVACY_CHECK_H"}, {"sha": "9ebc86988e9fa4b29560dd9a90d94afa8f17501d", "filename": "gcc/rust/privacy/rust-privacy-ctx.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-ctx.cc?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-privacy-ctx.h\"\n+#include \"selftest.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+static ReachLevel\n+insert_if_higher (ReachLevel new_level,\n+\t\t  std::unordered_map<DefId, ReachLevel>::iterator &existing)\n+{\n+  if (new_level > existing->second)\n+    existing->second = new_level;\n+\n+  return existing->second;\n+}\n+\n+ReachLevel\n+PrivacyContext::update_reachability (const Analysis::NodeMapping &mapping,\n+\t\t\t\t     ReachLevel reach)\n+{\n+  auto def_id = mapping.get_defid ();\n+  auto existing_reach = reachability_map.find (def_id);\n+  if (existing_reach != reachability_map.end ())\n+    return insert_if_higher (reach, existing_reach);\n+\n+  reachability_map.insert ({def_id, reach});\n+  return reach;\n+}\n+\n+const ReachLevel *\n+PrivacyContext::lookup_reachability (const Analysis::NodeMapping &mapping)\n+{\n+  auto existing_reach = reachability_map.find (mapping.get_defid ());\n+  if (existing_reach == reachability_map.end ())\n+    return nullptr;\n+\n+  return &existing_reach->second;\n+}\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#if CHECKING_P\n+namespace selftest {\n+static void\n+update_reachability_test (void)\n+{\n+  auto ctx = Rust::Privacy::PrivacyContext ();\n+  // Bogus values for the mappings\n+  auto mapping = Rust::Analysis::NodeMapping (15, 15, 15, 15);\n+\n+  auto new_level\n+    = ctx.update_reachability (mapping, Rust::Privacy::ReachLevel::Unreachable);\n+\n+  ASSERT_EQ (new_level, Rust::Privacy::ReachLevel::Unreachable);\n+\n+  ASSERT_TRUE (ctx.lookup_reachability (mapping));\n+  ASSERT_EQ (*ctx.lookup_reachability (mapping),\n+\t     Rust::Privacy::ReachLevel::Unreachable);\n+\n+  new_level\n+    = ctx.update_reachability (mapping, Rust::Privacy::ReachLevel::Reachable);\n+\n+  ASSERT_EQ (new_level, Rust::Privacy::ReachLevel::Reachable);\n+  ASSERT_TRUE (ctx.lookup_reachability (mapping));\n+  ASSERT_EQ (*ctx.lookup_reachability (mapping),\n+\t     Rust::Privacy::ReachLevel::Reachable);\n+}\n+\n+void\n+rust_privacy_ctx_test (void)\n+{\n+  update_reachability_test ();\n+}\n+} // namespace selftest\n+#endif // !CHECKING_P"}, {"sha": "52d790edf63fd11fc693b3b98061f8bdc0242151", "filename": "gcc/rust/privacy/rust-privacy-ctx.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-privacy-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-ctx.h?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PRIVACY_CTX_H\n+#define RUST_PRIVACY_CTX_H\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-privacy-check.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+/**\n+ * Reachability levels of HIR nodes. These levels are computed through the\n+ * `ReachabilityVisitor` visitor.\n+ */\n+enum ReachLevel\n+{\n+  Unreachable,\n+  Reachable,\n+};\n+\n+class PrivacyContext\n+{\n+public:\n+  /**\n+   * Insert a new resolved visibility for a given node. If the node is already\n+   * present in the reachability map, then its visibility will only be updated\n+   * if the given visibility is higher.\n+   *\n+   * @param mappings Mappings of the node to store the reach level for\n+   * @param reach Level of reachability for the given node\n+   *\n+   * @return The new reachability level for this node. If this was the first\n+   * time inserting this node, then return `reach`. Otherwise, return `reach` or\n+   * the existing reach level if it was higher.\n+   */\n+  ReachLevel update_reachability (const Analysis::NodeMapping &mapping,\n+\t\t\t\t  ReachLevel reach);\n+\n+  /**\n+   * Lookup the visibility of an already declared Node\n+   *\n+   * @param mapping Mappings of the node to fetch the reach level of\n+   *\n+   * @return `nullptr` if the reach level for the current node has not been\n+   * added, a valid pointer otherwise\n+   */\n+  const ReachLevel *lookup_reachability (const Analysis::NodeMapping &mapping);\n+\n+private:\n+  std::unordered_map<DefId, ReachLevel> reachability_map;\n+};\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#if CHECKING_P\n+namespace selftest {\n+void\n+rust_privacy_ctx_test (void);\n+}\n+#endif // !CHECKING_P\n+\n+#endif // !RUST_PRIVACY_CTX_H"}, {"sha": "82a48271177a8c45698298bd60eec8dc06c06389", "filename": "gcc/rust/privacy/rust-reachability.cc", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-reachability.cc?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -0,0 +1,157 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-reachability.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+static HIR::VisItem *\n+maybe_get_vis_item (std::unique_ptr<HIR::Item> &item)\n+{\n+  if (item->get_hir_kind () != HIR::Node::VIS_ITEM)\n+    return nullptr;\n+\n+  return static_cast<HIR::VisItem *> (item.get ());\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Module &mod)\n+{\n+  for (auto &item : mod.get_items ())\n+    {\n+      // FIXME: Is that what we want to do? Yes? Only visit the items with\n+      // visibility?\n+      //\n+      // Imagine if we had `maybe_get_vis_item(item)?->accept_vis(*this)` ;)\n+      auto vis_item = maybe_get_vis_item (item);\n+      if (vis_item)\n+\tvis_item->accept_vis (*this);\n+    }\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ExternCrate &crate)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::UseDeclaration &use_decl)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Function &func)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::TypeAlias &type_alias)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::StructStruct &struct_item)\n+{\n+  auto struct_reach = ReachLevel::Unreachable;\n+  if (struct_item.get_visibility ().is_public ())\n+    struct_reach = current_level;\n+\n+  struct_reach\n+    = ctx.update_reachability (struct_item.get_mappings (), struct_reach);\n+\n+  auto old_level = current_level;\n+  current_level = struct_reach;\n+\n+  if (struct_reach != ReachLevel::Unreachable)\n+    {\n+      for (auto &field : struct_item.get_fields ())\n+\tif (field.get_visibility ().is_public ())\n+\t  ctx.update_reachability (field.get_mappings (), struct_reach);\n+\n+      for (auto &generic : struct_item.get_generic_params ())\n+\t{\n+\t  switch (generic->get_kind ())\n+\t    {\n+\t    case HIR::GenericParam::LIFETIME:\n+\t      break;\n+\t    case HIR::GenericParam::TYPE:\n+\t      TyTy::BaseType *generic_ty = nullptr;\n+\t      rust_assert (\n+\t\tty_ctx.lookup_type (generic->get_mappings ().get_hirid (),\n+\t\t\t\t    &generic_ty));\n+\n+\t      if (generic_ty->get_kind () == TyTy::PARAM)\n+\t\t{\n+\t\t  auto generic_param\n+\t\t    = static_cast<TyTy::ParamType *> (generic_ty);\n+\t\t  for (const auto &bound :\n+\t\t       generic_param->get_specified_bounds ())\n+\t\t    {\n+\t\t      const auto trait = bound.get ()->get_hir_trait_ref ();\n+\t\t      ctx.update_reachability (trait->get_mappings (),\n+\t\t\t\t\t       struct_reach);\n+\t\t    }\n+\t\t}\n+\n+\t      break;\n+\t    }\n+\t}\n+\n+      for (auto &field : struct_item.get_fields ())\n+\tif (field.get_visibility ().is_public ())\n+\t  ctx.update_reachability (field.get_field_type ()->get_mappings (),\n+\t\t\t\t   struct_reach);\n+    }\n+\n+  current_level = old_level;\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::TupleStruct &tuple_struct)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Enum &enum_item)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Union &union_item)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ConstantItem &const_item)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::StaticItem &static_item)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Trait &trait)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ImplBlock &impl)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ExternBlock &block)\n+{}\n+\n+// FIXME: How can we visit Blocks in the current configuration? Have a full\n+// visitor?\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "75ed2699df661cfdc8c60346006c45312579d230", "filename": "gcc/rust/privacy/rust-reachability.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-reachability.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Fprivacy%2Frust-reachability.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-reachability.h?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_REACHABILITY_H\n+#define RUST_REACHABILITY_H\n+\n+#include \"rust-privacy-ctx.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+// FIXME: The EmbargoVisitor from rustc is a fixed-point visitor which tries\n+// to reach more and more nodes until nothing has changed anymore.\n+// Do we need to reproduce this behavior? How long does it take to do this?\n+\n+/**\n+ * The ReachabilityVisitor tries to reach all items possible in the crate,\n+ * according to their privacy level.\n+ */\n+class ReachabilityVisitor : public HIR::HIRVisItemVisitor\n+{\n+public:\n+  ReachabilityVisitor (PrivacyContext &ctx,\n+\t\t       const ::Rust::Resolver::TypeCheckContext &ty_ctx)\n+    : current_level (ReachLevel::Reachable), ctx (ctx), ty_ctx (ty_ctx)\n+  {}\n+\n+  virtual void visit (HIR::Module &mod);\n+  virtual void visit (HIR::ExternCrate &crate);\n+  virtual void visit (HIR::UseDeclaration &use_decl);\n+  virtual void visit (HIR::Function &func);\n+  virtual void visit (HIR::TypeAlias &type_alias);\n+  virtual void visit (HIR::StructStruct &struct_item);\n+  virtual void visit (HIR::TupleStruct &tuple_struct);\n+  virtual void visit (HIR::Enum &enum_item);\n+  virtual void visit (HIR::Union &union_item);\n+  virtual void visit (HIR::ConstantItem &const_item);\n+  virtual void visit (HIR::StaticItem &static_item);\n+  virtual void visit (HIR::Trait &trait);\n+  virtual void visit (HIR::ImplBlock &impl);\n+  virtual void visit (HIR::ExternBlock &block);\n+\n+private:\n+  ReachLevel current_level;\n+  PrivacyContext &ctx;\n+  const ::Rust::Resolver::TypeCheckContext &ty_ctx;\n+};\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_REACHABILITY_H"}, {"sha": "c7469412392460682af6eedc86d7e711d5a86055", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -32,8 +32,10 @@\n #include \"convert.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n+\n #include \"selftest.h\"\n #include \"rust-cfg-parser.h\"\n+#include \"rust-privacy-ctx.h\"\n \n #include <mpfr.h>\n // note: header files must be in this order or else forward declarations don't\n@@ -455,6 +457,7 @@ run_rust_tests ()\n   // Call tests for the rust frontend here\n   simple_assert ();\n   rust_cfg_parser_test ();\n+  rust_privacy_ctx_test ();\n }\n } // namespace selftest\n "}, {"sha": "ec99be7be9000d6205ec21905cd2b3f9eff8e72b", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-ast-resolve.h\"\n #include \"rust-ast-lower.h\"\n #include \"rust-hir-type-check.h\"\n+#include \"rust-privacy-check.h\"\n #include \"rust-tycheck-dump.h\"\n #include \"rust-compile.h\"\n #include \"rust-cfg-parser.h\"\n@@ -609,6 +610,9 @@ Session::parse_file (const char *filename)\n   if (saw_errors ())\n     return;\n \n+  // privacy pass\n+  Privacy::Resolver::resolve (hir);\n+\n   // do compile to gcc generic\n   Compile::Context ctx (backend);\n   Compile::CompileCrate::Compile (hir, &ctx);"}, {"sha": "e63f8ad4b038b7eaa6bfd9a179aa49dd56760c09", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -104,7 +104,7 @@ class TypeCheckContext\n   void insert_type (const Analysis::NodeMapping &mappings,\n \t\t    TyTy::BaseType *type);\n   void insert_implicit_type (TyTy::BaseType *type);\n-  bool lookup_type (HirId id, TyTy::BaseType **type);\n+  bool lookup_type (HirId id, TyTy::BaseType **type) const;\n \n   void insert_implicit_type (HirId id, TyTy::BaseType *type);\n "}, {"sha": "d8a49e8b9ea0569e6cbf06af5507dd6ae75f3334", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -98,7 +98,7 @@ TypeCheckContext::insert_implicit_type (HirId id, TyTy::BaseType *type)\n }\n \n bool\n-TypeCheckContext::lookup_type (HirId id, TyTy::BaseType **type)\n+TypeCheckContext::lookup_type (HirId id, TyTy::BaseType **type) const\n {\n   auto it = resolved.find (id);\n   if (it == resolved.end ())"}, {"sha": "c440ae98931f90bff69a22664ece5e074bfaeef3", "filename": "gcc/rust/util/rust-mapping-common.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Futil%2Frust-mapping-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7430791e0f71f1882a0f856c496071b76c61a6bc/gcc%2Frust%2Futil%2Frust-mapping-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-mapping-common.h?ref=7430791e0f71f1882a0f856c496071b76c61a6bc", "patch": "@@ -69,4 +69,17 @@ struct DefId\n \n } // namespace Rust\n \n+namespace std {\n+template <> struct hash<Rust::DefId>\n+{\n+  size_t operator() (const Rust::DefId &id) const noexcept\n+  {\n+    // TODO: Check if we can improve performance by having a better hash\n+    // algorithm for `DefId`s\n+    return hash<uint32_t> () (hash<uint32_t> () (id.crateNum)\n+\t\t\t      + hash<uint32_t> () (id.localDefId));\n+  }\n+};\n+} // namespace std\n+\n #endif // RUST_MAPPING_COMMON"}]}