{"sha": "9dfb66b9fe85b353f0efed3a98745f6c686511c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRmYjY2YjlmZTg1YjM1M2YwZWZlZDNhOTg3NDVmNmM2ODY1MTFjMQ==", "commit": {"author": {"name": "Carlos O'Donell", "email": "carlos@codesourcery.com", "date": "2006-04-20T00:21:51Z"}, "committer": {"name": "Carlos O'Donell", "email": "carlos@gcc.gnu.org", "date": "2006-04-20T00:21:51Z"}, "message": "re PR c/26774 (Out of memory compiling 9-line Delta-reduced Linux kernel driver msp3400.c)\n\ngcc/\n\n2006-04-19  Carlos O'Donell  <carlos@codesourcery.com>\n\t    Nathan Sidwell  <nathan@codesourcery.com>\n\n\tPR c/26774\n\t* stor-layout.c (update_alignment_for_field): Do not align \n\tERROR_MARK nodes.\n\t(place_union_field): Place union field at the start of the union.\n\t(place_field): Move ERROR_MARK check later, and use the current\n\tallocation position to maintain monotonicity.\n\ngcc/testsuite/\n\n2006-04-19  Carlos O'Donell  <carlos@codesourcery.com>\n\n\tPR c/26774\n\t* gcc.dg/struct-parse-1.c: New test case.\n\n\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com>\n\nFrom-SVN: r113107", "tree": {"sha": "2915a6e02f9f6c44b4b02c47404a627e46d27ab4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2915a6e02f9f6c44b4b02c47404a627e46d27ab4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dfb66b9fe85b353f0efed3a98745f6c686511c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfb66b9fe85b353f0efed3a98745f6c686511c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dfb66b9fe85b353f0efed3a98745f6c686511c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfb66b9fe85b353f0efed3a98745f6c686511c1/comments", "author": null, "committer": null, "parents": [{"sha": "4fc1015b1dc9007e5ebf68794e0212daee5449b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc1015b1dc9007e5ebf68794e0212daee5449b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc1015b1dc9007e5ebf68794e0212daee5449b5"}], "stats": {"total": 57, "additions": 46, "deletions": 11}, "files": [{"sha": "402493335f63267fdd408135b687de2842e2d431", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dfb66b9fe85b353f0efed3a98745f6c686511c1", "patch": "@@ -1,3 +1,13 @@\n+2006-04-19  Carlos O'Donell  <carlos@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c/26774\n+\t* stor-layout.c (update_alignment_for_field): Do not align \n+\tERROR_MARK nodes.\n+\t(place_union_field): Place union field at the start of the union.\n+\t(place_field): Move ERROR_MARK check later, and use the current\n+\tallocation position to maintain monotonicity.\n+\n 2006-04-19  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* dominance.c: Include timevar.h."}, {"sha": "b95e07594129e09ccd4e14bac74b0699d2836e4b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9dfb66b9fe85b353f0efed3a98745f6c686511c1", "patch": "@@ -663,6 +663,10 @@ update_alignment_for_field (record_layout_info rli, tree field,\n   bool user_align;\n   bool is_bitfield;\n \n+  /* Do not attempt to align an ERROR_MARK node */\n+  if (TREE_CODE (type) == ERROR_MARK)\n+    return 0;\n+\n   /* Lay out the field so we know what alignment it needs.  */\n   layout_decl (field, known_align);\n   desired_align = DECL_ALIGN (field);\n@@ -775,6 +779,12 @@ place_union_field (record_layout_info rli, tree field)\n   DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n   SET_DECL_OFFSET_ALIGN (field, BIGGEST_ALIGNMENT);\n \n+  /* If this is an ERROR_MARK return *after* having set the \n+     field at the start of the union. This helps when parsing\n+     invalid fields. */\n+  if (TREE_CODE (TREE_TYPE (field)) == ERROR_MARK)\n+    return;\n+\n   /* We assume the union's size will be a multiple of a byte so we don't\n      bother with BITPOS.  */\n   if (TREE_CODE (rli->t) == UNION_TYPE)\n@@ -823,17 +833,6 @@ place_field (record_layout_info rli, tree field)\n \n   gcc_assert (TREE_CODE (field) != ERROR_MARK);\n \n-  if (TREE_CODE (type) == ERROR_MARK)\n-    {\n-      if (TREE_CODE (field) == FIELD_DECL)\n-\t{\n-\t  DECL_FIELD_OFFSET (field) = size_int (0);\n-\t  DECL_FIELD_BIT_OFFSET (field) = bitsize_int (0);\n-\t}\n-      \n-      return;\n-    }\n-  \n   /* If FIELD is static, then treat it like a separate variable, not\n      really like a structure field.  If it is a FUNCTION_DECL, it's a\n      method.  In both cases, all we do is lay out the decl, and we do\n@@ -858,6 +857,16 @@ place_field (record_layout_info rli, tree field)\n       return;\n     }\n \n+  else if (TREE_CODE (type) == ERROR_MARK) \n+    {\n+      /* Place this field at the current allocation position, so we\n+\t maintain monotonicity.  */\n+      DECL_FIELD_OFFSET (field) = rli->offset;\n+      DECL_FIELD_BIT_OFFSET (field) = rli->bitpos;\n+      SET_DECL_OFFSET_ALIGN (field, rli->offset_align);\n+      return;\n+    }\n+\n   /* Work out the known alignment so far.  Note that A & (-A) is the\n      value of the least-significant bit in A that is one.  */\n   if (! integer_zerop (rli->bitpos))"}, {"sha": "b6772a0e205b5992b1324d55bb7ee0964173c034", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9dfb66b9fe85b353f0efed3a98745f6c686511c1", "patch": "@@ -1,3 +1,8 @@\n+2006-04-19  Carlos O'Donell  <carlos@codesourcery.com>\n+\n+\tPR c/26774\n+\t* gcc.dg/struct-parse-1.c: New test case.\n+\n 2006-04-19  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/26558"}, {"sha": "32c115797fdb1318733168451d27dd863b1567e4", "filename": "gcc/testsuite/gcc.dg/struct-parse-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct-parse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfb66b9fe85b353f0efed3a98745f6c686511c1/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct-parse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct-parse-1.c?ref=9dfb66b9fe85b353f0efed3a98745f6c686511c1", "patch": "@@ -0,0 +1,11 @@\n+/* Copyright (C) 2006 Free Software Foundation, Inc. */\n+/* Contributed by Carlos O'Donell on 2006-03-31 */\n+\n+/* This code caused the C frontend to loop \n+   forever exhausting all system memory, or ICE */\n+/* Origin: Carlos O'Donell <carlos@codesourcery.com> */\n+\n+/* { dg-options \"-std=c99\" } */\n+struct s { int a; int b; struct t c; }; /* { dg-error \"error: field 'c' has incomplete type\" } */\n+struct s d = { .b = 0 };\n+"}]}